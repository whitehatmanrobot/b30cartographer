rgs files change
nmctl1.rc:  CompWnd.rgs NMChatCtl.rgs ContainerControl.rgs NmApp.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\marshalableti.h ===
// MarshalableTI.h : Declaration of the CMarshalableTI

#ifndef __MARSHALABLETI_H_
#define __MARSHALABLETI_H_

#include "MarshalableTI.h"
#include "mslablti.h"
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMarshalableTI
class ATL_NO_VTABLE CMarshalableTI : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMarshalableTI, &CLSID_MarshalableTI>,
	public IMarshalableTI,
	public IMarshal,
	public ITypeInfo
{
private:
	CComTypeInfoHolder	m_TIHolder;
	GUID				m_guid;
	GUID				m_libid;
	LCID				m_lcid;
	bool				m_bCreated;

public:
	

DECLARE_REGISTRY_RESOURCEID(IDR_MSLABLTI)
DECLARE_NOT_AGGREGATABLE(CMarshalableTI)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMarshalableTI)
	COM_INTERFACE_ENTRY(IMarshalableTI)
	COM_INTERFACE_ENTRY(IMarshal)
	COM_INTERFACE_ENTRY(ITypeInfo)
END_COM_MAP()

	HRESULT FinalConstruct();

/////////////////////////////////////////////////////////////////////////////////
// IMarshalableTI methods

	STDMETHOD(Create)(/*[in]*/ REFIID clsid, 
					  /*[in]*/ REFIID iidLib, 
					  /*[in]*/ LCID lcid,
					  /*[in]*/ WORD dwMajorVer, 
					  /*[in]*/ WORD dwMinorVer);

/////////////////////////////////////////////////////////////////////////////////
// IMarshal methods

    STDMETHOD(GetUnmarshalClass)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID *pCid);

    STDMETHOD(GetMarshalSizeMax)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize);

    STDMETHOD(MarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags);

    STDMETHOD(UnmarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);

    STDMETHOD(ReleaseMarshalData)(
            /* [unique][in] */ IStream *pStm);

    STDMETHOD(DisconnectObject)(
            /* [in] */ DWORD dwReserved);

/////////////////////////////////////////////////////////////////////////////////
// ITypeInfo methods

    STDMETHOD(GetTypeAttr)(
                TYPEATTR ** ppTypeAttr);

    STDMETHOD(GetTypeComp)(
                ITypeComp ** ppTComp);

    STDMETHOD(GetFuncDesc)(
                UINT index,
                FUNCDESC ** ppFuncDesc);

    STDMETHOD(GetVarDesc)(
                UINT index,
                VARDESC ** ppVarDesc);

    STDMETHOD(GetNames)(
                MEMBERID memid,
                BSTR * rgBstrNames,
                UINT cMaxNames,
                UINT * pcNames);


    STDMETHOD(GetRefTypeOfImplType)(
                UINT index,
                HREFTYPE * pRefType);

    STDMETHOD(GetImplTypeFlags)(
                UINT index,
                INT * pImplTypeFlags);


    STDMETHOD(GetIDsOfNames)(
                LPOLESTR * rgszNames,
                UINT cNames,
                MEMBERID * pMemId);

    STDMETHOD(Invoke)(
                PVOID pvInstance,
                MEMBERID memid,
                WORD wFlags,
                DISPPARAMS * pDispParams,
                VARIANT * pVarResult,
                EXCEPINFO * pExcepInfo,
                UINT * puArgErr);

    STDMETHOD(GetDocumentation)(
                MEMBERID memid,
                BSTR * pBstrName,
                BSTR * pBstrDocString,
                DWORD * pdwHelpContext,
                BSTR * pBstrHelpFile);


    STDMETHOD(GetDllEntry)(
                MEMBERID memid,
                INVOKEKIND invKind,
                BSTR * pBstrDllName,
                BSTR * pBstrName,
                WORD * pwOrdinal);


    STDMETHOD(GetRefTypeInfo)(
                HREFTYPE hRefType,
                ITypeInfo ** ppTInfo);


    STDMETHOD(AddressOfMember)(
                MEMBERID memid,
                INVOKEKIND invKind,
                PVOID * ppv);

    STDMETHOD(CreateInstance)(
                IUnknown * pUnkOuter,
                REFIID riid,
                PVOID * ppvObj);


    STDMETHOD(GetMops)(
                MEMBERID memid,
                BSTR * pBstrMops);


    STDMETHOD(GetContainingTypeLib)(
                ITypeLib ** ppTLib,
                UINT * pIndex);

    STDMETHOD_(void, ReleaseTypeAttr)(
                TYPEATTR * pTypeAttr);

    STDMETHOD_(void, ReleaseFuncDesc)(
                FUNCDESC * pFuncDesc);

    STDMETHOD_(void, ReleaseVarDesc)(
                VARDESC * pVarDesc);


private:
	HRESULT _GetClassInfo(ITypeInfo** ppTI);
};

#endif //__MARSHALABLETI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\iconindices.h ===
#ifndef __IconIndices_h__
#define __IconIndices_h__

#define II_Announcement                     0
#define II_Decision                         1
#define II_ForDiscussion                    2
#define II_Presentation                     3
#define II_Action                           4
#define II_DocLink                          5
#define II_Minutes                          6
#define II_ScriptableAction                 7
#define II_ChatScript                       8
#define II_WhiteboardScript                 9
#define II_Call                            10
#define II_HangUpwStop                     11
#define II_Refresh                         12
#define II_Delete                          13
#define II_SendMail                        14
#define II_Chat                            15
#define II_NewChatMessage                  16
#define II_Whiteboard                      17
#define II_WhiteboardNewActivity           18
#define II_AgendaApplet                    19
#define II_Roster                          20
#define II_RosterSomeoneJoined             21
#define II_RosterSomeoneLeft               22
#define II_OutgoingVideo                   23
#define II_OutgoingVideoNotSending         24
#define II_IncommingVideo                  25
#define II_IncommingVideoReceiving         26
#define II_IncommingVideoNotReceiving      27
#define II_Dot                             30

#endif // __IconIndices_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\message.cpp ===
#include "precomp.h"
#include "Message.h"

CChatMessage *CChatMessage::ms_pFirst = NULL;
int          CChatMessage::ms_cMessages = 0;
CChatMessage *CChatMessage::ms_pLast = NULL;
int			 CChatMessage::ms_iMessageLimit = INITIAL_LIMIT;

CChatMessage *CChatMessage::get_head()
{
	return ms_pFirst;
}


int CChatMessage::get_count()
{
	return ms_cMessages;
}


CChatMessage *CChatMessage::get_last()
{
	return ms_pLast;
}

void CChatMessage::put_limit( int iLimit )
{
	ASSERT( iLimit >= 1 );

	ms_iMessageLimit = iLimit;

	while( ms_cMessages > ms_iMessageLimit )
	{
		CChatMessage *pKillMe = ms_pFirst;
		ms_pFirst = ms_pFirst->m_pNext;
		delete pKillMe;
	}
}

int CChatMessage::get_limit()
{
	return ms_iMessageLimit;
}

CChatMessage *CChatMessage::get_next() const
{
	return m_pNext;
}


CChatMessage *CChatMessage::get_prev() const
{
	return m_pPrev;
}


CChatMessage::CHAT_MSGTYPE CChatMessage::get_type() const
{
	return m_msgType;
}


const LPTSTR CChatMessage::get_date() const
{
	return m_szDate;
}


const LPTSTR CChatMessage::get_time() const
{
	return m_szTime;
}


const LPTSTR CChatMessage::get_person() const
{
	return m_szPerson;
}


const LPTSTR CChatMessage::get_message() const
{
	return m_szMessage;
}

CChatMessage::CChatMessage( LPCTSTR szPerson, LPCTSTR szMessage, CHAT_MSGTYPE msgType )
	: m_msgType( msgType ), m_szDate( NULL ), m_szTime( NULL ), 
	m_szPerson( NULL ), m_szMessage( NULL ), m_pNext( NULL ), m_pPrev( NULL )
{
	_GetDate();
	_GetTime();
	m_szPerson = _CopyString( szPerson );
	m_szMessage = _CopyString( szMessage );

	if( 0 == ms_cMessages )
	{
		ms_pFirst = this;
		ms_pLast = this;
	}
	else
	{
		ms_pLast->m_pNext = this;
		m_pPrev = ms_pLast;
		ms_pLast = this;
	}

	ms_cMessages++;

	while( ms_cMessages > ms_iMessageLimit )
	{
		CChatMessage *pKillMe = ms_pFirst;
		ms_pFirst = ms_pFirst->m_pNext;
		delete pKillMe;
	}
}


CChatMessage::~CChatMessage()
{
	delete [] m_szDate;
	delete [] m_szTime;
	delete [] m_szPerson;
	delete [] m_szMessage;

	ms_cMessages--;
}

void CChatMessage::DeleteAll()
{
	CChatMessage *pMsg = ms_pFirst;

	while( pMsg )
	{
		CChatMessage *pNext = pMsg->m_pNext;
		delete pMsg;
		pMsg = pNext;
	}

	ms_pFirst = NULL;
	ms_pLast = NULL;
	ms_cMessages = 0;
}

LPTSTR CChatMessage::_CopyString( LPCTSTR sz )
{
	LPTSTR szNew = NULL;
	if( NULL == sz )
	{
		DBG_SAVE_FILE_LINE
		szNew = new TCHAR[1];
		ASSERT( szNew );
		if( NULL == szNew )
		{
			return NULL;
		}
		szNew[0] = '\0';
	}
	else
	{
		int iLen = lstrlen( sz ) + 1;
		DBG_SAVE_FILE_LINE
		szNew = new TCHAR[ iLen ];
		ASSERT( szNew );
		if( NULL == szNew )
		{
			return NULL;
		}
		lstrcpyn( szNew, sz, iLen );
	}

	return szNew;
}


void CChatMessage::_GetDate()
{
	int iLen = 1 + GetDateFormat(
						LOCALE_USER_DEFAULT,       // locale for which date is to be formatted
						0,     // flags specifying function options
						NULL,                     // time to be formatted
						NULL,  // time format string
						NULL,  // buffer for storing formatted string
						0        // size, in bytes or characters, of the buffer
						);

	m_szDate = new TCHAR[ iLen ];
	ASSERT( m_szDate );
	if( 0 == (iLen = GetDateFormat(
				LOCALE_USER_DEFAULT,       // locale for which date is to be formatted
				0,     // flags specifying function options
				NULL,                     // time to be formatted
				NULL,  // time format string
				m_szDate,  // buffer for storing formatted string
				iLen   // size, in bytes or characters, of the buffer
				) ) )
	{
		DWORD dw = GetLastError();
		WARNING_OUT(( TEXT("CChatMessage::_GetDate: Can not get date") ));
	}
	else
	{
		m_szDate[ iLen ] = '\0';
	}
}


void CChatMessage::_GetTime(void)
{
	int iLen = 1 + GetTimeFormat(
						LOCALE_USER_DEFAULT,       // locale for which time is to be formatted
						0,     // flags specifying function options
						NULL,                     // time to be formatted
						NULL,  // time format string
						NULL,  // buffer for storing formatted string
						0        // size, in bytes or characters, of the buffer
						);

	m_szTime = new TCHAR[ iLen ];
	ASSERT( m_szTime );
	if( 0 == (iLen = GetTimeFormat(
				LOCALE_USER_DEFAULT,       // locale for which time is to be formatted
				0,     // flags specifying function options
				NULL,                     // time to be formatted
				NULL,  // time format string
				m_szTime,  // buffer for storing formatted string
				iLen   // size, in bytes or characters, of the buffer
				) ) )
	{
		DWORD dw = GetLastError();
		WARNING_OUT(( TEXT("CChatMessage::_GetTime: Can not get time") ));
	}
	else
	{
		m_szTime[ iLen ] = '\0';
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\ms_util.cpp ===
#include "precomp.h"


CRefCount::CRefCount(DWORD dwStampID)
:
#ifndef SHIP_BUILD
    m_dwStampID(dwStampID),
#endif
    m_cRefs(1)
{
}


// though it is pure virtual, we still need to have a destructor.
CRefCount::~CRefCount(void)
{
}


LONG CRefCount::AddRef(void)
{
    ASSERT(0 < m_cRefs);
    ::InterlockedIncrement(&m_cRefs);
    return m_cRefs;
}


LONG CRefCount::Release(void)
{
    ASSERT(NULL != this);
    ASSERT(0 < m_cRefs);
    if (0 == ::InterlockedDecrement(&m_cRefs))
    {
        delete this;
        return 0;
    }
    return m_cRefs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\ms_util.h ===
#ifndef __MS_UTIL_H__
#define __MS_UTIL_H__

//
// GUI message boxes kill us when we hit an assert or error, because they
// have a message pump that causes messages to get dispatched, making it
// very difficult for us to debug problems when they occur.  Therefore
// we redefine ERROR_OUT and ASSERT
//
#ifdef _DEBUG

__inline void MyDebugBreak(void) { DebugBreak(); }

#endif // _DEBUG



// the following create a dword that will look like "abcd" in debugger
#ifdef SHIP_BUILD
#define MAKE_STAMP_ID(a,b,c,d)     
#else
#define MAKE_STAMP_ID(a,b,c,d)     MAKELONG(MAKEWORD(a,b),MAKEWORD(c,d))
#endif // SHIP_BUILD

class CRefCount
{
public:

#ifdef SHIP_BUILD
    CRefCount(void);
#else
    CRefCount(DWORD dwStampID);
#endif
    virtual ~CRefCount(void) = 0;

    LONG AddRef(void);
    LONG Release(void);

protected:

    LONG GetRefCount(void) { return m_cRefs; }
    BOOL IsRefCountZero(void) { return (0 == m_cRefs); }

private:

#ifndef SHIP_BUILD
    DWORD       m_dwStampID;// to remove before we ship it
#endif
    LONG        m_cRefs;    // reference count
};


__inline void My_CloseHandle(HANDLE hdl)
{
    if (NULL != hdl)
    {
        CloseHandle(hdl);
    }
}


#endif // __MS_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\message.h ===
#ifndef _Message_h_
#define _Message_h_

#define MSG_IN			1
#define MSG_PRIVATE		2
#define MSG_SYS			4

#define INITIAL_LIMIT	500

class CChatMessage
{
	public:
	typedef enum eMsgTypes
	{
		MSG_SYSTEM = MSG_SYS,
		MSG_SAY = ~MSG_IN & ~MSG_PRIVATE,
		MSG_WHISPER = ~MSG_IN & MSG_PRIVATE,
		MSG_FROM_OTHER = MSG_IN & ~MSG_PRIVATE,
		MSG_WHISPER_FROM_OTHER = MSG_IN | MSG_PRIVATE
	} CHAT_MSGTYPE;

	private:
		static CChatMessage *ms_pFirst;
		static int          ms_cMessages;
		static CChatMessage *ms_pLast;
		static int			ms_iMessageLimit;

	private:
		LPTSTR m_szDate;
		LPTSTR m_szTime;
		LPTSTR m_szPerson;
		LPTSTR m_szMessage;
		CHAT_MSGTYPE m_msgType;
		
		CChatMessage *m_pNext;
		CChatMessage *m_pPrev;

	public:
		static CChatMessage *get_head();
		static int get_count();
		static CChatMessage *get_last();
		static void DeleteAll();
		static int get_limit();
		static void put_limit( int iLimit );

		BOOL inline IsPrivate()
		{
			return m_msgType & MSG_PRIVATE;
		}

		BOOL inline IsIncoming()
		{
			return m_msgType & MSG_IN;
		}

		BOOL inline IsValid()
		{
			return (m_szPerson != NULL) && (m_szMessage != NULL);
		}

	public:
		CChatMessage *get_next() const;
		CChatMessage *get_prev() const;
		CChatMessage::CHAT_MSGTYPE get_type() const;
		const LPTSTR get_date() const;
		const LPTSTR get_time() const;
		const LPTSTR get_person() const;
		const LPTSTR get_message() const;
		CChatMessage( LPCTSTR szPerson, LPCTSTR szMessage, CHAT_MSGTYPE msgType );
		~CChatMessage();

	private:
		LPTSTR _CopyString( LPCTSTR sz );
		void _GetDate();
		void _GetTime();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\nmagendaitemproppage.cpp ===
// NmAgendaItemPropPage.cpp : Implementation of CNmAgendaItemPropPage
#include "precomp.h"
#include "resource.h"
#include "NmCtl1.h"
#include "NmAgendaHelper.h"
#include "NmAgendaItemPropPage.h"

/////////////////////////////////////////////////////////////////////////////
// CNmAgendaItemPropPage


STDMETHODIMP CNmAgendaItemPropPage::Apply(void)
{
	DBGENTRY(CNmAgendaItemPropPage::Apply);
    HRESULT hr = S_OK;

	for (UINT i = 0; i < m_nObjects; i++)
	{
        CComQIPtr<INmAgendaItem,&IID_INmAgendaItem> pNmAgendaItem( m_ppUnk[i] );
        if( pNmAgendaItem )
        {
            HWND hEditName = GetDlgItem( IDC_EDITAGENDAITEMNAME );
            if( hEditName )
            {
                int cbLen = 1 + ::GetWindowTextLength( hEditName );

                if( cbLen > 1 )
                {
                    TCHAR* sz = new TCHAR[ cbLen ];

                    if( ::GetWindowText( hEditName, sz, cbLen ) )
                    {
                        hr = pNmAgendaItem->put_Name( CComBSTR( sz ) );

                        if( FAILED( hr ) )
                        {
                            WARNING_OUT(("put_Name Failed"));
                        }
                    }

                    delete [] sz;
                }
            }
        }
	}

	m_bDirty = FALSE;
    
    DBGEXIT_HR(CNmAgendaItemPropPage::Apply, hr);
	return hr;
}

LRESULT CNmAgendaItemPropPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = TRUE;
    
    USES_CONVERSION;

    DBGENTRY(CNmAgendaItemPropPage::OnInitDialog);

    if( m_nObjects > 0 )
    {
        CComQIPtr<INmAgendaItem,&IID_INmAgendaItem> pNmAgendaItem( m_ppUnk[0] );
        if( pNmAgendaItem )
        {   
            BSTR bstrName;
            if( SUCCEEDED( pNmAgendaItem->get_Name( &bstrName ) ) )
            {
                SetDlgItemText( IDC_EDITAGENDAITEMNAME, W2T( bstrName ) );

                NmAgendaItemType Type;
                if( SUCCEEDED( pNmAgendaItem->get_Type( &Type ) ) )
                {
                    SetDlgItemText( IDC_EDITAGENDAITEMTYPE, NmAgendaItemTypeToa( Type ) );
                }
            }
        }
    }
    m_bDirty = FALSE;

    m_bInitialized = true;

    DBGEXIT_ULONG(CNmAgendaItemPropPage::OnInitDialog, lr);
    return lr;
}

LRESULT CNmAgendaItemPropPage::OnAgendaItemNameChange(WORD wNotify, WORD wID, HWND hWnd, BOOL& bHandled)
{
    DBGENTRY(CNmAgendaItemPropPage::OnAgendaItemNameChange);
    
    if( m_bInitialized )
    {
        SetDirty( TRUE );
    }
    
    DBGEXIT(CNmAgendaItemPropPage::OnAgendaItemNameChange);
    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\nmchatctl.cpp ===
// NmChatCtl.cpp : Implementation of CNmChatCtl
#include "precomp.h"
#include "NmCtl1.h"
#include "NmChatCtl.h"
#include "ComboBoxEx.h"
#include "Message.h"
#include "OprahCom.h"
#include <version.h>

#include <nmhelp.h>
#include <help_ids.h>

extern CChatObj	*g_pChatObj;
extern DWORD    g_dwWorkThreadID;

// Class name
TCHAR szMainClassName[] = "ChatMainWindowClass";

static const TCHAR s_cszHtmlHelpFile[] = TEXT("nmchat.chm");

static const DWORD _mpIdHelpChatOptions[] = {
		// Information display group
	IDR_MESSAGE_GROUP,				IDH_CHAT_FORMAT_HEADER,
	IDC_INCLUDE_NAME, 				IDH_CHAT_NAME,
	IDC_INCLUDE_DATE, 				IDH_CHAT_DATE,
	IDC_INCLUDE_TIME, 				IDH_CHAT_TIME,
		
		// Message Format group
	IDC_HEADER_GROUP,				IDH_CHAT_FORMAT_MESSAGE,
	IDR_SINGLE_LINE,				IDH_CHAT_FORMAT_MESSAGE,
	IDR_SAME_LINE,					IDH_CHAT_FORMAT_MESSAGE,
	IDR_NEW_LINE,					IDH_CHAT_FORMAT_MESSAGE,
	IDC_FORMATSINGLE,				IDH_CHAT_FORMAT_MESSAGE,
	IDC_FORMATWRAP,				    IDH_CHAT_FORMAT_MESSAGE,
	IDC_FORMATWRAPNEW,				IDH_CHAT_FORMAT_MESSAGE,

		// Font buttons and edit controls
	IDC_FONTS_GROUP,				IDH_CHAT_FONTS_LABEL,
	IDC_FONT_MSGIN,					IDH_CHAT_RECEIVE_MSG,
	IDC_EDIT_MSGIN,					IDH_CHAT_FONT,
	IDC_FONT_PRIVATEIN,				IDH_CHAT_RECEIVE_PRIV,
	IDC_EDIT_PRIVATEIN,				IDH_CHAT_FONT,
	IDC_FONT_MSGOUT,				IDH_CHAT_SENT_MSG,
	IDC_EDIT_MSGOUT,				IDH_CHAT_FONT,
	IDC_FONT_PRIVATEOUT,			IDH_CHAT_SENT_PRIV,
	IDC_EDIT_PRIVATEOUT,			IDH_CHAT_FONT,

		// terminator
	0, 0
};

// Option entry names
#define OPT_MAIN_INFORMATION_DISPLAY_NAME     "Information Display Name"
#define OPT_MAIN_INFORMATION_DISPLAY_TIME	  "Information Display Time"
#define OPT_MAIN_INFORMATION_DISPLAY_DATE	  "Information Display Date"
#define OPT_MAIN_MESSAGE_FORMAT          "Message format"
const LPTSTR OPT_FONT_FORMAT[] = {"Received Message", "Received Private Messages",
	"Send Messages",  "Send Private Messages",  "System Format"};
const LPTSTR OPT_FONT_COLOR[] = {"Received Message Color", "Received Private Messages Color",
	"Send Messages Color",  "Send Private Messages Color",  "System Format Color"};


extern CNmChatCtl	*g_pChatWindow;
CNmChatCtl *CNmChatCtl::ms_pThis = NULL;
WORD	CChatOptionsDlg::IDD = IDD_CHAT_OPTIONS;

///////////////////////////////////////////////////////////////////////////////////////////////////////
// CNmChatCtl Construction and initialization
///////////////////////////////////////////////////////////////////////////////////////////////////////

CNmChatCtl::CNmChatCtl( void )
        :   m_hWndMsg( NULL ),
            m_himlIconSmall( NULL ),
            m_cOtherMembers( 0 ),
            m_hMenuShared(NULL),
			m_cchBufferSize( 0 ),
			m_hInstRichEd32( NULL ),
			m_bUseName( -1 ),
			m_bTimeStamp( 0 ),
			m_bUseDate( 0 ),
			m_style( MSGSTYLE_2_LINE_WRAP ),
			m_lpszOwnName( NULL ),
			m_iNameLen( 0 ),
			m_iStaticLen( 0 ),
			m_iDLGUX( 0 ),
			m_iDLGUY( 0 ),
			m_iStaticY( 0 ),
			m_iExtra( 0 ),
			m_szTo( NULL ),
			m_szPrivate( NULL ),
            m_bWeAreActiveApp(false),
			m_dwChatFlags( CHAT_FLAG_NONE ),
			m_hWndPrint( NULL ),
			m_lpszSaveFile( NULL ),
			m_bStatusBarVisible( TRUE ),
			m_wFileOffset( 0 ),
			m_lpszRichEdEOL( NULL ),
			m_lpszRichEd( NULL ),
			m_pChatOptions( NULL ),
			m_cMessages( 0 )
{
	DBGENTRY(CNmChatCtl::CNmChatCtl);


	g_pChatWindow = this;

	// Ensure the common controls are loaded
	INITCOMMONCONTROLSEX icc;
	icc.dwSize = sizeof(icc);
	icc.dwICC = ICC_WIN95_CLASSES | ICC_COOL_CLASSES | ICC_USEREX_CLASSES;
	::InitCommonControlsEx(&icc);

	_LoadIconImages();
	_InitFontsAndColors();

	//
	// CREATE THE MAIN FRAME WINDOW
	//

	//
	// Get the class info for it, and change the name.
	//
	WNDCLASSEX  wc;
	ZeroMemory(&wc, sizeof(wc));
	wc.cbSize = sizeof(wc);
	wc.style            = CS_DBLCLKS; // CS_HREDRAW | CS_VREDRAW?
	wc.lpfnWndProc      = ChatMainWindowProc;
	wc.hInstance        = g_hInstance;
	wc.hIcon            = ::LoadIcon(g_hInstance, MAKEINTRESOURCE(CHAT_ICON));
	wc.hCursor          = ::LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
	wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
	wc.lpszMenuName     = MAKEINTRESOURCE(IDR_MENU_CHAT_WITHFILE);
	wc.lpszClassName    = szMainClassName;

	if (!::RegisterClassEx(&wc))
	{
		ERROR_OUT(("Can't register private frame window class"));
	}

	TCHAR szCaption[MAX_PATH * 2];
   	::LoadString(g_hInstance, IDS_CHAT_NOT_IN_CALL_WINDOW_CAPTION, szCaption, sizeof(szCaption) );

	m_hWnd = ::CreateWindow(
                    szMainClassName,
                    szCaption,
                    WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_CLIPCHILDREN,
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                    NULL,   // no parent window
                    NULL,   // use class' menu
                    g_hInstance,
                    (LPVOID) this);  // this window is for this object


	m_hMenuShared = ::GetMenu(m_hWnd);

    ASSERT(m_hWnd);

	DBGEXIT(CNmChatCtl::CNmChatCtl);
}

CNmChatCtl::~CNmChatCtl( void )
{
	DBGENTRY(CNmChatCtl::~CNmChatCtl);

	delete [] m_lpszOwnName;
	delete [] m_szTo;
	delete [] m_szPrivate;
	delete [] m_lpszSaveFile;
	delete [] m_lpszRichEdEOL;
	delete [] m_lpszRichEd;

	if( NULL != m_hInstRichEd32 )
		FreeLibrary( m_hInstRichEd32 );

	CChatMessage::DeleteAll();

	m_pButton->Release();

	_DeleteFonts();
	_FreeIconImages();
	
	delete m_pChatOptions;

	DBGEXIT(CNmChatCtl::~CNmChatCtl);
}




//
// FilterMessage()
//
// This does tooltip message filtering, then translates accelerators.
//
BOOL CNmChatCtl::FilterMessage(MSG* pMsg)
{
    return (   (m_hAccelTable != NULL)
          && ::TranslateAccelerator(m_hWnd, m_hAccelTable, pMsg));
}


//
// ChatMainWindowProc()
// Frame window message handler
//
LRESULT CNmChatCtl::ChatMainWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult = 0;
	CNmChatCtl * pMain;
	LPWINDOWPOS pos;
	
	pMain = (CNmChatCtl *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

	switch (message)
	{

		case WM_NCCREATE:
			pMain = (CNmChatCtl *)((LPCREATESTRUCT)lParam)->lpCreateParams;
			ASSERT(pMain);
			pMain->m_hWnd = hwnd;
			::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pMain);
			pMain->OnCreate(wParam,lParam);
			goto DefWndProc;
			break;

		case WM_CREATE:
			::SetFocus(pMain->m_hWndEdit);
			break;
			
		case WM_NCDESTROY:
			pMain->m_hWnd = NULL;
			break;

		case WM_MENUSELECT:
			pMain->OnMenuSelect((DWORD)wParam, (DWORD)lParam);
			break;
		
		case WM_INITMENUPOPUP:
			pMain->OnInitMenuPopup((DWORD)wParam, (DWORD)lParam);
			break;

		case WM_ENDSESSION:
		case WM_CLOSE:
			pMain->cmdFileExit(wParam);
			break;

		case WM_COMMAND:
			pMain->OnCommand((DWORD)wParam, (DWORD)lParam);
			break;

		case WM_CONTEXTMENU:
			pMain->OnContextMenu((short)LOWORD(lParam), (short)HIWORD(lParam));
			break;


		case WM_SIZE:
			pMain->_Resize(0, 0, (short)LOWORD(lParam), (short)HIWORD(lParam));
			break;

		case WM_GETMINMAXINFO:
			if (pMain)
			{
				pMain->OnGetMinMaxInfo((LPMINMAXINFO)lParam);
			}
			break;

		case WM_USER_BRING_TO_FRONT_WINDOW:
			pMain->BringToFront();
			break;

		case WM_ACTIVATE:
			if (WA_INACTIVE != LOWORD(wParam) && IsWindowVisible(pMain->m_hWndEdit))
			{
				::SetFocus(pMain->m_hWndEdit);
			}
			break;

		case WM_NOTIFY:
			if(EN_LINK == ((LPNMHDR)lParam)->code)
			{
				pMain->OnNotifyEnLink((ENLINK*)lParam);
			}
			break;

		default:

DefWndProc:
			lResult = ::DefWindowProc(hwnd, message, wParam, lParam);
			break;
	}

	return(lResult);
}



void CNmChatCtl::BringToFront(void)
{
    if (NULL != m_hWnd)
    {
        int nCmdShow = SW_SHOW;

        WINDOWPLACEMENT wp;
        ::ZeroMemory(&wp, sizeof(wp));
        wp.length = sizeof(wp);

        if (::GetWindowPlacement(m_hWnd, &wp))
        {
            if (SW_MINIMIZE == wp.showCmd || SW_SHOWMINIMIZED == wp.showCmd)
            {
                // The window is minimized - restore it:
                nCmdShow = SW_RESTORE;
            }
        }

        // show the window now
        ::ShowWindow(m_hWnd, nCmdShow);

        // bring it to the foreground
        ::SetForegroundWindow(m_hWnd);

		//
		// Set the focus on the edit box
		//
        ::SetFocus(m_hWndEdit);
    }
}




///////////////////////////////////////////////////////////////////////////////////////////////////////
// CNmChatCtl Window message and command handlers
///////////////////////////////////////////////////////////////////////////////////////////////////////

LRESULT CNmChatCtl::OnCreate(WPARAM wParam, LPARAM lParam)
{
	DBGENTRY(CNmChatCtl::OnCreate);

	RECT rc;
	SetRect( &rc, 0, 0, 0, 0 );

	if( NULL == ( m_hInstRichEd32 = ::LoadLibrary( "RICHED20.DLL" ) ) )
	{
		if( NULL == ( m_hInstRichEd32 = ::LoadLibrary( "RICHED32.DLL" ) ) )
		{
			return 0;
		}
		else
		{
			LPTSTR szValue = TEXT("RichEdit");
			LPTSTR szValueEOL = TEXT("\r\n");
			DBG_SAVE_FILE_LINE
			m_lpszRichEd = new TCHAR[ lstrlen( szValue ) + 1 ];
			lstrcpy( m_lpszRichEd, szValue );
			m_lpszRichEdEOL = new TCHAR[ lstrlen( szValueEOL ) + 1 ];
			lstrcpy( m_lpszRichEdEOL, szValueEOL );
		}
	}
	else
	{
			LPTSTR szValue = RICHEDIT_CLASS;
			LPTSTR szValueEOL = TEXT(" \r");
			DBG_SAVE_FILE_LINE
			m_lpszRichEd = new TCHAR[ lstrlen( szValue ) + 1 ];
			lstrcpy( m_lpszRichEd, szValue );
			DBG_SAVE_FILE_LINE
			m_lpszRichEdEOL = new TCHAR[ lstrlen( szValueEOL ) + 1 ];
			lstrcpy( m_lpszRichEdEOL, szValueEOL );
	}

	////////// Edit control
    m_hWndEdit = ::CreateWindowEx(WS_EX_CLIENTEDGE,
								    _T("EDIT"),
									NULL,
								    WS_CHILD | WS_BORDER | WS_VISIBLE |
								    WS_TABSTOP | ES_MULTILINE | ES_AUTOVSCROLL,
									CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
							        m_hWnd, NULL, g_hInstance, NULL);

	::SendMessage( m_hWndEdit, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT ), TRUE);
	::SendMessage( m_hWndEdit, EM_LIMITTEXT, CCHMAX_CHAT_MSG - 1, 0 );
	::SendMessage( m_hWndEdit, EM_EXLIMITTEXT, 0, CCHMAX_CHAT_MSG - 1 );

	//// Get info from edit control
	TEXTMETRIC textmex;
	ZeroMemory( &textmex, sizeof( textmex ) );
	HDC hdc = GetDC(m_hWndEdit);
	GetTextMetrics( hdc, &textmex );
	ReleaseDC(m_hWndEdit, hdc );

	m_iDLGUY = PIX_FROM_DLGU_Y( 1, textmex.tmHeight );
	m_iDLGUX = PIX_FROM_DLGU_X( 1, textmex.tmAveCharWidth);


	////////// Send Button
	DBG_SAVE_FILE_LINE
	m_pButton = new CBitmapButton();
	if(m_pButton)
	{
		BOOL fRet = m_pButton->Create(m_hWnd,
								IDI_SENDBUTTON,
								g_hInstance,
								IDB_SENDCHAT,
								TRUE,
								CBitmapButton::Disabled,
								1,
								NULL);

		m_hWndSend = m_pButton->GetWindow();								
		if(fRet == FALSE)
		{
			m_pButton->Release();
			return fRet;
		}
        m_pButton->SetTooltip((LPSTR)IDS_TOOLTIP_SEND_MESSAGE);
	}
	else
	{
		return FALSE;
	}


	////////// Member List
    m_hWndMemberList = ::CreateWindowEx(0,
									_T(WC_COMBOBOXEX),
									NULL,
									WS_VISIBLE | WS_CHILD | CBS_DROPDOWNLIST | WS_TABSTOP | WS_VSCROLL,
									CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
							        m_hWnd, NULL, g_hInstance, NULL);


	ASSERT( m_himlIconSmall );

	::SendMessage(m_hWndMemberList, WM_SETFONT, (WPARAM)GetStockObject( DEFAULT_GUI_FONT ), TRUE);
	ComboBoxEx_SetImageList( m_hWndMemberList, m_himlIconSmall );

	int yFrameBorder = GetSystemMetrics( SM_CYFIXEDFRAME );
	int ySpace = GetSystemMetrics( SM_CYBORDER );
	int iHeight = ComboBoxEx_GetItemHeight( m_hWndMemberList, 0 );
	ComboBoxEx_SetHeight( m_hWndMemberList, ((iHeight + ySpace) * MSGLIST_VISMEMBERS) + yFrameBorder);





	////////// Status bar
   RECT    clientRect;
	::GetClientRect(m_hWnd, &clientRect);
	m_hwndSB = ::CreateWindowEx(0, STATUSCLASSNAME, NULL,
		WS_CHILD | WS_VISIBLE | CCS_NOPARENTALIGN | CCS_NOMOVEY |
		CCS_NORESIZE | SBARS_SIZEGRIP,
		clientRect.left, clientRect.bottom - STATUSBAR_HEIGHT,
		(clientRect.right - clientRect.left), STATUSBAR_HEIGHT,
		m_hWnd, 0, g_hInstance, NULL);

	if (!m_hwndSB)
	{
		ERROR_OUT(("Failed to create status bar window"));
		return(FALSE);
	}


	////////// Static
	TCHAR szBuff[ MAX_PATH ];
	NmCtlLoadString( IDS_CHAT_MESSAGE, szBuff, CCHMAX(szBuff));
    m_hWndStaticMessage = ::CreateWindowEx(0,
									_T("STATIC"),
									szBuff,
									WS_VISIBLE | WS_CHILD | SS_LEFT,
									CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
							        m_hWnd, NULL, g_hInstance, NULL);

	::SendMessage(m_hWndStaticMessage, WM_SETFONT, (WPARAM)GetStockObject( DEFAULT_GUI_FONT ), TRUE);


	////////// Static
	NmCtlLoadString( IDS_CHAT_SENDTO, szBuff, CCHMAX(szBuff));
    m_hWndStaticSendTo = ::CreateWindowEx(0,
									_T("STATIC"),
									szBuff,
									WS_VISIBLE | WS_CHILD | SS_LEFT,
									CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
							        m_hWnd, NULL, g_hInstance, NULL);

	::SendMessage(m_hWndStaticSendTo, WM_SETFONT, (WPARAM)GetStockObject( DEFAULT_GUI_FONT ), TRUE);



	////// Get info for static controls
	hdc = ::GetDC(m_hWndStaticMessage);
	GetTextMetrics( hdc, &textmex );

	TCHAR szBuffer[ MAX_PATH ];

	GetWindowText(m_hWndStaticMessage, szBuffer, CCHMAX( szBuffer ) );
	RECT rect1;
	ZeroMemory( &rect1, sizeof( rect1 ) );
	DrawText( hdc, szBuffer, lstrlen( szBuffer ), &rect1, DT_CALCRECT );

	GetWindowText(m_hWndStaticSendTo, szBuffer, CCHMAX( szBuffer ) );
	RECT rect2;
	ZeroMemory( &rect2, sizeof( rect2 ) );
	DrawText( hdc, szBuffer, lstrlen( szBuffer ), &rect1, DT_CALCRECT );
	
	ReleaseDC(m_hWndStaticMessage, hdc );

	m_iStaticLen = max( rect1.right, rect2.right );
	m_iStaticY = max( rect1.bottom, rect2.bottom );

	_UpdateContainerCaption();
	put_MsgStyle( m_style );
	_LoadStrings();

	HICON hIconSmall = (HICON)LoadImage(
							  g_hInstance,   // handle of the instance containing the image
							  MAKEINTRESOURCE( CHAT_ICON ),  // name or identifier of image
							  IMAGE_ICON,        // type of image
							  ICON_SMALL_SIZE,     // desired width
							  ICON_SMALL_SIZE,     // desired height
							  LR_DEFAULTCOLOR        // load flags
							  );
	HICON hIconLarge = (HICON)LoadImage(
							  g_hInstance,   // handle of the instance containing the image
							  MAKEINTRESOURCE( CHAT_ICON ),  // name or identifier of image
							  IMAGE_ICON,        // type of image
							  ICON_BIG_SIZE,     // desired width
							  ICON_BIG_SIZE,     // desired height
							  LR_DEFAULTCOLOR        // load flags
							  );

	DBGEXIT_ULONG(CNmChatCtl::OnCreate, 0);


    // Load the main accelerator table
    m_hAccelTable = ::LoadAccelerators(g_hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR));

    RECT rcUI;
    _GetWindowRectOption(&rcUI);

	::MoveWindow(m_hWnd, rcUI.left, rcUI.top, rcUI.right - rcUI.left, rcUI.bottom - rcUI.top, TRUE);

	return TRUE;
}

void CNmChatCtl::_LoadStrings()
{
	TCHAR buffer[ MAX_PATH ];
	
	NmCtlLoadString(IDS_PRIVATE, buffer, CCHMAX(buffer));
	DBG_SAVE_FILE_LINE
	m_szPrivate = new TCHAR[ lstrlen( buffer ) + 1 ];
	ASSERT( m_szPrivate );
	lstrcpy( m_szPrivate, buffer );

	NmCtlLoadString(IDS_TO, buffer, CCHMAX(buffer));
	DBG_SAVE_FILE_LINE
	m_szTo = new TCHAR[ lstrlen( buffer ) + 1 ];
	ASSERT( m_szTo );
	lstrcpy( m_szTo, buffer );

	m_iExtra = lstrlen( m_szTo ) + lstrlen( m_szPrivate ) + 1;
}

void CNmChatCtl::_InitFontsAndColors()
{
	if (_LoadChatOptions())
	{   // Load options succeed
		return;
	}

	// Load Fonts
	for( int i = 0; i < CChatOptionsDlg::FONT_COUNT; i++ )
	{
		GetObject( GetStockObject( DEFAULT_GUI_FONT ), sizeof( m_hMsgLogFonts[i] ), &m_hMsgLogFonts[i] );
		m_hMsgFonts[ i ] = CreateFontIndirect( &m_hMsgLogFonts[i] );
	}

	m_hMsgColors[ CChatOptionsDlg::FONT_MSGOUT ] = RGB( 0, 0, 0 );
	m_hMsgColors[ CChatOptionsDlg::FONT_MSGIN ] = RGB( 0, 0, 0 );
	m_hMsgColors[ CChatOptionsDlg::FONT_PRIVATEOUT ] = RGB( 100, 100, 100 );
	m_hMsgColors[ CChatOptionsDlg::FONT_PRIVATEIN ] = RGB( 100, 100, 100 );
	m_hMsgColors[ CChatOptionsDlg::FONT_MSGSYSTEM ] = RGB( 255, 0, 0 );
}

void CNmChatCtl::_DeleteFonts()
{
	for( int i = 0; i < CChatOptionsDlg::FONT_COUNT; i++ )
	{
		DeleteObject( m_hMsgFonts[i] );
	}
}

LRESULT CNmChatCtl::OnInitMenuPopup(WPARAM wParam, LPARAM lParam)
{
    DBGENTRY(CNmChatCtl::OnInitMenuPopup);

	if( FALSE == (BOOL)HIWORD(lParam ) )
	{
		switch( LOWORD( lParam ) )
		{
			case MENUPOS_FILE:
			{
				if( CChatMessage::get_count() )
				{
					EnableMenuItem( m_hMenuShared, ID_FILE_SAVE,
						( m_lpszSaveFile && *m_lpszSaveFile ) ? MF_ENABLED : MF_GRAYED );
					EnableMenuItem( m_hMenuShared, ID_FILE_SAVEAS, MF_ENABLED );
					EnableMenuItem( m_hMenuShared, ID_FILE_PRINT,
						!_IsPrinting() ? MF_ENABLED : MF_GRAYED );
				}
				else
				{
					EnableMenuItem( m_hMenuShared, ID_FILE_SAVE, MF_GRAYED );
					EnableMenuItem( m_hMenuShared, ID_FILE_SAVEAS, MF_GRAYED );
					EnableMenuItem( m_hMenuShared, ID_FILE_PRINT, MF_GRAYED );
				}
				return 0;
			}
			case MENUPOS_EDIT:
			{
				EnableMenuItem( m_hMenuShared, ID_EDIT_CLEARALL,
					CChatMessage::get_count() && !_IsPrinting() ? MF_ENABLED : MF_GRAYED );

				int iEnable = 0;
				
				HWND hwnd = ::GetFocus();
				if(hwnd == m_hWndEdit)
				{
					iEnable = (int)::SendMessage( hwnd, EM_GETSEL, 0, 0 );
					iEnable = (HIWORD(iEnable) == LOWORD(iEnable)) ? MF_GRAYED : MF_ENABLED;
				}
				else if(hwnd == m_hWndMsg)
				{
					CHARRANGE range;
					::SendMessage( hwnd, EM_EXGETSEL, 0, (LPARAM) &range );
					iEnable = (range.cpMin == range.cpMax) ? MF_GRAYED : MF_ENABLED;
				}

				EnableMenuItem( m_hMenuShared, ID_EDIT_CUT,hwnd == m_hWndEdit ?  iEnable : MF_GRAYED);
				EnableMenuItem( m_hMenuShared, ID_EDIT_PASTE,
					(IsClipboardFormatAvailable( CF_TEXT ) && (hwnd == m_hWndEdit)) ? MF_ENABLED : MF_GRAYED );

				EnableMenuItem( m_hMenuShared, ID_EDIT_COPY, iEnable );

				return 0;
			}
			case MENUPOS_VIEW:
			{
				_SetMenuItemCheck( ID_VIEW_STATUSBAR, _IsStatusBarVisibleFlagSet() );
				_SetMenuItemCheck( ID_VIEW_EDITWINDOW, _IsEditWindowVisibleFlagSet() );
				EnableMenuItem( m_hMenuShared, ID_VIEW_OPTIONS, _IsPrinting() ? MF_GRAYED : MF_ENABLED );
				return 0;
				break;
			}
			default:
				return 0;
		}
	}
	return 0;
}

LRESULT CNmChatCtl::OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DBGENTRY(CNmChatCtl::OnMenuSelect);

        UINT fuFlags = HIWORD( wParam );
			// If fuFlags == 0xffff and NULL == lParam, the menu is closed
		if( !( ( 0xFFFF == fuFlags ) && ( NULL == lParam ) ) )
		{
			UINT uStringID = 0;
			if( ( HIWORD( wParam ) & MF_HILITE ) )
			{

				if(( HIWORD( wParam ) & MF_SYSMENU))
				{
					uStringID = LOWORD( wParam );
					if(!uStringID)
					{
						uStringID = IDS_SYSTEM_HELP;
					}
				}
				else
				{

					switch( LOWORD( wParam ) )
					{

						case 0: // FILE top-level item
							uStringID = IDS_HELPTEXT_CHAT_FILE;
							break;

						case 1: // EDIT top-level item
							uStringID = IDS_HELPTEXT_CHAT_EDIT;
							break;

						case 2: // VIEW top-level item
							uStringID = IDS_HELPTEXT_CHAT_VIEW;
							break;

						case 3: // OPTIONS top-level item
							uStringID = IDS_HELPTEXT_CHAT_HELP;
							break;

						case ID_SEND_MESSAGE:
							uStringID = IDS_HELPTEXT_CHAT_FILE_SEND_MESSAGE;
							break;

						case ID_FILE_SAVE:
							uStringID = IDS_HELPTEXT_CHAT_FILE_SAVE;
							break;

						case ID_FILE_SAVEAS:
							uStringID = IDS_HELPTEXT_CHAT_FILE_SAVEAS;
							break;

						case ID_FILE_PRINT:
							uStringID = IDS_HELPTEXT_CHAT_FILE_PRINT;
							break;

						case ID_FILE_EXIT:
							uStringID = IDS_HELPTEXT_CHAT_FILE_EXIT;
							break;

						case ID_VIEW_EDITWINDOW:
							uStringID = IDS_HELPTEXT_CHAT_VIEW_EDITWINDOW;
							break;

						case ID_VIEW_STATUSBAR:
							uStringID = IDS_VIEW_STATUSBAR_HELP;
							break;

						case ID_VIEW_OPTIONS:
							uStringID = IDS_HELPTEXT_CHAT_VIEW_OPTIONS;
							break;

						case ID_EDIT_CUT:
							uStringID = IDS_HELPTEXT_EDIT_CUT  ;
							break;

						case ID_EDIT_COPY:
							uStringID = IDS_HELPTEXT_EDIT_COPY;
							break;

						case ID_EDIT_PASTE:
							uStringID = IDS_HELPTEXT_EDIT_PASTE;
							break;

						case ID_EDIT_CLEARALL:
							uStringID = IDS_HELPTEXT_EDIT_CLEARALL;
							break;

						case ID_HELP_ABOUTCHAT:
							uStringID = IDS_HELPTEXT_HELP_ABOUTCHAT;
							break;

						case ID_HELP_HELPTOPICS:
							uStringID = IDS_HELPTEXT_HELP_HELPTOPICS;
							break;
					}
				}
				_SetContainerStatusText(uStringID);
			}
		}

    DBGEXIT(CNmChatCtl::OnMenuSelect);
    return 0;
}


void CNmChatCtl::OnSendClicked(void)
{
	DBGENTRY(CNmChatCtl::OnSendClicked);

	_SendChatText();

	::SetFocus( m_hWndEdit );

	DBGEXIT(CNmChatCtl::OnCreate);
}

LRESULT CNmChatCtl::OnNotifyEnLink(ENLINK *pEnLink)
{
	DBGENTRY(CNmChatCtl::OnMsgWndNotify);

	switch( pEnLink->msg )
	{
		case WM_LBUTTONUP:
		case WM_LBUTTONDBLCLK:
		{
			return 1;
			break;
		}
		case WM_LBUTTONDOWN:
		{
			TEXTRANGE Range;
			ZeroMemory( &Range, sizeof( TEXTRANGE ) );
			DBG_SAVE_FILE_LINE
			Range.lpstrText = new TCHAR[ pEnLink->chrg.cpMax - pEnLink->chrg.cpMin + 1];
			ASSERT( Range.lpstrText );
			Range.chrg = pEnLink->chrg;
			::SendMessage( m_hWndMsg, EM_GETTEXTRANGE, 0L, (LPARAM)&Range );

			ShellExecute( m_hWndMsg, NULL, Range.lpstrText, NULL, NULL, SW_SHOWNORMAL );

			delete [] Range.lpstrText;
			return 1;
			break;
		}
		default:
		{
			break;
		}
	}

	DBGEXIT(CNmChatCtl::OnMsgWndNotify);

	return 0;
}


//////////////////////////////////////////////////////////////////////////

    void CNmChatCtl::cmdFileSave(void)
    {
        DBGENTRY(CNmChatCtl::cmdFileSave);

		if( ( NULL == m_lpszSaveFile ) || ( _T('\0') == *m_lpszSaveFile ) )
		{
			_SaveAs();
		}
		else
		{
			_Save();
		}

        DBGEXIT(CNmChatCtl::cmdFileSave);
    }

    void CNmChatCtl::cmdFileSaveAs(void)
    {
        DBGENTRY(CNmChatCtl::cmdFileSaveAs);

		_SaveAs();

        DBGEXIT(CNmChatCtl::cmdFileSaveAs);
    }

    void CNmChatCtl::cmdFilePrint(void)
    {

        DBGENTRY(CNmChatCtl::cmdFilePrint);

		m_dwChatFlags |= CHAT_PRINT_FLAG_PRINTING;

		_Print();

		m_dwChatFlags &= ~CHAT_PRINT_FLAG_PRINTING;

        DBGEXIT(CNmChatCtl::cmdFilePrint);
    }

    void CNmChatCtl::cmdFileExit(WPARAM wParam)
    {

        DBGENTRY(CNmChatCtl::cmdFileExit);

	    int iOnSave = IDOK;

		if(wParam == 0)
		{
	        // Check whether there are changes to be saved
    	    iOnSave = QueryEndSession();
    	}

	    // If the exit was not cancelled, close the application
	    if (iOnSave != IDCANCEL)
	    {
			// no more T.120
			g_pChatObj->LeaveT120();

	        // Close chat
    	    ::T120_AppletStatus(APPLET_ID_CHAT, APPLET_CLOSING);
    	    ::DestroyWindow(m_hWnd);
    	    ::UnregisterClass(szMainClassName, g_hInstance);

			m_hWnd = NULL;
			PostQuitMessage(0);

    	}

        DBGEXIT(CNmChatCtl::cmdFileExit);
    }

    void CNmChatCtl::cmdViewStatusBar(void)
    {
        DBGENTRY(CNmChatCtl::cmdViewStatusBar);
		RECT rect;
		GetClientRect(m_hWnd, &rect );
		::ShowWindow(m_hwndSB, _IsStatusBarVisibleFlagSet() ? SW_HIDE : SW_SHOW);
		_Resize( 0, 0, rect.right, rect.bottom );
		RedrawWindow(m_hWnd, NULL, NULL, RDW_UPDATENOW | RDW_INVALIDATE);
		DBGEXIT(CNmChatCtl::cmdViewStatusBar);
    }


//////////////////////////////////////////////////////////////////////////

void CNmChatCtl::cmdViewEditWindow(void)
{
	DBGENTRY(CNmChatCtl::cmdViewEditWindow);

	int iShowCommand = _IsEditWindowVisibleFlagSet() ? SW_HIDE : SW_SHOW;
	::ShowWindow( m_hWndEdit, iShowCommand );
	::ShowWindow( m_hWndSend, iShowCommand );
	::ShowWindow( m_hWndStaticMessage, iShowCommand );
	::ShowWindow( m_hWndStaticSendTo, iShowCommand );
	::ShowWindow( m_hWndMemberList, iShowCommand );

	_CalculateFontMetrics();
	RECT rect;
	GetClientRect(m_hWnd, &rect );
	_Resize( 0, 0, rect.right, rect.bottom );
	RedrawWindow(m_hWnd, NULL, NULL, RDW_UPDATENOW | RDW_INVALIDATE);

	DBGEXIT(CNmChatCtl::cmdViewEditWindow);
}


void CNmChatCtl::cmdEditCut(void)
{
	DBGENTRY(CNmChatCtl::cmdEditCut);

	::SendMessage(m_hWndEdit, WM_CUT, 0, 0);

	DBGEXIT(CNmChatCtl::cmdEditCut);
}

void CNmChatCtl::cmdEditCopy(void)
{
	DBGENTRY(CNmChatCtl::cmdEditCopy);

	HWND hwnd = ::GetFocus();
	if(hwnd == 0)
	{
		hwnd = m_hWndEdit;
	}

	::SendMessage(hwnd, WM_COPY, 0, 0);

	DBGEXIT(CNmChatCtl::cmdEditCopy);
}

void CNmChatCtl::cmdEditPaste(void)
{
	DBGENTRY(CNmChatCtl::cmdEditPaste);

	::SendMessage(m_hWndEdit, WM_PASTE, 0, 0);

	DBGEXIT(CNmChatCtl::cmdEditPaste);
}


void CNmChatCtl::cmdEditClearAll(void)
{
	DBGENTRY(CNmChatCtl::cmdEditClearAll);

	if( !_IsPrinting() )
	{
		ResetView();
	}

	DBGEXIT(CNmChatCtl::cmdEditClearAll);
}

void CNmChatCtl::cmdViewOptions(void)
{
    DBGENTRY(CNmChatCtl::cmdViewOptions);

	if(m_pChatOptions == NULL)
	{
		DBG_SAVE_FILE_LINE
		m_pChatOptions = new CChatOptionsDlg( this );
	}
	
	::DialogBox (g_hInstance,
					MAKEINTRESOURCE(IDD_CHAT_OPTIONS),
					m_hWnd,
					CChatOptionsDlg::_OptionsDlgProc);

	delete m_pChatOptions;
	m_pChatOptions = NULL;

    DBGEXIT(CNmChatCtl::cmdViewOptions);
}

void CNmChatCtl::cmdHelpHelpTopics(void)
{
	DBGENTRY(CNmChatCtl::cmdHelpHelpTopics);

	ShowNmHelp(s_cszHtmlHelpFile);

	DBGEXIT(CNmChatCtl::cmdHelpHelpTopics);
}


void CNmChatCtl::cmdHelpAboutChat()
{
	DBGENTRY(CNmChatCtl::cmdHelpAboutChat);

	::DialogBox( g_hInstance,
					MAKEINTRESOURCE( IDD_CHAT_ABOUT ),
					m_hWnd,
					_AboutDlgProc );

	DBGEXIT(CNmChatCtl::cmdHelpAboutChat);
}

int  CNmChatCtl::QueryEndSession()
{
	DBGENTRY(CNmChatCtl::QueryEndSession);

	//
	// We may be shuting down, last good chance to save the position
	//
	_SaveWindowPosition();
    _SaveChatOptions();

	int iRet;
	
	{
		if( m_dwChatFlags & CHAT_FLAG_DIRTYBIT )
		{
			TCHAR szRes[MAX_PATH];
			TCHAR szRes2[MAX_PATH];

			iRet = ::MessageBox( m_hWnd,
						   			 RES2T(IDS_SAVE_CHANGES_TO_CHAT_BEFORE_EXITING,szRes),
									 RES2T(IDS_NETMEETING_CHAT,szRes2),
									 MB_YESNOCANCEL | MB_ICONEXCLAMATION
								   );
			if( IDCANCEL == iRet )
			{
				return iRet;
			}
			else if( IDYES == iRet )
			{
				if( m_lpszSaveFile && *m_lpszSaveFile )
				{
					// if we already have a save file name
					// we just save it....
					_Save();
				}
				else
				{
					iRet = _SaveAs();
				}
			}
		}
	}

	DBGEXIT(CNmChatCtl::QueryEndSession);
	return iRet;
}

STDMETHODIMP CNmChatCtl::OnMenuSelect( IN DWORD wParam, IN DWORD lParam )
{
	DBGENTRY(CNmChatCtl::OnMenuSelect);
	HRESULT hr = S_OK;
	
	UINT fuFlags = HIWORD( wParam );

	if( !( ( 0xFFFF == fuFlags ) && ( NULL == lParam ) ) )
	{
		switch( LOWORD( wParam ) )
		{

			case ID_SEND_MESSAGE:
			case ID_FILE_SAVE:
			case ID_FILE_SAVEAS:
			case ID_FILE_PRINT:
			case ID_FILE_EXIT:
			case MENUPOS_FILE:
				OnInitMenuPopup( 0, MAKELPARAM( MENUPOS_FILE, 0 ));
				break;

			case ID_VIEW_STATUSBAR:
			case ID_VIEW_EDITWINDOW:
			case ID_VIEW_OPTIONS:
			case MENUPOS_VIEW:
				OnInitMenuPopup( 0, MAKELPARAM( MENUPOS_VIEW, 0 ));
				break;

			case ID_EDIT_CUT:
			case ID_EDIT_COPY:
			case ID_EDIT_PASTE:
			case ID_EDIT_CLEARALL:
			case MENUPOS_EDIT:
				OnInitMenuPopup( 0, MAKELPARAM( MENUPOS_EDIT, 0 ));
				break;

			case ID_HELP_HELPTOPICS:
			case ID_HELP_ABOUTCHAT:
			default:
				break;
		}

		OnMenuSelect(WM_MENUSELECT, wParam, lParam);
	}
	

	DBGEXIT_HR(CNmChatCtl::OnMenuSelect,hr);
	return hr;
}

LRESULT CNmChatCtl::OnContextMenu(short x, short y)
{
    // pop it up
    OnInitMenuPopup(0, MENUPOS_EDIT);
    ::TrackPopupMenu(::GetSubMenu(m_hMenuShared, MENUPOS_EDIT), TPM_RIGHTALIGN | TPM_RIGHTBUTTON,
						x , y , 0, m_hWnd, NULL);

	return 0;
}


STDMETHODIMP CNmChatCtl::OnCommand( IN WPARAM wParam, IN LPARAM lParam )
{
	DBGENTRY(CNmChatCtl::OnCommand);
	HRESULT hr = S_OK;

	if(m_hWndSend == (HWND)lParam)
	{
		OnSendClicked();
		return 0;
	}
	
	if((CBN_SETFOCUS == HIWORD(wParam) && m_hWndMemberList == (HWND)lParam) ||
		(EN_SETFOCUS == HIWORD(wParam) && m_hWndEdit == (HWND)lParam))
	{
		//
		// Deselect the text in the message window
		//
		CHARRANGE charRange;
		charRange.cpMin = m_cchBufferSize + 1;
		charRange.cpMax = m_cchBufferSize + 1;
		::SendMessage( m_hWndMsg, EM_EXSETSEL, 0L, (LPARAM) &charRange );
	}

	switch( LOWORD( wParam ) )
	{
		case ID_SEND_MESSAGE: OnSendClicked(); break;
		case ID_FILE_SAVE: cmdFileSave(); break;
		case ID_FILE_SAVEAS: cmdFileSaveAs(); break;
		case ID_FILE_PRINT: cmdFilePrint(); break;
		case ID_FILE_EXIT: cmdFileExit(0); break;
		case ID_VIEW_STATUSBAR: cmdViewStatusBar(); break;
		case ID_EDIT_CUT: cmdEditCut(); break;
		case ID_EDIT_COPY: cmdEditCopy(); break;
		case ID_EDIT_PASTE: cmdEditPaste(); break;
		case ID_EDIT_CLEARALL: cmdEditClearAll(); break;
		case ID_VIEW_EDITWINDOW: cmdViewEditWindow(); break;
		case ID_VIEW_OPTIONS: cmdViewOptions (); break;
		case ID_HELP_HELPTOPICS: cmdHelpHelpTopics(); break;
		case ID_HELP_ABOUTCHAT: cmdHelpAboutChat(); break;
	}

	DBGEXIT_HR(CNmChatCtl::OnCommand,hr);
	return hr;
}

void CNmChatCtl::OnGetMinMaxInfo(LPMINMAXINFO lpmmi)
{
    DBGENTRY(CNmChatCtl::OnGetMinMaxInfo);

	SIZE csFrame;
	csFrame.cx = ::GetSystemMetrics(SM_CXSIZEFRAME);
    csFrame.cy = ::GetSystemMetrics(SM_CYSIZEFRAME);

	lpmmi->ptMinTrackSize.y =
		    	csFrame.cy +
			    GetSystemMetrics( SM_CYCAPTION ) +
			    GetSystemMetrics( SM_CYMENU ) +
				DYP_CHAT_SEND * 2 +	// At least 2 lines
				m_iStaticY +	// Message:
				DYP_CHAT_SEND +	// Edit box
				m_iStaticY +	// Send to:
				ComboBoxEx_GetItemHeight(m_hWndMemberList, 0) + // ComboBox
				STATUSBAR_HEIGHT +
				csFrame.cy;

	lpmmi->ptMinTrackSize.x =
		csFrame.cx +
		m_iStaticLen * 2 +
		SPACING_DLU_X * m_iDLGUX +
		DXP_CHAT_SEND +
		csFrame.cx;


    // Retrieves the size of the work area on the primary display monitor. The work
    // area is the portion of the screen not obscured by the system taskbar or by
    // application desktop toolbars
    //
    RECT rcWorkArea;
    ::SystemParametersInfo( SPI_GETWORKAREA, 0, (&rcWorkArea), NULL );
    csFrame.cx = rcWorkArea.right - rcWorkArea.left;
    csFrame.cy = rcWorkArea.bottom - rcWorkArea.top;

    lpmmi->ptMaxPosition.x  = 0;
    lpmmi->ptMaxPosition.y  = 0;
    lpmmi->ptMaxSize.x      = csFrame.cx;
    lpmmi->ptMaxSize.y      = csFrame.cy;
    lpmmi->ptMaxTrackSize.x = csFrame.cx;
    lpmmi->ptMaxTrackSize.y = csFrame.cy;
		
    DBGEXIT(CNmChatCtl::OnGetMinMaxInfo);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////
// CNmChatCtl INmChatCtl implementation
///////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChatCtl::ResetView()
{

	DBGENTRY(CNmChatCtl::ResetView());

	HRESULT hr;

	if( _IsPrinting() )
	{
		hr = E_FAIL;
	}
	else
	{
		::SetWindowText( m_hWndMsg, TEXT(""));
		m_cchBufferSize = 0;
		m_cMessages = 0;
		CChatMessage::DeleteAll();

		m_dwChatFlags &= ~CHAT_FLAG_DIRTYBIT;

		hr = S_OK;
	}

	DBGEXIT_HR(CNmChatCtl::ResetView, hr);

	return hr;
}

void CNmChatCtl::_ReDisplayMessages()
{
	DBGENTRY(CNmChatCtl::_ReDisplayMessages());

	SNDMSG( m_hWndMsg, WM_SETREDRAW, FALSE, 0 );

	::SetWindowText( m_hWndMsg, TEXT(""));
	
	CChatMessage *pMsg = CChatMessage::get_head();
	while( pMsg != NULL )
	{
		_DisplayMsg( pMsg, FALSE );
		pMsg = pMsg->get_next();
	}

	SNDMSG( m_hWndMsg, WM_SETREDRAW, TRUE, 0 );
	::InvalidateRect( m_hWndMsg, NULL, INVALIDATE_BACKGROUND );

	DBGEXIT(CNmChatCtl::_ReDisplayMessages);
}

CNmChatCtl::MSGSTYLE CNmChatCtl::get_MsgStyle()
{
	return m_style;
}

STDMETHODIMP CNmChatCtl::put_MsgStyle( /*[in]*/ MSGSTYLE iStyle )
{
	DBGENTRY(CNmChatCtl::put_MsgStyle);

	HRESULT hr = S_OK;

	DWORD dwStyle;
	
	if( MSGSTYLE_2_LINE_WRAP == iStyle ||
		MSGSTYLE_1_LINE_WRAP == iStyle )
	{
		dwStyle = WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_MULTILINE | ES_READONLY | \
		ES_SAVESEL | ES_NOHIDESEL | ES_AUTOVSCROLL | WS_VSCROLL;
	}
	else if( MSGSTYLE_NO_WRAP == iStyle )
	{
		dwStyle = WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_MULTILINE | ES_READONLY | \
		ES_SAVESEL | ES_NOHIDESEL | ES_AUTOVSCROLL | WS_VSCROLL | WS_HSCROLL | ES_AUTOVSCROLL;
	}
	else
	{
		hr = E_FAIL;
		DBGEXIT_HR(CNmChatCtl::put_MsgStyle, hr);
		return hr;
	}

	HWND hwndKill = m_hWndMsg;

	m_hWndMsg = ::CreateWindowEx( WS_EX_CLIENTEDGE,
								m_lpszRichEd,
								NULL,
								dwStyle,
								0,0,0,0,
								m_hWnd,
								NULL,
								g_hInstance,
								this );

	ASSERT( m_hWndMsg );
	::SendMessage( m_hWndMsg, WM_SETFONT, (WPARAM)m_hMsgFonts[ CChatOptionsDlg::FONT_MSGOUT ], 0L );
	::SendMessage( m_hWndMsg, EM_AUTOURLDETECT, (WPARAM) TRUE, 0L );
	::SendMessage( m_hWndMsg, EM_SETBKGNDCOLOR, (WPARAM) TRUE, 0L );
	::SendMessage( m_hWndMsg, EM_SETEVENTMASK, 0L, (LPARAM) ENM_LINK );
	::SendMessage( m_hWndMsg, WM_PAINT, 0, 0);
	
	m_style = iStyle;

	_CalculateFontMetrics();

	RECT rect;
	GetClientRect(m_hWnd, &rect );
	_Resize( 0, 0, rect.right, rect.bottom );

	::SendMessage( m_hWndMsg, EM_SETPARAFORMAT, 0, (LPARAM) &m_paraLine1 );

	_ReDisplayMessages();

    if( ::IsWindow( hwndKill ) )
    {
	    ::DestroyWindow( hwndKill );
    }

	DBGEXIT_HR(CNmChatCtl::put_MsgStyle, hr);
	
	return hr;
}

STDMETHODIMP CNmChatCtl::put_ShowName(/*[in]*/ short bUseName )
{
	DBGENTRY(CNmChatCtl::put_ShowName);

	m_bUseName = bUseName;

	DBGEXIT_HR(CNmChatCtl::put_ShowName, S_OK);
	
	return S_OK;
}

STDMETHODIMP CNmChatCtl::get_ShowName(/*[out]*/ short *pbUseName )
{
	DBGENTRY(CNmChatCtl::get_ShowName);

	HRESULT hr = S_OK;

	if( NULL == pbUseName )
	{
		hr = E_POINTER;
	}
	else
	{
		*pbUseName = m_bUseName;
	}

	DBGEXIT_HR(CNmChatCtl::get_ShowName, hr);
	
	return hr;
}


STDMETHODIMP CNmChatCtl::put_Date(/*[in]*/ short bUseDate )
{
	DBGENTRY(CNmChatCtl::put_Date);

	m_bUseDate = bUseDate;

	DBGEXIT_HR(CNmChatCtl::put_Date, S_OK);
	
	return S_OK;
}

STDMETHODIMP CNmChatCtl::get_Date(/*[out]*/ short *pbUseDate )
{
	DBGENTRY(CNmChatCtl::get_Date);

	HRESULT hr = S_OK;

	if( NULL == pbUseDate )
	{
		hr = E_POINTER;
	}
	else
	{
		*pbUseDate = m_bUseDate;
	}

	DBGEXIT_HR(CNmChatCtl::get_Date, hr);
	
	return hr;
}

STDMETHODIMP CNmChatCtl::put_Timestamp(/*[in]*/ short bUseTimeStamp )
{
	DBGENTRY(CNmChatCtl::put_Timestamp);

	m_bTimeStamp = bUseTimeStamp;

	DBGEXIT_HR(CNmChatCtl::put_Timestamp, S_OK);
	
	return S_OK;
}

STDMETHODIMP CNmChatCtl::get_Timestamp(/*[out]*/ short *pbUseTimeStamp )
{
	DBGENTRY(CNmChatCtl::get_Timestamp);

	HRESULT hr = S_OK;

	if( NULL == pbUseTimeStamp )
	{
		hr = E_POINTER;
	}
	else
	{
		*pbUseTimeStamp = m_bTimeStamp;
	}

	DBGEXIT_HR(CNmChatCtl::get_Timestamp, hr);
	
	return hr;
}

void CNmChatCtl::_Resize(int x, int y, int cx, int cy)
{

	DBGENTRY(CNmChatCtl::_Resize);



	if( _IsEditWindowVisibleFlagSet() )
	{
		int iStatusBarHeight = _IsStatusBarVisibleFlagSet() ? STATUSBAR_HEIGHT : 0;
		int iMsgListY = MSGLIST_DLU_Y * m_iDLGUY;
		int iBetweenX = SPACING_DLU_X * m_iDLGUX;
		int iStaticHeight = m_iStaticY + STATIC_DLU_Y * m_iDLGUY;
		int iStaticStart = STATIC_DLU_Y * m_iDLGUY;

		HDWP hdwp = ::BeginDeferWindowPos(7);

		::DeferWindowPos(hdwp, m_hWndMsg, NULL,
			0,
			0,
			cx,
			cy-DYP_CHAT_SEND-iMsgListY-(iStaticHeight*2) - iStatusBarHeight,
			SWP_NOZORDER);
		
		::DeferWindowPos(hdwp, m_hWndStaticMessage, NULL,
			0,
			cy-DYP_CHAT_SEND-iMsgListY-iStaticHeight*2 + iStaticStart - iStatusBarHeight,
			m_iStaticLen,
			m_iStaticY,
			SWP_NOZORDER);
		
		::DeferWindowPos(hdwp, m_hWndEdit, NULL,
			0,
			cy-iMsgListY-iStaticHeight-DYP_CHAT_SEND - iStatusBarHeight,
			cx - DXP_CHAT_SEND - iBetweenX,
			DYP_CHAT_SEND,
			SWP_NOZORDER);
		
		::DeferWindowPos(hdwp, m_hWndSend, NULL,
			cx-DXP_CHAT_SEND,
			cy-iMsgListY-iStaticHeight-DYP_CHAT_SEND - iStatusBarHeight,
			DXP_CHAT_SEND,
			DYP_CHAT_SEND,
			SWP_NOZORDER);
		
		::DeferWindowPos(hdwp, m_hWndStaticSendTo, NULL,
			0,
			cy-iMsgListY-iStaticHeight + iStaticStart - iStatusBarHeight,
			m_iStaticLen,
			m_iStaticY,
			SWP_NOZORDER);

		::DeferWindowPos(hdwp, m_hWndMemberList, NULL,
			0,
			cy-iMsgListY - iStatusBarHeight,
			cx,
			ComboBoxEx_GetItemHeight(m_hWndMemberList, 0),
			SWP_NOZORDER);

		RECT rect;
	    ::GetClientRect(m_hWnd, &rect);
		 rect.top = rect.bottom - iStatusBarHeight;
	
		::DeferWindowPos(hdwp, m_hwndSB, NULL,
			rect.left, rect.top,
            rect.right - rect.left,
            rect.bottom - rect.top,
			SWP_NOZORDER);
	
		::EndDeferWindowPos(hdwp);


	}
	else
	{

		int iStatusBarHeight = _IsStatusBarVisibleFlagSet() ? STATUSBAR_HEIGHT : 0;

		::MoveWindow(m_hWndMsg,
			0, 0, cx, cy - iStatusBarHeight,
			TRUE);
	}


	DBGEXIT(CNmChatCtl::_Resize);
}

void CNmChatCtl::_LoadIconImages(void)
{
	
	DBGENTRY(CNmChatCtl::_LoadIconImages);

	COLORREF crTOOLBAR_MASK_COLOR = ( RGB( 255,   0, 255 ) );

	if( NULL == m_himlIconSmall )
	{
		m_himlIconSmall = ImageList_Create(DXP_ICON_SMALL, DYP_ICON_SMALL, ILC_MASK, 1, 0);
		if (NULL != m_himlIconSmall)
		{
			HBITMAP hBmp = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_CHAT_SMALL_ICON_IMAGES));
			if (NULL != hBmp)
			{
				ImageList_AddMasked(m_himlIconSmall, hBmp, crTOOLBAR_MASK_COLOR);
				::DeleteObject(hBmp);
			}
		}
	}

	DBGEXIT(CNmChatCtl::_LoadIconImages);
}

void CNmChatCtl::_FreeIconImages(void)
{

	DBGENTRY(CNmChatCtl::_FreeIconImages);

	if (NULL != m_himlIconSmall)
	{
		ImageList_Destroy(m_himlIconSmall);
		m_himlIconSmall = NULL;
	}	
	
	DBGEXIT(CNmChatCtl::_FreeIconImages);
}


HRESULT CNmChatCtl::_SendChatText(void)
{
	DBGENTRY(CNmChatCtl::_SendChatText);

	HRESULT hr = S_OK;
	
	TCHAR szMsg[CCHMAX_CHAT_MSG];

	// Get the text line
	int cb = (int)::SendMessage(m_hWndEdit, WM_GETTEXT, (WPARAM) CCHMAX(szMsg), (LPARAM) szMsg);
	if (0 != cb)
	{
		if (cb == 1)
		{
			szMsg[1] = ' ';
			szMsg[2] = 0;
			cb++;
		}
		// Delete the text in the edit box ( remember it is stored in szMsg )
		::SendMessage(m_hWndEdit, EM_SETSEL, (WPARAM) 0, (LPARAM)-1);
		::SendMessage(m_hWndEdit, WM_SETTEXT, (WPARAM) 0, (LPARAM) "");
		::SetFocus(m_hWndEdit); // reset the focus if we actually sent something

		MEMBER_CHANNEL_ID *pMemberID = (MEMBER_CHANNEL_ID*)_GetSelectedMember();
		MEMBER_ID			memberID;
		
	    TCHAR szName[MAX_PATH*2];
		szName[0] = '\0';
		CChatMessage::CHAT_MSGTYPE cmtype;
		LPTSTR szPerson = NULL;
		if( pMemberID == 0 )
		{
			cmtype = CChatMessage::MSG_SAY;
			memberID = MAKE_MEMBER_ID(0, g_pChatObj->m_broadcastChannel);
		}
		else
		{
			// Use the whisper
            memberID = MAKE_MEMBER_ID(pMemberID->nNodeId, pMemberID->nWhisperId);
			cmtype = CChatMessage::MSG_WHISPER;
			ULONG cb = T120_GetNodeName(g_pChatObj->m_nConfID,  pMemberID->nNodeId, szName, MAX_PATH*2);
		}

		_DisplayMsg( new CChatMessage( szName, szMsg, cmtype ) );
		
		if (g_pChatObj)
		{

			// Allocate a temporary buffer
			BYTE * pb = new BYTE[CB_NM2_HDR + (CCHMAX_CHAT_MSG * sizeof(WCHAR))];
			if (NULL != pb)
			{

				BYTE * pbData = pb+CB_NM2_HDR;

				// Initialize the header
				ZeroMemory(pb, CB_NM2_HDR);
				* ((LPDWORD) pb) = CB_NM2_HDR;

				cb++; // include final null
			#ifdef UNICODE
				lstrcpy(pbData, szMsg);
			#else
				cb = MultiByteToWideChar(CP_ACP, 0, szMsg, cb, (LPWSTR) pbData, CCHMAX_CHAT_MSG);
				cb *= 2; // adjust for UNICODE
			#endif //!UNICODE

				// Add special prefix
				cb += CB_NM2_HDR;

				hr = g_pChatObj->SendData(GET_USER_ID_FROM_MEMBER_ID(memberID), cb, (BYTE*)pb);

				delete pb;
			}
			else
			{
				ERROR_OUT(("Out of memory!!!"));
				hr = E_OUTOFMEMORY;

			}
		}
	}
	else
	{
		// There was no chat text

	}
	
	DBGEXIT_HR(CNmChatCtl::_SendChatText, hr);			

	return hr;
}


void  CNmChatCtl::_DataReceived(ULONG uSize, LPBYTE pb, T120ChannelID destinationID, T120UserID senderID)
{

	DBGENTRY(CNmChatCtl::DataReceived);

	ASSERT(uSize > CNmChatCtl::CB_NM2_HDR);
	LPTSTR psz = (LPTSTR) (pb + *(LPDWORD) pb);  // skip past header

#ifndef UNICODE
	// Convert UNICODE to ANSI
	char sz[CNmChatCtl::CCHMAX_CHAT_MSG];
	WideCharToMultiByte(CP_ACP, 0, (LPWSTR) psz, -1, sz, CNmChatCtl::
CCHMAX_CHAT_MSG, NULL, NULL);
	psz = sz;
#endif //

    TCHAR szPerson[MAX_PATH*2] = "\0";
	T120NodeID nodeID = ComboBoxEx_GetNodeIDFromSendID(m_hWndMemberList,  senderID );
	if (0 == nodeID)
	{
		nodeID = ComboBoxEx_GetNodeIDFromPrivateSendID(m_hWndMemberList, senderID);
	}
	ULONG cb = T120_GetNodeName(g_pChatObj->m_nConfID, nodeID, szPerson, MAX_PATH*2);

	// Display the message to the chat window
	_DisplayMsg(new CChatMessage( szPerson, psz,
		( destinationID == GET_USER_ID_FROM_MEMBER_ID(g_pChatObj->m_MyMemberID)) ?
		CChatMessage::MSG_WHISPER_FROM_OTHER : CChatMessage::MSG_FROM_OTHER ));


	DBGEXIT_HR(CNmChannelEventSink::DataReceived, S_OK);
}


inline void CNmChatCtl::_Write_Msg( LPTSTR pszText )
{
	ASSERT( NULL != pszText );
	::SendMessage( m_hWndMsg, EM_REPLACESEL, (WPARAM) FALSE, (WPARAM) pszText );
	m_cchBufferSize += lstrlen( pszText );
}

inline void CNmChatCtl::_Write_Msg_Range_Format( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& chatFormat )
{
	charRange.cpMin = m_cchBufferSize;
	charRange.cpMax = m_cchBufferSize;
	::SendMessage( m_hWndMsg, EM_EXSETSEL, 0L, (LPARAM) &charRange );
	::SendMessage( m_hWndMsg, EM_SETCHARFORMAT, (WPARAM)SCF_SELECTION, (LPARAM) &chatFormat );
	_Write_Msg( pszText );
}

inline void CNmChatCtl::_Write_Date_And_Time( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& chatFormat, CChatMessage *pChatMsg )
{
	if( m_bUseDate )
	{
		wsprintf( pszText, TEXT("%s\t"), pChatMsg->get_date() );
		_Write_Msg_Range_Format( pszText, charRange, chatFormat ) ;
	}
	if( m_bTimeStamp )
	{
		wsprintf( pszText, TEXT("%s\t"), pChatMsg->get_time() );
		_Write_Msg_Range_Format( pszText, charRange, chatFormat ) ;
	}
}

inline void CNmChatCtl::_Write_Name( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& chatFormat, CChatMessage *pChatMsg )
{
	if( m_bUseName )
	{
		wsprintf( pszText, TEXT("%s\t"), pChatMsg->get_person() );
		_Write_Msg_Range_Format( pszText, charRange, chatFormat );
	}
}

inline void CNmChatCtl::_Write_Own_Name( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& chatFormat )
{
	if( m_bUseName )
	{
		if(m_lpszOwnName == NULL)
		{
			RegEntry re(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
			LPCTSTR pcszName = re.GetString(REGVAL_ULS_NAME);
			
			DBG_SAVE_FILE_LINE
			m_lpszOwnName = new TCHAR[lstrlen(pcszName) + 1];
			wsprintf( m_lpszOwnName, TEXT("%s"),pcszName);
		}

		wsprintf( pszText, TEXT("%s\t"), m_lpszOwnName );
		_Write_Msg_Range_Format( pszText, charRange, chatFormat );
	}
}

inline void CNmChatCtl::_Write_Message( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& chatFormat, CChatMessage *pChatMsg )
{
	_Write_Msg_Range_Format( pChatMsg->get_message(), charRange, chatFormat );
	_Write_Msg_Range_Format( m_lpszRichEdEOL, charRange, chatFormat );
}

inline void CNmChatCtl::_Write_Private_In( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& chatFormat, CChatMessage *pChatMsg )
{
	wsprintf( pszText, TEXT("[%s]"), m_szPrivate );
	_Write_Msg_Range_Format( pszText, charRange, chatFormat );
	_Write_Message( pszText, charRange, chatFormat, pChatMsg );
}

inline void CNmChatCtl::_Write_Private_Out( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& chatFormat, CChatMessage *pChatMsg )
{
	wsprintf( pszText, TEXT("[%s %s %s] "), m_szPrivate, m_szTo, pChatMsg->get_person() );
	_Write_Msg_Range_Format( pszText, charRange, chatFormat );
	_Write_Message( pszText, charRange, chatFormat, pChatMsg );
}

inline void CNmChatCtl::_Write_New_Line_If_Needed( CHARRANGE& charRange, CHARFORMAT& chatFormat )
{
	if( MSGSTYLE_2_LINE_WRAP == m_style )
	{
		_Write_Msg_Range_Format( m_lpszRichEdEOL, charRange, chatFormat );

		::SendMessage( m_hWndMsg, EM_SETPARAFORMAT, 0, (LPARAM) &m_paraLine2 );
		::SendMessage( m_hWndMsg, EM_GETPARAFORMAT, 0, (LPARAM) &m_paraLine2 );
	}
}

inline void CNmChatCtl::_AddFontToCharFormat( CHARFORMAT& chatFormat, int i )
{
	chatFormat.dwMask |= CFM_COLOR | CFM_ALLCAPS | CFM_CHARSET | CFM_BOLD | CFM_FACE | CFM_ITALIC | CFM_SIZE | CFM_STRIKEOUT | CFM_UNDERLINE;

	chatFormat.crTextColor = m_hMsgColors[ i ];

	if( m_hMsgLogFonts[i].lfWeight >= FW_BOLD )
	{
		chatFormat.dwEffects |= CFE_BOLD;
	}
	if( m_hMsgLogFonts[i].lfItalic )
	{
		chatFormat.dwEffects |= CFE_ITALIC;
	}
	if( m_hMsgLogFonts[i].lfUnderline  )
	{
		chatFormat.dwEffects |= CFE_UNDERLINE;
	}
	if( m_hMsgLogFonts[i].lfStrikeOut  )
	{
		chatFormat.dwEffects |= CFE_STRIKEOUT;
	}
	chatFormat.yHeight = 20 * _Points_From_LogFontHeight( m_hMsgLogFonts[i].lfHeight, m_hWnd );

	chatFormat.bCharSet = m_hMsgLogFonts[i].lfCharSet;
	chatFormat.bPitchAndFamily = m_hMsgLogFonts[i].lfPitchAndFamily;
	lstrcpy( chatFormat.szFaceName, m_hMsgLogFonts[i].lfFaceName );
}

void CNmChatCtl::_DisplayMsg( CChatMessage *pChatMsg, BOOL bBatchRedraw /*= TRUE*/ )
{
	DBGENTRY(CNmChatCtl::_DisplayMsg);

	if( pChatMsg != NULL && !pChatMsg->IsValid() )
	{
		ERROR_OUT(( TEXT("CNmChatCtl::_DisplayMsg passed invalid message") ));
		return;
	}

	TCHAR pszText[CCHMAX_CHAT_MSG];
	
	CHARRANGE charRange;

	//
	// Start at the end of the last message
	//
	charRange.cpMin = m_cchBufferSize + 1;
	charRange.cpMax = m_cchBufferSize + 1;
	::SendMessage( m_hWndMsg, EM_EXSETSEL, 0L, (LPARAM) &charRange );


	CHARFORMAT chatFormat;
	ZeroMemory( &chatFormat, sizeof( chatFormat ) );
	chatFormat.cbSize = sizeof( chatFormat );

	::SendMessage( m_hWndMsg, EM_SETPARAFORMAT, 0, (LPARAM) &m_paraLine1 );
	::SendMessage( m_hWndMsg, EM_GETPARAFORMAT, 0, (LPARAM) &m_paraLine1 );

	CChatMessage::CHAT_MSGTYPE msgType = pChatMsg->get_type();
	switch( msgType )
	{
		case CChatMessage::MSG_WHISPER_FROM_OTHER:
		case CChatMessage::MSG_FROM_OTHER:
		case CChatMessage::MSG_WHISPER:
		case CChatMessage::MSG_SAY:
		{
			if( bBatchRedraw )
			{
				SNDMSG( m_hWndMsg, WM_SETREDRAW, FALSE, 0 );
			}
			switch( msgType )
			{
				case CChatMessage::MSG_WHISPER_FROM_OTHER:
				{
					_AddFontToCharFormat( chatFormat, CChatOptionsDlg::FONT_PRIVATEIN );
					break;
				}
				case CChatMessage::MSG_FROM_OTHER:
				{
					_AddFontToCharFormat( chatFormat, CChatOptionsDlg::FONT_MSGIN );
					break;
				}
				case CChatMessage::MSG_WHISPER:
				{
					_AddFontToCharFormat( chatFormat, CChatOptionsDlg::FONT_PRIVATEOUT );
					break;
				}
				case CChatMessage::MSG_SAY:
				{
					_AddFontToCharFormat( chatFormat, CChatOptionsDlg::FONT_MSGOUT );
					break;
				}
			}
				
			_Write_Date_And_Time( pszText, charRange, chatFormat, pChatMsg );

			if( pChatMsg->IsIncoming() )
			{
				_Write_Name( pszText, charRange, chatFormat, pChatMsg );
			}
			else
			{
				_Write_Own_Name( pszText, charRange, chatFormat );
			}

			_Write_New_Line_If_Needed( charRange, chatFormat );
			
			if( !pChatMsg->IsPrivate() )
			{
				_Write_Message( pszText, charRange, chatFormat, pChatMsg );
			}
			else if( pChatMsg->IsIncoming() )
			{
				_Write_Private_In( pszText, charRange, chatFormat, pChatMsg );
			}
			else
			{
				_Write_Private_Out( pszText, charRange, chatFormat, pChatMsg );
			}

			// Update message count
			m_cMessages++;

			m_dwChatFlags |= CHAT_FLAG_DIRTYBIT;

			if( bBatchRedraw )
			{
				SNDMSG( m_hWndMsg, WM_SETREDRAW, TRUE, 0 );
				::InvalidateRect( m_hWndMsg, NULL, INVALIDATE_BACKGROUND );
			}

			break;
		}
		case CChatMessage::MSG_SYSTEM:
		{
			_AddFontToCharFormat( chatFormat, CChatOptionsDlg::FONT_MSGSYSTEM );
			_Write_Message( pszText, charRange, chatFormat, pChatMsg );
			break;
		}
		default:
		{
			ERROR_OUT(( TEXT("CNmChatCtl::_DisplayMsg - Unknown Message Type") ));
			return;
			break;
		}
	}

	DBGEXIT(CNmChatCtl::_DisplayMsg);
}

HRESULT CNmChatCtl::_AddEveryoneInChat()
{
	DBGENTRY( CNmChatCtl::_AddEveryoneInChat );
	ASSERT( m_hWndMemberList );

	HRESULT hr = S_OK;

	int iImage = II_PERSON_PERSON;
	int iItem = 0;
	TCHAR szName[MAX_PATH];
	TCHAR szRes[MAX_PATH];

	lstrcpy( szName, RES2T( IDS_FILTER_ALL, szRes ) );

	COMBOBOXEXITEM cbexi;
	ClearStruct( &cbexi );
	cbexi.mask = CBEIF_LPARAM | CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE ;
	cbexi.iItem = iItem;
	cbexi.pszText = szName;
	cbexi.cchTextMax = lstrlen(cbexi.pszText);
	cbexi.iSelectedImage = iImage;
	cbexi.iImage = iImage;
	cbexi.lParam = (LPARAM) NULL;

	ComboBoxEx_InsertItem(m_hWndMemberList, &cbexi);
	ComboBoxEx_SetCurSel( m_hWndMemberList, 0 );

	DBGEXIT_HR( CNmChatCtl::_AddEveryoneInChat, hr );

	return hr;
}

HBITMAP CNmChatCtl::_GetHBITMAP( DWORD dwID )
{

    DBGENTRY(CNmChatCtl::_GetHBITMAP);

    HBITMAP hb = static_cast<HBITMAP>( LoadImage(g_hInstance, MAKEINTRESOURCE(dwID), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE));

    DBGEXIT(CNmChatCtl::_GetHBITMAP);

    return hb;
}


	// Delete item iIndex from the m_hWndMemberList list view and free the
	// pMember that is stored in the lParam of that item...
HRESULT CNmChatCtl::_DeleteMemberListItem( int iIndex )
{
	DBGENTRY(CNmChatCtl::_DeleteMemberListItem);

	HRESULT hr = S_OK;

	TCHAR szName[MAX_PATH];

    COMBOBOXEXITEM cbexi;
    ClearStruct( &cbexi );

	cbexi.iItem = iIndex;
    cbexi.mask = CBEIF_LPARAM | CBEIF_TEXT;
	cbexi.pszText = szName;
	cbexi.cchTextMax = CCHMAX(szName);

        // Find the item iIndex and get the Text and lParam data
    if( ComboBoxEx_GetItem( m_hWndMemberList, &cbexi ) )
    {

        if( CB_ERR == ComboBoxEx_DeleteItem(m_hWndMemberList, iIndex) )
		{
			WARNING_OUT(( "Could not delete %s from ComboBox", cbexi.pszText ));
		}
		
	}
	else
	{
			// There was an error...
		WARNING_OUT(("There was an error getting the list view item..."));
		DWORD dwErr = GetLastError();
		hr = HRESULT_FROM_WIN32( dwErr );
	}

	DBGEXIT_HR(CNmChatCtl::_DeleteMemberListItem, hr);

	return hr;
}


void CNmChatCtl::_DeleteAllListItems( void )
{
	DBGENTRY(CNmChatCtl::_DeleteAllListItems);

    int cItems = ComboBoxEx_GetCount( m_hWndMemberList );
    while( cItems-- )
    {   // Delete the first item in the list...
        int IndexOfFirstItemInList = 0;
        _DeleteMemberListItem( IndexOfFirstItemInList );
    }

	ComboBoxEx_SetCurSel( m_hWndMemberList, 0 );

    DBGEXIT(CNmChatCtl::_DeleteAllListItems);
}

HRESULT CNmChatCtl::_GetOwnName()
{
	DBGENTRY( CNmChatCtl::_GetOwnName );

	HRESULT hr = E_FAIL;

	DBGEXIT_HR( CNmChatCtl::_GetOwnName, hr );

	return( hr );
}


void CNmChatCtl::_UpdateContainerCaption( void )
{
	DBGENTRY(CNmChatCtl::_UpdateContainerCaption);

	TCHAR szCaption[MAX_PATH * 2];
	TCHAR szCaption2[MAX_PATH * 2];
	UINT captionID;
	UINT statusID;
	if (! g_pChatObj->IsInConference())
	{
		captionID = IDS_CHAT_NOT_IN_CALL_WINDOW_CAPTION;
		statusID = IDS_CHAT_STATUS_CHAT_NOT_ACTIVE;

	}
	else
	{
		captionID = IDS_CHAT_IN_CALL_WINDOW_CAPTION;
		statusID = IDS_CHAT_STATUS_CHAT_ACTIVE;

	}

   	::LoadString(g_hInstance, captionID, szCaption, sizeof(szCaption) );
   	
	wsprintf(szCaption2, szCaption, m_cOtherMembers);
	::SetWindowText(m_hWnd, szCaption2);

	_SetContainerStatusText( statusID );

	DBGEXIT(CNmChatCtl::_UpdateContainerCaption);
}

void CNmChatCtl::_CalculateFontMetrics()
{
	DBGENTRY(CNmChatCtl::_CalculateFontMetrics);

	ASSERT( m_hWndMsg );
	
	///// Get Info for RichEdit Box
	CHARFORMAT chfmt2;

	int yMaxHeightInTwips = 0;
	for( int i = 0; i < CChatOptionsDlg::FONT_COUNT; i++ )
	{
		ZeroMemory( &chfmt2, sizeof( chfmt2 ) );
		_AddFontToCharFormat( chfmt2, i );
		if( yMaxHeightInTwips < chfmt2.yHeight )
		{
			yMaxHeightInTwips = chfmt2.yHeight;
		}
	}

	TEXTMETRIC textmex;
	HDC hdc = ::GetDC( m_hWndMsg );
	::GetTextMetrics( hdc, &textmex );
	::ReleaseDC( m_hWndMsg, hdc );

	/*
	 * Average Width of Char in Twips         Average Width of Chars Logical Unit
	 * ------------------------------    =    -----------------------------------
	 *   Height of Char in Twips                  Height of Char in Logical Unit
	 *
	 */
	int iAveWidthInTwips = yMaxHeightInTwips * textmex.tmAveCharWidth / textmex.tmHeight;
	int iMaxWidthInTwips = yMaxHeightInTwips * textmex.tmMaxCharWidth / textmex.tmHeight;

	// Set the tabs on the two paragraph format rich edit things
	ZeroMemory( &m_paraLine1, sizeof( m_paraLine1 ) );
	m_paraLine1.cbSize = sizeof( m_paraLine1 );
	m_paraLine1.dwMask = PFM_OFFSET | PFM_TABSTOPS | PFM_STARTINDENT | PFM_RIGHTINDENT ;

	ZeroMemory( &m_paraLine2, sizeof( m_paraLine2 ) );
	m_paraLine2.cbSize = sizeof( m_paraLine2 );
	m_paraLine2.dwMask = PFM_OFFSET | PFM_TABSTOPS | PFM_STARTINDENT | PFM_RIGHTINDENT ;
	m_paraLine2.dxStartIndent = MULTILINE_MSG_OFFSET * iAveWidthInTwips;

	int iDelta = 0;
	if( m_bUseDate )
	{
		iDelta = DATE_EXTRA + GetDateFormat(
						LOCALE_USER_DEFAULT,		// locale for which date is to be formatted
						0,							// flags specifying function options
						NULL,						// time to be formatted
						NULL,						// time format string
						NULL,						// buffer for storing formatted string
						0							// size, in bytes or characters, of the buffer
						);

		iDelta *= iAveWidthInTwips;
		if( m_paraLine1.cTabCount )
		{
			m_paraLine1.rgxTabs[ m_paraLine1.cTabCount ] = m_paraLine1.rgxTabs[ m_paraLine1.cTabCount -1 ] + iDelta;
		}
		else
		{
			m_paraLine1.rgxTabs[ 0 ] = iDelta;
		}
		m_paraLine1.cTabCount++;
	}

	if( m_bTimeStamp )
	{
		iDelta = TIME_EXTRA + GetTimeFormat(
						LOCALE_USER_DEFAULT,		// locale for which date is to be formatted
						0,							// flags specifying function options
						NULL,						// time to be formatted
						NULL,						// time format string
						NULL,						// buffer for storing formatted string
						0							// size, in bytes or characters, of the buffer
						);

		iDelta *= iAveWidthInTwips;
		if( m_paraLine1.cTabCount )
		{
			m_paraLine1.rgxTabs[ m_paraLine1.cTabCount ] = m_paraLine1.rgxTabs[ m_paraLine1.cTabCount -1 ] + iDelta;
		}
		else
		{
			m_paraLine1.rgxTabs[ 0 ] = iDelta;
		}

		m_paraLine1.cTabCount++;
	}

	if( m_bUseName )
	{
		iDelta = (MAX_NAME + NAME_EXTRA) * iAveWidthInTwips;
		if( m_paraLine1.cTabCount )
		{
			m_paraLine1.rgxTabs[ m_paraLine1.cTabCount ] = m_paraLine1.rgxTabs[ m_paraLine1.cTabCount -1 ] + iDelta;
		}
		else
		{
			m_paraLine1.rgxTabs[ 0 ] = iDelta;
		}

		m_paraLine1.cTabCount++;
	}

	if( m_paraLine1.cTabCount )
	{
		m_paraLine1.dxOffset = m_paraLine1.rgxTabs[ m_paraLine1.cTabCount -1 ];
	}



	DBGEXIT(CNmChatCtl::_CalculateFontMetrics );
}

void CNmChatCtl::_SetContainerStatusText( UINT uID )
{
	DBGENTRY(CNmChatCtl::_SetContainerStatusText);

	TCHAR szStatus[MAX_RESOURCE_STRING_LEN] = "";
	NmCtlLoadString( uID, szStatus, CchMax(szStatus) );
	::SetWindowText(m_hwndSB, szStatus);
	
	DBGEXIT(CNmChatCtl::_SetContainerStatusText);
}


// Get the selected member from the m_hWndMemberList list view...
MEMBER_ID CNmChatCtl::_GetSelectedMember()
{
	DBGENTRY(CNmChatCtl::_GetSelectedMember);

	COMBOBOXEXITEM cbexi;
	ClearStruct( &cbexi );
	cbexi.mask = CBEIF_LPARAM;

	// Find the matching item
	if( CB_ERR == ( cbexi.iItem = ComboBoxEx_GetCurSel(m_hWndMemberList ) ) )
	{	
		ATLTRACE(("CNmChatCtl::_GetSelectedMember - no selection?\n"));
		DBGEXIT(CNmChatCtl::_GetSelectedMember);
		return 0;
	}

	ComboBoxEx_GetItem( m_hWndMemberList, &cbexi );

	MEMBER_ID memberID = (MEMBER_ID)( cbexi.lParam );

	DBGEXIT(CNmChatCtl::_GetSelectedMember);

	return memberID;
}




HRESULT CNmChatCtl::_AddMember(MEMBER_CHANNEL_ID *pMemberID)
{

	DBGENTRY(CNmChatCtl::_AddMember);

	HRESULT hr = S_OK;

	int iImage;
	int iItem = -1;
	TCHAR szName[MAX_PATH];

	if (GET_NODE_ID_FROM_MEMBER_ID(g_pChatObj->m_MyMemberID) != pMemberID->nNodeId)
	{

	    TCHAR szName[MAX_PATH*2];
		ULONG cb = T120_GetNodeName(g_pChatObj->m_nConfID,  pMemberID->nNodeId, szName, MAX_PATH*2);

		iImage = II_USER;

		COMBOBOXEXITEM cbexi;
		ClearStruct( &cbexi );
		cbexi.mask = CBEIF_LPARAM | CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE ;
		cbexi.iItem = iItem;
		cbexi.pszText = szName;
		cbexi.cchTextMax = lstrlen(cbexi.pszText);
		cbexi.iSelectedImage = iImage;
		cbexi.iImage = iImage;
		cbexi.lParam = (LPARAM) pMemberID;
		ComboBoxEx_InsertItem(m_hWndMemberList, &cbexi);
	}

	DBGEXIT_HR(CNmChatCtl::_AddMember, hr);
	return hr;

}

HRESULT CNmChatCtl::_RemoveMember(MEMBER_CHANNEL_ID *pMemberID)
{

	DBGENTRY(CNmChatCtl::_RemoveMember);

	HRESULT hr = S_OK;

	int iItem = ComboBoxEx_FindMember( m_hWndMemberList, -1, pMemberID);


	if( -1 != iItem )
	{
		_DeleteMemberListItem( iItem );
    }
    else
    {
        WARNING_OUT(("Could not find the specified item..."));
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

	DBGEXIT_HR(CNmChatCtl::_RemoveMember, hr);

	return hr;
}

HRESULT CNmChatCtl::_SetMenuItemCheck( UINT idItem, BOOL bChecked /* = true */ )
{
    DBGENTRY(CNmChatCtl::_SetMenuItemCheck);
    HRESULT hr = S_OK;
    if( m_hMenuShared )
    {
        MENUITEMINFO mii;
        ClearStruct(&mii);
        mii.cbSize = sizeof( MENUITEMINFO );
        mii.fMask = MIIM_STATE;
        mii.fState = bChecked ? MFS_CHECKED : MFS_UNCHECKED;

        if( !SetMenuItemInfo(m_hMenuShared, idItem, FALSE, &mii) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    DBGEXIT_HR(CNmChatCtl::_SetMenuItemCheck,hr);
    return hr;
}

bool CNmChatCtl::_IsEditWindowVisibleFlagSet(void)
{
    return ( ::IsWindow( m_hWndEdit ) && IsWindowVisible(m_hWndEdit));
}

bool CNmChatCtl::_IsStatusBarVisibleFlagSet(void)
{
    return ( ::IsWindow( m_hwndSB ) && IsWindowVisible(m_hwndSB));
}

int CNmChatCtl::_SaveAs()
{
	int iRet = 0;

	if( NULL == m_lpszSaveFile )
	{
		DBG_SAVE_FILE_LINE
		m_lpszSaveFile = new TCHAR[ MAX_PATH ];
		ASSERT( m_lpszSaveFile );
		ZeroMemory( m_lpszSaveFile, sizeof( m_lpszSaveFile ) );
	}

	if( SUCCEEDED( SaveDialog( m_lpszSaveFile, OFN_HIDEREADONLY | OFN_CREATEPROMPT, &m_wFileOffset ) ) )
	{
			// Since the file name has changed, we are dirty....
		m_dwChatFlags |= CHAT_FLAG_DIRTYBIT;

		_Save();
	}
	else
	{
		iRet = IDCANCEL;		
	}

	return iRet;
}


LRESULT CNmChatCtl::SaveDialog(LPTSTR lpszFile, DWORD dwFlags, LPWORD pnFileOffset )
{
    DBGENTRY(CNmChatCtl::SaveDialog)
    HRESULT hr = S_OK;

    TCHAR szFilter[MAX_PATH];
	TCHAR szDefExt[MAX_PATH];

    if( SUCCEEDED ( hr = _GetNmAppletFileOpenFilter( szFilter, CCHMAX( szFilter ), szDefExt, CCHMAX( szDefExt ) ) ) )
    {
        ConvertSzCh(szFilter);

        OPENFILENAME ofn;
        ClearStruct( &ofn );
        ofn.lStructSize = sizeof( OPENFILENAME );
        ofn.hwndOwner = m_hWnd;
        ofn.lpstrFilter = szFilter;
		ofn.lpstrFile = lpszFile;
        ofn.nMaxFile = MAX_PATH;
		ofn.lpstrDefExt = szDefExt;
        ofn.Flags = dwFlags;
        if( !GetSaveFileName( &ofn ) )
		{
			hr = E_FAIL;
		}
		else
		{
			*pnFileOffset = ofn.nFileOffset;
		}
    }

    DBGEXIT_HR(CNmChatCtl::SaveDialog,hr)
    return hr;
}

void CNmChatCtl::_SaveWindowPosition()
{
    RECT    rectWindow;

    // If we are not maximized
    if (!::IsZoomed(m_hWnd) && !::IsIconic(m_hWnd))
	{
	    // Get the new window rectangle
    	::GetWindowRect(m_hWnd, &rectWindow);

	    // Write the new option values to file
	    _SetWindowRectOption(&rectWindow);
	}

}


void CNmChatCtl::_SaveChatOptions()
{
	RegEntry reWnd( CHAT_KEY, HKEY_CURRENT_USER );

	reWnd.SetValue(OPT_MAIN_INFORMATION_DISPLAY_NAME, m_bUseName);
	reWnd.SetValue(OPT_MAIN_INFORMATION_DISPLAY_TIME, m_bTimeStamp);
	reWnd.SetValue(OPT_MAIN_INFORMATION_DISPLAY_DATE, m_bUseDate);
	reWnd.SetValue(OPT_MAIN_MESSAGE_FORMAT, m_style);

	for (int i = 0; i < CChatOptionsDlg::FONT_COUNT; i++ )
	{
		reWnd.SetValue( OPT_FONT_COLOR[i], &m_hMsgColors[i], sizeof(COLORREF));
		reWnd.SetValue( OPT_FONT_FORMAT[i], &m_hMsgLogFonts[i], sizeof(LOGFONT));
	}
}

BOOL CNmChatCtl::_LoadChatOptions()
{
	BOOL fRet = FALSE;
	int i;
	RegEntry reWnd(CHAT_KEY, HKEY_CURRENT_USER);
	LPVOID pData;

	for (i = 0; i < CChatOptionsDlg::FONT_COUNT; i++ )
	{	
		if (reWnd.GetBinary(OPT_FONT_COLOR[i], &pData) != sizeof(COLORREF))
			break;
		::CopyMemory(&m_hMsgColors[i], pData, sizeof(COLORREF));

		if (reWnd.GetBinary(OPT_FONT_FORMAT[i], &pData) != sizeof(LOGFONT))
			break;
		::CopyMemory(&m_hMsgLogFonts[i], pData, sizeof(LOGFONT));
	}
	if (i == CChatOptionsDlg::FONT_COUNT)
	{
		for (i = 0; i < CChatOptionsDlg::FONT_COUNT; i++ )
		{
			m_hMsgFonts[ i ] = CreateFontIndirect( &m_hMsgLogFonts[i] );
		}
		m_bUseName = (BOOL)reWnd.GetNumber(OPT_MAIN_INFORMATION_DISPLAY_NAME);
		m_bTimeStamp = (BOOL)reWnd.GetNumber(OPT_MAIN_INFORMATION_DISPLAY_TIME);
		m_bUseDate = (BOOL)reWnd.GetNumber(OPT_MAIN_INFORMATION_DISPLAY_DATE);
		m_style = (CNmChatCtl::eMsgStyles)reWnd.GetNumber(OPT_MAIN_MESSAGE_FORMAT);

		fRet = TRUE;
	}
	return fRet;
}


void CNmChatCtl::_Save()
{
	ASSERT( m_lpszSaveFile );

	if( 0 == (m_dwChatFlags & CHAT_FLAG_DIRTYBIT) )
	{
		return;
	}

	TCHAR szDrive[ MAX_PATH ];			
	lstrcpyn( szDrive, m_lpszSaveFile, m_wFileOffset + 1 );
	if( !FDirExists( szDrive ) )
	{
		TCHAR szBuffer[ 2 * MAX_PATH ];
		TCHAR szRes[MAX_PATH];

		wsprintf( szBuffer, RES2T( IDS_CHAT_CREATE_DIRECTORY, szRes ), szDrive );
		if( IDYES == MessageBox(m_hWnd, szBuffer, RES2T(IDS_CHAT_DOCUMENTNAME, szRes), MB_YESNO | MB_ICONQUESTION ) )
		{
			if( !FEnsureDirExists( szDrive ) )
			{
				wsprintf( szBuffer, RES2T( IDS_CHAT_COULD_NOT_CREATE_DIR, szRes ), szDrive );
				MessageBox(m_hWnd, szBuffer, RES2T(IDS_CHAT_DOCUMENTNAME, szRes), MB_OK | MB_ICONEXCLAMATION );
				return;
			}
		}
	}

	HANDLE hFile = CreateFile( m_lpszSaveFile,
								GENERIC_WRITE,
								0,
								NULL,
								CREATE_ALWAYS,
								0,
								NULL );
	if( INVALID_HANDLE_VALUE == hFile )
	{
		DWORD dw = GetLastError();
		switch( dw )
		{
			case ERROR_ACCESS_DENIED:
			{
				TCHAR szBuffer[ 2 * MAX_PATH ];
				TCHAR szRes[MAX_PATH];

				wsprintf( szBuffer, RES2T( IDS_CHAT_SAVE_ACCESS_DENIED, szRes ), m_lpszSaveFile );
				MessageBox(m_hWnd, szBuffer, RES2T(IDS_CHAT_DOCUMENTNAME, szRes), MB_OK | MB_ICONEXCLAMATION );
				break;
			}
			default:
			{
				TCHAR szBuffer[ 2 * MAX_PATH ];
				TCHAR szRes[MAX_PATH];

				wsprintf( szBuffer, RES2T( IDS_CHAT_SAVE_FAILED, szRes ), m_lpszSaveFile );
				MessageBox(m_hWnd, szBuffer, RES2T(IDS_CHAT_DOCUMENTNAME, szRes), MB_OK | MB_ICONEXCLAMATION );
				break;
			}
		}
	}
	else
	{
		LPTSTR szHeader1 = TEXT("<HTML>\n<HEAD>\n<TITLE>");
		LPTSTR szHeader2 = TEXT("</TITLE>\n</HEAD>\n<BODY BGCOLOR=\"white\" TEXT=\"black\">\n<TABLE BORDER=1>");
		LPTSTR szEnd = TEXT("</TABLE>\n</BODY>\n</HTML>\n");
		LPTSTR szStartRow = TEXT("<TR><TD>");
		LPTSTR szEndRow = TEXT("</TD></TR>");
		LPTSTR szSplitRow = TEXT("</TD><TD>");
		TCHAR  szPrivateTo[ MAX_PATH ];
		TCHAR  szPrivateFrom[ MAX_PATH ];
		TCHAR  szBuffer[ CCHMAX_CHAT_MSG ];
		DWORD dwWritten;

		NmCtlLoadString(IDS_CHAT_SAVE_PRIVATE_TO, szPrivateTo, MAX_PATH);
		NmCtlLoadString(IDS_CHAT_SAVE_PRIVATE, szPrivateFrom, MAX_PATH);

		WriteFile( hFile, szHeader1, lstrlen( szHeader1 ), &dwWritten, NULL );

		NmCtlLoadString(IDS_CHAT_DOCUMENTNAME, szBuffer, MAX_PATH);
		WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

		WriteFile( hFile, szHeader2, lstrlen( szHeader2 ), &dwWritten, NULL );

		CChatMessage *pMsg = CChatMessage::get_head();
		while( pMsg != NULL )
		{
			CChatMessage::CHAT_MSGTYPE style = pMsg->get_type();
			switch( style )
			{
				case CChatMessage::MSG_SAY:
				case CChatMessage::MSG_WHISPER:
				{

					WriteFile( hFile, szStartRow, lstrlen( szStartRow ), &dwWritten, NULL );

					lstrcpy( szBuffer, m_lpszOwnName );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szSplitRow, lstrlen( szSplitRow ), &dwWritten, NULL );

					lstrcpy( szBuffer, pMsg->get_date() );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szSplitRow, lstrlen( szSplitRow ), &dwWritten, NULL );

					lstrcpy( szBuffer, pMsg->get_time() );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szSplitRow, lstrlen( szSplitRow ), &dwWritten, NULL );

					if( CChatMessage::MSG_WHISPER == style )
					{
						wsprintf( szBuffer, szPrivateTo, pMsg->get_person() );
						WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );
					}

					lstrcpy( szBuffer, pMsg->get_message() );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szEndRow, lstrlen( szEndRow ), &dwWritten, NULL );
					break;
				}
				case CChatMessage::MSG_FROM_OTHER:
				case CChatMessage::MSG_WHISPER_FROM_OTHER:
				{
					WriteFile( hFile, szStartRow, lstrlen( szStartRow ), &dwWritten, NULL );

					lstrcpy( szBuffer, pMsg->get_person() );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szSplitRow, lstrlen( szSplitRow ), &dwWritten, NULL );

					lstrcpy( szBuffer, pMsg->get_date() );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szSplitRow, lstrlen( szSplitRow ), &dwWritten, NULL );

					lstrcpy( szBuffer, pMsg->get_time() );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szSplitRow, lstrlen( szSplitRow ), &dwWritten, NULL );

					if( CChatMessage::MSG_WHISPER_FROM_OTHER == style )
					{
						WriteFile( hFile, szPrivateFrom, lstrlen( szPrivateFrom ), &dwWritten, NULL );
					}

					lstrcpy( szBuffer, pMsg->get_message() );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szEndRow, lstrlen( szEndRow ), &dwWritten, NULL );
					break;
				}
				default:
				{
					break;
				}
			}
			pMsg = pMsg->get_next();
		};

		WriteFile( hFile, szEnd, lstrlen( szEnd ), &dwWritten, NULL );
		CloseHandle( hFile );

		m_dwChatFlags &= ~CHAT_FLAG_DIRTYBIT;
	}
}


inline BOOL CNmChatCtl::_IsPrinting()
{
	return( m_dwChatFlags & CHAT_PRINT_FLAG_PRINTING );
}

// From: KB Article ID: Q129860
// Modified by t-ivanl
void CNmChatCtl::_PrintIt(HDC hPrinterDC )
{
	DBGENTRY(CNmChatCtl::_PrintIt);

	FORMATRANGE		fr;
	int				nHorizRes =		GetDeviceCaps(hPrinterDC, HORZRES);
	int				nVertRes =		GetDeviceCaps(hPrinterDC, VERTRES);
	int				nLogPixelsX =	GetDeviceCaps(hPrinterDC, LOGPIXELSX);
	int				nLogPixelsY =	GetDeviceCaps(hPrinterDC, LOGPIXELSY);
	LONG			lTextLength = 0;   // Length of document.
	LONG			lTextPrinted = 0;  // Amount of document printed.
	TCHAR			lpszDateOrTime[ MAX_PATH ];
	TCHAR			lpszHeader[ MAX_PATH ];
	RECT            rcPrintLoc;

	// Ensure the printer DC is in MM_TEXT mode.
	SetMapMode ( hPrinterDC, MM_TEXT );

	// Rendering to the same DC we are measuring.
	ZeroMemory(&fr, sizeof(fr));
	fr.hdc = fr.hdcTarget = hPrinterDC;

	// Set up the page.
	fr.rcPage.left     = fr.rcPage.top = 0;
	fr.rcPage.right    = (nHorizRes/nLogPixelsX) * TWIPSPERINCH;
	fr.rcPage.bottom   = (nVertRes/nLogPixelsY) * TWIPSPERINCH;

	// Set up 1" margins all around.
	fr.rc.left   = fr.rcPage.left + TWIPSPERINCH;
	fr.rc.top    = fr.rcPage.top + TWIPSPERINCH;
	fr.rc.right  = fr.rcPage.right - TWIPSPERINCH;
	fr.rc.bottom = fr.rcPage.bottom - TWIPSPERINCH;

	// Default the range of text to print as the entire document.
	fr.chrg.cpMin = 0;
	fr.chrg.cpMax = -1;

	// Set up the print job (standard printing stuff here).
	DOCINFO di;
	ZeroMemory(&di, sizeof(di));
	di.cbSize = sizeof(DOCINFO);

	// Set the document name
	DBG_SAVE_FILE_LINE
	LPTSTR lpszDocName = new TCHAR[ MAX_PATH ];
	ASSERT( lpszDocName );
	NmCtlLoadString(IDS_CHAT_DOCUMENTNAME, lpszDocName, MAX_PATH);
	di.lpszDocName = lpszDocName;

	NmCtlLoadString(IDS_CHAT_HEADER, lpszHeader, MAX_PATH);
	GetDateFormat( LOCALE_USER_DEFAULT, 0, NULL, NULL, lpszDateOrTime, CCHMAX( lpszDateOrTime ) );
	lstrcat( lpszHeader, lpszDateOrTime );
	lstrcat( lpszHeader, TEXT(" " ) );
	GetTimeFormat( LOCALE_USER_DEFAULT, 0, NULL, NULL, lpszDateOrTime, CCHMAX( lpszDateOrTime ) );
	lstrcat( lpszHeader, lpszDateOrTime );

	GETTEXTLENGTHEX txtLength;
	txtLength.flags = GTL_NUMCHARS | GTL_PRECISE;
	txtLength.codepage = CP_ACP;

	int bufferSize = (int)::SendMessage( m_hWndMsg, EM_GETTEXTLENGTHEX, (WPARAM)&txtLength, 0 );
	if(bufferSize == E_INVALIDARG)
	{
		return;
	}

	lTextLength =bufferSize;


	if( lTextLength > 1 )
	{
		m_hWndPrint = ::CreateDialog( g_hInstance,
									MAKEINTRESOURCE( IDD_CHAT_PRINT ),
									m_hWnd,
									_PrintDlgProc );
		ASSERT( m_hWndPrint );

		SetAbortProc( hPrinterDC, _AbortProc );

		// Start the document.
		StartDoc(hPrinterDC, &di);

		while( (lTextPrinted < lTextLength) && (0 == (CHAT_PRINT_FLAG_ABORT & m_dwChatFlags) ) )
		{
			// Start the page.
			StartPage(hPrinterDC);

			// New Header print code for bugfix #29365 [mmaddin].
			rcPrintLoc.left   = nLogPixelsX;
			rcPrintLoc.top    = nLogPixelsY / 2;
			rcPrintLoc.right  = fr.rc.right;
			rcPrintLoc.bottom = fr.rc.bottom;
			DrawText( hPrinterDC, lpszHeader, lstrlen( lpszHeader ), &rcPrintLoc, 0);

			// Print as much text as can fit on a page. The return value is the
			// index of the first character on the next page.
			lTextPrinted = (LONG)::SendMessage(m_hWndMsg,
								      	EM_FORMATRANGE,
										FALSE,
										(LPARAM)&fr);
			if( 0 != lTextPrinted )
			{
				::SendMessage(m_hWndMsg, EM_DISPLAYBAND, 0, (LPARAM)&fr.rc);
			}

			// Print last page.
			EndPage(hPrinterDC);


			if(lTextPrinted < fr.chrg.cpMin)
			{
				break;
			}

			// If there is more text to print, adjust the range of characters to
			// start printing at the first character of the next page.
			if( 0 == lTextPrinted )
			{
				break;
			}
			else if (lTextPrinted < lTextLength)
			{
				fr.chrg.cpMin = lTextPrinted;
				fr.chrg.cpMax = -1;
			}
		}

		// Tell the control to release cached information.
		::SendMessage(m_hWndMsg, EM_FORMATRANGE, 0, (LPARAM)NULL);

		EndDoc(hPrinterDC);
	}

	delete [] lpszDocName;

	EndDialog( m_hWndPrint, 0 );

	DBGEXIT(CNmChatCtl::_PrintIt);
}

HRESULT CNmChatCtl::_Print()
{

	DBGENTRY(CNmChatCtl::_Print);
	HRESULT hr = E_FAIL;

	if( 0 == ( CHAT_PRINT_FLAG_PRINTDLG_INITIALIZED & m_dwChatFlags ) )
	{
		ZeroMemory( &m_PrintDlg, sizeof( m_PrintDlg ) );
		m_PrintDlg.lStructSize = sizeof( m_PrintDlg );
		m_PrintDlg.hwndOwner = m_hWnd;
		m_PrintDlg.Flags = PD_ALLPAGES | PD_NOPAGENUMS | PD_NOSELECTION | PD_RETURNDC | PD_DISABLEPRINTTOFILE;
		m_dwChatFlags |= CHAT_PRINT_FLAG_PRINTDLG_INITIALIZED;
	}
	
	BOOL b;
	if( FALSE != (b = PrintDlg( &m_PrintDlg ) ) )
	{
		ms_pThis = this;
		_PrintIt( m_PrintDlg.hDC );
		ms_pThis = NULL;
		hr = S_OK;
	}
	
	DBGEXIT_HR(CNmChatCtl::_Print, hr);

	return hr;
}

BOOL CALLBACK CNmChatCtl::_AbortProc( HDC hdcPrinter, int iCode )
{
	MSG msg;

	while( (0 == (CHAT_PRINT_FLAG_ABORT & ms_pThis->m_dwChatFlags) ) &&
		PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
	{
		if( NULL == ms_pThis->m_hWndPrint ||
			!::IsDialogMessage( ms_pThis->m_hWndPrint, &msg ) )
		{
			TranslateMessage( &msg );
			DispatchMessage( &msg );
		}
	}

	return(0 == (CHAT_PRINT_FLAG_ABORT & ms_pThis->m_dwChatFlags) );
}

INT_PTR CALLBACK CNmChatCtl::_PrintDlgProc( HWND hDlg,	UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	switch( uiMsg )
	{
		case WM_INITDIALOG:
		{
			return TRUE;
			break;
		}
		case WM_COMMAND:
		{
			switch( LOWORD( wParam ) )
			{
				case IDCANCEL:
				{
					ms_pThis->m_dwChatFlags |= CHAT_PRINT_FLAG_ABORT;
					//EndDialog( hDlg, CHAT_PRINT_FLAG_ABORT );
					return TRUE;
				}
			}
		}
	}
	return FALSE;
}

INT_PTR CALLBACK CNmChatCtl::_AboutDlgProc( HWND hDlg,	UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	switch( uiMsg )
	{
		case WM_INITDIALOG:
		{

            TCHAR   szFormat[256];
            TCHAR   szVersion[512];

            ::GetDlgItemText(hDlg, IDC_CHAT_ABOUT_VERSION, szFormat, 256);
            wsprintf(szVersion, szFormat, VER_PRODUCTRELEASE_STR,
                VER_PRODUCTVERSION_STR);
            ::SetDlgItemText(hDlg, IDC_CHAT_ABOUT_VERSION, szVersion);

			return TRUE;
			break;
		}
		case WM_QUIT:
		case WM_COMMAND:
		{
			EndDialog( hDlg, IDOK );
			return TRUE;
		}
	}
	return FALSE;
}





INT_PTR CALLBACK CChatOptionsDlg::_OptionsDlgProc( HWND hDlg,	UINT uiMsg, WPARAM wParam, LPARAM lParam )
{

	switch(uiMsg)
	{
		case WM_INITDIALOG:
			g_pChatWindow->m_pChatOptions->OnInit(hDlg);
			break;
			
		case WM_HELP:
			g_pChatWindow->m_pChatOptions->OnHelp(lParam);
			break;
			
		case WM_CONTEXTMENU:
			g_pChatWindow->m_pChatOptions->OnHelpWhatsThis(wParam);
			break;

		case WM_COMMAND:
			g_pChatWindow->m_pChatOptions->OnCommand(wParam);
			break;
	}

	return 0;
}


void CChatOptionsDlg::OnCommand(WPARAM wParam)
{

	switch( LOWORD( wParam ) )
	{
		case IDOK:
		OnOkClicked();
		break;
			
		case IDCANCEL:
		OnCancelClicked();
		break;
			
		case IDC_FONT_MSGOUT:
		case IDC_FONT_MSGIN:
		case IDC_FONT_PRIVATEOUT:
		case IDC_FONT_PRIVATEIN:
		OnFontClicked(LOWORD( wParam ));
		break;
	}
}








CChatOptionsDlg::CChatOptionsDlg( CNmChatCtl *pChatCtl )
		: m_pChatCtl( pChatCtl )
{
}


void CChatOptionsDlg::_DisplayFontNameAndSize( int iFont )
{
	TCHAR szBuffer[ MAX_PATH ];
	TCHAR szRes[MAX_PATH];


	ASSERT( iFont < FONT_COUNT );

	wsprintf( szBuffer, RES2T( IDS_CHAT_OPTIONS_FONT_FORMAT,szRes ),
			_Points_From_LogFontHeight( m_hMsgLogFonts[iFont].lfHeight, m_pChatCtl->GetHandle() ),
			m_hMsgLogFonts[iFont].lfFaceName );

	HWND hwndEdit = NULL;

	switch( iFont )
	{
		case FONT_MSGOUT:
		{
			hwndEdit = GetDlgItem(m_hOptionsDlg, IDC_EDIT_MSGOUT );
			break;
		}
		case FONT_MSGIN:
		{
			hwndEdit = GetDlgItem(m_hOptionsDlg, IDC_EDIT_MSGIN );
			break;
		}
		case FONT_PRIVATEOUT:
		{
			hwndEdit = GetDlgItem(m_hOptionsDlg, IDC_EDIT_PRIVATEOUT );
			break;
		}
		case FONT_PRIVATEIN:
		{
			hwndEdit = GetDlgItem(m_hOptionsDlg, IDC_EDIT_PRIVATEIN );
			break;
		}
	}
	::SetWindowText( hwndEdit, szBuffer );

}

LRESULT CChatOptionsDlg::OnInit(HWND hDlg)
{
	m_hOptionsDlg = hDlg;

	for( int i = 0; i < FONT_COUNT; i++ )
	{
		m_hMsgLogFonts[ i ] = m_pChatCtl->m_hMsgLogFonts[ i ];
		m_hMsgColors[ i ] = m_pChatCtl->m_hMsgColors[ i ];
		m_bDirtyFonts[ i ] = FALSE;
		_DisplayFontNameAndSize( i );
	}

	::SendMessage( GetDlgItem(m_hOptionsDlg, IDC_INCLUDE_NAME ),
		BM_SETCHECK,
		(WPARAM)m_pChatCtl->m_bUseName,
		0L );

	::SetFocus( GetDlgItem(m_hOptionsDlg, IDC_INCLUDE_NAME ));

		
	::SendMessage( GetDlgItem(m_hOptionsDlg, IDC_INCLUDE_DATE ),
		BM_SETCHECK,
		(WPARAM)m_pChatCtl->m_bUseDate,
		0L );
	::SendMessage( GetDlgItem(m_hOptionsDlg, IDC_INCLUDE_TIME ),
		BM_SETCHECK,
		(WPARAM)m_pChatCtl->m_bTimeStamp,
		0L );

	switch( m_pChatCtl->m_style )
	{
		case CNmChatCtl::MSGSTYLE_2_LINE_WRAP:
			::SendMessage( GetDlgItem(m_hOptionsDlg, IDR_NEW_LINE ),
				BM_SETCHECK,
				TRUE,
				0L );
			break;
		case CNmChatCtl::MSGSTYLE_1_LINE_WRAP:
			::SendMessage( GetDlgItem(m_hOptionsDlg, IDR_SAME_LINE ),
				BM_SETCHECK,
				TRUE,
				0L );
			break;
		case CNmChatCtl::MSGSTYLE_NO_WRAP:
			::SendMessage( GetDlgItem(m_hOptionsDlg, IDR_SINGLE_LINE ),
				BM_SETCHECK,
				TRUE,
				0L );
			break;
	}

	return 0L;
}

LRESULT CChatOptionsDlg::OnHelp(LPARAM lParam)
{
	DoHelp(lParam, _mpIdHelpChatOptions);
	return 0L;
}

LRESULT CChatOptionsDlg::OnHelpWhatsThis(WPARAM wParam)
{
	DoHelpWhatsThis(wParam, _mpIdHelpChatOptions);
	return 0L;
}


LRESULT CChatOptionsDlg::OnOkClicked()
{
	BOOL bChanged = FALSE;


	// View Fields
	BOOL bVal = (BOOL)::SendMessage( GetDlgItem(m_hOptionsDlg, IDC_INCLUDE_NAME ),
							BM_GETCHECK,
							0L,
							0L );
	bChanged = ( !m_pChatCtl->m_bUseName == !bVal ) ? bChanged : TRUE;
	m_pChatCtl->m_bUseName = (short)bVal;

	bVal = (BOOL)::SendMessage( GetDlgItem(m_hOptionsDlg, IDC_INCLUDE_TIME ),
							BM_GETCHECK,
							0L,
							0L );
	bChanged = ( !m_pChatCtl->m_bTimeStamp == !bVal ) ? bChanged : TRUE;
	m_pChatCtl->m_bTimeStamp = (short)bVal;

	bVal = (BOOL)::SendMessage( GetDlgItem(m_hOptionsDlg, IDC_INCLUDE_DATE ),
							BM_GETCHECK,
							0L,
							0L );
	bChanged = ( !m_pChatCtl->m_bUseDate == !bVal ) ? bChanged : TRUE;
	m_pChatCtl->m_bUseDate = (short)bVal;

	// Msg Style
	CNmChatCtl::MSGSTYLE style;
	if( ::SendMessage( GetDlgItem(m_hOptionsDlg, IDR_SINGLE_LINE ),
		BM_GETCHECK,
		0L,
		0L ) )
	{
		style = CNmChatCtl::MSGSTYLE_NO_WRAP;
	}
	else if( ::SendMessage( GetDlgItem(m_hOptionsDlg, IDR_SAME_LINE ),
		BM_GETCHECK,
		0L,
		0L ) )
	{
		style = CNmChatCtl::MSGSTYLE_1_LINE_WRAP;
	}
	else
	{
		style = CNmChatCtl::MSGSTYLE_2_LINE_WRAP;
	}

	bChanged = ( style == m_pChatCtl->get_MsgStyle() ) ? bChanged : TRUE;					

	// Fonts
	for( int i = 0; i < FONT_COUNT; i++ )
	{
		if( m_bDirtyFonts[i] )
		{
			m_pChatCtl->m_hMsgColors[ i ] = m_hMsgColors[ i ];
			m_pChatCtl->m_hMsgLogFonts[ i ] = m_hMsgLogFonts[ i ];
			DeleteObject( m_pChatCtl->m_hMsgFonts[i] );
			m_pChatCtl->m_hMsgFonts[i] = CreateFontIndirect( &m_pChatCtl->m_hMsgLogFonts[ i ] );
			bChanged = TRUE;
		}
	}
	if( bChanged )
	{
		m_pChatCtl->put_MsgStyle( style );
	}

	EndDialog(m_hOptionsDlg, IDOK );
	return 0L;
}

LRESULT CChatOptionsDlg::OnCancelClicked()
{
	EndDialog(m_hOptionsDlg, IDCANCEL );
	return 0L;
}

LRESULT CChatOptionsDlg::OnFontClicked(WORD wID)
{
	int iIndex = FONT_COUNT;

	switch( wID )
	{
		case IDC_FONT_MSGOUT:
		{
			iIndex = FONT_MSGOUT;
			break;
		}
		case IDC_FONT_MSGIN:
		{
			iIndex = FONT_MSGIN;
			break;
		}
		case IDC_FONT_PRIVATEOUT:
		{
			iIndex = FONT_PRIVATEOUT;
			break;
		}
		case IDC_FONT_PRIVATEIN:
		{
			iIndex = FONT_PRIVATEIN;
			break;
		}
		default:
			ASSERT( 0 );
	}

	CHOOSEFONT cf;
	ZeroMemory( &cf, sizeof( cf ) );
	cf.lStructSize = sizeof( cf );
	cf.hwndOwner = m_hOptionsDlg;
	cf.Flags = CF_FORCEFONTEXIST | CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT | CF_EFFECTS;
	cf.lpLogFont = &m_hMsgLogFonts[ iIndex ];
	cf.rgbColors = m_hMsgColors[ iIndex ];

	if( ChooseFont( &cf ) )
	{
		m_bDirtyFonts[ iIndex ] = TRUE;
		m_hMsgColors[ iIndex ] = cf.rgbColors;
		_DisplayFontNameAndSize( iIndex );
	}

	return 0L;
}



//
//
// Function: _GetWindowRectOption
//
// Purpose:  Retrieve a named option from the dictionary and convert it to
//           a window rectangle.  The rectangle is checked to make sure that
//           it is at least partially on screen, and not zero sized.
//
//
void _GetWindowRectOption(LPRECT pRect)
{
	RegEntry reWnd( CHAT_KEY, HKEY_CURRENT_USER );
	pRect->left = reWnd.GetNumber( REGVAL_WINDOW_XPOS, 0);
	pRect->top = reWnd.GetNumber( REGVAL_WINDOW_YPOS, 0);
	int cx = reWnd.GetNumber( REGVAL_WINDOW_WIDTH, 0);
	int cy = reWnd.GetNumber( REGVAL_WINDOW_HEIGHT, 0);
	pRect->right = pRect->left + cx;
	pRect->bottom = pRect->top + cy;

	int	iTop = pRect->top;
	int iLeft = pRect->left;
	int iBottom = pRect->bottom;
	int iRight = pRect->right;

	//
	// If it was an empty rect
	//
	if( !(pRect->bottom || pRect->top || pRect->left || pRect->right) )
	{
		MINMAXINFO lpmmi;
		g_pChatWindow->OnGetMinMaxInfo(&lpmmi);
		iTop = 50;
		iLeft = 50;
		iBottom = lpmmi.ptMinTrackSize.y + 100;
		iRight = lpmmi.ptMinTrackSize.x + 200;

		pRect->top = iTop;
		pRect->left = iLeft;
		pRect->bottom = iBottom;
		pRect->right = iRight;
		return;
	}
		
	// Make sure that the window rectangle is (at least partially) on
	// screen, and not too large.  First get the screen size
	int screenWidth  = ::GetSystemMetrics(SM_CXSCREEN);
	int screenHeight = ::GetSystemMetrics(SM_CYSCREEN);
   // Check the window size
	if ((iRight - iLeft) > screenWidth)
	{
		iRight = iLeft + screenWidth;
	}
	
	if ((iBottom - iTop) > screenHeight)
	{
		iTop = screenHeight;
	}

	// Check the window position
	if (iLeft >= screenWidth)
	{
		// Off screen to the right - keep the width the same
		iLeft  = screenWidth - (iRight - iLeft);
		iRight = screenWidth;
	}

	if (iRight < 0)
	{
		// Off screen to the left - keep the width the same
		iRight = iRight - iLeft;
		iLeft  = 0;
	}

	if (iTop >= screenHeight)
	{
		// Off screen to the bottom - keep the height the same
		iTop    = screenHeight - (iBottom - iTop);
		iBottom = screenHeight;
	}

    if (iBottom < 0)
	{
		// Off screen to the top - keep the height the same
		iBottom = (iBottom - iTop);
		iTop    = 0;
	}

	pRect->left = iLeft;
	pRect->top = iTop;
	pRect->right = iRight;
	pRect->bottom = iBottom;
}

//
//
// Function: SetWindowRectOption
//
// Purpose:  Write a window position rectangle
//
//
void _SetWindowRectOption(LPCRECT pcRect)
{
	RegEntry reWnd( CHAT_KEY, HKEY_CURRENT_USER );
	reWnd.SetValue( REGVAL_WINDOW_XPOS, pcRect->left );
	reWnd.SetValue( REGVAL_WINDOW_YPOS, pcRect->top );
	reWnd.SetValue( REGVAL_WINDOW_WIDTH, pcRect->right - pcRect->left );
	reWnd.SetValue( REGVAL_WINDOW_HEIGHT, pcRect->bottom - pcRect->top );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\nmagendaitemproppage.h ===
// NmAgendaItemPropPage.h : Declaration of the CNmAgendaItemPropPage

#ifndef __NMAGENDAITEMPROPPAGE_H_
#define __NMAGENDAITEMPROPPAGE_H_

#include "resource.h"       // main symbols

EXTERN_C const CLSID CLSID_NmAgendaItemPropPage;

/////////////////////////////////////////////////////////////////////////////
// CNmAgendaItemPropPage
class ATL_NO_VTABLE CNmAgendaItemPropPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNmAgendaItemPropPage, &CLSID_NmAgendaItemPropPage>,
	public IPropertyPageImpl<CNmAgendaItemPropPage>,
	public CDialogImpl<CNmAgendaItemPropPage>
{
public:
    bool m_bInitialized;

	CNmAgendaItemPropPage() 
	{
		m_dwTitleID = IDS_TITLENmAgendaItemPropPage;
		m_dwHelpFileID = IDS_HELPFILENmAgendaItemPropPage;
		m_dwDocStringID = IDS_DOCSTRINGNmAgendaItemPropPage;
        m_bInitialized = false;
	}

	enum {IDD = IDD_PROPPAGE_AGENDAITEM};

DECLARE_REGISTRY_RESOURCEID(IDR_NMAGENDAITEMPROPPAGE)
DECLARE_NOT_AGGREGATABLE(CNmAgendaItemPropPage)

BEGIN_COM_MAP(CNmAgendaItemPropPage) 
	COM_INTERFACE_ENTRY_IMPL(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CNmAgendaItemPropPage)
    MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog );
	CHAIN_MSG_MAP(IPropertyPageImpl<CNmAgendaItemPropPage>)
    COMMAND_HANDLER(IDC_EDITAGENDAITEMNAME, EN_CHANGE, OnAgendaItemNameChange)
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnAgendaItemNameChange(WORD wNotify, WORD wID, HWND hWnd, BOOL& bHandled);

	STDMETHOD(Apply)(void);
};


#endif //__NMAGENDAITEMPROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\nmctl1.h ===
// nmctl1.h : Declaration of the CNMChatObj

#ifndef __NMCHATOBJ_H_
#define __NMCHATOBJ_H_

#include <igccapp.h>
#include "resource.h"       // main symbols
#include <it120app.h>

typedef struct MEMBER_CHANNEL_ID
{
	T120NodeID		nNodeId;
	T120ChannelID	nSendId;
	T120ChannelID	nPrivateSendId;
	T120ChannelID	nWhisperId;
} MEMBER_CHANNEL_ID;

//
// Member ID
//
#define MAKE_MEMBER_ID(nid, uid)				(MAKELONG((nid), (uid)))
#define GET_NODE_ID_FROM_MEMBER_ID(id)          (LOWORD(id))
#define GET_USER_ID_FROM_MEMBER_ID(id)          (HIWORD(id))

//
// Member ID arrays, assuming 64 members
//
#define MAX_MEMBERS			128
static MEMBER_CHANNEL_ID g_aMembers[MAX_MEMBERS];
void MCSSendDataIndication(ULONG uSize, LPBYTE pb, T120ChannelID destinationID, T120UserID senderID);




/////////////////////////////////////////////////////////////////////////////
// CNMChatObj
class  CChatObj
{

public: // Construction/destruction and initialization
	CChatObj();
    ~CChatObj();

	//
	// T120 stuff
	//
	IT120Applet		*m_pApplet;
	IT120AppletSession	*m_pAppletSession;
	T120JoinSessionRequest	m_JoinSessionReq;
	T120ResourceRequest	m_resourceRequest;
	T120TokenRequest	m_tokenRequest;
	T120ConfID		m_nConfID;
	T120UserID		m_uidMyself;
	T120SessionID		m_sidMyself;
	T120EntityID		m_eidMyself;
	T120NodeID		m_nidMyself;
	T120ChannelID		m_broadcastChannel;
	MEMBER_CHANNEL_ID	*m_aMembers;
	BOOL			m_fInConference;
	MEMBER_ID		m_MyMemberID;
	UINT_PTR		m_nTimerID;

    GCCAppProtocolEntity    m_ChatProtocolEnt;
    GCCAppProtocolEntity   *m_pChatProtocolEnt;
    GCCAppProtEntityList    m_AppProtoEntList;
    GCCSimpleNodeList       m_NodeList;
	
	BOOL IsInConference(void) { return m_fInConference; }
    T120ConfID GetConfID(void) { return m_nConfID; }
    void OnPermitToEnroll(T120ConfID, BOOL fPermissionGranted);
    void OnJoinSessionConfirm(T120JoinSessionConfirm *);
    void OnAllocateHandleConfirm(GCCRegAllocateHandleConfirm *);
    void OnRosterIndication(ULONG cRosters, GCCAppRoster *apRosters[]);
    void OnRegistryEntryConfirm(GCCRegistryConfirm *);
    void CleanupPerConf(void);
	void LeaveT120(void);
	void SearchWhisperId(void);
	void InvokeApplet(void);

	T120Error SendData(T120UserID userID, ULONG cb, PBYTE pb);
};

#endif //__NMCHATOBJ_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\nmctl1.cpp ===
// ChatCtl.cpp : Implementation of DLL Exports.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f ChatCtlps.mk in the project directory.

#include "precomp.h"
#include "NmCtl1.h"
#include "Comboboxex.h"
#include <confguid.h>

BYTE   szStr[MAX_PATH];
GCCRequestTag GccTag;

extern CChatObj	*g_pChatObj;
extern CNmChatCtl	*g_pChatWindow;
extern HANDLE g_hWorkThread;

GUID guidNM2Chat = { 0x340f3a60, 0x7067, 0x11d0, { 0xa0, 0x41, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0 } };
#define cbKeyApp (4 + 1 + sizeof(GUID) + sizeof(DWORD))


static unsigned char H221IDGUID[5] = {H221GUIDKEY0,
                                      H221GUIDKEY1,
                                      H221GUIDKEY2,
                                      H221GUIDKEY3,
                                      H221GUIDKEY4};

static BYTE s_keyApp[cbKeyApp];

// Create an H.221 application key with a guid
VOID CreateH221AppKeyFromGuid(LPBYTE lpb, GUID * pguid)
{
	CopyMemory(lpb, H221IDGUID, sizeof(H221IDGUID));
	CopyMemory(lpb + sizeof(H221IDGUID), pguid, sizeof(GUID));
}


/*  S E T  A P P  K E Y */
/*----------------------------------------------------------------------------
    %%Function: SetAppKey

	Set the two pieces of an OctetString (the length and the data.)
	Note that the length always includes the terminating null character.
----------------------------------------------------------------------------*/
VOID SetAppKey(LPOSTR pOct, LPBYTE lpb)
{
	pOct->length = cbKeyApp;
	pOct->value = lpb;
}

/*  C R E A T E  A P P  K E Y */
/*----------------------------------------------------------------------------
    %%Function: CreateAppKey

	Given a guid and a userid, create the appropriate application key.

	The key is formated as:
	0xB5 0x00 0x53 0x4C  - Microsoft Object Identifier
	0x01                 - guid identifier
	<binary guid>        - guid data
	<dword node id>      - user node id
----------------------------------------------------------------------------*/
VOID CreateAppKey(LPBYTE lpb, GUID * pguid, DWORD dwUserId)
{
	CreateH221AppKeyFromGuid(lpb, pguid);
	CopyMemory(lpb + cbKeyApp - sizeof(DWORD), &dwUserId, sizeof(DWORD));
}


#define NODE_ID_ONLY			0x01
#define SEND_ID_ONLY			0x02
#define PRIVATE_SEND_ID_ONLY    0x04
#define WHISPER_ID_ONLY			0x08
#define ALL_IDS					0x10


/*
**  Return the array index of the first duplicate copy
*/
int IsAlreadyInArray(MEMBER_CHANNEL_ID *aArray, MEMBER_CHANNEL_ID *pMember, int nSize, int nFlag)
{
	int  i;

	for (i = 0; i < nSize; i++)
	{
		if (NODE_ID_ONLY == nFlag)
		{
			if (aArray[i].nNodeId == pMember->nNodeId)
				break;
		}
		else if (SEND_ID_ONLY == nFlag)
		{
			if (aArray[i].nSendId == pMember->nSendId)
			break;
		}
		else if (PRIVATE_SEND_ID_ONLY == nFlag)
		{
			if (aArray[i].nPrivateSendId == pMember->nPrivateSendId)
				break;
		}
		else if (WHISPER_ID_ONLY)
		{
			if (aArray[i].nWhisperId == pMember->nWhisperId)
				break;
		}
		else if (ALL_IDS == nFlag)
		{
			if ((aArray[i].nNodeId == pMember->nNodeId)&&
				(aArray[i].nSendId == pMember->nSendId)&&
				(aArray[i].nPrivateSendId == pMember->nPrivateSendId)&&
				(aArray[i].nWhisperId == pMember->nWhisperId))
			break;
		}
	}
	return (i < nSize)?i:-1;
}

void ChatTimerProc(HWND hWnd, UINT uMsg, UINT_PTR nTimerID, DWORD dwTime)
{
    if (g_pChatObj)
    {
        g_pChatObj->SearchWhisperId();
    }
}


#include "NmCtlDbg.h"
HINSTANCE   g_hInstance;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
        MyInitDebugModule();
		DisableThreadLibraryCalls(hInstance);
		g_hInstance = hInstance;
		DBG_INIT_MEMORY_TRACKING(hInstance);

        ::T120_AppletStatus(APPLET_ID_CHAT, APPLET_LIBRARY_LOADED);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (NULL != g_hWorkThread)
        {
            ::CloseHandle(g_hWorkThread);
        }
        ::T120_AppletStatus(APPLET_ID_CHAT, APPLET_LIBRARY_FREED);

        DBG_CHECK_MEMORY_TRACKING(hDllInst);
	    MyExitDebugModule();
    }
	return TRUE;    // ok
}



//
// T120 Applet Functions
//


void CALLBACK T120AppletCallbackProc
(
	T120AppletMsg 		*pMsg
)
{
	CChatObj *pCHATOBJ = (CChatObj *) pMsg->pAppletContext;
	if (pCHATOBJ == g_pChatObj)
	{
		switch (pMsg->eMsgType)
		{
		case GCC_PERMIT_TO_ENROLL_INDICATION:
			pCHATOBJ->OnPermitToEnroll(pMsg->PermitToEnrollInd.nConfID,
									 pMsg->PermitToEnrollInd.fPermissionGranted);
			break;

		case T120_JOIN_SESSION_CONFIRM:
		default:
			break;
		}
	}
}


void CALLBACK T120SessionCallbackProc
(
	T120AppletSessionMsg	*pMsg
)
{
	if(g_pChatObj == NULL)
	{
		return;
	}

	CChatObj *pSession = (CChatObj *) pMsg->pSessionContext;
    ASSERT(pMsg->pAppletContext == pMsg->pSessionContext);
	if (pSession == g_pChatObj)
	{
        ASSERT(pMsg->nConfID == pSession->GetConfID());
		switch (pMsg->eMsgType)
		{
        case MCS_UNIFORM_SEND_DATA_INDICATION:
		//
		// Check if we are receiving a indication from owrself
		//
		if(pMsg->SendDataInd.initiator == GET_USER_ID_FROM_MEMBER_ID(g_pChatObj->m_MyMemberID))
		{
			return;
		}
        case MCS_SEND_DATA_INDICATION:
				MCSSendDataIndication(
                        pMsg->SendDataInd.user_data.length,
                        pMsg->SendDataInd.user_data.value,
						pMsg->SendDataInd.channel_id,
                        pMsg->SendDataInd.initiator);
            break;

		case MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION:
//			m_fWaitingForBufferAvailable = FALSE;
			break;


        case GCC_APP_ROSTER_REPORT_INDICATION:
            pSession->OnRosterIndication((ULONG) pMsg->AppRosterReportInd.cRosters, pMsg->AppRosterReportInd.apAppRosters);
            break;

		case T120_JOIN_SESSION_CONFIRM:
			pSession->OnJoinSessionConfirm(&pMsg->JoinSessionConfirm);
			break;

        case GCC_RETRIEVE_ENTRY_CONFIRM:
			// Asynchronous Registry Retrieve Confirm message
			pSession->OnRegistryEntryConfirm(&pMsg->RegistryConfirm);
			break;

		default:
			break;
		}
	}
}


CChatObj::CChatObj() :
	m_pApplet(NULL),
	m_aMembers(&g_aMembers[0]),
	m_nTimerID(0)
{
	DBGENTRY(CChatObj::CChatObj);

	// Construct GCCAppProtEntityList
    ::ZeroMemory(&m_ChatProtocolEnt, sizeof(m_ChatProtocolEnt));
	m_ChatProtocolEnt.must_be_invoked = TRUE;
	m_ChatProtocolEnt.number_of_expected_capabilities = 0;
	m_ChatProtocolEnt.expected_capabilities_list = NULL;
	m_ChatProtocolEnt.startup_channel_type = MCS_DYNAMIC_MULTICAST_CHANNEL;

    // construct the applet key
	m_ChatProtocolEnt.session_key.application_protocol_key.key_type = APPLET_H221_NONSTD_KEY;
	SetAppKey(&m_ChatProtocolEnt.session_key.application_protocol_key.h221_non_standard_id, szStr);
	::CreateH221AppKeyFromGuid(szStr, (GUID *)&guidNM2Chat );

    // ape list
    m_pChatProtocolEnt = &m_ChatProtocolEnt;
	m_AppProtoEntList.cApes = 1;
	m_AppProtoEntList.apApes = &m_pChatProtocolEnt;

    // broadcast
	::ZeroMemory(&m_NodeList, sizeof(m_NodeList));

	// Cleanup per-conference T.120 info
	CleanupPerConf();

    // set the global pointer
	g_pChatObj = this;

	// T.120 Applet
	T120Error rc = ::T120_CreateAppletSAP(&m_pApplet);
	if (T120_NO_ERROR != rc)
	{
		ERROR_OUT(("CChatObj::CChatObj: cannot create applet SAP"));
		return;
	}

	ASSERT(NULL != m_pApplet);
	m_pApplet->Advise(T120AppletCallbackProc, this);

	DBGEXIT(CChatObj::CChatObj);
}

	
CChatObj::~CChatObj()
{

	DBGENTRY(CChatObj::~CChatObj);

	ASSERT(NULL == m_pAppletSession);
	ASSERT(NULL == m_pApplet);

	delete g_pChatWindow;

	DBGEXIT(CChatObj::~CChatObj);
}


void CChatObj::LeaveT120(void)
{
	// no more T.120
	if (NULL != m_pAppletSession)
	{
		m_pAppletSession->ReleaseInterface();
		CleanupPerConf();
	}
	if (NULL != m_pApplet)
	{
		m_pApplet->ReleaseInterface();
		m_pApplet = NULL;
	}
}


void CChatObj::OnPermitToEnroll
(
	T120ConfID			nConfID,
	BOOL				fPermissionGranted
)
{
	if (fPermissionGranted)
	{
		// We are not in a conference, right?
		ASSERT(NULL == m_pAppletSession);

		// Create an applet session
		T120Error rc = m_pApplet->CreateSession(&m_pAppletSession, nConfID);
		if (T120_NO_ERROR == rc)
		{
			ASSERT(NULL != m_pAppletSession);
			m_pAppletSession->Advise(T120SessionCallbackProc, this, this);

			// Build join-sesion request
			::ZeroMemory(&m_JoinSessionReq, sizeof(m_JoinSessionReq));
			m_JoinSessionReq.dwAttachmentFlags = ATTACHMENT_DISCONNECT_IN_DATA_LOSS | ATTACHMENT_MCS_FREES_DATA_IND_BUFFER;

			// Non standard key
			CreateAppKey(s_keyApp, &guidNM2Chat, 0);
			GCCObjectKey FAR * pObjKey;
			pObjKey = &m_JoinSessionReq.SessionKey.application_protocol_key;
			pObjKey->key_type = GCC_H221_NONSTANDARD_KEY;
			SetAppKey(&(pObjKey->h221_non_standard_id), s_keyApp);

			m_JoinSessionReq.SessionKey.session_id = m_sidMyself;
			m_JoinSessionReq.fConductingCapable = FALSE;
			m_JoinSessionReq.nStartupChannelType =MCS_DYNAMIC_MULTICAST_CHANNEL;

			//
			// Retrieve registry key
			//
			::ZeroMemory(&m_resourceRequest, sizeof(m_resourceRequest));
			m_resourceRequest.eCommand = APPLET_JOIN_DYNAMIC_CHANNEL;
			m_resourceRequest.RegKey.session_key = m_JoinSessionReq.SessionKey;
			SetAppKey(&m_resourceRequest.RegKey.resource_id, s_keyApp);
			m_JoinSessionReq.cResourceReqs = 1;
			m_JoinSessionReq.aResourceReqs = &m_resourceRequest;




			// Join now
			rc = m_pAppletSession->Join(&m_JoinSessionReq);
			if (T120_NO_ERROR == rc)
			{
                m_nConfID = nConfID;
            }
            else
            {
				WARNING_OUT(("CChatObj::OnPermitToEnroll: cannot join conf=%u, rc=%u", nConfID, rc));
			}
		}
	}
	else
	{
		if (NULL != m_pAppletSession)
		{
			T120RegistryRequest Req;
			::ZeroMemory(&Req, sizeof(Req));
			Req.eCommand = APPLET_DELETE_ENTRY;
			Req.pRegistryKey = &m_resourceRequest.RegKey;
			m_pAppletSession->RegistryRequest(&Req);

			m_pAppletSession->ReleaseInterface();
			CleanupPerConf();
		}
	}
}


void CChatObj::OnJoinSessionConfirm
(
	T120JoinSessionConfirm		*pConfirm
)
{
	if (NULL != m_pAppletSession)
	{
		ASSERT(m_pAppletSession == pConfirm->pIAppletSession);
		if (T120_RESULT_SUCCESSFUL == pConfirm->eResult)
		{
			m_uidMyself = pConfirm->uidMyself;
			m_sidMyself = pConfirm->sidMyself;
			m_eidMyself = pConfirm->eidMyself;
			m_nidMyself = pConfirm->nidMyself;

			// get the broadcast channel
			m_broadcastChannel = pConfirm->aResourceReqs[0].nChannelID;

			// create member ID
			m_MyMemberID = MAKE_MEMBER_ID(m_nidMyself, m_uidMyself);

			// we are now in the conference
			m_fInConference = TRUE;

			if(g_pChatWindow)
			{
				g_pChatWindow->_UpdateContainerCaption();
				g_pChatWindow->_AddEveryoneInChat();
			}

			// Invoke applet on other nodes (for interop with NM 2.x)
            InvokeApplet();

			// Register channel with GCC (for interop with NM 2.x)
			T120RegistryRequest Req;
			GCCRegistryKey		registry_key;
			BYTE				SessionKey[cbKeyApp];
			BYTE				ResourceKey[cbKeyApp];

			::ZeroMemory(&Req, sizeof(Req));
			Req.eCommand = APPLET_REGISTER_CHANNEL;
			::CopyMemory(&registry_key.session_key, 
					&m_resourceRequest.RegKey.session_key, sizeof(GCCSessionKey));
			CreateAppKey(SessionKey, &guidNM2Chat, 0);
			CreateAppKey(ResourceKey, &guidNM2Chat, m_nidMyself);
			SetAppKey(&registry_key.session_key.application_protocol_key.h221_non_standard_id, SessionKey);
			SetAppKey(&registry_key.resource_id, ResourceKey);
			Req.pRegistryKey = &registry_key;
			Req.nChannelID = m_uidMyself;

			m_pAppletSession->RegistryRequest(&Req);
					
		}
		else
		{
			WARNING_OUT(("CChatObj::OnJoinSessionConfirm: failed to join conference, result=%u. error=%u", pConfirm->eResult, pConfirm->eError));
			m_pAppletSession->ReleaseInterface();
			CleanupPerConf();
		}
	}
}


void CChatObj::InvokeApplet(void)
{
	m_ChatProtocolEnt.session_key.session_id = m_sidMyself;
	if (m_pAppletSession)
	{
		m_pAppletSession->InvokeApplet(&m_AppProtoEntList, &m_NodeList, &GccTag);
	}
}

void CChatObj::OnRosterIndication
(
    ULONG           cRosters,
    GCCAppRoster    *apRosters[]
)
{
	if (IsInConference())
	{
		BOOL fAdded = FALSE;
		BOOL fRemoved = FALSE;
		ULONG cOtherMembers = 0;
		ULONG i, j, k;

		// Caculate how many members in this session
		for (i = 0; i < cRosters; i++)
		{
			GCCAppRoster *pRoster = apRosters[i];

			// bail out if this roster is not for this session
			if (pRoster->session_key.session_id != m_sidMyself)
			{
					continue;
			}

			// node added or removed?
			fAdded |= pRoster->nodes_were_added;
			fRemoved |= pRoster->nodes_were_removed;

			// parse the roster records
			for (j = 0; j < pRoster->number_of_records; j++)
			{
				GCCAppRecord *pRecord = pRoster->application_record_list[j];
				// Because the flag is_enrolled_actively is not set correctly in 
				// NM 2.11, we don't bother to check it.
				// MEMBER_ID nMemberID = MAKE_MEMBER_ID(pRecord->node_id, pRecord->application_user_id);
				if (pRecord->node_id != m_nidMyself)
				{
					cOtherMembers++;
				}
				
			} // for
		} // for

		// If there are changes, we then do the update
		if (fAdded || fRemoved || cOtherMembers != g_pChatWindow->m_cOtherMembers)
		{
			MEMBER_CHANNEL_ID aTempMembers[MAX_MEMBERS]; // scratch copy

			// make sure we are able to handle it
			if (cOtherMembers >= MAX_MEMBERS)
			{
				ERROR_OUT(("CChatObj::OnRosterIndication: we hit the max members limit, cOtherMembers=%u, max-members=%u",
						cOtherMembers, MAX_MEMBERS));
				cOtherMembers = MAX_MEMBERS;
			}

			// reset the flags for members added and removed
			fAdded = FALSE;
			fRemoved = FALSE;

			// copy the members
			ULONG idxTempMember = 0;
			for (i = 0; i < cRosters; i++)
			{
				GCCAppRoster *pRoster = apRosters[i];

				// bail out if this roster is not for this session
				if (pRoster->session_key.session_id != m_sidMyself)
				{
					continue;
				}

				// parse the roster records
				for (j = 0; j < pRoster->number_of_records; j++)
				{
					GCCAppRecord *pRecord = pRoster->application_record_list[j];
					// Because of a bug in NM2.11, we don't check flag is_enrolled_actively
					// MEMBER_ID nMemberID = MAKE_MEMBER_ID(pRecord->node_id, pRecord->application_user_id);
					if (pRecord->node_id != m_nidMyself && idxTempMember < cOtherMembers)
					{
						aTempMembers[idxTempMember].nNodeId = pRecord->node_id;
						aTempMembers[idxTempMember].nSendId = aTempMembers[idxTempMember].nPrivateSendId =
							aTempMembers[idxTempMember].nWhisperId = pRecord->application_user_id;
						idxTempMember++;

						// let's see if it is an 'add' or a 'delete'
						for (k = 0; k <  g_pChatWindow->m_cOtherMembers; k++)
						{
							if (m_aMembers[k].nNodeId == pRecord->node_id)
							{
								::ZeroMemory(&m_aMembers[k], sizeof(MEMBER_CHANNEL_ID));
								break;
							}
						}
						fAdded |= (k >=  g_pChatWindow->m_cOtherMembers); // not found, must be new
					}
				} // for
			} // for

			// sanity check
			ASSERT(idxTempMember == cOtherMembers);

			// see if there are ones that are not in the new roster.
			// if so, they must be removed.
			for (k = 0; k <  g_pChatWindow->m_cOtherMembers; k++)
			{
				if (m_aMembers[k].nNodeId)
				{
					fRemoved = TRUE;
					g_pChatWindow->_RemoveMember(&m_aMembers[k]);
				}
			}

			// now, update the member array
			g_pChatWindow->m_cOtherMembers = cOtherMembers;
			if ( g_pChatWindow->m_cOtherMembers)
			{
				ASSERT(sizeof(m_aMembers[0]) == sizeof(aTempMembers[0]));
				::CopyMemory(&m_aMembers[0], &aTempMembers[0],  g_pChatWindow->m_cOtherMembers * sizeof(m_aMembers[0]));

				// Setup Send Channel Id
				int nDuplicates = 0;
				for (k = 0; k < g_pChatWindow->m_cOtherMembers; k++)
				{
					int nIndex = IsAlreadyInArray(m_aMembers, &m_aMembers[k], k, NODE_ID_ONLY);
					if (nIndex >= 0)
					{
						m_aMembers[nIndex].nSendId = m_aMembers[k].nSendId;
						nDuplicates++;
						m_aMembers[k].nNodeId = 0;
					}
				}

				// Remove all zeroed out regions
				if (nDuplicates)
				{
					k = 0;
					while (k < g_pChatWindow->m_cOtherMembers)
					{
						if (0 == m_aMembers[k].nNodeId)
						{
							for (i = k + 1; i < g_pChatWindow->m_cOtherMembers; i++)
							{
								if (m_aMembers[i].nNodeId)
									break;
							}
							if (i < g_pChatWindow->m_cOtherMembers)
							{
								m_aMembers[k] = m_aMembers[i];
								m_aMembers[i].nNodeId = 0;
							}
						}
						k++;
					}
				}
				g_pChatWindow->m_cOtherMembers -= nDuplicates;

				// Get the current selection
				MEMBER_CHANNEL_ID *pMemberID = (MEMBER_CHANNEL_ID*)g_pChatWindow->_GetSelectedMember();

				// Add the members to the list
				g_pChatWindow->_DeleteAllListItems();
				g_pChatWindow->_AddEveryoneInChat();
				for (k = 0; k < g_pChatWindow->m_cOtherMembers; k++)
				{
					g_pChatWindow->_AddMember(&m_aMembers[k]);
				}

				// Remove the bogus whisperId for Nm 2.x nodes
				BOOL fHasNM2xNode = FALSE;
				for (k = 0; k < g_pChatWindow->m_cOtherMembers; k++)
				{
					if (T120_GetNodeVersion(m_nConfID, m_aMembers[k].nNodeId) < 0x0404)
					{   // Version 2.x, give it a whisper id of 0
						m_aMembers[k].nWhisperId = 0;
						fHasNM2xNode = TRUE;
					}
				}

				if ((fHasNM2xNode)&&(!m_nTimerID))
				{   // time out every 1 sec
					m_nTimerID = ::SetTimer(NULL, 0, 1000,  ChatTimerProc);
				}

				//
				// Goto the current selection, if it is still there.
				//
				i = ComboBoxEx_FindMember(g_pChatWindow->GetMemberList(), 0, pMemberID);
				if(i == -1 )
				{
					i = 0;
				}
				ComboBoxEx_SetCurSel( g_pChatWindow->GetMemberList(), i );

			}

			g_pChatWindow->_UpdateContainerCaption();

		} // if any change
	} // if is in conf
}


void CChatObj::OnRegistryEntryConfirm(GCCRegistryConfirm *pRegistryConfirm)
{
	BOOL  fAllFound = TRUE;
	// This is generated by "m_pAppletSession->RegistryRequest(&Req)" above to
	// retrieve the channel id number of NM 2.x nodes
	if (T120_RESULT_SUCCESSFUL == pRegistryConfirm->nResult)
	{
		// Update the m_aWhisperIds array.
		T120NodeID nNodeId;
		::CopyMemory(&nNodeId, pRegistryConfirm->pRegKey->resource_id.value + cbKeyApp - sizeof(DWORD), 
			sizeof(T120NodeID));
		T120ChannelID nChannelId = pRegistryConfirm->pRegItem->channel_id;
		WARNING_OUT(("Receive registry: node id 0x%x, channel id 0x%x.\n",
						nNodeId, nChannelId));
		for (ULONG k = 0; k < g_pChatWindow->m_cOtherMembers; k++)
		{
			if (m_aMembers[k].nNodeId == nNodeId)
			{
				m_aMembers[k].nWhisperId = nChannelId;
			}
			if (fAllFound && (0 == m_aMembers[k].nWhisperId))
			{
				fAllFound = FALSE;
				WARNING_OUT(("Node 0x%x is still not updated.\n", 
							m_aMembers[k].nNodeId));
			}
		}
		if (fAllFound)
		{
			::KillTimer(NULL, m_nTimerID);
			m_nTimerID = 0;
			WARNING_OUT(("All updated. Kill timer.\n"));
		}
	}
}



void CChatObj::CleanupPerConf(void)
{
	m_fInConference = FALSE;
	m_pAppletSession = NULL;
	m_MyMemberID = 0;
    m_nConfID = 0;      // Conf ID
	m_uidMyself = 0;	// User ID
	m_sidMyself = 0;	// Session ID
	m_eidMyself = 0;	// Entity ID
	m_nidMyself = 0;	// Node ID
	if(g_pChatWindow)
	{
		g_pChatWindow->m_cOtherMembers = 0;
		g_pChatWindow->_UpdateContainerCaption();
		g_pChatWindow->_DeleteAllListItems();
	}
}


T120Error CChatObj::SendData
(
	T120UserID		userID,
    ULONG           cbDataSize,
    PBYTE           pbData
)
{
	T120Error rc;

	if (IsInConference())
	{
    	rc = m_pAppletSession->SendData(
                            NORMAL_SEND_DATA,
                            userID,
                            APPLET_LOW_PRIORITY,
                            pbData,
                            cbDataSize,
                            APP_ALLOCATION);
	}
	else
	{
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

    return rc;
}


void CChatObj::SearchWhisperId(void)
{
	T120RegistryRequest Req;
	GCCRegistryKey		registry_key;
	BYTE				SessionKey[cbKeyApp];
	BYTE				ResourceKey[cbKeyApp];

    if (NULL != m_pAppletSession)
    {
	    // Set up T120RegistryRequest
        ZeroMemory(&Req, sizeof(Req));
    	Req.eCommand = APPLET_RETRIEVE_ENTRY;
	    ::CopyMemory(&registry_key.session_key, 
			&m_resourceRequest.RegKey.session_key, sizeof(GCCSessionKey));
    	CreateAppKey(SessionKey, &guidNM2Chat, 0);
	    SetAppKey(&registry_key.session_key.application_protocol_key.h221_non_standard_id, SessionKey);
    	SetAppKey(&registry_key.resource_id, ResourceKey);
	    Req.pRegistryKey = &registry_key;

    	for (ULONG i = 0; i < g_pChatWindow->m_cOtherMembers; i++)
	    {
		    if (m_aMembers[i].nWhisperId == 0)
		    {
			    CreateAppKey(ResourceKey, &guidNM2Chat, m_aMembers[i].nNodeId);
    			m_pAppletSession->RegistryRequest(&Req);
	    		WARNING_OUT(("Send search registry for node 0x%x.\n", m_aMembers[i].nNodeId));
		    }
        }
	}
}


void MCSSendDataIndication(ULONG uSize, LPBYTE pb, T120ChannelID destinationID, T120UserID senderID)
{
	if(g_pChatWindow)
	{
		g_pChatWindow->_DataReceived(uSize, pb, destinationID, senderID);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\nmctldbg.h ===
#ifndef __NmCtlDbg_h__
#define __NmCtlDbg_h__

#ifdef _DEBUG

    
    #ifdef ATLTRACE
        #undef ATLTRACE
    #endif 

    void DbgZPrintAtlTrace(LPCTSTR pszFormat,...);
    bool MyInitDebugModule(void);
    void MyExitDebugModule(void);

    #define ZONE_ATLTRACE   3
    #define ZONE_ATLTRACE_FLAG 0x08
    #define ATLTRACE DbgZPrintAtlTrace

#else

    inline bool MyInitDebugModule(void) { return true; }
    inline void MyExitDebugModule(void) { ; }

#endif // _DEBUG



#endif // __NmCtlDbg_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\nmctldbg.cpp ===
#include "precomp.h"
#include "NmCtlDbg.h"


#ifdef _DEBUG

    static PTCHAR _rgZones[] = {
	    TEXT("NmCtl1"),
	    TEXT("Warning"),
	    TEXT("Trace"),
	    TEXT("Function"),
	    TEXT("AtlTrace")
    };

    bool MyInitDebugModule(void)
    {
        g_pcszSpewModule = _rgZones[0];
	    DBGINIT(&ghDbgZone, _rgZones);
	    return true;
    }

    void MyExitDebugModule(void)
    {
	    g_pcszSpewModule = NULL;
	    DBGDEINIT(&ghDbgZone);
    }


    void DbgZPrintAtlTrace(LPCTSTR pszFormat,...)
    {
	    if (GETZONEMASK(ghDbgZone) & ZONE_ATLTRACE_FLAG)
	    {
		    va_list v1;
		    va_start(v1, pszFormat);
            DbgPrintf(NULL, pszFormat, v1 );
		    va_end(v1);
	    }
    }



#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\nmchatctl.h ===
#ifndef __NMCHATCTL_H_
#define __NMCHATCTL_H_


// Includes
#include "resource.h" 
#include "richedit.h"
#include "message.h"
#include <confreg.h>
#include <gencontrols.h>
#include <gencontainers.h>

#include "Chatldr.h"
typedef ULONG_PTR	MEMBER_ID;				// loword = node_id, hiword = user_id



extern HINSTANCE   g_hInstance;
#define STRING_RESOURCE_MODULE g_hInstance
#define RES2T(uID, psz ) ( Res2THelper( uID, psz, RES_CH_MAX ) )


#include <standrd.h>

#define DECLARE_NMAPPLET_FILE_OPEN_FILTER(idStringResourceFilter, idStringResourceExt) \
static HRESULT _GetNmAppletFileOpenFilter( LPTSTR szFilter, int cchMaxFilter, LPTSTR szExtension, int cchMaxExtension )\
{	HRESULT hr = S_OK;\
	DBGENTRY(_GetNmAppletFileOpenFilter);\
	if( SUCCEEDED( hr = NmCtlLoadString( idStringResourceFilter, szFilter, cchMaxFilter ) ) )\
	{\
		hr = NmCtlLoadString( idStringResourceExt, szExtension, cchMaxExtension );\
	}\
	DBGEXIT_HR(_GetNmAppletFileOpenFilter,hr);\
    return hr;\
}



//
// Extra windows messages for the chat
//
enum
{
    WM_USER_BRING_TO_FRONT_WINDOW  =   WM_USER,
};

#define RES_CH_MAX 256


#define MAX_FONT_SIZE       20
#define STATUSBAR_HEIGHT    (MAX_FONT_SIZE + 2*::GetSystemMetrics(SM_CYEDGE))


// Forward Decls
class CNmChatCtl;
class CChatOptionsDlg;

#define PIX_FROM_DLGU_X( XDLGU, XDBU )  MulDiv(XDLGU, XDBU, 4 )
#define PIX_FROM_DLGU_Y( YDLGU, YDBU )  MulDiv(YDLGU, YDBU, 8 ) 

#define CHAT_FLAG_NONE								0
#define CHAT_PRINT_FLAG_PRINTING					1
#define CHAT_PRINT_FLAG_PRINTDLG_INITIALIZED		2
#define CHAT_PRINT_FLAG_ABORT						4
#define CHAT_FLAG_DIRTYBIT							8

#define TWIPSPERINCH								1440

#define ICON_BIG_SIZE								32
#define ICON_SMALL_SIZE								16

#define INVALIDATE_BACKGROUND						FALSE


void _SetWindowRectOption(LPCRECT pcRect);
void _GetWindowRectOption(LPRECT pRect);




/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CChatOptionsDlg
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CChatOptionsDlg
{
friend CNmChatCtl;

private:
	enum { FONT_MSGOUT,
			FONT_MSGIN,
			FONT_PRIVATEOUT,
			FONT_PRIVATEIN,
			FONT_MSGSYSTEM,
			FONT_COUNT
	};

	CNmChatCtl	*m_pChatCtl;
	LOGFONT		m_hMsgLogFonts[ FONT_COUNT ];
	COLORREF	m_hMsgColors[ FONT_COUNT ];
	BOOL		m_bDirtyFonts[ FONT_COUNT ];

public:
	static WORD	IDD;

private:

public:
	CChatOptionsDlg( CNmChatCtl *pChatCtl );
	static INT_PTR CALLBACK _OptionsDlgProc( HWND hDlg,UINT uiMsg, WPARAM wParam, LPARAM lParam );
	void OnCommand(WPARAM wParam);

private:
	
	HWND	m_hOptionsDlg;
	LRESULT OnInit(HWND hDlg);
	LRESULT OnHelp(LPARAM lParam);
	LRESULT OnHelpWhatsThis(WPARAM wParam);
	LRESULT OnOkClicked();
	LRESULT OnCancelClicked();
	LRESULT OnFontClicked(WORD wID);
	void _DisplayFontNameAndSize( int iFont );
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CNmChatCtl
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

struct MEMBER_CHANNEL_ID;

class CNmChatCtl
{
friend CChatOptionsDlg;

public:  // Data Decls

    enum eWndIDs{ MsgWndID = 1,
				  MemberListWndID,
				  EditWndID,
                  SendWndID,
				  StaticMessageID,
				  StaticSendToID
    };

    enum eStates { state_Idle,
                   state_MessageWaiting
    };

	enum eMenuPos { MENUPOS_FILE = 0,
					MENUPOS_EDIT,
					MENUPOS_VIEW,
					MENUPOS_HELP
	};

private: // Data Decls
        // Constants
    enum {DXP_ICON_SMALL = 16 };
	enum {DYP_ICON_SMALL = 16 };
	enum {DYP_CHAT_EDIT = 46 };
	enum {DYP_CHAT_USERS = 46 };
	enum {DXP_CHAT_SEND = 46 };
	enum {DYP_CHAT_SEND = 46 };
	enum {DXP_CHAT_DEST = 100 };
	enum {CCHMAX_CHAT_MSG = 2048 };
	enum {CB_NM2_HDR = 8 };
	enum {ILV_NAME = 0 };
	enum {ILV_TIME = 1 };
	enum {ILV_TEXT = 2 };
	enum {MSG_EXTRA = 4 };
	enum {MAX_DATE = 10 };
	enum {DATE_EXTRA = 1 };
	enum {TIME_EXTRA = 1 };
	enum {MAX_NAME = 15 };
	enum {NAME_EXTRA = 1 };
	enum {MULTILINE_MSG_OFFSET = 5 };
	enum {MSGLIST_DLU_Y = 14 };
	enum {MSGLIST_VISMEMBERS = 5 };
	enum {SPACING_DLU_X = 4 };
	enum {STATIC_DLU_Y = 4 };

	// menu item group constants
    CONSTANT( CHAT_WITH_FILEMENU_NUM_EDITGROUP_ITEMS = 3 );
    CONSTANT( CHAT_WITH_FILEMENU_NUM_OBJECTGROUP_ITEMS = 0 );
    CONSTANT( CHAT_WITH_FILEMENU_NUM_HELPGROUP_ITEMS = 1 );
    CONSTANT( CHAT_WITHOUT_FILEMENU_NUM_EDITGROUP_ITEMS = 1 );
    CONSTANT( CHAT_WITHOUT_FILEMENU_NUM_OBJECTGROUP_ITEMS = CHAT_WITH_FILEMENU_NUM_OBJECTGROUP_ITEMS );
    CONSTANT( CHAT_WITHOUT_FILEMENU_NUM_HELPGROUP_ITEMS  = CHAT_WITH_FILEMENU_NUM_HELPGROUP_ITEMS );


        // These are the icon indices for the listview icon bitmaps
    enum { II_PERSON_PERSON = 1,
           II_EXCLAMATION = 14,
           II_USER = 16
    };

	typedef enum eMsgStyles
	{
		MSGSTYLE_2_LINE_WRAP,
		MSGSTYLE_1_LINE_WRAP,
		MSGSTYLE_NO_WRAP
	} MSGSTYLE;

protected: // Data


	HWND m_hWnd;
    HACCEL     m_hAccelTable;

	static	   CNmChatCtl	*ms_pThis;

	ULONG	   m_cchBufferSize;
    HIMAGELIST m_himlIconSmall;
	HINSTANCE  m_hInstRichEd32;
		
	LPTSTR     m_lpszOwnName;
	LPTSTR     m_szPrivate;
	LPTSTR     m_szTo;
	int		   m_iExtra;
	int        m_iNameLen;

	LPTSTR		m_lpszRichEdEOL;
	LPTSTR		m_lpszRichEd;

	// Msg fonts and colors
	COLORREF	m_hMsgColors[ CChatOptionsDlg::FONT_COUNT ];
	HFONT		m_hMsgFonts[ CChatOptionsDlg::FONT_COUNT ];
	LOGFONT		m_hMsgLogFonts[ CChatOptionsDlg::FONT_COUNT ];

	// UI sizing
	int			m_iStaticLen;
	int			m_iDLGUY;
	int			m_iDLGUX;
	int			m_iStaticY;

	// Msg style formats
	PARAFORMAT m_paraLine1;
	PARAFORMAT m_paraLine2;

	DWORD		m_dwChatFlags;

	// For printing
	PRINTDLG	m_PrintDlg;
	HWND		m_hWndPrint;

	// Count of messages in conference for whether or not to display conference ended
	ULONG		m_cMessages;

	// Saving
	LPTSTR		m_lpszSaveFile;
	WORD		m_wFileOffset;

    // Window stuff    
	HWND			 m_hWndMsg;         // Message window alias

	HWND	m_hWndMemberList;  // Destination (0=everyone)
	HWND	m_hWndEdit;        // Edit control
	HWND	m_hWndSend;        // Send Button
	HWND	m_hWndStaticMessage;
	HWND	m_hWndStaticSendTo;
	HWND	m_hwndSB;			// Status bar

	CBitmapButton  * m_pButton;

	
    BOOL             m_bWeAreActiveApp;

    HMENU m_hMenuShared;

	BOOL			m_bStatusBarVisible;


	// Properties
	short											m_bUseName;
	short											m_bTimeStamp;
	short											m_bUseDate;
	MSGSTYLE										m_style;


public: // Construction/destruction and initialization
	CNmChatCtl();
    ~CNmChatCtl();

    ULONG	m_cOtherMembers;
	HWND	GetMemberList(){return m_hWndMemberList;}

protected:

	static LRESULT ChatMainWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);



        // Window Message and Command Handling functions for Main Window
	LRESULT OnCreate(WPARAM wParam, LPARAM lParam);
    LRESULT OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnCharEditWnd(UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT OnInitMenuPopup(WPARAM wParam, LPARAM lParam);
	void OnSendClicked(void);
	LRESULT SaveDialog(LPTSTR lpszFile, DWORD dwFlags, LPWORD pnFileOffset );
    void cmdFileSave(void);
    void cmdFileSaveAs(void);
    void cmdFilePrint(void);
	void cmdFileExit(WPARAM wparam);
    void cmdViewStatusBar(void);

	LRESULT OnNotifyEnLink(ENLINK *pEnLink);
	LRESULT OnContextMenu(short, short);

    void cmdViewEditWindow(void);
    void cmdViewOptions(void);
    void cmdEditCut(void);
    void cmdEditCopy(void);
    void cmdEditPaste(void);
    void cmdEditClearAll(void);
    void cmdHelpHelpTopics(void);
    void cmdHelpAboutChat(void);
 

protected:
	STDMETHOD(OnMenuSelect)( IN DWORD wParam, IN DWORD lParam );
	STDMETHOD(OnCommand)( IN WPARAM wParam, IN LPARAM lParam );

protected:
        // INmChatCtl Interface implementation
	STDMETHOD(ResetView)();

        // These may be in the interface is the future...
	STDMETHOD(put_ShowName)(/*[in]*/ short bShowName );
	STDMETHOD(get_ShowName)(/*[out]*/ short *pbShowName );
	STDMETHOD(put_Timestamp)(/*[in]*/ short bUseTimeStamp );
	STDMETHOD(get_Timestamp)(/*[out]*/ short *pbUseTimeStamp );
	STDMETHOD(put_Date)(/*[in]*/ short bUseDate );
	STDMETHOD(get_Date)(/*[out]*/ short *pbUseDate );
	STDMETHOD(put_MsgStyle)(/*[in]*/ MSGSTYLE iStyle );
	MSGSTYLE get_MsgStyle();

private: // Helper Fns
	static BOOL CALLBACK _AbortProc( HDC hdcPrinter, int iCode );
	static INT_PTR CALLBACK _PrintDlgProc( HWND hDlg,	UINT uiMsg, WPARAM wParam, LPARAM lParam );
	static INT_PTR CALLBACK _AboutDlgProc( HWND hDlg,	UINT uiMsg, WPARAM wParam, LPARAM lParam );

    // Notifitation helpers
    
	void	_CalculateFontMetrics();
    void	_DecrementNumOtherMembers( void );
	void	_DeleteFonts( void );
    HRESULT _DeleteMemberListItem( int iIndex );
	void	_DisplayMsg( CChatMessage *pChatMsg, BOOL bBatchRedraw = TRUE );
	bool	_FCreate(HWND hwndParent);
	void	_FreeView(void);
    HBITMAP _GetHBITMAP( DWORD dwID );
	HRESULT _GetOwnName();
    void	_IncrementNumOtherMembers( void );
    bool	_IsEditWindowVisibleFlagSet(void);
	bool    _IsStatusBarVisibleFlagSet(void);
	void	_InitFontsAndColors();
    void	_FreeIconImages( void );
    void	_LoadIconImages( void );
	void	_LoadStrings();
	HRESULT _Print();
	void	_PrintIt(HDC hPrinterDC );
	void	_ReDisplayMessages();
	void	_Redraw(void);
	void	_Resize(int x, int y, int cx, int cy);
    HRESULT _SendChatText(void);
    void	_SetContainerStatusText( UINT uID );
    HRESULT _SetMenuItemCheck( UINT idItem, BOOL bChecked = TRUE  );
	void 	_SaveWindowPosition();
    void    _SaveChatOptions();
    BOOL    _LoadChatOptions();
	void	_Save();
	int	    _SaveAs();
	void	_ShiftFocus(HWND hwndCur, BOOL fForward);
    HRESULT _UpdateContainerStatusText( void );


	inline BOOL _IsPrinting();
	
	inline void _Write_Msg( LPTSTR pszText );
	inline void _Write_Msg_Range_Format( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& charFormat );
	inline void _Write_Date_And_Time( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& charFormat, CChatMessage *pChatMsg );
	inline void _Write_Name( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& charFormat, CChatMessage *pChatMsg );
	inline void _Write_Own_Name( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& charFormat );
	inline void _Write_Message( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& charFormat, CChatMessage *pChatMsg );
	inline void _Write_Private_In( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& charFormat, CChatMessage *pChatMsg );
	inline void _Write_Private_Out( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& charFormat, CChatMessage *pChatMsg );
	inline void _Write_New_Line_If_Needed( CHARRANGE& charRange, CHARFORMAT& chatFormat );
	inline void _AddFontToCharFormat( CHARFORMAT& chatFormat, int i );

public:
		BOOL FilterMessage(MSG* pMsg);
		void BringToFront(void);
	    void _UpdateContainerCaption( void );
		void OnGetMinMaxInfo (LPMINMAXINFO lpmmi);
		HWND GetHandle(void){return m_hWnd;}
		int QueryEndSession(void);
		CChatOptionsDlg * m_pChatOptions;

		void _DataReceived(ULONG uSize, LPBYTE pb, T120ChannelID destinationID, T120UserID senderID);
		HRESULT _AddEveryoneInChat();
		MEMBER_ID _GetSelectedMember();
		HRESULT _AddMember(MEMBER_CHANNEL_ID *pMemberID);
		HRESULT _RemoveMember(MEMBER_CHANNEL_ID *pMemberID);
	    void	_DeleteAllListItems( void );

		DECLARE_NMAPPLET_FILE_OPEN_FILTER(IDS_CHAT_SAVE_FILTER_STRING, IDS_CHAT_SAVE_DEF_EXT )

};

#endif //__NMCHATCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\precomp.h ===
//
// Precompiled header stuff
//


#define OEMRESOURCE
#define STRICT 1


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define ATLTRACE

#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <cderr.h>
#include <shellapi.h>                   // Includes drag drop interface
#include <imm.h>


//
// NM headers
//
#define MULTI_LEVEL_ZONES
#include <ConfDbg.h>
#include <mlzdbg.h>
#include "NmCtlDbg.h"
#include "ms_util.h"
#include "memtrack.h"
#include "t120type.h"

#include <regentry.h>

#include "nmchatctl.h"
#include "CHATldr.h"
#include "nmctl1.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NmCtl1.rc
//

/////////////////////////////////////////////
// Registry resource IDS
#define IDR_NMAPP						50
#define IDR_NMCHATCTL                   51
#define IDR_CONTAINERCONTROL			52
#define IDR_MSLABLTI					54
#define IDR_NMSYSINFO					55
#define IDR_NMMANAGER				    56
/////////////////////////////////////////////

#define IDS_SYSTEM_HELP  				60
#define IDS_SIZE_HELP                   61440
#define IDS_MOVE_HELP                   61456
#define IDS_MINIMIZE_HELP               61472
#define IDS_MAXIMIZE_HELP               61488
#define IDS_CLOSE_HELP                  61536
#define IDS_RESTORE_HELP                61728




#define IDS_PROJNAME                    100
#define IDD_CHAT_PRINT                  101
#define IDD_PROPPAGE_AGENDAITEM         102
#define IDD_CHAT_ABOUT                  103
#define CHAT_ICON                       105
#define IDD_CHAT_OPTIONS                108
#define IDB_LGCHAT_TB_DISABLED_ICON     112
#define IDC_SPLITV                      113
#define IDR_MENU_CHAT_WITHFILE          115
#define IDS_UNKNOWN_PERSON              203
#define IDS_FILTER_ALL                  205
#define IDB_CHAT_SMALL_ICON_IMAGES      207
#define IDS_CHAT_NOT_IN_CALL_WINDOW_CAPTION 213
#define IDS_CHAT_IN_CALL_WINDOW_CAPTION 214
#define IDS_CHAT_STATUS_CHAT_ACTIVE     217
#define IDS_CHAT_STATUS_CHAT_NOT_ACTIVE 218
#define IDI_SENDBUTTON                  219
#define IDS_CHAT_SENDTO                 220
#define IDS_PRIVATE                     221
#define IDS_TO                          222
#define IDC_EDIT_AGDOCLINKITEM_URL      223
#define IDC_EDIT_AGDOCLINKITEM_NAME     224
#define IDC_EDIT_AGTITLEDLG_NAME        225
#define IDC_EDIT_AGDECISION_DESC        226
#define IDC_LIST_DECISION_CHOICES       227
#define IDC_EDIT_AGDECISION_NEW_CHOICE  228
#define IDC_BUTTON_AGDECISION_ADD_CHOICE 229
#define IDC_CHECK_AGDECISION_MULTIPLE_CHOICE 230
#define IDD_CHAT_FORMAT                 234
#define FORMATWRAPNEW_ICON              235
#define FORMATWRAP_ICON                 236
#define FORMATSINGLE_ICON               237
#define IDS_CHAT_MESSAGE                240
#define IDS_CHAT_SAVE_FILTER_STRING     241
#define IDR_ACCELERATOR					265
#define IDB_SENDCHAT					270

#define IDS_TOOLTIP_SEND_MESSAGE        283
#define IDS_HELPTEXT_INSERT_NEWSCRIPTABLEACTION 284
#define IDS_HELPTEXT_INSERT_NEWANNOUNCEMENT 285
#define IDS_HELPTEXT_INSERT_NEWDECISION 286
#define IDS_HELPTEXT_INSERT_NEWDISCUSSIONTOPIC 287
#define IDS_HELPTEXT_INSERT_NEWPRESENTATION 288
#define IDS_HELPTEXT_INSERT_NEWACTION   289
#define IDS_HELPTEXT_INSERT_NEWDOCUMENTLINK 290
#define IDS_HELPTEXT_INSERT_NEWMINUTES  291
#define IDS_HELPTEXT_HELP_HELPTOPICS    293
#define IDS_HELPTEXT_EDIT_CUT           294
#define IDS_HELPTEXT_EDIT_COPY          295
#define IDS_HELPTEXT_EDIT_PASTE         296
#define IDS_HELPTEXT_OPTIONS_FONT       297
#define IDS_HELPTEXT_OPTIONS_CHATFORMAT 298
#define IDS_HELPTEXT_HELP_ABOUTCHAT     299
#define IDS_HELPTEXT_EDIT_CLEARALL      300
#define IDS_MINUTES_VIEW_TITLE_CAPTION  301
#define IDS_DECISION_VIEW_ISRESOLVED_CAPTION 302
#define IDS_ACTION_VIEW_ASSIGNEDTO_CAPTION 303
#define IDS_DOCLINK_VIEW_FILENAME_CAPTION 304
#define IDS_DOCLINK_VIEW_BROWSE_BTN_CAPTION 305
#define IDS_SCRPT_ACTION_DOIT_BTN_DEFAULT_CAPTION 306
#define IDS_SCRPT_ACTION_CALLTO_CAPTION 307
#define IDS_SCRPT_ACTION_SEND_FILE_SEND_TO_CAPTION 308
#define IDS_DOCLINK_FILE_BROWSE_DLG_CAPTION 309
#define IDS_DOCLINK_DEFAULT_FILENAME_CAPTION 310
#define IDS_DEFAULT_ACTION_ITEM_NAME    311
#define IDS_DEFAULT_ACTION_ITEM_ASSIGNEE 312
#define IDS_WB_FILE_OPEN_FILTER_STRING  313
#define IDS_WB_FILE_BROWSE_DLG_CAPTION  314
#define ID_SEND_MESSAGE                 321
#define ID_FILE_SAVE                    322
#define ID_FILE_SAVEAS                  323
#define ID_FILE_PRINT                   324
#define ID_VIEW_TOOLBAR                 325
#define ID_VIEW_STATUSBAR               326
#define IDS_VIEW_TOOLBAR_HELP           327
#define IDS_VIEW_STATUSBAR_HELP         328
#define IDS_HELPTEXT_CHAT_FILE_SEND_MESSAGE     329
#define IDS_HELPTEXT_CHAT_FILE_SAVE     330
#define IDS_HELPTEXT_CHAT_FILE_SAVEAS   331
#define IDS_HELPTEXT_CHAT_FILE_PRINT    332
#define IDS_HELPTEXT_CHAT_FILE_EXIT     333
#define ID_FILE_EXIT                    334
#define IDS_HELPTEXT_CHAT_FILE          335
#define IDS_HELPTEXT_CHAT_VIEW          336
#define IDS_HELPTEXT_CHAT_OPTIONS       337
#define IDS_HELPTEXT_CHAT_HELP          338
#define IDS_HELPTEXT_CHAT_EDIT          339
#define ID_VIEW_EDITWINDOW              340
#define IDS_HELPTEXT_CHAT_VIEW_EDITWINDOW 341
#define IDS_CHAT_DOCUMENTNAME           342
#define IDS_CHAT_HEADER                 343
#define IDS_CHAT_SAVE_PRIVATE_TO        344
#define IDS_CHAT_SAVE_PRIVATE           345
#define IDS_CHAT_CREATE_DIRECTORY       346
#define IDS_CHAT_COULD_NOT_CREATE_DIR   347
#define IDS_CHAT_SAVE_ACCESS_DENIED     348
#define IDS_CHAT_SAVE_FAILED            349
#define IDS_CHAT_CONF_OVER_SAVE         350
#define IDS_CHAT_MB_TITLE               351
#define IDS_CHAT_SAVE_DEF_EXT           352
#define IDS_CHAT_ICON_LABEL             353
#define IDS_CHAT_OPTIONS_FONT_FORMAT    354
#define IDS_HELPTEXT_CHAT_VIEW_OPTIONS  355
#define IDS_CHAT_CONF_ENDED             356
#define IDS_NETMEETING_CHAT             357
#define IDS_SAVE_CHANGES_TO_CHAT_BEFORE_EXITING 358
#define IDC_HEADER_GROUP                401
#define IDC_INCLUDE_NAME                402
#define IDC_INCLUDE_DATE                403
#define IDC_INCLUDE_TIME                404
#define IDR_MESSAGE_GROUP               405
#define IDR_SINGLE_LINE                 406
#define IDR_SAME_LINE                   407
#define IDR_NEW_LINE                    408
#define IDC_FONTS_GROUP                 409
#define IDC_CHAT_PRINT_STATIC           1001
#define IDC_CHAT_ABOUT_VERSION          1002
#define IDC_FORMATSINGLE                1003
#define IDC_CHAT_ABOUT_PRODUCT_NAME     1003
#define IDC_FORMATWRAP                  1004
#define IDC_CHAT_ABOUT_COPYRIGHT        1004
#define IDC_FORMATWRAPNEW               1005
#define IDC_FONT_MSGOUT                 1016
#define IDC_FONT_MSGIN                  1017
#define IDC_FONT_PRIVATEOUT             1018
#define IDC_FONT_PRIVATEIN              1019
#define IDC_EDIT_MSGIN                  1021
#define IDC_EDIT_PRIVATEIN              1022
#define IDC_EDIT_MSGOUT                 1023
#define IDC_EDIT_PRIVATEOUT             1024
#define IDM_PROPERTIES                  32768
#define IDM_INSERT                      32769
#define ID_EDIT_CUT                     32770
#define ID_EDIT_COPY                    32771
#define ID_EDIT_PASTE                   32772
#define ID_EDIT_CLEARALL                32773
#define ID_OPTIONS_FONT                 32774
#define ID_OPTIONS_CHATFORMAT           32775
#define ID_HELP_ABOUTCHAT               32776
#define ID_HELP_HELPTOPICS              32777
#define ID_INSERT_NEWANNOUNCEMENT       32778
#define ID_INSERT_NEWDECISION           32779
#define ID_INSERT_NEWDISCUSSIONTOPIC    32780
#define ID_INSERT_NEWPRESENTATION       32781
#define ID_INSERT_NEWACTION             32782
#define ID_INSERT_NEWDOCUMENTLINK       32783
#define ID_INSERT_NEWMINUTES            32784
#define ID_INSERT_NEWSCRIPTABLEACTION   32785
#define ID_VIEW_OPTIONS                 40004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40005
#define _APS_NEXT_CONTROL_VALUE         1025
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\splitbar2.h ===
// File: splitbar.h

#ifndef __SplitBar2_h__
#define __SplitBar2_h__


class CSplitBar2 
: public CWindowImpl<CSplitBar2>
{

public: // Datatypes
    typedef void (WINAPI * PFN_ADJUST)(int dxp, LPARAM lParam);

private:
	HWND  m_hwndBuddy;      // Buddy window
	HWND  m_hwndParent;     // Parent window
	BOOL  m_fCaptured;      // TRUE if captured
	HDC   m_hdcDrag;        // The captured desktop hdc

    static int ms_dxpSplitBar; // width of a splitbar window
	int   m_dxSplitter;     // Width of the splitter bar
	int   m_dxDragOffset;   // Offset of mouse click within splitter (0 - m_dxSplitter)
	int   m_xCurr;          // Current x position of bar (m_hwndParent co-ordinates)
	int   m_dxMin;
	int   m_dxMax;


        // callback data and fn ptrs
    PFN_ADJUST  m_pfnAdjust;
    LPARAM      m_Context;
	

BEGIN_MSG_MAP(CSplitBar2)
    MESSAGE_HANDLER( WM_LBUTTONDOWN, OnLButtonDown )
END_MSG_MAP()

    // Message map handlers
    LRESULT OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

public:
    CSplitBar2(void);
	~CSplitBar2();
    
    HRESULT Create(HWND hwndBuddy, PFN_ADJUST pfnAdjust, LPARAM Context);


    int GetWidth(void) const { return ms_dxpSplitBar; }


    static CWndClassInfo& GetWndClassInfo();

private:
	void _DrawBar(void);
	int  _ConstrainDragPoint(short x);
	void CancelDragLoop(void);
	BOOL FInitDragLoop(POINT pt);
	void OnDragMove(POINT pt);
	void OnDragEnd(POINT pt);

private:
// Helper Fns
	void _TrackDrag(POINT pt);
    static void _UpdateSplitBar(void);
};

#endif // __SplitBar2_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\agrp.cpp ===
//
// AGRP.CPP
// Tool Attributes Display Group
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


// Class name
static const TCHAR szAGClassName[] = "T126WB_AGRP";

//
// Page Control child IDs
// Index is PGC_ value
//
static UINT_PTR g_uPageIds[NUM_PAGE_CONTROLS] =
{
    IDM_PAGE_FIRST,
    IDM_PAGE_PREV,
    IDM_PAGE_ANY,
    IDM_PAGE_NEXT,
    IDM_PAGE_LAST,
    IDM_PAGE_INSERT_AFTER
};



//
// WbAttributesGroup()
//
WbAttributesGroup::WbAttributesGroup(void)
{
    int             i;

    m_hwnd = NULL;

    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        m_uPageCtrls[i].hbmp = NULL;
        m_uPageCtrls[i].hwnd = NULL;
    }

    m_hPageCtrlFont = NULL;
    m_cxPageCtrls = DEFAULT_PGC_WIDTH;

    m_hwndFontButton = NULL;
}


//
// ~WbAttibutesGroup()
//
WbAttributesGroup::~WbAttributesGroup(void)
{
    int i;

    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    ::UnregisterClass(szAGClassName, g_hInstance);

    //
    // Delete control bitmaps
    //
    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        if (m_uPageCtrls[i].hbmp)
        {
            ::DeleteBitmap(m_uPageCtrls[i].hbmp);
            m_uPageCtrls[i].hbmp = NULL;
        }
    }

    if (m_hPageCtrlFont != NULL)
    {
        ::DeleteFont(m_hPageCtrlFont);
        m_hPageCtrlFont = NULL;
    }

}



//
// Create()
//
BOOL WbAttributesGroup::Create
(
    HWND    hwndParent,
    LPCRECT lpRect
)
{
    SIZE    size;
    RECT    rectCG;
    RECT    rectFSG;
    TCHAR   szFOBStr[256];
    HFONT   hOldFont;
    HDC     hdc;
    int     i;
    BITMAP  bmpInfo;
    int     x, cx;
    int     yLogPix;
    WNDCLASSEX  wc;

    ASSERT(m_hwnd == NULL);

    // Register our class
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = AGWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE+1);
    wc.lpszClassName    = szAGClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbAttributesGroup::Create register class failed"));
        return(FALSE);
    }

    // Create the window
    if (!::CreateWindowEx(0, szAGClassName, NULL,
        WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN,
        lpRect->left, lpRect->top,
        lpRect->right - lpRect->left, lpRect->bottom - lpRect->top,
        hwndParent, NULL, g_hInstance, this))
    {
        ERROR_OUT(("Couldn't create WbAttributesGroup window"));
        return(FALSE);
    }

    ASSERT(m_hwnd != NULL);

    //
    // Create the page control button bitmaps
    //
    if (!RecolorButtonImages())
    {
        ERROR_OUT(("Error getting page button bitmaps"));
        return(FALSE);
    }

    hdc = ::CreateCompatibleDC(NULL);
    yLogPix = ::GetDeviceCaps(hdc, LOGPIXELSY);
    ::DeleteDC(hdc);

    //
    // Create the font for the edit field and buttons
    //
    ::GetObject(m_uPageCtrls[PGC_LAST].hbmp, sizeof(BITMAP), &bmpInfo);
    m_hPageCtrlFont = ::CreateFont(-bmpInfo.bmHeight,
                                0, 0, 0,
                                FW_NORMAL, 0, 0, 0,
                                DEFAULT_CHARSET,
                                OUT_TT_PRECIS,
                                CLIP_DFA_OVERRIDE,
                                DEFAULT_QUALITY,
                                VARIABLE_PITCH | FF_SWISS,
                                "Arial" );
    if (!m_hPageCtrlFont)
    {
        ERROR_OUT(("WbPagesGroup::Create - couldn't create font"));
        return(FALSE);
    }

    //
    // Create the child controls in inverse order, right to left
    //
    x = lpRect->right;

    for (i = NUM_PAGE_CONTROLS - 1; i >= 0; i--)
    {
        x -= BORDER_SIZE_X;

        switch (i)
        {
            case PGC_ANY:
                cx = (3*PAGEBTN_WIDTH)/2;
                break;

            case PGC_FIRST:
            case PGC_LAST:
                // make button fit bitmap width + standard border
                ::GetObject(m_uPageCtrls[i].hbmp, sizeof(BITMAP), &bmpInfo);
                cx = bmpInfo.bmWidth + 2*::GetSystemMetrics(SM_CXFIXEDFRAME); // standard button border
                break;

            default:
                cx = PAGEBTN_WIDTH;
                break;

        }

        x -= cx;

        if (i == PGC_ANY)
        {
            m_uPageCtrls[i].hwnd = ::CreateWindowEx(WS_EX_CLIENTEDGE,
                _T("EDIT"), NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE |
                ES_NUMBER | ES_CENTER | ES_MULTILINE,
                x, 2*BORDER_SIZE_Y, cx, PAGEBTN_HEIGHT,
                m_hwnd, (HMENU)g_uPageIds[i], g_hInstance, NULL);

            if (!m_uPageCtrls[i].hwnd)
            {
                ERROR_OUT(("Couldn't create PGRP edit field"));
                return(FALSE);
            }

            ::SendMessage(m_uPageCtrls[i].hwnd, EM_LIMITTEXT, MAX_NUMCHARS, 0);
            ::SendMessage(m_uPageCtrls[i].hwnd, WM_SETFONT, (WPARAM)m_hPageCtrlFont, 0);
        }
        else
        {
            m_uPageCtrls[i].hwnd = ::CreateWindowEx(0, _T("BUTTON"),
                NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | BS_BITMAP,
                x, 2*BORDER_SIZE_Y, cx, PAGEBTN_HEIGHT,
                m_hwnd, (HMENU)g_uPageIds[i], g_hInstance, NULL);

            if (!m_uPageCtrls[i].hwnd)
            {
                ERROR_OUT(("Couldn't create PGRP button ID %x", g_uPageIds[i]));
                return(FALSE);
            }

            ::SendMessage(m_uPageCtrls[i].hwnd, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)m_uPageCtrls[i].hbmp);
        }
    }

    m_cxPageCtrls = lpRect->right - x;

    SetPageButtonNo(PGC_FIRST, 1);
    SetPageButtonNo(PGC_LAST, 1);

    //
    // Create the color palette
    //

    m_colorsGroup.GetNaturalSize(&size);
    rectCG.left = BORDER_SIZE_X;
    rectCG.right = rectCG.left + size.cx;
    rectCG.top = BORDER_SIZE_Y;
    rectCG.bottom = rectCG.top + size.cy;

    if (!m_colorsGroup.Create(m_hwnd, &rectCG))
    {
        ERROR_OUT(("Couldn't create CGRP window"));
        return(FALSE);
    }

    //
    // Create the font button.
    // Now calculate the real size of the button
    //

    hdc = ::GetDC(m_hwnd);
    if (!hdc)
        return(FALSE);

    hOldFont = SelectFont(hdc, (HFONT)::GetStockObject(DEFAULT_GUI_FONT));

    ::LoadString(g_hInstance, IDS_FONTOPTIONS, szFOBStr, 256);
    ::GetTextExtentPoint(hdc, szFOBStr, lstrlen(szFOBStr), &size);

    SelectFont(hdc, hOldFont);
    ::ReleaseDC(m_hwnd, hdc);

    size.cx += 4 * BORDER_SIZE_X;
    size.cy += 4 * BORDER_SIZE_Y;

    m_hwndFontButton = ::CreateWindowEx(0, _T("BUTTON"), szFOBStr,
        WS_CHILD | WS_CLIPSIBLINGS | BS_PUSHBUTTON,
        rectCG.right + SEPARATOR_SIZE_X, 2*BORDER_SIZE_Y,
        max(size.cx, FONTBUTTONWIDTH), max(size.cy, FONTBUTTONHEIGHT),
        m_hwnd, (HMENU)IDM_FONT, g_hInstance, NULL);

    if (!m_hwndFontButton)
    {
        ERROR_OUT(("Couldn't create FONT button"));
        return(FALSE);
    }

    ::SendMessage(m_hwndFontButton, WM_SETFONT, (WPARAM)::GetStockObject(DEFAULT_GUI_FONT),
        FALSE);

    return(TRUE);
}



//
// RecolorButtonImages()
//
BOOL WbAttributesGroup::RecolorButtonImages(void)
{
    int         i;
    HBITMAP     hbmpNew;

    //
    // This creates button bitmaps tied to the 3D colors, and clears the old
    // ones/sets the new ones if the buttons are around.
    //

    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        // No bitmaps for the edit field
        if (i == PGC_ANY)
            continue;

        hbmpNew = (HBITMAP)::LoadImage(g_hInstance, MAKEINTRESOURCE(g_uPageIds[i]),
            IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS | LR_DEFAULTCOLOR | LR_DEFAULTSIZE);
        if (!hbmpNew)
        {
            ERROR_OUT(("AG::RecolorButtonImages faile to load bitmap ID %d",
                g_uPageIds[i]));
            return(FALSE);
        }

        // Set the new one
        if (m_uPageCtrls[i].hwnd != NULL)
        {
            ::SendMessage(m_uPageCtrls[i].hwnd, BM_SETIMAGE, IMAGE_BITMAP,
                (LPARAM)hbmpNew);
        }

        // Delete the old one
        if (m_uPageCtrls[i].hbmp != NULL)
        {
            ::DeleteBitmap(m_uPageCtrls[i].hbmp);
        }

        // Save this one
        m_uPageCtrls[i].hbmp = hbmpNew;

        // Put the page number on top
        if (m_uPageCtrls[i].hwnd != NULL)
        {
            if (i == PGC_FIRST)
            {
                SetPageButtonNo(i, 1);
            }
            else if (i == PGC_LAST)
            {
                SetPageButtonNo(i, 1);
            }
        }
    }

    return(TRUE);
}




//
//
// Function:    GetNaturalSize
//
// Purpose:     Return the natural size of the attributes group
//
//
void WbAttributesGroup::GetNaturalSize(LPSIZE lpsize)
{
    SIZE    sizeCG;
    SIZE    sizeFSG;
    RECT    rc;

    m_colorsGroup.GetNaturalSize(&sizeCG);

    if (!m_hwndFontButton)
    {
        sizeFSG.cx = FONTBUTTONWIDTH;
        sizeFSG.cy = FONTBUTTONHEIGHT;
    }
    else
    {
        ::GetWindowRect(m_hwndFontButton, &rc);
        sizeFSG.cx = rc.right - rc.left;
        sizeFSG.cy = rc.bottom - rc.top;
    }

    // m_cxPageCtrls includes BORDER_SIZE_X on right side
    lpsize->cx = BORDER_SIZE_X
               + sizeCG.cx
               + SEPARATOR_SIZE_X
               + sizeFSG.cx
               + SEPARATOR_SIZE_X
               + m_cxPageCtrls;

    sizeFSG.cy = max(sizeFSG.cy, PAGEBTN_HEIGHT) + BORDER_SIZE_Y;
    lpsize->cy = BORDER_SIZE_Y
                + max(sizeCG.cy, sizeFSG.cy)
                + BORDER_SIZE_Y;
}


//
// IsChildEditField()
//
BOOL WbAttributesGroup::IsChildEditField(HWND hwnd)
{
    return(hwnd == m_uPageCtrls[PGC_ANY].hwnd);
}


//
// GetCurrentPageNumber()
//
UINT WbAttributesGroup::GetCurrentPageNumber(void)
{
    return(::GetDlgItemInt(m_hwnd, IDM_PAGE_ANY, NULL, FALSE));
}


//
// SetCurrentPageNumber()
//
void WbAttributesGroup::SetCurrentPageNumber(UINT number)
{
    ::SetDlgItemInt(m_hwnd, IDM_PAGE_ANY, number, FALSE);
}


//
// SetLastPageNumber()
//
void WbAttributesGroup::SetLastPageNumber(UINT number)
{
    SetPageButtonNo(PGC_LAST, number);
}


//
// EnablePageCtrls()
//
void WbAttributesGroup::EnablePageCtrls(BOOL bEnable)
{
    int i;

    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        ::EnableWindow(m_uPageCtrls[i].hwnd, bEnable);
    }

	//
	// Insert is enabled if we are synced and didn't reach the limit
	//
   ::EnableWindow(m_uPageCtrls[PGC_INSERT].hwnd, g_pDraw->IsSynced() &&  (g_numberOfWorkspaces < 256) ? bEnable : FALSE);


}


//
// EnableInsert()
//
void WbAttributesGroup::EnableInsert(BOOL bEnable)
{
    ::EnableWindow(m_uPageCtrls[PGC_INSERT].hwnd, bEnable);
}


//
// AGWndProc()
//
LRESULT CALLBACK AGWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbAttributesGroup * pag = (WbAttributesGroup *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pag = (WbAttributesGroup *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pag);

            pag->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pag);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pag);
            pag->m_hwnd = NULL;
            break;

        case WM_SIZE:
            ASSERT(pag);
            pag->OnSize((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_COMMAND:
            ASSERT(pag);
            pag->OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                    GET_WM_COMMAND_CMD(wParam, lParam),
                    GET_WM_COMMAND_HWND(wParam, lParam));
            break;

        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}


//
//
// Function:    OnSize
//
// Purpose:     The tool window has been resized
//
//
void WbAttributesGroup::OnSize(UINT, int, int)
{
    RECT    rc;
    int     i;
    int     x;
    RECT    rcT;

    //
    // We haven't created our children yet.
    //
    if (!m_uPageCtrls[0].hwnd)
        return;

    ::GetClientRect(m_hwnd, &rc);
    x = rc.right - m_cxPageCtrls;

    //
    // Move the page controls to be right justified.
    //
    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        // Get width of control
        ::GetWindowRect(m_uPageCtrls[i].hwnd, &rcT);
        rcT.right -= rcT.left;

        ::MoveWindow(m_uPageCtrls[i].hwnd, x, 2*BORDER_SIZE_Y,
            rcT.right, PAGEBTN_HEIGHT, TRUE);

        //
        // Move to the next one
        //
        x += rcT.right + BORDER_SIZE_X;
    }

    //
    // The color palette and font button are left justified, no need to
    // move them.
    //
}



//
// SetPageButtonNo()
//
// Updates the page text in the first/last button
//
void WbAttributesGroup::SetPageButtonNo(UINT pgcIndex, UINT uiPageNumber )
{
    HDC     hdc;
    BITMAP  bmpInfo;
    HBITMAP hbmp;
    HFONT   hOldFont;
    HBITMAP hOldBitmap;
    RECT    rectNumBox;
    TCHAR   NumStr[16];
    TEXTMETRIC tm;
    HWND    hwndButton;

    MLZ_EntryOut(ZONE_FUNCTION, "WbAttributesGroup::SetPageButtonNo");

    hwndButton = m_uPageCtrls[pgcIndex].hwnd;
    hbmp = m_uPageCtrls[pgcIndex].hbmp;

    ASSERT(hwndButton);
    ASSERT(hbmp);
    ASSERT(m_hPageCtrlFont);

    ::GetObject(hbmp, sizeof (BITMAP), (LPVOID)&bmpInfo);

    hdc = ::CreateCompatibleDC(NULL);
    hOldFont = SelectFont(hdc, m_hPageCtrlFont);
    hOldBitmap = SelectBitmap(hdc, hbmp);
    ::GetTextMetrics(hdc, &tm);

    rectNumBox.left = 10;
    rectNumBox.top = -(tm.tmInternalLeading/2);
    rectNumBox.right = bmpInfo.bmWidth;
    rectNumBox.bottom = bmpInfo.bmHeight;

    SelectBrush(hdc, ::GetSysColorBrush( COLOR_3DFACE ) );
    ::SetTextColor(hdc, ::GetSysColor( COLOR_BTNTEXT ) );
    ::SetBkColor(hdc, ::GetSysColor( COLOR_3DFACE ) );

    ::PatBlt(hdc, rectNumBox.left, rectNumBox.top,
        rectNumBox.right - rectNumBox.left, rectNumBox.bottom - rectNumBox.top,
        PATCOPY);

    wsprintf(NumStr, "%d", uiPageNumber);
    ::DrawText(hdc, NumStr, -1, &rectNumBox, DT_CENTER);

    SelectFont(hdc, hOldFont);
    SelectBitmap(hdc, hOldBitmap);

    ::DeleteDC(hdc);

    ::InvalidateRect(hwndButton, NULL, TRUE);
    ::UpdateWindow(hwndButton);
}



//
//
// Function:    DisplayTool
//
// Purpose:     Display a tool in the attributes group
//
//
void WbAttributesGroup::DisplayTool(WbTool* pTool)
{
    SIZE    size;

    // Display the colors group if necessary
    if (!pTool->HasColor())
    {
        ::ShowWindow(m_colorsGroup.m_hwnd, SW_HIDE);
    }
    else
    {
        // Change the color button to match the tool
        m_colorsGroup.SetCurColor(pTool->GetColor());

        // If the group is currently hidden, show it
        if (!::IsWindowVisible(m_colorsGroup.m_hwnd))
        {
            ::ShowWindow(m_colorsGroup.m_hwnd, SW_SHOW);
        }
    }

    // Display the widths group if necessary
    if( (!pTool->HasWidth()) || (!g_pMain->IsToolBarOn()) )
    {
        ::ShowWindow(g_pMain->m_WG.m_hwnd, SW_HIDE);
    }
    else
    {
        UINT uiWidthIndex = pTool->GetWidthIndex();

        // If the width index isn't valid, then pop up all the buttons
        if (uiWidthIndex < NUM_OF_WIDTHS)
        {
            // Tell the widths group of the new selection
            g_pMain->m_WG.PushDown(uiWidthIndex);
        }

        // If the group is currently hidden, show it
        if (!::IsWindowVisible(g_pMain->m_WG.m_hwnd))
        {
            ::ShowWindow(g_pMain->m_WG.m_hwnd, SW_SHOW);
        }
    }

    // The font sample group is visible for text and select tools
    if (!pTool->HasFont())
    {
        ::ShowWindow(m_hwndFontButton, SW_HIDE);
    }
    else
    {
        if (!::IsWindowVisible(m_hwndFontButton))
        {
            ::ShowWindow(m_hwndFontButton, SW_SHOW);
        }
    }
}


//
//
// Function:    Hide.
//
// Purpose:     Hide the tool attributes bar.
//
//
void WbAttributesGroup::Hide(void)
{
    if (m_colorsGroup.m_hwnd != NULL)
        ::ShowWindow(m_colorsGroup.m_hwnd, SW_HIDE);

    if (m_hwndFontButton != NULL)
        ::ShowWindow(m_hwndFontButton, SW_HIDE);
}

//
//
// Function:    SelectColor
//
// Purpose:     Set the current color
//
//
void WbAttributesGroup::SelectColor(WbTool* pTool)
{
    if (pTool != NULL)
    {
        pTool->SetColor(m_colorsGroup.GetCurColor());
    }
}




//
// This forwards all button commands to our main window
//
void WbAttributesGroup::OnCommand(UINT id, UINT cmd, HWND hwndCtl)
{
    switch (id)
    {
        case IDM_PAGE_FIRST:
        case IDM_PAGE_PREV:
        case IDM_PAGE_NEXT:
        case IDM_PAGE_LAST:
        case IDM_PAGE_INSERT_AFTER:
        case IDM_FONT:
            if (cmd == BN_CLICKED)
            {
                ::PostMessage(g_pMain->m_hwnd, WM_COMMAND,
                    GET_WM_COMMAND_MPS(id, cmd, hwndCtl));
            }
            break;

        case IDM_PAGE_ANY:
            if (cmd == EN_SETFOCUS)
            {
                ::SendMessage(hwndCtl, EM_SETSEL, 0, (LPARAM)-1);
                ::SendMessage(hwndCtl, EM_SCROLLCARET, 0, 0);
            }
			else if(cmd == EN_MAXTEXT)
			{
                ::PostMessage(g_pMain->m_hwnd, WM_COMMAND,
                    GET_WM_COMMAND_MPS(id, cmd, hwndCtl));
			}
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\splitbar2.cpp ===
#include "precomp.h"
#include "splitbar2.h"
#include "resource.h"

/* static */ int CSplitBar2::ms_dxpSplitBar = 0;  // width of a standard split bar window // GetSystemMetrics(SM_CXSIZEFRAME);

/* static */ void CSplitBar2::_UpdateSplitBar(void)
{
	ms_dxpSplitBar = GetSystemMetrics(SM_CXSIZEFRAME);
}

/*  C  S P L I T  B A R  */
/*-------------------------------------------------------------------------
    %%Function: CSplitBar2
    
-------------------------------------------------------------------------*/
CSplitBar2::CSplitBar2(void)
: m_hwndBuddy (NULL)
, m_hwndParent(NULL)
, m_pfnAdjust(NULL)
, m_Context(NULL)
, m_hdcDrag(NULL)
, m_fCaptured(FALSE)
{

    DBGENTRY(CSplitBar2::CSplitBar2);

    _UpdateSplitBar();

    DBGEXIT(CSplitBar2::CSplitBar2);
}


CSplitBar2::~CSplitBar2()
{
    DBGENTRY(CSplitBar2::~CSplitBar2);
	
    if( ::IsWindow( m_hWnd ) )
    {
        DestroyWindow();
    }

    DBGEXIT(CSplitBar2::~CSplitBar2);
}



HRESULT CSplitBar2::Create(HWND hwndBuddy, PFN_ADJUST pfnAdjust, LPARAM Context)
{
    DBGENTRY(CSplitBar2::Create);
    HRESULT hr = S_OK;

    if( hwndBuddy && pfnAdjust )
    {
        m_hwndBuddy = hwndBuddy;
        m_hwndParent = ::GetParent(hwndBuddy);
        m_pfnAdjust = pfnAdjust;
        m_Context = Context;

        RECT rc;
        SetRect( &rc, 0, 0, ms_dxpSplitBar, 0 );    
        
        if( !CWindowImpl<CSplitBar2>::Create( m_hwndParent, rc ) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = E_INVALIDARG;

    }

    DBGEXIT_HR(CSplitBar2::Create,hr);
    return hr;
}


LRESULT CSplitBar2::OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    
    
    DBGENTRY(CSplitBar2::OnLButtonDown);        

	POINT pt;
	pt.x = LOWORD(lParam);
	pt.y = HIWORD(lParam); 

	_TrackDrag(pt);

    DBGEXIT(CSplitBar2::OnLButtonDown);

	return 0;

}


/*  C O N S T R A I N  D R A G  P O I N T  */
/*-------------------------------------------------------------------------
    %%Function: _ConstrainDragPoint
    
-------------------------------------------------------------------------*/
int CSplitBar2::_ConstrainDragPoint(short x)
{

    DBGENTRY(CSplitBar2::_ConstrainDragPoint);


	// Factor out the drag offset (to make calculations easier)
	int dx = x - m_dxDragOffset;

	// Don't allow the panes to go below their minimum size
	if (dx < m_dxMin)
	{
		dx = m_dxMin;
	}
	else if (dx > m_dxMax)
	{
		dx = m_dxMax;
	}


    DBGEXIT(CSplitBar2::_ConstrainDragPoint);

	// Factor the drag offset back in
	return (m_dxDragOffset + dx);
}


/*  D R A W  B A R  */
/*-------------------------------------------------------------------------
    %%Function: _DrawBar
    
-------------------------------------------------------------------------*/
void CSplitBar2::_DrawBar(void)
{
    DBGENTRY(CSplitBar2::_DrawBar);

	RECT rc;
    
    RECT ClientRect;
    GetClientRect( &ClientRect );

	// Rectangle is a larger to make it easier to see.
	rc.top = ClientRect.top;
	rc.bottom = ClientRect.bottom;
	rc.left = m_xCurr - (m_dxDragOffset + 1); //ClientRect.left + 
	rc.right = rc.left + ms_dxpSplitBar + 1;
	::MapWindowPoints(m_hwndParent, GetDesktopWindow(), (POINT *) &rc, 2);

	::InvertRect(m_hdcDrag, &rc);

    DBGEXIT(CSplitBar2::_DrawBar);
}


/*  F  I N I T  D R A G  L O O P  */
/*-------------------------------------------------------------------------
    %%Function: FInitDragLoop

    Initialize the mouse down drag loop.
    Return FALSE if there was a problem.
-------------------------------------------------------------------------*/
BOOL CSplitBar2::FInitDragLoop(POINT pt)
{
    
    DBGENTRY(CSplitBar2::FInitDragLoop);

	if (NULL != ::GetCapture())
	{
		ERROR_OUT(("InitDragLoop: Unable to capture"));
		return FALSE;
	}

	// handle pending WM_PAINT messages
	MSG msg;
	while (::PeekMessage(&msg, NULL, WM_PAINT, WM_PAINT, PM_NOREMOVE))
	{
		if (!GetMessage(&msg, NULL, WM_PAINT, WM_PAINT))
			return FALSE;
		DispatchMessage(&msg);
	}

	HWND hwndDesktop = GetDesktopWindow();
	DWORD dwFlags = ::LockWindowUpdate(hwndDesktop) ? DCX_WINDOW|DCX_CACHE|DCX_LOCKWINDOWUPDATE : DCX_WINDOW|DCX_CACHE;

	ASSERT(m_hdcDrag == NULL);
	m_hdcDrag = ::GetDCEx(hwndDesktop, NULL, dwFlags);
	ASSERT(m_hdcDrag != NULL);

	ASSERT(!m_fCaptured);
	SetCapture();
	ASSERT(m_hWnd == GetCapture());
	m_fCaptured = TRUE;

	m_dxDragOffset = pt.x;
	m_xCurr = pt.x;
	_DrawBar();

	RECT rc;
	// determine the drag extent
	::GetClientRect(m_hwndBuddy, &rc);
	::MapWindowPoints(m_hwndBuddy, m_hwndParent, (POINT *) &rc, 1);
	m_dxMin = rc.left + (32 + (3*2));
	
	::GetClientRect( ::GetParent( m_hwndParent ) , &rc);
	m_dxMax = RectWidth(rc) - (ms_dxpSplitBar + 176);

	if (m_dxMax < m_dxMin)
		m_dxMax = m_dxMin;

	TRACE_OUT(("captured mouse at (%d,%d) (min=%d, max=%d)", pt.x, pt.y, m_dxMin, m_dxMax));

    DBGEXIT(CSplitBar2::FInitDragLoop);

	return TRUE;
}


/*  O N  D R A G  M O V E  */
/*-------------------------------------------------------------------------
    %%Function: OnDragMove
    
-------------------------------------------------------------------------*/
void CSplitBar2::OnDragMove(POINT pt)
{

    DBGENTRY(CSplitBar2::OnDragMove);

	ASSERT(m_fCaptured);

	::ScreenToClient(m_hwndParent, &pt);
	int x = _ConstrainDragPoint((short)pt.x);
	if (x != m_xCurr)
	{
		_DrawBar();
		m_xCurr = x;
		_DrawBar();
	}

    DBGEXIT(CSplitBar2::OnDragMove);
}


/*  O N  D R A G  E N D  */
/*-------------------------------------------------------------------------
    %%Function: OnDragEnd
    
-------------------------------------------------------------------------*/
void CSplitBar2::OnDragEnd(POINT pt)
{

    DBGENTRY(CSplitBar2::OnDragEnd);

	CancelDragLoop();

    RECT ClientRect;
    GetClientRect( &ClientRect );

	::ScreenToClient(m_hwndParent, &pt);
	int x = _ConstrainDragPoint((short)pt.x);
	if (0 != x)
	{
		// Call the adjustment function
        if(m_pfnAdjust)
        {
            m_pfnAdjust(x - (ClientRect.left + m_dxDragOffset), m_Context);
        }

//		ForceWindowResize();
	}

    DBGEXIT(CSplitBar2::OnDragEnd);
}


/*  C A N C E L  D R A G  L O O P  */
/*-------------------------------------------------------------------------
    %%Function: CancelDragLoop
    
-------------------------------------------------------------------------*/
void CSplitBar2::CancelDragLoop(void)
{

    DBGENTRY(CSplitBar2::CancelDragLoop);

	if (m_fCaptured)
    {
	    TRACE_OUT(("Canceling drag loop..."));

	    // Release the capture
	    ReleaseCapture();
	    m_fCaptured = FALSE;

	    // Erase the bar
	    _DrawBar();

	    // unlock window updates
	    LockWindowUpdate(NULL);
	    if (m_hdcDrag != NULL)
	    {
		    ::ReleaseDC(GetDesktopWindow(), m_hdcDrag);
		    m_hdcDrag = NULL;
	    }
    }
    
    DBGEXIT(CSplitBar2::CancelDragLoop);
}


void CSplitBar2::_TrackDrag(POINT pt)
{

    DBGENTRY(CSplitBar2::_TrackDrag);

	// set capture to the window which received this message
	if (FInitDragLoop(pt))
	{
	    // get messages until capture lost or cancelled/accepted
	    while (GetCapture() == m_hWnd)
	    {
		    MSG msg;
		    if (!::GetMessage(&msg, NULL, 0, 0))
		    {
			    PostQuitMessage(msg.wParam);
			    break;
		    }

		    if (WM_MOUSEMOVE == msg.message)
		    {
			    OnDragMove(msg.pt);
			    continue;
		    }

		    if (WM_LBUTTONUP == msg.message)
		    {
			    OnDragEnd(msg.pt);
			    break;
		    }

		    if ((WM_KEYDOWN == msg.message) || 
			    (WM_RBUTTONDOWN == msg.message))
		    {
			    break;
		    }

		    // dispatch all other messages
		    DispatchMessage(&msg);
	    }

	    CancelDragLoop();
	}
    else
    {
		WARNING_OUT(("Unable to Initialize drag loop?"));
    }

    DBGEXIT(CSplitBar2::_TrackDrag);
}



/* static */ CWndClassInfo& CSplitBar2::GetWndClassInfo()
{

    DBGENTRY(CSplitBar2::GetWndClassInfo);

	static CWndClassInfo wc =
	{
		{ 
            sizeof(WNDCLASSEX), // cbSize
            NULL,               // style
            StartWindowProc,    // WndProc
            0,                  // cbClsExtra
            0,                  // cbWndExtra
            0,                  // hInstance
            0,                  // hIcon
            NULL,               // hCursor
            reinterpret_cast<HBRUSH>(COLOR_3DFACE + 1),  // hBackground
            0,                          // lpszMenuName
            _T("ConfSplitBarClass2"),   // lpszClassName
            0                           // hIconSm
        },
		NULL, 
        NULL, 
        MAKEINTRESOURCE(IDC_SPLITV), // hCursor, 
        FALSE, 
        0, 
        _T("")
	};

    DBGEXIT(CSplitBar2::GetWndClassInfo);

	return wc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\nmctl1\nmsysinfo.h ===
#ifndef __NmSysInfo_h__
#define __NmSysInfo_h__

#include "SDKInternal.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CNmSysInfoObj
class ATL_NO_VTABLE CNmSysInfoObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNmSysInfoObj, &CLSID_NmSysInfo>,
	public IConnectionPointContainerImpl<CNmSysInfoObj>,
	public IConnectionPointImpl<CNmSysInfoObj, &IID_INmSysInfoNotify, CComDynamicUnkArray>,
	public INmSysInfo2,
	public IMarshal
{

	CComPtr<IInternalConfExe> m_spConfHook;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_NMSYSINFO)
DECLARE_NOT_AGGREGATABLE(CNmSysInfoObj)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNmSysInfoObj)
	COM_INTERFACE_ENTRY(INmSysInfo)
	COM_INTERFACE_ENTRY(INmSysInfo2)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IMarshal)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CNmSysInfoObj)
	CONNECTION_POINT_ENTRY(IID_INmSysInfoNotify)
END_CONNECTION_POINT_MAP()

	HRESULT FinalConstruct();
	void FinalRelease();

///////////////////////////////////////////////
// INmSysInfo methods

	STDMETHOD(IsInstalled)(void);
	STDMETHOD(GetProperty)(NM_SYSPROP uProp, BSTR *pbstrProp);
	STDMETHOD(SetProperty)(NM_SYSPROP uProp, BSTR bstrName);
	STDMETHOD(GetUserData)(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	STDMETHOD(SetUserData)(REFGUID rguid, BYTE *pb, ULONG cb);
	STDMETHOD(GetNmApp)(REFGUID rguid,BSTR *pbstrApplication, BSTR *pbstrCommandLine, BSTR *pbstrDirectory);
	STDMETHOD(SetNmApp)(REFGUID rguid,BSTR bstrApplication, BSTR bstrCommandLine, BSTR bstrDirectory);
	STDMETHOD(GetNmchCaps)(ULONG *pchCaps);
	STDMETHOD(GetLaunchInfo)(INmConference **ppConference, INmMember **ppMember);

///////////////////////////////////////////////
// INmSysInfo2 methods

    STDMETHOD(GetOption)(NM_SYSOPT uOption, ULONG * plValue);
    STDMETHOD(SetOption)(NM_SYSOPT uOption, ULONG lValue);
    STDMETHOD(ProcessSecurityData)(DWORD dwTaskCode, DWORD dwParam1, DWORD dwParam2, DWORD * pdwResult);
    STDMETHOD(GkLogon)(BSTR bstrAddr, BSTR bstrName, NM_ADDR_TYPE addrType);
	STDMETHOD(GkLogoff)();
    STDMETHOD(GkState)(NM_GK_STATE* plState);


/////////////////////////////////////////////////////////////////////////////////
// IMarshal methods

    STDMETHOD(GetUnmarshalClass)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID *pCid) { *pCid = CLSID_NmSysInfo; return S_OK; };

    STDMETHOD(GetMarshalSizeMax)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize) { *pSize = 0; return S_OK; }

    STDMETHOD(MarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags) { return S_OK; }

    STDMETHOD(UnmarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);

    STDMETHOD(ReleaseMarshalData)(
            /* [unique][in] */ IStream *pStm) { return S_OK; }

    STDMETHOD(DisconnectObject)(
            /* [in] */ DWORD dwReserved) { return S_OK; }

///////////////////////////////////////////////
// Notifications and callbacks
public:

///////////////////////////////////////////////
// Helper Fns

	HRESULT _EnsureConfHook(void);

private:
	static bool _GetKeyDataForProp(NM_SYSPROP uProp, HKEY * phkey, LPTSTR * ppszSubKey, LPTSTR * ppszValue, bool *pfString);
	static void _GetSzKeyForGuid(LPTSTR psz, REFGUID rguid);
};


#endif // __NmSysInfo_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\agrp.hpp ===
//
// AGRP.HPP
// WbAttributesGroup
//
// Copyright Microsoft 1998-
//

#ifndef __AGRP_HPP_
#define __AGRP_HPP_


#define FONTBUTTONWIDTH        100
#define FONTBUTTONHEIGHT        23


#define PAGEBTN_WIDTH	23
#define PAGEBTN_HEIGHT	23
#define MAX_NUMCHARS	3


//
// Local defines
//
#define BORDER_SIZE_X        ::GetSystemMetrics(SM_CXEDGE)
#define BORDER_SIZE_Y        ::GetSystemMetrics(SM_CYEDGE)
#define SEPARATOR_SIZE_X     6
#define SEPARATOR_SIZE_Y     6

#define DEFAULT_PGC_WIDTH   (8*24)

enum
{
    PGC_FIRST = 0,
    PGC_PREV,
    PGC_ANY,
    PGC_NEXT,
    PGC_LAST,
    PGC_INSERT,
    NUM_PAGE_CONTROLS
};


//
// Indexedby PGC_ value
//
typedef struct tagPAGECTRL
{
    HBITMAP     hbmp;
    HWND        hwnd;
}
PAGECTRL;


//
// The buttons are all BS_BITMAP
// The edit field is ES_CENTER | ES_MULTILINE | ES_NUMBER | WS_BORDER
//



class WbTool;

//
//
// Class:   WbAttributesGroup
//
// Purpose: Define Whiteboard tool attributes display group
//
//
class WbAttributesGroup
{
public:
    WbAttributesGroup();
    ~WbAttributesGroup();

    //
    // Window creation
    //
    BOOL Create(HWND hwndParent, LPCRECT lprc);

    //
    // Display the attributes of the tool passed as parameter
    //
    void DisplayTool(WbTool* pTool);

    //
    // Hide the tool attributes bar.
    //
    void Hide(void);

    //
    // Resizing functions
    //
    void GetNaturalSize(LPSIZE lpsize);


    //
    // Colors
    //
    void SelectColor(WbTool* pTool);
	
    void SetChoiceColor(COLORREF clr)
		{m_colorsGroup.SetCurColor(clr);}

	LRESULT OnEditColors( void )
		{return m_colorsGroup.OnEditColors();}

    void SaveSettings( void )
        {m_colorsGroup.SaveSettings();}

    //
    // Page Controls
    //
    BOOL IsChildEditField(HWND hwnd);

    UINT GetCurrentPageNumber(void);
    void SetCurrentPageNumber(UINT number);
    void SetLastPageNumber(UINT number);

    void EnablePageCtrls(BOOL bEnable);
    void EnableInsert(BOOL bEnable);

    BOOL RecolorButtonImages();

    HWND    m_hwnd;

    friend LRESULT CALLBACK AGWndProc(HWND, UINT, WPARAM, LPARAM);

protected:
    void OnSize(UINT nType, int cx, int cy);
    void OnCommand(UINT id, UINT code, HWND hwndCtl);

    //
    // Color palette
    //
	WbColorsGroup     m_colorsGroup;

    //
    // Font Button
    //
    HWND        m_hwndFontButton;

    //
    // Page controls
    //
    PAGECTRL    m_uPageCtrls[NUM_PAGE_CONTROLS];
    HFONT       m_hPageCtrlFont;
    int         m_cxPageCtrls;

    void        SetPageButtonNo(UINT pgcCtrl, UINT uiPageNumber);
};


#endif // __AGRP_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\bmpobj.cpp ===
//
// BitmapObj.CPP
// Bitmap objects:
//
// Copyright Microsoft 1998-
//
#include "precomp.h"

#include "NMWbObj.h"

BitmapObj::BitmapObj (BitmapCreatePDU * pbitmapCreatePDU)
{
	ResetAttrib();
	SetType(bitmapCreatePDU_chosen);
	SetPenThickness(0);
	SetMyWorkspace(NULL);
	m_lpTransparencyMask = NULL;
	m_lpbiImage = NULL;
	m_lpBitMask = NULL;
	m_hSaveBitmap = NULL;
	m_hOldBitmap = NULL;
	m_hIcon = NULL;
	m_fMoreToFollow = TRUE;

	//
	// Created remotely, not selected, not editing or deleting.
	//
	ClearCreationFlags();
	ClearSelectionFlags();
	ClearEditionFlags();
	ClearDeletionFlags();

	if(pbitmapCreatePDU->bitmapFormatHeader.choice != bitmapHeaderNonStandard_chosen)
	{
	    ERROR_OUT(("Only Handle uncompresed bitmaps"));
	    return;
	}

    SetThisObjectHandle(pbitmapCreatePDU->bitmapHandle);

	UINT workspaceHandle;
	UINT planeID;
	m_ToolType = GetBitmapDestinationAddress(&pbitmapCreatePDU->destinationAddress, &workspaceHandle, &planeID);
	SetWorkspaceHandle(workspaceHandle);
	SetPlaneID(planeID);

	//
	// Get bitmap attributes
	//
	if(pbitmapCreatePDU->bit_mask & BitmapCreatePDU_attributes_present)
	{
		GetBitmapAttrib(pbitmapCreatePDU->attributes);
	}

	//
	// Get bitmap anchor point
	//
	if(pbitmapCreatePDU->bit_mask & BitmapCreatePDU_anchorPoint_present)
	{

		SetAnchorPoint(pbitmapCreatePDU->anchorPoint.xCoordinate, pbitmapCreatePDU->anchorPoint.yCoordinate);
	}

	//
	// Get bitmap size
	//
    m_bitmapSize.x = pbitmapCreatePDU->bitmapSize.width;
    m_bitmapSize.y = pbitmapCreatePDU->bitmapSize.height;

	RECT rect;
	rect.top = pbitmapCreatePDU->anchorPoint.yCoordinate;
	rect.left = pbitmapCreatePDU->anchorPoint.xCoordinate;
	rect.bottom = pbitmapCreatePDU->anchorPoint.yCoordinate + m_bitmapSize.y;
	rect.right = pbitmapCreatePDU->anchorPoint.xCoordinate + m_bitmapSize.x;
	SetRect(&rect);

	//
	// Get bitmap region of interest
	//
	if(pbitmapCreatePDU->bit_mask & bitmapRegionOfInterest_present)
	{
		m_bitmapRegionOfInterest.left = pbitmapCreatePDU->bitmapRegionOfInterest.upperLeft.xCoordinate;
		m_bitmapRegionOfInterest.top = pbitmapCreatePDU->bitmapRegionOfInterest.upperLeft.yCoordinate;
		m_bitmapRegionOfInterest.right = pbitmapCreatePDU->bitmapRegionOfInterest.lowerRight.xCoordinate;
		m_bitmapRegionOfInterest.bottom = pbitmapCreatePDU->bitmapRegionOfInterest.lowerRight.yCoordinate;
	}

    //
    // Get the bitmap pixel aspect ration
    //
    m_pixelAspectRatio = pbitmapCreatePDU->pixelAspectRatio.choice;

	if(pbitmapCreatePDU->bit_mask & BitmapCreatePDU_scaling_present)
	{
		m_scaling.x =  pbitmapCreatePDU->scaling.xCoordinate;
		m_scaling.y =  pbitmapCreatePDU->scaling.yCoordinate;
	}


   	//
   	// Non standard bitmap
   	//
	if((pbitmapCreatePDU->bit_mask & BitmapCreatePDU_nonStandardParameters_present) &&
		pbitmapCreatePDU->nonStandardParameters->value.nonStandardIdentifier.choice == h221nonStandard_chosen)
	{

		m_bitmapData.m_length = pbitmapCreatePDU->nonStandardParameters->value.data.length;
    	m_lpbiImage = (LPBITMAPINFOHEADER)::GlobalAlloc(GPTR, m_bitmapData.m_length);
    	memcpy(m_lpbiImage, // pColor is now pointing to the begining of the bitmap bits
    			pbitmapCreatePDU->nonStandardParameters->value.data.value,
    			m_bitmapData.m_length);
	}

    m_fMoreToFollow = pbitmapCreatePDU->moreToFollow;


    // Create a memory DC compatible with the display
    m_hMemDC = ::CreateCompatibleDC(NULL);

	//
	// If this is a remote pointer
	//
	if(m_ToolType == TOOLTYPE_REMOTEPOINTER)
	{
		CreateColoredIcon(0, m_lpbiImage, m_lpTransparencyMask);
		CreateSaveBitmap();
	}


}

void BitmapObj::Continue (BitmapCreateContinuePDU * pbitmapCreateContinuePDU)
{
	//
	// Get the continuation bitmap data
	//
	BYTE * pNewBitmapBuffer = NULL;
	ULONG length = 0;
	BYTE* pSentBuff;

   	//
   	// Allocate a buffer for the previous data and the one we just got, copy the old data in the new buffer
   	//
	if(pbitmapCreateContinuePDU->bit_mask == BitmapCreateContinuePDU_nonStandardParameters_present)
	{
		length = pbitmapCreateContinuePDU->nonStandardParameters->value.data.length;
		pSentBuff = pbitmapCreateContinuePDU->nonStandardParameters->value.data.value;
	}
	else
	{
		return;
	}

	//
	// Copy the old data
	//
	pNewBitmapBuffer = (BYTE *)::GlobalAlloc(GPTR, m_bitmapData.m_length + length);
	if(pNewBitmapBuffer == NULL)
	{
		TRACE_DEBUG(("Could not allocate memory size = %d)", m_bitmapData.m_length + length));
		return;
	}
	
	memcpy(pNewBitmapBuffer, m_lpbiImage, m_bitmapData.m_length);

	TRACE_DEBUG(("BitmapObj::Continue length = %d moreToFollow = %d)", length, pbitmapCreateContinuePDU->moreToFollow));

	//
	// Copy the new data
	//
    memcpy(pNewBitmapBuffer + m_bitmapData.m_length, pSentBuff, length);

	//
	// delete the old buffer
	//
    ::GlobalFree((HGLOBAL)m_lpbiImage);

	//
	// Update bitmap data info
	//
    m_lpbiImage = (LPBITMAPINFOHEADER)pNewBitmapBuffer;
	m_bitmapData.m_length += length;
	m_lpbiImage->biSizeImage += length;

    m_fMoreToFollow = pbitmapCreateContinuePDU->moreToFollow;
}


BitmapObj::BitmapObj (UINT toolType)
{

	SetType(bitmapCreatePDU_chosen);
	ResetAttrib();
	SetOwnerID(g_MyMemberID);
	SetMyWorkspace(NULL);
	m_ToolType = toolType;
	m_lpTransparencyMask = NULL;
	m_lpbiImage = NULL;
	m_lpBitMask = NULL;
	m_hSaveBitmap = NULL;
	m_hOldBitmap = NULL;
	m_fMoreToFollow = FALSE;

	//
	// Created locally, not selected, not editing or deleting.
	//
	CreatedLocally();
	ClearSelectionFlags();
	ClearEditionFlags();
	ClearDeletionFlags();

	SetPenThickness(0);

	//
	// Set it to 0 so it boundsRect == rect
	//
	RECT rect;
    ::SetRectEmpty(&rect);
	SetRect(&rect);

	
	SetWorkspaceHandle(g_pCurrentWorkspace == NULL ? 0 : g_pCurrentWorkspace->GetWorkspaceHandle());
	SetPlaneID(1);

	SetViewState(unselected_chosen);
	SetZOrder(front);
	SetAnchorPoint(0,0);

	if(m_ToolType == TOOLTYPE_REMOTEPOINTER)
	{
		// We haven't yet created our mem DC
	    m_hSaveBitmap = NULL;
	    m_hOldBitmap = NULL;

    	// Set the bounding rectangle of the object
		rect.left = 0;
		rect.top = 0;
		rect.right = ::GetSystemMetrics(SM_CXICON);
		rect.bottom = ::GetSystemMetrics(SM_CYICON);
		SetRect(&rect);
	}

    // Show that we do not have an icon for drawing yet
    m_hIcon = NULL;

    // Create a memory DC compatible with the display
    m_hMemDC = ::CreateCompatibleDC(NULL);

}

BitmapObj::~BitmapObj( void )
{
	RemoveObjectFromResendList(this);
	RemoveObjectFromRequestHandleList(this);
	
	if(GetMyWorkspace() != NULL && WasDeletedLocally())
	{
		OnObjectDelete();
	}
    ::GlobalFree((HGLOBAL)m_lpbiImage);

	DeleteSavedBitmap();
	
    if (m_hMemDC != NULL)
    {
        ::DeleteDC(m_hMemDC);
        m_hMemDC = NULL;
    }

	if(g_pMain && g_pMain->m_pLocalRemotePointer == this)
	{
		GetAnchorPoint(&g_pMain->m_localRemotePointerPosition);
		g_pMain->m_pLocalRemotePointer = NULL;
		g_pMain->m_TB.PopUp(IDM_REMOTE);
	}

	if(m_lpTransparencyMask)
	{
		delete m_lpTransparencyMask;
		m_lpTransparencyMask = NULL;
	}

	if(m_hIcon)
	{
		::DestroyIcon(m_hIcon);
	}


}
	

void BitmapObj::BitmapEditObj (BitmapEditPDU * pbitmapEditPDU )
{
	RECT		rect;
	POSITION	pos;
	POINT		anchorPoint;
	LONG 		deltaX = 0;
	LONG		deltaY = 0;

	TRACE_MSG(("bitmapHandle = %d", pbitmapEditPDU->bitmapHandle ));

	//
	// Was edited remotely
	//
	ClearEditionFlags();

	//
	// Read attributes
	//
	if(pbitmapEditPDU->bit_mask & BitmapEditPDU_attributeEdits_present)
	{
		GetBitmapAttrib((PBitmapCreatePDU_attributes)pbitmapEditPDU->attributeEdits);
	}

	//
	// Change the anchor point
	//
	GetAnchorPoint(&anchorPoint);
	if(pbitmapEditPDU->bit_mask & BitmapEditPDU_anchorPointEdit_present)
	{

		TRACE_DEBUG(("Old anchor point (%d,%d)", anchorPoint.x, anchorPoint.y));
		TRACE_DEBUG(("New anchor point (%d,%d)",
		pbitmapEditPDU->anchorPointEdit.xCoordinate, pbitmapEditPDU->anchorPointEdit.yCoordinate));
		//
		// Get the delta from previous anchor point
		//
		deltaX =  pbitmapEditPDU->anchorPointEdit.xCoordinate - anchorPoint.x;
		deltaY =  pbitmapEditPDU->anchorPointEdit.yCoordinate - anchorPoint.y;
		TRACE_DEBUG(("Delta (%d,%d)", deltaX , deltaY));

		//
		// Was edited remotely
		//
		ClearEditionFlags();

		//
		// Set new anchor point
		//
		anchorPoint.x = pbitmapEditPDU->anchorPointEdit.xCoordinate;
		anchorPoint.y = pbitmapEditPDU->anchorPointEdit.yCoordinate;
		SetAnchorPoint(anchorPoint.x, anchorPoint.y);

		GetRect(&rect);
		::OffsetRect(&rect,  deltaX, deltaY);
		SetRect(&rect);
	}


//	if(pbitmapEditPDU->bit_mask & BitmapEditPDU_nonStandardParameters_present)
//	{
//		;		// Do the non Standard Edit PDU NYI
//	}

	if(HasAnchorPointChanged())
	{
		g_pDraw->EraseInitialDrawFinal(0 - deltaX,0 - deltaY, FALSE, (T126Obj*)this);
		GetBoundsRect(&rect);
		g_pDraw->InvalidateSurfaceRect(&rect,TRUE);
	}
	else if(HasZOrderChanged())
	{
		if(GetZOrder() == front)
		{
			g_pDraw->BringToTopSelection(FALSE, this);
		}
		else
		{
			g_pDraw->SendToBackSelection(FALSE, this);
		}

	}
	//
	// If it just select/unselected it
	//
	else if(HasViewStateChanged())
	{
	}
	else
	{
		Draw();
	}

	//
	// Reset all the attributes
	//
	ResetAttrib();

}

void    BitmapObj::GetBitmapAttrib(PBitmapCreatePDU_attributes pAttribPDU)
{

	PBitmapCreatePDU_attributes attributes;
	attributes = (PBitmapCreatePDU_attributes)pAttribPDU;
	while(attributes)
	{
		switch(attributes->value.choice)
		{

			case(BitmapAttribute_viewState_chosen):
			{

				if((attributes->value.u.viewState).choice != nonStandardViewState_chosen)
				{
					SetViewState(attributes->value.u.viewState.choice);
					
					//
					// If the other node is selecting the drawing or unselecting
					//
					if(attributes->value.u.viewState.choice == selected_chosen)
					{
						SelectedRemotely();
					}
					else if(attributes->value.u.viewState.choice == unselected_chosen)
					{
						ClearSelectionFlags();
					}

					TRACE_MSG(("Attribute viewState %d", attributes->value.u.viewState.choice));
				}
				else
				{
					// Do the non Standard view state
					;
				}
				break;
			}

			case(BitmapAttribute_zOrder_chosen):
			{
				SetZOrder(attributes->value.u.zOrder);
				TRACE_MSG(("Attribute zOrder %d", attributes->value.u.zOrder));
				break;
			}

			case(BitmapAttribute_transparencyMask_chosen):
			{
				TRACE_MSG(("Attribute transparencyMask"));
				if(attributes->value.u.transparencyMask.bitMask.choice == uncompressed_chosen)
				{
					m_SizeOfTransparencyMask = attributes->value.u.transparencyMask.bitMask.u.uncompressed.length;
					DBG_SAVE_FILE_LINE
					m_lpTransparencyMask = new BYTE[m_SizeOfTransparencyMask];

					memcpy(m_lpTransparencyMask, attributes->value.u.transparencyMask.bitMask.u.uncompressed.value, m_SizeOfTransparencyMask);

					//
					// Asn wants it top bottom left right
					//
//					BYTE swapByte;
//					for (UINT i=0; i <m_SizeOfTransparencyMask ; i++)
//					{
//						swapByte = attributes->value.u.transparencyMask.bitMask.u.uncompressed.value[i];
//						m_lpTransparencyMask [i] = ~(((swapByte >> 4) & 0x0f) | ((swapByte << 4)));
//					}
				}
				break;
			}
			
			case(DrawingAttribute_nonStandardAttribute_chosen):
			{
				break; // NYI
			}

			default:
		    WARNING_OUT(("Invalid attributes choice"));
			break;
		}

		attributes = attributes->next;
	}
}

void BitmapObj::CreateNonStandard24BitBitmap(BitmapCreatePDU * pBitmapCreatePDU)
{
	pBitmapCreatePDU->bit_mask |= BitmapCreatePDU_nonStandardParameters_present;

	//
	// Create the bitmpa header because it is not optional
	//
	pBitmapCreatePDU->bitmapFormatHeader.choice = bitmapHeaderNonStandard_chosen;
	pBitmapCreatePDU->bitmapFormatHeader.u.bitmapHeaderNonStandard.nonStandardIdentifier.choice = bitmapHeaderNonStandard_chosen;
	CreateNonStandardPDU(&pBitmapCreatePDU->bitmapFormatHeader.u.bitmapHeaderNonStandard, NonStandard24BitBitmapID);
	pBitmapCreatePDU->bitmapFormatHeader.u.bitmapHeaderNonStandard.data.length = 0;
	pBitmapCreatePDU->bitmapFormatHeader.u.bitmapHeaderNonStandard.data.value = NULL;

	
	DBG_SAVE_FILE_LINE
	pBitmapCreatePDU->nonStandardParameters = new BitmapCreatePDU_nonStandardParameters;
	pBitmapCreatePDU->nonStandardParameters->next = NULL;
	CreateNonStandardPDU(&pBitmapCreatePDU->nonStandardParameters->value, NonStandard24BitBitmapID);
	
}


void BitmapObj::CreateBitmapCreatePDU(CWBOBLIST * pCreatePDUList)
{

	if(m_lpbiImage == NULL)
	{
		TRACE_MSG(("We dont have a bitmap structure to sent"));
		return;
	}

	
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(!sipdu)
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        return;
	}

	//
	// This is the first bitmap create pdu
	//
	sipdu->choice = bitmapCreatePDU_chosen;
	BitmapCreatePDU *pCreatePDU = &sipdu->u.bitmapCreatePDU;

	pCreatePDU->bit_mask = 0;
	pCreatePDU->nonStandardParameters = NULL;

	//
	// Pass the bitmap Handle
	//
	pCreatePDU->bitmapHandle = GetThisObjectHandle();

	//
	// Pass the destination adress
	//
	if(	m_ToolType == TOOLTYPE_REMOTEPOINTER)
	{
		pCreatePDU->destinationAddress.choice = softCopyPointerPlane_chosen;
		pCreatePDU->destinationAddress.u.softCopyPointerPlane.workspaceHandle = GetMyWorkspace()->GetWorkspaceHandle();
	}
	else
	{
		pCreatePDU->destinationAddress.choice = BitmapDestinationAddress_softCopyImagePlane_chosen;
		pCreatePDU->destinationAddress.u.softCopyImagePlane.workspaceHandle = GetMyWorkspace()->GetWorkspaceHandle();
		pCreatePDU->destinationAddress.u.softCopyImagePlane.plane = (DataPlaneID)GetPlaneID();
	}

	//
	// Pass the bitmap attributes
	//
	pCreatePDU->bit_mask |=BitmapCreatePDU_attributes_present;
 	SetBitmapAttrib(&pCreatePDU->attributes);

	//
	// Pass the anchor point
	//
    pCreatePDU->bit_mask |=BitmapCreatePDU_anchorPoint_present;
	POINT point;
	GetAnchorPoint(&point);
    pCreatePDU->anchorPoint.xCoordinate = point.x;
    pCreatePDU->anchorPoint.yCoordinate = point.y;

	//
	// Pass the bitmap size
	//
	pCreatePDU->bitmapSize.width = m_bitmapSize.x;
	pCreatePDU->bitmapSize.height = m_bitmapSize.y;

	//
	// Pass bitmap region of interest
	//
	pCreatePDU->bit_mask |=bitmapRegionOfInterest_present;
    BitmapRegion bitmapRegionOfInterest;

	//
	// Pass pixel aspect ratio
	//
    pCreatePDU->pixelAspectRatio.choice = PixelAspectRatio_square_chosen;

	//
	// Pass scaling factor
	//
//	pCreatePDU->bit_mask |=BitmapCreatePDU_scaling_present;
//  pCreatePDU->scaling.xCoordinate = 0;
//  pCreatePDU->scaling.yCoordinate = 0;

	//
	// Pass check points
//
//	pCreatePDU->bit_mask |=checkpoints_present;
//  pCreatePDU->checkpoints;

	//
	// JOSEF If we want > 8 have to recalculate to 24
	//
	
	LPSTR pDIB_bits;
	LPBITMAPINFOHEADER lpbi8 = m_lpbiImage;
	HDC hdc = NULL;
	HBITMAP hbmp = NULL;
	DWORD sizeOfBmpData = 0;

	if(!g_pNMWBOBJ->CanDo24BitBitmaps())
	{
	
		hdc = GetDC(NULL);
		
		BITMAPINFOHEADER lpbmih;
		if(lpbi8->biBitCount > MAX_BITS_PERPIXEL)
		{
	
			lpbmih.biSize = sizeof(BITMAPINFOHEADER);
			lpbmih.biWidth = lpbi8->biWidth;
			lpbmih.biHeight = lpbi8->biHeight;
			lpbmih.biPlanes = 1;
			lpbmih.biBitCount = MAX_BITS_PERPIXEL;
			lpbmih.biCompression = lpbi8->biCompression;
			lpbmih.biSizeImage = lpbi8->biSizeImage;
			lpbmih.biXPelsPerMeter = lpbi8->biXPelsPerMeter;
			lpbmih.biYPelsPerMeter = lpbi8->biYPelsPerMeter;
			lpbmih.biClrUsed = lpbi8->biClrUsed;
			lpbmih.biClrImportant = lpbi8->biClrImportant;
	
			hbmp = CreateDIBitmap(hdc, &lpbmih, CBM_INIT, DIB_Bits(lpbi8),(LPBITMAPINFO)lpbi8, DIB_RGB_COLORS);
			lpbi8 = DIB_FromBitmap(hbmp, NULL, FALSE, FALSE);
		}
	}

	pDIB_bits = (LPSTR)lpbi8;
	sizeOfBmpData = DIB_TotalLength(lpbi8);

	
	
	//
	// Sending data
	//
	BOOL bMoreToFollow = FALSE;
	DWORD length = sizeOfBmpData;
	
	pCreatePDU->bitmapData.bit_mask = 0;
	
	if(sizeOfBmpData > MAX_BITMAP_DATA)
	{
		length = MAX_BITMAP_DATA;
		bMoreToFollow = TRUE;
	}
	
	pCreatePDU->moreToFollow = (ASN1bool_t)bMoreToFollow;
	//
	// Pass the bitmap info
	//
	pCreatePDU->bit_mask |= BitmapCreatePDU_nonStandardParameters_present;
	CreateNonStandard24BitBitmap(&sipdu->u.bitmapCreatePDU);
	pCreatePDU->nonStandardParameters->value.data.length = length;
	pCreatePDU->nonStandardParameters->value.data.value = (ASN1octet_t *)pDIB_bits;

	//
	// We are not passing it into the data field
	//
	pCreatePDU->bitmapData.bit_mask = 0;
	pCreatePDU->bitmapData.data.length = 1;

	pCreatePDUList->AddTail(sipdu);
	
	BitmapCreateContinuePDU * pCreateContinuePDU;
	while(bMoreToFollow)
	{
		//
		// Advance the pointer
		//
		pDIB_bits += MAX_BITMAP_DATA;
		sizeOfBmpData-= MAX_BITMAP_DATA;
	
		if(sizeOfBmpData > MAX_BITMAP_DATA)
		{
			length = MAX_BITMAP_DATA;
		}
		else
		{
			length = sizeOfBmpData;
			bMoreToFollow = FALSE;
		}

		//
		// Create a new BitmapCreateContinuePDU
		//
		sipdu = NULL;
		DBG_SAVE_FILE_LINE
		sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
		if(!sipdu)
		{
			TRACE_MSG(("Failed to create sipdu"));
	        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	        return;
		}

		sipdu->choice = bitmapCreateContinuePDU_chosen;
		pCreateContinuePDU = &sipdu->u.bitmapCreateContinuePDU;
		
		pCreateContinuePDU->bit_mask = 0;
		pCreateContinuePDU->nonStandardParameters = NULL;

	
		//
		// Pass the bitmap Handle
		//
		pCreateContinuePDU->bitmapHandle = GetThisObjectHandle();
			
		//
		// Pass the data
		//
		pCreateContinuePDU->bit_mask |= BitmapCreateContinuePDU_nonStandardParameters_present;
			
		//
		// Pass the bitmap info
		//
		DBG_SAVE_FILE_LINE
		pCreateContinuePDU->nonStandardParameters = new BitmapCreateContinuePDU_nonStandardParameters;
		pCreateContinuePDU->nonStandardParameters->next = NULL;
			
		CreateNonStandardPDU(&pCreateContinuePDU->nonStandardParameters->value, NonStandard24BitBitmapID);
		pCreateContinuePDU->nonStandardParameters->value.data.length = length;
		pCreateContinuePDU->nonStandardParameters->value.data.value = (ASN1octet_t *)pDIB_bits;

		//
		// We are not passing it into the data field
		//
		pCreateContinuePDU->bitmapData.bit_mask = 0;
		pCreateContinuePDU->bitmapData.data.length = 1;
		
		pCreateContinuePDU->moreToFollow = (ASN1bool_t) bMoreToFollow;
		pCreatePDUList->AddTail(sipdu);
		
	}
	
	if(hbmp)
	{
		DeleteObject(hbmp);
	}
	
	if(hdc)
	{
		ReleaseDC(NULL, hdc);
	}
}
	
void BitmapObj::CreateBitmapEditPDU(BitmapEditPDU *pEditPDU)
{
	pEditPDU->bit_mask = (ASN1uint16_t) GetPresentAttribs();

	//
	// Pass the anchor point
	//
	if(HasAnchorPointChanged())
	{
		POINT point;
		GetAnchorPoint(&point);
		pEditPDU->anchorPointEdit.xCoordinate = point.x;
		pEditPDU->anchorPointEdit.yCoordinate = point.y;
	}

	//
	// JOSEF Pass Region of interest (FEATURE)
	//

	//
	// JOSEF Pass scaling (FEATURE)
	//
	
	//
	// Pass all the changed attributes, if any.
	//
	pEditPDU->attributeEdits = NULL;
	if(pEditPDU->bit_mask & BitmapEditPDU_attributeEdits_present)
	{
		SetBitmapAttrib((PBitmapCreatePDU_attributes *)&pEditPDU->attributeEdits);
	}
	
	pEditPDU->bitmapHandle = GetThisObjectHandle();

}
	
void BitmapObj::CreateBitmapDeletePDU(BitmapDeletePDU *pDeletePDU)
{
	pDeletePDU->bit_mask = 0;
	pDeletePDU->bitmapHandle = GetThisObjectHandle();
}


void    BitmapObj::AllocateAttrib(PBitmapCreatePDU_attributes *pAttributes)
{
	DBG_SAVE_FILE_LINE
	PBitmapCreatePDU_attributes  pAttrib = (PBitmapCreatePDU_attributes)new BYTE[sizeof(BitmapCreatePDU_attributes)];
	if(*pAttributes == NULL)
	{
		*pAttributes = pAttrib;	
		pAttrib->next = NULL;
	}
	else
	{
		((PBitmapCreatePDU_attributes)pAttrib)->next = *pAttributes;
		*pAttributes = pAttrib;
	}
}





void    BitmapObj::SetBitmapAttrib(PBitmapCreatePDU_attributes *pattributes)
{
	PBitmapCreatePDU_attributes attributes = NULL;

	//
	// Do the viewState
	//
	if(HasViewStateChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = BitmapAttribute_viewState_chosen;
		attributes->value.u.viewState.choice = (ASN1choice_t)GetViewState();
	}

	//
	// Do the zOrder
	//
	if(HasZOrderChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = BitmapAttribute_zOrder_chosen;
		attributes->value.u.zOrder = GetZOrder();
	}


	//
	// Do the Transparency
	//
	if(HasTransparencyMaskChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = BitmapAttribute_transparencyMask_chosen;
		attributes->value.u.transparencyMask.bit_mask = 0;
		attributes->value.u.transparencyMask.bitMask.choice = uncompressed_chosen;
		attributes->value.u.transparencyMask.bitMask.u.uncompressed.length = m_SizeOfTransparencyMask;
		attributes->value.u.transparencyMask.bitMask.u.uncompressed.value = m_lpTransparencyMask;
	}
	
	//
	// End of attributes
	//
	*pattributes = attributes;

}


void	BitmapObj::Draw(HDC hDC, BOOL bForcedDraw, BOOL bPrinting)
{

	if(!bPrinting)
	{
		//
		// Don't draw anything if we don't belong in this workspace
		//
		if(GetWorkspaceHandle() != g_pCurrentWorkspace->GetThisObjectHandle())
		{
			return;
		}
	}

	RECT	clipBox;
	RECT 	rect;
	GetRect(&rect);

	if(hDC == NULL)
	{
		hDC = g_pDraw->m_hDCCached;
	}
	
	MLZ_EntryOut(ZONE_FUNCTION, "BitmapObj::Draw");

	// Only draw anything if the bounding rectangle intersects
	// the current clip box.
	if (::GetClipBox(hDC, &clipBox) == ERROR)
	{
		WARNING_OUT(("Failed to get clip box"));
	}
	else if (!::IntersectRect(&clipBox, &clipBox, &rect))
	{
		TRACE_MSG(("No clip/bounds intersection"));
		return;
	}

	if(m_ToolType == TOOLTYPE_FILLEDBOX)
	{
		if(m_fMoreToFollow)
		{
			return;
		}

	    // Set the stretch mode to be used so that scan lines are deleted
		// rather than combined. This will tend to preserve color better.
		int iOldStretchMode = ::SetStretchBltMode(hDC, STRETCH_DELETESCANS);

		// Draw the bitmap
		::StretchDIBits(hDC,
						 rect.left,
						 rect.top,
						 rect.right - rect.left,
						 rect.bottom - rect.top,
						 0,
						 0,
						 (UINT) m_lpbiImage->biWidth,
						 (UINT) m_lpbiImage->biHeight,
						 (VOID FAR *) DIB_Bits(m_lpbiImage),
						 (LPBITMAPINFO)m_lpbiImage,
						 DIB_RGB_COLORS,
						 SRCCOPY);

		// Restore the stretch mode
		::SetStretchBltMode(hDC, iOldStretchMode);
	}
 	else
	{
		// Create the save bitmap if necessary
		CreateSaveBitmap();

		// Draw the icon
		::DrawIcon(hDC, rect.left, rect.top, m_hIcon);
  	
	}

}



//
//
// Function:    BitmapObj::::FromScreenArea
//
// Purpose:     Set the content of the object from an area of the screen
//
//
void BitmapObj::FromScreenArea(LPCRECT lprcScreen)
{
    m_lpbiImage = DIB_FromScreenArea(lprcScreen);
    if (m_lpbiImage == NULL)
    {
        ::Message(NULL, (UINT)IDS_MSG_CAPTION, (UINT)IDS_CANTGETBMP, (UINT)MB_OK );
    }
    else
    {

		m_bitmapSize.x = m_lpbiImage->biWidth;
		m_bitmapSize.y = m_lpbiImage->biHeight;

		RECT rect;
    	GetBoundsRect(&rect);
        // Calculate the bounding rectangle from the size of the bitmap
        rect.right = rect.left + m_lpbiImage->biWidth;
        rect.bottom = rect.top + m_lpbiImage->biHeight;
		SetRect(&rect);
    }
}


UINT GetBitmapDestinationAddress(BitmapDestinationAddress *destinationAddress, PUINT workspaceHandle, PUINT planeID)
{
	UINT toolType = TOOLTYPE_FILLEDBOX;

	//
	// Get the destination address
	//
	switch(destinationAddress->choice)
	{

		case(BitmapDestinationAddress_softCopyImagePlane_chosen):
		{
			*workspaceHandle = (destinationAddress->u.softCopyImagePlane.workspaceHandle);
			*planeID = (destinationAddress->u.softCopyImagePlane.plane);
			break;
		}
		case(BitmapDestinationAddress_softCopyAnnotationPlane_chosen):
		{
			*workspaceHandle = (destinationAddress->u.softCopyAnnotationPlane.workspaceHandle);
			*planeID = (destinationAddress->u.softCopyAnnotationPlane.plane);
			break;
		}
		case(softCopyPointerPlane_chosen):
		{
			*workspaceHandle = (destinationAddress->u.softCopyPointerPlane.workspaceHandle);
			*planeID = (0);
			toolType = TOOLTYPE_REMOTEPOINTER;
			break;
		}
	
//		case(BitmapDestinationAddress_nonStandardDestination_chosen):
//		{
//			break;
//		}

		default:
	    ERROR_OUT(("Invalid destinationAddress"));
		break;
	}
	return toolType;
}


//
// UI Edited the Bitmap Object
//
void BitmapObj::OnObjectEdit(void)
{
	g_bContentsChanged = TRUE;
	
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = bitmapEditPDU_chosen;
		CreateBitmapEditPDU(&sipdu->u.bitmapEditPDU);
		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}

}

//
// UI Deleted the Bitmap Object
//
void BitmapObj::OnObjectDelete(void)
{
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = bitmapDeletePDU_chosen;
		CreateBitmapDeletePDU(&sipdu->u.bitmapDeletePDU);
		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}

}

void	BitmapObj::GetEncodedCreatePDU(ASN1_BUF *pBuf)
{
	pBuf->length = DIB_TotalLength(m_lpbiImage);
	pBuf->value = (PBYTE)m_lpbiImage;
}



//
// UI Created a new Bitmap Object
//
void BitmapObj::SendNewObjectToT126Apps(void)
{
	SIPDU *sipdu = NULL;
	CWBOBLIST BitmapContinueCreatePDUList;
	BitmapContinueCreatePDUList.EmptyList();
	CreateBitmapCreatePDU(&BitmapContinueCreatePDUList);
	T120Error rc = T120_NO_ERROR;
	
	WBPOSITION pos = BitmapContinueCreatePDUList.GetHeadPosition();
	while (pos != NULL)
    {
		sipdu = (SIPDU *) BitmapContinueCreatePDUList.GetNext(pos);
		TRACE_DEBUG(("Sending Bitmap >> Bitmap handle  = %d", sipdu->u.bitmapCreatePDU.bitmapHandle ));
		if(g_bSavingFile && GraphicTool() == TOOLTYPE_REMOTEPOINTER)
		{
			; // Don't send Remote pointers to disk
		}
		else
		{
			if(!m_fMoreToFollow)
			{
				rc = SendT126PDU(sipdu);
			}
		}

		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}
			
	}
	BitmapContinueCreatePDUList.EmptyList();

}




//
//
// Function:	CreateColoredIcon
//
// Purpose:	 Create an icon of the correct color for this pointer.
//
//
HICON BitmapObj::CreateColoredIcon(COLORREF color, LPBITMAPINFOHEADER lpbInfo, LPBYTE pMaskBits)
{
	HICON	   hColoredIcon = NULL;
	HBRUSH	  hBrush = NULL;
	HBRUSH	  hOldBrush;
	HBITMAP	 hImage = NULL;
	HBITMAP	 hOldBitmap;
	HBITMAP	 hMask = NULL;
	COLOREDICON  *pColoredIcon;
	ICONINFO	ii;
	UINT i;
	LPSTR pBits;
	LPBITMAPINFOHEADER lpbi;
	BYTE swapByte;

	color = SET_PALETTERGB(color);
	
	MLZ_EntryOut(ZONE_FUNCTION, "RemotePointerObject::CreateColoredIcon");

	//
	// Create the mask for the icon with the data sent through T126
	//
	if(pMaskBits && lpbInfo)
	{
		hMask = CreateBitmap(lpbInfo->biWidth, lpbInfo->biHeight, 1, 1, m_lpTransparencyMask);
	}
	//
	// Create the local mask
	//
	else
	{
		// Load the mask bitmap
		hMask = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(REMOTEPOINTERANDMASK));
		if (!hMask)
		{
			TRACE_MSG(("Could not load mask bitmap"));
			goto CreateIconCleanup;
		}
	}	

	//
	// Create a bitmap with the data that sent through T126
	//
	if(lpbInfo)
	{
		VOID *ppvBits;
		hImage = CreateDIBSection(m_hMemDC, (LPBITMAPINFO)lpbInfo, DIB_RGB_COLORS, &ppvBits, NULL, 0);

		if(!ppvBits)
		{
			TRACE_MSG(("CreateColoredIcon failed calling CreateDIBSection  error = %d", GetLastError()));
			goto CreateIconCleanup;
		}

		
		pBits = DIB_Bits(lpbInfo);

		::GetDIBits(m_hMemDC, hImage, 0, (WORD) lpbInfo->biHeight, NULL,(LPBITMAPINFO)lpbInfo, DIB_RGB_COLORS);
		memcpy(ppvBits, pBits, lpbInfo->biSizeImage);
		if(!hMask)
		{
			hMask = CreateBitmap(lpbInfo->biWidth, lpbInfo->biHeight, 1, 1, NULL);
		}
	}
	//
	// Create a local bitmap
	//
	else
	{
		// Load the image bitmap
		hImage = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(REMOTEPOINTERXORDATA));
		if (!hImage)
		{
			TRACE_MSG(("Could not load pointer bitmap"));
			goto CreateIconCleanup;
		}

		hBrush = ::CreateSolidBrush(color);
		if (!hBrush)
		{
			TRACE_MSG(("Couldn't create color brush"));
			goto CreateIconCleanup;
		}

		// Select in the icon color
		hOldBrush = SelectBrush(m_hMemDC, hBrush);

		// Select the image bitmap into the memory DC
		hOldBitmap = SelectBitmap(m_hMemDC, hImage);

		if(!hOldBitmap)
		{
			ERROR_OUT(("DeleteSavedBitmap - Could not select old bitmap"));
		}

		// Fill the image bitmap with color
		::FloodFill(m_hMemDC, ::GetSystemMetrics(SM_CXICON) / 2, ::GetSystemMetrics(SM_CYICON) / 2, RGB(0, 0, 0));

		SelectBitmap(m_hMemDC, hOldBitmap);

		SelectBrush(m_hMemDC, hOldBrush);
   	}

	//
	// Now use the image and mask bitmaps to create an icon
	//
	ii.fIcon = TRUE;
	ii.xHotspot = 0;
	ii.yHotspot = 0;
	ii.hbmMask = hMask;
	ii.hbmColor = hImage;

	// Create a new icon from the data and mask
	hColoredIcon = ::CreateIconIndirect(&ii);

	//
	// Create the internal format if we were created locally
	//
	if(m_lpbiImage == NULL)
	{
		m_lpbiImage = DIB_FromBitmap(hImage, NULL, FALSE, FALSE, TRUE);
	}	

	if(m_lpTransparencyMask == NULL)
	{
		ChangedTransparencyMask();
		
		lpbi = DIB_FromBitmap(hMask,NULL,FALSE, TRUE);
		pBits = DIB_Bits(lpbi);
		m_SizeOfTransparencyMask = lpbi->biSizeImage;
		DBG_SAVE_FILE_LINE
		m_lpTransparencyMask = new BYTE[m_SizeOfTransparencyMask];
		memcpy(m_lpTransparencyMask, pBits, m_SizeOfTransparencyMask );
		::GlobalFree(lpbi);
	}	
	
	if (m_lpbiImage == NULL)
	{
		::Message(NULL, (UINT)IDS_MSG_CAPTION, (UINT)IDS_CANTGETBMP, (UINT)MB_OK );
	}
	else
	{

		m_bitmapSize.x = m_lpbiImage->biWidth;
		m_bitmapSize.y = m_lpbiImage->biHeight;

		RECT rect;
		GetBoundsRect(&rect);
		// Calculate the bounding rectangle from the size of the bitmap
		rect.right = rect.left + m_lpbiImage->biWidth;
		rect.bottom = rect.top + m_lpbiImage->biHeight;
		SetRect(&rect);
		SetAnchorPoint(rect.left, rect.top);

 	}

CreateIconCleanup:

	// Free the image bitmap
	if (hImage != NULL)
	{
		::DeleteBitmap(hImage);
	}

	// Free the mask bitmap
	if (hMask != NULL)
	{
		::DeleteBitmap(hMask);
	}

	if (hBrush != NULL)
	{
		::DeleteBrush(hBrush);
	}

	m_hIcon = hColoredIcon;
	
	return(hColoredIcon);
}


//
//
// Function:    BitmapObj::CreateSaveBitmap()
//
// Purpose:     Create a bitmap for saving the bits under the pointer.
//
//
void BitmapObj::CreateSaveBitmap()
{
    MLZ_EntryOut(ZONE_FUNCTION, "BitmapObj::CreateSaveBitmap");

    // If we already have a save bitmap, exit immediately
    if (m_hSaveBitmap != NULL)
    {
        TRACE_MSG(("Already have save bitmap"));
        return;
    }

    // Create a bitmap to save the bits under the icon. This bitmap is
    // created with space for building the new screen image before
    // blitting it to the screen.
	RECT rect;
	RECT    rcVis;

	POINT point;
	POINT delta;
	HDC hDC = NULL;
    g_pDraw->GetVisibleRect(&rcVis);
	GetRect(&rect);

	delta.x = rect.right - rect.left;
	delta.y = rect.bottom - rect.top;

	point.x = rect.left - rcVis.left;
	point.y = rect.top - rcVis.top;

	ClientToScreen (g_pDraw->m_hwnd, &point);

	rect.left = point.x;
	rect.top = point.y;
	rect.right = rect.left + delta.x;
	rect.bottom = rect.top + delta.y;

	//
	// Create the bitmap
	//
	m_hSaveBitmap = FromScreenAreaBmp(&rect);

}

//
//
// Function:    BitmapObj::Undraw()
//
// Purpose:     Draw the marker object
//
//
void BitmapObj::UnDraw(void)
{
	if(GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{

		// Create the save bitmap if necessary
		CreateSaveBitmap();

		//
		// Select the saved area
		//
		if(m_hSaveBitmap)
		{
			m_hOldBitmap = SelectBitmap(m_hMemDC, m_hSaveBitmap);
			if(!m_hOldBitmap)
			{
				ERROR_OUT(("DeleteSavedBitmap - Could not select old bitmap"));
			}
		}

		// Copy the saved bits onto the screen
		UndrawScreen();
	}
	else
	{
		RECT rect;
		GetBoundsRect(&rect);
		g_pDraw->InvalidateSurfaceRect(&rect,TRUE);
	}
	
}

//
//
// Function:    BitmapObj::UndrawScreen()
//
// Purpose:     Copy the saved bits under the pointer to the screen.
//
//
BOOL BitmapObj::UndrawScreen()
{
    BOOL    bResult = FALSE;
    RECT    rcUpdate;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::UndrawScreen");

	GetRect(&rcUpdate);


    // We are undrawing - copy the saved bits to the DC passed
    bResult = ::BitBlt(g_pDraw->m_hDCCached, rcUpdate.left, rcUpdate.top,
        rcUpdate.right - rcUpdate.left, rcUpdate.bottom - rcUpdate.top,
        m_hMemDC, 0, 0, SRCCOPY);

    if (!bResult)
    {
        WARNING_OUT(("UndrawScreen - Could not copy from bitmap"));
    }
	else
	{
		DeleteSavedBitmap();
	}


    return(bResult);
}

void BitmapObj::DeleteSavedBitmap(void)
{

	// Restore the original bitmap to the memory DC
	if (m_hOldBitmap != NULL)
	{
		if(!SelectBitmap(m_hMemDC, m_hOldBitmap))
		{
			ERROR_OUT(("DeleteSavedBitmap - Could not select old bitmap"));
		}

//		if(!DeleteBitmap(m_hOldBitmap))
//		{
//			ERROR_OUT(("DeleteSavedBitmap - Could not delete old bitmap"));
//		}
		m_hOldBitmap = NULL;
	}

	if (m_hSaveBitmap != NULL)
	{
		if(!DeleteBitmap(m_hSaveBitmap))
		{
			ERROR_OUT(("DeleteSavedBitmap - Could not delete bitmap"));
		}
		m_hSaveBitmap = NULL;
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\bmpobj.hpp ===
//
// BITMAPOBJ.HPP
// Bitmap objects:
//
// Copyright Microsoft 1998-
//
#ifndef __BITMAPOBJ_HPP_
#define __BITMAPOBJ_HPP_

typedef struct COLOREDICON
{
	HICON    hIcon;
 	COLORREF color;
} COLORED_ICON;


#define MAX_BITMAP_DATA 8192

UINT GetBitmapDestinationAddress(BitmapDestinationAddress *destinationAddress, PUINT workspaceHandle, PUINT planeID);

#define NonStandard24BitBitmapID "Bitmap24\0"

typedef struct tagBITMAP_DATA
{
	//
	// Data Buffer
	//
    BOOL m_bdataCheckpoint;
    UINT m_padBits;
	UINT m_length;
} BITMAPDATA, *PBITMAPDATA;


class BitmapObj : public T126Obj
{

public:

	BitmapObj (BitmapCreatePDU * pbitmapCreatePDU);
	void Continue (BitmapCreateContinuePDU * pbitmapCreateContinuePDU);
	BitmapObj (UINT);
	~BitmapObj( void );

	void Draw(HDC hDC = NULL, BOOL bForcedDraw = FALSE, BOOL bPrinting = FALSE);
	BOOL CheckReallyHit(LPCRECT pRectHit){return RectangleHit(FALSE, pRectHit);}
	void FromScreenArea(LPCRECT lprcScreen);

	BOOL HasFillColor(void){return FALSE;}
	void SetFillColor(COLORREF cr, BOOL isPresent){}
    BOOL GetFillColor(COLORREF * pcr){return FALSE;}
    BOOL GetFillColor(RGBTRIPLE* prgb){return FALSE;}

	void SetPenColor(COLORREF cr, BOOL isPresent){}
    BOOL GetPenColor(COLORREF * pcr) {return FALSE;}
    BOOL GetPenColor(RGBTRIPLE* prgb){return FALSE;}

    void SetViewHandle(UINT viewHandle){};


	void DeleteSavedBitmap(void);
	void BitmapEditObj ( BitmapEditPDU * pbitmapEditPDU );
	void GetBitmapAttrib(PBitmapCreatePDU_attributes pAttribPDU);
	void SetBitmapAttrib(PBitmapCreatePDU_attributes *pattributes);
	void AllocateAttrib(PBitmapCreatePDU_attributes *pAttributes);

	//
	// PDU stuff
	//
	void CreateBitmapCreatePDU(CWBOBLIST * pCreatePDUList);
	void CreateBitmapEditPDU(BitmapEditPDU *pEditPDU);
	void CreateBitmapDeletePDU(BitmapDeletePDU *pDeletePDU);
	void CreateNonStandard24BitBitmap(BitmapCreatePDU * pBitmapCreatePDU);


	LPBITMAPINFOHEADER  m_lpbiImage;		// local copy of the DIB
	LPBITMAPINFOHEADER	m_lpBitMask;		// Bitmask for transparent bitmaps.
	LPBYTE				m_lpTransparencyMask;
	UINT				m_SizeOfTransparencyMask;
	
	BOOL				m_fMoreToFollow;

	//
	// Masks 0x000000007 (BitmapAttribute_viewState_chosen = 1... BitmapAttribute_transparencyMask_chosen = 3)
	//
	void ChangedViewState(void){m_dwChangedAttrib |= (1 << (BitmapAttribute_viewState_chosen-1)) |
								BitmapEditPDU_attributeEdits_present;};
	void ChangedZOrder(void){m_dwChangedAttrib |= (1 << (BitmapAttribute_zOrder_chosen-1)) |
								BitmapEditPDU_attributeEdits_present;};
	void ChangedTransparencyMask(void){m_dwChangedAttrib |= (1 << (BitmapAttribute_transparencyMask_chosen-1)) |
								BitmapEditPDU_attributeEdits_present;};

	BOOL HasViewStateChanged(void){return (m_dwChangedAttrib & ( 1 << (BitmapAttribute_viewState_chosen-1)));};
	BOOL HasZOrderChanged(void){return (m_dwChangedAttrib & ( 1 << (BitmapAttribute_zOrder_chosen-1)));};
	BOOL HasTransparencyMaskChanged(void){return (m_dwChangedAttrib & ( 1 << (BitmapAttribute_transparencyMask_chosen-1)));};

	//
	// Masks 0x000000070 (BitmapEditPDU_scalingEdit_present = 0x10... BitmapEditPDU_anchorPointEdit_present = 0x40)
	//
	void ChangedAnchorPoint(void){ m_dwChangedAttrib |= BitmapEditPDU_anchorPointEdit_present;}
	void ChangedRegionOfInterest(void){ m_dwChangedAttrib |= bitmapRegionOfInterestEdit_present;}
	void ChangedScaling(void){ m_dwChangedAttrib |= BitmapEditPDU_scalingEdit_present;}

	BOOL HasAnchorPointChanged(void){ return (m_dwChangedAttrib & BitmapEditPDU_anchorPointEdit_present);}
	BOOL HasRegionOfInterestChanged(void){ return (m_dwChangedAttrib & bitmapRegionOfInterestEdit_present);}
	BOOL HasScalingChanged(void){ return (m_dwChangedAttrib & BitmapEditPDU_scalingEdit_present);}
	void ResetAttrib(void){m_dwChangedAttrib = 0;}
	void SetAllAttribs(void){m_dwChangedAttrib = 0x07;}
	DWORD GetPresentAttribs(void){return ((m_dwChangedAttrib & 0x0F0));}

	void ChangedPenThickness(void){};

	void	OnObjectEdit(void);
	void	OnObjectDelete(void);
	void	SendNewObjectToT126Apps(void);
	void	GetEncodedCreatePDU(ASN1_BUF *pBuf);


	//Remote pointer stuff
    //
    // Device context used for drawing and undrawing the pointer
    //
    HDC         m_hMemDC;

    //
    // Pointer to the bitmap used to save the data under the pointer
    //
    HBITMAP     m_hSaveBitmap;

    //
    // Handle of bitmap originally supplied with memDC
    //
    HBITMAP     m_hOldBitmap;

    //
    // Handle of icon to be used for drawing
    //
    HICON       m_hIcon;

	HICON	CreateColoredIcon(COLORREF color, LPBITMAPINFOHEADER lpbInfo = NULL, LPBYTE pMaskBits = NULL);
	void	CreateSaveBitmap();
	void	UnDraw(void);
	BOOL	UndrawScreen();
	void	SetBitmapSize(LONG x, LONG y){m_bitmapSize.x = x; m_bitmapSize.y = y;}

protected:

	DWORD			m_dwChangedAttrib;
	POINT			m_bitmapSize;			// Width, Height
	RECT			m_bitmapRegionOfInterest;
	UINT			m_pixelAspectRatio;
	POINT			m_scaling;
	UINT			m_checkPoints;
	BITMAPDATA		m_bitmapData;

};


#endif // __BITMAPOBJ_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\ccl32.hpp ===
//
// CCL32.HPP
// Common Control Classes
//
// Copyright Microsoft 1998-
//

#ifndef CCL32_HPP
#define CCL32_HPP


#define HLP_MENU_ITEM_OFFSET	0x10000

	
#define HLP_BASE				600
enum
{
    IDH_CONTENTS = HLP_BASE + 1,
    IDH_SEARCH,
    IDH_ABOUT,
    IDH_HELPHELP,
    HLP_PROCESSED
};



#define HELPID_WBSAVEASDLG      4070
#define HELPID_WBFILEMENU       4140
#define HELPID_WBEDITMENU       4150
#define HELPID_WBVIEWMENU       4160
#define HELPID_WBTOOLSMENU      4170
#define HELPID_WBHELPMENU       4190
#define HELPID_WBWIDTHMENU      4210
#define HELPID_WBSYSTEMMENU     4300


//
// IMM32 stuff
//
typedef HIMC (WINAPI * IGC_PROC)(HWND);
typedef BOOL (WINAPI * INI_PROC)(HIMC, DWORD, DWORD, DWORD);

extern void  UT_CaptureMouse( HWND   hwnd );
extern void  UT_ReleaseMouse( HWND  hwnd );



//
// Option entry names
//

#define OPT_MAIN_STATUSBARVISIBLE       "StatusBarVisible"
#define OPT_MAIN_TOOLBARVISIBLE         "ToolBarVisible"
#define OPT_MAIN_MAXIMIZED              "Maximized"
#define OPT_MAIN_MINIMIZED              "Minimized"
#define OPT_MAIN_MAINWINDOWRECT         "MainWindowPosition"
#define OPT_MAIN_SELECTWINDOW_NOTAGAIN  "GrabWindow_dontwarn"
#define OPT_MAIN_SELECTAREA_NOTAGAIN    "GrabArea_dontwarn"
#define OPT_MAIN_COLORPALETTE		    "ColorPalette"
#define OPT_MAIN_CUSTOMCOLORS		    "CustomColors"

#define DFLT_MAIN_STATUSBARVISIBLE      TRUE
#define DFLT_MAIN_TOOLBARVISIBLE        TRUE
#define DFLT_MAIN_MAXIMIZED             FALSE			
#define DFLT_MAIN_MINIMIZED             FALSE			
#define DFLT_MAIN_SELECTWINDOW_NOTAGAIN FALSE			
#define DFLT_MAIN_SELECTAREA_NOTAGAIN   FALSE			



//
// Settings routines
//

//
// GetIntegerOption retrieves and converts an option string to a long.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
LONG OPT_GetIntegerOption(LPCSTR cstrOptionName,
                          LONG lDefault = 0L);

//
// GetBooleanOption retrieves and converts an option string to a boolean
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
BOOL OPT_GetBooleanOption(LPCSTR cstrOptionName,
                          BOOL  bDefault = FALSE);

//
// GetStringOption  retrieves a string option (no conversion).
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
void OPT_GetStringOption(LPCSTR cstrOptionName,
                            LPSTR pcDefault,
                            UINT size);

//
// GetDataOption    retrieves an option string and parses it into an
//                  array of hex bytes.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
int OPT_GetDataOption(LPCSTR optionName,
                      int   iBufferLength,
                      BYTE* pbBuffer);

//
// GetWindowRectOption  retrieves a option string and parses it into a
//                      rectangle representing the corners of the
//                  window.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
void OPT_GetWindowRectOption(LPRECT lprc);

//
// SetStringOption  writes a string option (no conversion).
//                  Returns TRUE if the option was successfully written.
//
BOOL OPT_SetStringOption(LPCSTR cstrOptionName,
                         LPCSTR cstrValue);

//
// SetBooleanOption writes a boolean option
//                  Returns TRUE if the option was successfully written.
//
BOOL OPT_SetBooleanOption(LPCSTR cstrOptionName,
                          BOOL  bValue);

//
// SetIntegerOption write an integer option
//                  Returns TRUE if the option was successfully written.
	
//
BOOL OPT_SetIntegerOption(LPCSTR cstrOptionName,
                          LONG  lValue);

//
// SetWindowRectOption  write a window rectangle option.
//                  Returns TRUE if the option was successfully written.
//
void OPT_SetWindowRectOption(LPCRECT lpwindowRect);

//
// SetDataOption    writes a data option.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
BOOL OPT_SetDataOption(LPCSTR optionName,
                       int   iBufferLength,
                       BYTE* pbBuffer);

BOOL OPT_Lookup(LPCSTR cstrOptionName,
                          LPCSTR cstrResult,
                          UINT size);




//
//
// Class:   WbPrinter
//
// Purpose: Printer class including cancellation dialog
//
//
class WbPrinter
{
public:
    //
    // Constructor
    //
    // The parameter specifies the printer to be used. Under Windows this
    // value can be obtained from the Common Print Dialog.
    //
    WbPrinter(LPCTSTR szDeviceName);
    ~WbPrinter(void);

    void    SetPrintPageNumber(int nPageNumber);

    // Return TRUE if an error has occurred
    BOOL    Error(void)       { return (m_bAborted || (m_nPrintResult < 0)); };

    // Return TRUE if the user has aborted the print
    BOOL    Aborted(void)     { return m_bAborted; };

    // Return the last result code from a print function call
    int     PrintResult(void) { return m_nPrintResult; };

    //
    // Document manipulation functions
    //

    // Start a new print job
    int StartDoc(HDC hdc, LPCTSTR cstrDocName, int nStartPage);

    // Start a new page
    int StartPage(HDC hdc, int nPageNumber);

    // Indicate that the page is now complete
    int EndPage(HDC hdc);

    // Indicate that the document is complete
    int EndDoc(HDC hdc);

    // Abort the print job
    int AbortDoc(void);

protected:
    HWND    m_hwndDialog;

    //
    // Device and port name for this printer
    //
    LPCTSTR m_szDeviceName;
    TCHAR   m_szPrintPageText[_MAX_PATH];

    //
    // Internal state variables
    //
    int     m_nPrintResult;
    BOOL    m_bAborted;

    void    StopDialog(void);

    //
    // Friend callback routine
    //
    friend BOOL CALLBACK AbortProc(HDC, int);
    friend INT_PTR CALLBACK CancelPrintDlgProc(HWND, UINT, WPARAM, LPARAM);
};




//
// Defines for palettes
//
#define PALVERSION  0x300
#define MAXPALETTE  256

HPALETTE CreateSystemPalette(void);
HPALETTE CreateColorPalette(void);


HBITMAP FromScreenAreaBmp(LPCRECT lprc);


UINT        DIB_NumberOfColors(LPBITMAPINFOHEADER lpbi);
UINT        DIB_PaletteLength(LPBITMAPINFOHEADER lpbi);
UINT        DIB_DataLength(LPBITMAPINFOHEADER lpbi);
UINT        DIB_TotalLength(LPBITMAPINFOHEADER lpbi);

HPALETTE    DIB_CreatePalette(LPBITMAPINFOHEADER lpbi);
LPSTR       DIB_Bits(LPBITMAPINFOHEADER lpbi);

LPBITMAPINFOHEADER  DIB_FromBitmap(HBITMAP hBitmap, HPALETTE hPalette, BOOL fGHandle, BOOL fTopBottom, BOOL fForce8Bits = FALSE);
LPBITMAPINFOHEADER  DIB_FromScreenArea(LPCRECT lprc);
LPBITMAPINFOHEADER  DIB_Copy(LPBITMAPINFOHEADER lpbi);



//
// Extra windows messages for the Whiteboard
//
enum
{
    WM_USER_GOTO_USER_POSITION  =   WM_USER,
    WM_USER_GOTO_USER_POINTER,
    WM_USER_JOIN_CALL,
    WM_USER_DISPLAY_ERROR,
    WM_USER_UPDATE_ATTRIBUTES,
    WM_USER_JOIN_PENDING_CALL,
    WM_USER_PRIVATE_PARENTNOTIFY,
    WM_USER_BRING_TO_FRONT_WINDOW,
    WM_USER_LOAD_FILE

};

//
// Internal error codes
//
#define WB_BASE_RC                     0x0300
#define WB_LAST_RC                     0x03FF

#define WBFE_RC_BASE       (WB_LAST_RC - 20)

enum
{
    WBFE_RC_WINDOWS = WBFE_RC_BASE,
    WBFE_RC_WB,
    WBFE_RC_JOIN_CALL_FAILED,
    WBFE_RC_CM,
    WBFE_RC_AL,
    WBFE_RC_PRINTER
};


enum
{
    WB_RC_NOT_LOCKED = WB_BASE_RC,
    WB_RC_LOCKED,
    WB_RC_BAD_FILE_FORMAT,
    WB_RC_BAD_STATE,
    WB_RC_WRITE_FAILED,
    WB_RC_BAD_PAGE_HANDLE,
    WB_RC_BAD_PAGE_NUMBER,
    WB_RC_CHANGED,
    WB_RC_NOT_CHANGED,
    WB_RC_NO_SUCH_PAGE,
    WB_RC_NO_SUCH_GRAPHIC,
    WB_RC_NO_SUCH_PERSON,
    WB_RC_TOO_MANY_PAGES,
    WB_RC_ALREADY_LOADING,
    WB_RC_BUSY,
    WB_RC_GRAPHIC_LOCKED,
    WB_RC_GRAPHIC_NOT_LOCKED,
    WB_RC_NOT_LOADING,
    WB_RC_CREATE_FAILED,
    WB_RC_READ_FAILED
};


//
// The following functions can be found in wwbapp.cpp
//

//
// Functions displaying a message box from the string resources specified
//
int Message(HWND hwndOwner,
            UINT uiCaption,
            UINT uiMessage,
            UINT uiStyle = (MB_OK | MB_ICONEXCLAMATION));

//
// Functions displaying a message box from return codes
//
void ErrorMessage(UINT uiFEReturnCode, UINT uiDCGReturnCode);


//
// Default exception handler
//
void DefaultExceptionHandler(UINT uiFEReturnCode, UINT uiDCGReturnCode);


//
//
// Class:   DCWbPointerColorMap
//
// Purpose: Map from pointer color to pointer structures
//
//
class DCWbColorToIconMap : public COBLIST
{

  public:
    //
    // Destructor
    //
    ~DCWbColorToIconMap(void);
};




//
// BOGUS LAURABU TEMP!
// StrArray
//

#define ALLOC_CHUNK     8

class StrArray
{
public:
	StrArray();
	~StrArray();

	int GetSize() const { return(m_nSize); }
	void SetSize(int nNewSize);

	// Clean up
	void RemoveAll() { SetSize(0); }
    void ClearOut();
	
	// Adding elements
	void SetAt(int nIndex, LPCTSTR newElement);
	void SetAtGrow(int nIndex, LPCTSTR newElement);
	void Add(LPCTSTR newElement);

	// overloaded operator helpers
	LPCTSTR operator[](int nIndex) const;

// Implementation
protected:

	LPCTSTR * m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
};

char *  StrTok (
        char * string,
        char * control
        );

StrCspn(char * string, char * control);

#endif // CCL32_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\coder.cpp ===
//
// CODER.CPP
// ASN1 t126 encoder/decoder
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"

#ifdef __cplusplus
extern "C" {
#endif /*__cplusplus*/

#include   "coder.hpp"

#ifdef __cplusplus
}
#endif /*__cplusplus*/





Coder::Coder()
{
	T126_InitModule();
	InitCoder();
}

Coder::~Coder(){

	EnterCriticalSection(&m_critSec);
	T126_TermCoder(&p_Coder);
	T126_TermModule();
	LeaveCriticalSection(&m_critSec);
	DeleteCriticalSection(&m_critSec);
}

int Coder::InitCoder()
{

    int	iError = 0;

	InitializeCriticalSection(&m_critSec);

    // Call TELES Library initialization routine
    EnterCriticalSection(&m_critSec);
    iError = T126_InitCoder(&p_Coder);
    LeaveCriticalSection(&m_critSec);

    return iError;
}

// ASN.1 Encode a T.126 PDU
// Take a T.126 structure and returns a T.126 PDU
//
int Coder::	Encode(SIPDU *pInputData, ASN1_BUF *pOutputOssBuf){
	int iError;

	// initialize encoding buffer structure values
	pOutputOssBuf->value = NULL;
	pOutputOssBuf->length = 0;

	// encode pdu
	EnterCriticalSection(&m_critSec);
    iError = T126_Encode(&p_Coder,
                       (void *)pInputData,
                       SIPDU_PDU,
                       pOutputOssBuf);
	LeaveCriticalSection(&m_critSec);
    return iError;
}


int Coder::Decode(ASN1_BUF *pInputOssBuf, SIPDU **pOutputData){
	int iError;

	// NULL tells decoder to malloc memory for SIPDU
	// user must free this memory by calling Coder::FreePDU()
	 *pOutputData = NULL;
	
	// decode the pdu
	EnterCriticalSection(&m_critSec);
    iError = T126_Decode(&p_Coder,
                       (void **)pOutputData,
                       SIPDU_PDU,
                       pInputOssBuf);
	LeaveCriticalSection(&m_critSec);
	return iError;
}

// Used to free buffer created by decode
int Coder::Free(SIPDU *pData){
	int iError;

	EnterCriticalSection(&m_critSec);
	iError = freePDU(&p_Coder,SIPDU_PDU,pData, T126_Module);
	LeaveCriticalSection(&m_critSec);
	return iError;
}

// Used to free buffer created by encode
void Coder::Free(ASN1_BUF Asn1Buf){
	EnterCriticalSection(&m_critSec);
	ASN1_FreeEncoded(p_Coder.pEncInfo,(void *)(Asn1Buf.value));
	LeaveCriticalSection(&m_critSec);
}



// THE FOLLOWING IS ADDED FOR TELES ASN.1 INTEGRATION

extern "C" {

int T126_InitModule(void)
{
    T126_Module_Startup();
    return (T126_Module != NULL) ? ASN1_SUCCESS : ASN1_ERR_MEMORY;
}

int T126_TermModule(void)
{
    T126_Module_Cleanup();
    return ASN1_SUCCESS;
}

int T126_InitCoder(ASN1_CODER_INFO *pCoder)
{
    int rc;

    ZeroMemory(pCoder, sizeof(*pCoder));

    if (T126_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                T126_Module,           // ptr to mdule
                &(pCoder->pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        ASSERT(pCoder->pEncInfo != NULL);
        rc = ASN1_CreateDecoder(
                T126_Module,           // ptr to mdule
                &(pCoder->pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
        ASSERT(pCoder->pDecInfo != NULL);
    }

    if (rc != ASN1_SUCCESS)
    {
        T126_TermCoder(pCoder);
    }

    return rc;
}

int T126_TermCoder(ASN1_CODER_INFO *pCoder)
{
    if (T126_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(pCoder->pEncInfo);
    ASN1_CloseDecoder(pCoder->pDecInfo);

    ZeroMemory(pCoder, sizeof(*pCoder));

    return ASN1_SUCCESS;
}

int T126_Encode(ASN1_CODER_INFO *pCoder, void *pStruct, int nPDU, ASN1_BUF *pBuf)
{
	int rc;
    ASN1encoding_t pEncInfo = pCoder->pEncInfo;
    BOOL fBufferSupplied = (pBuf->value != NULL) && (pBuf->length != 0);
    DWORD dwFlags = fBufferSupplied ? ASN1ENCODE_SETBUFFER : ASN1ENCODE_ALLOCATEBUFFER;

	// clean up out parameters
    if (! fBufferSupplied)
    {
        pBuf->length = 0;
        pBuf->value = NULL;
    }

    rc = ASN1_Encode(
                    pEncInfo,                   // ptr to encoder info
                    pStruct,                    // pdu data structure
                    nPDU,                       // pdu id
                    dwFlags,                    // flags
                    pBuf->value,                // buffer
                    pBuf->length);              // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        if (fBufferSupplied)
        {
            ASSERT(pBuf->value == pEncInfo->buf);
            ASSERT(pBuf->length >= pEncInfo->len);
        }
        else
        {
            pBuf->value = pEncInfo->buf;             // buffer to encode into
        }
        pBuf->length = pEncInfo->len;        // len of encoded data in buffer
    }
    else
    {
        ASSERT(FALSE);
    }
    return rc;
}

int T126_Decode(ASN1_CODER_INFO *pCoder, void **ppStruct, int nPDU, ASN1_BUF *pBuf)
{
    ASN1decoding_t pDecInfo = pCoder->pDecInfo;
    BYTE *pEncoded = pBuf->value;
    ULONG cbEncodedSize = pBuf->length;

    int rc = ASN1_Decode(
                    pDecInfo,                   // ptr to encoder info
                    ppStruct,                   // pdu data structure
                    nPDU,                       // pdu id
                    ASN1DECODE_SETBUFFER,       // flags
                    pEncoded,                   // do not provide buffer
                    cbEncodedSize);             // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        ASSERT(pDecInfo->pos > pDecInfo->buf);
        pBuf->length -= (ULONG)(pDecInfo->pos - pDecInfo->buf);
        pBuf->value = pDecInfo->pos;
    }
    else
    {
		ASSERT(FALSE);
        *ppStruct = NULL;
    }
    return rc;
}

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\clpbd.cpp ===
//
// CLPBD.CPP
// Clipboard Handling
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"



//
// NFC, SFR 5921.  Maximum length of a string pasted from the clipboard.
// We impose this limit as our graphic object code cant
// handle more then this number of chars.
//
#define WB_MAX_TEXT_PASTE_LEN  (INT_MAX-1)

//
//
// Function:    Paste
//
// Purpose:     Paste a format from the clipboard
//
//
BOOL WbMainWindow::CLP_Paste(void)
{
	UINT		length = 0;
	HANDLE		handle = NULL;
	T126Obj*	pGraphic = NULL;
	BOOL bResult = FALSE;

	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_Paste");

	// Get the highest priority acceptable format in the clipboard
	int iFormat = CLP_AcceptableClipboardFormat();
	if (!iFormat)
		goto NoOpenClip;

	TRACE_MSG(("Found acceptable format %d", iFormat));

	// Open the clipboard

	if (!::OpenClipboard(m_hwnd))
	{
		WARNING_OUT(("CLP_Paste: can't open clipboard"));
		goto NoOpenClip;
	}

	handle = ::GetClipboardData(iFormat);
	if (!handle)
	{
		WARNING_OUT(("CLP_Paste: can't get data for format %d", iFormat));
		goto NoFormatData;
	}

	switch (iFormat)
	{
		//
		// Check the standard formats
		//
		case CF_DIB:
		{
			TRACE_MSG(("Pasting CF_DIB"));

			// Lock the handle to get a pointer to the DIB
			LPBITMAPINFOHEADER lpbi;
			lpbi = (LPBITMAPINFOHEADER) ::GlobalLock(handle);
			if (lpbi != NULL)
			{
				bResult= PasteDIB(lpbi);

				// Release the memory
				::GlobalUnlock(handle);
			}

		
		}
		break;

		//
		// We have a metafile. Play it into a bitmap and then use the
		// data.
		//
		case CF_ENHMETAFILE:
		{
			TRACE_MSG(("Pasting CF_ENHMETAFILE"));

			HDC		 hDrawingDC;
			ENHMETAHEADER meta_header;
			HBITMAP	 hBitmap = NULL;
			HDC		 meta_dc = NULL;
			HBITMAP	 hSaveBitmap;
			HPEN		hSavePen;
			HPALETTE	hPalette;
			RECT		meta_rect;
			LPBITMAPINFOHEADER lpbiNew;
			int		 tmp;

			// We just need a DC compatible with the drawing area wnd
			hDrawingDC = m_drawingArea.GetCachedDC();

			// make a dc
			meta_dc = ::CreateCompatibleDC(hDrawingDC);
			if (!meta_dc)
				goto CleanupMetaFile;

			// figure out image size.
			::GetEnhMetaFileHeader( (HENHMETAFILE)handle,
									  sizeof( ENHMETAHEADER ),
									  &meta_header );
			meta_rect.left = meta_rect.top = 0;

			meta_rect.right = ((meta_header.rclFrame.right - meta_header.rclFrame.left)
				* ::GetDeviceCaps(hDrawingDC, LOGPIXELSX ))/2540;

			meta_rect.bottom = ((meta_header.rclFrame.bottom - meta_header.rclFrame.top)
				* ::GetDeviceCaps(hDrawingDC, LOGPIXELSY ))/2540;

			// Normalize coords
			if (meta_rect.right < meta_rect.left)
			{
				tmp = meta_rect.left;
				meta_rect.left = meta_rect.right;
				meta_rect.right = tmp;
			}
			if (meta_rect.bottom < meta_rect.top)
			{
				tmp = meta_rect.top;
				meta_rect.top = meta_rect.bottom;
				meta_rect.bottom = tmp;
			}

			// make a place to play meta in
			hBitmap = ::CreateCompatibleBitmap(hDrawingDC,
				meta_rect.right - meta_rect.left,
				meta_rect.bottom - meta_rect.top);
			if (!hBitmap)
				goto CleanupMetaFile;

			hSaveBitmap = SelectBitmap(meta_dc, hBitmap);

			// erase our paper
			hSavePen = SelectPen(meta_dc, GetStockObject(NULL_PEN));

			::Rectangle(meta_dc, meta_rect.left, meta_rect.top,
				meta_rect.right + 1, meta_rect.bottom + 1);

			SelectPen(meta_dc, hSavePen);

			// play the tape
			::PlayEnhMetaFile(meta_dc, (HENHMETAFILE)handle, &meta_rect);

			// unplug our new bitmap
			SelectBitmap(meta_dc, hSaveBitmap);

			// Check for a palette object in the clipboard
			hPalette = (HPALETTE)::GetClipboardData(CF_PALETTE);

			// Create a new DIB from the bitmap
		   	lpbiNew = DIB_FromBitmap(hBitmap, hPalette, FALSE, FALSE);

			if(lpbiNew != NULL)
			{
				bResult= PasteDIB(lpbiNew);
			}

CleanupMetaFile:
			// Free our temp intermediate bitmap
			if (hBitmap != NULL)
			{
				DeleteBitmap(hBitmap);
			}

			if (meta_dc != NULL)
			{
				::DeleteDC(meta_dc);
			}
		}
		break;

		case CF_TEXT:
		{
			LPSTR   pData;

			TRACE_DEBUG(("Pasting text"));

            // Get a handle to the clipboard contents
            pData = (LPSTR)::GlobalLock(handle);

			if(pData)
			{
	            // Create a text object to hold the data - get the font to
	            // use from the tool attributes group.
				DBG_SAVE_FILE_LINE
	            WbTextEditor* pPasteText = new WbTextEditor();

    	        // Use the current font attributes
                if (!pPasteText)
                {
                    ERROR_OUT(("CF_TEXT handling; failed to allocate DCWbGraphicText object"));
                }
                else
                {
                    pPasteText->SetFont(m_pCurrentTool->GetFont());
    	            pPasteText->SetText(pData);
					
					RECT    rcVis;
					m_drawingArea.GetVisibleRect(&rcVis);
					pPasteText->SetPenColor(RGB(0,0,0),TRUE);
					pPasteText->SetAnchorPoint(0, 0);
					pPasteText->MoveTo(rcVis.left, rcVis.top);
					pPasteText->Draw();
					pPasteText->m_pEditBox = NULL;

					// Add the new grabbed bitmap
					pPasteText->SetAllAttribs();
					pPasteText->AddToWorkspace();
					bResult = TRUE;
                }

        	    pGraphic = pPasteText;
            }

		}
		break;

		default:
		{
			if (iFormat == g_ClipboardFormats[CLIPBOARD_PRIVATE])
			{

				WB_OBJ objectHeader;
				ULONG length;
				UINT type;
				ULONG nItems = 0;
			
				PBYTE pClipBoardBuffer;
				if (pClipBoardBuffer = (PBYTE) ::GlobalLock(handle))
				{

					//
					// Count objects before we paste.
					//
					PBYTE pClipBuff = pClipBoardBuffer;
					length = ((PWB_OBJ)pClipBuff)->length;
					pClipBuff += sizeof(objectHeader);
					while(length)
					{
						nItems++;
						pClipBuff += length;
						length = ((PWB_OBJ)pClipBuff)->length;
						pClipBuff += sizeof(objectHeader);
					}

					TimeToGetGCCHandles(nItems);

					length = ((PWB_OBJ)pClipBoardBuffer)->length;
					type = ((PWB_OBJ)pClipBoardBuffer)->type;
					pClipBoardBuffer += sizeof(objectHeader);
					
					while(length)
					{
						if(type == TYPE_T126_ASN_OBJECT)
						{
							bResult = T126_MCSSendDataIndication(length, pClipBoardBuffer, g_MyMemberID, TRUE);
						}
						else if(type == TYPE_T126_DIB_OBJECT)
						{
							bResult = PasteDIB((LPBITMAPINFOHEADER)pClipBoardBuffer);
						}
						
						pClipBoardBuffer += length;
						length = ((PWB_OBJ)pClipBoardBuffer)->length;
						type = ((PWB_OBJ)pClipBoardBuffer)->type;
						pClipBoardBuffer += sizeof(objectHeader);
					}
				
					// Release the handle
					::GlobalUnlock(handle);
				}				   
			}
		}
		break;
	}

NoFormatData:
	::CloseClipboard();

NoOpenClip:
	return bResult;
}


//
//
// Function:	Copy
//
// Purpose:	 Copy a graphic to the clipboard.
//
//
BOOL WbMainWindow::CLP_Copy()
{
	BOOL bResult = FALSE;

	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_Copy");

	//
	// We act according to the format of the selected graphic.
	//
	// For all formats we supply the Whiteboard private format (which is
	// just a copy of the flat representation of the graphic).
	//
	// We supply standard formats as follows.
	//
	// For bitmaps and all others we supply CF_DIB.
	//
	// For text graphics we supply CF_TEXT.
	//

	TRACE_MSG(("Rendering the graphic now"));

	// Have to empty the clipboard before rendering the formats.
	if (::OpenClipboard(m_hwnd))
	{
		// Get ownership of the clipboard
		::EmptyClipboard();
		::CloseClipboard();

		// Render the graphic
		bResult = CLP_RenderAllFormats();
	}


	return bResult;
}


//
//
// Function:	RenderAllFormats
//
// Purpose:	 Render a graphic to the clipboard
//
//
BOOL WbMainWindow::CLP_RenderAllFormats()
{
	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAllFormats");
	BOOL bResult = FALSE;

	// Open the clipboard
	if (bResult = ::OpenClipboard(m_hwnd))
	{
		TRACE_DEBUG(("Rendering all formats of graphic"));

		// Render the private format
		bResult &= CLP_RenderPrivateFormat();

		// Text graphic
		bResult &= CLP_RenderAsText();

		// DIBs
//		bResult &= CLP_RenderAsImage();

		// Bitmaps
		bResult &= CLP_RenderAsBitmap();

		// Close the clipboard
		::CloseClipboard();
	}

	return bResult;
}


//
//
// Function:	CLP_RenderPrivateFormat
//
// Purpose:	 Render the private format of a graphic to the clipboard.
//			  The clipboard should be open before this call is made.
//
//
BOOL WbMainWindow::CLP_RenderPrivateFormat()
{
	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderPrivateFormat");

	BOOL bResult = FALSE;
	LPBYTE pDest = NULL;
	HGLOBAL hMem = NULL;
	HGLOBAL hRealloc = NULL;
	WB_OBJ objectHeader; 
	ULONG length = sizeof(objectHeader);
	BOOL	bDoASN1CleanUp = FALSE;
	
	
	ULONG previousLength = 0;

	WBPOSITION pos;
	T126Obj * pObj;
	ASN1_BUF encodedPDU;

	pos = g_pCurrentWorkspace->GetHeadPosition();

	while(pos)
	{
		pObj = g_pCurrentWorkspace->GetNextObject(pos);
		if(pObj && pObj->WasSelectedLocally())
		{

			//
			// Get the encoded buffer
			//
			pObj->SetAllAttribs();
			pObj->SetViewState(unselected_chosen);
			pObj->GetEncodedCreatePDU(&encodedPDU);
			objectHeader.length = encodedPDU.length;


			if(pObj->GetType() == bitmapCreatePDU_chosen)
			{
				objectHeader.type = TYPE_T126_DIB_OBJECT;
			}
			else if(pObj->GetType() == drawingCreatePDU_chosen  || pObj->GetType() == siNonStandardPDU_chosen)
			{
				objectHeader.type = TYPE_T126_ASN_OBJECT;
				bDoASN1CleanUp = TRUE;
			}
			
			length += encodedPDU.length + sizeof(objectHeader);

			if(pDest)
			{
				hRealloc = ::GlobalReAlloc(hMem, length, GMEM_MOVEABLE | GMEM_DDESHARE);
				if(!hRealloc)
				{
					goto bail;
				}
				hMem = hRealloc;
			
			}
			else
			{
				// Allocate memory for the clipboard data
				hMem = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, length);
				if(hMem == NULL)
				{
					goto bail;
				}
			}


			//
			// Get a pointer to the destination
			//
			pDest = (LPBYTE)::GlobalLock(hMem);

			//
			// Write the header
			//
			memcpy(pDest + previousLength, &objectHeader, sizeof(objectHeader));
			previousLength += sizeof(objectHeader);

			//
			// Copy the decoded data in the destination
			//
			memcpy(pDest + previousLength, encodedPDU.value, encodedPDU.length);
			previousLength += encodedPDU.length;

			//
			// Terminate the block with a 0 
			//
			objectHeader.length = 0;
			memcpy(pDest + previousLength, &objectHeader, sizeof(objectHeader));
		
			//
			// Free the encoded data
			//	
			if(bDoASN1CleanUp)
			{
				g_pCoder->Free(encodedPDU);
				bDoASN1CleanUp = FALSE;
			}
		}
	}

	// Release the memory
	::GlobalUnlock(hMem);

	// Pass the data to the clipboard
	if (::SetClipboardData(g_ClipboardFormats[CLIPBOARD_PRIVATE], hMem))
	{
			TRACE_DEBUG(("Rendered data in Whiteboard format"));
			bResult = TRUE;
	}

bail:



	if(bDoASN1CleanUp)
	{
		g_pCoder->Free(encodedPDU);
	}

	// If we failed to put the data into the clipboard, free the memory.
	// (If we did put it into the clipboard we must not free it).
	if (bResult == FALSE)
	{
		WARNING_OUT(("Render failed"));
		::GlobalFree(hMem);
	}

	return bResult;
}

//
//
// Function:	RenderAsText
//
// Purpose:	 Render the text format of a graphic to the clipboard.
//			  The clipboard should be open before this call is made.
//			  This member should only be called for text graphics.
//
//
BOOL WbMainWindow::CLP_RenderAsText()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAsText");

    BOOL bResult = TRUE;

	WBPOSITION pos;

	T126Obj * pObj;
	pos = g_pCurrentWorkspace->GetHeadPosition();
	while(pos)
	{
		pObj = g_pCurrentWorkspace->GetNextObject(pos);
		if(pObj && pObj->WasSelectedLocally() && pObj->GraphicTool() == TOOLTYPE_TEXT)
		{

			// Get the total length of the clipboard format of the text
			StrArray& strText = ((TextObj*) pObj)->strTextArray;
			int   iCount = strText.GetSize();
			int   iIndex;
			DWORD dwLength = 0;

			for (iIndex = 0; iIndex < iCount; iIndex++)
			{
				// Length of string plus 2 for carriage return and line feed
				dwLength += lstrlen(strText[iIndex]) + 2;
			}

			// One more for the terminating NULL
			dwLength += 1;

			// Allocate memory for the clipboard data
			HANDLE hMem = ::GlobalAlloc(GHND, dwLength);
			if (hMem != NULL)
			{
				// Get a pointer to the memory
				LPSTR pDest = (LPSTR) ::GlobalLock(hMem);
				if (pDest != NULL)
				{
					// Write the graphic data to the allocated memory
					for (iIndex = 0; iIndex < iCount; iIndex++)
					{
						_tcscpy(pDest, strText[iIndex]);
						pDest += lstrlen(strText[iIndex]);

						// Add the carriage return and line feed
						*pDest++ = '\r';
						*pDest++ = '\n';
					}

					// Add the final NULL
					*pDest = '\0';

					// Release the memory
					::GlobalUnlock(hMem);

					// Pass the data to the clipboard
					if (::SetClipboardData(CF_TEXT, hMem))
					{
						TRACE_DEBUG(("Rendered data in text format"));
					}
					else
					{
						bResult = FALSE;
					}
				}

				// If we failed to put the data into the clipboard, free the memory
				if (bResult == FALSE)
				{
					::GlobalFree(hMem);
				}
				

				break;		// JOSEF what about copying all the text objects in the clipboard
			}

		}
	}

    return bResult;
}


//
// CLP_RenderAsBitmap()
//
// This draws all other graphics into a bitmap and pastes the DIB contents
// onto the clipboard.
//
BOOL WbMainWindow::CLP_RenderAsBitmap()
{
	BOOL	bResult = FALSE;
	HDC	 hdcDisplay = NULL;
	HDC	 hdcMem = NULL;
	HBITMAP hBitmap = NULL;
	HBITMAP hOldBitmap = NULL;
	HPALETTE hPalette;
	RECT	rcBounds = g_pDraw->m_selectorRect;
	POINT   pt;
	LPBITMAPINFOHEADER lpbi;
	T126Obj * pObj = NULL;

	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAsBitmap");

	//
	// First, draw this into a bitmap
	// Second, get the DIB bits of the bitmap
	//

	hdcDisplay = ::CreateDC("DISPLAY", NULL, NULL, NULL);
	if (!hdcDisplay)
	{
		ERROR_OUT(("Can't create DISPLAY dc"));
		goto AsBitmapDone;
	}

	hdcMem = ::CreateCompatibleDC(hdcDisplay);
	if (!hdcMem)
	{
		ERROR_OUT(("Can't create DISPLAY compatible dc"));
		goto AsBitmapDone;
	}

	hBitmap = ::CreateCompatibleBitmap(hdcDisplay,
		(rcBounds.right - rcBounds.left), (rcBounds.bottom - rcBounds.top));
	if (!hBitmap)
	{
		ERROR_OUT(("Can't create compatible bitmap"));
		goto AsBitmapDone;
	}

	hOldBitmap = SelectBitmap(hdcMem, hBitmap);
	if (!hOldBitmap)
	{
		ERROR_OUT(("Failed to select compatible bitmap"));
		goto AsBitmapDone;
	}

	::SetMapMode(hdcMem, MM_ANISOTROPIC);
	::SetWindowOrgEx(hdcMem, rcBounds.left,rcBounds.top, NULL);

	// Clear out bitmap with white background -- now that origin has been
	// altered, we can use drawing area coors.
	::PatBlt(hdcMem, rcBounds.left, rcBounds.top, rcBounds.right - rcBounds.left,
		rcBounds.bottom - rcBounds.top, WHITENESS);


		WBPOSITION pos;

		pos = g_pCurrentWorkspace->GetHeadPosition();

		while(pos)
		{
			pObj = g_pCurrentWorkspace->GetNextObject(pos);

			if(pObj && pObj->WasSelectedLocally())
			{
				pObj->Draw(hdcMem);
			}
		}

	SelectBitmap(hdcMem, hOldBitmap);

	// Now get the dib bits...
	hPalette = CreateSystemPalette();
	lpbi = DIB_FromBitmap(hBitmap, hPalette, TRUE, FALSE);
	if (hPalette != NULL)
		::DeletePalette(hPalette);

	// And put the handle on the clipboard
	if (lpbi != NULL)
	{
		if (::SetClipboardData(CF_DIB, (HGLOBAL)lpbi))
		{
			bResult = TRUE;
		}
		else
		{
			::GlobalFree((HGLOBAL)lpbi);
		}
	}

AsBitmapDone:
	if (hBitmap != NULL)
		::DeleteBitmap(hBitmap);

	if (hdcMem != NULL)
		::DeleteDC(hdcMem);

	if (hdcDisplay != NULL)
		::DeleteDC(hdcDisplay);

	return(bResult);
}

//
//
// Function:	AcceptableClipboardFormat
//
// Purpose:	 Return highest priority clipboard format if an acceptable
//			  one is available, else return NULL.
//
//
int WbMainWindow::CLP_AcceptableClipboardFormat(void)
{
	// Look for any of the supported formats being available
	int iFormat = ::GetPriorityClipboardFormat((UINT *)g_ClipboardFormats, CLIPBOARD_ACCEPTABLE_FORMATS);
	if (iFormat == -1)
	{
		iFormat = 0;
	}

	return iFormat;
}


BOOL WbMainWindow::PasteDIB( LPBITMAPINFOHEADER lpbi)
{
	BOOL bResult = FALSE;
	
	//
	// Create a bitmap object
	//
	BitmapObj* pDIB = NULL;
	DBG_SAVE_FILE_LINE
	pDIB = new BitmapObj(TOOLTYPE_FILLEDBOX);
	pDIB->SetBitmapSize(lpbi->biWidth,lpbi->biHeight);

	RECT rect;
	// Calculate the bounding rectangle from the size of the bitmap
	rect.top = 0;
	rect.left = 0;
	rect.right = lpbi->biWidth;
	rect.bottom = lpbi->biHeight;
	pDIB->SetRect(&rect);
	pDIB->SetAnchorPoint(rect.left, rect.top);

	//
	// Make a copy of the clipboard data
	//
	pDIB->m_lpbiImage = DIB_Copy(lpbi);

	if(pDIB->m_lpbiImage!= NULL)
	{
		// Add the new bitmap
		AddCapturedImage(pDIB);
		bResult = TRUE;
	}
	else
	{
		delete pDIB;
	}

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\ccl32.cpp ===
//
// CCL32.CPP
// Common Control Classes
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"
#define COMPILE_MULTIMON_STUBS
#include <multimon.h>
#include <regentry.h>
#include "NMWbObj.h"

LRESULT CALLBACK DummyMouseHookProc( int code, WPARAM wParam, LPARAM lParam );



HHOOK   g_utMouseHookHandle = NULL;
HWND    g_utCaptureWindow = NULL;





void UT_CaptureMouse( HWND   hwnd )
{
	// disable asynchronous input so we don't lose capture because the
	// left button isn't down
    g_utMouseHookHandle = SetWindowsHookEx( WH_JOURNALRECORD,
                                              DummyMouseHookProc,
                                              g_hInstance,
                                              NULL );

    if( g_utMouseHookHandle == NULL )
    {
        WARNING_OUT(("Failed to insert JournalRecord hook"));
	}

	// grap mouse
    ::SetCapture(hwnd);
    g_utCaptureWindow = hwnd;
}


void UT_ReleaseMouse( HWND  hwnd )
{
    ::ReleaseCapture();
    g_utCaptureWindow = NULL;

    if (g_utMouseHookHandle != NULL )
	{
		// le go my lego
        ::UnhookWindowsHookEx( g_utMouseHookHandle );
        g_utMouseHookHandle = NULL;
	}
}


LRESULT CALLBACK DummyMouseHookProc( int code, WPARAM wParam, LPARAM lParam )
{
    return( CallNextHookEx( g_utMouseHookHandle, code, wParam, lParam ) );
}




//
// General definitions
//
#define MAX_OPTIONS_LINE_LENGTH         255
#define MAX_SECTION_LEN                 200


//
//
// Function: HexDigitToByte
//
// Purpose:  Helper function to convert a single hex digit to a byte value.
//
//
BOOL HexDigitToByte(char cHexDigit, BYTE& byte);

BOOL HexDigitToByte(char cHexDigit, BYTE& byte)
{
  // Decimal digits
  if (   (cHexDigit >= '0')
      && (cHexDigit <= '9'))
  {
    byte = (BYTE) (cHexDigit - '0');
    return(TRUE);
  }

  // Uppercase characters
  if (   (cHexDigit >= 'A')
      && (cHexDigit <= 'F'))
  {
    byte = (BYTE) ((cHexDigit - 'A') + 10);
    return(TRUE);
  }

  // Lowercase characters
  if (   (cHexDigit >= 'a')
      && (cHexDigit <= 'f'))
  {
    byte = (BYTE) ((cHexDigit - 'a') + 10);
    return(TRUE);
  }

  // The character is not a valid hex digit
  return(FALSE);
}




//
//
// Function: GetIntegerOption
//
// Purpose:  Retrieve a named option from the dictionary and convert the
//           option string to a long integer value.
//
//
LONG OPT_GetIntegerOption
(
    LPCSTR  cstrOptionName,
    LONG    lDefault
)
{
    LONG    lResult;
    TCHAR   cstrValue[MAX_OPTIONS_LINE_LENGTH];

    if (OPT_Lookup(cstrOptionName, cstrValue, MAX_OPTIONS_LINE_LENGTH))
    {
        // Option has been found, convert it to a long
        lResult = RtStrToInt(cstrValue);
    }
    else
    {
        // The option is not in the dictionary, return the default
        lResult = lDefault;
    }

    return lResult;
}



//
//
// Function: GetBooleanOption
//
// Purpose:  Retrieve a named option from the dictionary and convert it to
//           a boolean value.
//
//
BOOL OPT_GetBooleanOption
(
    LPCSTR  cstrOptionName,
    BOOL    bDefault
)
{
    TCHAR cstrValue[MAX_OPTIONS_LINE_LENGTH];

    // Lookup the option
    if (OPT_Lookup(cstrOptionName, cstrValue,MAX_OPTIONS_LINE_LENGTH))
    {
        return(cstrValue[0] == 'y' || cstrValue[0] =='Y') ;
    }

    return bDefault;
}



//
//
// Function: GetStringOption
//
// Purpose:  Retrieve a named option from the dictionary and return a copy
//           of it. No conversion of the string is performed.
//
//
void OPT_GetStringOption
(
    LPCSTR  cstrOptionName,
    LPSTR   cstrValue,
    UINT	size
)
{
    if (!OPT_Lookup(cstrOptionName, cstrValue, size) || !(lstrlen(cstrValue)))
    {
        *cstrValue = _T('\0');
    }
}


//
//
// Function: Lookup
//
// Purpose:  Retrieve a named option from the dictionary and return a copy
//           of it in the CString object passed. No conversion is performed.
//
//
BOOL OPT_Lookup
(
    LPCSTR      cstrOptionName,
    LPCSTR      cstrResult,
    UINT		size
)
{
    BOOL        fSuccess = FALSE;
	HKEY	    read_hkey = NULL;
	DWORD	    read_type;
	DWORD	    read_bufsize;

	// open key
	if (RegOpenKeyEx( HKEY_CURRENT_USER,
					  NEW_WHITEBOARD_KEY,
					  0,
					  KEY_EXECUTE,
					  &read_hkey )
		!= ERROR_SUCCESS )
    {
        TRACE_MSG(("Could not open key"));
        goto bail_out;
    }


	// read key's value
	read_bufsize = size;
	if (RegQueryValueEx( read_hkey,
					     cstrOptionName,
						 NULL,
						 &read_type,
						 (LPBYTE)cstrResult,
						 &read_bufsize )
		!= ERROR_SUCCESS )
    {
        TRACE_MSG(("Could not read key"));
        goto bail_out;
    }


	// check for valid type
	if (read_type != REG_SZ)
    {
        WARNING_OUT(("Bad key data"));
        goto bail_out;
    }

    fSuccess = TRUE;

bail_out:
	if (read_hkey != NULL)
		RegCloseKey(read_hkey);

	return (fSuccess);
}

//
//
// Function: GetWindowRectOption
//
// Purpose:  Retrieve a named option from the dictionary and convert it to
//           a window rectangle.  The rectangle is checked to make sure that
//           it is at least partially on screen, and not zero sized.
//
//
void OPT_GetWindowRectOption(LPRECT pRect)
{
	RegEntry reWnd( NEW_WHITEBOARD_KEY, HKEY_CURRENT_USER );
	pRect->left = reWnd.GetNumber( REGVAL_WINDOW_XPOS, 0);
	pRect->top = reWnd.GetNumber( REGVAL_WINDOW_YPOS, 0);
	int cx = reWnd.GetNumber( REGVAL_WINDOW_WIDTH, 0);
	int cy = reWnd.GetNumber( REGVAL_WINDOW_HEIGHT, 0);
	pRect->right = pRect->left + cx;
	pRect->bottom = pRect->top + cy;

	int	iTop = pRect->top;
	int iLeft = pRect->left;
	int iBottom = pRect->bottom;
	int iRight = pRect->right;

	//
	// If it was an empty rect
	//
	if( !(pRect->bottom || pRect->top || pRect->left || pRect->right) )
	{
		MINMAXINFO lpmmi;
		g_pMain->OnGetMinMaxInfo(&lpmmi);
		iTop = 0;
		iLeft = 0;
		iBottom = lpmmi.ptMinTrackSize.y;
		iRight = lpmmi.ptMinTrackSize.x;
	}
		
	// Make sure that the window rectangle is (at least partially) on
	// screen, and not too large.  First get the screen size
	int screenWidth  = ::GetSystemMetrics(SM_CXSCREEN);
	int screenHeight = ::GetSystemMetrics(SM_CYSCREEN);
   // Check the window size
	if ((iRight - iLeft) > screenWidth)
	{
		iRight = iLeft + screenWidth;
	}
	
	if ((iBottom - iTop) > screenHeight)
	{
		iTop = screenHeight;
	}

	// Check the window position
	if (iLeft >= screenWidth)
	{
		// Off screen to the right - keep the width the same
		iLeft  = screenWidth - (iRight - iLeft);
		iRight = screenWidth;
	}

	if (iRight < 0)
	{
		// Off screen to the left - keep the width the same
		iRight = iRight - iLeft;
		iLeft  = 0;
	}

	if (iTop >= screenHeight)
	{
		// Off screen to the bottom - keep the height the same
		iTop    = screenHeight - (iBottom - iTop);
		iBottom = screenHeight;
	}

    if (iBottom < 0)
	{
		// Off screen to the top - keep the height the same
		iBottom = (iBottom - iTop);
		iTop    = 0;
	}

	pRect->left = iLeft;
	pRect->top = iTop;
	pRect->right = iRight;
	pRect->bottom = iBottom;
}
	

//
//
// Function: GetDataOption
//
// Purpose:  Retrieve a named option from the dictionary and parse it as
//           an ASCII representation of a string of hex bytes.
//
//
int OPT_GetDataOption
(
    LPCSTR      cstrOptionName,
    int         iBufferLength,
    BYTE*       pbResult
)
{
    TCHAR cstrValue[MAX_OPTIONS_LINE_LENGTH];
    BYTE* pbSaveResult = pbResult;

    // Lookup the option
    OPT_GetStringOption(cstrOptionName, cstrValue,MAX_OPTIONS_LINE_LENGTH);
    if (lstrlen(cstrValue))
    {
        // Calculate the maximum number of characters to convert
        int iMaxChars = min(2 * iBufferLength, lstrlen(cstrValue));

        // Option found, convert the string to hex bytes
        for (int iIndex = 0; iIndex < iMaxChars; iIndex += 2)
        {
            BYTE bByteHigh = 0;
            BYTE bByteLow  = 0;

            if (   (HexDigitToByte(cstrValue[iIndex], bByteHigh) == FALSE)
                || (HexDigitToByte(cstrValue[iIndex + 1], bByteLow) == FALSE))
            {
                // The character was not a valid hex digit
                break;
            }

            // Build the result byte
            *pbResult++ = (BYTE) ((bByteHigh << 4) | bByteLow);
        }
    }

    // Return the length of data in the buffer
    return (int)(pbResult - pbSaveResult);
}



//
//
// Function: SetStringOption
//
// Purpose:  Set the value of an option in the dictionary.
//

//
BOOL OPT_SetStringOption
(
    LPCSTR      cstrOptionName,
    LPCSTR      cstrValue
)
{
    BOOL        fSuccess = FALSE;
	HKEY	    write_hkey = NULL;
	DWORD       disposition;

    // open or create the key
	if (RegCreateKeyEx( HKEY_CURRENT_USER,
						NEW_WHITEBOARD_KEY,
						0,
						NULL,
						REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						&write_hkey,
						&disposition) != ERROR_SUCCESS)
    {
        WARNING_OUT(("Could not write key"));
        goto bail_out;
    }

    // got data, write the value
    if (RegSetValueEx( write_hkey,
                       cstrOptionName,
					   0,
					   REG_SZ,
					   (LPBYTE)cstrValue,
                       _tcsclen(cstrValue) + sizeof(TCHAR)) != ERROR_SUCCESS )
    {
        WARNING_OUT(("Could not write key value"));
        goto bail_out;
    }

    fSuccess = TRUE;

bail_out:
	if (write_hkey != NULL)
		RegCloseKey(write_hkey);

    return(fSuccess);
}



//
//
// Function: SetIntegerOption
//
// Purpose:  Write an integer option
//
//
BOOL OPT_SetIntegerOption
(
    LPCSTR      cstrOptionName,
    LONG        lValue
)
{
    char cBuffer[20];

    // Convert the integer value to ASCII decimal
    wsprintf(cBuffer, "%ld", lValue);

	// Write the option
	return OPT_SetStringOption(cstrOptionName, cBuffer);
}


//
//
// Function: SetBooleanOption
//
// Purpose:  Write a boolean option
//
//
BOOL OPT_SetBooleanOption
(
    LPCSTR      cstrOptionName,
    BOOL        bValue
)
{
    char        cBuffer[8];

    wsprintf(cBuffer, "%c", (bValue ? 'Y' : 'N'));

    // Write the option
	return OPT_SetStringOption(cstrOptionName, cBuffer);
}



//
//
// Function: SetWindowRectOption
//
// Purpose:  Write a window position rectangle
//
//
void OPT_SetWindowRectOption(LPCRECT pcRect)
{
	RegEntry reWnd( NEW_WHITEBOARD_KEY, HKEY_CURRENT_USER );
	reWnd.SetValue( REGVAL_WINDOW_XPOS, pcRect->left );
	reWnd.SetValue( REGVAL_WINDOW_YPOS, pcRect->top );
	reWnd.SetValue( REGVAL_WINDOW_WIDTH, pcRect->right - pcRect->left );
	reWnd.SetValue( REGVAL_WINDOW_HEIGHT, pcRect->bottom - pcRect->top );
}

//
//
// Function: SetDataOption
//
// Purpose:  Write a data option to the options file
//
//
BOOL OPT_SetDataOption
(
    LPCSTR      cstrOptionName,
    int         iBufferLength,
    BYTE*       pbBuffer
)
{
    char        cBuffer[1024];
    LPSTR       cTmp;

    ASSERT(iBufferLength*2 < sizeof(cBuffer));

    // Loop through the data array converting a byte at a time
    cTmp = cBuffer;
    for (int iIndex = 0; iIndex < iBufferLength; iIndex++)
    {
        // Convert the next byte to ASCII hex
        wsprintf(cTmp, "%02x", pbBuffer[iIndex]);

        // add it to the string to be written
        cTmp += lstrlen(cTmp);
    }

    // Write the option
    return OPT_SetStringOption(cstrOptionName, cBuffer);
}





//
//
// Function:    CreateSystemPalette
//
// Purpose:     Get a palette representing the system palette
//
//
HPALETTE CreateSystemPalette(void)
{
    LPLOGPALETTE    lpLogPal;
    HDC             hdc;
    HPALETTE        hPal = NULL;
    int             nColors;

    MLZ_EntryOut(ZONE_FUNCTION, "CreateSystemPalette");

    hdc = ::CreateIC("DISPLAY", NULL, NULL, NULL);

    if (!hdc)
    {
        ERROR_OUT(("Couldn't create DISPLAY IC"));
        return(NULL);
    }

    nColors = ::GetDeviceCaps(hdc, SIZEPALETTE);

    ::DeleteDC(hdc);

    if (nColors == 0)
    {
        TRACE_MSG(("CreateSystemPalette: device has no palette"));
        return(NULL);
    }

    // Allocate room for the palette and lock it.
    lpLogPal = (LPLOGPALETTE)::GlobalAlloc(GPTR, sizeof(LOGPALETTE) +
                                    nColors * sizeof(PALETTEENTRY));

    if (lpLogPal != NULL)
    {
        lpLogPal->palVersion    = PALVERSION;
        lpLogPal->palNumEntries = (WORD) nColors;

        for (int iIndex = 0;  iIndex < nColors;  iIndex++)
        {
            lpLogPal->palPalEntry[iIndex].peBlue  = 0;
            *((LPWORD) (&lpLogPal->palPalEntry[iIndex].peRed)) = (WORD) iIndex;
            lpLogPal->palPalEntry[iIndex].peFlags = PC_EXPLICIT;
        }

        hPal = ::CreatePalette(lpLogPal);

        // Free the logical palette structure
        ::GlobalFree((HGLOBAL)lpLogPal);
    }

    return(hPal);
}


//
//
// Function:    CreateColorPalette
//
// Purpose:     Get a 256-color palette
//
//
HPALETTE CreateColorPalette(void)
{
    HDC hdc;
    HPALETTE hPal = NULL;

	MLZ_EntryOut(ZONE_FUNCTION, "CreateColorPalette");

	// Find out how many colors are reserved
    hdc = ::CreateIC("DISPLAY", NULL, NULL, NULL);
    if (!hdc)
    {
        ERROR_OUT(("Couldn't create DISPLAY IC"));
        return(NULL);
    }

	UINT uiSystemUse  = ::GetSystemPaletteUse(hdc);

    // Get the number of static colors
    int  iCountStatic = 20;
    int  iHalfCountStatic = 10;
	if (uiSystemUse == SYSPAL_NOSTATIC)
	{
        iCountStatic = 2;
        iHalfCountStatic = 1;
    }

	LOGPALETTE_NM gIndeoPalette = gcLogPaletteIndeo;

    // put system colors in correct lower and upper pal entries (bug NM4db:817)
    ::GetSystemPaletteEntries(hdc,
							  0,
							  iHalfCountStatic,
							  &(gIndeoPalette.aEntries[0]) );

    ::GetSystemPaletteEntries(hdc,
							  MAXPALETTE - iHalfCountStatic,
							  iHalfCountStatic,
							  &(gIndeoPalette.aEntries[MAXPALETTE - iHalfCountStatic]) );

    // Create the windows object for this palette
    // from the logical palette
    hPal = CreatePalette( (LOGPALETTE *)&gIndeoPalette );

	// Delete the display DC
	::DeleteDC(hdc);

	return(hPal);
}





//
//
// Function:    FromScreenAreaBmp
//
// Purpose:     Create a bitmap from an area of the screen
//
//
HBITMAP FromScreenAreaBmp(LPCRECT lprect)
{
    RECT    rcScreen;
    HBITMAP hBitMap = NULL;

    //
    // Get screen boundaries, in a way that works for single and multiple
    // monitor scenarios.
    //
    if (rcScreen.right = ::GetSystemMetrics(SM_CXVIRTUALSCREEN))
    {
        //
        // This is Win98, NT 4.0 SP-3, or NT5
        //
        rcScreen.bottom  = ::GetSystemMetrics(SM_CYVIRTUALSCREEN);
        rcScreen.left    = ::GetSystemMetrics(SM_XVIRTUALSCREEN);
        rcScreen.top     = ::GetSystemMetrics(SM_YVIRTUALSCREEN);
    }
    else
    {
        //
        // The VIRTUALSCREEN size metrics are zero on older platforms
        // which don't support them.
        //
        rcScreen.right  = ::GetSystemMetrics(SM_CXSCREEN);
        rcScreen.bottom = ::GetSystemMetrics(SM_CYSCREEN);
        rcScreen.left   = 0;
        rcScreen.top    = 0;
    }

    rcScreen.right += rcScreen.left;
    rcScreen.bottom += rcScreen.top;

    //
    // Clip bitmap rectangle to the screen.
    //
    if (IntersectRect(&rcScreen, &rcScreen, lprect))
    {
        // Create a DC for the screen and create
        // a memory DC compatible to screen DC
        HDC hdisplayDC;
        hdisplayDC = ::CreateDC("DISPLAY", NULL, NULL, NULL);

        HDC hmemDC;
        hmemDC = ::CreateCompatibleDC(hdisplayDC);

        // Create a bitmap compatible with the screen DC
        hBitMap =  ::CreateCompatibleBitmap(hdisplayDC,
            rcScreen.right - rcScreen.left,
            rcScreen.bottom - rcScreen.top);
        if (hBitMap != NULL)
        {
            // Select new bitmap into memory DC
            HBITMAP  hOldBitmap = SelectBitmap(hmemDC, hBitMap);

            // BitBlt screen DC to memory DC
            ::BitBlt(hmemDC, 0, 0, rcScreen.right - rcScreen.left,
                rcScreen.bottom - rcScreen.top, hdisplayDC,
                rcScreen.left, rcScreen.top, SRCCOPY);

            // Select old bitmap back into memory DC and get handle to
            // bitmap of the screen
            SelectBitmap(hmemDC, hOldBitmap);
        }

        ::DeleteDC(hmemDC);

        ::DeleteDC(hdisplayDC);
    }

    // return handle to the bitmap
    return hBitMap;
}





// Macro to round off the given value to the closest byte
#define WIDTHBYTES(i)   (((i+31)/32)*4)


//
//
// Function:    DIB_NumberOfColors
//
// Purpose:     Calculates the number of colours in the DIB
//
//
UINT DIB_NumberOfColors(LPBITMAPINFOHEADER lpbi)
{
    UINT                numColors;
    int                 bits;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_NumberOfColors");

    ASSERT(lpbi != NULL);

    //  With the BITMAPINFO format headers, the size of the palette
    //  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
    //  is dependent on the bits per pixel ( = 2 raised to the power of
    //  bits/pixel).
    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
    {
        // Old DIB format, some apps still put this on the clipboard
        numColors = 0;
        bits = ((LPBITMAPCOREHEADER)lpbi)->bcBitCount;
    }
    else
    {
        numColors = lpbi->biClrUsed;
        bits = lpbi->biBitCount;
    }

    if ((numColors == 0) && (bits <= 8))
    {
        numColors = (1 << bits);
    }

    return numColors;
}


//
//
// Function:    DIB_PaletteLength
//
// Purpose:     Calculates the palette size in bytes
//
//
UINT DIB_PaletteLength(LPBITMAPINFOHEADER lpbi)
{
    UINT size;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_PaletteLength");

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
    {
        size = DIB_NumberOfColors(lpbi) * sizeof(RGBTRIPLE);
    }
    else
    {
        size = DIB_NumberOfColors(lpbi) * sizeof(RGBQUAD);
    }

    TRACE_MSG(("Palette length %d", size));
    return(size);
}

//
//
// Function:    DIB_DataLength
//
// Purpose:     Return the length of the DIB data (after the header and the
//              color table.
//
//
UINT DIB_DataLength(LPBITMAPINFOHEADER lpbi)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DIB_DataLength");

    ASSERT(lpbi);

    UINT dwLength = 0;

    // If the image is not compressed, calculate the length of the data
    if (lpbi->biCompression == BI_RGB)
    {
        // Image is not compressed, the size can be given as zero in the header

        // Calculate the width in bytes of the image
        DWORD dwByteWidth = ( ((DWORD) lpbi->biWidth) * (DWORD) lpbi->biBitCount);
        TRACE_MSG(("Data byte width is %ld",dwByteWidth));

        // Round the width to a multiple of 4 bytes
        dwByteWidth = WIDTHBYTES(dwByteWidth);
        TRACE_MSG(("Rounded up to %ld",dwByteWidth));

        dwLength = (dwByteWidth * ((DWORD) lpbi->biHeight));
    }
    else
    {
        // Image is compressed, the length should be correct in the header
        dwLength = lpbi->biSizeImage;
    }

    TRACE_MSG(("Total data length is %d",dwLength));

    return(dwLength);
}


//
//
// Function:    DIB_TotalLength
//
// Purpose:     Return the total length of the DIB (header + colors + data).
//
//
UINT DIB_TotalLength(LPBITMAPINFOHEADER lpbi)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DIB_TotalLength");

    ASSERT(lpbi);

    // Header + Palette + Bits
    return(lpbi->biSize + DIB_PaletteLength(lpbi) + DIB_DataLength(lpbi));
}


//
//
// Function:    DIB_CreatePalette
//
// Purpose:     Create a palette object from the bitmap info color table
//
//
HPALETTE DIB_CreatePalette(LPBITMAPINFOHEADER lpbi)
{
    LOGPALETTE    *pPal;
    HPALETTE      hpal = NULL;
    WORD          nNumColors;
    BYTE          red;
    BYTE          green;
    BYTE          blue;
    WORD          i;
    RGBQUAD FAR * pRgb;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_CreatePalette");

    if (!lpbi)
        return NULL;

    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
        return NULL;

    // Get a pointer to the color table and the number of colors in it
    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi->biSize);
    nNumColors = (WORD)DIB_NumberOfColors(lpbi);

    if (nNumColors)
    {
        TRACE_MSG(("There are %d colors in the palette",nNumColors));

        // Allocate for the logical palette structure
        pPal = (LOGPALETTE*) ::GlobalAlloc(GPTR, sizeof(LOGPALETTE)
                                    + (nNumColors * sizeof(PALETTEENTRY)));
        if (!pPal)
        {
            ERROR_OUT(("Couldn't allocate palette memory"));
            return(NULL);
        }

        pPal->palNumEntries = nNumColors;
        pPal->palVersion    = PALVERSION;

        // Fill in the palette entries from the DIB color table and
        // create a logical color palette.
        for (i = 0; i < nNumColors; i++)
        {
            pPal->palPalEntry[i].peRed   = pRgb[i].rgbRed;
            pPal->palPalEntry[i].peGreen = pRgb[i].rgbGreen;
            pPal->palPalEntry[i].peBlue  = pRgb[i].rgbBlue;
            pPal->palPalEntry[i].peFlags = (BYTE)0;
        }

        hpal = ::CreatePalette(pPal);

        ::GlobalFree((HGLOBAL)pPal);
    }
    else
    {
        if (lpbi->biBitCount == 24)
        {
            // A 24 bitcount DIB has no color table entries so, set the number
            // of to the maximum value (256).
            nNumColors = MAXPALETTE;

            pPal = (LOGPALETTE*) ::GlobalAlloc(GPTR,  sizeof(LOGPALETTE)
                    + (nNumColors * sizeof(PALETTEENTRY)));
            if (!pPal)
            {
                ERROR_OUT(("Couldn't allocate palette memory"));
                return NULL;
            }

            pPal->palNumEntries = nNumColors;
            pPal->palVersion    = PALVERSION;

            red = green = blue = 0;

            // Generate 256 (= 8*8*4) RGB combinations to fill the palette
            // entries.

            for (i = 0; i < pPal->palNumEntries; i++)
            {
                pPal->palPalEntry[i].peRed   = red;
                pPal->palPalEntry[i].peGreen = green;
                pPal->palPalEntry[i].peBlue  = blue;
                pPal->palPalEntry[i].peFlags = (BYTE) 0;

                if (!(red += 32))
                    if (!(green += 32))
                        blue += 64;
            }

            hpal = ::CreatePalette(pPal);
            ::GlobalFree((HGLOBAL)pPal);
        }
    }

    return hpal;
}


//
//
// Function:    DIB_Bits
//
// Purpose:     Return a pointer to the bitmap bits data (from a pointer
//              to the bitmap info header).
//
//
LPSTR DIB_Bits(LPBITMAPINFOHEADER lpbi)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DIB_Bits");
    ASSERT(lpbi);

    return ((LPSTR) (((char *) lpbi)
                   + lpbi->biSize
                   + DIB_PaletteLength(lpbi)));
}



//
//
// Function:    DIB_FromScreenArea
//
// Purpose:     Create a DIB from an area of the screen
//
//
LPBITMAPINFOHEADER DIB_FromScreenArea(LPCRECT lprect)
{
    HBITMAP     hBitmap     = NULL;
    HPALETTE    hPalette    = NULL;
    LPBITMAPINFOHEADER lpbi = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_FromScreenArea");

    //  Get the device-dependent bitmap from the screen area
    hBitmap = FromScreenAreaBmp(lprect);
    if (hBitmap != NULL)
    {
        // Get the current system palette
        hPalette = CreateSystemPalette();
        lpbi = DIB_FromBitmap(hBitmap, hPalette, FALSE, FALSE);
    }

    if (hPalette != NULL)
        ::DeletePalette(hPalette);

    if (hBitmap != NULL)
        ::DeleteBitmap(hBitmap);

    return(lpbi);
}


//
//
// Function:    DIB_Copy
//
// Purpose:     Make a copy of the DIB memory
//
//
LPBITMAPINFOHEADER DIB_Copy(LPBITMAPINFOHEADER lpbi)
{
    LPBITMAPINFOHEADER  lpbiNew = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_Copy");

    ASSERT(lpbi);

    // Get the length of memory
    DWORD dwLen = DIB_TotalLength(lpbi);

    lpbiNew = (LPBITMAPINFOHEADER)::GlobalAlloc(GPTR, dwLen);
    if (lpbiNew != NULL)
    {
        // Copy the data
        memcpy(lpbiNew, lpbi, dwLen);
    }

    return(lpbiNew);
}

//
//
// Function:    DIB_FromBitmap
//
// Purpose:     Creates a DIB from a bitmap and palette
//
//
LPBITMAPINFOHEADER DIB_FromBitmap
(
    HBITMAP     hBitmap,
    HPALETTE    hPalette,
    BOOL        fGHandle,
    BOOL		fTopBottom,
    BOOL		fForce8Bits
)
{
    LPBITMAPINFOHEADER  lpbi = NULL;
    HGLOBAL             hmem = NULL;
    BITMAP              bm;
    BITMAPINFOHEADER    bi;
    DWORD               dwLen;
    WORD                biBits;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_FromBitmap");

    // If the bitmap handle given is null, do nothing
    if (hBitmap != NULL)
    {
        if (hPalette == NULL)
            hPalette = (HPALETTE)::GetStockObject(DEFAULT_PALETTE);

        // Get the bitmap information
        ::GetObject(hBitmap, sizeof(bm), (LPSTR) &bm);
		if(!fForce8Bits)
		{

	        biBits =  (WORD) (bm.bmPlanes * bm.bmBitsPixel);

    	    if (biBits > 8)
        	{
				if(g_pNMWBOBJ->CanDo24BitBitmaps())
				{
					biBits = 24;
				}
				else
				{
		            // If > 8, The maximum T126 supports is 8
		            biBits = 8;
		        }
	        }
	    }
	    else
	    {
	    	biBits = 8;
	    }

        bi.biSize               = sizeof(BITMAPINFOHEADER);
        bi.biWidth              = bm.bmWidth;
        bi.biHeight             = fTopBottom ? 0 - bm.bmHeight : bm.bmHeight;
        bi.biPlanes             = 1;
        bi.biBitCount           = biBits;
        bi.biCompression        = 0;
        bi.biSizeImage          = 0;
        bi.biXPelsPerMeter      = 0;
        bi.biYPelsPerMeter      = 0;
        bi.biClrUsed            = 0;
        bi.biClrImportant       = 0;

        dwLen  = bi.biSize + DIB_PaletteLength(&bi);

        HDC         hdc;
        HPALETTE    hPalOld;

        hdc = ::CreateDC("DISPLAY", NULL, NULL, NULL);
        hPalOld = ::SelectPalette(hdc, hPalette, FALSE);
        ::RealizePalette(hdc);

        // Allocate memory for the DIB
        if (fGHandle)
        {
            // For the clipboard, we MUST use GHND
            hmem = ::GlobalAlloc(GHND, dwLen);
            lpbi = (LPBITMAPINFOHEADER)::GlobalLock(hmem);
        }
        else
        {
            lpbi = (LPBITMAPINFOHEADER)::GlobalAlloc(GPTR, dwLen);
        }

        if (lpbi != NULL)
        {
            *lpbi = bi;

            // Call GetDIBits with a NULL lpBits param, so it will calculate the
            // biSizeImage field for us
            ::GetDIBits(hdc, hBitmap, 0, (WORD) bm.bmHeight, NULL,
                  (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

            bi = *lpbi;

            // If the driver did not fill in the biSizeImage field, make one up
            if (bi.biSizeImage == 0)
            {
                bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;
            }

            // Realloc the buffer big enough to hold all the bits
            dwLen = bi.biSize + DIB_PaletteLength(&bi) + bi.biSizeImage;

            if (fGHandle)
            {
                HGLOBAL hT;

                ::GlobalUnlock(hmem);
                hT = ::GlobalReAlloc(hmem, dwLen, GHND);
                if (!hT)
                {
                    ERROR_OUT(("Can't reallocate DIB handle"));
                    ::GlobalFree(hmem);
                    hmem = NULL;
                    lpbi = NULL;
                }
                else
                {
                    hmem = hT;
                    lpbi = (LPBITMAPINFOHEADER)::GlobalLock(hmem);
                }
            }
            else
            {
                LPBITMAPINFOHEADER lpbiT;

                lpbiT = (LPBITMAPINFOHEADER)::GlobalReAlloc((HGLOBAL)lpbi, dwLen, GMEM_MOVEABLE);
                if (!lpbiT)
                {
                    ERROR_OUT(("Can't reallocate DIB ptr"));

                    ::GlobalFree((HGLOBAL)lpbi);
                    lpbi = NULL;
                }
                else
                {
                    lpbi = lpbiT;
                }
            }
        }

        if (lpbi != NULL)
        {
            ::GetDIBits(hdc, hBitmap, 0,
                    (WORD)bm.bmHeight,
                    DIB_Bits(lpbi),
                    (LPBITMAPINFO)lpbi,
                    DIB_RGB_COLORS);

            if (fGHandle)
            {
                // We want to return the HANDLE, not the POINTER
                ::GlobalUnlock(hmem);
                lpbi = (LPBITMAPINFOHEADER)hmem;
            }
        }

        // Restore the old palette and give back the device context
        ::SelectPalette(hdc, hPalOld, FALSE);
        ::DeleteDC(hdc);
    }

    return(lpbi);
}





//
// AbortProc()
// Process messages during printing
//
//
BOOL CALLBACK AbortProc(HDC, int)
{
    MSG msg;

    ASSERT(g_pPrinter);

    // Message pump in case user wants to cancel printing
    while (!g_pPrinter->Aborted()
        && PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
    {
        if ( (g_pPrinter->m_hwndDialog == NULL) ||
            !::IsDialogMessage(g_pPrinter->m_hwndDialog, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return !g_pPrinter->Aborted();
}

//
//
// Function:    WbPrinter
//
// Purpose:     Constructor for a printer object
//
//
WbPrinter::WbPrinter(LPCTSTR szDeviceName)
{
    m_szDeviceName = szDeviceName;
    m_szPrintPageText[0] = 0;

    // Set up the global pointer for the abort procedure
    g_pPrinter = this;

    // Create the dialog window
    m_hwndDialog = ::CreateDialogParam(g_hInstance, MAKEINTRESOURCE(PRINTCANCEL),
        g_pMain->m_hwnd, CancelPrintDlgProc, 0);

    // Save the original text for the page number area
    ::GetDlgItemText(m_hwndDialog, IDD_PRINT_PAGE, m_szPrintPageText, _MAX_PATH);
}


//
//
// Function:    ~WbPrinter
//
// Purpose:     Destructor for a printer object
//
//
WbPrinter::~WbPrinter(void)
{
    // Kill off the dialog etc. if still around
    StopDialog();

    ASSERT(m_hwndDialog == NULL);

    g_pPrinter = NULL;
}


//
// StopDialog()
// If the dialog is up, ends it.
//
void WbPrinter::StopDialog(void)
{
    ::EnableWindow(g_pMain->m_hwnd, TRUE);

    // Close and destroy the dialog
    if (m_hwndDialog != NULL)
    {
        ::DestroyWindow(m_hwndDialog);
        m_hwndDialog = NULL;
    }

}

//
//
// Function:    StartDoc
//
// Purpose:     Tell the printer we are starting a new document
//
//
int WbPrinter::StartDoc
(
    HDC     hdc,
    LPCTSTR szJobName,
    int     nStartPage
)
{
    // Initialize the result codes and page number
    m_bAborted  = FALSE;         // Not aborted
    m_nPrintResult = 1;        // Greater than 0 implies all is well

    // Disable the main window
    ::EnableWindow(g_pMain->m_hwnd, FALSE);

    // Attach the printer DC
    SetPrintPageNumber(nStartPage);

    // Set up the abort routine for the print
    if (SetAbortProc(hdc, AbortProc) >= 0)
    {
        // Abort routine successfully set
        ::ShowWindow(m_hwndDialog, SW_SHOW);
        ::UpdateWindow(m_hwndDialog);

	    DOCINFO docinfo;

        docinfo.cbSize = sizeof(DOCINFO);
        docinfo.lpszDocName = szJobName;
        docinfo.lpszOutput = NULL;
        docinfo.lpszDatatype = NULL;   // Windows 95 only; ignored on Windows NT
        docinfo.fwType = 0;         // Windows 95 only; ignored on Windows NT

        // Initialize the document.
        m_nPrintResult = ::StartDoc(hdc, &docinfo);
    }

    return m_nPrintResult;
}

//
//
// Function:    StartPage
//
// Purpose:     Tell the printer we are starting a new page
//
//
int WbPrinter::StartPage(HDC hdc, int nPageNumber)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbPrinter::StartPage");

    m_nPrintResult = -1;  // Initialise to error

    // If the print has been aborted, return an error.
    if (m_bAborted)
    {
        TRACE_DEBUG(("Print has been aborted"));
    }
    else
    {
        SetPrintPageNumber(nPageNumber);

        // Tell the printer of the new page number
        m_nPrintResult = ::StartPage(hdc);
    }

    return(m_nPrintResult);
}


//
//
// Function:    EndPage
//
// Purpose:     Tell the printer we are finishing a page
//
//
int WbPrinter::EndPage(HDC hdc)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbPrinter::EndPage");

    m_nPrintResult = -1;  // Initialise to error

    // If the print has been aborted, return an error.
    if (m_bAborted)
    {
        TRACE_DEBUG(("Print has been aborted"));
    }
    else
    {
        // Tell the printer of the new page number
        m_nPrintResult = ::EndPage(hdc);
    }

    return(m_nPrintResult);
}

//
//
// Function:    EndDoc
//
// Purpose:     Tell the printer we have completed a document
//
//
int WbPrinter::EndDoc(HDC hdc)
{
    // If an error has occurred the driver will already have aborted the print
    if (m_nPrintResult > 0)
    {
        if (!m_bAborted)
        {
            // If we have not been aborted, and no error has occurred
            //   end the document
            m_nPrintResult = ::EndDoc(hdc);
        }
        else
        {
            m_nPrintResult = ::AbortDoc(hdc);
        }
    }

    StopDialog();

    // Return an the error indicator
    return m_nPrintResult;
}

//
//
// Function:    AbortDoc
//
// Purpose:     Abort the document currently in progress
//
//
int WbPrinter::AbortDoc()
{
    // Show that we have been aborted, the actual abort is
    // done by the EndDoc call.
    m_bAborted = TRUE;

    //
    // Renable the application window.
    //
    StopDialog();

    // Return a positive value indicating "aborted OK"
    return 1;
}


//
//
// Function:    SetPrintPageNumber
//
// Purpose:     Set the number of the page currently being printed
//
//
void WbPrinter::SetPrintPageNumber(int nPageNumber)
{
	// Display the number of the page currently being printed
	TCHAR szPageNumber [10 + _MAX_PATH];

    wsprintf(szPageNumber, m_szPrintPageText, nPageNumber);
    ::SetDlgItemText(m_hwndDialog, IDD_PRINT_PAGE, szPageNumber);
}


//
// CancelPrintDlgProc()
// Dialog message handler for the cancel printing dialog
//
INT_PTR CALLBACK CancelPrintDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            ASSERT(g_pPrinter != NULL);
            ::SetDlgItemText(hwnd, IDD_DEVICE_NAME, g_pPrinter->m_szDeviceName);
            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ASSERT(g_pPrinter != NULL);
                            g_pPrinter->AbortDoc();
                            break;
                    }
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}



//
// Bogus Bogus LAURABU
// STRING ARRAY (TEMP!)
//

StrArray::StrArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = 0;
}

StrArray::~StrArray()
{
    ClearOut();
}


void StrArray::ClearOut(void)
{
    int iItem;

    for (iItem = 0; iItem < m_nSize; iItem++)
    {
        if (m_pData[iItem] != NULL)
        {
            delete (LPTSTR)m_pData[iItem];
            m_pData[iItem] = NULL;
        }
    }

    m_nSize = 0;
    m_nMaxSize = 0;

    if (m_pData != NULL)
    {
        delete[] m_pData;
        m_pData = NULL;
    }

}


void StrArray::SetSize(int nNewSize)
{
	if (nNewSize == 0)
	{
		// shrink to nothing
        ClearOut();
	}
    else if (nNewSize <= m_nMaxSize)
    {
        // No shrinking allowed.
        ASSERT(nNewSize >= m_nSize);

        // We're still within the alloced block range
        m_nSize = nNewSize;
    }
	else
	{
        //
		// Make a larger array (isn't this lovely if you already have an
        // array, we alloc a new one and free the old one)
        //
		int nNewMax;

        nNewMax = (nNewSize + (ALLOC_CHUNK -1)) & ~(ALLOC_CHUNK-1);
		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around

		DBG_SAVE_FILE_LINE
		LPCTSTR* pNewData = new LPCTSTR[nNewMax];
        if (!pNewData)
        {
            ERROR_OUT(("StrArray::SetSize failed, couldn't allocate larger array"));
        }
        else
        {
            // Zero out the memory
            ZeroMemory(pNewData, nNewMax * sizeof(LPCTSTR));

            // If an old array exists, copy the existing string ptrs.
            if (m_pData != NULL)
            {
                CopyMemory(pNewData, m_pData, m_nSize * sizeof(LPCTSTR));

                //
                // Delete the old array, but not the strings inside, we're
                // keeping them around in the new array
                //
                delete[] m_pData;
            }

    		m_pData = pNewData;
	    	m_nSize = nNewSize;
		    m_nMaxSize = nNewMax;
        }
	}
}


void StrArray::SetAtGrow(int nIndex, LPCTSTR newElement)
{
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);

    SetAt(nIndex, newElement);
}


LPCTSTR StrArray::operator[](int nIndex) const
{
    ASSERT(nIndex >= 0);
    ASSERT(nIndex < m_nSize);
    return(m_pData[nIndex]);
}


void StrArray::SetAt(int nIndex, LPCTSTR newElement)
{
    ASSERT(nIndex >= 0);
    ASSERT(nIndex < m_nSize);

	DBG_SAVE_FILE_LINE
    m_pData[nIndex] = new TCHAR[lstrlen(newElement) + 1];
    lstrcpy((LPTSTR)m_pData[nIndex], newElement);
}


void StrArray::Add(LPCTSTR newElement)
{
	SetAtGrow(m_nSize, newElement);
}


//
//char *StrTok(string, control) - tokenize string with delimiter in control
//
char *  StrTok (char * string, char * control)
{
        char *str;
        char *ctrl = control;

        unsigned char map[32];
        int count;

        static char *nextoken;

        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do {
                map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. If string is NULL, set str to the saved
         * pointer (i.e., continue breaking tokens out of the string
         * from the last StrTok call) */
        if (string)
                str = string;
        else
                str = nextoken;

        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token iff this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
                str++;

        string = str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
                if ( map[*str >> 3] & (1 << (*str & 7)) ) {
                        *str++ = '\0';
                        break;
                }

        /* Update nextoken (or the corresponding field in the per-thread data
         * structure */
        nextoken = str;

        /* Determine if a token has been found. */
        if ( string == str )
                return NULL;
        else
                return string;
}


StrCspn(char * string, char * control)
{
        unsigned char *str = (unsigned char *)string;
        unsigned char *ctrl = (unsigned char *)control;

        unsigned char map[32];
        int count;

        /* Clear out bit map */
        for (count=0; count<32; count++)
                map[count] = 0;

        /* Set bits in control map */
        while (*ctrl)
        {
                map[*ctrl >> 3] |= (1 << (*ctrl & 7));
                ctrl++;
        }
		count=0;
        map[0] |= 1;    /* null chars not considered */
        while (!(map[*str >> 3] & (1 << (*str & 7))))
        {
                count++;
                str++;
        }
        return(count);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\coder.hpp ===
#ifndef _CODER_HPP
#define _CODER_HPP

#define ObjectID_       ASN1objectidentifier_s

typedef struct
{
    ASN1encoding_t  pEncInfo;
    ASN1decoding_t  pDecInfo;
}ASN1_CODER_INFO;

typedef struct
{
    ULONG           length;
    PBYTE           value;
}ASN1_BUF;

#include "t126.h"

extern "C" {
int T126_InitModule(void);
int T126_TermModule(void);
int T126_InitCoder(ASN1_CODER_INFO *pCoder);
int T126_TermCoder(ASN1_CODER_INFO *pCoder);
int T126_Encode(ASN1_CODER_INFO *pCoder, void *pStruct, int nPDU, ASN1_BUF *pBuf);
int T126_Decode(ASN1_CODER_INFO *pCoder, void **ppStruct, int nPDU, ASN1_BUF *pBuf);
}

//  DEBUG OPTIONS
#define CODER_DEBUG		  0x00000001
#define CODER_SUPER_DEBUG 0x00000002

// Coder Error Messages

#define CODER_NOERROR 0
#define CODER_ERROR   1

// Protocol version information
#define ITU_T			0
#define RECOMMENDATION	0
#define SERIES			20     // H225.0
#define RECOMM_NUMBER   126
#define VERSION         0
#define ADDITIONAL      1


class Coder{

private:
	ASN1_CODER_INFO		p_Coder;
	CRITICAL_SECTION	m_critSec;

public:
	struct ObjectID_ m_protocolIdentifier1,m_protocolIdentifier2,m_protocolIdentifier3,
		             m_protocolIdentifier4,m_protocolIdentifier5,m_protocolIdentifier6;

public:
	Coder();
	~Coder();

	int InitCoder();
	// Creates an OssBuf
	int Encode(SIPDU *pInputData, ASN1_BUF *pOutputOssBuf);
	// Create memory to hold decoded OssBuf
	// For H323 this is a rasStruct
	int Decode(ASN1_BUF *pInputOssBuf, SIPDU **pOutputData);
	// Used to free buffer created by decode
	int Free(SIPDU *pData);
	// Used to free buffer created by encode
	void Free(ASN1_BUF Asn1Buf);
	// Returns TRUE if protocols match, FALSE - otherwise

	__inline int freePDU(ASN1_CODER_INFO *pCoder, int nPDU, void *pDecoded, 
	ASN1module_t pModule)
	{
	    ASN1_FreeDecoded(pCoder->pDecInfo, pDecoded, nPDU);
	    return ASN1_SUCCESS;
	}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\cgrp.hpp ===
//
// CGRP.HPP
// WbColorsGroup
//
// Copyright Microsoft 1998-
//

#ifndef CGRP_HPP
#define CGRP_HPP



#define NUMROWS			2
#define NUMCOLS			14
#define NUMCLRPANES		(NUMROWS*NUMCOLS + 1) // palette + current one
#define INDEX_CHOICE    (NUMCLRPANES-1)     // last one
#define NUMCUSTCOLORS	16

#define CLRPANE_HEIGHT	16
#define CLRPANE_WIDTH	CLRPANE_HEIGHT
#define CLRPANE_BLACK	RGB( 0,0,0 )
#define CLRPANE_WHITE	RGB( 255,255,255 )


#define CLRCHOICE_HEIGHT    (NUMROWS * CLRPANE_HEIGHT)
#define CLRCHOICE_WIDTH     CLRCHOICE_HEIGHT


//
// Colors window proc
//
class WbColorsGroup
{
public:
	WbColorsGroup();
	~WbColorsGroup();
	virtual BOOL Create(HWND hwndParent, LPCRECT lprect);
    void    GetNaturalSize(LPSIZE lpsize);

	void SaveSettings( void );

    COLORREF GetCurColor(void);
    void    SetCurColor(COLORREF clr);
	LRESULT    OnEditColors( void );

    HWND    m_hwnd;

    friend  LRESULT CALLBACK CGWndProc(HWND, UINT, WPARAM, LPARAM);

protected:
    void     OnPaint(void);
    void     OnLButtonDown(UINT nFlags, int x, int y);
    void     OnLButtonDblClk(UINT nFlags, int x, int y);

	int      m_nLastColor;
	COLORREF m_crColors[ NUMCLRPANES ];
	HBRUSH   m_hBrushes[ NUMCLRPANES ];
	COLORREF m_crCustomColors[ NUMCUSTCOLORS ];

	COLORREF GetColorOfBrush( int nColor );
	void     SetColorOfBrush( int nColor, COLORREF crNewColor );
    void     SetColorOfPane(int nColor, COLORREF clr);

	COLORREF DoColorDialog( int nColor );
	void     ClickOwner( void );
};



#endif // CGRP_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\cgrp.cpp ===
//
// CGRP.CPP
// Color Group
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


static const TCHAR szCGClassName[] = "T126WB_CGRP";

// These default colors are the same as MSPaint
COLORREF g_crDefaultColors[NUMCLRPANES] =
{
        PALETTERGB(   0,  0,  0 ),
        PALETTERGB( 128,128,128 ),
        PALETTERGB( 128,  0,  0 ),
        PALETTERGB( 128,128,  0 ),
        PALETTERGB(   0,128,  0 ),
        PALETTERGB(   0,128,128 ),
        PALETTERGB(   0,  0,128 ),
        PALETTERGB( 128,  0,128 ),
        PALETTERGB( 128,128, 64 ),
        PALETTERGB(   0, 64, 64 ),
        PALETTERGB(   0,128,255 ),
        PALETTERGB(   0, 64,128 ),
        PALETTERGB(  64,  0,255 ),
        PALETTERGB( 128, 64,  0 ),

        PALETTERGB( 255,255,255 ),
        PALETTERGB( 192,192,192 ),
        PALETTERGB( 255,  0,  0 ),
        PALETTERGB( 255,255,  0 ),
        PALETTERGB(   0,255,  0 ),
        PALETTERGB(   0,255,255 ),
        PALETTERGB(   0,  0,255 ),
        PALETTERGB( 255,  0,255 ),
        PALETTERGB( 255,255,128 ),
        PALETTERGB(   0,255,128 ),
        PALETTERGB( 128,255,255 ),
        PALETTERGB( 128,128,255 ),
        PALETTERGB( 255,  0,128 ),
        PALETTERGB( 255,128, 64 ),

        PALETTERGB(   0,  0,  0 )    // Current color
};



//
// WbColorsGroup()
//
WbColorsGroup::WbColorsGroup()
{
    int         i;

    m_hwnd = NULL;

    for (i = 0; i < NUMCLRPANES; i++)
    {
        m_crColors[i] = g_crDefaultColors[i];
        m_hBrushes[i] = NULL;
    }


    for (i = 0; i < NUMCUSTCOLORS; i++)
    {
        m_crCustomColors[i] = CLRPANE_WHITE;
    }

    m_nLastColor = 0;
}



WbColorsGroup::~WbColorsGroup(void)
{
    int i;

    // clean up
    for (i = 0; i < NUMCLRPANES; i++)
    {
        if (m_hBrushes[i] != NULL)
        {
            ::DeleteBrush(m_hBrushes[i]);
            m_hBrushes[i] = NULL;
        }
    }

    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    // Unregister our class
    ::UnregisterClass(szCGClassName, g_hInstance);
}



BOOL WbColorsGroup::Create(HWND hwndParent, LPCRECT lprect)
{
    int         i;
    HDC         hdc;
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;
    WNDCLASSEX  wc;

    ASSERT(m_hwnd == NULL);

    // Register our class
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_DBLCLKS;
    wc.lpfnWndProc      = CGWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszClassName    = szCGClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbColorsGroup::Create register class failed"));
        return(FALSE);
    }

    //
    // We should be created the right siez
    //
    ASSERT(lprect->right - lprect->left == CLRCHOICE_WIDTH + NUMCOLS*CLRPANE_WIDTH);
    ASSERT(lprect->bottom - lprect->top == CLRCHOICE_HEIGHT);

    //
    // Calculate our item colors, then figure out our size.
    //

    hdc = ::GetDC(hwndParent);
    hPal = PG_GetPalette();
    if (hPal != NULL)
    {
        hOldPal = ::SelectPalette(hdc, hPal, FALSE);
        ::RealizePalette(hdc);
    }

    // load the colors from last time
    OPT_GetDataOption(OPT_MAIN_COLORPALETTE,
                           sizeof m_crColors,
                          (BYTE *)m_crColors );

    OPT_GetDataOption(OPT_MAIN_CUSTOMCOLORS,
                          sizeof m_crCustomColors,
                          (BYTE *)m_crCustomColors );

    // make brushes.
    for (i = 0; i < NUMCLRPANES; i++)
    {
        // force color matching
        m_crColors[i] = SET_PALETTERGB( m_crColors[i] );
        m_hBrushes[i] = ::CreateSolidBrush(m_crColors[i]);
    }

    for (i = 0; i < NUMCUSTCOLORS; i++)
    {
        // force color matching
        m_crCustomColors[i] = SET_PALETTERGB( m_crCustomColors[i] );
    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(hdc, hOldPal, TRUE);
    }
    ::ReleaseDC(hwndParent, hdc);

    //
    // Here's our layout:
    //      * The colors window is CHOICEFRAME_HEIGHT pixels high
    //      * The current choice is a rect of CHOICEFRAME_WIDTH by
    //          CHOICEFRAME_HEIGHT pixels, on the left side.  This includes
    //          a sunken EDGE.
    //      * There is no gap horizontally or vertically among panes.

    //
    // Create our window -- we're always visible.  The attribute group
    // shows/hides colors by showing/hiding itself.
    //
    if (!::CreateWindowEx(0, szCGClassName, NULL, WS_CHILD | WS_VISIBLE,
        lprect->left, lprect->top,
        lprect->right - lprect->left,
        lprect->bottom - lprect->top,
        hwndParent, NULL, g_hInstance, this))
    {
        ERROR_OUT(("Can't create WbColorsGroup"));
        return(FALSE);
    }

    ASSERT(m_hwnd != NULL);
    return(TRUE);
}


LRESULT CALLBACK CGWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbColorsGroup * pcg;

    pcg = (WbColorsGroup *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pcg = (WbColorsGroup *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pcg);

            pcg->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pcg);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pcg);
            pcg->m_hwnd = NULL;
            break;

        case WM_PAINT:
            ASSERT(pcg);
            pcg->OnPaint();
            break;

        case WM_LBUTTONDOWN:
            pcg->OnLButtonDown((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_LBUTTONDBLCLK:
            pcg->OnLButtonDblClk((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}



void WbColorsGroup::GetNaturalSize(LPSIZE lpsize)
{
    lpsize->cx = CLRCHOICE_WIDTH + NUMCOLS*CLRPANE_WIDTH;
    lpsize->cy = CLRCHOICE_HEIGHT;
}



COLORREF WbColorsGroup::GetCurColor(void)
{
    return(GetColorOfBrush(INDEX_CHOICE));
}



void WbColorsGroup::SetCurColor(COLORREF clr)
{
    SetColorOfPane(INDEX_CHOICE, clr);
}






//
// OnPaint()
//
// MFC message handler for WM_PAINT
//
void WbColorsGroup::OnPaint(void)
{
    PAINTSTRUCT ps;
    RECT        rc;
    RECT        rcClient;
    int         dx, dy;
    int         i;
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;

    ::BeginPaint(m_hwnd, &ps);

    hPal = PG_GetPalette();
    if (hPal != NULL)
    {
        hOldPal = ::SelectPalette(ps.hdc, hPal, FALSE);
        ::RealizePalette(ps.hdc);
    }

    dx = ::GetSystemMetrics(SM_CXEDGE);
    dy = ::GetSystemMetrics(SM_CYEDGE);
    ::GetClientRect(m_hwnd, &rcClient);

    // Draw the current choice
    rc = rcClient;
    rc.right = rc.left + CLRCHOICE_WIDTH;
    ::DrawEdge(ps.hdc, &rc, EDGE_SUNKEN, BF_ADJUST | BF_RECT);
    ::FillRect(ps.hdc, &rc, m_hBrushes[INDEX_CHOICE]);

    // Draw the colors
    rcClient.left += CLRCHOICE_WIDTH;

    rc = rcClient;
    rc.right = rc.left + CLRPANE_WIDTH;
    rc.bottom = rc.top + CLRPANE_HEIGHT;

    for (i = 0; i < NUMCLRPANES; i++)
    {
        ::DrawEdge(ps.hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
        ::FillRect(ps.hdc, &rc, m_hBrushes[i]);
        ::InflateRect(&rc, dx, dy);

        if (i == NUMCOLS - 1)
        {
            ::OffsetRect(&rc, - (NUMCOLS-1)*CLRPANE_WIDTH, CLRPANE_HEIGHT);
        }
        else
        {
            ::OffsetRect(&rc, CLRPANE_WIDTH, 0);
        }

    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(ps.hdc, hOldPal, TRUE);
    }

    ::EndPaint(m_hwnd, &ps);

}

//
// OnLButtonDown()
//
void WbColorsGroup::OnLButtonDown(UINT nFlags, int x, int y)
{
    //
    // If this is the current choice, do nothing.  Otherwise, change the
    // current color.
    //
    if (x >= CLRCHOICE_WIDTH)
    {
        int pane;

        pane = 0;
        if (y >= CLRPANE_HEIGHT)
            pane += NUMCOLS;
        pane += (x - CLRCHOICE_WIDTH) / CLRPANE_WIDTH;

        // Set the current color
        SetColorOfPane(INDEX_CHOICE, GetColorOfBrush(pane));
        m_nLastColor = pane;

        // tell Whiteboard about it.
        ClickOwner();
    }
}



//
// OnLButtonDblClk()
//
void  WbColorsGroup::OnLButtonDblClk(UINT nFlags, int x, int y)
// Invoke color dialog to edit this color
{
    if (x >= CLRCHOICE_WIDTH)
    {
        int pane;

        pane = 0;
        if (y >= CLRPANE_HEIGHT)
            pane += NUMCOLS;
        pane += (x - CLRCHOICE_WIDTH) / CLRPANE_WIDTH;

        DoColorDialog(pane);
    }
}



// Returns COLORREF of Brushes[] or BLACK if no brush
COLORREF WbColorsGroup::GetColorOfBrush( int nColor )
{
    ASSERT(nColor >= 0);
    ASSERT(nColor < NUMCLRPANES);

    if (m_hBrushes[nColor] != NULL)
    {
        return(m_crColors[nColor]);
    }
    else
    {
        return(CLRPANE_BLACK);
    }
}


// Recreates the nColor-th brush, using the new color
void WbColorsGroup::SetColorOfBrush( int nColor, COLORREF crNewColor )
{
    HBRUSH  hNewBrush;

    // force color matching
    crNewColor = SET_PALETTERGB( crNewColor );

    // check if we need to do anything
    if ((nColor > -1) && (crNewColor != GetColorOfBrush(nColor)))
    {
        // new color is different from old color, make a new brush

        hNewBrush = ::CreateSolidBrush(crNewColor);
        if (hNewBrush != NULL)
        {
            // We managed to create the new brush.  Delete the old one
            if (m_hBrushes[nColor] != NULL)
            {
                ::DeleteBrush(m_hBrushes[nColor]);
            }

            m_hBrushes[nColor] = hNewBrush;
            m_crColors[nColor] = crNewColor;
        }
    }
}



//
// SetColorOfPane()
//
// Replaces brush associated with nPaneId.
//
void WbColorsGroup::SetColorOfPane(int pane, COLORREF crNewColor )
{
    RECT    rcClient;

    // make a new brush
    SetColorOfBrush(pane, crNewColor);

    // update pane
    ::GetClientRect(m_hwnd, &rcClient);
    if (pane == INDEX_CHOICE)
    {
        rcClient.right = rcClient.left + CLRCHOICE_WIDTH;
    }
    else
    {
        rcClient.left += CLRCHOICE_WIDTH;

        rcClient.top += (pane / NUMCOLS) * CLRPANE_HEIGHT;
        rcClient.bottom = rcClient.top + CLRPANE_HEIGHT;
        rcClient.left += (pane % NUMCOLS) * CLRPANE_WIDTH;
        rcClient.right = rcClient.left + CLRPANE_WIDTH;
    }
    ::InvalidateRect(m_hwnd, &rcClient, FALSE);
}




void WbColorsGroup::SaveSettings( void )
    // Saves stuff in registry because we're shutting down
{
    // load the colors from last time
    OPT_SetDataOption(OPT_MAIN_COLORPALETTE,
                           sizeof m_crColors,
                          (BYTE *)m_crColors );

    OPT_SetDataOption(OPT_MAIN_CUSTOMCOLORS,
                          sizeof m_crCustomColors,
                          (BYTE *)m_crCustomColors );

}



LRESULT WbColorsGroup::OnEditColors( void )
{
    DoColorDialog( m_nLastColor );
	return S_OK;
}



//
// DoColorDialog()
// Put up ComDlg color picker to edit the pane's color value
//
COLORREF WbColorsGroup::DoColorDialog( int nColor )
{
    CHOOSECOLOR cc;

    memset(&cc, 0, sizeof(cc));
    cc.lStructSize = sizeof(cc);
    cc.lpCustColors = m_crCustomColors;
    cc.Flags = CC_RGBINIT;
    cc.rgbResult = GetColorOfBrush(nColor);
    cc.hwndOwner = m_hwnd;

    ::ChooseColor(&cc);

    // force color matching
    cc.rgbResult = SET_PALETTERGB(cc.rgbResult);

    // use the new color
    SetColorOfPane(nColor, cc.rgbResult );

    // set choice pane
    SetColorOfPane(INDEX_CHOICE,  cc.rgbResult );
    m_nLastColor = nColor;

    // tell Whiteboard about it.
    ClickOwner();

    return(cc.rgbResult );
}





void WbColorsGroup::ClickOwner( void )
{
    ::PostMessage(g_pMain->m_hwnd, WM_COMMAND,
                    (WPARAM)MAKELONG( IDM_COLOR, BN_CLICKED ),
                    (LPARAM)m_hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\drawobj.hpp ===
//
// DRAWOBJ.HPP
// Drawing objects: point, openpolyline, closepolyline, ellipse
//
// Copyright Microsoft 1998-
//
#ifndef __DRAWOBJ_HPP_
#define __DRAWOBJ_HPP_

//
// Maximum number of points in a freehand object
//
#define MAX_FREEHAND_POINTS     65535
#define MAX_POINT_LIST_VALUES   255

BOOL EllipseHit(LPCRECT lpEllipseRect, BOOL bBorderHit, UINT uPenWidth, LPCRECT lpHitRect );
void GetDrawingDestinationAddress(DrawingDestinationAddress *destinationAddress, PUINT workspaceHandle, PUINT planeID);

typedef struct tagCOLOR_PRESENT
{
	BOOL		m_bIsPresent;
	RGBTRIPLE	m_color;
}COLOR;


class DrawObj : public T126Obj
{

public:

	DCDWordArray *	m_points;				// List of consecutive points including anchor point


	DrawObj (UINT drawingType, UINT toolType);
	DrawObj ( DrawingCreatePDU * pdrawingCreatePDU );
	void DrawEditObj ( DrawingEditPDU * pdrawingEditPDU );

	~DrawObj( void );

	void Draw(HDC hDC = NULL, BOOL bForcedDraw = FALSE, BOOL bPrinting = FALSE);
	BOOL PolyLineHit(LPCRECT pRectHit);
	BOOL CheckReallyHit(LPCRECT pRectHit);

	//
	// PDU stuff
	//
	void CreateDrawingCreatePDU(DrawingCreatePDU *);
	void CreateDrawingEditPDU(DrawingEditPDU *);
	void CreateDrawingDeletePDU(DrawingDeletePDU*);
	void SetDrawingAttrib(PDrawingCreatePDU_attributes *attributes);
	void AllocateAttrib(PDrawingCreatePDU_attributes *pattributes);


	//
	// Get/Set drawing type
	//
	void SetDrawingType(UINT type){m_drawingType = type;};
	UINT GetDrawingType(void) {return m_drawingType;}

    //
    // Get/set the pen style
    //
    void SetLineStyle(UINT lineStyle){m_lineStyle = lineStyle;	ChangedLineStyle();};
    UINT  GetLineStyle(void) { return m_lineStyle;}


	//
	// Get/set pen Color
	//
    void SetPenColor(COLORREF rgb, BOOL isPresent);
    BOOL GetPenColor(COLORREF * rgb);
	BOOL GetPenColor(RGBTRIPLE* rgb);

	//
	// Get/set fill Color
	//
	BOOL HasFillColor(void){return m_bIsFillColorPresent;}
    void SetFillColor(COLORREF rgb, BOOL isPresent);
    BOOL GetFillColor(COLORREF * rgb);
	BOOL GetFillColor(RGBTRIPLE* rgb);

	//
	//
	// Get/set pen nib
	//
    void SetPenNib(UINT nib){m_penNib = nib;ChangedPenNib();};
    UINT GetPenNib(void){return m_penNib;}

	//
	// Get/set highlight
	//
    void SetHighlight(BOOL bHighlight){m_bHighlight = bHighlight; ChangedHighlight();};
    BOOL GetHighlight(void){return m_bHighlight;}


	BOOL AddPoint(POINT point);
	void AddPointToBounds(int x, int y);


	// JOSEF add functionality
	void SetEnd(POINT){};
	void UnDraw(void);
    void SetViewHandle(UINT viewHandle){};

	//
	// Get/set flag telling that this drawing is completed
	//
	void SetIsCompleted(BOOL isCompleted) {m_isDrawingCompleted = isCompleted;}
	BOOL GetIsCompleted(void){return m_isDrawingCompleted;}

	//
	// Get the UI tool from a drawing pdu
	//
	void SetUIToolType(void);

	//
	// Mask 0x000008FF (penColor_chosen = 1... DrawingAttribute_zOrder_chosen = 8)
	//
	void ChangedPenColor(void){m_dwChangedAttrib |=
					(1 << (penColor_chosen-1)) | (DrawingEditPDU_attributeEdits_present << 4);}
	void ChangedFillColor(void){m_dwChangedAttrib |=
					(1 << (fillColor_chosen-1))  | (DrawingEditPDU_attributeEdits_present << 4);}
	void ChangedPenThickness(void){m_dwChangedAttrib |=
					(1 << (penThickness_chosen-1))  | (DrawingEditPDU_attributeEdits_present << 4);}
	void ChangedPenNib(void){m_dwChangedAttrib |=
					(1 << (penNib_chosen-1))  | (DrawingEditPDU_attributeEdits_present << 4);}
	void ChangedLineStyle(void){m_dwChangedAttrib |=
					(1 << (lineStyle_chosen-1))  | (DrawingEditPDU_attributeEdits_present << 4);}
	void ChangedHighlight(void){m_dwChangedAttrib |=
					(1 << (highlight_chosen-1))  | (DrawingEditPDU_attributeEdits_present << 4);}
	void ChangedViewState(void){m_dwChangedAttrib |=
					(1 << (DrawingAttribute_viewState_chosen-1))  | (DrawingEditPDU_attributeEdits_present << 4);}
	void ChangedZOrder(void){m_dwChangedAttrib |=
					(1 << (DrawingAttribute_zOrder_chosen-1))  | (DrawingEditPDU_attributeEdits_present << 4);}

	BOOL HasPenColorChanged(void){return (m_dwChangedAttrib & (1 << (penColor_chosen - 1)));}
	BOOL HasFillColorChanged(void){return (m_dwChangedAttrib & (1 << (fillColor_chosen - 1)));}
	BOOL HasPenThicknessChanged(void){return (m_dwChangedAttrib & (1 << (penThickness_chosen - 1)));}
	BOOL HasPenNibChanged(void){return (m_dwChangedAttrib & (1 << (penNib_chosen - 1)));}
	BOOL HasLineStyleChanged(void){return (m_dwChangedAttrib & (1 << (lineStyle_chosen - 1)));}
	BOOL HasHighlightChanged(void){return (m_dwChangedAttrib & (1 << (highlight_chosen - 1)));}
	BOOL HasViewStateChanged(void){return (m_dwChangedAttrib & (1 << (DrawingAttribute_viewState_chosen - 1)));}
	BOOL HasZOrderChanged(void){return (m_dwChangedAttrib & (1 << (DrawingAttribute_zOrder_chosen - 1)));}


	//
	// Mask 0x000000700 bits (pointListEdits_present = 0x10... DrawingEditPDU_anchorPointEdit_present = 0x40)
	//
	void ChangedPointList(void) { m_dwChangedAttrib |= pointListEdits_present << 4;}
	void ChangedRotation(void) { m_dwChangedAttrib |= rotationEdit_present << 4;}
	void ChangedAnchorPoint(void) { m_dwChangedAttrib |= DrawingEditPDU_anchorPointEdit_present << 4;}

	BOOL HasPointListChanged(void) { return (m_dwChangedAttrib & pointListEdits_present << 4);}
	BOOL HasRotationChanged(void) { return (m_dwChangedAttrib & rotationEdit_present << 4);}
	BOOL HasAnchorPointChanged(void) { return (m_dwChangedAttrib & DrawingEditPDU_anchorPointEdit_present << 4);}
	DWORD GetPresentAttribs(void){return ((m_dwChangedAttrib & 0x0F00)>> 4);}
	void ResetAttrib(void){m_dwChangedAttrib = 0;}
	void SetAllAttribs(void){m_dwChangedAttrib = 0x08FF;}


	void	OnObjectEdit(void);
	void	OnObjectDelete(void);
	void	SendNewObjectToT126Apps(void);
	void	GetEncodedCreatePDU(ASN1_BUF *pBuf);

		
protected:

		//
		// T126 Drawing and UI specific
		//
		DWORD		m_dwChangedAttrib;
		UINT		m_drawingType;
		UINT 		m_lineStyle;
		BOOL		m_bIsPenColorPresent;
		BOOL		m_bIsFillColorPresent;
		RGBTRIPLE	m_penColor;
		RGBTRIPLE	m_fillColor;
		UINT		m_penNib;
		BOOL		m_bHighlight;
		BOOL		m_isDrawingCompleted;



UINT  GetSubsequentPoints(UINT choice, POINT * initialPoint, PointList * pointList);
void  GetDrawingAttrib(PVOID pAttribPDU);


};

#endif // __DRAWOBJ_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\drawobj.cpp ===
//
// DRAWOBJ.CPP
// Drawing objects: point, openpolyline, closepolyline, ellipse
//
// Copyright Microsoft 1998-
//
#include "precomp.h"

#define DECIMAL_PRECISION  100


DrawObj::DrawObj(UINT drawingType, UINT toolType):
	m_drawingType(drawingType),
	m_isDrawingCompleted(FALSE)
{
	SetMyWorkspace(NULL);
	SetOwnerID(g_MyMemberID);

	m_ToolType = toolType;

	//
	// Created locally, not selected, not editing or deleting.
	//
	CreatedLocally();
	ClearSelectionFlags();
	ClearEditionFlags();
	ClearDeletionFlags();

	SetFillColor(0,FALSE);

	//
	// No attributes changed, they will be set as we change them
	//
	ResetAttrib();

	DBG_SAVE_FILE_LINE
	m_points = new DCDWordArray();
	SetWorkspaceHandle(g_pCurrentWorkspace == NULL ? 0 : g_pCurrentWorkspace->GetWorkspaceHandle());
	SetType(drawingCreatePDU_chosen);
	SetPenNib(circular_chosen);
	SetROP(R2_NOTXORPEN);
	SetPlaneID(1);
	SetMyPosition(NULL);
	SetMyWorkspace(NULL);

	
	RECT rect;
    ::SetRectEmpty(&rect);
	SetBoundsRect(&rect);
	SetRect(&rect);

}

DrawObj::DrawObj (DrawingCreatePDU * pdrawingCreatePDU)
{
	SetType(drawingCreatePDU_chosen);
	SetMyWorkspace(NULL);

	//
	// Created remotely, not selected, not editing or deleting.
	//
	ClearCreationFlags();
	ClearSelectionFlags();
	ClearEditionFlags();
	ClearDeletionFlags();

	ResetAttrib();

	//
	// Get the drawing handle
	//
	SetThisObjectHandle(pdrawingCreatePDU->drawingHandle);

	//
	// Get the destination address
	//
	UINT workspaceHandle;
	UINT planeID;
	GetDrawingDestinationAddress(&pdrawingCreatePDU->destinationAddress, &workspaceHandle, &planeID);
	SetWorkspaceHandle(workspaceHandle);
	SetPlaneID(planeID);
	TRACE_DEBUG(("Destination address, Workspace Handle = %d", workspaceHandle));
	TRACE_DEBUG(("Destination address, Plane ID = %d", planeID));

	//
	// Get the drawing type, line, circle, etc ...
	//
    SetDrawingType(pdrawingCreatePDU->drawingType.choice);

	//
	// Set defaults
	//
//	m_T126Drawing.m_sampleRate = INVALID_SAMPLE_RATE;

	//
	// Default attributes
	//
	// Pen color black
	SetPenColor(0,TRUE);
	// No fill color
	SetFillColor(0,FALSE);
	// 1 Pixels for pen thickness
	SetPenThickness(1);
	// Pen Nib is circular
	SetPenNib(circular_chosen);
	// Solid line
	SetLineStyle(PS_SOLID);
	// No highlight
	SetHighlight(FALSE);
	// Not selected
	SetViewState(unselected_chosen);
	// Top object
	SetZOrder(front);

	// This is a complete drawing
	SetIsCompleted(TRUE);

	//
	// Get attributes
	//
	if(pdrawingCreatePDU->bit_mask & DrawingCreatePDU_attributes_present)
	{
		GetDrawingAttrib((PVOID)pdrawingCreatePDU->attributes);
	}

	DBG_SAVE_FILE_LINE
	m_points = new DCDWordArray();

	//
	// Get Anchor point
	//
	POINT Point;

	//
	// For open polylines the first point will be an offset of the anchor point
	//
	if(pdrawingCreatePDU->drawingType.choice == openPolyLine_chosen)
	{
		Point.x = 0;
		Point.y = 0;
		AddPoint(Point);
	}
	
	SetAnchorPoint(pdrawingCreatePDU->anchorPoint.xCoordinate, pdrawingCreatePDU->anchorPoint.yCoordinate);
	GetAnchorPoint(&Point);
	RECT rect;
	rect.left = pdrawingCreatePDU->anchorPoint.xCoordinate;
	rect.top = pdrawingCreatePDU->anchorPoint.yCoordinate;
	rect.right = pdrawingCreatePDU->anchorPoint.xCoordinate;
	rect.bottom = pdrawingCreatePDU->anchorPoint.yCoordinate;		
	SetRect(&rect);
	SetBoundsRect(&rect);
	AddPointToBounds(pdrawingCreatePDU->anchorPoint.xCoordinate, pdrawingCreatePDU->anchorPoint.yCoordinate);
	
	//
	// Since we don't know ahead of time how many points we have, set the type as a polyline
	//
	m_ToolType = TOOLTYPE_PEN;

	//
	// Get consecutive points
	//
	UINT nPoints;
	nPoints = GetSubsequentPoints(pdrawingCreatePDU->pointList.choice, &Point, &pdrawingCreatePDU->pointList);

	//
	// Find out what UI tool are we, and set the correct ROP
	//
	SetUIToolType();

	
	if(nPoints == 1)
	{
		POINT *point;
		point = m_points->GetBuffer();
		rect.right = point->x + pdrawingCreatePDU->anchorPoint.xCoordinate;
		rect.bottom = point->y + pdrawingCreatePDU->anchorPoint.yCoordinate;		
		SetRect(&rect);
		::InflateRect(&rect, GetPenThickness()/2, GetPenThickness()/2);
		SetBoundsRect(&rect);
	}
	
	//
	// Get Non standard stuff
	//
	if(pdrawingCreatePDU->bit_mask & DrawingCreatePDU_nonStandardParameters_present)
	{
		; // NYI
	}


}

DrawObj::~DrawObj( void )
{
	RemoveObjectFromResendList(this);
	RemoveObjectFromRequestHandleList(this);

	TRACE_DEBUG(("drawingHandle = %d", GetThisObjectHandle() ));

	//
	// Tell other nodes that we are gone
	//
	if(GetMyWorkspace() != NULL && WasDeletedLocally())
	{
		OnObjectDelete();
	}

	//
	// Clear the list of points
	//
	delete m_points;

}

void DrawObj::DrawEditObj ( DrawingEditPDU * pdrawingEditPDU )
{

	RECT		rect;
	POSITION	pos;
	POINT		anchorPoint;
	LONG 		deltaX = 0;
	LONG		deltaY = 0;

	TRACE_DEBUG(("DrawEditObj drawingHandle = %d", pdrawingEditPDU->drawingHandle ));

	//
	// Was edited remotely
	//
	ClearEditionFlags();

	//
	// Read attributes
	//
	if(pdrawingEditPDU->bit_mask & DrawingEditPDU_attributeEdits_present)
	{
		GetDrawingAttrib((PVOID)pdrawingEditPDU->attributeEdits);
	}

	//
	// Change the anchor point
	//
	GetAnchorPoint(&anchorPoint);
	if(pdrawingEditPDU->bit_mask & DrawingEditPDU_anchorPointEdit_present)
	{

		TRACE_DEBUG(("Old anchor point (%d,%d)", anchorPoint.x, anchorPoint.y));
		TRACE_DEBUG(("New anchor point (%d,%d)",
		pdrawingEditPDU->anchorPointEdit.xCoordinate, pdrawingEditPDU->anchorPointEdit.yCoordinate));
		//
		// Get the delta from previous anchor point
		//
		deltaX =  pdrawingEditPDU->anchorPointEdit.xCoordinate - anchorPoint.x;
		deltaY =  pdrawingEditPDU->anchorPointEdit.yCoordinate - anchorPoint.y;
		TRACE_DEBUG(("Delta (%d,%d)", deltaX , deltaY));

		//
		// Was edited remotely
		//
		ClearEditionFlags();
	}
	
	//
	// Get Rotation
	//
//	if(pdrawingEditPDU->bit_mask & rotationEdit_present)
//	{
//		m_T126Drawing.m_rotation.m_bIsPresent = TRUE;
//	    m_T126Drawing.m_rotation.m_rotation.rotationAngle = pdrawingEditPDU->rotation.rotationAngle;
//    	m_T126Drawing.m_rotation.m_rotation.rotationAxis.xCoordinate = pdrawingEditPDU->rotation.rotationAxis.xCoordinate;
//    	m_T126Drawing.m_rotation.m_rotation.rotationAxis.yCoordinate = pdrawingEditPDU->rotation.rotationAxis.yCoordinate;
//	}
//	else
//	{
//		m_T126Drawing.m_rotation.m_bIsPresent = FALSE;
//	}


	//
	// Get the list of points
	//
	if(pdrawingEditPDU->bit_mask & pointListEdits_present)
	{
		UINT i, initialIndex, xInitial,yInitial,numberOfPoints;
		
		PointListEdits_Seq pointList;
		POINT initialPoint;

		TRACE_DEBUG(("Number of point edit lists %d", pdrawingEditPDU->pointListEdits.count));


		for (i = 0; i<pdrawingEditPDU->pointListEdits.count; i++)
		{
			pointList = pdrawingEditPDU->pointListEdits.value[i];
			initialIndex = pointList.initialIndex;
			TRACE_DEBUG(("Points cached = %d", m_points->GetSize()));
			TRACE_DEBUG(("initialIndex = %d", initialIndex));
			initialPoint.x = pointList.initialPointEdit.xCoordinate;
			initialPoint.y = pointList.initialPointEdit.yCoordinate;

			POINT * pPoint = m_points->GetBuffer();
				
			TRACE_DEBUG(("initialPoint=(%d, %d), previousPoint=(%d, %d), anchorPoint=(%d, %d)",
					initialPoint.x, initialPoint.y,
					pPoint[initialIndex-1].x, pPoint[initialIndex-1].y,
					anchorPoint.x , anchorPoint.y
					));
			if(initialIndex > 1)
			{
				for(UINT i = 0; i< initialIndex; i++)
				{
					deltaX += pPoint[i].x;
					deltaY += pPoint[i].y;
				}
				initialPoint.x -= deltaX;
				initialPoint.y -= deltaY;
			}
			m_points->SetSize(initialIndex);
			AddPoint(initialPoint);

			if(GetDrawingType() == rectangle_chosen || GetDrawingType() == ellipse_chosen)
			{
				
				GetRect(&rect);
				rect.right = initialPoint.x + anchorPoint.x;
				rect.bottom = initialPoint.y + anchorPoint.y;		
				SetRect(&rect);
				::InflateRect(&rect, GetPenThickness()/2, GetPenThickness()/2);
				SetBoundsRect(&rect);
			}


			if(pointList.bit_mask & subsequentPointEdits_present)
			{
				GetSubsequentPoints(pointList.subsequentPointEdits.choice,
									&anchorPoint,
									&pointList.subsequentPointEdits);

			}
	        ChangedPointList();
		}
	}

	//
	// Just changed the anchor point, the other points have to change as well
	//
	if(pdrawingEditPDU->bit_mask & DrawingEditPDU_anchorPointEdit_present)
	{
		//
		// Set new anchor point
		//
		anchorPoint.x = pdrawingEditPDU->anchorPointEdit.xCoordinate;
		anchorPoint.y = pdrawingEditPDU->anchorPointEdit.yCoordinate;
		SetAnchorPoint(anchorPoint.x, anchorPoint.y);

		GetRect(&rect);
		::OffsetRect(&rect,  deltaX, deltaY);
		SetRect(&rect);
	
		GetBoundsRect(&rect);
		::OffsetRect(&rect,  deltaX, deltaY);
		SetBoundsRect(&rect);

	}


	if(pdrawingEditPDU->bit_mask & DrawingEditPDU_nonStandardParameters_present)
	{
		;		// Do the non Standard Edit PDU NYI
	}
	if(HasAnchorPointChanged() ||
		HasPointListChanged() ||
		HasFillColorChanged() ||
		HasPenColorChanged()||
		HasPenThicknessChanged()||
		HasLineStyleChanged())
	{
		g_pDraw->EraseInitialDrawFinal(0 - deltaX,0 - deltaY, FALSE, (T126Obj*)this);
		::InvalidateRect(g_pDraw->m_hwnd, NULL, TRUE);

	}
	else if(HasZOrderChanged())
	{
		if(GetZOrder() == front)
		{
			g_pDraw->BringToTopSelection(FALSE, this);
		}
		else
		{
			g_pDraw->SendToBackSelection(FALSE, this);
		}
	}
	//
	// If it just select/unselected it
	//
	else if(HasViewStateChanged())
	{
		; // do nothing
	}
	//
	// If we have a valid pen.
	//
	else if(GetPenThickness())
	{
		Draw();
	}

	//
	// Reset all the attributes
	//
	ResetAttrib();
}


void    DrawObj::GetDrawingAttrib(PVOID pAttribPDU)
{
	PDrawingEditPDU_attributeEdits attributes;
	attributes = (PDrawingEditPDU_attributeEdits)pAttribPDU;
	COLORREF rgb;
	while(attributes)
	{
		switch(attributes->value.choice)
		{
			case(penColor_chosen):
			{
				switch(attributes->value.u.penColor.choice)
				{
//					case(workspacePaletteIndex_chosen):
//					{
//						ASN1uint16_t workspacePaletteIndex = ((attributes->value.u.penColor).u).workspacePaletteIndex;
//						break;
//					}
					case(rgbTrueColor_chosen):
					{
						rgb = RGB(attributes->value.u.penColor.u.rgbTrueColor.r,
										attributes->value.u.penColor.u.rgbTrueColor.g,
										attributes->value.u.penColor.u.rgbTrueColor.b);
						SetPenColor(rgb, TRUE);
						TRACE_DEBUG(("Attribute penColor (r,g,b)=(%d, %d,%d)",
								attributes->value.u.penColor.u.rgbTrueColor.r,
								attributes->value.u.penColor.u.rgbTrueColor.g,
								attributes->value.u.penColor.u.rgbTrueColor.b));
						break;
					}
					case(transparent_chosen):
					{
						SetPenColor(0,FALSE);
						break;
					}
					default:
				    ERROR_OUT(("Invalid penColor choice"));
					break;
				}
				break;
  			}

			case(fillColor_chosen):
			{
				TRACE_DEBUG(("Attribute fillColor"));
				switch(attributes->value.u.fillColor.choice)
				{
//					case(workspacePaletteIndex_chosen):
//					{
//						ASN1uint16_t workspacePaletteIndex = ((attributes->value.u.fillColor).u).workspacePaletteIndex;
//						break;
//					}
					case(rgbTrueColor_chosen):
					{
						rgb = RGB(attributes->value.u.fillColor.u.rgbTrueColor.r,
										attributes->value.u.fillColor.u.rgbTrueColor.g,
										attributes->value.u.fillColor.u.rgbTrueColor.b);
						SetFillColor(rgb, TRUE);
						TRACE_DEBUG(("Attribute fillColor (r,g,b)=(%d, %d,%d)",
								attributes->value.u.fillColor.u.rgbTrueColor.r,
								attributes->value.u.fillColor.u.rgbTrueColor.g,
								attributes->value.u.fillColor.u.rgbTrueColor.b));
						break;
					}
					case(transparent_chosen):
					{
						SetFillColor(0,FALSE);
						break;
					}
					default:
				    ERROR_OUT(("Invalid fillColor choice"));
					break;
					}
					break;
  				}

			case(penThickness_chosen):
			{
				SetPenThickness(attributes->value.u.penThickness);
				TRACE_DEBUG(("Attribute penThickness %d", attributes->value.u.penThickness));
				break;
			}

			case(penNib_chosen):
			{
				if (attributes->value.u.penNib.choice != nonStandardNib_chosen)
				{
					SetPenNib(attributes->value.u.penNib.choice);
					TRACE_DEBUG(("Attribute penNib %d",attributes->value.u.penNib.choice));
				}
				else
				{
					// Do the non Standard penNib NYI
					;
				}
				break;
			}

			case(lineStyle_chosen):
			{
				if((attributes->value.u.lineStyle).choice != nonStandardStyle_chosen)
				{
					SetLineStyle(attributes->value.u.lineStyle.choice - 1);
					TRACE_DEBUG(("Attribute lineStyle %d", attributes->value.u.lineStyle.choice));
				}
				else
				{
					// Do the non Standard lineStyle NYI
					;
				}
				break;
			}
				
			case(highlight_chosen):
			{
				SetHighlight(attributes->value.u.highlight);
				TRACE_DEBUG(("Attribute highlight %d", attributes->value.u.highlight));
				break;
			}

			case(DrawingAttribute_viewState_chosen):
			{
				if((attributes->value.u.viewState).choice != nonStandardViewState_chosen)
				{
					SetViewState(attributes->value.u.viewState.choice);
					
					//
					// If the other node is selecting the drawing or unselecting
					//
					if(attributes->value.u.viewState.choice == selected_chosen)
					{
						SelectedRemotely();
					}
					else if(attributes->value.u.viewState.choice == unselected_chosen)
					{
						ClearSelectionFlags();
					}

					TRACE_DEBUG(("Attribute viewState %d", attributes->value.u.viewState.choice));
				}
				else
				{
					// Do the non Standard lineStyle NYI
					;
				}
				break;
			}

			case(DrawingAttribute_zOrder_chosen):
			{
				SetZOrder(attributes->value.u.zOrder);
				TRACE_DEBUG(("Attribute zOrder %d", attributes->value.u.zOrder));
				break;

			}
			case(DrawingAttribute_nonStandardAttribute_chosen):
			{
				break; // NYI
			}

			default:
		    ERROR_OUT(("Invalid attributes choice"));
			break;
		}

		attributes = attributes->next;
	}
	
}


UINT    DrawObj::GetSubsequentPoints(UINT choice, POINT * initialPoint, PointList * pointList)
{
	UINT numberOfPoints = 0;
	INT deltaX, deltaY;

	POINT point;
	if(choice == pointsDiff16_chosen)
	{
		PPointList_pointsDiff16 drawingPoint = pointList->u.pointsDiff16;
		deltaX = (SHORT)initialPoint->x;
		deltaY = (SHORT)initialPoint->y;
 		TRACE_DEBUG(("initialpoint (%d,%d)", deltaX, deltaY));

		while(drawingPoint)
		{
			numberOfPoints++;
	    	point.x = drawingPoint->value.xCoordinate;
   			point.y = drawingPoint->value.yCoordinate;
	        m_points->Add(point);
			deltaX += point.x;
			deltaY += point.y;
			drawingPoint = drawingPoint->next;
		}
	}
	else
	{
		TRACE_DEBUG(("GetSubsequentPoints got points != pointsDiff16_chosen"));
	}

	TRACE_DEBUG(("Got %d points", numberOfPoints));

	return numberOfPoints;
}



void DrawObj::CreateDrawingCreatePDU(DrawingCreatePDU *pCreatePDU)
{
	int nPoints = 1;
	pCreatePDU->bit_mask = 0;

	//
	// Pass the drawing Handle
	//
	pCreatePDU->bit_mask |=drawingHandle_present;
	pCreatePDU->drawingHandle = GetThisObjectHandle();

	//
	// Pass the destination adress
	//
	pCreatePDU->destinationAddress.choice = DrawingDestinationAddress_softCopyAnnotationPlane_chosen;
	pCreatePDU->destinationAddress.u.softCopyAnnotationPlane.workspaceHandle = GetWorkspaceHandle();
	pCreatePDU->destinationAddress.u.softCopyAnnotationPlane.plane = (DataPlaneID)GetPlaneID();

	//
	// Pass the drawing type
	//
	pCreatePDU->drawingType.choice = (ASN1choice_t)GetDrawingType();

	//
	// Pass the attributes
	//
	SetDrawingAttrib(&pCreatePDU->attributes);
	if(pCreatePDU->attributes != NULL)
	{
		pCreatePDU->bit_mask |=DrawingCreatePDU_attributes_present;
	}


	//
	// Pass the anchor point
	//
	POINT point;
	GetAnchorPoint(&point);
	pCreatePDU->anchorPoint.xCoordinate = point.x;
	pCreatePDU->anchorPoint.yCoordinate = point.y;

	RECT  rect;
	GetRect(&rect);


	pCreatePDU->pointList.choice = pointsDiff16_chosen;
	DBG_SAVE_FILE_LINE
	pCreatePDU->pointList.u.pointsDiff16 = (PPointList_pointsDiff16)new BYTE[sizeof(PointList_pointsDiff16)];
	PPointList_pointsDiff16 drawingPoint = pCreatePDU->pointList.u.pointsDiff16;
	PPointList_pointsDiff16 drawingPointLast = NULL;
	drawingPoint->next = NULL;

	switch(GetDrawingType())
	{

		case point_chosen:
		drawingPoint->value.xCoordinate = 0;
		drawingPoint->value.yCoordinate = 0;
		drawingPoint->next = NULL;
		break;

		case openPolyLine_chosen:
		case closedPolyLine_chosen:
		case rectangle_chosen:
		case ellipse_chosen:
		{
			UINT nPoints = m_points->GetSize();
			UINT maxPoints = 1;
			POINT * pPoint = m_points->GetBuffer();
			while(nPoints && maxPoints < (MAX_POINT_LIST_VALUES + 1))
			{
				drawingPoint->value.xCoordinate = (SHORT)pPoint->x;
				drawingPoint->value.yCoordinate = (SHORT)pPoint->y;
				drawingPointLast = drawingPoint;
				DBG_SAVE_FILE_LINE
				drawingPoint->next = (PPointList_pointsDiff16)new BYTE[sizeof(PointList_pointsDiff16)];
				drawingPoint = drawingPoint->next;
				nPoints--;
				pPoint++;
				maxPoints++;
			}
			if(drawingPointLast)
			{
				delete drawingPointLast->next;
				drawingPointLast->next = NULL;
			}
			
		}
		break;		
	}
	
}
	
void DrawObj::CreateDrawingEditPDU(DrawingEditPDU *pEditPDU)
{
	pEditPDU->bit_mask = (ASN1uint16_t) GetPresentAttribs();

	//
	// Pass the anchor point
	//
	POINT point;
	GetAnchorPoint(&point);

	if(HasAnchorPointChanged())
	{
		pEditPDU->anchorPointEdit.xCoordinate = point.x;
		pEditPDU->anchorPointEdit.yCoordinate = point.y;
	}

	pEditPDU->pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16 = NULL;

	//
	// Pass point list changes
	//
	if(HasPointListChanged())
	{

		UINT nPoints = m_points->GetSize();
		POINT * pPoint = m_points->GetBuffer();

		pPoint = &pPoint[1];

		//
		// Just send the last 255 points
		//
		if(nPoints > 256)
		{
			pEditPDU->pointListEdits.value[0].initialIndex = nPoints - 256;
			nPoints = 256;
		}
		else
		{
			pEditPDU->pointListEdits.value[0].initialIndex = 0;
		}

		//
		// Calculate the initial point
		//
		point.x = 0;
		point.y = 0;
		for(UINT i = 0; i < pEditPDU->pointListEdits.value[0].initialIndex; i++)
		{
			point.x += pPoint[i].x;
			point.y += pPoint[i].y;
		}

		pEditPDU->pointListEdits.count = 1;
		pEditPDU->pointListEdits.value[0].bit_mask = subsequentPointEdits_present;
		pEditPDU->pointListEdits.value[0].subsequentPointEdits.choice = pointsDiff16_chosen;
		pEditPDU->pointListEdits.value[0].initialPointEdit.xCoordinate = (SHORT)point.x;
		pEditPDU->pointListEdits.value[0].initialPointEdit.yCoordinate = (SHORT)point.y;

		TRACE_DEBUG(("Sending List of points starting at Index = %d  point(%d,%d)",
			pEditPDU->pointListEdits.value[0].initialIndex, point.x, point.y));


		pPoint = &pPoint[pEditPDU->pointListEdits.value[0].initialIndex];

		DBG_SAVE_FILE_LINE
		pEditPDU->pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16 = (PPointList_pointsDiff16)new BYTE[sizeof(PointList_pointsDiff16)];
		PPointList_pointsDiff16 drawingPointLast = NULL;
		PPointList_pointsDiff16 drawingPoint = pEditPDU->pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16;
		pEditPDU->pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16->next = NULL;
		pEditPDU->pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16->value.xCoordinate = 0;
		pEditPDU->pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16->value.yCoordinate = 0;

		
		nPoints--;
		while(nPoints)
		{
			drawingPoint->value.xCoordinate = (SHORT)pPoint->x;
			drawingPoint->value.yCoordinate = (SHORT)pPoint->y;
			drawingPointLast = drawingPoint;
			DBG_SAVE_FILE_LINE
			drawingPoint->next = (PPointList_pointsDiff16)new BYTE[sizeof(PointList_pointsDiff16)];
			drawingPoint = drawingPoint->next;
			nPoints--;
			pPoint++;
		}
		if(drawingPointLast)
		{
			delete drawingPointLast->next;
			drawingPointLast->next = NULL;
		}
	}

	//
	// JOSEF Pass rotation if we ever do it (FEATURE)
	//
	
	//
	// Pass all the changed attributes, if any.
	//
	if(pEditPDU->bit_mask & DrawingEditPDU_attributeEdits_present)
	{
		SetDrawingAttrib((PDrawingCreatePDU_attributes *)&pEditPDU->attributeEdits);
	}

	pEditPDU->drawingHandle = GetThisObjectHandle();
}
	
void DrawObj::CreateDrawingDeletePDU(DrawingDeletePDU *pDeletePDU)
{
	pDeletePDU->bit_mask = 0;
	pDeletePDU->drawingHandle = GetThisObjectHandle();
}

void    DrawObj::AllocateAttrib(PDrawingCreatePDU_attributes *pAttributes)
{
	DBG_SAVE_FILE_LINE
	PDrawingCreatePDU_attributes  pAttrib = (PDrawingCreatePDU_attributes)new BYTE[sizeof(DrawingCreatePDU_attributes)];
	if(*pAttributes == NULL)
	{
		*pAttributes = pAttrib;	
		pAttrib->next = NULL;
	}
	else
	{
		((PDrawingCreatePDU_attributes)pAttrib)->next = *pAttributes;
		*pAttributes = pAttrib;
	}
}

void    DrawObj::SetDrawingAttrib(PDrawingCreatePDU_attributes *pattributes)
{

	PDrawingCreatePDU_attributes attributes = NULL;
	RGBTRIPLE color;

	//
	// Do the pen Color
	//
	if(HasPenColorChanged())
	{
		if(GetPenColor(&color))
		{
			AllocateAttrib(&attributes);
			attributes->value.choice = penColor_chosen;
			attributes->value.u.penColor.choice = rgbTrueColor_chosen;
			attributes->value.u.penColor.u.rgbTrueColor.r = color.rgbtRed;
			attributes->value.u.penColor.u.rgbTrueColor.g = color.rgbtGreen;
			attributes->value.u.penColor.u.rgbTrueColor.b = color.rgbtBlue;
		}
	}

	//
	// Do the fillColor
	//
	if(HasFillColorChanged())
	{
		if(GetFillColor(&color))
		{
			AllocateAttrib(&attributes);
			attributes->value.choice = fillColor_chosen;
			attributes->value.u.fillColor.choice = rgbTrueColor_chosen;
			attributes->value.u.fillColor.u.rgbTrueColor.r = color.rgbtRed;
			attributes->value.u.fillColor.u.rgbTrueColor.g = color.rgbtGreen;
			attributes->value.u.fillColor.u.rgbTrueColor.b = color.rgbtBlue;
		}
	}
	
	//
	// Do the penThickness
	//
	if(HasPenThicknessChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = penThickness_chosen;
		attributes->value.u.penThickness = (PenThickness)GetPenThickness();
	}

	//
	// Do the penNib
	//
	if(HasPenNibChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = penNib_chosen;
		attributes->value.u.penNib.choice = (ASN1choice_t)GetPenNib();
	}

	//
	// Do the lineStyle
	//
	if(HasLineStyleChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = lineStyle_chosen;
		attributes->value.u.lineStyle.choice = GetLineStyle()+1;
	}
	
	//
	// Do the Highlight
	//
	if(HasHighlightChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = highlight_chosen;
		attributes->value.u.highlight = (ASN1bool_t)GetHighlight();
	}
	
	//
	// Do the viewState
	//
	if(HasViewStateChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = DrawingAttribute_viewState_chosen;
		attributes->value.u.viewState.choice = (ASN1choice_t)GetViewState();
	}
	
	//
	// Do the zOrder
	//
	if(HasZOrderChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = DrawingAttribute_zOrder_chosen;
		attributes->value.u.zOrder = GetZOrder();
	}

	*pattributes = attributes;

}






//
// CircleHit()
//
// Checks for overlap between circle at PcxPcy with uRadius and
// lpHitRect. If overlap TRUE is returned, otherwise FALSE.
//
BOOL CircleHit( LONG Pcx, LONG Pcy, UINT uRadius, LPCRECT lpHitRect,
					BOOL bCheckPt )
{
	RECT hr = *lpHitRect;
	RECT ellipse;
	ellipse.left = Pcx - uRadius;
	ellipse.right= Pcx + uRadius;
	ellipse.bottom = Pcy + uRadius;
	ellipse.top = Pcy - uRadius;


	// check the easy thing first (don't use PtInRect)
	if( bCheckPt &&(lpHitRect->left >= ellipse.left)&&(ellipse.right >= lpHitRect->right)&&
				   (lpHitRect->top >= ellipse.top)&&(ellipse.bottom >= lpHitRect->bottom))
	{
		return( TRUE );
	}

	//
	// The circle is just a boring ellipse
	//
	return EllipseHit(&ellipse, bCheckPt,  uRadius, lpHitRect );
}


//
// EllipseHit()
//
// Checks for overlap between ellipse defined by lpEllipseRect and
// lpHitRect. If overlap TRUE is returned, otherwise FALSE.
//
BOOL EllipseHit(LPCRECT lpEllipseRect, BOOL bBorderHit, UINT uPenWidth,
					 LPCRECT lpHitRect )
{
	RECT hr = *lpHitRect;
	RECT er = *lpEllipseRect;

	// Some code below assumes l<r and t<b
	NormalizeRect(&er);
	lpEllipseRect = &er;

	// Check easy thing first. If lpEllipseRect is inside lpHitRect
	// then we have a hit (no duh...)
	if( (hr.left <= lpEllipseRect->left)&&(hr.right >= lpEllipseRect->right)&&
		(hr.top <= lpEllipseRect->top)&&(hr.bottom >= lpEllipseRect->bottom) )
		return( TRUE );

	// Check easy thing first. If lpEllipseRect is disjoint from lpHitRect
	// then we have a miss (no duh...)
	if( (hr.left > lpEllipseRect->right)||(hr.right < lpEllipseRect->left)||
		(hr.top > lpEllipseRect->bottom)||(hr.bottom < lpEllipseRect->top) )
		return( FALSE );

	// If this is an ellipse....
	//
	//		*  *         ^
	//	 *     | b       | Y
	// *       |    a    +-------> X
	// *-------+--------
	//         |
	//
		
	
	//
	// Look for the ellipse hit. (x/a)^2 + (y/b)^2 = 1
	// If it is > 1 than the point is outside the ellipse
	// If it is < 1 it is inside
	//
	LONG a,b,aOuter, bOuter, x, y, xCenter, yCenter;
	BOOL bInsideOuter = FALSE;
	BOOL bOutsideInner = FALSE;

	//
	// Calculate a and b
	//
	a = (lpEllipseRect->right - lpEllipseRect->left)/2;
	b = (lpEllipseRect->bottom - lpEllipseRect->top)/2;

	//
	// Get the center of the ellipse
	//
	xCenter = lpEllipseRect->left + a;
	yCenter = lpEllipseRect->top + b;

	//
	// a and b generates a inner ellipse
	// aOuter and bOuter generates a outer ellipse
	//
	aOuter = a + uPenWidth/2;
	bOuter = b + uPenWidth/2;
	a = a - uPenWidth/2;
	b = b - uPenWidth/2;

	//
	// Make our coordinates relative to the center of the ellipse
	//
	y = abs(hr.bottom - yCenter);
	x = abs(hr.right - xCenter);

	
	//
	// Be carefull not to divide by 0
	//
	if((a && b && aOuter && bOuter) == 0)
	{
		return FALSE;
	}

	//
	// We are using LONG instead of double and we need to have some precision
	// that is why we multiply the equation of the ellipse
	// ((x/a)^2 + (y/b)^2 = 1) by DECIMAL_PRECISION
	// Note that the multiplication has to be done before the division, if we didn't do that
	// we will always get 0 or 1 for x/a
	//
	if(x*x*DECIMAL_PRECISION/(aOuter*aOuter) + y*y*DECIMAL_PRECISION/(bOuter*bOuter) <= DECIMAL_PRECISION)
	{
		bInsideOuter = TRUE;
	}

	if(x*x*DECIMAL_PRECISION/(a*a)+ y*y*DECIMAL_PRECISION/(b*b) >= DECIMAL_PRECISION)
	{
		bOutsideInner = TRUE;
	}
	
	//
	// If we are checking for border hit,
	// we need to be inside the outer ellipse and inside the inner
	//
	if( bBorderHit )
	{
			return( bInsideOuter & bOutsideInner );
	}
	// just need to be inside the outer ellipse
	else
	{
		return( bInsideOuter );
	}

}


//
// LineHit()
//
// Checks for overlap (a "hit") between lpHitRect and the line
// P1P2 accounting for line width. If bCheckP1End or bCheckP2End is
// TRUE then a circle of radius 0.5 * uPenWidth is also checked for
// a hit to account for the rounded ends of wide lines.
//
// If a hit is found TRUE is returned, otherwise FALSE.
//
BOOL LineHit( LONG P1x, LONG P1y, LONG P2x, LONG P2y, UINT uPenWidth,
				  BOOL bCheckP1End, BOOL bCheckP2End,
				  LPCRECT lpHitRect )
{

	LONG uHalfPenWidth = uPenWidth/2;

	//
	// It is really hard to hit if the width is only 2
	//
	if(uHalfPenWidth == 1)
	{
		uHalfPenWidth = 2;
	}

	LONG a,b,x,y;

	x = lpHitRect->left + (lpHitRect->right - lpHitRect->left)/2;
	y = lpHitRect->bottom + (lpHitRect->top - lpHitRect->bottom)/2;

	//
	// This code assume the rectangle is normalized
	//
	RECT rect;
	rect.top = P1y;
	rect.left = P1x;
	rect.bottom = P2y;
	rect.right = P2x;

	NormalizeRect(&rect);

	if( (P1x == P2x)&&(P1y == P2y) )
	{
		// just check one end point's circle
		return( CircleHit( P1x, P1y, uHalfPenWidth, lpHitRect, TRUE ) );
	}

	// check rounded end at P1
	if( bCheckP1End && CircleHit( P1x, P1y, uHalfPenWidth, lpHitRect, FALSE ) )
		return( TRUE );

	// check rounded end at P2
	if( bCheckP2End && CircleHit( P2x, P2y, uHalfPenWidth, lpHitRect, FALSE ) )
		return( TRUE );
	
	//
	// The function of a line is Y = a.X + b
	//
	// a = (Y1-Y2)/(X1 -X2)
	// if we found a we get b = y1 -a.X1
	//

	if(P1x == P2x)
	{
		a=0;
		b = DECIMAL_PRECISION*P1x;

	}
	else
	{
		a = (P1y - P2y)*DECIMAL_PRECISION/(P1x - P2x);
		b = DECIMAL_PRECISION*P1y - a*P1x;
	}


	//
	// Paralel to Y
	//
	if(P1x == P2x && ((x >= P1x - uHalfPenWidth) && x <= P1x + uHalfPenWidth))
	{
		return (P1y <= y && P2y >= y);
	}

	//
	// Paralel to X
	//
	if(P1y == P2y && ((y >= P1y - uHalfPenWidth) && y <= P1y + uHalfPenWidth))
	{
		return (P1x <= x && P2x >= x);
	}

	//
	// General line
	//

	return(( y*DECIMAL_PRECISION <= a*x + b + DECIMAL_PRECISION*uHalfPenWidth) &&
			( y*DECIMAL_PRECISION >= a*x + b - DECIMAL_PRECISION*uHalfPenWidth)&&
			((rect.top <= y && rect.bottom >= y) && (rect.left <= x && rect.right >= x)));
}





//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//
BOOL DrawObj::PolyLineHit(LPCRECT pRectHit)
{
	POINT	*lpPoints;
	int		iCount;
	int		i;
	POINT	ptLast;
	UINT	uRadius;
	RECT	rectHit;

	iCount = m_points->GetSize();
	lpPoints = (POINT *)m_points->GetBuffer();

	if( iCount == 0 )
		return( FALSE );


	// addjust hit rect to lpPoints coord space.
	rectHit = *pRectHit;
	POINT anchorPoint;
	GetAnchorPoint(&anchorPoint);

	if( (iCount > 0)&&(iCount < 2) )
	{
		// only one point, just hit check it
		uRadius = GetPenThickness() >> 1; // m_uiPenWidth/2
		return(CircleHit( anchorPoint.x + lpPoints->x, anchorPoint.y - lpPoints->y, uRadius, &rectHit, TRUE ));
	}


	// look for a hit on each line segment body
	ptLast = anchorPoint;
	for( i=1; i<iCount; i++ )
	{
		RECT rect;
		rect.top = ptLast.y;
		rect.left = ptLast.x;
		rect.bottom =  ptLast.y + lpPoints->y;
		rect.right = ptLast.x + lpPoints->x;
		NormalizeRect(&rect);

		if( LineHit(rect.left, rect.top, rect.right, rect.bottom, GetPenThickness(), TRUE, TRUE, &rectHit))
		{
			return( TRUE ); // got a hit
		}

		lpPoints++;
		ptLast.x +=lpPoints->x;
		ptLast.y +=lpPoints->y;
	}

	// now, look for a hit on the line endpoints if m_uiPenWidth > 1
	if( GetPenThickness() > 1 )
	{
		uRadius = GetPenThickness() >> 1; // m_uiPenWidth/2
		lpPoints = (POINT *)m_points->GetBuffer();
		for( i=0; i<iCount; i++, lpPoints++ )
		{
			if( CircleHit( anchorPoint.x + lpPoints->x, anchorPoint.y + lpPoints->y, uRadius, &rectHit, FALSE ))
			{
				return( TRUE ); // got a hit
			}
		}
	}

	return( FALSE ); // no hits
}




DrawObj::CheckReallyHit(LPCRECT pRectHit)
{
	RECT rect;
	
	switch(GetDrawingType())
	{
		case point_chosen:
		case openPolyLine_chosen:
		{
			UINT nPoints = m_points->GetSize();
			if(nPoints > 2 )
			{
				POINT point;
				RECT rect;
				GetBoundsRect(&rect);
				point.y = pRectHit->top;
				point.x = pRectHit->left;
				return PolyLineHit(pRectHit);
			}
			else
			{
				GetRect(&rect);
				return(LineHit(rect.left, rect.top, rect.right, rect.bottom, GetPenThickness(), TRUE, TRUE, pRectHit));
	       	}
       }
		break;

		case rectangle_chosen:
		{
		    // Draw the rectangle
		    return(RectangleHit(!HasFillColor(), pRectHit));
		}
		break;
		
		case ellipse_chosen:
		{
			GetRect(&rect);
		    return( EllipseHit( &rect, !HasFillColor(), GetPenThickness(), pRectHit ));

		}
		break;
	}

	return FALSE;
}

void DrawObj::UnDraw(void)
{
	RECT rect;
	UINT penThickness;
	GetBoundsRect(&rect);
	penThickness = GetPenThickness();
	::InflateRect(&rect, penThickness, penThickness);
	g_pDraw->InvalidateSurfaceRect(&rect,TRUE);

	BitmapObj* remotePointer = NULL;
	WBPOSITION pos = NULL;
	remotePointer = g_pCurrentWorkspace->RectHitRemotePointer(&rect, penThickness, NULL);
	while(remotePointer)
	{
		remotePointer->DeleteSavedBitmap();
		remotePointer = g_pCurrentWorkspace->RectHitRemotePointer(&rect, penThickness, remotePointer->GetMyPosition());
	}
}


void DrawObj::Draw(HDC hDC, BOOL bForcedDraw, BOOL bPrinting)
{

	if(!bPrinting)
	{
		//
		// Don't draw anything if we don't belong in this workspace
		//
		if(!(GraphicTool() == TOOLTYPE_SELECT || GraphicTool() == TOOLTYPE_ERASER) && GetWorkspaceHandle() != g_pCurrentWorkspace->GetThisObjectHandle())
		{
			return;
		}
	}

	HPEN	hPen = NULL;
	HPEN	hOldPen = NULL;
	HBRUSH	hBrush = NULL;
	HBRUSH  hOldBrush = NULL;
	BOOL	bHasPenColor;
	BOOL	bHasFillColor;
	BitmapObj* remotePointer = NULL;
	COLORREF color;
	COLORREF fillColor;
	RECT boundsRect;
	RECT rect;
	UINT penThickness = GetPenThickness();

	if(hDC == NULL)
	{
		hDC = g_pDraw->m_hDCCached;
	}

	MLZ_EntryOut(ZONE_FUNCTION, "DrawObj::Draw");

	// Select the required pen and fill color
	bHasPenColor = GetPenColor(&color);
	bHasFillColor = GetFillColor(&fillColor);

	if(bHasFillColor)
	{
		hBrush = ::CreateSolidBrush(SET_PALETTERGB(fillColor));
		hOldBrush = SelectBrush(hDC, hBrush);
	}
	else
	{
		hOldBrush = SelectBrush(hDC, ::GetStockObject(NULL_BRUSH));
	}

	//
	// Get rect
	//
	GetBoundsRect(&boundsRect);
	GetRect(&rect);


	hPen = ::CreatePen(GetLineStyle(), penThickness, SET_PALETTERGB(color));
	hOldPen = SelectPen(hDC, hPen);


	if (hOldPen != NULL)
	{

		// Select the raster operation
		int iOldROP = ::SetROP2(hDC, GetROP());

		switch(GetDrawingType())
		{
			case point_chosen:
			case openPolyLine_chosen:
			{
				UINT nPoints = m_points->GetSize();
				//
				// This is a redraw of a pen or highlight
				// We have to draw all the segments
				//
				if( (bForcedDraw || GetIsCompleted()) && nPoints  > 1)
				{
					POINT anchorPoint;
					GetAnchorPoint(&anchorPoint);

					AddPointToBounds(anchorPoint.x, anchorPoint.y);

					//
					// Go to the beggining
					//
					::MoveToEx(hDC, anchorPoint.x, anchorPoint.y, NULL);

					//
					// Get the list of points
					//
					POINT *point = m_points->GetBuffer();
					while(nPoints)
					{
						anchorPoint.x += point->x;
						anchorPoint.y += point->y;
						::LineTo(hDC, anchorPoint.x, anchorPoint.y);
						::MoveToEx(hDC, anchorPoint.x, anchorPoint.y, NULL);
						point++;
						nPoints--;

						RECT rect;
						MAKE_HIT_RECT(rect, anchorPoint);
						if(remotePointer)
						{
							remotePointer->Draw();
							remotePointer = NULL;
						}

						AddPointToBounds(anchorPoint.x, anchorPoint.y);

						::InflateRect(&rect, GetPenThickness()/2, GetPenThickness()/2);
						remotePointer = g_pCurrentWorkspace->RectHitRemotePointer(&rect, GetPenThickness()/2, NULL);

					}
									
				}
				else
				{
					// Draw the line
					::MoveToEx(hDC, rect.left, rect.top, NULL);
					::LineTo(hDC, rect.right, rect.bottom);
				}
			}
			break;


			case rectangle_chosen:
			{

				TRACE_DEBUG(("RECTANGLE %d, %d, %d , %d", rect.left, rect.top, rect.right, rect.bottom ));

				// Draw the rectangle
				::Rectangle(hDC, rect.left, rect.top, rect.right, rect.bottom);
			}
			break;
			
			case ellipse_chosen:
			{
				::Ellipse(hDC, rect.left, rect.top, rect.right, rect.bottom);
			}
			break;
	
			case closedPolyLine_chosen:
			default:
			TRACE_DEBUG(("Unsupported DrawingType", GetDrawingType()));
			break;
		}

		//
		// De-select the brush
		//
		SelectBrush(hDC, hOldBrush);

		// De-select the pen and ROP
		::SetROP2(hDC, iOldROP);
		SelectPen(hDC, hOldPen);
	}

    //
    // Do NOT draw focus if clipboard or printing
    //
	if (WasSelectedLocally() && (hDC == g_pDraw->m_hDCCached))
	{
		DrawRect();
	}

	if (hPen != NULL)
	{
		::DeletePen(hPen);
	}

	if (hBrush != NULL)
	{
		::DeleteBrush(hBrush);
	}

	if(remotePointer)
	{
		remotePointer->Draw();
	}

	//
	// Now for rectangles ellipses and lines, check if we are on top of any remote pointer
	//

	remotePointer = NULL;
	WBPOSITION pos = NULL;
	::InflateRect(&rect, GetPenThickness()/2, GetPenThickness()/2);
	remotePointer = g_pCurrentWorkspace->RectHitRemotePointer(&rect, GetPenThickness()/2, NULL);
	while(remotePointer)
	{
		remotePointer->DeleteSavedBitmap();
		remotePointer->Draw();
		remotePointer = g_pCurrentWorkspace->RectHitRemotePointer(&rect, GetPenThickness()/2, remotePointer->GetMyPosition());
	}
}

void DrawObj::SetPenColor(COLORREF rgb, BOOL isPresent)
{
	ChangedPenColor();
	m_bIsPenColorPresent = isPresent;
	if(!isPresent)
	{
		return;
	}
	
	m_penColor.rgbtRed = GetRValue(rgb);
	m_penColor.rgbtGreen = GetGValue(rgb);
	m_penColor.rgbtBlue = GetBValue(rgb);

}

BOOL DrawObj::GetPenColor(COLORREF * rgb)
{
	if(m_bIsPenColorPresent)
	{
		*rgb = RGB(m_penColor.rgbtRed, m_penColor.rgbtGreen, m_penColor.rgbtBlue);
	}
	return m_bIsPenColorPresent;
}

BOOL DrawObj::GetPenColor(RGBTRIPLE* rgb)
{
	if(m_bIsPenColorPresent)
	{
		*rgb = m_penColor;
	}
	return m_bIsPenColorPresent;
}


void DrawObj::SetFillColor(COLORREF rgb, BOOL isPresent)
{
	ChangedFillColor();
	m_bIsFillColorPresent = isPresent;
	if(!isPresent)
	{
		return;
	}
	
	m_fillColor.rgbtRed = GetRValue(rgb);
	m_fillColor.rgbtGreen = GetGValue(rgb);
	m_fillColor.rgbtBlue = GetBValue(rgb);

}

BOOL DrawObj::GetFillColor(COLORREF* rgb)
{
	if(m_bIsFillColorPresent && rgb !=NULL)
	{
		*rgb = RGB(m_fillColor.rgbtRed, m_fillColor.rgbtGreen, m_fillColor.rgbtBlue);
	}
	return m_bIsFillColorPresent;
}

BOOL DrawObj::GetFillColor(RGBTRIPLE* rgb)
{
	if(m_bIsFillColorPresent && rgb!= NULL)
	{
		*rgb = m_fillColor;
	}
	return m_bIsFillColorPresent;
}


BOOL DrawObj::AddPoint(POINT point)
{
    BOOL bSuccess = TRUE;

    MLZ_EntryOut(ZONE_FUNCTION, "DrawObj::::AddPoint");

	int nPoints = m_points->GetSize();

    // if we've reached the maximum number of points then quit with failure
    if (nPoints >= MAX_FREEHAND_POINTS)
    {
        bSuccess = FALSE;
        TRACE_DEBUG(("Maximum number of points for freehand object reached."));
        return(bSuccess);
    }

    m_points->Add(point);
	nPoints++;

	ChangedPointList();


	//
	// If we hit the 256 limit fake a timer notification and resend the polyline
	//
	if((nPoints & 0xff) == 0)
	{
		g_pDraw->OnTimer(0);
	}
	
	
    return(bSuccess);
}


void DrawObj::AddPointToBounds(int x, int y)
{
    // Create a rectangle containing the point just added (expanded
    // by the width of the pen being used).
    RECT  rect;
	RECT  boundsRect;
	rect.left   = x - 1;
    rect.top    = y - 1;
    rect.right  = x + 1;
    rect.bottom = y + 1;


	GetBoundsRect(&boundsRect);
	::UnionRect(&boundsRect, &boundsRect, &rect);
    SetBoundsRect(&boundsRect);
}


void GetDrawingDestinationAddress(DrawingDestinationAddress *destinationAddress, PUINT workspaceHandle, PUINT planeID)
{

	//
	// Get the destination address
	//
	switch(destinationAddress->choice)
	{

		case(DrawingDestinationAddress_softCopyAnnotationPlane_chosen):
		{
			*workspaceHandle = (destinationAddress->u.softCopyAnnotationPlane.workspaceHandle);
			*planeID = (destinationAddress->u.softCopyAnnotationPlane.plane);
			break;
		}
//		case(DrawingDestinationAddress_nonStandardDestination_chosen):
//		{
//			break;
//		}

		default:
	    ERROR_OUT(("Invalid destinationAddress"));
		break;
	}
}


void DrawObj::SetUIToolType(void)
{
	UINT drawingType = GetDrawingType();
	BOOL filled	= HasFillColor();

	UINT rop = R2_COPYPEN;

    switch (drawingType)
    {
    	case openPolyLine_chosen:
    	{
			if(m_points->GetSize() > 1)
			{
				if(GetHighlight())
				{
					m_ToolType = TOOLTYPE_HIGHLIGHT;
					 rop = R2_MASKPEN;

				}
				else
				{
					m_ToolType = TOOLTYPE_PEN;	
				}

			}
			else
			{
				m_ToolType = TOOLTYPE_LINE;	
			}
    	}
    	break;
    	
		case rectangle_chosen:
		{
			if(filled)
			{
				m_ToolType = TOOLTYPE_FILLEDBOX;
			}
			else
			{
				m_ToolType = TOOLTYPE_BOX;
			}
		}
		break;

		case ellipse_chosen:
		{
			if(filled)
			{
				m_ToolType = TOOLTYPE_FILLEDELLIPSE;
			}
			else
			{
				m_ToolType = TOOLTYPE_ELLIPSE;
			}
		}
		break;
	}	

	SetROP(rop);
}



//
// UI Edited the Drawing Object
//
void	DrawObj::OnObjectEdit(void)
{
	g_bContentsChanged = TRUE;

	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = drawingEditPDU_chosen;

		CreateDrawingEditPDU(&sipdu->u.drawingEditPDU);

		TRACE_DEBUG(("Sending Drawing Edit >> Drawing handle  = %d", sipdu->u.drawingEditPDU.drawingHandle ));

		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
			ResetAttrib();
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}
}

//
// UI Deleted the Drawing Object
//
void	DrawObj::OnObjectDelete(void)
{
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = drawingDeletePDU_chosen;
		CreateDrawingDeletePDU(&sipdu->u.drawingDeletePDU);
		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}

}

//
// Get the encoded buffer for Drawing Create PDU
//
void	DrawObj::GetEncodedCreatePDU(ASN1_BUF *pBuf)
{
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = drawingCreatePDU_chosen;
		CreateDrawingCreatePDU(&sipdu->u.drawingCreatePDU);

		ASN1_BUF encodedPDU;
		g_pCoder->Encode(sipdu, pBuf);

		SIPDUCleanUp(sipdu);
	}
	else
	{
		TRACE_MSG(("Failed to create penMenu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);

	}
}


//
// UI Created a new Drawing Object
//
void DrawObj::SendNewObjectToT126Apps(void)
{

	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = drawingCreatePDU_chosen;
		CreateDrawingCreatePDU(&sipdu->u.drawingCreatePDU);

		TRACE_DEBUG(("Sending Drawing >> Drawing handle  = %d", sipdu->u.drawingCreatePDU.drawingHandle ));
		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\gccmsg.h ===
#ifndef GCCMSG_H
#define GCCMSG_H
#include <igccapp.h>

GCCError CreateSap(void);
GCCError DeleteSap(void);

void CALLBACK DispatchGCCNotification( GCCAppSapMsg *pMsg );
#endif //GCCMSG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\draw.cpp ===
//
// DRAW.CPP
// Main Drawing Window
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"
#include "nmwbobj.h"

static const TCHAR szDrawClassName[] = "T126WB_DRAW";

//
//
// Function:    Constructor
//
// Purpose:     Initialize the drawing area object
//
//
WbDrawingArea::WbDrawingArea(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::WbDrawingArea");

    g_pDraw = this;

    m_hwnd = NULL;

    m_hDCWindow = NULL;
    m_hDCCached = NULL;

    m_originOffset.cx = 0;
    m_originOffset.cy = 0;

    m_posScroll.x     = 0;
    m_posScroll.y     = 0;

    // Show that the drawing area is not zoomed
    m_iZoomFactor = 1;
    m_iZoomOption = 1;

    // Show that the left mouse button is up
    m_bLButtonDown = FALSE;
    m_bIgnoreNextLClick = FALSE;
    m_bBusy = FALSE;
    m_bLocked = FALSE;
    m_HourGlass = FALSE;
    m_bSync = TRUE;

    // Indicate that the cached zoom scroll position is invalid
    m_zoomRestoreScroll = FALSE;

    // Show that we are not currently editing text
    m_bGotCaret = FALSE;
    m_bTextEditorActive = FALSE;
	m_pTextEditor = NULL;


    // Show that no graphic object is in progress
    m_pGraphicTracker = NULL;

    // Show that the marker is not present.
    m_bMarkerPresent = FALSE;
    m_bNewMarkedGraphic = FALSE;
    m_pSelectedGraphic = NULL;
    m_bTrackingSelectRect = FALSE;

    // Show that no area is currently marked
    ::SetRectEmpty(&m_rcMarkedArea);

    // Show we haven't got a tool yet
    m_pToolCur = NULL;

    // Show that we dont have a page attached yet
    g_pCurrentWorkspace = NULL;
	g_pConferenceWorkspace = NULL;

	DBG_SAVE_FILE_LINE
	m_pMarker = new DrawObj(rectangle_chosen, TOOLTYPE_SELECT);
    m_pMarker->SetPenColor(RGB(0,0,0), TRUE);
    m_pMarker->SetFillColor(RGB(255,255,255), FALSE);
    m_pMarker->SetLineStyle(PS_DOT);
    m_pMarker->SetPenThickness(1);

    // Set up a checked pattern to draw the marker rect with
    WORD    bits[] = {204, 204, 51, 51, 204, 204, 51, 51};

    // Create the brush to be used to draw the marker rectangle
    HBITMAP hBmpMarker = ::CreateBitmap(8, 8, 1, 1, bits);
    m_hMarkerBrush = ::CreatePatternBrush(hBmpMarker);
    ::DeleteBitmap(hBmpMarker);

	RECT rect;
    ::SetRectEmpty(&rect);
    m_pMarker->SetRect(&rect);
    m_pMarker->SetBoundsRect(&rect);




}


//
//
// Function:    Destructor
//
// Purpose:     Close down the drawing area
//
//
WbDrawingArea::~WbDrawingArea(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::~WbDrawingArea");

    if (m_pTextEditor != NULL)
    {
	    m_pTextEditor->AbortEditGently();
    }

    if (m_pMarker != NULL)
    {
		delete m_pMarker;
		m_pMarker = NULL;
	}


    if (m_hMarkerBrush != NULL)
    {
        DeleteBrush(m_hMarkerBrush);
        m_hMarkerBrush = NULL;
    }


    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    ::UnregisterClass(szDrawClassName, g_hInstance);

	g_pDraw = NULL;

}

//
// WbDrawingArea::Create()
//
BOOL WbDrawingArea::Create(HWND hwndParent, LPCRECT lprect)
{
    WNDCLASSEX  wc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Create");

    // Get our cursor
    m_hCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( PENFREEHANDCURSOR));

    //
    // Register the window class
    //
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_OWNDC;
    wc.lpfnWndProc      = DrawWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = m_hCursor;
    wc.hbrBackground    = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName    = szDrawClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbDraw::Create register class failed"));
        return(FALSE);
    }

    //
    // Create our window
    //
    ASSERT(m_hwnd == NULL);

    if (!::CreateWindowEx(WS_EX_CLIENTEDGE, szDrawClassName, NULL,
        WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_BORDER |
        WS_CLIPCHILDREN,
        lprect->left, lprect->top, lprect->right - lprect->left,
        lprect->bottom - lprect->top,
        hwndParent, NULL, g_hInstance, this))
    {
        ERROR_OUT(("Error creating drawing area window"));
        return(FALSE);
    }

    ASSERT(m_hwnd != NULL);

    //
    // Initialize remaining data members
    //
    ASSERT(!m_bBusy);
    ASSERT(!(m_bLocked && g_pNMWBOBJ->m_LockerID != g_MyMemberID));
    ASSERT(!m_HourGlass);

    // Start and end points of the last drawing operation
    m_ptStart.x = m_originOffset.cx;
    m_ptStart.y = m_originOffset.cy;
    m_ptEnd = m_ptStart;

    // Get the zoom factor to be used
    m_iZoomOption = DRAW_ZOOMFACTOR;

    m_hDCWindow = ::GetDC(m_hwnd);
    m_hDCCached = m_hDCWindow;

    PrimeDC(m_hDCCached);
    ::SetWindowOrgEx(m_hDCCached, m_originOffset.cx, m_originOffset.cy, NULL);
    return(TRUE);
}



//
// DrawWndProc()
// Message handler for the drawing area
//
LRESULT CALLBACK DrawWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbDrawingArea * pDraw = (WbDrawingArea *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pDraw = (WbDrawingArea *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pDraw);

            pDraw->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pDraw);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pDraw);

            //
            // When you call GetDC(), the HDC you get back is only valid
            // as long as the HWND it refers to is.  So we must release
            // it here.
            //
            pDraw->ShutDownDC();
            pDraw->m_hwnd = NULL;
            break;

        case WM_PAINT:
            ASSERT(pDraw);
            pDraw->OnPaint();
            break;

        case WM_MOUSEMOVE:
            ASSERT(pDraw);
            pDraw->OnMouseMove((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_LBUTTONDOWN:
            ASSERT(pDraw);
			pDraw->DeleteSelection();
            pDraw->OnLButtonDown((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_LBUTTONUP:
            ASSERT(pDraw);
            pDraw->OnLButtonUp((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_CONTEXTMENU:
            ASSERT(pDraw);
            pDraw->OnContextMenu((short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_SIZE:
            ASSERT(pDraw);
            pDraw->OnSize((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_HSCROLL:
            ASSERT(pDraw);
            pDraw->OnHScroll(GET_WM_HSCROLL_CODE(wParam, lParam),
                GET_WM_HSCROLL_POS(wParam, lParam));
            break;

		case WM_MOUSEWHEEL:
			ASSERT(pDraw);
			lParam = 0;
			if((short) HIWORD(wParam) > 0)
			{
				wParam = SB_LINEUP;
			}
			else
			{
				wParam = SB_LINEDOWN;
	   		}
			pDraw->OnVScroll(GET_WM_VSCROLL_CODE(wParam, lParam),
				GET_WM_VSCROLL_POS(wParam, lParam));
				
			wParam = SB_ENDSCROLL;
           	//
           	// Just work like a vertical scroll
           	//
		
        case WM_VSCROLL:
            ASSERT(pDraw);
            pDraw->OnVScroll(GET_WM_VSCROLL_CODE(wParam, lParam),
                GET_WM_VSCROLL_POS(wParam, lParam));
            break;

        case WM_CTLCOLOREDIT:
            ASSERT(pDraw);
            lResult = pDraw->OnEditColor((HDC)wParam);
            break;

        case WM_SETFOCUS:
            ASSERT(pDraw);
            pDraw->OnSetFocus();
            break;

        case WM_ACTIVATE:
            ASSERT(pDraw);
            pDraw->OnActivate(GET_WM_ACTIVATE_STATE(wParam, lParam));
            break;

        case WM_SETCURSOR:
            ASSERT(pDraw);
            lResult = pDraw->OnCursor((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_CANCELMODE:
            ASSERT(pDraw);
            pDraw->OnCancelMode();
            break;

        case WM_TIMER:
            ASSERT(pDraw);
            pDraw->OnTimer((UINT)wParam);
            break;


        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}


//
//
// Function:    RealizePalette
//
// Purpose:     Realize the drawing area palette
//
//
void WbDrawingArea::RealizePalette( BOOL bBackground )
{
    UINT entriesChanged;
    HDC hdc = m_hDCCached;

    if (g_pCurrentWorkspace != NULL)
    {
        HPALETTE    hPalette = PG_GetPalette();
        if (hPalette != NULL)
        {
            // get our 2cents in
            m_hOldPalette = ::SelectPalette(hdc, hPalette, bBackground);
            entriesChanged = ::RealizePalette(hdc);

            // if mapping changes go repaint
            if (entriesChanged > 0)
                ::InvalidateRect(m_hwnd, NULL, TRUE);
        }
    }
}


LRESULT WbDrawingArea::OnEditColor(HDC hdc)
{
    HPALETTE    hPalette = PG_GetPalette();

    if (hPalette != NULL)
    {
        ::SelectPalette(hdc, hPalette, FALSE);
        ::RealizePalette(hdc);
    }

	COLORREF rgb;
	m_pTextEditor->GetPenColor(&rgb);
	
    ::SetTextColor(hdc, SET_PALETTERGB( rgb) );

    return((LRESULT)::GetSysColorBrush(COLOR_WINDOW));
}

//
//
// Function:	OnPaint
//
// Purpose:	 Paint the window. This routine is called whenever Windows
//			  issues a WM_PAINT message for the Whiteboard window.
//
//
void WbDrawingArea::OnPaint(void)
{
	RECT		rcUpdate;
	RECT		rcTmp;
	RECT		rcBounds;
	HDC		 hSavedDC;
	HPEN		hSavedPen;
	HBRUSH	  hSavedBrush;
	HPALETTE	hSavedPalette;
	HPALETTE	hPalette;
	HFONT	   hSavedFont;

	MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnPaint");

	// Get the update rectangle
	::GetUpdateRect(m_hwnd, &rcUpdate, FALSE);

	if (Zoomed())
	{
		::InflateRect(&rcUpdate, 1, 1);
		InvalidateSurfaceRect(&rcUpdate, TRUE);
	}

	// Start painting
	PAINTSTRUCT	 ps;

	::BeginPaint(m_hwnd, &ps);

	hSavedDC	  =   m_hDCCached;
	hSavedFont	=   m_hOldFont;
	hSavedPen	 =   m_hOldPen;
	hSavedBrush   =   m_hOldBrush;
	hSavedPalette =   m_hOldPalette;

	TRACE_MSG(("Flipping cache to paint DC"));
	m_hDCCached   =   ps.hdc;
	PrimeDC(m_hDCCached);

	// Only draw anything if we have a valid page attached
	if (g_pCurrentWorkspace != NULL )
	{
		// set palette
		hPalette = PG_GetPalette();
		if (hPalette != NULL)
		{
			m_hOldPalette = ::SelectPalette(m_hDCCached, hPalette, FALSE );
			::RealizePalette(m_hDCCached);
		}


		T126Obj * pObj = NULL;
		WBPOSITION pos;

		pObj = PG_First(g_pCurrentWorkspace, &rcUpdate, FALSE);
		if(pObj)
		{
			pos = pObj->GetMyPosition();
			if(pos)
			{
				g_pCurrentWorkspace->GetNextObject(pos);
			}
		}
	
		while (pObj != NULL)
		{
			pObj->Draw(NULL, TRUE);
	
			// Get the next one
			if(pos)
			{
				pObj = PG_Next(g_pCurrentWorkspace, pos, &rcUpdate, FALSE);
			}
			else
			{
				break;
			}
		}
		
		if (hPalette != NULL)
		{
			::SelectPalette(m_hDCCached, m_hOldPalette, TRUE);
		}

		// fixes painting problems for bug 2185
		if( TextEditActive() )
		{
			RedrawTextEditbox();
		}

		//
		// Draw the tracking graphic
		//
		if ((m_pGraphicTracker != NULL) && !EqualPoint(m_ptStart, m_ptEnd))
		{
			TRACE_MSG(("Drawing the tracking graphic"));
			m_pGraphicTracker->Draw(NULL, FALSE);
		}
	
	}

	//
	// Restore the DC to its original state
	//
	UnPrimeDC(m_hDCCached);

	m_hOldFont	  = hSavedFont;
	m_hOldPen	   = hSavedPen;
	m_hOldBrush	 = hSavedBrush;
	m_hOldPalette   = hSavedPalette;
	m_hDCCached	 = hSavedDC;

	// Finish painting
	::EndPaint(m_hwnd, &ps);
}


//
// Selects all graphic objs contained in rectSelect. If rectSelect is
// NULL then ALL objs are selected
//
void WbDrawingArea::SelectMarkerFromRect(LPCRECT lprcSelect)
{
    T126Obj* pGraphic;
    RECT    rc;
    ::SetRectEmpty(&rc);

    m_HourGlass = TRUE;
    SetCursorForState();

	WBPOSITION pos;
		
	pGraphic = NULL;
    pGraphic = PG_First(g_pCurrentWorkspace, lprcSelect, TRUE);
	if(pGraphic)
	{
		pos = pGraphic->GetMyPosition();
		if(pos)
		{
			g_pCurrentWorkspace->GetNextObject(pos);
		}
	}


    while (pGraphic != NULL)
    {
		if(pGraphic->GraphicTool() == TOOLTYPE_REMOTEPOINTER &&	// if it is a pointer and it is not local
			(!pGraphic->IAmTheOwner() ||						// we can't select it. Or this was a select all
			(pGraphic->IAmTheOwner() && lprcSelect == NULL)))
		{
			; // don't select it
		}
		else
		{
	        SelectGraphic(pGraphic, TRUE, TRUE);

			//
			// Calculate de size of the total selection
			//
			RECT selctRect;
			pGraphic->GetBoundsRect(&selctRect);
			::UnionRect(&rc,&selctRect,&rc);
		}

        // Get the next one
        pGraphic = PG_Next(g_pCurrentWorkspace, pos, lprcSelect, TRUE );
    }

	m_pMarker->SetRect(&rc);

    m_HourGlass = FALSE;
    SetCursorForState();

    g_pMain->OnUpdateAttributes();

}

//
//
// Function:    OnTimer
//
// Purpose:     Process a timer event. These are used to update freehand and
//              text objects while they are being drawn/edited and to
//              update the remote pointer position when the mouse stops.
//
//
void WbDrawingArea::OnTimer(UINT idTimer)
{
    TRACE_TIMER(("WbDrawingArea::OnTimer"));

    // We are only interested if the user is drawing something or editing
    if (m_bLButtonDown == TRUE)
    {


		if(idTimer == TIMER_REMOTE_POINTER_UPDATE)
		{
			ASSERT(g_pMain->m_pLocalRemotePointer);
			if(g_pMain->m_pLocalRemotePointer)
			{
				if(g_pMain->m_pLocalRemotePointer->HasAnchorPointChanged())
				{
					g_pMain->m_pLocalRemotePointer->OnObjectEdit();
					g_pMain->m_pLocalRemotePointer->ResetAttrib();
				}
			}
			return;
		}


        // If the user is dragging an object or drawing a freehand line
        if (m_pGraphicTracker != NULL)
        {
        	if(m_pGraphicTracker->HasAnchorPointChanged() || m_pGraphicTracker->HasPointListChanged())
        	{
				//
				// If we are not added to the workspace
				//
				if(!m_pGraphicTracker->GetMyWorkspace())
				{
					m_pGraphicTracker->AddToWorkspace();
				}
				else
				{
					m_pGraphicTracker->OnObjectEdit();
				}
	        }
        }
    }
}



//
//
// Function:    OnSize
//
// Purpose:     The window has been resized.
//
//
void WbDrawingArea::OnSize(UINT nType, int cx, int cy)
{
    // Only process this message if the window is not minimized
    if (   (nType == SIZEFULLSCREEN)
        || (nType == SIZENORMAL))
    {
        if (TextEditActive())
        {
            TextEditParentResize();
        }

        // Set the new scroll range (based on the new client area)
        SetScrollRange(cx, cy);

        // Ensure that the scroll position lies in the new scroll range
        ValidateScrollPos();

        // make page move if needed
        ScrollWorkspace();

        // Update the scroll bars
        ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);
        ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);
    }
}


//
//
// Function:    SetScrollRange
//
// Purpose:     Set the current scroll range. The range is based on the
//              work surface size and the size of the client area.
//
//
void WbDrawingArea::SetScrollRange(int cx, int cy)
{
    SCROLLINFO scinfo;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SetScrollRange");

    // If we are in zoom mode, then allow for the magnification
    ASSERT(m_iZoomFactor != 0);
    cx /= m_iZoomFactor;
    cy /= m_iZoomFactor;

    ZeroMemory( &scinfo,  sizeof (SCROLLINFO) );
    scinfo.cbSize = sizeof (SCROLLINFO);
    scinfo.fMask = SIF_PAGE    | SIF_RANGE|
                    SIF_DISABLENOSCROLL;

    // Set the horizontal scroll range and proportional thumb size
    scinfo.nMin = 0;
    scinfo.nMax = DRAW_WIDTH - 1;
    scinfo.nPage = cx;
    ::SetScrollInfo(m_hwnd, SB_HORZ, &scinfo, FALSE);

    // Set the vertical scroll range and proportional thumb size
    scinfo.nMin = 0;
    scinfo.nMax = DRAW_HEIGHT - 1;
    scinfo.nPage = cy;
    ::SetScrollInfo(m_hwnd, SB_VERT, &scinfo, FALSE);
}

//
//
// Function:    ValidateScrollPos
//
// Purpose:     Ensure that the current scroll position is within the bounds
//              of the current scroll range. The scroll range is set to
//              ensure that the window on the worksurface never extends
//              beyond the surface boundaries.
//
//
void WbDrawingArea::ValidateScrollPos()
{
    int iMax;
    SCROLLINFO scinfo;

    // Validate the horixontal scroll position using proportional settings
    scinfo.cbSize = sizeof(scinfo);
    scinfo.fMask = SIF_ALL;
    ::GetScrollInfo(m_hwnd, SB_HORZ, &scinfo);
    iMax = scinfo.nMax - scinfo.nPage;
    m_posScroll.x = max(m_posScroll.x, 0);
    m_posScroll.x = min(m_posScroll.x, iMax);

    // Validate the vertical scroll position using proportional settings
    scinfo.cbSize = sizeof(scinfo);
    scinfo.fMask = SIF_ALL;
    ::GetScrollInfo(m_hwnd, SB_VERT, &scinfo);
    iMax = scinfo.nMax - scinfo.nPage;
    m_posScroll.y = max(m_posScroll.y, 0);
    m_posScroll.y = min(m_posScroll.y, iMax);
}

//
//
// Function:    ScrollWorkspace
//
// Purpose:     Scroll the workspace to the position set in the member
//              variable m_posScroll.
//
//
void WbDrawingArea::ScrollWorkspace(void)
{

	RECT rc;
	
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::ScrollWorkspace");


    // Do the scroll
    DoScrollWorkspace();


	if(Zoomed())
	{
    	// Tell the parent that the scroll position has changed
	    HWND    hwndParent;

	    hwndParent = ::GetParent(m_hwnd);
	    if (hwndParent != NULL)
	    {
	        ::PostMessage(hwndParent, WM_USER_PRIVATE_PARENTNOTIFY, WM_VSCROLL, 0L);
	    }
	}
}

//
//
// Function:    DoScrollWorkspace
//
// Purpose:     Scroll the workspace to the position set in the member
//              variable m_posScroll.
//
//
void WbDrawingArea::DoScrollWorkspace()
{
    // Validate the scroll position
    ValidateScrollPos();

    // Set the scroll box position
    ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);
    ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);

    // Only update the screen if the scroll position has changed
    if ( (m_originOffset.cy != m_posScroll.y)
        || (m_originOffset.cx != m_posScroll.x) )
    {

		// Calculate the amount to scroll
        INT iVScrollAmount = m_originOffset.cy - m_posScroll.y;
        INT iHScrollAmount = m_originOffset.cx - m_posScroll.x;

        // Save the new position (for UpdateWindow)
        m_originOffset.cx = m_posScroll.x;
        m_originOffset.cy = m_posScroll.y;

        ::SetWindowOrgEx(m_hDCCached, m_originOffset.cx, m_originOffset.cy, NULL);

        // Scroll and redraw the newly invalidated portion of the window
        ::ScrollWindow(m_hwnd, iHScrollAmount, iVScrollAmount, NULL, NULL);
        ::UpdateWindow(m_hwnd);
	}
}

//
//
// Function:    GotoPosition
//
// Purpose:     Move the top-left corner of the workspace to the specified
//              position in the workspace.
//
//
void WbDrawingArea::GotoPosition(int x, int y)
{
    // Set the new scroll position
    m_posScroll.x = x;
    m_posScroll.y = y;

    // Scroll to the new position
    DoScrollWorkspace();

    // Invalidate the zoom scroll cache if we scroll when unzoomed.
    if (!Zoomed())
    {
        m_zoomRestoreScroll = FALSE;
    }
}

//
//
// Function:    OnVScroll
//
// Purpose:     Process a WM_VSCROLL messages.
//
//
void WbDrawingArea::OnVScroll(UINT nSBCode, UINT nPos)
{
    RECT    rcClient;

    // Get the current client rectangle HEIGHT
    ::GetClientRect(m_hwnd, &rcClient);
    ASSERT(rcClient.top == 0);
    rcClient.bottom -= rcClient.top;

    // Act on the scroll code
    switch(nSBCode)
    {
        // Scroll to bottom
        case SB_BOTTOM:
            m_posScroll.y = DRAW_HEIGHT - rcClient.bottom;
            break;

        // Scroll down a line
        case SB_LINEDOWN:
            m_posScroll.y += DRAW_LINEVSCROLL;
            break;

        // Scroll up a line
        case SB_LINEUP:
            m_posScroll.y -= DRAW_LINEVSCROLL;
            break;

        // Scroll down a page
        case SB_PAGEDOWN:
            m_posScroll.y += rcClient.bottom / m_iZoomFactor;
            break;

        // Scroll up a page
        case SB_PAGEUP:
            m_posScroll.y -= rcClient.bottom / m_iZoomFactor;
            break;

        // Scroll to the top
        case SB_TOP:
            m_posScroll.y = 0;
            break;

        // Track the scroll box
        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            m_posScroll.y = nPos; // don't round
            break;

        default:
        break;
    }

    // Validate the scroll position
    ValidateScrollPos();
    ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);

    // If this message is informing us of the end of scrolling,
    //   update the window
    if (nSBCode == SB_ENDSCROLL)
    {
        // Scroll the window
        ScrollWorkspace();
    }

    // Invalidate the zoom scroll cache if we scroll when unzoomed.
    if (!Zoomed())
    {
        m_zoomRestoreScroll = FALSE;
    }
}

//
//
// Function:    OnHScroll
//
// Purpose:     Process a WM_HSCROLL messages.
//
//
void WbDrawingArea::OnHScroll(UINT nSBCode, UINT nPos)
{
    RECT    rcClient;

    // Get the current client rectangle WIDTH
    ::GetClientRect(m_hwnd, &rcClient);
    ASSERT(rcClient.left == 0);
    rcClient.right -= rcClient.left;

    switch(nSBCode)
    {
        // Scroll to the far right
        case SB_BOTTOM:
            m_posScroll.x = DRAW_WIDTH - rcClient.right;
            break;

        // Scroll right a line
        case SB_LINEDOWN:
            m_posScroll.x += DRAW_LINEHSCROLL;
            break;

        // Scroll left a line
        case SB_LINEUP:
            m_posScroll.x -= DRAW_LINEHSCROLL;
            break;

        // Scroll right a page
        case SB_PAGEDOWN:
            m_posScroll.x += rcClient.right / m_iZoomFactor;
            break;

        // Scroll left a page
        case SB_PAGEUP:
            m_posScroll.x -= rcClient.right / m_iZoomFactor;
            break;

        // Scroll to the far left
        case SB_TOP:
            m_posScroll.x = 0;
            break;

        // Track the scroll box
        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            m_posScroll.x = nPos; // don't round
            break;

        default:
            break;
    }

    // Validate the scroll position
    ValidateScrollPos();
    ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);

    // If this message is informing us of the end of scrolling,
    //   update the window
    if (nSBCode == SB_ENDSCROLL)
    {
        // Scroll the window
        ScrollWorkspace();
    }

    // Invalidate the zoom scroll cache if we scroll when unzoomed.
    if (!Zoomed())
    {
        m_zoomRestoreScroll = FALSE;
    }
}


//
//
// Function:    AutoScroll
//
// Purpose:     Auto-scroll the window to bring the position passed as
//              parameter into view.
//
//
BOOL WbDrawingArea::AutoScroll
(
    int     xSurface,
    int     ySurface,
    BOOL    bMoveCursor,
    int     xCaret,
    int     yCaret
)
{
    int nXPSlop, nYPSlop;
    int nXMSlop, nYMSlop;
    int nDeltaHScroll, nDeltaVScroll;
    BOOL bDoScroll = FALSE;

    nXPSlop = 0;
    nYPSlop = 0;
    nXMSlop = 0;
    nYMSlop = 0;

    if( TextEditActive() )
    {

        POINT   ptDirTest;

        ptDirTest.x = xSurface - xCaret;
        ptDirTest.y = ySurface - yCaret;

        // set up for text editbox
        if( ptDirTest.x > 0 )
            nXPSlop = m_pTextEditor->m_textMetrics.tmMaxCharWidth;
        else
        if( ptDirTest.x < 0 )
            nXMSlop = -m_pTextEditor->m_textMetrics.tmMaxCharWidth;

        if( ptDirTest.y > 0 )
            nYPSlop = m_pTextEditor->m_textMetrics.tmHeight;
        else
        if( ptDirTest.y < 0 )
            nYMSlop = -m_pTextEditor->m_textMetrics.tmHeight;

        nDeltaHScroll = m_pTextEditor->m_textMetrics.tmMaxCharWidth;
        nDeltaVScroll = m_pTextEditor->m_textMetrics.tmHeight;
    }
    else
    {
        // set up for all other objects
        nDeltaHScroll = DRAW_LINEHSCROLL;
        nDeltaVScroll = DRAW_LINEVSCROLL;
    }

    // Get the current visible surface rectangle
    RECT  visibleRect;
    GetVisibleRect(&visibleRect);

    // Check for pos + slop being outside visible area
    if( (xSurface + nXPSlop) >= visibleRect.right )
    {
        bDoScroll = TRUE;
        m_posScroll.x +=
            (((xSurface + nXPSlop) - visibleRect.right) + nDeltaHScroll);
    }

    if( (xSurface + nXMSlop) <= visibleRect.left )
    {
        bDoScroll = TRUE;
        m_posScroll.x -=
            ((visibleRect.left - (xSurface + nXMSlop)) + nDeltaHScroll);
    }

    if( (ySurface + nYPSlop) >= visibleRect.bottom)
    {
        bDoScroll = TRUE;
        m_posScroll.y +=
            (((ySurface + nYPSlop) - visibleRect.bottom) + nDeltaVScroll);
    }

    if( (ySurface + nYMSlop) <= visibleRect.top)
    {
        bDoScroll = TRUE;
        m_posScroll.y -=
            ((visibleRect.top - (ySurface + nYMSlop)) + nDeltaVScroll);
    }

    if( !bDoScroll )
        return( FALSE );

    // Indicate that scrolling has completed (in both directions)
    ScrollWorkspace();

    // Update the mouse position (if required)
    if (bMoveCursor)
    {
        POINT   screenPos;

        screenPos.x = xSurface;
        screenPos.y = ySurface;

        SurfaceToClient(&screenPos);
        ::ClientToScreen(m_hwnd, &screenPos);
        ::SetCursorPos(screenPos.x, screenPos.y);
    }

    return( TRUE );
}

//
//
// Function:    OnCursor
//
// Purpose:     Process a WM_SETCURSOR messages.
//
//
LRESULT WbDrawingArea::OnCursor(HWND hwnd, UINT uiHit, UINT uMsg)
{
    BOOL bResult = FALSE;

    // Check that this message is for the main window
    if (hwnd == m_hwnd)
    {
        // If the cursor is now in the client area, set the cursor
        if (uiHit == HTCLIENT)
        {
            bResult = SetCursorForState();
        }
        else
        {
            // Restore the cursor to the standard arrow. Set m_hCursor to NULL
            // to indicate that we have not set a special cursor.
            m_hCursor = NULL;
           ::SetCursor(::LoadCursor(NULL, IDC_ARROW));
            bResult = TRUE;
        }
    }

    // Return result indicating whether we processed the message or not
    return bResult;
}

//
//
// Function:    SetCursorForState
//
// Purpose:     Set the cursor for the current state
//
//
BOOL WbDrawingArea::SetCursorForState(void)
{
    BOOL    bResult = FALSE;

    m_hCursor = NULL;

    // If the drawing area is locked, use the "locked" cursor
    if (m_HourGlass)
    {
        m_hCursor = ::LoadCursor( NULL, IDC_WAIT );
    }
    else if (m_bLocked && g_pNMWBOBJ->m_LockerID != g_MyMemberID)
    {
        // Return the cursor for the tool
        m_hCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( LOCKCURSOR ));
    }
    else if (m_pToolCur != NULL)
    {
        // Get the cursor for the tool currently in use
        m_hCursor = m_pToolCur->GetCursorForTool();
    }

    if (m_hCursor != NULL)
    {
        ::SetCursor(m_hCursor);
        bResult = TRUE;
    }

    // Return result indicating whether we set the cursor or not
    return bResult;
}

//
//
// Function:    Lock
//
// Purpose:     Lock the drawing area, preventing further updates
//
//
void WbDrawingArea::Lock(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Lock");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Stop any drawing we are doing.
    CancelDrawingMode();

    // Deselect any selected graphic
    ClearSelection();

    // Show that we are now locked
    m_bLocked = TRUE;
    TRACE_MSG(("Drawing area is now locked"));

    // Set the cursor for the drawing mode, but only if we should be drawing
    // a special cursor (if m_hCursor != the current cursor, then the cursor
    // is out of the client area).
    if (::GetCursor() == m_hCursor)
    {
        SetCursorForState();
    }
}

//
//
// Function:    Unlock
//
// Purpose:     Unlock the drawing area, preventing further updates
//
//
void WbDrawingArea::Unlock(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Unlock");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Show that we are now unlocked
    m_bLocked = FALSE;
    TRACE_MSG(("Drawing area is now UNlocked"));

    // Set the cursor for the drawing mode, but only if we should be drawing
    // a special cursor (if m_hCursor != the current cursor, then the cursor
    // is out of the client area).
    if (::GetCursor() == m_hCursor)
    {
        SetCursorForState();
    }
}

//
//
// Function:    PageCleared
//
// Purpose:     The page has been cleared
//
//
void WbDrawingArea::PageCleared(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PageCleared");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Discard any text being edited
    if (m_bTextEditorActive)
    {
        if (m_bLocked && g_pNMWBOBJ->m_LockerID != g_MyMemberID)
        {
            DeactivateTextEditor();
        }
        else
        {
            EndTextEntry(FALSE);
        }
    }

    // Remove the copy of the marked graphic and the marker
    ClearSelection();

    // Invalidate the whole window
    ::InvalidateRect(m_hwnd, NULL, TRUE);
}

//
//
// Function:    InvalidateSurfaceRect
//
// Purpose:     Invalidate the window rectangle corresponding to the given
//              drawing surface rectangle.
//
//
void WbDrawingArea::InvalidateSurfaceRect(LPCRECT lprc, BOOL bErase)
{
    RECT    rc;

    // Convert the surface co-ordinates to client window and invalidate
    // the rectangle.
    rc = *lprc;
    SurfaceToClient(&rc);
    ::InvalidateRect(m_hwnd, &rc, bErase);
}


//
//
// Function:    PrimeFont
//
// Purpose:     Insert the supplied font into our DC and return the
//              text metrics
//
//
void WbDrawingArea::PrimeFont(HDC hDC, HFONT hFont, TEXTMETRIC* pTextMetrics)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PrimeFont");

    //
    // temporarily unzoom to get the font that we want
    //
    if (Zoomed())
    {
        ::ScaleViewportExtEx(m_hDCCached, 1, m_iZoomFactor, 1, m_iZoomFactor, NULL);
    }

    HFONT hOldFont = SelectFont(hDC, hFont);
    if (hOldFont == NULL)
    {
        WARNING_OUT(("Failed to select font into DC"));
    }

    if (pTextMetrics != NULL)
    {
        ::GetTextMetrics(hDC, pTextMetrics);
    }

    //
    // restore the zoom state
    //
    if (Zoomed())
    {
        ::ScaleViewportExtEx(m_hDCCached, m_iZoomFactor, 1, m_iZoomFactor, 1, NULL);
    }
}

//
//
// Function:    UnPrimeFont
//
// Purpose:     Remove the specified font from the DC and clear cache
//              variable
//
//
void WbDrawingArea::UnPrimeFont(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::UnPrimeFont");

    if (hDC != NULL)
    {
        SelectFont(hDC, ::GetStockObject(SYSTEM_FONT));
    }
}

//
//
// Function:    PrimeDC
//
// Purpose:     Set up a DC for drawing
//
//
void WbDrawingArea::PrimeDC(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PrimeDC");

    ::SetMapMode(hDC, MM_ANISOTROPIC);

    ::SetBkMode(hDC, TRANSPARENT);

    ::SetTextAlign(hDC, TA_LEFT | TA_TOP);
}

//
//
// Function:    UnPrimeDC
//
// Purpose:     Reset the DC to default state
//
//
void WbDrawingArea::UnPrimeDC(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::UnPrimeDC");

    SelectPen(hDC, (HPEN)::GetStockObject(BLACK_PEN));
    SelectBrush(hDC, (HBRUSH)::GetStockObject(BLACK_BRUSH));

    UnPrimeFont(hDC);
}


//
// WbDrawingArea::OnContextMenu()
//
void WbDrawingArea::OnContextMenu(int xScreen, int yScreen)
{
    POINT   pt;
    RECT    rc;

    pt.x = xScreen;
    pt.y = yScreen;
    ::ScreenToClient(m_hwnd, &pt);

    ::GetClientRect(m_hwnd, &rc);
    if (::PtInRect(&rc, pt))
    {
        // Complete drawing action, if any
        OnLButtonUp(0, pt.x, pt.y);

        // Ask main window to put up context menu
        g_pMain->PopupContextMenu(pt.x, pt.y);
    }
}


//
// WbDrawingArea::OnLButtonDown()
//
void WbDrawingArea::OnLButtonDown(UINT flags, int x, int y)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnLButtonDown");

    if( m_bIgnoreNextLClick )
    {
        TRACE_MSG( ("Ignoring WM_LBUTTONDOWN") );
        return;
    }

    // Set the focus to this window. This is done to ensure that we trap
    // the text edit keys and the delete key when they are used.
    ::SetFocus(m_hwnd);

    // Save the operation start point (and current end point)
    // Adjust the mouse position to allow for the zoom factor
    m_ptStart.x = x;
    m_ptStart.y = y;
    ClientToSurface(&m_ptStart);
    m_ptEnd   = m_ptStart;

    // Show that the mouse button is now down
    m_bLButtonDown = TRUE;

    // Show that the drawing area is now busy
    m_bBusy = TRUE;

    // Only allow the action to take place if the drawing area is unlocked,
    // and we have a valid tool
    if ((m_bLocked && g_pNMWBOBJ->m_LockerID != g_MyMemberID) || (m_pToolCur == NULL))
    {
        // Tidy up the state and leave now
        m_bLButtonDown = FALSE;
        m_bBusy        = FALSE;
        return;
    }

    // Call the relevant initialization routine
    if (m_pToolCur->ToolType() != TOOLTYPE_SELECT)
    {
        // dump selection if not select tool
        ClearSelection();
    }

	INT border = 1;
    switch (m_pToolCur->ToolType())
    {

        case TOOLTYPE_TEXT:
			break;

		case TOOLTYPE_HIGHLIGHT:
        case TOOLTYPE_PEN:
        case TOOLTYPE_LINE:
        case TOOLTYPE_BOX:
        case TOOLTYPE_FILLEDBOX:
        case TOOLTYPE_ELLIPSE:
        case TOOLTYPE_FILLEDELLIPSE:
            BeginDrawingMode(m_ptStart);
            break;

        case TOOLTYPE_ERASER:
        	BeginSelectMode(m_ptStart, TRUE);
			break;

        case TOOLTYPE_SELECT:
        	border = -2;
			BeginSelectMode(m_ptStart, FALSE);
			break;


        // Do nothing if we do not recognise the pen type
        default:
            ERROR_OUT(("Bad tool type"));
            break;
    }

    // Clamp the cursor to the drawing window
    RECT    rcClient;

    ::GetClientRect(m_hwnd, &rcClient);
    ::MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcClient.left, 2);
    ::InflateRect(&rcClient, border, border);
    ::ClipCursor(&rcClient);
}

//
//
// Function:	SelectPreviousGraphicAt
//
// Purpose:	 Select the previous graphic (in the Z-order) at the position
//			  specified, and starting at a specified graphic. If the
//			  graphic pointer given is NULL the search starts from the
//			  top. If the point specified is outside the bounding
//			  rectangle of the specified graphic the search starts at the
//			  top and chooses the first graphic which contains the point.
//
//			  The search process will loop back to the top of the Z-order
//			  if it gets to the bottom having failed to find a graphic.
//
//			  Graphics which are locked are ignored by the search.
//
//
T126Obj* WbDrawingArea::SelectPreviousGraphicAt
(
	T126Obj* pStartGraphic,
	POINT	   point
)
{
	// Set the result to "none found" initially
	T126Obj* pResultGraphic = NULL;

	// If a starting point has been specified
	if (pStartGraphic != NULL)
	{
		RECT rectHit;

		MAKE_HIT_RECT(rectHit, point);

		// If the reference point is within the start graphic
		if ( pStartGraphic->PointInBounds(point) &&
			pStartGraphic->CheckReallyHit( &rectHit ) )
		{
			WBPOSITION pos = pStartGraphic->GetMyPosition();
			g_pCurrentWorkspace->GetPreviousObject(pos);
			while (pos)
			{
		   		pResultGraphic = g_pCurrentWorkspace->GetPreviousObject(pos);
				if( pResultGraphic && pResultGraphic->CheckReallyHit( &rectHit ) )
				{
					if(m_pMarker)
					{
						RECT rect;
						pResultGraphic->GetRect(&rect);
						m_pMarker->SetRect(&rect);
					}
					break;
				}			
		   		pResultGraphic = NULL;
		   	}
		}
	}

	// If we have not got a result graphic yet. (This catches two cases:
	// - where no start graphic has been given so that we want to start
	//   from the top,
	// - where we have searched back from the start graphic and reached
	//   the bottom of the Z-order without finding a suitable graphic.
	if (pResultGraphic == NULL)
	{
		// Get the topmost graphic that contains the point specified
		pResultGraphic = PG_SelectLast(g_pCurrentWorkspace, point);
	}

	// If we have found an object, draw the marker
	if (pResultGraphic != NULL)
	{
		//
		// If we are already selected and we didn't select it
		// some other node has the control over this graphic don't select it
		// in this case
		// Or if we are trying to select a remote pointer that is not ours
		//
		if(pResultGraphic->IsSelected() && pResultGraphic->WasSelectedRemotely()
			|| (pResultGraphic->GraphicTool() == TOOLTYPE_REMOTEPOINTER && !pResultGraphic->IAmTheOwner()))
		{
			pResultGraphic = NULL;
		}
		else
		{
			// Select the new one
			SelectGraphic(pResultGraphic);
		}
	}

	return pResultGraphic;
}

//
//
// Function:    BeginSelectMode
//
// Purpose:     Process a mouse button down in select mode
//
//

void WbDrawingArea::BeginSelectMode(POINT surfacePos, BOOL bDontDrag )
{
    RECT    rc;

    // Assume we do not start dragging a graphic
    m_pGraphicTracker = NULL;

    // Assume that we do not mark a new graphic
    m_bNewMarkedGraphic = FALSE;

    // turn off TRACK-SELECT-RECT
    m_bTrackingSelectRect = FALSE;

    // Check whether there is currently an object marked, and
    // whether we are clicking inside the same object. If we are then
    // we do nothing here - the click will be handled by the tracking or
    // completion routines for select mode.
    if (   (GraphicSelected() == FALSE)
        || (m_pMarker->PointInBounds(surfacePos) == FALSE))
    {
	    ::SetRectEmpty(&g_pDraw->m_selectorRect);
		
        // We are selecting a new object if bDontDrag == FALSE, find it.
        //  otherwise just turn on the select rect
        T126Obj* pGraphic;
        if( bDontDrag )
            pGraphic = NULL;
        else
            pGraphic = SelectPreviousGraphicAt(NULL, surfacePos);

        // If we have found an object, draw the marker
        if (pGraphic != NULL)
        {

			if(pGraphic->IsSelected() && pGraphic->WasSelectedRemotely())	
			{
				return;
			}
			// Show that a new graphic has now been marked.
			m_bNewMarkedGraphic = TRUE;
        }
        else
        {
            if( (GetAsyncKeyState( VK_SHIFT ) >= 0) &&
                (GetAsyncKeyState( VK_CONTROL ) >= 0) )
            {
                // clicked on dead air, remove all selections
                ClearSelection();
            }

            //TRACK-SELECT-RECT
            m_bTrackingSelectRect = TRUE;

            BeginDrawingMode(surfacePos);

            return;
        }
    }

	if(GraphicSelected())
	{
		m_pMarker->SetRect(&m_selectorRect);
		m_pMarker->SetBoundsRect(&m_selectorRect);
		m_pGraphicTracker = m_pMarker;
	}
	
    // Get all mouse input directed to the this window
    ::SetCapture(m_hwnd);
}


//
//
// Function:    TrackSelectMode
//
// Purpose:     Process a mouse move event in select mode
//
//
void WbDrawingArea::TrackSelectMode(POINT surfacePos)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::TrackSelectMode");
	

	if( m_bTrackingSelectRect )
		TrackDrawingMode(surfacePos);
	else
	{
		// In this case we must be dragging a marked object
		if(!EqualPoint(surfacePos, m_ptEnd))
		{
			MoveSelectedGraphicBy(surfacePos.x - m_ptEnd.x, surfacePos.y - m_ptEnd.y);
		}
		m_ptEnd = surfacePos;
	}
}


void WbDrawingArea::BeginDeleteMode(POINT mousePos )
{
    // turn off object dragging
    BeginSelectMode( mousePos, TRUE );
}



void  WbDrawingArea::TrackDeleteMode( POINT mousePos )
{
    TrackSelectMode( mousePos );
}






//
//
// Function:	BeginTextMode
//
// Purpose:	 Process a mouse button down in text mode
//
//
void WbDrawingArea::BeginTextMode(POINT surfacePos)
{
	RECT	rc;

	MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::BeginTextMode");

	//
	// Get a DC for passing into the text editor
	//
	HDC hDC = m_hDCCached;

	// If we are already editing a text object, we just move the text cursor
	if (m_bTextEditorActive)
	{
		// If the mouse has been clicked in the currently active object
		// we just move the cursor within the object, otherwise we end the
		// edit for the current object and move to a new one.
		m_pTextEditor->GetRect(&rc);
		if (::PtInRect(&rc, surfacePos))
		{
			// Set the new position for the cursor
			m_pTextEditor->SetCursorPosFromPoint(surfacePos);
		}
		else
		{
			// Complete the text entry accepting the changes
			EndTextEntry(TRUE);

			// LAURABU BOGUS:
			// It would be cooler to now return, that way you don't get
			// another text object just cuz you ended the current editing
			// session.
		}
	}

	// If we are not editing an object we check to see whether there is
	// a text object under the cursor or whether we must start a new one.
	if (!m_bTextEditorActive)
	{
		// Check whether we are clicking over a text object. If we are
		// start editing the object, otherwise we start a new text object.

		// Look back through the Z-order for a text object
		T126Obj* pGraphic = PG_SelectLast(g_pCurrentWorkspace, surfacePos);
		T126Obj* pNextGraphic = NULL;
		WBPOSITION pos;
		if(pGraphic)
		{
			pos = pGraphic->GetMyPosition();
		}
		while (   (pGraphic != NULL)  && pGraphic->GraphicTool() != TOOLTYPE_TEXT)
		{

			// Get the next one
			pNextGraphic = PG_SelectPrevious(g_pCurrentWorkspace, pos, surfacePos);

			// Use the next one
			pGraphic = pNextGraphic;
		}

		// Check whether this graphic object is already being edited by
		// another user in the call.
		if (pGraphic != NULL && !pGraphic->WasSelectedRemotely() && pGraphic->GraphicTool() == TOOLTYPE_TEXT)
		{
			// We found a text object under the mouse pointer...
			// ...edit it
			m_pTextEditor = (WbTextEditor*)pGraphic;

			m_pTextEditor->SetTextObject(m_pTextEditor);

			// Make sure the tool reflects the new information
			if (m_pToolCur != NULL)
			{
				m_pToolCur->SelectGraphic(pGraphic);
			}

            HWND hwndParent = ::GetParent(m_hwnd);
            if (hwndParent != NULL)
            {
                ASSERT(g_pMain);
                ASSERT(g_pMain->m_hwnd == hwndParent);
                ::PostMessage(hwndParent, WM_USER_UPDATE_ATTRIBUTES, 0, 0);
            }
		
			// Show that we are now gathering text but dont put up cursor
			// yet. Causes cursor droppings later (bug 2505)
			//ActivateTextEditor( FALSE );
			RECT rect;
			m_pTextEditor->GetRect(&rect);
			m_pTextEditor->Create();
		
			// init editbox size
			m_pTextEditor->GetText();

			//
			// Tell the other nodes they can't edit this object now
			//
			m_pTextEditor->SetViewState(selected_chosen);
			m_pTextEditor->OnObjectEdit();

			ActivateTextEditor( TRUE );

			::BringWindowToTop(m_pTextEditor->m_pEditBox->m_hwnd);
			
			//
			// Account for scrolling
			//
			SurfaceToClient(&rect);
				
			::MoveWindow(m_pTextEditor->m_pEditBox->m_hwnd, rect.left, rect.top,
				rect.right - rect.left, rect.bottom - rect.top,	TRUE);

			// Set the initial cursor position for the edit
			m_pTextEditor->SetCursorPosFromPoint(surfacePos);

		}
		else
		{


			RECT rect;
			rect.top = m_ptEnd.y;
			rect.left = m_ptEnd.x;
			rect.bottom = m_ptEnd.y;
			rect.right = m_ptEnd.x;
	
			DBG_SAVE_FILE_LINE
			m_pTextEditor = new WbTextEditor();

			m_pTextEditor->SetRect(&rect);
			m_pTextEditor->SetAnchorPoint(m_ptEnd.x, m_ptEnd.y);
			m_pTextEditor->SetViewState(selected_chosen);

			
			// There are no text objects under the mouse pointer...
			// ...start a new one

			// Clear any old text out of the editor, and reset its graphic
			// handle. This prevents us from replacing an old text object when
			// we next save the text editor contents.
			if (!m_pTextEditor->New())
			{
				DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
				return;
			}


			// Set the attributes of the text
			m_pTextEditor->SetFont(m_pToolCur->GetFont());
			m_pTextEditor->SetPenColor(m_pToolCur->GetColor(), TRUE);

			// We need to reselect a font now into our DC
			SelectFont(hDC, m_pTextEditor->GetFont());

			// Set the position of the new object
			SIZE sizeCursor;
			m_pTextEditor->GetCursorSize(&sizeCursor);
			m_pTextEditor->CalculateBoundsRect();
			m_pTextEditor->MoveTo(m_ptEnd.x, m_ptEnd.y - sizeCursor.cy);
			// Show that we are now gathering text
			ActivateTextEditor( TRUE );
		}
	}
}

void WbDrawingArea::BeginDrawingMode(POINT surfacePos)
{

	if(!g_pCurrentWorkspace)
	{
		TRACE_DEBUG(("Can't draw without a workspace"));
		return;
	}

	//
	// Get all mouse input directed to the this window
	//
	::SetCapture(m_hwnd);

	//
	// We shouldn't be using the tracker
	//
	ASSERT(!m_pGraphicTracker);

	UINT drawingType;
	BOOL sendBeforefinished = FALSE;
	BOOL highlight = FALSE;
	UINT lineStyle = PS_SOLID;
	UINT toolType = m_pToolCur->ToolType();
	switch (toolType)
	{
		case TOOLTYPE_HIGHLIGHT:
			highlight = TRUE;
		case TOOLTYPE_PEN:
			sendBeforefinished = TRUE;
		case TOOLTYPE_LINE:
			drawingType = openPolyLine_chosen;
			break;

		case TOOLTYPE_SELECT:
		case TOOLTYPE_ERASER:
			m_pGraphicTracker = m_pMarker;
			return;
			break;

		case TOOLTYPE_FILLEDBOX:
		case TOOLTYPE_BOX:
			drawingType = rectangle_chosen;
			break;

		case TOOLTYPE_FILLEDELLIPSE:
		case TOOLTYPE_ELLIPSE:
			drawingType = ellipse_chosen;
			break;
	}	


	
	DBG_SAVE_FILE_LINE
	m_pGraphicTracker = new DrawObj(drawingType, toolType);

	//
	// Use black for the tracking rectangle unless it is pen or highlighter
	//
	if(m_pToolCur->ToolType() == TOOLTYPE_PEN || m_pToolCur->ToolType() == TOOLTYPE_HIGHLIGHT)
	{
		m_pGraphicTracker->SetPenColor(m_pToolCur->GetColor(), TRUE);
	}
	else
	{
		m_pGraphicTracker->SetPenColor(RGB(0,0,0), TRUE);
	}

	m_pGraphicTracker->SetFillColor(RGB(255,255,255), FALSE);
	m_pGraphicTracker->SetLineStyle(lineStyle);
	m_pGraphicTracker->SetAnchorPoint(surfacePos.x, surfacePos.y);
	m_pGraphicTracker->SetHighlight(highlight);
	m_pGraphicTracker->SetViewState(unselected_chosen);
	m_pGraphicTracker->SetZOrder(front);

	//
	// Start a timer if we want it to send intermidiate drawings
	//
	if(sendBeforefinished)
	{

		RECT rect;
		rect.left = surfacePos.x;
		rect.top = surfacePos.y;
		rect.right = surfacePos.x;
		rect.bottom = surfacePos.y;
		
		m_pGraphicTracker->SetRect(&rect);
		m_pGraphicTracker->SetBoundsRect(&rect);

		surfacePos.x = 0;
		surfacePos.y = 0;
		m_pGraphicTracker->AddPoint(surfacePos);
		
		//
		// Select the final ROP
		//
		if (highlight)
		{
			m_pGraphicTracker->SetROP(R2_MASKPEN);
		}
		else
		{
			m_pGraphicTracker->SetROP(R2_COPYPEN);
		}

		//
		// Use the tools width for pen or highlight
		//
		m_pGraphicTracker->SetPenThickness(m_pToolCur->GetWidth());

		// Start the timer for updating the graphic (this is only for updating
		// the graphic when the user stops moving the pointer but keeps the
		// mouse button down).
		::SetTimer(m_hwnd, TIMER_GRAPHIC_UPDATE, DRAW_GRAPHICUPDATEDELAY, NULL);

		// Save the current time (used to determine when to update
		// the external graphic pointer information while the mouse is
		// being moved).
		m_dwTickCount = ::GetTickCount();

		m_pGraphicTracker->SetViewState(selected_chosen);

		
	}
	else
	{
		m_pGraphicTracker->SetPenThickness(1);
	}
}



//
//
// Function:    TrackDrawingMode
//
// Purpose:     Process a mouse move event in drawing mode
//
//
void WbDrawingArea::TrackDrawingMode(POINT surfacePos)
{
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;

	if(!m_pGraphicTracker)
	{
		return;
	}

	if(EqualPoint(surfacePos, m_ptEnd))
	{
		return;
	}

    // Get a device context for tracking
    HDC         hDC = m_hDCCached;

    // set up palette
    if ((g_pCurrentWorkspace != NULL) && ((hPal = PG_GetPalette()) != NULL) )
    {
        hOldPal = ::SelectPalette(hDC, hPal, FALSE );
        ::RealizePalette(hDC);
    }

    // Erase the last ellipse (using XOR property)
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        // Draw the rectangle
        m_pGraphicTracker->Draw();
    }

    // Draw the new rectangle (XORing it onto the display)
    if (!EqualPoint(m_ptStart, surfacePos))
    {
		//
		// If we are using a pen or highlighter
		// Tracking in draw mode is a special case. We draw directly to the client
		// area of the window and to the recording device context.
		if(	m_pToolCur->ToolType() == TOOLTYPE_HIGHLIGHT || m_pToolCur->ToolType() == TOOLTYPE_PEN)
		{
			POINT deltaPoint;

			deltaPoint.x = surfacePos.x - m_ptEnd.x;
			deltaPoint.y = surfacePos.y - m_ptEnd.y;

			// Save the point, checking there aren't too many points
			if (m_pGraphicTracker->AddPoint(deltaPoint) == FALSE)
	    	{
				// too many points so end the freehand object
				OnLButtonUp(0, surfacePos.x, surfacePos.y);
				goto cleanUp;
			}
			m_pGraphicTracker->SetRectPts(m_ptEnd, surfacePos);

			m_pGraphicTracker->AddPointToBounds(surfacePos.x, surfacePos.y);

			m_ptEnd = surfacePos;
	
		}
		else
		{

			// Save the new box end point
			m_ptEnd = surfacePos;

			// Draw the rectangle
			m_pGraphicTracker->SetRectPts(m_ptStart, m_ptEnd);

		}

		m_pGraphicTracker->Draw();

	}

cleanUp:

    if (hOldPal != NULL)
    {
        ::SelectPalette(hDC, hOldPal, TRUE);
    }
}



//
// WbDrawingArea::OnMouseMove
//
void WbDrawingArea::OnMouseMove(UINT flags, int x, int y)
{

	if(!g_pCurrentWorkspace)
	{
		return;
	}

    POINT surfacePos;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnMouseMove");

    surfacePos.x = x;
    surfacePos.y = y;

    // Check if the left mouse button is down
    if (m_bLButtonDown)
    {
        // Calculate the worksurface position
        // Adjust the mouse position to allow for the zoom factor
        ClientToSurface(&surfacePos);

        // Make sure the point is a valid surface position
        MoveOntoSurface(&surfacePos);

        // Check whether the window needs to be scrolled to get the
        // current position into view.
        AutoScroll(surfacePos.x, surfacePos.y, FALSE, 0, 0);

        // Action taken depends on the tool type
        switch(m_pToolCur->ToolType())
        {
            case TOOLTYPE_HIGHLIGHT:
            case TOOLTYPE_PEN:
            case TOOLTYPE_LINE:
            case TOOLTYPE_BOX:
            case TOOLTYPE_FILLEDBOX:
            case TOOLTYPE_ELLIPSE:
            case TOOLTYPE_FILLEDELLIPSE:
                TrackDrawingMode(surfacePos);
                break;

            case TOOLTYPE_ERASER:
            case TOOLTYPE_SELECT:
				TrackSelectMode(surfacePos);
				break;

            case TOOLTYPE_TEXT:
        	// JOSEF add functionality
                break;


            default:
                ERROR_OUT(("Unknown tool type"));
                break;
        }
    }
}

//
//
// Function:    CancelDrawingMode
//
// Purpose:     Cancels a drawing operation after an error.
//
//
void WbDrawingArea::CancelDrawingMode(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::CancelDrawingMode");

    //
    // Quit if there's nothing to cancel.
    //
    if (!m_bBusy && !m_bTextEditorActive)
    {
        TRACE_DEBUG(("Drawing area not busy and text editor not active..."));
        return;
    }

    // The drawing area is no longer busy
    m_bBusy = FALSE;

    //
    // Redraw the object - we need to discard any local updates which we
    // weren't able to write to the object we are editing.  Ideally we should
    // just invalidate the object itself but because some of the co-ordinates
    // we have already drawn on the page may have been lost, we dont know
    // exactly how big the object is.
    //
    ::InvalidateRect(m_hwnd, NULL, TRUE);

    m_bLButtonDown = FALSE;

    // Release the mouse capture
    if (::GetCapture() == m_hwnd)
    {
        ::ReleaseCapture();
    }

    //
    // Perform any tool specific processing.
    //
    switch(m_pToolCur->ToolType())
    {
        case TOOLTYPE_HIGHLIGHT:
        case TOOLTYPE_PEN:
            CompleteDrawingMode();
            break;

        case TOOLTYPE_SELECT:
            // Stop the pointer update timer
            ::KillTimer(m_hwnd, TIMER_GRAPHIC_UPDATE);
            break;

        case TOOLTYPE_TEXT:
            if (m_bTextEditorActive)
            {
                m_pTextEditor->AbortEditGently();
            }
            break;

        default:
            break;
    }

    // Show that we are no longer tracking an object
    if (m_pGraphicTracker != NULL)
    {
        m_pGraphicTracker = NULL; // We don't delete the tracker, because it is also the drawing
    }
}



//
// WbDrawingArea::OnLButtonUp()
//
void WbDrawingArea::OnLButtonUp(UINT flags, int x, int y)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnLButtonUp");

    if (m_bIgnoreNextLClick)
    {
        TRACE_MSG( ("Ignoring WM_LBUTTONUP") );
        m_bIgnoreNextLClick = FALSE;
        return;
    }

    // Only process the event if we saw the button down event
    if (m_bLButtonDown)
    {
        TRACE_MSG(("End of drawing operation"));

        m_bLButtonDown = FALSE;

        // The drawing area is no longer busy
        m_bBusy = FALSE;

        if (m_pGraphicTracker == NULL)
        {
            // Calculate the work surface position
            // Adjust the mouse position to allow for the zoom factor
            POINT surfacePos;

            surfacePos.x = x;
            surfacePos.y = y;
            ClientToSurface(&surfacePos);
            MoveOntoSurface(&surfacePos);
            m_ptEnd = surfacePos;
        }

        // Release the mouse capture
        if (::GetCapture() == m_hwnd)
        {
            ::ReleaseCapture();
        }

        // Check the page is valid - might not be if it has been deleted
        // while the object was being drawn - we would not have been
        // alerted to this because m_bBusy was true.
        if (g_pCurrentWorkspace != NULL)
        {


            // surround in an exception handler in case of lock errors, etc -
            // we need to remove the graphic tracker
            // Action taken depends on the current tool type
            switch(m_pToolCur->ToolType())
            {
                case TOOLTYPE_HIGHLIGHT:
                case TOOLTYPE_PEN:
                case TOOLTYPE_LINE:
                case TOOLTYPE_BOX:
                case TOOLTYPE_FILLEDBOX:
                case TOOLTYPE_ELLIPSE:
                case TOOLTYPE_FILLEDELLIPSE:
                    CompleteDrawingMode();
                    break;

                case TOOLTYPE_SELECT:
                    CompleteSelectMode();
                    break;

                case TOOLTYPE_ERASER:
                    CompleteDeleteMode();
                    break;

                case TOOLTYPE_TEXT:
                    m_ptStart.x = x;
                    m_ptStart.y = y;
                    ClientToSurface(&m_ptStart);
                    BeginTextMode(m_ptStart);
                    break;

                default:
                    ERROR_OUT(("Unknown pen type"));
                    break;
            }
        }

        // Show that we are no longer tracking an object
        if (m_pGraphicTracker != NULL)
        {
	        m_pGraphicTracker = NULL;	// Don't delete the tracker since it is the drawing object
        }
	}

    // unclamp cursor (bug 589)
    ClipCursor(NULL);
}

//
//
// Function:    CompleteSelectMode
//
// Purpose:     Complete a select mode operation
//
//
void WbDrawingArea::CompleteSelectMode()
{
    // If an object is being dragged
    //if (m_pGraphicTracker != NULL)
    {
		// Check if we were dragging a pointer. Pointers track
		// themselves i.e. the original copy of the pointer is not
		// left on the page. We want to leave the last drawn image on
		// the page as this is the new pointer position.
		if( m_bTrackingSelectRect && (!EqualPoint(m_ptStart, m_ptEnd)))
		{
			CompleteMarkAreaMode();
			SelectMarkerFromRect( &m_rcMarkedArea );
		}
		else
		{

			// If we need to remove the rubber band box
			if (!EqualPoint(m_ptStart, m_ptEnd))
			{
				EraseInitialDrawFinal(m_ptStart.x - m_ptEnd.x , m_ptStart.y - m_ptEnd.y, TRUE);
				InvalidateSurfaceRect(&g_pDraw->m_selectorRect,TRUE);
				
			}
			else
			{
				// Start and end points were the same, in this case the object has
				// not been moved. We treat this as a request to move the marker
				// back through the stack of objects.
				if (m_bNewMarkedGraphic == FALSE)
				{
					SelectPreviousGraphicAt(m_pSelectedGraphic, m_ptEnd);
				}
			}

			m_bTrackingSelectRect = TRUE;
		}

		//
		// Make sure to delete the saved bitmap
		//
		if(m_pSelectedGraphic && m_pSelectedGraphic->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
		{
			((BitmapObj*)m_pSelectedGraphic)->DeleteSavedBitmap();

		}
	}
}




void WbDrawingArea::CompleteDeleteMode()
{
    // select object(s)
    CompleteSelectMode();


	//
	// If we are draging the remote pointer do nothing
	//
    if(m_pSelectedGraphic && m_pSelectedGraphic->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
    {
    	return;
    }

    // nuke 'em
    ::PostMessage(g_pMain->m_hwnd, WM_COMMAND, MAKELONG(IDM_DELETE, BN_CLICKED), 0);
}



//
//
// Function:	CompleteMarkAreaMode
//
// Purpose:	 Process a mouse button up event in mark area mode
//
//
void WbDrawingArea::CompleteMarkAreaMode(void)
{
	// Get a device context for tracking
	HDC hDC = m_hDCCached;

	// Erase the last ellipse (using XOR property)
	if (!EqualPoint(m_ptStart, m_ptEnd))
	{
		// Draw the rectangle
		m_pGraphicTracker->Draw();

		// Use normalized coords
		if (m_ptEnd.x < m_ptStart.x)
		{
			m_rcMarkedArea.left = m_ptEnd.x;
			m_rcMarkedArea.right = m_ptStart.x;
		}
		else
		{
			m_rcMarkedArea.left = m_ptStart.x;
			m_rcMarkedArea.right = m_ptEnd.x;
		}

		if (m_ptEnd.y < m_ptStart.y)
		{
			m_rcMarkedArea.top = m_ptEnd.y;
			m_rcMarkedArea.bottom = m_ptStart.y;
		}
		else
		{
			m_rcMarkedArea.top = m_ptStart.y;
			m_rcMarkedArea.bottom = m_ptEnd.y;
		}
	}
}

//
//
// Function:    CompleteTextMode
//
// Purpose:     Complete a text mode operation
//
//
void WbDrawingArea::CompleteTextMode()
{
    // Not much to for text mode. Main text mode actions are taken
    // as a result of a WM_CHAR message and not on mouse events.
    // Just deselect our font if it is still selected
    UnPrimeFont(m_hDCCached);
}


//
//
// Function:    CompleteDrawingMode
//
// Purpose:     Complete a draw mode operation
//
//
void WbDrawingArea::CompleteDrawingMode()
{
    // Only draw the line if it has non-zero length
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        DrawObj *pObj;
        pObj = m_pGraphicTracker;
		
   		//
		// Erase the last traking
		//
		pObj->Draw();

		if(m_pToolCur->ToolType() == TOOLTYPE_PEN || m_pToolCur->ToolType() == TOOLTYPE_HIGHLIGHT)
		{
			// DO nothing because we drew it already and all the attributes are also already set
		    // Stop the update timer
		    ::KillTimer(m_hwnd, TIMER_GRAPHIC_UPDATE);
		}
		else
		{
	
			RECT rect;
			rect.left = m_ptStart.x;
			rect.top = m_ptStart.y;
			rect.right = m_ptEnd.x;
			rect.bottom = m_ptEnd.y;

			pObj->SetRect(&rect);
			pObj->SetPenThickness(m_pToolCur->GetWidth());
			::InflateRect(&rect, m_pToolCur->GetWidth()/2, m_pToolCur->GetWidth()/2);
			pObj->SetBoundsRect(&rect);

			pObj->SetPenColor(m_pToolCur->GetColor(), TRUE);
			pObj->SetFillColor(m_pToolCur->GetColor(), (m_pToolCur->ToolType() == TOOLTYPE_FILLEDELLIPSE || m_pToolCur->ToolType() == TOOLTYPE_FILLEDBOX));
			pObj->SetROP(m_pToolCur->GetROP());

			POINT deltaPoint;
			deltaPoint.x =   m_ptEnd.x - m_ptStart.x;
			deltaPoint.y =   m_ptEnd.y - m_ptStart.y;
			pObj->AddPoint(deltaPoint);

			//
			// Draw the object
			//
			pObj->Draw();
		}

		//
		// We are done with this drawing
		//
		pObj->SetIsCompleted(TRUE);

		pObj->SetViewState(unselected_chosen);

		//
		// If the object was alredy added just send an edit
		//
		if(pObj->GetMyWorkspace())
		{
			pObj->OnObjectEdit();
		}
		else
		{
			// Add the object to the list of objects
			pObj->AddToWorkspace();
		}
		
    }
    else
    {
		delete m_pGraphicTracker;
    }
   	m_pGraphicTracker =NULL;
}

//
//
// Function:    EndTextEntry
//
// Purpose:     The user has finished entering a text object. The parameter
//              indicates whether the changes are to be accepted or
//              discarded.
//
//
void WbDrawingArea::EndTextEntry(BOOL bAccept)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::EndTextEntry");

	WorkspaceObj * pWorkspace = m_pTextEditor->GetMyWorkspace();

	// Deactivate the text editor
	DeactivateTextEditor();

	if(bAccept &&( m_pTextEditor->strTextArray.GetSize()) )
	{
		if(!pWorkspace && m_pTextEditor->strTextArray.GetSize())
		{
			m_pTextEditor->AddToWorkspace();
		}
		else
		{
			if(m_pTextEditor->HasTextChanged())
			{
				m_pTextEditor->OnObjectEdit();
			}
		}

		//
		// Tell the other nodes they can edit this object now
		//
		m_pTextEditor->SetViewState(unselected_chosen);
		m_pTextEditor->OnObjectEdit();


	}
	else
	{
		//
		// if we were already added by a WM_TIMER message
		//
		if(pWorkspace)
		{

			//
			// Tell the other nodes we deleted this text.
			//
			m_pTextEditor->OnObjectDelete();			

			//
			// If we delete localy we add this object to the trash can, but we really want to delete it
			//
			m_pTextEditor->ClearDeletionFlags();
			pWorkspace->RemoveT126Object(m_pTextEditor);
		}
		else
		{
			delete m_pTextEditor;
		}
	}
	
	m_pTextEditor = NULL;
}

//
//
// Function:    Zoom
//
// Purpose:     Toggle the zoom state of the drawing area
//
//
void WbDrawingArea::Zoom(void)
{
    RECT    rcClient;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Zoom");

    // We zoom focusing on the centre of the window
    ::GetClientRect(m_hwnd, &rcClient);
    long xOffset = (rcClient.right - (rcClient.right / m_iZoomOption)) / 2;
    long yOffset = (rcClient.bottom - (rcClient.bottom / m_iZoomOption)) / 2;

    if (m_iZoomFactor != 1)
    {
        // We are already zoomed move back to unzoomed state
        // First save the scroll position in case we return to zoom immediately
        m_posZoomScroll = m_posScroll;
        m_zoomRestoreScroll  = TRUE;

        m_posScroll.x  -= xOffset;
        m_posScroll.y  -= yOffset;
        ::ScaleViewportExtEx(m_hDCCached, 1, m_iZoomFactor, 1, m_iZoomFactor, NULL);
        m_iZoomFactor = 1;
    }
    else
    {
        // We are not zoomed so do it
        if (m_zoomRestoreScroll)
        {
            m_posScroll = m_posZoomScroll;
        }
        else
        {
            m_posScroll.x += xOffset;
            m_posScroll.y += yOffset;
        }

        m_iZoomFactor = m_iZoomOption;
        ::ScaleViewportExtEx(m_hDCCached, m_iZoomFactor, 1, m_iZoomFactor, 1, NULL);

        // ADDED BY RAND - don't allow text editing in zoom mode
        if( (m_pToolCur == NULL) || (m_pToolCur->ToolType() == TOOLTYPE_TEXT) )
            ::SendMessage(g_pMain->m_hwnd, WM_COMMAND, IDM_TOOLS_START, 0 );
    }

    TRACE_MSG(("Set zoom factor to %d", m_iZoomFactor));

      // Update the scroll information
    SetScrollRange(rcClient.right, rcClient.bottom);
    ValidateScrollPos();

    ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);
    ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);

    // Update the origin offset from the scroll position
    m_originOffset.cx = m_posScroll.x;
    m_originOffset.cy = m_posScroll.y;
    ::SetWindowOrgEx(m_hDCCached, m_originOffset.cx, m_originOffset.cy, NULL);

    // Tell the parent that the scroll position has changed
    ::PostMessage(g_pMain->m_hwnd, WM_USER_PRIVATE_PARENTNOTIFY, WM_VSCROLL, 0L);

    //
    // Update the tool/menu item states, since our zoom state has changed
    // and that will enable/disable some tools, etc.
    //
    g_pMain->SetMenuStates(::GetSubMenu(::GetMenu(g_pMain->m_hwnd), 3));

    // Redraw the window
    ::InvalidateRect(m_hwnd, NULL, TRUE);
}

//
//
// Function:    SelectTool
//
// Purpose:     Set the current tool
//
//
void WbDrawingArea::SelectTool(WbTool* pToolNew)
{
	if(pToolNew == m_pToolCur)
	{
		return;
	}

    // If we are leaving text mode, complete the text entry
    if (m_bTextEditorActive  && (m_pToolCur->ToolType() == TOOLTYPE_TEXT)
      && (pToolNew->ToolType() != TOOLTYPE_TEXT))
  {
    // End text entry accepting the changes
    EndTextEntry(TRUE);
  }

  // If we are no longer in select mode, and the marker is present,
  // then remove it and let the tool know it's no longer selected
  if (m_pToolCur != NULL)
  {
    RemoveMarker();
    m_pSelectedGraphic = NULL;
  }

    // Save the new tool
    m_pToolCur = pToolNew;
}

//
//
// Function:    SetSelectionColor
//
// Purpose:     Set the color of the selected object
//
//
void WbDrawingArea::SetSelectionColor(COLORREF clr)
{
    RECT    rc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SetSelectionColor");

	if(g_pCurrentWorkspace)
	{
		RECT rect;
		T126Obj* pObj;
		WBPOSITION pos = g_pCurrentWorkspace->GetHeadPosition();
		while(pos)
		{
			pObj = (T126Obj*)g_pCurrentWorkspace->GetNextObject(pos);
			if(pObj && pObj->WasSelectedLocally())
			{
				//
				// Set the new pen color
				//
				pObj->SetPenColor(clr, TRUE);
				pObj->SetFillColor(clr, (pObj->GraphicTool() == TOOLTYPE_FILLEDELLIPSE || pObj->GraphicTool() == TOOLTYPE_FILLEDBOX));
				pObj->UnDraw();
				pObj->DrawRect();

				//
				// Send it to other nodes
				//
				pObj->OnObjectEdit();

				//
				// Draw it locally
				//
				pObj->Draw();
			}
		}	
	}
	
	
	
    // If the text editor is active - redraw the text in the new color
    if (m_bTextEditorActive)
    {
        // Change the color being used by the editor
        m_pTextEditor->SetPenColor(clr, TRUE);

        // Update the screen
        m_pTextEditor->GetBoundsRect(&rc);
        InvalidateSurfaceRect(&rc, TRUE);
    }

}

//
//
// Function:    SetSelectionWidth
//
// Purpose:     Set the nib width used to draw the currently selected object
//
//
void WbDrawingArea::SetSelectionWidth(UINT uiWidth)
{
	if(g_pCurrentWorkspace)
	{
		RECT rect;
		T126Obj* pObj;
		WBPOSITION pos = g_pCurrentWorkspace->GetHeadPosition();
		while(pos)
		{
			pObj = (T126Obj*)g_pCurrentWorkspace->GetNextObject(pos);
			if(pObj && pObj->WasSelectedLocally())
			{
				//
				// Undraw the object
				//
				pObj->UnDraw();
				pObj->DrawRect();

				//
				// Get the correct width for each object
				//
				WbTool*   pSelectedTool = g_pMain->m_ToolArray[pObj->GraphicTool()];
				pSelectedTool->SetWidthIndex(uiWidth);
				pObj->SetPenThickness(pSelectedTool->GetWidth());

				//
				// Send it to other nodes
				//
				pObj->OnObjectEdit();

				//
				// Draw it locally
				//
				pObj->Draw();
			}
		}	
	}
}

//
//
// Function:    SetSelectionFont
//
// Purpose:     Set the font used by the currently selected object
//
//
void WbDrawingArea::SetSelectionFont(HFONT hFont)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SetSelectionFont");


    // Define rectangles for redrawing
    RECT    rcOldBounds;
    RECT    rcNewBounds;


    // Pass the font onto the text editor
    // If the text editor is active - redraw the text in the new font
    if (m_bTextEditorActive)
    {
	    m_pTextEditor->GetBoundsRect(&rcOldBounds);

		m_pTextEditor->SetFont(hFont);

        // Get the new rectangle of the text
        m_pTextEditor->GetBoundsRect(&rcNewBounds);

        // Remove and destroy the text cursor to ensure that it
        // gets re-drawn with the new size for the font

        // Update the screen
        InvalidateSurfaceRect(&rcOldBounds, TRUE);
        InvalidateSurfaceRect(&rcNewBounds, TRUE);

        // get the text cursor back
        ActivateTextEditor( TRUE );
    }

	if(g_pCurrentWorkspace)
	{
		T126Obj* pObj;
		WBPOSITION pos = g_pCurrentWorkspace->GetHeadPosition();
		while(pos)
		{
			pObj = (T126Obj*)g_pCurrentWorkspace->GetNextObject(pos);
			if(pObj && pObj->WasSelectedLocally() && pObj->GraphicTool() == TOOLTYPE_TEXT)
			{
				//
				// Set the new pen color
				//
				((TextObj*)pObj)->SetFont(hFont);
				pObj->UnDraw();
				pObj->DrawRect();

				//
				// Send it to other nodes
				//
				pObj->OnObjectEdit();

				//
				// Draw it locally
				//
				pObj->Draw();
			}
		}	
	}
}

//
//
// Function:    OnSetFocus
//
// Purpose:     The window is getting the focus
//
//
void WbDrawingArea::OnSetFocus(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnSetFocus");

    //
    // If we are in text mode, we must make the text cursor visible.
    //
    if (m_bTextEditorActive && (m_pToolCur->ToolType() == TOOLTYPE_TEXT))
    {
        ActivateTextEditor(TRUE);
    }
}


//
//
// Function:    OnActivate
//
// Purpose:     The window is being activated or deactivated
//
//
void WbDrawingArea::OnActivate(UINT uiState)
{
    // Check if we are being activated or deactivated
    if (uiState)
    {
        // We are being activated, get the focus as well
        ::SetFocus(m_hwnd);

        // If we are in text mode, we must make the text cursor visible
        if (m_bTextEditorActive && (m_pToolCur->ToolType() == TOOLTYPE_TEXT))
        {
            ActivateTextEditor(TRUE);
        }
    }
    else
    {
        // We are being deactivated
        DeactivateTextEditor();
    }
}

//
//
// Function:    DeleteSelection
//
// Purpose:     Delete the currently selected object
//
//
void WbDrawingArea::DeleteSelection()
{
	m_pSelectedGraphic = NULL;
}

//
//
// Function:    GetSelection
//
// Purpose:     Return the currently selected graphic (or NULL if none).
//
//
T126Obj* WbDrawingArea::GetSelection()
{
  T126Obj* pGraphic = NULL;

  // If there is an object currently selected...
  if (GraphicSelected())
  {
    // ...return it
    pGraphic = m_pSelectedGraphic;
  }

  return pGraphic;
}

//
//
// Function:    BringToTopSelection
//
// Purpose:     Bring the currently selected object to the top
//
//
LRESULT WbDrawingArea::BringToTopSelection(BOOL editedLocally, T126Obj * pT126Obj)
{
	T126Obj* pObj;
	WBPOSITION posTail;
	WBPOSITION pos;
	WBPOSITION myPos;
	WorkspaceObj *pWorkspace;

	if(pT126Obj)
	{
		pos = pT126Obj->GetMyPosition();
		pWorkspace = pT126Obj->GetMyWorkspace();
	}
	else
	{
		pos = g_pCurrentWorkspace->GetHeadPosition();
		pWorkspace = g_pCurrentWorkspace;
	}


	posTail = pWorkspace->GetTailPosition();


	while(pos && pos != posTail)
	{
		pObj = pWorkspace->GetNextObject(pos);

		//
		// If the graphic is selected
		//
		if( pObj && (pObj->IsSelected() &&
		//
		// We were called locally and the graphic is selected locally
		//
		((editedLocally && pObj->WasSelectedLocally()) ||
		//
		// We were called because the graphic got edited remotely
		// and it is selected remotely
		((!editedLocally && pObj->WasSelectedRemotely())))))
		{
			myPos = pObj->GetMyPosition();
			pObj = pWorkspace->RemoveAt(myPos);
			pWorkspace->AddTail(pObj);

			if(pT126Obj)
			{
				::InvalidateRect(m_hwnd, NULL, TRUE);
				return  S_OK;
			}
			
			//
			// send change of z order
			//
			pObj->ResetAttrib();
			pObj->SetZOrder(front);
			pObj->OnObjectEdit();

			//
			// Unselect it
			//
			pObj->UnselectDrawingObject();

			RECT rect;
			pObj->GetBoundsRect(&rect);
			InvalidateSurfaceRect(&rect,TRUE);

		}
	}
	return S_OK;
}

//
//
// Function:    SendToBackSelection
//
// Purpose:     Send the currently marked object to the back
//
//
LRESULT WbDrawingArea::SendToBackSelection(BOOL editedLocally, T126Obj * pT126Obj)
{
	// If there is an object currently selected...
	T126Obj* pObj;
	WBPOSITION posHead;
	WBPOSITION myPos;
	WBPOSITION pos;
	WorkspaceObj *pWorkspace;

	if(pT126Obj)
	{
		pos = pT126Obj->GetMyPosition();
		pWorkspace = pT126Obj->GetMyWorkspace();
	}
	else
	{
		pos = g_pCurrentWorkspace->GetTailPosition();
		pWorkspace = g_pCurrentWorkspace;

	}

	posHead = pWorkspace->GetHeadPosition();

	while(pos && pos != posHead)
	{
		pObj = pWorkspace->GetPreviousObject(pos);
		//
		// If the graphic is selected
		//
		if( (pObj->IsSelected() &&
		//
		// We were called locally and the graphic is selected locally
		//
		((editedLocally && pObj->WasSelectedLocally()) ||
		//
		// We were called because the graphic got edited remotely
		// and it is selected remotely
		((!editedLocally && pObj->WasSelectedRemotely())))))
		{
			myPos = pObj->GetMyPosition();
			pObj = pWorkspace->RemoveAt(myPos);
			pWorkspace->AddHead(pObj);

			if(pT126Obj)
			{
				::InvalidateRect(m_hwnd, NULL, TRUE);
				return  S_OK;
			}

			//
			// send change of z order
			//
			pObj->ResetAttrib();
			pObj->SetZOrder(back);
			pObj->OnObjectEdit();

			//
			// Unselect it
			//
			pObj->UnselectDrawingObject();

			RECT rect;
			pObj->GetBoundsRect(&rect);
			::InvalidateRect(m_hwnd, NULL , TRUE);
		}
	}
	return S_OK;
}

//
//
// Function:    Clear
//
// Purpose:     Clear the drawing area.
//
//
void WbDrawingArea::Clear()
{
    // Remove the recorded objects
//    PG_Clear(m_hPage);

  // The page will be redrawn after an event generated by the clear request
}

//
//
// Function:    Attach
//
// Purpose:     Change the page the window is displaying
//
//
void WbDrawingArea::Attach(WorkspaceObj* pNewWorkspace)
{

    // Accept any text being edited
    if (m_bTextEditorActive)
    {
        EndTextEntry(TRUE);
    }

    // finish any drawing operation now
    if (m_bLButtonDown)
    {
        OnLButtonUp(0, m_ptStart.x, m_ptStart.y);
    }

    // Get rid of the selection
    ClearSelection();

    // Save the new page details
    g_pCurrentWorkspace = pNewWorkspace;

	if(IsSynced())
	{
		g_pConferenceWorkspace = g_pCurrentWorkspace;
	}



    // Force a redraw of the window to show the new contents
    ::InvalidateRect(m_hwnd, NULL, TRUE);
}

//
//
// Function:    DrawMarker
//
// Purpose:     Draw the graphic object marker
//
//
void WbDrawingArea::DrawMarker(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::DrawMarker");

    // Draw the marker
    m_pMarker->Draw();
}

//
//
// Function:    PutMarker
//
// Purpose:     Draw the graphic object marker
//
//
void WbDrawingArea::PutMarker(HDC hDC, BOOL bDraw)
{
}

//
//
// Function:    RemoveMarker
//
// Purpose:     Remove the graphic object marker
//
//
void WbDrawingArea::RemoveMarker()
{
	if(g_pCurrentWorkspace)
	{
	    T126Obj* pObj;
		WBPOSITION pos;
		pos = g_pCurrentWorkspace->GetHeadPosition();

		while(pos)
		{
			pObj = (T126Obj*)g_pCurrentWorkspace->GetNextObject(pos);
			if(pObj && pObj->WasSelectedLocally())
			{
				pObj->UnselectDrawingObject();
			}
		}	
	}
}




//
//
// Function:    ActivateTextEditor
//
// Purpose:     Start a text editing session
//
//
void WbDrawingArea::ActivateTextEditor( BOOL bPutUpCusor )
{
    // Record that the editor is now active
    m_bTextEditorActive = TRUE;

    // show editbox
    m_pTextEditor->ShowBox( SW_SHOW );

    // Start the timer for updating the text
    m_pTextEditor->SetTimer( DRAW_GRAPHICUPDATEDELAY);
}

//
//
// Function:    DeactivateTextEditor
//
// Purpose:     End a text editing session
//
//
void WbDrawingArea::DeactivateTextEditor(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::DeactivateTextEditor");

    // Stop the update timer
    m_pTextEditor->KillTimer();

    // Show that we are not editing any text
    m_bTextEditorActive = FALSE;

	// hide editbox
    m_pTextEditor->ShowBox( SW_HIDE );

}



//
//
// Function:    SurfaceToClient
//
// Purpose:     Convert a point in surface co-ordinates to client
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::SurfaceToClient(LPPOINT lppoint)
{
    lppoint->x -= m_originOffset.cx;
    lppoint->x *= m_iZoomFactor;

    lppoint->y -= m_originOffset.cy;
    lppoint->y *= m_iZoomFactor;
}

//
//
// Function:    ClientToSurface
//
// Purpose:     Convert a point in client co-ordinates to surface
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::ClientToSurface(LPPOINT lppoint)
{
    ASSERT(m_iZoomFactor != 0);

    lppoint->x /= m_iZoomFactor;
    lppoint->x += m_originOffset.cx;

    lppoint->y /= m_iZoomFactor;
    lppoint->y += m_originOffset.cy;
}


//
//
// Function:    SurfaceToClient
//
// Purpose:     Convert a rectangle in surface co-ordinates to client
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::SurfaceToClient(LPRECT lprc)
{
    SurfaceToClient((LPPOINT)&lprc->left);
    SurfaceToClient((LPPOINT)&lprc->right);
}

//
//
// Function:    ClientToSurface
//
// Purpose:     Convert a rectangle in client co-ordinates to surface
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::ClientToSurface(LPRECT lprc)
{
    ClientToSurface((LPPOINT)&lprc->left);
    ClientToSurface((LPPOINT)&lprc->right);
}

//
//
// Function:    GraphicSelected
//
// Purpose:     Return TRUE if a graphic is currently selected
//
//
BOOL WbDrawingArea::GraphicSelected(void)
{

	if(g_pCurrentWorkspace)
	{

		T126Obj* pObj;
		WBPOSITION pos = g_pCurrentWorkspace->GetHeadPosition();

		while(pos)
		{
			pObj = (T126Obj*)g_pCurrentWorkspace->GetNextObject(pos);
			if(pObj && pObj->WasSelectedLocally())
			{
				m_pSelectedGraphic = pObj;
				return TRUE;
			}
		}	
	}

	return FALSE;
}




BOOL WbDrawingArea::MoveSelectedGraphicBy(LONG x, LONG y)
{

    T126Obj* pObj;
	WBPOSITION pos = g_pCurrentWorkspace->GetHeadPosition();

	while(pos)
	{
		pObj = (T126Obj*)g_pCurrentWorkspace->GetNextObject(pos);
		if(pObj && pObj->WasSelectedLocally())
		{
			pObj->MoveBy(x, y);
		}
	}	

	return FALSE;
}

void WbDrawingArea::EraseSelectedDrawings(void)
{

    T126Obj* pObj;
	//
	// Burn trash
	//
	pObj = (T126Obj *)g_pTrash->RemoveTail();
    while (pObj != NULL)
    {
		delete pObj;
		pObj = (T126Obj *) g_pTrash->RemoveTail();
	}

	WBPOSITION pos = g_pCurrentWorkspace->GetHeadPosition();
	while(pos)
	{
		pObj = (T126Obj*)g_pCurrentWorkspace->GetNextObject(pos);
		if(pObj && pObj->WasSelectedLocally() && pObj->GraphicTool() != TOOLTYPE_REMOTEPOINTER)
		{
			pObj->DeletedLocally();
			g_pCurrentWorkspace->RemoveT126Object(pObj);
		}
	}
}

void WbDrawingArea::EraseInitialDrawFinal(LONG x, LONG y, BOOL editedLocally, T126Obj* pObj)

{

    T126Obj* pGraphic;
    WorkspaceObj * pWorkspace;	WBPOSITION pos;
	
	if(pObj)
	{
	 	pWorkspace = pObj->GetMyWorkspace();
		pGraphic = pObj;
	}
	else
	{
		pWorkspace = g_pCurrentWorkspace;
	}

	//
	// Check if the objects workspace is valid or if there is a current workspace
	//
	if(pWorkspace == NULL)
	{
		return;
	}

	pos = pWorkspace->GetHeadPosition();

	while(pos)
	{
		// if we are talking about an specifc object
		if(!pObj)
		{
			pGraphic = (T126Obj*)pWorkspace->GetNextObject(pos);
		}

		//
		// If the graphic is selected
		//
		if(pGraphic &&

		//
		// We were called locally and the graphic is selected locally
		//
		((editedLocally && pGraphic->WasSelectedLocally()) ||

		//
		// We were called because the graphic got edited remotely
		// and it is selected remotely
		//
		(!editedLocally)))
		
		{

			POINT finalAnchorPoint;
			RECT initialRect;
			RECT rect;
			RECT initialBoundsRect;
			RECT boundsRect;

			//
			// Get The final Rects
			//
			pGraphic->GetRect(&rect);
			pGraphic->GetBoundsRect(&boundsRect);
			initialRect = rect;
			initialBoundsRect = boundsRect;
			pGraphic->GetAnchorPoint(&finalAnchorPoint);


			//
			// Find out were the drawing was
			//
			::OffsetRect(&initialRect, x, y);
			::OffsetRect(&initialBoundsRect, x, y);
			pGraphic->SetRect(&initialRect);
			pGraphic->SetBoundsRect(&initialBoundsRect);
			
			pGraphic->SetAnchorPoint(finalAnchorPoint.x + x, finalAnchorPoint.y + y);

			//
			// Erase initial drawing
			//
			pGraphic->UnDraw();

			//
			//Erase the selection rectangle only if we selected locally
			//
			if(editedLocally)
			{
				pGraphic->DrawRect();
			}

			//
			// The only attributes we want to send unselected and anchorpoint
			//
			pGraphic->ResetAttrib();
			
			//
			// Restore rectangles and draw the object in the final position
			//
			pGraphic->SetRect(&rect);
			pGraphic->SetBoundsRect(&boundsRect);
			pGraphic->SetAnchorPoint(finalAnchorPoint.x, finalAnchorPoint.y);
			pGraphic->Draw(FALSE);

			//
			// Don't send it if it was not created locally
			//
			if(editedLocally)
			{
				pGraphic->EditedLocally();

				//
				// Sends the final drawing to the other nodes
				//
				pGraphic->OnObjectEdit();

				//
				// This will remove the selection box and send a
				// edit PDU telling other nodes the object is not selected
				//
				pGraphic->UnselectDrawingObject();
			}
		}

		//
		// Just moved one specifc object
		//
		if(pObj != NULL)
		{
			return;
		}
	
	}	
}




//
//
// Function:    SelectGraphic
//
// Purpose:     Select a graphic - save the pointer to the graphic and
//              draw the marker on it.
//
//
void WbDrawingArea::SelectGraphic(T126Obj* pGraphic,
                                      BOOL bEnableForceAdd,
                                      BOOL bForceAdd )
{
    BOOL bZapCurrentSelection;
    RECT rc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SelectGraphic");

	if(pGraphic->IsSelected() && pGraphic->WasSelectedLocally())
	{
		pGraphic->UnselectDrawingObject();
		return;
	}
	else if(pGraphic->IsSelected() && pGraphic->WasSelectedRemotely())
	{
		return;
	}
	else
	{

		// new selection, add to list or replace list?
		if( bEnableForceAdd )
		{
			bZapCurrentSelection = !bForceAdd;
		}
		else
		{
			bZapCurrentSelection = ((GetAsyncKeyState( VK_SHIFT ) >= 0) && (GetAsyncKeyState( VK_CONTROL ) >= 0));
		}
	
		if( bZapCurrentSelection )
		{
			// replace list
			RemoveMarker();
		}
	}


   // Update the attributes window to show graphic is selected
    m_pToolCur->SelectGraphic(pGraphic);
	pGraphic->SelectDrawingObject();

    HWND hwndParent = ::GetParent(m_hwnd);
    if (hwndParent != NULL)
    {
        ::PostMessage(hwndParent, WM_USER_UPDATE_ATTRIBUTES, 0, 0);
    }
}

//
//
// Function:    DeselectGraphic
//
// Purpose:     Deselect a graphic - remove the marker and delete the
//              graphic object associated with it.
//
//
void WbDrawingArea::DeselectGraphic(void)
{
    HWND hwndParent = ::GetParent(m_hwnd);
    if (hwndParent != NULL)
    {
        ::PostMessage(hwndParent, WM_USER_UPDATE_ATTRIBUTES, 0, 0);
    }
}



//
//
// Function:    GetVisibleRect
//
// Purpose:     Return the rectangle of the surface currently visible in the
//              drawing area window.
//
//
void WbDrawingArea::GetVisibleRect(LPRECT lprc)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::VisibleRect");

    // Get the client rectangle
    ::GetClientRect(m_hwnd, lprc);

    // Convert to surface co-ordinates
    ClientToSurface(lprc);
}


//
//
// Function:    MoveOntoSurface
//
// Purpose:     If a given point is outwith the surface rect, move it on
//
//
void WbDrawingArea::MoveOntoSurface(LPPOINT lppoint)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::MoveOntoSurface");

    //
    // Make sure that the position is within the surface rect
    //

    if (lppoint->x < 0)
    {
        lppoint->x = 0;
    }
    else if (lppoint->x >= DRAW_WIDTH)
    {
        lppoint->x = DRAW_WIDTH - 1;
    }

    if (lppoint->y < 0)
    {
        lppoint->y = 0;
    }
    else if (lppoint->y >= DRAW_HEIGHT)
    {
        lppoint->y = DRAW_HEIGHT - 1;
    }
}


//
//
// Function:    GetOrigin
//
// Purpose:     Provide current origin of display
//
//
void WbDrawingArea::GetOrigin(LPPOINT lppoint)
{
    lppoint->x = m_originOffset.cx;
    lppoint->y = m_originOffset.cy;
}



void WbDrawingArea::ShutDownDC(void)
{
    UnPrimeDC(m_hDCCached);

    if (m_hDCWindow != NULL)
    {
        ::ReleaseDC(m_hwnd, m_hDCWindow);
        m_hDCWindow = NULL;
    }

    m_hDCCached = NULL;
}




void WbDrawingArea::ClearSelection( void )
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::ClearSelection");

    RemoveMarker();

    g_pMain->OnUpdateAttributes();
}





void WbDrawingArea::OnCancelMode( void )
{
    // We were dragging but lost mouse control, gracefully end the drag (NM4db:573)
    POINT pt;

    ::GetCursorPos(&pt);
    ::ScreenToClient(m_hwnd, &pt);
    OnLButtonUp(0, pt.x, pt.y);
    m_bLButtonDown = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\gcchelp.h ===
//
// GCCHELP.H
// GCC Helper functions
//
// Copyright Microsoft 1998-
//

void T126_GCCAllocateHandleConfirm(ULONG, ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\draw.hpp ===
//
// DRAW.HPP
// Drawing Code
//
// Copyright Microsoft 1998-
//


#ifndef __DRAW_HPP_
#define __DRAW_HPP_

#include <oblist.h>

#define HIT_WINDOW 1
#define MAKE_HIT_RECT(r, p )  \
    ::SetRect(&r, p.x-HIT_WINDOW, p.y-HIT_WINDOW, p.x+HIT_WINDOW, p.y+HIT_WINDOW);

//
// Timer for periodic update of some graphic objects
//
#define TIMER_GRAPHIC_UPDATE  8
#define TIMER_REMOTE_POINTER_UPDATE 9

#define EqualPoint(pt1, pt2)    (((pt1).x == (pt2).x) && ((pt1).y == (pt2).y))


#define DRAW_WIDTH                      1280
#define DRAW_HEIGHT                     1024
#define DRAW_LINEVSCROLL                8				
#define DRAW_LINEHSCROLL                8				
#define DRAW_HANDLESIZE                 6				
#define DRAW_ZOOMFACTOR                 2
#define DRAW_REMOTEPOINTERDELAY         250
#define DRAW_GRAPHICUPDATEDELAY         1000


extern WorkspaceObj* g_pCurrentWorkspace;


//
//
// Class:   WbDrawingArea
//
// Purpose: drawing window
//
//
class WbDrawingArea
{

  friend class WbTextBox;


public:
    //
    // Constructor
    //
    WbDrawingArea(void);
    ~WbDrawingArea(void);

	void ShutDownDC(void);
  
    //
    // Create the drawing area
    //
    BOOL Create(HWND hwndParent, LPCRECT lprect);

    //
    // Return TRUE if the drawing area is busy and may be actively using
    // graphic objects in the current page.
    //
    BOOL IsBusy(void) { return m_bBusy; }

    //
    // Lock and unlock the drawing area
    //
    BOOL IsLocked (void) { return m_bLocked; }
    void SetLock(BOOL bLock){ m_bLocked = bLock; }
    void Unlock   (void);
    void Lock     (void);

    BOOL IsSynced (void) { return m_bSync; }
    void SetSync(BOOL bSync) { m_bSync = bSync; }

    //
    // Realize the drawing area's palette
    //
    void RealizePalette( BOOL bBackground );//CHANGED BY RAND

    //
    // Selection functions
    //
    void SelectTool(WbTool* pToolNew);  // Select drawing tool

    //
    // Update the selected object
    //
    void SetSelectionColor (COLORREF clr);         // Change color
    void SetSelectionWidth (UINT uiNewWidth);  // Select pen width
    void SetSelectionFont  (HFONT hFont);       // Select font

    //
    // External update functions
    //
    void PageCleared(void);

    //
    // Query functions
    //
    // Ask whether an object is currently selected
    BOOL GraphicSelected(void);

    // Return the currently selected graphic
    T126Obj* GetSelection(void);

	// Clear current (multi object) selection
	void ClearSelection( void );

	T126Obj *GetHitObject( POINT surfacePos )
		{return( PG_SelectLast(g_pCurrentWorkspace, surfacePos) );}


    // Ask whether the drawing area is zoomed
    BOOL Zoomed(void) { return (m_iZoomFactor != 1); }

    // Ask whether the drawing area is zoomed
    int ZoomOption(void) { return (m_iZoomOption); }
    int ZoomFactor(void) { return (m_iZoomFactor); }

    //
    // Complete a text object
    //
    void EndTextEntry(BOOL bAccept);

    // Ask whether the text editor is active
    BOOL TextEditActive(void) { return m_bTextEditorActive; }

	// text editor clipboard
	void   TextEditCopy( void )	{m_pTextEditor->Copy();}

	void   TextEditCut( void ) 	{m_pTextEditor->Cut();}

	void   TextEditPaste( void ) {m_pTextEditor->Paste();}

	// Resets text editor for window resizing
	void TextEditParentResize( void )
		{m_pTextEditor->ParentResize();}

	// Redraws editbox
	void RedrawTextEditbox(void)
		{m_pTextEditor->RedrawEditbox();}

	// Gets editbox bounding rect
	void GetTextEditBoundsRect(LPRECT lprc)
		{ m_pTextEditor->GetBoundsRect(lprc); }

    // Return the rectangle currently being viewed i.e. that portion of
    // the page surface that is within the window client area.
    void    GetVisibleRect(LPRECT lprc);

	// Select objects inside rectSelect or ALL if rect is NULL
	void SelectMarkerFromRect(LPCRECT lprcSelect);
    DrawObj *GetMarker( void )
		{return( m_pMarker );}

    T126Obj* SelectPreviousGraphicAt(T126Obj* pGraphic, POINT point);

	void SetLClickIgnore( BOOL bIgnore )
		{m_bIgnoreNextLClick = bIgnore;}


    //
    // Action members
    //
    void  Attach(WorkspaceObj * pNewWorkspace);    // Attach a new page to the window
    void  Detach(void) { Attach(NULL); }   // Attach the empty page

    void  DeleteSelection(void);           // Delete selected graphic

    LRESULT  BringToTopSelection(BOOL editedLocally, T126Obj * pT126Obj = NULL);       // Bring selected graphic to top
	LRESULT  SendToBackSelection(BOOL editedLocally, T126Obj * pT126Obj = NULL);       // Send selected graphic to back

    void  Clear(void);                     // Clear the workspace

    void  Zoom(void);                      // Zoom the drawing area

    void GotoPosition(int x, int y); // Set scroll position

	// select an object
    void SelectGraphic(T126Obj* pGraphic, 
						 BOOL bEnableForceAdd=FALSE, //CHANGED BY RAND
						 BOOL bForceAdd=FALSE );	 //CHANGED BY RAND


	BOOL MoveSelectedGraphicBy(LONG x, LONG y);
	void EraseInitialDrawFinal(LONG x, LONG y, BOOL editedLocally, T126Obj* pObj = NULL);
	void EraseSelectedDrawings();

    //
	//
    // Convert between surface and client co-ordinates
    //
    void SurfaceToClient(LPPOINT lppt);
    void ClientToSurface(LPPOINT lppt);
    void SurfaceToClient(LPRECT lprc);
    void ClientToSurface(LPRECT lprc);
    void MoveOntoSurface(LPPOINT lppt);
    void GetOrigin(LPPOINT lppt);
	T126Obj* GetSelectedGraphic (void){ return m_pSelectedGraphic;}

    //
    // Invalidate the client area rectangle corresponding to the surface
    // rectangle specified.
    //
    void InvalidateSurfaceRect(LPCRECT lprc, BOOL bErase);

    HDC  GetCachedDC  (void) const {return(m_hDCCached); }
    void PrimeFont   (HDC hDC, HFONT hFont, TEXTMETRIC* pTextMetrics);
    void UnPrimeFont (HDC hDC);

    void DrawMarker   (HDC hDC);
    void PutMarker    (HDC hDC, BOOL bDraw = TRUE );
    void RemoveMarker (void);

    //
    // Cancel a drawing operation.
    //
    void CancelDrawingMode(void);

    friend LRESULT CALLBACK DrawWndProc(HWND, UINT, WPARAM, LPARAM);

    //
    // Windows message handling
    //
    void OnPaint(void);
    void OnMouseMove(UINT flags, int x, int y);
    void OnLButtonDown(UINT flags, int x, int y);
    void OnLButtonUp(UINT flags, int x, int y);
    void OnRButtonDown(UINT flags, int x, int y);
    void OnSize(UINT flags, int cx, int cy);
    void OnHScroll(UINT code, UINT pos);
    void OnVScroll(UINT code, UINT pos);
    LRESULT OnEditColor(HDC hdc);
    void OnSetFocus(void);
    void OnActivate(UINT flags);
    LRESULT OnCursor(HWND hwnd, UINT hitTest, UINT msg);
    void OnTimer(UINT idTimer);
    void OnCancelMode(void);
    void OnContextMenu(int xScreen, int yScreen);

protected:
    //
    // Set the cursor to be used in the drawing area for the current state
    //
    BOOL SetCursorForState(void);

    //
    // Setup functions for the various drawing operations
    //
    BOOL RemotePointerSelect (POINT mousePos);
    void BeginSelectMode     (POINT mousePos, 
									BOOL bDontDrag );
    void BeginDeleteMode     (POINT mousePos);
    void BeginTextMode       (POINT mousePos);

    //
    // Mouse tracking functions. These are called for each mouse move event
    // (depending on the current drawing mode).
    //
    void TrackSelectMode    (POINT mousePos);
    void TrackDeleteMode    (POINT mousePos);

    //
    // Completion functions for the various mode drawing operations.
    //
    void CompleteSelectMode();
    void CompleteDeleteMode();
    void CompleteMarkAreaMode();
    void CompleteTextMode();

	void BeginDrawingMode(POINT surfacePos);
	void TrackDrawingMode(POINT surfacePos);
	void CompleteDrawingMode();

    //
    // Scroll the workspace to scrollPosition
    //
    void ScrollWorkspace   (void);
    void DoScrollWorkspace (void);
    BOOL   AutoScroll(int xPos, int yPos, BOOL bMoveCursor, int xCaret, int yCaret);

    //
    // Graphic object selection and marker manipulation
    //
    void DeselectGraphic(void);

    //
    // Remote pointer manipulation
    //

    //
    // Redraw the pointers in the list specified. The pointers are drawn
    // from the start of the list to the end. If a NULL pointer is
    // specified, the undrawnPointers list is used.
    //
    void PutPointers(HDC hDC, COBLIST* pDrawList = NULL);

    void PrimeDC   (HDC hDC);
    void UnPrimeDC (HDC hDC);

    //
    // Flag indicating that the drawing area is busy or locked
    //
    BOOL        m_bBusy;
    BOOL        m_bLocked;
	BOOL        m_HourGlass; // we're busy doing something local
	BOOL		m_bSync;

    //
    // Saved drawing attributes
    //
    HPEN        m_hOldPen;
    HBRUSH      m_hOldBrush;
    HPALETTE    m_hOldPalette;
    HFONT       m_hOldFont;
    HFONT       m_hCurFont;

    //
    // Current offset of the client region of the window onto the picture
    //
    RECT        m_rcSurface;

public:
    SIZE        m_originOffset;
    HWND        m_hwnd;

    //
    // Saved drawing attributes
    //
    HDC         m_hDCCached;
    HDC         m_hDCWindow;

    HBRUSH		m_hMarkerBrush;
	RECT		m_selectorRect;
    WbTextEditor* m_pTextEditor;
    void DeactivateTextEditor(void);

protected:
    //
    // Scrolling control
    //
    void   SetScrollRange(int cx, int cy);
    void   ValidateScrollPos(void);

    POINT   m_posScroll;
    POINT   m_posZoomScroll;
    BOOL    m_zoomRestoreScroll;

    //
    // Start and end points of most recent drawing operation
    //
    POINT   m_ptStart;
    POINT   m_ptEnd;

    //
    // Current drawing tool
    //
    WbTool * m_pToolCur;

    //
    // Mouse button down flag
    //
    BOOL    m_bLButtonDown;

    //
    // Graphics object pointer used for tracking object
    //
    DrawObj* m_pGraphicTracker;

    //
    // Tick count used to determine when it is time to update the external
    // copy of a graphic.
    //
    DWORD   m_dwTickCount;

    //
    // Marker for selection mode
    //
    DrawObj* m_pMarker;
    T126Obj* m_pSelectedGraphic;
    BOOL m_bMarkerPresent;
    BOOL m_bNewMarkedGraphic;

	BOOL m_bTrackingSelectRect; 

    //
    // Text editor control
    //
    BOOL        m_bTextEditorActive;
//    TextObj* 	m_pActiveText;

    void ActivateTextEditor( BOOL bPutUpCusor ); 

    //
    // Text cursor control
    //
    BOOL        m_bGotCaret;

    //
    // Currently marked area
    //
    RECT    m_rcMarkedArea;

    //
    // Zoom variables
    //
    int     m_iZoomFactor;                   // Current zoom factor
    int     m_iZoomOption;                   // Zoom factor to be used


    HCURSOR m_hCursor;                    // handle of last cursor we displayed
                                        // (or null if normal arrow cursor)
	BOOL    m_bIgnoreNextLClick;

};


#endif // __DRAW_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\ms_util.cpp ===
#include "precomp.h"


CRefCount::CRefCount(DWORD dwStampID)
:
#ifndef SHIP_BUILD
    m_dwStampID(dwStampID),
#endif
    m_cRefs(1)
{
}


// though it is pure virtual, we still need to have a destructor.
CRefCount::~CRefCount(void)
{
}


LONG CRefCount::AddRef(void)
{
    ASSERT(0 < m_cRefs);
    ::InterlockedIncrement(&m_cRefs);
    return m_cRefs;
}


LONG CRefCount::Release(void)
{
    ASSERT(NULL != this);
    ASSERT(0 < m_cRefs);
    if (0 == ::InterlockedDecrement(&m_cRefs))
    {
        delete this;
        return 0;
    }
    return m_cRefs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\ms_util.h ===
#ifndef __MS_UTIL_H__
#define __MS_UTIL_H__

//
// GUI message boxes kill us when we hit an assert or error, because they
// have a message pump that causes messages to get dispatched, making it
// very difficult for us to debug problems when they occur.  Therefore
// we redefine ERROR_OUT and ASSERT
//
#ifdef _DEBUG

__inline void MyDebugBreak(void) { DebugBreak(); }

#endif // _DEBUG



// the following create a dword that will look like "abcd" in debugger
#ifdef SHIP_BUILD
#define MAKE_STAMP_ID(a,b,c,d)     
#else
#define MAKE_STAMP_ID(a,b,c,d)     MAKELONG(MAKEWORD(a,b),MAKEWORD(c,d))
#endif // SHIP_BUILD

class CRefCount
{
public:

#ifdef SHIP_BUILD
    CRefCount(void);
#else
    CRefCount(DWORD dwStampID);
#endif
    virtual ~CRefCount(void) = 0;

    LONG AddRef(void);
    LONG Release(void);

protected:

    LONG GetRefCount(void) { return m_cRefs; }
    BOOL IsRefCountZero(void) { return (0 == m_cRefs); }

private:

#ifndef SHIP_BUILD
    DWORD       m_dwStampID;// to remove before we ship it
#endif
    LONG        m_cRefs;    // reference count
};


__inline void My_CloseHandle(HANDLE hdl)
{
    if (NULL != hdl)
    {
        CloseHandle(hdl);
    }
}


#endif // __MS_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\gcchelp.cpp ===
//
// GCCHELP.CPP
// GCC helper functions
//
// Copyright Microsoft 1998-
//


// PRECOMP
#include "precomp.h"
#include "gcchelp.h"

void	T126_GCCAllocateHandleConfirm(ULONG drawingHandle, ULONG handle_range)
{
	g_WaitingForGCCHandles = FALSE;
	TRACE_MSG(("T126_GCCAllocateHandleConfirm drawing handle = %d, range = %d", drawingHandle, handle_range));

	TRACE_MSG(("GCC Tank 0 has %d GCC handles ", g_GCCPreallocHandles[0].GccHandleCount));
	TRACE_MSG(("GCC Tank 1 has %d GCC handles ", g_GCCPreallocHandles[1].GccHandleCount));

	ULONG gccHandle;
	if(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount == 0)
	{
		TRACE_MSG(("Using GCC Tank %d ", g_iGCCHandleIndex));

		g_GCCPreallocHandles[g_iGCCHandleIndex].InitialGCCHandle = drawingHandle;
		g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount = handle_range;
	}
	else
	{
		UINT index = g_iGCCHandleIndex ? 0 : 1;
		TRACE_MSG(("T126_GCCAllocateHandleConfirm: Using GCC Tank %d that contains %d handles",
							index, g_GCCPreallocHandles[index].GccHandleCount ));
		TRACE_MSG(("Filling up GCC Tank %d ", index));
		g_GCCPreallocHandles[index].InitialGCCHandle = drawingHandle;
		g_GCCPreallocHandles[index].GccHandleCount = handle_range;
	}

	if(handle_range <= 2)
	{
		gccHandle = g_GCCPreallocHandles[g_iGCCHandleIndex].InitialGCCHandle + g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - handle_range;
		g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount = g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - handle_range;

		//
		// Remove the drawing object from the list of objects to send
		//
		T126Obj * pT126Obj = (T126Obj*)g_pListOfObjectsThatRequestedHandles->RemoveTail();

		if(!pT126Obj)
		{
			return;
		}

		pT126Obj->GotGCCHandle(gccHandle);

	}
	else
	{
		
		if(handle_range != PREALLOC_GCC_HANDLES)
		{

			//
			// Resend all objects
			//
			WBPOSITION pos;
			WBPOSITION posObj;
			WorkspaceObj* pWorkspace;
			ULONG	workspaceHandle;
			T126Obj* pObj;

			pos = g_pListOfWorkspaces->GetHeadPosition();

			while(pos)
			{
				gccHandle = g_GCCPreallocHandles[g_iGCCHandleIndex].InitialGCCHandle + g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - 2;
				
				if(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount == 0)
				{
					//
					// Time to switch to the other tank
					//
					g_iGCCHandleIndex =  g_iGCCHandleIndex ? 0 : 1;
				}
					
				
				ASSERT(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount);
				g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount -=2;
				
				workspaceHandle = gccHandle;
				pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
				pWorkspace->SetThisObjectHandle(workspaceHandle);
				pWorkspace->SetWorkspaceHandle(workspaceHandle);
				pWorkspace->SetOwnerID(g_MyMemberID);
				pWorkspace->SetViewHandle(workspaceHandle + 1);

				posObj = pWorkspace->GetHeadPosition();
				while(posObj)
				{
					pObj = pWorkspace->GetNextObject(posObj);
					if(pObj)
					{
						gccHandle = g_GCCPreallocHandles[g_iGCCHandleIndex].InitialGCCHandle + g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - 1;
						ASSERT(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount);
						g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount--;
						pObj->SetThisObjectHandle(gccHandle);
						pObj->SetWorkspaceHandle(workspaceHandle);
						pObj->SetOwnerID(g_MyMemberID);
					}
				}
			}
		}
	}


	//
	// Check if we have enough handles or shoul switch
	//
	TimeToGetGCCHandles(PREALLOC_GCC_HANDLES);
	SetFakeGCCHandle(drawingHandle + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\globals.h ===
//
// Global variables
//

extern WbMainWindow *   g_pMain;
extern HINSTANCE    g_hInstance;
extern UINT         g_uConfShutdown;
extern HPALETTE     g_hRainbowPaletteDisplay;
extern WbPrinter *  g_pPrinter;
extern HINSTANCE        g_hImmLib;
extern IGC_PROC         g_fnImmGetContext;
extern INI_PROC         g_fnImmNotifyIME;


//extern "C" int _fltused;
extern int __cdecl atexit (void);


enum
{
    CLIPBOARD_PRIVATE = 0,
    CLIPBOARD_DIB,
    CLIPBOARD_ENHMETAFILE,
    CLIPBOARD_TEXT,
    CLIPBOARD_ACCEPTABLE_FORMATS
};



//
// GCC handle allocation
//
#define PREALLOC_GCC_HANDLES 256
#define PREALLOC_GCC_BUFFERS 2

typedef struct tagGCCPrealloc
{
	ULONG InitialGCCHandle;
	ULONG GccHandleCount;
} GCCPREALOC;

extern GCCPREALOC g_GCCPreallocHandles[];
extern UINT g_iGCCHandleIndex;
extern BOOL g_WaitingForGCCHandles;



#define MAX_BITS_PERPIXEL 8 // Specifies the number of bits per pixel ASN1 allows

extern int         g_ClipboardFormats[CLIPBOARD_ACCEPTABLE_FORMATS];

extern BOOL         g_bPalettesInitialized;
extern BOOL         g_bUsePalettes;
extern UINT         g_PenWidths[NUM_OF_WIDTHS];
extern UINT         g_HighlightWidths[NUM_OF_WIDTHS];


#define NUM_COLOR_ENTRIES   21
extern COLORREF     g_ColorTable[NUM_COLOR_ENTRIES];


//
// Complex object globals
//
extern WbDrawingArea*		g_pDraw;
extern DCWbColorToIconMap*	g_pIcons;

extern UINT			g_numberOfWorkspaces;
extern UINT			g_numberOfObjects;
extern CWBOBLIST*	g_pListOfWorkspaces;
extern CWBOBLIST*	g_pListOfObjectsThatRequestedHandles;
extern CWBOBLIST*	g_pRetrySendList;
extern BOOL			g_fWaitingForBufferAvailable;
extern CWBOBLIST*	g_pTrash;
extern UINT			g_localGCCHandle;
extern WorkspaceObj*g_pCurrentWorkspace;
extern WorkspaceObj*g_pConferenceWorkspace;
extern ULONG		g_MyMemberID;
extern ULONG		g_RefresherID;
extern UINT			g_MyIndex;
extern COLORREF 	g_crDefaultColors[];
extern BOOL			g_bSavingFile;
extern BOOL			g_bContentsChanged;
extern Coder *		g_pCoder;
extern DWORD g_dwWorkThreadID;




#define WB_MAX_WORKSPACES 256

class CNMWbObj;

extern CNMWbObj * g_pNMWBOBJ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\mcshelp.h ===
//
// MCSHELP.H
// MCS Helper functions
//
// Copyright Microsoft 1998-
//
#include "imcsapp.h"

#include "mcatmcs.h"	// For MAX_MCS_DATA_SIZE
#define     _MAX_MCS_MESSAGE_SIZE	64000
#define		_MAX_MCS_PDU_SIZE		MAX_MCS_DATA_SIZE
#define 	ObjectIDNode  unsigned long

// From T120 recomendation
#define _SI_CHANNEL_0                    8  
#define _SI_BITMAP_CREATE_TOKEN			 8
#define	_SI_WORKSPACE_REFRESH_TOKEN		 9

//Default values
#define INVALID_SAMPLE_RATE - 1


// Prototypes
BOOL T126_MCSSendDataIndication(ULONG uSize, LPBYTE pb, ULONG memberID, BOOL bResend);
BOOL AddT126ObjectToWorkspace(T126Obj *pObj);
UINT AllocateFakeGCCHandle(void);
void SetFakeGCCHandle(UINT fakeHandle);
WorkspaceObj * GetWorkspace(UINT activeWorkspace);
BOOL FindObjectAndWorkspace(UINT objectHandle, T126Obj**  pObj, WorkspaceObj** pWorkspace);

//
// From transport to UI
//

//
// DrawingPDUs
//
void	OnDrawingCreatePDU(DrawingCreatePDU * pdrawingCreatePDU, ULONG memberID, BOOL bResend);
void	OnDrawingEditPDU(DrawingEditPDU * pdrawingEditPDU, ULONG memberID, BOOL bResend);
void	OnDrawingDeletePDU(DrawingDeletePDU * pdrawingDeletePDU, ULONG memberID);

//
// TextPDUs
//
void	OnTextCreatePDU(MSTextPDU* pCreatePDU, ULONG memberID, BOOL bForcedResend);;
void	OnTextEditPDU(MSTextPDU *pEditPDU, ULONG memberID);
void	OnTextDeletePDU(TEXTPDU_HEADER *pHeader, ULONG memberID);

//
// WorkspacePDUs
//
void OnWorkspaceCreatePDU(WorkspaceCreatePDU * pWorkspaceCreatePDU, ULONG memberID, BOOL bResend);
void OnWorkspaceCreateAcknowledgePDU(WorkspaceCreateAcknowledgePDU * pWorkspaceCreateAcknowledgePDU, ULONG memberID);
void OnWorkspaceDeletePDU(WorkspaceDeletePDU * pWorkspaceDeletePDU, ULONG memberID);
void OnWorkspaceEditPDU(WorkspaceEditPDU * pWorkspaceEditPDU, ULONG memberID);
void OnWorkspacePlaneCopyPDU(WorkspacePlaneCopyPDU * pWorkspacePlaneCopyPDU, ULONG memberID);
void OnWorkspaceReadyPDU(WorkspaceReadyPDU * pWorkspaceReadyPDU, ULONG memberID);
void OnWorkspaceRefreshStatusPDU(WorkspaceRefreshStatusPDU * pWorkspaceRefreshStatusPDU, ULONG memberID);

//
// BitmapPDUs
//
void	OnBitmapCreatePDU(BitmapCreatePDU * pBitmapCreatePDU, ULONG memberID, BOOL bResend);
void	OnBitmapCreateContinuePDU(BitmapCreateContinuePDU * pBitmapCreateContinuePDU, ULONG memberID, BOOL bForcedResend);
void	OnBitmapCheckpointPDU(BitmapCheckpointPDU * pBitmapCheckPointPDU, ULONG memberID);
void	OnBitmapAbortPDU(BitmapAbortPDU * pBitmapAbortPDU, ULONG memberID);
void	OnBitmapEditPDU(BitmapEditPDU * pBitmapEditPDU, ULONG memberID);
void	OnBitmapDeletePDU(BitmapDeletePDU * pBitmapDeletePDU, ULONG memberID);

void	DeleteAllWorkspaces(BOOL sendPDU);

void RetrySend(void);
T120Error  	SendT126PDU(SIPDU * pPDU);
T120Error   SendPDU(SIPDU * pPDU, BOOL bRetry);
void SIPDUCleanUp(SIPDU *sipdu);
void DeleteAllRetryPDUS(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\main.cpp ===
//
// MAIN.CPP
// Whiteboard Windows App Code
//
// Copyright Microsoft 1998-
//


// PRECOMP
#include "precomp.h"
#include <it120app.h>
#include <regentry.h>
#include "gccmsg.h"
#include "coder.hpp"
#include "NMWbObj.h"
#include "wbloader.h"

Coder * g_pCoder;

WbMainWindow *  g_pMain;
HINSTANCE   g_hInstance;
UINT        g_uConfShutdown;
WbPrinter * g_pPrinter;
BOOL        g_bPalettesInitialized;
BOOL        g_bUsePalettes;
HPALETTE    g_hRainbowPaletteDisplay;
DWORD		g_dwWorkThreadID = 0;
DWORD __stdcall WBWorkThreadProc(LPVOID lpv);

HINSTANCE   g_hImmLib;
IGC_PROC    g_fnImmGetContext;
INI_PROC    g_fnImmNotifyIME;

extern HANDLE g_hWorkThread;

//
// Arrays
//
COLORREF    g_ColorTable[NUM_COLOR_ENTRIES] =
{
    RGB(  0, 255, 255),                   // Cyan
    RGB(255, 255,   0),                   // Yellow
    RGB(255,   0, 255),                   // Magenta
    RGB(  0,   0, 255),                   // Blue
    RGB(192, 192, 192),                   // Grey
    RGB(255,   0,   0),                   // Red
    RGB(  0,   0, 128),                   // Dark blue
    RGB(  0, 128, 128),                   // Dark cyan
    RGB(  0, 255,   0),                   // Green
    RGB(  0, 128,   0),                   // Dark green
    RGB(128,   0,   0),                   // Dark red
    RGB(128,   0, 128),                   // Purple
    RGB(128, 128,   0),                   // Olive
    RGB(128, 128, 128),                   // Grey
    RGB(255, 255, 255),                   // White
    RGB(  0,   0,   0),                   // Black
    RGB(255, 128,   0),                   // Orange
    RGB(128, 255, 255),                   // Turquoise
    RGB(  0, 128, 255),                   // Mid blue
    RGB(  0, 255, 128),                   // Pale green
    RGB(255,   0, 128)                    // Dark pink
};


int g_ClipboardFormats[CLIPBOARD_ACCEPTABLE_FORMATS] =
{
    0,                   // CLIPBOARD_PRIVATE - Reserved for the T126 whiteboard private format
    CF_DIB,              // Standard formats
    CF_ENHMETAFILE,	   // move metafiles to lower pri than bitmaps (bug NM4db:411)
    CF_TEXT
};



// Default widths for all tools except for highlighters
UINT g_PenWidths[NUM_OF_WIDTHS] = { 2, 4, 8, 16 };

// Default widths for highlight tools
UINT g_HighlightWidths[NUM_OF_WIDTHS] = { 4, 8, 16, 32 };

//
// Objects
//
WbDrawingArea *         g_pDraw;
DCWbColorToIconMap *    g_pIcons;
UINT					g_localGCCHandle;		// This is a fake GCC handle used when we are not in a conference

#ifdef _DEBUG
HDBGZONE    ghZoneWb;

PTCHAR      g_rgZonesWb[] = // CHECK ZONE_WBxxx CONSTANTS IF THESE CHANGE
{
    "NewWB",
    DEFAULT_ZONES
	"DEBUG",
	"MSG",
	"TIMER",
	"EVENT"
};
#endif // _DEBUG


//
// Mapping of internal return codes to string resources                     
//
typedef struct tagERROR_MAP
{
    UINT uiFEReturnCode;
    UINT uiDCGReturnCode;
    UINT uiCaption;
    UINT uiMessage;
}
ERROR_MAP;


ERROR_MAP g_ErrorStringID[] =
{
  { WBFE_RC_JOIN_CALL_FAILED,           // Registration failed
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_JOIN_CALL_FAILED
  },

  { WBFE_RC_WINDOWS,                    // A windows error has occurred
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_WINDOWS_RESOURCES
  },

  { WBFE_RC_WB,                         // Page limit exceeded
    WB_RC_TOO_MANY_PAGES,
    IDS_MSG_CAPTION,
    IDS_MSG_TOO_MANY_PAGES
  },

  { WBFE_RC_WB,          // Another user has the contents lock
    WB_RC_LOCKED,
    IDS_MSG_CAPTION,
    IDS_MSG_LOCKED
  },

  { WBFE_RC_WB,          // Another user has the graphic locked
    WB_RC_GRAPHIC_LOCKED,
    IDS_MSG_CAPTION,
    IDS_MSG_GRAPHIC_LOCKED,
  },

  { WBFE_RC_WB,          // The local user does not have the lock
    WB_RC_NOT_LOCKED,
    IDS_MSG_CAPTION,
    IDS_MSG_NOT_LOCKED
  },

  { WBFE_RC_WB,          // File is not in expected format
    WB_RC_BAD_FILE_FORMAT,
    IDS_MSG_CAPTION,
    IDS_MSG_BAD_FILE_FORMAT
  },

  { WBFE_RC_WB,          // File is not in expected format
    WB_RC_BAD_STATE,
    IDS_MSG_CAPTION,
    IDS_MSG_BAD_STATE_TO_LOAD_FILE
  },


  { WBFE_RC_WB,          // Whiteboard busy (exhausted page cache)
    WB_RC_BUSY,
    IDS_MSG_CAPTION,
    IDS_MSG_BUSY
  },

  { WBFE_RC_CM,          // Failed to access call manager
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_CM_ERROR
  },

  { WBFE_RC_AL,          // Failed to register with application loader
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_AL_ERROR
  },

  { WBFE_RC_PRINTER,     // Failed to register with application loader
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_PRINTER_ERROR
  },

  { 0,                   // Catch-all default
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_DEFAULT
  }
};




//
//                                                                          
// Function:    Message                                                     
//                                                                          
// Purpose:     Display an error message box with string resources specified
//              as parameters, with the WB main window as the modal window. 
//                                                                          
//
int Message
(
    HWND    hwnd,
    UINT    uiCaption,
    UINT    uiMessage,
    UINT    uiStyle
)
{
    TCHAR   message[256];
    TCHAR   caption[256];

	//make sure we're on top
    ASSERT(g_pMain);
    if (!hwnd)
        hwnd = g_pMain->m_hwnd;

    if (hwnd != NULL)
    {
		::SetForegroundWindow(hwnd);
    }

    LoadString(g_hInstance, uiMessage, message, 256);

    LoadString(g_hInstance, uiCaption, caption, 256);

    //
    // BOGUS LAURABU:
    // Make use of MessageBoxEx() and just pass the string IDs along, 
    // rather than doing the LoadString() ourself.
    //

    // Display a message box with the relevant text
	return(::MessageBox(hwnd, message, caption, uiStyle));
}



//
//                                                                          
// Function:    ErrorMessage                                                
//                                                                          
// Purpose:     Display an error based on return codes from Whiteboard      
//              processing.                                                 
//                                                                          
//
void ErrorMessage(UINT uiFEReturnCode, UINT uiDCGReturnCode)
{
    MLZ_EntryOut(ZONE_FUNCTION, "::ErrorMessage (codes)");

    TRACE_MSG(("FE return code  = %hd", uiFEReturnCode));
    TRACE_MSG(("DCG return code = %hd", uiDCGReturnCode));

    // Find the associated string resource IDS
    int iIndex;

    for (iIndex = 0; ; iIndex++)
    {
        // If we have come to the end of the list, stop
        if (g_ErrorStringID[iIndex].uiFEReturnCode == 0)
        {
            break;
        }

        // Check for a match
        if (g_ErrorStringID[iIndex].uiFEReturnCode == uiFEReturnCode)
        {
            if (   (g_ErrorStringID[iIndex].uiDCGReturnCode == uiDCGReturnCode)
                || (g_ErrorStringID[iIndex].uiDCGReturnCode == 0))
            {
                break;
            }
        }
    }

    // Display the message
    Message(NULL, g_ErrorStringID[iIndex].uiCaption, g_ErrorStringID[iIndex].uiMessage);
}



//
//                                                                          
// Function:    DefaultExceptionHandler                                     
//                                                                          
// Purpose:     Default exception processing. This can be called in an      
//              exception handler to get a message relevant to the          
//              exception. The message is generated by posting a message to 
//              the applications main window.                               
//                                                                          
//
void DefaultExceptionHandler(UINT uiFEReturnCode, UINT uiDCGReturnCode)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DefaultExceptionHandler");

    // Post a message to the main window to get the error displayed
    if (g_pMain != NULL)
    {
        if (g_pMain->m_hwnd)
            ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, uiFEReturnCode, uiDCGReturnCode);
    }
}


BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID lpv)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hDllInst;
        DisableThreadLibraryCalls(hDllInst);
		g_dwWorkThreadID = 0;
		

#ifdef _DEBUG
            MLZ_DbgInit((PSTR *) &g_rgZonesWb[0],
            (sizeof(g_rgZonesWb) / sizeof(g_rgZonesWb[0])) - 1);
#endif

        DBG_INIT_MEMORY_TRACKING(hDllInst);
        g_pCoder = new Coder; 

        ::T120_AppletStatus(APPLET_ID_WB, APPLET_LIBRARY_LOADED);
        break;

    case DLL_PROCESS_DETACH:

        if (NULL != g_hWorkThread)
        {
            ::CloseHandle(g_hWorkThread);
        }
        ::T120_AppletStatus(APPLET_ID_WB, APPLET_LIBRARY_FREED);
		g_hInstance = NULL;
		g_dwWorkThreadID = 0;

		if(g_pCoder)
		{
			delete g_pCoder;
			g_pCoder = NULL;
		}

        DBG_CHECK_MEMORY_TRACKING(hDllInst);

#ifdef _DEBUG
            MLZ_DbgDeInit();
#endif

        break;

    default:
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\mcshelp.cpp ===
#include "precomp.h"
#include "gcchelp.h"
#include "coder.hpp"
#include "drawobj.hpp"
#include "NMWbObj.h"

extern Coder * g_pCoder;

UINT AllocateFakeGCCHandle(void)
{
	return g_localGCCHandle++;
}

void SetFakeGCCHandle(UINT fakeGCCHandle)
{
	g_localGCCHandle = fakeGCCHandle;
}

//
// Add drawings/bitmaps etc... to workspace
//
BOOL AddT126ObjectToWorkspace(T126Obj *pObj)
{
	WorkspaceObj * pWorkspace =	GetWorkspace(pObj->GetWorkspaceHandle());
	if(pWorkspace)
	{	
		pWorkspace->AddTail(pObj);
		g_numberOfObjects++;
		return TRUE;
	}
	else
	{
		WARNING_OUT(("Object sent to invalid workspace %d, will be deleted now!!!", GetWorkspace(pObj->GetWorkspaceHandle())));
		delete pObj;
		return FALSE;
	}
}

//
// Cleanup for all pdus we send
//
void SIPDUCleanUp(SIPDU *sipdu)
{
	switch(sipdu->choice)
	{
		//
		// Simple cleanup
		//
		case bitmapDeletePDU_chosen:
		case drawingDeletePDU_chosen:
		case workspaceDeletePDU_chosen:
		case workspaceRefreshStatusPDU_chosen:
		break;

		//
		// Bitmap Create cleanup
		//
		case bitmapCreatePDU_chosen:
		{
			if(sipdu->u.bitmapCreatePDU.nonStandardParameters)
			{
				delete sipdu->u.bitmapCreatePDU.nonStandardParameters;
			}

			PBitmapCreatePDU_attributes pAttrib;
			PBitmapCreatePDU_attributes pNextAttrib;
			pAttrib = sipdu->u.bitmapCreatePDU.attributes;
			while(pAttrib)
			{
				pNextAttrib = pAttrib->next;
				delete pAttrib;
				pAttrib = pNextAttrib;
			}
		}
		break;


		case bitmapEditPDU_chosen:
		{
			BitmapEditPDU_attributeEdits * pAttrib;
			BitmapEditPDU_attributeEdits * pNextAttrib;
			pAttrib = sipdu->u.bitmapEditPDU.attributeEdits;
			while(pAttrib)
			{
				pNextAttrib = pAttrib->next;
				delete pAttrib;
				pAttrib = pNextAttrib;
			}
		}
		break;


		//
		// Bitmap Continue cleanup
		//
		case bitmapCreateContinuePDU_chosen:
		{
			if(sipdu->u.bitmapCreateContinuePDU.nonStandardParameters)
			{
				delete sipdu->u.bitmapCreateContinuePDU.nonStandardParameters;
			}
		}
		break;

		//
		// Drawing Edit Cleanup
		//
		case drawingEditPDU_chosen:
		{
			if(sipdu->u.drawingEditPDU.bit_mask & DrawingEditPDU_attributeEdits_present)
			{
				PDrawingEditPDU_attributeEdits pAttrib;
				PDrawingEditPDU_attributeEdits pNextAttrib;
				pAttrib = sipdu->u.drawingEditPDU.attributeEdits;
				while(pAttrib)
				{
					pNextAttrib = pAttrib->next;
					delete pAttrib;
					pAttrib = pNextAttrib;
				}
			}

			if(sipdu->u.drawingEditPDU.pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16)
			{
				PPointList_pointsDiff16 drawingPoint = sipdu->u.drawingEditPDU.pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16;
				PPointList_pointsDiff16 drawingPointNext = drawingPoint; 
				while(drawingPointNext)
				{
					drawingPointNext = drawingPoint->next;
					delete drawingPoint;
					drawingPoint = drawingPointNext;
				}
			}
		}
		break;


		//
		// Drawing Edit cleanup
		//
		case drawingCreatePDU_chosen:
		{
			PDrawingCreatePDU_attributes pNextAttrib;
			PDrawingCreatePDU_attributes pAttrib;

			pAttrib = sipdu->u.drawingCreatePDU.attributes;
			while(pAttrib)
			{
				pNextAttrib = pAttrib->next;
				delete pAttrib;
				pAttrib = pNextAttrib;
			}

			PPointList_pointsDiff16 pNextPoint;
			PPointList_pointsDiff16 pPoint;
			pPoint = sipdu->u.drawingCreatePDU.pointList.u.pointsDiff16;

			while(pPoint)
			{
				pNextPoint = pPoint->next;
				delete pPoint;
				pPoint = pNextPoint;
			}
		}
		break;


		//
		// Non Standard cleanup
		//
		case siNonStandardPDU_chosen:
		if(sipdu->u.siNonStandardPDU.nonStandardTransaction.data.value)
		{
			delete sipdu->u.siNonStandardPDU.nonStandardTransaction.data.value;
		}
		break;


		//
		// Workspace Edit cleanup
		//
		case workspaceEditPDU_chosen:
		{
			if(sipdu->u.workspaceEditPDU.bit_mask & viewEdits_present)
			{
				PWorkspaceEditPDU_viewEdits_Set_action_editView pEditView = sipdu->u.workspaceEditPDU.viewEdits->value.action.u.editView;
				PWorkspaceEditPDU_viewEdits_Set_action_editView pNextEditView = pEditView;
				while(pNextEditView)
				{
					pNextEditView = pEditView->next;
					delete pEditView;
					pEditView = pNextEditView;
				}
				delete sipdu->u.workspaceEditPDU.viewEdits;
			}
		}
		break;
		

		//
		// Workspace Create cleanup
		//
		case workspaceCreatePDU_chosen:
		{

			if(sipdu->u.workspaceCreatePDU.viewParameters)
			{
				if(sipdu->u.workspaceCreatePDU.viewParameters->value.viewAttributes)
				{
					delete sipdu->u.workspaceCreatePDU.viewParameters->value.viewAttributes;
				}
				delete sipdu->u.workspaceCreatePDU.viewParameters;
			}

			if(sipdu->u.workspaceCreatePDU.planeParameters)
			{
				PWorkspaceCreatePDU_planeParameters_Seq_usage pNextUsage;
				PWorkspaceCreatePDU_planeParameters_Seq_usage pUsage = sipdu->u.workspaceCreatePDU.planeParameters->value.usage;
				while(pUsage)
				{
					pNextUsage = pUsage->next;
					delete pUsage;
					pUsage = pNextUsage;
				}

				delete sipdu->u.workspaceCreatePDU.planeParameters->value.planeAttributes;
				PWorkspaceCreatePDU_planeParameters pNextPlaneParameters;
				PWorkspaceCreatePDU_planeParameters pPlaneParameters = sipdu->u.workspaceCreatePDU.planeParameters;
				while(pPlaneParameters)
				{
					pNextPlaneParameters = pPlaneParameters->next;
					delete pPlaneParameters;
					pPlaneParameters = pNextPlaneParameters;
				}
			}
		}
		break;

		default:
        ERROR_OUT(("UNKNOWN PDU TYPE =  %d we may leak memory", sipdu->choice));
		break;

	}
	
	delete sipdu;
}


//
// Cleans the retry list, when we close down or disconnect
//
void DeleteAllRetryPDUS(void)
{
	SIPDU * sipdu;
	while((sipdu = (SIPDU *)g_pRetrySendList->RemoveTail()) != NULL)
	{
		SIPDUCleanUp(sipdu);
	}
}

//
// Retry sending buffered pdus and send the new pdu
//
T120Error SendT126PDU(SIPDU * pPDU)
{

    MLZ_EntryOut(ZONE_FUNCTION, "SendT126PDU");


	//
	// First send buffered pdus
	//
	RetrySend();

	//
	// Now send the current pdu
	//
	T120Error rc = SendPDU(pPDU, FALSE);


	return rc;
}


//
// Retry sending pdus that couldn't be sent before
//
void RetrySend(void)
{

    MLZ_EntryOut(ZONE_FUNCTION, "RetrySend");

	if(g_fWaitingForBufferAvailable)
	{
		return;
	}

	TRACE_MSG(("RetrySend"));

	SIPDU * sipdu;
	while((sipdu = (SIPDU *)g_pRetrySendList->RemoveTail()) != NULL)
	{
		TRACE_DEBUG(("RetrySend sipdu->choice = %d", sipdu->choice));
		T120Error rc = SendPDU(sipdu, TRUE);
		if(rc == T120_NO_ERROR)
		{
			TRACE_DEBUG(("RetrySend OK!!!"));
			SIPDUCleanUp(sipdu);
		}
		else
		{
			TRACE_DEBUG(("RetrySend Failed"));
			break;
		}
	}
}

//
// Send T126 pdus down to the conference
//
T120Error SendPDU(SIPDU * pPDU, BOOL bRetry)
{

    MLZ_EntryOut(ZONE_FUNCTION, "SendPDU");

	T120Error rc = T120_NO_ERROR;
	
	//
	// If we are in a conference
	//
	if(g_pNMWBOBJ->IsInConference() || g_bSavingFile)
	{
		ASN1_BUF encodedPDU;

		g_pCoder->Encode(pPDU, &encodedPDU);
		if(g_bSavingFile)
		{
			g_pMain->ObjectSave(TYPE_T126_ASN_OBJECT, encodedPDU.value, encodedPDU.length);
		}
		else
		{
			if(!g_fWaitingForBufferAvailable)
			{

				T120Priority	ePriority = APPLET_LOW_PRIORITY;
				
				if(pPDU->choice == workspaceCreatePDU_chosen ||
					pPDU->choice == workspaceEditPDU_chosen ||
					pPDU->choice == workspaceDeletePDU_chosen)
				{


					//
					// Do what the standard says send the pdus in 3 different priorities
					//
					TRACE_MSG(("SendPDU sending PDU length = %d in APPLET_HIGH_PRIORITY", encodedPDU.length));

					rc = g_pNMWBOBJ->SendData(APPLET_HIGH_PRIORITY,
												    encodedPDU.length,
													encodedPDU.value);


					TRACE_MSG(("SendPDU sending PDU length = %d in APPLET_MEDIUM_PRIORITY", encodedPDU.length));
					if(rc == T120_NO_ERROR)
					{
						rc = g_pNMWBOBJ->SendData(APPLET_MEDIUM_PRIORITY,
													encodedPDU.length,
													encodedPDU.value);
					}
				}
											    

				TRACE_MSG(("SendPDU sending PDU length = %d in APPLET_LOW_PRIORITY", encodedPDU.length));
				if(rc == T120_NO_ERROR)
				{
					rc = g_pNMWBOBJ->SendData(ePriority,
											    encodedPDU.length,
											    encodedPDU.value);
				}

				if(rc == MCS_TRANSMIT_BUFFER_FULL)
				{
					g_fWaitingForBufferAvailable = TRUE;

					//
					// We need to add it back to the correct position
					//
					if(bRetry)
					{
						g_pRetrySendList->AddTail(pPDU);
					}
					else
					{
						g_pRetrySendList->AddHead(pPDU);
					}
				}
											    
			}
			else
			{
				rc = MCS_TRANSMIT_BUFFER_FULL;
				g_pRetrySendList->AddHead(pPDU);
			}
		}

		// Free the encoder memory
		g_pCoder->Free(encodedPDU);
	}

	return rc;
}


BOOL T126_MCSSendDataIndication(ULONG uSize, LPBYTE pb, ULONG memberID, BOOL bResend)
{
	BOOL bRet = TRUE;
	SIPDU * pDecodedPDU;
	ASN1_BUF InputBuffer;

	InputBuffer.length =  uSize;
	InputBuffer.value = pb;
		
	//
	// Decode incoming PDU
	if(ASN1_SUCCEEDED(g_pCoder->Decode(&InputBuffer, &pDecodedPDU)))
	{
		switch(pDecodedPDU->choice)
		{
//			case (archiveAcknowledgePDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a archiveAcknowledgePDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (archiveClosePDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a archiveClosePDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (archiveErrorPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a archiveErrorPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (archiveOpenPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a archiveOpenPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

			case (bitmapAbortPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a bitmapAbortPDU"));
				OnBitmapAbortPDU(&pDecodedPDU->u.bitmapAbortPDU, memberID);
				break;
			}

			case (bitmapCheckpointPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a bitmapCheckpointPDU"));
				OnBitmapCheckpointPDU(&pDecodedPDU->u.bitmapCheckpointPDU, memberID);
				break;
			}

			case (bitmapCreatePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a bitmapCreatePDU"));
				OnBitmapCreatePDU(&pDecodedPDU->u.bitmapCreatePDU, memberID, bResend);
				break;
			}

			case (bitmapCreateContinuePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a bitmapCreateContinuePDU"));
				OnBitmapCreateContinuePDU(&pDecodedPDU->u.bitmapCreateContinuePDU, memberID, bResend);
				break;
			}

			case (bitmapDeletePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a bitmapDeletePDU"));
				OnBitmapDeletePDU(&pDecodedPDU->u.bitmapDeletePDU, memberID);
				break;
			}

			case (bitmapEditPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a bitmapEditPDU"));
				OnBitmapEditPDU(&pDecodedPDU->u.bitmapEditPDU, memberID);
				break;
			}

			case (conductorPrivilegeGrantPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a conductorPrivilegeGrantPDU"));
				TRACE_DEBUG(("No action taken"));
				break;
			}

			case (conductorPrivilegeRequestPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a conductorPrivilegeRequestPDU"));
				TRACE_DEBUG(("No action taken"));
				break;
			}

			case (drawingCreatePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a drawingCreatePDU"));
				OnDrawingCreatePDU(&pDecodedPDU->u.drawingCreatePDU, memberID, bResend);
				break;
			}

			case (drawingDeletePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a drawingDeletePDU"));
				OnDrawingDeletePDU(&pDecodedPDU->u.drawingDeletePDU, memberID);
				break;
			}

			case (drawingEditPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a drawingEditPDU"));
				OnDrawingEditPDU(&pDecodedPDU->u.drawingEditPDU, memberID, bResend);
				break;
			}

//			case (remoteEventPermissionGrantPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a remoteEventPermissionGrantPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (remoteEventPermissionRequestPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a remoteEventPermissionRequestPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (remoteKeyboardEventPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a remoteKeyboardEventPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (remotePointingDeviceEventPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a remotePointingDeviceEventPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (remotePrintPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a remotePrintPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

			case (siNonStandardPDU_chosen):
			{

				if(pDecodedPDU->u.siNonStandardPDU.nonStandardTransaction.nonStandardIdentifier.choice == h221nonStandard_chosen)
				{

					PT126_VENDORINFO pVendorInfo = (PT126_VENDORINFO)pDecodedPDU->u.siNonStandardPDU.nonStandardTransaction.nonStandardIdentifier.u.h221nonStandard.value;

					if (!lstrcmp((LPSTR)&pVendorInfo->nonstandardString, NonStandardTextID))
					{
						TEXTPDU_HEADER *pHeader = (TEXTPDU_HEADER*) pDecodedPDU->u.siNonStandardPDU.nonStandardTransaction.data.value;
						switch(pHeader->nonStandardPDU)
						{
							case textCreatePDU_chosen:
							TRACE_DEBUG((">>> Received a textCreatePDU_chosen"));
							OnTextCreatePDU((MSTextPDU*)pHeader, memberID, bResend);
							break;

							case textEditPDU_chosen:
							TRACE_DEBUG((">>> Received a textEditPDU_chosen"));
							OnTextEditPDU((MSTextPDU*)pHeader, memberID);
							break;

							case textDeletePDU_chosen:
							TRACE_DEBUG((">>> Received a textDeletePDU_chosen"));
							OnTextDeletePDU(pHeader, memberID);
							break;

							default:
							TRACE_DEBUG(("Invalid text pdu"));
							break;
						}
						
					}


				}

				break;
			}

			case (workspaceCreatePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a workspaceCreatePDU"));
				OnWorkspaceCreatePDU(&pDecodedPDU->u.workspaceCreatePDU, memberID, bResend);
				break;
			}

			case (workspaceCreateAcknowledgePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a workspaceCreateAcknowledgePDU"));
				OnWorkspaceCreateAcknowledgePDU(&pDecodedPDU->u.workspaceCreateAcknowledgePDU, memberID);
				break;
			}

			case (workspaceDeletePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a workspaceDeletePDU"));
				OnWorkspaceDeletePDU(&pDecodedPDU->u.workspaceDeletePDU, memberID);
				break;
			}

			case (workspaceEditPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a workspaceEditPDU"));
				OnWorkspaceEditPDU(&pDecodedPDU->u.workspaceEditPDU, memberID);
				break;
			}

			case (workspacePlaneCopyPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a workspacePlaneCopyPDU"));
				OnWorkspacePlaneCopyPDU(&pDecodedPDU->u.workspacePlaneCopyPDU, memberID);
				break;
			}

			case (workspaceReadyPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a workspaceReadyPDU"));
				OnWorkspaceReadyPDU(&pDecodedPDU->u.workspaceReadyPDU, memberID);
				break;
			}

			case (workspaceRefreshStatusPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a workspaceRefreshStatusPDU"));
				OnWorkspaceRefreshStatusPDU(&pDecodedPDU->u.workspaceRefreshStatusPDU, memberID);
				break;
			}

//			case (fontPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a fontPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (textCreatePDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a textCreatePDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (textDeletePDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a textDeletePDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (textEditPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a textEditPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (videoWindowCreatePDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a videoWindowCreatePDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (videoWindowDeleatePDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a videoWindowDeleatePDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (videoWindowEditPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a videoWindowEditPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

			default:
			bRet = FALSE;
			TRACE_DEBUG(("Receive an Unhandled PDU choice = %d", pDecodedPDU->choice));
			break;
		}
	}

	//
	// Free the decoded pdu
	// JOSEF: for performance in the future we could pass
	// the decoded buffer to the ui, avoiding more memory allocation.
	// But it will be hard to read the code, since the T126 structures
	// are a bit confusing.
	//
	
	g_pCoder->Free(pDecodedPDU);

	return bRet;
}


//
// Delete All Workspaces sent and received
//
void DeleteAllWorkspaces(BOOL sendPDU)
{
	T126Obj * pObj;

	if(g_pDraw && g_pDraw->m_pTextEditor)
	{
		g_pDraw->m_pTextEditor->AbortEditGently();
	}

	g_pCurrentWorkspace = NULL;
	g_pConferenceWorkspace = NULL;

	while ((pObj = (T126Obj *)g_pListOfWorkspaces->RemoveTail()) != NULL)
	{
		if(sendPDU)
		{
			pObj->DeletedLocally();
		}
		else
		{
			pObj->ClearDeletionFlags();
		}
		
		delete pObj;
	}
	
	if(g_pMain)
	{
		g_pMain->EnableToolbar(FALSE);
		g_pMain->UpdatePageButtons();
	}

}

/////////////////////////////////////////////////////////////////////////////////////////////
// TEXT PDUS
/////////////////////////////////////////////////////////////////////////////////////////////
void	OnTextCreatePDU(MSTextPDU* pCreatePDU, ULONG memberID, BOOL bForcedResend)
{
	WorkspaceObj* pWObj;
	WbTextEditor * pText;

	//
	// Check for resend
	//

	if(!bForcedResend)
	{

		pWObj = GetWorkspace(pCreatePDU->header.workspaceHandle);
		if(pWObj)
		{
			pText = (WbTextEditor *)pWObj->FindObjectInWorkspace(pCreatePDU->header.textHandle);
			if(pText)
			{
				TRACE_DEBUG(("drawingHandle already used = %d", pCreatePDU->header.textHandle ));
				return;
			}
		}	
	}

	//
	// New Drawing object
	//
	DBG_SAVE_FILE_LINE
	pText = new WbTextEditor();
	pText->SetWorkspaceHandle(pCreatePDU->header.workspaceHandle);
	pText->SetThisObjectHandle(pCreatePDU->header.textHandle);
	
	if(!bForcedResend)
	{
		//
		// Some one sent us this drawing, it is not created locally
		//
		pText->ClearCreationFlags();

		//
		// Add a this drawing to the correct workspace
		//
		if(!AddT126ObjectToWorkspace(pText))
		{
			return;
		}
	}
	else
	{
	
		//
		// Add this object and send Create PDU
		//
		pText->SetAllAttribs();
		pText->SetWorkspaceHandle(g_pCurrentWorkspace == NULL ? 0 : g_pCurrentWorkspace->GetWorkspaceHandle()); 
		pText->ClearSelectionFlags();
		pText->GetTextAttrib(&pCreatePDU->attrib);
		pText->AddToWorkspace();
		pText->Draw();
		return;		
	}

	pText->TextEditObj(&pCreatePDU->attrib);
	pText->Draw();
	pText->ResetAttrib();	
}

void	OnTextDeletePDU(TEXTPDU_HEADER *pHeader, ULONG memberID)
{

	T126Obj*  pText;
	WorkspaceObj* pWorkspace;
	
	// We should find this drawing object
    if(FindObjectAndWorkspace(pHeader->textHandle, (T126Obj**)&pText, (WorkspaceObj**)&pWorkspace))
	{
		pText->SetOwnerID(memberID);
		pWorkspace->RemoveT126Object(pText);
	}

}

void	OnTextEditPDU(MSTextPDU *pEditPDU, ULONG memberID)
{
	TextObj*  pText;
	WorkspaceObj* pWorkspace;
	
	// We should find this drawing object
    if(FindObjectAndWorkspace(pEditPDU->header.textHandle, (T126Obj **)&pText, (WorkspaceObj**)&pWorkspace))
	{
		pText->SetOwnerID(memberID);
		pText->TextEditObj(&pEditPDU->attrib);
	}
}



/////////////////////////////////////////////////////////////////////////////////////////////
// DRAWING PDUS
/////////////////////////////////////////////////////////////////////////////////////////////
void	OnDrawingCreatePDU(DrawingCreatePDU * pdrawingCreatePDU, ULONG memberID, BOOL bForcedResend)
{
	WorkspaceObj* pWObj;
	DrawObj * pDraw;
	UINT workspace;
	UINT planeID;

	//
	// If we don't have a drawing handle dont take it
	//
	if(!(pdrawingCreatePDU->bit_mask & drawingHandle_present))
	{
		TRACE_DEBUG(("Got a DrawingCreatePDU but no drawingHandle" ));
		return;
	}

	GetDrawingDestinationAddress(&pdrawingCreatePDU->destinationAddress, &workspace, &planeID);

	//
	// Check for resend
	//

	if(!bForcedResend)
	{

		pWObj = GetWorkspace(workspace);
		if(pWObj)
		{
			pDraw = (DrawObj *)pWObj->FindObjectInWorkspace(pdrawingCreatePDU->drawingHandle);
			if(pDraw)
			{
				TRACE_DEBUG(("drawingHandle already used = %d", pdrawingCreatePDU->drawingHandle ));
				return;
			}
		}	
	}

	//
	// New Drawing object
	//
	DBG_SAVE_FILE_LINE
	pDraw = new DrawObj(pdrawingCreatePDU);
	pDraw->SetOwnerID(memberID);

	if(!bForcedResend)
	{
		//
		// Some one sent us this drawing, it is not created locally
		//
		pDraw->ClearCreationFlags();

		//
		// Add a this drawing to the correct workspace
		//
		if(!AddT126ObjectToWorkspace(pDraw))
		{
			return;
		}
	}
	else
	{
	
		//
		// Add this object and send Create PDU
		//
		pDraw->SetAllAttribs();
		pDraw->SetWorkspaceHandle(g_pCurrentWorkspace == NULL ? 0 : g_pCurrentWorkspace->GetWorkspaceHandle()); 
		pDraw->ClearSelectionFlags();
		pDraw->AddToWorkspace();
		pDraw->Draw();
		return;
	}

	//
	// Draw it
	//
	if(pDraw->GetPenThickness())
	{
		pDraw->Draw();
		pDraw->ResetAttrib();	
	}

}

void	OnDrawingDeletePDU(DrawingDeletePDU * pdrawingDeletePDU, ULONG memberID)
{

	DrawObj*  pDraw;
	WorkspaceObj* pWorkspace;
	
	// We should find this drawing object
    if(FindObjectAndWorkspace(pdrawingDeletePDU->drawingHandle, (T126Obj **)&pDraw, (WorkspaceObj**)&pWorkspace))
	{
		pDraw->SetOwnerID(memberID);
		pWorkspace->RemoveT126Object((T126Obj*)pDraw);
	}

}

void	OnDrawingEditPDU(DrawingEditPDU * pdrawingEditPDU, ULONG memberID, BOOL bResend)
{
	DrawObj*  pDraw;
	WorkspaceObj* pWorkspace;
	
	// We should find this drawing object
	if(FindObjectAndWorkspace(pdrawingEditPDU->drawingHandle, (T126Obj **)&pDraw, (WorkspaceObj**)&pWorkspace))
	{
		pDraw->SetOwnerID(memberID);
		pDraw->DrawEditObj(pdrawingEditPDU);
	}
	else
	{
		//
		// We are reading this pdu from disk add the rest of the line to the previous freehand drawing
		//
		if(bResend)
		{
			T126Obj * pObj;
			pObj = g_pCurrentWorkspace->GetTail();
			if(pObj && pObj->GetType() == drawingCreatePDU_chosen &&
			(pObj->GraphicTool() == TOOLTYPE_PEN ||  pObj->GraphicTool() == TOOLTYPE_HIGHLIGHT))
			{
				pdrawingEditPDU->drawingHandle = pObj->GetThisObjectHandle();
				pObj->SetOwnerID(memberID);
				((DrawObj*)pObj)->DrawEditObj(pdrawingEditPDU);
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////
// WORKSPACE PDUS
/////////////////////////////////////////////////////////////////////////////////////////////


BOOL FindObjectAndWorkspace(UINT objectHandle, T126Obj**  pObj, WorkspaceObj**pWorkspace)
{
	WorkspaceObj * pWrkspc;
	T126Obj * pT126Obj;

	WBPOSITION pos;
	pos = g_pListOfWorkspaces->GetHeadPosition();
    while (pos != NULL)
    {
		pWrkspc = (WorkspaceObj *) g_pListOfWorkspaces->GetNext(pos);
		if(pWrkspc)
		{
			pT126Obj = pWrkspc->FindObjectInWorkspace(objectHandle);
			if(pT126Obj)
			{
				*pObj = pT126Obj;
				*pWorkspace = pWrkspc;
				return TRUE;
			}
		}
	}

	return FALSE;
}




//
// Retrieves workspace from the list of workspaces
//
WorkspaceObj * GetWorkspace(UINT activeWorkspace)
{
	WorkspaceObj * pWorkspaceObj;
	WBPOSITION pos;
	pos = g_pListOfWorkspaces->GetHeadPosition();
    while (pos != NULL)
    {
		pWorkspaceObj = (WorkspaceObj *) g_pListOfWorkspaces->GetNext(pos);

		if(pWorkspaceObj->GetWorkspaceHandle() == activeWorkspace)
		{
			return pWorkspaceObj;
		}
	}


	return NULL;
}

//
// The remote sent us a new workspace
//
void OnWorkspaceCreatePDU(WorkspaceCreatePDU * pWorkspaceCreatePDU, ULONG memberID, BOOL bForcedResend)
{
	TRACE_DEBUG(("OnWorkspaceCreatePDU WorkspaceIdentifier = %d", pWorkspaceCreatePDU->workspaceIdentifier.u.activeWorkspace));

	WorkspaceObj * pWorkspaceObj;


	//
	// Check for resend
	//
	if(!bForcedResend)
	{
		pWorkspaceObj = GetWorkspace(WorkspaceObj::GetWorkspaceIdentifier(&pWorkspaceCreatePDU->workspaceIdentifier));
		if(pWorkspaceObj)
		{
			return;
		}

		DBG_SAVE_FILE_LINE
		pWorkspaceObj = new WorkspaceObj(pWorkspaceCreatePDU, bForcedResend);
		pWorkspaceObj->SetOwnerID(memberID);
	}
	else
	{
		DBG_SAVE_FILE_LINE
		pWorkspaceObj = new WorkspaceObj(pWorkspaceCreatePDU, bForcedResend);
		pWorkspaceObj->SetOwnerID(memberID);
	}
}

//
// If we created an unsynchronized workspace the remote has to sen us
// a WorkspaceCreateAcknowledgePDU. Why???
//
void OnWorkspaceCreateAcknowledgePDU(WorkspaceCreateAcknowledgePDU * pWorkspaceCreateAcknowledgePDU, ULONG memberID)
{
	TRACE_DEBUG(("OnWorkspaceCreateAcknowledgePDU WorkspaceIdentifier = %d", pWorkspaceCreateAcknowledgePDU->workspaceIdentifier));
}

//
// The remote is deleting the workspace
//
void OnWorkspaceDeletePDU(WorkspaceDeletePDU * pWorkspaceDeletePDU, ULONG memberID)
{
	TRACE_DEBUG(("OnWorkspaceDeletePDU WorkspaceIdentifier = %d", pWorkspaceDeletePDU->workspaceIdentifier.u.activeWorkspace));

	//
	// Find the workspace
	//
	WorkspaceObj * pWorkspaceObj;
	pWorkspaceObj = GetWorkspace(WorkspaceObj::GetWorkspaceIdentifier(&pWorkspaceDeletePDU->workspaceIdentifier));
	if(!pWorkspaceObj)
	{
		return;
	}

	pWorkspaceObj->SetOwnerID(memberID);
	pWorkspaceObj->ClearDeletionFlags();

	//
	// Reason for deleting
	//
	TRACE_DEBUG(("OnWorkspaceDeletePDU reason = %d", pWorkspaceDeletePDU->reason.choice));

	//
	// Remove it from the List Of Workspaces
	//
	WBPOSITION prevPos;
	WBPOSITION pos;

	pos = g_pListOfWorkspaces->GetPosition(pWorkspaceObj);
	prevPos = g_pListOfWorkspaces->GetHeadPosition(); 

	//
	// This is the only workspace we have ?????
	//
	if(g_pListOfWorkspaces->GetHeadPosition() == g_pListOfWorkspaces->GetTailPosition())
	{
		RemoveWorkspace(pWorkspaceObj);

		g_pCurrentWorkspace = NULL;

		if(g_pMain)
		{
			g_pMain->EnableToolbar(FALSE);
		}
	}
	else
	{

		//
		// If we had a remote pointer
		//
		BOOL	 bRemote = FALSE;
		if(g_pMain->m_pLocalRemotePointer)
		{
			bRemote = TRUE;
			g_pMain->OnRemotePointer();
		}

		//
		// Remove the workspace and point the current one to the correct one.
		//
		pWorkspaceObj = RemoveWorkspace(pWorkspaceObj);

		g_pConferenceWorkspace = pWorkspaceObj;

		if(g_pDraw->IsSynced())
		{
			g_pMain->GoPage(pWorkspaceObj,FALSE);
		}

		//
		// If we had a remote pointer
		//
		if(bRemote)
		{
			g_pMain->OnRemotePointer();
		}
	}
}

//
// The remote is changing the workspace
//
void OnWorkspaceEditPDU(WorkspaceEditPDU * pWorkspaceEditPDU, ULONG memberID)
{
	TRACE_DEBUG(("OnWorkspaceEditPDU WorkspaceIdentifier = %d",pWorkspaceEditPDU->workspaceIdentifier.u.activeWorkspace));

	//
	// Find the workspace
	//
	WorkspaceObj * pWorkspaceObj;
	pWorkspaceObj = GetWorkspace(WorkspaceObj::GetWorkspaceIdentifier(&pWorkspaceEditPDU->workspaceIdentifier));
	if(!pWorkspaceObj)
	{
		return;
	}
	pWorkspaceObj->SetOwnerID(memberID);
	pWorkspaceObj->WorkspaceEditObj(pWorkspaceEditPDU);
}

void OnWorkspacePlaneCopyPDU(WorkspacePlaneCopyPDU * pWorkspacePlaneCopyPDU, ULONG memberID)
{
	TRACE_DEBUG(("OnWorkspacePlaneCopyPDU WorkspaceIdentifier = %d",pWorkspacePlaneCopyPDU->sourceWorkspaceIdentifier));
}

void OnWorkspaceReadyPDU(WorkspaceReadyPDU * pWorkspaceReadyPDU, ULONG memberID)
{
	TRACE_DEBUG(("OnWorkspaceReadyPDU WorkspaceIdentifier = %d",pWorkspaceReadyPDU->workspaceIdentifier));

	//
	// Find the workspace
	//
	WorkspaceObj * pWorkspaceObj;
	pWorkspaceObj = GetWorkspace(WorkspaceObj::GetWorkspaceIdentifier(&pWorkspaceReadyPDU->workspaceIdentifier));
	if(!pWorkspaceObj)
	{
		return;
	}
	pWorkspaceObj->SetOwnerID(memberID);

	//
	// This workspace is ready
	//
	pWorkspaceObj->m_bWorkspaceReady = TRUE;
}

//
// If we got a refreshStatus == TRUE, we have to refresh late joiners
//
void OnWorkspaceRefreshStatusPDU(WorkspaceRefreshStatusPDU * pWorkspaceRefreshStatusPDU, ULONG memberID)
{
	if (pWorkspaceRefreshStatusPDU->refreshStatus == TRUE)
	{
		g_RefresherID = memberID;
	}
	else
	{
		//
		// The token is out there, try to grab it
		//
		g_pNMWBOBJ->GrabRefresherToken();
	}
}





/////////////////////////////////////////////////////////////////////////////////////////////
// BITMAP PDUS
/////////////////////////////////////////////////////////////////////////////////////////////

void	OnBitmapCreatePDU(BitmapCreatePDU * pBitmapCreatePDU, ULONG memberID, BOOL bForcedResend)
{

	TRACE_DEBUG(("drawingHandle = %d", pBitmapCreatePDU->bitmapHandle ));
	
	//
	// If we find this object, it is because T120 is broadcasting the drawing
	// we just sent to T126
	//
	UINT workspace;
	UINT planeID;
	
	GetBitmapDestinationAddress(&pBitmapCreatePDU->destinationAddress, &workspace, &planeID);

	//
	// Check for resend
	//
	WorkspaceObj* pWObj;
	BitmapObj * pBitmap;
	if(!bForcedResend)
	{
		pWObj = GetWorkspace(workspace);
		if(pWObj)
		{
			pBitmap = (BitmapObj*)pWObj->FindObjectInWorkspace(pBitmapCreatePDU->bitmapHandle);
			if(pBitmap)
			return;
		}
	}

	//
	// New Drawing object
	//
	DBG_SAVE_FILE_LINE
	pBitmap = new BitmapObj(pBitmapCreatePDU);
	pBitmap->SetOwnerID(memberID);


	if(!bForcedResend)
	{
		//
		// Someone else sent us this bitmap, it was not created locally
		//
		pBitmap->ClearCreationFlags();

		//
		// Add a this drawing to the correct workspace
		//
		if(!AddT126ObjectToWorkspace(pBitmap))
		{
			return;
		}

	}
	else
	{
		//
		// If we are reading from disk, this has to be added in the current workspace
		// and we have to wait until we have the whole bitmap to send it
		//
		if(pBitmap->m_fMoreToFollow)
		{
			pBitmap->SetWorkspaceHandle(g_pCurrentWorkspace == NULL ? 0 : g_pCurrentWorkspace->GetWorkspaceHandle());
			AddT126ObjectToWorkspace(pBitmap);
		}
		else
		{
			//
			// Add this object and send Create PDU
			//
			pBitmap->SetAllAttribs();
			pBitmap->AddToWorkspace();
		}
	}


	//
	// PASS IT TO UI
	//
	if(!pBitmap->m_fMoreToFollow)
	{
		pBitmap->Draw();
	}

}
void	OnBitmapCreateContinuePDU(BitmapCreateContinuePDU * pBitmapCreateContinuePDU, ULONG memberID,  BOOL bForcedResend)
{

	WorkspaceObj* pWorkspace;
	BitmapObj*  pBitmap = NULL;
	
	// We should find this drawing object

	//
	// If we are loading from file it is in the current workspace
	//
	if(bForcedResend)
	{
		ASSERT(g_pCurrentWorkspace);
		if(g_pCurrentWorkspace)
		{
			pBitmap = (BitmapObj*)g_pCurrentWorkspace->FindObjectInWorkspace(pBitmapCreateContinuePDU->bitmapHandle);
		}
	}
	else
	{
		FindObjectAndWorkspace(pBitmapCreateContinuePDU->bitmapHandle, (T126Obj **)&pBitmap, (WorkspaceObj**)&pWorkspace);
	}


	if(pBitmap)
	{

		pBitmap->SetOwnerID(memberID);

		//
		// Found the previous bitmap, concatenate the data
		//
		pBitmap->Continue(pBitmapCreateContinuePDU);

		//
		// PASS IT TO UI
		//
		if(!pBitmap->m_fMoreToFollow)
		{
			pBitmap->Draw();

			if(bForcedResend)
			{
				pBitmap->SetAllAttribs();
				pBitmap->AddToWorkspace();
			}
		}
	}
}
void	OnBitmapCheckpointPDU(BitmapCheckpointPDU * pBitmapCheckPointPDU, ULONG memberID)
{
}

void	OnBitmapAbortPDU(BitmapAbortPDU * pBitmapAbortPDU, ULONG memberID)
{
		BitmapDeletePDU bitmapDeletePDU;
		bitmapDeletePDU.bitmapHandle = pBitmapAbortPDU->bitmapHandle;
		bitmapDeletePDU.bit_mask = 0;

		//
		// Pass it to bitmapDeletePDU
		//
		OnBitmapDeletePDU(&bitmapDeletePDU, memberID);
}
void	OnBitmapEditPDU(BitmapEditPDU * pBitmapEditPDU, ULONG memberID)
{
	BitmapObj*  pObj;
	WorkspaceObj* pWorkspace;
	
	// We should find this drawing object
    if(FindObjectAndWorkspace(pBitmapEditPDU->bitmapHandle, (T126Obj **)&pObj, (WorkspaceObj**)&pWorkspace))
	{
		pObj->SetOwnerID(memberID);
		pObj->BitmapEditObj(pBitmapEditPDU);
	}

}
void	OnBitmapDeletePDU(BitmapDeletePDU * pBitmapDeletePDU, ULONG memberID)
{
	BitmapObj*  pObj;
	WorkspaceObj* pWorkspace;
	
	// We should find this drawing object
    if(FindObjectAndWorkspace(pBitmapDeletePDU->bitmapHandle, (T126Obj **)&pObj, (WorkspaceObj**)&pWorkspace))
	{
		pObj->SetOwnerID(memberID);
		pWorkspace->RemoveT126Object((T126Obj*)pObj);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\mwnd.cpp ===
//
// MWND.CPP
// Main WB Window
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"
#include <dde.h>
#include "version.h"
#include "nmwbobj.h"

static const TCHAR s_cszHtmlHelpFile[] = TEXT("nmwhiteb.chm");

// Class name
TCHAR szMainClassName[] = "T126WBMainWindowClass";

extern TCHAR g_PassedFileName[];

//
// Scroll accelerators
//
typedef struct tagSCROLL
{
	UINT uiMenuId;
	UINT uiMessage;
	UINT uiScrollCode;
}
SCROLL;

static const SCROLL s_MenuToScroll[] =
{
  { IDM_PAGEUP,        WM_VSCROLL, SB_PAGEUP },
  { IDM_PAGEDOWN,      WM_VSCROLL, SB_PAGEDOWN },
  { IDM_SHIFTPAGEUP,   WM_HSCROLL, SB_PAGEUP },
  { IDM_SHIFTPAGEDOWN, WM_HSCROLL, SB_PAGEDOWN },
  { IDM_HOME,          WM_HSCROLL, SB_TOP },
  { IDM_HOME,          WM_VSCROLL, SB_TOP },
  { IDM_END,           WM_HSCROLL, SB_BOTTOM },
  { IDM_END,           WM_VSCROLL, SB_BOTTOM },
  { IDM_LINEUP,        WM_VSCROLL, SB_LINEUP },
  { IDM_LINEDOWN,      WM_VSCROLL, SB_LINEDOWN },
  { IDM_SHIFTLINEUP,   WM_HSCROLL, SB_LINEUP },
  { IDM_SHIFTLINEDOWN, WM_HSCROLL, SB_LINEDOWN }
};


// tooltip data
// check codes
#define NA    0   // dont't check checked state
#define TB    1    // check toolbar for checked state
#define BT    2    // check tipped wnd (a button) for checked state

typedef struct
{
    UINT    nID;
    UINT    nCheck;
    UINT    nUpTipID;
    UINT    nDownTipID;
}
TIPIDS;

TIPIDS g_tipIDsArray[]    =
{
{IDM_SELECT,            TB, IDS_HINT_SELECT,        IDS_HINT_SELECT},
{IDM_ERASER,            TB, IDS_HINT_ERASER,        IDS_HINT_ERASER},
{IDM_TEXT,              TB, IDS_HINT_TEXT,          IDS_HINT_TEXT},
{IDM_HIGHLIGHT,         TB, IDS_HINT_HIGHLIGHT,     IDS_HINT_HIGHLIGHT},
{IDM_PEN,               TB, IDS_HINT_PEN,           IDS_HINT_PEN},
{IDM_LINE,              TB, IDS_HINT_LINE,          IDS_HINT_LINE},
{IDM_BOX,               TB, IDS_HINT_BOX,           IDS_HINT_BOX},
{IDM_FILLED_BOX,        TB, IDS_HINT_FBOX,          IDS_HINT_FBOX},
{IDM_ELLIPSE,           TB, IDS_HINT_ELLIPSE,       IDS_HINT_ELLIPSE},
{IDM_FILLED_ELLIPSE,    TB, IDS_HINT_FELLIPSE,      IDS_HINT_FELLIPSE},
{IDM_ZOOM,              TB, IDS_HINT_ZOOM_UP,       IDS_HINT_ZOOM_DOWN},
{IDM_REMOTE,            TB, IDS_HINT_REMOTE_UP,     IDS_HINT_REMOTE_DOWN},
{IDM_LOCK,              TB, IDS_HINT_LOCK_UP,       IDS_HINT_LOCK_DOWN},
{IDM_SYNC,              TB, IDS_HINT_SYNC_UP,       IDS_HINT_SYNC_DOWN},
{IDM_GRAB_AREA,         TB, IDS_HINT_GRAB_AREA,     IDS_HINT_GRAB_AREA},
{IDM_GRAB_WINDOW,       TB, IDS_HINT_GRAB_WINDOW,   IDS_HINT_GRAB_WINDOW},

{IDM_WIDTH_1,           NA, IDS_HINT_WIDTH_1,       IDS_HINT_WIDTH_1},
{IDM_WIDTH_2,           NA, IDS_HINT_WIDTH_2,       IDS_HINT_WIDTH_2},
{IDM_WIDTH_3,           NA, IDS_HINT_WIDTH_3,       IDS_HINT_WIDTH_3},
{IDM_WIDTH_4,           NA, IDS_HINT_WIDTH_4,       IDS_HINT_WIDTH_4},

{IDM_PAGE_FIRST,        BT, IDS_HINT_PAGE_FIRST,    IDS_HINT_PAGE_FIRST},
{IDM_PAGE_PREV,         BT, IDS_HINT_PAGE_PREVIOUS, IDS_HINT_PAGE_PREVIOUS},
{IDM_PAGE_ANY,          NA, IDS_HINT_PAGE_ANY,      IDS_HINT_PAGE_ANY},
{IDM_PAGE_NEXT,         BT, IDS_HINT_PAGE_NEXT,     IDS_HINT_PAGE_NEXT},
{IDM_PAGE_LAST,         BT, IDS_HINT_PAGE_LAST,     IDS_HINT_PAGE_LAST},
{IDM_PAGE_INSERT_AFTER, BT, IDS_HINT_PAGE_INSERT,   IDS_HINT_PAGE_INSERT}
    };
////////////


HRESULT WbMainWindow::WB_LoadFile(LPCTSTR szFile)
{
	//
	// If a file name was passed
	//
    if (szFile && g_pMain)
    {
        int     cchLength;
        BOOL    fSkippedQuote;

        // Skip past first quote
        if (fSkippedQuote = (*szFile == '"'))
            szFile++;

        cchLength = lstrlen(szFile);

        //
        // NOTE:
        // There may be DBCS implications with this.  Hence we check to see
        // if we skipped the first quote; we assume that if the file name
        // starts with a quote it must end with one also.  But we need to check
        // it out.
        //
        // Strip last quote
        if (fSkippedQuote && (cchLength > 0) && (szFile[cchLength - 1] == '"'))
        {
            BYTE * pLastQuote = (BYTE *)&szFile[cchLength - 1];
            TRACE_MSG(("Skipping last quote in file name %s", szFile));
        	*pLastQuote = '\0';
        }

        g_pMain->OnOpen(szFile);
	}

	return S_OK;
}



void WbMainWindow::BringToFront(void)
{
    if (NULL != m_hwnd)
    {
        int nCmdShow = SW_SHOW;

        WINDOWPLACEMENT wp;
        ::ZeroMemory(&wp, sizeof(wp));
        wp.length = sizeof(wp);

        if (::GetWindowPlacement(m_hwnd, &wp))
        {
            if (SW_MINIMIZE == wp.showCmd || SW_SHOWMINIMIZED == wp.showCmd)
            {
                // The window is minimized - restore it:
                nCmdShow = SW_RESTORE;
            }
        }

        // show the window now
        ::ShowWindow(m_hwnd, nCmdShow);

        // bring it to the foreground
        ::SetForegroundWindow(m_hwnd);
    }
}



//
//
// Function:    WbMainWindow constructor
//
// Purpose:     Create the main Whiteboard window. An exception is thrown
//              if an error occurs during construction.
//
//
WbMainWindow::WbMainWindow(void)
{
    OSVERSIONINFO   OsData;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::WbMainWindow");

    //
    // Initialize member vars first!
    //
    ZeroMemory(m_ToolArray, sizeof(m_ToolArray));

	m_hwnd = NULL;
    m_hwndToolTip = NULL;
    ZeroMemory(&m_tiLastHit, sizeof(m_tiLastHit));
    m_nLastHit = -1;

    m_bInitOk = FALSE;
    m_bDisplayingError = FALSE;

    m_hwndSB = NULL;
    m_bStatusBarOn = TRUE;
    m_bToolBarOn    = TRUE;

    // Load the main accelerator table
    m_hAccelTable =
        ::LoadAccelerators(g_hInstance, MAKEINTRESOURCE(MAINACCELTABLE));

    m_hwndQuerySaveDlg = NULL;
    m_hwndWaitForEventDlg = NULL;
    m_hwndWaitForLockDlg = NULL;


    m_pCurrentTool = NULL;
	ZeroMemory(m_strFileName, sizeof(m_strFileName));
	m_pTitleFileName = NULL;

    // Load the alternative accelerator table for the pages edit
    // field and text editor
    m_hAccelPagesGroup =
        ::LoadAccelerators(g_hInstance, MAKEINTRESOURCE(PAGESGROUPACCELTABLE));
    m_hAccelTextEdit   =
        ::LoadAccelerators(g_hInstance, MAKEINTRESOURCE(TEXTEDITACCELTABLE));


    // Show that we are not yet in a call
    m_uiSubState = SUBSTATE_IDLE;

    // We are not currently displaying a menu
    m_hContextMenuBar = NULL;
    m_hContextMenu = NULL;
    m_hGrobjContextMenuBar = NULL;
    m_hGrobjContextMenu = NULL;

    m_bInSaveDialog = FALSE;

    m_bSelectAllInProgress = FALSE;
    m_bUnlockStateSettled = TRUE;
    m_bQuerySysShutdown = FALSE;

    // figure out if we're on Win95
    m_bIsWin95 = FALSE;
    OsData.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if( GetVersionEx( &OsData ) )
    {
        if( OsData.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
            m_bIsWin95 = TRUE;
    }

    m_cancelModeSent = FALSE;

    //
    // We only do this once for the lifetime of the DLL.  There is no
    // way really to clean up registered window messages, and each register
    // bumps up a ref count.  If we registered each time WB was started up
    // during one session of CONF, we'd overflow the refcount.
    //
    if (!g_uConfShutdown)
    {
        g_uConfShutdown = ::RegisterWindowMessage( NM_ENDSESSION_MSG_NAME );
    }

	m_pLocalRemotePointer = NULL;
	m_localRemotePointerPosition.x = -50;
	m_localRemotePointerPosition.y = -50;
}


//
// Open()
// Do Main window initialization (stuff that can fail).  After this,
// the run code will try to join the current domain and do message loop
// stuff.
//
BOOL WbMainWindow::Open(int iCommand)
{
    WNDCLASSEX  wc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::Open");

    //
    // CREATE OTHER GLOBALS
    //


    if (!InitToolArray())
    {
        ERROR_OUT(("Can't create tools; failing to start up"));
        return(FALSE);
    }

    //
    // Init comon controls
    //
    InitCommonControls();


    //
    // CREATE THE MAIN FRAME WINDOW
    //
    ASSERT(!m_hwnd);

	//
    // Get the class info for it, and change the name.
    //
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(wc);
    wc.style            = CS_DBLCLKS; // CS_HREDRAW | CS_VREDRAW?
    wc.lpfnWndProc      = WbMainWindowProc;
    wc.hInstance        = g_hInstance;
    wc.hIcon            = ::LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_APP));
    wc.hCursor          = ::LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName     = MAKEINTRESOURCE(IDR_MENU_WB_WITHFILE);
    wc.lpszClassName    = szMainClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("Can't register private frame window class"));
        return(FALSE);
    }

    // Create the main drawing window.
    if (!::CreateWindowEx(WS_EX_APPWINDOW | WS_EX_WINDOWEDGE, szMainClassName,
        NULL, WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, g_hInstance, this))
    {
        // Could not create the main window
        ERROR_OUT(("Failed to create main window"));
        return(FALSE);
    }

    ASSERT(m_hwnd);

	//
    // Create the pop-up context menu
    //
    if (!CreateContextMenus())
    {
        ERROR_OUT(("Failed to create context menus"));
        return(FALSE);
    }

	//
    // Register the the main window for Drag/Drop messages.
    //
    DragAcceptFiles(m_hwnd, TRUE);

    //
    // CREATE THE CHILD WINDOWS
    //

    // Create the drawing pane
    // (the Create call throws an exception on error)
    RECT    clientRect;
    RECT    drawingAreaRect;

	::GetClientRect(m_hwnd, &clientRect);
  	drawingAreaRect.top=0;
	drawingAreaRect.bottom = DRAW_HEIGHT;
	drawingAreaRect.left = 0;
	drawingAreaRect.right = DRAW_WIDTH;

    // Every control in the main window has a border on it, so increase the
    // client size by 1 to force these borders to be drawn under the inside
    // black line in the window frame.  This prevents a 2 pel wide border
    // being drawn
    ::InflateRect(&clientRect, 1, 1);

    SIZE sizeAG;
    m_AG.GetNaturalSize(&sizeAG);

    if (!m_drawingArea.Create(m_hwnd, &drawingAreaRect))
    {
        ERROR_OUT(("Failed to create drawing area"));
        return(FALSE);
    }

	//
	// Create the toolbar
	//
    if (!m_TB.Create(m_hwnd))
    {
        ERROR_OUT(("Failed to create tool window"));
        return(FALSE);
    }


    //
    // Create the attributes group
    // The attributes group is on the bottom, underneath the
    // drawing area, above the status bar.
    //
    RECT    rectAG;

    rectAG.left = clientRect.left;
    rectAG.right = clientRect.right;
    rectAG.top = drawingAreaRect.bottom;
    rectAG.bottom = rectAG.top + sizeAG.cy;

    if (!m_AG.Create(m_hwnd, &rectAG))
    {
        ERROR_OUT(("Failed to create attributes group window"));
        return(FALSE);
    }

    //
    // Create the widths group.
    // The widths group is on the left side, underneath the tools group
    //
    SIZE    sizeWG;
    RECT    rectWG;


    // The widths group is on the left side, underneath the toolbar
    m_WG.GetNaturalSize(&sizeWG);
    rectWG.left = 0;
    rectWG.right = rectWG.left + sizeWG.cx;
    rectWG.bottom = rectAG.top;
    rectWG.top  = rectWG.bottom - sizeWG.cy;

    if (!m_WG.Create(m_hwnd, &rectWG))
    {
        ERROR_OUT(("Failed to create widths group window"));
        return(FALSE);
    }

	//
	// Create the status bar
	//
	m_hwndSB = ::CreateWindowEx(0, STATUSCLASSNAME, NULL,
		WS_CHILD | WS_VISIBLE | CCS_NOPARENTALIGN | CCS_NOMOVEY |
		CCS_NORESIZE | SBARS_SIZEGRIP,
		clientRect.left, clientRect.bottom - STATUSBAR_HEIGHT,
		(clientRect.right - clientRect.left), STATUSBAR_HEIGHT,
		m_hwnd, 0, g_hInstance, NULL);

	if (!m_hwndSB)
	{
		ERROR_OUT(("Failed to create status bar window"));
		return(FALSE);
	}

    // Initialize the color, width and tool menus
    InitializeMenus();

    m_currentMenuTool       = IDM_SELECT;
    m_pCurrentTool          = m_ToolArray[TOOL_INDEX(IDM_SELECT)];
	OnSelectTool(m_currentMenuTool);


    m_hwndToolTip = ::CreateWindowEx(NULL, TOOLTIPS_CLASS, NULL,
        WS_POPUP | TTS_ALWAYSTIP, CW_USEDEFAULT, CW_USEDEFAULT,
        CW_USEDEFAULT, CW_USEDEFAULT, m_hwnd, NULL, g_hInstance, NULL);
    if (!m_hwndToolTip)
    {
        ERROR_OUT(("Unable to create tooltip window"));
        return(FALSE);
    }

    // Add a dead-area tooltip
    TOOLINFO ti;

    ZeroMemory(&ti, sizeof(ti));
    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_IDISHWND;
    ti.hwnd = m_hwnd;
    ti.uId = (UINT_PTR)m_hwnd;
    ::SendMessage(m_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

    // Ensure the page buttons are disabled while starting
    UpdatePageButtons();

    // If this is the first time we have created a clipboard object,
    // register the private Whiteboard formats.
    if (g_ClipboardFormats[CLIPBOARD_PRIVATE] == 0)
    {
        g_ClipboardFormats[CLIPBOARD_PRIVATE] =
            (int) ::RegisterClipboardFormat("NMWT126");
    }


    m_bInitOk = TRUE;

    BOOL bSuccess = TRUE;    // indicates whether window opened successfully

    // Get the position of the window from options
    RECT    rectWindow;

    OPT_GetWindowRectOption(&rectWindow);

    ::MoveWindow(m_hwnd, rectWindow.left, rectWindow.top,
            rectWindow.right - rectWindow.left,
            rectWindow.bottom - rectWindow.top, FALSE );


	//
	// Inititalize the fake GCC handle, it will be used when we are not in a conference and need
	//	handles for workspaces/drawings/bitmaps etc...
	//
	g_localGCCHandle = 1;

	//
	// Create a standard workspace
	//
	if(g_pCurrentWorkspace)
	{
		m_drawingArea.Attach(g_pCurrentWorkspace);
	}
	else
	{
		if(g_numberOfWorkspaces < WB_MAX_WORKSPACES)
		{
			m_drawingArea.Detach();
			WorkspaceObj * pObj;
			DBG_SAVE_FILE_LINE
			pObj = new WorkspaceObj();
			pObj->AddToWorkspace();
			g_pConferenceWorkspace = pObj;
		}
	}

	CheckMenuItem(IDM_STATUS_BAR_TOGGLE);
	CheckMenuItem(IDM_TOOL_BAR_TOGGLE);

	//
	// Start synced
	//
	Sync();

	if(!OPT_GetBooleanOption(OPT_MAIN_STATUSBARVISIBLE, DFLT_MAIN_STATUSBARVISIBLE))
	{
		OnStatusBarToggle();
	}	

	if(!OPT_GetBooleanOption(OPT_MAIN_TOOLBARVISIBLE, DFLT_MAIN_TOOLBARVISIBLE))
	{
		OnToolBarToggle();
	}
	
	::ShowWindow(m_hwnd, iCommand);
	::UpdateWindow(m_hwnd);

	// Update the window title with no file name
	UpdateWindowTitle();


	// Return value indicating success or failure
	return(bSuccess);
}




//
//
// Function : OnMenuSelect
//
// Purpose  : Update the text in the help bar
//
//
void WbMainWindow::OnMenuSelect(UINT uiItemID, UINT uiFlags, HMENU hSysMenu)
{
	UINT   firstMenuId;
	UINT   statusId;

	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnMenuSelect");

	//
	// Work out the help ID for the menu item.  We have to store this now
	// because when the user presses F1 from a menu item, we can't tell
	// which item it was.
	//
	if ((uiFlags & MF_POPUP) && (uiFlags & MF_SYSMENU))
	{
		//
		// System menu selected
		//
		statusId   = IDS_MENU_SYSTEM;
	}
	else if (uiFlags & MF_POPUP)
	{
		// get popup menu handle and first item (bug NM4db:463)
		HMENU hPopup = ::GetSubMenu( hSysMenu, uiItemID );
		firstMenuId = ::GetMenuItemID( hPopup, 0 );

		// figure out which popup it is so we can display the right help text
		switch (firstMenuId)
		{
			case IDM_NEW:
				statusId   = IDS_MENU_FILE;
				break;

			case IDM_DELETE:
				statusId   = IDS_MENU_EDIT;
				break;

			case IDM_TOOL_BAR_TOGGLE:
				statusId   = IDS_MENU_VIEW;
				break;

			case IDM_EDITCOLOR:
			case IDM_TOOLS_START:
				statusId   = IDS_MENU_TOOLS;
				break;

			case IDM_HELP:
				statusId = IDS_MENU_HELP;
				break;

			case IDM_WIDTH_1: // (added for bug NM4db:463)
				statusId   = IDS_MENU_WIDTH;
				break;

			default:
				statusId   = IDS_DEFAULT;
				break;
		}
	}
	else
	{
		//
		// A normal menu item has been selected
		//
		statusId   = uiItemID;
	}

	// Set the new help text
	TCHAR   szStatus[256];

	if (::LoadString(g_hInstance, statusId, szStatus, 256))
	{
		::SetWindowText(m_hwndSB, szStatus);
	}
}




//
// WbMainWindowProc()
// Frame window message handler
//
LRESULT WbMainWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbMainWindow * pMain;

    pMain = (WbMainWindow *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pMain = (WbMainWindow *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            ASSERT(pMain);

            pMain->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pMain);
            goto DefWndProc;
            break;

        case WM_DESTROY:
            ShutDownHelp();
            break;

        case WM_NCDESTROY:
            pMain->m_hwnd = NULL;
            break;

        case WM_SIZE:
            pMain->OnSize((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_ACTIVATE:
            if (GET_WM_ACTIVATE_STATE(wParam, lParam) == WA_INACTIVE)
            {
                // Cancel the tooltip if it's around
                if (pMain->m_hwndToolTip)
                    ::SendMessage(pMain->m_hwndToolTip, TTM_ACTIVATE, FALSE, 0);
            }
            goto DefWndProc;
            break;

        case WM_SETFOCUS:
            pMain->OnSetFocus();
            break;

        case WM_CANCELMODE:
            pMain->OnCancelMode();
            break;

        case WM_INITMENUPOPUP:
            pMain->OnInitMenuPopup((HMENU)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_MENUSELECT:
            pMain->OnMenuSelect(GET_WM_MENUSELECT_CMD(wParam, lParam),
                GET_WM_MENUSELECT_FLAGS(wParam, lParam),
                GET_WM_MENUSELECT_HMENU(wParam, lParam));
            break;

        case WM_MEASUREITEM:
            pMain->OnMeasureItem((UINT)wParam, (LPMEASUREITEMSTRUCT)lParam);
            break;

        case WM_DRAWITEM:
            pMain->OnDrawItem((UINT)wParam, (LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_QUERYNEWPALETTE:
            lResult = pMain->OnQueryNewPalette();
            break;

        case WM_PALETTECHANGED:
            pMain->OnPaletteChanged((HWND)wParam);
            break;

        case WM_HELP:
            pMain->OnCommand(IDM_HELP, 0, NULL);
            break;

        case WM_CLOSE:
            pMain->OnClose();
            break;

        case WM_QUERYENDSESSION:
            lResult = pMain->OnQueryEndSession();
            break;

        case WM_ENDSESSION:
            pMain->OnEndSession((UINT)wParam);
            break;

        case WM_SYSCOLORCHANGE:
            pMain->OnSysColorChange();
            break;

        case WM_USER_PRIVATE_PARENTNOTIFY:
            pMain->OnParentNotify(GET_WM_PARENTNOTIFY_MSG(wParam, lParam));
            break;

        case WM_GETMINMAXINFO:
            if (pMain)
                pMain->OnGetMinMaxInfo((LPMINMAXINFO)lParam);
            break;

        case WM_COMMAND:
            pMain->OnCommand(LOWORD(wParam), HIWORD(wParam), (HWND)lParam);
            break;

        case WM_NOTIFY:
            pMain->OnNotify((UINT)wParam, (NMHDR *)lParam);
            break;

        case WM_DROPFILES:
            pMain->OnDropFiles((HDROP)wParam);
            break;

        case WM_USER_DISPLAY_ERROR:
            pMain->OnDisplayError(wParam, lParam);
            break;

        case WM_USER_UPDATE_ATTRIBUTES:
            pMain->m_AG.DisplayTool(pMain->m_pCurrentTool);
            break;

		case WM_USER_LOAD_FILE:
			pMain->WB_LoadFile(g_PassedFileName);
			// Fall through.

        case WM_USER_BRING_TO_FRONT_WINDOW:
        	pMain->BringToFront();
        	break;

        default:
            if (message == g_uConfShutdown)
            {
                lResult = pMain->OnConfShutdown(wParam, lParam);
            }
            else
            {
DefWndProc:
                lResult = DefWindowProc(hwnd, message, wParam, lParam);
            }
            break;
    }

    return(lResult);
}



//
// OnCommand()
// Command dispatcher for the main window
//
void WbMainWindow::OnCommand(UINT cmd, UINT code, HWND hwndCtl)
{
	switch (cmd)
	{
		//
		// FILE MENU
		//
		case IDM_NEW:
			OnNew();
			break;

		case IDM_OPEN:
			OnOpen();
			break;

		case IDM_SAVE:
			OnSave(FALSE);
			break;

		case IDM_SAVE_AS:
			OnSave(TRUE);
			break;

		case IDM_PRINT:
			OnPrint();
			break;

		case IDM_EXIT:
			::PostMessage(m_hwnd, WM_CLOSE, 0, 0);
			break;

		//
		// EDIT MENU
		//
		case IDM_DELETE:
			OnDelete();
			break;

		case IDM_UNDELETE:
			OnUndelete();
			break;

		case IDM_CUT:
			OnCut();
			break;

		case IDM_COPY:
			OnCopy();
			break;

		case IDM_PASTE:
			OnPaste();
			break;

		case IDM_SELECTALL:
			OnSelectAll();
			break;

		case IDM_BRING_TO_TOP:
			m_drawingArea.BringToTopSelection(TRUE, 0);
			break;

		case IDM_SEND_TO_BACK:
			m_drawingArea.SendToBackSelection(TRUE, 0);
			break;

		case IDM_CLEAR_PAGE:
			OnClearPage();
			break;

		case IDM_DELETE_PAGE:
			OnDeletePage();
			break;

		case IDM_PAGE_INSERT_AFTER:
			OnInsertPageAfter();
			break;

		//
		// VIEW MENU
		//
		case IDM_TOOL_BAR_TOGGLE:
			OnToolBarToggle();
			break;

		case IDM_STATUS_BAR_TOGGLE:
			OnStatusBarToggle();
			break;

		case IDM_ZOOM:
			OnZoom();
			break;

		//
		// TOOLS MENU
		//
		case IDM_SELECT:
		case IDM_PEN:
		case IDM_HIGHLIGHT:
		case IDM_TEXT:
		case IDM_ERASER:
		case IDM_LINE:
		case IDM_BOX:
		case IDM_FILLED_BOX:
		case IDM_ELLIPSE:
		case IDM_FILLED_ELLIPSE:
			OnSelectTool(cmd);
			break;

		case IDM_REMOTE:
			OnRemotePointer();

			//
			// Are we turnig remote pointer on
			//
			if(m_pLocalRemotePointer)
			{
				//put us in select-tool mode
				OnSelectTool(IDM_SELECT);
			}
			break;

		case IDM_GRAB_AREA:
			OnGrabArea();
			break;

		case IDM_GRAB_WINDOW:
			OnGrabWindow();
			break;

		case IDM_SYNC:
			OnSync();
			break;

		case IDM_LOCK:
			OnLock();
			break;

		case IDM_COLOR:
			OnSelectColor();
			break;

		case IDM_EDITCOLOR:
			m_AG.OnEditColors();
			break;

		case IDM_FONT:
			OnChooseFont();
			break;

		case IDM_WIDTH_1:
		case IDM_WIDTH_2:
		case IDM_WIDTH_3:
		case IDM_WIDTH_4:
			OnSelectWidth(cmd);
			break;

		//
		// HELP MENU
		//
		case IDM_ABOUT:
			OnAbout();
			break;

		case IDM_HELP:
			ShowHelp();
			break;

		//
		// PAGE BAR
		//
		case IDM_PAGE_FIRST:
			OnFirstPage();
			break;

		case IDM_PAGE_PREV:
			OnPrevPage();
			break;

		case IDM_PAGE_GOTO:
			OnGotoPage();
			break;

		case IDM_PAGE_NEXT:
			OnNextPage();
			break;

		case IDM_PAGE_LAST:
			OnLastPage();
			break;

		//
		// SCROLLING
		//
		case IDM_PAGEUP:
		case IDM_PAGEDOWN:
		case IDM_SHIFTPAGEUP:
		case IDM_SHIFTPAGEDOWN:
		case IDM_HOME:
		case IDM_END:
		case IDM_LINEUP:
		case IDM_LINEDOWN:
		case IDM_SHIFTLINEUP:
		case IDM_SHIFTLINEDOWN:
			OnScrollAccelerator(cmd);
			break;
	}
}



//
//
// Function:    OnInitMenuPopup
//
// Purpose:     Process a WM_INITMENUPOPUP event
//
//
void WbMainWindow::OnInitMenuPopup
(
    HMENU   hMenu,
    UINT    uiIndex,
    BOOL    bSystemMenu
)
{

    // Ignore the event if it relates to the system menu
    if (!bSystemMenu)
    {
        if (hMenu)
        {
            SetMenuStates(hMenu);
            m_hInitMenu = hMenu;
        }
        else
        {
            m_hInitMenu = NULL;
        }

        // Save the last menu we handled, so that we can alter its state
        // if necessary whilst it is still visible
    }
}


//
//
// Function:    GetMenuWithItem
//
// Purpose:     Return the menu which contains the specified item.
//
//
HMENU WbMainWindow::GetMenuWithItem(HMENU hMenu, UINT uiID)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GetMenuWithItem");

    ASSERT(hMenu != NULL);

    HMENU hMenuResult = NULL;

    // Get the number ofitems in the menu
    UINT uiNumItems = ::GetMenuItemCount(hMenu);
    UINT   uiPos;
    UINT   uiNextID;

    // Look for the item through the menu
    for (uiPos = 0; uiPos < uiNumItems; uiPos++)
    {
        // Get the ID of the item at this position
        uiNextID = ::GetMenuItemID(hMenu, uiPos);

        if (uiNextID == uiID)
        {
            // We have found the item
            hMenuResult = hMenu;
            break;
        }
    }

    // If we have not yet found the item
    if (hMenuResult == NULL)
    {
        // Look through each of the submenus of the current menu
        HMENU hSubMenu;

        for (uiPos = 0; uiPos < uiNumItems; uiPos++)
        {
            // Get the ID of the item at this position
            uiNextID = ::GetMenuItemID(hMenu, uiPos);

            // If the item is a submenu
            if (uiNextID == -1)
            {
                // Get the submenu
                hSubMenu = ::GetSubMenu(hMenu, (int) uiPos);

                // Search the submenu
                hMenuResult = GetMenuWithItem(hSubMenu, uiID);
                if (hMenuResult != NULL)
                {
                    // We have found the menu with the requested item
                    break;
                }
            }
        }
    }

    return hMenuResult;
}



//
//
// Function:    WbMainWindow::InitializeMenus
//
// Purpose:     Initialise the menus: set up owner-drawn menu items and
//              those read from options file.
//
//
void WbMainWindow::InitializeMenus(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::InitializeMenus");

    // Make the width menu ownerdraw
    HMENU hMenu = GetMenuWithItem(::GetMenu(m_hwnd), IDM_WIDTH_1);
    if (hMenu != NULL)
    {
        // Change each entry to be ownerdraw (loop until failure)
        int iIndex;
        UINT uiId;
        int iCount = ::GetMenuItemCount(hMenu);

        for (iIndex = 0; iIndex < iCount; iIndex++)
        {
            uiId = ::GetMenuItemID(hMenu, iIndex);
            ::ModifyMenu(hMenu, iIndex,
                        MF_BYPOSITION
                      | MF_ENABLED
                      | MF_OWNERDRAW,
                      uiId,
                      NULL);
        }
    }
}




//
//
// Function:    CheckMenuItem
//
// Purpose:     Check an item on the application menus (main and context
//              menu.)
//
//
void WbMainWindow::CheckMenuItem(UINT uiId)
{
    CheckMenuItemRecursive(::GetMenu(m_hwnd), uiId, MF_BYCOMMAND | MF_CHECKED);
    CheckMenuItemRecursive(m_hContextMenu, uiId, MF_BYCOMMAND | MF_CHECKED);
    CheckMenuItemRecursive(m_hGrobjContextMenu, uiId, MF_BYCOMMAND | MF_CHECKED);
}

//
//
// Function:    UncheckMenuItem
//
// Purpose:     Uncheck an item on the application menus (main and context
//              menus.)
//
//
void WbMainWindow::UncheckMenuItem(UINT uiId)
{
    CheckMenuItemRecursive(::GetMenu(m_hwnd), uiId, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItemRecursive(m_hContextMenu, uiId, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItemRecursive(m_hGrobjContextMenu, uiId, MF_BYCOMMAND | MF_UNCHECKED);
}

//
//
// Function:    CheckMenuItemRecursive
//
// Purpose:     Check or uncheck an item on the any of the Whiteboard menus.
//              This function recursively searches through the menus until
//              it finds the specified item. The menu item Ids must be
//              unique for this function to work.
//
//
BOOL WbMainWindow::CheckMenuItemRecursive(HMENU hMenu,
                                            UINT uiId,
                                            BOOL bCheck)
{
    UINT uiNumItems = ::GetMenuItemCount(hMenu);

    // Attempt to check the menu item
    UINT uiCheck = MF_BYCOMMAND | (bCheck ? MF_CHECKED : MF_UNCHECKED);

    // A return code of -1 from CheckMenuItem implies that
    // the menu item was not found
    BOOL bChecked = ((::CheckMenuItem(hMenu, uiId, uiCheck) == -1) ? FALSE : TRUE);
    if (bChecked)
    {
        //
        // If this item is on the active menu, ensure it's redrawn now
        //
        if (hMenu == m_hInitMenu)
        {
            InvalidateActiveMenu();
        }
    }
    else
    {
        UINT   uiPos;
        HMENU hSubMenu;

        // Recurse through the submenus of the specified menu
        for (uiPos = 0; uiPos < uiNumItems; uiPos++)
        {
            // Assume that the next item is a submenu
            // and try to get a pointer to it
            hSubMenu = ::GetSubMenu(hMenu, (int)uiPos);

            // NULL return implies the item is a not submenu
            if (hSubMenu != NULL)
            {
                // Item is a submenu, make recursive call to search it
                bChecked = CheckMenuItemRecursive(hSubMenu, uiId, bCheck);
                if (bChecked)
                {
                    // We have found the item
                    break;
                }
            }
        }
    }

    return bChecked;
}

//
//
//  Function:  InvalidateActiveMenu
//
//  Purpose:   If a menu is currently active, gray items according to
//             the current state, and force it to redraw.
//
//
void WbMainWindow::InvalidateActiveMenu()
{
  if (m_hInitMenu != NULL)
  {
      // A menu is displayed, so set the state appropriately and force a
      // repaint to show the new state
      SetMenuStates(m_hInitMenu);

      ::RedrawWindow(::GetTopWindow(::GetDesktopWindow()),
                     NULL, NULL,
                     RDW_FRAME | RDW_INVALIDATE | RDW_ERASE |
                                   RDW_ERASENOW | RDW_ALLCHILDREN);
  }
}

//
//
// Function:    SetMenuState
//
// Purpose:     Sets menu contents to their correct enabled/disabled state
//
//
void WbMainWindow::SetMenuStates(HMENU hInitMenu)
{
    BOOL  bLocked;
    BOOL  bPageOrderLocked;
    BOOL  bPresentationMode;
    UINT  uiEnable;
    UINT  uiCountPages;
    BOOL  bIdle;
    BOOL  bSelected;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::SetMenuStates");

    //
    // Check menu exists
    //
    if (hInitMenu == NULL)
    {
        WARNING_OUT(("Menu doesn't exist"));
        return;
    }

    HMENU hMainMenu = ::GetMenu(m_hwnd);

    // Get the window's main menu and check that the menu
    // now being popped up is one on the top-level. (We do not
    // seem to be able to associate the index number passed with
    // sub-menus easily.)
    if ((hInitMenu != m_hContextMenu) && (hInitMenu != m_hGrobjContextMenu))
    {
        BOOL bTopLevel = FALSE;

        int nCount = ::GetMenuItemCount(hMainMenu);

        for (int nNext = 0; nNext < nCount; nNext++)
        {
            HMENU hNextMenu = ::GetSubMenu(hMainMenu, nNext);
            if (hNextMenu != NULL)
            {
                if (hNextMenu == hInitMenu)
                {
                    bTopLevel = TRUE;
                    break;
                }
            }
        }

        // not a top level, so leave the function now
        if (!bTopLevel)
        {
            TRACE_DEBUG(("Not top-level menu"));
            return;
        }
    }

	BOOL bImNotLocked = (g_pCurrentWorkspace ? (g_pCurrentWorkspace->GetUpdatesEnabled() ? TRUE : g_pNMWBOBJ->m_LockerID == g_MyMemberID) :FALSE);
	BOOL bIsThereAnything = IsThereAnythingInAnyWorkspace();
	BOOL bIsThereSomethig = bImNotLocked && (g_pCurrentWorkspace && g_pCurrentWorkspace->GetHead() != NULL) ? TRUE : FALSE;
	BOOL bIsThereTrash = bImNotLocked && (g_pTrash->GetHead() != NULL) && (g_pCurrentWorkspace != NULL);
	BOOL bIsSomethingSelected = bImNotLocked && g_pDraw->GraphicSelected() && g_pDraw->GetSelectedGraphic()->GraphicTool() != TOOLTYPE_REMOTEPOINTER && g_pCurrentWorkspace != NULL;
	BOOL bIsSynced = g_pDraw->IsSynced();
	BOOL bOnlyOnePage = (g_pListOfWorkspaces->GetHead() == g_pListOfWorkspaces->GetTail());

    //
    // Functions which are disabled when contents is locked
    //
    uiEnable = MF_BYCOMMAND | (bImNotLocked && bIsSynced ? MF_ENABLED : MF_GRAYED);

	//
	// File menu
	//
    ::EnableMenuItem(hInitMenu, IDM_NEW,     uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_OPEN,    uiEnable);

    uiEnable = MF_BYCOMMAND | (bIsThereAnything ? MF_ENABLED : MF_GRAYED);
    ::EnableMenuItem(hInitMenu, IDM_SAVE,    uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_SAVE_AS, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_PRINT,   uiEnable);

	//
	// Tools menu
	//
    uiEnable = MF_BYCOMMAND | (bImNotLocked ? MF_ENABLED : MF_GRAYED);
    ::EnableMenuItem(hInitMenu, IDM_SELECT,    uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_ERASER, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_PEN, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_HIGHLIGHT, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_GRAB_AREA, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_GRAB_WINDOW, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_LINE, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_BOX, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_FILLED_BOX, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_ELLIPSE, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_FILLED_ELLIPSE, uiEnable);
	::EnableMenuItem(hInitMenu, IDM_TEXT, m_drawingArea.Zoomed() ? MF_BYCOMMAND | MF_GRAYED : uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_ZOOM, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_REMOTE, uiEnable);

	::EnableMenuItem(hInitMenu, IDM_FONT, MF_BYCOMMAND | bImNotLocked && m_pCurrentTool->HasFont() ? MF_ENABLED : MF_GRAYED);
    ::EnableMenuItem(hInitMenu, IDM_EDITCOLOR, MF_BYCOMMAND | bImNotLocked && m_pCurrentTool->HasColor() ? MF_ENABLED : MF_GRAYED);

    HMENU hToolsMenu = ::GetSubMenu(hMainMenu, MENUPOS_TOOLS);
    uiEnable = (bImNotLocked && m_pCurrentTool->HasWidth()) ? MF_ENABLED : MF_GRAYED;

    if (hToolsMenu == hInitMenu )
    {
        ::EnableMenuItem(hToolsMenu, TOOLSPOS_WIDTH, MF_BYPOSITION | uiEnable );
    }


	UINT i;
	UINT uIdmCurWidth = 0;
    if( uiEnable == MF_ENABLED )
        uIdmCurWidth = m_pCurrentTool->GetWidthIndex() + IDM_WIDTH_1;

    for( i=IDM_WIDTH_1; i<=IDM_WIDTH_4; i++ )
    {
        ::EnableMenuItem(hInitMenu,  i, uiEnable );

        if( uiEnable == MF_ENABLED )
        {
            if( uIdmCurWidth == i )
                ::CheckMenuItem(hInitMenu, i, MF_CHECKED );
            else
                ::CheckMenuItem(hInitMenu, i, MF_UNCHECKED );
        }
    }


	//
	// Edit Menu
	//
    uiEnable = MF_BYCOMMAND | (bIsSomethingSelected? MF_ENABLED : MF_GRAYED);
    ::EnableMenuItem(hInitMenu, IDM_DELETE, uiEnable );
    ::EnableMenuItem(hInitMenu, IDM_CUT, uiEnable );
    ::EnableMenuItem(hInitMenu, IDM_COPY, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_BRING_TO_TOP, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_SEND_TO_BACK, uiEnable);

    uiEnable = MF_BYCOMMAND | (bIsThereSomethig ?MF_ENABLED : MF_GRAYED);
    ::EnableMenuItem(hInitMenu, IDM_CLEAR_PAGE, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_SELECTALL, uiEnable);

    ::EnableMenuItem(hInitMenu, IDM_PASTE, MF_BYCOMMAND | CLP_AcceptableClipboardFormat() && bImNotLocked ?  MF_ENABLED : MF_GRAYED);
    ::EnableMenuItem(hInitMenu, IDM_UNDELETE, MF_BYCOMMAND | (bIsThereTrash? MF_ENABLED : MF_GRAYED) );

    ::EnableMenuItem(hInitMenu, IDM_DELETE_PAGE, MF_BYCOMMAND | bIsSynced && bImNotLocked && !bOnlyOnePage ? MF_ENABLED : MF_GRAYED);
    ::EnableMenuItem(hInitMenu, IDM_PAGE_INSERT_AFTER, MF_BYCOMMAND | bIsSynced && bImNotLocked && g_numberOfWorkspaces < WB_MAX_WORKSPACES ? MF_ENABLED : MF_GRAYED);

	//
	// View Menu
	//
    ::EnableMenuItem(hInitMenu, IDM_SYNC, MF_BYCOMMAND | (bImNotLocked && !m_drawingArea.IsLocked()? MF_ENABLED : MF_GRAYED));
    ::EnableMenuItem(hInitMenu, IDM_LOCK, MF_BYCOMMAND |((bImNotLocked && bIsSynced) ? MF_ENABLED : MF_GRAYED));


	//
    // Enable toolbar
	//
    EnableToolbar(bImNotLocked);

	//
    // Enable page controls
	//
    m_AG.EnablePageCtrls(bImNotLocked);
}


//
//
// Function:    WbMainWindow destructor
//
// Purpose:     Tidy up main window on destruction.
//
//
WbMainWindow::~WbMainWindow()
{
    //
    // Destroy the tooltip window
    //
    if (m_hwndToolTip)
    {
        ::DestroyWindow(m_hwndToolTip);
        m_hwndToolTip = NULL;
    }


    if (m_hGrobjContextMenuBar != NULL)
    {
        ::DestroyMenu(m_hGrobjContextMenuBar);
        m_hGrobjContextMenuBar = NULL;
    }
    m_hGrobjContextMenu = NULL;

    if (m_hContextMenuBar != NULL)
    {
        ::DestroyMenu(m_hContextMenuBar);
        m_hContextMenuBar = NULL;
    }
    m_hContextMenu = NULL;

	POSITION position = m_pageToPosition.GetHeadPosition();

	PAGE_POSITION * pPoint;

	while (position)
	{
		pPoint = (PAGE_POSITION*)m_pageToPosition.GetNext(position);
		delete pPoint;
	}

	m_pageToPosition.EmptyList();

    //
    // Free the palette
    //
    if (g_hRainbowPaletteDisplay)
    {
        if (g_pDraw && g_pDraw->m_hDCCached)
        {
            // Select out the rainbow palette so we can delete it
            ::SelectPalette(g_pDraw->m_hDCCached, (HPALETTE)::GetStockObject(DEFAULT_PALETTE), TRUE);
        }

        DeletePalette(g_hRainbowPaletteDisplay);
        g_hRainbowPaletteDisplay = NULL;
    }

    g_bPalettesInitialized = FALSE;
    g_bUsePalettes = FALSE;

    if (g_pIcons)
    {
        delete g_pIcons;
        g_pIcons = NULL;
    }

	if(m_pTitleFileName)
	{
		delete m_pTitleFileName;
        m_pTitleFileName = NULL;
	}

	//
	// Delete all the objectsb in global lists
	//
	DeleteAllWorkspaces(FALSE);
    ASSERT(g_pListOfWorkspaces);
  	g_pListOfWorkspaces->EmptyList();

    ASSERT(g_pListOfObjectsThatRequestedHandles);
   	g_pListOfObjectsThatRequestedHandles->EmptyList();

	g_numberOfWorkspaces = 0;

    //
    // Delete objects in limbo, sitting in the undelete trash
    //
    ASSERT(g_pTrash);

    T126Obj* pGraphic;

	//
    // Burn trash
	//
    pGraphic = (T126Obj *)g_pTrash->RemoveTail();
	while (pGraphic != NULL)
    {
	   	delete pGraphic;
	    pGraphic = (T126Obj *) g_pTrash->RemoveTail();
    }

	DeleteAllRetryPDUS();

	DestroyToolArray();

	::DestroyWindow(m_hwnd);
	::UnregisterClass(szMainClassName, g_hInstance);


}

//
// OnToolHitTest()
// This handles tooltips for child windows.
//
int WbMainWindow::OnToolHitTest(POINT pt, TOOLINFO* pTI) const
{
    HWND    hwnd;
    int     status;
    int     nHit;

    ASSERT(!IsBadWritePtr(pTI, sizeof(TOOLINFO)));

    hwnd = ::ChildWindowFromPointEx(m_hwnd, pt, CWP_SKIPINVISIBLE);
    if (hwnd == m_AG.m_hwnd)
    {
        ::MapWindowPoints(m_hwnd, m_AG.m_hwnd, &pt, 1);
        hwnd = ::ChildWindowFromPointEx(m_AG.m_hwnd, pt, CWP_SKIPINVISIBLE);

        if (hwnd != NULL)
        {
            nHit = ::GetDlgCtrlID(hwnd);

            pTI->hwnd = m_hwnd;
            pTI->uId = (UINT_PTR)hwnd;
            pTI->uFlags |= TTF_IDISHWND;
            pTI->lpszText = LPSTR_TEXTCALLBACK;

            return(nHit);
        }
    }
    else if (hwnd == m_WG.m_hwnd)
    {
        int iItem;

        ::MapWindowPoints(m_hwnd, m_WG.m_hwnd, &pt, 1);

        iItem = m_WG.ItemFromPoint(pt.x, pt.y);

        pTI->hwnd = m_WG.m_hwnd;
        pTI->uId  = iItem;

        // Since the area isn't a window, we must fill in the rect ourself
        m_WG.GetItemRect(iItem, &pTI->rect);
        pTI->lpszText = LPSTR_TEXTCALLBACK;

        return(iItem);
    }
    else if (hwnd == m_TB.m_hwnd)
    {
        RECT        rect;
        TBBUTTON    button;
        int         i;

        for (i = 0; i < TOOLBAR_MAXBUTTON; i++)
        {
            if (::SendMessage(m_TB.m_hwnd, TB_GETITEMRECT, i, (LPARAM)&rect) &&
                ::PtInRect(&rect, pt) &&
                ::SendMessage(m_TB.m_hwnd, TB_GETBUTTON, i, (LPARAM)&button) &&
                !(button.fsStyle & TBSTYLE_SEP))
            {
                int nHit = button.idCommand;

                pTI->hwnd = m_TB.m_hwnd;
                pTI->uId = nHit;
                pTI->rect = rect;
                pTI->lpszText = LPSTR_TEXTCALLBACK;

                // found matching rect, return the ID of the button
                return(nHit);
            }
        }
    }

    return(-1);
}


//
// WinHelp() wrapper
//
LRESULT WbMainWindow::ShowHelp(void)
{
    HWND hwndCapture;

    // Get the main window out of any mode
    ::SendMessage(m_hwnd, WM_CANCELMODE, 0, 0);

    // Cancel any other tracking
    if (hwndCapture = ::GetCapture())
        ::SendMessage(hwndCapture, WM_CANCELMODE, 0, 0);

	// finally, run the NetMeeting Help engine
    ShowNmHelp(s_cszHtmlHelpFile);

    return S_OK;
}


//
// TimedDlgProc()
// This puts up a visible or invisible dialog which only goes away when
// an event occurs or a certain amount of time has passed.  We store the
// DialogBoxParam parameter, a TMDLG pointer, in our user data.  That is
// from the stack of the DialogBoxParam() caller, so it is valid until that
// function returns, which won't be until a bit after the dialog has been
// destroyed.
//
INT_PTR CALLBACK TimedDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL        fHandled = FALSE;
    TMDLG *     ptm;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            ptm = (TMDLG *)lParam;
            ASSERT(!IsBadWritePtr(ptm, sizeof(TMDLG)));
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)ptm);

            //
            // Set the WbMainWindow hwnd
            //
            if (ptm->bLockNotEvent)
            {
                g_pMain->m_hwndWaitForLockDlg = hwnd;
            }
            else
            {
                g_pMain->m_hwndWaitForEventDlg = hwnd;
            }

            //
            // Set max timer
            //
            ::SetTimer(hwnd, TIMERID_MAXDISPLAY, ptm->uiMaxDisplay, NULL);

            //
            // Change the cursor if invisible
            //
            if (!ptm->bVisible)
                ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

            fHandled = TRUE;
            break;

        case WM_TIMER:
            ASSERT(wParam == TIMERID_MAXDISPLAY);

            // End the dialog--since we timed out, it acts like cancel
            ::SendMessage(hwnd, WM_COMMAND, MAKELONG(IDCANCEL, BN_CLICKED), 0);

            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                    {
                        ptm = (TMDLG *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
                        ASSERT(!IsBadWritePtr(ptm, sizeof(TMDLG)));

                        // Clear out the HWND variable
                        if (ptm->bLockNotEvent)
                        {
                            g_pMain->m_hwndWaitForLockDlg = NULL;
                        }
                        else
                        {
                            g_pMain->m_hwndWaitForEventDlg = NULL;
                        }

                        // Restore the cursor
                        if (!ptm->bVisible)
                            ::SetCursor(::LoadCursor(NULL, IDC_ARROW));

                        ::KillTimer(hwnd, TIMERID_MAXDISPLAY);

                        ::EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
                    }
                    break;
            }

            fHandled = TRUE;
            break;

        //
        // Don't let these dialogs be killed by any other means than our
        // getting an event or timing out.
        //
        case WM_CLOSE:
            fHandled = TRUE;
            break;
    }

    return(fHandled);
}


//
// FilterMessage()
//
// This does tooltip message filtering, then translates accelerators.
//
BOOL WbMainWindow::FilterMessage(MSG* pMsg)
{
    BOOL   bResult = FALSE;

   	if ((pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST) ||
    	(pMsg->message == WM_LBUTTONDOWN || pMsg->message == WM_LBUTTONDBLCLK) ||
	    (pMsg->message == WM_RBUTTONDOWN || pMsg->message == WM_RBUTTONDBLCLK) ||
	    (pMsg->message == WM_MBUTTONDOWN || pMsg->message == WM_MBUTTONDBLCLK) ||
	    (pMsg->message == WM_NCLBUTTONDOWN || pMsg->message == WM_NCLBUTTONDBLCLK) ||
	    (pMsg->message == WM_NCRBUTTONDOWN || pMsg->message == WM_NCRBUTTONDBLCLK) ||
	    (pMsg->message == WM_NCMBUTTONDOWN || pMsg->message == WM_NCMBUTTONDBLCLK))
   	{
        // Cancel any tooltip up
        ::SendMessage(m_hwndToolTip, TTM_ACTIVATE, FALSE, 0);
   	}

	// handle tooltip messages (some messages cancel, some may cause it to popup)
	if ((pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_NCMOUSEMOVE ||
		 pMsg->message == WM_LBUTTONUP || pMsg->message == WM_RBUTTONUP ||
		 pMsg->message == WM_MBUTTONUP) &&
		(GetKeyState(VK_LBUTTON) >= 0 && GetKeyState(VK_RBUTTON) >= 0 &&
		 GetKeyState(VK_MBUTTON) >= 0))
	{
#if 0
        //
        // If this mouse move isn't for a descendant of the main window, skip
        // it.  For example, when the tooltip is shown, it gets a mousemove
        // to itself, which if we didn't check for it, would cause us to
        // immediately dismiss this!
        //
        HWND    hwndTmp = pMsg->hwnd;

        while (hwndTmp && (::GetWindowLong(hwndTmp, GWL_STYLE) & WS_CHILD))
        {
            hwndTmp = ::GetParent(hwndTmp);
        }

        if (hwndTmp != m_hwnd)
        {
            // This is not for us, it's for another top level window in
            // our app.
            goto DoneToolTipFiltering;
        }
#endif

		// determine which tool was hit
        POINT   pt;

        pt = pMsg->pt;
		::ScreenToClient(m_hwnd, &pt);

		TOOLINFO tiHit;

        ZeroMemory(&tiHit, sizeof(tiHit));
		tiHit.cbSize = sizeof(TOOLINFO);

		int nHit = OnToolHitTest(pt, &tiHit);

		if (m_nLastHit != nHit)
		{
			if (nHit != -1)
			{
				// add new tool and activate the tip
                if (!::SendMessage(m_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&tiHit))
                {
                    ERROR_OUT(("TTM_ADDTOOL failed"));
                }

				if (::GetActiveWindow() == m_hwnd)
				{
					// allow the tooltip to popup when it should
                    ::SendMessage(m_hwndToolTip, TTM_ACTIVATE, TRUE, 0);

					// bring the tooltip window above other popup windows
					::SetWindowPos(m_hwndToolTip, HWND_TOP, 0, 0, 0, 0,
						SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOMOVE);
				}
			}

			// relay mouse event before deleting old tool
            ::SendMessage(m_hwndToolTip, TTM_RELAYEVENT, 0, (LPARAM)pMsg);

			// now safe to delete the old tool
            if (m_tiLastHit.cbSize != 0)
                ::SendMessage(m_hwndToolTip, TTM_DELTOOL, 0, (LPARAM)&m_tiLastHit);

            m_nLastHit = nHit;
            m_tiLastHit = tiHit;
		}
		else
		{
			// relay mouse events through the tooltip
			if (nHit != -1)
                ::SendMessage(m_hwndToolTip, TTM_RELAYEVENT, 0, (LPARAM)pMsg);
		}
	}

#if 0
DoneToolTipFiltering:
#endif
    // Assume we will use the main accelerator table
    HACCEL hAccelTable = m_hAccelTable;

    // If this window has focus, just continue
    HWND hwndFocus = ::GetFocus();
    if (hwndFocus && (hwndFocus != m_hwnd))
    {
        // Check whether an edit field in the pages group has the focus
        if (m_AG.IsChildEditField(hwndFocus))
        {
            hAccelTable = m_hAccelPagesGroup;
        }
        // Check whether text editor has the focus and is active
        else if (   (hwndFocus == m_drawingArea.m_hwnd)
                 && (m_drawingArea.TextEditActive()))
        {
            // Let editbox do its own acceleration.
            hAccelTable = NULL;
        }
    }

    return (   (hAccelTable != NULL)
          && ::TranslateAccelerator(m_hwnd, hAccelTable, pMsg));
}

//
//
// Function:    OnDisplayError
//
// Purpose:     Display an error message
//
//
void WbMainWindow::OnDisplayError(WPARAM uiFEReturnCode, LPARAM uiDCGReturnCode)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDisplayError");

    // Only continue if we are not currently displaying an error
    if (!m_bDisplayingError)
    {
        // Show that we are currently displaying an error message
        m_bDisplayingError = TRUE;

        // Display the error
        ::ErrorMessage((UINT)uiFEReturnCode, (UINT)uiDCGReturnCode);

        // Show that we are no longer displaying an error
        m_bDisplayingError = FALSE;
    }
}


//
//
// Function:    OnPaletteChanged
//
// Purpose:     The palette has changed.
//
//
void WbMainWindow::OnPaletteChanged(HWND hwndPalette)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnPaletteChanged");

    if ((hwndPalette != m_hwnd) &&
        (hwndPalette != m_drawingArea.m_hwnd))
    {
        // Tell the drawing area to realize its palette
        m_drawingArea.RealizePalette( TRUE );
    }
}



//
//
// Function:    OnQueryNewPalette
//
// Purpose:     We are getting focus and must realize our palette
//
//
LRESULT WbMainWindow::OnQueryNewPalette(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnQueryNewPalette");

    // Tell the drawing area to realize its palette
    m_drawingArea.RealizePalette( FALSE );

    return TRUE;
}

//
//
// Function:    PopupContextMenu
//
// Purpose:     Popup the context menu for the drawing area. This is called
//              by the drawing area window on a right mouse click.
//
//
void WbMainWindow::PopupContextMenu(int x, int y)
{
    POINT   surfacePos;
    RECT    clientRect;
    T126Obj * pGraphic;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::PopupContextMenu");

    surfacePos.x = x;
    surfacePos.y = y;

    m_drawingArea.ClientToSurface(&surfacePos);
    if( (pGraphic = m_drawingArea.GetHitObject( surfacePos )) != NULL
		&& pGraphic->GraphicTool() != TOOLTYPE_REMOTEPOINTER )
    {
		if(!pGraphic->IsSelected() )
		{
			g_pDraw->SelectGraphic(pGraphic);
		}

        // selector tool is active, and one or more objects are selected
        m_hInitMenu = m_hGrobjContextMenu;

	}
    else
    {
		// no current selection, show drawing menu
		m_hInitMenu = m_hContextMenu;
	}


    // set up current menu state
    SetMenuStates(m_hInitMenu);

    // pop it up
    ::GetClientRect(m_drawingArea.m_hwnd, &clientRect);
    ::MapWindowPoints(m_drawingArea.m_hwnd, NULL, (LPPOINT)&clientRect.left, 2);

    ::TrackPopupMenu(m_hInitMenu, TPM_RIGHTALIGN | TPM_RIGHTBUTTON,
                                 x + clientRect.left,
                                 y + clientRect.top,
                                 0,
                                 m_hwnd,
                                 NULL);

    // reset m_hInitMenu to indicate the popup menu isn't being shown anymore
    m_hInitMenu = NULL;

}




//
//
// Function:    OnSize
//
// Purpose:     The window has been resized.
//
//
void WbMainWindow::OnSize(UINT nType, int cx, int cy )
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnSize");

    // Only process this message if the window is not minimized
    if (nType != SIZE_MINIMIZED)
    {

	    // The user's view has changed
	    PositionUpdated();

		if (m_bStatusBarOn)
		{
			::ShowWindow(m_hwndSB, SW_HIDE);
		}
	
		// Resize the subpanes of the window
		ResizePanes();

		// Show it again
		if (m_bStatusBarOn)
		{
			::ShowWindow(m_hwndSB, SW_SHOW);
		}

	    // If the status has changed, set the option
	    if (m_uiWindowSize != nType)
	    {
	        m_uiWindowSize = nType;

	        // Write the new option values to file
	        OPT_SetBooleanOption(OPT_MAIN_MAXIMIZED,
	                             (m_uiWindowSize == SIZE_MAXIMIZED));
	        OPT_SetBooleanOption(OPT_MAIN_MINIMIZED,
	                             (m_uiWindowSize == SIZE_MINIMIZED));
    	}
	}
}

//
//
// Function:    SaveWindowPosition
//
// Purpose:     Save the current window position to the options file.
//
//
void WbMainWindow::SaveWindowPosition(void)
{
    RECT    rectWindow;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::SaveWindowPosition");

    // Get the new window rectangle
    ::GetWindowRect(m_hwnd, &rectWindow);

    // Write the new option values to file
    OPT_SetWindowRectOption(&rectWindow);
}


//
//
// Function:    ResizePanes
//
// Purpose:     Resize the subpanes of the main window.
//
//
void WbMainWindow::ResizePanes(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::ResizePanes");

    //
    //
    // The client area is organized as follows:
    //
    //  -------------------------------------
    //  |   |                               |
    //  | T |                               |
    //  | o |   Drawing Area                |
    //  | o |                               |
    //  | l |                               |
    //  | s |                               |
    //  |---|                               |
    //  | W |                               |
    //  | i |                               |
    //  | d |                               |
    //  | t |                               |
    //  | h |                               |
    //  | s |                               |
    //  |-----------------------------------|
    //  | Attributes (colors)   | Pages     |
    //  |-----------------------------------|
    //  |       Status                      |
    //  -------------------------------------
    //
    //

    RECT clientRect;
    RECT rectStatusBar;
    RECT rectToolBar;
    RECT rectWG;
    RECT rectAG;
    RECT rectDraw;
    SIZE size;
    SIZE sizeAG;

    // Get the client rectangle
    ::GetClientRect(m_hwnd, &clientRect);
    rectStatusBar = clientRect;

    // Resize the help bar and progress meter
    if (m_bStatusBarOn)
    {
        rectStatusBar.top = rectStatusBar.bottom - STATUSBAR_HEIGHT;

        ::MoveWindow(m_hwndSB, rectStatusBar.left, rectStatusBar.top,
            rectStatusBar.right - rectStatusBar.left,
            rectStatusBar.bottom - rectStatusBar.top, TRUE);
    }
    else
    {
        // Status bar is off - set it's height to zero
        rectStatusBar.top = rectStatusBar.bottom;
    }

    // Resize the tool and width windows
    m_TB.GetNaturalSize(&size);
    rectToolBar.left  = 0;
    rectToolBar.right = rectToolBar.left + size.cx;
    rectToolBar.top =  0;
    rectToolBar.bottom = rectToolBar.top + size.cy;

    m_WG.GetNaturalSize(&size);
    rectWG.left = rectToolBar.left;
    rectWG.top = rectToolBar.bottom;
    rectWG.bottom = rectWG.top + size.cy;

    if (!m_bToolBarOn)
    {
        // Toolbar is either off or floating - set its width to zero
        rectToolBar.right = rectToolBar.left;
    }
    rectWG.right = rectToolBar.right;

    // Position attribute group
    m_AG.GetNaturalSize(&sizeAG);

    ::MoveWindow(m_AG.m_hwnd, rectToolBar.left, rectStatusBar.top - sizeAG.cy,
        clientRect.right - rectToolBar.left, sizeAG.cy, TRUE);

    // finish fiddling with tools and widths bars
    if (m_bToolBarOn)
    {
        //
        // We make the toolbar, which includes the width bar, extend all
        // down the left side.
        //
        rectToolBar.bottom = rectStatusBar.top - sizeAG.cy;
        rectWG.left += TOOLBAR_MARGINX;
        rectWG.right -= 2*TOOLBAR_MARGINX;

        ::MoveWindow(m_TB.m_hwnd, rectToolBar.left,
            rectToolBar.top, rectToolBar.right - rectToolBar.left,
            rectToolBar.bottom - rectToolBar.top, TRUE);

        ::MoveWindow(m_WG.m_hwnd, rectWG.left, rectWG.top,
            rectWG.right - rectWG.left, rectWG.bottom - rectWG.top, TRUE);

        ::BringWindowToTop(m_WG.m_hwnd);
    }

    // Resize the drawing pane
    rectDraw = clientRect;
    rectDraw.bottom = rectStatusBar.top - sizeAG.cy;
    rectDraw.left   = rectToolBar.right;
    ::MoveWindow(m_drawingArea.m_hwnd, rectDraw.left, rectDraw.top,
        rectDraw.right - rectDraw.left, rectDraw.bottom - rectDraw.top, TRUE);

    // Check to see if Width group is overlapping Attributes group. This can happen if
    // the menu bar has wrapped because the window isn't wide enough (bug 424)
    RECT crWidthWnd;
    RECT crAttrWnd;

    ::GetWindowRect(m_WG.m_hwnd, &crWidthWnd);
    ::GetWindowRect(m_AG.m_hwnd, &crAttrWnd);

    if (crAttrWnd.top < crWidthWnd.bottom)
    {
        // the menu bar has wrapped and our height placements are wrong. Adjust window
        // by difference and try again
        RECT crMainWnd;

        ::GetWindowRect(m_hwnd, &crMainWnd);
        crMainWnd.bottom += (crWidthWnd.bottom - crAttrWnd.top + ::GetSystemMetrics(SM_CYFIXEDFRAME));

        ::MoveWindow(m_hwnd, crMainWnd.left, crMainWnd.top,
            crMainWnd.right - crMainWnd.left, crMainWnd.bottom - crMainWnd.top,
            FALSE);

        // this is going to recurse but the adjustment will happen only once.....
    }
}


//
//
// Function:    WbMainWindow::OnGetMinMaxInfo
//
// Purpose:     Set the minimum and maximum tracking sizes of the window
//
//
void WbMainWindow::OnGetMinMaxInfo(LPMINMAXINFO lpmmi)
{
    if (m_TB.m_hwnd == NULL)
        return; // not ready to do this yet

    SIZE    csFrame;
    SIZE    csSeparator;
    SIZE    csAG;
    SIZE    csToolBar;
    SIZE    csWidthBar;
    SIZE    csMaxSize;
    SIZE    csScrollBars;

    csFrame.cx = ::GetSystemMetrics(SM_CXSIZEFRAME);
    csFrame.cy = ::GetSystemMetrics(SM_CYSIZEFRAME);

    csSeparator.cx = ::GetSystemMetrics(SM_CXEDGE);
    csSeparator.cy = ::GetSystemMetrics(SM_CYEDGE);

    csScrollBars.cx = ::GetSystemMetrics(SM_CXVSCROLL);
    csScrollBars.cy = ::GetSystemMetrics(SM_CYHSCROLL);

    m_AG.GetNaturalSize(&csAG);

    m_TB.GetNaturalSize(&csToolBar);
    m_WG.GetNaturalSize(&csWidthBar);


    // Set the minimum width and height of the window
    lpmmi->ptMinTrackSize.x =
      csFrame.cx + csAG.cx + csFrame.cx;

    lpmmi->ptMinTrackSize.y =
      csFrame.cy +
      GetSystemMetrics( SM_CYCAPTION ) +
      GetSystemMetrics( SM_CYMENU ) +
      csToolBar.cy +
      csWidthBar.cy +
      csSeparator.cy +
      csAG.cy +
      csSeparator.cy +
      csFrame.cy +
      STATUSBAR_HEIGHT;

    //
    // Retrieves the size of the work area on the primary display monitor. The work
    // area is the portion of the screen not obscured by the system taskbar or by
    // application desktop toolbars
    //
    RECT rcWorkArea;
    ::SystemParametersInfo( SPI_GETWORKAREA, 0, (&rcWorkArea), NULL );
    csMaxSize.cx = rcWorkArea.right - rcWorkArea.left;
    csMaxSize.cy = rcWorkArea.bottom - rcWorkArea.top;

    lpmmi->ptMaxPosition.x  = 0;
    lpmmi->ptMaxPosition.y  = 0;
    lpmmi->ptMaxSize.x      = csMaxSize.cx;
    lpmmi->ptMaxSize.y      = csMaxSize.cy;
    lpmmi->ptMaxTrackSize.x = csMaxSize.cx;
    lpmmi->ptMaxTrackSize.y = csMaxSize.cy;
}


//
//
// Function:    WbMainWindow::CreateContextMenus
//
// Purpose:     Create the pop-up context menus: used within the application
//              drawing area.
//
//
BOOL WbMainWindow::CreateContextMenus(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CreateContextMenus");

    m_hContextMenuBar = ::LoadMenu(g_hInstance, MAKEINTRESOURCE(CONTEXTMENU));
    if (!m_hContextMenuBar)
    {
        ERROR_OUT(("Failed to create context menu"));
        DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
        return FALSE;
    }
    m_hContextMenu = ::GetSubMenu(m_hContextMenuBar, 0);

    m_hGrobjContextMenuBar = ::LoadMenu(g_hInstance, MAKEINTRESOURCE(GROBJMENU));
    if (!m_hGrobjContextMenuBar)
    {
        ERROR_OUT(("Failed to create grobj context menu"));
        DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
        return FALSE;
    }
    m_hGrobjContextMenu = ::GetSubMenu(m_hGrobjContextMenuBar, 0);

    // make parts of m_hGrobjContextMenu be owner draw
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_1, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_1, NULL);
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_2, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_2, NULL);
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_3, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_3, NULL);
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_4, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_4, NULL);

    return TRUE;
}




//
//
// Function:    WbMainWindow::OnMeasureItem
//
// Purpose:     Return the size of an item in the widths menu
//
//
void WbMainWindow::OnMeasureItem
(
    int                 nIDCtl,
    LPMEASUREITEMSTRUCT measureStruct
)
{
    // Check that this is for a color menu item
    if (    (measureStruct->itemID >= IDM_WIDTHS_START)
         && (measureStruct->itemID < IDM_WIDTHS_END))
    {
        measureStruct->itemWidth  = ::GetSystemMetrics(SM_CXMENUCHECK) +
            (2 * CHECKMARK_BORDER_X) + COLOR_MENU_WIDTH;
        measureStruct->itemHeight = ::GetSystemMetrics(SM_CYMENUCHECK) +
            (2 * CHECKMARK_BORDER_Y);
    }
}

//
//
// Function:    WbMainWindow::OnDrawItem
//
// Purpose:     Draw an item in the color menu
//
//
void WbMainWindow::OnDrawItem
(
    int     nIDCtl,
    LPDRAWITEMSTRUCT drawStruct
)
{
    COLORREF crMenuBackground;
    COLORREF crMenuText;
    HPEN     hOldPen;
    HBRUSH      hOldBrush;
    COLORREF crOldBkgnd;
    COLORREF crOldText;
    int         nOldBkMode;
    HBITMAP hbmp = NULL;
    BITMAP  bitmap;
    UINT    uiCheckWidth;
    UINT    uiCheckHeight;
    RECT    rect;
    RECT    rectCheck;
    RECT    rectLine;
    HDC     hMemDC;
    UINT    uiWidthIndex;
    UINT    uiWidth;
    HPEN    hPenMenu;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDrawItem");

    // Check that this is a width menu item
    if( (drawStruct->itemID < IDM_WIDTHS_START) ||
        (drawStruct->itemID >= IDM_WIDTHS_END) )
    {
        return;
    }

    // get menu item colors
    if( (drawStruct->itemState & ODS_SELECTED) ||
        ((drawStruct->itemState & (ODS_SELECTED |ODS_CHECKED)) ==
            (ODS_SELECTED |ODS_CHECKED))
        )
    {
        crMenuBackground = COLOR_HIGHLIGHT;
        crMenuText = COLOR_HIGHLIGHTTEXT;
    }
    else if( drawStruct->itemState & ODS_GRAYED)
    {
        crMenuBackground = COLOR_MENU;
        crMenuText = COLOR_GRAYTEXT;
    }
    else
    {
        crMenuBackground = COLOR_MENU;
        crMenuText = COLOR_MENUTEXT;
    }

    hPenMenu = ::CreatePen(PS_SOLID, 0, ::GetSysColor(crMenuBackground));
    if (!hPenMenu)
    {
        TRACE_MSG(("Failed to create penMenu"));
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    rect = drawStruct->rcItem;

    // Fill the whole box with current menu background color
    hOldPen     = SelectPen(drawStruct->hDC, hPenMenu);
    hOldBrush   = SelectBrush(drawStruct->hDC, GetSysColorBrush(crMenuBackground));

    ::Rectangle(drawStruct->hDC, rect.left, rect.top, rect.right, rect.bottom);

    SelectBrush(drawStruct->hDC, hOldBrush);
    SelectPen(drawStruct->hDC, hOldPen);

    if( (hbmp = (HBITMAP)LoadImage( NULL, MAKEINTRESOURCE( OBM_CHECK ), IMAGE_BITMAP,
                0,0, 0 ))
        == NULL )
    {
        TRACE_MSG(("Failed to create check image"));
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    // Get the width and height of the bitmap (allowing some border)
    ::GetObject(hbmp, sizeof(BITMAP), &bitmap);
    uiCheckWidth  = bitmap.bmWidth  + (2 * CHECKMARK_BORDER_X);
    uiCheckHeight = bitmap.bmHeight;

    // Draw in a checkmark (if needed)
    if (drawStruct->itemState & ODS_CHECKED)
    {
        hMemDC = ::CreateCompatibleDC(drawStruct->hDC);
        if (!hMemDC)
        {
            ERROR_OUT(("Failed to create memDC"));
            ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
            goto bail_out;
        }

        crOldBkgnd = ::SetBkColor(drawStruct->hDC, GetSysColor( crMenuBackground ) );
        crOldText = ::SetTextColor(drawStruct->hDC, GetSysColor( crMenuText ) );
        nOldBkMode = ::SetBkMode(drawStruct->hDC, OPAQUE );

        HBITMAP hOld = SelectBitmap(hMemDC, hbmp);

        if (hOld != NULL)
        {
            rectCheck = rect;
            rectCheck.top += ((rectCheck.bottom - rectCheck.top)/2 - uiCheckHeight/2);
            rectCheck.right  = rectCheck.left + uiCheckWidth;
            rectCheck.bottom = rectCheck.top + uiCheckHeight;

            ::BitBlt(drawStruct->hDC, rectCheck.left,
                        rectCheck.top,
                        rectCheck.right - rectCheck.left,
                        rectCheck.bottom - rectCheck.top,
                        hMemDC,
                        0,
                        0,
                        SRCCOPY);

            SelectBitmap(hMemDC, hOld);
        }

        ::SetBkMode(drawStruct->hDC, nOldBkMode);
        ::SetTextColor(drawStruct->hDC, crOldText);
        ::SetBkColor(drawStruct->hDC, crOldBkgnd);

        ::DeleteDC(hMemDC);
    }

    DeleteBitmap(hbmp);

    // Allow room for the checkmark to the left of the color
    rect.left += uiCheckWidth;

    uiWidthIndex = drawStruct->itemID - IDM_WIDTHS_START;
    uiWidth = g_PenWidths[uiWidthIndex];

    // If pens are very wide they can be larger than the allowed rectangle.
    // So we reduce the clipping rectangle here. We save the DC so that we
    // can restore it - getting the clip region back.
    if (::SaveDC(drawStruct->hDC) == 0)
    {
        ERROR_OUT(("Failed to save DC"));
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    if (::IntersectClipRect(drawStruct->hDC, rect.left, rect.top,
        rect.right, rect.bottom) == ERROR)
    {
        ERROR_OUT(("Failed to set clip rect"));

        ::RestoreDC(drawStruct->hDC, -1);
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    hOldPen   = SelectPen(drawStruct->hDC, hPenMenu);
    hOldBrush = SelectBrush(drawStruct->hDC, GetSysColorBrush(crMenuText));

    rectLine.left = rect.left;
    rectLine.top    = rect.top + ((rect.bottom - rect.top) / 2) - uiWidth/2;
    rectLine.right= rect.right - ((rect.right - rect.left) / 6);
    rectLine.bottom = rectLine.top + uiWidth + 2;

    ::Rectangle(drawStruct->hDC, rectLine.left, rectLine.top,
        rectLine.right, rectLine.bottom);

    SelectBrush(drawStruct->hDC, hOldBrush);
    SelectPen(drawStruct->hDC, hOldPen);

    ::RestoreDC(drawStruct->hDC, -1);

bail_out:
    if (hPenMenu != NULL)
    {
        ::DeletePen(hPenMenu);
    }
}



//
//
// Function:    OnSetFocus
//
// Purpose:     The window is getting the focus
//
//
void WbMainWindow::OnSetFocus(void)
{
    // We pass the focus on to the main drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}


//
//
// Function:    OnParentNotfiy
//
// Purpose:     Process a message coming from a child window
//
//
void WbMainWindow::OnParentNotify(UINT uiMessage)
{
    switch (uiMessage)
    {
        // Scroll message from the drawing area. These are sent when the user
        // scrolls the area using the scroll bars. We queue an update of the
        // current sync position.
        case WM_HSCROLL:
        case WM_VSCROLL:
            // The user's view has changed
            PositionUpdated();
            break;
    }
}


//
//
// Function:    QuerySaveRequired
//
// Purpose:     Check whether the drawing pane contents are to be saved
//              before a destructive function is performed.
//
//
int WbMainWindow::QuerySaveRequired(BOOL bCancelBtn)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::QuerySaveRequired");

    // If we are not maximized
    if (!::IsZoomed(m_hwnd) && !::IsIconic(m_hwnd))
    {
        // Save the new position of the window
        SaveWindowPosition();
    }

    // Default the response to "no save required"
    int  iResult = IDNO;

    //
    // If we are already displaying a "Save As" dialog, dismiss it.
    //
    if (m_hwndQuerySaveDlg != NULL)
    {
        ::SendMessage(m_hwndQuerySaveDlg, WM_COMMAND,
            MAKELONG(IDCANCEL, BN_CLICKED), 0);
        ASSERT(m_hwndQuerySaveDlg == NULL);
    }

    // If any of the pages has changed - ask the user if they want to
    // save the contents of the Whiteboard.
    if (g_bContentsChanged  && IsThereAnythingInAnyWorkspace())
    {
        ::SetForegroundWindow(m_hwnd); //bring us to the top first

        // SetForegroundWindow() does not work properly in Memphis when its called during a
        // SendMessage handler, specifically, when conf calls me to shutdown. The window activation
        // state is messed up or something and my window does not pop to the top. So I have to
        // force my window to the top using SetWindowPos. But even after that the titlebar is not
        // highlighted properly. I tried combinations of SetActiveWindow, SetFocus, etc but to no
        // avail. But, at least the dialog is visible so you can clear it thus fixing the
        // bug (NM4db:2103). SetForegroundWindow() works ok for Win95 and NT here without
        // having to use SetWindowPos (it doesn't hurt anyting to do it anyway so I didn't
        // do a platform check).
        ::SetWindowPos(m_hwnd, HWND_TOPMOST, 0,0, 0,0, SWP_NOMOVE | SWP_NOSIZE );       // force to top
        ::SetWindowPos(m_hwnd, HWND_NOTOPMOST, 0,0, 0,0, SWP_NOMOVE | SWP_NOSIZE );  // let go of topmost

        //
        // Display a dialog box with the relevant question
        //      LOWORD of user data is "cancel command is allowed"
        //      HIWORD of user data is "disable cancel button"
        //
        iResult = (int)DialogBoxParam(g_hInstance,
            bCancelBtn ? MAKEINTRESOURCE(QUERYSAVEDIALOGCANCEL)
                       : MAKEINTRESOURCE(QUERYSAVEDIALOG),
            m_hwnd,
            QuerySaveDlgProc,
            MAKELONG(bCancelBtn, FALSE));
    }

    return iResult;
}



//
// QuerySaveDlgProc()
// Handler for query save dialogs.  We save some flags in GWL_USER
//
INT_PTR CALLBACK QuerySaveDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            //
            // Save away our HWND so this dialog can be cancelled if necessary
            //
            g_pMain->m_hwndQuerySaveDlg = hwnd;

            // Remember the flags we passed
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);

            // Should the cancel button be disabled?
            if (HIWORD(lParam))
                ::EnableWindow(::GetDlgItem(hwnd, IDCANCEL), FALSE);

            // Bring us to the front
            ::SetForegroundWindow(hwnd);

            fHandled = TRUE;
            break;

        case WM_CLOSE:
            // Even if the cancel button is disabled, kill the dialog
            ::PostMessage(hwnd, WM_COMMAND, IDCANCEL, 0);
            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDCANCEL:
                    //
                    // If a dialog doesn't have a cancel button or it's
                    // disabled and the user pressed the close btn, we can
                    // get here.
                    //
                    if (!LOWORD(::GetWindowLongPtr(hwnd, GWLP_USERDATA)))
                        wParam = MAKELONG(IDNO, HIWORD(wParam));
                    // FALL THRU

                case IDYES:
                case IDNO:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                    {
                        g_pMain->m_hwndQuerySaveDlg = NULL;

                        ::EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
                        break;
                    }
                    break;
            }
            fHandled = TRUE;
            break;
    }

    return(fHandled);
}


//
//
// Function:    OnNew
//
// Purpose:     Clear the workspace and associated filenames
//
//
LRESULT WbMainWindow::OnNew(void)
{
    int iDoNew;

    if( UsersMightLoseData( NULL, NULL ) ) // bug NM4db:418
        return S_OK;


    // check state before proceeding - if we're already doing a new, then abort
    if (m_uiSubState == SUBSTATE_NEW_IN_PROGRESS)
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return S_OK;
    }
    // if we're currently loading, then cancel the load and proceed (don't
    // prompt to save).
    else if (m_uiSubState == SUBSTATE_LOADING)
    {
        // cancel load, not releasing the page order lock, because
        // we need it immediately afterwards
        CancelLoad(FALSE);
        iDoNew = IDNO;
    }
    // otherwise prompt to save if necessary
    else
    {
        // Get confirmation for the new
        iDoNew = QuerySaveRequired(TRUE);
    }

    if (iDoNew == IDYES)
    {
        // Save the changes
        iDoNew = (int)OnSave(FALSE);
    }

    // If the user did not cancel the operation, clear the drawing area
    if (iDoNew != IDCANCEL)
    {
        //
        // Remember if we had a remote pointer.
        // In OldWB, the remote pointer is a global thing that clearing
        //      doesn't get rid of.
        // In T.126WB, it's just an object on a page, so we need to add
        //      it back because we're deleting the old pages and creating
        //      new ones.
        //
        BOOL bRemote = FALSE;
        if (m_pLocalRemotePointer)
        {
            // Remove remote pointer from pages
            bRemote = TRUE;
            OnRemotePointer();
        }

    	::InvalidateRect(g_pDraw->m_hwnd, NULL, TRUE);
	    DeleteAllWorkspaces(TRUE);

	    WorkspaceObj * pObj;
	    DBG_SAVE_FILE_LINE
    	pObj = new WorkspaceObj();
	    pObj->AddToWorkspace();

        if (bRemote)
        {
            // Put it back
            OnRemotePointer();
        }

        // Clear the associated file name
        ZeroMemory(m_strFileName, sizeof(m_strFileName));

        // Update the window title with no file name
        UpdateWindowTitle();
    }

    return S_OK;
}

//
//
// Function:    OnNextPage
//
// Purpose:     Move to the next worksheet in the pages list
//
//
LRESULT WbMainWindow::OnNextPage(void)
{
	// Go to the next page
	if(g_pCurrentWorkspace)
	{
		WBPOSITION pos = g_pCurrentWorkspace->GetMyPosition();
		g_pListOfWorkspaces->GetNext(pos);
		if(pos)
		{
			WorkspaceObj* pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
			GotoPage(pWorkspace);
		}
	}
	return S_OK;
}

//
//
// Function:    OnPrevPage
//
// Purpose:     Move to the previous worksheet in the pages list
//
//
LRESULT WbMainWindow::OnPrevPage(void)
{
	if(g_pCurrentWorkspace)
	{
		WBPOSITION pos = g_pCurrentWorkspace->GetMyPosition();
		g_pListOfWorkspaces->GetPrevious(pos);
		if(pos)
		{
			WorkspaceObj* pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetPrevious(pos);
			GotoPage(pWorkspace);
		}
	}
    return S_OK;
}

//
//
// Function:    OnFirstPage
//
// Purpose:     Move to the first worksheet in the pages list
//
//
LRESULT WbMainWindow::OnFirstPage(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnFirstPage");

	WorkspaceObj * pWorkspace = (WorkspaceObj *)g_pListOfWorkspaces->GetHead();
	GotoPage(pWorkspace);
    return S_OK;
}

//
//
// Function:    OnLastPage
//
// Purpose:     Move to the last worksheet in the pages list
//
//
LRESULT WbMainWindow::OnLastPage(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnLastPage");

	WorkspaceObj * pWorkspace = (WorkspaceObj *)g_pListOfWorkspaces->GetTail();
    GotoPage(pWorkspace);
    return S_OK;
}

//
//
// Function:    OnGotoPage
//
// Purpose:     Move to the specified page (if it exists)
//
//
LRESULT WbMainWindow::OnGotoPage(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGotoPage");

	// Get the requested page number from the pages group
	UINT uiPageNumber = m_AG.GetCurrentPageNumber() - 1;

	WBPOSITION pos;
	WorkspaceObj* pWorkspace = NULL;

	pos = g_pListOfWorkspaces->GetHeadPosition();

	while(pos && uiPageNumber != 0)
	{
		g_pListOfWorkspaces->GetNext(pos);
		uiPageNumber--;
	}

	if(pos)
	{
		pWorkspace = (WorkspaceObj *)g_pListOfWorkspaces->GetNext(pos);
		GotoPage(pWorkspace);
	}

    return S_OK;
}

//
// Check if remote pointer was on before we go to page
//
void WbMainWindow::GotoPage(WorkspaceObj * pNewWorkspace, BOOL bSend)
{

	//
	// If we were editing text
	//
	if (g_pDraw->TextEditActive())
   	{
		g_pDraw->EndTextEntry(TRUE);
	}

	//
	// If we had a remote pointer
	//
	BOOL bRemote = FALSE;
	if(m_pLocalRemotePointer)
	{
		bRemote = TRUE;
		OnRemotePointer();
	}
	
	//
	// Undraw remote pointers
	//
	T126Obj * pPointer = g_pCurrentWorkspace->GetTail();
	WBPOSITION pos = g_pCurrentWorkspace->GetTailPosition();
	while(pos && pPointer->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{
		pPointer->UnDraw();	
		pPointer = (T126Obj*) g_pCurrentWorkspace->GetPreviousObject(pos);	
	}

	GoPage(pNewWorkspace, bSend);

	//
	// Draw remote pointers back
	//
	pPointer = g_pCurrentWorkspace->GetTail();
	pos = g_pCurrentWorkspace->GetTailPosition();
	while(pos && pPointer->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{
		pPointer->Draw();	
		pPointer = (T126Obj*) g_pCurrentWorkspace->GetPreviousObject(pos);	
	}



	//
	// If we had a remote pointer
	//
	if(bRemote)
	{
		OnRemotePointer();
	}
}






//
//
// Function:    GoPage
//
// Purpose:     Move to the specified page
//
//
void WbMainWindow::GoPage(WorkspaceObj * pNewWorkspace, BOOL bSend)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GotoPage");

	// If we are changing pages
	if (pNewWorkspace != g_pCurrentWorkspace)
	{

		m_drawingArea.CancelDrawingMode();

		// Attach the new page to the drawing area
		m_drawingArea.Attach(pNewWorkspace);

		// set the focus back to the drawing area
		if (!(m_AG.IsChildEditField(::GetFocus())))
		{
			::SetFocus(m_drawingArea.m_hwnd);
		}

		::InvalidateRect(m_drawingArea.m_hwnd, NULL, TRUE );
		::UpdateWindow(m_drawingArea.m_hwnd);

		//
		// Tell the other nodes we moved to a different page.
		//
		if(bSend)
		{
			//
			// Set the view state
			//
			pNewWorkspace->SetViewState(focus_chosen);
			pNewWorkspace->SetViewActionChoice(editView_chosen);
			pNewWorkspace->OnObjectEdit();

		}
	}

	UpdatePageButtons();
}


//
//
// Function:	GotoPosition
//
// Purpose:		Move to the specified position within the page
//
//
void WbMainWindow::GotoPosition(int x, int y)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GotoPosition");

    // Move the drawing area to the new position
    m_drawingArea.GotoPosition(x, y);

    // The user's view has changed
    PositionUpdated();
}


//
//
// Function:    LoadFile
//
// Purpose:     Load a metafile into the application. Errors are reported
//              to the caller by the return code.
//
//
void WbMainWindow::LoadFile
(
    LPCSTR szLoadFileName
)
{
    UINT    uRes;

    // Check we're in idle state
    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        goto UserPointerCleanup;
    }

    if (*szLoadFileName)
    {
        // Change the cursor to "wait"
        ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

        // Set the state to say that we are loading a file
        SetSubstate(SUBSTATE_LOADING);

       // Load the file
       uRes = ContentsLoad(szLoadFileName);
       if (uRes != 0)
       {
           DefaultExceptionHandler(WBFE_RC_WB, uRes);
           goto UserPointerCleanup;
       }

        // Set the window title to the new file name
        lstrcpy(m_strFileName, szLoadFileName);

		// Update the window title with the new file name

		g_bContentsChanged = FALSE;
    }

UserPointerCleanup:
	// Set the state to say that we are loading a file
	SetSubstate(SUBSTATE_IDLE);

    // Restore the cursor
    ::SetCursor(::LoadCursor(NULL, IDC_ARROW));
}

//
//
// Function:    OnDropFiles
//
// Purpose:     Files have been dropped onto the Whiteboard window
//
//
void WbMainWindow::OnDropFiles(HDROP hDropInfo)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDropFiles");

    UINT  uiFilesDropped = 0;
    UINT  eachfile;
	PT126WB_FILE_HEADER_AND_OBJECTS pHeader = NULL;

    // Get the total number of files dropped
    uiFilesDropped = ::DragQueryFile(hDropInfo, (UINT) -1, NULL, (UINT) 0);

    // release mouse capture in case we report any errors (message boxes
    // won't repsond to mouse clicks if we don't)
    ReleaseCapture();

    for (eachfile = 0; eachfile < uiFilesDropped; eachfile++)
    {
        // Retrieve each file name
        char  szDropFileName[256];

        ::DragQueryFile(hDropInfo, eachfile,
            szDropFileName, 256);

        TRACE_MSG(("Loading file: %s", szDropFileName));

		OnOpen(szDropFileName);
    }

    ::DragFinish(hDropInfo);
}

//
//
// Function:    OnOpen
//
// Purpose:     Load a metafile into the application.
//
//
LRESULT WbMainWindow::OnOpen(LPCSTR szLoadFileName)
{
    int iOnSave;


	if(g_pDraw->IsLocked() || !g_pDraw->IsSynced())
	{
	    DefaultExceptionHandler(WBFE_RC_WB, WB_RC_BAD_STATE);
	    return S_FALSE;
	}	


    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnOpen");

    if( UsersMightLoseData( NULL, NULL ) ) // bug NM4db:418
        return S_OK;

    // Check we're in idle state
    if ((m_uiSubState == SUBSTATE_NEW_IN_PROGRESS))
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return S_OK;
      }

    // Don't prompt to save file if we're already loading
    if (m_uiSubState != SUBSTATE_LOADING)
    {
        // Check whether there are changes to be saved
        iOnSave = QuerySaveRequired(TRUE);
    }
    else
    {
        iOnSave = IDNO;
    }

    if (iOnSave == IDYES)
    {
        // User wants to save the drawing area contents
        int iResult = (int)OnSave(TRUE);

        if (iResult == IDOK)
        {
        }
        else
        {
            // cancelled out of Save As, so cancel the open operation
            iOnSave = IDCANCEL;
        }
    }

    // Only continue if the user has not cancelled the operation
    if (iOnSave != IDCANCEL)
    {
		//
		// If the filename was passed
		//
		if(szLoadFileName)
		{
			LoadFile(szLoadFileName);
		}
		else
		{

			OPENFILENAME    ofn;
			TCHAR           szFileName[_MAX_PATH];
			TCHAR           szFileTitle[64];
			TCHAR           strLoadFilter[2*_MAX_PATH];
			TCHAR           strDefaultExt[_MAX_PATH];
			TCHAR           strDefaultPath[2*_MAX_PATH];
			TCHAR *         pStr;
  			UINT            strSize = 0;
      		UINT            totalSize;

			// Build the filter for loadable files
			pStr = strLoadFilter;
			totalSize = 2*_MAX_PATH;

			// These must be NULL separated, with a double NULL at the end
			strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT, pStr, totalSize) + 1;
			pStr += strSize;
			ASSERT(totalSize > strSize);
			totalSize -= strSize;

			strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT_SPEC, pStr, totalSize) + 1;
			pStr += strSize;
			ASSERT(totalSize > strSize);
			totalSize -= strSize;

			strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL, pStr, totalSize) + 1;
			pStr += strSize;
			ASSERT(totalSize > strSize);
			totalSize -= strSize;

			strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL_SPEC, pStr, totalSize) + 1;
			pStr += strSize;
			ASSERT(totalSize > strSize);
			totalSize -= strSize;

			*pStr = 0;

			//
			// Setup the OPENFILENAME struct
			//
			ZeroMemory(&ofn, sizeof(ofn));
			ofn.lStructSize = sizeof(ofn);
			ofn.hwndOwner = m_hwnd;

			// No file name supplied to begin with
			szFileName[0] = 0;
			ofn.lpstrFile = szFileName;
			ofn.nMaxFile = _MAX_PATH;

			// Default Extension:  .NMW
			::LoadString(g_hInstance, IDS_EXT_WHT, strDefaultExt, sizeof(strDefaultExt));
			ofn.lpstrDefExt = strDefaultExt;

			// Default file title is empty
			szFileTitle[0] = 0;
			ofn.lpstrFileTitle = szFileTitle;
			ofn.nMaxFileTitle = 64;

			// Open flags
			ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_EXPLORER;
			ofn.hInstance = g_hInstance;

			// Filter
			ofn.lpstrFilter = strLoadFilter;

			// Default path
			if (GetDefaultPath(strDefaultPath, sizeof(strDefaultPath)))
				ofn.lpstrInitialDir = strDefaultPath;

			// Get user input, continue only if the user selects the OK button
			if (::GetOpenFileName(&ofn))
			{
				// Change the cursor to "wait"
				::SetCursor(::LoadCursor(NULL, IDC_WAIT));

				// if we're currently loading a file, cancel it, not releasing
				// the page order lock, because we need it immediately afterwards
				if (m_uiSubState == SUBSTATE_LOADING)
				{
					CancelLoad(FALSE);
				}

				// Load the file
				LoadFile(ofn.lpstrFile);
			}
		}
	}

	// Update the window title with no file name
	UpdateWindowTitle();

    return S_OK;
}


//
//
// Function:    GetFileName
//
// Purpose:     Get a file name for saving the contents
//
//
int WbMainWindow::GetFileName(void)
{
    OPENFILENAME    ofn;
    int             iResult;
    TCHAR           szFileTitle[64];
    TCHAR           strSaveFilter[2*_MAX_PATH];
    TCHAR           strDefaultExt[_MAX_PATH];
    TCHAR           strDefaultPath[2 * _MAX_PATH];
    TCHAR           szFileName[2*_MAX_PATH];
    TCHAR *         pStr;
    UINT            strSize = 0;
    UINT            totalSize;

    //
    // If we are already displaying a "Save As" dialog, dismiss it and create
    // a new one.  This can happen if Win95 shuts down whilst WB is
    // displaying the "Save As" dialog and the use selects "Yes" when asked
    // whether they want to save the contents - a second "Save As dialog
    // appears on top of the first.
    //
    if (m_bInSaveDialog)
    {
        CancelSaveDialog();
    }

    // Build the filter for save files
    pStr = strSaveFilter;
    totalSize = 2*_MAX_PATH;

    // These must be NULL separated, with a double NULL at the end
    strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT_SPEC, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL_SPEC, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    *pStr = 0;

    //
    // Setup the OPENFILENAME struct
    //
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hwnd;

    lstrcpy(szFileName, m_strFileName);
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = _MAX_PATH;

    // Build the default extension string
    ::LoadString(g_hInstance, IDS_EXT_WHT, strDefaultExt, sizeof(strDefaultExt));
    ofn.lpstrDefExt = strDefaultExt;

    szFileTitle[0] = 0;
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = 64;

    // Save flags
    ofn.Flags = OFN_HIDEREADONLY | OFN_NOREADONLYRETURN |
        OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
    ofn.hInstance = g_hInstance;

    // Filter
    ofn.lpstrFilter = strSaveFilter;

    // Default path
    if (GetDefaultPath(strDefaultPath, sizeof(strDefaultPath)))
        ofn.lpstrInitialDir = strDefaultPath;

    m_bInSaveDialog = TRUE;

    if (::GetSaveFileName(&ofn))
    {
        // The user selected OK
        iResult = IDOK;
        lstrcpy(m_strFileName, szFileName);
    }
    else
    {
        iResult = IDCANCEL;
    }

    m_bInSaveDialog = FALSE;

    return iResult;
}


//
//
// Function:    OnSave
//
// Purpose:     Save the contents of the Whiteboard using the current file
//              name (or prompting for a new name if there is no current).
//
//
LRESULT WbMainWindow::OnSave(BOOL bPrompt)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnSave");

    LRESULT iResult = IDOK;

    // save the old file name in case there's an error
    TCHAR strOldName[2*MAX_PATH];
    UINT fileNameSize = lstrlen(m_strFileName);
    lstrcpy(strOldName, m_strFileName);

    BOOL bNewName = FALSE;

    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return(iResult);
    }

    // Check whether there is a filename available for use
    if (!fileNameSize || (bPrompt))
    {
        // Get user input, continue only if the user selects the OK button
        iResult = GetFileName();

        if (iResult == IDOK)
        {
            // entering a blank file name is treated as cancelling the save
            if (!lstrlen(m_strFileName))
            {
                lstrcpy(m_strFileName, strOldName);
                iResult = IDCANCEL;
            }
            else
            {
                // flag that we've changed the contents file name
                bNewName = TRUE;
            }
        }
    }

    // Now save the file
    if ((iResult == IDOK) && lstrlen(m_strFileName))
    {
        WIN32_FIND_DATA findFileData;
        HANDLE          hFind;

        // Get attributes
        hFind = ::FindFirstFile(m_strFileName, &findFileData);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            ::FindClose(hFind);

            // This is a read-only file; we can't change its contents
            if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                WARNING_OUT(("Dest file %s is read only", m_strFileName));
                ::Message(NULL, IDS_SAVE, IDS_SAVE_READ_ONLY);

                // If the file name was changed for this save then undo
                // the change
                if (bNewName)
                {
                    lstrcpy(m_strFileName, strOldName);
                    bNewName = FALSE;
                }

                // Change the return code to indicate no save was made
                iResult = IDCANCEL;
                return(iResult);
            }
        }

        // Change the cursor to "wait"
        ::SetCursor(::LoadCursor(NULL,IDC_WAIT));

        // Write the file
        if (ContentsSave(m_strFileName) != 0)
        {
            // Show that an error occurred saving the file.
            WARNING_OUT(("Error saving file"));
            ::Message(NULL, IDS_SAVE, IDS_SAVE_ERROR);

            // If the file name was changed for this save then undo
            // the change
            if (bNewName)
            {
                lstrcpy(m_strFileName, strOldName);
                bNewName = FALSE;
            }

            // Change the return code to indicate no save was made
            iResult = IDCANCEL;
        }
        else
        {
        	g_bContentsChanged = FALSE;
        }

        // Restore the cursor
        ::SetCursor(::LoadCursor(NULL,IDC_ARROW));
    }

    // if the contents file name has changed as a result of the save then
    // update the window title
    if (bNewName)
    {
		UpdateWindowTitle();
    }

    return(iResult);
}


//
// CancelSaveDialog()
// This cancels the save as dialog if up and we need to kill it to continue.
// We walk back up the owner chain in case the save dialog puts up help or
// other owned windows.
//
void WbMainWindow::CancelSaveDialog(void)
{
    WBFINDDIALOG        wbf;

    ASSERT(m_bInSaveDialog);

    wbf.hwndOwner = m_hwnd;
    wbf.hwndDialog = NULL;
    EnumThreadWindows(::GetCurrentThreadId(), WbFindCurrentDialog, (LPARAM)&wbf);

    if (wbf.hwndDialog)
    {
        // Found it!
        ::SendMessage(wbf.hwndDialog, WM_COMMAND, IDCANCEL, 0);
    }

    m_bInSaveDialog = FALSE;
}



BOOL CALLBACK WbFindCurrentDialog(HWND hwndNext, LPARAM lParam)
{
    WBFINDDIALOG * pwbf = (WBFINDDIALOG *)lParam;

    // Is this a dialog, owned by the main window?
    if ((::GetClassLong(hwndNext, GCW_ATOM) == 0x8002) &&
        (::GetWindow(hwndNext, GW_OWNER) == pwbf->hwndOwner))
    {
        pwbf->hwndDialog = hwndNext;
        return(FALSE);
    }

    return(TRUE);
}


//
//
// Function:    OnClose
//
// Purpose:     Close the Whiteboard
//
//
void WbMainWindow::OnClose()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnClose");

    int iOnSave = IDOK;

    m_drawingArea.CancelDrawingMode();

    m_AG.SaveSettings();

    // If we got here, by way of OnDestroy from the DCL cores or
    // by system shutdown, then assume that user responded already to the
    // save-changes dialog that would have poped up during conf's global shutdown
    // message. We don't need to ask 'em again. What tangled webs......
    if ((!m_bQuerySysShutdown) && (IsIdle()))
    {
        // Check whether there are changes to be saved
        iOnSave = QuerySaveRequired(TRUE);
        if (iOnSave == IDYES)
        {
            // User wants to save the drawing area contents
            iOnSave = (int)OnSave(TRUE);
        }
    }

    // If the exit was not cancelled, close the application
    if (iOnSave != IDCANCEL)
    {
        // Close the application
        ::PostQuitMessage(0);

    }

}


//
//
// Function:    OnClearPage
//
// Purpose:     Clear the Whiteboard drawing area. The user is prompted to
//              choose clearing of foreground, background or both.
//
//
LRESULT WbMainWindow::OnClearPage(BOOL bClearAll)
{
    LRESULT iResult;
    BOOL bWasPosted;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnClearPage");

    if( UsersMightLoseData( &bWasPosted, NULL ) ) // bug NM4db:418
        return S_OK;

    if( bWasPosted )
        iResult = IDYES;
    else
        iResult = ::Message(NULL, bClearAll == FALSE ? IDS_DELETE_PAGE : IDS_CLEAR_CAPTION, bClearAll == FALSE ? IDS_DELETE_PAGE_MESSAGE : IDS_CLEAR_MESSAGE, MB_YESNO | MB_ICONQUESTION);


    if ((iResult == IDYES) && bClearAll)
    {
		OnSelectAll();
		OnDelete();
		
        TRACE_MSG(("User requested clear of page"));
	}
	return iResult;
}




//
//
// Function:    OnDelete
//
// Purpose:     Delete the current selection
//
//
LRESULT WbMainWindow::OnDelete()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDelete");


    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

	// Delete the currently selected graphics and add to m_LastDeletedGraphic
	m_drawingArea.EraseSelectedDrawings();

    return S_OK;
}

//
//
// Function:	OnUndelete
//
// Purpose:	 Undo the last delete operation
//
//
LRESULT WbMainWindow::OnUndelete()
{
	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnUndelete");

	// If there is a deleted graphic to restore
   	T126Obj * pObj;
	pObj = (T126Obj *)g_pTrash->RemoveHead();
	while (pObj != NULL)
	{
		if(!AddT126ObjectToWorkspace(pObj))
		{
			return S_FALSE;
		}
		if(pObj->GetMyWorkspace() == g_pCurrentWorkspace)
		{
			pObj->Draw(FALSE);
		}

        //
        // Make sure it gets added back as unselected.  It was selected
        // when deleted.
        //
        pObj->ClearDeletionFlags();
        pObj->SetAllAttribs();
        pObj->SetViewState(unselected_chosen);
        pObj->SendNewObjectToT126Apps();

		pObj = (T126Obj *) g_pTrash->RemoveHead();
	}
	return S_OK;
}


//
//
// Function:    OnSelectAll
//
// Purpose:     Select all the objects in the current page
//
//
LRESULT WbMainWindow::OnSelectAll( void )
{

	// Unselect every oject first.
	m_drawingArea.RemoveMarker();

    // turn off any selections
    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    // inhibit normal select-tool action
    m_bSelectAllInProgress = TRUE;

    //put us in select-tool mode first
    OnSelectTool(IDM_SELECT);

    // back to normal
    m_bSelectAllInProgress = FALSE;

    // now, select everything
    m_drawingArea.SelectMarkerFromRect( NULL );

	return S_OK;
}

//
//
// Function:    OnCut
//
// Purpose:     Cut the current selection
//
//
LRESULT WbMainWindow::OnCut()
{
	// Copy all the selected graphics to the clipboard
	BOOL bResult = CLP_Copy();
	
	// If an error occurred during the copy, report it now
	if (!bResult)
	{
		::Message(NULL, IDM_CUT, IDS_COPY_ERROR);
		return S_FALSE;
	}

	//
	// Erase the selected objects
	//
	OnDelete();

    return S_OK;
}


//
// OnCopy()
// Purpose:     Copy the current selection to the clipboard
//
//
LRESULT WbMainWindow::OnCopy(void)
{
	// Copy all the selected graphics to the clipboard
	BOOL bResult = CLP_Copy();

	// If an error occurred during the copy, report it now
	if (!bResult)
	{
		::Message(NULL, IDS_COPY, IDS_COPY_ERROR);
		return S_FALSE;
	}

    return S_OK;
}


//
//
// Function:    OnPaste
//
// Purpose:     Paste the contents of the clipboard into the drawing pane
//
//
LRESULT WbMainWindow::OnPaste()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnPaste");

	BOOL bResult = CLP_Paste();
	
	// If an error occurred during the copy, report it now
	if (!bResult)
	{
		::Message(NULL, IDS_PASTE, IDS_PASTE_ERROR);
		return S_FALSE;
	}

	return S_OK;
}


//
//
// Function:    OnScrollAccelerator
//
// Purpose:     Called when a scroll accelerator is used
//
//
LRESULT WbMainWindow::OnScrollAccelerator(UINT uiMenuId)
{
    int     iScroll;

    // Locate the scroll messages to be sent in the conversion table
    for (iScroll = 0; iScroll < ARRAYSIZE(s_MenuToScroll); iScroll++)
    {
        if (s_MenuToScroll[iScroll].uiMenuId == uiMenuId)
        {
            // Found it;
            break;
        }
    }

    // Send the messages
    if (iScroll < ARRAYSIZE(s_MenuToScroll))
    {
        while ((s_MenuToScroll[iScroll].uiMenuId == uiMenuId) && (iScroll < ARRAYSIZE(s_MenuToScroll)))
        {
            // Tell the drawing pane to scroll
            ::PostMessage(m_drawingArea.m_hwnd, s_MenuToScroll[iScroll].uiMessage,
                s_MenuToScroll[iScroll].uiScrollCode, 0);

            iScroll++;
        }

        // Indicate that scrolling has completed (in both directions)
        ::PostMessage(m_drawingArea.m_hwnd, WM_HSCROLL, SB_ENDSCROLL, 0L);
        ::PostMessage(m_drawingArea.m_hwnd, WM_VSCROLL, SB_ENDSCROLL, 0L);
    }
    return S_OK;
}


//
//
// Function:    OnZoom
//
// Purpose:     Zoom or unzoom the drawing area
//
//
LRESULT WbMainWindow::OnZoom()
{
    // If the drawing area is currently zoomed
    if (m_drawingArea.Zoomed())
    {
        // Tell the tool bar of the new selection
        m_TB.PopUp(IDM_ZOOM);
		UncheckMenuItem(IDM_ZOOM);

    }
    else
    {
        // Tell the tool bar of the new selection
        m_TB.PushDown(IDM_ZOOM);
		CheckMenuItem(IDM_ZOOM);

    }

    // Zoom/unzoom the drawing area
    m_drawingArea.Zoom();

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);

    return S_OK;
}


LRESULT WbMainWindow::OnLock()
{
	// If the drawing area is currently Locked
	if (m_drawingArea.IsLocked())
	{
		m_TB.PopUp(IDM_LOCK);
		UncheckMenuItem(IDM_LOCK);
	}
	else
	{
		
		m_TB.PushDown(IDM_LOCK);
		CheckMenuItem(IDM_LOCK);
		g_pNMWBOBJ->m_LockerID = g_MyMemberID;
	}
	m_drawingArea.SetLock(!m_drawingArea.IsLocked());
	TogleLockInAllWorkspaces(m_drawingArea.IsLocked(), TRUE);
	EnableToolbar( TRUE );

	return S_OK;
}


//
//
// Function:    OnSelectTool
//
// Purpose:     Select the current tool
//
//
LRESULT WbMainWindow::OnSelectTool(UINT uiMenuId)
{

    UncheckMenuItem(m_currentMenuTool);
    CheckMenuItem( uiMenuId);

    UINT uiIndex;

    // Save the new menu Id
    m_currentMenuTool = uiMenuId;

    // Tell the tool bar of the new selection
    m_TB.PushDown(m_currentMenuTool);

    // Get the new tool
    m_pCurrentTool = m_ToolArray[TOOL_INDEX(m_currentMenuTool)];

    // Set the current attributes
    if( !m_bSelectAllInProgress )
    {
        m_AG.SetChoiceColor(m_pCurrentTool->GetColor() );

        ::SendMessage(m_hwnd, WM_COMMAND, IDM_COLOR, 0L);
    }

    // Report the change of tool to the attributes group
    m_AG.DisplayTool(m_pCurrentTool);

    // Select the new tool into the drawing area
    m_drawingArea.SelectTool(m_pCurrentTool);

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
	return S_OK;
}


//
//
// Function:    OnSelectColor
//
// Purpose:     Set the current color
//
//
LRESULT WbMainWindow::OnSelectColor(void)
{
    // Tell the attributes group of the new selection and get the
    // new color value selected ino the current tool.
    m_AG.SelectColor(m_pCurrentTool);

    // Select the changed tool into the drawing area
    m_drawingArea.SelectTool(m_pCurrentTool);

    // If there is an object marked for changing
    if (m_drawingArea.GraphicSelected() || m_drawingArea.TextEditActive())
    {
		// Update the object
        m_drawingArea.SetSelectionColor(m_pCurrentTool->GetColor());
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);

    return S_OK;
}


//
//
// Function:    OnSelectWidth
//
// Purpose:     Set the current nib width
//
//
LRESULT WbMainWindow::OnSelectWidth(UINT uiMenuId)
{
    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    // Save the new pen width
    m_currentMenuWidth = uiMenuId;

    // Tell the attributes display of the new selection
    m_WG.PushDown(uiMenuId - IDM_WIDTHS_START);

    if (m_pCurrentTool != NULL)
    {
        m_pCurrentTool->SetWidthIndex(uiMenuId - IDM_WIDTHS_START);
    }

    // Tell the drawing pane of the new selection
    m_drawingArea.SelectTool(m_pCurrentTool);

	// If there is an object marked for changing
	if (m_drawingArea.GraphicSelected())
	{
		// Update the object
		m_drawingArea.SetSelectionWidth(uiMenuId - IDM_WIDTHS_START);
	}

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);

    return S_OK;
}


//
//
// Function:    OnChooseFont
//
// Purpose:     Let the user select a font
//
//
LRESULT WbMainWindow::OnChooseFont(void)
{
    HDC hdc;
    LOGFONT lfont;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnChooseFont");

    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    // It is only really sensible to be here when a text tool is selected.
    // This is achieved by graying the Font selection menu entry when
    // anything other than a text tool is in use.

    // Get the font details from the current tool
    ::GetObject(m_pCurrentTool->GetFont(), sizeof(LOGFONT), &lfont);
    lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;

    //
    // The Font dialog is passed a LOGFONT structure which it uses to
    // initialize all of its fields (face name, weight etc).
    //
    // The face name passed in the LOGFONT structure is checked by the dialog
    // against the facenames of all available fonts.  If the name does not
    // match one of the available fonts, no name is displayed.
    //
    // WB stores the LOGFONT structure specifying the font used for a text
    // object in the object.  This LOGFONT is selected into a DC where the
    // GDIs font mapper decides which physical font most closely matches the
    // required logical font.  On boxes where the original font is not
    // supported the font is substituted for the closest matching font
    // available.
    //
    // So, if we pass the LOGFONT structure for a font which is not supported
    // into the Font dialog, no facename is displayed.  To bypass this we
    //
    // - select the logical font into a DC
    //
    // - determine the textmetrics and get the face name of the physical font
    //   chosen by the Font Mapper
    //
    // - use these textmetrics to create a LOGFONT structure which matches
    //   the substituted font!
    //
    // The resulting LOGFONT will have the correct weight, dimensions and
    // facename for the substituted font.
    //
    hdc = ::CreateCompatibleDC(NULL);
    if (hdc != NULL)
    {
        TEXTMETRIC  tm;
        HFONT       hFont;
        HFONT       hOldFont;

        hFont = ::CreateFontIndirect(&lfont);

        //
        // Get the face name and text metrics of the selected font.
        //
        hOldFont = SelectFont(hdc, hFont);
        if (hOldFont == NULL)
        {
            WARNING_OUT(("Failed to select font into DC"));
        }
        else
        {
            ::GetTextMetrics(hdc, &tm);
            ::GetTextFace(hdc, LF_FACESIZE, lfont.lfFaceName);

            //
            // Restore the old font back into the DC.
            //
            SelectFont(hdc, hOldFont);

            //
            // Create a LOGFONT structure which matches the Text metrics
            // of the font used by the DC so that the font dialog manages
            // to initialise all of its fields properly, even for
            // substituted fonts...
            //
            lfont.lfHeight    =  tm.tmHeight;
            lfont.lfWidth     =  tm.tmAveCharWidth;
            lfont.lfWeight    =  tm.tmWeight;
            lfont.lfItalic    =  tm.tmItalic;
            lfont.lfUnderline =  tm.tmUnderlined;
            lfont.lfStrikeOut =  tm.tmStruckOut;
            lfont.lfCharSet   =  tm.tmCharSet;

            //ADDED BY RAND - to make lfHeight be a char height. This makes
            //                the font dlg show the same pt size that is
            //                displayed in the sample font toolbar
            if( lfont.lfHeight > 0 )
            {
                lfont.lfHeight = -(lfont.lfHeight - tm.tmInternalLeading);
            }
        }

        ::DeleteDC(hdc);

        if (hFont != NULL)
        {
            ::DeleteFont(hFont);
        }
    }
    else
    {
        WARNING_OUT(("Failed to get DC to select font into"));
    }

    CHOOSEFONT  cf;
    TCHAR       szStyleName[64];

    ZeroMemory(&cf, sizeof(cf));
    ZeroMemory(szStyleName, sizeof(szStyleName));

    cf.lStructSize = sizeof(cf);
    cf.lpszStyle = szStyleName;
    cf.rgbColors = m_pCurrentTool->GetColor() & 0x00ffffff; // blow off palette bits (NM4db:2304)
    cf.Flags = CF_EFFECTS | CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS |
        CF_NOVERTFONTS;
    cf.lpLogFont = &lfont;
    cf.hwndOwner = m_hwnd;

    // Call up the ChooseFont dialog from COM DLG
    if (::ChooseFont(&cf))
    {
        lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;

        //ADDED BY RAND - set color selected in dialog.
        m_pCurrentTool->SetColor(cf.rgbColors);
        m_AG.DisplayTool( m_pCurrentTool );

        ::SendMessage(m_hwnd, WM_COMMAND,
                (WPARAM)MAKELONG( IDM_COLOR, BN_CLICKED ),
                (LPARAM)0 );

        // Inform the drawing pane of the new selection
        HFONT   hNewFont;

        hNewFont = ::CreateFontIndirect(&lfont);
        if (!hNewFont)
        {
            ERROR_OUT(("Failed to create font"));
            DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
            return S_FALSE;
        }

        //
        // We need to set the text editor font after inserting it in the DC
        // and querying the metrics, otherwise we may get a font with different
        // metrics in zoomed mode
        //
        HFONT   hNewFont2;
        HDC hDC = m_drawingArea.GetCachedDC();
        TEXTMETRIC textMetrics;

        m_drawingArea.PrimeFont(hDC, hNewFont, &textMetrics);
        lfont.lfHeight            = textMetrics.tmHeight;
        lfont.lfWidth             = textMetrics.tmAveCharWidth;
        lfont.lfPitchAndFamily    = textMetrics.tmPitchAndFamily;
        ::GetTextFace(hDC, sizeof(lfont.lfFaceName),
                     lfont.lfFaceName);
        TRACE_MSG(("Font face name %s", lfont.lfFaceName));

        // Inform the drawing pane of the new selection
        hNewFont2 = ::CreateFontIndirect(&lfont);
        if (!hNewFont2)
        {
            ERROR_OUT(("Failed to create font"));
            DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
            return S_FALSE;
        }

		m_drawingArea.SetSelectionColor(cf.rgbColors);

        m_drawingArea.SetSelectionFont(hNewFont2);

        if (m_pCurrentTool != NULL)
        {
            m_pCurrentTool->SetFont(hNewFont2);
        }
        m_drawingArea.SelectTool(m_pCurrentTool);

        //
        // discard the new font
        //
        m_drawingArea.UnPrimeFont( hDC );

        // Delete the fonts we created--everybody above makes copies
        ::DeleteFont(hNewFont2);
        ::DeleteFont(hNewFont);
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
    return S_OK;
}


//
//
// Function:    OnToolBarToggle
//
// Purpose:     Let the user toggle the tool bar on/off
//
//
LRESULT WbMainWindow::OnToolBarToggle(void)
{
    RECT rectWnd;

    // Toggle the flag
    m_bToolBarOn = !m_bToolBarOn;

    // Make the necessary updates
    if (m_bToolBarOn)
    {
        // The tool bar was hidden, so show it
        ::ShowWindow(m_TB.m_hwnd, SW_SHOW);

        // The tool window is fixed so we must resize the other panes in
        // the window to make room for it
        ResizePanes();

        // Check the associated menu item
        CheckMenuItem(IDM_TOOL_BAR_TOGGLE);
    }
    else
    {
        // The tool bar was visible, so hide it
        ::ShowWindow(m_TB.m_hwnd, SW_HIDE);

        ResizePanes();

        // Uncheck the associated menu item
        UncheckMenuItem(IDM_TOOL_BAR_TOGGLE);

    }

    // Make sure things reflect current tool
    m_AG.DisplayTool(m_pCurrentTool);

    // Write the new option value to the options file
    OPT_SetBooleanOption(OPT_MAIN_TOOLBARVISIBLE,
                           m_bToolBarOn);

    ::GetWindowRect(m_hwnd, &rectWnd);
    ::MoveWindow(m_hwnd, rectWnd.left, rectWnd.top, rectWnd.right - rectWnd.left, rectWnd.bottom - rectWnd.top, TRUE);
	
	return S_OK;
}


//
//
// Function:    OnStatusBarToggle
//
// Purpose:     Let the user toggle the help bar on/off
//
//
void WbMainWindow::OnStatusBarToggle(void)
{
    RECT rectWnd;

    // Toggle the flag
    m_bStatusBarOn = !m_bStatusBarOn;

    // Make the necessary updates
    if (m_bStatusBarOn)
    {
        // Resize the panes to give room for the help bar
        ResizePanes();

        // The help bar was hidden, so show it
        ::ShowWindow(m_hwndSB, SW_SHOW);

        // Check the associated menu item
        CheckMenuItem(IDM_STATUS_BAR_TOGGLE);
    }
    else
    {
        // The help bar was visible, so hide it
        ::ShowWindow(m_hwndSB, SW_HIDE);

        // Uncheck the associated menu item
        UncheckMenuItem(IDM_STATUS_BAR_TOGGLE);

        // Resize the panes to take up the help bar space
        ResizePanes();
    }

    // Write the new option value to the options file
    OPT_SetBooleanOption(OPT_MAIN_STATUSBARVISIBLE, m_bStatusBarOn);

    ::GetWindowRect(m_hwnd, &rectWnd);
    ::MoveWindow(m_hwnd, rectWnd.left, rectWnd.top, rectWnd.right - rectWnd.left, rectWnd.bottom - rectWnd.top, TRUE);
}


//
//
// Function:    OnAbout
//
// Purpose:     Show the about box for the Whiteboard application. This
//              method is called whenever a WM_COMMAND with IDM_ABOUT
//              is issued by Windows.
//
//
LRESULT	WbMainWindow::OnAbout()
{
    ::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(ABOUTBOX), m_hwnd,
        AboutDlgProc, 0);
        return S_OK;
}


INT_PTR AboutDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            TCHAR   szFormat[256];
            TCHAR   szVersion[512];

            ::GetDlgItemText(hwnd, IDC_ABOUTVERSION, szFormat, 256);
            wsprintf(szVersion, szFormat, VER_PRODUCTRELEASE_STR,
                VER_PRODUCTVERSION_STR);
            ::SetDlgItemText(hwnd, IDC_ABOUTVERSION, szVersion);

            fHandled = TRUE;
            break;
        }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ::EndDialog(hwnd, IDCANCEL);
                            break;
                    }
                    break;
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}


void WbMainWindow::UpdateWindowTitle(void)
{
	TCHAR szCaption[MAX_PATH * 2];
	TCHAR szFileName[MAX_PATH * 2];
	UINT captionID;
	if (! g_pNMWBOBJ->IsInConference())
	{
		captionID = IDS_WB_NOT_IN_CALL_WINDOW_CAPTION;
	}
	else
	{
		captionID = IDS_WB_IN_CALL_WINDOW_CAPTION;
	}

   	::LoadString(g_hInstance, captionID, szFileName, sizeof(szFileName) );
   	
	wsprintf(szCaption, szFileName, GetFileNameStr(), g_pNMWBOBJ->m_cOtherMembers);
	SetWindowText(m_hwnd, szCaption);

}




//
//
// Function:    SelectWindow
//
// Purpose:     Let the user select a window for grabbing
//
//
HWND WbMainWindow::SelectWindow(void)
{
    POINT   mousePos;            // Mouse position
    HWND    hwndSelected = NULL; // Window clicked on
    MSG     msg;                 // Current message

    // Load the grabbing cursors
    HCURSOR hGrabCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( GRABCURSOR ) );

    // Capture the mouse
    UT_CaptureMouse(m_hwnd);

    // Ensure we receive all keyboard messages.
    ::SetFocus(m_hwnd);

    // Reset the CancelMode state
    ResetCancelMode();

    // Change to the grab cursor
    HCURSOR hOldCursor = ::SetCursor(hGrabCursor);

    // Trap all mouse messages until a WM_LBUTTONUP is received
    for ( ; ; )
    {
        // Wait for the next message
        ::WaitMessage();


        // Cancel if we have been sent a WM_CANCELMODE message
        if (CancelModeSent())
        {
            break;
        }

        // If it is a mouse message, process it
        if (::PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
        {
            if (msg.message == WM_LBUTTONUP)
            {
                // Get mouse position
                mousePos.x = (short)LOWORD(msg.lParam);
                mousePos.y = (short)HIWORD(msg.lParam);

                // Convert to screen coordinates
                ::ClientToScreen(m_hwnd, &mousePos);

                // Get the window under the mouse
                hwndSelected = ::WindowFromPoint(mousePos);

                // Leave the loop
                break;
            }
        }

        // Cancel if ESCAPE is pressed.
        // or if another window receives the focus
        else if (::PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))
        {
            if (msg.wParam == VK_ESCAPE)
            {
                break;
            }
        }
    }

    // Release the mouse
    UT_ReleaseMouse(m_hwnd);

    // Restore the cursor
    ::SetCursor(hOldCursor);

    return(hwndSelected);
}


//
//
// Function:    OnGrabWindow
//
// Purpose:     Allows the user to grab a bitmap of a window
//
//
LRESULT WbMainWindow::OnGrabWindow(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGrabWindow");

    if (::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(WARNSELECTWINDOW),
        m_hwnd, WarnSelectWindowDlgProc, 0) != IDOK)
    {
        // User cancelled; bail out
        return S_OK;;
    }

    // Hide the application windows
    ::ShowWindow(m_hwnd, SW_HIDE);


	HWND mainUIhWnd = FindWindow("MPWClass\0" , NULL);
	if(IsWindowVisible(mainUIhWnd))
	{
		::UpdateWindow(mainUIhWnd);
    }

    // Get window selection from the user
    HWND hwndSelected = SelectWindow();

    if (hwndSelected != NULL)
    {
        // Walk back to the find the 'real' window ancestor
        HWND    hwndParent;

        // The following piece of code attempts to find the frame window
        // enclosing the selected window. This allows us to bring the
        // enclosing window to the top, bringing the child window with it.
        DWORD dwStyle;

        while ((hwndParent = ::GetParent(hwndSelected)) != NULL)
        {
            // If we have reached a stand-alone window, stop the search
            dwStyle = ::GetWindowLong(hwndSelected, GWL_STYLE);

            if (   ((dwStyle & WS_POPUP) == WS_POPUP)
                || ((dwStyle & WS_THICKFRAME) == WS_THICKFRAME)
                || ((dwStyle & WS_DLGFRAME) == WS_DLGFRAME))
            {
                break;
            }

            // Move up to the parent window
            hwndSelected = hwndParent;
        }

        // Bring the selected window to the top
        ::BringWindowToTop(hwndSelected);
        ::UpdateWindow(hwndSelected);

        // Get an image copy of the window
        RECT areaRect;

        ::GetWindowRect(hwndSelected, &areaRect);

        BitmapObj* dib;
		DBG_SAVE_FILE_LINE
        dib = new BitmapObj(TOOLTYPE_FILLEDBOX);
        dib->FromScreenArea(&areaRect);

		if(dib->m_lpbiImage == NULL)
		{
			delete dib;
			return S_FALSE;
		}

        // Add the new grabbed bitmap
        AddCapturedImage(dib);

        // Force the selection tool to be selected
        ::PostMessage(m_hwnd, WM_COMMAND, IDM_TOOLS_START, 0L);
    }

    // Show the windows again
    ::ShowWindow(m_hwnd, SW_SHOW);

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);

    return S_OK;
}


//
// WarnSelectWindowDlgProc()
// This puts up the warning/explanation dialog.  We use the default settings
// or whatever the user chose last time this dialog was up.
//
INT_PTR CALLBACK WarnSelectWindowDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            if (OPT_GetBooleanOption( OPT_MAIN_SELECTWINDOW_NOTAGAIN,
                            DFLT_MAIN_SELECTWINDOW_NOTAGAIN))
            {
                // End this right away, the user doesn't want a warning
                ::EndDialog(hwnd, IDOK);
            }

            fHandled = TRUE;
            break;
        }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            //
                            // Update settings -- note that we don't have to write out
                            // FALSE--we wouldn't be in the dialog in the first place
                            // if the current setting weren't already FALSE.
                            //
                            if (::IsDlgButtonChecked(hwnd, IDC_SWWARN_NOTAGAIN))
                            {
                                OPT_SetBooleanOption(OPT_MAIN_SELECTWINDOW_NOTAGAIN, TRUE);
                            }

                            ::EndDialog(hwnd, IDOK);
                            break;
                    }
                    break;

                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ::EndDialog(hwnd, IDCANCEL);
                            break;
                    }
                    break;
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}



//
//
// Function:    ShowAllWindows
//
// Purpose:     Show or hide the main window and associated windows
//
//
void WbMainWindow::ShowAllWindows(int iShow)
{
    // Show/hide the main window
    ::ShowWindow(m_hwnd, iShow);

    // Show/hide the tool window
    if (m_bToolBarOn)
    {
        ::ShowWindow(m_TB.m_hwnd, iShow);
    }
}

//
//
// Function:    OnGrabArea
//
// Purpose:     Allows the user to grab a bitmap of an area of the screen
//
//
LRESULT WbMainWindow::OnGrabArea(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGrabArea");

    if (::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(WARNSELECTAREA),
        m_hwnd, WarnSelectAreaDlgProc, 0) != IDOK)
    {
        // User cancelled, so bail out
        return S_OK;;
    }

    // Hide the application windows
    ::ShowWindow(m_hwnd, SW_HIDE);

	HWND mainUIhWnd = FindWindow("MPWClass\0" , NULL);
	if(IsWindowVisible(mainUIhWnd))
	{
		::UpdateWindow(mainUIhWnd);
    }

    // Load the grabbing cursors
    HCURSOR hGrabCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( PENCURSOR ) );

    // Capture the mouse
    UT_CaptureMouse(m_hwnd);

    // Ensure we receive all keyboard messages.
    ::SetFocus(m_hwnd);

    // Reset the CancelMode status
    ResetCancelMode();

    // Change to the grab cursor
    HCURSOR hOldCursor = ::SetCursor(hGrabCursor);

    // Let the user select the area to be grabbed
    RECT rect;
    int  tmp;

    GetGrabArea(&rect);

    // Normalize coords
    if (rect.right < rect.left)
    {
        tmp = rect.left;
        rect.left = rect.right;
        rect.right = tmp;
    }

    if (rect.bottom < rect.top)
    {
        tmp = rect.top;
        rect.top = rect.bottom;
        rect.bottom = tmp;
    }

    BitmapObj* dib;
	DBG_SAVE_FILE_LINE
    dib = new BitmapObj(TOOLTYPE_FILLEDBOX);
    if (!::IsRectEmpty(&rect))
    {
        // Get a bitmap copy of the screen area
        dib->FromScreenArea(&rect);
    }

    // Show the windows again now - if we do it later we get the bitmap to
    // be added re-drawn twice (once on the window show and once when the
    // graphic added indication arrives).
    ::ShowWindow(m_hwnd, SW_SHOW);
    ::UpdateWindow(m_hwnd);




    if (!::IsRectEmpty(&rect) && dib->m_lpbiImage)
    {
    	
	        // Add the bitmap
    	    AddCapturedImage(dib);

        	// Force the selection tool to be selected
	        ::PostMessage(m_hwnd, WM_COMMAND, IDM_TOOLS_START, 0L);
    }
    else
    {
    	delete dib;
    	dib = NULL;
    }

    // Release the mouse
    UT_ReleaseMouse(m_hwnd);

    // Restore the cursor
    ::SetCursor(hOldCursor);

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);

	if(dib)
	{
		dib->Draw();
	}


    return S_OK;
}


//
// WarnSelectArea dialog handler
//
INT_PTR CALLBACK WarnSelectAreaDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            if (OPT_GetBooleanOption(OPT_MAIN_SELECTAREA_NOTAGAIN,
                    DFLT_MAIN_SELECTAREA_NOTAGAIN))
            {
                // End this right away, the user doesn't want a warning
                ::EndDialog(hwnd, IDOK);
            }

            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            //
                            // Update settings -- note that we don't have to write out
                            // FALSE--we wouldn't be in the dialog in the first place
                            // if the current setting weren't already FALSE.
                            //
                            if (::IsDlgButtonChecked(hwnd, IDC_SAWARN_NOTAGAIN))
                            {
                                OPT_SetBooleanOption(OPT_MAIN_SELECTAREA_NOTAGAIN, TRUE);
                            }

                            ::EndDialog(hwnd, IDOK);
                            break;
                    }
                    break;

                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ::EndDialog(hwnd, IDCANCEL);
                            break;
                    }
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}



//
//
// Function:	GetGrabArea
//
// Purpose:	 Allows the user to grab a bitmap of an area of the screen
//
//
void WbMainWindow::GetGrabArea(LPRECT lprect)
{
	POINT  mousePos;			// Mouse position
	MSG	msg;				 // Current message
	BOOL   tracking = FALSE;	// Flag indicating mouse button is down
	HDC	hDC = NULL;
	POINT  grabStartPoint;	  // Start point (when mouse button is pressed)
	POINT  grabEndPoint;		// End point (when mouse button is released)
	POINT  grabCurrPoint;	   // Current mouse position

	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GetGrabArea");

	// Set the result to an empty rectangle
	::SetRectEmpty(lprect);

	// Create the rectangle to be used for tracking
	DrawObj* pRectangle = NULL;

	DBG_SAVE_FILE_LINE
	pRectangle = new DrawObj(rectangle_chosen, TOOLTYPE_SELECT);
	pRectangle->SetPenColor(RGB(0,0,0), TRUE);
	pRectangle->SetFillColor(RGB(255,255,255), FALSE);
	pRectangle->SetLineStyle(PS_DOT);
	pRectangle->SetPenThickness(1);


	// Get the DC for tracking
	HWND hDesktopWnd = ::GetDesktopWindow();
	hDC = ::GetWindowDC(hDesktopWnd);
	if (hDC == NULL)
	{
		WARNING_OUT(("NULL desktop DC"));
		goto GrabAreaCleanup;
	}

	RECT rect;

	// Trap all mouse messages until a WM_LBUTTONUP is received
	for ( ; ; )
	{
		// Wait for the next message
		::WaitMessage();


		// Cancel if we have been sent a WM_CANCELMODE message
		if (CancelModeSent())
		{
			TRACE_MSG(("canceling grab"));

			// Erase the last tracking rectangle
			if (!EqualPoint(grabStartPoint, grabEndPoint))
			{
				rect.top = grabStartPoint.y;
				rect.left = grabStartPoint.x;
				rect.bottom = grabEndPoint.y;
				rect.right = grabEndPoint.x;
				pRectangle->SetRect(&rect);
				pRectangle->SetBoundsRect(&rect);
				pRectangle->Draw(hDC);
			}

			break;
		}

		// If it is a mouse message, process it
		if (::PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
		{
			// Get mouse position
			TRACE_MSG( ("msg = %x, lParam = %0x", msg.message, msg.lParam) );
			mousePos.x = (short)LOWORD(msg.lParam);
			mousePos.y = (short)HIWORD(msg.lParam);

			TRACE_MSG( ("mousePos = %d,%d", mousePos.x, mousePos.y) );

			// Convert to screen coordinates
			::ClientToScreen(m_hwnd, &mousePos);
			grabCurrPoint = mousePos;

			switch (msg.message)
			{
				// Starting the grab
				case  WM_LBUTTONDOWN:
					// Save the starting position
					TRACE_MSG(("grabbing start position"));
					grabStartPoint = mousePos;
					grabEndPoint   = mousePos;
					tracking	   = TRUE;
					break;

				// Completing the rectangle
				case WM_LBUTTONUP:
				{
					tracking	   = FALSE;
					// Check that there is an area to capture
					TRACE_MSG(("grabbing end position"));
					if (EqualPoint(grabStartPoint, grabCurrPoint))
					{
						TRACE_MSG(("start == end, skipping grab"));
						goto GrabAreaCleanup;
					}

					// Erase the last tracking rectangle
					if (!EqualPoint(grabStartPoint, grabEndPoint))
					{	
						rect.top = grabStartPoint.y;
						rect.left = grabStartPoint.x;
						rect.bottom = grabEndPoint.y;
						rect.right = grabEndPoint.x;
						pRectangle->SetRect(&rect);
						pRectangle->SetBoundsRect(&rect);
						pRectangle->Draw(hDC);
					}

					// Update the rectangle object
					rect.top = grabStartPoint.y;
					rect.left = grabStartPoint.x;
					rect.bottom = grabCurrPoint.y;
					rect.right = grabCurrPoint.x;
					pRectangle->SetRect(&rect);
					pRectangle->SetBoundsRect(&rect);
					pRectangle->GetBoundsRect(lprect);

					// We are done
					goto GrabAreaCleanup;
				}
				break;

				// Continuing the rectangle
				case WM_MOUSEMOVE:
					if (tracking)
					{
						TRACE_MSG(("tracking grab"));

						// Erase the last tracking rectangle
						if (!EqualPoint(grabStartPoint, grabEndPoint))
						{
							rect.top = grabStartPoint.y;
							rect.left = grabStartPoint.x;
							rect.bottom = grabEndPoint.y;
							rect.right = grabEndPoint.x;
							pRectangle->SetRect(&rect);
							pRectangle->SetBoundsRect(&rect);
							pRectangle->Draw(hDC);
						}

						// Draw the new rectangle
						if (!EqualPoint(grabStartPoint, grabCurrPoint))
						{
							// Save the new box end point
							grabEndPoint = grabCurrPoint;

							// Draw the rectangle
							TRACE_MSG( ("grabStartPoint = %d,%d",
								grabStartPoint.x, grabStartPoint.y) );
							TRACE_MSG( ("grabEndPoint = %d,%d",
								grabEndPoint.x, grabEndPoint.y) );

							rect.top = grabStartPoint.y;
							rect.left = grabStartPoint.x;
							rect.bottom = grabEndPoint.y;
							rect.right = grabEndPoint.x;
							pRectangle->SetRect(&rect);
							pRectangle->SetBoundsRect(&rect);
							pRectangle->Draw(hDC);
						}
					}
					break;
			}
		}
		// Cancel if ESCAPE is pressed.
		else if (::PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))
		{
			if( ((msg.message == WM_KEYUP)||(msg.message == WM_SYSKEYUP))&&
				(msg.wParam == VK_ESCAPE) )
			{
				TRACE_MSG(("grab cancelled by ESC"));

				// Erase the last tracking rectangle
				if (!EqualPoint(grabStartPoint, grabEndPoint))
				{
					rect.top = grabStartPoint.y;
					rect.left = grabStartPoint.x;
					rect.bottom = grabEndPoint.y;
					rect.right = grabEndPoint.x;
					pRectangle->SetRect(&rect);
					pRectangle->Draw(hDC);
				}
				break;
			}
		}
	}

GrabAreaCleanup:

	// Release the device context (if we have it)
	if (hDC != NULL)
	{
		::ReleaseDC(hDesktopWnd, hDC);
	}


	delete pRectangle;
}



//
//
// Function:    AddCapturedImage
//
// Purpose:     Add a bitmap to the contents (adding a new page for it
//              if necessary).
//
//
void WbMainWindow::AddCapturedImage(BitmapObj* dib)
{
    // Position the grabbed object at the top left of the currently visible
    // area.
    RECT    rcVis;
    m_drawingArea.GetVisibleRect(&rcVis);
    dib->MoveTo(rcVis.left, rcVis.top);

	dib->Draw();

    // Add the new grabbed bitmap
	dib->AddToWorkspace();
}

//
//
// Function:    OnPrint
//
// Purpose:     Print the contents of the drawing pane
//
//
LRESULT WbMainWindow::OnPrint()
{
    BOOL        bPrintError = FALSE;
    PRINTDLG    pd;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnPrint");

    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return S_FALSE;
    }

    //
    // Initialize the PRINTDLG structure
    //
    ZeroMemory(&pd, sizeof(pd));
    pd.lStructSize      = sizeof(pd);
    pd.hInstance        = g_hInstance;
    pd.hwndOwner        = m_hwnd;
    pd.Flags            = PD_ALLPAGES | PD_RETURNDC | PD_PAGENUMS |
        PD_HIDEPRINTTOFILE | PD_NOSELECTION;

    pd.nMinPage         = 1;
    pd.nMaxPage         = (WORD)g_numberOfWorkspaces;
    pd.nFromPage        = pd.nMinPage;
    pd.nToPage          = pd.nMaxPage;

    // Put up the COMMDLG print dialog
    if (::PrintDlg(&pd))
    {
        int nStartPage, nEndPage;

        // Get the start and end page numbers to be printed
        if (pd.Flags & PD_PAGENUMS)
        {
            nStartPage  = pd.nFromPage;
            nEndPage    = pd.nToPage;
        }
        else
        {
            nStartPage  = pd.nMinPage;
            nEndPage    = pd.nMaxPage;
        }

        // Check whether any pages are to be printed
        if (nStartPage <= pd.nMaxPage)
        {
            // Ensure that the start and end pages lie within range.
            nStartPage = max(nStartPage, pd.nMinPage);
            nEndPage = min(nEndPage, pd.nMaxPage);

            // Get the printer and output port names.
            // These are written to the dialog for the user to see
            // in the OnInitDialog member.
            TCHAR szDeviceName[2*_MAX_PATH];
            LPDEVNAMES lpDev;

            // Device name
            if (pd.hDevNames == NULL)
            {
                szDeviceName[0] = 0;
            }
            else
            {
                lpDev = (LPDEVNAMES)::GlobalLock(pd.hDevNames);

                wsprintf(szDeviceName, "%s %s",
                    (LPCTSTR)lpDev + lpDev->wDeviceOffset,
                    (LPCTSTR)lpDev + lpDev->wOutputOffset);

                ::GlobalUnlock(pd.hDevNames);
            }

            //
            // Tell the printer we are starting the print.
            // Note that the printer object handles the cancellation dialog.
            WbPrinter printer(szDeviceName);

            TCHAR szJobName[_MAX_PATH];
            ::LoadString(g_hInstance, IDS_PRINT_NAME, szJobName, _MAX_PATH);

            int nPrintResult = printer.StartDoc(pd.hDC, szJobName, nStartPage);
            if (nPrintResult < 0)
            {
                WARNING_OUT(("Print result %d", nPrintResult));
                bPrintError = TRUE;
            }
            else
            {
                // Find out how many copies to print
                int copyNum;

                copyNum = 0;
                while ((copyNum < pd.nCopies) && !bPrintError)
                {
                    // Loop through all pages
                    int nPrintPage = 0;

					WBPOSITION pos;
					WorkspaceObj * pWorkspace = NULL;
					pos = g_pListOfWorkspaces->GetHeadPosition();

					while(pos)
					{
						pWorkspace = (WorkspaceObj*) g_pListOfWorkspaces->GetNext(pos);
						nPrintPage++;

						if (nPrintPage >= nStartPage &&  nPrintPage <= nEndPage	// We are in the range
							&& pWorkspace && pWorkspace->GetHead() != NULL)		// is there anything in the workspace
						{
                            // Tell the printer we are starting a new page
                            printer.StartPage(pd.hDC, nPrintPage);
                            if (!printer.Error())
                            {
                                RECT    rectArea;

                                rectArea.left = 0;
                                rectArea.top = 0;
                                rectArea.right = DRAW_WIDTH;
                                rectArea.bottom = DRAW_HEIGHT;

                                // Print the page
                                PG_Print(pWorkspace, pd.hDC, &rectArea);

                                // Inform the printer that the page is complete
                                printer.EndPage(pd.hDC);
                            }
                            else
                            {
                                bPrintError = TRUE;
                                break;
                            }
                        }
                    }

                    copyNum++;
                }

                // The print has completed
                nPrintResult = printer.EndDoc(pd.hDC);
                if (nPrintResult < 0)
                {
                    WARNING_OUT(("Print result %d", nPrintResult));
                    bPrintError = TRUE;
                }

                // reset the error if the user cancelled the print
                if (printer.Aborted())
                {
                    WARNING_OUT(("User cancelled print"));
                    bPrintError = FALSE;
                }
            }
        }
    }

    // Inform the user if an error occurred
    if (bPrintError)
    {
        // display a message informing the user the job terminated
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_PRINTER, 0);
    }

    //
    // Cleanup the hDevMode, hDevNames, and hdc blocks if allocated
    //
    if (pd.hDevMode != NULL)
    {
        ::GlobalFree(pd.hDevMode);
        pd.hDevMode = NULL;
    }

    if (pd.hDevNames != NULL)
    {
        ::GlobalFree(pd.hDevNames);
        pd.hDevNames = NULL;
    }

    if (pd.hDC != NULL)
    {
        ::DeleteDC(pd.hDC);
        pd.hDC = NULL;
    }

	return S_OK;
}

//
//
// Function:	InsertPageAfter
//
// Purpose:	 Insert a new page after the specified page.
//
//
void WbMainWindow::InsertPageAfter(WorkspaceObj * pCurrentWorkspace)
{
	//
	// Create a standard workspace
	//
	if(g_numberOfWorkspaces < WB_MAX_WORKSPACES)
	{
		//
		// If we were editing text
		//
		if (g_pDraw->TextEditActive())
	   	{
			g_pDraw->EndTextEntry(TRUE);
		}
		
		BOOL bRemote = FALSE;
		if(m_pLocalRemotePointer)
		{
			bRemote = TRUE;
			OnRemotePointer();
		}

		WorkspaceObj * pObj;
		DBG_SAVE_FILE_LINE
		pObj = new WorkspaceObj();
		pObj->AddToWorkspace();

		if(bRemote)
		{
			OnRemotePointer();
		}
	}
}

//
//
// Function:    OnInsertPageAfter
//
// Purpose:     Insert a new page after the current page
//
//
LRESULT WbMainWindow::OnInsertPageAfter()
{
    // Insert the new page
    InsertPageAfter(g_pCurrentWorkspace);
    return S_OK;
}

//
//
// Function:    OnDeletePage
//
// Purpose:     Delete the current page
//
//
LRESULT WbMainWindow::OnDeletePage()
{

	//
	// Clear the page
	//
	if(g_pListOfWorkspaces->GetHeadPosition() == g_pListOfWorkspaces->GetTailPosition())
	{
		OnClearPage(TRUE);
	}
	else
	{
		LRESULT result = OnClearPage(FALSE);
		//
		// If we had more pages move to the previous page
		//
		if(result == IDYES)
		{
			//
			// Deleted locally
			//
			g_pCurrentWorkspace->DeletedLocally();

			//
			// If the text editor is active
			//
			if(m_drawingArea.TextEditActive())
			{
				m_drawingArea.DeactivateTextEditor();
			}


			BOOL remotePointerIsOn = FALSE;
			if(g_pMain->m_pLocalRemotePointer)
			{
				g_pMain->OnRemotePointer();
				remotePointerIsOn = TRUE;
			}

			//
			// Remove the workspace and point current to the correct one.
			//
			WorkspaceObj * pWorkspace = RemoveWorkspace(g_pCurrentWorkspace);
			g_pMain->GoPage(pWorkspace);

			if(remotePointerIsOn)
			{
				g_pMain->OnRemotePointer();
			}

		
		}
	}
	return S_OK;
}

//
//
// Function:    OnRemotePointer
//
// Purpose:     Create a remote pointer
//
//
LRESULT WbMainWindow::OnRemotePointer(void)
{

	if(m_pLocalRemotePointer == NULL)
	{
		BitmapObj* remotePtr;

		DBG_SAVE_FILE_LINE
		m_pLocalRemotePointer = new BitmapObj(TOOLTYPE_REMOTEPOINTER);


		if(g_pMain->m_localRemotePointerPosition.x < 0 && g_pMain->m_localRemotePointerPosition.y < 0 )
		{
			// Position the remote pointer in center of the drawing area
			RECT    rcVis;
			m_drawingArea.GetVisibleRect(&rcVis);
			m_localRemotePointerPosition.x = rcVis.left + (rcVis.right - rcVis.left)/2;
			m_localRemotePointerPosition.y =  rcVis.top + (rcVis.bottom - rcVis.top)/2;
		}
		m_pLocalRemotePointer->MoveTo(m_localRemotePointerPosition.x ,m_localRemotePointerPosition.y);

		COLORREF color;
		color = g_crDefaultColors[g_MyIndex + 1];
		m_pLocalRemotePointer->CreateColoredIcon(color);
		
		//
		// If we couldn't create an image for teh remote pointer bitmap
		//
		if(m_pLocalRemotePointer->m_lpbiImage == NULL)
		{
			delete m_pLocalRemotePointer;
			m_pLocalRemotePointer = NULL;
			return S_FALSE;
		}
		m_pLocalRemotePointer->Draw(FALSE);

	    // Add the new grabbed bitmap
		m_pLocalRemotePointer->AddToWorkspace();

	    m_TB.PushDown(IDM_REMOTE);
	    CheckMenuItem(IDM_REMOTE);

	    // Start the timer for updating the graphic (this is only for updating
	    // the graphic when the user stops moving the pointer but keeps the
	    // mouse button down).
	    ::SetTimer(g_pDraw->m_hwnd, TIMER_REMOTE_POINTER_UPDATE, DRAW_REMOTEPOINTERDELAY, NULL);

	}
	else
	{
       ::KillTimer(g_pDraw->m_hwnd, TIMER_REMOTE_POINTER_UPDATE);
		m_pLocalRemotePointer->DeletedLocally();
		g_pCurrentWorkspace->RemoveT126Object(m_pLocalRemotePointer);
		m_pLocalRemotePointer = NULL;
	    m_TB.PopUp(IDM_REMOTE);
		UncheckMenuItem(IDM_REMOTE);
	}
	
	return S_OK;
}


//
//
// Function:    OnSync
//
// Purpose:     Sync or unsync the Whiteboard with other users
//
//
LRESULT WbMainWindow::OnSync(void)
{
	// Determine whether we are currently synced
	if (m_drawingArea.IsSynced())
    {
		// currently synced, so unsync
		Unsync();
	}
	else
	{
		// currently unsynced, so sync
		Sync();
	}
	m_drawingArea.SetSync(!m_drawingArea.IsSynced());
	EnableToolbar( TRUE );
	m_AG.EnablePageCtrls(TRUE);

	return S_OK;
}



//
//
// Function:    Sync
//
// Purpose:     Sync the Whiteboard with other users
//
//
void WbMainWindow::Sync(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::Sync");
    m_TB.PushDown(IDM_SYNC);
    CheckMenuItem(IDM_SYNC);
	GotoPage(g_pConferenceWorkspace);
} // Sync



//
//
// Function:    Unsync
//
// Purpose:     Unsync the Whiteboard with other users
//
//
void WbMainWindow::Unsync(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::Unsync");
	m_TB.PopUp(IDM_SYNC);
    UncheckMenuItem(IDM_SYNC);
}  // Unsync



LRESULT WbMainWindow::OnConfShutdown( WPARAM, LPARAM )
{
    if (OnQueryEndSession())
    {
        ::SendMessage(m_hwnd, WM_CLOSE, 0, 0); // do close immediately
        //    :
        // DON'T DO ANYTHING else at this point except for exit.
        return( 0 );// tell conf ok to shutdown
    }
    else
        return( (LRESULT)g_cuEndSessionAbort ); // don't shutdown
}


//
//
// Function:    OnQueryEndSession
//
// Purpose:     Ensure user is prompted to save changes when windows is
//              ended.
//
//
LRESULT WbMainWindow::OnQueryEndSession(void)
{
    HWND hwndPopup;

    if ((hwndPopup = ::GetLastActivePopup(m_hwnd)) != m_hwnd)
    {
        ::Message(NULL,  IDS_DEFAULT, IDS_CANTCLOSE );
        ::BringWindowToTop(hwndPopup);
        return( FALSE );
    }

    // If changes are required then prompt the user to save
    int iDoNew = IDYES;

    if (IsIdle())
    {
        iDoNew = QuerySaveRequired(TRUE);
        if (iDoNew == IDYES)
        {
            // Save the changes
            iDoNew = (int)OnSave(FALSE);
        }
    }

    // remember what we did so OnClose can act appropriately
    m_bQuerySysShutdown = (iDoNew != IDCANCEL);

    // If the user did not cancel, let windows exit
    return( m_bQuerySysShutdown );
}

//
//
// Function:    UnlockDrawingArea
//
// Purpose:     Unlock the drawing area and enable the appropriate buttons
//
//
//
void WbMainWindow::UnlockDrawingArea()
{
	m_drawingArea.Unlock();

    {
        EnableToolbar( TRUE );
	    m_AG.EnablePageCtrls(TRUE);

    }

    //
    // Show the tool attributes group.
    //
    m_AG.DisplayTool(m_pCurrentTool);
}



//
//
// Function:    LockDrawingArea
//
// Purpose:     Lock the drawing area and enable the appropriate buttons
//
//
//
void WbMainWindow::LockDrawingArea()
{
    m_drawingArea.Lock();

	if(g_pNMWBOBJ->m_LockerID != g_MyMemberID)
	{

		// Disable tool-bar buttons that cannot be used while locked
		EnableToolbar( FALSE );

		m_AG.EnablePageCtrls(FALSE);

		//
		// Hide the tool attributes
		//
		if (m_WG.m_hwnd != NULL)
		{
	        ::ShowWindow(m_WG.m_hwnd, SW_HIDE);
	    }
	    m_AG.Hide();
	}
}


void WbMainWindow::EnableToolbar( BOOL bEnable )
{
    if (bEnable)
    {
        m_TB.Enable(IDM_SELECT);

        // don't allow text editing in zoom mode
        if( m_drawingArea.Zoomed() )
            m_TB.Disable(IDM_TEXT);
        else
            m_TB.Enable(IDM_TEXT);

        m_TB.Enable(IDM_PEN);
        m_TB.Enable(IDM_HIGHLIGHT);

        m_TB.Enable(IDM_LINE);
        m_TB.Enable(IDM_ZOOM);
        m_TB.Enable(IDM_BOX);
        m_TB.Enable(IDM_FILLED_BOX);
        m_TB.Enable(IDM_ELLIPSE);
        m_TB.Enable(IDM_FILLED_ELLIPSE);
        m_TB.Enable(IDM_ERASER);

        m_TB.Enable(IDM_GRAB_AREA);
        m_TB.Enable(IDM_GRAB_WINDOW);

		//
		// If we are not synced we can't lock the other nodes
		//
		if(g_pDraw->IsSynced())
		{
			m_TB.PushDown(IDM_SYNC);
	        m_TB.Enable(IDM_LOCK);
	    }
	    else
	    {
			m_TB.PopUp(IDM_SYNC);
	        m_TB.Disable(IDM_LOCK);
	    }

		if(m_drawingArea.IsLocked())
		{
	        m_TB.Disable(IDM_SYNC);
	    }
	    else
	    {
	        m_TB.Enable(IDM_SYNC);
	    }

        m_TB.Enable(IDM_REMOTE);

    }
    else
    {
        m_TB.Disable(IDM_SELECT);
        m_TB.Disable(IDM_PEN);
        m_TB.Disable(IDM_HIGHLIGHT);
        m_TB.Disable(IDM_TEXT);
        m_TB.Disable(IDM_LINE);
        m_TB.Disable(IDM_ZOOM);
        m_TB.Disable(IDM_BOX);
        m_TB.Disable(IDM_FILLED_BOX);
        m_TB.Disable(IDM_ELLIPSE);
        m_TB.Disable(IDM_FILLED_ELLIPSE);
        m_TB.Disable(IDM_ERASER);
        m_TB.Disable(IDM_REMOTE);

        m_TB.Disable(IDM_GRAB_AREA);
        m_TB.Disable(IDM_GRAB_WINDOW);
        m_TB.Disable(IDM_LOCK);
        m_TB.Disable(IDM_SYNC);
    }
}




//
//
// Function:    UpdatePageButtons
//
// Purpose:     Enable or disable the page buttons, according to the current
//              state.
//
//
//
void WbMainWindow::UpdatePageButtons()
{
	BOOL bEnable = TRUE;
	if(!g_pCurrentWorkspace)
	{
		g_numberOfWorkspaces = 0;
		bEnable = FALSE;
	}
	else
	{
		//
		// Can we update this workspace
		//
		bEnable = g_pCurrentWorkspace->GetUpdatesEnabled();

		//
		// If it is locked, is it locked by us
		//
		if(!bEnable)
		{
			bEnable |= g_pNMWBOBJ->m_LockerID == g_MyMemberID;
		}
	}


    m_AG.EnablePageCtrls(bEnable);

	WBPOSITION pos;
	WorkspaceObj * pWorkspace;
	UINT pageNumber = 0;

	pos = g_pListOfWorkspaces->GetHeadPosition();
	while(pos)
	{
		pageNumber++;
		pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
		if(g_pCurrentWorkspace == pWorkspace)
		{
			break;
		}
	}

    m_AG.SetCurrentPageNumber(pageNumber);
    m_AG.SetLastPageNumber(g_numberOfWorkspaces);

    EnableToolbar( bEnable );
}

//
//
// Function:    CancelLoad
//
// Purpose:     Cancel any load in progress
//
//
void WbMainWindow::CancelLoad(BOOL bReleaseLock)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CancelLoad");

    // reset file name to untitled
    ZeroMemory(m_strFileName, sizeof(m_strFileName));

    // reset the whiteboard substate
    SetSubstate(SUBSTATE_IDLE);
}

//
//
// Function:    IsIdle
//
// Purpose:     Returns true if the main window is idle (in a call and not
//              loading a file/performing a new)
//
//
BOOL WbMainWindow::IsIdle()
{

    return(m_uiSubState == SUBSTATE_IDLE);
}

//
//
// Function:    SetSubstate
//
// Purpose:     Sets the substate, informing the page sorter dialog of the
//              change, if necessary.
//
//
void WbMainWindow::SetSubstate(UINT newSubState)
{
  MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::SetSubstate");

  // substate only valid if in a call
  if (newSubState != m_uiSubState)
  {
	DBG_SAVE_FILE_LINE
    m_uiSubState = newSubState;

    // Trace the substate change
    switch (m_uiSubState)
    {
      case SUBSTATE_IDLE:
        TRACE_DEBUG(("set substate to IDLE"));
        break;

      case SUBSTATE_LOADING:
        TRACE_DEBUG(("set substate to LOADING"));
        break;

      case SUBSTATE_SAVING:
        TRACE_DEBUG(("set substate to SAVING"));
        break;

      case SUBSTATE_NEW_IN_PROGRESS:
        TRACE_DEBUG(("set substate to NEW_IN_PROGRESS"));
        break;

      default:
        ERROR_OUT(("Unknown substate %hd",m_uiSubState));
        break;
    }

    // update the page buttons (may have become enabled/disabled)
    UpdatePageButtons();
  }

}

//
//
// Function:    PositionUpdated
//
// Purpose:     Called when the drawing area position has changed.
//              change, if necessary.
//
//
void WbMainWindow::PositionUpdated()
{
	RECT rectDraw;
    m_drawingArea.GetVisibleRect(&rectDraw);
	g_pDraw->InvalidateSurfaceRect(&rectDraw,FALSE);
}

//
//
// Function : OnEndSession
//
// Purpose  : Called when Windows is exiting
//
//
void WbMainWindow::OnEndSession(BOOL bEnding)
{
    if (bEnding)
    {
        ::PostQuitMessage(0);
    }
    else
    {
        m_bQuerySysShutdown = FALSE; // never mind, cancel OnClose special handling
    }
}


//
// Function: OnCancelMode()
//
// Purpose:  Called whenever a WM_CANCELMODE message is sent to the frame
//           window.
//           WM_CANCELMODE is sent when another app or dialog receives the
//           input focus.  The frame simply records that a WM_CANCELMODE
//           message has been sent.  This fact is used by the SelectWindow
//           code to determine if it should cancel the selecting of a
//           window
//
//
void WbMainWindow::OnCancelMode()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnCancelMode");

    m_cancelModeSent = TRUE;

    //
    // Note: Not passed to the default handler as the default action on
    //       WM_CANCELMODE is to release mouse capture - we shall do this
    //       explicitly.
    //


    // blow off any dragging that might be in progress (bug 573)
    POINT   pt;
    ::GetCursorPos( &pt );
    ::ScreenToClient(m_drawingArea.m_hwnd, &pt);
    ::SendMessage(m_drawingArea.m_hwnd, WM_LBUTTONUP, 0, MAKELONG( pt.x, pt.y ) );

}



void WbMainWindow::LoadCmdLine(LPCSTR szFilename)
{
    int iOnSave;

    if (szFilename && *szFilename)
    {
        if( UsersMightLoseData( NULL, NULL ) ) // bug NM4db:418
            return;

        // Don't prompt to save file if we're already loading
        if (m_uiSubState != SUBSTATE_LOADING )
        {
            // Check whether there are changes to be saved
            iOnSave = QuerySaveRequired(TRUE);
        }
        else
        {
            return;
        }

        if (iOnSave == IDYES)
        {
            // User wants to save the drawing area contents
            int iResult = (int)OnSave(TRUE);

            if( iResult == IDOK )
            {
            }
            else
            {
                // cancelled out of save, so cancel the open operation
                return;
            }
        }

        // load filename
        if( iOnSave != IDCANCEL )
            LoadFile(szFilename);
    }
}



//
// OnNotify()
// Handles TTN_NEEDTEXTA and TTN_NEEDTEXTW
//
void WbMainWindow::OnNotify(UINT id, NMHDR * pNM)
{
    UINT    nID;
    HWND    hwnd = NULL;
    POINT ptCurPos;
    UINT  nTipStringID;

    if (!pNM)
        return;

    if (pNM->code == TTN_NEEDTEXTA)
    {
        TOOLTIPTEXTA *pTA = (TOOLTIPTEXTA *)pNM;

        // get id and hwnd
        if( pTA->uFlags & TTF_IDISHWND )
        {
            // idFrom is actually the HWND of the tool
            hwnd = (HWND)pNM->idFrom;
            nID = ::GetDlgCtrlID(hwnd);
        }
        else
        {
            nID = (UINT)pNM->idFrom;
        }

        // get tip string id
        nTipStringID = GetTipId(hwnd, nID);
        if (nTipStringID == 0)
            return;

        // give it to em
        pTA->lpszText = MAKEINTRESOURCE( nTipStringID );
        pTA->hinst = g_hInstance;
    }
    else if (pNM->code == TTN_NEEDTEXTW)
    {
        TOOLTIPTEXTW *pTW = (TOOLTIPTEXTW *)pNM;

        // get id and hwnd
        if( pTW->uFlags & TTF_IDISHWND )
        {
            // idFrom is actually the HWND of the tool
            hwnd = (HWND)pNM->idFrom;
            nID = ::GetDlgCtrlID(hwnd);
        }
        else
        {
            nID = (UINT)pNM->idFrom;
        }

        // get tip string id
        nTipStringID = GetTipId(hwnd, nID );
        if (nTipStringID == 0)
            return;

        // give it to em
        pTW->lpszText = (LPWSTR) MAKEINTRESOURCE( nTipStringID );
        pTW->hinst = g_hInstance;
    }
}




//
// GetTipId()
// Finds the tooltip for a control in Whiteboard
//
UINT WbMainWindow::GetTipId(HWND hwndTip, UINT nID)
{
    WbTool *  pTool;
    BOOL      bCheckedState;
    int       nTipID;
    int       nTipStringID;
    int       i;

    // find tip stuff relevant for nID
    nTipID = -1;
    for( i=0; i<((sizeof g_tipIDsArray)/(sizeof (TIPIDS) )); i++ )
    {
        if( g_tipIDsArray[i].nID == nID )
        {
            nTipID = i;
            break;
        }
    }

    // valid?
    if( nTipID < 0 )
        return( 0 );

    // get checked state
    switch( g_tipIDsArray[ nTipID ].nCheck )
    {
        case TB:
            bCheckedState =
                (::SendMessage(m_TB.m_hwnd, TB_ISBUTTONCHECKED, nID, 0) != 0);
            break;

        case BT:
            if (hwndTip != NULL)
            {
                bCheckedState =
                    (::SendMessage(hwndTip, BM_GETSTATE, 0, 0) & 0x0003) == 1;
            }
            else
                bCheckedState = FALSE;

            break;

        case NA:
        default:
            bCheckedState = FALSE;
            break;
    }

    // get tip string id
    if( bCheckedState )
        nTipStringID = g_tipIDsArray[ nTipID ].nDownTipID;
    else
        nTipStringID = g_tipIDsArray[ nTipID ].nUpTipID;

    // done
    return( nTipStringID );
}



// gets default path if no saves or opens have been done yet
// Returns FALSE if last default should be reused
BOOL WbMainWindow::GetDefaultPath(LPTSTR csDefaultPath , UINT size)
{
    DWORD dwType;
    DWORD dwBufLen = size;
    HKEY  hDefaultKey = NULL;

    if( !lstrlen(m_strFileName) )
    {
        // a name has not been picked yet in this session, use path
        // to "My Documents"
        if( (RegOpenKeyEx( HKEY_CURRENT_USER,
							"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
							0,
							KEY_READ,
							&hDefaultKey )
							!= ERROR_SUCCESS) ||
							(RegQueryValueEx( hDefaultKey,
                             "Personal",
                             NULL,
                             &dwType,
                             (BYTE *)csDefaultPath,
                             &dwBufLen )
							!= ERROR_SUCCESS))
		{
            // reg failed, use desktop
            GetWindowsDirectory( csDefaultPath, 2*_MAX_PATH );
            lstrcpy(csDefaultPath,"\\Desktop");
        }

        if( hDefaultKey != NULL )
            RegCloseKey( hDefaultKey );

        return( TRUE );
    }
    else
    {
        return( FALSE );
    }
}





void WbMainWindow::OnSysColorChange( void )
{
    if (g_pCurrentWorkspace != NULL)
    {
        PG_ReinitPalettes();

        ::InvalidateRect(m_hwnd, NULL, TRUE );
        ::UpdateWindow(m_hwnd);
    }

    m_TB.RecolorButtonImages();
    m_AG.RecolorButtonImages();
}



//
// posts a do-you-wana-do-that message if other users are in the conference
//
BOOL WbMainWindow::UsersMightLoseData( BOOL *pbWasPosted, HWND hwnd )
{
	if (g_pNMWBOBJ->GetNumberOfMembers() > 0)
	{
		if( pbWasPosted != NULL )
			*pbWasPosted = TRUE;
			return( ::Message(hwnd,  IDS_DEFAULT, IDS_MSG_USERSMIGHTLOSE, MB_YESNO | MB_ICONEXCLAMATION ) != IDYES );
	}

	if( pbWasPosted != NULL )
        *pbWasPosted = FALSE;

    return( FALSE );
}


//
//
// Name:    ContentsSave
//
// Purpose: Save the contents of the WB.
//
// Returns: Error code
//
//
UINT WbMainWindow::ContentsSave(LPCSTR pFileName)
{
    UINT	result = 0;
    UINT	index;
    HANDLE	hFile;
    ULONG	cbSizeWritten;
    T126WB_FILE_HEADER  t126Header;
    WB_OBJ			endOfFile;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::ContentsSave");

    //
    // Open the file
    //
    m_hFile = CreateFile(pFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL, 0);
    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        result = WB_RC_CREATE_FAILED;
        ERROR_OUT(("Error creating file, win32 err=%d", GetLastError()));
        goto CleanUp;
    }

    //
    // Create the file header.
    //
	memcpy(t126Header.functionProfile, T126WB_FP_NAME,sizeof(T126WB_FP_NAME));
	t126Header.length = sizeof(T126WB_FILE_HEADER) + g_numberOfWorkspaces*sizeof(UINT);
	t126Header.version = T126WB_VERSION;
	t126Header.numberOfWorkspaces = g_numberOfWorkspaces;


 	//
    // Save the header
    //
    if (!WriteFile(m_hFile, (void *) &t126Header, sizeof(T126WB_FILE_HEADER), &cbSizeWritten, NULL))
    {
        result = WB_RC_WRITE_FAILED;
        ERROR_OUT(("Error writing length to file, win32 err=%d", GetLastError()));
        goto CleanUp;
    }


	WorkspaceObj* pWorkspace;
	WBPOSITION pos;
	index = 0;

	pos = g_pListOfWorkspaces->GetHeadPosition();
	while(pos)
	{
		pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
		ASSERT(pWorkspace);


		UINT numberOfObjects = pWorkspace->EnumerateObjectsInWorkspace();


	 	//
	    // Save the number of objects in each page
    	//
	    if (!WriteFile(m_hFile, (void *) &numberOfObjects, sizeof(numberOfObjects), &cbSizeWritten, NULL))
    	{
	        result = WB_RC_WRITE_FAILED;
	        ERROR_OUT(("Error writing length to file, win32 err=%d", GetLastError()));
	        goto CleanUp;
	    }

		index++;
	}

	ASSERT(index == g_numberOfWorkspaces);


    //
    // Loop through the pages, saving each as we go
    //
    g_bSavingFile = TRUE;
	ResendAllObjects();

	//
	// The Last Object to be saved is the current workspace
	//
	g_pCurrentWorkspace->OnObjectEdit();

	//
    // If we have successfully written the contents, we write an end-of-page
    // marker to the file.
    //
    ZeroMemory(&endOfFile, sizeof(endOfFile));
    endOfFile.length = sizeof(endOfFile);
    endOfFile.type   = TYPE_T126_END_OF_FILE;

    //
    // Write the end-of-file object
    //
    if (!WriteFile(m_hFile, (void *) &endOfFile, sizeof(endOfFile), &cbSizeWritten, NULL))
    {
        result = WB_RC_WRITE_FAILED;
        ERROR_OUT(("Error writing length to file, win32 err=%d", GetLastError()));
        goto CleanUp;
    }


CleanUp:

    //
    // Close the file
    //
    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hFile);
    }

    //
    // If an error occurred in saving the contents to file, and the file was
    // opened, then delete it.
    //
    if (result != 0)
    {
        //
        // If the file was opened successfully, delete it
        //
        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            DeleteFile(pFileName);
        }
    }

    g_bSavingFile = FALSE;
    return(result);
}


//
//
// Name:    ObjectSave
//
// Purpose: Save a structure to file
//
// Returns: Error code
//
//
UINT WbMainWindow::ObjectSave(UINT type, LPBYTE pData, UINT length)
{
    ASSERT(m_hFile != INVALID_HANDLE_VALUE);

    UINT        result = 0;
    ULONG       cbSizeWritten;
	WB_OBJ objectHeader;

	objectHeader.length = sizeof(WB_OBJ) + length;
	objectHeader.type = type;

	//
	// Save the Header
	//
    if (! WriteFile(m_hFile, (void *) &objectHeader, sizeof(WB_OBJ), &cbSizeWritten, NULL))
    {
        result = WB_RC_WRITE_FAILED;
        ERROR_OUT(("Error writing length to file, win32 err=%d", GetLastError()));
        goto bail;
    }
    ASSERT(cbSizeWritten == sizeof(WB_OBJ));

    //
    // Save the object data
    //
    if (! WriteFile(m_hFile, pData, length, &cbSizeWritten, NULL))
    {
        result = WB_RC_WRITE_FAILED;
        ERROR_OUT(("Error writing data to file, win32 err=%d", GetLastError()));
        goto bail;
    }
    ASSERT(cbSizeWritten == length);

bail:
  return result;
}

//
//
// Function:    ContentsLoad
//
// Purpose:     Load a file and delete the current workspaces
//
//
UINT WbMainWindow::ContentsLoad(LPCSTR pFileName)
{
    BOOL        bRemote;
    UINT        result = 0;
	PT126WB_FILE_HEADER_AND_OBJECTS pHeader = NULL;

    //
    // Validate the file, and get a handle to it.
    // If there is an error, then no file handle is returned.
    //
	pHeader = ValidateFile(pFileName);
    if (pHeader == NULL)
    {
        result = WB_RC_BAD_FILE_FORMAT;
        goto bail;
    }
    delete pHeader;

    //
    // Remember if remote pointer is on
    //
    bRemote = FALSE;
    if (m_pLocalRemotePointer)
    {
        // Remove remote pointer from pages
        bRemote = TRUE;
        OnRemotePointer();
    }

	//
	// Just before loading anything delete all the workspaces
	//
	::InvalidateRect(g_pDraw->m_hwnd, NULL, TRUE);
	DeleteAllWorkspaces(TRUE);

	result = ObjectLoad();

    //
    // Put remote pointer back if it was on
    //
    if (bRemote)
    {
        OnRemotePointer();
    }

	//
	// The workspaces may have being saved as locked
	// Unlock all workspaces, and make sure the drawing area is unlocked
	//
	TogleLockInAllWorkspaces(FALSE, FALSE); // Not locked, don't send updates
	UnlockDrawingArea();

	ResendAllObjects();

bail:

	if(INVALID_HANDLE_VALUE != m_hFile)
	{
		CloseHandle(m_hFile);
	}
    return(result);


}


//
//
// Function:    ObjectLoad
//
// Purpose:     Load t126 ASN1 objects from the file
//
//
UINT WbMainWindow::ObjectLoad(void)
{
	UINT		result = 0;
	LPSTR 		pData;
    UINT        length;

	DWORD		cbSizeRead;
	BOOL readFileOk = TRUE;
	WB_OBJ objectHeader;

	while(readFileOk)
	{

		//
		// Read objects header info
		//
		readFileOk = ReadFile(m_hFile, (void *) &objectHeader, sizeof(WB_OBJ), &cbSizeRead, NULL);
		if ( !readFileOk )
    	{
        	//
	        // Make sure we return a sensible error.
	        //
	        ERROR_OUT(("reading object length, win32 err=%d, length=%d", GetLastError(), sizeof(WB_OBJ)));
	        result = WB_RC_BAD_FILE_FORMAT;
	        goto bail;
	    }
		ASSERT(cbSizeRead ==  sizeof(WB_OBJ));

		//
		// Read the object's raw data
		//
		length = objectHeader.length - sizeof(WB_OBJ);
		DBG_SAVE_FILE_LINE
	    pData = (LPSTR)new BYTE[length];
	
		readFileOk = ReadFile(m_hFile, (LPBYTE) pData, length, &cbSizeRead, NULL);
    	
    	if(! readFileOk)
	    {
	        //
    	    // Make sure we return a sensible error.
        	//
	        ERROR_OUT(("Reading object from file: win32 err=%d, asked for %d got %d bytes", GetLastError(), length, cbSizeRead));
	        result = WB_RC_BAD_FILE_FORMAT;
    	    goto bail;
	    }
		ASSERT(cbSizeRead == length);

		//
		// It is an ASN1 t126 object
		//
		if(objectHeader.type == TYPE_T126_ASN_OBJECT)
		{
			//
			// Try decoding and adding it to the workspace
			//
			if(!T126_MCSSendDataIndication(length, (LPBYTE)pData, g_MyMemberID, TRUE))
		   	{
				result = WB_RC_BAD_FILE_FORMAT;
		   	    goto bail;
			}
		}
		//
		// If it is an end of file do a last check
		//
		else if(objectHeader.type == TYPE_T126_END_OF_FILE)
		{
			if(objectHeader.length != sizeof(WB_OBJ))
			{
				result = WB_RC_BAD_FILE_FORMAT;
			}
			goto bail;
		}
		else
		{
			ERROR_OUT(("Don't know object type =%d , size=%d  ; skipping to next object", objectHeader.type, length));
		}

	    delete pData;
	    pData = NULL;
    }


bail:

	if(pData)
	{
		delete pData;
	}
	
    return(result);
}


//
//
// Function:    ValidateFile
//
// Purpose:     Open a T126 file and check if it is valid, if it is the it will
//				return a pointer to the header structure
//
//
PT126WB_FILE_HEADER_AND_OBJECTS  WbMainWindow::ValidateFile(LPCSTR pFileName)
{
    UINT            result = 0;
    PT126WB_FILE_HEADER  pFileHeader = NULL;
	PT126WB_FILE_HEADER_AND_OBJECTS  pCompleteFileHeader = NULL;
    UINT            length;
    ULONG           cbSizeRead;
    BOOL            fileOpen = FALSE;


	DBG_SAVE_FILE_LINE
	pFileHeader = new T126WB_FILE_HEADER[1];

	if(pFileHeader == NULL)
	{
        WARNING_OUT(("Could not allocate memory to read the file header opening file, win32 err=%d", GetLastError()));
        result = WB_RC_CREATE_FAILED;
        goto bail;
	}

    //
    // Open the file
    //
    m_hFile = CreateFile(pFileName, GENERIC_READ, 0, NULL,
                            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        WARNING_OUT(("Error opening file, win32 err=%d", GetLastError()));
        result = WB_RC_CREATE_FAILED;
        goto bail;
    }

    //
    // Show that we have opened the file successfully
    //
    fileOpen = TRUE;

    //
    // Read the file header
    //
    if (! ReadFile(m_hFile, (void *) pFileHeader, sizeof(T126WB_FILE_HEADER), &cbSizeRead, NULL))
    {
        WARNING_OUT(("Error reading file header, win32 err=%d", GetLastError()));
        result = WB_RC_READ_FAILED;
        goto bail;
    }

    if (cbSizeRead != sizeof(T126WB_FILE_HEADER))
    {
        WARNING_OUT(("Could not read file header"));
        result = WB_RC_BAD_FILE_FORMAT;
        goto bail;
    }

    //
    // Validate the file header
    //
    if (memcmp(pFileHeader->functionProfile, T126WB_FP_NAME, sizeof(T126WB_FP_NAME)))
    {
        WARNING_OUT(("Bad function profile in file header"));
        result = WB_RC_BAD_FILE_FORMAT;
        goto bail;
    }

	//
	// Check for version
	//
	if( pFileHeader->version < T126WB_VERSION)
	{
        WARNING_OUT(("Bad version number"));
        result = WB_RC_BAD_FILE_FORMAT;
        goto bail;
	}
	DBG_SAVE_FILE_LINE
	pCompleteFileHeader = (PT126WB_FILE_HEADER_AND_OBJECTS) new BYTE[sizeof(T126WB_FILE_HEADER) + pFileHeader->numberOfWorkspaces*sizeof(UINT)];
	memcpy(pCompleteFileHeader, pFileHeader, sizeof(T126WB_FILE_HEADER));

    //
    // Read the rest of the file header
    //
    if(! ReadFile(m_hFile, (void *) &pCompleteFileHeader->numberOfObjects[0], pFileHeader->numberOfWorkspaces*sizeof(UINT), &cbSizeRead, NULL))
    {
		if(cbSizeRead != pFileHeader->numberOfWorkspaces)
        result = WB_RC_BAD_FILE_FORMAT;
        goto bail;
    }

		TRACE_DEBUG(("Opening file with %d workspaces", pFileHeader->numberOfWorkspaces));
#ifdef _DEBUG
		INT i;
		for(i = 0; i < (INT)pFileHeader->numberOfWorkspaces; i++)
		{
			TRACE_DEBUG(("Workspace %d contains %d objects", i+1, pCompleteFileHeader->numberOfObjects[i] ));
		}
#endif



bail:

    //
    // Close the file if there has been an error
    //
    if ( (fileOpen) && (result != 0))
    {
        CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
    }

	//
	// Delete allocated file header
	//
	if(pFileHeader)
	{
		delete pFileHeader;
	}

	//
	// if there was an error delete the return header
	//
	if(result != 0)
	{
		if(pCompleteFileHeader)
		{
			delete pCompleteFileHeader;
			pCompleteFileHeader = NULL;
		}
	}

	return pCompleteFileHeader;
}


//
//
// Function:    GetFileNameStr
//
// Purpose:     Return a plain file name string
//
//
LPSTR  WbMainWindow::GetFileNameStr(void)
{
	UINT size = 2*_MAX_FNAME;

	if(m_pTitleFileName)
	{
		delete m_pTitleFileName;
		m_pTitleFileName = NULL;
	}
	
	DBG_SAVE_FILE_LINE
	m_pTitleFileName = new TCHAR[size];
	if (!m_pTitleFileName)
    {
        ERROR_OUT(("GetWindowTitle: failed to allocate TitleFileName"));
        return(NULL);
    }

	// Set title to either the "Untitled" string, or the loaded file name
    if( (!lstrlen(m_strFileName))|| (GetFileTitle( m_strFileName, m_pTitleFileName, (WORD)size ) != 0) )
    {
		::LoadString(g_hInstance, IDS_UNTITLED , m_pTitleFileName, 2*_MAX_FNAME);
    }

	return (LPSTR)m_pTitleFileName;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\page.cpp ===
//
// PAGE.CPP
// WB Page Handling
//
// Copyright Microsoft 1998-
//
	
// PRECOMP
#include "precomp.h"




//
//
// Function:    Draw
//
// Purpose:     Draw the contents of the page into the specified device
//              context.
//
//
void PG_Draw(WorkspaceObj* pWorkspace, HDC hDC)
{
	T126Obj * pObj = NULL;
	WBPOSITION pos = NULL;

	if(pWorkspace)
	{
		pos = pWorkspace->GetHeadPosition();
	}
	
	while(pos)
	{
		pObj = (T126Obj*)pWorkspace->GetNextObject(pos);
		if(pObj)
		{
	        pObj->Draw(hDC, FALSE, TRUE);
	    }
	}
}


//
//
// Function:    First (crect)
//
// Purpose:     Return the first object in the page (bottommost Z-order)
//              that intersects the bounding rectangle
//
//
T126Obj* PG_First(WorkspaceObj * pWorkSpc,LPCRECT pRectUpdate, BOOL bCheckReallyHit)
{
    BOOL         empty = TRUE;
    T126Obj*	 pGraphic = NULL;
    RECT         rc;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_First");

	if(pWorkSpc)
	{
		pGraphic = pWorkSpc->GetHead();
	}

	if(pGraphic == NULL)
	{
		return NULL;
	}

    if (pRectUpdate == NULL)
    {
        // We have got what we want
        TRACE_MSG(("Got the object we want"));
    }
    else
    {
        WBPOSITION pos = pWorkSpc->GetHeadPosition(); 

		pGraphic->GetBoundsRect(&rc);
    	empty = !::IntersectRect(&rc, &rc, pRectUpdate);

        if (empty)
        {
            TRACE_MSG(("First object not needed - go to next"));
            pGraphic = PG_Next(pWorkSpc, pos, pRectUpdate, bCheckReallyHit);
        }
        else
        {
            if(bCheckReallyHit)
            {
                // do a real object hit test since we
                // know its bounding rect has hit
                if( !pGraphic->CheckReallyHit( pRectUpdate ) )
                {
                    pGraphic = PG_Next(pWorkSpc, pos, pRectUpdate, TRUE); // look again
                }
            }
        }
    }

    return(pGraphic);
}


//
//
// Function:    Next
//
// Purpose:     Return the next graphic in the page (going up through the
//              Z-order).  GetFirst must have been called before this
//              member.
//
T126Obj* PG_Next(WorkspaceObj* pWorkSpc, WBPOSITION& pos, LPCRECT pRectUpdate, BOOL bCheckReallyHit)
{
    BOOL		empty = TRUE;
    T126Obj*	pGraphic = NULL;
    RECT		rc;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_Next");

    while (pos)
    {
		if(pWorkSpc)
		{
			pGraphic = pWorkSpc->GetNextObject(pos);
		}
    	
        if (pRectUpdate == NULL)
        {
            // We have got what we want
            TRACE_MSG(("Got the object we want"));
			break;
        }
        else
        {
			if(pGraphic)
			{
				pGraphic->GetBoundsRect(&rc);
				empty = !::IntersectRect(&rc, &rc, pRectUpdate);
			}
			
			if (!empty)
			{
				if( bCheckReallyHit )
				{
					// do a real object hit test since we
					// know its bounding rect has hit
					if( pGraphic && pGraphic->CheckReallyHit( pRectUpdate ) )
					{
						break;
					}
					else
                    {
						pGraphic = NULL; // look again
                    }
                }
                else
                {
					break; // found it
				}
            }
			else
			{
				pGraphic = NULL;
			}
        }
    }

    return(pGraphic);
}


//
//
// Function:    Last
//
// Purpose:     Select the last object whose bounding rectangle contains
//              the point specified.
//
//
T126Obj* PG_SelectLast
(
    WorkspaceObj * pWorkSpc,
    POINT	point
)
{
    RECT		rectHit;
    T126Obj*	pGraphic = NULL;

	if(pWorkSpc)
	{
		pGraphic = pWorkSpc->GetTail();
	}

	if(pGraphic == NULL)
	{
		return NULL;
	}

    WBPOSITION pos = pWorkSpc->GetTailPosition(); 

	MAKE_HIT_RECT(rectHit, point);
	if (!pGraphic->CheckReallyHit( &rectHit ))
	{
		// have to look some more
        pGraphic = PG_SelectPrevious(pWorkSpc, pos, point);
	}

    return(pGraphic);
}

//
//
// Function:    Previous
//
// Purpose:     Select the previous object whose bounding rectangle contains
//              the point specified.
//
//
T126Obj* PG_SelectPrevious(WorkspaceObj* pWorkspace, WBPOSITION& pos, POINT point)
{
	RECT        rectHit;
	T126Obj* pGraphic = NULL;

	MLZ_EntryOut(ZONE_FUNCTION, "PG_Previous");
	MAKE_HIT_RECT(rectHit, point );

	while (pos)
	{
		if(pWorkspace)
		{
	   		pGraphic = pWorkspace->GetPreviousObject(pos);
		}

        if( pGraphic && pGraphic->CheckReallyHit( &rectHit ) )
		{
			break;
		}            
        pGraphic = NULL;
    }
    return(pGraphic);
}

//CHANGED BY RAND
#define WB_MIN_PRINT_MARGIN_SIZE     (30)

//
//
// Function:    Print
//
// Purpose:     Print the contents of the page to the specified printer. The
//              contents are scaled to "best fit" on the page. i.e. the
//              largest scaling factor that preserves the aspect ratio of
//              the page is used.
//
//
void PG_Print(WorkspaceObj* pWorkspace,HDC hdc, LPCRECT lprcPrint)
{
    int pageWidth;
    int pageHeight;
    int areaHeight;
    int areaWidth;
    int areaAspectRatio;
    int pageAspectRatio;
    int nPhysOffsetX;
    int nPhysOffsetY;
    int nPhysWidth;
    int nPhysHeight;
    int nVOffsetX;
    int nVOffsetY;

    // get physical printer params
    nPhysOffsetX = GetDeviceCaps(hdc, PHYSICALOFFSETX );
    nPhysOffsetY = GetDeviceCaps(hdc, PHYSICALOFFSETY );
    nPhysWidth   = GetDeviceCaps(hdc, PHYSICALWIDTH );
    nPhysHeight  = GetDeviceCaps(hdc, PHYSICALHEIGHT );

    // calc correct printer area (allow for bugs in some drivers...)
    if( nPhysOffsetX <= 0 )
    {
        nPhysOffsetX = WB_MIN_PRINT_MARGIN_SIZE;
        nVOffsetX = nPhysOffsetX;
    }
    else
        nVOffsetX = 0;

    if( nPhysOffsetY <= 0 )
    {
        nPhysOffsetY = WB_MIN_PRINT_MARGIN_SIZE;
        nVOffsetY = nPhysOffsetY;
    }
    else
        nVOffsetY = 0;


    // get and adjust printer page area
    pageWidth  = GetDeviceCaps(hdc, HORZRES );
    pageHeight = GetDeviceCaps(hdc, VERTRES );

    if( pageWidth >= (nPhysWidth - nPhysOffsetX) )
    {
        // HORZRES is lying to us, compensate
        pageWidth = nPhysWidth - 2*nPhysOffsetX;
    }

    if( pageHeight >= (nPhysHeight - nPhysOffsetY) )
    {
        // VERTRES is lying to us, compensate
        pageHeight = nPhysHeight - 2*nPhysOffsetY;
    }


    // adjust printer area to get max fit for Whiteboard page
    areaWidth  = lprcPrint->right - lprcPrint->left;
    areaHeight = lprcPrint->bottom - lprcPrint->top;
    areaAspectRatio = ((100 * areaHeight + (areaWidth/2))/(areaWidth));
    pageAspectRatio = ((100 * pageHeight + (pageWidth/2))/(pageWidth));

    if (areaAspectRatio < pageAspectRatio)
        pageHeight  = ((pageWidth * areaHeight + (areaWidth/2))/areaWidth);
    else 
    if (areaAspectRatio > pageAspectRatio)
        pageWidth = ((pageHeight * areaWidth + (areaHeight/2))/areaHeight);

    // set up xforms

   	::SetMapMode(hdc, MM_ANISOTROPIC );
    ::SetWindowExtEx(hdc, areaWidth, areaHeight,NULL );
    ::SetWindowOrgEx(hdc, 0,0, NULL );
    ::SetViewportExtEx(hdc, pageWidth, pageHeight, NULL );
    ::SetViewportOrgEx(hdc, nVOffsetX, nVOffsetY, NULL );
    
    // draw the page
    PG_Draw(pWorkspace, hdc);
}

//
//
// Function:    PG_InitializePalettes
//
// Purpose:     Create palettes for display and print (if necessary)
//
//
void PG_InitializePalettes(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_InitializePalettes");

    // If the palettes are not yet initialized - initialize them now
    if (!g_bPalettesInitialized)
    {
        ASSERT(!g_hRainbowPaletteDisplay);

        // Get the number of colors supported by the screen
        // We only need an info DC for this, not a full DC
        HDC     hdc;

        hdc = ::CreateIC("DISPLAY", NULL, NULL, NULL);
        if (!hdc)
        {
            return;
        }

        // Determine whether the device supports palettes
        int iBitsPixel = ::GetDeviceCaps(hdc, BITSPIXEL);
        int iPlanes    = ::GetDeviceCaps(hdc, PLANES);
        int iNumColors = iBitsPixel * iPlanes;

        ::DeleteDC(hdc);

        // If we need the palette, create it.
        // We only need the palette on a 8bpp machine. Anything less (4bpp)
        // and there will be no palette, anything more is a pure color display.
        if ((iNumColors == 8) &&
            (g_hRainbowPaletteDisplay = CreateColorPalette()))
        {
            // Show that we want to use the palette
            g_bUsePalettes = TRUE;

        }
        else
        {
            g_bUsePalettes = FALSE;
        }

        // Show that we have now initialized the palette information
        g_bPalettesInitialized = TRUE;
    }
}

//
//
// Function:    PG_GetPalette
//
// Purpose:     Return the palette for use with this page.
//              This object is temporary and should not be stored.
//
//
HPALETTE PG_GetPalette(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GetPalette");

    // If the palettes are not yet initialized - initialize them now
    PG_InitializePalettes();

    if (g_bUsePalettes)
    {
        // If we are using a non-default palette, set the return value
        return(g_hRainbowPaletteDisplay);
    }
    else
    {
        return(NULL);
    }
}


void PG_ReinitPalettes(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_ReinitPalettes");

    if (g_hRainbowPaletteDisplay)
    {
        if (g_pDraw->m_hDCCached)
        {
            // Select out the rainbow palette so we can delete it
            ::SelectPalette(g_pDraw->m_hDCCached, (HPALETTE)::GetStockObject(DEFAULT_PALETTE), TRUE);
        }
        ::DeletePalette(g_hRainbowPaletteDisplay);
        g_hRainbowPaletteDisplay = NULL;
    }

    g_bPalettesInitialized = FALSE;
    PG_InitializePalettes();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\nmwbobj.h ===
// NMWbObj.h : Declaration of the CNMWbObj

#ifndef __NMWBOBJ_H_
#define __NMWBOBJ_H_

#include <igccapp.h>
#include "resource.h"       // main symbols
#include <it120app.h>


//Microsoft non-collapsing capabilities values....
enum NonCollapsCaps
{
	_iT126_TEXT_CAPABILITY_ID = 0,
	_iT126_24BIT_BITMAP_ID,
	_iT126_LAST_NON_COLLAPSING_CAPABILITIES
};

LRESULT WbMainWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

enum eMenuPos { MENUPOS_FILE = 0,
					MENUPOS_EDIT,
					MENUPOS_VIEW,
					MENUPOS_TOOLS};


// Forward Decls
class CNMWbObj;

#define ICON_BIG_SIZE								32
#define ICON_SMALL_SIZE								16



/////////////////////////////////////////////////////////////////////////////
// CNMWbObj
class  CNMWbObj
{

public: // Construction/destruction and initialization
	CNMWbObj();
    ~CNMWbObj();

    ULONG GetNumberOfMembers(void){return m_cOtherMembers;}
	BOOL			m_bImTheTopProvider;
	BOOL			m_bImTheT126Refresher;
	BOOL			m_bICanDo24BitBitmaps;
	BOOL			m_bConferenceCanDo24BitBitmaps;
	BOOL 			m_bConferenceCanDoText;
	BOOL			m_bConferenceOnlyNetmeetingNodes;
	BOOL 			CanDo24BitBitmaps(){return m_bConferenceCanDo24BitBitmaps;}
	BOOL			CanDoText(){return m_bConferenceCanDoText;}
	ULONG			m_LockerID;
	UINT      		m_instanceNumber;

	//
	// T120 stuff
	//
	IT120Applet				*m_pApplet;
	IT120AppletSession		*m_pAppletSession;
	T120JoinSessionRequest	m_JoinSessionReq;
	T120ResourceRequest		m_tokenResourceRequest;
	T120TokenRequest		m_tokenRequest;
    T120ConfID              m_nConfID;
	T120UserID				m_uidMyself;
	T120SessionID			m_sidMyself;
	T120EntityID			m_eidMyself;
	T120NodeID				m_nidMyself;
    ULONG      				m_cOtherMembers;
	MEMBER_ID				*m_aMembers;
	BOOL					m_fInConference;

	BOOL IsInConference(void) { return m_fInConference; }
    T120ConfID GetConfID(void) { return m_nConfID; }
    void OnPermitToEnroll(T120ConfID, BOOL fPermissionGranted);
    void OnJoinSessionConfirm(T120JoinSessionConfirm *);
    void OnAllocateHandleConfirm(GCCRegAllocateHandleConfirm *);
    void OnRosterIndication(ULONG cRosters, GCCAppRoster *apRosters[]);
    void CleanupPerConf(void);

	void BuildCaps(void);
	
	T120Error SendData(T120Priority	ePriority, ULONG cb, PBYTE pb);
    T120Error AllocateHandles(ULONG cHandles);
	T120Error GrabRefresherToken(void);
	HRESULT _UpdateContainerCaption( void );
};

#endif //__NMWBOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\mwnd.hpp ===
//
// MWND.HPP
// Main WB Window
//
// Copyright Microsoft 1998-
//

#ifndef __MWND_HPP_
#define __MWND_HPP_

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))


#define T126WB_FP_NAME "Microsoft NetMeeting Whiteboard"
#define T126WB_VERSION 30	// for 3.0

//
// Workset type constants
//
#define TYPE_T126_ASN_OBJECT	0
#define TYPE_T126_DIB_OBJECT	1
#define TYPE_T126_TEXT_OBJECT	2
#define TYPE_T126_END_OF_FILE	1000

//
// Generic object
//
typedef struct tagWB_OBJ
{
  ULONG length;		// Total length of object
  UINT	type;		// Type of file object
} WB_OBJ;

typedef WB_OBJ*        PWB_OBJ;

//
// File header for Whiteboard format files
//
typedef struct tagT126WB_FILE_HEADER
{
  BYTE	functionProfile[sizeof(T126WB_FP_NAME)];
  UINT	length;
  UINT	version;
  UINT	numberOfWorkspaces;
} T126WB_FILE_HEADER;
typedef T126WB_FILE_HEADER *        PT126WB_FILE_HEADER;

typedef struct tagT126WB_FILE_HEADER_AND_OBJECTS
{
	T126WB_FILE_HEADER fileHeader;
	UINT	numberOfObjects[1];
}T126WB_FILE_HEADER_AND_OBJECTS;

typedef T126WB_FILE_HEADER_AND_OBJECTS* PT126WB_FILE_HEADER_AND_OBJECTS;

//
// The progress timer meter is kinda the heart beat of this thing
//
#define MAIN_PROGRESS_TIMER         1000


// Milliseconds
#define MAIN_DIALOG_DELAY           1500
#define MAIN_REGISTRATION_TIMEOUT   300000   // These are long, for modems
#define MAIN_LOCK_TIMEOUT           120000

//
// Timer IDs
//
#define TIMERID_PROGRESS_METER      4
#define TIMERID_MAXDISPLAY          10


//
// Timed dialog information
//
typedef struct tagTMDLG
{
    BOOL    bLockNotEvent;
    BOOL    bVisible;
    UINT    uiMaxDisplay;
}
TMDLG;


//				  This constant must only be defined in FAR EAST sdk
//				  since it is not in US version. In Sook Choi (Korea) says
//				  it is 40h so thats what I will use. Bug 3258.
#ifndef	CLIP_DFA_OVERRIDE
#define CLIP_DFA_OVERRIDE (0x40)
#endif


// Constants for width menu commands
#define TOOLSPOS_WIDTH      16



//
// Main state
//  STARTING      = Whiteboard just started, not ready for user input.
//                  In this state until registration dialog is cleared.
//  IN_CALL       = Whiteboard ready for input
//  ERROR_STATE   = a serious error has occurred, Whiteboard must be closed
//  JOINING       = joining a call (join call dialog is up)
//  JOINED        = Received join call indication, waiting for 'join call'
//                  dialog to be dismissed.
//  CLOSING       = Whiteboard is shutting down. Ignore all messages.
//
//
enum
{
    STARTING    = 0,
    IN_CALL,
    ERROR_STATE,
    JOINING,
    JOINED,
    CLOSING
};


//
// Substate - valid only when in call
//  IDLE            = Normal state - user can do anything permitted by
//                    current lock status.
//  LOADING         = Currently loading a file
//  NEW_IN_PROGRESS = Currently deleting contents
//
//
#define SUBSTATE_IDLE				0
#define SUBSTATE_LOADING			1
#define SUBSTATE_NEW_IN_PROGRESS	2
#define SUBSTATE_SAVING				3

//
// Capture options
//
#define CAPTURE_TO_SAME   0
#define CAPTURE_TO_NEW    1

//
// Border to be left around the checkmark in the color and width menus and
// width of items in these menus.
//
#define CHECKMARK_BORDER_X 3
#define CHECKMARK_BORDER_Y 5
#define COLOR_MENU_WIDTH   40


typedef struct tagWBFINDDIALOG
{
    HWND    hwndDialog;
    HWND    hwndOwner;
} WBFINDDIALOG;



#define MAX_FONT_SIZE       20
#define STATUSBAR_HEIGHT    (MAX_FONT_SIZE + 2*::GetSystemMetrics(SM_CYEDGE))

//
//
// Class:   WbMainWindow
//
// Purpose: Main Whiteboard window
//
//
class WbMainWindow
{

    friend LRESULT CALLBACK WbMainWindowProc(HWND, UINT, WPARAM, LPARAM);

    friend BOOL CALLBACK WbFindCurrentDialog(HWND hwnd, LPARAM);


public:
    //
    // Construction and destruction
    //
    WbMainWindow(void);
    ~WbMainWindow(void);

    BOOL    InitToolArray(void);
    void    DestroyToolArray(void);

    //
    // Initialization - display the window and its children
    //
    BOOL Open(int iCommand);
	VOID ShowWindow();	// For T126 we want to open but hide the ui


    void    OnMenuSelect(UINT uiItemID, UINT uiFlags, HMENU hSysMenu);
    void    OnCommand(UINT id, UINT code, HWND hwndCtl);
    void    OnInitMenuPopup(HMENU hMenu, UINT uiIndex, BOOL bSystem);
    void	SetMenuStates(HMENU hInitMenu);
	void 	UpdateWindowTitle(void);

    //
    // Popup context menu for drawing area
    //
    void PopupContextMenu(int x, int y);
    void UncheckMenuItem(UINT uiId);

    //
    // Check whether the application is idle (not opening or doing a new)
    //
    BOOL IsIdle(void);

	// widthbar needs access to the current tool to get the current widths
    WbTool *GetCurrentTool( void )
		{return( m_pCurrentTool );}


	BOOL IsToolBarOn( void )
		{return( m_bToolBarOn );}

	BOOL UsersMightLoseData( BOOL *pbWasPosted, HWND hwnd );

	//
	// Bring the main ui to top
	//
	void WbMainWindow::BringToFront(void);

    //
    // Update the page buttons disable/enable status
    //
    void UpdatePageButtons(void);

    //
    // Go to a specific page
    //
    void GotoPage(WorkspaceObj * pNewWorkspace, BOOL bResend = TRUE);
	void GoPage(WorkspaceObj * pNewWorkspace, BOOL bSend = TRUE);


    //
    // Handles tool tips and accelerators
    //
    BOOL    FilterMessage(MSG* pMsg);

    //
    // Global data
    //
    HWND        m_hwnd;
    WbTool *    m_ToolArray[TOOLTYPE_MAX];

    // Dropping files onto the window
    void	OnDropFiles(HDROP hDropInfo);

    //
    // HELP
    //
	LRESULT    ShowHelp();

    // Command handlers
	LRESULT OnAbout(void);
	LRESULT OnNew(void);
	LRESULT OnOpen(LPCSTR szLoadFileName = NULL);
	LRESULT OnClearPage(BOOL bClearAll = TRUE);
	LRESULT OnDelete(void);
	LRESULT OnUndelete(void);
	LRESULT OnCut(void);
	LRESULT OnCopy(void);
	LRESULT OnPaste(void);
	LRESULT OnSelectAll( void );
	LRESULT OnChooseFont(void);
	LRESULT OnToolBarToggle(void);
	LRESULT OnLock(void);
	LRESULT OnGrabWindow(void);
	LRESULT OnZoom(void);
	LRESULT OnSave(BOOL bPrompt);
	LRESULT OnPrint(void);
	LRESULT OnInsertPageAfter(void);
	LRESULT OnDeletePage(void);
	LRESULT OnGrabArea(void);
	LRESULT OnLButtonDown(void);
	LRESULT OnLButtonUp(void);
	LRESULT OnMouseMove(void);
	LRESULT OnRemotePointer(void);

	LRESULT OnSelectTool(UINT id);          // Select the current tool
	LRESULT OnSelectColor(void);            // Color changed in palette
	LRESULT OnSelectWidth(UINT id);         // Select pen width

    // Scrolling control (accessed via accelerators)
	LRESULT OnScrollAccelerator(UINT id);

    // Moving through the pages
	LRESULT OnFirstPage(void);
	LRESULT OnPrevPage(void);
	LRESULT OnNextPage(void);
	LRESULT OnLastPage(void);
	LRESULT OnGotoPage(void);
	LRESULT OnSync(void);
	void OnStatusBarToggle(void);



    // WindowProc handlers
    int     OnCreate(LPCREATESTRUCT lpcs);
    void    OnDestroy();
    void    OnClose(void);
    void    OnSize(UINT, int, int);
    void    OnSetFocus(void);
    void    OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT measureStruct);
    void    OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT drawStruct);
    void    OnGetMinMaxInfo(MINMAXINFO FAR* lpmmi);
    void    OnPaletteChanged(HWND hwndPalette);
    LRESULT OnQueryNewPalette(void);
    LRESULT OnQueryEndSession(void);
    LRESULT OnConfShutdown( WPARAM, LPARAM );
    void    OnEndSession(BOOL bEnding);
    void    OnParentNotify(UINT msg);
    LRESULT OnToolTipText(UINT, NMHDR*);

    void    OnDisplayError(WPARAM wParam, LPARAM lParam);

    void    LoadCmdLine(LPCSTR szFileName);

    // CancelMode processing
    void	OnCancelMode();
    void    OnNotify(UINT id, NMHDR* pNM);
	void	OnSysColorChange( void );

    BOOL                CLP_RenderFormat(int iFormat);

    BOOL            m_bToolBarOn;
	BitmapObj * 	m_pLocalRemotePointer;
	POINT			m_localRemotePointerPosition;

    //
    // Tool bar window
    //
    WbToolBar       m_TB;

    int             CLP_AcceptableClipboardFormat(void);


protected:
    void InvalidateActiveMenu();
    HMENU   m_hInitMenu;
    //
    // Tooltips
    //
    HWND        m_hwndToolTip;
    TOOLINFO    m_tiLastHit;
    int         m_nLastHit;

    int     OnToolHitTest(POINT pt, TOOLINFO* pTI) const;


	BOOL    m_bInitOk;

    //
    // Flag indicating that we are currently displaying a serious error
    // message.
    //
    BOOL    m_bDisplayingError;

    //
    // Domain ID of the call we are currently in
    //
    DWORD       m_dwDomain;

    //
    // Move to a given position in the page
    //
    void GotoPosition(int x, int y);

    //
    // Sync/unsync with other users.
    //
    void Sync(void);
    void Unsync(void);

    //
    // Clipboard access
    //
	BOOL 				PasteDIB( LPBITMAPINFOHEADER lpbi);
    BOOL			    CLP_Paste(void);
    BOOL                CLP_Copy(void);
    void                CLP_SaveDelayedGraphic(void);

    BOOL                CLP_RenderAllFormats(void);
    BOOL                CLP_RenderAllFormats(DCWbGraphic * pGraphic);
    BOOL                CLP_DelayAllFormats(DCWbGraphic * pGraphic);
    BOOL                CLP_RenderPrivateFormat();
    BOOL                CLP_RenderPrivateSingleFormat(DCWbGraphic* pGraphic);
    BOOL                CLP_RenderAsImage();
    BOOL                CLP_RenderAsText();
    BOOL                CLP_RenderAsBitmap();

#ifdef RENDER_AS_MF
    BOOL                CLP_RenderMetafileFormat(DCWbGraphic* pGraphic);
#endif


    //
    // Insert a new page after the specified page
    //
    void InsertPageAfter(WorkspaceObj * pCurrentWorkspace);

public:
    //
    // Drawing pane window
    //
    WbDrawingArea m_drawingArea;

    //
    // Color palette, font, page controls
    //
    WbAttributesGroup   m_AG;

    //
    // Resize function for subpanes - called when the window is resized by
    // the user.
    //
    void ResizePanes(void);


    UINT GetSubState( void )
		{return(m_uiSubState );}

    //
    // Get a lock on the Whiteboard contents.  The first parameter
    // determines the type of lock, the second whether a visible or
    // invisible dialog is to be used (use SW_SHOW or SW_HIDE).
    //
    BOOL GetLock(UINT uiLockType, UINT uiHide = SW_SHOW);

    //
    // FRAME WINDOW VARS
    //
    HACCEL              m_hAccelTable;

    //
    // Get the window title
    //
    TCHAR * GetWindowTitle(void);

    WbWidthsGroup       m_WG;              // Pen Widths

	void EnableToolbar( BOOL bEnable );

    //
    // Dialog that asks whether to save changes.
    //
    HWND        m_hwndQuerySaveDlg;

    //
    // Get confirmation for destructive functions (new, clear)
    //
    int QuerySaveRequired(BOOL bCancelBtn);

    //
    // Timed dialogs that are running while the main window is waiting
    // for a specific event.
    //
    HWND        m_hwndWaitForEventDlg;
    HWND        m_hwndWaitForLockDlg;

    //
    // Lock/unlock the drawing area
    //
    void LockDrawingArea(void);
    void UnlockDrawingArea(void);


	HANDLE m_hFile;
	LPSTR  GetFileNameStr(void);
	UINT ObjectSave(UINT type, LPBYTE pData,UINT length);
	PT126WB_FILE_HEADER_AND_OBJECTS ValidateFile(LPCSTR pFileName);

	UINT ContentsLoad(LPCSTR pFileName);
	UINT ObjectLoad(void);

    UINT m_currentMenuTool;                   // Current tool menu Id

    //
    // Load a file
    //
	HRESULT WB_LoadFile(LPCTSTR szFile);
    void LoadFile(LPCSTR strLoadFileName);

    //
    // Ensure the attributes window is up to date
    //
    void OnUpdateAttributes(void)
                 { m_AG.DisplayTool(m_pCurrentTool); }


protected:

	
	UINT GetTipId(HWND hTipWnd, UINT nID);


    //
    // Current window size - normal, maximized or minimized
    //
    UINT                m_uiWindowSize;

    //
    // Save the current window position to the options file
    //
    void SaveWindowPosition(void);


    //
    // Menu selection functions
    //
    UINT m_currentMenuWidth;                  // Current width menu Id


    HWND                m_hwndSB;
    BOOL                m_bStatusBarOn;
    void                UpdateStatus(void);

    //
    // Current drawing tool
    //
    WbTool*           m_pCurrentTool;

    //
    // Menu update functions
    //
	void InitializeMenus(void);
    void CheckMenuItem(UINT uiId);
    BOOL CheckMenuItemRecursive(HMENU hMenu, UINT uiId, BOOL bCheck);
	HMENU GetMenuWithItem(HMENU hMenu, UINT uiID);

    //
    //
    // Select a window for grabbing
    //
    HWND SelectWindow(void);

    //
    // Add a captured bitmap to the contents
    //
    void AddCapturedImage(BitmapObj* dib);

    //
    // Get a file name for saving
    //
    int GetFileName();

	//
    // Registration state variables
    //
    UINT        m_uiSubState;

    //
    // Display a message box for an error
    //
    void DisplayError(UINT uiCaption, UINT uiMessage);

    //
    // Current file name for saving image
    //
    TCHAR     m_strFileName[2*_MAX_PATH];
	TCHAR 	* m_pTitleFileName;	// File Name in the title

    //
    // Grab an area of the screen into a bitmap
    //
    void GetGrabArea(LPRECT lprect);

    //
    // Hide/show the main window and its associated popups
    //
    void ShowAllWindows(int iShow);
    void ShowAllWindows(void) { ShowAllWindows(SW_RESTORE); }	
    void HideAllWindows(void) { ShowAllWindows(SW_MINIMIZE); }	

    //
    // Handle of alternative accelerator table for page and text edit fields
    //
    HACCEL      m_hAccelPagesGroup;
    HACCEL      m_hAccelTextEdit;

	//
    // Context menu for drawing area
    //
    HMENU           m_hContextMenuBar;
    HMENU			m_hEditContextMenu;
    HMENU           m_hContextMenu;
    HMENU           m_hGrobjContextMenuBar;
    HMENU           m_hGrobjContextMenu;

    //
    // Member function to create pop-up context menu for the drawing area
    //
    BOOL CreateContextMenus(void);


    // We remember if we're in a save dialog so we can canel it on certain events
    BOOL            m_bInSaveDialog;
    void            CancelSaveDialog(void);

    //
    // Cancel a load in progress
    //
    void CancelLoad(BOOL bReleaseLock = TRUE);


	UINT ContentsSave(LPCSTR pFileName);

    //
    // Set the application substate
    //
    void SetSubstate(UINT newSubState);

    //
    // Map of page handles to positions
    //
	typedef struct PAGEPOSITION
	{
		WORD    hPage;
	 	POINT   position;
	} PAGE_POSITION;

    COBLIST    m_pageToPosition;
    void PositionUpdated(void);

protected:


    //
    // Number of remote users
    //

	BOOL m_bSelectAllInProgress;

	BOOL GetDefaultPath( LPTSTR csDefaultPath, UINT size );

	
	BOOL m_bUnlockStateSettled;

	BOOL m_bQuerySysShutdown;

	
	BOOL m_bIsWin95;

    //
    // Interface for determining if a WM_CANCELMODE message has been sent
    //
protected:
    BOOL m_cancelModeSent;

public:
    void ResetCancelMode() { m_cancelModeSent = FALSE; };
    BOOL CancelModeSent()  { return m_cancelModeSent;  };
};


//
// Timed dialog proc
//
INT_PTR CALLBACK TimedDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// QuerySave dialog proc
//
INT_PTR CALLBACK QuerySaveDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// WarnSelectWindow dialog proc
//
INT_PTR CALLBACK WarnSelectWindowDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// WarnSelectArea dialog proc
//
INT_PTR CALLBACK WarnSelectAreaDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// About Box dialog proc
//
INT_PTR CALLBACK AboutDlgProc(HWND, UINT, WPARAM, LPARAM);

#endif // __MWND_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\nmwbobj.cpp ===
// NMWbObj.cpp : Implementation of CNMWbObj
#include "precomp.h"
#include <wbguid.h>
#include "wbcaps.h"
#include "NMWbObj.h"
#include <iappldr.h>

// Local prototypes
void CALLBACK T120AppletCallbackProc(T120AppletMsg *pMsg);
void CALLBACK T120SessionCallbackProc(T120AppletSessionMsg *pMsg);


/////////////////////////////////////////////////////////////////////////////////////////////////////
// CNMWbObj Construction and initialization
///////////////////////////////////////////////////////////////////////////////////////////////////////

CNMWbObj*	g_pNMWBOBJ;
UINT		g_numberOfWorkspaces;
UINT		g_numberOfObjects;
CWBOBLIST*	g_pListOfWorkspaces;
BOOL		g_fWaitingForBufferAvailable;
CWBOBLIST*	g_pListOfObjectsThatRequestedHandles;
CWBOBLIST*	g_pRetrySendList;
CWBOBLIST*	g_pTrash;
ULONG		g_MyMemberID;
ULONG		g_RefresherID;
UINT		g_MyIndex;
BOOL 		g_bSavingFile;
BOOL		g_bContentsChanged;

GCCPREALOC 	g_GCCPreallocHandles[PREALLOC_GCC_BUFFERS];
UINT 		g_iGCCHandleIndex;
BOOL		g_WaitingForGCCHandles;

//
// T.126 protocol related
//
static const ULONG g_T126KeyNodes[] = {0,0,20,126,0,1};
static const T120ChannelID g_aStaticChannels[] = { _SI_CHANNEL_0 };


//
// T.120 capabilities
//
static GCCAppCap *g_CapPtrList[_iT126_MAX_COLLAPSING_CAPABILITIES];
static GCCAppCap g_CapArray[_iT126_MAX_COLLAPSING_CAPABILITIES];

//
// T.120 non-collapsing capabilities
//
#define MY_APP_STR              "_MSWB"
#define T126_TEXT_STRING        "NM 3 Text"
#define T126_24BIT_STRING       "NM 3 24BitMap"
static const OSTR s_AppData[_iT126_LAST_NON_COLLAPSING_CAPABILITIES] =
    {
        {
            sizeof(T126_TEXT_STRING),
            (LPBYTE) T126_TEXT_STRING
        },
        {
            sizeof(T126_24BIT_STRING),
            (LPBYTE) T126_24BIT_STRING
        },
    };

static GCCNonCollCap g_NCCapArray[2];
static const GCCNonCollCap *g_NCCapPtrList[2] = { &g_NCCapArray[0], &g_NCCapArray[1] };


//
// Member ID arrays, assuming 64 members
//
#define MAX_MEMBERS			128
static MEMBER_ID g_aMembers[MAX_MEMBERS];




CNMWbObj::CNMWbObj( void ) :
			// T.120 applet SAP
			m_pApplet(NULL),
			m_aMembers(&g_aMembers[0])
{
	DBGENTRY(CNMWbObj::CNMWbObj);

	DBG_SAVE_FILE_LINE
	g_pListOfWorkspaces = new CWBOBLIST();
	DBG_SAVE_FILE_LINE
	g_pListOfObjectsThatRequestedHandles = new CWBOBLIST();
	DBG_SAVE_FILE_LINE
	g_pTrash = new CWBOBLIST();
	DBG_SAVE_FILE_LINE
	g_pRetrySendList = new CWBOBLIST();
	g_pListOfWorkspaces->EmptyList();
	g_pListOfObjectsThatRequestedHandles->EmptyList();
	g_pRetrySendList->EmptyList();
	g_pTrash->EmptyList();
	g_numberOfWorkspaces = 0;
	g_numberOfObjects = 0;
	g_MyIndex = 0;
	g_bSavingFile = FALSE;
	g_bContentsChanged = FALSE;
	g_iGCCHandleIndex = 0;
	g_fWaitingForBufferAvailable = FALSE;
	g_WaitingForGCCHandles = FALSE;
    ::ZeroMemory(&g_GCCPreallocHandles, sizeof(g_GCCPreallocHandles));
    m_instanceNumber = 0;
    m_bConferenceOnlyNetmeetingNodes = TRUE;

	g_pNMWBOBJ = this;

	// Cleanup per-conference T.120 info
	CleanupPerConf();

	// T.120 Applet
	T120Error rc = ::T120_CreateAppletSAP(&m_pApplet);
	if (T120_NO_ERROR != rc)
	{
		ERROR_OUT(("CNMWbObj::CNMWbObj: cannot create applet SAP"));
		return;
	}
	ASSERT(NULL != m_pApplet);
	m_pApplet->Advise(T120AppletCallbackProc, this);

	//
	// Fill in the capabilities
	//
	BuildCaps();

    //
    // Load IMM32 if this is FE
    //
    ASSERT(!g_hImmLib);
    ASSERT(!g_fnImmGetContext);
    ASSERT(!g_fnImmNotifyIME);

    if (GetSystemMetrics(SM_DBCSENABLED))
    {
        g_hImmLib = LoadLibrary("imm32.dll");
        if (!g_hImmLib)
        {
            ERROR_OUT(("Failed to load imm32.dll"));
        }
        else
        {
            g_fnImmGetContext = (IGC_PROC)GetProcAddress(g_hImmLib, "ImmGetContext");
            if (!g_fnImmGetContext)
            {
                ERROR_OUT(("Failed to get ImmGetContext pointer"));
            }
            g_fnImmNotifyIME = (INI_PROC)GetProcAddress(g_hImmLib, "ImmNotifyIME");
            if (!g_fnImmNotifyIME)
            {
                ERROR_OUT(("Failed to get ImmNotifyIME pointer"));
            }
        }
    }

	DBG_SAVE_FILE_LINE
    g_pMain = new WbMainWindow();
    if (!g_pMain)
    {
        ERROR_OUT(("Can't create WbMainWindow"));
    }
    else
    {
	    //
    	// OK, now we're ready to create our HWND
	    //

    	if (!g_pMain->Open(SW_SHOWDEFAULT))
	    {
    	    ERROR_OUT(("Can't create WB windows"));
    	}
	}

	
	DBGEXIT(CNMWbObj::CNMWbObj);
}

CNMWbObj::~CNMWbObj( void ) 
{
	DBGENTRY(CNMWbObj::~CNMWbObj);

	//
	// If i'm the refresher, I have to release the token
	// And send an workspace refresh status pdu
	//
	if(m_bImTheT126Refresher)
	{
		::ZeroMemory(&m_tokenRequest, sizeof(m_tokenRequest));
		m_tokenRequest.eCommand = APPLET_RELEASE_TOKEN;
		m_tokenRequest.nTokenID = _SI_WORKSPACE_REFRESH_TOKEN;
		T120Error rc = m_pAppletSession->TokenRequest(&m_tokenRequest);

		SendWorkspaceRefreshPDU(FALSE);
	
	}



	// no more T.120
	if (NULL != m_pAppletSession)
	{
		m_pAppletSession->ReleaseInterface();
		CleanupPerConf();
	}
	if (NULL != m_pApplet)
	{
		m_pApplet->ReleaseInterface();
		m_pApplet = NULL;
	}



	if(g_pMain)
	{
		delete g_pMain;
		g_pMain = NULL;
	}

	//
	// Delete all the global lists
	//
	DeleteAllWorkspaces(FALSE);
	g_pListOfWorkspaces->EmptyList();
	g_pListOfObjectsThatRequestedHandles->EmptyList();
	g_numberOfWorkspaces = 0;

	T126Obj* pGraphic;
	//
	// Burn trash
	//
	pGraphic = (T126Obj *)g_pTrash->RemoveTail();
	while (pGraphic != NULL)
	{
		delete pGraphic;
		pGraphic = (T126Obj *) g_pTrash->RemoveTail();
	}

	if(g_pTrash)
	{
		delete g_pTrash;
		g_pTrash = NULL;
	}

	if(g_pListOfWorkspaces)
	{
		delete g_pListOfWorkspaces;
		g_pListOfWorkspaces = NULL;
	}

	if(g_pListOfObjectsThatRequestedHandles)
	{
		delete g_pListOfObjectsThatRequestedHandles;
		g_pListOfObjectsThatRequestedHandles = NULL;
	}
	
	if(g_pRetrySendList)
	{
		delete g_pRetrySendList;
		g_pRetrySendList = NULL;
	}

	g_fnImmNotifyIME = NULL;
    g_fnImmGetContext = NULL;
    if (g_hImmLib)
    {
        FreeLibrary(g_hImmLib);
        g_hImmLib = NULL;
    }

	DBGEXIT(CNMWbObj::~CNMWbObj);
}


void 	CNMWbObj::BuildCaps(void)
{
	// Fill in the caps we support
	int i;

	for(i=0;i<_iT126_MAX_COLLAPSING_CAPABILITIES;i++)
	{
		g_CapArray[i].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
		g_CapArray[i].capability_id.standard_capability = GCCCaps[i].CapValue;
		g_CapArray[i].capability_class.eType = GCCCaps[i].Type;


		if( GCCCaps[i].CapValue == Soft_Copy_Workspace_Max_Width)
		{
			GCCCaps[i].MinValue = DRAW_WIDTH + 1;
			GCCCaps[i].MaxValue = DRAW_WIDTH - 1;
		}

		if(GCCCaps[i].CapValue == Soft_Copy_Workspace_Max_Height)
		{
			GCCCaps[i].MinValue = DRAW_HEIGHT + 1;
			GCCCaps[i].MaxValue = DRAW_HEIGHT - 1;
		}

		if(GCCCaps[i].CapValue == Soft_Copy_Workspace_Max_Planes)
		{
			GCCCaps[i].MinValue = WB_MAX_WORKSPACES + 1;
			GCCCaps[i].MaxValue = WB_MAX_WORKSPACES - 1;
		}


		if(GCCCaps[i].Type == GCC_UNSIGNED_MINIMUM_CAPABILITY)
		{
			g_CapArray[i].capability_class.nMinOrMax = GCCCaps[i].MinValue - 1;
		}
		else if ((GCCCaps[i].Type == GCC_UNSIGNED_MAXIMUM_CAPABILITY))
		{
			g_CapArray[i].capability_class.nMinOrMax = GCCCaps[i].MaxValue + 1;
		}
		else
		{
			g_CapArray[i].capability_class.nMinOrMax = 0;
		}

		g_CapArray[i].number_of_entities = 0;

		g_CapPtrList[i] = &g_CapArray[i];
	}

    //
    // Non-Collapsed Capabilities
	//
	g_NCCapArray[0].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
	g_NCCapArray[0].capability_id.standard_capability = _iT126_TEXT_CAPABILITY_ID;
	g_NCCapArray[0].application_data = (OSTR *) &s_AppData[0];

	//
	// How many bits per pixel can we handle?
	//
	HDC hDC = CreateCompatibleDC(NULL);

	if((GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES)) >= 24)
	{
		m_bICanDo24BitBitmaps = TRUE;
		g_NCCapArray[1].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
		g_NCCapArray[1].capability_id.standard_capability = _iT126_24BIT_BITMAP_ID;
		g_NCCapArray[1].application_data = (OSTR *) &s_AppData[1];
	}
	else
	{
		m_bICanDo24BitBitmaps = FALSE;
	}

	if (hDC)
	{
		DeleteDC(hDC);
	}

}





//
// T120 Applet Functions
//


void CALLBACK T120AppletCallbackProc
(
	T120AppletMsg 		*pMsg
)
{
	CNMWbObj *pWBOBJ = (CNMWbObj *) pMsg->pAppletContext;
	if (pWBOBJ == g_pNMWBOBJ)
	{
		switch (pMsg->eMsgType)
		{
		case GCC_PERMIT_TO_ENROLL_INDICATION:
			pWBOBJ->OnPermitToEnroll(pMsg->PermitToEnrollInd.nConfID,
									 pMsg->PermitToEnrollInd.fPermissionGranted);
			break;

		case T120_JOIN_SESSION_CONFIRM:
		default:
			break;
		}
	}
}


void CALLBACK T120SessionCallbackProc
(
	T120AppletSessionMsg	*pMsg
)
{
	if(g_pNMWBOBJ == NULL)
	{
		return;
	}

	CNMWbObj *pSession = (CNMWbObj *) pMsg->pSessionContext;
    ASSERT(pMsg->pAppletContext == pMsg->pSessionContext);
	if (pSession == g_pNMWBOBJ)
	{
        ASSERT(pMsg->nConfID == pSession->GetConfID());
		switch (pMsg->eMsgType)
		{
        case MCS_UNIFORM_SEND_DATA_INDICATION:
		//
		// Check if we are receiving a indication from owrself
		//
		if(pMsg->SendDataInd.initiator == GET_USER_ID_FROM_MEMBER_ID(g_MyMemberID))
		{
			return;
		}
        case MCS_SEND_DATA_INDICATION:
				::T126_MCSSendDataIndication(
                        pMsg->SendDataInd.user_data.length,
                        pMsg->SendDataInd.user_data.value,
                        pMsg->SendDataInd.initiator,
                        FALSE);
            break;

		case MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION:
			g_fWaitingForBufferAvailable = FALSE;
			RetrySend();
			break;


        case GCC_APP_ROSTER_REPORT_INDICATION:
            pSession->OnRosterIndication((ULONG) pMsg->AppRosterReportInd.cRosters,
                                         pMsg->AppRosterReportInd.apAppRosters);
            break;

        case GCC_ALLOCATE_HANDLE_CONFIRM:
            pSession->OnAllocateHandleConfirm(&pMsg->RegAllocHandleConfirm);
            break;

		case T120_JOIN_SESSION_CONFIRM:
			pSession->OnJoinSessionConfirm(&pMsg->JoinSessionConfirm);
			break;


		case MCS_TOKEN_GRAB_CONFIRM:
			TRACE_DEBUG(("MCS_TOKEN_GRAB_CONFIRM result = %d",pMsg->TokenConfirm.eResult));

			if(pMsg->TokenConfirm.eResult == T120_RESULT_SUCCESSFUL)
			{
				TRACE_DEBUG((">>> I'm the T126 REFRESHER <<<"));
				g_pNMWBOBJ->m_bImTheT126Refresher = TRUE;

				//
				// Tell everybody I'm the refresher
				//
				SendWorkspaceRefreshPDU(TRUE);

				g_RefresherID = g_MyMemberID;
				
			}
			else
			{
				TRACE_DEBUG((">>> I'm NOT the  T126 REFRESHER <<<"));

				// if we are not the t126 refresher, we should save the previous work
				if (!g_pNMWBOBJ->m_bImTheT126Refresher)
				{

					if(!g_pNMWBOBJ->IsInConference())
					{
						if (g_pMain && (g_pMain->QuerySaveRequired(FALSE) == IDYES))
						{
							g_pMain->OnSave(FALSE);
						}
			
						//
						// If we were waiting on the save contents <yes> <no> dialog
						// and the whole conference and UI are exiting, g_pMain could be NULL
						// Or if  we are not in a call anymore, we don't need to delete all the local workspaces.
						// 
						if(g_pMain == NULL || !g_pNMWBOBJ->IsInConference())
						{
							return;
						}


						::InvalidateRect(g_pDraw->m_hwnd, NULL, TRUE);
						DeleteAllWorkspaces(FALSE);

						//
						// Fill up the GCC tank
						//
						TimeToGetGCCHandles(PREALLOC_GCC_HANDLES);
					}
					// ELSE
					// If we got here and we are in a call don't do a thing.
					// We just got here because the refresher went away. We tried
					// to grab the token and we lost it to a faster node.
					//
					
				}
			}

		    break;


		default:
			break;
		}
	}
}


void CNMWbObj::OnPermitToEnroll
(
	T120ConfID			nConfID,
	BOOL				fPermissionGranted
)
{
	if (fPermissionGranted)
	{
		// We are not in a conference, right?
		ASSERT(NULL == m_pAppletSession);

		m_bConferenceOnlyNetmeetingNodes = TRUE;

		// Create an applet session
		T120Error rc = m_pApplet->CreateSession(&m_pAppletSession, nConfID);
		if (T120_NO_ERROR == rc)
		{
			ASSERT(NULL != m_pAppletSession);
			m_pAppletSession->Advise(T120SessionCallbackProc, this, this);

			// get top provider information
			m_bImTheTopProvider = m_pAppletSession->IsThisNodeTopProvider();

			// Build join-sesion request
			::ZeroMemory(&m_JoinSessionReq, sizeof(m_JoinSessionReq));
			m_JoinSessionReq.dwAttachmentFlags = ATTACHMENT_DISCONNECT_IN_DATA_LOSS | ATTACHMENT_MCS_FREES_DATA_IND_BUFFER;
			m_JoinSessionReq.SessionKey.application_protocol_key.key_type = GCC_OBJECT_KEY;
			m_JoinSessionReq.SessionKey.application_protocol_key.object_id.long_string = (ULONG *) g_T126KeyNodes;
			m_JoinSessionReq.SessionKey.application_protocol_key.object_id.long_string_length = sizeof(g_T126KeyNodes) / sizeof(g_T126KeyNodes[0]);
			m_JoinSessionReq.SessionKey.session_id = _SI_CHANNEL_0;
			m_JoinSessionReq.fConductingCapable = FALSE;
			m_JoinSessionReq.nStartupChannelType =MCS_STATIC_CHANNEL;
			m_JoinSessionReq.cNonCollapsedCaps =1 + (m_bICanDo24BitBitmaps ? 1 : 0);
			m_JoinSessionReq.apNonCollapsedCaps = (GCCNonCollCap **) g_NCCapPtrList;
			m_JoinSessionReq.cCollapsedCaps = sizeof(g_CapPtrList) / sizeof(g_CapPtrList[0]);
			ASSERT(_iT126_MAX_COLLAPSING_CAPABILITIES == sizeof(g_CapPtrList) / sizeof(g_CapPtrList[0]));
			m_JoinSessionReq.apCollapsedCaps = g_CapPtrList;
			m_JoinSessionReq.cStaticChannels = sizeof(g_aStaticChannels) / sizeof(g_aStaticChannels[0]);
			m_JoinSessionReq.aStaticChannels = (T120ChannelID *) g_aStaticChannels;


			//
			// Token to grab
			//
			::ZeroMemory(&m_tokenResourceRequest, sizeof(m_tokenResourceRequest));
			m_tokenResourceRequest.eCommand = APPLET_GRAB_TOKEN_REQUEST;
			// m_tokenRequest.nChannelID = _SI_CHANNEL_0;
			m_tokenResourceRequest.nTokenID = _SI_WORKSPACE_REFRESH_TOKEN;
            m_tokenResourceRequest.fImmediateNotification = TRUE;

			m_JoinSessionReq.cResourceReqs = 1;
			m_JoinSessionReq.aResourceReqs = &m_tokenResourceRequest;

			// Join now
			rc = m_pAppletSession->Join(&m_JoinSessionReq);
			if (T120_NO_ERROR == rc)
			{
                m_nConfID = nConfID;

				//
				// JOSEF NOW SET THE MAIN WINDOW STATUS
            }
            else
            {
				WARNING_OUT(("CNMWbObj::OnPermitToEnroll: cannot join conf=%u, rc=%u", nConfID, rc));
			}
		}
	}
	else
	{
		if (NULL != m_pAppletSession)
		{
			m_pAppletSession->ReleaseInterface();
			CleanupPerConf();
		}
	}
}


void CNMWbObj::OnJoinSessionConfirm
(
	T120JoinSessionConfirm		*pConfirm
)
{
	if (NULL != m_pAppletSession)
	{
		ASSERT(m_pAppletSession == pConfirm->pIAppletSession);
		if (T120_RESULT_SUCCESSFUL == pConfirm->eResult)
		{
			m_uidMyself = pConfirm->uidMyself;
			m_sidMyself = pConfirm->sidMyself;
			m_eidMyself = pConfirm->eidMyself;
			m_nidMyself = pConfirm->nidMyself;

			// create member ID
			g_MyMemberID = MAKE_MEMBER_ID(m_nidMyself, m_uidMyself);

			if(g_pDraw && g_pDraw->IsLocked())
			{
				m_LockerID = g_MyMemberID;
			}

			// regardless, update the index anyway
			g_MyIndex = (m_uidMyself + NUMCOLS) % NUMCLRPANES;

			// we are now in the conference
			m_fInConference = TRUE;

			// allocate handles for all objects
			if (m_bImTheT126Refresher)
			{

				g_RefresherID = g_MyMemberID;

				//
				// Resend all objects
				//
				WBPOSITION pos;
				WBPOSITION posObj;
				WorkspaceObj* pWorkspace;
				T126Obj* pObj;

				pos = g_pListOfWorkspaces->GetHeadPosition();

				while(pos)
				{
					pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
					g_pListOfObjectsThatRequestedHandles->AddHead(pWorkspace);
		
					posObj = pWorkspace->GetHeadPosition();
					while(posObj)
					{
						pObj = pWorkspace->GetNextObject(posObj);
						if(pObj)
						{
							g_pListOfObjectsThatRequestedHandles->AddHead(pObj);
						}
					}
				}


				//
				// Delete the fake handles we had
				//
				g_WaitingForGCCHandles = FALSE;
				g_GCCPreallocHandles[0].GccHandleCount = 0;
				g_GCCPreallocHandles[1].GccHandleCount = 0;
				TimeToGetGCCHandles(g_numberOfObjects + g_numberOfWorkspaces + PREALLOC_GCC_HANDLES);
			}
			else
			{
				::InvalidateRect(g_pDraw->m_hwnd, NULL, TRUE);
				DeleteAllWorkspaces(FALSE);
			}


		}
		else
		{
			WARNING_OUT(("CNMWbObj::OnJoinSessionConfirm: failed to join conference, result=%u. error=%u",
				pConfirm->eResult, pConfirm->eError));
			ASSERT(GCC_CONFERENCE_NOT_ESTABLISHED == pConfirm->eError);
			m_pAppletSession->ReleaseInterface();
			CleanupPerConf();
		}
	}
}


void CNMWbObj::OnAllocateHandleConfirm
(
    GCCRegAllocateHandleConfirm     *pConfirm
)
{
    if (T120_RESULT_SUCCESSFUL == pConfirm->nResult)
    {
	    ::T126_GCCAllocateHandleConfirm(pConfirm->nFirstHandle, pConfirm->cHandles);
    }
    else
    {
        ERROR_OUT(("CNMWbObj::OnAllocateHandleConfirm: failed to allocate %u handles, result=%u",
                pConfirm->cHandles, pConfirm->nResult));
    }
}


void CNMWbObj::OnRosterIndication
(
    ULONG           cRosters,
    GCCAppRoster    *apRosters[]
)
{
	if (IsInConference())
	{
		BOOL fAdded = FALSE;
		BOOL fRemoved = FALSE;
		ULONG cOtherMembers = 0;
		ULONG i, j, k;

		// Caculate how many members in this session
		for (i = 0; i < cRosters; i++)
		{
			GCCAppRoster *pRoster = apRosters[i];

			// bail out if this roster is not for this session
			if (pRoster->session_key.session_id != m_sidMyself)
			{
					continue;
			}

			// node added or removed?
			fAdded |= pRoster->nodes_were_added;
			fRemoved |= pRoster->nodes_were_removed;

			BOOL conferenceCanDo24BitBitmap = TRUE;
			BOOL conferenceCanDoText = TRUE;
			// parse the roster records
			for (j = 0; j < pRoster->number_of_records; j++)
			{
				GCCAppRecord *pRecord = pRoster->application_record_list[j];
				if (pRecord->is_enrolled_actively)
				{
					MEMBER_ID nMemberID = MAKE_MEMBER_ID(pRecord->node_id, pRecord->application_user_id);
					if (nMemberID != g_MyMemberID)
					{
						//
						// Only count T126 apps
						//
						if((pRoster->session_key.application_protocol_key.key_type == GCC_OBJECT_KEY &&
						pRoster->session_key.application_protocol_key.object_id.long_string_length == sizeof(g_T126KeyNodes) / sizeof(g_T126KeyNodes[0]) &&
						!memcmp (pRoster->session_key.application_protocol_key.object_id.long_string, g_T126KeyNodes, sizeof(g_T126KeyNodes))))
						{
							
							cOtherMembers++;
							m_instanceNumber = pRoster->instance_number;

							if(T120_GetNodeVersion(m_nConfID, pRecord->node_id) < 0x404)
							{
								m_bConferenceOnlyNetmeetingNodes = FALSE;
							}

						}
					}

					
					//
					// Can we do 24 color bitmap
					//
					BOOL nodeCanDo24BitBitmap = FALSE;
					BOOL nodeCanDoText = FALSE;
					for (k = 0; k < pRecord->number_of_non_collapsed_caps; k++)
					{
						//
						// Check if the node handles 24 bit bitmaps
						//
						if(pRecord->non_collapsed_caps_list[k]->application_data->length == sizeof(T126_24BIT_STRING))
						{
							if(!memcmp(pRecord->non_collapsed_caps_list[k]->application_data->value, T126_24BIT_STRING ,sizeof(T126_24BIT_STRING)))
							{
								nodeCanDo24BitBitmap = TRUE;
							}
						}

						//
						// Check if the node handles text
						//
						if(pRecord->non_collapsed_caps_list[k]->application_data->length == sizeof(T126_TEXT_STRING))
						{
							if(!memcmp(pRecord->non_collapsed_caps_list[k]->application_data->value, T126_TEXT_STRING ,sizeof(T126_TEXT_STRING)))
							{
								nodeCanDoText = TRUE;
							}
						}
						
					}

					conferenceCanDo24BitBitmap &= nodeCanDo24BitBitmap;
					conferenceCanDoText &= nodeCanDoText;
				}
				
			} // for

			m_bConferenceCanDo24BitBitmaps = conferenceCanDo24BitBitmap;
			m_bConferenceCanDoText = conferenceCanDoText;
		
		} // for




		// If there are changes, we then do the update
		if (fAdded || fRemoved || cOtherMembers != m_cOtherMembers)
		{
			MEMBER_ID aTempMembers[MAX_MEMBERS]; // scratch copy

			// make sure we are able to handle it
			if (cOtherMembers >= MAX_MEMBERS)
			{
				ERROR_OUT(("CNMWbObj::OnRosterIndication: we hit the max members limit, cOtherMembers=%u, max-members=%u",
						cOtherMembers, MAX_MEMBERS));
				cOtherMembers = MAX_MEMBERS;
			}

			// reset the flags for members added and removed
			fAdded = FALSE;
			fRemoved = FALSE;

			// copy the members
			ULONG idxTempMember = 0;
			for (i = 0; i < cRosters; i++)
			{
				GCCAppRoster *pRoster = apRosters[i];

				// bail out if this roster is not for this session
				if (pRoster->session_key.session_id != m_sidMyself)
				{
					continue;
				}

				// parse the roster records
				for (j = 0; j < pRoster->number_of_records; j++)
				{
					GCCAppRecord *pRecord = pRoster->application_record_list[j];
					if (pRecord->is_enrolled_actively)
					{
						MEMBER_ID nMemberID = MAKE_MEMBER_ID(pRecord->node_id, pRecord->application_user_id);
						if (nMemberID != g_MyMemberID && idxTempMember < cOtherMembers)
						{
							aTempMembers[idxTempMember++] = nMemberID;

							// let's see if it is an 'add' or a 'delete'
							for (k = 0; k < m_cOtherMembers; k++)
							{
								if (m_aMembers[k] == nMemberID)
								{
									m_aMembers[k] = 0;
									break;
								}
							}
							fAdded |= (k >= m_cOtherMembers); // not found, must be new
						}
					}
				} // for
			} // for

			// sanity check
			ASSERT(idxTempMember == cOtherMembers);

			// see if there are ones that are not in the new roster.
			// if so, they must be removed.
			for (k = 0; k < m_cOtherMembers; k++)
			{
				if (m_aMembers[k])
				{
					fRemoved = TRUE;

					ULONG memberID = GET_USER_ID_FROM_MEMBER_ID(m_aMembers[k]);

					TRACE_DEBUG(("OnRosterIndication removing RemotePointer from member =%x", memberID));

					RemoveRemotePointer(memberID);

					//
					// if the refresher went away
					//
					if(g_RefresherID == memberID)
					{
						GrabRefresherToken();
					}

					//
					// if node locking went away
					//
					if(m_LockerID == memberID)
					{
						TogleLockInAllWorkspaces(FALSE, FALSE); // Not locked, don't send updates
						g_pMain->UnlockDrawingArea();
						g_pMain->m_TB.PopUp(IDM_LOCK);
						g_pMain->UncheckMenuItem(IDM_LOCK);
						m_LockerID = 0;
					}
				}
			}

			// now, update the member array
			m_cOtherMembers = cOtherMembers;
			if (m_cOtherMembers)
			{
				ASSERT(sizeof(m_aMembers[0]) == sizeof(aTempMembers[0]));
				::CopyMemory(&m_aMembers[0], &aTempMembers[0], m_cOtherMembers * sizeof(m_aMembers[0]));
			}

			// if added, resend all objects
			if (fAdded && (m_bImTheT126Refresher))
			{
				//
				// Tell the new node that I'm the refresher
				//
				SendWorkspaceRefreshPDU(TRUE);

				//
				// Refresh the new node
				//
				ResendAllObjects();


				//
				// if node locking everybody went away
				//
				if(m_LockerID == g_MyMemberID)
				{
					TogleLockInAllWorkspaces(TRUE, TRUE); // Locked, send updates 
				}

				//
				// Syncronize it
				//
				if(g_pCurrentWorkspace)
				{
					g_pCurrentWorkspace->OnObjectEdit();
				}
			}

			// finally, update the caption
			if(g_pMain)
			{
				g_pMain->UpdateWindowTitle();
			}
		} // if any change
	} // if is in conf
}


void CNMWbObj::CleanupPerConf(void)
{
	m_fInConference = FALSE;
	m_pAppletSession = NULL;

	g_MyMemberID = 0;
	g_RefresherID = 0;

    m_nConfID = 0;      // Conf ID
	m_uidMyself = 0;	// User ID
	m_sidMyself = 0;	// Session ID
	m_eidMyself = 0;	// Entity ID
	m_nidMyself = 0;	// Node ID

	m_bImTheTopProvider = FALSE;
	m_bImTheT126Refresher = FALSE;
	m_bConferenceOnlyNetmeetingNodes = TRUE;
	
	m_cOtherMembers = 0;

	if(g_pMain)
	{
 
        g_pMain->UpdateWindowTitle();
		RemoveRemotePointer(0);
		DeleteAllRetryPDUS();
		g_pListOfObjectsThatRequestedHandles->EmptyList();

		ASSERT(g_pDraw);
		//
		// If we were locked
		//
		if(g_pDraw->IsLocked())
		{
			m_LockerID = g_MyMemberID;
			TogleLockInAllWorkspaces(FALSE, FALSE); // Not locked, don't send updates
			g_pMain->UnlockDrawingArea();
			g_pMain->m_TB.PopUp(IDM_LOCK);
			g_pMain->UncheckMenuItem(IDM_LOCK);
		}
	}
	m_LockerID = 0;
}


T120Error CNMWbObj::SendData
(
    T120Priority	ePriority,
    ULONG           cbDataSize,
    PBYTE           pbData
)
{
	T120Error rc;

	if (IsInConference())
	{
    	rc = m_pAppletSession->SendData(
                            UNIFORM_SEND_DATA,
                            _SI_CHANNEL_0,
                            ePriority,
                            pbData,
                            cbDataSize,
                            APP_ALLOCATION);
	}
	else
	{
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

    return rc;
}


T120Error CNMWbObj::GrabRefresherToken(void)
{
	T120Error rc;

	if (IsInConference())
	{
	    T120TokenRequest Req;

		Req.eCommand = APPLET_GRAB_TOKEN;
		Req.nTokenID = _SI_WORKSPACE_REFRESH_TOKEN;
		Req.uidGiveTo = m_uidMyself;
		Req.eGiveResponse = T120_RESULT_SUCCESSFUL;

	    rc = m_pAppletSession->TokenRequest(&Req);
		if (T120_NO_ERROR != rc)
		{
			WARNING_OUT(("CNMWbObj::AllocateHandles: TokenRequest"));
		}
	}
	else
	{
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

    return rc;
}


T120Error CNMWbObj::AllocateHandles
(
    ULONG           cHandles
)
{
	T120Error rc;

	if ( cHandles > 0  && IsInConference())
	{
	    T120RegistryRequest Req;
	    Req.eCommand = APPLET_ALLOCATE_HANDLE;
	    Req.pRegistryKey = NULL;
	    Req.cHandles = cHandles;

	    rc = m_pAppletSession->RegistryRequest(&Req);
		if (T120_NO_ERROR != rc)
		{
			ERROR_OUT(("CNMWbObj::AllocateHandles: RegistryRequest(cHandles=%u), rc=%u", cHandles, rc));
		}
	}
	else
	{
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\page.hpp ===
//
// PAGE.HPP
// Page Class
//
// Copyright Microsoft 1998-
//
#ifndef __PAGE_HPP_
#define __PAGE_HPP_

//
// Purpose: Handler for page of graphic objects
//


class T126Obj;
class WorkspaceObj;

//
// Retrieving object data
//
T126Obj* PG_First(WorkspaceObj * pWorkSpc, LPCRECT lprcUpdate=NULL, BOOL bCheckReallyHit=FALSE);
T126Obj* PG_Next(WorkspaceObj * pWorkSpc, WBPOSITION& pos, LPCRECT lprcUpdate=NULL, BOOL bCheckReallyHit=FALSE);
T126Obj* PG_SelectLast(WorkspaceObj * pWorkSpc,POINT point);
T126Obj* PG_SelectPrevious(WorkspaceObj* pWorkspace,WBPOSITION& pos,POINT point);

//
// Draw the entire contents of the page into the device context
// specified.
//
void PG_Draw(WorkspaceObj*  pWorkspace, HDC hDC);

//
// Print an area of the page to the specified DC
//
void PG_Print(WorkspaceObj*  pWorkspace, HDC hdcPrinter, LPCRECT lprcArea);

//
// Return the palette to be used for displaying the page
//
HPALETTE    PG_GetPalette(void);
void        PG_InitializePalettes(void);
void        PG_ReinitPalettes(void);



#endif // __PAGE_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\precomp.h ===
//
// Precompiled header stuff
//


#define OEMRESOURCE
#define STRICT 1


#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <shellapi.h>                   // Includes drag drop interface
#include <imm.h>


//
// NM headers
//
#include <mlzdbg.h>
#include <confreg.h>
#include <oprahcom.h>
#include <indeopal.h>
#include <help_ids.h>
#include <endsesn.h>
#include <nmhelp.h>

// macro for setting "match to palette colors" bits in a COLORREF
#define SET_PALETTERGB( c )  (0x02000000 | (0x00ffffff & c))


#ifdef _DEBUG
extern HDBGZONE ghZoneWb;

// UPDATE g_rgZonesWb IF THESE CHANGE
enum
{
    ZONE_WB_DEBUG = BASE_ZONE_INDEX,
    ZONE_WB_MSG,
    ZONE_WB_TIMER,
    ZONE_WB_EVENT,
    ZONE_WB_MAX
};
		
#define TRACE_DEBUG( s )	MLZ_TraceZoneEnabled(ZONE_WB_DEBUG) ? (MLZ_TraceOut s) : 0
#define TRACE_MSG( s )		MLZ_TraceZoneEnabled(ZONE_WB_MSG) ? (MLZ_TraceOut s) : 0
#define TRACE_TIMER( s )	MLZ_TraceZoneEnabled(ZONE_WB_TIMER) ? (MLZ_TraceOut s) : 0
#define TRACE_EVENT( s )	MLZ_TraceZoneEnabled(ZONE_WB_EVENT) ? (MLZ_TraceOut s) : 0

#else

#define MLZ_EntryOut(zone, func)

#define TRACE_DEBUG( a )
#define TRACE_MSG( a )
#define TRACE_TIMER( a )
#define TRACE_EVENT( a )

#endif


#include "resource.h"
#include <oblist.h>
#include "ms_util.h"
#include "wboblist.hpp"
#include "ccl32.hpp"
#include "page.hpp"
#include "cgrp.hpp"
#include "wgrp.hpp"
#include "agrp.hpp"
#include "tool.hpp"
#include "twnd.hpp"
#include "t126.h"
#include "coder.hpp"
#include "t126obj.hpp"
#include "drawobj.hpp"
#include "textobj.hpp"
#include "txted.hpp"
#include "draw.hpp"
#include "wrkspobj.hpp"
#include "bmpobj.hpp"
#include "mcshelp.h"
#include "mwnd.hpp"
#include "gcchelp.h"
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\resource.h ===
#define IDI_APP                           1
#define WARNSELECTWINDOW                103
#define WARNSELECTAREA                  104
#define IDR_TOOLS                       118
#define IDR_NMWBOBJ                     120
#define ABOUTBOX                        130
#define PRINTCANCEL                     131
#define PAGESORTERDIALOG                132
#define LOCKDIALOG                      133
#define INVISIBLEDIALOG                 134
#define QUERYSAVEDIALOG                 135
#define QUERYSAVEDIALOGCANCEL           136

#define IDR_MENU_WB                     137
#define CONTEXTMENU                     138
#define GROBJMENU                       139

#define MAINACCELTABLE                  140
#define TEXTEDITACCELTABLE              141
#define PAGESGROUPACCELTABLE            142

#define REMOTEPOINTERANDMASK            143
#define REMOTEPOINTERXORDATA            144
#define LOCKCURSOR                      145
#define TEXTCURSOR                      146
#define PENCURSOR                       147
#define PENFREEHANDCURSOR               148
#define HIGHLIGHTFREEHANDCURSOR         149
#define GRABCURSOR                      150
#define DRAGPAGECURSOR                  151
#define DELETECURSOR                    152

#define IM_INITIALIZING                 161
#define IDS_OBJECTSARELOCKED            716
#define IDS_CANTCLOSE                   875
#define IDS_CANTGETBMP                  876
#define IDS_LOCKEDTITLE                 884
#define IDS_MSG_USERSMIGHTLOSE          885

#define IDR_MENU_WB_WITHFILE            900


#define IDC_SWWARN_NOTAGAIN             1001
#define IDC_SAWARN_NOTAGAIN             1002
#define IDC_TOOLBAR                     1003
#define IDS_FONTOPTIONS                 1004


#define IDS_T126_EXT        		1234

//
// Page sorter dialog
//
#define IDC_PS_GOTO                     300
#define IDC_PS_DELETE                   301
#define IDC_PS_INSERT_AFTER             303
#define IDC_PS_THUMBNAILS               304

#define IDB_LGCHAT_TB_DISABLED_ICON     3000
#define IDB_LGCHAT_TB_ICON              3001
#define IDB_LGCHAT_TB_HOT_ICON          3002
#define IDB_LGCHATACTIVE_TB_ICON        3003
#define IDB_LGCHATACTIVE_TB_HOT_ICON    3004
#define IDB_LGCHATACTIVE_TB_DISABLED_ICON 3005

#define IDS_WB_STATUS_WB_NOT_ACTIVE   2000
#define IDS_WB_STATUS_WB_ACTIVE         2001
#define IDS_WB_NOT_IN_CALL_WINDOW_CAPTION 2002
#define IDS_WB_IN_CALL_WINDOW_CAPTION   2003

#define IDC_ABOUTVERSION                1041
#define IDC_INITIALIZING_ANIMATION      1042

#define IDM_EDITCOLOR                   40024
#define IDM_SELECTALL                   40025








//
// Accelerators
//
#define IDVK_HELP                       50

#define IDD_PRINT_PAGE                  101
#define IDD_DEVICE_NAME                 102

#define IDM_ABOUT                       0x3000
#define IDM_HELP                        0x3001



//
// Tools menu ids
//
#define IDM_TOOLS_START                 0x3100
#define IDM_SELECT                      IDM_TOOLS_START
#define IDM_ERASER                      0x3101
#define IDM_TEXT                        0x3102
#define IDM_HIGHLIGHT                   0x3103
#define IDM_PEN                         0x3104
#define IDM_LINE                        0x3105
#define IDM_BOX                         0x3106
#define IDM_FILLED_BOX                  0x3107
#define IDM_ELLIPSE                     0x3108
#define IDM_FILLED_ELLIPSE              0x3109
#define IDM_TOOLS_MAX                   0x310A

#define IDM_COLOR                       0x3300

#define IDM_WIDTH                      0x3400
#define IDM_WIDTH_1                    0x3401
#define IDM_WIDTHS_START               IDM_WIDTH_1
#define IDM_WIDTH_2                    0x3402
#define IDM_WIDTH_3                    0x3403
#define IDM_WIDTH_4                    0x3404
#define IDM_WIDTHS_END                 0x3405

#define IDM_PAGE_FIRST                  0x3500
#define IDM_PAGE_PREV                   0x3501
#define IDM_PAGE_ANY                    0x3502
#define IDM_PAGE_NEXT                   0x3503
#define IDM_PAGE_LAST                   0x3504
#define IDM_PAGE_GOTO                   0x3505

#define IDM_EXIT                       0x3600
#define IDM_CLEAR_PAGE                 0x3601
#define IDM_FONT                       0x3602
#define IDM_SAVE                       0x3604
#define IDM_SAVE_AS                    0x3605
#define IDM_TOOL_BAR_TOGGLE            0x3606
#define IDM_STATUS_BAR_TOGGLE          0x3608
#define IDM_OPEN                       0x360b
#define IDM_CUT                        0x360c
#define IDM_COPY                       0x360d
#define IDM_PASTE                      0x360e
#define IDM_NEW                        0x360f
#define IDM_GRAB_AREA                  0x3610
#define IDM_GRAB_WINDOW                0x3611
#define IDM_PRINT                      0x3613
#define IDM_BRING_TO_TOP               0x3614
#define IDM_SEND_TO_BACK               0x3615
#define IDM_DELETE                     0x3617
#define IDM_UNDELETE                   0x3618
#define IDM_PAGE_INSERT_AFTER          0x361c
#define IDM_DELETE_PAGE                0x361d
#define IDM_REMOTE                     0x361e
#define IDM_SYNC                       0x361f
#define IDM_LOCK                       0x3620
#define IDM_WIDTHS                     0x3622
#define IDM_PAGES                      0x3623
#define IDM_GOTO_USER_POSITION         0x3624
#define IDM_GOTO_USER_POINTER          0x3625
#define IDM_ZOOM                       0x3626

//
// Scroll accelerators
//
#define IDM_PAGEUP                     0x3700
#define IDM_PAGEDOWN                   0x3701
#define IDM_SHIFTPAGEUP                0x3702
#define IDM_SHIFTPAGEDOWN              0x3703
#define IDM_LINEUP                     0x3704
#define IDM_HOME                       0x3705
#define IDM_END                        0x3706
#define IDM_LINEDOWN                   0x3707
#define IDM_SHIFTLINEUP                0x3708
#define IDM_SHIFTLINEDOWN              0x3709
#define IDM_SCROLL_END                 0x370a
#define IDM_NEXT_SHEET                 0x370b
#define IDM_PREV_SHEET                 0x370c

//
// Text Edit accelerators
//
#define IDM_DELETECHAR                 0x3800

//
// String table entry IDs
//
#define MAKE_STRING_ID(N)              (700 + N)

#define IDS_DEFAULT                    MAKE_STRING_ID(  1)

#define IDS_MENU_SYSTEM                MAKE_STRING_ID(  2)
#define IDS_MENU_FILE                  MAKE_STRING_ID(  3)
#define IDS_MENU_EDIT                  MAKE_STRING_ID(  4)
#define IDS_MENU_VIEW                  MAKE_STRING_ID(  5)
#define IDS_MENU_TOOLS                 MAKE_STRING_ID(  6)
#define IDS_MENU_HELP                  MAKE_STRING_ID(  7)
#define IDS_MENU_WIDTH                 MAKE_STRING_ID(  8)

#define IDS_CLEAR_CAPTION              MAKE_STRING_ID( 13)
#define IDS_CLEAR_MESSAGE              MAKE_STRING_ID( 14)
#define IDS_ERROR_CAPTION              MAKE_STRING_ID( 15)
#define IDS_WINDOW_CLOSED              MAKE_STRING_ID( 16)
#define IDS_PRINT_NAME                 MAKE_STRING_ID( 17)

#define IDS_UNTITLED                   MAKE_STRING_ID( 21)
#define IDS_IN_CALL                    MAKE_STRING_ID( 22)
#define IDS_NOT_IN_CALL                MAKE_STRING_ID( 23)
#define IDS_TITLE_SEPARATOR            MAKE_STRING_ID( 24)
#define IDS_PASTE                      MAKE_STRING_ID( 29)
#define IDS_PASTE_ERROR                MAKE_STRING_ID( 30)
#define IDS_SAVE                       MAKE_STRING_ID( 31)
#define IDS_SAVE_ERROR                 MAKE_STRING_ID( 32)
#define IDS_LOCK                       MAKE_STRING_ID( 33)
#define IDS_LOCK_ERROR                 MAKE_STRING_ID( 34)
#define IDS_DELETE_PAGE                MAKE_STRING_ID( 35)
#define IDS_DELETE_PAGE_MESSAGE        MAKE_STRING_ID( 36)

#define IDS_FONT_SAMPLE                MAKE_STRING_ID( 42)
#define IDS_COPY                       MAKE_STRING_ID( 48)
#define IDS_COPY_ERROR                 MAKE_STRING_ID( 49)
#define IDS_SAVE_READ_ONLY             MAKE_STRING_ID( 50)
#define IDS_JOINING                    MAKE_STRING_ID( 51)
#define IDS_INITIALIZING               MAKE_STRING_ID( 52)

//
// File extension filters
//
#define IDS_FILTER_ALL              MAKE_STRING_ID(100)
#define IDS_FILTER_ALL_SPEC         MAKE_STRING_ID(101)
#define IDS_FILTER_WHT              MAKE_STRING_ID(102)
#define IDS_FILTER_WHT_SPEC         MAKE_STRING_ID(103)
#define IDS_EXT_WHT                 MAKE_STRING_ID(104)
#define IDS_WHT_SAVE_FILTER_STRING  MAKE_STRING_ID(105)


//
// Error and information messages
//
#define IDS_MSG_TOO_MANY_PAGES         MAKE_STRING_ID(150)
#define IDS_MSG_CAPTION                MAKE_STRING_ID(151)
#define IDS_MSG_DEFAULT                MAKE_STRING_ID(152)
#define IDS_MSG_JOIN_CALL_FAILED       MAKE_STRING_ID(154)
#define IDS_MSG_WINDOWS_RESOURCES      MAKE_STRING_ID(158)
#define IDS_MSG_LOCKED                 MAKE_STRING_ID(159)
#define IDS_MSG_GRAPHIC_LOCKED         MAKE_STRING_ID(160)
#define IDS_MSG_NOT_LOCKED             MAKE_STRING_ID(161)
#define IDS_MSG_BAD_STATE_TO_LOAD_FILE MAKE_STRING_ID(162)
#define IDS_MSG_BAD_FILE_FORMAT        MAKE_STRING_ID(163)
#define IDS_MSG_BUSY                   MAKE_STRING_ID(165)
#define IDS_MSG_CM_ERROR               MAKE_STRING_ID(166)
#define IDS_MSG_AL_ERROR               MAKE_STRING_ID(167)
#define IDS_MSG_PRINTER_ERROR          MAKE_STRING_ID(169)
#define IDS_MSG_LOAD_FAIL_NO_FP        MAKE_STRING_ID(171)
#define IDS_MSG_LOAD_FAIL_NO_EXE       MAKE_STRING_ID(172)
#define IDS_MSG_LOAD_FAIL_BAD_EXE      MAKE_STRING_ID(173)
#define IDS_MSG_LOAD_FAIL_LOW_MEM      MAKE_STRING_ID(174)

//
// String IDs for hint windows associated with buttons
//

// TOOLBAR
#define IDS_HINT_SELECT                 MAKE_STRING_ID(200)
#define IDS_HINT_ERASER                 MAKE_STRING_ID(201)
#define IDS_HINT_TEXT                   MAKE_STRING_ID(202)
#define IDS_HINT_HIGHLIGHT              MAKE_STRING_ID(203)
#define IDS_HINT_PEN                    MAKE_STRING_ID(204)
#define IDS_HINT_LINE                   MAKE_STRING_ID(205)
#define IDS_HINT_BOX                    MAKE_STRING_ID(206)
#define IDS_HINT_FBOX                   MAKE_STRING_ID(207)
#define IDS_HINT_ELLIPSE                MAKE_STRING_ID(208)
#define IDS_HINT_FELLIPSE               MAKE_STRING_ID(209)
#define IDS_HINT_ZOOM_UP                MAKE_STRING_ID(210)
#define IDS_HINT_ZOOM_DOWN              MAKE_STRING_ID(211)
#define IDS_HINT_REMOTE_UP              MAKE_STRING_ID(212)
#define IDS_HINT_REMOTE_DOWN            MAKE_STRING_ID(213)
#define IDS_HINT_LOCK_UP                MAKE_STRING_ID(214)
#define IDS_HINT_LOCK_DOWN              MAKE_STRING_ID(215)
#define IDS_HINT_SYNC_UP                MAKE_STRING_ID(216)
#define IDS_HINT_SYNC_DOWN              MAKE_STRING_ID(217)
#define IDS_HINT_GRAB_AREA              MAKE_STRING_ID(218)
#define IDS_HINT_GRAB_WINDOW            MAKE_STRING_ID(219)

// WIDTHBAR
#define IDS_HINT_WIDTH_1                MAKE_STRING_ID(230)
#define IDS_HINT_WIDTH_2                MAKE_STRING_ID(231)
#define IDS_HINT_WIDTH_3                MAKE_STRING_ID(232)
#define IDS_HINT_WIDTH_4                MAKE_STRING_ID(233)

// PAGEBAR
#define IDS_HINT_PAGE_FIRST             MAKE_STRING_ID(240)
#define IDS_HINT_PAGE_PREVIOUS          MAKE_STRING_ID(241)
#define IDS_HINT_PAGE_ANY               MAKE_STRING_ID(242)
#define IDS_HINT_PAGE_NEXT              MAKE_STRING_ID(243)
#define IDS_HINT_PAGE_LAST              MAKE_STRING_ID(244)
#define IDS_HINT_PAGE_INSERT            MAKE_STRING_ID(245)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\psdlg.hpp ===
//
// PSDLG.HPP
// Page Sorter Dialog
//
// Copyright Microsoft 1998-
//

#ifndef __PSDLG_HPP_
#define __PSDLG_HPP_



#define INSERT_BEFORE 1
#define INSERT_AFTER  2

#define WM_LBTRACKPOINT     0x0131

#define RENDERED_WIDTH      (DRAW_WIDTH / 16)
#define RENDERED_HEIGHT     (DRAW_HEIGHT / 16)

//
// Data we store in the GWL_USERDATA of the dialog.  Some is passed in
// by the DialogBox caller.  Some is used just by the dialog.  Some is
// returned back to the DialogBox caller.
//
typedef struct tagPAGESORT
{
    UINT        hCurPage;
    BOOL        fPageOpsAllowed;
    BOOL        fChanged;
    BOOL        fDragging;
    HWND        hwnd;
    int         iCurPageNo;
    int         iPageDragging;
    HCURSOR     hCursorCurrent;
    HCURSOR     hCursorDrag;
    HCURSOR     hCursorNoDrop;
    HCURSOR     hCursorNormal;
}
PAGESORT;


//
// Messages the caller can send to the page sort dialog
//
enum
{
    WM_PS_GETCURRENTPAGE    = WM_APP,
    WM_PS_HASCHANGED,
    WM_PS_ENABLEPAGEOPS,    // wParam == TRUE or FALSE
    WM_PS_LOCKCHANGE,
    WM_PS_PAGECLEARIND,     // wParam == hPage
    WM_PS_PAGEDELIND,       // wParam == hPage
    WM_PS_PAGEORDERUPD
};

//
// The page sorter dialog uses a horizontal listbox to display the
// thumbnail views of pages.  Each item holds a bitmap of data for the
// page.  We render this bitmap the first time the item is painted.  The
// listbox takes care of scrolling and keyboard navigation for us.
//

BOOL CALLBACK PageSortDlgProc(HWND, UINT, WPARAM, LPARAM);

void    OnInitDialog(HWND hwndPS, PAGESORT * pps);
void    OnMeasureItem(HWND hwndPS, UINT id, LPMEASUREITEMSTRUCT lpmi);
void    OnDeleteItem(HWND hwndPS, UINT id, LPDELETEITEMSTRUCT lpdi);
void    OnDrawItem(HWND hwndPS, UINT id, LPDRAWITEMSTRUCT lpdi);
void    OnCommand(PAGESORT * pps, UINT id, UINT code, HWND hwndCtl);
BOOL    OnSetCursor(PAGESORT * pps, HWND hwnd, UINT ht, UINT msg);
void    OnDelete(PAGESORT * pps);
void    InsertPage(PAGESORT * pps, UINT uiBeforeAfter);

void    OnPageClearInd(PAGESORT * pps, WB_PAGE_HANDLE hPage);
void    OnPageDeleteInd(PAGESORT * pps, WB_PAGE_HANDLE hPage);
void    OnPageOrderUpdated(PAGESORT * pps);

void    OnStartDragDrop(PAGESORT * pps, UINT iItem, int x, int y);
void    WhileDragging(PAGESORT * pps, int x, int y);
void    OnEndDragDrop(PAGESORT * pps, BOOL fComplete, int x, int y);

void    EnableButtons(PAGESORT * pps);
void    MovePage(PAGESORT * pps, int iOldPageNo, int iNewPageNo);


#endif // __PSDLG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\t126.c ===
/* Copyright (C) Microsoft Corporation, 1998-1999. All rights reserved. */
/* ASN.1 definitions for Whiteboard */

#include <windows.h>
#include "t126.h"

ASN1module_t T126_Module = NULL;

static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(ASN1encoding_t enc, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes *val);
static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(ASN1encoding_t enc, BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut *val);
static int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor_objectList_Seq(ASN1encoding_t enc, EditablePlaneCopyDescriptor_objectList_Seq *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq(ASN1encoding_t enc, WorkspaceCreatePDU_planeParameters_Seq *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_Set(ASN1encoding_t enc, WorkspaceCreatePDU_viewParameters_Set *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_Set(ASN1encoding_t enc, WorkspaceEditPDU_planeEdits_Set *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_protectedPlaneAccessList(ASN1encoding_t enc, PWorkspaceCreatePDU_protectedPlaneAccessList *val);
static int ASN1CALL ASN1Enc_BitmapCreatePDU_checkpoints(ASN1encoding_t enc, PBitmapCreatePDU_checkpoints *val);
static int ASN1CALL ASN1Enc_BitmapCheckpointPDU_passedCheckpoints(ASN1encoding_t enc, PBitmapCheckpointPDU_passedCheckpoints *val);
static int ASN1CALL ASN1Enc_WorkspaceIdentifier_archiveWorkspace(ASN1encoding_t enc, WorkspaceIdentifier_archiveWorkspace *val);
static int ASN1CALL ASN1Enc_PixelAspectRatio_general(ASN1encoding_t enc, PixelAspectRatio_general *val);
static int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor_objectList(ASN1encoding_t enc, PEditablePlaneCopyDescriptor_objectList *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters(ASN1encoding_t enc, ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab_generalCIELabParameters(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab_generalCIELabParameters *val);
static int ASN1CALL ASN1Enc_BitmapRegion_lowerRight(ASN1encoding_t enc, BitmapRegion_lowerRight *val);
static int ASN1CALL ASN1Enc_BitmapRegion_upperLeft(ASN1encoding_t enc, BitmapRegion_upperLeft *val);
static int ASN1CALL ASN1Enc_BitmapData_dataCheckpoint(ASN1encoding_t enc, PBitmapData_dataCheckpoint *val);
#define ASN1Enc_ArchiveHeader(x,y)      0
#define ASN1Enc_ArchiveMode(x,y)      0
static int ASN1CALL ASN1Enc_BitmapData(ASN1encoding_t enc, BitmapData *val);
static int ASN1CALL ASN1Enc_BitmapHeaderT4(ASN1encoding_t enc, BitmapHeaderT4 *val);
static int ASN1CALL ASN1Enc_BitmapHeaderT6(ASN1encoding_t enc, BitmapHeaderT6 *val);
static int ASN1CALL ASN1Enc_BitmapRegion(ASN1encoding_t enc, BitmapRegion *val);
static int ASN1CALL ASN1Enc_BitmapSize(ASN1encoding_t enc, BitmapSize *val);
static int ASN1CALL ASN1Enc_ColorCIELab(ASN1encoding_t enc, ColorCIELab *val);
static int ASN1CALL ASN1Enc_ColorCIExyChromaticity(ASN1encoding_t enc, ColorCIExyChromaticity *val);
static int ASN1CALL ASN1Enc_ColorIndexTable(ASN1encoding_t enc, PColorIndexTable *val);
static int ASN1CALL ASN1Enc_ColorRGB(ASN1encoding_t enc, ColorRGB *val);
static int ASN1CALL ASN1Enc_ColorYCbCr(ASN1encoding_t enc, ColorYCbCr *val);
static int ASN1CALL ASN1Enc_DSMCCTap(ASN1encoding_t enc, DSMCCTap *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val);
static int ASN1CALL ASN1Enc_PenNib(ASN1encoding_t enc, PenNib *val);
static int ASN1CALL ASN1Enc_PixelAspectRatio(ASN1encoding_t enc, PixelAspectRatio *val);
static int ASN1CALL ASN1Enc_PlaneProtection(ASN1encoding_t enc, PlaneProtection *val);
static int ASN1CALL ASN1Enc_PlaneUsage(ASN1encoding_t enc, PlaneUsage *val);
static int ASN1CALL ASN1Enc_PointList(ASN1encoding_t enc, PointList *val);
static int ASN1CALL ASN1Enc_PointDiff4(ASN1encoding_t enc, PointDiff4 *val);
static int ASN1CALL ASN1Enc_PointDiff8(ASN1encoding_t enc, PointDiff8 *val);
static int ASN1CALL ASN1Enc_PointDiff16(ASN1encoding_t enc, PointDiff16 *val);
static int ASN1CALL ASN1Enc_RemoteEventDestinationAddress(ASN1encoding_t enc, RemoteEventDestinationAddress *val);
static int ASN1CALL ASN1Enc_RemoteEventPermission(ASN1encoding_t enc, RemoteEventPermission *val);
static int ASN1CALL ASN1Enc_RotationSpecifier(ASN1encoding_t enc, RotationSpecifier *val);
static int ASN1CALL ASN1Enc_SoftCopyDataPlaneAddress(ASN1encoding_t enc, SoftCopyDataPlaneAddress *val);
static int ASN1CALL ASN1Enc_SoftCopyPointerPlaneAddress(ASN1encoding_t enc, SoftCopyPointerPlaneAddress *val);
static int ASN1CALL ASN1Enc_SourceDisplayIndicator(ASN1encoding_t enc, SourceDisplayIndicator *val);
#define ASN1Enc_VideoWindowDestinationAddress(x,y)      0
#define ASN1Enc_VideoSourceIdentifier(x,y)      0
#define ASN1Enc_VideoWindowDeletePDU(x,y)      0
static int ASN1CALL ASN1Enc_ViewState(ASN1encoding_t enc, ViewState *val);
static int ASN1CALL ASN1Enc_WorkspaceColor(ASN1encoding_t enc, WorkspaceColor *val);
static int ASN1CALL ASN1Enc_WorkspaceDeleteReason(ASN1encoding_t enc, WorkspaceDeleteReason *val);
static int ASN1CALL ASN1Enc_WorkspaceIdentifier(ASN1encoding_t enc, WorkspaceIdentifier *val);
static int ASN1CALL ASN1Enc_WorkspacePoint(ASN1encoding_t enc, WorkspacePoint *val);
static int ASN1CALL ASN1Enc_WorkspaceRegion(ASN1encoding_t enc, WorkspaceRegion *val);
static int ASN1CALL ASN1Enc_WorkspaceSize(ASN1encoding_t enc, WorkspaceSize *val);
static int ASN1CALL ASN1Enc_WorkspaceViewState(ASN1encoding_t enc, WorkspaceViewState *val);
#define ASN1Enc_ArchiveClosePDU(x,y)      0
#define ASN1Enc_ArchiveOpenPDU(x,y)      0
static int ASN1CALL ASN1Enc_BitmapCheckpointPDU(ASN1encoding_t enc, BitmapCheckpointPDU *val);
static int ASN1CALL ASN1Enc_BitmapCreateContinuePDU(ASN1encoding_t enc, BitmapCreateContinuePDU *val);
static int ASN1CALL ASN1Enc_BitmapDeletePDU(ASN1encoding_t enc, BitmapDeletePDU *val);
static int ASN1CALL ASN1Enc_BitmapEditPDU(ASN1encoding_t enc, BitmapEditPDU *val);
static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU(ASN1encoding_t enc, ConductorPrivilegeGrantPDU *val);
static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU(ASN1encoding_t enc, ConductorPrivilegeRequestPDU *val);
static int ASN1CALL ASN1Enc_DrawingDeletePDU(ASN1encoding_t enc, DrawingDeletePDU *val);
static int ASN1CALL ASN1Enc_FontPDU(ASN1encoding_t enc, FontPDU *val);
static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU(ASN1encoding_t enc, RemoteEventPermissionGrantPDU *val);
static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU(ASN1encoding_t enc, RemoteEventPermissionRequestPDU *val);
static int ASN1CALL ASN1Enc_RemotePrintPDU(ASN1encoding_t enc, RemotePrintPDU *val);
static int ASN1CALL ASN1Enc_SINonStandardPDU(ASN1encoding_t enc, SINonStandardPDU *val);
#define ASN1Enc_TextCreatePDU(x,y)      0
#define ASN1Enc_TextDeletePDU(x,y)      0
#define ASN1Enc_TextEditPDU(x,y)      0
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU(ASN1encoding_t enc, WorkspaceCreatePDU *val);
static int ASN1CALL ASN1Enc_WorkspaceCreateAcknowledgePDU(ASN1encoding_t enc, WorkspaceCreateAcknowledgePDU *val);
static int ASN1CALL ASN1Enc_WorkspaceDeletePDU(ASN1encoding_t enc, WorkspaceDeletePDU *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU(ASN1encoding_t enc, WorkspaceEditPDU *val);
static int ASN1CALL ASN1Enc_WorkspaceReadyPDU(ASN1encoding_t enc, WorkspaceReadyPDU *val);
static int ASN1CALL ASN1Enc_WorkspaceRefreshStatusPDU(ASN1encoding_t enc, WorkspaceRefreshStatusPDU *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action(ASN1encoding_t enc, WorkspaceEditPDU_viewEdits_Set_action *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_usage(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_usage *val);
static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB_palette(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteRGB_palette *val);
static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab_palette(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteCIELab_palette *val);
static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr_palette(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteYCbCr_palette *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB_generalRGBParameters_primaries(ASN1encoding_t enc, ColorAccuracyEnhancementRGB_generalRGBParameters_primaries *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set(ASN1encoding_t enc, WorkspaceEditPDU_viewEdits_Set *val);
static int ASN1CALL ASN1Enc_WorkspaceRefreshStatusPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceRefreshStatusPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceReadyPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceReadyPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspacePlaneCopyPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits *val);
static int ASN1CALL ASN1Enc_WorkspaceDeletePDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceCreateAcknowledgePDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceCreateAcknowledgePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_TextEditPDU_nonStandardParameters(ASN1encoding_t enc, PTextEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_TextDeletePDU_nonStandardParameters(ASN1encoding_t enc, PTextDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_TextCreatePDU_nonStandardParameters(ASN1encoding_t enc, PTextCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_RemotePrintPDU_nonStandardParameters(ASN1encoding_t enc, PRemotePrintPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_RemotePointingDeviceEventPDU_nonStandardParameters(ASN1encoding_t enc, PRemotePointingDeviceEventPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_nonStandardParameters(ASN1encoding_t enc, PRemoteKeyboardEventPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_nonStandardParameters(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_remoteEventPermissionList(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_remoteEventPermissionList *val);
static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_nonStandardParameters(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_remoteEventPermissionList(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_remoteEventPermissionList *val);
static int ASN1CALL ASN1Enc_FontPDU_nonStandardParameters(ASN1encoding_t enc, PFontPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_DrawingEditPDU_nonStandardParameters(ASN1encoding_t enc, PDrawingEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_DrawingDeletePDU_nonStandardParameters(ASN1encoding_t enc, PDrawingDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_DrawingCreatePDU_nonStandardParameters(ASN1encoding_t enc, PDrawingCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_nonStandardParameters(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_nonStandardParameters(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_BitmapEditPDU_nonStandardParameters(ASN1encoding_t enc, PBitmapEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_BitmapDeletePDU_nonStandardParameters(ASN1encoding_t enc, PBitmapDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_BitmapCreateContinuePDU_nonStandardParameters(ASN1encoding_t enc, PBitmapCreateContinuePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_BitmapCreatePDU_nonStandardParameters(ASN1encoding_t enc, PBitmapCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_BitmapCheckpointPDU_nonStandardParameters(ASN1encoding_t enc, PBitmapCheckpointPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_BitmapAbortPDU_nonStandardParameters(ASN1encoding_t enc, PBitmapAbortPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ArchiveOpenPDU_nonStandardParameters(ASN1encoding_t enc, PArchiveOpenPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ArchiveErrorPDU_nonStandardParameters(ASN1encoding_t enc, PArchiveErrorPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ArchiveClosePDU_nonStandardParameters(ASN1encoding_t enc, PArchiveClosePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ArchiveAcknowledgePDU_nonStandardParameters(ASN1encoding_t enc, PArchiveAcknowledgePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_WorkspaceViewAttribute_viewRegion(ASN1encoding_t enc, WorkspaceViewAttribute_viewRegion *val);
static int ASN1CALL ASN1Enc_VideoWindowEditPDU_nonStandardParameters(ASN1encoding_t enc, PVideoWindowEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_VideoWindowDeletePDU_nonStandardParameters(ASN1encoding_t enc, PVideoWindowDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_VideoWindowCreatePDU_nonStandardParameters(ASN1encoding_t enc, PVideoWindowCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_VideoSourceIdentifier_dSMCCConnBinder(ASN1encoding_t enc, PVideoSourceIdentifier_dSMCCConnBinder *val);
static int ASN1CALL ASN1Enc_TransparencyMask_nonStandardParameters(ASN1encoding_t enc, PTransparencyMask_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_TransparencyMask_bitMask(ASN1encoding_t enc, TransparencyMask_bitMask *val);
static int ASN1CALL ASN1Enc_PointListEdits_Seq(ASN1encoding_t enc, PointListEdits_Seq *val);
static int ASN1CALL ASN1Enc_PointList_pointsDiff16(ASN1encoding_t enc, PPointList_pointsDiff16 *val);
static int ASN1CALL ASN1Enc_PointList_pointsDiff8(ASN1encoding_t enc, PPointList_pointsDiff8 *val);
static int ASN1CALL ASN1Enc_PointList_pointsDiff4(ASN1encoding_t enc, PPointList_pointsDiff4 *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB_generalRGBParameters(ASN1encoding_t enc, ColorAccuracyEnhancementRGB_generalRGBParameters *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB_predefinedRGBSpace(ASN1encoding_t enc, ColorAccuracyEnhancementRGB_predefinedRGBSpace *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(ASN1encoding_t enc, ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab_predefinedCIELabSpace *val);
#define ASN1Enc_ArchiveError(x,y)      0
#define ASN1Enc_ArchiveOpenResult(x,y)      0
static int ASN1CALL ASN1Enc_BitmapAbortReason(ASN1encoding_t enc, BitmapAbortReason *val);
static int ASN1CALL ASN1Enc_BitmapDestinationAddress(ASN1encoding_t enc, BitmapDestinationAddress *val);
static int ASN1CALL ASN1Enc_ButtonEvent(ASN1encoding_t enc, ButtonEvent *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementGreyscale(ASN1encoding_t enc, ColorAccuracyEnhancementGreyscale *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB(ASN1encoding_t enc, ColorAccuracyEnhancementRGB *val);
static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr *val);
static int ASN1CALL ASN1Enc_ColorResolutionModeSpecifier(ASN1encoding_t enc, ColorResolutionModeSpecifier *val);
static int ASN1CALL ASN1Enc_ConductorPrivilege(ASN1encoding_t enc, ConductorPrivilege *val);
static int ASN1CALL ASN1Enc_DrawingDestinationAddress(ASN1encoding_t enc, DrawingDestinationAddress *val);
static int ASN1CALL ASN1Enc_DrawingType(ASN1encoding_t enc, DrawingType *val);
static int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor(ASN1encoding_t enc, EditablePlaneCopyDescriptor *val);
#define ASN1Enc_KeyCode(x,y)      0
static int ASN1CALL ASN1Enc_KeyModifier(ASN1encoding_t enc, KeyModifier *val);
#define ASN1Enc_KeyPressState(x,y)      0
static int ASN1CALL ASN1Enc_LineStyle(ASN1encoding_t enc, LineStyle *val);
static int ASN1CALL ASN1Enc_PermanentPlaneCopyDescriptor(ASN1encoding_t enc, PermanentPlaneCopyDescriptor *val);
static int ASN1CALL ASN1Enc_PlaneAttribute(ASN1encoding_t enc, PlaneAttribute *val);
static int ASN1CALL ASN1Enc_PointListEdits(ASN1encoding_t enc, PointListEdits *val);
static int ASN1CALL ASN1Enc_TransparencyMask(ASN1encoding_t enc, TransparencyMask *val);
#define ASN1Enc_VideoWindowAttribute(x,y)      0
#define ASN1Enc_VideoWindowCreatePDU(x,y)      0
#define ASN1Enc_VideoWindowEditPDU(x,y)      0
static int ASN1CALL ASN1Enc_WorkspaceAttribute(ASN1encoding_t enc, WorkspaceAttribute *val);
static int ASN1CALL ASN1Enc_WorkspaceViewAttribute(ASN1encoding_t enc, WorkspaceViewAttribute *val);
#define ASN1Enc_ArchiveAcknowledgePDU(x,y)      0
#define ASN1Enc_ArchiveErrorPDU(x,y)      0
static int ASN1CALL ASN1Enc_BitmapAbortPDU(ASN1encoding_t enc, BitmapAbortPDU *val);
static int ASN1CALL ASN1Enc_DrawingCreatePDU(ASN1encoding_t enc, DrawingCreatePDU *val);
static int ASN1CALL ASN1Enc_DrawingEditPDU(ASN1encoding_t enc, DrawingEditPDU *val);
#define ASN1Enc_RemoteKeyboardEventPDU(x,y)      0
static int ASN1CALL ASN1Enc_RemotePointingDeviceEventPDU(ASN1encoding_t enc, RemotePointingDeviceEventPDU *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_editView(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_editView *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_createNewView(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_createNewView *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_Set_planeAttributes(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits_Set_planeAttributes *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes *val);
static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr(ASN1encoding_t enc, ColorPalette_colorLookUpTable_paletteYCbCr *val);
static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab(ASN1encoding_t enc, ColorPalette_colorLookUpTable_paletteCIELab *val);
static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB(ASN1encoding_t enc, ColorPalette_colorLookUpTable_paletteRGB *val);
static int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU_copyDescriptor(ASN1encoding_t enc, WorkspacePlaneCopyPDU_copyDescriptor *val);
static int ASN1CALL ASN1Enc_WorkspaceEditPDU_attributeEdits(ASN1encoding_t enc, PWorkspaceEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_workspaceAttributes(ASN1encoding_t enc, PWorkspaceCreatePDU_workspaceAttributes *val);
static int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_keyModifierStates(ASN1encoding_t enc, PRemoteKeyboardEventPDU_keyModifierStates *val);
static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_privilegeList(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_privilegeList *val);
static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_privilegeList(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_privilegeList *val);
static int ASN1CALL ASN1Enc_VideoWindowEditPDU_attributeEdits(ASN1encoding_t enc, PVideoWindowEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Enc_VideoWindowCreatePDU_attributes(ASN1encoding_t enc, PVideoWindowCreatePDU_attributes *val);
static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_cieLab(ASN1encoding_t enc, ColorSpaceSpecifier_cieLab *val);
static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_rgb(ASN1encoding_t enc, ColorSpaceSpecifier_rgb *val);
static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_yCbCr(ASN1encoding_t enc, ColorSpaceSpecifier_yCbCr *val);
static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_greyscale(ASN1encoding_t enc, ColorSpaceSpecifier_greyscale *val);
static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable(ASN1encoding_t enc, ColorPalette_colorLookUpTable *val);
static int ASN1CALL ASN1Enc_BitmapAttribute(ASN1encoding_t enc, BitmapAttribute *val);
static int ASN1CALL ASN1Enc_ColorPalette(ASN1encoding_t enc, ColorPalette *val);
static int ASN1CALL ASN1Enc_ColorSpaceSpecifier(ASN1encoding_t enc, ColorSpaceSpecifier *val);
static int ASN1CALL ASN1Enc_DrawingAttribute(ASN1encoding_t enc, DrawingAttribute *val);
static int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU(ASN1encoding_t enc, WorkspacePlaneCopyPDU *val);
static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed_colorMappingMode_paletteMap(ASN1encoding_t enc, BitmapHeaderUncompressed_colorMappingMode_paletteMap *val);
static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed_colorMappingMode_directMap(ASN1encoding_t enc, BitmapHeaderUncompressed_colorMappingMode_directMap *val);
static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap(ASN1encoding_t enc, BitmapHeaderT82_colorMappingMode_paletteMap *val);
static int ASN1CALL ASN1Enc_DrawingEditPDU_attributeEdits(ASN1encoding_t enc, PDrawingEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Enc_DrawingCreatePDU_attributes(ASN1encoding_t enc, PDrawingCreatePDU_attributes *val);
static int ASN1CALL ASN1Enc_BitmapEditPDU_attributeEdits(ASN1encoding_t enc, PBitmapEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Enc_BitmapCreatePDU_attributes(ASN1encoding_t enc, PBitmapCreatePDU_attributes *val);
static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode(ASN1encoding_t enc, BitmapHeaderT82_colorMappingMode *val);
static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed_colorMappingMode(ASN1encoding_t enc, BitmapHeaderUncompressed_colorMappingMode *val);
static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed(ASN1encoding_t enc, BitmapHeaderUncompressed *val);
static int ASN1CALL ASN1Enc_BitmapHeaderT81(ASN1encoding_t enc, BitmapHeaderT81 *val);
static int ASN1CALL ASN1Enc_BitmapHeaderT82(ASN1encoding_t enc, BitmapHeaderT82 *val);
static int ASN1CALL ASN1Enc_BitmapCreatePDU_bitmapFormatHeader(ASN1encoding_t enc, BitmapCreatePDU_bitmapFormatHeader *val);
static int ASN1CALL ASN1Enc_BitmapCreatePDU(ASN1encoding_t enc, BitmapCreatePDU *val);
static int ASN1CALL ASN1Enc_SIPDU(ASN1encoding_t enc, SIPDU *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(ASN1decoding_t dec, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(ASN1decoding_t dec, BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut *val);
static int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor_objectList_Seq(ASN1decoding_t dec, EditablePlaneCopyDescriptor_objectList_Seq *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq(ASN1decoding_t dec, WorkspaceCreatePDU_planeParameters_Seq *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_Set(ASN1decoding_t dec, WorkspaceCreatePDU_viewParameters_Set *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_Set(ASN1decoding_t dec, WorkspaceEditPDU_planeEdits_Set *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_protectedPlaneAccessList(ASN1decoding_t dec, PWorkspaceCreatePDU_protectedPlaneAccessList *val);
static int ASN1CALL ASN1Dec_BitmapCreatePDU_checkpoints(ASN1decoding_t dec, PBitmapCreatePDU_checkpoints *val);
static int ASN1CALL ASN1Dec_BitmapCheckpointPDU_passedCheckpoints(ASN1decoding_t dec, PBitmapCheckpointPDU_passedCheckpoints *val);
static int ASN1CALL ASN1Dec_WorkspaceIdentifier_archiveWorkspace(ASN1decoding_t dec, WorkspaceIdentifier_archiveWorkspace *val);
static int ASN1CALL ASN1Dec_PixelAspectRatio_general(ASN1decoding_t dec, PixelAspectRatio_general *val);
static int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor_objectList(ASN1decoding_t dec, PEditablePlaneCopyDescriptor_objectList *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters(ASN1decoding_t dec, ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab_generalCIELabParameters(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab_generalCIELabParameters *val);
static int ASN1CALL ASN1Dec_BitmapRegion_lowerRight(ASN1decoding_t dec, BitmapRegion_lowerRight *val);
static int ASN1CALL ASN1Dec_BitmapRegion_upperLeft(ASN1decoding_t dec, BitmapRegion_upperLeft *val);
static int ASN1CALL ASN1Dec_BitmapData_dataCheckpoint(ASN1decoding_t dec, PBitmapData_dataCheckpoint *val);
#define ASN1Dec_ArchiveHeader(x,y)      0
#define ASN1Dec_ArchiveMode(x,y)      0
static int ASN1CALL ASN1Dec_BitmapData(ASN1decoding_t dec, BitmapData *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT4(ASN1decoding_t dec, BitmapHeaderT4 *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT6(ASN1decoding_t dec, BitmapHeaderT6 *val);
static int ASN1CALL ASN1Dec_BitmapRegion(ASN1decoding_t dec, BitmapRegion *val);
static int ASN1CALL ASN1Dec_BitmapSize(ASN1decoding_t dec, BitmapSize *val);
static int ASN1CALL ASN1Dec_ColorCIELab(ASN1decoding_t dec, ColorCIELab *val);
static int ASN1CALL ASN1Dec_ColorCIExyChromaticity(ASN1decoding_t dec, ColorCIExyChromaticity *val);
static int ASN1CALL ASN1Dec_ColorIndexTable(ASN1decoding_t dec, PColorIndexTable *val);
static int ASN1CALL ASN1Dec_ColorRGB(ASN1decoding_t dec, ColorRGB *val);
static int ASN1CALL ASN1Dec_ColorYCbCr(ASN1decoding_t dec, ColorYCbCr *val);
static int ASN1CALL ASN1Dec_DSMCCTap(ASN1decoding_t dec, DSMCCTap *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val);
static int ASN1CALL ASN1Dec_PenNib(ASN1decoding_t dec, PenNib *val);
static int ASN1CALL ASN1Dec_PixelAspectRatio(ASN1decoding_t dec, PixelAspectRatio *val);
static int ASN1CALL ASN1Dec_PlaneProtection(ASN1decoding_t dec, PlaneProtection *val);
static int ASN1CALL ASN1Dec_PlaneUsage(ASN1decoding_t dec, PlaneUsage *val);
static int ASN1CALL ASN1Dec_PointList(ASN1decoding_t dec, PointList *val);
static int ASN1CALL ASN1Dec_PointDiff4(ASN1decoding_t dec, PointDiff4 *val);
static int ASN1CALL ASN1Dec_PointDiff8(ASN1decoding_t dec, PointDiff8 *val);
static int ASN1CALL ASN1Dec_PointDiff16(ASN1decoding_t dec, PointDiff16 *val);
static int ASN1CALL ASN1Dec_RemoteEventDestinationAddress(ASN1decoding_t dec, RemoteEventDestinationAddress *val);
static int ASN1CALL ASN1Dec_RemoteEventPermission(ASN1decoding_t dec, RemoteEventPermission *val);
static int ASN1CALL ASN1Dec_RotationSpecifier(ASN1decoding_t dec, RotationSpecifier *val);
static int ASN1CALL ASN1Dec_SoftCopyDataPlaneAddress(ASN1decoding_t dec, SoftCopyDataPlaneAddress *val);
static int ASN1CALL ASN1Dec_SoftCopyPointerPlaneAddress(ASN1decoding_t dec, SoftCopyPointerPlaneAddress *val);
static int ASN1CALL ASN1Dec_SourceDisplayIndicator(ASN1decoding_t dec, SourceDisplayIndicator *val);
#define ASN1Dec_VideoWindowDestinationAddress(x,y)      0
#define ASN1Dec_VideoSourceIdentifier(x,y)      0
#define ASN1Dec_VideoWindowDeletePDU(x,y)      0
static int ASN1CALL ASN1Dec_ViewState(ASN1decoding_t dec, ViewState *val);
static int ASN1CALL ASN1Dec_WorkspaceColor(ASN1decoding_t dec, WorkspaceColor *val);
static int ASN1CALL ASN1Dec_WorkspaceDeleteReason(ASN1decoding_t dec, WorkspaceDeleteReason *val);
static int ASN1CALL ASN1Dec_WorkspaceIdentifier(ASN1decoding_t dec, WorkspaceIdentifier *val);
static int ASN1CALL ASN1Dec_WorkspacePoint(ASN1decoding_t dec, WorkspacePoint *val);
static int ASN1CALL ASN1Dec_WorkspaceRegion(ASN1decoding_t dec, WorkspaceRegion *val);
static int ASN1CALL ASN1Dec_WorkspaceSize(ASN1decoding_t dec, WorkspaceSize *val);
static int ASN1CALL ASN1Dec_WorkspaceViewState(ASN1decoding_t dec, WorkspaceViewState *val);
#define ASN1Dec_ArchiveClosePDU(x,y)      0
#define ASN1Dec_ArchiveOpenPDU(x,y)      0
static int ASN1CALL ASN1Dec_BitmapCheckpointPDU(ASN1decoding_t dec, BitmapCheckpointPDU *val);
static int ASN1CALL ASN1Dec_BitmapCreateContinuePDU(ASN1decoding_t dec, BitmapCreateContinuePDU *val);
static int ASN1CALL ASN1Dec_BitmapDeletePDU(ASN1decoding_t dec, BitmapDeletePDU *val);
static int ASN1CALL ASN1Dec_BitmapEditPDU(ASN1decoding_t dec, BitmapEditPDU *val);
static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU(ASN1decoding_t dec, ConductorPrivilegeGrantPDU *val);
static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU(ASN1decoding_t dec, ConductorPrivilegeRequestPDU *val);
static int ASN1CALL ASN1Dec_DrawingDeletePDU(ASN1decoding_t dec, DrawingDeletePDU *val);
static int ASN1CALL ASN1Dec_FontPDU(ASN1decoding_t dec, FontPDU *val);
static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU(ASN1decoding_t dec, RemoteEventPermissionGrantPDU *val);
static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU(ASN1decoding_t dec, RemoteEventPermissionRequestPDU *val);
static int ASN1CALL ASN1Dec_RemotePrintPDU(ASN1decoding_t dec, RemotePrintPDU *val);
static int ASN1CALL ASN1Dec_SINonStandardPDU(ASN1decoding_t dec, SINonStandardPDU *val);
#define ASN1Dec_TextCreatePDU(x,y)      0
#define ASN1Dec_TextDeletePDU(x,y)      0
#define ASN1Dec_TextEditPDU(x,y)      0
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU(ASN1decoding_t dec, WorkspaceCreatePDU *val);
static int ASN1CALL ASN1Dec_WorkspaceCreateAcknowledgePDU(ASN1decoding_t dec, WorkspaceCreateAcknowledgePDU *val);
static int ASN1CALL ASN1Dec_WorkspaceDeletePDU(ASN1decoding_t dec, WorkspaceDeletePDU *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU(ASN1decoding_t dec, WorkspaceEditPDU *val);
static int ASN1CALL ASN1Dec_WorkspaceReadyPDU(ASN1decoding_t dec, WorkspaceReadyPDU *val);
static int ASN1CALL ASN1Dec_WorkspaceRefreshStatusPDU(ASN1decoding_t dec, WorkspaceRefreshStatusPDU *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action(ASN1decoding_t dec, WorkspaceEditPDU_viewEdits_Set_action *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_usage(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_usage *val);
static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB_palette(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteRGB_palette *val);
static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab_palette(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteCIELab_palette *val);
static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr_palette(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteYCbCr_palette *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB_generalRGBParameters_primaries(ASN1decoding_t dec, ColorAccuracyEnhancementRGB_generalRGBParameters_primaries *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set(ASN1decoding_t dec, WorkspaceEditPDU_viewEdits_Set *val);
static int ASN1CALL ASN1Dec_WorkspaceRefreshStatusPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceRefreshStatusPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceReadyPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceReadyPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspacePlaneCopyPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits *val);
static int ASN1CALL ASN1Dec_WorkspaceDeletePDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceCreateAcknowledgePDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceCreateAcknowledgePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_TextEditPDU_nonStandardParameters(ASN1decoding_t dec, PTextEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_TextDeletePDU_nonStandardParameters(ASN1decoding_t dec, PTextDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_TextCreatePDU_nonStandardParameters(ASN1decoding_t dec, PTextCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_RemotePrintPDU_nonStandardParameters(ASN1decoding_t dec, PRemotePrintPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_RemotePointingDeviceEventPDU_nonStandardParameters(ASN1decoding_t dec, PRemotePointingDeviceEventPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_nonStandardParameters(ASN1decoding_t dec, PRemoteKeyboardEventPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_nonStandardParameters(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_remoteEventPermissionList(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_remoteEventPermissionList *val);
static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_nonStandardParameters(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_remoteEventPermissionList(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_remoteEventPermissionList *val);
static int ASN1CALL ASN1Dec_FontPDU_nonStandardParameters(ASN1decoding_t dec, PFontPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_DrawingEditPDU_nonStandardParameters(ASN1decoding_t dec, PDrawingEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_DrawingDeletePDU_nonStandardParameters(ASN1decoding_t dec, PDrawingDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_DrawingCreatePDU_nonStandardParameters(ASN1decoding_t dec, PDrawingCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_nonStandardParameters(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_nonStandardParameters(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_BitmapEditPDU_nonStandardParameters(ASN1decoding_t dec, PBitmapEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_BitmapDeletePDU_nonStandardParameters(ASN1decoding_t dec, PBitmapDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_BitmapCreateContinuePDU_nonStandardParameters(ASN1decoding_t dec, PBitmapCreateContinuePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_BitmapCreatePDU_nonStandardParameters(ASN1decoding_t dec, PBitmapCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_BitmapCheckpointPDU_nonStandardParameters(ASN1decoding_t dec, PBitmapCheckpointPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_BitmapAbortPDU_nonStandardParameters(ASN1decoding_t dec, PBitmapAbortPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ArchiveOpenPDU_nonStandardParameters(ASN1decoding_t dec, PArchiveOpenPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ArchiveErrorPDU_nonStandardParameters(ASN1decoding_t dec, PArchiveErrorPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ArchiveClosePDU_nonStandardParameters(ASN1decoding_t dec, PArchiveClosePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ArchiveAcknowledgePDU_nonStandardParameters(ASN1decoding_t dec, PArchiveAcknowledgePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_WorkspaceViewAttribute_viewRegion(ASN1decoding_t dec, WorkspaceViewAttribute_viewRegion *val);
static int ASN1CALL ASN1Dec_VideoWindowEditPDU_nonStandardParameters(ASN1decoding_t dec, PVideoWindowEditPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_VideoWindowDeletePDU_nonStandardParameters(ASN1decoding_t dec, PVideoWindowDeletePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_VideoWindowCreatePDU_nonStandardParameters(ASN1decoding_t dec, PVideoWindowCreatePDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_VideoSourceIdentifier_dSMCCConnBinder(ASN1decoding_t dec, PVideoSourceIdentifier_dSMCCConnBinder *val);
static int ASN1CALL ASN1Dec_TransparencyMask_nonStandardParameters(ASN1decoding_t dec, PTransparencyMask_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_TransparencyMask_bitMask(ASN1decoding_t dec, TransparencyMask_bitMask *val);
static int ASN1CALL ASN1Dec_PointListEdits_Seq(ASN1decoding_t dec, PointListEdits_Seq *val);
static int ASN1CALL ASN1Dec_PointList_pointsDiff16(ASN1decoding_t dec, PPointList_pointsDiff16 *val);
static int ASN1CALL ASN1Dec_PointList_pointsDiff8(ASN1decoding_t dec, PPointList_pointsDiff8 *val);
static int ASN1CALL ASN1Dec_PointList_pointsDiff4(ASN1decoding_t dec, PPointList_pointsDiff4 *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB_generalRGBParameters(ASN1decoding_t dec, ColorAccuracyEnhancementRGB_generalRGBParameters *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB_predefinedRGBSpace(ASN1decoding_t dec, ColorAccuracyEnhancementRGB_predefinedRGBSpace *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(ASN1decoding_t dec, ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab_predefinedCIELabSpace *val);
#define ASN1Dec_ArchiveError(x,y)      0
#define ASN1Dec_ArchiveOpenResult(x,y)      0
static int ASN1CALL ASN1Dec_BitmapAbortReason(ASN1decoding_t dec, BitmapAbortReason *val);
static int ASN1CALL ASN1Dec_BitmapDestinationAddress(ASN1decoding_t dec, BitmapDestinationAddress *val);
static int ASN1CALL ASN1Dec_ButtonEvent(ASN1decoding_t dec, ButtonEvent *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementGreyscale(ASN1decoding_t dec, ColorAccuracyEnhancementGreyscale *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB(ASN1decoding_t dec, ColorAccuracyEnhancementRGB *val);
static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr *val);
static int ASN1CALL ASN1Dec_ColorResolutionModeSpecifier(ASN1decoding_t dec, ColorResolutionModeSpecifier *val);
static int ASN1CALL ASN1Dec_ConductorPrivilege(ASN1decoding_t dec, ConductorPrivilege *val);
static int ASN1CALL ASN1Dec_DrawingDestinationAddress(ASN1decoding_t dec, DrawingDestinationAddress *val);
static int ASN1CALL ASN1Dec_DrawingType(ASN1decoding_t dec, DrawingType *val);
static int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor(ASN1decoding_t dec, EditablePlaneCopyDescriptor *val);
#define ASN1Dec_KeyCode(x,y)      0
static int ASN1CALL ASN1Dec_KeyModifier(ASN1decoding_t dec, KeyModifier *val);
#define ASN1Dec_KeyPressState(x,y)      0
static int ASN1CALL ASN1Dec_LineStyle(ASN1decoding_t dec, LineStyle *val);
static int ASN1CALL ASN1Dec_PermanentPlaneCopyDescriptor(ASN1decoding_t dec, PermanentPlaneCopyDescriptor *val);
static int ASN1CALL ASN1Dec_PlaneAttribute(ASN1decoding_t dec, PlaneAttribute *val);
static int ASN1CALL ASN1Dec_PointListEdits(ASN1decoding_t dec, PointListEdits *val);
static int ASN1CALL ASN1Dec_TransparencyMask(ASN1decoding_t dec, TransparencyMask *val);
#define ASN1Dec_VideoWindowAttribute(x,y)      0
#define ASN1Dec_VideoWindowCreatePDU(x,y)      0
#define ASN1Dec_VideoWindowEditPDU(x,y)      0
static int ASN1CALL ASN1Dec_WorkspaceAttribute(ASN1decoding_t dec, WorkspaceAttribute *val);
static int ASN1CALL ASN1Dec_WorkspaceViewAttribute(ASN1decoding_t dec, WorkspaceViewAttribute *val);
#define ASN1Dec_ArchiveAcknowledgePDU(x,y)      0
#define ASN1Dec_ArchiveErrorPDU(x,y)      0
static int ASN1CALL ASN1Dec_BitmapAbortPDU(ASN1decoding_t dec, BitmapAbortPDU *val);
static int ASN1CALL ASN1Dec_DrawingCreatePDU(ASN1decoding_t dec, DrawingCreatePDU *val);
static int ASN1CALL ASN1Dec_DrawingEditPDU(ASN1decoding_t dec, DrawingEditPDU *val);
#define ASN1Dec_RemoteKeyboardEventPDU(x,y)      0
static int ASN1CALL ASN1Dec_RemotePointingDeviceEventPDU(ASN1decoding_t dec, RemotePointingDeviceEventPDU *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_editView(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_editView *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_createNewView(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_createNewView *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_Set_planeAttributes(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits_Set_planeAttributes *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes *val);
static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr(ASN1decoding_t dec, ColorPalette_colorLookUpTable_paletteYCbCr *val);
static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab(ASN1decoding_t dec, ColorPalette_colorLookUpTable_paletteCIELab *val);
static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB(ASN1decoding_t dec, ColorPalette_colorLookUpTable_paletteRGB *val);
static int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU_copyDescriptor(ASN1decoding_t dec, WorkspacePlaneCopyPDU_copyDescriptor *val);
static int ASN1CALL ASN1Dec_WorkspaceEditPDU_attributeEdits(ASN1decoding_t dec, PWorkspaceEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_workspaceAttributes(ASN1decoding_t dec, PWorkspaceCreatePDU_workspaceAttributes *val);
static int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_keyModifierStates(ASN1decoding_t dec, PRemoteKeyboardEventPDU_keyModifierStates *val);
static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_privilegeList(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_privilegeList *val);
static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_privilegeList(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_privilegeList *val);
static int ASN1CALL ASN1Dec_VideoWindowEditPDU_attributeEdits(ASN1decoding_t dec, PVideoWindowEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Dec_VideoWindowCreatePDU_attributes(ASN1decoding_t dec, PVideoWindowCreatePDU_attributes *val);
static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_cieLab(ASN1decoding_t dec, ColorSpaceSpecifier_cieLab *val);
static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_rgb(ASN1decoding_t dec, ColorSpaceSpecifier_rgb *val);
static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_yCbCr(ASN1decoding_t dec, ColorSpaceSpecifier_yCbCr *val);
static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_greyscale(ASN1decoding_t dec, ColorSpaceSpecifier_greyscale *val);
static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable(ASN1decoding_t dec, ColorPalette_colorLookUpTable *val);
static int ASN1CALL ASN1Dec_BitmapAttribute(ASN1decoding_t dec, BitmapAttribute *val);
static int ASN1CALL ASN1Dec_ColorPalette(ASN1decoding_t dec, ColorPalette *val);
static int ASN1CALL ASN1Dec_ColorSpaceSpecifier(ASN1decoding_t dec, ColorSpaceSpecifier *val);
static int ASN1CALL ASN1Dec_DrawingAttribute(ASN1decoding_t dec, DrawingAttribute *val);
static int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU(ASN1decoding_t dec, WorkspacePlaneCopyPDU *val);
static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed_colorMappingMode_paletteMap(ASN1decoding_t dec, BitmapHeaderUncompressed_colorMappingMode_paletteMap *val);
static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed_colorMappingMode_directMap(ASN1decoding_t dec, BitmapHeaderUncompressed_colorMappingMode_directMap *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap(ASN1decoding_t dec, BitmapHeaderT82_colorMappingMode_paletteMap *val);
static int ASN1CALL ASN1Dec_DrawingEditPDU_attributeEdits(ASN1decoding_t dec, PDrawingEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Dec_DrawingCreatePDU_attributes(ASN1decoding_t dec, PDrawingCreatePDU_attributes *val);
static int ASN1CALL ASN1Dec_BitmapEditPDU_attributeEdits(ASN1decoding_t dec, PBitmapEditPDU_attributeEdits *val);
static int ASN1CALL ASN1Dec_BitmapCreatePDU_attributes(ASN1decoding_t dec, PBitmapCreatePDU_attributes *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode(ASN1decoding_t dec, BitmapHeaderT82_colorMappingMode *val);
static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed_colorMappingMode(ASN1decoding_t dec, BitmapHeaderUncompressed_colorMappingMode *val);
static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed(ASN1decoding_t dec, BitmapHeaderUncompressed *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT81(ASN1decoding_t dec, BitmapHeaderT81 *val);
static int ASN1CALL ASN1Dec_BitmapHeaderT82(ASN1decoding_t dec, BitmapHeaderT82 *val);
static int ASN1CALL ASN1Dec_BitmapCreatePDU_bitmapFormatHeader(ASN1decoding_t dec, BitmapCreatePDU_bitmapFormatHeader *val);
static int ASN1CALL ASN1Dec_BitmapCreatePDU(ASN1decoding_t dec, BitmapCreatePDU *val);
static int ASN1CALL ASN1Dec_SIPDU(ASN1decoding_t dec, SIPDU *val);
static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes *val);
static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq(WorkspaceCreatePDU_planeParameters_Seq *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_Set(WorkspaceCreatePDU_viewParameters_Set *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_Set(WorkspaceEditPDU_planeEdits_Set *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits(PWorkspaceEditPDU_planeEdits *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters(PWorkspaceCreatePDU_viewParameters *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters(PWorkspaceCreatePDU_planeParameters *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_protectedPlaneAccessList(PWorkspaceCreatePDU_protectedPlaneAccessList *val);
static void ASN1CALL ASN1Free_BitmapCreatePDU_checkpoints(PBitmapCreatePDU_checkpoints *val);
static void ASN1CALL ASN1Free_BitmapCheckpointPDU_passedCheckpoints(PBitmapCheckpointPDU_passedCheckpoints *val);
static void ASN1CALL ASN1Free_WorkspaceIdentifier_archiveWorkspace(WorkspaceIdentifier_archiveWorkspace *val);
static void ASN1CALL ASN1Free_EditablePlaneCopyDescriptor_objectList(PEditablePlaneCopyDescriptor_objectList *val);
static void ASN1CALL ASN1Free_BitmapData_dataCheckpoint(PBitmapData_dataCheckpoint *val);
#define ASN1Free_ArchiveHeader(x)
static void ASN1CALL ASN1Free_BitmapData(BitmapData *val);
static void ASN1CALL ASN1Free_ColorIndexTable(PColorIndexTable *val);
static void ASN1CALL ASN1Free_DSMCCTap(DSMCCTap *val);
static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val);
static void ASN1CALL ASN1Free_PenNib(PenNib *val);
static void ASN1CALL ASN1Free_PixelAspectRatio(PixelAspectRatio *val);
static void ASN1CALL ASN1Free_PlaneUsage(PlaneUsage *val);
static void ASN1CALL ASN1Free_PointList(PointList *val);
static void ASN1CALL ASN1Free_RemoteEventDestinationAddress(RemoteEventDestinationAddress *val);
static void ASN1CALL ASN1Free_RemoteEventPermission(RemoteEventPermission *val);
#define ASN1Free_VideoWindowDestinationAddress(x)
#define ASN1Free_VideoSourceIdentifier(x)
#define ASN1Free_VideoWindowDeletePDU(x)
static void ASN1CALL ASN1Free_ViewState(ViewState *val);
static void ASN1CALL ASN1Free_WorkspaceDeleteReason(WorkspaceDeleteReason *val);
static void ASN1CALL ASN1Free_WorkspaceIdentifier(WorkspaceIdentifier *val);
static void ASN1CALL ASN1Free_WorkspaceViewState(WorkspaceViewState *val);
#define ASN1Free_ArchiveClosePDU(x)
#define ASN1Free_ArchiveOpenPDU(x)
static void ASN1CALL ASN1Free_BitmapCheckpointPDU(BitmapCheckpointPDU *val);
static void ASN1CALL ASN1Free_BitmapCreateContinuePDU(BitmapCreateContinuePDU *val);
static void ASN1CALL ASN1Free_BitmapDeletePDU(BitmapDeletePDU *val);
static void ASN1CALL ASN1Free_BitmapEditPDU(BitmapEditPDU *val);
static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU(ConductorPrivilegeGrantPDU *val);
static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU(ConductorPrivilegeRequestPDU *val);
static void ASN1CALL ASN1Free_DrawingDeletePDU(DrawingDeletePDU *val);
static void ASN1CALL ASN1Free_FontPDU(FontPDU *val);
static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU(RemoteEventPermissionGrantPDU *val);
static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU(RemoteEventPermissionRequestPDU *val);
static void ASN1CALL ASN1Free_RemotePrintPDU(RemotePrintPDU *val);
static void ASN1CALL ASN1Free_SINonStandardPDU(SINonStandardPDU *val);
#define ASN1Free_TextCreatePDU(x)
#define ASN1Free_TextDeletePDU(x)
#define ASN1Free_TextEditPDU(x)
static void ASN1CALL ASN1Free_WorkspaceCreatePDU(WorkspaceCreatePDU *val);
static void ASN1CALL ASN1Free_WorkspaceCreateAcknowledgePDU(WorkspaceCreateAcknowledgePDU *val);
static void ASN1CALL ASN1Free_WorkspaceDeletePDU(WorkspaceDeletePDU *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU(WorkspaceEditPDU *val);
static void ASN1CALL ASN1Free_WorkspaceReadyPDU(WorkspaceReadyPDU *val);
static void ASN1CALL ASN1Free_WorkspaceRefreshStatusPDU(WorkspaceRefreshStatusPDU *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action(WorkspaceEditPDU_viewEdits_Set_action *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_usage(PWorkspaceCreatePDU_planeParameters_Seq_usage *val);
static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteRGB_palette(PColorPalette_colorLookUpTable_paletteRGB_palette *val);
static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab_palette(PColorPalette_colorLookUpTable_paletteCIELab_palette *val);
static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr_palette(PColorPalette_colorLookUpTable_paletteYCbCr_palette *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set(WorkspaceEditPDU_viewEdits_Set *val);
static void ASN1CALL ASN1Free_WorkspaceRefreshStatusPDU_nonStandardParameters(PWorkspaceRefreshStatusPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_WorkspaceReadyPDU_nonStandardParameters(PWorkspaceReadyPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU_nonStandardParameters(PWorkspacePlaneCopyPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_nonStandardParameters(PWorkspaceEditPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits(PWorkspaceEditPDU_viewEdits *val);
static void ASN1CALL ASN1Free_WorkspaceDeletePDU_nonStandardParameters(PWorkspaceDeletePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_WorkspaceCreateAcknowledgePDU_nonStandardParameters(PWorkspaceCreateAcknowledgePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_nonStandardParameters(PWorkspaceCreatePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_TextEditPDU_nonStandardParameters(PTextEditPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_TextDeletePDU_nonStandardParameters(PTextDeletePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_TextCreatePDU_nonStandardParameters(PTextCreatePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_RemotePrintPDU_nonStandardParameters(PRemotePrintPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_RemotePointingDeviceEventPDU_nonStandardParameters(PRemotePointingDeviceEventPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_nonStandardParameters(PRemoteKeyboardEventPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_nonStandardParameters(PRemoteEventPermissionRequestPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_remoteEventPermissionList(PRemoteEventPermissionRequestPDU_remoteEventPermissionList *val);
static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_nonStandardParameters(PRemoteEventPermissionGrantPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_remoteEventPermissionList(PRemoteEventPermissionGrantPDU_remoteEventPermissionList *val);
static void ASN1CALL ASN1Free_FontPDU_nonStandardParameters(PFontPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_DrawingEditPDU_nonStandardParameters(PDrawingEditPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_DrawingDeletePDU_nonStandardParameters(PDrawingDeletePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_DrawingCreatePDU_nonStandardParameters(PDrawingCreatePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_nonStandardParameters(PConductorPrivilegeRequestPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_nonStandardParameters(PConductorPrivilegeGrantPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_BitmapEditPDU_nonStandardParameters(PBitmapEditPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_BitmapDeletePDU_nonStandardParameters(PBitmapDeletePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_BitmapCreateContinuePDU_nonStandardParameters(PBitmapCreateContinuePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_BitmapCreatePDU_nonStandardParameters(PBitmapCreatePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_BitmapCheckpointPDU_nonStandardParameters(PBitmapCheckpointPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_BitmapAbortPDU_nonStandardParameters(PBitmapAbortPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ArchiveOpenPDU_nonStandardParameters(PArchiveOpenPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ArchiveErrorPDU_nonStandardParameters(PArchiveErrorPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ArchiveClosePDU_nonStandardParameters(PArchiveClosePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ArchiveAcknowledgePDU_nonStandardParameters(PArchiveAcknowledgePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_VideoWindowEditPDU_nonStandardParameters(PVideoWindowEditPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_VideoWindowDeletePDU_nonStandardParameters(PVideoWindowDeletePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_VideoWindowCreatePDU_nonStandardParameters(PVideoWindowCreatePDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_VideoSourceIdentifier_dSMCCConnBinder(PVideoSourceIdentifier_dSMCCConnBinder *val);
static void ASN1CALL ASN1Free_TransparencyMask_nonStandardParameters(PTransparencyMask_nonStandardParameters *val);
static void ASN1CALL ASN1Free_TransparencyMask_bitMask(TransparencyMask_bitMask *val);
static void ASN1CALL ASN1Free_PointListEdits_Seq(PointListEdits_Seq *val);
static void ASN1CALL ASN1Free_PointList_pointsDiff16(PPointList_pointsDiff16 *val);
static void ASN1CALL ASN1Free_PointList_pointsDiff8(PPointList_pointsDiff8 *val);
static void ASN1CALL ASN1Free_PointList_pointsDiff4(PPointList_pointsDiff4 *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementRGB_predefinedRGBSpace(ColorAccuracyEnhancementRGB_predefinedRGBSpace *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(ColorAccuracyEnhancementCIELab_predefinedCIELabSpace *val);
#define ASN1Free_ArchiveError(x)
#define ASN1Free_ArchiveOpenResult(x)
static void ASN1CALL ASN1Free_BitmapAbortReason(BitmapAbortReason *val);
static void ASN1CALL ASN1Free_BitmapDestinationAddress(BitmapDestinationAddress *val);
static void ASN1CALL ASN1Free_ButtonEvent(ButtonEvent *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementCIELab(ColorAccuracyEnhancementCIELab *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementGreyscale(ColorAccuracyEnhancementGreyscale *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementRGB(ColorAccuracyEnhancementRGB *val);
static void ASN1CALL ASN1Free_ColorAccuracyEnhancementYCbCr(ColorAccuracyEnhancementYCbCr *val);
static void ASN1CALL ASN1Free_ColorResolutionModeSpecifier(ColorResolutionModeSpecifier *val);
static void ASN1CALL ASN1Free_ConductorPrivilege(ConductorPrivilege *val);
static void ASN1CALL ASN1Free_DrawingDestinationAddress(DrawingDestinationAddress *val);
static void ASN1CALL ASN1Free_DrawingType(DrawingType *val);
static void ASN1CALL ASN1Free_EditablePlaneCopyDescriptor(EditablePlaneCopyDescriptor *val);
#define ASN1Free_KeyCode(x)
static void ASN1CALL ASN1Free_KeyModifier(KeyModifier *val);
#define ASN1Free_KeyPressState(x)
static void ASN1CALL ASN1Free_LineStyle(LineStyle *val);
static void ASN1CALL ASN1Free_PlaneAttribute(PlaneAttribute *val);
static void ASN1CALL ASN1Free_PointListEdits(PointListEdits *val);
static void ASN1CALL ASN1Free_TransparencyMask(TransparencyMask *val);
#define ASN1Free_VideoWindowAttribute(x)
#define ASN1Free_VideoWindowCreatePDU(x)
#define ASN1Free_VideoWindowEditPDU(x)
static void ASN1CALL ASN1Free_WorkspaceAttribute(WorkspaceAttribute *val);
static void ASN1CALL ASN1Free_WorkspaceViewAttribute(WorkspaceViewAttribute *val);
#define ASN1Free_ArchiveAcknowledgePDU(x)
#define ASN1Free_ArchiveErrorPDU(x)
static void ASN1CALL ASN1Free_BitmapAbortPDU(BitmapAbortPDU *val);
static void ASN1CALL ASN1Free_DrawingCreatePDU(DrawingCreatePDU *val);
static void ASN1CALL ASN1Free_DrawingEditPDU(DrawingEditPDU *val);
#define ASN1Free_RemoteKeyboardEventPDU(x)
static void ASN1CALL ASN1Free_RemotePointingDeviceEventPDU(RemotePointingDeviceEventPDU *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_editView(PWorkspaceEditPDU_viewEdits_Set_action_editView *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_createNewView(PWorkspaceEditPDU_viewEdits_Set_action_createNewView *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_Set_planeAttributes(PWorkspaceEditPDU_planeEdits_Set_planeAttributes *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(PWorkspaceCreatePDU_viewParameters_Set_viewAttributes *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes *val);
static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr(ColorPalette_colorLookUpTable_paletteYCbCr *val);
static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab(ColorPalette_colorLookUpTable_paletteCIELab *val);
static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteRGB(ColorPalette_colorLookUpTable_paletteRGB *val);
static void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU_copyDescriptor(WorkspacePlaneCopyPDU_copyDescriptor *val);
static void ASN1CALL ASN1Free_WorkspaceEditPDU_attributeEdits(PWorkspaceEditPDU_attributeEdits *val);
static void ASN1CALL ASN1Free_WorkspaceCreatePDU_workspaceAttributes(PWorkspaceCreatePDU_workspaceAttributes *val);
static void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_keyModifierStates(PRemoteKeyboardEventPDU_keyModifierStates *val);
static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_privilegeList(PConductorPrivilegeRequestPDU_privilegeList *val);
static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_privilegeList(PConductorPrivilegeGrantPDU_privilegeList *val);
static void ASN1CALL ASN1Free_VideoWindowEditPDU_attributeEdits(PVideoWindowEditPDU_attributeEdits *val);
static void ASN1CALL ASN1Free_VideoWindowCreatePDU_attributes(PVideoWindowCreatePDU_attributes *val);
static void ASN1CALL ASN1Free_ColorSpaceSpecifier_cieLab(ColorSpaceSpecifier_cieLab *val);
static void ASN1CALL ASN1Free_ColorSpaceSpecifier_rgb(ColorSpaceSpecifier_rgb *val);
static void ASN1CALL ASN1Free_ColorSpaceSpecifier_yCbCr(ColorSpaceSpecifier_yCbCr *val);
static void ASN1CALL ASN1Free_ColorSpaceSpecifier_greyscale(ColorSpaceSpecifier_greyscale *val);
static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable(ColorPalette_colorLookUpTable *val);
static void ASN1CALL ASN1Free_BitmapAttribute(BitmapAttribute *val);
static void ASN1CALL ASN1Free_ColorPalette(ColorPalette *val);
static void ASN1CALL ASN1Free_ColorSpaceSpecifier(ColorSpaceSpecifier *val);
static void ASN1CALL ASN1Free_DrawingAttribute(DrawingAttribute *val);
static void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU(WorkspacePlaneCopyPDU *val);
static void ASN1CALL ASN1Free_BitmapHeaderUncompressed_colorMappingMode_paletteMap(BitmapHeaderUncompressed_colorMappingMode_paletteMap *val);
static void ASN1CALL ASN1Free_BitmapHeaderUncompressed_colorMappingMode_directMap(BitmapHeaderUncompressed_colorMappingMode_directMap *val);
static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap(BitmapHeaderT82_colorMappingMode_paletteMap *val);
static void ASN1CALL ASN1Free_DrawingEditPDU_attributeEdits(PDrawingEditPDU_attributeEdits *val);
static void ASN1CALL ASN1Free_DrawingCreatePDU_attributes(PDrawingCreatePDU_attributes *val);
static void ASN1CALL ASN1Free_BitmapEditPDU_attributeEdits(PBitmapEditPDU_attributeEdits *val);
static void ASN1CALL ASN1Free_BitmapCreatePDU_attributes(PBitmapCreatePDU_attributes *val);
static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode(BitmapHeaderT82_colorMappingMode *val);
static void ASN1CALL ASN1Free_BitmapHeaderUncompressed_colorMappingMode(BitmapHeaderUncompressed_colorMappingMode *val);
static void ASN1CALL ASN1Free_BitmapHeaderUncompressed(BitmapHeaderUncompressed *val);
static void ASN1CALL ASN1Free_BitmapHeaderT81(BitmapHeaderT81 *val);
static void ASN1CALL ASN1Free_BitmapHeaderT82(BitmapHeaderT82 *val);
static void ASN1CALL ASN1Free_BitmapCreatePDU_bitmapFormatHeader(BitmapCreatePDU_bitmapFormatHeader *val);
static void ASN1CALL ASN1Free_BitmapCreatePDU(BitmapCreatePDU *val);
static void ASN1CALL ASN1Free_SIPDU(SIPDU *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[1] = {
    (ASN1EncFun_t) ASN1Enc_SIPDU,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[1] = {
    (ASN1DecFun_t) ASN1Dec_SIPDU,
};
static const ASN1FreeFun_t freefntab[1] = {
    (ASN1FreeFun_t) ASN1Free_SIPDU,
};
static const ULONG sizetab[1] = {
    SIZE_T126_Module_PDU_0,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
double one = 1;

void ASN1CALL T126_Module_Startup(void)
{
    T126_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 1, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x36323174);
}

void ASN1CALL T126_Module_Cleanup(void)
{
    ASN1_CloseModule(T126_Module);
    T126_Module = NULL;
}

static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(ASN1encoding_t enc, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn, 1, 8, 3);
}

static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn(ASN1encoding_t enc, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes val)
{
    if (!ASN1Enc_ColorIndexTable(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(ASN1decoding_t dec, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn, sizeof(**val), 1, 8, 3);
}

static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn(ASN1decoding_t dec, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes val)
{
    if (!ASN1Dec_ColorIndexTable(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn(PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes val)
{
    if (val) {
	ASN1Free_ColorIndexTable(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(ASN1encoding_t enc, BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(enc, &(val)->u.progressivePalettes))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(ASN1decoding_t dec, BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(dec, &(val)->u.progressivePalettes))
	    return 0;
	break;
    case 2:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes(&(val)->u.progressivePalettes);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->lSpan + 32768))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->lOffset + 32768))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->aSpan + 32768))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->aOffset + 32768))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bSpan + 32768))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bOffset + 32768))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->lSpan))
	return 0;
    (val)->lSpan += 0 - 32768;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->lOffset))
	return 0;
    (val)->lOffset += 0 - 32768;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->aSpan))
	return 0;
    (val)->aSpan += 0 - 32768;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->aOffset))
	return 0;
    (val)->aOffset += 0 - 32768;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bSpan))
	return 0;
    (val)->bSpan += 0 - 32768;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bOffset))
	return 0;
    (val)->bOffset += 0 - 32768;
    return 1;
}

static int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor_objectList_Seq(ASN1encoding_t enc, EditablePlaneCopyDescriptor_objectList_Seq *val)
{
    ASN1uint32_t l;
    l = ASN1uint32_uoctets((val)->sourceObjectHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sourceObjectHandle))
	return 0;
    l = ASN1uint32_uoctets((val)->destinationObjectHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->destinationObjectHandle))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor_objectList_Seq(ASN1decoding_t dec, EditablePlaneCopyDescriptor_objectList_Seq *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sourceObjectHandle))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->destinationObjectHandle))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq(ASN1encoding_t enc, WorkspaceCreatePDU_planeParameters_Seq *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->editable))
	return 0;
    if (!ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_usage(enc, &(val)->usage))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(enc, &(val)->planeAttributes))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq(ASN1decoding_t dec, WorkspaceCreatePDU_planeParameters_Seq *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->editable))
	return 0;
    if (!ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_usage(dec, &(val)->usage))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(dec, &(val)->planeAttributes))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq(WorkspaceCreatePDU_planeParameters_Seq *val)
{
    if (val) {
	ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_usage(&(val)->usage);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(&(val)->planeAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_Set(ASN1encoding_t enc, WorkspaceCreatePDU_viewParameters_Set *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->viewHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->viewHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(enc, &(val)->viewAttributes))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_Set(ASN1decoding_t dec, WorkspaceCreatePDU_viewParameters_Set *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->viewHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(dec, &(val)->viewAttributes))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_Set(WorkspaceCreatePDU_viewParameters_Set *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(&(val)->viewAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_Set(ASN1encoding_t enc, WorkspaceEditPDU_planeEdits_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->plane))
	return 0;
    if (!ASN1Enc_WorkspaceEditPDU_planeEdits_Set_planeAttributes(enc, &(val)->planeAttributes))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_Set(ASN1decoding_t dec, WorkspaceEditPDU_planeEdits_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->plane))
	return 0;
    if (!ASN1Dec_WorkspaceEditPDU_planeEdits_Set_planeAttributes(dec, &(val)->planeAttributes))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_Set(WorkspaceEditPDU_planeEdits_Set *val)
{
    if (val) {
	ASN1Free_WorkspaceEditPDU_planeEdits_Set_planeAttributes(&(val)->planeAttributes);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceEditPDU_planeEdits_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits val)
{
    if (!ASN1Enc_WorkspaceEditPDU_planeEdits_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceEditPDU_planeEdits_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits val)
{
    if (!ASN1Dec_WorkspaceEditPDU_planeEdits_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits(PWorkspaceEditPDU_planeEdits *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceEditPDU_planeEdits_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_ElmFn(PWorkspaceEditPDU_planeEdits val)
{
    if (val) {
	ASN1Free_WorkspaceEditPDU_planeEdits_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_viewParameters_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters val)
{
    if (!ASN1Enc_WorkspaceCreatePDU_viewParameters_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_viewParameters_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters val)
{
    if (!ASN1Dec_WorkspaceCreatePDU_viewParameters_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters(PWorkspaceCreatePDU_viewParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_viewParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_ElmFn(PWorkspaceCreatePDU_viewParameters val)
{
    if (val) {
	ASN1Free_WorkspaceCreatePDU_viewParameters_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_planeParameters_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters val)
{
    if (!ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_planeParameters_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters val)
{
    if (!ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters(PWorkspaceCreatePDU_planeParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_planeParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_ElmFn(PWorkspaceCreatePDU_planeParameters val)
{
    if (val) {
	ASN1Free_WorkspaceCreatePDU_planeParameters_Seq(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_protectedPlaneAccessList(ASN1encoding_t enc, PWorkspaceCreatePDU_protectedPlaneAccessList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_protectedPlaneAccessList val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_protectedPlaneAccessList(ASN1decoding_t dec, PWorkspaceCreatePDU_protectedPlaneAccessList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_protectedPlaneAccessList val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_protectedPlaneAccessList(PWorkspaceCreatePDU_protectedPlaneAccessList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn(PWorkspaceCreatePDU_protectedPlaneAccessList val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU_checkpoints(ASN1encoding_t enc, PBitmapCreatePDU_checkpoints *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapCreatePDU_checkpoints_ElmFn, 1, 100, 7);
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU_checkpoints_ElmFn(ASN1encoding_t enc, PBitmapCreatePDU_checkpoints val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU_checkpoints(ASN1decoding_t dec, PBitmapCreatePDU_checkpoints *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapCreatePDU_checkpoints_ElmFn, sizeof(**val), 1, 100, 7);
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU_checkpoints_ElmFn(ASN1decoding_t dec, PBitmapCreatePDU_checkpoints val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCreatePDU_checkpoints(PBitmapCreatePDU_checkpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapCreatePDU_checkpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapCreatePDU_checkpoints_ElmFn(PBitmapCreatePDU_checkpoints val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_BitmapCheckpointPDU_passedCheckpoints(ASN1encoding_t enc, PBitmapCheckpointPDU_passedCheckpoints *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapCheckpointPDU_passedCheckpoints_ElmFn, 1, 100, 7);
}

static int ASN1CALL ASN1Enc_BitmapCheckpointPDU_passedCheckpoints_ElmFn(ASN1encoding_t enc, PBitmapCheckpointPDU_passedCheckpoints val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCheckpointPDU_passedCheckpoints(ASN1decoding_t dec, PBitmapCheckpointPDU_passedCheckpoints *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapCheckpointPDU_passedCheckpoints_ElmFn, sizeof(**val), 1, 100, 7);
}

static int ASN1CALL ASN1Dec_BitmapCheckpointPDU_passedCheckpoints_ElmFn(ASN1decoding_t dec, PBitmapCheckpointPDU_passedCheckpoints val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCheckpointPDU_passedCheckpoints(PBitmapCheckpointPDU_passedCheckpoints *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapCheckpointPDU_passedCheckpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapCheckpointPDU_passedCheckpoints_ElmFn(PBitmapCheckpointPDU_passedCheckpoints val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_WorkspaceIdentifier_archiveWorkspace(ASN1encoding_t enc, WorkspaceIdentifier_archiveWorkspace *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->archiveHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->archiveHandle))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, ((val)->entryName).length - 1))
	return 0;
    if (!ASN1PEREncChar16String(enc, ((val)->entryName).length, ((val)->entryName).value, 16))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncGeneralizedTime(enc, &(val)->modificationTime, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceIdentifier_archiveWorkspace(ASN1decoding_t dec, WorkspaceIdentifier_archiveWorkspace *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->archiveHandle))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &((val)->entryName).length))
	return 0;
    ((val)->entryName).length += 1;
    if (!ASN1PERDecChar16String(dec, ((val)->entryName).length, &((val)->entryName).value, 16))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecGeneralizedTime(dec, &(val)->modificationTime, 8))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceIdentifier_archiveWorkspace(WorkspaceIdentifier_archiveWorkspace *val)
{
    if (val) {
	ASN1char16string_free(&(val)->entryName);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_PixelAspectRatio_general(ASN1encoding_t enc, PixelAspectRatio_general *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->numerator - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->denominator - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PixelAspectRatio_general(ASN1decoding_t dec, PixelAspectRatio_general *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numerator))
	return 0;
    (val)->numerator += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->denominator))
	return 0;
    (val)->denominator += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor_objectList(ASN1encoding_t enc, PEditablePlaneCopyDescriptor_objectList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EditablePlaneCopyDescriptor_objectList_ElmFn);
}

static int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor_objectList_ElmFn(ASN1encoding_t enc, PEditablePlaneCopyDescriptor_objectList val)
{
    if (!ASN1Enc_EditablePlaneCopyDescriptor_objectList_Seq(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor_objectList(ASN1decoding_t dec, PEditablePlaneCopyDescriptor_objectList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EditablePlaneCopyDescriptor_objectList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor_objectList_ElmFn(ASN1decoding_t dec, PEditablePlaneCopyDescriptor_objectList val)
{
    if (!ASN1Dec_EditablePlaneCopyDescriptor_objectList_Seq(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EditablePlaneCopyDescriptor_objectList(PEditablePlaneCopyDescriptor_objectList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EditablePlaneCopyDescriptor_objectList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EditablePlaneCopyDescriptor_objectList_ElmFn(PEditablePlaneCopyDescriptor_objectList val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters(ASN1encoding_t enc, ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncDouble(enc, (val)->gamma))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters(ASN1decoding_t dec, ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecDouble(dec, &(val)->gamma))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab_generalCIELabParameters(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab_generalCIELabParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedInteger(enc, (val)->colorTemperature))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut(enc, &(val)->gamut))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab_generalCIELabParameters(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab_generalCIELabParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedInteger(dec, &(val)->colorTemperature))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut(dec, &(val)->gamut))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_BitmapRegion_lowerRight(ASN1encoding_t enc, BitmapRegion_lowerRight *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->xCoordinate))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->yCoordinate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapRegion_lowerRight(ASN1decoding_t dec, BitmapRegion_lowerRight *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->xCoordinate))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->yCoordinate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_BitmapRegion_upperLeft(ASN1encoding_t enc, BitmapRegion_upperLeft *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->xCoordinate))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->yCoordinate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapRegion_upperLeft(ASN1decoding_t dec, BitmapRegion_upperLeft *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->xCoordinate))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->yCoordinate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_BitmapData_dataCheckpoint(ASN1encoding_t enc, PBitmapData_dataCheckpoint *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapData_dataCheckpoint_ElmFn, 1, 100, 7);
}

static int ASN1CALL ASN1Enc_BitmapData_dataCheckpoint_ElmFn(ASN1encoding_t enc, PBitmapData_dataCheckpoint val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapData_dataCheckpoint(ASN1decoding_t dec, PBitmapData_dataCheckpoint *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapData_dataCheckpoint_ElmFn, sizeof(**val), 1, 100, 7);
}

static int ASN1CALL ASN1Dec_BitmapData_dataCheckpoint_ElmFn(ASN1decoding_t dec, PBitmapData_dataCheckpoint val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapData_dataCheckpoint(PBitmapData_dataCheckpoint *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapData_dataCheckpoint_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapData_dataCheckpoint_ElmFn(PBitmapData_dataCheckpoint val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_BitmapData(ASN1encoding_t enc, BitmapData *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_BitmapData_dataCheckpoint(enc, &(val)->dataCheckpoint))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->padBits - 1))
	    return 0;
    }
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->data, 1, 8192, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapData(ASN1decoding_t dec, BitmapData *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_BitmapData_dataCheckpoint(dec, &(val)->dataCheckpoint))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->padBits))
	    return 0;
	(val)->padBits += 1;
    }
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->data, 1, 8192, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapData(BitmapData *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_BitmapData_dataCheckpoint(&(val)->dataCheckpoint);
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderT4(ASN1encoding_t enc, BitmapHeaderT4 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoDimensionalEncoding))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT4(ASN1decoding_t dec, BitmapHeaderT4 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->twoDimensionalEncoding))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_BitmapHeaderT6(ASN1encoding_t enc, BitmapHeaderT6 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT6(ASN1decoding_t dec, BitmapHeaderT6 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_BitmapRegion(ASN1encoding_t enc, BitmapRegion *val)
{
    if (!ASN1Enc_BitmapRegion_upperLeft(enc, &(val)->upperLeft))
	return 0;
    if (!ASN1Enc_BitmapRegion_lowerRight(enc, &(val)->lowerRight))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapRegion(ASN1decoding_t dec, BitmapRegion *val)
{
    if (!ASN1Dec_BitmapRegion_upperLeft(dec, &(val)->upperLeft))
	return 0;
    if (!ASN1Dec_BitmapRegion_lowerRight(dec, &(val)->lowerRight))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_BitmapSize(ASN1encoding_t enc, BitmapSize *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, (val)->width - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, (val)->height - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapSize(ASN1decoding_t dec, BitmapSize *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &(val)->width))
	return 0;
    (val)->width += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &(val)->height))
	return 0;
    (val)->height += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_ColorCIELab(ASN1encoding_t enc, ColorCIELab *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->l))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->a))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->b))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorCIELab(ASN1decoding_t dec, ColorCIELab *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->l))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->a))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->b))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ColorCIExyChromaticity(ASN1encoding_t enc, ColorCIExyChromaticity *val)
{
    if (!ASN1PEREncDouble(enc, (val)->x))
	return 0;
    if (!ASN1PEREncDouble(enc, (val)->y))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorCIExyChromaticity(ASN1decoding_t dec, ColorCIExyChromaticity *val)
{
    if (!ASN1PERDecDouble(dec, &(val)->x))
	return 0;
    if (!ASN1PERDecDouble(dec, &(val)->y))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ColorIndexTable(ASN1encoding_t enc, PColorIndexTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ColorIndexTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_ColorIndexTable_ElmFn(ASN1encoding_t enc, PColorIndexTable val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorIndexTable(ASN1decoding_t dec, PColorIndexTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ColorIndexTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_ColorIndexTable_ElmFn(ASN1decoding_t dec, PColorIndexTable val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ColorIndexTable(PColorIndexTable *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ColorIndexTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ColorIndexTable_ElmFn(PColorIndexTable val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ColorRGB(ASN1encoding_t enc, ColorRGB *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->r))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->g))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->b))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorRGB(ASN1decoding_t dec, ColorRGB *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->r))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->g))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->b))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ColorYCbCr(ASN1encoding_t enc, ColorYCbCr *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->y))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->cb))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->cr))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorYCbCr(ASN1decoding_t dec, ColorYCbCr *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->cb))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->cr))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_DSMCCTap(ASN1encoding_t enc, DSMCCTap *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->use))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->id))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->associationTag))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->selector, 1, 256, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DSMCCTap(ASN1decoding_t dec, DSMCCTap *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->use))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->id))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->associationTag))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->selector, 1, 256, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DSMCCTap(DSMCCTap *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.h221nonStandard, 4, 255, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.h221nonStandard, 4, 255, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	case 2:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val)
{
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val)
{
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val)
{
    if (val) {
	ASN1Free_NonStandardIdentifier(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_PenNib(ASN1encoding_t enc, PenNib *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardNib))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PenNib(ASN1decoding_t dec, PenNib *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardNib))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PenNib(PenNib *val)
{
    if (val) {
	switch ((val)->choice) {
	case 3:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardNib);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PixelAspectRatio(ASN1encoding_t enc, PixelAspectRatio *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Enc_PixelAspectRatio_general(enc, &(val)->u.general))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardAspectRatio))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PixelAspectRatio(ASN1decoding_t dec, PixelAspectRatio *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Dec_PixelAspectRatio_general(dec, &(val)->u.general))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardAspectRatio))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PixelAspectRatio(PixelAspectRatio *val)
{
    if (val) {
	switch ((val)->choice) {
	case 6:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardAspectRatio);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PlaneProtection(ASN1encoding_t enc, PlaneProtection *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->protectedplane))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PlaneProtection(ASN1decoding_t dec, PlaneProtection *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->protectedplane))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_PlaneUsage(ASN1encoding_t enc, PlaneUsage *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardPlaneUsage))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PlaneUsage(ASN1decoding_t dec, PlaneUsage *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardPlaneUsage))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PlaneUsage(PlaneUsage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 3:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardPlaneUsage);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PointList(ASN1encoding_t enc, PointList *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PointList_pointsDiff4(enc, &(val)->u.pointsDiff4))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_PointList_pointsDiff8(enc, &(val)->u.pointsDiff8))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_PointList_pointsDiff16(enc, &(val)->u.pointsDiff16))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PointList(ASN1decoding_t dec, PointList *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PointList_pointsDiff4(dec, &(val)->u.pointsDiff4))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_PointList_pointsDiff8(dec, &(val)->u.pointsDiff8))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_PointList_pointsDiff16(dec, &(val)->u.pointsDiff16))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PointList(PointList *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_PointList_pointsDiff4(&(val)->u.pointsDiff4);
	    break;
	case 2:
	    ASN1Free_PointList_pointsDiff8(&(val)->u.pointsDiff8);
	    break;
	case 3:
	    ASN1Free_PointList_pointsDiff16(&(val)->u.pointsDiff16);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PointDiff4(ASN1encoding_t enc, PointDiff4 *val)
{
    if (!ASN1PEREncBitVal(enc, 4, (val)->xCoordinate + 8))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->yCoordinate + 8))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PointDiff4(ASN1decoding_t dec, PointDiff4 *val)
{
    if (!ASN1PERDecU8Val(dec, 4, &(val)->xCoordinate))
	return 0;
    (val)->xCoordinate += 0 - 8;
    if (!ASN1PERDecU8Val(dec, 4, &(val)->yCoordinate))
	return 0;
    (val)->yCoordinate += 0 - 8;
    return 1;
}

static int ASN1CALL ASN1Enc_PointDiff8(ASN1encoding_t enc, PointDiff8 *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->xCoordinate + 128))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->yCoordinate + 128))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PointDiff8(ASN1decoding_t dec, PointDiff8 *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU8Val(dec, 8, &(val)->xCoordinate))
	return 0;
    (val)->xCoordinate += 0 - 128;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU8Val(dec, 8, &(val)->yCoordinate))
	return 0;
    (val)->yCoordinate += 0 - 128;
    return 1;
}

static int ASN1CALL ASN1Enc_PointDiff16(ASN1encoding_t enc, PointDiff16 *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->xCoordinate + 32768))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->yCoordinate + 32768))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PointDiff16(ASN1decoding_t dec, PointDiff16 *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->xCoordinate))
	return 0;
    (val)->xCoordinate += 0 - 32768;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->yCoordinate))
	return 0;
    (val)->yCoordinate += 0 - 32768;
    return 1;
}

static int ASN1CALL ASN1Enc_RemoteEventDestinationAddress(ASN1encoding_t enc, RemoteEventDestinationAddress *val)
{
    ASN1uint32_t l;
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	l = ASN1uint32_uoctets((val)->u.softCopyWorkspace);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->u.softCopyWorkspace))
	    return 0;
	break;
    case 2:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardDestination))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventDestinationAddress(ASN1decoding_t dec, RemoteEventDestinationAddress *val)
{
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->u.softCopyWorkspace))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardDestination))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventDestinationAddress(RemoteEventDestinationAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardDestination);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RemoteEventPermission(ASN1encoding_t enc, RemoteEventPermission *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardEvent))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventPermission(ASN1decoding_t dec, RemoteEventPermission *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardEvent))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventPermission(RemoteEventPermission *val)
{
    if (val) {
	switch ((val)->choice) {
	case 3:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardEvent);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RotationSpecifier(ASN1encoding_t enc, RotationSpecifier *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->rotationAngle))
	return 0;
    if (!ASN1Enc_PointDiff16(enc, &(val)->rotationAxis))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RotationSpecifier(ASN1decoding_t dec, RotationSpecifier *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->rotationAngle))
	return 0;
    if (!ASN1Dec_PointDiff16(dec, &(val)->rotationAxis))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SoftCopyDataPlaneAddress(ASN1encoding_t enc, SoftCopyDataPlaneAddress *val)
{
    ASN1uint32_t l;
    l = ASN1uint32_uoctets((val)->workspaceHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->workspaceHandle))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->plane))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SoftCopyDataPlaneAddress(ASN1decoding_t dec, SoftCopyDataPlaneAddress *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->workspaceHandle))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->plane))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SoftCopyPointerPlaneAddress(ASN1encoding_t enc, SoftCopyPointerPlaneAddress *val)
{
    ASN1uint32_t l;
    l = ASN1uint32_uoctets((val)->workspaceHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->workspaceHandle))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SoftCopyPointerPlaneAddress(ASN1decoding_t dec, SoftCopyPointerPlaneAddress *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->workspaceHandle))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SourceDisplayIndicator(ASN1encoding_t enc, SourceDisplayIndicator *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncDouble(enc, (val)->displayAspectRatio))
	return 0;
    if (!ASN1PEREncDouble(enc, (val)->horizontalSizeRatio))
	return 0;
    if (!ASN1PEREncDouble(enc, (val)->horizontalPosition))
	return 0;
    if (!ASN1PEREncDouble(enc, (val)->verticalPosition))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SourceDisplayIndicator(ASN1decoding_t dec, SourceDisplayIndicator *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecDouble(dec, &(val)->displayAspectRatio))
	return 0;
    if (!ASN1PERDecDouble(dec, &(val)->horizontalSizeRatio))
	return 0;
    if (!ASN1PERDecDouble(dec, &(val)->horizontalPosition))
	return 0;
    if (!ASN1PERDecDouble(dec, &(val)->verticalPosition))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ViewState(ASN1encoding_t enc, ViewState *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardViewState))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ViewState(ASN1decoding_t dec, ViewState *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardViewState))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ViewState(ViewState *val)
{
    if (val) {
	switch ((val)->choice) {
	case 4:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardViewState);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceColor(ASN1encoding_t enc, WorkspaceColor *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.workspacePaletteIndex))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ColorRGB(enc, &(val)->u.rgbTrueColor))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceColor(ASN1decoding_t dec, WorkspaceColor *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.workspacePaletteIndex))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ColorRGB(dec, &(val)->u.rgbTrueColor))
	    return 0;
	break;
    case 3:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_WorkspaceDeleteReason(ASN1encoding_t enc, WorkspaceDeleteReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardReason))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceDeleteReason(ASN1decoding_t dec, WorkspaceDeleteReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardReason))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceDeleteReason(WorkspaceDeleteReason *val)
{
    if (val) {
	switch ((val)->choice) {
	case 3:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardReason);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceIdentifier(ASN1encoding_t enc, WorkspaceIdentifier *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	l = ASN1uint32_uoctets((val)->u.activeWorkspace);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->u.activeWorkspace))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_WorkspaceIdentifier_archiveWorkspace(enc, &(val)->u.archiveWorkspace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceIdentifier(ASN1decoding_t dec, WorkspaceIdentifier *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->u.activeWorkspace))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_WorkspaceIdentifier_archiveWorkspace(dec, &(val)->u.archiveWorkspace))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceIdentifier(WorkspaceIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_WorkspaceIdentifier_archiveWorkspace(&(val)->u.archiveWorkspace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspacePoint(ASN1encoding_t enc, WorkspacePoint *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, (val)->xCoordinate + 21845))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, (val)->yCoordinate + 21845))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspacePoint(ASN1decoding_t dec, WorkspacePoint *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &(val)->xCoordinate))
	return 0;
    (val)->xCoordinate += 0 - 21845;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &(val)->yCoordinate))
	return 0;
    (val)->yCoordinate += 0 - 21845;
    return 1;
}

static int ASN1CALL ASN1Enc_WorkspaceRegion(ASN1encoding_t enc, WorkspaceRegion *val)
{
    if (!ASN1Enc_WorkspacePoint(enc, &(val)->upperLeft))
	return 0;
    if (!ASN1Enc_WorkspacePoint(enc, &(val)->lowerRight))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceRegion(ASN1decoding_t dec, WorkspaceRegion *val)
{
    if (!ASN1Dec_WorkspacePoint(dec, &(val)->upperLeft))
	return 0;
    if (!ASN1Dec_WorkspacePoint(dec, &(val)->lowerRight))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_WorkspaceSize(ASN1encoding_t enc, WorkspaceSize *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->width - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->height - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceSize(ASN1decoding_t dec, WorkspaceSize *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->width))
	return 0;
    (val)->width += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->height))
	return 0;
    (val)->height += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_WorkspaceViewState(ASN1encoding_t enc, WorkspaceViewState *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardState))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceViewState(ASN1decoding_t dec, WorkspaceViewState *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardState))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceViewState(WorkspaceViewState *val)
{
    if (val) {
	switch ((val)->choice) {
	case 5:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardState);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapCheckpointPDU(ASN1encoding_t enc, BitmapCheckpointPDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->bitmapHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitmapHandle))
	return 0;
    if (!ASN1Enc_BitmapCheckpointPDU_passedCheckpoints(enc, &(val)->passedCheckpoints))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->percentComplete - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_BitmapCheckpointPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCheckpointPDU(ASN1decoding_t dec, BitmapCheckpointPDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitmapHandle))
	return 0;
    if (!ASN1Dec_BitmapCheckpointPDU_passedCheckpoints(dec, &(val)->passedCheckpoints))
	return 0;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->percentComplete))
	return 0;
    (val)->percentComplete += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_BitmapCheckpointPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCheckpointPDU(BitmapCheckpointPDU *val)
{
    if (val) {
	ASN1Free_BitmapCheckpointPDU_passedCheckpoints(&(val)->passedCheckpoints);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_BitmapCheckpointPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapCreateContinuePDU(ASN1encoding_t enc, BitmapCreateContinuePDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->bitmapHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitmapHandle))
	return 0;
    if (!ASN1Enc_BitmapData(enc, &(val)->bitmapData))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->moreToFollow))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_BitmapCreateContinuePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCreateContinuePDU(ASN1decoding_t dec, BitmapCreateContinuePDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitmapHandle))
	return 0;
    if (!ASN1Dec_BitmapData(dec, &(val)->bitmapData))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->moreToFollow))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_BitmapCreateContinuePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCreateContinuePDU(BitmapCreateContinuePDU *val)
{
    if (val) {
	ASN1Free_BitmapData(&(val)->bitmapData);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_BitmapCreateContinuePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapDeletePDU(ASN1encoding_t enc, BitmapDeletePDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->bitmapHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitmapHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_BitmapDeletePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapDeletePDU(ASN1decoding_t dec, BitmapDeletePDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitmapHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_BitmapDeletePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapDeletePDU(BitmapDeletePDU *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_BitmapDeletePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapEditPDU(ASN1encoding_t enc, BitmapEditPDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->bitmapHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitmapHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_BitmapEditPDU_attributeEdits(enc, &(val)->attributeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_WorkspacePoint(enc, &(val)->anchorPointEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_BitmapRegion(enc, &(val)->bitmapRegionOfInterestEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_PointDiff16(enc, &(val)->scalingEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_BitmapEditPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapEditPDU(ASN1decoding_t dec, BitmapEditPDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitmapHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_BitmapEditPDU_attributeEdits(dec, &(val)->attributeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_WorkspacePoint(dec, &(val)->anchorPointEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_BitmapRegion(dec, &(val)->bitmapRegionOfInterestEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_PointDiff16(dec, &(val)->scalingEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_BitmapEditPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapEditPDU(BitmapEditPDU *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_BitmapEditPDU_attributeEdits(&(val)->attributeEdits);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_BitmapEditPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU(ASN1encoding_t enc, ConductorPrivilegeGrantPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->destinationUserID - 1001))
	return 0;
    if (!ASN1Enc_ConductorPrivilegeGrantPDU_privilegeList(enc, &(val)->privilegeList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ConductorPrivilegeGrantPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU(ASN1decoding_t dec, ConductorPrivilegeGrantPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->destinationUserID))
	return 0;
    (val)->destinationUserID += 1001;
    if (!ASN1Dec_ConductorPrivilegeGrantPDU_privilegeList(dec, &(val)->privilegeList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ConductorPrivilegeGrantPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU(ConductorPrivilegeGrantPDU *val)
{
    if (val) {
	ASN1Free_ConductorPrivilegeGrantPDU_privilegeList(&(val)->privilegeList);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ConductorPrivilegeGrantPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU(ASN1encoding_t enc, ConductorPrivilegeRequestPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ConductorPrivilegeRequestPDU_privilegeList(enc, &(val)->privilegeList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ConductorPrivilegeRequestPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU(ASN1decoding_t dec, ConductorPrivilegeRequestPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ConductorPrivilegeRequestPDU_privilegeList(dec, &(val)->privilegeList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ConductorPrivilegeRequestPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU(ConductorPrivilegeRequestPDU *val)
{
    if (val) {
	ASN1Free_ConductorPrivilegeRequestPDU_privilegeList(&(val)->privilegeList);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ConductorPrivilegeRequestPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_DrawingDeletePDU(ASN1encoding_t enc, DrawingDeletePDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->drawingHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->drawingHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_DrawingDeletePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingDeletePDU(ASN1decoding_t dec, DrawingDeletePDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->drawingHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_DrawingDeletePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DrawingDeletePDU(DrawingDeletePDU *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_DrawingDeletePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_FontPDU(ASN1encoding_t enc, FontPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_FontPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FontPDU(ASN1decoding_t dec, FontPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_FontPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_FontPDU(FontPDU *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_FontPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU(ASN1encoding_t enc, RemoteEventPermissionGrantPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RemoteEventDestinationAddress(enc, &(val)->destinationAddress))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->destinationUserID - 1001))
	return 0;
    if (!ASN1Enc_RemoteEventPermissionGrantPDU_remoteEventPermissionList(enc, &(val)->remoteEventPermissionList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RemoteEventPermissionGrantPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU(ASN1decoding_t dec, RemoteEventPermissionGrantPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RemoteEventDestinationAddress(dec, &(val)->destinationAddress))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->destinationUserID))
	return 0;
    (val)->destinationUserID += 1001;
    if (!ASN1Dec_RemoteEventPermissionGrantPDU_remoteEventPermissionList(dec, &(val)->remoteEventPermissionList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RemoteEventPermissionGrantPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU(RemoteEventPermissionGrantPDU *val)
{
    if (val) {
	ASN1Free_RemoteEventDestinationAddress(&(val)->destinationAddress);
	ASN1Free_RemoteEventPermissionGrantPDU_remoteEventPermissionList(&(val)->remoteEventPermissionList);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RemoteEventPermissionGrantPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU(ASN1encoding_t enc, RemoteEventPermissionRequestPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RemoteEventDestinationAddress(enc, &(val)->destinationAddress))
	return 0;
    if (!ASN1Enc_RemoteEventPermissionRequestPDU_remoteEventPermissionList(enc, &(val)->remoteEventPermissionList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RemoteEventPermissionRequestPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU(ASN1decoding_t dec, RemoteEventPermissionRequestPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RemoteEventDestinationAddress(dec, &(val)->destinationAddress))
	return 0;
    if (!ASN1Dec_RemoteEventPermissionRequestPDU_remoteEventPermissionList(dec, &(val)->remoteEventPermissionList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RemoteEventPermissionRequestPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU(RemoteEventPermissionRequestPDU *val)
{
    if (val) {
	ASN1Free_RemoteEventDestinationAddress(&(val)->destinationAddress);
	ASN1Free_RemoteEventPermissionRequestPDU_remoteEventPermissionList(&(val)->remoteEventPermissionList);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RemoteEventPermissionRequestPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_RemotePrintPDU(ASN1encoding_t enc, RemotePrintPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1Enc_RemoteEventDestinationAddress(enc, &(val)->destinationAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 16, (val)->numberOfCopies - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBoolean(enc, (val)->portrait))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_WorkspaceRegion(enc, &(val)->regionOfInterest))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_RemotePrintPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemotePrintPDU(ASN1decoding_t dec, RemotePrintPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1Dec_RemoteEventDestinationAddress(dec, &(val)->destinationAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 16, &(val)->numberOfCopies))
	    return 0;
	(val)->numberOfCopies += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecBoolean(dec, &(val)->portrait))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_WorkspaceRegion(dec, &(val)->regionOfInterest))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_RemotePrintPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RemotePrintPDU(RemotePrintPDU *val)
{
    if (val) {
	ASN1Free_RemoteEventDestinationAddress(&(val)->destinationAddress);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_RemotePrintPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_SINonStandardPDU(ASN1encoding_t enc, SINonStandardPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardTransaction))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SINonStandardPDU(ASN1decoding_t dec, SINonStandardPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardTransaction))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SINonStandardPDU(SINonStandardPDU *val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&(val)->nonStandardTransaction);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU(ASN1encoding_t enc, WorkspaceCreatePDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1Enc_WorkspaceIdentifier(enc, &(val)->workspaceIdentifier))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->appRosterInstance))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->synchronized))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->acceptKeyboardEvents))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->acceptPointingDeviceEvents))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceCreatePDU_protectedPlaneAccessList(enc, &(val)->protectedPlaneAccessList))
	    return 0;
    }
    if (!ASN1Enc_WorkspaceSize(enc, &(val)->workspaceSize))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_WorkspaceCreatePDU_workspaceAttributes(enc, &(val)->workspaceAttributes))
	    return 0;
    }
    if (!ASN1Enc_WorkspaceCreatePDU_planeParameters(enc, &(val)->planeParameters))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_WorkspaceCreatePDU_viewParameters(enc, &(val)->viewParameters))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_WorkspaceCreatePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU(ASN1decoding_t dec, WorkspaceCreatePDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1Dec_WorkspaceIdentifier(dec, &(val)->workspaceIdentifier))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->appRosterInstance))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->synchronized))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->acceptKeyboardEvents))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->acceptPointingDeviceEvents))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceCreatePDU_protectedPlaneAccessList(dec, &(val)->protectedPlaneAccessList))
	    return 0;
    }
    if (!ASN1Dec_WorkspaceSize(dec, &(val)->workspaceSize))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_WorkspaceCreatePDU_workspaceAttributes(dec, &(val)->workspaceAttributes))
	    return 0;
    }
    if (!ASN1Dec_WorkspaceCreatePDU_planeParameters(dec, &(val)->planeParameters))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_WorkspaceCreatePDU_viewParameters(dec, &(val)->viewParameters))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_WorkspaceCreatePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU(WorkspaceCreatePDU *val)
{
    if (val) {
	ASN1Free_WorkspaceIdentifier(&(val)->workspaceIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceCreatePDU_protectedPlaneAccessList(&(val)->protectedPlaneAccessList);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_WorkspaceCreatePDU_workspaceAttributes(&(val)->workspaceAttributes);
	}
	ASN1Free_WorkspaceCreatePDU_planeParameters(&(val)->planeParameters);
	if ((val)->o[0] & 0x20) {
	    ASN1Free_WorkspaceCreatePDU_viewParameters(&(val)->viewParameters);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_WorkspaceCreatePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreateAcknowledgePDU(ASN1encoding_t enc, WorkspaceCreateAcknowledgePDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_WorkspaceIdentifier(enc, &(val)->workspaceIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceCreateAcknowledgePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreateAcknowledgePDU(ASN1decoding_t dec, WorkspaceCreateAcknowledgePDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_WorkspaceIdentifier(dec, &(val)->workspaceIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceCreateAcknowledgePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreateAcknowledgePDU(WorkspaceCreateAcknowledgePDU *val)
{
    if (val) {
	ASN1Free_WorkspaceIdentifier(&(val)->workspaceIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceCreateAcknowledgePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceDeletePDU(ASN1encoding_t enc, WorkspaceDeletePDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_WorkspaceIdentifier(enc, &(val)->workspaceIdentifier))
	return 0;
    if (!ASN1Enc_WorkspaceDeleteReason(enc, &(val)->reason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceDeletePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceDeletePDU(ASN1decoding_t dec, WorkspaceDeletePDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_WorkspaceIdentifier(dec, &(val)->workspaceIdentifier))
	return 0;
    if (!ASN1Dec_WorkspaceDeleteReason(dec, &(val)->reason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceDeletePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceDeletePDU(WorkspaceDeletePDU *val)
{
    if (val) {
	ASN1Free_WorkspaceIdentifier(&(val)->workspaceIdentifier);
	ASN1Free_WorkspaceDeleteReason(&(val)->reason);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceDeletePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU(ASN1encoding_t enc, WorkspaceEditPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1Enc_WorkspaceIdentifier(enc, &(val)->workspaceIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceEditPDU_attributeEdits(enc, &(val)->attributeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_WorkspaceEditPDU_planeEdits(enc, &(val)->planeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_WorkspaceEditPDU_viewEdits(enc, &(val)->viewEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_WorkspaceEditPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU(ASN1decoding_t dec, WorkspaceEditPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1Dec_WorkspaceIdentifier(dec, &(val)->workspaceIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceEditPDU_attributeEdits(dec, &(val)->attributeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_WorkspaceEditPDU_planeEdits(dec, &(val)->planeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_WorkspaceEditPDU_viewEdits(dec, &(val)->viewEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_WorkspaceEditPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU(WorkspaceEditPDU *val)
{
    if (val) {
	ASN1Free_WorkspaceIdentifier(&(val)->workspaceIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceEditPDU_attributeEdits(&(val)->attributeEdits);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_WorkspaceEditPDU_planeEdits(&(val)->planeEdits);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_WorkspaceEditPDU_viewEdits(&(val)->viewEdits);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_WorkspaceEditPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceReadyPDU(ASN1encoding_t enc, WorkspaceReadyPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_WorkspaceIdentifier(enc, &(val)->workspaceIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceReadyPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceReadyPDU(ASN1decoding_t dec, WorkspaceReadyPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_WorkspaceIdentifier(dec, &(val)->workspaceIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceReadyPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceReadyPDU(WorkspaceReadyPDU *val)
{
    if (val) {
	ASN1Free_WorkspaceIdentifier(&(val)->workspaceIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceReadyPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceRefreshStatusPDU(ASN1encoding_t enc, WorkspaceRefreshStatusPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->refreshStatus))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspaceRefreshStatusPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceRefreshStatusPDU(ASN1decoding_t dec, WorkspaceRefreshStatusPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->refreshStatus))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspaceRefreshStatusPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceRefreshStatusPDU(WorkspaceRefreshStatusPDU *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspaceRefreshStatusPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action(ASN1encoding_t enc, WorkspaceEditPDU_viewEdits_Set_action *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_createNewView(enc, &(val)->u.createNewView))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_editView(enc, &(val)->u.editView))
	    return 0;
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardAction))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action(ASN1decoding_t dec, WorkspaceEditPDU_viewEdits_Set_action *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_createNewView(dec, &(val)->u.createNewView))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_editView(dec, &(val)->u.editView))
	    return 0;
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardAction))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action(WorkspaceEditPDU_viewEdits_Set_action *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_createNewView(&(val)->u.createNewView);
	    break;
	case 2:
	    ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_editView(&(val)->u.editView);
	    break;
	case 4:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAction);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_usage(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_usage *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_usage val)
{
    if (!ASN1Enc_PlaneUsage(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_usage(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_usage *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_usage val)
{
    if (!ASN1Dec_PlaneUsage(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_usage(PWorkspaceCreatePDU_planeParameters_Seq_usage *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn(PWorkspaceCreatePDU_planeParameters_Seq_usage val)
{
    if (val) {
	ASN1Free_PlaneUsage(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB_palette(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteRGB_palette *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn, 2, 256, 8);
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteRGB_palette val)
{
    if (!ASN1Enc_ColorRGB(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB_palette(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteRGB_palette *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn, sizeof(**val), 2, 256, 8);
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteRGB_palette val)
{
    if (!ASN1Dec_ColorRGB(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteRGB_palette(PColorPalette_colorLookUpTable_paletteRGB_palette *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn(PColorPalette_colorLookUpTable_paletteRGB_palette val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab_palette(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteCIELab_palette *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn, 2, 256, 8);
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteCIELab_palette val)
{
    if (!ASN1Enc_ColorCIELab(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab_palette(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteCIELab_palette *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn, sizeof(**val), 2, 256, 8);
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteCIELab_palette val)
{
    if (!ASN1Dec_ColorCIELab(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab_palette(PColorPalette_colorLookUpTable_paletteCIELab_palette *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn(PColorPalette_colorLookUpTable_paletteCIELab_palette val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr_palette(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteYCbCr_palette *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn, 2, 256, 8);
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteYCbCr_palette val)
{
    if (!ASN1Enc_ColorYCbCr(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr_palette(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteYCbCr_palette *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn, sizeof(**val), 2, 256, 8);
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteYCbCr_palette val)
{
    if (!ASN1Dec_ColorYCbCr(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr_palette(PColorPalette_colorLookUpTable_paletteYCbCr_palette *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn(PColorPalette_colorLookUpTable_paletteYCbCr_palette val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB_generalRGBParameters_primaries(ASN1encoding_t enc, ColorAccuracyEnhancementRGB_generalRGBParameters_primaries *val)
{
    if (!ASN1Enc_ColorCIExyChromaticity(enc, &(val)->red))
	return 0;
    if (!ASN1Enc_ColorCIExyChromaticity(enc, &(val)->green))
	return 0;
    if (!ASN1Enc_ColorCIExyChromaticity(enc, &(val)->blue))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB_generalRGBParameters_primaries(ASN1decoding_t dec, ColorAccuracyEnhancementRGB_generalRGBParameters_primaries *val)
{
    if (!ASN1Dec_ColorCIExyChromaticity(dec, &(val)->red))
	return 0;
    if (!ASN1Dec_ColorCIExyChromaticity(dec, &(val)->green))
	return 0;
    if (!ASN1Dec_ColorCIExyChromaticity(dec, &(val)->blue))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries *val)
{
    if (!ASN1Enc_ColorCIExyChromaticity(enc, &(val)->red))
	return 0;
    if (!ASN1Enc_ColorCIExyChromaticity(enc, &(val)->green))
	return 0;
    if (!ASN1Enc_ColorCIExyChromaticity(enc, &(val)->blue))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries *val)
{
    if (!ASN1Dec_ColorCIExyChromaticity(dec, &(val)->red))
	return 0;
    if (!ASN1Dec_ColorCIExyChromaticity(dec, &(val)->green))
	return 0;
    if (!ASN1Dec_ColorCIExyChromaticity(dec, &(val)->blue))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set(ASN1encoding_t enc, WorkspaceEditPDU_viewEdits_Set *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    l = ASN1uint32_uoctets((val)->viewHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->viewHandle))
	return 0;
    if (!ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action(enc, &(val)->action))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set(ASN1decoding_t dec, WorkspaceEditPDU_viewEdits_Set *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->viewHandle))
	return 0;
    if (!ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action(dec, &(val)->action))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set(WorkspaceEditPDU_viewEdits_Set *val)
{
    if (val) {
	ASN1Free_WorkspaceEditPDU_viewEdits_Set_action(&(val)->action);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceRefreshStatusPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceRefreshStatusPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceRefreshStatusPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceRefreshStatusPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceRefreshStatusPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceRefreshStatusPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceRefreshStatusPDU_nonStandardParameters(PWorkspaceRefreshStatusPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn(PWorkspaceRefreshStatusPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceReadyPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceReadyPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceReadyPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceReadyPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceReadyPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceReadyPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceReadyPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceReadyPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceReadyPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceReadyPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceReadyPDU_nonStandardParameters(PWorkspaceReadyPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceReadyPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceReadyPDU_nonStandardParameters_ElmFn(PWorkspaceReadyPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspacePlaneCopyPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspacePlaneCopyPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspacePlaneCopyPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspacePlaneCopyPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU_nonStandardParameters(PWorkspacePlaneCopyPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn(PWorkspacePlaneCopyPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceEditPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceEditPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceEditPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceEditPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_nonStandardParameters(PWorkspaceEditPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceEditPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_nonStandardParameters_ElmFn(PWorkspaceEditPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceEditPDU_viewEdits_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits val)
{
    if (!ASN1Enc_WorkspaceEditPDU_viewEdits_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceEditPDU_viewEdits_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits val)
{
    if (!ASN1Dec_WorkspaceEditPDU_viewEdits_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits(PWorkspaceEditPDU_viewEdits *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceEditPDU_viewEdits_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_ElmFn(PWorkspaceEditPDU_viewEdits val)
{
    if (val) {
	ASN1Free_WorkspaceEditPDU_viewEdits_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceDeletePDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceDeletePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceDeletePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceDeletePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceDeletePDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceDeletePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceDeletePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceDeletePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceDeletePDU_nonStandardParameters(PWorkspaceDeletePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceDeletePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceDeletePDU_nonStandardParameters_ElmFn(PWorkspaceDeletePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreateAcknowledgePDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceCreateAcknowledgePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreateAcknowledgePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreateAcknowledgePDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceCreateAcknowledgePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreateAcknowledgePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreateAcknowledgePDU_nonStandardParameters(PWorkspaceCreateAcknowledgePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn(PWorkspaceCreateAcknowledgePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_nonStandardParameters(ASN1encoding_t enc, PWorkspaceCreatePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_nonStandardParameters(ASN1decoding_t dec, PWorkspaceCreatePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_nonStandardParameters(PWorkspaceCreatePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_nonStandardParameters_ElmFn(PWorkspaceCreatePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TextEditPDU_nonStandardParameters(ASN1encoding_t enc, PTextEditPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TextEditPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_TextEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTextEditPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TextEditPDU_nonStandardParameters(ASN1decoding_t dec, PTextEditPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TextEditPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TextEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTextEditPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TextEditPDU_nonStandardParameters(PTextEditPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TextEditPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TextEditPDU_nonStandardParameters_ElmFn(PTextEditPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TextDeletePDU_nonStandardParameters(ASN1encoding_t enc, PTextDeletePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TextDeletePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_TextDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTextDeletePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TextDeletePDU_nonStandardParameters(ASN1decoding_t dec, PTextDeletePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TextDeletePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TextDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTextDeletePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TextDeletePDU_nonStandardParameters(PTextDeletePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TextDeletePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TextDeletePDU_nonStandardParameters_ElmFn(PTextDeletePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TextCreatePDU_nonStandardParameters(ASN1encoding_t enc, PTextCreatePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TextCreatePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_TextCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTextCreatePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TextCreatePDU_nonStandardParameters(ASN1decoding_t dec, PTextCreatePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TextCreatePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TextCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTextCreatePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TextCreatePDU_nonStandardParameters(PTextCreatePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TextCreatePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TextCreatePDU_nonStandardParameters_ElmFn(PTextCreatePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemotePrintPDU_nonStandardParameters(ASN1encoding_t enc, PRemotePrintPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemotePrintPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_RemotePrintPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemotePrintPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemotePrintPDU_nonStandardParameters(ASN1decoding_t dec, PRemotePrintPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemotePrintPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemotePrintPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemotePrintPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemotePrintPDU_nonStandardParameters(PRemotePrintPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemotePrintPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemotePrintPDU_nonStandardParameters_ElmFn(PRemotePrintPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemotePointingDeviceEventPDU_nonStandardParameters(ASN1encoding_t enc, PRemotePointingDeviceEventPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemotePointingDeviceEventPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemotePointingDeviceEventPDU_nonStandardParameters(ASN1decoding_t dec, PRemotePointingDeviceEventPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemotePointingDeviceEventPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemotePointingDeviceEventPDU_nonStandardParameters(PRemotePointingDeviceEventPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn(PRemotePointingDeviceEventPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_nonStandardParameters(ASN1encoding_t enc, PRemoteKeyboardEventPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemoteKeyboardEventPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_nonStandardParameters(ASN1decoding_t dec, PRemoteKeyboardEventPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemoteKeyboardEventPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_nonStandardParameters(PRemoteKeyboardEventPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn(PRemoteKeyboardEventPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_nonStandardParameters(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_nonStandardParameters(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_nonStandardParameters(PRemoteEventPermissionRequestPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn(PRemoteEventPermissionRequestPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_remoteEventPermissionList(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_remoteEventPermissionList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn);
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_remoteEventPermissionList val)
{
    if (!ASN1Enc_RemoteEventPermission(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_remoteEventPermissionList(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_remoteEventPermissionList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_remoteEventPermissionList val)
{
    if (!ASN1Dec_RemoteEventPermission(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_remoteEventPermissionList(PRemoteEventPermissionRequestPDU_remoteEventPermissionList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn(PRemoteEventPermissionRequestPDU_remoteEventPermissionList val)
{
    if (val) {
	ASN1Free_RemoteEventPermission(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_nonStandardParameters(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_nonStandardParameters(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_nonStandardParameters(PRemoteEventPermissionGrantPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn(PRemoteEventPermissionGrantPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_remoteEventPermissionList(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_remoteEventPermissionList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn);
}

static int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_remoteEventPermissionList val)
{
    if (!ASN1Enc_RemoteEventPermission(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_remoteEventPermissionList(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_remoteEventPermissionList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_remoteEventPermissionList val)
{
    if (!ASN1Dec_RemoteEventPermission(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_remoteEventPermissionList(PRemoteEventPermissionGrantPDU_remoteEventPermissionList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn(PRemoteEventPermissionGrantPDU_remoteEventPermissionList val)
{
    if (val) {
	ASN1Free_RemoteEventPermission(&val->value);
    }
}

static int ASN1CALL ASN1Enc_FontPDU_nonStandardParameters(ASN1encoding_t enc, PFontPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_FontPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_FontPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PFontPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FontPDU_nonStandardParameters(ASN1decoding_t dec, PFontPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_FontPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_FontPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PFontPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_FontPDU_nonStandardParameters(PFontPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_FontPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_FontPDU_nonStandardParameters_ElmFn(PFontPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DrawingEditPDU_nonStandardParameters(ASN1encoding_t enc, PDrawingEditPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DrawingEditPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_DrawingEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDrawingEditPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingEditPDU_nonStandardParameters(ASN1decoding_t dec, PDrawingEditPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DrawingEditPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DrawingEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDrawingEditPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DrawingEditPDU_nonStandardParameters(PDrawingEditPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DrawingEditPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DrawingEditPDU_nonStandardParameters_ElmFn(PDrawingEditPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DrawingDeletePDU_nonStandardParameters(ASN1encoding_t enc, PDrawingDeletePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DrawingDeletePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_DrawingDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDrawingDeletePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingDeletePDU_nonStandardParameters(ASN1decoding_t dec, PDrawingDeletePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DrawingDeletePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DrawingDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDrawingDeletePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DrawingDeletePDU_nonStandardParameters(PDrawingDeletePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DrawingDeletePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DrawingDeletePDU_nonStandardParameters_ElmFn(PDrawingDeletePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DrawingCreatePDU_nonStandardParameters(ASN1encoding_t enc, PDrawingCreatePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DrawingCreatePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_DrawingCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDrawingCreatePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingCreatePDU_nonStandardParameters(ASN1decoding_t dec, PDrawingCreatePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DrawingCreatePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DrawingCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDrawingCreatePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DrawingCreatePDU_nonStandardParameters(PDrawingCreatePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DrawingCreatePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DrawingCreatePDU_nonStandardParameters_ElmFn(PDrawingCreatePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_nonStandardParameters(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_nonStandardParameters(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_nonStandardParameters(PConductorPrivilegeRequestPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn(PConductorPrivilegeRequestPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_nonStandardParameters(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_nonStandardParameters(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_nonStandardParameters(PConductorPrivilegeGrantPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn(PConductorPrivilegeGrantPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapEditPDU_nonStandardParameters(ASN1encoding_t enc, PBitmapEditPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapEditPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapEditPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapEditPDU_nonStandardParameters(ASN1decoding_t dec, PBitmapEditPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapEditPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapEditPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapEditPDU_nonStandardParameters(PBitmapEditPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapEditPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapEditPDU_nonStandardParameters_ElmFn(PBitmapEditPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapDeletePDU_nonStandardParameters(ASN1encoding_t enc, PBitmapDeletePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapDeletePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapDeletePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapDeletePDU_nonStandardParameters(ASN1decoding_t dec, PBitmapDeletePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapDeletePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapDeletePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapDeletePDU_nonStandardParameters(PBitmapDeletePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapDeletePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapDeletePDU_nonStandardParameters_ElmFn(PBitmapDeletePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapCreateContinuePDU_nonStandardParameters(ASN1encoding_t enc, PBitmapCreateContinuePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapCreateContinuePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapCreateContinuePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapCreateContinuePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCreateContinuePDU_nonStandardParameters(ASN1decoding_t dec, PBitmapCreateContinuePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapCreateContinuePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapCreateContinuePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapCreateContinuePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCreateContinuePDU_nonStandardParameters(PBitmapCreateContinuePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapCreateContinuePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapCreateContinuePDU_nonStandardParameters_ElmFn(PBitmapCreateContinuePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU_nonStandardParameters(ASN1encoding_t enc, PBitmapCreatePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapCreatePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapCreatePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU_nonStandardParameters(ASN1decoding_t dec, PBitmapCreatePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapCreatePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapCreatePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCreatePDU_nonStandardParameters(PBitmapCreatePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapCreatePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapCreatePDU_nonStandardParameters_ElmFn(PBitmapCreatePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapCheckpointPDU_nonStandardParameters(ASN1encoding_t enc, PBitmapCheckpointPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapCheckpointPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapCheckpointPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapCheckpointPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCheckpointPDU_nonStandardParameters(ASN1decoding_t dec, PBitmapCheckpointPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapCheckpointPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapCheckpointPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapCheckpointPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCheckpointPDU_nonStandardParameters(PBitmapCheckpointPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapCheckpointPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapCheckpointPDU_nonStandardParameters_ElmFn(PBitmapCheckpointPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapAbortPDU_nonStandardParameters(ASN1encoding_t enc, PBitmapAbortPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapAbortPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapAbortPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapAbortPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapAbortPDU_nonStandardParameters(ASN1decoding_t dec, PBitmapAbortPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapAbortPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapAbortPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapAbortPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapAbortPDU_nonStandardParameters(PBitmapAbortPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapAbortPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapAbortPDU_nonStandardParameters_ElmFn(PBitmapAbortPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ArchiveOpenPDU_nonStandardParameters(ASN1encoding_t enc, PArchiveOpenPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ArchiveOpenPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ArchiveOpenPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveOpenPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ArchiveOpenPDU_nonStandardParameters(ASN1decoding_t dec, PArchiveOpenPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ArchiveOpenPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ArchiveOpenPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveOpenPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ArchiveOpenPDU_nonStandardParameters(PArchiveOpenPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ArchiveOpenPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ArchiveOpenPDU_nonStandardParameters_ElmFn(PArchiveOpenPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ArchiveErrorPDU_nonStandardParameters(ASN1encoding_t enc, PArchiveErrorPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ArchiveErrorPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ArchiveErrorPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveErrorPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ArchiveErrorPDU_nonStandardParameters(ASN1decoding_t dec, PArchiveErrorPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ArchiveErrorPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ArchiveErrorPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveErrorPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ArchiveErrorPDU_nonStandardParameters(PArchiveErrorPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ArchiveErrorPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ArchiveErrorPDU_nonStandardParameters_ElmFn(PArchiveErrorPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ArchiveClosePDU_nonStandardParameters(ASN1encoding_t enc, PArchiveClosePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ArchiveClosePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ArchiveClosePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveClosePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ArchiveClosePDU_nonStandardParameters(ASN1decoding_t dec, PArchiveClosePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ArchiveClosePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ArchiveClosePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveClosePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ArchiveClosePDU_nonStandardParameters(PArchiveClosePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ArchiveClosePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ArchiveClosePDU_nonStandardParameters_ElmFn(PArchiveClosePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ArchiveAcknowledgePDU_nonStandardParameters(ASN1encoding_t enc, PArchiveAcknowledgePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveAcknowledgePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ArchiveAcknowledgePDU_nonStandardParameters(ASN1decoding_t dec, PArchiveAcknowledgePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveAcknowledgePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ArchiveAcknowledgePDU_nonStandardParameters(PArchiveAcknowledgePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn(PArchiveAcknowledgePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceViewAttribute_viewRegion(ASN1encoding_t enc, WorkspaceViewAttribute_viewRegion *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_WorkspaceRegion(enc, &(val)->u.partialWorkspace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceViewAttribute_viewRegion(ASN1decoding_t dec, WorkspaceViewAttribute_viewRegion *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_WorkspaceRegion(dec, &(val)->u.partialWorkspace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VideoWindowEditPDU_nonStandardParameters(ASN1encoding_t enc, PVideoWindowEditPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VideoWindowEditPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_VideoWindowEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PVideoWindowEditPDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoWindowEditPDU_nonStandardParameters(ASN1decoding_t dec, PVideoWindowEditPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VideoWindowEditPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VideoWindowEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PVideoWindowEditPDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VideoWindowEditPDU_nonStandardParameters(PVideoWindowEditPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VideoWindowEditPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VideoWindowEditPDU_nonStandardParameters_ElmFn(PVideoWindowEditPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VideoWindowDeletePDU_nonStandardParameters(ASN1encoding_t enc, PVideoWindowDeletePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VideoWindowDeletePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_VideoWindowDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PVideoWindowDeletePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoWindowDeletePDU_nonStandardParameters(ASN1decoding_t dec, PVideoWindowDeletePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VideoWindowDeletePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VideoWindowDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PVideoWindowDeletePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VideoWindowDeletePDU_nonStandardParameters(PVideoWindowDeletePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VideoWindowDeletePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VideoWindowDeletePDU_nonStandardParameters_ElmFn(PVideoWindowDeletePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VideoWindowCreatePDU_nonStandardParameters(ASN1encoding_t enc, PVideoWindowCreatePDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VideoWindowCreatePDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_VideoWindowCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PVideoWindowCreatePDU_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoWindowCreatePDU_nonStandardParameters(ASN1decoding_t dec, PVideoWindowCreatePDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VideoWindowCreatePDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VideoWindowCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PVideoWindowCreatePDU_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VideoWindowCreatePDU_nonStandardParameters(PVideoWindowCreatePDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VideoWindowCreatePDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VideoWindowCreatePDU_nonStandardParameters_ElmFn(PVideoWindowCreatePDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VideoSourceIdentifier_dSMCCConnBinder(ASN1encoding_t enc, PVideoSourceIdentifier_dSMCCConnBinder *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VideoSourceIdentifier_dSMCCConnBinder_ElmFn);
}

static int ASN1CALL ASN1Enc_VideoSourceIdentifier_dSMCCConnBinder_ElmFn(ASN1encoding_t enc, PVideoSourceIdentifier_dSMCCConnBinder val)
{
    if (!ASN1Enc_DSMCCTap(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoSourceIdentifier_dSMCCConnBinder(ASN1decoding_t dec, PVideoSourceIdentifier_dSMCCConnBinder *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VideoSourceIdentifier_dSMCCConnBinder_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VideoSourceIdentifier_dSMCCConnBinder_ElmFn(ASN1decoding_t dec, PVideoSourceIdentifier_dSMCCConnBinder val)
{
    if (!ASN1Dec_DSMCCTap(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VideoSourceIdentifier_dSMCCConnBinder(PVideoSourceIdentifier_dSMCCConnBinder *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VideoSourceIdentifier_dSMCCConnBinder_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VideoSourceIdentifier_dSMCCConnBinder_ElmFn(PVideoSourceIdentifier_dSMCCConnBinder val)
{
    if (val) {
	ASN1Free_DSMCCTap(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransparencyMask_nonStandardParameters(ASN1encoding_t enc, PTransparencyMask_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TransparencyMask_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_TransparencyMask_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTransparencyMask_nonStandardParameters val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransparencyMask_nonStandardParameters(ASN1decoding_t dec, PTransparencyMask_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TransparencyMask_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TransparencyMask_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTransparencyMask_nonStandardParameters val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransparencyMask_nonStandardParameters(PTransparencyMask_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TransparencyMask_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TransparencyMask_nonStandardParameters_ElmFn(PTransparencyMask_nonStandardParameters val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransparencyMask_bitMask(ASN1encoding_t enc, TransparencyMask_bitMask *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->u.uncompressed))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->u.jbigCompressed))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardFormat))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransparencyMask_bitMask(ASN1decoding_t dec, TransparencyMask_bitMask *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->u.uncompressed))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->u.jbigCompressed))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardFormat))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransparencyMask_bitMask(TransparencyMask_bitMask *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.uncompressed);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.jbigCompressed);
	    break;
	case 3:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardFormat);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PointListEdits_Seq(ASN1encoding_t enc, PointListEdits_Seq *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->initialIndex))
	return 0;
    if (!ASN1Enc_PointDiff16(enc, &(val)->initialPointEdit))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_PointList(enc, &(val)->subsequentPointEdits))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PointListEdits_Seq(ASN1decoding_t dec, PointListEdits_Seq *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->initialIndex))
	return 0;
    if (!ASN1Dec_PointDiff16(dec, &(val)->initialPointEdit))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_PointList(dec, &(val)->subsequentPointEdits))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PointListEdits_Seq(PointListEdits_Seq *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PointList(&(val)->subsequentPointEdits);
	}
    }
}

static int ASN1CALL ASN1Enc_PointList_pointsDiff16(ASN1encoding_t enc, PPointList_pointsDiff16 *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PointList_pointsDiff16_ElmFn, 0, 255, 8);
}

static int ASN1CALL ASN1Enc_PointList_pointsDiff16_ElmFn(ASN1encoding_t enc, PPointList_pointsDiff16 val)
{
    if (!ASN1Enc_PointDiff16(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PointList_pointsDiff16(ASN1decoding_t dec, PPointList_pointsDiff16 *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PointList_pointsDiff16_ElmFn, sizeof(**val), 0, 255, 8);
}

static int ASN1CALL ASN1Dec_PointList_pointsDiff16_ElmFn(ASN1decoding_t dec, PPointList_pointsDiff16 val)
{
    if (!ASN1Dec_PointDiff16(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PointList_pointsDiff16(PPointList_pointsDiff16 *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PointList_pointsDiff16_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PointList_pointsDiff16_ElmFn(PPointList_pointsDiff16 val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PointList_pointsDiff8(ASN1encoding_t enc, PPointList_pointsDiff8 *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PointList_pointsDiff8_ElmFn, 0, 255, 8);
}

static int ASN1CALL ASN1Enc_PointList_pointsDiff8_ElmFn(ASN1encoding_t enc, PPointList_pointsDiff8 val)
{
    if (!ASN1Enc_PointDiff8(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PointList_pointsDiff8(ASN1decoding_t dec, PPointList_pointsDiff8 *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PointList_pointsDiff8_ElmFn, sizeof(**val), 0, 255, 8);
}

static int ASN1CALL ASN1Dec_PointList_pointsDiff8_ElmFn(ASN1decoding_t dec, PPointList_pointsDiff8 val)
{
    if (!ASN1Dec_PointDiff8(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PointList_pointsDiff8(PPointList_pointsDiff8 *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PointList_pointsDiff8_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PointList_pointsDiff8_ElmFn(PPointList_pointsDiff8 val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PointList_pointsDiff4(ASN1encoding_t enc, PPointList_pointsDiff4 *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PointList_pointsDiff4_ElmFn, 0, 255, 8);
}

static int ASN1CALL ASN1Enc_PointList_pointsDiff4_ElmFn(ASN1encoding_t enc, PPointList_pointsDiff4 val)
{
    if (!ASN1Enc_PointDiff4(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PointList_pointsDiff4(ASN1decoding_t dec, PPointList_pointsDiff4 *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PointList_pointsDiff4_ElmFn, sizeof(**val), 0, 255, 8);
}

static int ASN1CALL ASN1Dec_PointList_pointsDiff4_ElmFn(ASN1decoding_t dec, PPointList_pointsDiff4 val)
{
    if (!ASN1Dec_PointDiff4(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PointList_pointsDiff4(PPointList_pointsDiff4 *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PointList_pointsDiff4_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PointList_pointsDiff4_ElmFn(PPointList_pointsDiff4 val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncDouble(enc, (val)->gamma))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncUnsignedInteger(enc, (val)->colorTemperature))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries(enc, &(val)->primaries))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr_generalYCbCrParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecDouble(dec, &(val)->gamma))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecUnsignedInteger(dec, &(val)->colorTemperature))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries(dec, &(val)->primaries))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardRGBSpace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardRGBSpace))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardRGBSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB_generalRGBParameters(ASN1encoding_t enc, ColorAccuracyEnhancementRGB_generalRGBParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncDouble(enc, (val)->gamma))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncUnsignedInteger(enc, (val)->colorTemperature))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ColorAccuracyEnhancementRGB_generalRGBParameters_primaries(enc, &(val)->primaries))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB_generalRGBParameters(ASN1decoding_t dec, ColorAccuracyEnhancementRGB_generalRGBParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecDouble(dec, &(val)->gamma))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecUnsignedInteger(dec, &(val)->colorTemperature))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ColorAccuracyEnhancementRGB_generalRGBParameters_primaries(dec, &(val)->primaries))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB_predefinedRGBSpace(ASN1encoding_t enc, ColorAccuracyEnhancementRGB_predefinedRGBSpace *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardRGBSpace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB_predefinedRGBSpace(ASN1decoding_t dec, ColorAccuracyEnhancementRGB_predefinedRGBSpace *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardRGBSpace))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementRGB_predefinedRGBSpace(ColorAccuracyEnhancementRGB_predefinedRGBSpace *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardRGBSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(ASN1encoding_t enc, ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardGreyscaleSpace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(ASN1decoding_t dec, ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardGreyscaleSpace))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardGreyscaleSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab_predefinedCIELabSpace *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardCIELabSpace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab_predefinedCIELabSpace *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardCIELabSpace))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(ColorAccuracyEnhancementCIELab_predefinedCIELabSpace *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardCIELabSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapAbortReason(ASN1encoding_t enc, BitmapAbortReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardReason))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapAbortReason(ASN1decoding_t dec, BitmapAbortReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardReason))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapAbortReason(BitmapAbortReason *val)
{
    if (val) {
	switch ((val)->choice) {
	case 4:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardReason);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapDestinationAddress(ASN1encoding_t enc, BitmapDestinationAddress *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_SoftCopyDataPlaneAddress(enc, &(val)->u.softCopyImagePlane))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_SoftCopyDataPlaneAddress(enc, &(val)->u.softCopyAnnotationPlane))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_SoftCopyPointerPlaneAddress(enc, &(val)->u.softCopyPointerPlane))
	    return 0;
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardDestination))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapDestinationAddress(ASN1decoding_t dec, BitmapDestinationAddress *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_SoftCopyDataPlaneAddress(dec, &(val)->u.softCopyImagePlane))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_SoftCopyDataPlaneAddress(dec, &(val)->u.softCopyAnnotationPlane))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_SoftCopyPointerPlaneAddress(dec, &(val)->u.softCopyPointerPlane))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardDestination))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapDestinationAddress(BitmapDestinationAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 5:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardDestination);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ButtonEvent(ASN1encoding_t enc, ButtonEvent *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardButtonEvent))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ButtonEvent(ASN1decoding_t dec, ButtonEvent *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardButtonEvent))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ButtonEvent(ButtonEvent *val)
{
    if (val) {
	switch ((val)->choice) {
	case 6:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardButtonEvent);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementCIELab(ASN1encoding_t enc, ColorAccuracyEnhancementCIELab *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(enc, &(val)->u.predefinedCIELabSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ColorAccuracyEnhancementCIELab_generalCIELabParameters(enc, &(val)->u.generalCIELabParameters))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementCIELab(ASN1decoding_t dec, ColorAccuracyEnhancementCIELab *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(dec, &(val)->u.predefinedCIELabSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ColorAccuracyEnhancementCIELab_generalCIELabParameters(dec, &(val)->u.generalCIELabParameters))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementCIELab(ColorAccuracyEnhancementCIELab *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ColorAccuracyEnhancementCIELab_predefinedCIELabSpace(&(val)->u.predefinedCIELabSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementGreyscale(ASN1encoding_t enc, ColorAccuracyEnhancementGreyscale *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(enc, &(val)->u.predefinedGreyscaleSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters(enc, &(val)->u.generalGreyscaleParameters))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementGreyscale(ASN1decoding_t dec, ColorAccuracyEnhancementGreyscale *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(dec, &(val)->u.predefinedGreyscaleSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters(dec, &(val)->u.generalGreyscaleParameters))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementGreyscale(ColorAccuracyEnhancementGreyscale *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace(&(val)->u.predefinedGreyscaleSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementRGB(ASN1encoding_t enc, ColorAccuracyEnhancementRGB *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ColorAccuracyEnhancementRGB_predefinedRGBSpace(enc, &(val)->u.predefinedRGBSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ColorAccuracyEnhancementRGB_generalRGBParameters(enc, &(val)->u.generalRGBParameters))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementRGB(ASN1decoding_t dec, ColorAccuracyEnhancementRGB *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ColorAccuracyEnhancementRGB_predefinedRGBSpace(dec, &(val)->u.predefinedRGBSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ColorAccuracyEnhancementRGB_generalRGBParameters(dec, &(val)->u.generalRGBParameters))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementRGB(ColorAccuracyEnhancementRGB *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ColorAccuracyEnhancementRGB_predefinedRGBSpace(&(val)->u.predefinedRGBSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorAccuracyEnhancementYCbCr(ASN1encoding_t enc, ColorAccuracyEnhancementYCbCr *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(enc, &(val)->u.predefinedYCbCrSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters(enc, &(val)->u.generalYCbCrParameters))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorAccuracyEnhancementYCbCr(ASN1decoding_t dec, ColorAccuracyEnhancementYCbCr *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(dec, &(val)->u.predefinedYCbCrSpace))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ColorAccuracyEnhancementYCbCr_generalYCbCrParameters(dec, &(val)->u.generalYCbCrParameters))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorAccuracyEnhancementYCbCr(ColorAccuracyEnhancementYCbCr *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace(&(val)->u.predefinedYCbCrSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorResolutionModeSpecifier(ASN1encoding_t enc, ColorResolutionModeSpecifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardResolutionMode))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorResolutionModeSpecifier(ASN1decoding_t dec, ColorResolutionModeSpecifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardResolutionMode))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorResolutionModeSpecifier(ColorResolutionModeSpecifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 4:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardResolutionMode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConductorPrivilege(ASN1encoding_t enc, ConductorPrivilege *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardPrivilege))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPrivilege(ASN1decoding_t dec, ConductorPrivilege *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardPrivilege))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPrivilege(ConductorPrivilege *val)
{
    if (val) {
	switch ((val)->choice) {
	case 9:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardPrivilege);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DrawingDestinationAddress(ASN1encoding_t enc, DrawingDestinationAddress *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_SoftCopyDataPlaneAddress(enc, &(val)->u.softCopyAnnotationPlane))
	    return 0;
	break;
    case 2:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardDestination))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingDestinationAddress(ASN1decoding_t dec, DrawingDestinationAddress *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_SoftCopyDataPlaneAddress(dec, &(val)->u.softCopyAnnotationPlane))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardDestination))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DrawingDestinationAddress(DrawingDestinationAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardDestination);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DrawingType(ASN1encoding_t enc, DrawingType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardDrawingType))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingType(ASN1decoding_t dec, DrawingType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardDrawingType))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DrawingType(DrawingType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 6:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardDrawingType);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor(ASN1encoding_t enc, EditablePlaneCopyDescriptor *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_EditablePlaneCopyDescriptor_objectList(enc, &(val)->objectList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_PointDiff16(enc, &(val)->destinationOffset))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->planeClearFlag))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor(ASN1decoding_t dec, EditablePlaneCopyDescriptor *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_EditablePlaneCopyDescriptor_objectList(dec, &(val)->objectList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_PointDiff16(dec, &(val)->destinationOffset))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->planeClearFlag))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EditablePlaneCopyDescriptor(EditablePlaneCopyDescriptor *val)
{
    if (val) {
	ASN1Free_EditablePlaneCopyDescriptor_objectList(&(val)->objectList);
    }
}

static int ASN1CALL ASN1Enc_KeyModifier(ASN1encoding_t enc, KeyModifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardModifier))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KeyModifier(ASN1decoding_t dec, KeyModifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardModifier))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KeyModifier(KeyModifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 11:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardModifier);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_LineStyle(ASN1encoding_t enc, LineStyle *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardStyle))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LineStyle(ASN1decoding_t dec, LineStyle *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardStyle))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_LineStyle(LineStyle *val)
{
    if (val) {
	switch ((val)->choice) {
	case 7:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardStyle);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PermanentPlaneCopyDescriptor(ASN1encoding_t enc, PermanentPlaneCopyDescriptor *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_WorkspaceRegion(enc, &(val)->sourceRegion))
	return 0;
    if (!ASN1Enc_WorkspaceRegion(enc, &(val)->destinationRegion))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PermanentPlaneCopyDescriptor(ASN1decoding_t dec, PermanentPlaneCopyDescriptor *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_WorkspaceRegion(dec, &(val)->sourceRegion))
	return 0;
    if (!ASN1Dec_WorkspaceRegion(dec, &(val)->destinationRegion))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_PlaneAttribute(ASN1encoding_t enc, PlaneAttribute *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PlaneProtection(enc, &(val)->u.protection))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PlaneAttribute(ASN1decoding_t dec, PlaneAttribute *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PlaneProtection(dec, &(val)->u.protection))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PlaneAttribute(PlaneAttribute *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAttribute);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_PointListEdits(ASN1encoding_t enc, PointListEdits *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_PointListEdits_Seq(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PointListEdits(ASN1decoding_t dec, PointListEdits *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_PointListEdits_Seq(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PointListEdits(PointListEdits *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_PointListEdits_Seq(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_TransparencyMask(ASN1encoding_t enc, TransparencyMask *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_TransparencyMask_bitMask(enc, &(val)->bitMask))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransparencyMask_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransparencyMask(ASN1decoding_t dec, TransparencyMask *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_TransparencyMask_bitMask(dec, &(val)->bitMask))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransparencyMask_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransparencyMask(TransparencyMask *val)
{
    if (val) {
	ASN1Free_TransparencyMask_bitMask(&(val)->bitMask);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransparencyMask_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceAttribute(ASN1encoding_t enc, WorkspaceAttribute *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_WorkspaceColor(enc, &(val)->u.backgroundColor))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncBoolean(enc, (val)->u.preserve))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceAttribute(ASN1decoding_t dec, WorkspaceAttribute *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_WorkspaceColor(dec, &(val)->u.backgroundColor))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecBoolean(dec, &(val)->u.preserve))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceAttribute(WorkspaceAttribute *val)
{
    if (val) {
	switch ((val)->choice) {
	case 3:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAttribute);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceViewAttribute(ASN1encoding_t enc, WorkspaceViewAttribute *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_WorkspaceViewAttribute_viewRegion(enc, &(val)->u.viewRegion))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_WorkspaceViewState(enc, &(val)->u.viewState))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncBoolean(enc, (val)->u.updatesEnabled))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_SourceDisplayIndicator(enc, &(val)->u.sourceDisplayIndicator))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceViewAttribute(ASN1decoding_t dec, WorkspaceViewAttribute *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_WorkspaceViewAttribute_viewRegion(dec, &(val)->u.viewRegion))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_WorkspaceViewState(dec, &(val)->u.viewState))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecBoolean(dec, &(val)->u.updatesEnabled))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_SourceDisplayIndicator(dec, &(val)->u.sourceDisplayIndicator))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceViewAttribute(WorkspaceViewAttribute *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_WorkspaceViewState(&(val)->u.viewState);
	    break;
	case 5:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAttribute);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapAbortPDU(ASN1encoding_t enc, BitmapAbortPDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->bitmapHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitmapHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->userID - 1001))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_BitmapAbortReason(enc, &(val)->reason))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->message).length - 1))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->message).length, ((val)->message).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_BitmapAbortPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapAbortPDU(ASN1decoding_t dec, BitmapAbortPDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitmapHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->userID))
	    return 0;
	(val)->userID += 1001;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_BitmapAbortReason(dec, &(val)->reason))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->message).length))
	    return 0;
	((val)->message).length += 1;
	if (!ASN1PERDecChar16String(dec, ((val)->message).length, &((val)->message).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_BitmapAbortPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapAbortPDU(BitmapAbortPDU *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_BitmapAbortReason(&(val)->reason);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1char16string_free(&(val)->message);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_BitmapAbortPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_DrawingCreatePDU(ASN1encoding_t enc, DrawingCreatePDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->drawingHandle);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->drawingHandle))
	    return 0;
    }
    if (!ASN1Enc_DrawingDestinationAddress(enc, &(val)->destinationAddress))
	return 0;
    if (!ASN1Enc_DrawingType(enc, &(val)->drawingType))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_DrawingCreatePDU_attributes(enc, &(val)->attributes))
	    return 0;
    }
    if (!ASN1Enc_WorkspacePoint(enc, &(val)->anchorPoint))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_RotationSpecifier(enc, &(val)->rotation))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->sampleRate - 1))
	    return 0;
    }
    if (!ASN1Enc_PointList(enc, &(val)->pointList))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_DrawingCreatePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingCreatePDU(ASN1decoding_t dec, DrawingCreatePDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->drawingHandle))
	    return 0;
    }
    if (!ASN1Dec_DrawingDestinationAddress(dec, &(val)->destinationAddress))
	return 0;
    if (!ASN1Dec_DrawingType(dec, &(val)->drawingType))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_DrawingCreatePDU_attributes(dec, &(val)->attributes))
	    return 0;
    }
    if (!ASN1Dec_WorkspacePoint(dec, &(val)->anchorPoint))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_RotationSpecifier(dec, &(val)->rotation))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->sampleRate))
	    return 0;
	(val)->sampleRate += 1;
    }
    if (!ASN1Dec_PointList(dec, &(val)->pointList))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_DrawingCreatePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DrawingCreatePDU(DrawingCreatePDU *val)
{
    if (val) {
	ASN1Free_DrawingDestinationAddress(&(val)->destinationAddress);
	ASN1Free_DrawingType(&(val)->drawingType);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_DrawingCreatePDU_attributes(&(val)->attributes);
	}
	ASN1Free_PointList(&(val)->pointList);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_DrawingCreatePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_DrawingEditPDU(ASN1encoding_t enc, DrawingEditPDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->drawingHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->drawingHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_DrawingEditPDU_attributeEdits(enc, &(val)->attributeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_WorkspacePoint(enc, &(val)->anchorPointEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_RotationSpecifier(enc, &(val)->rotationEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_PointListEdits(enc, &(val)->pointListEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_DrawingEditPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingEditPDU(ASN1decoding_t dec, DrawingEditPDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->drawingHandle))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_DrawingEditPDU_attributeEdits(dec, &(val)->attributeEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_WorkspacePoint(dec, &(val)->anchorPointEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_RotationSpecifier(dec, &(val)->rotationEdit))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_PointListEdits(dec, &(val)->pointListEdits))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_DrawingEditPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DrawingEditPDU(DrawingEditPDU *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_DrawingEditPDU_attributeEdits(&(val)->attributeEdits);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PointListEdits(&(val)->pointListEdits);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_DrawingEditPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_RemotePointingDeviceEventPDU(ASN1encoding_t enc, RemotePointingDeviceEventPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1Enc_RemoteEventDestinationAddress(enc, &(val)->destinationAddress))
	return 0;
    if (!ASN1Enc_ButtonEvent(enc, &(val)->leftButtonState))
	return 0;
    if (!ASN1Enc_ButtonEvent(enc, &(val)->middleButtonState))
	return 0;
    if (!ASN1Enc_ButtonEvent(enc, &(val)->rightButtonState))
	return 0;
    if (!ASN1Enc_WorkspacePoint(enc, &(val)->initialPoint))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->sampleRate - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_PointList(enc, &(val)->pointList))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_RemotePointingDeviceEventPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemotePointingDeviceEventPDU(ASN1decoding_t dec, RemotePointingDeviceEventPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1Dec_RemoteEventDestinationAddress(dec, &(val)->destinationAddress))
	return 0;
    if (!ASN1Dec_ButtonEvent(dec, &(val)->leftButtonState))
	return 0;
    if (!ASN1Dec_ButtonEvent(dec, &(val)->middleButtonState))
	return 0;
    if (!ASN1Dec_ButtonEvent(dec, &(val)->rightButtonState))
	return 0;
    if (!ASN1Dec_WorkspacePoint(dec, &(val)->initialPoint))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->sampleRate))
	    return 0;
	(val)->sampleRate += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_PointList(dec, &(val)->pointList))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_RemotePointingDeviceEventPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RemotePointingDeviceEventPDU(RemotePointingDeviceEventPDU *val)
{
    if (val) {
	ASN1Free_RemoteEventDestinationAddress(&(val)->destinationAddress);
	ASN1Free_ButtonEvent(&(val)->leftButtonState);
	ASN1Free_ButtonEvent(&(val)->middleButtonState);
	ASN1Free_ButtonEvent(&(val)->rightButtonState);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_PointList(&(val)->pointList);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_RemotePointingDeviceEventPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_editView(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_editView *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_editView val)
{
    if (!ASN1Enc_WorkspaceViewAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_editView(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_editView *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_editView val)
{
    if (!ASN1Dec_WorkspaceViewAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_editView(PWorkspaceEditPDU_viewEdits_Set_action_editView *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn(PWorkspaceEditPDU_viewEdits_Set_action_editView val)
{
    if (val) {
	ASN1Free_WorkspaceViewAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_createNewView(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_createNewView *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_createNewView val)
{
    if (!ASN1Enc_WorkspaceViewAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_createNewView(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_createNewView *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_createNewView val)
{
    if (!ASN1Dec_WorkspaceViewAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_createNewView(PWorkspaceEditPDU_viewEdits_Set_action_createNewView *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn(PWorkspaceEditPDU_viewEdits_Set_action_createNewView val)
{
    if (val) {
	ASN1Free_WorkspaceViewAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_Set_planeAttributes(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits_Set_planeAttributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits_Set_planeAttributes val)
{
    if (!ASN1Enc_PlaneAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_Set_planeAttributes(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits_Set_planeAttributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits_Set_planeAttributes val)
{
    if (!ASN1Dec_PlaneAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_Set_planeAttributes(PWorkspaceEditPDU_planeEdits_Set_planeAttributes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn(PWorkspaceEditPDU_planeEdits_Set_planeAttributes val)
{
    if (val) {
	ASN1Free_PlaneAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes val)
{
    if (!ASN1Enc_WorkspaceViewAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes val)
{
    if (!ASN1Dec_WorkspaceViewAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_Set_viewAttributes(PWorkspaceCreatePDU_viewParameters_Set_viewAttributes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn(PWorkspaceCreatePDU_viewParameters_Set_viewAttributes val)
{
    if (val) {
	ASN1Free_WorkspaceViewAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes val)
{
    if (!ASN1Enc_PlaneAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes val)
{
    if (!ASN1Dec_PlaneAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes(PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn(PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes val)
{
    if (val) {
	ASN1Free_PlaneAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr(ASN1encoding_t enc, ColorPalette_colorLookUpTable_paletteYCbCr *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr_palette(enc, &(val)->palette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ColorAccuracyEnhancementYCbCr(enc, &(val)->enhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr(ASN1decoding_t dec, ColorPalette_colorLookUpTable_paletteYCbCr *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr_palette(dec, &(val)->palette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ColorAccuracyEnhancementYCbCr(dec, &(val)->enhancement))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr(ColorPalette_colorLookUpTable_paletteYCbCr *val)
{
    if (val) {
	ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr_palette(&(val)->palette);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorAccuracyEnhancementYCbCr(&(val)->enhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab(ASN1encoding_t enc, ColorPalette_colorLookUpTable_paletteCIELab *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab_palette(enc, &(val)->palette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ColorAccuracyEnhancementCIELab(enc, &(val)->enhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab(ASN1decoding_t dec, ColorPalette_colorLookUpTable_paletteCIELab *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab_palette(dec, &(val)->palette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ColorAccuracyEnhancementCIELab(dec, &(val)->enhancement))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab(ColorPalette_colorLookUpTable_paletteCIELab *val)
{
    if (val) {
	ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab_palette(&(val)->palette);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorAccuracyEnhancementCIELab(&(val)->enhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB(ASN1encoding_t enc, ColorPalette_colorLookUpTable_paletteRGB *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB_palette(enc, &(val)->palette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ColorAccuracyEnhancementRGB(enc, &(val)->enhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB(ASN1decoding_t dec, ColorPalette_colorLookUpTable_paletteRGB *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB_palette(dec, &(val)->palette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ColorAccuracyEnhancementRGB(dec, &(val)->enhancement))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteRGB(ColorPalette_colorLookUpTable_paletteRGB *val)
{
    if (val) {
	ASN1Free_ColorPalette_colorLookUpTable_paletteRGB_palette(&(val)->palette);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorAccuracyEnhancementRGB(&(val)->enhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU_copyDescriptor(ASN1encoding_t enc, WorkspacePlaneCopyPDU_copyDescriptor *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PermanentPlaneCopyDescriptor(enc, &(val)->u.permanentPlaneCopyDescriptor))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_EditablePlaneCopyDescriptor(enc, &(val)->u.editablePlaneCopyDescriptor))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU_copyDescriptor(ASN1decoding_t dec, WorkspacePlaneCopyPDU_copyDescriptor *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PermanentPlaneCopyDescriptor(dec, &(val)->u.permanentPlaneCopyDescriptor))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_EditablePlaneCopyDescriptor(dec, &(val)->u.editablePlaneCopyDescriptor))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU_copyDescriptor(WorkspacePlaneCopyPDU_copyDescriptor *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_EditablePlaneCopyDescriptor(&(val)->u.editablePlaneCopyDescriptor);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_attributeEdits(ASN1encoding_t enc, PWorkspaceEditPDU_attributeEdits *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceEditPDU_attributeEdits_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_attributeEdits val)
{
    if (!ASN1Enc_WorkspaceAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_attributeEdits(ASN1decoding_t dec, PWorkspaceEditPDU_attributeEdits *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceEditPDU_attributeEdits_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_attributeEdits val)
{
    if (!ASN1Dec_WorkspaceAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_attributeEdits(PWorkspaceEditPDU_attributeEdits *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceEditPDU_attributeEdits_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceEditPDU_attributeEdits_ElmFn(PWorkspaceEditPDU_attributeEdits val)
{
    if (val) {
	ASN1Free_WorkspaceAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_workspaceAttributes(ASN1encoding_t enc, PWorkspaceCreatePDU_workspaceAttributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WorkspaceCreatePDU_workspaceAttributes_ElmFn);
}

static int ASN1CALL ASN1Enc_WorkspaceCreatePDU_workspaceAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_workspaceAttributes val)
{
    if (!ASN1Enc_WorkspaceAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_workspaceAttributes(ASN1decoding_t dec, PWorkspaceCreatePDU_workspaceAttributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WorkspaceCreatePDU_workspaceAttributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WorkspaceCreatePDU_workspaceAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_workspaceAttributes val)
{
    if (!ASN1Dec_WorkspaceAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_workspaceAttributes(PWorkspaceCreatePDU_workspaceAttributes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WorkspaceCreatePDU_workspaceAttributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WorkspaceCreatePDU_workspaceAttributes_ElmFn(PWorkspaceCreatePDU_workspaceAttributes val)
{
    if (val) {
	ASN1Free_WorkspaceAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_keyModifierStates(ASN1encoding_t enc, PRemoteKeyboardEventPDU_keyModifierStates *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RemoteKeyboardEventPDU_keyModifierStates_ElmFn);
}

static int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_keyModifierStates_ElmFn(ASN1encoding_t enc, PRemoteKeyboardEventPDU_keyModifierStates val)
{
    if (!ASN1Enc_KeyModifier(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_keyModifierStates(ASN1decoding_t dec, PRemoteKeyboardEventPDU_keyModifierStates *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RemoteKeyboardEventPDU_keyModifierStates_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_keyModifierStates_ElmFn(ASN1decoding_t dec, PRemoteKeyboardEventPDU_keyModifierStates val)
{
    if (!ASN1Dec_KeyModifier(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_keyModifierStates(PRemoteKeyboardEventPDU_keyModifierStates *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RemoteKeyboardEventPDU_keyModifierStates_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_keyModifierStates_ElmFn(PRemoteKeyboardEventPDU_keyModifierStates val)
{
    if (val) {
	ASN1Free_KeyModifier(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_privilegeList(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_privilegeList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConductorPrivilegeRequestPDU_privilegeList_ElmFn);
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_privilegeList_ElmFn(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_privilegeList val)
{
    if (!ASN1Enc_ConductorPrivilege(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_privilegeList(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_privilegeList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConductorPrivilegeRequestPDU_privilegeList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_privilegeList_ElmFn(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_privilegeList val)
{
    if (!ASN1Dec_ConductorPrivilege(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_privilegeList(PConductorPrivilegeRequestPDU_privilegeList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConductorPrivilegeRequestPDU_privilegeList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_privilegeList_ElmFn(PConductorPrivilegeRequestPDU_privilegeList val)
{
    if (val) {
	ASN1Free_ConductorPrivilege(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_privilegeList(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_privilegeList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConductorPrivilegeGrantPDU_privilegeList_ElmFn);
}

static int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_privilegeList_ElmFn(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_privilegeList val)
{
    if (!ASN1Enc_ConductorPrivilege(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_privilegeList(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_privilegeList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConductorPrivilegeGrantPDU_privilegeList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_privilegeList_ElmFn(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_privilegeList val)
{
    if (!ASN1Dec_ConductorPrivilege(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_privilegeList(PConductorPrivilegeGrantPDU_privilegeList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConductorPrivilegeGrantPDU_privilegeList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_privilegeList_ElmFn(PConductorPrivilegeGrantPDU_privilegeList val)
{
    if (val) {
	ASN1Free_ConductorPrivilege(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VideoWindowEditPDU_attributeEdits(ASN1encoding_t enc, PVideoWindowEditPDU_attributeEdits *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VideoWindowEditPDU_attributeEdits_ElmFn);
}

static int ASN1CALL ASN1Enc_VideoWindowEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PVideoWindowEditPDU_attributeEdits val)
{
    if (!ASN1Enc_VideoWindowAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoWindowEditPDU_attributeEdits(ASN1decoding_t dec, PVideoWindowEditPDU_attributeEdits *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VideoWindowEditPDU_attributeEdits_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VideoWindowEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PVideoWindowEditPDU_attributeEdits val)
{
    if (!ASN1Dec_VideoWindowAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VideoWindowEditPDU_attributeEdits(PVideoWindowEditPDU_attributeEdits *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VideoWindowEditPDU_attributeEdits_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VideoWindowEditPDU_attributeEdits_ElmFn(PVideoWindowEditPDU_attributeEdits val)
{
    if (val) {
	ASN1Free_VideoWindowAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VideoWindowCreatePDU_attributes(ASN1encoding_t enc, PVideoWindowCreatePDU_attributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VideoWindowCreatePDU_attributes_ElmFn);
}

static int ASN1CALL ASN1Enc_VideoWindowCreatePDU_attributes_ElmFn(ASN1encoding_t enc, PVideoWindowCreatePDU_attributes val)
{
    if (!ASN1Enc_VideoWindowAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoWindowCreatePDU_attributes(ASN1decoding_t dec, PVideoWindowCreatePDU_attributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VideoWindowCreatePDU_attributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VideoWindowCreatePDU_attributes_ElmFn(ASN1decoding_t dec, PVideoWindowCreatePDU_attributes val)
{
    if (!ASN1Dec_VideoWindowAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VideoWindowCreatePDU_attributes(PVideoWindowCreatePDU_attributes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VideoWindowCreatePDU_attributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VideoWindowCreatePDU_attributes_ElmFn(PVideoWindowCreatePDU_attributes val)
{
    if (val) {
	ASN1Free_VideoWindowAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_cieLab(ASN1encoding_t enc, ColorSpaceSpecifier_cieLab *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ColorAccuracyEnhancementCIELab(enc, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_cieLab(ASN1decoding_t dec, ColorSpaceSpecifier_cieLab *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ColorAccuracyEnhancementCIELab(dec, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorSpaceSpecifier_cieLab(ColorSpaceSpecifier_cieLab *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorAccuracyEnhancementCIELab(&(val)->accuracyEnhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_rgb(ASN1encoding_t enc, ColorSpaceSpecifier_rgb *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ColorAccuracyEnhancementRGB(enc, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_rgb(ASN1decoding_t dec, ColorSpaceSpecifier_rgb *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ColorAccuracyEnhancementRGB(dec, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorSpaceSpecifier_rgb(ColorSpaceSpecifier_rgb *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorAccuracyEnhancementRGB(&(val)->accuracyEnhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_yCbCr(ASN1encoding_t enc, ColorSpaceSpecifier_yCbCr *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ColorAccuracyEnhancementYCbCr(enc, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_yCbCr(ASN1decoding_t dec, ColorSpaceSpecifier_yCbCr *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ColorAccuracyEnhancementYCbCr(dec, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorSpaceSpecifier_yCbCr(ColorSpaceSpecifier_yCbCr *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorAccuracyEnhancementYCbCr(&(val)->accuracyEnhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_ColorSpaceSpecifier_greyscale(ASN1encoding_t enc, ColorSpaceSpecifier_greyscale *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ColorAccuracyEnhancementGreyscale(enc, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorSpaceSpecifier_greyscale(ASN1decoding_t dec, ColorSpaceSpecifier_greyscale *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ColorAccuracyEnhancementGreyscale(dec, &(val)->accuracyEnhancement))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorSpaceSpecifier_greyscale(ColorSpaceSpecifier_greyscale *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorAccuracyEnhancementGreyscale(&(val)->accuracyEnhancement);
	}
    }
}

static int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable(ASN1encoding_t enc, ColorPalette_colorLookUpTable *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB(enc, &(val)->u.paletteRGB))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab(enc, &(val)->u.paletteCIELab))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr(enc, &(val)->u.paletteYCbCr))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardPalette))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable(ASN1decoding_t dec, ColorPalette_colorLookUpTable *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB(dec, &(val)->u.paletteRGB))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab(dec, &(val)->u.paletteCIELab))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr(dec, &(val)->u.paletteYCbCr))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardPalette))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable(ColorPalette_colorLookUpTable *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ColorPalette_colorLookUpTable_paletteRGB(&(val)->u.paletteRGB);
	    break;
	case 2:
	    ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab(&(val)->u.paletteCIELab);
	    break;
	case 3:
	    ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr(&(val)->u.paletteYCbCr);
	    break;
	case 4:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardPalette);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapAttribute(ASN1encoding_t enc, BitmapAttribute *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ViewState(enc, &(val)->u.viewState))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncExtensionBitClear(enc))
	    return 0;
	if (!ASN1PEREncBitVal(enc, 1, (val)->u.zOrder))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TransparencyMask(ee, &(val)->u.transparencyMask))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapAttribute(ASN1decoding_t dec, BitmapAttribute *val)
{
    ASN1uint32_t x;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ViewState(dec, &(val)->u.viewState))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecExtensionBit(dec, &x))
	    return 0;
	if (!x) {
	    if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *)&(val)->u.zOrder))
		return 0;
	} else {
	    if (!ASN1PERDecSkipNormallySmall(dec))
		return 0;
	}
	break;
    case 3:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TransparencyMask(dd, &(val)->u.transparencyMask))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapAttribute(BitmapAttribute *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ViewState(&(val)->u.viewState);
	    break;
	case 3:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAttribute);
	    break;
	case 4:
	    ASN1Free_TransparencyMask(&(val)->u.transparencyMask);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ColorPalette(ASN1encoding_t enc, ColorPalette *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ColorPalette_colorLookUpTable(enc, &(val)->colorLookUpTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->transparentEntry))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorPalette(ASN1decoding_t dec, ColorPalette *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ColorPalette_colorLookUpTable(dec, &(val)->colorLookUpTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->transparentEntry))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorPalette(ColorPalette *val)
{
    if (val) {
	ASN1Free_ColorPalette_colorLookUpTable(&(val)->colorLookUpTable);
    }
}

static int ASN1CALL ASN1Enc_ColorSpaceSpecifier(ASN1encoding_t enc, ColorSpaceSpecifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ColorSpaceSpecifier_greyscale(enc, &(val)->u.greyscale))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ColorSpaceSpecifier_yCbCr(enc, &(val)->u.yCbCr))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ColorSpaceSpecifier_rgb(enc, &(val)->u.rgb))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ColorSpaceSpecifier_cieLab(enc, &(val)->u.cieLab))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->u.nonStandardColorSpace))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ColorSpaceSpecifier(ASN1decoding_t dec, ColorSpaceSpecifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ColorSpaceSpecifier_greyscale(dec, &(val)->u.greyscale))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ColorSpaceSpecifier_yCbCr(dec, &(val)->u.yCbCr))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ColorSpaceSpecifier_rgb(dec, &(val)->u.rgb))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ColorSpaceSpecifier_cieLab(dec, &(val)->u.cieLab))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->u.nonStandardColorSpace))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ColorSpaceSpecifier(ColorSpaceSpecifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ColorSpaceSpecifier_greyscale(&(val)->u.greyscale);
	    break;
	case 2:
	    ASN1Free_ColorSpaceSpecifier_yCbCr(&(val)->u.yCbCr);
	    break;
	case 3:
	    ASN1Free_ColorSpaceSpecifier_rgb(&(val)->u.rgb);
	    break;
	case 4:
	    ASN1Free_ColorSpaceSpecifier_cieLab(&(val)->u.cieLab);
	    break;
	case 5:
	    ASN1Free_NonStandardIdentifier(&(val)->u.nonStandardColorSpace);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DrawingAttribute(ASN1encoding_t enc, DrawingAttribute *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_WorkspaceColor(enc, &(val)->u.penColor))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_WorkspaceColor(enc, &(val)->u.fillColor))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.penThickness - 1))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_PenNib(enc, &(val)->u.penNib))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_LineStyle(enc, &(val)->u.lineStyle))
	    return 0;
	break;
    case 6:
	if (!ASN1PEREncBoolean(enc, (val)->u.highlight))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_ViewState(enc, &(val)->u.viewState))
	    return 0;
	break;
    case 8:
	if (!ASN1PEREncExtensionBitClear(enc))
	    return 0;
	if (!ASN1PEREncBitVal(enc, 1, (val)->u.zOrder))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingAttribute(ASN1decoding_t dec, DrawingAttribute *val)
{
    ASN1uint32_t x;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_WorkspaceColor(dec, &(val)->u.penColor))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_WorkspaceColor(dec, &(val)->u.fillColor))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.penThickness))
	    return 0;
	(val)->u.penThickness += 1;
	break;
    case 4:
	if (!ASN1Dec_PenNib(dec, &(val)->u.penNib))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_LineStyle(dec, &(val)->u.lineStyle))
	    return 0;
	break;
    case 6:
	if (!ASN1PERDecBoolean(dec, &(val)->u.highlight))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_ViewState(dec, &(val)->u.viewState))
	    return 0;
	break;
    case 8:
	if (!ASN1PERDecExtensionBit(dec, &x))
	    return 0;
	if (!x) {
	    if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->u.zOrder))
		return 0;
	} else {
	    if (!ASN1PERDecSkipNormallySmall(dec))
		return 0;
	}
	break;
    case 9:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardAttribute))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DrawingAttribute(DrawingAttribute *val)
{
    if (val) {
	switch ((val)->choice) {
	case 4:
	    ASN1Free_PenNib(&(val)->u.penNib);
	    break;
	case 5:
	    ASN1Free_LineStyle(&(val)->u.lineStyle);
	    break;
	case 7:
	    ASN1Free_ViewState(&(val)->u.viewState);
	    break;
	case 9:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAttribute);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU(ASN1encoding_t enc, WorkspacePlaneCopyPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_WorkspaceIdentifier(enc, &(val)->sourceWorkspaceIdentifier))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sourcePlane))
	return 0;
    if (!ASN1Enc_WorkspaceIdentifier(enc, &(val)->destinationWorkspaceIdentifier))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->destinationPlane))
	return 0;
    if (!ASN1Enc_WorkspacePlaneCopyPDU_copyDescriptor(enc, &(val)->copyDescriptor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WorkspacePlaneCopyPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU(ASN1decoding_t dec, WorkspacePlaneCopyPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_WorkspaceIdentifier(dec, &(val)->sourceWorkspaceIdentifier))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sourcePlane))
	return 0;
    if (!ASN1Dec_WorkspaceIdentifier(dec, &(val)->destinationWorkspaceIdentifier))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->destinationPlane))
	return 0;
    if (!ASN1Dec_WorkspacePlaneCopyPDU_copyDescriptor(dec, &(val)->copyDescriptor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WorkspacePlaneCopyPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU(WorkspacePlaneCopyPDU *val)
{
    if (val) {
	ASN1Free_WorkspaceIdentifier(&(val)->sourceWorkspaceIdentifier);
	ASN1Free_WorkspaceIdentifier(&(val)->destinationWorkspaceIdentifier);
	ASN1Free_WorkspacePlaneCopyPDU_copyDescriptor(&(val)->copyDescriptor);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WorkspacePlaneCopyPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed_colorMappingMode_paletteMap(ASN1encoding_t enc, BitmapHeaderUncompressed_colorMappingMode_paletteMap *val)
{
    if (!ASN1Enc_ColorPalette(enc, &(val)->colorPalette))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->bitsPerPixel - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed_colorMappingMode_paletteMap(ASN1decoding_t dec, BitmapHeaderUncompressed_colorMappingMode_paletteMap *val)
{
    if (!ASN1Dec_ColorPalette(dec, &(val)->colorPalette))
	return 0;
    if (!ASN1PERDecU16Val(dec, 3, &(val)->bitsPerPixel))
	return 0;
    (val)->bitsPerPixel += 1;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderUncompressed_colorMappingMode_paletteMap(BitmapHeaderUncompressed_colorMappingMode_paletteMap *val)
{
    if (val) {
	ASN1Free_ColorPalette(&(val)->colorPalette);
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed_colorMappingMode_directMap(ASN1encoding_t enc, BitmapHeaderUncompressed_colorMappingMode_directMap *val)
{
    if (!ASN1Enc_ColorSpaceSpecifier(enc, &(val)->colorSpace))
	return 0;
    if (!ASN1Enc_ColorResolutionModeSpecifier(enc, &(val)->resolutionMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed_colorMappingMode_directMap(ASN1decoding_t dec, BitmapHeaderUncompressed_colorMappingMode_directMap *val)
{
    if (!ASN1Dec_ColorSpaceSpecifier(dec, &(val)->colorSpace))
	return 0;
    if (!ASN1Dec_ColorResolutionModeSpecifier(dec, &(val)->resolutionMode))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderUncompressed_colorMappingMode_directMap(BitmapHeaderUncompressed_colorMappingMode_directMap *val)
{
    if (val) {
	ASN1Free_ColorSpaceSpecifier(&(val)->colorSpace);
	ASN1Free_ColorResolutionModeSpecifier(&(val)->resolutionMode);
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap(ASN1encoding_t enc, BitmapHeaderT82_colorMappingMode_paletteMap *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ColorPalette(enc, &(val)->bitmapPalette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(enc, &(val)->progressiveMode))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap(ASN1decoding_t dec, BitmapHeaderT82_colorMappingMode_paletteMap *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ColorPalette(dec, &(val)->bitmapPalette))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(dec, &(val)->progressiveMode))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap(BitmapHeaderT82_colorMappingMode_paletteMap *val)
{
    if (val) {
	ASN1Free_ColorPalette(&(val)->bitmapPalette);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode(&(val)->progressiveMode);
	}
    }
}

static int ASN1CALL ASN1Enc_DrawingEditPDU_attributeEdits(ASN1encoding_t enc, PDrawingEditPDU_attributeEdits *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DrawingEditPDU_attributeEdits_ElmFn);
}

static int ASN1CALL ASN1Enc_DrawingEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PDrawingEditPDU_attributeEdits val)
{
    if (!ASN1Enc_DrawingAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingEditPDU_attributeEdits(ASN1decoding_t dec, PDrawingEditPDU_attributeEdits *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DrawingEditPDU_attributeEdits_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DrawingEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PDrawingEditPDU_attributeEdits val)
{
    if (!ASN1Dec_DrawingAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DrawingEditPDU_attributeEdits(PDrawingEditPDU_attributeEdits *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DrawingEditPDU_attributeEdits_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DrawingEditPDU_attributeEdits_ElmFn(PDrawingEditPDU_attributeEdits val)
{
    if (val) {
	ASN1Free_DrawingAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DrawingCreatePDU_attributes(ASN1encoding_t enc, PDrawingCreatePDU_attributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DrawingCreatePDU_attributes_ElmFn);
}

static int ASN1CALL ASN1Enc_DrawingCreatePDU_attributes_ElmFn(ASN1encoding_t enc, PDrawingCreatePDU_attributes val)
{
    if (!ASN1Enc_DrawingAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DrawingCreatePDU_attributes(ASN1decoding_t dec, PDrawingCreatePDU_attributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DrawingCreatePDU_attributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DrawingCreatePDU_attributes_ElmFn(ASN1decoding_t dec, PDrawingCreatePDU_attributes val)
{
    if (!ASN1Dec_DrawingAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DrawingCreatePDU_attributes(PDrawingCreatePDU_attributes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DrawingCreatePDU_attributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DrawingCreatePDU_attributes_ElmFn(PDrawingCreatePDU_attributes val)
{
    if (val) {
	ASN1Free_DrawingAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapEditPDU_attributeEdits(ASN1encoding_t enc, PBitmapEditPDU_attributeEdits *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapEditPDU_attributeEdits_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PBitmapEditPDU_attributeEdits val)
{
    if (!ASN1Enc_BitmapAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapEditPDU_attributeEdits(ASN1decoding_t dec, PBitmapEditPDU_attributeEdits *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapEditPDU_attributeEdits_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PBitmapEditPDU_attributeEdits val)
{
    if (!ASN1Dec_BitmapAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapEditPDU_attributeEdits(PBitmapEditPDU_attributeEdits *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapEditPDU_attributeEdits_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapEditPDU_attributeEdits_ElmFn(PBitmapEditPDU_attributeEdits val)
{
    if (val) {
	ASN1Free_BitmapAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU_attributes(ASN1encoding_t enc, PBitmapCreatePDU_attributes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BitmapCreatePDU_attributes_ElmFn);
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU_attributes_ElmFn(ASN1encoding_t enc, PBitmapCreatePDU_attributes val)
{
    if (!ASN1Enc_BitmapAttribute(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU_attributes(ASN1decoding_t dec, PBitmapCreatePDU_attributes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BitmapCreatePDU_attributes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU_attributes_ElmFn(ASN1decoding_t dec, PBitmapCreatePDU_attributes val)
{
    if (!ASN1Dec_BitmapAttribute(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCreatePDU_attributes(PBitmapCreatePDU_attributes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BitmapCreatePDU_attributes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BitmapCreatePDU_attributes_ElmFn(PBitmapCreatePDU_attributes val)
{
    if (val) {
	ASN1Free_BitmapAttribute(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode(ASN1encoding_t enc, BitmapHeaderT82_colorMappingMode *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ColorSpaceSpecifier(enc, &(val)->u.directMap))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap(enc, &(val)->u.paletteMap))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode(ASN1decoding_t dec, BitmapHeaderT82_colorMappingMode *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ColorSpaceSpecifier(dec, &(val)->u.directMap))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap(dec, &(val)->u.paletteMap))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode(BitmapHeaderT82_colorMappingMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ColorSpaceSpecifier(&(val)->u.directMap);
	    break;
	case 2:
	    ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap(&(val)->u.paletteMap);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed_colorMappingMode(ASN1encoding_t enc, BitmapHeaderUncompressed_colorMappingMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_BitmapHeaderUncompressed_colorMappingMode_directMap(enc, &(val)->u.directMap))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_BitmapHeaderUncompressed_colorMappingMode_paletteMap(enc, &(val)->u.paletteMap))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed_colorMappingMode(ASN1decoding_t dec, BitmapHeaderUncompressed_colorMappingMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_BitmapHeaderUncompressed_colorMappingMode_directMap(dec, &(val)->u.directMap))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_BitmapHeaderUncompressed_colorMappingMode_paletteMap(dec, &(val)->u.paletteMap))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderUncompressed_colorMappingMode(BitmapHeaderUncompressed_colorMappingMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_BitmapHeaderUncompressed_colorMappingMode_directMap(&(val)->u.directMap);
	    break;
	case 2:
	    ASN1Free_BitmapHeaderUncompressed_colorMappingMode_paletteMap(&(val)->u.paletteMap);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderUncompressed(ASN1encoding_t enc, BitmapHeaderUncompressed *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_BitmapHeaderUncompressed_colorMappingMode(enc, &(val)->colorMappingMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderUncompressed(ASN1decoding_t dec, BitmapHeaderUncompressed *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_BitmapHeaderUncompressed_colorMappingMode(dec, &(val)->colorMappingMode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderUncompressed(BitmapHeaderUncompressed *val)
{
    if (val) {
	ASN1Free_BitmapHeaderUncompressed_colorMappingMode(&(val)->colorMappingMode);
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderT81(ASN1encoding_t enc, BitmapHeaderT81 *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1Enc_ColorSpaceSpecifier(enc, &(val)->colorSpace))
	return 0;
    if (!ASN1Enc_ColorResolutionModeSpecifier(enc, &(val)->resolutionMode))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1Enc_ColorPalette(ee, &(val)->colorPalette))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT81(ASN1decoding_t dec, BitmapHeaderT81 *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_ColorSpaceSpecifier(dec, &(val)->colorSpace))
	return 0;
    if (!ASN1Dec_ColorResolutionModeSpecifier(dec, &(val)->resolutionMode))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_ColorPalette(dd, &(val)->colorPalette))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderT81(BitmapHeaderT81 *val)
{
    if (val) {
	ASN1Free_ColorSpaceSpecifier(&(val)->colorSpace);
	ASN1Free_ColorResolutionModeSpecifier(&(val)->resolutionMode);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ColorPalette(&(val)->colorPalette);
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapHeaderT82(ASN1encoding_t enc, BitmapHeaderT82 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_BitmapHeaderT82_colorMappingMode(enc, &(val)->colorMappingMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapHeaderT82(ASN1decoding_t dec, BitmapHeaderT82 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_BitmapHeaderT82_colorMappingMode(dec, &(val)->colorMappingMode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapHeaderT82(BitmapHeaderT82 *val)
{
    if (val) {
	ASN1Free_BitmapHeaderT82_colorMappingMode(&(val)->colorMappingMode);
    }
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU_bitmapFormatHeader(ASN1encoding_t enc, BitmapCreatePDU_bitmapFormatHeader *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_BitmapHeaderUncompressed(enc, &(val)->u.bitmapHeaderUncompressed))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_BitmapHeaderT4(enc, &(val)->u.bitmapHeaderT4))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_BitmapHeaderT6(enc, &(val)->u.bitmapHeaderT6))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_BitmapHeaderT81(enc, &(val)->u.bitmapHeaderT81))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_BitmapHeaderT82(enc, &(val)->u.bitmapHeaderT82))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.bitmapHeaderNonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU_bitmapFormatHeader(ASN1decoding_t dec, BitmapCreatePDU_bitmapFormatHeader *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_BitmapHeaderUncompressed(dec, &(val)->u.bitmapHeaderUncompressed))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_BitmapHeaderT4(dec, &(val)->u.bitmapHeaderT4))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_BitmapHeaderT6(dec, &(val)->u.bitmapHeaderT6))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_BitmapHeaderT81(dec, &(val)->u.bitmapHeaderT81))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_BitmapHeaderT82(dec, &(val)->u.bitmapHeaderT82))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.bitmapHeaderNonStandard))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCreatePDU_bitmapFormatHeader(BitmapCreatePDU_bitmapFormatHeader *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_BitmapHeaderUncompressed(&(val)->u.bitmapHeaderUncompressed);
	    break;
	case 4:
	    ASN1Free_BitmapHeaderT81(&(val)->u.bitmapHeaderT81);
	    break;
	case 5:
	    ASN1Free_BitmapHeaderT82(&(val)->u.bitmapHeaderT82);
	    break;
	case 6:
	    ASN1Free_NonStandardParameter(&(val)->u.bitmapHeaderNonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BitmapCreatePDU(ASN1encoding_t enc, BitmapCreatePDU *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->bitmapHandle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitmapHandle))
	return 0;
    if (!ASN1Enc_BitmapDestinationAddress(enc, &(val)->destinationAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_BitmapCreatePDU_attributes(enc, &(val)->attributes))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_WorkspacePoint(enc, &(val)->anchorPoint))
	    return 0;
    }
    if (!ASN1Enc_BitmapSize(enc, &(val)->bitmapSize))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_BitmapRegion(enc, &(val)->bitmapRegionOfInterest))
	    return 0;
    }
    if (!ASN1Enc_PixelAspectRatio(enc, &(val)->pixelAspectRatio))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_PointDiff16(enc, &(val)->scaling))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_BitmapCreatePDU_checkpoints(enc, &(val)->checkpoints))
	    return 0;
    }
    if (!ASN1Enc_BitmapCreatePDU_bitmapFormatHeader(enc, &(val)->bitmapFormatHeader))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_BitmapData(enc, &(val)->bitmapData))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->moreToFollow))
	return 0;
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_BitmapCreatePDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BitmapCreatePDU(ASN1decoding_t dec, BitmapCreatePDU *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitmapHandle))
	return 0;
    if (!ASN1Dec_BitmapDestinationAddress(dec, &(val)->destinationAddress))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_BitmapCreatePDU_attributes(dec, &(val)->attributes))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_WorkspacePoint(dec, &(val)->anchorPoint))
	    return 0;
    }
    if (!ASN1Dec_BitmapSize(dec, &(val)->bitmapSize))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_BitmapRegion(dec, &(val)->bitmapRegionOfInterest))
	    return 0;
    }
    if (!ASN1Dec_PixelAspectRatio(dec, &(val)->pixelAspectRatio))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_PointDiff16(dec, &(val)->scaling))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_BitmapCreatePDU_checkpoints(dec, &(val)->checkpoints))
	    return 0;
    }
    if (!ASN1Dec_BitmapCreatePDU_bitmapFormatHeader(dec, &(val)->bitmapFormatHeader))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_BitmapData(dec, &(val)->bitmapData))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->moreToFollow))
	return 0;
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_BitmapCreatePDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BitmapCreatePDU(BitmapCreatePDU *val)
{
    if (val) {
	ASN1Free_BitmapDestinationAddress(&(val)->destinationAddress);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_BitmapCreatePDU_attributes(&(val)->attributes);
	}
	ASN1Free_PixelAspectRatio(&(val)->pixelAspectRatio);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_BitmapCreatePDU_checkpoints(&(val)->checkpoints);
	}
	ASN1Free_BitmapCreatePDU_bitmapFormatHeader(&(val)->bitmapFormatHeader);
	if ((val)->o[0] & 0x4) {
	    ASN1Free_BitmapData(&(val)->bitmapData);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_BitmapCreatePDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_SIPDU(ASN1encoding_t enc, SIPDU *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 5, 28))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ArchiveAcknowledgePDU(enc, &(val)->u.archiveAcknowledgePDU))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ArchiveClosePDU(enc, &(val)->u.archiveClosePDU))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ArchiveErrorPDU(enc, &(val)->u.archiveErrorPDU))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ArchiveOpenPDU(enc, &(val)->u.archiveOpenPDU))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_BitmapAbortPDU(enc, &(val)->u.bitmapAbortPDU))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_BitmapCheckpointPDU(enc, &(val)->u.bitmapCheckpointPDU))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_BitmapCreatePDU(enc, &(val)->u.bitmapCreatePDU))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_BitmapCreateContinuePDU(enc, &(val)->u.bitmapCreateContinuePDU))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_BitmapDeletePDU(enc, &(val)->u.bitmapDeletePDU))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_BitmapEditPDU(enc, &(val)->u.bitmapEditPDU))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_ConductorPrivilegeGrantPDU(enc, &(val)->u.conductorPrivilegeGrantPDU))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_ConductorPrivilegeRequestPDU(enc, &(val)->u.conductorPrivilegeRequestPDU))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_DrawingCreatePDU(enc, &(val)->u.drawingCreatePDU))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_DrawingDeletePDU(enc, &(val)->u.drawingDeletePDU))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_DrawingEditPDU(enc, &(val)->u.drawingEditPDU))
	    return 0;
	break;
    case 16:
	if (!ASN1Enc_RemoteEventPermissionGrantPDU(enc, &(val)->u.remoteEventPermissionGrantPDU))
	    return 0;
	break;
    case 17:
	if (!ASN1Enc_RemoteEventPermissionRequestPDU(enc, &(val)->u.remoteEventPermissionRequestPDU))
	    return 0;
	break;
    case 18:
	if (!ASN1Enc_RemoteKeyboardEventPDU(enc, &(val)->u.remoteKeyboardEventPDU))
	    return 0;
	break;
    case 19:
	if (!ASN1Enc_RemotePointingDeviceEventPDU(enc, &(val)->u.remotePointingDeviceEventPDU))
	    return 0;
	break;
    case 20:
	if (!ASN1Enc_RemotePrintPDU(enc, &(val)->u.remotePrintPDU))
	    return 0;
	break;
    case 21:
	if (!ASN1Enc_SINonStandardPDU(enc, &(val)->u.siNonStandardPDU))
	    return 0;
	break;
    case 22:
	if (!ASN1Enc_WorkspaceCreatePDU(enc, &(val)->u.workspaceCreatePDU))
	    return 0;
	break;
    case 23:
	if (!ASN1Enc_WorkspaceCreateAcknowledgePDU(enc, &(val)->u.workspaceCreateAcknowledgePDU))
	    return 0;
	break;
    case 24:
	if (!ASN1Enc_WorkspaceDeletePDU(enc, &(val)->u.workspaceDeletePDU))
	    return 0;
	break;
    case 25:
	if (!ASN1Enc_WorkspaceEditPDU(enc, &(val)->u.workspaceEditPDU))
	    return 0;
	break;
    case 26:
	if (!ASN1Enc_WorkspacePlaneCopyPDU(enc, &(val)->u.workspacePlaneCopyPDU))
	    return 0;
	break;
    case 27:
	if (!ASN1Enc_WorkspaceReadyPDU(enc, &(val)->u.workspaceReadyPDU))
	    return 0;
	break;
    case 28:
	if (!ASN1Enc_WorkspaceRefreshStatusPDU(enc, &(val)->u.workspaceRefreshStatusPDU))
	    return 0;
	break;
    case 29:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_FontPDU(ee, &(val)->u.fontPDU))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 30:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TextCreatePDU(ee, &(val)->u.textCreatePDU))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 31:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TextDeletePDU(ee, &(val)->u.textDeletePDU))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 32:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TextEditPDU(ee, &(val)->u.textEditPDU))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 33:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_VideoWindowCreatePDU(ee, &(val)->u.videoWindowCreatePDU))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 34:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_VideoWindowDeletePDU(ee, &(val)->u.videoWindowDeleatePDU))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 35:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_VideoWindowEditPDU(ee, &(val)->u.videoWindowEditPDU))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SIPDU(ASN1decoding_t dec, SIPDU *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 5, 28))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ArchiveAcknowledgePDU(dec, &(val)->u.archiveAcknowledgePDU))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ArchiveClosePDU(dec, &(val)->u.archiveClosePDU))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ArchiveErrorPDU(dec, &(val)->u.archiveErrorPDU))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ArchiveOpenPDU(dec, &(val)->u.archiveOpenPDU))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_BitmapAbortPDU(dec, &(val)->u.bitmapAbortPDU))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_BitmapCheckpointPDU(dec, &(val)->u.bitmapCheckpointPDU))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_BitmapCreatePDU(dec, &(val)->u.bitmapCreatePDU))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_BitmapCreateContinuePDU(dec, &(val)->u.bitmapCreateContinuePDU))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_BitmapDeletePDU(dec, &(val)->u.bitmapDeletePDU))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_BitmapEditPDU(dec, &(val)->u.bitmapEditPDU))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_ConductorPrivilegeGrantPDU(dec, &(val)->u.conductorPrivilegeGrantPDU))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_ConductorPrivilegeRequestPDU(dec, &(val)->u.conductorPrivilegeRequestPDU))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_DrawingCreatePDU(dec, &(val)->u.drawingCreatePDU))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_DrawingDeletePDU(dec, &(val)->u.drawingDeletePDU))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_DrawingEditPDU(dec, &(val)->u.drawingEditPDU))
	    return 0;
	break;
    case 16:
	if (!ASN1Dec_RemoteEventPermissionGrantPDU(dec, &(val)->u.remoteEventPermissionGrantPDU))
	    return 0;
	break;
    case 17:
	if (!ASN1Dec_RemoteEventPermissionRequestPDU(dec, &(val)->u.remoteEventPermissionRequestPDU))
	    return 0;
	break;
    case 18:
	if (!ASN1Dec_RemoteKeyboardEventPDU(dec, &(val)->u.remoteKeyboardEventPDU))
	    return 0;
	break;
    case 19:
	if (!ASN1Dec_RemotePointingDeviceEventPDU(dec, &(val)->u.remotePointingDeviceEventPDU))
	    return 0;
	break;
    case 20:
	if (!ASN1Dec_RemotePrintPDU(dec, &(val)->u.remotePrintPDU))
	    return 0;
	break;
    case 21:
	if (!ASN1Dec_SINonStandardPDU(dec, &(val)->u.siNonStandardPDU))
	    return 0;
	break;
    case 22:
	if (!ASN1Dec_WorkspaceCreatePDU(dec, &(val)->u.workspaceCreatePDU))
	    return 0;
	break;
    case 23:
	if (!ASN1Dec_WorkspaceCreateAcknowledgePDU(dec, &(val)->u.workspaceCreateAcknowledgePDU))
	    return 0;
	break;
    case 24:
	if (!ASN1Dec_WorkspaceDeletePDU(dec, &(val)->u.workspaceDeletePDU))
	    return 0;
	break;
    case 25:
	if (!ASN1Dec_WorkspaceEditPDU(dec, &(val)->u.workspaceEditPDU))
	    return 0;
	break;
    case 26:
	if (!ASN1Dec_WorkspacePlaneCopyPDU(dec, &(val)->u.workspacePlaneCopyPDU))
	    return 0;
	break;
    case 27:
	if (!ASN1Dec_WorkspaceReadyPDU(dec, &(val)->u.workspaceReadyPDU))
	    return 0;
	break;
    case 28:
	if (!ASN1Dec_WorkspaceRefreshStatusPDU(dec, &(val)->u.workspaceRefreshStatusPDU))
	    return 0;
	break;
    case 29:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_FontPDU(dd, &(val)->u.fontPDU))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 30:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TextCreatePDU(dd, &(val)->u.textCreatePDU))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 31:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TextDeletePDU(dd, &(val)->u.textDeletePDU))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 32:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_TextEditPDU(dd, &(val)->u.textEditPDU))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 33:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_VideoWindowCreatePDU(dd, &(val)->u.videoWindowCreatePDU))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 34:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_VideoWindowDeletePDU(dd, &(val)->u.videoWindowDeleatePDU))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 35:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
	    return 0;
	if (!ASN1Dec_VideoWindowEditPDU(dd, &(val)->u.videoWindowEditPDU))
	    return 0;
	ASN1_CloseDecoder(dd);
	ASN1Free(db);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SIPDU(SIPDU *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ArchiveAcknowledgePDU(&(val)->u.archiveAcknowledgePDU);
	    break;
	case 2:
	    ASN1Free_ArchiveClosePDU(&(val)->u.archiveClosePDU);
	    break;
	case 3:
	    ASN1Free_ArchiveErrorPDU(&(val)->u.archiveErrorPDU);
	    break;
	case 4:
	    ASN1Free_ArchiveOpenPDU(&(val)->u.archiveOpenPDU);
	    break;
	case 5:
	    ASN1Free_BitmapAbortPDU(&(val)->u.bitmapAbortPDU);
	    break;
	case 6:
	    ASN1Free_BitmapCheckpointPDU(&(val)->u.bitmapCheckpointPDU);
	    break;
	case 7:
	    ASN1Free_BitmapCreatePDU(&(val)->u.bitmapCreatePDU);
	    break;
	case 8:
	    ASN1Free_BitmapCreateContinuePDU(&(val)->u.bitmapCreateContinuePDU);
	    break;
	case 9:
	    ASN1Free_BitmapDeletePDU(&(val)->u.bitmapDeletePDU);
	    break;
	case 10:
	    ASN1Free_BitmapEditPDU(&(val)->u.bitmapEditPDU);
	    break;
	case 11:
	    ASN1Free_ConductorPrivilegeGrantPDU(&(val)->u.conductorPrivilegeGrantPDU);
	    break;
	case 12:
	    ASN1Free_ConductorPrivilegeRequestPDU(&(val)->u.conductorPrivilegeRequestPDU);
	    break;
	case 13:
	    ASN1Free_DrawingCreatePDU(&(val)->u.drawingCreatePDU);
	    break;
	case 14:
	    ASN1Free_DrawingDeletePDU(&(val)->u.drawingDeletePDU);
	    break;
	case 15:
	    ASN1Free_DrawingEditPDU(&(val)->u.drawingEditPDU);
	    break;
	case 16:
	    ASN1Free_RemoteEventPermissionGrantPDU(&(val)->u.remoteEventPermissionGrantPDU);
	    break;
	case 17:
	    ASN1Free_RemoteEventPermissionRequestPDU(&(val)->u.remoteEventPermissionRequestPDU);
	    break;
	case 18:
	    ASN1Free_RemoteKeyboardEventPDU(&(val)->u.remoteKeyboardEventPDU);
	    break;
	case 19:
	    ASN1Free_RemotePointingDeviceEventPDU(&(val)->u.remotePointingDeviceEventPDU);
	    break;
	case 20:
	    ASN1Free_RemotePrintPDU(&(val)->u.remotePrintPDU);
	    break;
	case 21:
	    ASN1Free_SINonStandardPDU(&(val)->u.siNonStandardPDU);
	    break;
	case 22:
	    ASN1Free_WorkspaceCreatePDU(&(val)->u.workspaceCreatePDU);
	    break;
	case 23:
	    ASN1Free_WorkspaceCreateAcknowledgePDU(&(val)->u.workspaceCreateAcknowledgePDU);
	    break;
	case 24:
	    ASN1Free_WorkspaceDeletePDU(&(val)->u.workspaceDeletePDU);
	    break;
	case 25:
	    ASN1Free_WorkspaceEditPDU(&(val)->u.workspaceEditPDU);
	    break;
	case 26:
	    ASN1Free_WorkspacePlaneCopyPDU(&(val)->u.workspacePlaneCopyPDU);
	    break;
	case 27:
	    ASN1Free_WorkspaceReadyPDU(&(val)->u.workspaceReadyPDU);
	    break;
	case 28:
	    ASN1Free_WorkspaceRefreshStatusPDU(&(val)->u.workspaceRefreshStatusPDU);
	    break;
	case 29:
	    ASN1Free_FontPDU(&(val)->u.fontPDU);
	    break;
	case 30:
	    ASN1Free_TextCreatePDU(&(val)->u.textCreatePDU);
	    break;
	case 31:
	    ASN1Free_TextDeletePDU(&(val)->u.textDeletePDU);
	    break;
	case 32:
	    ASN1Free_TextEditPDU(&(val)->u.textEditPDU);
	    break;
	case 33:
	    ASN1Free_VideoWindowCreatePDU(&(val)->u.videoWindowCreatePDU);
	    break;
	case 34:
	    ASN1Free_VideoWindowDeletePDU(&(val)->u.videoWindowDeleatePDU);
	    break;
	case 35:
	    ASN1Free_VideoWindowEditPDU(&(val)->u.videoWindowEditPDU);
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\t126.h ===
/* Copyright (C) Microsoft Corporation, 1998-1999. All rights reserved. */
/* ASN.1 definitions for Whiteboard */

#ifndef _T126_Module_H_
#define _T126_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes * PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes;

typedef struct WorkspaceEditPDU_planeEdits * PWorkspaceEditPDU_planeEdits;

typedef struct WorkspaceCreatePDU_viewParameters * PWorkspaceCreatePDU_viewParameters;

typedef struct WorkspaceCreatePDU_planeParameters * PWorkspaceCreatePDU_planeParameters;

typedef struct WorkspaceCreatePDU_protectedPlaneAccessList * PWorkspaceCreatePDU_protectedPlaneAccessList;

typedef struct BitmapCreatePDU_checkpoints * PBitmapCreatePDU_checkpoints;

typedef struct BitmapCheckpointPDU_passedCheckpoints * PBitmapCheckpointPDU_passedCheckpoints;

typedef struct EditablePlaneCopyDescriptor_objectList * PEditablePlaneCopyDescriptor_objectList;

typedef struct BitmapData_dataCheckpoint * PBitmapData_dataCheckpoint;

typedef struct ColorIndexTable * PColorIndexTable;

typedef struct WorkspaceCreatePDU_planeParameters_Seq_usage * PWorkspaceCreatePDU_planeParameters_Seq_usage;

typedef struct ColorPalette_colorLookUpTable_paletteRGB_palette * PColorPalette_colorLookUpTable_paletteRGB_palette;

typedef struct ColorPalette_colorLookUpTable_paletteCIELab_palette * PColorPalette_colorLookUpTable_paletteCIELab_palette;

typedef struct ColorPalette_colorLookUpTable_paletteYCbCr_palette * PColorPalette_colorLookUpTable_paletteYCbCr_palette;

typedef struct WorkspaceRefreshStatusPDU_nonStandardParameters * PWorkspaceRefreshStatusPDU_nonStandardParameters;

typedef struct WorkspaceReadyPDU_nonStandardParameters * PWorkspaceReadyPDU_nonStandardParameters;

typedef struct WorkspacePlaneCopyPDU_nonStandardParameters * PWorkspacePlaneCopyPDU_nonStandardParameters;

typedef struct WorkspaceEditPDU_nonStandardParameters * PWorkspaceEditPDU_nonStandardParameters;

typedef struct WorkspaceEditPDU_viewEdits * PWorkspaceEditPDU_viewEdits;

typedef struct WorkspaceDeletePDU_nonStandardParameters * PWorkspaceDeletePDU_nonStandardParameters;

typedef struct WorkspaceCreateAcknowledgePDU_nonStandardParameters * PWorkspaceCreateAcknowledgePDU_nonStandardParameters;

typedef struct WorkspaceCreatePDU_nonStandardParameters * PWorkspaceCreatePDU_nonStandardParameters;

typedef struct TextEditPDU_nonStandardParameters * PTextEditPDU_nonStandardParameters;

typedef struct TextDeletePDU_nonStandardParameters * PTextDeletePDU_nonStandardParameters;

typedef struct TextCreatePDU_nonStandardParameters * PTextCreatePDU_nonStandardParameters;

typedef struct RemotePrintPDU_nonStandardParameters * PRemotePrintPDU_nonStandardParameters;

typedef struct RemotePointingDeviceEventPDU_nonStandardParameters * PRemotePointingDeviceEventPDU_nonStandardParameters;

typedef struct RemoteKeyboardEventPDU_nonStandardParameters * PRemoteKeyboardEventPDU_nonStandardParameters;

typedef struct RemoteEventPermissionRequestPDU_nonStandardParameters * PRemoteEventPermissionRequestPDU_nonStandardParameters;

typedef struct RemoteEventPermissionRequestPDU_remoteEventPermissionList * PRemoteEventPermissionRequestPDU_remoteEventPermissionList;

typedef struct RemoteEventPermissionGrantPDU_nonStandardParameters * PRemoteEventPermissionGrantPDU_nonStandardParameters;

typedef struct RemoteEventPermissionGrantPDU_remoteEventPermissionList * PRemoteEventPermissionGrantPDU_remoteEventPermissionList;

typedef struct FontPDU_nonStandardParameters * PFontPDU_nonStandardParameters;

typedef struct DrawingEditPDU_nonStandardParameters * PDrawingEditPDU_nonStandardParameters;

typedef struct DrawingDeletePDU_nonStandardParameters * PDrawingDeletePDU_nonStandardParameters;

typedef struct DrawingCreatePDU_nonStandardParameters * PDrawingCreatePDU_nonStandardParameters;

typedef struct ConductorPrivilegeRequestPDU_nonStandardParameters * PConductorPrivilegeRequestPDU_nonStandardParameters;

typedef struct ConductorPrivilegeGrantPDU_nonStandardParameters * PConductorPrivilegeGrantPDU_nonStandardParameters;

typedef struct BitmapEditPDU_nonStandardParameters * PBitmapEditPDU_nonStandardParameters;

typedef struct BitmapDeletePDU_nonStandardParameters * PBitmapDeletePDU_nonStandardParameters;

typedef struct BitmapCreateContinuePDU_nonStandardParameters * PBitmapCreateContinuePDU_nonStandardParameters;

typedef struct BitmapCreatePDU_nonStandardParameters * PBitmapCreatePDU_nonStandardParameters;

typedef struct BitmapCheckpointPDU_nonStandardParameters * PBitmapCheckpointPDU_nonStandardParameters;

typedef struct BitmapAbortPDU_nonStandardParameters * PBitmapAbortPDU_nonStandardParameters;

typedef struct ArchiveOpenPDU_nonStandardParameters * PArchiveOpenPDU_nonStandardParameters;

typedef struct ArchiveErrorPDU_nonStandardParameters * PArchiveErrorPDU_nonStandardParameters;

typedef struct ArchiveClosePDU_nonStandardParameters * PArchiveClosePDU_nonStandardParameters;

typedef struct ArchiveAcknowledgePDU_nonStandardParameters * PArchiveAcknowledgePDU_nonStandardParameters;

typedef struct VideoWindowEditPDU_nonStandardParameters * PVideoWindowEditPDU_nonStandardParameters;

typedef struct VideoWindowDeletePDU_nonStandardParameters * PVideoWindowDeletePDU_nonStandardParameters;

typedef struct VideoWindowCreatePDU_nonStandardParameters * PVideoWindowCreatePDU_nonStandardParameters;

typedef struct VideoSourceIdentifier_dSMCCConnBinder * PVideoSourceIdentifier_dSMCCConnBinder;

typedef struct TransparencyMask_nonStandardParameters * PTransparencyMask_nonStandardParameters;

typedef struct PointList_pointsDiff16 * PPointList_pointsDiff16;

typedef struct PointList_pointsDiff8 * PPointList_pointsDiff8;

typedef struct PointList_pointsDiff4 * PPointList_pointsDiff4;

typedef struct WorkspaceEditPDU_viewEdits_Set_action_editView * PWorkspaceEditPDU_viewEdits_Set_action_editView;

typedef struct WorkspaceEditPDU_viewEdits_Set_action_createNewView * PWorkspaceEditPDU_viewEdits_Set_action_createNewView;

typedef struct WorkspaceEditPDU_planeEdits_Set_planeAttributes * PWorkspaceEditPDU_planeEdits_Set_planeAttributes;

typedef struct WorkspaceCreatePDU_viewParameters_Set_viewAttributes * PWorkspaceCreatePDU_viewParameters_Set_viewAttributes;

typedef struct WorkspaceCreatePDU_planeParameters_Seq_planeAttributes * PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes;

typedef struct WorkspaceEditPDU_attributeEdits * PWorkspaceEditPDU_attributeEdits;

typedef struct WorkspaceCreatePDU_workspaceAttributes * PWorkspaceCreatePDU_workspaceAttributes;

typedef struct RemoteKeyboardEventPDU_keyModifierStates * PRemoteKeyboardEventPDU_keyModifierStates;

typedef struct ConductorPrivilegeRequestPDU_privilegeList * PConductorPrivilegeRequestPDU_privilegeList;

typedef struct ConductorPrivilegeGrantPDU_privilegeList * PConductorPrivilegeGrantPDU_privilegeList;

typedef struct VideoWindowEditPDU_attributeEdits * PVideoWindowEditPDU_attributeEdits;

typedef struct VideoWindowCreatePDU_attributes * PVideoWindowCreatePDU_attributes;

typedef struct DrawingEditPDU_attributeEdits * PDrawingEditPDU_attributeEdits;

typedef struct DrawingCreatePDU_attributes * PDrawingCreatePDU_attributes;

typedef struct BitmapEditPDU_attributeEdits * PBitmapEditPDU_attributeEdits;

typedef struct BitmapCreatePDU_attributes * PBitmapCreatePDU_attributes;

typedef ASN1uint16_t ColorIndexTable_Seq;

typedef ASN1char16string_t ArchiveEntryName;

typedef ASN1char16string_t ArchiveName;

typedef ASN1uint16_t DataPlaneID;

typedef ASN1uint32_t Handle;

typedef ASN1uint16_t MCSUserID;

typedef struct H221NonStandardIdentifier {
    ASN1uint32_t length;
    ASN1octet_t value[255];
} H221NonStandardIdentifier;

typedef ASN1uint16_t PenThickness;

typedef ASN1uint16_t TokenID;

typedef ASN1int32_t WorkspaceCoordinate;

typedef enum ZOrder {
    front = 0,
    back = 1,
} ZOrder;

typedef struct BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes {
    PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes next;
    PColorIndexTable value;
} BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_Element;

typedef struct BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode {
    ASN1choice_t choice;
    union {
#	define progressivePalettes_chosen 1
	PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes progressivePalettes;
#	define selfProgressive_chosen 2
    } u;
} BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode;

typedef struct ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut {
    ASN1int16_t lSpan;
    ASN1int16_t lOffset;
    ASN1int16_t aSpan;
    ASN1int16_t aOffset;
    ASN1int16_t bSpan;
    ASN1int16_t bOffset;
} ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut;

typedef struct EditablePlaneCopyDescriptor_objectList_Seq {
    Handle sourceObjectHandle;
    Handle destinationObjectHandle;
} EditablePlaneCopyDescriptor_objectList_Seq;

typedef struct WorkspaceCreatePDU_planeParameters_Seq {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t editable;
    PWorkspaceCreatePDU_planeParameters_Seq_usage usage;
#   define planeAttributes_present 0x80
    PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes planeAttributes;
} WorkspaceCreatePDU_planeParameters_Seq;

typedef struct WorkspaceCreatePDU_viewParameters_Set {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle viewHandle;
#   define viewAttributes_present 0x80
    PWorkspaceCreatePDU_viewParameters_Set_viewAttributes viewAttributes;
} WorkspaceCreatePDU_viewParameters_Set;

typedef struct WorkspaceEditPDU_planeEdits_Set {
    DataPlaneID plane;
    PWorkspaceEditPDU_planeEdits_Set_planeAttributes planeAttributes;
} WorkspaceEditPDU_planeEdits_Set;

typedef struct WorkspaceEditPDU_planeEdits {
    PWorkspaceEditPDU_planeEdits next;
    WorkspaceEditPDU_planeEdits_Set value;
} WorkspaceEditPDU_planeEdits_Element;

typedef struct WorkspaceCreatePDU_viewParameters {
    PWorkspaceCreatePDU_viewParameters next;
    WorkspaceCreatePDU_viewParameters_Set value;
} WorkspaceCreatePDU_viewParameters_Element;

typedef struct WorkspaceCreatePDU_planeParameters {
    PWorkspaceCreatePDU_planeParameters next;
    WorkspaceCreatePDU_planeParameters_Seq value;
} WorkspaceCreatePDU_planeParameters_Element;

typedef struct WorkspaceCreatePDU_protectedPlaneAccessList {
    PWorkspaceCreatePDU_protectedPlaneAccessList next;
    MCSUserID value;
} WorkspaceCreatePDU_protectedPlaneAccessList_Element;

typedef struct BitmapCreatePDU_checkpoints {
    PBitmapCreatePDU_checkpoints next;
    TokenID value;
} BitmapCreatePDU_checkpoints_Element;

typedef struct BitmapCheckpointPDU_passedCheckpoints {
    PBitmapCheckpointPDU_passedCheckpoints next;
    TokenID value;
} BitmapCheckpointPDU_passedCheckpoints_Element;

typedef struct WorkspaceIdentifier_archiveWorkspace {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle archiveHandle;
    ArchiveEntryName entryName;
#   define modificationTime_present 0x80
    ASN1generalizedtime_t modificationTime;
} WorkspaceIdentifier_archiveWorkspace;

typedef struct PixelAspectRatio_general {
    ASN1uint16_t numerator;
    ASN1uint16_t denominator;
} PixelAspectRatio_general;

typedef struct EditablePlaneCopyDescriptor_objectList {
    PEditablePlaneCopyDescriptor_objectList next;
    EditablePlaneCopyDescriptor_objectList_Seq value;
} EditablePlaneCopyDescriptor_objectList_Element;

typedef struct ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters_gamma_present 0x80
    double gamma;
} ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters;

typedef struct ColorAccuracyEnhancementCIELab_generalCIELabParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorAccuracyEnhancementCIELab_generalCIELabParameters_colorTemperature_present 0x80
    ASN1uint32_t colorTemperature;
#   define gamut_present 0x40
    ColorAccuracyEnhancementCIELab_generalCIELabParameters_gamut gamut;
} ColorAccuracyEnhancementCIELab_generalCIELabParameters;

typedef struct BitmapRegion_lowerRight {
    ASN1uint16_t xCoordinate;
    ASN1uint16_t yCoordinate;
} BitmapRegion_lowerRight;

typedef struct BitmapRegion_upperLeft {
    ASN1uint16_t xCoordinate;
    ASN1uint16_t yCoordinate;
} BitmapRegion_upperLeft;

typedef struct BitmapData_dataCheckpoint {
    PBitmapData_dataCheckpoint next;
    TokenID value;
} BitmapData_dataCheckpoint_Element;

typedef struct ArchiveHeader {
    ArchiveName archiveName;
    ASN1generalizedtime_t archiveCreationTime;
    ASN1generalizedtime_t archiveModificationTime;
} ArchiveHeader;

typedef struct ArchiveMode {
    ASN1bool_t create;
    ASN1bool_t read;
    ASN1bool_t write;
} ArchiveMode;

typedef struct BitmapData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define dataCheckpoint_present 0x80
    PBitmapData_dataCheckpoint dataCheckpoint;
#   define padBits_present 0x40
    ASN1uint16_t padBits;
    struct BitmapData_data_data {
	ASN1uint32_t length;
	ASN1octet_t value[8192];
    } data;
} BitmapData;

typedef struct BitmapHeaderT4 {
    ASN1bool_t twoDimensionalEncoding;
} BitmapHeaderT4;

typedef struct BitmapHeaderT6 {
    char placeholder;
} BitmapHeaderT6;

typedef struct BitmapRegion {
    BitmapRegion_upperLeft upperLeft;
    BitmapRegion_lowerRight lowerRight;
} BitmapRegion;

typedef struct BitmapSize {
    ASN1uint32_t width;
    ASN1uint32_t height;
} BitmapSize;

typedef struct ColorCIELab {
    ASN1uint16_t l;
    ASN1uint16_t a;
    ASN1uint16_t b;
} ColorCIELab;

typedef struct ColorCIExyChromaticity {
    double x;
    double y;
} ColorCIExyChromaticity;

typedef struct ColorIndexTable {
    PColorIndexTable next;
    ColorIndexTable_Seq value;
} ColorIndexTable_Element;

typedef struct ColorRGB {
    ASN1uint16_t r;
    ASN1uint16_t g;
    ASN1uint16_t b;
} ColorRGB;

typedef struct ColorYCbCr {
    ASN1uint16_t y;
    ASN1uint16_t cb;
    ASN1uint16_t cr;
} ColorYCbCr;

typedef struct DSMCCTap {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t use;
    ASN1uint16_t id;
    ASN1uint16_t associationTag;
#   define selector_present 0x80
    struct DSMCCTap_selector_selector {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } selector;
} DSMCCTap;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221nonStandard_chosen 2
	H221NonStandardIdentifier h221nonStandard;
    } u;
} NonStandardIdentifier;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct PenNib {
    ASN1choice_t choice;
    union {
#	define circular_chosen 1
#	define PenNib_square_chosen 2
#	define nonStandardNib_chosen 3
	NonStandardIdentifier nonStandardNib;
    } u;
} PenNib;

typedef struct PixelAspectRatio {
    ASN1choice_t choice;
    union {
#	define PixelAspectRatio_square_chosen 1
#	define cif_chosen 2
#	define fax1_chosen 3
#	define fax2_chosen 4
#	define general_chosen 5
	PixelAspectRatio_general general;
#	define nonStandardAspectRatio_chosen 6
	NonStandardIdentifier nonStandardAspectRatio;
    } u;
} PixelAspectRatio;

typedef struct PlaneProtection {
    ASN1bool_t protectedplane;
} PlaneProtection;

typedef struct PlaneUsage {
    ASN1choice_t choice;
    union {
#	define annotation_chosen 1
#	define image_chosen 2
#	define nonStandardPlaneUsage_chosen 3
	NonStandardIdentifier nonStandardPlaneUsage;
    } u;
} PlaneUsage;

typedef struct PointList {
    ASN1choice_t choice;
    union {
#	define pointsDiff4_chosen 1
	PPointList_pointsDiff4 pointsDiff4;
#	define pointsDiff8_chosen 2
	PPointList_pointsDiff8 pointsDiff8;
#	define pointsDiff16_chosen 3
	PPointList_pointsDiff16 pointsDiff16;
    } u;
} PointList;

typedef struct PointDiff4 {
    ASN1int8_t xCoordinate;
    ASN1int8_t yCoordinate;
} PointDiff4;

typedef struct PointDiff8 {
    ASN1int8_t xCoordinate;
    ASN1int8_t yCoordinate;
} PointDiff8;

typedef struct PointDiff16 {
    ASN1int16_t xCoordinate;
    ASN1int16_t yCoordinate;
} PointDiff16;

typedef struct RemoteEventDestinationAddress {
    ASN1choice_t choice;
    union {
#	define softCopyWorkspace_chosen 1
	Handle softCopyWorkspace;
#	define RemoteEventDestinationAddress_nonStandardDestination_chosen 2
	NonStandardParameter nonStandardDestination;
    } u;
} RemoteEventDestinationAddress;

typedef struct RemoteEventPermission {
    ASN1choice_t choice;
    union {
#	define keyboardEvent_chosen 1
#	define pointingDeviceEvent_chosen 2
#	define nonStandardEvent_chosen 3
	NonStandardIdentifier nonStandardEvent;
    } u;
} RemoteEventPermission;

typedef struct RotationSpecifier {
    ASN1uint16_t rotationAngle;
    PointDiff16 rotationAxis;
} RotationSpecifier;

typedef struct SoftCopyDataPlaneAddress {
    Handle workspaceHandle;
    DataPlaneID plane;
} SoftCopyDataPlaneAddress;

typedef struct SoftCopyPointerPlaneAddress {
    Handle workspaceHandle;
} SoftCopyPointerPlaneAddress;

typedef struct SourceDisplayIndicator {
    double displayAspectRatio;
    double horizontalSizeRatio;
    double horizontalPosition;
    double verticalPosition;
} SourceDisplayIndicator;

typedef struct VideoWindowDestinationAddress {
    ASN1choice_t choice;
    union {
#	define VideoWindowDestinationAddress_softCopyImagePlane_chosen 1
	SoftCopyDataPlaneAddress softCopyImagePlane;
#	define VideoWindowDestinationAddress_nonStandardDestination_chosen 2
	NonStandardParameter nonStandardDestination;
    } u;
} VideoWindowDestinationAddress;

typedef struct VideoSourceIdentifier {
    ASN1choice_t choice;
    union {
#	define VideoSourceIdentifier_default_chosen 1
#	define h243SourceIdentifier_chosen 2
	struct VideoSourceIdentifier_h243SourceIdentifier_h243SourceIdentifier {
	    ASN1uint32_t length;
	    ASN1octet_t value[2];
	} h243SourceIdentifier;
#	define h245SourceIdentifier_chosen 3
	ASN1uint16_t h245SourceIdentifier;
#	define dSMCCConnBinder_chosen 4
	PVideoSourceIdentifier_dSMCCConnBinder dSMCCConnBinder;
#	define videoIdentifier_chosen 5
	struct VideoSourceIdentifier_videoIdentifier_videoIdentifier {
	    ASN1uint32_t length;
	    ASN1octet_t value[256];
	} videoIdentifier;
#	define nonStandardSourceIdentifier_chosen 6
	NonStandardParameter nonStandardSourceIdentifier;
    } u;
} VideoSourceIdentifier;

typedef struct VideoWindowDeletePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle videoWindowHandle;
#   define VideoWindowDeletePDU_nonStandardParameters_present 0x80
    PVideoWindowDeletePDU_nonStandardParameters nonStandardParameters;
} VideoWindowDeletePDU;

typedef struct ViewState {
    ASN1choice_t choice;
    union {
#	define unselected_chosen 1
#	define selected_chosen 2
#	define ViewState_hidden_chosen 3
#	define nonStandardViewState_chosen 4
	NonStandardIdentifier nonStandardViewState;
    } u;
} ViewState;

typedef struct WorkspaceColor {
    ASN1choice_t choice;
    union {
#	define workspacePaletteIndex_chosen 1
	ASN1uint16_t workspacePaletteIndex;
#	define rgbTrueColor_chosen 2
	ColorRGB rgbTrueColor;
#	define transparent_chosen 3
    } u;
} WorkspaceColor;

typedef struct WorkspaceDeleteReason {
    ASN1choice_t choice;
    union {
#	define userInitiated_chosen 1
#	define insufficientStorage_chosen 2
#	define WorkspaceDeleteReason_nonStandardReason_chosen 3
	NonStandardParameter nonStandardReason;
    } u;
} WorkspaceDeleteReason;

typedef struct WorkspaceIdentifier {
    ASN1choice_t choice;
    union {
#	define activeWorkspace_chosen 1
	Handle activeWorkspace;
#	define archiveWorkspace_chosen 2
	WorkspaceIdentifier_archiveWorkspace archiveWorkspace;
    } u;
} WorkspaceIdentifier;

typedef struct WorkspacePoint {
    WorkspaceCoordinate xCoordinate;
    WorkspaceCoordinate yCoordinate;
} WorkspacePoint;

typedef struct WorkspaceRegion {
    WorkspacePoint upperLeft;
    WorkspacePoint lowerRight;
} WorkspaceRegion;

typedef struct WorkspaceSize {
    ASN1uint16_t width;
    ASN1uint16_t height;
} WorkspaceSize;

typedef struct WorkspaceViewState {
    ASN1choice_t choice;
    union {
#	define WorkspaceViewState_hidden_chosen 1
#	define background_chosen 2
#	define foreground_chosen 3
#	define focus_chosen 4
#	define nonStandardState_chosen 5
	NonStandardIdentifier nonStandardState;
    } u;
} WorkspaceViewState;

typedef struct ArchiveClosePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle archiveHandle;
#   define ArchiveClosePDU_nonStandardParameters_present 0x80
    PArchiveClosePDU_nonStandardParameters nonStandardParameters;
} ArchiveClosePDU;

typedef struct ArchiveOpenPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle archiveHandle;
    ArchiveMode mode;
    ArchiveHeader header;
#   define maxEntries_present 0x80
    ASN1uint16_t maxEntries;
#   define ArchiveOpenPDU_nonStandardParameters_present 0x40
    PArchiveOpenPDU_nonStandardParameters nonStandardParameters;
} ArchiveOpenPDU;

typedef struct BitmapCheckpointPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle bitmapHandle;
    PBitmapCheckpointPDU_passedCheckpoints passedCheckpoints;
    ASN1uint16_t percentComplete;
#   define BitmapCheckpointPDU_nonStandardParameters_present 0x80
    PBitmapCheckpointPDU_nonStandardParameters nonStandardParameters;
} BitmapCheckpointPDU;

typedef struct BitmapCreateContinuePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle bitmapHandle;
    BitmapData bitmapData;
    ASN1bool_t moreToFollow;
#   define BitmapCreateContinuePDU_nonStandardParameters_present 0x80
    PBitmapCreateContinuePDU_nonStandardParameters nonStandardParameters;
} BitmapCreateContinuePDU;

typedef struct BitmapDeletePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle bitmapHandle;
#   define BitmapDeletePDU_nonStandardParameters_present 0x80
    PBitmapDeletePDU_nonStandardParameters nonStandardParameters;
} BitmapDeletePDU;

typedef struct BitmapEditPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle bitmapHandle;
#   define BitmapEditPDU_attributeEdits_present 0x80
    PBitmapEditPDU_attributeEdits attributeEdits;
#   define BitmapEditPDU_anchorPointEdit_present 0x40
    WorkspacePoint anchorPointEdit;
#   define bitmapRegionOfInterestEdit_present 0x20
    BitmapRegion bitmapRegionOfInterestEdit;
#   define BitmapEditPDU_scalingEdit_present 0x10
    PointDiff16 scalingEdit;
#   define BitmapEditPDU_nonStandardParameters_present 0x8
    PBitmapEditPDU_nonStandardParameters nonStandardParameters;
} BitmapEditPDU;

typedef struct ConductorPrivilegeGrantPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    MCSUserID destinationUserID;
    PConductorPrivilegeGrantPDU_privilegeList privilegeList;
#   define ConductorPrivilegeGrantPDU_nonStandardParameters_present 0x80
    PConductorPrivilegeGrantPDU_nonStandardParameters nonStandardParameters;
} ConductorPrivilegeGrantPDU;

typedef struct ConductorPrivilegeRequestPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PConductorPrivilegeRequestPDU_privilegeList privilegeList;
#   define ConductorPrivilegeRequestPDU_nonStandardParameters_present 0x80
    PConductorPrivilegeRequestPDU_nonStandardParameters nonStandardParameters;
} ConductorPrivilegeRequestPDU;

typedef struct DrawingDeletePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle drawingHandle;
#   define DrawingDeletePDU_nonStandardParameters_present 0x80
    PDrawingDeletePDU_nonStandardParameters nonStandardParameters;
} DrawingDeletePDU;

typedef struct FontPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define FontPDU_nonStandardParameters_present 0x80
    PFontPDU_nonStandardParameters nonStandardParameters;
} FontPDU;

typedef struct RemoteEventPermissionGrantPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RemoteEventDestinationAddress destinationAddress;
    MCSUserID destinationUserID;
    PRemoteEventPermissionGrantPDU_remoteEventPermissionList remoteEventPermissionList;
#   define RemoteEventPermissionGrantPDU_nonStandardParameters_present 0x80
    PRemoteEventPermissionGrantPDU_nonStandardParameters nonStandardParameters;
} RemoteEventPermissionGrantPDU;

typedef struct RemoteEventPermissionRequestPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RemoteEventDestinationAddress destinationAddress;
    PRemoteEventPermissionRequestPDU_remoteEventPermissionList remoteEventPermissionList;
#   define RemoteEventPermissionRequestPDU_nonStandardParameters_present 0x80
    PRemoteEventPermissionRequestPDU_nonStandardParameters nonStandardParameters;
} RemoteEventPermissionRequestPDU;

typedef struct RemotePrintPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RemoteEventDestinationAddress destinationAddress;
#   define numberOfCopies_present 0x80
    ASN1uint32_t numberOfCopies;
#   define portrait_present 0x40
    ASN1bool_t portrait;
#   define regionOfInterest_present 0x20
    WorkspaceRegion regionOfInterest;
#   define RemotePrintPDU_nonStandardParameters_present 0x10
    PRemotePrintPDU_nonStandardParameters nonStandardParameters;
} RemotePrintPDU;

typedef struct SINonStandardPDU {
    NonStandardParameter nonStandardTransaction;
} SINonStandardPDU;

typedef struct TextCreatePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TextCreatePDU_nonStandardParameters_present 0x80
    PTextCreatePDU_nonStandardParameters nonStandardParameters;
} TextCreatePDU;

typedef struct TextDeletePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TextDeletePDU_nonStandardParameters_present 0x80
    PTextDeletePDU_nonStandardParameters nonStandardParameters;
} TextDeletePDU;

typedef struct TextEditPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TextEditPDU_nonStandardParameters_present 0x80
    PTextEditPDU_nonStandardParameters nonStandardParameters;
} TextEditPDU;

typedef struct WorkspaceCreatePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    WorkspaceIdentifier workspaceIdentifier;
    ASN1uint16_t appRosterInstance;
    ASN1bool_t synchronized;
    ASN1bool_t acceptKeyboardEvents;
    ASN1bool_t acceptPointingDeviceEvents;
#   define protectedPlaneAccessList_present 0x80
    PWorkspaceCreatePDU_protectedPlaneAccessList protectedPlaneAccessList;
    WorkspaceSize workspaceSize;
#   define workspaceAttributes_present 0x40
    PWorkspaceCreatePDU_workspaceAttributes workspaceAttributes;
    PWorkspaceCreatePDU_planeParameters planeParameters;
#   define viewParameters_present 0x20
    PWorkspaceCreatePDU_viewParameters viewParameters;
#   define WorkspaceCreatePDU_nonStandardParameters_present 0x10
    PWorkspaceCreatePDU_nonStandardParameters nonStandardParameters;
} WorkspaceCreatePDU;

typedef struct WorkspaceCreateAcknowledgePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    WorkspaceIdentifier workspaceIdentifier;
#   define WorkspaceCreateAcknowledgePDU_nonStandardParameters_present 0x80
    PWorkspaceCreateAcknowledgePDU_nonStandardParameters nonStandardParameters;
} WorkspaceCreateAcknowledgePDU;

typedef struct WorkspaceDeletePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    WorkspaceIdentifier workspaceIdentifier;
    WorkspaceDeleteReason reason;
#   define WorkspaceDeletePDU_nonStandardParameters_present 0x80
    PWorkspaceDeletePDU_nonStandardParameters nonStandardParameters;
} WorkspaceDeletePDU;

typedef struct WorkspaceEditPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    WorkspaceIdentifier workspaceIdentifier;
#   define WorkspaceEditPDU_attributeEdits_present 0x80
    PWorkspaceEditPDU_attributeEdits attributeEdits;
#   define planeEdits_present 0x40
    PWorkspaceEditPDU_planeEdits planeEdits;
#   define viewEdits_present 0x20
    PWorkspaceEditPDU_viewEdits viewEdits;
#   define WorkspaceEditPDU_nonStandardParameters_present 0x10
    PWorkspaceEditPDU_nonStandardParameters nonStandardParameters;
} WorkspaceEditPDU;

typedef struct WorkspaceReadyPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    WorkspaceIdentifier workspaceIdentifier;
#   define WorkspaceReadyPDU_nonStandardParameters_present 0x80
    PWorkspaceReadyPDU_nonStandardParameters nonStandardParameters;
} WorkspaceReadyPDU;

typedef struct WorkspaceRefreshStatusPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t refreshStatus;
#   define WorkspaceRefreshStatusPDU_nonStandardParameters_present 0x80
    PWorkspaceRefreshStatusPDU_nonStandardParameters nonStandardParameters;
} WorkspaceRefreshStatusPDU;

typedef struct WorkspaceEditPDU_viewEdits_Set_action {
    ASN1choice_t choice;
    union {
#	define createNewView_chosen 1
	PWorkspaceEditPDU_viewEdits_Set_action_createNewView createNewView;
#	define editView_chosen 2
	PWorkspaceEditPDU_viewEdits_Set_action_editView editView;
#	define deleteView_chosen 3
#	define nonStandardAction_chosen 4
	NonStandardParameter nonStandardAction;
    } u;
} WorkspaceEditPDU_viewEdits_Set_action;

typedef struct WorkspaceCreatePDU_planeParameters_Seq_usage {
    PWorkspaceCreatePDU_planeParameters_Seq_usage next;
    PlaneUsage value;
} WorkspaceCreatePDU_planeParameters_Seq_usage_Element;

typedef struct ColorPalette_colorLookUpTable_paletteRGB_palette {
    PColorPalette_colorLookUpTable_paletteRGB_palette next;
    ColorRGB value;
} ColorPalette_colorLookUpTable_paletteRGB_palette_Element;

typedef struct ColorPalette_colorLookUpTable_paletteCIELab_palette {
    PColorPalette_colorLookUpTable_paletteCIELab_palette next;
    ColorCIELab value;
} ColorPalette_colorLookUpTable_paletteCIELab_palette_Element;

typedef struct ColorPalette_colorLookUpTable_paletteYCbCr_palette {
    PColorPalette_colorLookUpTable_paletteYCbCr_palette next;
    ColorYCbCr value;
} ColorPalette_colorLookUpTable_paletteYCbCr_palette_Element;

typedef struct ColorAccuracyEnhancementRGB_generalRGBParameters_primaries {
    ColorCIExyChromaticity red;
    ColorCIExyChromaticity green;
    ColorCIExyChromaticity blue;
} ColorAccuracyEnhancementRGB_generalRGBParameters_primaries;

typedef struct ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries {
    ColorCIExyChromaticity red;
    ColorCIExyChromaticity green;
    ColorCIExyChromaticity blue;
} ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries;

typedef struct WorkspaceEditPDU_viewEdits_Set {
    Handle viewHandle;
    WorkspaceEditPDU_viewEdits_Set_action action;
} WorkspaceEditPDU_viewEdits_Set;

typedef struct WorkspaceRefreshStatusPDU_nonStandardParameters {
    PWorkspaceRefreshStatusPDU_nonStandardParameters next;
    NonStandardParameter value;
} WorkspaceRefreshStatusPDU_nonStandardParameters_Element;

typedef struct WorkspaceReadyPDU_nonStandardParameters {
    PWorkspaceReadyPDU_nonStandardParameters next;
    NonStandardParameter value;
} WorkspaceReadyPDU_nonStandardParameters_Element;

typedef struct WorkspacePlaneCopyPDU_nonStandardParameters {
    PWorkspacePlaneCopyPDU_nonStandardParameters next;
    NonStandardParameter value;
} WorkspacePlaneCopyPDU_nonStandardParameters_Element;

typedef struct WorkspaceEditPDU_nonStandardParameters {
    PWorkspaceEditPDU_nonStandardParameters next;
    NonStandardParameter value;
} WorkspaceEditPDU_nonStandardParameters_Element;

typedef struct WorkspaceEditPDU_viewEdits {
    PWorkspaceEditPDU_viewEdits next;
    WorkspaceEditPDU_viewEdits_Set value;
} WorkspaceEditPDU_viewEdits_Element;

typedef struct WorkspaceDeletePDU_nonStandardParameters {
    PWorkspaceDeletePDU_nonStandardParameters next;
    NonStandardParameter value;
} WorkspaceDeletePDU_nonStandardParameters_Element;

typedef struct WorkspaceCreateAcknowledgePDU_nonStandardParameters {
    PWorkspaceCreateAcknowledgePDU_nonStandardParameters next;
    NonStandardParameter value;
} WorkspaceCreateAcknowledgePDU_nonStandardParameters_Element;

typedef struct WorkspaceCreatePDU_nonStandardParameters {
    PWorkspaceCreatePDU_nonStandardParameters next;
    NonStandardParameter value;
} WorkspaceCreatePDU_nonStandardParameters_Element;

typedef struct TextEditPDU_nonStandardParameters {
    PTextEditPDU_nonStandardParameters next;
    NonStandardParameter value;
} TextEditPDU_nonStandardParameters_Element;

typedef struct TextDeletePDU_nonStandardParameters {
    PTextDeletePDU_nonStandardParameters next;
    NonStandardParameter value;
} TextDeletePDU_nonStandardParameters_Element;

typedef struct TextCreatePDU_nonStandardParameters {
    PTextCreatePDU_nonStandardParameters next;
    NonStandardParameter value;
} TextCreatePDU_nonStandardParameters_Element;

typedef struct RemotePrintPDU_nonStandardParameters {
    PRemotePrintPDU_nonStandardParameters next;
    NonStandardParameter value;
} RemotePrintPDU_nonStandardParameters_Element;

typedef struct RemotePointingDeviceEventPDU_nonStandardParameters {
    PRemotePointingDeviceEventPDU_nonStandardParameters next;
    NonStandardParameter value;
} RemotePointingDeviceEventPDU_nonStandardParameters_Element;

typedef struct RemoteKeyboardEventPDU_nonStandardParameters {
    PRemoteKeyboardEventPDU_nonStandardParameters next;
    NonStandardParameter value;
} RemoteKeyboardEventPDU_nonStandardParameters_Element;

typedef struct RemoteEventPermissionRequestPDU_nonStandardParameters {
    PRemoteEventPermissionRequestPDU_nonStandardParameters next;
    NonStandardParameter value;
} RemoteEventPermissionRequestPDU_nonStandardParameters_Element;

typedef struct RemoteEventPermissionRequestPDU_remoteEventPermissionList {
    PRemoteEventPermissionRequestPDU_remoteEventPermissionList next;
    RemoteEventPermission value;
} RemoteEventPermissionRequestPDU_remoteEventPermissionList_Element;

typedef struct RemoteEventPermissionGrantPDU_nonStandardParameters {
    PRemoteEventPermissionGrantPDU_nonStandardParameters next;
    NonStandardParameter value;
} RemoteEventPermissionGrantPDU_nonStandardParameters_Element;

typedef struct RemoteEventPermissionGrantPDU_remoteEventPermissionList {
    PRemoteEventPermissionGrantPDU_remoteEventPermissionList next;
    RemoteEventPermission value;
} RemoteEventPermissionGrantPDU_remoteEventPermissionList_Element;

typedef struct FontPDU_nonStandardParameters {
    PFontPDU_nonStandardParameters next;
    NonStandardParameter value;
} FontPDU_nonStandardParameters_Element;

typedef struct DrawingEditPDU_nonStandardParameters {
    PDrawingEditPDU_nonStandardParameters next;
    NonStandardParameter value;
} DrawingEditPDU_nonStandardParameters_Element;

typedef struct DrawingDeletePDU_nonStandardParameters {
    PDrawingDeletePDU_nonStandardParameters next;
    NonStandardParameter value;
} DrawingDeletePDU_nonStandardParameters_Element;

typedef struct DrawingCreatePDU_nonStandardParameters {
    PDrawingCreatePDU_nonStandardParameters next;
    NonStandardParameter value;
} DrawingCreatePDU_nonStandardParameters_Element;

typedef struct ConductorPrivilegeRequestPDU_nonStandardParameters {
    PConductorPrivilegeRequestPDU_nonStandardParameters next;
    NonStandardParameter value;
} ConductorPrivilegeRequestPDU_nonStandardParameters_Element;

typedef struct ConductorPrivilegeGrantPDU_nonStandardParameters {
    PConductorPrivilegeGrantPDU_nonStandardParameters next;
    NonStandardParameter value;
} ConductorPrivilegeGrantPDU_nonStandardParameters_Element;

typedef struct BitmapEditPDU_nonStandardParameters {
    PBitmapEditPDU_nonStandardParameters next;
    NonStandardParameter value;
} BitmapEditPDU_nonStandardParameters_Element;

typedef struct BitmapDeletePDU_nonStandardParameters {
    PBitmapDeletePDU_nonStandardParameters next;
    NonStandardParameter value;
} BitmapDeletePDU_nonStandardParameters_Element;

typedef struct BitmapCreateContinuePDU_nonStandardParameters {
    PBitmapCreateContinuePDU_nonStandardParameters next;
    NonStandardParameter value;
} BitmapCreateContinuePDU_nonStandardParameters_Element;

typedef struct BitmapCreatePDU_nonStandardParameters {
    PBitmapCreatePDU_nonStandardParameters next;
    NonStandardParameter value;
} BitmapCreatePDU_nonStandardParameters_Element;

typedef struct BitmapCheckpointPDU_nonStandardParameters {
    PBitmapCheckpointPDU_nonStandardParameters next;
    NonStandardParameter value;
} BitmapCheckpointPDU_nonStandardParameters_Element;

typedef struct BitmapAbortPDU_nonStandardParameters {
    PBitmapAbortPDU_nonStandardParameters next;
    NonStandardParameter value;
} BitmapAbortPDU_nonStandardParameters_Element;

typedef struct ArchiveOpenPDU_nonStandardParameters {
    PArchiveOpenPDU_nonStandardParameters next;
    NonStandardParameter value;
} ArchiveOpenPDU_nonStandardParameters_Element;

typedef struct ArchiveErrorPDU_nonStandardParameters {
    PArchiveErrorPDU_nonStandardParameters next;
    NonStandardParameter value;
} ArchiveErrorPDU_nonStandardParameters_Element;

typedef struct ArchiveClosePDU_nonStandardParameters {
    PArchiveClosePDU_nonStandardParameters next;
    NonStandardParameter value;
} ArchiveClosePDU_nonStandardParameters_Element;

typedef struct ArchiveAcknowledgePDU_nonStandardParameters {
    PArchiveAcknowledgePDU_nonStandardParameters next;
    NonStandardParameter value;
} ArchiveAcknowledgePDU_nonStandardParameters_Element;

typedef struct WorkspaceViewAttribute_viewRegion {
    ASN1choice_t choice;
    union {
#	define fullWorkspace_chosen 1
#	define partialWorkspace_chosen 2
	WorkspaceRegion partialWorkspace;
    } u;
} WorkspaceViewAttribute_viewRegion;

typedef struct VideoWindowEditPDU_nonStandardParameters {
    PVideoWindowEditPDU_nonStandardParameters next;
    NonStandardParameter value;
} VideoWindowEditPDU_nonStandardParameters_Element;

typedef struct VideoWindowDeletePDU_nonStandardParameters {
    PVideoWindowDeletePDU_nonStandardParameters next;
    NonStandardParameter value;
} VideoWindowDeletePDU_nonStandardParameters_Element;

typedef struct VideoWindowCreatePDU_nonStandardParameters {
    PVideoWindowCreatePDU_nonStandardParameters next;
    NonStandardParameter value;
} VideoWindowCreatePDU_nonStandardParameters_Element;

typedef struct VideoSourceIdentifier_dSMCCConnBinder {
    PVideoSourceIdentifier_dSMCCConnBinder next;
    DSMCCTap value;
} VideoSourceIdentifier_dSMCCConnBinder_Element;

typedef struct TransparencyMask_nonStandardParameters {
    PTransparencyMask_nonStandardParameters next;
    NonStandardParameter value;
} TransparencyMask_nonStandardParameters_Element;

typedef struct TransparencyMask_bitMask {
    ASN1choice_t choice;
    union {
#	define uncompressed_chosen 1
	ASN1octetstring_t uncompressed;
#	define jbigCompressed_chosen 2
	ASN1octetstring_t jbigCompressed;
#	define nonStandardFormat_chosen 3
	NonStandardParameter nonStandardFormat;
    } u;
} TransparencyMask_bitMask;

typedef struct PointListEdits_Seq {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t initialIndex;
    PointDiff16 initialPointEdit;
#   define subsequentPointEdits_present 0x80
    PointList subsequentPointEdits;
} PointListEdits_Seq;

typedef struct PointList_pointsDiff16 {
    PPointList_pointsDiff16 next;
    PointDiff16 value;
} PointList_pointsDiff16_Element;

typedef struct PointList_pointsDiff8 {
    PPointList_pointsDiff8 next;
    PointDiff8 value;
} PointList_pointsDiff8_Element;

typedef struct PointList_pointsDiff4 {
    PPointList_pointsDiff4 next;
    PointDiff4 value;
} PointList_pointsDiff4_Element;

typedef struct ColorAccuracyEnhancementYCbCr_generalYCbCrParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_gamma_present 0x80
    double gamma;
#   define ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_colorTemperature_present 0x40
    ASN1uint32_t colorTemperature;
#   define ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries_present 0x20
    ColorAccuracyEnhancementYCbCr_generalYCbCrParameters_primaries primaries;
} ColorAccuracyEnhancementYCbCr_generalYCbCrParameters;

typedef struct ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace {
    ASN1choice_t choice;
    union {
#	define cCIR709_chosen 1
#	define ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace_nonStandardRGBSpace_chosen 2
	NonStandardParameter nonStandardRGBSpace;
    } u;
} ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace;

typedef struct ColorAccuracyEnhancementRGB_generalRGBParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorAccuracyEnhancementRGB_generalRGBParameters_gamma_present 0x80
    double gamma;
#   define ColorAccuracyEnhancementRGB_generalRGBParameters_colorTemperature_present 0x40
    ASN1uint32_t colorTemperature;
#   define ColorAccuracyEnhancementRGB_generalRGBParameters_primaries_present 0x20
    ColorAccuracyEnhancementRGB_generalRGBParameters_primaries primaries;
} ColorAccuracyEnhancementRGB_generalRGBParameters;

typedef struct ColorAccuracyEnhancementRGB_predefinedRGBSpace {
    ASN1choice_t choice;
    union {
#	define ColorAccuracyEnhancementRGB_predefinedRGBSpace_nonStandardRGBSpace_chosen 1
	NonStandardParameter nonStandardRGBSpace;
    } u;
} ColorAccuracyEnhancementRGB_predefinedRGBSpace;

typedef struct ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace {
    ASN1choice_t choice;
    union {
#	define nonStandardGreyscaleSpace_chosen 1
	NonStandardParameter nonStandardGreyscaleSpace;
    } u;
} ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace;

typedef struct ColorAccuracyEnhancementCIELab_predefinedCIELabSpace {
    ASN1choice_t choice;
    union {
#	define nonStandardCIELabSpace_chosen 1
	NonStandardParameter nonStandardCIELabSpace;
    } u;
} ColorAccuracyEnhancementCIELab_predefinedCIELabSpace;

typedef struct ArchiveError {
    ASN1choice_t choice;
    union {
#	define entryNotFound_chosen 1
#	define entryExists_chosen 2
#	define ArchiveError_storageExceeded_chosen 3
#	define archiveNoLongerAvailable_chosen 4
#	define ArchiveError_unspecifiedError_chosen 5
#	define nonStandardError_chosen 6
	NonStandardIdentifier nonStandardError;
    } u;
} ArchiveError;

typedef struct ArchiveOpenResult {
    ASN1choice_t choice;
    union {
#	define archiveOpenSuccessful_chosen 1
#	define archiveNotFound_chosen 2
#	define archiveTimeIncorrect_chosen 3
	ArchiveHeader archiveTimeIncorrect;
#	define archiveExists_chosen 4
#	define archiveOpenForWriting_chosen 5
#	define ArchiveOpenResult_storageExceeded_chosen 6
#	define ArchiveOpenResult_unspecifiedError_chosen 7
#	define nonStandardResult_chosen 8
	NonStandardIdentifier nonStandardResult;
    } u;
} ArchiveOpenResult;

typedef struct BitmapAbortReason {
    ASN1choice_t choice;
    union {
#	define unspecified_chosen 1
#	define noResources_chosen 2
#	define outOfPaper_chosen 3
#	define BitmapAbortReason_nonStandardReason_chosen 4
	NonStandardParameter nonStandardReason;
    } u;
} BitmapAbortReason;

typedef struct BitmapDestinationAddress {
    ASN1choice_t choice;
    union {
#	define hardCopyDevice_chosen 1
#	define BitmapDestinationAddress_softCopyImagePlane_chosen 2
	SoftCopyDataPlaneAddress softCopyImagePlane;
#	define BitmapDestinationAddress_softCopyAnnotationPlane_chosen 3
	SoftCopyDataPlaneAddress softCopyAnnotationPlane;
#	define softCopyPointerPlane_chosen 4
	SoftCopyPointerPlaneAddress softCopyPointerPlane;
#	define BitmapDestinationAddress_nonStandardDestination_chosen 5
	NonStandardParameter nonStandardDestination;
    } u;
} BitmapDestinationAddress;

typedef struct ButtonEvent {
    ASN1choice_t choice;
    union {
#	define buttonUp_chosen 1
#	define buttonDown_chosen 2
#	define buttonDoubleClick_chosen 3
#	define buttonTripleClick_chosen 4
#	define buttonQuadClick_chosen 5
#	define nonStandardButtonEvent_chosen 6
	NonStandardIdentifier nonStandardButtonEvent;
    } u;
} ButtonEvent;

typedef struct ColorAccuracyEnhancementCIELab {
    ASN1choice_t choice;
    union {
#	define predefinedCIELabSpace_chosen 1
	ColorAccuracyEnhancementCIELab_predefinedCIELabSpace predefinedCIELabSpace;
#	define generalCIELabParameters_chosen 2
	ColorAccuracyEnhancementCIELab_generalCIELabParameters generalCIELabParameters;
    } u;
} ColorAccuracyEnhancementCIELab;

typedef struct ColorAccuracyEnhancementGreyscale {
    ASN1choice_t choice;
    union {
#	define predefinedGreyscaleSpace_chosen 1
	ColorAccuracyEnhancementGreyscale_predefinedGreyscaleSpace predefinedGreyscaleSpace;
#	define generalGreyscaleParameters_chosen 2
	ColorAccuracyEnhancementGreyscale_generalGreyscaleParameters generalGreyscaleParameters;
    } u;
} ColorAccuracyEnhancementGreyscale;

typedef struct ColorAccuracyEnhancementRGB {
    ASN1choice_t choice;
    union {
#	define predefinedRGBSpace_chosen 1
	ColorAccuracyEnhancementRGB_predefinedRGBSpace predefinedRGBSpace;
#	define generalRGBParameters_chosen 2
	ColorAccuracyEnhancementRGB_generalRGBParameters generalRGBParameters;
    } u;
} ColorAccuracyEnhancementRGB;

typedef struct ColorAccuracyEnhancementYCbCr {
    ASN1choice_t choice;
    union {
#	define predefinedYCbCrSpace_chosen 1
	ColorAccuracyEnhancementYCbCr_predefinedYCbCrSpace predefinedYCbCrSpace;
#	define generalYCbCrParameters_chosen 2
	ColorAccuracyEnhancementYCbCr_generalYCbCrParameters generalYCbCrParameters;
    } u;
} ColorAccuracyEnhancementYCbCr;

typedef struct ColorResolutionModeSpecifier {
    ASN1choice_t choice;
    union {
#	define resolution4_4_4_chosen 1
#	define resolution_4_2_2_chosen 2
#	define resolution_4_2_0_chosen 3
#	define nonStandardResolutionMode_chosen 4
	NonStandardIdentifier nonStandardResolutionMode;
    } u;
} ColorResolutionModeSpecifier;

typedef struct ConductorPrivilege {
    ASN1choice_t choice;
    union {
#	define workspacePrivilege_chosen 1
#	define annotationPrivilege_chosen 2
#	define imagePrivilege_chosen 3
#	define pointingPrivilege_chosen 4
#	define remoteKeyEventPrivilege_chosen 5
#	define remotePointingEventPrivilege_chosen 6
#	define remotePrintingPrivilege_chosen 7
#	define archiveCreateWritePrivilege_chosen 8
#	define nonStandardPrivilege_chosen 9
	NonStandardIdentifier nonStandardPrivilege;
    } u;
} ConductorPrivilege;

typedef struct DrawingDestinationAddress {
    ASN1choice_t choice;
    union {
#	define DrawingDestinationAddress_softCopyAnnotationPlane_chosen 1
	SoftCopyDataPlaneAddress softCopyAnnotationPlane;
#	define DrawingDestinationAddress_nonStandardDestination_chosen 2
	NonStandardParameter nonStandardDestination;
    } u;
} DrawingDestinationAddress;

typedef struct DrawingType {
    ASN1choice_t choice;
    union {
#	define point_chosen 1
#	define openPolyLine_chosen 2
#	define closedPolyLine_chosen 3
#	define rectangle_chosen 4
#	define ellipse_chosen 5
#	define nonStandardDrawingType_chosen 6
	NonStandardIdentifier nonStandardDrawingType;
    } u;
} DrawingType;

typedef struct EditablePlaneCopyDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PEditablePlaneCopyDescriptor_objectList objectList;
#   define destinationOffset_present 0x80
    PointDiff16 destinationOffset;
    ASN1bool_t planeClearFlag;
} EditablePlaneCopyDescriptor;

typedef struct KeyCode {
    ASN1choice_t choice;
    union {
#	define character_chosen 1
	ASN1char16string_t character;
#	define fkey_chosen 2
	ASN1uint16_t fkey;
#	define upArrow_chosen 3
#	define downArrow_chosen 4
#	define leftArrow_chosen 5
#	define rightArrow_chosen 6
#	define pageUp_chosen 7
#	define pageDown_chosen 8
#	define home_chosen 9
#	define end_chosen 10
#	define insert_chosen 11
#	define KeyCode_delete_chosen 12
#	define nonStandardKey_chosen 13
	NonStandardIdentifier nonStandardKey;
    } u;
} KeyCode;

typedef struct KeyModifier {
    ASN1choice_t choice;
    union {
#	define leftAlt_chosen 1
#	define rightAlt_chosen 2
#	define leftShift_chosen 3
#	define rightShift_chosen 4
#	define leftControl_chosen 5
#	define rightControl_chosen 6
#	define leftSpecial_chosen 7
#	define rightSpecial_chosen 8
#	define numberPad_chosen 9
#	define scrollLock_chosen 10
#	define nonStandardModifier_chosen 11
	NonStandardIdentifier nonStandardModifier;
    } u;
} KeyModifier;

typedef struct KeyPressState {
    ASN1choice_t choice;
    union {
#	define none_chosen 1
#	define keyPress_chosen 2
#	define keyDown_chosen 3
#	define keyUp_chosen 4
#	define nonStandardKeyPressState_chosen 5
	NonStandardIdentifier nonStandardKeyPressState;
    } u;
} KeyPressState;

typedef struct LineStyle {
    ASN1choice_t choice;
    union {
#	define solid_chosen 1
#	define dashed_chosen 2
#	define dotted_chosen 3
#	define dash_dot_chosen 4
#	define dash_dot_dot_chosen 5
#	define two_tone_chosen 6
#	define nonStandardStyle_chosen 7
	NonStandardIdentifier nonStandardStyle;
    } u;
} LineStyle;

typedef struct PermanentPlaneCopyDescriptor {
    WorkspaceRegion sourceRegion;
    WorkspaceRegion destinationRegion;
} PermanentPlaneCopyDescriptor;

typedef struct PlaneAttribute {
    ASN1choice_t choice;
    union {
#	define protection_chosen 1
	PlaneProtection protection;
#	define PlaneAttribute_nonStandardAttribute_chosen 2
	NonStandardParameter nonStandardAttribute;
    } u;
} PlaneAttribute;

typedef struct PointListEdits {
    ASN1uint32_t count;
    PointListEdits_Seq value[255];
} PointListEdits;

typedef struct TransparencyMask {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    TransparencyMask_bitMask bitMask;
#   define TransparencyMask_nonStandardParameters_present 0x80
    PTransparencyMask_nonStandardParameters nonStandardParameters;
} TransparencyMask;

typedef struct VideoWindowAttribute {
    ASN1choice_t choice;
    union {
#	define VideoWindowAttribute_transparencyMask_chosen 1
	TransparencyMask transparencyMask;
#	define VideoWindowAttribute_nonStandardAttribute_chosen 2
	NonStandardParameter nonStandardAttribute;
    } u;
} VideoWindowAttribute;

typedef struct VideoWindowCreatePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle videoWindowHandle;
    VideoWindowDestinationAddress destinationAddress;
    VideoSourceIdentifier videoSourceIdentifier;
#   define VideoWindowCreatePDU_attributes_present 0x80
    PVideoWindowCreatePDU_attributes attributes;
#   define VideoWindowCreatePDU_anchorPoint_present 0x40
    WorkspacePoint anchorPoint;
    BitmapSize videoWindowSize;
#   define videoWindowRegionOfInterest_present 0x20
    BitmapRegion videoWindowRegionOfInterest;
    PixelAspectRatio pixelAspectRatio;
#   define VideoWindowCreatePDU_scaling_present 0x10
    PointDiff16 scaling;
#   define VideoWindowCreatePDU_nonStandardParameters_present 0x8
    PVideoWindowCreatePDU_nonStandardParameters nonStandardParameters;
} VideoWindowCreatePDU;

typedef struct VideoWindowEditPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle videoWindowHandle;
#   define videoSourceIdentifierEdit_present 0x80
    VideoSourceIdentifier videoSourceIdentifierEdit;
#   define VideoWindowEditPDU_attributeEdits_present 0x40
    PVideoWindowEditPDU_attributeEdits attributeEdits;
#   define VideoWindowEditPDU_anchorPointEdit_present 0x20
    WorkspacePoint anchorPointEdit;
    BitmapSize videoWindowSize;
#   define videoWindowRegionOfInterestEdit_present 0x10
    BitmapRegion videoWindowRegionOfInterestEdit;
#   define pixelAspectRatioEdit_present 0x8
    PixelAspectRatio pixelAspectRatioEdit;
#   define VideoWindowEditPDU_scalingEdit_present 0x4
    PointDiff16 scalingEdit;
#   define VideoWindowEditPDU_nonStandardParameters_present 0x2
    PVideoWindowEditPDU_nonStandardParameters nonStandardParameters;
} VideoWindowEditPDU;

typedef struct WorkspaceAttribute {
    ASN1choice_t choice;
    union {
#	define backgroundColor_chosen 1
	WorkspaceColor backgroundColor;
#	define preserve_chosen 2
	ASN1bool_t preserve;
#	define WorkspaceAttribute_nonStandardAttribute_chosen 3
	NonStandardParameter nonStandardAttribute;
    } u;
} WorkspaceAttribute;

typedef struct WorkspaceViewAttribute {
    ASN1choice_t choice;
    union {
#	define viewRegion_chosen 1
	WorkspaceViewAttribute_viewRegion viewRegion;
#	define WorkspaceViewAttribute_viewState_chosen 2
	WorkspaceViewState viewState;
#	define updatesEnabled_chosen 3
	ASN1bool_t updatesEnabled;
#	define sourceDisplayIndicator_chosen 4
	SourceDisplayIndicator sourceDisplayIndicator;
#	define WorkspaceViewAttribute_nonStandardAttribute_chosen 5
	NonStandardParameter nonStandardAttribute;
    } u;
} WorkspaceViewAttribute;

typedef struct ArchiveAcknowledgePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle archiveHandle;
    ArchiveOpenResult result;
#   define ArchiveAcknowledgePDU_nonStandardParameters_present 0x80
    PArchiveAcknowledgePDU_nonStandardParameters nonStandardParameters;
} ArchiveAcknowledgePDU;

typedef struct ArchiveErrorPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle archiveHandle;
#   define entryName_present 0x80
    ArchiveEntryName entryName;
    ArchiveError errorCode;
#   define ArchiveErrorPDU_nonStandardParameters_present 0x40
    PArchiveErrorPDU_nonStandardParameters nonStandardParameters;
} ArchiveErrorPDU;

typedef struct BitmapAbortPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle bitmapHandle;
#   define userID_present 0x80
    MCSUserID userID;
#   define reason_present 0x40
    BitmapAbortReason reason;
#   define message_present 0x20
    ASN1char16string_t message;
#   define BitmapAbortPDU_nonStandardParameters_present 0x10
    PBitmapAbortPDU_nonStandardParameters nonStandardParameters;
} BitmapAbortPDU;

typedef struct DrawingCreatePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define drawingHandle_present 0x80
    Handle drawingHandle;
    DrawingDestinationAddress destinationAddress;
    DrawingType drawingType;
#   define DrawingCreatePDU_attributes_present 0x40
    PDrawingCreatePDU_attributes attributes;
    WorkspacePoint anchorPoint;
#   define rotation_present 0x20
    RotationSpecifier rotation;
#   define DrawingCreatePDU_sampleRate_present 0x10
    ASN1uint16_t sampleRate;
    PointList pointList;
#   define DrawingCreatePDU_nonStandardParameters_present 0x8
    PDrawingCreatePDU_nonStandardParameters nonStandardParameters;
} DrawingCreatePDU;

typedef struct DrawingEditPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle drawingHandle;
#   define DrawingEditPDU_attributeEdits_present 0x80
    PDrawingEditPDU_attributeEdits attributeEdits;
#   define DrawingEditPDU_anchorPointEdit_present 0x40
    WorkspacePoint anchorPointEdit;
#   define rotationEdit_present 0x20
    RotationSpecifier rotationEdit;
#   define pointListEdits_present 0x10
    PointListEdits pointListEdits;
#   define DrawingEditPDU_nonStandardParameters_present 0x8
    PDrawingEditPDU_nonStandardParameters nonStandardParameters;
} DrawingEditPDU;

typedef struct RemoteKeyboardEventPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RemoteEventDestinationAddress destinationAddress;
#   define keyModifierStates_present 0x80
    PRemoteKeyboardEventPDU_keyModifierStates keyModifierStates;
    KeyPressState keyPressState;
    KeyCode keyCode;
#   define RemoteKeyboardEventPDU_nonStandardParameters_present 0x40
    PRemoteKeyboardEventPDU_nonStandardParameters nonStandardParameters;
} RemoteKeyboardEventPDU;

typedef struct RemotePointingDeviceEventPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RemoteEventDestinationAddress destinationAddress;
    ButtonEvent leftButtonState;
    ButtonEvent middleButtonState;
    ButtonEvent rightButtonState;
    WorkspacePoint initialPoint;
#   define RemotePointingDeviceEventPDU_sampleRate_present 0x80
    ASN1uint16_t sampleRate;
#   define pointList_present 0x40
    PointList pointList;
#   define RemotePointingDeviceEventPDU_nonStandardParameters_present 0x20
    PRemotePointingDeviceEventPDU_nonStandardParameters nonStandardParameters;
} RemotePointingDeviceEventPDU;

typedef struct WorkspaceEditPDU_viewEdits_Set_action_editView {
    PWorkspaceEditPDU_viewEdits_Set_action_editView next;
    WorkspaceViewAttribute value;
} WorkspaceEditPDU_viewEdits_Set_action_editView_Element;

typedef struct WorkspaceEditPDU_viewEdits_Set_action_createNewView {
    PWorkspaceEditPDU_viewEdits_Set_action_createNewView next;
    WorkspaceViewAttribute value;
} WorkspaceEditPDU_viewEdits_Set_action_createNewView_Element;

typedef struct WorkspaceEditPDU_planeEdits_Set_planeAttributes {
    PWorkspaceEditPDU_planeEdits_Set_planeAttributes next;
    PlaneAttribute value;
} WorkspaceEditPDU_planeEdits_Set_planeAttributes_Element;

typedef struct WorkspaceCreatePDU_viewParameters_Set_viewAttributes {
    PWorkspaceCreatePDU_viewParameters_Set_viewAttributes next;
    WorkspaceViewAttribute value;
} WorkspaceCreatePDU_viewParameters_Set_viewAttributes_Element;

typedef struct WorkspaceCreatePDU_planeParameters_Seq_planeAttributes {
    PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes next;
    PlaneAttribute value;
} WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_Element;

typedef struct ColorPalette_colorLookUpTable_paletteYCbCr {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PColorPalette_colorLookUpTable_paletteYCbCr_palette palette;
#   define ColorPalette_colorLookUpTable_paletteYCbCr_enhancement_present 0x80
    ColorAccuracyEnhancementYCbCr enhancement;
} ColorPalette_colorLookUpTable_paletteYCbCr;

typedef struct ColorPalette_colorLookUpTable_paletteCIELab {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PColorPalette_colorLookUpTable_paletteCIELab_palette palette;
#   define ColorPalette_colorLookUpTable_paletteCIELab_enhancement_present 0x80
    ColorAccuracyEnhancementCIELab enhancement;
} ColorPalette_colorLookUpTable_paletteCIELab;

typedef struct ColorPalette_colorLookUpTable_paletteRGB {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PColorPalette_colorLookUpTable_paletteRGB_palette palette;
#   define ColorPalette_colorLookUpTable_paletteRGB_enhancement_present 0x80
    ColorAccuracyEnhancementRGB enhancement;
} ColorPalette_colorLookUpTable_paletteRGB;

typedef struct WorkspacePlaneCopyPDU_copyDescriptor {
    ASN1choice_t choice;
    union {
#	define permanentPlaneCopyDescriptor_chosen 1
	PermanentPlaneCopyDescriptor permanentPlaneCopyDescriptor;
#	define editablePlaneCopyDescriptor_chosen 2
	EditablePlaneCopyDescriptor editablePlaneCopyDescriptor;
    } u;
} WorkspacePlaneCopyPDU_copyDescriptor;

typedef struct WorkspaceEditPDU_attributeEdits {
    PWorkspaceEditPDU_attributeEdits next;
    WorkspaceAttribute value;
} WorkspaceEditPDU_attributeEdits_Element;

typedef struct WorkspaceCreatePDU_workspaceAttributes {
    PWorkspaceCreatePDU_workspaceAttributes next;
    WorkspaceAttribute value;
} WorkspaceCreatePDU_workspaceAttributes_Element;

typedef struct RemoteKeyboardEventPDU_keyModifierStates {
    PRemoteKeyboardEventPDU_keyModifierStates next;
    KeyModifier value;
} RemoteKeyboardEventPDU_keyModifierStates_Element;

typedef struct ConductorPrivilegeRequestPDU_privilegeList {
    PConductorPrivilegeRequestPDU_privilegeList next;
    ConductorPrivilege value;
} ConductorPrivilegeRequestPDU_privilegeList_Element;

typedef struct ConductorPrivilegeGrantPDU_privilegeList {
    PConductorPrivilegeGrantPDU_privilegeList next;
    ConductorPrivilege value;
} ConductorPrivilegeGrantPDU_privilegeList_Element;

typedef struct VideoWindowEditPDU_attributeEdits {
    PVideoWindowEditPDU_attributeEdits next;
    VideoWindowAttribute value;
} VideoWindowEditPDU_attributeEdits_Element;

typedef struct VideoWindowCreatePDU_attributes {
    PVideoWindowCreatePDU_attributes next;
    VideoWindowAttribute value;
} VideoWindowCreatePDU_attributes_Element;

typedef struct ColorSpaceSpecifier_cieLab {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorSpaceSpecifier_cieLab_accuracyEnhancement_present 0x80
    ColorAccuracyEnhancementCIELab accuracyEnhancement;
} ColorSpaceSpecifier_cieLab;

typedef struct ColorSpaceSpecifier_rgb {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorSpaceSpecifier_rgb_accuracyEnhancement_present 0x80
    ColorAccuracyEnhancementRGB accuracyEnhancement;
} ColorSpaceSpecifier_rgb;

typedef struct ColorSpaceSpecifier_yCbCr {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorSpaceSpecifier_yCbCr_accuracyEnhancement_present 0x80
    ColorAccuracyEnhancementYCbCr accuracyEnhancement;
} ColorSpaceSpecifier_yCbCr;

typedef struct ColorSpaceSpecifier_greyscale {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ColorSpaceSpecifier_greyscale_accuracyEnhancement_present 0x80
    ColorAccuracyEnhancementGreyscale accuracyEnhancement;
} ColorSpaceSpecifier_greyscale;

typedef struct ColorPalette_colorLookUpTable {
    ASN1choice_t choice;
    union {
#	define paletteRGB_chosen 1
	ColorPalette_colorLookUpTable_paletteRGB paletteRGB;
#	define paletteCIELab_chosen 2
	ColorPalette_colorLookUpTable_paletteCIELab paletteCIELab;
#	define paletteYCbCr_chosen 3
	ColorPalette_colorLookUpTable_paletteYCbCr paletteYCbCr;
#	define nonStandardPalette_chosen 4
	NonStandardParameter nonStandardPalette;
    } u;
} ColorPalette_colorLookUpTable;

typedef struct BitmapAttribute {
    ASN1choice_t choice;
    union {
#	define BitmapAttribute_viewState_chosen 1
	ViewState viewState;
#	define BitmapAttribute_zOrder_chosen 2
	ZOrder zOrder;
#	define BitmapAttribute_nonStandardAttribute_chosen 3
	NonStandardParameter nonStandardAttribute;
#	define BitmapAttribute_transparencyMask_chosen 4
	TransparencyMask transparencyMask;
    } u;
} BitmapAttribute;

typedef struct ColorPalette {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ColorPalette_colorLookUpTable colorLookUpTable;
#   define transparentEntry_present 0x80
    ASN1uint16_t transparentEntry;
} ColorPalette;

typedef struct ColorSpaceSpecifier {
    ASN1choice_t choice;
    union {
#	define greyscale_chosen 1
	ColorSpaceSpecifier_greyscale greyscale;
#	define yCbCr_chosen 2
	ColorSpaceSpecifier_yCbCr yCbCr;
#	define rgb_chosen 3
	ColorSpaceSpecifier_rgb rgb;
#	define cieLab_chosen 4
	ColorSpaceSpecifier_cieLab cieLab;
#	define nonStandardColorSpace_chosen 5
	NonStandardIdentifier nonStandardColorSpace;
    } u;
} ColorSpaceSpecifier;

typedef struct DrawingAttribute {
    ASN1choice_t choice;
    union {
#	define penColor_chosen 1
	WorkspaceColor penColor;
#	define fillColor_chosen 2
	WorkspaceColor fillColor;
#	define penThickness_chosen 3
	PenThickness penThickness;
#	define penNib_chosen 4
	PenNib penNib;
#	define lineStyle_chosen 5
	LineStyle lineStyle;
#	define highlight_chosen 6
	ASN1bool_t highlight;
#	define DrawingAttribute_viewState_chosen 7
	ViewState viewState;
#	define DrawingAttribute_zOrder_chosen 8
	ZOrder zOrder;
#	define DrawingAttribute_nonStandardAttribute_chosen 9
	NonStandardParameter nonStandardAttribute;
    } u;
} DrawingAttribute;

typedef struct WorkspacePlaneCopyPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    WorkspaceIdentifier sourceWorkspaceIdentifier;
    DataPlaneID sourcePlane;
    WorkspaceIdentifier destinationWorkspaceIdentifier;
    DataPlaneID destinationPlane;
    WorkspacePlaneCopyPDU_copyDescriptor copyDescriptor;
#   define WorkspacePlaneCopyPDU_nonStandardParameters_present 0x80
    PWorkspacePlaneCopyPDU_nonStandardParameters nonStandardParameters;
} WorkspacePlaneCopyPDU;

typedef struct BitmapHeaderUncompressed_colorMappingMode_paletteMap {
    ColorPalette colorPalette;
    ASN1uint16_t bitsPerPixel;
} BitmapHeaderUncompressed_colorMappingMode_paletteMap;

typedef struct BitmapHeaderUncompressed_colorMappingMode_directMap {
    ColorSpaceSpecifier colorSpace;
    ColorResolutionModeSpecifier resolutionMode;
} BitmapHeaderUncompressed_colorMappingMode_directMap;

typedef struct BitmapHeaderT82_colorMappingMode_paletteMap {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ColorPalette bitmapPalette;
#   define progressiveMode_present 0x80
    BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode progressiveMode;
} BitmapHeaderT82_colorMappingMode_paletteMap;

typedef struct DrawingEditPDU_attributeEdits {
    PDrawingEditPDU_attributeEdits next;
    DrawingAttribute value;
} DrawingEditPDU_attributeEdits_Element;

typedef struct DrawingCreatePDU_attributes {
    PDrawingCreatePDU_attributes next;
    DrawingAttribute value;
} DrawingCreatePDU_attributes_Element;

typedef struct BitmapEditPDU_attributeEdits {
    PBitmapEditPDU_attributeEdits next;
    BitmapAttribute value;
} BitmapEditPDU_attributeEdits_Element;

typedef struct BitmapCreatePDU_attributes {
    PBitmapCreatePDU_attributes next;
    BitmapAttribute value;
} BitmapCreatePDU_attributes_Element;

typedef struct BitmapHeaderT82_colorMappingMode {
    ASN1choice_t choice;
    union {
#	define BitmapHeaderT82_colorMappingMode_directMap_chosen 1
	ColorSpaceSpecifier directMap;
#	define BitmapHeaderT82_colorMappingMode_paletteMap_chosen 2
	BitmapHeaderT82_colorMappingMode_paletteMap paletteMap;
    } u;
} BitmapHeaderT82_colorMappingMode;

typedef struct BitmapHeaderUncompressed_colorMappingMode {
    ASN1choice_t choice;
    union {
#	define BitmapHeaderUncompressed_colorMappingMode_directMap_chosen 1
	BitmapHeaderUncompressed_colorMappingMode_directMap directMap;
#	define BitmapHeaderUncompressed_colorMappingMode_paletteMap_chosen 2
	BitmapHeaderUncompressed_colorMappingMode_paletteMap paletteMap;
    } u;
} BitmapHeaderUncompressed_colorMappingMode;

typedef struct BitmapHeaderUncompressed {
    BitmapHeaderUncompressed_colorMappingMode colorMappingMode;
} BitmapHeaderUncompressed;

typedef struct BitmapHeaderT81 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ColorSpaceSpecifier colorSpace;
    ColorResolutionModeSpecifier resolutionMode;
#   define colorPalette_present 0x80
    ColorPalette colorPalette;
} BitmapHeaderT81;

typedef struct BitmapHeaderT82 {
    BitmapHeaderT82_colorMappingMode colorMappingMode;
} BitmapHeaderT82;

typedef struct BitmapCreatePDU_bitmapFormatHeader {
    ASN1choice_t choice;
    union {
#	define bitmapHeaderUncompressed_chosen 1
	BitmapHeaderUncompressed bitmapHeaderUncompressed;
#	define bitmapHeaderT4_chosen 2
	BitmapHeaderT4 bitmapHeaderT4;
#	define bitmapHeaderT6_chosen 3
	BitmapHeaderT6 bitmapHeaderT6;
#	define bitmapHeaderT81_chosen 4
	BitmapHeaderT81 bitmapHeaderT81;
#	define bitmapHeaderT82_chosen 5
	BitmapHeaderT82 bitmapHeaderT82;
#	define bitmapHeaderNonStandard_chosen 6
	NonStandardParameter bitmapHeaderNonStandard;
    } u;
} BitmapCreatePDU_bitmapFormatHeader;

typedef struct BitmapCreatePDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Handle bitmapHandle;
    BitmapDestinationAddress destinationAddress;
#   define BitmapCreatePDU_attributes_present 0x80
    PBitmapCreatePDU_attributes attributes;
#   define BitmapCreatePDU_anchorPoint_present 0x40
    WorkspacePoint anchorPoint;
    BitmapSize bitmapSize;
#   define bitmapRegionOfInterest_present 0x20
    BitmapRegion bitmapRegionOfInterest;
    PixelAspectRatio pixelAspectRatio;
#   define BitmapCreatePDU_scaling_present 0x10
    PointDiff16 scaling;
#   define checkpoints_present 0x8
    PBitmapCreatePDU_checkpoints checkpoints;
    BitmapCreatePDU_bitmapFormatHeader bitmapFormatHeader;
#   define bitmapData_present 0x4
    BitmapData bitmapData;
    ASN1bool_t moreToFollow;
#   define BitmapCreatePDU_nonStandardParameters_present 0x2
    PBitmapCreatePDU_nonStandardParameters nonStandardParameters;
} BitmapCreatePDU;

typedef struct SIPDU {
    ASN1choice_t choice;
    union {
#	define archiveAcknowledgePDU_chosen 1
	ArchiveAcknowledgePDU archiveAcknowledgePDU;
#	define archiveClosePDU_chosen 2
	ArchiveClosePDU archiveClosePDU;
#	define archiveErrorPDU_chosen 3
	ArchiveErrorPDU archiveErrorPDU;
#	define archiveOpenPDU_chosen 4
	ArchiveOpenPDU archiveOpenPDU;
#	define bitmapAbortPDU_chosen 5
	BitmapAbortPDU bitmapAbortPDU;
#	define bitmapCheckpointPDU_chosen 6
	BitmapCheckpointPDU bitmapCheckpointPDU;
#	define bitmapCreatePDU_chosen 7
	BitmapCreatePDU bitmapCreatePDU;
#	define bitmapCreateContinuePDU_chosen 8
	BitmapCreateContinuePDU bitmapCreateContinuePDU;
#	define bitmapDeletePDU_chosen 9
	BitmapDeletePDU bitmapDeletePDU;
#	define bitmapEditPDU_chosen 10
	BitmapEditPDU bitmapEditPDU;
#	define conductorPrivilegeGrantPDU_chosen 11
	ConductorPrivilegeGrantPDU conductorPrivilegeGrantPDU;
#	define conductorPrivilegeRequestPDU_chosen 12
	ConductorPrivilegeRequestPDU conductorPrivilegeRequestPDU;
#	define drawingCreatePDU_chosen 13
	DrawingCreatePDU drawingCreatePDU;
#	define drawingDeletePDU_chosen 14
	DrawingDeletePDU drawingDeletePDU;
#	define drawingEditPDU_chosen 15
	DrawingEditPDU drawingEditPDU;
#	define remoteEventPermissionGrantPDU_chosen 16
	RemoteEventPermissionGrantPDU remoteEventPermissionGrantPDU;
#	define remoteEventPermissionRequestPDU_chosen 17
	RemoteEventPermissionRequestPDU remoteEventPermissionRequestPDU;
#	define remoteKeyboardEventPDU_chosen 18
	RemoteKeyboardEventPDU remoteKeyboardEventPDU;
#	define remotePointingDeviceEventPDU_chosen 19
	RemotePointingDeviceEventPDU remotePointingDeviceEventPDU;
#	define remotePrintPDU_chosen 20
	RemotePrintPDU remotePrintPDU;
#	define siNonStandardPDU_chosen 21
	SINonStandardPDU siNonStandardPDU;
#	define workspaceCreatePDU_chosen 22
	WorkspaceCreatePDU workspaceCreatePDU;
#	define workspaceCreateAcknowledgePDU_chosen 23
	WorkspaceCreateAcknowledgePDU workspaceCreateAcknowledgePDU;
#	define workspaceDeletePDU_chosen 24
	WorkspaceDeletePDU workspaceDeletePDU;
#	define workspaceEditPDU_chosen 25
	WorkspaceEditPDU workspaceEditPDU;
#	define workspacePlaneCopyPDU_chosen 26
	WorkspacePlaneCopyPDU workspacePlaneCopyPDU;
#	define workspaceReadyPDU_chosen 27
	WorkspaceReadyPDU workspaceReadyPDU;
#	define workspaceRefreshStatusPDU_chosen 28
	WorkspaceRefreshStatusPDU workspaceRefreshStatusPDU;
#	define fontPDU_chosen 29
	FontPDU fontPDU;
#	define textCreatePDU_chosen 30
	TextCreatePDU textCreatePDU;
#	define textDeletePDU_chosen 31
	TextDeletePDU textDeletePDU;
#	define textEditPDU_chosen 32
	TextEditPDU textEditPDU;
#	define videoWindowCreatePDU_chosen 33
	VideoWindowCreatePDU videoWindowCreatePDU;
#	define videoWindowDeleatePDU_chosen 34
	VideoWindowDeletePDU videoWindowDeleatePDU;
#	define videoWindowEditPDU_chosen 35
	VideoWindowEditPDU videoWindowEditPDU;
    } u;
} SIPDU;
#define SIPDU_PDU 0
#define SIZE_T126_Module_PDU_0 sizeof(SIPDU)

extern double one;

extern ASN1module_t T126_Module;
extern void ASN1CALL T126_Module_Startup(void);
extern void ASN1CALL T126_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn(ASN1encoding_t enc, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes val);
    extern int ASN1CALL ASN1Dec_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn(ASN1decoding_t dec, PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes val);
	extern void ASN1CALL ASN1Free_BitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes_ElmFn(PBitmapHeaderT82_colorMappingMode_paletteMap_progressiveMode_progressivePalettes val);
    extern int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits val);
    extern int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits val);
	extern void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_ElmFn(PWorkspaceEditPDU_planeEdits val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_ElmFn(PWorkspaceCreatePDU_viewParameters val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_ElmFn(PWorkspaceCreatePDU_planeParameters val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_protectedPlaneAccessList val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_protectedPlaneAccessList val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_protectedPlaneAccessList_ElmFn(PWorkspaceCreatePDU_protectedPlaneAccessList val);
    extern int ASN1CALL ASN1Enc_BitmapCreatePDU_checkpoints_ElmFn(ASN1encoding_t enc, PBitmapCreatePDU_checkpoints val);
    extern int ASN1CALL ASN1Dec_BitmapCreatePDU_checkpoints_ElmFn(ASN1decoding_t dec, PBitmapCreatePDU_checkpoints val);
	extern void ASN1CALL ASN1Free_BitmapCreatePDU_checkpoints_ElmFn(PBitmapCreatePDU_checkpoints val);
    extern int ASN1CALL ASN1Enc_BitmapCheckpointPDU_passedCheckpoints_ElmFn(ASN1encoding_t enc, PBitmapCheckpointPDU_passedCheckpoints val);
    extern int ASN1CALL ASN1Dec_BitmapCheckpointPDU_passedCheckpoints_ElmFn(ASN1decoding_t dec, PBitmapCheckpointPDU_passedCheckpoints val);
	extern void ASN1CALL ASN1Free_BitmapCheckpointPDU_passedCheckpoints_ElmFn(PBitmapCheckpointPDU_passedCheckpoints val);
    extern int ASN1CALL ASN1Enc_EditablePlaneCopyDescriptor_objectList_ElmFn(ASN1encoding_t enc, PEditablePlaneCopyDescriptor_objectList val);
    extern int ASN1CALL ASN1Dec_EditablePlaneCopyDescriptor_objectList_ElmFn(ASN1decoding_t dec, PEditablePlaneCopyDescriptor_objectList val);
	extern void ASN1CALL ASN1Free_EditablePlaneCopyDescriptor_objectList_ElmFn(PEditablePlaneCopyDescriptor_objectList val);
    extern int ASN1CALL ASN1Enc_BitmapData_dataCheckpoint_ElmFn(ASN1encoding_t enc, PBitmapData_dataCheckpoint val);
    extern int ASN1CALL ASN1Dec_BitmapData_dataCheckpoint_ElmFn(ASN1decoding_t dec, PBitmapData_dataCheckpoint val);
	extern void ASN1CALL ASN1Free_BitmapData_dataCheckpoint_ElmFn(PBitmapData_dataCheckpoint val);
    extern int ASN1CALL ASN1Enc_ColorIndexTable_ElmFn(ASN1encoding_t enc, PColorIndexTable val);
    extern int ASN1CALL ASN1Dec_ColorIndexTable_ElmFn(ASN1decoding_t dec, PColorIndexTable val);
	extern void ASN1CALL ASN1Free_ColorIndexTable_ElmFn(PColorIndexTable val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_usage val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_usage val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_usage_ElmFn(PWorkspaceCreatePDU_planeParameters_Seq_usage val);
    extern int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteRGB_palette val);
    extern int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteRGB_palette val);
	extern void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteRGB_palette_ElmFn(PColorPalette_colorLookUpTable_paletteRGB_palette val);
    extern int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteCIELab_palette val);
    extern int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteCIELab_palette val);
	extern void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteCIELab_palette_ElmFn(PColorPalette_colorLookUpTable_paletteCIELab_palette val);
    extern int ASN1CALL ASN1Enc_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn(ASN1encoding_t enc, PColorPalette_colorLookUpTable_paletteYCbCr_palette val);
    extern int ASN1CALL ASN1Dec_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn(ASN1decoding_t dec, PColorPalette_colorLookUpTable_paletteYCbCr_palette val);
	extern void ASN1CALL ASN1Free_ColorPalette_colorLookUpTable_paletteYCbCr_palette_ElmFn(PColorPalette_colorLookUpTable_paletteYCbCr_palette val);
    extern int ASN1CALL ASN1Enc_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceRefreshStatusPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceRefreshStatusPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceRefreshStatusPDU_nonStandardParameters_ElmFn(PWorkspaceRefreshStatusPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_WorkspaceReadyPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceReadyPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceReadyPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceReadyPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceReadyPDU_nonStandardParameters_ElmFn(PWorkspaceReadyPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspacePlaneCopyPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspacePlaneCopyPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_WorkspacePlaneCopyPDU_nonStandardParameters_ElmFn(PWorkspacePlaneCopyPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_WorkspaceEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceEditPDU_nonStandardParameters_ElmFn(PWorkspaceEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits val);
    extern int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits val);
	extern void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_ElmFn(PWorkspaceEditPDU_viewEdits val);
    extern int ASN1CALL ASN1Enc_WorkspaceDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceDeletePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceDeletePDU_nonStandardParameters_ElmFn(PWorkspaceDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreateAcknowledgePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreateAcknowledgePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceCreateAcknowledgePDU_nonStandardParameters_ElmFn(PWorkspaceCreateAcknowledgePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_nonStandardParameters_ElmFn(PWorkspaceCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_TextEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTextEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_TextEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTextEditPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_TextEditPDU_nonStandardParameters_ElmFn(PTextEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_TextDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTextDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_TextDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTextDeletePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_TextDeletePDU_nonStandardParameters_ElmFn(PTextDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_TextCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTextCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_TextCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTextCreatePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_TextCreatePDU_nonStandardParameters_ElmFn(PTextCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_RemotePrintPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemotePrintPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_RemotePrintPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemotePrintPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_RemotePrintPDU_nonStandardParameters_ElmFn(PRemotePrintPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemotePointingDeviceEventPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemotePointingDeviceEventPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_RemotePointingDeviceEventPDU_nonStandardParameters_ElmFn(PRemotePointingDeviceEventPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemoteKeyboardEventPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemoteKeyboardEventPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_nonStandardParameters_ElmFn(PRemoteKeyboardEventPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_nonStandardParameters_ElmFn(PRemoteEventPermissionRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionRequestPDU_remoteEventPermissionList val);
    extern int ASN1CALL ASN1Dec_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionRequestPDU_remoteEventPermissionList val);
	extern void ASN1CALL ASN1Free_RemoteEventPermissionRequestPDU_remoteEventPermissionList_ElmFn(PRemoteEventPermissionRequestPDU_remoteEventPermissionList val);
    extern int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_nonStandardParameters_ElmFn(PRemoteEventPermissionGrantPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn(ASN1encoding_t enc, PRemoteEventPermissionGrantPDU_remoteEventPermissionList val);
    extern int ASN1CALL ASN1Dec_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn(ASN1decoding_t dec, PRemoteEventPermissionGrantPDU_remoteEventPermissionList val);
	extern void ASN1CALL ASN1Free_RemoteEventPermissionGrantPDU_remoteEventPermissionList_ElmFn(PRemoteEventPermissionGrantPDU_remoteEventPermissionList val);
    extern int ASN1CALL ASN1Enc_FontPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PFontPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_FontPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PFontPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_FontPDU_nonStandardParameters_ElmFn(PFontPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_DrawingEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDrawingEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_DrawingEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDrawingEditPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_DrawingEditPDU_nonStandardParameters_ElmFn(PDrawingEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_DrawingDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDrawingDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_DrawingDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDrawingDeletePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_DrawingDeletePDU_nonStandardParameters_ElmFn(PDrawingDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_DrawingCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDrawingCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_DrawingCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDrawingCreatePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_DrawingCreatePDU_nonStandardParameters_ElmFn(PDrawingCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_nonStandardParameters_ElmFn(PConductorPrivilegeRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_nonStandardParameters_ElmFn(PConductorPrivilegeGrantPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_BitmapEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_BitmapEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapEditPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_BitmapEditPDU_nonStandardParameters_ElmFn(PBitmapEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_BitmapDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_BitmapDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapDeletePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_BitmapDeletePDU_nonStandardParameters_ElmFn(PBitmapDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_BitmapCreateContinuePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapCreateContinuePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_BitmapCreateContinuePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapCreateContinuePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_BitmapCreateContinuePDU_nonStandardParameters_ElmFn(PBitmapCreateContinuePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_BitmapCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_BitmapCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapCreatePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_BitmapCreatePDU_nonStandardParameters_ElmFn(PBitmapCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_BitmapCheckpointPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapCheckpointPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_BitmapCheckpointPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapCheckpointPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_BitmapCheckpointPDU_nonStandardParameters_ElmFn(PBitmapCheckpointPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_BitmapAbortPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PBitmapAbortPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_BitmapAbortPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PBitmapAbortPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_BitmapAbortPDU_nonStandardParameters_ElmFn(PBitmapAbortPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ArchiveOpenPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveOpenPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ArchiveOpenPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveOpenPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ArchiveOpenPDU_nonStandardParameters_ElmFn(PArchiveOpenPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ArchiveErrorPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveErrorPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ArchiveErrorPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveErrorPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ArchiveErrorPDU_nonStandardParameters_ElmFn(PArchiveErrorPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ArchiveClosePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveClosePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ArchiveClosePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveClosePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ArchiveClosePDU_nonStandardParameters_ElmFn(PArchiveClosePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PArchiveAcknowledgePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PArchiveAcknowledgePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ArchiveAcknowledgePDU_nonStandardParameters_ElmFn(PArchiveAcknowledgePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_VideoWindowEditPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PVideoWindowEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_VideoWindowEditPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PVideoWindowEditPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_VideoWindowEditPDU_nonStandardParameters_ElmFn(PVideoWindowEditPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_VideoWindowDeletePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PVideoWindowDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_VideoWindowDeletePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PVideoWindowDeletePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_VideoWindowDeletePDU_nonStandardParameters_ElmFn(PVideoWindowDeletePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_VideoWindowCreatePDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PVideoWindowCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_VideoWindowCreatePDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PVideoWindowCreatePDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_VideoWindowCreatePDU_nonStandardParameters_ElmFn(PVideoWindowCreatePDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_VideoSourceIdentifier_dSMCCConnBinder_ElmFn(ASN1encoding_t enc, PVideoSourceIdentifier_dSMCCConnBinder val);
    extern int ASN1CALL ASN1Dec_VideoSourceIdentifier_dSMCCConnBinder_ElmFn(ASN1decoding_t dec, PVideoSourceIdentifier_dSMCCConnBinder val);
	extern void ASN1CALL ASN1Free_VideoSourceIdentifier_dSMCCConnBinder_ElmFn(PVideoSourceIdentifier_dSMCCConnBinder val);
    extern int ASN1CALL ASN1Enc_TransparencyMask_nonStandardParameters_ElmFn(ASN1encoding_t enc, PTransparencyMask_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_TransparencyMask_nonStandardParameters_ElmFn(ASN1decoding_t dec, PTransparencyMask_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_TransparencyMask_nonStandardParameters_ElmFn(PTransparencyMask_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_PointList_pointsDiff16_ElmFn(ASN1encoding_t enc, PPointList_pointsDiff16 val);
    extern int ASN1CALL ASN1Dec_PointList_pointsDiff16_ElmFn(ASN1decoding_t dec, PPointList_pointsDiff16 val);
	extern void ASN1CALL ASN1Free_PointList_pointsDiff16_ElmFn(PPointList_pointsDiff16 val);
    extern int ASN1CALL ASN1Enc_PointList_pointsDiff8_ElmFn(ASN1encoding_t enc, PPointList_pointsDiff8 val);
    extern int ASN1CALL ASN1Dec_PointList_pointsDiff8_ElmFn(ASN1decoding_t dec, PPointList_pointsDiff8 val);
	extern void ASN1CALL ASN1Free_PointList_pointsDiff8_ElmFn(PPointList_pointsDiff8 val);
    extern int ASN1CALL ASN1Enc_PointList_pointsDiff4_ElmFn(ASN1encoding_t enc, PPointList_pointsDiff4 val);
    extern int ASN1CALL ASN1Dec_PointList_pointsDiff4_ElmFn(ASN1decoding_t dec, PPointList_pointsDiff4 val);
	extern void ASN1CALL ASN1Free_PointList_pointsDiff4_ElmFn(PPointList_pointsDiff4 val);
    extern int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_editView val);
    extern int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_editView val);
	extern void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_editView_ElmFn(PWorkspaceEditPDU_viewEdits_Set_action_editView val);
    extern int ASN1CALL ASN1Enc_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_viewEdits_Set_action_createNewView val);
    extern int ASN1CALL ASN1Dec_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_viewEdits_Set_action_createNewView val);
	extern void ASN1CALL ASN1Free_WorkspaceEditPDU_viewEdits_Set_action_createNewView_ElmFn(PWorkspaceEditPDU_viewEdits_Set_action_createNewView val);
    extern int ASN1CALL ASN1Enc_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_planeEdits_Set_planeAttributes val);
    extern int ASN1CALL ASN1Dec_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_planeEdits_Set_planeAttributes val);
	extern void ASN1CALL ASN1Free_WorkspaceEditPDU_planeEdits_Set_planeAttributes_ElmFn(PWorkspaceEditPDU_planeEdits_Set_planeAttributes val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_viewParameters_Set_viewAttributes val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_viewParameters_Set_viewAttributes_ElmFn(PWorkspaceCreatePDU_viewParameters_Set_viewAttributes val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_planeParameters_Seq_planeAttributes_ElmFn(PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes val);
    extern int ASN1CALL ASN1Enc_WorkspaceEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PWorkspaceEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Dec_WorkspaceEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PWorkspaceEditPDU_attributeEdits val);
	extern void ASN1CALL ASN1Free_WorkspaceEditPDU_attributeEdits_ElmFn(PWorkspaceEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Enc_WorkspaceCreatePDU_workspaceAttributes_ElmFn(ASN1encoding_t enc, PWorkspaceCreatePDU_workspaceAttributes val);
    extern int ASN1CALL ASN1Dec_WorkspaceCreatePDU_workspaceAttributes_ElmFn(ASN1decoding_t dec, PWorkspaceCreatePDU_workspaceAttributes val);
	extern void ASN1CALL ASN1Free_WorkspaceCreatePDU_workspaceAttributes_ElmFn(PWorkspaceCreatePDU_workspaceAttributes val);
    extern int ASN1CALL ASN1Enc_RemoteKeyboardEventPDU_keyModifierStates_ElmFn(ASN1encoding_t enc, PRemoteKeyboardEventPDU_keyModifierStates val);
    extern int ASN1CALL ASN1Dec_RemoteKeyboardEventPDU_keyModifierStates_ElmFn(ASN1decoding_t dec, PRemoteKeyboardEventPDU_keyModifierStates val);
	extern void ASN1CALL ASN1Free_RemoteKeyboardEventPDU_keyModifierStates_ElmFn(PRemoteKeyboardEventPDU_keyModifierStates val);
    extern int ASN1CALL ASN1Enc_ConductorPrivilegeRequestPDU_privilegeList_ElmFn(ASN1encoding_t enc, PConductorPrivilegeRequestPDU_privilegeList val);
    extern int ASN1CALL ASN1Dec_ConductorPrivilegeRequestPDU_privilegeList_ElmFn(ASN1decoding_t dec, PConductorPrivilegeRequestPDU_privilegeList val);
	extern void ASN1CALL ASN1Free_ConductorPrivilegeRequestPDU_privilegeList_ElmFn(PConductorPrivilegeRequestPDU_privilegeList val);
    extern int ASN1CALL ASN1Enc_ConductorPrivilegeGrantPDU_privilegeList_ElmFn(ASN1encoding_t enc, PConductorPrivilegeGrantPDU_privilegeList val);
    extern int ASN1CALL ASN1Dec_ConductorPrivilegeGrantPDU_privilegeList_ElmFn(ASN1decoding_t dec, PConductorPrivilegeGrantPDU_privilegeList val);
	extern void ASN1CALL ASN1Free_ConductorPrivilegeGrantPDU_privilegeList_ElmFn(PConductorPrivilegeGrantPDU_privilegeList val);
    extern int ASN1CALL ASN1Enc_VideoWindowEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PVideoWindowEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Dec_VideoWindowEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PVideoWindowEditPDU_attributeEdits val);
	extern void ASN1CALL ASN1Free_VideoWindowEditPDU_attributeEdits_ElmFn(PVideoWindowEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Enc_VideoWindowCreatePDU_attributes_ElmFn(ASN1encoding_t enc, PVideoWindowCreatePDU_attributes val);
    extern int ASN1CALL ASN1Dec_VideoWindowCreatePDU_attributes_ElmFn(ASN1decoding_t dec, PVideoWindowCreatePDU_attributes val);
	extern void ASN1CALL ASN1Free_VideoWindowCreatePDU_attributes_ElmFn(PVideoWindowCreatePDU_attributes val);
    extern int ASN1CALL ASN1Enc_DrawingEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PDrawingEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Dec_DrawingEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PDrawingEditPDU_attributeEdits val);
	extern void ASN1CALL ASN1Free_DrawingEditPDU_attributeEdits_ElmFn(PDrawingEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Enc_DrawingCreatePDU_attributes_ElmFn(ASN1encoding_t enc, PDrawingCreatePDU_attributes val);
    extern int ASN1CALL ASN1Dec_DrawingCreatePDU_attributes_ElmFn(ASN1decoding_t dec, PDrawingCreatePDU_attributes val);
	extern void ASN1CALL ASN1Free_DrawingCreatePDU_attributes_ElmFn(PDrawingCreatePDU_attributes val);
    extern int ASN1CALL ASN1Enc_BitmapEditPDU_attributeEdits_ElmFn(ASN1encoding_t enc, PBitmapEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Dec_BitmapEditPDU_attributeEdits_ElmFn(ASN1decoding_t dec, PBitmapEditPDU_attributeEdits val);
	extern void ASN1CALL ASN1Free_BitmapEditPDU_attributeEdits_ElmFn(PBitmapEditPDU_attributeEdits val);
    extern int ASN1CALL ASN1Enc_BitmapCreatePDU_attributes_ElmFn(ASN1encoding_t enc, PBitmapCreatePDU_attributes val);
    extern int ASN1CALL ASN1Dec_BitmapCreatePDU_attributes_ElmFn(ASN1decoding_t dec, PBitmapCreatePDU_attributes val);
	extern void ASN1CALL ASN1Free_BitmapCreatePDU_attributes_ElmFn(PBitmapCreatePDU_attributes val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _T126_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\twnd.hpp ===
//
// TWND.HPP
// Tool Window Class
//
// Copyright Microsoft 1998-
//
#ifndef __TWND_HPP_
#define __TWND_HPP_


//
// Our toolbar has three sections:
//      5 rows of exclusive tools 
//      SEPARATOR
//      2 rows of options
//      SEPARATOR
//      1 row of other commands (screen grabbing)
//      


#define TOOLBAR_NUMROWS			8
#define TOOLBAR_NUMSEPARATORS	2
#define TOOLBAR_NUMCOLS			2

#define TOOLBAR_FIRSTBUTTON     0
#define TOOLBAR_MAXBUTTON       18
#define TOOLBAR_LASTBUTTON      (TOOLBAR_MAXBUTTON - 1)


#define TOOLBAR_IMAGEWIDTH      16
#define TOOLBAR_IMAGEHEIGHT     15    
#define TOOLBAR_BTNEXTRA        7
#define TOOLBAR_BTNWIDTH        (TOOLBAR_IMAGEWIDTH + TOOLBAR_BTNEXTRA)
#define TOOLBAR_BTNHEIGHT       (TOOLBAR_IMAGEHEIGHT + TOOLBAR_BTNEXTRA)
#define TOOLBAR_MARGINX         (::GetSystemMetrics(SM_CXEDGE))
#define TOOLBAR_SEPARATORY      8
#define TOOLBAR_WIDTH           (2 * TOOLBAR_BTNWIDTH + 3 * TOOLBAR_MARGINX)


//
//
// Class:   WbToolBar
//
// Purpose: Define Whiteboard tool-bar window
//
//
class WbToolBar
{
public:
    //
    // Construction
    //
    WbToolBar();
    ~WbToolBar();

    //
    // Window creation
    //
    BOOL Create(HWND hwndParent);

    //
    // Button manipulation
    //
    BOOL PushDown(UINT uiId);
    BOOL PopUp(UINT uiId);

    BOOL Enable(UINT uiId);
    BOOL Disable(UINT uiId);

    //
    // Resizing functions
    //
    void    GetNaturalSize(LPSIZE lpsize);
    UINT    WidthFromHeight(UINT height);

    void    RecolorButtonImages(void);

    HWND    m_hwnd;

protected:
    HBITMAP m_hbmImages;
};


#endif // __TWND_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\t126obj.cpp ===
//
// T126OBJ.CPP
// T126 objects: point, openpolyline, closepolyline, ellipse, bitmaps, workspaces
//
// Copyright Microsoft 1998-
//
#include "precomp.h"
#include "NMWbObj.h"

void T126Obj::AddToWorkspace()
{

	ULONG gccHandle;

	UINT neededHandles = 1;
	if(GetType() == workspaceCreatePDU_chosen)
	{
		neededHandles = 2;
	}
	
	if(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount >= neededHandles)
	{
		gccHandle = g_GCCPreallocHandles[g_iGCCHandleIndex].InitialGCCHandle + g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - neededHandles;
		g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount = g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - neededHandles;

		//
		// We got a handle  no need to ask for another one
		//
		GotGCCHandle(gccHandle);

		TimeToGetGCCHandles(PREALLOC_GCC_HANDLES);
		
		return;
	}
	else
	{

		TRACE_MSG(("GCC Tank %d has not enough handles, we needed %d and we have %d",
			g_iGCCHandleIndex, neededHandles, g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount));

		//
		// Not enough handles 
		//
		g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount = 0;
		TRACE_MSG(("GCC Tank %d is now empty, switching to other GCC tank", g_iGCCHandleIndex));

		//
		// Switch gcc handles
		//
		g_iGCCHandleIndex = g_iGCCHandleIndex ? 0 : 1;


		//
		// Try again
		//
		if(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount >= neededHandles)
		{
			gccHandle = g_GCCPreallocHandles[g_iGCCHandleIndex].InitialGCCHandle + g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - neededHandles;
			g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount = g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - neededHandles;

			//
			// We got a handle  no need to ask for another one
			//
			GotGCCHandle(gccHandle);
	
			TimeToGetGCCHandles(PREALLOC_GCC_HANDLES);
		
			return;
		}
	}
	

	//
	// Save this object in our list of DrawingObjects
	//
	g_pListOfObjectsThatRequestedHandles->AddHead(this);

	//
	// Ask GCC to give us an unique handle
	//
	T120Error rc = g_pNMWBOBJ->AllocateHandles(neededHandles);

	//
	// If we are not in a conference RegistryAllocateHandle will not work,
	// so we need to create a fake confirm to remove the object from the list
	//
	if (T120_NO_ERROR != rc)
	{
		//
		// Fake a GCCAllocateHandleConfim
		//
		T126_GCCAllocateHandleConfirm(AllocateFakeGCCHandle(),neededHandles);
	}
}


//
//
// Function:    T126Obj::NormalizeRect
//
// Purpose:     Normalize a rectangle ensuring that the top left is above
//              and to the left of the bottom right.
//
//
void NormalizeRect(LPRECT lprc)
{
    int tmp;

    if (lprc->right < lprc->left)
    {
        tmp = lprc->left;
        lprc->left = lprc->right;
        lprc->right = tmp;
    }

    if (lprc->bottom < lprc->top)
    {
        tmp = lprc->top;
        lprc->top = lprc->bottom;
        lprc->bottom = tmp;
    }
}

void T126Obj::SetRect(LPCRECT lprc)
{
    m_rect.top = lprc->top;
    m_rect.bottom = lprc->bottom;
    m_rect.left = lprc->left;
    m_rect.right = lprc->right;
}

void T126Obj::SetBoundsRect(LPCRECT lprc)
{
	m_boundsRect.top = lprc->top;
	m_boundsRect.bottom = lprc->bottom;
	m_boundsRect.left = lprc->left;
	m_boundsRect.right = lprc->right;
}

void T126Obj::SetRectPts(POINT point1, POINT point2)
{
    RECT    rc;

    rc.left = point1.x;
    rc.top  = point1.y;
    rc.right = point2.x;
    rc.bottom = point2.y;

    SetRect(&rc);
}

void T126Obj::SetBoundRectPts(POINT point1, POINT point2)
{
    RECT    rc;

    rc.left = point1.x;
    rc.top  = point1.y;
    rc.right = point2.x;
    rc.bottom = point2.y;

    SetBoundsRect(&rc);
}

void T126Obj::GetRect(LPRECT lprc)
{ 
	lprc->top = m_rect.top;
	lprc->bottom = m_rect.bottom;
	lprc->left = m_rect.left;
	lprc->right = m_rect.right;
}


void T126Obj::GetBoundsRect(LPRECT lprc)
{
	if(GraphicTool() == TOOLTYPE_HIGHLIGHT || GraphicTool() == TOOLTYPE_PEN)
	{
		lprc->top = m_boundsRect.top;
		lprc->bottom = m_boundsRect.bottom;
		lprc->left = m_boundsRect.left;
		lprc->right = m_boundsRect.right;
	}
	else
	{
		GetRect(lprc);
		::InflateRect(lprc, m_penThickness/2, m_penThickness/2);
	}
	NormalizeRect(lprc);
}


BOOL T126Obj::PointInBounds(POINT point)
{
	RECT rect;
	GetBoundsRect(&rect);
	return ::PtInRect(&rect, point);
}


void T126Obj::MoveBy(int cx, int cy)
{
    // Move the bounding rectangle
    ::OffsetRect(&m_rect, cx, cy);
}

void T126Obj::MoveTo(int x, int y)
{
    // Calculate the offset needed to translate the object from its current
    // position to the required position.
    x -= m_rect.left;
    y -= m_rect.top;

    MoveBy(x, y);
}

//
// Select a drawing and add the rectangle sizes to the selector size rectangle
//
void T126Obj::SelectDrawingObject(void)
{

	if(GraphicTool() == TOOLTYPE_REMOTEPOINTER && GetOwnerID() != GET_NODE_ID_FROM_MEMBER_ID(g_MyMemberID))
	{
		return;
	}

	//
	// Mark it as selected locally
	//
	SelectedLocally();

	//
	// Calculate the size of the rectangle to be invalidated.
	//
	CalculateInvalidationRect();

	//
	// Draw the selection rectangle
	// 
	DrawRect();
}

void T126Obj::UnselectDrawingObject(void)
{
	//
	// Erase selection rect
	//
	DrawRect();

	if(GraphicTool() == TOOLTYPE_REMOTEPOINTER && GetOwnerID() != GET_NODE_ID_FROM_MEMBER_ID(g_MyMemberID))
	{
		return;
	}

    ClearSelectionFlags();

	//
	// Don't even bother sending selection changes if we were deleted
	// or if this was a remote that unselected us.
	//
	if(WasDeletedLocally() || WasSelectedRemotely())
	{
		return;
	}

	ResetAttrib();
	SetViewState(unselected_chosen);

	//
	// We are going to send a new view state, mark it as edited locally
	//
	EditedLocally();

	//
	// Sends the change in the view state to the other nodes
	//
	OnObjectEdit();
	ClearEditionFlags();
	
}


void T126Obj::DrawRect(void)
{
	if(GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{
		return;
	}

	RECT rect;
	GetBoundsRect(&rect);
	::DrawFocusRect(g_pDraw->m_hDCCached,&rect);
  
}
void T126Obj::SelectedLocally(void)
{
	m_bSelectedLocally = TRUE;
	m_bSelectedRemotely = FALSE;
	
	SetViewState(selected_chosen);

	//
	// We are going to send a new view state, mark it as edited locally
	//
	EditedLocally();

	ResetAttrib();
	ChangedViewState();

	//
	// Sends the change in the view state to the other nodes
	//
	OnObjectEdit();
}

void T126Obj::SelectedRemotely(void)
{
	m_bSelectedLocally = FALSE;
	m_bSelectedRemotely = TRUE; 
	SetViewState(selected_chosen);
}




void T126Obj::MoveBy(LONG x , LONG y)
{

	//
	// Erase the old one
	// 
	if(GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{
		UnDraw();
	}

	DrawRect();

	RECT rect;
	
	if(GraphicTool() == TOOLTYPE_PEN || GraphicTool() == TOOLTYPE_HIGHLIGHT)
	{
		GetBoundsRect(&rect);
	}
	else
	{
		GetRect(&rect);
	}
	
	::OffsetRect(&rect, x, y);
	
	if(GraphicTool() == TOOLTYPE_PEN || GraphicTool() == TOOLTYPE_HIGHLIGHT)
	{
		SetBoundsRect(&rect);
	}
	else
	{
		SetRect(&rect);
	}

	POINT anchorPoint;
	GetAnchorPoint(&anchorPoint);
	SetAnchorPoint(anchorPoint.x + x ,anchorPoint.y + y);
		
	//
	// Draw the new one
	//
	if(GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{
		Draw();
	}

	DrawRect();
	
	CalculateInvalidationRect();

	
}

void T126Obj::CalculateInvalidationRect(void)
{

	RECT rect;
	UINT penThickness = GetPenThickness();


	TRACE_DEBUG(("Invalidation Rect (%d,%d) (%d,%d)", g_pDraw->m_selectorRect.left,g_pDraw->m_selectorRect.top, g_pDraw->m_selectorRect.right, g_pDraw->m_selectorRect.bottom ));
	GetBoundsRect(&rect);
	::UnionRect(&g_pDraw->m_selectorRect,&g_pDraw->m_selectorRect,&rect);
	TRACE_DEBUG(("Invalidation Rect (%d,%d) (%d,%d)", g_pDraw->m_selectorRect.left,g_pDraw->m_selectorRect.top, g_pDraw->m_selectorRect.right, g_pDraw->m_selectorRect.bottom ));
}




//
// Checks object for an actual overlap with pRectHit. This 
// function assumes that the boundingRect has already been
// compared with pRectHit.
//
BOOL T126Obj::RectangleHit(BOOL borderHit, LPCRECT pRectHit)
{
	RECT rectEdge;
	RECT rectHit;
	RECT rect;

	//
	// If we are filled do the simple thing
	//
	if(!borderHit)
	{
		POINT point;
		point.x = (pRectHit->left + pRectHit->right) / 2;
		point.y = (pRectHit->top + pRectHit->bottom) / 2;
		if(PointInBounds(point))
		{
			return TRUE;
		}
	}


	GetRect(&rect);

	NormalizeRect(&rect);
	
	// check left edge
    rectEdge.left   = rect.left - GetPenThickness()/2;
    rectEdge.top    = rect.top -  GetPenThickness()/2;
    rectEdge.right  = rect.left + GetPenThickness()/2 ;
    rectEdge.bottom = rect.bottom + GetPenThickness()/2;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );

	// check right edge
	rectEdge.left =     rect.right - GetPenThickness()/2;
	rectEdge.right =    rect.right + GetPenThickness()/2;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );


	// check top edge
	rectEdge.left =     rect.left;
	rectEdge.right =    rect.right;
	rectEdge.top = rect.top - GetPenThickness()/2;
	rectEdge.bottom = rect.top + GetPenThickness()/2;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );


	// check bottom edge
	rectEdge.top = rect.bottom - GetPenThickness()/2;
	rectEdge.bottom = rect.bottom + GetPenThickness()/2;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );

	return( FALSE );
}

void T126Obj::SetAnchorPoint(LONG x, LONG y)
{
	if(m_anchorPoint.x != x || m_anchorPoint.y != y)
	{
		ChangedAnchorPoint();
		m_anchorPoint.x = x;
		m_anchorPoint.y = y;
	}
}


void T126Obj::SetZOrder(ZOrder zorder)
{
	m_zOrder = zorder;
	ChangedZOrder();
}



#define ARRAY_INCREMENT 0x200

DCDWordArray::DCDWordArray()
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCDWordArray::DCDWordArray");
	m_Size = 0;
	m_MaxSize = ARRAY_INCREMENT;
	DBG_SAVE_FILE_LINE
	m_pData = new POINT[ARRAY_INCREMENT];
	ASSERT(m_pData);
}

DCDWordArray::~DCDWordArray()
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCDWordArray::~DCDWordArray");

	delete[] m_pData;
}

//
// We need to increase the size of the array
//
BOOL DCDWordArray::ReallocateArray(void)
{
	POINT *pOldArray =  m_pData;
	DBG_SAVE_FILE_LINE
	m_pData = new POINT[m_MaxSize];
	
	ASSERT(m_pData);
	if(m_pData)
	{
		TRACE_DEBUG((">>>>>Increasing size of array to hold %d points", m_MaxSize));
	
		// copy new data from old
		memcpy( m_pData, pOldArray, (m_Size) * sizeof(POINT));

		TRACE_DEBUG(("Deleting array of points %x", pOldArray));
		delete[] pOldArray;
		return TRUE;
	}
	else
	{
		m_pData = pOldArray;
		return FALSE;
	}
}

//
// Add a new point to the array
//
void DCDWordArray::Add(POINT point)
{

	MLZ_EntryOut(ZONE_FUNCTION, "DCDWordArray::Add");
	TRACE_DEBUG(("Adding point(%d,%d) at %d", point.x, point.y, m_Size));
	TRACE_DEBUG(("Adding point at %x", &m_pData[m_Size]));

	if(m_pData == NULL)
	{
		return;
	}
	
	m_pData[m_Size].x = point.x;
	m_pData[m_Size].y = point.y;
	m_Size++;

	//
	// if we want more points, we need to re allocate the array
	//
	if(m_Size == m_MaxSize)
	{
		m_MaxSize +=ARRAY_INCREMENT;
		if(ReallocateArray() == FALSE)
		{
			m_Size--;
		}
	}
}

//
// Return the number of points in the array
//    
UINT DCDWordArray::GetSize(void)
{
	return m_Size;
}

//
// Sets the size of the array
//
void DCDWordArray::SetSize(UINT size)
{
	int newSize;
	//
	// if we want more points, we need to re allocate the array
	//
	if (size > m_MaxSize)
	{
		m_MaxSize= ((size/ARRAY_INCREMENT)+1)*ARRAY_INCREMENT;
		if(ReallocateArray() == FALSE)
		{
			return;
		}
	}
	m_Size = size;
}

void T126Obj::SetPenThickness(UINT penThickness)
{
	m_penThickness = penThickness;
	ChangedPenThickness();
}

void T126Obj::GotGCCHandle(ULONG gccHandle)
{
	//
	// Save this objects handle
	//
	SetThisObjectHandle(gccHandle);
	
	//
	// It was created locally
	//
	CreatedLocally();

	switch(GetType())
	{
		//
		// New drawing requested a unique handle
		//
		case(bitmapCreatePDU_chosen):
		case(drawingCreatePDU_chosen):
		{

			WorkspaceObj * pWorkspace =	GetWorkspace(GetWorkspaceHandle());
			if(pWorkspace && !pWorkspace->IsObjectInWorkspace(this))
			{		
				//
				// Add a this drawing to the correct workspace
				//
				if(!AddT126ObjectToWorkspace(this))
				{
					return;
				}
			}

			break;
		}

		//
		// New workspace requested a unique handle
		//
		case(workspaceCreatePDU_chosen):
		{
			
			//
			// Save this objects handle
			//
			SetViewHandle(gccHandle + 1);
			SetWorkspaceHandle(gccHandle);

			if(!IsWorkspaceListed(this))
			{
				AddNewWorkspace((WorkspaceObj*) this);
			}


			break;
		}
	}

	//
	// Send it to T126 apps
	//
	SendNewObjectToT126Apps();

}


//
// Create the nonstandard pdu header
//
void CreateNonStandardPDU(NonStandardParameter * sipdu, LPSTR NonStandardString)
{
		PT126_VENDORINFO vendorInfo;
		sipdu->nonStandardIdentifier.choice = h221nonStandard_chosen;
		vendorInfo = (PT126_VENDORINFO) &sipdu->nonStandardIdentifier.u.h221nonStandard.value;
		vendorInfo->bCountryCode =	USA_H221_COUNTRY_CODE;
		vendorInfo->bExtension = USA_H221_COUNTRY_EXTENSION;
		vendorInfo->wManufacturerCode = MICROSOFT_H_221_MFG_CODE;
		lstrcpy((LPSTR)&vendorInfo->nonstandardString,NonStandardString);
		sipdu->nonStandardIdentifier.u.h221nonStandard.length =  sizeof(T126_VENDORINFO) -sizeof(vendorInfo->nonstandardString) + lstrlen(NonStandardString);
		sipdu->data.value = NULL;
}


void TimeToGetGCCHandles(ULONG numberOfGccHandles)
{

	

	TRACE_MSG(("Using GCC Tank %d ", g_iGCCHandleIndex));
	TRACE_MSG(("GCC Tank 0 has %d GCC handles ", g_GCCPreallocHandles[0].GccHandleCount));
	TRACE_MSG(("GCC Tank 1 has %d GCC handles ", g_GCCPreallocHandles[1].GccHandleCount));


	//
	// If we have half a tank of GCC handles, it is time to fill up the spare tank
	//
	if(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount <= PREALLOC_GCC_HANDLES / 2 &&
		g_GCCPreallocHandles[g_iGCCHandleIndex ? 0 : 1].GccHandleCount == 0 &&
		!g_WaitingForGCCHandles)
	{

		TRACE_MSG(("GCC Tank %d is half full, time to get more GCC handles", g_iGCCHandleIndex));

		g_pNMWBOBJ->AllocateHandles(numberOfGccHandles);
		g_WaitingForGCCHandles = TRUE;
	}

	//
	// If we ran out of handles, it is time to switch tanks
	//
	if(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount == 0)
	{
		TRACE_MSG(("GCC Tank %d is empty, switching to other GCC tank", g_iGCCHandleIndex));
		g_iGCCHandleIndex = g_iGCCHandleIndex ? 0 : 1;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\t126obj.hpp ===
//
// T126OBJ.HPP
// Drawing objects: point, openpolyline, closepolyline, ellipse
//
// Copyright Microsoft 1998-
//


void GetDestinationAddress(DrawingDestinationAddress *DestinationAddress, PUINT workspaceHandle, PUINT planeID);
void NormalizeRect(LPRECT lprc);
void CreateNonStandardPDU(NonStandardParameter * sipdu, LPSTR NonStandardString);
void TimeToGetGCCHandles(ULONG numberOfGccHandles);

//
// Member ID
//
#define MAKE_MEMBER_ID(nid,uid)			(MAKELONG((nid),(uid)))
#define GET_NODE_ID_FROM_MEMBER_ID(id)	(LOWORD(id))
#define GET_USER_ID_FROM_MEMBER_ID(id)	(HIWORD(id))
typedef ULONG	MEMBER_ID;				// loword = node_id, hiword = user_id


extern ULONG g_MyMemberID;

typedef struct
{
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
    BYTE					nonstandardString;
} T126_VENDORINFO, *PT126_VENDORINFO;


class T126Obj
{

public:

	virtual ~T126Obj(){};

	virtual void Draw(HDC hdc = NULL, BOOL bForcedDraw = FALSE, BOOL bPrinting = FALSE) = 0;
	virtual void UnDraw(void) = 0;
	virtual BOOL CheckReallyHit(LPCRECT pRectHit) = 0;
	BOOL 	RectangleHit(BOOL borderHit, LPCRECT pRectHit);

	virtual void SetPenColor(COLORREF rgb, BOOL isPresent) = 0;
    virtual BOOL GetPenColor(COLORREF * pcr) = 0;
    virtual BOOL GetPenColor(RGBTRIPLE * prgb) = 0;

	virtual BOOL HasFillColor(void) = 0;
	virtual void SetFillColor(COLORREF rgb, BOOL isPresent) = 0;
    virtual BOOL GetFillColor(COLORREF * pcr) = 0;
    virtual BOOL GetFillColor(RGBTRIPLE * prgb) = 0;

    virtual UINT GraphicTool(void) { return m_ToolType;}
    virtual void SetViewHandle(UINT viewHandle) = 0;



	//
	// Edit stuff
	//
	virtual void ChangedAnchorPoint(void) = 0;
	virtual BOOL HasAnchorPointChanged(void) = 0;
	virtual void ChangedZOrder(void) = 0;
	virtual BOOL HasZOrderChanged(void) = 0;
	virtual void ChangedViewState(void) = 0;
	virtual BOOL HasViewStateChanged(void) = 0;
	virtual void ResetAttrib(void) = 0;
	virtual void SetAllAttribs(void) = 0;
	virtual void ChangedPenThickness(void) = 0;

	virtual void OnObjectEdit(void) = 0;
	virtual void OnObjectDelete(void) = 0;
	virtual void SendNewObjectToT126Apps(void) = 0;
	virtual void GetEncodedCreatePDU(ASN1_BUF *pBuf) = 0;
	void 	GotGCCHandle(ULONG gccHandle);



	//
	// Draw, bitmap, or workspace object
	//
	UINT GetType(void){return m_T126ObjectType;};
	void SetType(UINT type){m_T126ObjectType = type;};

	//
	// Workspace stuff
	//
	UINT GetWorkspaceHandle(void) {return m_workspaceHandle;};
	void SetWorkspaceHandle(UINT handle) {m_workspaceHandle = handle;};

	//
	// Get/set plane id
	//
    void SetPlaneID(UINT planeID){m_planeID = planeID;}
    UINT  GetPlaneID(void) { return m_planeID; }

	//
	// This object's handle
	//
	UINT GetThisObjectHandle(void) {return m_thisObjectHandle;};
	void SetThisObjectHandle(UINT handle) {m_thisObjectHandle = handle; TRACE_DEBUG(("Object 0x%08x Handle = %d", this, handle));};

	//
	// Get/set view state
	//
    void SetViewState(UINT viewState){m_viewState = viewState; ChangedViewState();}
    UINT  GetViewState(void) { return m_viewState;}

	//
	// Get/set zorder
	//
    void SetZOrder(ZOrder zorder);
    ZOrder  GetZOrder(void) { return m_zOrder; }

	//
	// Get/set anchor Point
	//
    void SetAnchorPoint(LONG x, LONG y);
    void GetAnchorPoint(LPPOINT lpPoint) { *lpPoint = m_anchorPoint; }

    //
    // Get/set the bounding rectangle of the graphic object (in logical
    // co-ordinates).
    //

	void	SetRect(LPCRECT lprc);
    void    GetRect(LPRECT lprc);
	void	SetRectPts(POINT point1, POINT point2);
	void	SetBoundRectPts(POINT point1, POINT point2);
    void    GetBoundsRect(LPRECT lprc);
	void 	SetBoundsRect(LPCRECT lprc);
	BOOL 	PointInBounds(POINT point);

    //
    // Get/set the width of the pen used to draw the object
    //
    void SetPenThickness(UINT penThickness);
    UINT GetPenThickness(void) { return m_penThickness;}

	//
	// Get/set penROP
	//
	void SetROP(UINT penROP) {m_penROP = penROP;}
	UINT GetROP(void){return m_penROP;}


	void MoveBy(int cx, int cy);
	void MoveTo(int x, int y);

	WBPOSITION	m_MyPosition;			// Returns this objects position in the list it is located
	WBPOSITION	GetMyPosition(void){return m_MyPosition;}
	void SetMyPosition(WBPOSITION pos){m_MyPosition = pos;}

	WorkspaceObj * m_pMyWorkspace;
	WorkspaceObj * GetMyWorkspace(void){return m_pMyWorkspace;}
	void SetMyWorkspace(WorkspaceObj * pWorkspace){m_pMyWorkspace = pWorkspace;}

	
	void CalculateInvalidationRect(void);
	void DrawMarker(LPCRECT pMarkerRect );
	void DrawRect(void);
	void SelectDrawingObject(void);
	void UndrawMarker(LPCRECT pMarkerRect );
	void UnselectDrawingObject(void);
	void MoveBy(LONG x , LONG y);


	void CreatedLocally(void){m_bCreatedLocally = TRUE;}
	BOOL WasCreatedLocally(void){return m_bCreatedLocally;}
	void ClearCreationFlags(void){m_bCreatedLocally = FALSE;}

	void SelectedLocally(void);
	void SelectedRemotely(void);
	BOOL WasSelectedLocally(){return m_bSelectedLocally;}
	BOOL WasSelectedRemotely(){return m_bSelectedRemotely;}
	BOOL IsSelected(void){return (m_bSelectedLocally || m_bSelectedRemotely);}
	void ClearSelectionFlags(void){m_bSelectedLocally = FALSE; m_bSelectedRemotely = FALSE;}
	
	void EditedLocally(void){m_bEditedLocally = TRUE;}
	BOOL WasEditedLocally(void){return m_bEditedLocally;}
	void ClearEditionFlags(void){m_bEditedLocally = FALSE;}
	
	void DeletedLocally(void){m_bDeleteLocally = TRUE;}
	BOOL WasDeletedLocally(void){return m_bDeleteLocally;}
	void ClearDeletionFlags(void){m_bDeleteLocally = FALSE;}
	void SetOwnerID(ULONG ID){
								m_OwnerID = GET_NODE_ID_FROM_MEMBER_ID(ID);
								TRACE_DEBUG(("SetOwnerID ID= %x",m_OwnerID));
								}
	ULONG GetOwnerID(void){return m_OwnerID;}
	BOOL IAmTheOwner(void){return m_OwnerID == GET_NODE_ID_FROM_MEMBER_ID(g_MyMemberID);}
	
	void AddToWorkspace();

	protected:
		UINT			m_ToolType;				// Tool type from UI

		BOOL m_bCreatedLocally;
		BOOL m_bSelectedLocally;
		BOOL m_bSelectedRemotely;
		BOOL m_bEditedLocally;
		BOOL m_bDeleteLocally;
		RECT m_boundsRect;
		RECT m_rect;



	private:
		ULONG			m_OwnerID;				// The owner of this selected object
		UINT			m_T126ObjectType;
		UINT        	m_planeID;				// Destination plane in workspace
		UINT			m_workspaceHandle;		// Destination workspace for this object
		UINT			m_thisObjectHandle;		// My own handle assigned by GCC
		UINT			m_viewState;
		ZOrder			m_zOrder;
		POINT			m_anchorPoint;
		UINT			m_penThickness;
		UINT			m_penROP;
};


class DCDWordArray
{

  public:
	DCDWordArray(void);
	~DCDWordArray(void);
	
    void Add(POINT point);
	BOOL ReallocateArray(void);
	POINT* GetBuffer(void) { return m_pData; }
    void SetSize(UINT size);
	UINT GetSize(void);

    POINT* operator[](UINT index){return &(m_pData[index]);}
	
  private:

	POINT*  m_pData;
	UINT	m_Size;
	UINT	m_MaxSize;

  
    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\textobj.hpp ===
//
// TEXTOBJ.HPP
// Text object
//
// Copyright Microsoft 1998-
//
#ifndef __TEXTOBJ_HPP_
#define __TEXTOBJ_HPP_

#include <common.h>

#define NonStandardTextID "Text2\0"

void GetTextDestinationAddress(SINonStandardPDU *destinationAddress, PUINT workspaceHandle, PUINT planeID);

//
// Definitions for text objects
//
#define LAST_LINE -1
#define LAST_CHAR -2

#ifdef _DEBUG
#define DBG_UNINIT  -1
#endif // _DEBUG

//
// Definitions for debug stuff
//
typedef struct tagVARIABLE_STRING_HEADER
{
    ULONG	len;	// length of this structure + string length
	POINT	start;  // starting X(column) Y(line) inside the previous text
}VARIABLE_STRING_HEADER;

typedef struct tagVARIABLE_STRING
{
	VARIABLE_STRING_HEADER header;
    CHAR	string;
} VARIABLE_STRING;

typedef struct tagTEXTPDU_HEADER
{
	UINT nonStandardPDU;
	UINT textHandle;
	UINT workspaceHandle;
}TEXTPDU_HEADER;

typedef struct tagTEXTPDU_ATTRIB {
	DWORD attributesFlag;	// flag with the attributes that changed
	COLORREF textPenColor;
	COLORREF textFillColor;
	UINT textViewState;
	UINT textZOrder;
	POINT textAnchorPoint;
	LOGFONT textFont;
	UINT numberOfLines;
	VARIABLE_STRING textString;
} TEXTPDU_ATTRIB;


typedef struct tagMSTextPDU
{
	TEXTPDU_HEADER header;
	TEXTPDU_ATTRIB attrib;
}MSTextPDU;


typedef struct tagMSTextDeletePDU
{
	TEXTPDU_HEADER header;
}MSTextDeletePDU;


class TextObj : public T126Obj
{

  // Friend declaration for text editing
  friend class WbTextEditor;


public:

	TextObj (void);
	void TextEditObj (TEXTPDU_ATTRIB*  pEditPDU );

	~TextObj( void );

	void Draw(HDC hDC = NULL, BOOL bForcedDraw = FALSE, BOOL bPrinting = FALSE);
	void UnDraw(void);
	BOOL CheckReallyHit(LPCRECT pRectHit){return RectangleHit(FALSE, pRectHit);}
    void SetViewHandle(UINT viewHandle){};

	//
	// PDU stuff
	//
	void CreateTextPDU(ASN1octetstring_t*, UINT);
	void SetTextAttrib(TEXTPDU_ATTRIB * pattributes);
	void GetTextAttrib(TEXTPDU_ATTRIB * pattributes);


	//
	// Get/set pen Color
	//
    void SetPenColor(COLORREF rgb, BOOL isPresent);
    BOOL GetPenColor(COLORREF * pcr);
	BOOL GetPenColor(RGBTRIPLE* rgb);

	//
	// Get/set fill Color
	//
	BOOL HasFillColor(void){return m_bIsFillColorPresent;}
    void SetFillColor(COLORREF rgb, BOOL isPresent);
    BOOL GetFillColor(COLORREF * rgb);
	BOOL GetFillColor(RGBTRIPLE* rgb);

    //
    // Set the text of the object
    //
    void SetText(TCHAR * strText);
    void SetText(const StrArray& strTextArray);

    //
    // Get/Set the font for drawing the text
    //
    virtual void SetFont(HFONT hFont);
    virtual void SetFont(LOGFONT *pLogFont, BOOL bReCalc=TRUE );
    HFONT GetFont(void) {return m_hFont;};
	HFONT GetFontThumb(void){return m_hFontThumb;}


	//
	// Get the UI tool from a drawing pdu
	//
	void SetUIToolType(void);

	//
	// Mask 0x0000001F
	//
	void ChangedPenColor(void){m_dwChangedAttrib	|= 0x00000001;}
	void ChangedFillColor(void){m_dwChangedAttrib	|= 0x00000002;}
	void ChangedViewState(void){m_dwChangedAttrib	|= 0x00000004;}
	void ChangedZOrder(void){m_dwChangedAttrib		|= 0x00000008;}
	void ChangedAnchorPoint(void) { m_dwChangedAttrib |= 0x00000010;}
	void ChangedFont(void) { m_dwChangedAttrib |= 0x00000020;}
	void ChangedText(void) { m_dwChangedAttrib |= 0x00000040;}

	BOOL HasPenColorChanged(void){return (m_dwChangedAttrib & 0x00000001);}
	BOOL HasFillColorChanged(void){return (m_dwChangedAttrib & 0x00000002);}
	BOOL HasViewStateChanged(void){return (m_dwChangedAttrib & 0x00000004);}
	BOOL HasZOrderChanged(void){return (m_dwChangedAttrib & 0x00000008);}
	BOOL HasAnchorPointChanged(void) { return (m_dwChangedAttrib & 0x00000010);}
	BOOL HasFontChanged(void) { return m_dwChangedAttrib & 0x00000020;}
	BOOL HasTextChanged(void) { return m_dwChangedAttrib & 0x00000040;}
	
	DWORD GetPresentAttribs(void){return (m_dwChangedAttrib & 0x0000007F);}
	void ResetAttrib(void){m_dwChangedAttrib = 0;}
	void SetAllAttribs(void){m_dwChangedAttrib = 0x0000007F;}

	void ChangedPenThickness(void){};

	void CalculateBoundsRect(void);
	void CalculateRect(int iStartX, int iStartY, int iStopX, int iStopY, LPRECT lprcResult);
	ABC GetTextABC( LPCTSTR pText, int iStartX, int iStopX);
	void GetTextRectangle(int iStartY, int iStartX, int iStopX, LPRECT lprc);

	void SendTextPDU(UINT choice);
	void	OnObjectEdit(void);
	void	OnObjectDelete(void);
	void	SendNewObjectToT126Apps(void);
	void GetEncodedCreatePDU(ASN1_BUF *pBuf);

	TEXTMETRIC   m_textMetrics;

	//
    // Array for storing text
	//
    StrArray    strTextArray;
   	HFONT       m_hFont;

		
protected:

		DWORD		m_dwChangedAttrib;
		BOOL		m_bIsPenColorPresent;
		BOOL		m_bIsFillColorPresent;
		RGBTRIPLE	m_penColor;
		RGBTRIPLE	m_fillColor;

	    //
	    // Font details
	    //
	    HFONT       m_hFontThumb;
		BOOL		m_bFirstSetFontCall;
		LONG		m_nKerningOffset;


};

#endif // __TEXTOBJ_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\textobj.cpp ===
//
// TEXTOBJ.CPP
// Drawing objects: point, openpolyline, closepolyline, ellipse
//
// Copyright Microsoft 1998-
//
#include "precomp.h"
#include "nmwbobj.h"


TextObj::TextObj(void)
{
#ifdef _DEBUG
    FillMemory(&m_textMetrics, sizeof(m_textMetrics), DBG_UNINIT);
#endif // _DEBUG

    //
    // ALWAYS ZERO OUT m_textMetrics.  Calculations depend on the height
    // and width of chars being zero before the font is set.
    //
    ZeroMemory(&m_textMetrics, sizeof(m_textMetrics));

	SetMyWorkspace(NULL);
	SetOwnerID(g_MyMemberID);

	m_ToolType = TOOLTYPE_TEXT;

	//
	// Created locally, not selected, not editing or deleting.
	//
	CreatedLocally();
	ClearSelectionFlags();
	ClearEditionFlags();
	ClearDeletionFlags();
	SetType(siNonStandardPDU_chosen);

	SetFillColor(RGB(-1,-1,-1),TRUE);
	SetZOrder(front);

	//
	// No attributes changed, they will be set as we change them
	//
	SetWorkspaceHandle(g_pCurrentWorkspace == NULL ? 0 : g_pCurrentWorkspace->GetWorkspaceHandle()); 
	SetType(drawingCreatePDU_chosen);
	SetROP(R2_NOTXORPEN);
	SetPlaneID(1);
	SetMyPosition(NULL);
	SetMyWorkspace(NULL);
	// 1 Pixels for pen thickness
	SetPenThickness(2);
	SetAnchorPoint(0,0);
	
	RECT rect;
    ::SetRectEmpty(&rect);
	SetRect(&rect);
	SetBoundsRect(&rect);

    m_hFontThumb = ::CreateFont(0,0,0,0,FW_NORMAL,0,0,0,0,OUT_TT_PRECIS,
        CLIP_DFA_OVERRIDE, DRAFT_QUALITY,FF_SWISS,NULL);

	m_hFont = ::CreateFont(0,0,0,0,FW_NORMAL,0,0,0,0,OUT_TT_PRECIS,
				    CLIP_DFA_OVERRIDE, 
				    DRAFT_QUALITY,
				    FF_SWISS,NULL);

	m_nKerningOffset = 0;
	ResetAttrib();

}

TextObj::~TextObj( void )
{
	RemoveObjectFromResendList(this);
	RemoveObjectFromRequestHandleList(this);

	TRACE_DEBUG(("drawingHandle = %d", GetThisObjectHandle() ));

	//
	// Tell other nodes that we are gone
	//
	if(GetMyWorkspace() != NULL && WasDeletedLocally())
	{
		OnObjectDelete();
	}

	if(m_hFont)
	{
		::DeleteFont(m_hFont);
        m_hFont = NULL;
	}


	if (m_hFontThumb)
    {
        ::DeleteFont(m_hFontThumb);
        m_hFontThumb = NULL;
    }


	strTextArray.ClearOut();
    strTextArray.RemoveAll();

}

void TextObj::TextEditObj (TEXTPDU_ATTRIB* pEditAttrib )
{

	RECT		rect;
	POSITION	pos;
	POINT		anchorPoint;
	LONG 		deltaX = 0;
	LONG		deltaY = 0;

	TRACE_DEBUG(("TextEditObj drawingHandle = %d", GetThisObjectHandle() ));

	//
	// Was edited remotely
	//
	ClearEditionFlags();

	//
	// Get the previous anchor point
	//
	GetAnchorPoint(&anchorPoint);

	//
	// Read attributes
	//
	m_dwChangedAttrib = pEditAttrib->attributesFlag;
	GetTextAttrib(pEditAttrib);

	//
	// Change the anchor point
	//
	if(HasAnchorPointChanged())
	{
		{
			//
			// Get the delta from previous anchor point
			//
			deltaX -= anchorPoint.x; 
			deltaY -= anchorPoint.y;

			//
			// Get the new anchor point
			//
			GetAnchorPoint(&anchorPoint);
			deltaX += anchorPoint.x; 
			deltaY += anchorPoint.y;
			TRACE_DEBUG(("Delta (%d,%d)", deltaX , deltaY));

			//
			// Was edited remotely
			//
			ClearEditionFlags();
		}
		
		UnDraw();

		GetRect(&rect);
		::OffsetRect(&rect,  deltaX, deltaY);
		SetRect(&rect);
		SetBoundsRect(&rect);

	}
	

	if(HasAnchorPointChanged() ||
		HasFillColorChanged() ||
		HasPenColorChanged() ||
		HasFontChanged() ||
		HasTextChanged())
	{
		Draw(NULL);
	}
	else if(HasZOrderChanged())
	{
		if(GetZOrder() == front)
		{
			g_pDraw->BringToTopSelection(FALSE, this);
		}
		else
		{
			g_pDraw->SendToBackSelection(FALSE, this);
		}
	}
	//
	// If it just select/unselected it
	//
	else if(HasViewStateChanged())
	{
		; // do nothing
	}
	//
	// If we have a valid font. 
	//
	else if(GetFont())
	{
		Draw();
	}

	//
	// Reset all the attributes
	//
	ResetAttrib();
}


void    TextObj::GetTextAttrib(TEXTPDU_ATTRIB * pattributes)
{
	if(HasPenColorChanged())
	{
		SetPenColor(pattributes->textPenColor, TRUE);
	}
	
	if(HasFillColorChanged())
	{
		SetFillColor(pattributes->textFillColor, TRUE);
	}
	
	if(HasViewStateChanged())
	{

		//
		// If the other node is selecting the drawing or unselecting
		//
		if(pattributes->textViewState == selected_chosen)
		{
			SelectedRemotely();
		}
		else if(pattributes->textViewState == unselected_chosen)
		{
			ClearSelectionFlags();
		}

		SetViewState(pattributes->textViewState);
	}
	
	if(HasZOrderChanged())
	{
		SetZOrder((ZOrder)pattributes->textZOrder);
	}
	
	if(HasAnchorPointChanged())
	{
		SetAnchorPoint(pattributes->textAnchorPoint.x, pattributes->textAnchorPoint.y );
	}
	
	if(HasFontChanged())
	{
		UnDraw();

		if(m_hFont)
		{
			::DeleteFont(m_hFont);
			m_hFont = NULL;
		}
	    m_hFont = ::CreateFontIndirect(&pattributes->textFont);
	    if (!m_hFont)
	    {
	        // Could not create the font
	        ERROR_OUT(("Failed to create font"));
	    }

        if (m_hFontThumb)
        {
            ::DeleteFont(m_hFontThumb);
            m_hFontThumb = NULL;
        }
        m_hFontThumb = ::CreateFontIndirect(&pattributes->textFont);
        if (!m_hFontThumb)
        {
            // Could not create the font
            ERROR_OUT(("Failed to create thumbnail font"));
        }
	}
	
	int lines = 0;
	UINT maxString = 0;
	
	if(HasTextChanged())
	{

		BYTE * pBuff = (BYTE *)&pattributes->textString;
		VARIABLE_STRING * pVarString = NULL;

		lines = pattributes->numberOfLines;
		int i;
		CHAR * cBuff = NULL;
		LPWSTR   lpWideCharStr;

		for (i = 0; i < lines ; i++)
		{
			pVarString  = (VARIABLE_STRING *) pBuff;

			lpWideCharStr = (LPWSTR)&pVarString->string;
			UINT strSize = 0;
			strSize= WideCharToMultiByte(CP_ACP, 0, lpWideCharStr, -1, NULL, 0, NULL, NULL ); 

			//
			// Get the longest string
			//
			if(strSize > maxString)
			{
				maxString = strSize;
			}
			
			DBG_SAVE_FILE_LINE
		    cBuff = new TCHAR[strSize];
			WideCharToMultiByte(CP_ACP, 0, lpWideCharStr, -1, cBuff, strSize, NULL, NULL );
			strTextArray.SetSize(i);
		    strTextArray.SetAtGrow(i, cBuff );
			delete cBuff;

 			ASSERT(pVarString->header.start.y == i);
			pBuff += pVarString->header.len;

		}

		//
		// Calculate the rect
		//
		if(m_hFont)
		{

			//
			// Remove the old text before we paly with the text size
			//
			UnDraw();

			g_pDraw->PrimeFont(g_pDraw->m_hDCCached, m_hFont, &m_textMetrics);
			g_pDraw->UnPrimeFont(g_pDraw->m_hDCCached);
		}	
	}

}

void    TextObj::SetTextAttrib(TEXTPDU_ATTRIB * pattributes)
{

	if(HasPenColorChanged())
	{
		GetPenColor(&pattributes->textPenColor);
	}
	
	if(HasFillColorChanged())
	{
		GetFillColor(&pattributes->textFillColor);
	}
	
	if(HasViewStateChanged())
	{
		pattributes->textViewState = GetViewState();
	}
	
	if(HasZOrderChanged())
	{
		pattributes->textZOrder = GetZOrder();
	}
	
	if(HasAnchorPointChanged())
	{
		GetAnchorPoint(&pattributes->textAnchorPoint);
	}
	
	if(HasFontChanged())
	{
	    ::GetObject(m_hFont, sizeof(LOGFONT), &pattributes->textFont);
	}
	

	if(HasTextChanged())
	{
		BYTE * pBuff = (BYTE *)&pattributes->textString;
		VARIABLE_STRING * pVarString= NULL;
		LPWSTR   lpWideCharStr;

		int size = strTextArray.GetSize();
		int i;

		for (i = 0; i < size ; i++)
		{
			pVarString = (VARIABLE_STRING *)pBuff;
			lpWideCharStr = (LPWSTR)&pVarString->string;
			int strSize = 0;
			strSize= MultiByteToWideChar(CP_ACP, 0, strTextArray[i], -1, lpWideCharStr, 0)*sizeof(WCHAR); 
			MultiByteToWideChar(CP_ACP, 0, strTextArray[i], -1, lpWideCharStr, strSize);
			pVarString->header.len = strSize + sizeof(VARIABLE_STRING_HEADER);
			pVarString->header.start.x = 0; // JOSEF change that
			pVarString->header.start.y = i;
			pBuff += pVarString->header.len;
		}

		pattributes->numberOfLines = size;

		//
		// Since we are sending text, need to send some font
		//
		::GetObject(m_hFont, sizeof(LOGFONT), &pattributes->textFont);
	}


	
}


void TextObj::CreateTextPDU(ASN1octetstring_t *pData, UINT choice)
{

	MSTextPDU * pTextPDU = NULL;
	UINT stringSize = 0;	// Size of all the strings UNICODE
	int lines = 0;			// Number of text lines

	//
	// Calculate the size of the whole pdu
	//
	ULONG length = 0;
	if(choice == textDeletePDU_chosen)
	{
		length = sizeof(MSTextDeletePDU);
	}
	else
	{

		//
		// Calculate the size of the text
		//
		if(HasTextChanged())
		{
			int i;
			lines = strTextArray.GetSize();

			for (i = 0; i < lines ; i++)
			{
				stringSize += MultiByteToWideChar(CP_ACP, 0, strTextArray[i], -1, NULL, 0) * sizeof(WCHAR); 
			}
		}

		length = sizeof(MSTextPDU) + sizeof(VARIABLE_STRING_HEADER)* lines + stringSize;
	}

	DBG_SAVE_FILE_LINE
	pTextPDU = (MSTextPDU *) new BYTE[length];

	//
	// PDU choice: create, edit delete
	//
	pTextPDU->header.nonStandardPDU = choice;

	//
	// This objects handle
	//
	pTextPDU->header.textHandle = GetThisObjectHandle();
	TRACE_DEBUG(("Text >> Text handle  = %d",pTextPDU->header.textHandle ));

	//
	// This objects workspacehandle
	//
	WorkspaceObj * pWorkspace = GetMyWorkspace();
	ASSERT(pWorkspace);
    if(pWorkspace == NULL)
    {
        delete pTextPDU;
        pData->value = NULL;
        pData->length = 0;
        return;
    }
	pTextPDU->header.workspaceHandle = pWorkspace->GetThisObjectHandle();
	TRACE_DEBUG(("Text >> Workspace handle  = %d",pTextPDU->header.workspaceHandle ));

	if(choice != textDeletePDU_chosen)
	{
		//
		// Get all the attributes that changed
		//
		pTextPDU->attrib.attributesFlag = GetPresentAttribs();
		SetTextAttrib(&pTextPDU->attrib);
	}

	//
	// Set the pointer for the data that is going to be encoded
	//
	pData->value = (ASN1octet_t *)pTextPDU;
	pData->length = length;
}




void TextObj::UnDraw(void)
{
	RECT rect;
	GetBoundsRect(&rect);
	g_pDraw->InvalidateSurfaceRect(&rect,TRUE);
}


void TextObj::Draw(HDC hDC, BOOL thumbNail, BOOL bPrinting)
{

	if(!bPrinting)
	{

		//
		// Don't draw anything if we don't belong in this workspace
		//
		if(GetWorkspaceHandle() != g_pCurrentWorkspace->GetThisObjectHandle())
		{
			return;
		}
	}

    RECT        clipBox;
    BOOL        dbcsEnabled = GetSystemMetrics(SM_DBCSENABLED);
    INT		    *tabArray; 
    UINT        ch;
    int         i,j;
    BOOL        zoomed    = g_pDraw->Zoomed();
    int		    oldBkMode = 0;
    int         iIndex    = 0;
    POINT       pointPos;
	int		    nLastTab;
	ABC		    abc;
    int		    iLength;
    TCHAR *     strLine;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::Draw");

	if(hDC == NULL)
	{
		hDC = g_pDraw->m_hDCCached;
	}

    //
    // Only draw anything if the bounding rectangle intersects the current
    // clip box.
    //
    if (::GetClipBox(hDC, &clipBox) == ERROR)
	{
        WARNING_OUT(("Failed to get clip box"));
	}

    //
    // Select the font.
    //
    if (thumbNail)
	{
        TRACE_MSG(("Using thumbnail font"));
        g_pDraw->PrimeFont(hDC, m_hFontThumb, &m_textMetrics);
	}
    else
	{
        TRACE_MSG(("Using standard font"));
        g_pDraw->PrimeFont(hDC, m_hFont, &m_textMetrics);
	}

    //
    // Set the color and mode for drawing.
    //
    COLORREF rgb;
    GetPenColor(&rgb);
    
    ::SetTextColor(hDC, SET_PALETTERGB(rgb));

    //
    // Set the background to be transparent
    //
    oldBkMode = ::SetBkMode(hDC, TRANSPARENT);

    //
    // Calculate the bounding rectangle, accounting for the new font.
    //
    CalculateBoundsRect();

    if (!::IntersectRect(&clipBox, &clipBox, &m_rect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }



    //
    // Get the start point for the text.
    //
    pointPos.x = m_rect.left + m_nKerningOffset;
    pointPos.y = m_rect.top;

    //
    // Loop through the text strings drawing each as we go.
    //
    for (iIndex = 0; iIndex < strTextArray.GetSize(); iIndex++)
	{
        //
        // Get a reference to the line to be printed for convenience.
        //
        strLine  = (LPTSTR)strTextArray[iIndex];
        iLength  = lstrlen(strLine);

        //
        // Only draw the line if there are any characters in it.
        //
        if (iLength > 0)
	  	{
            if (zoomed)
	  		{
				// if new fails just skip it
				DBG_SAVE_FILE_LINE
				tabArray = new INT[iLength+1];
				if( tabArray == NULL )
                {
                    ERROR_OUT(("Failed to allocate tabArray"));
					continue;
                }

				// We are zoomed. Must calculate char spacings
				// ourselfs so that they end up proportionally
				// in the right places. TabbedTextOut will not
				// do this right so we have to use ExtTextOut with
				// a tab array.

				// figure out tab array
                j = 0;
				nLastTab = 0;
                for (i=0; i < iLength; i++)
	  			{
                    ch = strLine[(int)i]; //Don't worry about DBCS here...
					abc = GetTextABC(strLine, 0, i);

					if( j > 0 )
						tabArray[j-1] = abc.abcB - nLastTab;

					nLastTab = abc.abcB;
					j++;
	  			}

				// Now, strip out any tab chars so they don't interact
				// in an obnoxious manner with the tab array we just
				// made and so they don't make ugly little 
				// blocks when they are drawn.
                for (i=0; i < iLength; i++)
	  			{
                    ch = strLine[(int)i];
                    if ((dbcsEnabled) && (IsDBCSLeadByte((BYTE)ch)))
						i++;
					else
                    if(strLine[(int)i] == '\t')
                        strLine[i] = ' '; // blow off tab, tab array 
											   // will compensate for this
	  			}

				// do it
                ::ExtTextOut(hDC, pointPos.x,
                                pointPos.y,
                                0,
                                NULL,
                                strLine,
                                iLength,
                                tabArray);

				delete tabArray; 
			}
            else
			{
                POINT   ptPos;

                GetAnchorPoint(&ptPos);

				// Not zoomed, just do it
				::TabbedTextOut(hDC, pointPos.x,
								 pointPos.y,
								 strLine,
								 iLength,
								 0,
								 NULL,
                                 ptPos.x);
			}
		}

        //
        // Move to the next line.
        //
        ASSERT(m_textMetrics.tmHeight != DBG_UNINIT);
        pointPos.y += (m_textMetrics.tmHeight);
	}

    //
    // Do NOT draw focus if clipboard or printing
    //
	if (WasSelectedLocally() && (hDC == g_pDraw->m_hDCCached))
	{
		DrawRect();
	}


    //
    // Restore the old background mode.
    //
    ::SetBkMode(hDC, oldBkMode);
    g_pDraw->UnPrimeFont(hDC);


	//
	// If we are drawing on top of a remote pointer, draw it.
	//
	BitmapObj* remotePointer = NULL;
	WBPOSITION pos = NULL;
	remotePointer = g_pCurrentWorkspace->RectHitRemotePointer(&m_rect, GetPenThickness()/2, NULL);
	while(remotePointer)
	{
		remotePointer->Draw();
		remotePointer = g_pCurrentWorkspace->RectHitRemotePointer(&m_rect, GetPenThickness()/2, remotePointer->GetMyPosition());
	}

    
}

void TextObj::SetPenColor(COLORREF rgb, BOOL isPresent)
{
	ChangedPenColor();
	m_bIsPenColorPresent = isPresent;
	if(!isPresent)
	{
		return;
	}
	
	m_penColor.rgbtRed = GetRValue(rgb);
	m_penColor.rgbtGreen = GetGValue(rgb);
	m_penColor.rgbtBlue = GetBValue(rgb);

}

BOOL TextObj::GetPenColor(COLORREF * rgb)
{
	if(m_bIsPenColorPresent)
	{
		*rgb = RGB(m_penColor.rgbtRed, m_penColor.rgbtGreen, m_penColor.rgbtBlue);
	}
	return m_bIsPenColorPresent;
}

BOOL TextObj::GetPenColor(RGBTRIPLE* rgb)
{
	if(m_bIsPenColorPresent)
	{
		*rgb = m_penColor;
	}
	return m_bIsPenColorPresent;
}


void TextObj::SetFillColor(COLORREF rgb, BOOL isPresent)
{
	ChangedFillColor();
	m_bIsFillColorPresent = isPresent;
	if(!isPresent)
	{
		return;
	}
	
	m_fillColor.rgbtRed = GetRValue(rgb);
	m_fillColor.rgbtGreen = GetGValue(rgb);
	m_fillColor.rgbtBlue = GetBValue(rgb);

}

BOOL TextObj::GetFillColor(COLORREF* rgb)
{
	if(m_bIsFillColorPresent && rgb !=NULL)
	{
		*rgb = RGB(m_fillColor.rgbtRed, m_fillColor.rgbtGreen, m_fillColor.rgbtBlue);
	}
	return m_bIsFillColorPresent;
}

BOOL TextObj::GetFillColor(RGBTRIPLE* rgb)
{
	if(m_bIsFillColorPresent && rgb!= NULL)
	{
		*rgb = m_fillColor;
	}
	return m_bIsFillColorPresent;
}

//
// Get the encoded buffer for Drawing Create PDU
//
void	TextObj::GetEncodedCreatePDU(ASN1_BUF *pBuf)
{
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = siNonStandardPDU_chosen;
		CreateNonStandardPDU(&sipdu->u.siNonStandardPDU.nonStandardTransaction, NonStandardTextID);
		CreateTextPDU(&sipdu->u.siNonStandardPDU.nonStandardTransaction.data, textCreatePDU_chosen);
		((MSTextPDU *)sipdu->u.siNonStandardPDU.nonStandardTransaction.data.value)->header.nonStandardPDU = textCreatePDU_chosen;
		ASN1_BUF encodedPDU;
		g_pCoder->Encode(sipdu, pBuf);
		if(sipdu->u.siNonStandardPDU.nonStandardTransaction.data.value)
		{
			delete sipdu->u.siNonStandardPDU.nonStandardTransaction.data.value;
		}
		delete sipdu;
	}
	else
	{
		TRACE_MSG(("Failed to create penMenu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);

	}
}

void TextObj::SendTextPDU(UINT choice)
{

	if(!g_pNMWBOBJ->CanDoText())
	{
		return;
	}

	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = siNonStandardPDU_chosen;
		CreateNonStandardPDU(&sipdu->u.siNonStandardPDU.nonStandardTransaction, NonStandardTextID);
		CreateTextPDU(&sipdu->u.siNonStandardPDU.nonStandardTransaction.data, choice);
        if(sipdu->u.siNonStandardPDU.nonStandardTransaction.data.value == NULL)
        {
            return;
        }

		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			ResetAttrib();
			SIPDUCleanUp(sipdu);
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}

}

//
// UI Created a new Drawing Object
//
void TextObj::SendNewObjectToT126Apps(void)
{
	SendTextPDU(textCreatePDU_chosen);
}

//
// UI Edited the Drawing Object
//
void	TextObj::OnObjectEdit(void)
{
	g_bContentsChanged = TRUE;
	SendTextPDU(textEditPDU_chosen);
}

//
// UI Deleted the Drawing Object
//
void	TextObj::OnObjectDelete(void)
{
	g_bContentsChanged = TRUE;
	SendTextPDU(textDeletePDU_chosen);
}

//
//
// Function:    TextObj::SetFont
//
// Purpose:     Set the font to be used for drawing
//
//
void TextObj::SetFont(HFONT hFont)
{
    MLZ_EntryOut(ZONE_FUNCTION, "TextObj::SetFont");

    // Get the font details
    LOGFONT lfont;
    ::GetObject(hFont, sizeof(LOGFONT), &lfont);

    //
    // Pass the logical font into the SetFont() function
    //
	SetFont(&lfont);
}




//
//
// Function:    TextObj::SetText
//
// Purpose:     Set the text of the object
//
//
void TextObj::SetText(TCHAR * strText)
{
    // Remove all the current stored text
	strTextArray.SetSize(0);

    // Scan the text for carriage return and new-line characters
    int iNext = 0;
    int iLast = 0;
    int textSize = lstrlen(strText);
    TCHAR savedChar[1];

    //
    // In this case, we don't know how many lines there will be.  So we
    // use Add() from the StrArray class.
    //
    while (iNext < textSize)
    {
        // Find the next carriage return or line feed
        iNext += StrCspn(strText + iNext, "\r\n");

        // Extract the text before the terminator
        // and add it to the current list of text lines.

        savedChar[0] = strText[iNext];
        strText[iNext] = 0;
        strTextArray.Add((strText+iLast));
        strText[iNext] = savedChar[0];
    

        if (iNext < textSize)
        {
            // Skip the carriage return
            if (strText[iNext] == '\r')
                iNext++;

            // Skip a following new line (if there is one)
            if (strText[iNext] == '\n')
                iNext++;

            // Update the index of the start of the next line
            iLast = iNext;
        }
    }

	if(textSize)
	{
    
		// Calculate the bounding rectangle for the new text
		CalculateBoundsRect();
		ChangedText();
	}
}



//
//
// Function:    TextObj::SetText
//
// Purpose:     Set the text of the object
//
//
void TextObj::SetText(const StrArray& _strTextArray)
{
    // Scan the text for carriage return and new-line characters
    int iSize = _strTextArray.GetSize();

    //
    // In this case we know how many lines, so set that # then use SetAt()
    // to stick text there.
    //
    strTextArray.RemoveAll();
    strTextArray.SetSize(iSize);

    int iNext = 0;
    for ( ; iNext < iSize; iNext++)
    {
        strTextArray.SetAt(iNext, _strTextArray[iNext]);
    }

    // Calculate the new bounding rectangle
    CalculateBoundsRect();

}



//
//
// Function:    TextObj::SetFont(metrics)
//
// Purpose:     Set the font to be used for drawing
//
//
void TextObj::SetFont(LOGFONT *pLogFont, BOOL bReCalc )
{
    HFONT hNewFont;

    MLZ_EntryOut(ZONE_FUNCTION, "TextObj::SetFont");

    // Ensure that the font can be resized by the zoom function
    // (proof quality prevents font scaling).
    pLogFont->lfQuality = DRAFT_QUALITY;

    //zap FontAssociation mode (bug 3258)
    pLogFont->lfClipPrecision |= CLIP_DFA_OVERRIDE;

    // Always work in cell coordinates to get scaling right
    TRACE_MSG(("Setting font height %d, width %d, face %s, family %d, precis %d",
        pLogFont->lfHeight,pLogFont->lfWidth,pLogFont->lfFaceName,
        pLogFont->lfPitchAndFamily, pLogFont->lfOutPrecision));

    hNewFont = ::CreateFontIndirect(pLogFont);
    if (!hNewFont)
    {
        // Could not create the font
        ERROR_OUT(("Failed to create font"));
        DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
	    return;
    }

    // We are now guaranteed to be able to delete the old font
    if (m_hFont != NULL)
    {
        DeleteFont(m_hFont);
    }
    m_hFont = hNewFont;


    // Calculate the line height for this font
    ASSERT(g_pDraw);
	g_pDraw->PrimeFont(g_pDraw->GetCachedDC(), m_hFont, &m_textMetrics);

    // Set up the thumbnail font, forcing truetype if not currently TT
    if (!(m_textMetrics.tmPitchAndFamily & TMPF_TRUETYPE))
    {
        pLogFont->lfFaceName[0]    = 0;
        pLogFont->lfOutPrecision   = OUT_TT_PRECIS;
        TRACE_MSG(("Non-True type font"));
    }

    if (m_hFontThumb != NULL)
    {
        ::DeleteFont(m_hFontThumb);
        m_hFontThumb = NULL;
    }
    m_hFontThumb = ::CreateFontIndirect(pLogFont);
    if (!m_hFontThumb)
    {
        // Could not create the font
        ERROR_OUT(("Failed to create thumbnail font"));
    }

    // Calculate the bounding rectangle, accounting for the new font
    if( bReCalc )
	    CalculateBoundsRect();

	ChangedFont();

	g_pDraw->UnPrimeFont(g_pDraw->m_hDCCached);
}


//
//
// Function:    TextObj::CalculateRect
//
// Purpose:     Calculate the bounding rectangle of a portion of the object
//
//
void TextObj::CalculateRect(int iStartX,
                                     int iStartY,
                                     int iStopX,
                                     int iStopY,
                                    LPRECT lprcResult)
{
    RECT    rcResult;
    RECT    rcT;
    int     iIndex;

    MLZ_EntryOut(ZONE_FUNCTION, "TextObj::CalculateRect");

    //
    // NOTE:
    // We must use an intermediate rectangle, so as not to disturb the
    // contents of the passed-in one until done.  lprcResult may be pointing
    // to the current bounds rect, and we call functions from here that
    // may need its current value.
    //

    // Initialize the result rectangle
    ::SetRectEmpty(&rcResult);

    if (!strTextArray.GetSize())
    {
        // Text is empty
        goto DoneCalc;
    }

    // Allow for special limit values and ensure that the start and stop
    // character positions are in range.
    if (iStopY == LAST_LINE)
    {
        iStopY = strTextArray.GetSize() - 1;
    }
    iStopY = min(iStopY, strTextArray.GetSize() - 1);
    iStopY = max(iStopY, 0);

    if (iStopX == LAST_CHAR)
    {
        iStopX = lstrlen(strTextArray[iStopY]);
    }
    iStopX = min(iStopX, lstrlen(strTextArray[iStopY]));
    iStopX = max(iStopX, 0);

    // Loop through the text strings, adding each to the rectangle
    for (iIndex = iStartY; iIndex <= iStopY; iIndex++)
    {
        int iLeftX = ((iIndex == iStartY) ? iStartX : 0);
        int iRightX = ((iIndex == iStopY)
                        ? iStopX : lstrlen(strTextArray[iIndex]));

        GetTextRectangle(iIndex, iLeftX, iRightX, &rcT);
        ::UnionRect(&rcResult, &rcResult, &rcT);
    }

DoneCalc:
    *lprcResult = rcResult;
}

//
//
// Function:    TextObj::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the object
//
//
void TextObj::CalculateBoundsRect(void)
{
    // Set the new bounding rectangle
    CalculateRect(0, 0, LAST_CHAR, LAST_LINE, &m_rect);
}


//
//
// Function:    TextObj::GetTextABC
//
// Purpose:     Calculate the ABC numbers for a string of text
//																			
// COMMENT BY RAND: The abc returned is for the whole string, not just one
//					char. I.e, ABC.abcA is the offset to the first glyph in
//					the string, ABC.abcB is the sum of all of the glyphs and
//					ABC.abcC is the trailing space after the last glyph. 	
//					ABC.abcA + ABC.abcB + ABC.abcC is the total rendered 	
//					length including overhangs.								
//
// Note - we never use the A spacing so it is always 0
//
ABC TextObj::GetTextABC( LPCTSTR pText,
                                int iStartX,
                                int iStopX)
{
	MLZ_EntryOut(ZONE_FUNCTION, "TextObj::GetTextABC");
	ABC  abcResult;
    HDC  hDC;
	BOOL rc = FALSE;
	ABC  abcFirst;
	ABC  abcLast;
	BOOL zoomed = g_pDraw->Zoomed();
	int  nCharLast;
	int  i;
	LPCTSTR pScanStr;
	
	ZeroMemory( (PVOID)&abcResult, sizeof abcResult );
	ZeroMemory( (PVOID)&abcFirst, sizeof abcFirst );
	ZeroMemory( (PVOID)&abcLast, sizeof abcLast );

	// Get the standard size measure of the text
	LPCTSTR pABC = (pText + iStartX);
	int pABCLength = iStopX - iStartX;
	hDC = g_pDraw->GetCachedDC();
	g_pDraw->PrimeFont(hDC, m_hFont, &m_textMetrics);

	//
	// We must temporarily unzoom if we are currently zoomed since the
	// weird Windows font handling will not give us the same answer for
	// the text extent in zoomed mode for some TrueType fonts
	//
	if (zoomed)
    {
		::ScaleViewportExtEx(hDC, 1, g_pDraw->ZoomFactor(), 1, g_pDraw->ZoomFactor(), NULL);
    }

    DWORD size = ::GetTabbedTextExtent(hDC, pABC, pABCLength, 0, NULL);

	// We now have the advance width of the text
	abcResult.abcB = LOWORD(size);
	TRACE_MSG(("Basic text width is %d",abcResult.abcB));

	// Allow for C space (or overhang)
	if (iStopX > iStartX)
		{
		if (m_textMetrics.tmPitchAndFamily & TMPF_TRUETYPE)
			{
			if(GetSystemMetrics( SM_DBCSENABLED ))
				{
				// have to handle DBCS on both ends
				if( IsDBCSLeadByte( (BYTE)pABC[0] ) )
					{
					// pack multi byte char into a WORD for GetCharABCWidths
					WORD wMultiChar = MAKEWORD( pABC[1], pABC[0] );
					rc = ::GetCharABCWidths(hDC, wMultiChar, wMultiChar, &abcFirst);
					}
				else
					{
					// first char is SBCS
					rc = ::GetCharABCWidths(hDC, pABC[0], pABC[0], &abcFirst );
					}

				// Check for DBCS as last char. Have to scan whole string to be sure
				pScanStr = pABC;
				nCharLast = 0;
				for( i=0; i<pABCLength; i++, pScanStr++ )
					{
					nCharLast = i;
					if( IsDBCSLeadByte( (BYTE)*pScanStr ) )
						{
						i++;
						pScanStr++;
						}
					}

				if( IsDBCSLeadByte( (BYTE)pABC[nCharLast] ) )
					{
					// pack multi byte char into a WORD for GetCharABCWidths
					ASSERT( (nCharLast+1) < pABCLength );
					WORD wMultiChar = MAKEWORD( pABC[nCharLast+1], pABC[nCharLast] );
					rc = ::GetCharABCWidths(hDC, wMultiChar, wMultiChar, &abcLast);
					}
				else
					{
					// last char is SBCS
					rc = ::GetCharABCWidths(hDC, pABC[nCharLast], pABC[nCharLast], &abcLast );
					}
				}
			else
				{
				// SBCS, no special fiddling, just call GetCharABCWidths()
				rc = ::GetCharABCWidths(hDC, pABC[0], pABC[0], &abcFirst );

				nCharLast = pABCLength-1;
				rc = rc && ::GetCharABCWidths(hDC, pABC[nCharLast], pABC[nCharLast], &abcLast );
				}

			TRACE_MSG(("abcFirst: rc=%d, a=%d, b=%d, c=%d", 
						rc, abcFirst.abcA, abcFirst.abcB, abcFirst.abcC) );
			TRACE_MSG(("abcLast: rc=%d, a=%d, b=%d, c=%d", 
						rc, abcLast.abcA, abcLast.abcB, abcLast.abcC) );
			}


		if( rc )
			{
			// The text was trutype and we got good abcwidths
			// Give the C space of the last characters from
			// the string as the C space of the text.
			abcResult.abcA = abcFirst.abcA;
			abcResult.abcC = abcLast.abcC;
			}
		else
			{
			//
			// Mock up C value for a non TT font by taking some of overhang as
			// the negative C value.
			//
			//TRACE_MSG(("Using overhang -%d as C space",m_textMetrics.tmOverhang/2));
			
			// Adjust B by -overhang to make update rect schoot
			// far enough to the left so that the toes of italic cap A's
			// don't get clipped. Ignore comment above.
			abcResult.abcB -= m_textMetrics.tmOverhang;
			}
		}

	//
	// If we temporarily unzoomed then restore it now
	//
	if (zoomed)
    {
		::ScaleViewportExtEx(hDC, g_pDraw->ZoomFactor(), 1, g_pDraw->ZoomFactor(), 1, NULL);
	}

	TRACE_MSG(("Final text width is %d, C space %d",abcResult.abcB,abcResult.abcC));

	return abcResult;
}





//
//
// Function:    TextObj::GetTextRectangle
//
// Purpose:     Calculate the bounding rectangle of a portion of the object
//
//
void TextObj::GetTextRectangle(int iStartY,
                                        int iStartX,
                                        int iStopX,
                                        LPRECT lprc)
{
	// ABC structures for text sizing
	ABC abcText1;
	ABC abcText2;
	int iLeftOffset = 0;
	MLZ_EntryOut(ZONE_FUNCTION, "TextObj::GetTextRectangle");

    ASSERT(iStartY < strTextArray.GetSize());

	// Here we calculate the width of the text glyphs in which we
	// are interested. In case there are tabs involved we must start
	// with position 0 and get two lengths then subtract them

	abcText1 = GetTextABC(strTextArray[iStartY], 0, iStopX);

	if (iStartX > 0)
	{
		
		// The third param used to be iStartX-1 which is WRONG. It
		// has to point to the first char pos past the string
		// we are using.
		abcText2 = GetTextABC(strTextArray[iStartY], 0, iStartX);

		
		// Just use B part for offset. Adding A snd/or C to it moves the update
		// rectangle too far to the right and clips the char
		iLeftOffset = abcText2.abcB;
		}
	else
		{
		
		ZeroMemory( &abcText2, sizeof abcText2 );
		}

	//
	// We need to allow for A and C space in the bounding rectangle.  Use
	// ABS function just to make sure we get a large enough rectangle.
	//
	
	// Move A and C from original offset calc to here for width of update 
	// rectangle. Add in tmOverhang (non zero for non-tt fonts) to compensate
	// for the kludge in GetTextABC()....THIS EDITBOX CODE HAS GOT TO GO...
	abcText1.abcB = abcText1.abcB - iLeftOffset +	
					  abs(abcText2.abcA) + abs(abcText2.abcC) +
					  abs(abcText1.abcA) + abs(abcText1.abcC) +
					  m_textMetrics.tmOverhang;

	TRACE_DEBUG(("Left offset %d",iLeftOffset));
	TRACE_DEBUG(("B width now %d",abcText1.abcB));

	// Build the result rectangle.
	// Note that we never return an empty rectangle. This allows for the
	// fact that the Windows rectangle functions will ignore empty
	// rectangles completely. This would cause the bounding rectangle
	// calculation (for instance) to go wrong if the top or bottom lines
	// in a text object were empty.
    ASSERT(m_textMetrics.tmHeight != DBG_UNINIT);
	int iLineHeight = m_textMetrics.tmHeight + m_textMetrics.tmExternalLeading;

    lprc->left = 0;
    lprc->top = 0;
    lprc->right = max(1, abcText1.abcB);
    lprc->bottom = iLineHeight;
    ::OffsetRect(lprc, iLeftOffset, iLineHeight * iStartY);

	// rect is the correct width at this point but it might need to be schooted to 
	// the left a bit to allow for kerning of 1st letter (bug 469)
	if( abcText1.abcA < 0 )
	{
        ::OffsetRect(lprc, abcText1.abcA, 0);
		m_nKerningOffset = -abcText1.abcA;
	}
	else
		m_nKerningOffset = 0;

    POINT   pt;
    GetAnchorPoint(&pt);
    ::OffsetRect(lprc, pt.x, pt.y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\tool.hpp ===
//
// TOOL.HPP
// Tool Classes
//
// Copyright Microsoft 1998-
//
#ifndef __TOOL_HPP_
#define __TOOL_HPP_


class DCWbGraphic;


//
// Tool types
//
#define TOOLTYPE_FIRST  0
enum
{
    TOOLTYPE_SELECT = TOOLTYPE_FIRST,
    TOOLTYPE_ERASER,
    TOOLTYPE_TEXT,
    TOOLTYPE_HIGHLIGHT,
    TOOLTYPE_PEN,
    TOOLTYPE_LINE,
    TOOLTYPE_BOX,
    TOOLTYPE_FILLEDBOX,
    TOOLTYPE_ELLIPSE,
    TOOLTYPE_FILLEDELLIPSE,
    TOOLTYPE_REMOTEPOINTER,

    // This must come last
    TOOLTYPE_MAX
}; 


#define TOOL_INDEX(cmd)     ((cmd) - IDM_TOOLS_START)


#define DEF_PENCOLOR        RGB(0, 0, 0)
#define DEF_HIGHLIGHTCOLOR  RGB(255, 255, 0)

#define NUM_OF_WIDTHS       4



//
//
// Class:   WbTool
//
// Purpose: Base Tool class
//
//
class WbTool
{
public:
    //
    // Constructors
    //
    WbTool(int toolType);
    ~WbTool();

    //
    // Return the type of the tool
    //
    int ToolType(void) { return m_toolType; }

    //
    // Return whether the tool supports various attributes
    //
    BOOL HasColor(void);        // Tool supports colors
    BOOL HasWidth(void);        // Tool supports widths
    BOOL HasFont(void);         // Tool supports font

    //
    // Return the handle of the cursor for the tool
    //
    HCURSOR GetCursorForTool(void);

    //
    // Get/set the tool attributes
    //
    UINT GetWidthAtIndex(UINT uiIndex){ return m_uiWidths[uiIndex]; }
    VOID SetWidthAtIndex(UINT uiIndex, UINT uiWidth)
                               { m_uiWidths[uiIndex] = uiWidth; }

    void SetFont(HFONT hFont);
    void DeselectGraphic(void) { m_selectedTool = TOOLTYPE_MAX; }
    void SelectGraphic(T126Obj* pGraphic);

    //
    // Return the pen attributes
    //
    COLORREF GetColor(void)  { return m_clrCur; }
    void     SetColor(COLORREF clr) { m_clrCur = clr; }
    UINT     GetWidth(void)  { return m_uiWidths[m_uiWidthIndexCur]; }
    void     SetWidthIndex(UINT uiWidthIndex){ m_uiWidthIndexCur = uiWidthIndex; }
    UINT     GetWidthIndex(void)  { return m_uiWidthIndexCur; }
    int      GetROP(void);
    HFONT    GetFont(void) { return(m_hFont); }


protected:
    //
    // Tool type
    //
    int         m_toolType;
    int         m_selectedTool;

    //
    // Tool attributes
    //
    COLORREF    m_clrCur;
    UINT        m_uiWidths[NUM_OF_WIDTHS];
    UINT        m_uiWidthIndexCur;
    HFONT       m_hFont;
};


#endif // __TOOL_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\tool.cpp ===
//
// TOOL.CPP
// Drawing Tools
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"
#include "draw.hpp"



//
//
// Function:    WbTool
//
// Purpose:     Constructors for tools
//
//
WbTool::WbTool(int toolType)
{
    COLORREF    defColor;
    UINT        defWidth;
    int         iIndex;

    MLZ_EntryOut(ZONE_FUNCTION, "WbTool::WbTool");


    // Save the tool type
    m_toolType = toolType;
    m_selectedTool = TOOLTYPE_MAX;

    m_uiWidthIndexCur = 0;

    // Read the colors of the pen
    if (toolType == TOOLTYPE_HIGHLIGHT)
        defColor = DEF_HIGHLIGHTCOLOR;
    else
        defColor = DEF_PENCOLOR;
    m_clrCur = defColor;

    for (iIndex = 0; iIndex < NUM_OF_WIDTHS; iIndex++)
    {
        defWidth = 	(toolType == TOOLTYPE_HIGHLIGHT) ?
            g_HighlightWidths[iIndex] :
            g_PenWidths[iIndex];

        m_uiWidths[iIndex] = defWidth;
    }

    // Read the font details
    LOGFONT lfont;

    ::GetObject(::GetStockObject(DEFAULT_GUI_FONT), sizeof(LOGFONT), &lfont);
    lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;
    lfont.lfCharSet = DEFAULT_CHARSET;
    m_hFont = ::CreateFontIndirect(&lfont);
}


//
// WbTool::~WbTool
// Destructor
//
WbTool::~WbTool()
{
    if (m_hFont != NULL)
    {
        ::DeleteFont(m_hFont);
        m_hFont = NULL;
    }
}



//
//
// Function:    HasColor
//
// Purpose:     Return TRUE if the tool supports colors
//
//
BOOL WbTool::HasColor(void) 
{
    BOOL bResult = TRUE;

    switch (m_toolType)
    {
        case TOOLTYPE_ERASER:
            bResult = FALSE;
            break;

    }

    return bResult;
}


//
//
// Function:    HasWidth
//
// Purpose:     Return TRUE if the tool supports widths
//
//
BOOL WbTool::HasWidth(void) 
{
    BOOL bResult = FALSE;

    switch (m_toolType)
    {
        case TOOLTYPE_PEN:
        case TOOLTYPE_HIGHLIGHT:
        case TOOLTYPE_LINE:
        case TOOLTYPE_BOX:
        case TOOLTYPE_ELLIPSE:
            bResult = TRUE;
            break;

        // For the selector tool, it depends on the selected object type
        case TOOLTYPE_SELECT:
            switch (m_selectedTool)
            {
		        case TOOLTYPE_LINE:
        		case TOOLTYPE_BOX:
			    case TOOLTYPE_ELLIPSE:
                case TOOLTYPE_PEN:
                case TOOLTYPE_HIGHLIGHT:
                {
                    bResult = TRUE;
                    break;
                }
            }
            break;

        default:
            // The rest don't support widths, including filled tools
            break;
    }

    return bResult;
}




//
//
// Function:	HasFont
//
// Purpose:	 Return TRUE if the tool supports fonts
//
//
BOOL WbTool::HasFont(void)
{
	BOOL bResult = FALSE;

	switch (m_toolType)
	{
		case TOOLTYPE_TEXT:
			bResult = TRUE;
			break;

		// For the selector tool, it depends on the selected object type
		case TOOLTYPE_SELECT:
            switch (m_selectedTool)
            {
                case TOOLTYPE_TEXT:
                    bResult = TRUE;
                    break;

                default:
                    break;
            }
            break;

        default:
            break;
	}

    return bResult;
}

//
//
// Function:    GetROP
//
// Purpose:     Return the ROP for this tool
//
//
int WbTool::GetROP(void) 
{
    // If this is a highlight tool we use MASKPEN, else we use the standard
    if (m_toolType == TOOLTYPE_HIGHLIGHT)
        return(R2_MASKPEN);
    else
        return(R2_COPYPEN);
}


//
//
// Function:    GetCursorForTool
//
// Purpose:     Return the handle to the cursor for the tool
//
//
HCURSOR WbTool::GetCursorForTool(void) 
{
    int   nName = -1;

    switch(m_toolType)
    {
        case TOOLTYPE_SELECT:
            break; // use default arrow for select cursor (bug 439)

        case TOOLTYPE_PEN:
            nName = PENFREEHANDCURSOR;
            break;

        case TOOLTYPE_LINE:
        case TOOLTYPE_BOX:
        case TOOLTYPE_FILLEDBOX:
        case TOOLTYPE_ELLIPSE:
        case TOOLTYPE_FILLEDELLIPSE:
            nName = PENCURSOR;
            break;

        case TOOLTYPE_HIGHLIGHT:
            nName = HIGHLIGHTFREEHANDCURSOR;
            break;

        case TOOLTYPE_TEXT:
            nName = TEXTCURSOR;
            break;
    
        case TOOLTYPE_ERASER:
            nName = DELETECURSOR;
            break;

        default:
            // Do nothing - the name pointer is NULL
            break;
    }

    HCURSOR hcursorResult = NULL;

    if (nName == -1)
    {
        // Return the standard arrow cursor as a default
        hcursorResult = ::LoadCursor(NULL, IDC_ARROW);
    }
    else
    {
        // Return the cursor for the tool
        hcursorResult = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( nName ) );
    }

    return hcursorResult;
}

//
//
// Function:    SetFont
//
// Purpoxse:     Set the current font of the tool
//
//
void WbTool::SetFont(HFONT hFont)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbTool::SetFont");

    // Get the font details
    LOGFONT lfont;

    ::GetObject(hFont, sizeof(LOGFONT), &lfont);
    //zap FontAssociation mode (bug 3258)
    lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;

    // Set the local font
    if (m_hFont != NULL)
    {
        ::DeleteFont(m_hFont);
        m_hFont = NULL;
    }
    m_hFont = ::CreateFontIndirect(&lfont);
}


//
//
// Function:    SelectGraphic
//
// Purpose:     Set the current selected graphic type, and copy the colors,
//              widths and font into this tool's attributes.
//
//
void WbTool::SelectGraphic(T126Obj* pGraphic)
{
    UINT uiIndex;

    // Save the selected tool type
    m_selectedTool = pGraphic->GraphicTool();

    // Get the tool object for the selected tool type
    WbTool* pTool = g_pMain->m_ToolArray[m_selectedTool];

    if (HasColor())
    {
        pGraphic->GetPenColor(&m_clrCur);
    }

    if (HasWidth())
    {
        for (uiIndex = 0; uiIndex < NUM_OF_WIDTHS; uiIndex++)
        {
            SetWidthAtIndex(uiIndex, pTool->GetWidthAtIndex(uiIndex));
        }

        // See if the object's width matches any of the available colors
        // for this tool type
        for (uiIndex = 0; uiIndex < NUM_OF_WIDTHS; uiIndex++)
        {
            if (pGraphic->GetPenThickness() == m_uiWidths[uiIndex])
            {
                break;
            }
        }

        SetWidthIndex(uiIndex);
    }

    if (HasFont())
    {
        if (pGraphic->GraphicTool() == TOOLTYPE_TEXT)
        {
            SetFont(((TextObj *)pGraphic)->GetFont());
        }
    }
}



//
// WbMainWindow::InitToolArray
// Create the array of WB tools
//
//
BOOL WbMainWindow::InitToolArray(void)
{
    int tool;
    WbTool * pTool;

    for (tool = TOOLTYPE_FIRST; tool < TOOLTYPE_MAX; tool++)
    {
        // Add the new tool to the array
		DBG_SAVE_FILE_LINE
        pTool = new WbTool(tool);
        if (!pTool)
        {
            ERROR_OUT(("Can't create tool %d", tool));
            return(FALSE);
        }

        m_ToolArray[tool] = pTool;
    }

    return(TRUE);
}


//
// WbMainWindow::DestroyToolAray()
//
// Free the array of WB tools
//
void WbMainWindow::DestroyToolArray(void)
{
    int         tool;
    WbTool *    pTool;

    for (tool = TOOLTYPE_FIRST; tool < TOOLTYPE_MAX; tool++)
    {
        pTool = m_ToolArray[tool];
        if (pTool != NULL)
        {
            m_ToolArray[tool] = NULL;
            delete pTool;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\twnd.cpp ===
//
// TWND.CPP
// ToolBar handler
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


//
// This is the button layout for the toolbar
//
static UINT g_uToolBar[TOOLBAR_MAXBUTTON] =
{
    IDM_SELECT,
    IDM_ERASER,
    IDM_TEXT,
    IDM_HIGHLIGHT,
    IDM_PEN,
    IDM_LINE,
    IDM_BOX,
    IDM_FILLED_BOX,
    IDM_ELLIPSE,
    IDM_FILLED_ELLIPSE,
    0,
    IDM_ZOOM,
    IDM_REMOTE,
    IDM_LOCK,
    IDM_SYNC,
    0,
    IDM_GRAB_AREA,
    IDM_GRAB_WINDOW
};



//
//
// Function:    WbToolBar constructor
//
// Purpose:     Create the tool window
//
//
WbToolBar::WbToolBar()
{
    m_hwnd = NULL;
    m_hbmImages = NULL;
}


WbToolBar::~WbToolBar()
{
    if (m_hbmImages != NULL)
    {
        ::DeleteBitmap(m_hbmImages);
        m_hbmImages = NULL;
    }
}



//
//
// Function:    Create
//
// Purpose:     Create the tool window
//
//
BOOL WbToolBar::Create(HWND hwndParent)
{
    TBBUTTON    tb;
    int         iImage, i;

    //
    // Create the tool window
    //
    m_hwnd = ::CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
        WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | TBSTYLE_WRAPABLE |
        CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NOMOVEY | CCS_NORESIZE,
        0, 0, 0, 0,
        hwndParent, (HMENU)IDC_TOOLBAR, g_hInstance, NULL);

    if (!m_hwnd)
    {
        ERROR_OUT(("WbToolBar::Create create of window failed"));
        return(FALSE);
    }

    //
    // Tell COMCTL32 the structure size for the buttons
    //
    ::SendMessage(m_hwnd, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

    //
    // And the margin for the buttons
    //
    ::SendMessage(m_hwnd, TB_SETINDENT, TOOLBAR_MARGINX, 0);


    //
    // Add the buttons into the toolbar
    //

    ZeroMemory(&tb, sizeof(tb));
    iImage = 0;

    for (i = 0; i < TOOLBAR_MAXBUTTON; i++)
    {
        tb.fsState = TBSTATE_ENABLED;
        tb.idCommand = g_uToolBar[i];

        if (!tb.idCommand)
        {
            tb.fsStyle = TBSTYLE_SEP;
            tb.iBitmap = TOOLBAR_SEPARATORY;
        }
        else
        {
            tb.fsStyle = TBSTYLE_BUTTON;
            tb.iBitmap = iImage++;
        }

        if (!::SendMessage(m_hwnd, TB_ADDBUTTONS, 1, (LPARAM)&tb))
        {
            ERROR_OUT(("Failed to add button %d to toolbar", i));
            return(FALSE);
        }
    }

    //
    // Tell the toolbar the image and button sizes
    //
    ::SendMessage(m_hwnd, TB_SETBITMAPSIZE, 0,
        MAKELONG(TOOLBAR_IMAGEWIDTH, TOOLBAR_IMAGEHEIGHT));
    ::SendMessage(m_hwnd, TB_SETBUTTONSIZE, 0,
        MAKELONG(TOOLBAR_BTNWIDTH, TOOLBAR_BTNHEIGHT));

    //
    // Load the bitmap resource -- use sys color change handler
    //
    RecolorButtonImages();

    // set up rows
    ::SendMessage(m_hwnd, TB_SETROWS, MAKELPARAM(TOOLBAR_NUMROWS +
        TOOLBAR_NUMSEPARATORS, TRUE), 0);

    ::InvalidateRect(m_hwnd, NULL, TRUE);

    return(TRUE);
}



//
//
// Function:    GetNaturalSize
//
// Purpose:     Return the natural size of the tool client area
//
//
void WbToolBar::GetNaturalSize(LPSIZE lpsize)
{
    RECT rectButton;
    RECT rectButton2;

    if (!::SendMessage(m_hwnd, TB_GETITEMRECT, TOOLBAR_FIRSTBUTTON,
        (LPARAM)&rectButton))
    {
        ::SetRectEmpty(&rectButton);
    }

    if (!::SendMessage(m_hwnd, TB_GETITEMRECT, TOOLBAR_LASTBUTTON,
        (LPARAM)&rectButton2))
    {
        ::SetRectEmpty(&rectButton2);
    }

    lpsize->cx = TOOLBAR_WIDTH;
    lpsize->cy = rectButton2.bottom - rectButton.top +
        // Vertical margin
        (rectButton2.bottom - rectButton2.top);
}


//
//
// Function:    WidthFromHeight
//
// Purpose:     Calculate the width of the toolbar, given the height for
//              the fixed mode.
//
//
UINT WbToolBar::WidthFromHeight(UINT uiHeight)
{
    SIZE    size;

    GetNaturalSize(&size);
    return(size.cx);
}


//
//
// Function:    PushDown
//
// Purpose:     Push down a button in the tool window
//
//
BOOL WbToolBar::PushDown(UINT uiId)
{
    UINT butId;
    BOOL bDown;

    // If this isn't an exclusive checkable group, it's easy.
    if ((uiId < IDM_TOOLS_START) || (uiId >= IDM_TOOLS_MAX))
    {
        return (BOOL)(::SendMessage(m_hwnd, TB_CHECKBUTTON, uiId, MAKELPARAM(TRUE, 0)));
    }

    // Push this one down and pop up all the others
    for (butId = IDM_TOOLS_START; butId < IDM_TOOLS_MAX; butId++)
    {
        bDown = (butId == uiId);
        ::SendMessage(m_hwnd, TB_CHECKBUTTON, butId, MAKELPARAM(bDown, 0));
    }

    return( TRUE );
}


//
//
// Function:    PopUp
//
// Purpose:     Pop up a button in the tool window
//
//
BOOL WbToolBar::PopUp(UINT uiId)
{
    return (BOOL)(::SendMessage(m_hwnd, TB_CHECKBUTTON, uiId, MAKELPARAM(FALSE, 0)));
}

//
//
// Function:    Enable
//
// Purpose:     Enable a button in the tool window
//
//
BOOL WbToolBar::Enable(UINT uiId)
{
    return (BOOL)(::SendMessage(m_hwnd, TB_ENABLEBUTTON, uiId, MAKELPARAM(TRUE, 0)));
}

//
//
// Function:    Disable
//
// Purpose:     Disable a button in the tool window
//
//
BOOL WbToolBar::Disable(UINT uiId)
{
    return (BOOL)(::SendMessage(m_hwnd, TB_ENABLEBUTTON, uiId, MAKELPARAM(FALSE, 0)));
}




void WbToolBar::RecolorButtonImages(void)
{
    // re-color bitmap for toolbar
    HBITMAP hbmNew;

    hbmNew = (HBITMAP)::LoadImage(g_hInstance, MAKEINTRESOURCE(IDR_TOOLS),
        IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS | LR_DEFAULTCOLOR | LR_DEFAULTSIZE);

    if (hbmNew == NULL)
    {
        ERROR_OUT(("OnSysColorChange:  failed to load toolbar bitmap"));
    }
    else
    {
        BITMAP  bmp;

        ::GetObject(hbmNew, sizeof(bmp), &bmp);

        if (m_hbmImages == NULL)
        {
            TBADDBITMAP addBitmap;

            // First time
            addBitmap.hInst = NULL;
            addBitmap.nID   = (UINT_PTR)hbmNew;

            ::SendMessage(m_hwnd, TB_ADDBITMAP,
                (bmp.bmWidth / TOOLBAR_IMAGEWIDTH), (LPARAM)&addBitmap);
        }
        else
        {
            TBREPLACEBITMAP replaceBitmap;

            replaceBitmap.hInstOld = NULL;
            replaceBitmap.nIDOld = (UINT_PTR)m_hbmImages;
            replaceBitmap.hInstNew = NULL;
            replaceBitmap.nIDNew = (UINT_PTR)hbmNew;

            ::SendMessage(m_hwnd, TB_REPLACEBITMAP, 0, (LPARAM)&replaceBitmap);
        }

        if (m_hbmImages)
        {
            ::DeleteBitmap(m_hbmImages);
        }

        m_hbmImages = hbmNew;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\txted.cpp ===
//
// TXTED.CPP
// Editor for Text Objects
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"




/////////////////////////////////////////////////////////////////////////////
// WbTextBox


//
// This is a subclassed edit field
//

WbTextBox::WbTextBox(WbTextEditor * pEditor)
{
    OSVERSIONINFO OsData;

    m_hwnd = NULL;
    m_pfnEditPrev = NULL;

    m_MaxRect.left = 0;
    m_MaxRect.top = 0;
    m_MaxRect.right = INT_MAX;
    m_MaxRect.bottom = INT_MAX;

    ::SetRectEmpty(&m_rectErase);

    m_bInIME = FALSE;
    m_bDontEscapeThisTime = FALSE;

    // see if we need to make adjustments for NT.
    m_ptNTBooger.x = 0;
    m_ptNTBooger.y = 0;
    OsData.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if( GetVersionEx( &OsData ) )
    {
        if( OsData.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            // NT editboxes are offset from Win95 editboxes. We
            // have to de-booger them
            m_ptNTBooger.x = 3;
        }
    }

    m_pEditor = pEditor;
}


//
// ~WbTextBox()
//
WbTextBox::~WbTextBox()
{
    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }
}



//
// Create()
// Creates an edit field then subclasses it with our window procedure
//
BOOL WbTextBox::Create(HWND hwndParent)
{
    ASSERT(!m_hwnd);

    m_hwnd = ::CreateWindowEx(0, _T("EDIT"), NULL,
        WS_CHILD | WS_BORDER | ES_MULTILINE | ES_WANTRETURN |
        ES_AUTOHSCROLL | ES_AUTOVSCROLL,
        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
        hwndParent, NULL, g_hInstance, NULL);

    if (!m_hwnd)
    {
        ERROR_OUT(("WbTextBox::Create failed to create edit window"));
        return(FALSE);
    }

    // Init the data
    ::SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)this);

    // Subclass the window
    m_pfnEditPrev = (WNDPROC)::SetWindowLongPtr(m_hwnd, GWLP_WNDPROC,
        (LONG_PTR)TextWndProc);

    return(TRUE);

}



//
// TextWndProc()
// Message subclass handler for edit field
//
LRESULT CALLBACK TextWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    WbTextBox * ptb;

    ptb = (WbTextBox *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(ptb != NULL);
    ASSERT(ptb->m_pfnEditPrev != NULL);

    lResult = 0;

    switch( message )
    {
        case WM_CLEAR:
        case WM_CUT:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnClearCut();
            break;

        case WM_UNDO:
        case WM_PASTE:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnUndoPaste();
            break;

        case WM_IME_STARTCOMPOSITION:
        {
            ptb->m_bInIME = TRUE;
            ptb->m_bDontEscapeThisTime = TRUE;

            // let editbox take it from here
            goto DefEditProc;
            break;
        }


        case WM_IME_CHAR:
        {
            ptb->m_bDontEscapeThisTime = FALSE;
            goto DefEditProc;
            break;
        }


        case WM_IME_ENDCOMPOSITION:
        {
            ptb->m_bInIME = FALSE;
            goto DefEditProc;
            break;
        }

        case WM_KILLFOCUS:
        {
            if (ptb->m_bInIME && g_fnImmGetContext)
            {
                HIMC hImc = g_fnImmGetContext(hwnd);
                if ((hImc != NULL) && g_fnImmNotifyIME)
                {
                    // we're loosing control, tell IME to wrap it up (bug 130)
                    g_fnImmNotifyIME( hImc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0 );
                }
            }
            // goto DefEditProc;
            break;
        }

        case WM_CHAR:
            ptb->OnChar((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_KEYUP:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnKeyUp((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_SYSKEYDOWN:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnSysKeyDown((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_TIMER:
            ptb->OnTimer((UINT)wParam);
            break;

        case WM_MOUSEMOVE:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnMouseMove((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_LBUTTONUP:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnLButtonUp((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_MOVE:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnMove((short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        default:
DefEditProc:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}


//
// OnClearCut()
//
void WbTextBox::OnClearCut()
{
    POINT   ptCaret;
    POINT   ptPos;

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetAnchorPoint(&ptPos);

    m_pEditor->m_cursorXYPos.x = ptCaret.x + ptPos.x;
    m_pEditor->m_cursorXYPos.y = ptCaret.y + ptPos.y;
	OnUndoPaste();
}


//
// OnUndoPaste()
//
void WbTextBox::OnUndoPaste(void)
{
    FitBox();
    AutoCaretScroll();
	OnTimer(0);

}


//
// OnChar()
//
void  WbTextBox::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    int    nFirst;
    int    nLast;
    int    nPrevNumLines;
    int    nPrevNumChars;
    LRESULT dwPosChar;
    POINT  ptTop;

    // clear ignore next escape (NM4db:456)
    m_bDontEscapeThisTime = FALSE;

    ::SendMessage(m_hwnd, EM_GETSEL, (WPARAM)&nFirst, (LPARAM)&nLast);
    dwPosChar = ::SendMessage(m_hwnd, EM_POSFROMCHAR, nFirst, 0);
    ptTop.x = (short)LOWORD(dwPosChar);
    ptTop.y = (short)HIWORD(dwPosChar);

    nPrevNumLines = (int)::SendMessage(m_hwnd, EM_GETLINECOUNT, 0, 0);
    nPrevNumChars = (int)::SendMessage(m_hwnd, EM_LINELENGTH, (WPARAM)-1, 0);

    ::CallWindowProc(m_pfnEditPrev, m_hwnd, WM_CHAR, nChar, MAKELONG(nRepCnt, nFlags));

    SetupBackgroundRepaint( ptTop,
         (nPrevNumLines != ::SendMessage(m_hwnd, EM_GETLINECOUNT, 0, 0))||
         (nPrevNumChars > ::SendMessage(m_hwnd, EM_LINELENGTH, (WPARAM)-1, 0)));

    FitBox();
	m_pEditor->ChangedText();

}




void WbTextBox::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    POINT   ptCaret;
    POINT   ptPos;

    AutoCaretScroll();

    switch( nChar )
    {
        case VK_MENU:
        case VK_SHIFT:
        case VK_CONTROL:
            break;


        case VK_DELETE:
            SelectAtLeastOne();
            ::SendMessage(m_hwnd, WM_CLEAR, 0, 0);
            break;


        case VK_ESCAPE:
            if( !m_bInIME )
            {
                if( m_bDontEscapeThisTime )
                    m_bDontEscapeThisTime = FALSE;
                else
                {
                    // End the text entry abandoning the changes
                    g_pDraw->EndTextEntry(FALSE);
                    return; // we don't exist anymore, bail out
                }
            }
            break;


        default:
            break;
    }

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetAnchorPoint(&ptPos);

    m_pEditor->m_cursorXYPos.x = ptCaret.x + ptPos.x;
    m_pEditor->m_cursorXYPos.y = ptCaret.y + ptPos.y;
}





void WbTextBox::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    switch( nChar )
    {
        case VK_MENU:
            // ignore next escape (NM4db:456)
            m_bDontEscapeThisTime = TRUE;
            break;

        default:
            break;
    }
}




BOOL WbTextBox::FitBox( void )
{
    RECT rectErase;
    RECT crEditRect;
    RECT crEditBox;
    RECT crEditWnd;
    RECT crDrawWnd;
    int   nDeltaWidth, nDeltaHeight;
    HDC     hDC = NULL;
    HDC     hDrawDC = NULL;
    TCHAR *szBoxText;
    BOOL bNoChanges;
    POINT   ptDrawLoc;
    HFONT   hSaveFont;
    POINT  ptBitmapTopLeft;
    LPTSTR pszText;
    int    nTextLen;
    int textSize;

    bNoChanges = TRUE;

    hDC = ::GetDC(m_hwnd);
    if (hDC == NULL)
    {
        bNoChanges = TRUE;
        goto bail_out;
    }

    hDrawDC = g_pDraw->GetCachedDC();
    if (hDrawDC == NULL)
    {
        bNoChanges = TRUE;
        goto bail_out;
    }

    hSaveFont = SelectFont(hDC, m_pEditor->GetFont());

    textSize = ::GetWindowTextLength(m_hwnd);
    if (!textSize)
    {
        // Use a " " for a string, which is two characters.
		DBG_SAVE_FILE_LINE
        szBoxText = new TCHAR[2];
        if (!szBoxText)
        {
            ERROR_OUT(("Failed to allocate TCHAR array for empty text"));
            goto bail_out;
        }
        else
        {
            szBoxText[0] = 0;
        }
    }
    else
    {
		DBG_SAVE_FILE_LINE
        szBoxText = new TCHAR[textSize+1];
        if (!szBoxText)
        {
            ERROR_OUT(("Failed to allocate TCHAR array for object text"));
            goto bail_out;
        }
        else
        {
            ::GetWindowText(m_hwnd, (LPTSTR)szBoxText, textSize+1);
        }
    }

    // Have to check string length for NT. crEditRect comes back from
    // DrawText    giant-positive (i.e., still equal to m_MaxRect) if szBoxText
    // is empty. This causes crEditRect to overflow to giant negative later
    // resulting in very bizare painting problems. Win95 doesn't care because
    // it returns 16bit results that look like -1 instead of giant positive.

    ::GetClientRect(g_pDraw->m_hwnd, &crDrawWnd );

    // BUG 464 -DrawText doesn't calc widths involving tabs the same way a
    //            standard edit control does so replace it with DrawTextEx
    //            using the DT_EDITCONTROL format
    crEditRect = m_MaxRect;
    pszText = szBoxText;
    nTextLen = lstrlen(szBoxText);

	::DrawTextEx( hDC,
		  ((nTextLen == 0) ? " " : pszText),
		  ((nTextLen == 0) ? 1 : nTextLen),
		  &crEditRect,
		  DT_CALCRECT | DT_EXPANDTABS | DT_NOPREFIX | DT_EDITCONTROL,
		  NULL );



	m_pEditor->SetText(szBoxText);

    // BUG 464 (continued) -DrawTextEx doesn't include blank-last-lines in its height
    //                        calc like DrawText does so have to add an extra line
    //                        height for blank lines to have same behavior as DrawText
    ASSERT(m_pEditor->m_textMetrics.tmHeight != DBG_UNINIT);
    if ((nTextLen >= 2) && !IsDBCSLeadByte(pszText[nTextLen-2]) && (pszText[nTextLen-1] == _T('\n')) )
        crEditRect.bottom += m_pEditor->m_textMetrics.tmHeight;

    // NT sanity check if this still fails
    if ( ((crEditRect.right - crEditRect.left) == (m_MaxRect.right - m_MaxRect.left)) ||
         ((crEditRect.right - crEditRect.left) <= 0) )
    {
        crEditRect.right = crEditRect.left + crDrawWnd.right - crDrawWnd.left;
    }

    if ( ((crEditRect.bottom - crEditRect.top) == (m_MaxRect.bottom - m_MaxRect.top)) ||
         ((crEditRect.bottom - crEditRect.top) <= 0) )
    {
        crEditRect.bottom = crEditRect.top + crDrawWnd.bottom - crDrawWnd.top;
    }

    ::GetClientRect(m_hwnd, &crEditBox);
    ::GetWindowRect(m_hwnd, &crEditWnd);
    ::MapWindowPoints(NULL, g_pDraw->m_hwnd, (LPPOINT)&crEditWnd, 2);

    // do min size check for IME's.
    int nMinWidth;
    ASSERT(m_pEditor->m_textMetrics.tmMaxCharWidth != DBG_UNINIT);
    nMinWidth = MIN_FITBOX_CHARS*m_pEditor->m_textMetrics.tmMaxCharWidth;
    if ((crEditRect.right - crEditRect.left) < nMinWidth )
        crEditRect.right = crEditRect.left + nMinWidth;

    // must add some slop to prevent autoscroll from kicking in
    crEditRect.right += 2*m_pEditor->m_textMetrics.tmMaxCharWidth;

    ASSERT(m_pEditor->m_textMetrics.tmHeight != DBG_UNINIT);
    crEditRect.bottom += m_pEditor->m_textMetrics.tmHeight;

    //pretend we had a right or bottom scroll
    ::OffsetRect(&crEditRect, -1, -1);

    nDeltaWidth = (crEditRect.right - crEditRect.left) - (crEditBox.right - crEditBox.left);
    if (nDeltaWidth > 0)
    {
        bNoChanges = FALSE;
        if ( crEditRect.left < 0 )
        {
            // right scroll, adjust right edge
            crEditWnd.right += nDeltaWidth;
        }
        else
        {
            // left scroll, adjust left edge
            crEditWnd.left -= nDeltaWidth;
        }
    }

    nDeltaHeight = (crEditRect.bottom - crEditRect.top) - (crEditBox.bottom - crEditBox.top);
    if (nDeltaHeight > 0)
    {
        bNoChanges = FALSE;
        if( crEditRect.left < 0 )
        {
            // bottom scroll, adjust bottom edge
            crEditWnd.bottom += nDeltaHeight;
        }
        else
        {
            // top scroll, adjust top edge
            crEditWnd.top -= nDeltaHeight;
        }
    }

    if( bNoChanges )
        goto bail_out;

    // resize
    ::MoveWindow(m_hwnd, crEditWnd.left, crEditWnd.top,
        crEditWnd.right - crEditWnd.left, crEditWnd.bottom - crEditWnd.top, TRUE );

    // update bounding box
    ::GetClientRect(m_hwnd, &crEditBox);
    ::MapWindowPoints(m_hwnd, g_pDraw->m_hwnd, (LPPOINT)&crEditBox, 2);

    ::OffsetRect(&crEditBox, g_pDraw->m_originOffset.cx+1 + m_ptNTBooger.x,
        g_pDraw->m_originOffset.cy + m_ptNTBooger.y );//+1 );
    m_pEditor->m_rect = crEditBox;
    m_pEditor->SetBoundsRect(&crEditBox);

bail_out:

    if (hDC != NULL )
    {
        SelectFont(hDC, hSaveFont);
        ::ReleaseDC(m_hwnd, hDC );
    }

    delete szBoxText;
	return( !bNoChanges );
}




void WbTextBox::OnTimer(UINT nIDEvent)
{
    TRACE_TIMER(("WbTextBox::OnTimer"));

	//
	// If something changed: Text,Font, anchor point etc...
	//
	if(m_pEditor->HasTextChanged())
	{
		//
		// If we are not added to the workspace
		//
		if(!m_pEditor->GetMyWorkspace())
		{
			m_pEditor->SetAllAttribs();
			m_pEditor->AddToWorkspace();
		}
		else
		{
			m_pEditor->OnObjectEdit();
		}
	}
}



//
// WbTextBox::OnLButtonUp()
//
void  WbTextBox::OnLButtonUp(UINT nFlags, int x, int y)
{
    POINT   ptCaret;
    POINT   ptPos;

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetAnchorPoint(&ptPos);

    m_pEditor->m_cursorXYPos.x = ptCaret.x + ptPos.x;
    m_pEditor->m_cursorXYPos.y = ptCaret.y + ptPos.y;
}




//
// WbTextBox::OnMouseMove()
//
void  WbTextBox::OnMouseMove(UINT nFlags, int x, int y)
{
    if (nFlags & MK_LBUTTON )
    {
        // we're dragging
        ::HideCaret(m_hwnd);
        AutoCaretScroll();
        ::ShowCaret(m_hwnd);
    }
}



void  WbTextBox::AutoCaretScroll( void )
{
    POINT   ptCaret;
    POINT   ptPos;

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetAnchorPoint(&ptPos);

    ptCaret.x += ptPos.x;
    ptCaret.y += ptPos.y;

    g_pDraw->AutoScroll(ptCaret.x, ptCaret.y, FALSE, m_pEditor->m_cursorXYPos.x,
        m_pEditor->m_cursorXYPos.y);
    m_pEditor->m_cursorXYPos = ptCaret;
}



void WbTextBox::SetupBackgroundRepaint
(
    POINT   ptTopPaint,
    BOOL    bNumLinesChanged
)
{
    RECT    rectBox;

    ::GetClientRect(m_hwnd, &rectBox);

    if (ptTopPaint.y == -1)
    {
        ::GetCaretPos(&ptTopPaint);
    }

    ASSERT(m_pEditor->m_textMetrics.tmHeight != DBG_UNINIT);
    rectBox.top = ptTopPaint.y;
    if( !bNumLinesChanged )
        rectBox.bottom = rectBox.top + m_pEditor->m_textMetrics.tmHeight;

    ::InvalidateRect(m_hwnd, &rectBox, TRUE );
}



//
// Selects at least one (DBCS) char if there is not a selection already.
//
void WbTextBox::SelectAtLeastOne( void )
{
    int nFirst, nLast;
    TCHAR * szBoxText;

    ::SendMessage(m_hwnd, EM_GETSEL, (WPARAM)&nFirst, (LPARAM)&nLast);
    if( nFirst == nLast )
    {
        int textSize = ::GetWindowTextLength(m_hwnd);
		DBG_SAVE_FILE_LINE
        szBoxText = new TCHAR[textSize + 1];
        if (!szBoxText)
        {
            ERROR_OUT(("Failed to allocate TCHAR array for object text"));
        }
        else
        {
            ::GetWindowText( m_hwnd, szBoxText, textSize+1);

            if (nFirst < textSize)
            {
                nLast++;

                if( IsDBCSLeadByte( (BYTE) szBoxText[ nFirst ] )||
                    (szBoxText[ nFirst ] == _T('\r'))
                    )
                    nLast++;

                ::SendMessage(m_hwnd, EM_SETSEL, nFirst, nLast);
            }

            delete szBoxText;
        }
    }
}



void WbTextBox::OnMove(int x, int y)
{
    if (m_pEditor->m_nLastShow == SW_SHOW)
    {
        FitBox();
        ::ShowCaret(m_hwnd);
    }
}


int WbTextBox::GetMaxCharHeight( void )
{
    ASSERT(m_pEditor->m_textMetrics.tmHeight != DBG_UNINIT);
    return( m_pEditor->m_textMetrics.tmHeight );
}




int WbTextBox::GetMaxCharWidth( void )
{
    ASSERT(m_pEditor->m_textMetrics.tmMaxCharWidth != DBG_UNINIT);
    return( m_pEditor->m_textMetrics.tmMaxCharWidth );
}




//
// Aborts and shuts down text editor without hitting the cores.  Call this
// to shutdown editing during a lock condition (that we don't own)
//
void WbTextBox::AbortEditGently( void )
{
    RECT           boundsRect;

    // shut down rejecting all edits
    g_pDraw->EndTextEntry(FALSE);

    // Delete the text object
    if (g_pDraw->m_pTextEditor != NULL)
    {
	    m_pEditor->GetBoundsRect(&boundsRect);

		delete g_pDraw->m_pTextEditor;		// zap in memory original
        g_pDraw->m_pTextEditor = NULL;		//  text object, loose any current edits
		m_pEditor = NULL;
    }
    else
    {
        SetRectEmpty(&boundsRect);
    }

	// Redraw any altered parts of the screen
    g_pDraw->InvalidateSurfaceRect(&boundsRect, TRUE);

}



//
//
// Function:    WbTextEditor
//
// Purpose:     Constructor
//
//
WbTextEditor::WbTextEditor(void)
{
    // Initialize the cursor position
    m_cursorCharPos.x = 0;
    m_cursorCharPos.y = 0;

    // set parent for editbox
    m_pEditBox = NULL;

    m_cursorXYPos.x = 0;
    m_cursorXYPos.y = 0;

    m_bFirstSetFontCall = TRUE;
    m_nLastShow = -1;
}


WbTextEditor::~WbTextEditor(void)
{
    if (m_pEditBox != NULL)
    {
        delete m_pEditBox;
        m_pEditBox = NULL;
    }
}


//
//
// Function:    SetCursorPosFromPoint
//
// Purpose:     Return the character position most closely matching a
//              given co-ordinate position in the text object.
//
//
void WbTextEditor::SetCursorPosFromPoint(POINT pointXY)
{
    int    nCharPos;

    if (::PtInRect(&m_rect, pointXY))
    {
        // make point relative to editbox
        pointXY.x -= g_pDraw->m_originOffset.cx;
        pointXY.y -= g_pDraw->m_originOffset.cy;

        ::MapWindowPoints(g_pDraw->m_hwnd, m_pEditBox->m_hwnd,
            &pointXY, 1);

        ::SendMessage(m_pEditBox->m_hwnd, WM_LBUTTONDOWN, 0,
                               MAKELONG( pointXY.x, pointXY.y ) );
        ::SendMessage(m_pEditBox->m_hwnd, WM_LBUTTONUP, 0,
                               MAKELONG( pointXY.x, pointXY.y ) );


        // get char index in editbox
        nCharPos = (int)::SendMessage(m_pEditBox->m_hwnd, EM_CHARFROMPOS, 0,
            MAKELPARAM(pointXY.x, pointXY.y));
        if( nCharPos < 0 )
            return;

        // Set the new cursor char co-ordinates
        m_cursorCharPos.x = (short)LOWORD(nCharPos);
        m_cursorCharPos.y = (short)HIWORD(nCharPos);

        // Move the cursor to the new position
        GetXYPosition(m_cursorCharPos, &m_cursorXYPos);
    }
}

//
//
// Function:    GetCursorSize
//
// Purpose:     Return the cursor size for the current font
//
//
void WbTextEditor::GetCursorSize(LPSIZE lpsize)
{
    ASSERT(m_textMetrics.tmHeight != DBG_UNINIT);
    lpsize->cx = ::GetSystemMetrics(SM_CXBORDER);
    lpsize->cy = m_textMetrics.tmHeight;
}

//
//
// Function:    XYPosition
//
// Purpose:     Calculate the X,Y co-ordinates of a character position
//
//
void WbTextEditor::GetXYPosition(POINT pointChar, LPPOINT lpptXY)
{
    int     nCharIndex;
    LRESULT dwCharPos;

    nCharIndex = (int)::SendMessage(m_pEditBox->m_hwnd, EM_LINEINDEX, pointChar.y, 0)
        + pointChar.x;

    GetAnchorPoint(lpptXY);

    dwCharPos = ::SendMessage(m_pEditBox->m_hwnd, EM_POSFROMCHAR, nCharIndex, 0);

    lpptXY->x += (short)LOWORD(dwCharPos);
    lpptXY->y += (short)HIWORD(dwCharPos);
}



//
//
// Function:    Clear
//
// Purpose:     Clear the text editor
//
//
void WbTextEditor::Clear(void)
{
    RECT cEWndRect;

    // Remove all the current stored text
    strTextArray.RemoveAll();

    // Reset the cursor position
    m_cursorCharPos.x = 0;
    m_cursorCharPos.y = 0;

    // clear editbox
    ::SetWindowText(m_pEditBox->m_hwnd, _TEXT(""));

    // init editbox size
    m_rect.right = m_rect.left + 2*m_pEditBox->GetMaxCharWidth();
    m_rect.bottom = m_rect.top + 2*m_pEditBox->GetMaxCharHeight();
	SetBoundsRect(&m_rect);

    cEWndRect = m_rect;
    ::OffsetRect(&cEWndRect, -(g_pDraw->m_originOffset.cx+1 + m_pEditBox->m_ptNTBooger.x),
                          -(g_pDraw->m_originOffset.cy + m_pEditBox->m_ptNTBooger.y) );

    ::BringWindowToTop(m_pEditBox->m_hwnd);
    ::MoveWindow(m_pEditBox->m_hwnd, cEWndRect.left, cEWndRect.top,
        cEWndRect.right - cEWndRect.left, cEWndRect.bottom - cEWndRect.top,
        TRUE);
}

//
//
// Function:    New
//
// Purpose:     Clear the text editor and reset the graphic handle
//
//
BOOL WbTextEditor::New(void)
{
    // create editbox
    if (!Create())
    {
        ERROR_OUT(("Error creating drawing area window"));
        return(FALSE);
    }

    // Clear the object
    Clear();

    return(TRUE);
}


//
//
// Function:    SetTextObject
//
// Purpose:     Attach a text object to the editor
//
//
BOOL WbTextEditor::SetTextObject(TextObj* ptext)
{
    // create editbox
    if (!Create())
    {
        ERROR_OUT(("Error creating drawing area window"));
        return(FALSE);
    }

    // setup font
    SetFont( ptext->m_hFont );

	POINT	pPoint;
    ptext->GetAnchorPoint(&pPoint);

    MoveTo(pPoint.x, pPoint.y);

    // copy the text to the editbox
    GetText();

    return(TRUE);
}


//
//
// Function:    IsEmpty
//
// Purpose:     Return TRUE if there is no text in the object
//
//
BOOL WbTextEditor::IsEmpty(void)
{
    return(::GetWindowTextLength(m_pEditBox->m_hwnd) <= 0 );
}



void WbTextEditor::PutText(void)
{
    int nNumLines;
    int i;
    int nMaxLineLen, nLineLen;
    int nLine;
    TCHAR *cbuf;
    WbTextEditor *pThis;

    pThis = (WbTextEditor *)this; // overide const declaration

    nNumLines = (int)::SendMessage(m_pEditBox->m_hwnd, EM_GETLINECOUNT, 0, 0);

    // figure out buf size
    nMaxLineLen = 0;
    for (i = 0; i < nNumLines; i++)
    {
        nLine = (int)::SendMessage(m_pEditBox->m_hwnd, EM_LINEINDEX, i, 0);
        nLineLen = (int)::SendMessage(m_pEditBox->m_hwnd, EM_LINELENGTH, nLine, 0);

        if (nMaxLineLen < nLineLen)
            nMaxLineLen = nLineLen;
    }

    // make buf
    nMaxLineLen += sizeof(WORD);
	DBG_SAVE_FILE_LINE
    cbuf = new TCHAR[nMaxLineLen];
    if( cbuf == NULL )
    {
        ERROR_OUT(("PutText failing; couldn't allocate TCHAR array"));
        return;
    }

    //
    // copy editbox innards to textbox string
    // Again, we know in advance how many lines; use SetSize/SetAt()
    //
    strTextArray.RemoveAll();
    strTextArray.SetSize(nNumLines);

    for(i = 0; i < nNumLines; i++)
    {
        *(LPWORD)cbuf = (WORD)nMaxLineLen;
        nLineLen = (int)::SendMessage(m_pEditBox->m_hwnd, EM_GETLINE, i, (LPARAM)cbuf);
        cbuf[nLineLen] = _T('\0');
        strTextArray.SetAt(i, cbuf );
    }

    // clean up
    delete cbuf;
}




void WbTextEditor::GetText(void)
{
    int nNumLines;
    int textSize = 0;
    int i;
    TCHAR * pText = NULL;
    TCHAR * pStartText;

    nNumLines = strTextArray.GetSize();

    //
    // Calculate the buffer size we need
    //
    for (i = 0; i < nNumLines; i++ )
    {
        textSize += lstrlen(strTextArray[i]);

        if ((i + 1) < nNumLines)
            textSize += lstrlen(_T("\r\n"));
    }

    //
    // Get the lines, with \r\n separating them
    //
	DBG_SAVE_FILE_LINE
    pText = new TCHAR[textSize + 1];
    if (!pText)
    {
        ERROR_OUT(("GetText failing; couldn't allocate TCHAR array"));
    }
    else
    {
        // Null this out in casae textSize is 0.
        pStartText = pText;
        pStartText[0] = 0;

        for (i = 0; i < nNumLines; i++)
        {
            lstrcpy(pStartText, strTextArray[i]);
            pStartText += lstrlen(strTextArray[i]);

            if ((i + 1) < nNumLines)
            {
                lstrcpy(pStartText, _T("\r\n"));
                pStartText += lstrlen(_T("\r\n"));
            }
        }

        ::SetWindowText(m_pEditBox->m_hwnd, pText);
        delete pText;
    }
}




void WbTextEditor::CalculateBoundsRect( void )
{
    RECT    cEWndRect;

    ASSERT(m_pEditBox);

    ::GetClientRect(m_pEditBox->m_hwnd, &cEWndRect);
    ::MapWindowPoints(m_pEditBox->m_hwnd, g_pDraw->m_hwnd,
        (LPPOINT)&cEWndRect, 2);

    m_rect = cEWndRect;
    ::OffsetRect(&m_rect, g_pDraw->m_originOffset.cx+1 + m_pEditBox->m_ptNTBooger.x,
                           g_pDraw->m_originOffset.cy + m_pEditBox->m_ptNTBooger.y);//+1 );

	SetBoundsRect(&m_rect);

    ::BringWindowToTop(m_pEditBox->m_hwnd);
}




// set editbox visibility
void WbTextEditor::ShowBox( int nShow )
{
    if (m_nLastShow == nShow)
    {
        if( nShow == SW_SHOW)
            ::SetFocus(m_pEditBox->m_hwnd);

        return;
    }

    m_nLastShow = nShow;

    if (nShow == SW_SHOW)
    {
        // show it
        if (m_pEditBox != NULL)
        {
            ::ShowWindow(m_pEditBox->m_hwnd, SW_SHOW);
            ::BringWindowToTop(m_pEditBox->m_hwnd);
            ::SetFocus(m_pEditBox->m_hwnd);

            ::HideCaret(m_pEditBox->m_hwnd);
            m_pEditBox->FitBox();
            ::ShowCaret(m_pEditBox->m_hwnd);
        }
    }
    else
    {
        if (m_pEditBox != NULL)
        {
            ::ShowWindow(m_pEditBox->m_hwnd, SW_HIDE);
            m_bFirstSetFontCall = TRUE;
		
			KillTimer();

            delete m_pEditBox;
            m_pEditBox = NULL;
        }
    }
}



//
// Create()
//
// Creates the edit box window
//
BOOL WbTextEditor::Create( void )
{
    if (m_pEditBox == NULL)
    {
		DBG_SAVE_FILE_LINE
        m_pEditBox = new WbTextBox(this);
        if (m_pEditBox == NULL)
        {
            ERROR_OUT(("Couldn't create edit text box"));
            return(FALSE);
        }

        if (!m_pEditBox->Create(g_pDraw->m_hwnd))
        {
            ERROR_OUT(("WbTextEditor::Create failed; can't create edit field"));
            return(FALSE);
        }
    }

    return(TRUE);
}




void WbTextEditor::MoveBy(int cx, int cy)
{
    RECT cEWndRect;

    ::GetClientRect(m_pEditBox->m_hwnd, &cEWndRect);

    if ((m_rect.right - m_rect.left) < (cEWndRect.right - cEWndRect.left))
        m_rect.right = m_rect.left + (cEWndRect.right - cEWndRect.left);

    if ((m_rect.bottom - m_rect.top) < (cEWndRect.bottom - cEWndRect.top))
        m_rect.bottom = m_rect.top + (cEWndRect.bottom - cEWndRect.top);

    cEWndRect = m_rect;
    ::OffsetRect(&cEWndRect, -(g_pDraw->m_originOffset.cx+1 + m_pEditBox->m_ptNTBooger.x),
                          -(g_pDraw->m_originOffset.cy + m_pEditBox->m_ptNTBooger.y) );//+1) );

    ::BringWindowToTop(m_pEditBox->m_hwnd);
    ::MoveWindow(m_pEditBox->m_hwnd, cEWndRect.left, cEWndRect.top,
        cEWndRect.right - cEWndRect.left, cEWndRect.bottom - cEWndRect.top,
        TRUE);
}




void WbTextEditor::SetFont( LOGFONT *pLogFont, BOOL bDummy )
{
    // Ignore bDummy. Had to add that so polymorph will work correctly
    // for DCWbGraphicText::SetFont()

    // Have to delay recalc of bounding rect because editbox will have a
    // bogus (bad) font until SetFont is called. Can't call SetFont
    // before this because new font hasn't been made yet.

	TextObj::SetFont( pLogFont, FALSE );

	if(m_pEditBox)
	{
		::SendMessage(m_pEditBox->m_hwnd, WM_SETFONT, (WPARAM)m_hFont, TRUE);

		// now do bounding rect
		CalculateBoundsRect();

		if( m_bFirstSetFontCall )
	        m_bFirstSetFontCall = FALSE;
	    else
	    {
			::HideCaret(m_pEditBox->m_hwnd);

	        m_pEditBox->FitBox();
			m_pEditBox->AutoCaretScroll();

	        ::ShowCaret(m_pEditBox->m_hwnd);
		}
	}
}




void WbTextEditor::SetTimer( UINT nElapse )
{
    ::SetTimer(m_pEditBox->m_hwnd, TIMER_GRAPHIC_UPDATE, nElapse, NULL);
}



void WbTextEditor::KillTimer( void )
{
	if(m_pEditBox)
	{
		::KillTimer(m_pEditBox->m_hwnd, TIMER_GRAPHIC_UPDATE);
	}
}




// Resets editbox painting for a resized drawing window
void WbTextEditor::ParentResize( void )
{
    ::HideCaret(m_pEditBox->m_hwnd);
    m_pEditBox->FitBox();
    ::ShowCaret(m_pEditBox->m_hwnd);
}




void WbTextEditor::RedrawEditbox(void)
{
    ::InvalidateRect(m_pEditBox->m_hwnd, NULL, TRUE);
    m_pEditBox->FitBox();
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\txted.hpp ===
//
// TXTED.HPP
// Text Object Editor
//
// Copyright Microsoft 1998-
//
#ifndef __TXTED_HPP_
#define __TXTED_HPP_



#define MIN_IME_WINDOW    30 

#define MIN_FITBOX_CHARS 6

class WbTextEditor;

/////////////////////////////////////////////////////////////////////////////
// WbTextBox window

class WbTextBox
{
public:
	WbTextBox(WbTextEditor * pEditor);
    ~WbTextBox();

    BOOL Create(HWND hwndParent);

	BOOL FitBox( void );

	void AutoCaretScroll( void );

	int	GetMaxCharHeight( void );

	int	GetMaxCharWidth( void );

	void AbortEditGently( void );

    HWND    m_hwnd;
	POINT   m_ptNTBooger;

    friend LRESULT CALLBACK TextWndProc(HWND, UINT, WPARAM, LPARAM);

    WNDPROC m_pfnEditPrev;

protected:
    RECT    m_MaxRect;
	WbTextEditor *m_pEditor;
	RECT     m_rectErase;
	BOOL	 m_bInIME;
	BOOL	 m_bDontEscapeThisTime;

	void SetupBackgroundRepaint( POINT ptTopPaint, BOOL bNumLinesChanged=TRUE );
	void SelectAtLeastOne( void );

    void    OnClearCut(void);
    void    OnUndoPaste(void);
	void    OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	void    OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	void    OnTimer(UINT nIDEvent);
	void    OnLButtonUp(UINT nFlags, int x, int y);
	void    OnMouseMove(UINT nFlags, int x, int y);
    void    OnMove(int x, int y);
	void    OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
};

/////////////////////////////////////////////////////////////////////////////


//
//
// Class:   WbTextEditor
//
// Purpose: Allow editing of the text in a DCWbGraphicText object
//
//
class WbTextEditor : public TextObj
{
	friend class WbTextBox;
    friend class WbDrawingArea;
	
	public:
    //
    // Constructor
    //
    WbTextEditor(void);
   ~WbTextEditor(void);

    // writes text to underlying text object before relaying to text object
    DWORD CalculateExternalLength(void);

	// calcs bounds rect and sets editbox to new size
    void CalculateBoundsRect(void);

	void SetTimer( UINT nElapse );
	void KillTimer( void );
  
	// set editbox visibility
	void ShowBox( int nShow );

	BOOL Create( void );

	// Moves underlying text object and then moves editbox rect
    void MoveBy(int cx, int cy);

	void RedrawEditbox(void);

	// resets editbox for parent resizing
	void ParentResize( void );

	// clipboard
	void Copy( void ) 
		{ ::SendMessage(m_pEditBox->m_hwnd, WM_COPY, 0, 0); }

	void Cut( void ) 
        { ::SendMessage(m_pEditBox->m_hwnd, WM_CUT, 0, 0); }

	void Paste( void ) 
        { ::SendMessage(m_pEditBox->m_hwnd, WM_PASTE, 0, 0); }

    virtual void SetFont( LOGFONT *pLogFont, BOOL bDummy=TRUE );
    virtual void SetFont(HFONT hFont) { TextObj::SetFont(hFont); }

    //
    // Attach a text object to the editor.  This function copies the
    // contents of the specified text object into the text editor.  The
    // editor will not alter the contents of the object passed and does not
    // keep a copy of the pointer parameter.
    //
    BOOL SetTextObject(TextObj * ptext);

    //
    // Return the width and height for the cursor in pixels as a size
    //
    void GetCursorSize(LPSIZE lpsize);

    //
    // Set the current edit cursor position from a point specified in
    // logical co-ordinates.  This function does nothing if the point
    // specified is outside the bounding rectangle of the object being
    // edited.  If the point specified is within the bounding rectangle the
    // current edit cursor position is updated to a point as close as
    // possible to that passed as parameter.
    //
    void SetCursorPosFromPoint(POINT pointXY);

    void Clear(void);                // Delete all text
    BOOL New(void);                  // Delete text and reset handles

    //
    // Return TRUE if there is not text in the object
    //
    BOOL IsEmpty(void);

	void AbortEditGently( void )
		{m_pEditBox->AbortEditGently();}

	WbTextBox *m_pEditBox;

protected:
    //
    // Pixel position from a character position
    //
    void GetXYPosition(POINT pointChar, LPPOINT lpptGet);

    //
    // Current cursor position.  Note that cursorCharPos.x gives the BYTE
    // position of the cursor rather than the character position.  On SBCS
    // systems the character and byte positions will always be the same,
    // but on DBCS systems the number of bytes in a string can be greater
    // than the number of characters.
    //
    // cursorCharPos.x should NEVER be set to a byte count which is in the
    // middle of a double byte character.
    //
    POINT   m_cursorCharPos;
    POINT   m_cursorXYPos;

	int	 m_nLastShow;
	void PutText(void);
	void GetText(void);
};


#endif // __TXTED_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\wgrp.hpp ===
//
// WGRP.HPP
// Widths Group
//
// Copyright Microsoft 1998-
//

#ifndef __WGRP_HPP
#define __WGRP_HPP


#define WIDTHBAR_WIDTH	TOOLBAR_WIDTH
#define WIDTHBAR_HEIGHT	50




class WbWidthsGroup
{
public:
	WbWidthsGroup();
    ~WbWidthsGroup();

	BOOL    Create(HWND hwndParent, LPCRECT lprect);
    void    GetNaturalSize(LPSIZE lpsize);

    void    PushDown(UINT uiIndex);
    int     ItemFromPoint(int x, int y) const;
    void    GetItemRect(int iItem, LPRECT lprc) const;

    HWND    m_hwnd;

    friend LRESULT CALLBACK  WGWndProc(HWND, UINT, WPARAM, LPARAM);

protected:
    void    OnPaint(void);
    void    OnLButtonDown(int x, int y);

	UINT    m_uLast;
    UINT    m_cyItem;
};

#endif // __WGRP_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\wbloader.h ===
#ifndef _WhiteBoard_AppletLoader_H_
#define _WhiteBoard_AppletLoader_H_

#include <iappldr.h>


class WBLoader : public CRefCount, public IAppletLoader
{
public:

    WBLoader(void);
    ~WBLoader(void);

    // IAppletLoader methods
    STDMETHOD_(void,           ReleaseInterface)(void);
	STDMETHOD_(APPLDR_RESULT,  AppletStartup)(BOOL fNoUI);
	STDMETHOD_(APPLDR_RESULT,  AppletCleanup)(DWORD dwTimeout);
	STDMETHOD_(APPLDR_RESULT,  AppletInvoke)(BOOL fRemote, T120ConfID nConfID, LPSTR pszCmdLine);
    STDMETHOD_(APPLDR_RESULT,  AppletQuery)(APPLET_QUERY_ID eQueryId);
    STDMETHOD_(APPLDR_RESULT,  OnNM2xNodeJoin)(void);
};


#endif // _WhiteBoard_AppletLoader_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\wbloader.cpp ===
#include "precomp.h"
#include "wbloader.h"
#include "nmwbobj.h"

WBLoader   *g_pWBLoader = NULL;
HANDLE      g_hWorkThread = NULL;
BOOL        g_fShutdownByT120 = FALSE;

DWORD __stdcall WBWorkThreadProc(LPVOID lpv);

TCHAR g_PassedFileName [MAX_PATH * 2];

T120Error CALLBACK CreateAppletLoaderInterface
(
    IAppletLoader     **ppOutIntf
)
{
    if (NULL != ppOutIntf)
    {
        if (NULL == g_pWBLoader)
        {
            DBG_SAVE_FILE_LINE
            *ppOutIntf = (IAppletLoader *) new WBLoader();
            return ((NULL != *ppOutIntf) ? T120_NO_ERROR : T120_ALLOCATION_FAILURE);
        }
        return T120_ALREADY_INITIALIZED;
    }
    return T120_INVALID_PARAMETER;
}



//
// FT Applet Loader
//

WBLoader::WBLoader(void)
:
    CRefCount(MAKE_STAMP_ID('W','B','L','D'))
{

	ASSERT(NULL == g_pWBLoader);

    g_pWBLoader = this;
}


WBLoader::~WBLoader(void)
{
    ASSERT(this == g_pWBLoader);

    g_pWBLoader = NULL;
}


//
// Create the work thread and wait for its being started.
//
APPLDR_RESULT WBLoader::AppletStartup
(
    BOOL            fNoUI
)
{
    APPLDR_RESULT eRet = APPLDR_FAIL;
    if (0 == g_dwWorkThreadID)
    {
        HANDLE hSync = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL != hSync)
        {
            g_hWorkThread = ::CreateThread(NULL, 0, WBWorkThreadProc, hSync, 0, &g_dwWorkThreadID);
            if (NULL != g_hWorkThread)
            {
                ::WaitForSingleObject(hSync, 5000); // 5 seconds
                // ASSERT(g_pNMWBOBJ);
                eRet = APPLDR_NO_ERROR;
            }
            ::CloseHandle(hSync);
        }
    }
    return eRet;
}

//
APPLDR_RESULT WBLoader::AppletCleanup
(
    DWORD           dwTimeout
)
{
	if (g_pMain)
	{
		//
		// Last change to save
		//
		int rc = g_pMain->QuerySaveRequired(TRUE);
        if (rc == IDYES)
        {
            rc = (int)g_pMain->OnSave(FALSE);
        }

		if (rc == IDCANCEL)
		{
			return APPLDR_CANCEL_EXIT;
		}
	}

    g_fShutdownByT120 = TRUE;

    ::T120_AppletStatus(APPLET_ID_WB, APPLET_CLOSING);

    // notify the work thread to exit
    ::PostThreadMessage(g_dwWorkThreadID, WM_QUIT, 0, 0);

    // wait for the worker thread's going down
    ::WaitForSingleObject(g_hWorkThread, dwTimeout);

    return APPLDR_NO_ERROR;
}


APPLDR_RESULT WBLoader::AppletQuery(APPLET_QUERY_ID eQueryId)
{
    // Do nothing now
    return APPLDR_NO_ERROR;
}

APPLDR_RESULT WBLoader::OnNM2xNodeJoin(void)
{
    // Do nothing now
    return APPLDR_NO_ERROR;
}

APPLDR_RESULT WBLoader::AppletInvoke
(
    BOOL            fRemote,
    T120ConfID      nConfID,
    LPSTR           pszCmdLine
)
{
	::ZeroMemory(&g_PassedFileName, sizeof(g_PassedFileName));
	if(pszCmdLine)
	{
		lstrcpy(g_PassedFileName, pszCmdLine);
		if(g_pMain)
		{
			PostMessage(g_pMain->m_hwnd, WM_USER_LOAD_FILE, 0, 0);
		}
    }

	TRACE_MSG((">>>>AppletInvoke g_pMain = %x",g_pMain));

	if(g_pMain)
	{
		PostMessage(g_pMain->m_hwnd, WM_USER_BRING_TO_FRONT_WINDOW, 0, 0);
	}

    return APPLDR_NO_ERROR;
}


void WBLoader::ReleaseInterface(void)
{
    Release();
}


DWORD __stdcall WBWorkThreadProc(LPVOID lpv)
{

    HRESULT hr = S_OK;

    ::SetEvent((HANDLE) lpv);

	DBG_SAVE_FILE_LINE
	g_pNMWBOBJ  = new CNMWbObj();
	if (NULL == g_pNMWBOBJ || NULL == g_pMain)
	{
		ERROR_OUT(("WB_Startup: cannot create CNMWbObj"));
        hr = E_OUTOFMEMORY;
	}

	if(*g_PassedFileName)
	{
		PostMessage(g_pMain->m_hwnd, WM_USER_LOAD_FILE, 0, 0);
	}

    ::T120_AppletStatus(APPLET_ID_WB, APPLET_WORK_THREAD_STARTED);
	TRACE_MSG((">>>>WBWorkThreadProc APPLET_WORK_THREAD_STARTED"));

	if(g_pMain)
	{
		PostMessage(g_pMain->m_hwnd, WM_USER_BRING_TO_FRONT_WINDOW, 0, 0);
	}

    //
    // MESSAGE LOOP
    //
    if (S_OK == hr)
    {
	    MSG     msg;
	
    	while (::GetMessage(&msg, NULL, NULL, NULL))
	    {
	        if (!g_pMain->FilterMessage(&msg))
	        {
	
				::TranslateMessage(&msg);
    	    	::DispatchMessage(&msg);
    	    }
	    }
	}

	if(g_pNMWBOBJ)
	{
		delete  g_pNMWBOBJ;
		g_pNMWBOBJ = NULL;
	}

    ::T120_AppletStatus(APPLET_ID_WB, APPLET_WORK_THREAD_EXITED);

    g_dwWorkThreadID = 0;

	TRACE_MSG((">>>>WBWorkThreadProc APPLET_WORK_THREAD_EXITED"));

    if (! g_fShutdownByT120)
    {
        FreeLibraryAndExitThread(g_hInstance, 0);
    }

	return 0;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\user.hpp ===
//
// USER.HPP
// User Class
//
// Copyright Microsoft 1998-
//
#ifndef __USER_HPP_
#define __USER_HPP_


//
//
// Class:   WbUser
//
// Purpose: User object recorder
//
//
class DCWbGraphicPointer;

class WbUser
{
public:
    //
    // Constructor
    //
    WbUser(POM_OBJECT hUser = NULL);

    //
    // Destructor
    //
    ~WbUser(void);

    //
    // Return the user handle
    //
    POM_OBJECT Handle(void) const { return(m_hUser);}

    //
    // Refresh the user details
    //
    void Refresh(void);

    //
    // Update the external copy of the user information
    //
    void Update(void);

    //
    // Return the user name
    //
    LPCSTR Name(void) const { return(m_strName); }

    //
    // Synchronize the users page with other synced users
    //
    void Sync(void);
    void Unsync(void);

    //
    // Update the user's position from the sync position. This does not
    // change the sync position.
    //
    void GetSyncPosition(void);

    //
    // Update the sync position from the user's current position
    //
    void PutSyncPosition(void);

    //
    // Return a remote pointer object for this user
    //
    DCWbGraphicPointer* GetPointer(void) { return(m_pRemotePointer); }

    //
    // Put the user's remote pointer at the position specified
    //
    void PutPointer(WB_PAGE_HANDLE hPage, POINT point);

    //
    // Remove the user's remote pointer
    //
    void RemovePointer(void);

    //
    // Return TRUE if the user is synced
    //
    BOOL IsSynced(void) const { return m_bSynced; }

    //
    // Return TRUE if the user has the contents lock
    //
    BOOL HasContentsLock(void) const;

    //
    // Return TRUE if the user has their remote pointer active
    //
    BOOL IsUsingPointer(void) const;

    //
    // Return the current page of the user
    //
    WB_PAGE_HANDLE Page(void) const {return m_hPageCurrent; }
    void SetPage(WB_PAGE_HANDLE hPage);

    //
    // Return the current position within the page of the user
    //
    void  GetVisibleRect(LPRECT lprc) { *lprc = m_rectVisible; }
    void  SetVisibleRect(LPCRECT lprc);

    //
    // Return the page of the user's pointer
    //
    WB_PAGE_HANDLE PointerPage(void) const;

    //
    // Return the position of the user's pointer
    //
    void GetPointerPosition(LPPOINT lpptPos);

    //
    // Return the user's color
    //
    COLORREF Color(void) const { return(m_color); }

    //
    // Return TRUE if this is the local user
    //
    BOOL IsLocalUser(void) const { return(m_bLocalUser); }

    //
    // Operators
    //
    virtual WbUser& operator=(const WbUser& user);
    virtual BOOL operator!=(const WbUser& user) const;
    virtual BOOL operator==(const WbUser& user) const;

    //
    // Set zoom/unzoom state
    //
    void Zoom(void) { m_zoomed = TRUE; }
    void Unzoom(void) { m_zoomed = FALSE; }
    BOOL GetZoom(void) const { return(m_zoomed); }

protected:
    //
    // Core access handle
    //
    POM_OBJECT  m_hUser;

    //
    // Flag indicating Whether this is the local user
    //
    BOOL        m_bLocalUser;

    BOOL        m_zoomed;

    //
    // Local copies of the user information
    //
    char        m_strName[TSHR_MAX_PERSON_NAME_LEN];
    BOOL        m_bSynced;
    WB_PAGE_HANDLE  m_hPageCurrent;
    RECT        m_rectVisible;
    COLORREF    m_color;

    //
    // Graphic pointer associated with this user
    //
    DCWbGraphicPointer* m_pRemotePointer;
};


//
//
// Class:   WbUserList
//
// Purpose: Map from user handles to user object pointers
//
//
class WbUserList : public COBLIST
{
public:

    //
    // Destructor
    //
    ~WbUserList(void);

    //
    // Clear all entries from the map, deleting the associated object
    //
    void Clear(void);
};



//
// Return lock status
//
BOOL WB_Locked(void);
BOOL WB_ContentsLocked(void);
BOOL WB_GotLock(void);
BOOL WB_GotContentsLock(void);
BOOL WB_PresentationMode(void);



//
// Return an object representing the local user
//
WbUser* WB_LocalUser(void);

//
// Retrieving users
//
WbUser* WB_GetUser(POM_OBJECT hUser);
WbUser* WB_GetFirstUser(void);
WbUser* WB_GetNextUser(const WbUser* pUser);

//
// Return an object representing the user who has the lock
//
WbUser* WB_LockUser(void);




#endif // __USER_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\wboblist.cpp ===
// PRECOMP
#include "precomp.h"
   
VOID* CWBOBLIST::GetTail()
{
	if(m_pTail)
	{
		return m_pTail->pItem;
	}
	else
	{
		return NULL;
	}
}

VOID* CWBOBLIST::GetNext(WBPOSITION& rPos)
{
	ASSERT(rPos);
	
	VOID* pReturn = rPos->pItem;
	rPos = rPos->pNext;

	return pReturn;
}

VOID* CWBOBLIST::GetPrevious(WBPOSITION& rPos)
{
	ASSERT(rPos);
	
	VOID* pReturn = rPos->pItem;
	rPos = rPos->pPrev;

	return pReturn;
}

WBPOSITION CWBOBLIST::AddAt(VOID* pItem, WBPOSITION Pos)
{
	ASSERT(Pos);

	WBPOSITION posRet = NULL;

	DBG_SAVE_FILE_LINE
	if (posRet = new COBNODED)
	{
		posRet->pItem = pItem;
		posRet->pNext = Pos->pNext;
		posRet->pPrev = Pos;
		Pos->pNext = posRet;
		if(posRet->pNext)
		{
			posRet->pNext->pPrev = posRet;
		}
		else
		{
			m_pTail = posRet;
		}

	}
	
	return posRet;
}

VOID* CWBOBLIST::RemoveAt(WBPOSITION Pos)
{
	VOID* pReturn = NULL;

	if (m_pHead)
	{
		if (m_pHead == Pos)
		{
			// Removing the first element in the list
			
			m_pHead = Pos->pNext;
			pReturn = Pos->pItem;
			delete Pos;

			if(m_pHead != NULL)
			{
				m_pHead->pPrev = NULL;
			}
			else
			{
				// Removing the only element!
				m_pTail = NULL;
			}


		}
		else
		{
			WBPOSITION pCur = m_pHead;

			while (pCur && pCur->pNext)
			{
				if (pCur->pNext == Pos)
				{
					// Removing 
					
					pCur->pNext = Pos->pNext;
					
					if(pCur->pNext)
					{
						pCur->pNext->pPrev = pCur;
					}

					if (m_pTail == Pos)
					{
						m_pTail = pCur;
					}
					pReturn = Pos->pItem;
					delete Pos;
				}

				pCur = pCur->pNext;
			}
		}
	}

	return pReturn;
}

WBPOSITION CWBOBLIST::AddTail(VOID* pItem)
{
	WBPOSITION posRet = NULL;

	if (m_pTail)
	{
		DBG_SAVE_FILE_LINE
		if (m_pTail->pNext = new COBNODED)
		{
			m_pTail->pNext->pPrev = m_pTail;
			m_pTail = m_pTail->pNext;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
		}
	}
	else
	{
		ASSERT(!m_pHead);
		DBG_SAVE_FILE_LINE
		if (m_pHead = new COBNODED)
		{
			m_pTail = m_pHead;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
			m_pTail->pPrev = NULL;
		}
	}

	return m_pTail;
}

void CWBOBLIST::EmptyList()
{
    while (!IsEmpty()) {
        RemoveAt(GetHeadPosition());
    }
}

CWBOBLIST::~CWBOBLIST()
{
    ASSERT(IsEmpty());
}

WBPOSITION CWBOBLIST::GetPosition(void* _pItem)
{
    // For potential efficiency of lookup (if we switched to 
    // a doubly linked list), users should really store the WBPOSITION
    // of an item. For those that don't, this method is provided.

    WBPOSITION    pos = m_pHead;

    while (pos) {
        if (pos->pItem == _pItem) {
            break;
        }
		GetNext(pos);
    }
    return pos;
}

WBPOSITION CWBOBLIST::Lookup(void* pComparator)
{
    WBPOSITION    pos = m_pHead;

    while (pos) {
        if (Compare(pos->pItem, pComparator)) {
            break;
        }
		GetNext(pos);
    }
    return pos;
}


WBPOSITION CWBOBLIST::AddHead(VOID* pItem)
{
	WBPOSITION posRet = NULL;

	if (m_pHead)
	{
		DBG_SAVE_FILE_LINE
		if (posRet = new COBNODED)
		{
			posRet->pNext = m_pHead;
			m_pHead->pPrev = posRet;
			posRet->pItem = pItem;
			m_pHead = posRet;
			m_pHead->pPrev = NULL;
		}
	}
	else
	{
		ASSERT(!m_pTail);
		DBG_SAVE_FILE_LINE
		if (m_pHead = new COBNODED)
		{
			m_pTail = m_pHead;
			m_pHead->pItem = pItem;
			m_pHead->pNext = NULL;
			m_pHead->pPrev = NULL;
		}
	}

	return m_pHead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\wboblist.hpp ===
//
// CWBOBLIST.HPP
// User Class
//
// Copyright Microsoft 1998-
//
#ifndef __CWBOBLIST_HPP_
#define __CWBOBLIST_HPP_

// class COBNODED;
#define WBPOSITION COBNODED*

struct COBNODED
{
	WBPOSITION	pNext;
	WBPOSITION	pPrev;
	void*		pItem;
};

class CWBOBLIST
{
protected:
	WBPOSITION m_pHead;
	WBPOSITION m_pTail;
    virtual BOOL Compare(void* pItemToCompare, void* pComparator) 
        {return(pItemToCompare == pComparator);};
public:
	CWBOBLIST() : m_pHead(NULL), m_pTail(NULL) { };
	
	WBPOSITION	    GetHeadPosition() { return(m_pHead); };
	WBPOSITION	    GetTailPosition() { return(m_pTail); };
	virtual void *  RemoveAt(WBPOSITION rPos);
	WBPOSITION		AddAt(VOID* pItem, WBPOSITION Pos);
	virtual void *	ReplaceAt(WBPOSITION rPos, void* pNewItem)
	{
		void *pvoid = rPos->pItem;
		rPos->pItem = pNewItem;
		return(pvoid);
	}

	WBPOSITION		AddHead(void* pItem);
	WBPOSITION	    AddTail(void* pItem);
	BOOL		    IsEmpty() { return(!m_pHead); };
	void *		    GetHead(){return GetFromPosition(GetHeadPosition());};
	void *		    GetTail();
	void *		    GetNext(WBPOSITION& rPos);
	void*			GetPrevious(WBPOSITION& rPos);
    WBPOSITION      GetPosition(void* pItem);
    WBPOSITION      Lookup(void* pComparator);
    void            EmptyList();
    virtual         ~CWBOBLIST();
	void *			RemoveHead() { return RemoveAt(m_pHead); };
	void *			RemoveTail() { return RemoveAt(m_pTail); };
	void *		    GetFromPosition(WBPOSITION rPos){return (rPos == NULL ? NULL : rPos->pItem);};
};




#endif  __CWBOBLIST_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\wbcaps.h ===
// From T120 recomendation
#include <gcc.h>
#define _SI_CHANNEL_0                    8
#define _SI_BITMAP_CREATE_TOKEN         8
#define  _SI_WORKSPACE_REFRESH_TOKEN       9

enum T126Caps
{
Cap_None = 0,
Hard_Copy_Image,
Hard_Copy_Image_Bitmap_Max_Width,
Hard_Copy_Image_Bitmap_Max_Height,
Hard_Copy_Image_Bitmap_Any_Aspect_Ratio,
Hard_Copy_Image_Bitmap_Format_T_6,
Hard_Copy_Image_Bitmap_Format_T_82,
Soft_Copy_Workspace,
Soft_Copy_Workspace_Max_Width,
Soft_Copy_Workspace_Max_Height,
Soft_Copy_Workspace_Max_Planes = 10,
Soft_Copy_Color_16,
Soft_Copy_Color_202,
Soft_Copy_Color_True,
Soft_Copy_Plane_Editing,
Soft_Copy_Scaling,
Soft_Copy_Bitmap_No_Token_Protection,
Soft_Copy_Pointing,
Soft_Copy_Pointing_Bitmap_Max_Width,
Soft_Copy_Pointing_Bitmap_Max_Height,
Soft_Copy_Pointing_Bitmap_Format_T_82 = 20,
Soft_Copy_Annotation,
Soft_Copy_Annotation_Bitmap_Max_Width,
Soft_Copy_Annotation_Bitmap_Max_Height,
Soft_Copy_Annotation_Drawing_Pen_Min_Thickness,
Soft_Copy_Annotation_Drawing_Pen_Max_Thickness,
Soft_Copy_Annotation_Drawing_Ellipse,
Soft_Copy_Annotation_Drawing_Pen_Square_Nib,
Soft_Copy_Annotation_Drawing_Highlight,
Soft_Copy_Annotation_Bitmap_Format_T_82,
Soft_Copy_Image = 30,
Soft_Copy_Image_Bitmap_Max_Width,
Soft_Copy_Image_Bitmap_Max_Height,
Soft_Copy_Image_Bitmap_Any_Aspect_Ratio,
Soft_Copy_Image_Bitmap_Format_T_82_Differential,
Soft_Copy_Image_Bitmap_Format_T_82_Differential_Deterministic_Prediction,
Soft_Copy_Image_Bitmap_Format_T_82_12_Bit_Grey_Scale,
Soft_Copy_Image_Bitmap_Format_T_81_Extended_Sequential_DCT,
Soft_Copy_Image_Bitmap_Format_T_81_Progressive_DCT,
Soft_Copy_Image_Bitmap_Format_T_81_Spatial_DPCM,
Soft_Copy_Image_Bitmap_Format_T_81_Differential_Sequential_DCT = 40,
Soft_Copy_Image_Bitmap_Format_T_81_Differential_Progressive_DCT,
Soft_Copy_Image_Bitmap_Format_T_81_Differential_Spatial_DPCM,
Soft_Copy_Image_Bitmap_Format_T_81_Extended_Sequential_DCT_Arithmetic,
Soft_Copy_Image_Bitmap_Format_T_81_Progressive_DCT_Arithmetic,
Soft_Copy_Image_Bitmap_Format_T_81_Spatial_DPCM_Arithmetic,
Soft_Copy_Image_Bitmap_Format_T_81_Differential_Sequential_DCT_Arithmetic,
Soft_Copy_Image_Bitmap_Format_T_81_Differential_Progressive_DCT_Arithmetic,
Soft_Copy_Image_Bitmap_Format_T_81_Differential_Spatial_DPCM_Arithmetic,
Soft_Copy_Image_Bitmap_Format_T_81_YCbCr_420,
Soft_Copy_Image_Bitmap_Format_T_81_YCbCr_444 = 50,
Soft_Copy_Image_Bitmap_Format_T_81_RGB_444,
Soft_Copy_Image_Bitmap_Format_T_81__CIELab_420,
Soft_Copy_Image_Bitmap_Format_T_81_CIELab_422,
Soft_Copy_Image_Bitmap_Format_T_81_CIELab_444,
Soft_Copy_Image_Bitmap_Format_T_81_Non_Interleaved,
Soft_Copy_Image_Bitmap_Format_Uncompressed_YCbCr_420,
Soft_Copy_Image_Bitmap_Format_Uncompressed_YCbCr_444,
Soft_Copy_Image_Bitmap_Format_Uncompressed__CIELab_420,
Soft_Copy_Image_Bitmap_Format_Uncompressed_CIELab_422,
Soft_Copy_Image_Bitmap_Format_Uncompressed_CIELab_444 = 60,
Archive_Support,
Soft_Copy_Annotation_Drawing_Rotation,
Soft_Copy_Transparency_Mask,
Soft_Copy_Video_Window,
};

typedef struct tagCAPS
{
	T126Caps	CapValue;
	GCCCapType  Type;
	UINT		SICE_Count_Rule;
	UINT		MinValue;
	UINT		MaxValue;
	T126Caps	Dependency;
}GCCCAPABILITY;




GCCCAPABILITY GCCCaps[] = 
{
///*01*/Hard_Copy_Image,GCC_LOGICAL_CAPABILITY,2,0,0,Cap_None,
		//Negotiate the use of hard-copy image exchanges
		//This capability implies a maximum image size of 1728 horizontal by 2300 vertical
		//It also implies the ability to support unscaled image bitmap creation using either
		//Uncompressed or T_4 (G3) formats with a single bitplane and either fax1 or fax2 pixel aspect ratios.
///*02*/Hard_Copy_Image_Bitmap_Max_Width,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,1729,21845,Hard_Copy_Image,
		//Negotiate the maximum width of an image bitmap for hard-copy image exchanges
		//This dimension is relative to the pixel aspect ratio of the image.
///*03*/Hard_Copy_Image_Bitmap_Max_Height,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,2301,21845,Hard_Copy_Image,
		//Negotiate the maximum height of an image bitmap for hard-copy image exchanges
		//This dimension is relative to the pixel aspect ratio of the image.
///*04*/Hard_Copy_Image_Bitmap_Any_Aspect_Ratio,GCC_LOGICAL_CAPABILITY,1,0,0,Hard_Copy_Image,
		//Negotiate the ability to transmit image bitmaps to a hard-copy workspace with an arbitrary aspect ratio.
///*05*/Hard_Copy_Image_Bitmap_Format_T_6,GCC_LOGICAL_CAPABILITY,1,0,0,Hard_Copy_Image,
		//Negotiate the ability to support bitmap creation using T_6 (G4) image compression format
		//with a single bitplane and either fax1 or fax2 pixel aspect ratios.
///*06*/Hard_Copy_Image_Bitmap_Format_T_82,GCC_LOGICAL_CAPABILITY,1,0,0,Hard_Copy_Image,
		//Negotiate the ability to support bitmap creation using T_82 (JBIG) image compression format
		//This capability implies the ability to handle 1 bit plane with 1:1 pixel aspect ratio and the
		//ability to only handle bitmaps encoded without the use of JBIG resolution reduction.
  /*07*/Soft_Copy_Workspace,GCC_LOGICAL_CAPABILITY,2,0,0,Cap_None,
		//Negotiate the ability to support at least one workspace for soft-copy information
		//This capability implies a maximum workspace size of 384 horizontal by 288 vertical
		//with workspace background colors Black and White.
		//Presence of this capability also implies that one of the capabilities Soft-Copy-Annotation
		//or Soft-Copy-Image shall also be included in the Application Capabilities List.
  /*08*/Soft_Copy_Workspace_Max_Width,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,385,21845,Soft_Copy_Workspace,
		//Negotiate the maximum workspace width.  This dimension is relative to a 1:1 pixel aspect ratio (square pixels).
  /*09*/Soft_Copy_Workspace_Max_Height,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,289,21845,Soft_Copy_Workspace,
		//Negotiate the maximum workspace height.  This dimension is relative to a 1:1 pixel aspect ratio (square pixels).
  /*10*/Soft_Copy_Workspace_Max_Planes,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,2,256,Soft_Copy_Workspace,
		//Negotiate the maximum number of planes allowed in any workspace.
  /*11*/Soft_Copy_Color_16,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Workspace,
		//Negotiate the use of the 16-color palette for use in workspace backgrounds or,
		//if the Soft-Copy-Annotation capability is negotiated, in drawing elements.
  /*12*/Soft_Copy_Color_202,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Workspace,
		//Negotiate the use of the 202 color palette for use in workspace backgrounds or,
		//if the Soft-Copy-Annotation capability is negotiated, in drawing elements.
  /*13*/Soft_Copy_Color_True,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Workspace,
		//Negotiate the use of the true color (24-bit RGB) as well as the use of the 202 color palette
		//for use in workspace backgrounds or, if the Soft-Copy-Annotation capability is negotiated, in drawing elements.
  /*14*/Soft_Copy_Plane_Editing,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Workspace,
		//Negotiate the ability to declare any workspace plane to be editable.
  /*15*/Soft_Copy_Scaling,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Workspace,
		//Negotiate the ability to declare a scaling rectangle during creation of soft-copy bitmaps
		//Without this capability, bitmaps are applied to the destination workspace without scaling
		//(other than that required for non 1:1 pixel aspect ratios).
///*16*/Soft_Copy_Bitmap_No_Token_Protection,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Workspace,
		//Negotiate the ability to transmit soft-copy bitmaps of any variety without the need to hold the SI-BITMAP-CREATE-TOKEN.
///*17*/Soft_Copy_Pointing,GCC_LOGICAL_CAPABILITY,2,0,0,Soft_Copy_Workspace,
		//Negotiate the use of pointer bitmaps on soft-copy workspaces
		//Successful negotiation of this capability  allows the following coding formats  and associated
		//parameter constraints for pointer bitmaps:1. Uncompressed format of either 8-bit greyscale,
		//RGB 4:4:4 or 1, 4, or 8 bit palettized with a 1:1 pixel aspect ratio
		//This capability implies the ability to handle pointer bitmaps up to a maximum size of 32 by 32 pixels.
///*18*/Soft_Copy_Pointing_Bitmap_Max_Width,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,33,21845,Soft_Copy_Pointing,
		//Negotiate the maximum width of a pointer bitmap
		//This dimension is relative to a 1:1 pixel aspect ratio (square pixels).
///*19*/Soft_Copy_Pointing_Bitmap_Max_Height,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,33,21845,Soft_Copy_Pointing,
		//Negotiate the maximum height of a pointer bitmap
		//This dimension is relative to a 1:1 pixel aspect ratio (square pixels).
///*20*/Soft_Copy_Pointing_Bitmap_Format_T_82,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Pointing,
		//Negotiate the ability to use T_82 (JBIG) compression format for encoding pointer bitmaps
		//This capability implies the ability to handle either 8-bit greyscale, or up to
		//8 palettized bitplanes with a 1:1 pixel aspect ratio and the ability to only handle bitmaps
		//encoded without the use of JBIG resolution reduction.
  /*21*/Soft_Copy_Annotation,GCC_LOGICAL_CAPABILITY,2,0,0,Soft_Copy_Workspace,
		//Negotiate the use of annotation on soft-copy workspaces
		//The presence of this capability in the negotiated capability set implies the ability to create
		//workspaces with annotation specified as the usage-designator of workspace planes
		//Successful negotiation of this capability also allows the following coding formats
		//and associated parameter constraints for annotation bitmaps:
		//1. Uncompressed bitmap format of either 8-bit greyscale, RGB 4:4:4 or 1, 4,
		//or 8 bit palettized raster and color formats with a 1:1 pixel aspect ratio
		//This capability also implies the ability to support the creation of drawings using
		//the DrawingCreatePDU with a pen thickness of 3 to 16 pixels, and a round pen nib. 
///*22*/Soft_Copy_Annotation_Bitmap_Max_Width,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,385,65536,Soft_Copy_Annotation,
		//Negotiate the maximum width of an annotation bitmap
		//This dimension is relative to a 1:1 pixel aspect ratio (square pixels).
///*23*/Soft_Copy_Annotation_Bitmap_Max_Height,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,289,65536,Soft_Copy_Annotation,
		//Negotiate the maximum height of an annotation bitmap
		//This dimension is relative to a 1:1 pixel aspect ratio (square pixels).
  /*24*/Soft_Copy_Annotation_Drawing_Pen_Min_Thickness,GCC_UNSIGNED_MAXIMUM_CAPABILITY,1,1,2,Soft_Copy_Annotation,
		//Negotiate the Minimum thickness in pixels of lines drawn using the DrawingCreatePDU.
  /*25*/Soft_Copy_Annotation_Drawing_Pen_Max_Thickness,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,17,255,Soft_Copy_Annotation,
		//The capability is used to negotiate the maximum thickness in pixels of lines drawn using the DrawingCreatePDU.
  /*26*/Soft_Copy_Annotation_Drawing_Ellipse,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Annotation,
		//Negotiate the ability to use the ellipse drawing type when using the DrawingCreatePDU.
///*27*/Soft_Copy_Annotation_Drawing_Pen_Square_Nib,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Annotation,
		//Negotiate the ability to use a square nib shape in creation of lines drawn using the DrawingCreatePDU.
  /*28*/Soft_Copy_Annotation_Drawing_Highlight,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Annotation,
		//Negotiate the ability to make use of the Highlight line style for drawing.
///*29*/Soft_Copy_Annotation_Bitmap_Format_T_82,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Annotation,
		//Negotiate the ability to use T_82 (JBIG) compression format for encoding annotation bitmaps
		//This capability implies the ability to handle either 8-bit greyscale, or up to 8 palettized bitplanes
		//with a 1:1 pixel aspect ratio and  the ability to only handle bitmaps encoded without the use of JBIG
		//resolution reduction.
  /*30*/Soft_Copy_Image,GCC_LOGICAL_CAPABILITY,2,0,0,Soft_Copy_Workspace,
		//Negotiate the use of image bitmaps on soft-copy workspaces
		//The presence of this capability in the negotiated capability set implies the ability to create workspaces
		//with image specified as the usage-designator of workspace planes
		//Successful negotiation of this capability  allows the following coding formats  and associated parameter
		//constraints for image bitmaps:
		//1. JBIG: this capability implies the ability to handle either 8-bit greyscale, RGB 4:4:4,
		//or  up to 8 palettized bitplanes and  the ability to only handle bitmaps encoded without the use of JBIG
		//resolution reduction.  Both 1:1 and CIF pixel aspect ratios shall be supported
		//2. JPEG: this capability implies the ability to handle the Baseline DCT encoding mode, with baseline 
		//sequential transmission and 8 bit/sample data precision in component interleaved format only, using 
		//a color space and color resolution mode of YCbCr 4:2:2, or greyscale
		//Both 1:1 and CIF pixel aspect ratios shall be supported.
		//3. Uncompressed: this capability implies the ability to handle 8-bit greyscale, RGB 4:4:4, 
		//YCbCr 4:2:2, or palettized 1, 4, or 8 bits per pixel.  Both 1:1 and CIF pixel aspect ratios shall be supported.
///*31*/Soft_Copy_Image_Bitmap_Max_Width,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,385,65536,Soft_Copy_Image,
		//Negotiate the Maximum workspace width for soft-copy image bitmap exchanges
		//This dimension is relative to the pixel aspect ratio of the image bitmap.
///*32*/Soft_Copy_Image_Bitmap_Max_Height,GCC_UNSIGNED_MINIMUM_CAPABILITY,1,289,65536,Soft_Copy_Image,
		//Negotiate the Maximum workspace height for soft-copy image bitmap exchanges
		//This dimension is relative to the pixel aspect ratio of the image bitmap.
///*33*/Soft_Copy_Image_Bitmap_Any_Aspect_Ratio,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to transmit image bitmaps to a soft-copy workspace with an arbitrary aspect ratio.
///*34*/Soft_Copy_Image_Bitmap_Format_T_82_Differential,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use resolution reduction (differential layers) when encoding a JBIG format image bitmap
///*35*/Soft_Copy_Image_Bitmap_Format_T_82_Differential_Deterministic_Prediction,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image_Bitmap_Format_T_82_Differential,
		//Negotiate the ability to use deterministic prediction when encoding a JBIG 
		//format image bitmap using resolution reduction (differential layers).
///*36*/Soft_Copy_Image_Bitmap_Format_T_82_12_Bit_Grey_Scale,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use 12 bit planes when encoding a JBIG format image bitmap.
///*37*/Soft_Copy_Image_Bitmap_Format_T_81_Extended_Sequential_DCT,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Extended Sequential DCT mode when encoding a JPEG format image bitmap.
///*38*/Soft_Copy_Image_Bitmap_Format_T_81_Progressive_DCT,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Progressive DCT mode when encoding a JPEG format image bitmap.
///*39*/Soft_Copy_Image_Bitmap_Format_T_81_Spatial_DPCM,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Spatial DPCM mode when encoding a JPEG format image bitmap.
///*40*/Soft_Copy_Image_Bitmap_Format_T_81_Differential_Sequential_DCT,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Differential Sequential DCT mode when encoding a JPEG format image bitmap.
///*41*/Soft_Copy_Image_Bitmap_Format_T_81_Differential_Progressive_DCT,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Differential Progressive DCT mode when encoding a JPEG format image bitmap.
///*42*/Soft_Copy_Image_Bitmap_Format_T_81_Differential_Spatial_DPCM,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Differential Spatial DPCM mode when encoding a JPEG format image bitmap.
///*43*/Soft_Copy_Image_Bitmap_Format_T_81_Extended_Sequential_DCT_Arithmetic,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Extended Sequential DCT mode using Arithmetic encoding when encoding a JPEG 
		//format image bitmap.
///*44*/Soft_Copy_Image_Bitmap_Format_T_81_Progressive_DCT_Arithmetic,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Progressive DCT mode using Arithmetic encoding when encoding a JPEG format image bitmap.
///*45*/Soft_Copy_Image_Bitmap_Format_T_81_Spatial_DPCM_Arithmetic,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Spatial DPCM mode using Arithmetic encoding when encoding a JPEG format image bitmap.
///*46*/Soft_Copy_Image_Bitmap_Format_T_81_Differential_Sequential_DCT_Arithmetic,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Differential Sequential DCT mode using Arithmetic encoding when encoding a JPEG 
		//format image bitmap.
///*47*/Soft_Copy_Image_Bitmap_Format_T_81_Differential_Progressive_DCT_Arithmetic,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Differential Progressive DCT mode using Arithmetic encoding when encoding a JPEG 
		//format image bitmap.
///*48*/Soft_Copy_Image_Bitmap_Format_T_81_Differential_Spatial_DPCM_Arithmetic,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use Differential Spatial DPCM mode using Arithmetic encoding when encoding a JPEG 
		//format image bitmap.
///*49*/Soft_Copy_Image_Bitmap_Format_T_81_YCbCr_420,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of YCbCr 4:2:0 when encoding a JPEG format image bitmap.
///*50*/Soft_Copy_Image_Bitmap_Format_T_81_YCbCr_444,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of YCbCr 4:4:4 when encoding a JPEG format image bitmap.
///*51*/Soft_Copy_Image_Bitmap_Format_T_81_RGB_444,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of RGB 4:4:4 when encoding a JPEG format image bitmap.
///*52*/Soft_Copy_Image_Bitmap_Format_T_81__CIELab_420,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of CIELab 4:2:0 when encoding a JPEG format image bitmap.
///*53*/Soft_Copy_Image_Bitmap_Format_T_81_CIELab_422,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of CIELab 4:2:2 when encoding a JPEG format image bitmap.
///*54*/Soft_Copy_Image_Bitmap_Format_T_81_CIELab_444,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of CIELab 4:4:4 when encoding a JPEG format image bitmap.
///*55*/Soft_Copy_Image_Bitmap_Format_T_81_Non_Interleaved,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use non-interleaved ordering of color components.
///*56*/Soft_Copy_Image_Bitmap_Format_Uncompressed_YCbCr_420,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of YCbCr 4:2:0 when encoding an Uncompressed format image bitmap.
///*57*/Soft_Copy_Image_Bitmap_Format_Uncompressed_YCbCr_444,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of YCbCr 4:4:4 when encoding an Uncompressed format image bitmap.
///*58*/Soft_Copy_Image_Bitmap_Format_Uncompressed__CIELab_420,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of CIELab 4:2:0 when encoding an Uncompressed format image bitmap.
///*59*/Soft_Copy_Image_Bitmap_Format_Uncompressed_CIELab_422,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of CIELab 4:2:2 when encoding an Uncompressed format image bitmap.
///*60*/Soft_Copy_Image_Bitmap_Format_Uncompressed_CIELab_444,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Image,
		//Negotiate the ability to use a chroma format of CIELab 4:4:4 when encoding an Uncompressed format image bitmap.
///*61*/Archive_Support,GCC_LOGICAL_CAPABILITY,0,0,0,Cap_None,
		//Negotiate the support of archives.
///*62*/Soft_Copy_Annotation_Drawing_Rotation,GCC_LOGICAL_CAPABILITY,1,0,0,Soft_Copy_Annotation,
		//This capability is used to negotiate the ability to specify the optional 
		//rotation parameter that defines a rotation to be applied to annotation 
		//drawing elements.
///*63*/Soft_Copy_Transparency_Mask,GCC_LOGICAL_CAPABILITY,2,0,0,Soft_Copy_Image,
		//This capability is used to negotiate the ability to use arbitrary 
		//transparency masks for applicable graphical elements allowing arbitrary 
		//pixels within these objects to be interpreted as transparent. This capability 
		//also implies the support of JBIG compression given that a transparency mask 
		//can be optionally encoded in this manner.
///*64*/Soft_Copy_Video_Window,GCC_LOGICAL_CAPABILITY,2,0,0,Soft_Copy_Image
		//This capability is used to negotiate the ability to define video windows that 
		//can encapsulate out of band video streams in a workspace. Successful 
		//negotiation of this capability between two or more session participants 
		//enables the use of the VideoWindowCreatePDU, VideoWindowDeletePDU and 
		//VideoWindowEditPDU.
};


const USHORT _iT126_MAX_COLLAPSING_CAPABILITIES   = sizeof(GCCCaps)/sizeof(GCCCAPABILITY);

static ULONG T126KeyNodes[] = {0,0,20,126,0,1};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\wgrp.cpp ===
//
// WGRP.CPP
// Widths Group
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


static const TCHAR szWGClassName[] = "T126WB_WGRP";


WbWidthsGroup::WbWidthsGroup()
{
    int     i;

    m_hwnd  = NULL;
    m_uLast = 0;

    //
    // Calculate the height of each item in the list--it's the max of the
    // pen widths + slop space
    //
    m_cyItem = 0;
    for (i = 0; i < NUM_OF_WIDTHS; i++)
    {
        m_cyItem = max(m_cyItem, g_PenWidths[i]);
    }
    m_cyItem += 2 * ::GetSystemMetrics(SM_CYEDGE);
}


WbWidthsGroup::~WbWidthsGroup()
{
    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    ::UnregisterClass(szWGClassName, g_hInstance);
}



BOOL WbWidthsGroup::Create(HWND hwndParent, LPCRECT lprect)
{
    WNDCLASSEX      wc;

    // Register our class
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = WGWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszClassName    = szWGClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbWidthsGroup::Create register class failed"));
        return(FALSE);
    }

    ASSERT(!m_hwnd);

    if (!::CreateWindowEx(WS_EX_STATICEDGE, szWGClassName, NULL,
        WS_CHILD | WS_CLIPSIBLINGS, lprect->left, lprect->top,
        lprect->right - lprect->left, lprect->bottom - lprect->top,
        hwndParent, (HMENU)IDM_WIDTH, g_hInstance, this))
    {
        ERROR_OUT(("Can't create WbWidthsGroup"));
        return(FALSE);
    }

    return(TRUE);
}



//
// WGWndProc()
// Message handler for width window
//
LRESULT CALLBACK WGWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbWidthsGroup * pwg = (WbWidthsGroup *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pwg = (WbWidthsGroup *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pwg);

            pwg->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pwg);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pwg);
            pwg->m_hwnd = NULL;
            break;

        case WM_PAINT:
            ASSERT(pwg);
            pwg->OnPaint();
            break;

        case WM_LBUTTONDOWN:
            ASSERT(pwg);
            pwg->OnLButtonDown((short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_NOTIFY:
            // Pass up to main window
            lResult = ::SendMessage(g_pMain->m_hwnd, message, wParam, lParam);
            break;

        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}



void WbWidthsGroup::GetNaturalSize(LPSIZE lpsize)
{
    lpsize->cy = ::GetSystemMetrics(SM_CYEDGE) +
        (NUM_OF_WIDTHS * m_cyItem);

    if (m_hwnd != NULL)
    {
        RECT    rect;

        ::GetWindowRect(m_hwnd, &rect);
        rect.right -= rect.left;
        lpsize->cx = max(WIDTHBAR_WIDTH, rect.right);
    }
    else
    {
        lpsize->cx = WIDTHBAR_WIDTH;
    }
}



void WbWidthsGroup::PushDown(UINT uiIndex)
{
    if( (uiIndex < NUM_OF_WIDTHS))
    {
        //
        // We really should just invalidate the last selected item, if one,
        // and the new selected item, if one.  But heck, there are only 4
        // items, no big deal to paint.
        //
        m_uLast = uiIndex;
        ::InvalidateRect(m_hwnd, NULL, TRUE);
    }
}




void WbWidthsGroup::OnPaint(void)
{
    PAINTSTRUCT ps;
    int         i;
    RECT        rect;
    int         cx, cy;
    int         nPenWidth;
    HBRUSH      hOldBrush;

    ::BeginPaint(m_hwnd, &ps);

    ::GetClientRect(m_hwnd, &rect);
    cx = ::GetSystemMetrics(SM_CXEDGE);
    cy = m_cyItem / 2;

    // First, fill the background of the selected item
    hOldBrush = SelectBrush(ps.hdc, ::GetSysColorBrush(COLOR_3DHILIGHT));

    ::PatBlt(ps.hdc, rect.left, m_uLast * m_cyItem,
        rect.right - rect.left, m_cyItem, PATCOPY);

    rect.right -= rect.left + 2*cx;

    // Now, use the black brush
    SelectBrush(ps.hdc, ::GetStockObject(BLACK_BRUSH));

    for (i = 0; i < NUM_OF_WIDTHS; i++)
    {
        nPenWidth = g_PenWidths[i];

        ::PatBlt(ps.hdc, cx, rect.top + (m_cyItem - nPenWidth) / 2,
            rect.right, nPenWidth, PATCOPY);

        rect.top += m_cyItem;
    }

    SelectBrush(ps.hdc, hOldBrush);

    // Finish painting
    ::EndPaint(m_hwnd, &ps);
}



//
// ItemFromPoint()
// Returns which item, in the client, is under the point.
//
int WbWidthsGroup::ItemFromPoint(int x, int y) const
{
    int iItem;

    iItem = y / m_cyItem;

    // If it's in the border above the first item, pin it.
    if (iItem < 0)
        iItem = 0;

    // If it's in the border below the last item, pin it.
    if (iItem >= (IDM_WIDTHS_END - IDM_WIDTHS_START))
        iItem = (IDM_WIDTHS_END - IDM_WIDTHS_START - 1);

    return(iItem + IDM_WIDTHS_START);
}


//
// GetItemRect()
// Gets the client-relative rectangle of an item
//
void WbWidthsGroup::GetItemRect(int iItem, LPRECT lprc) const
{
    ::GetClientRect(m_hwnd, lprc);

    lprc->top = (iItem - IDM_WIDTHS_START) * m_cyItem;
    lprc->bottom = lprc->top + m_cyItem;
}


//
// OnLButtonDown()
//
void WbWidthsGroup::OnLButtonDown(int x, int y)
{
    int iItem;

    iItem = ItemFromPoint(x, y);
    ::PostMessage(g_pMain->m_hwnd, WM_COMMAND,
                    (WPARAM)MAKELONG(iItem, BN_CLICKED),
                    (LPARAM)m_hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\wrkspobj.cpp ===
//
// DRAWOBJ.CPP
// Drawing objects: point, openpolyline, closepolyline, ellipse
//
// Copyright Microsoft 1998-
//
#include "precomp.h"
#include "NMWbObj.h"

WorkspaceObj* g_pCurrentWorkspace;
WorkspaceObj* g_pConferenceWorkspace;

//
// Created from UI
//
WorkspaceObj::WorkspaceObj ( void )
{

	ResetAttrib();

	SetOwnerID(g_MyMemberID);

	SetType(workspaceCreatePDU_chosen);

	//
	// Workspace Identifier
	//
	SetWorkspaceHandle(0);

	//
	// Application Roster Instance
	//
    m_appRosterInstance = g_pNMWBOBJ->m_instanceNumber;

	//
	// Is Wokspace synchronized
	//
    m_bsynchronized = TRUE;

	//
	// Does workspace accept keyboard events
	//
    m_acceptKeyboardEvents = FALSE;

	//
	// Does workspace accept mouse events
	//
    m_acceptPointingDeviceEvents = FALSE;

	SetViewState(focus_chosen);

	SetUpdatesEnabled(!g_pDraw->IsLocked());

	//
	// Workspace max width and height
	//
    m_workspaceSize.x = DRAW_WIDTH;		// Max width
    m_workspaceSize.y = DRAW_HEIGHT;	// Max height in Draw.hpp

	RECT rect;
	rect.top = 0;
	rect.left = 0;
	rect.right = m_workspaceSize.x;
	rect.bottom = m_workspaceSize.y;
	SetRect(&rect);
}


//
// Created from Remote
//
WorkspaceObj::WorkspaceObj (WorkspaceCreatePDU * pWorkspaceCreatePDU, BOOL bForcedResend)
{

	ResetAttrib();
	SetType(workspaceCreatePDU_chosen);

	SetUpdatesEnabled(TRUE);

	//
	// Workspace Identifier
	//
	SetWorkspaceHandle(GetWorkspaceIdentifier(&pWorkspaceCreatePDU->workspaceIdentifier));
	SetThisObjectHandle(GetWorkspaceHandle());

#ifdef _DEBUG

	//
	// Application Roster Instance
	//
    m_appRosterInstance = pWorkspaceCreatePDU->appRosterInstance;
	TRACE_DEBUG(("m_appRosterInstance = %d", m_appRosterInstance));

	//
	// Is Wokspace synchronized
	//
    m_bsynchronized = pWorkspaceCreatePDU->synchronized;
	TRACE_DEBUG(("m_bsynchronized = %d", m_bsynchronized));

	//
	// Does workspace accept keyboard events
	//
    m_acceptKeyboardEvents = pWorkspaceCreatePDU->acceptKeyboardEvents;
	TRACE_DEBUG(("m_acceptKeyboardEvents = %d", m_acceptKeyboardEvents));

	//
	// Does workspace accept mouse events
	//
     m_acceptPointingDeviceEvents = pWorkspaceCreatePDU->acceptPointingDeviceEvents;
	TRACE_DEBUG(("m_acceptPointingDeviceEvents = %d", m_acceptPointingDeviceEvents));

	//
	// List of nodes that can access workspace
	//
	if(pWorkspaceCreatePDU->bit_mask & protectedPlaneAccessList_present)
	{
		WorkspaceCreatePDU_protectedPlaneAccessList_Element *pNode;
		pNode = pWorkspaceCreatePDU->protectedPlaneAccessList;
		do
		{
			BYTE * pByte;
			DBG_SAVE_FILE_LINE
			pByte = new BYTE[1];
			*pByte = (UCHAR)pNode->value;
			m_protectedPlaneAccessList.AddTail(pByte);
			pNode = pNode->next;		
		}while (pNode);

	}

	//
	// Workspace max width and height
	//
    m_workspaceSize.x = pWorkspaceCreatePDU->workspaceSize.width;
    m_workspaceSize.y = pWorkspaceCreatePDU->workspaceSize.height;
	TRACE_DEBUG(("m_workspaceSize(x,y) = (%d, %d)", m_workspaceSize.x, m_workspaceSize.y));

	RECT rect;
	rect.top = 0;
	rect.left = 0;
	rect.right = m_workspaceSize.x;
	rect.bottom = m_workspaceSize.y;
	SetRect(&rect);

	//
	// Workspace attributes
	//
	if(pWorkspaceCreatePDU->bit_mask & workspaceAttributes_present)
	{
		GetWorkSpaceAttrib(pWorkspaceCreatePDU->workspaceAttributes);
	}

	//
	// Workspace plane parameters
	//
	GetWorkSpacePlaneParam(pWorkspaceCreatePDU->planeParameters);


	//
	// Workspace view parameters
	//
	if(pWorkspaceCreatePDU->bit_mask & viewParameters_present)
	{
		m_viewHandle = pWorkspaceCreatePDU->viewParameters->value.viewHandle;
		TRACE_DEBUG(("View Handle = %d", m_viewHandle));
		
		if(pWorkspaceCreatePDU->viewParameters->value.bit_mask & viewAttributes_present)
		{
			GetWorkSpaceViewParam(pWorkspaceCreatePDU->viewParameters->value.viewAttributes);
		}
	}

#endif // 0

	//
	// Add it to the list of workspaces
	//
	AddNewWorkspace(this, bForcedResend);

}



WorkspaceObj::~WorkspaceObj( void )
{
	RemoveObjectFromResendList(this);
	RemoveObjectFromRequestHandleList(this);

	//
	// Tell other nodes that we are gone
	//
	if(WasDeletedLocally())
	{
		OnObjectDelete();
	}

	//
	// Delete all the objects in this workspace
	//
	T126Obj * pObj;
    while ((pObj = (T126Obj *)m_T126ObjectsInWorkspace.RemoveTail()) != NULL)
    {
    	pObj->SetMyWorkspace(NULL);
		delete pObj;
		g_numberOfObjects--;
	}
	
	g_numberOfWorkspaces--;
}


void WorkspaceObj::WorkspaceEditObj ( WorkspaceEditPDU * pWorkspaceEditPDU )
{

	//
	// Workspace view parameters
	//
	if(pWorkspaceEditPDU->bit_mask & viewEdits_present)
	{
		GetWorkSpaceViewEditParam(pWorkspaceEditPDU->viewEdits);
	}

	if(HasUpatesEnabledStateChanged())
	{
		if(GetUpdatesEnabled())
		{
			g_pMain->UnlockDrawingArea();
		}
		else
		{
			g_pMain->LockDrawingArea();
		}

		g_pMain->UpdatePageButtons();
	}

	if(HasViewStateChanged() &&
		pWorkspaceEditPDU->viewEdits &&
		pWorkspaceEditPDU->viewEdits->value.action.choice == editView_chosen)
	{
		if(g_pDraw->IsSynced())
		{
			g_pMain->GotoPage(this, FALSE);
		}

		g_pConferenceWorkspace = this;
	}
	
	ResetAttrib();
	
#ifdef _DEBUG
	//
	// Workspace attributes
	//
	if(pWorkspaceEditPDU->bit_mask & WorkspaceEditPDU_attributeEdits_present)
	{
		GetWorkSpaceAttrib((WorkspaceCreatePDU_workspaceAttributes *)pWorkspaceEditPDU->attributeEdits);
	}

	//
	// Workspace plane parameters
	//
	if(pWorkspaceEditPDU->bit_mask & planeEdits_present)
	{
		GetWorkSpacePlaneParam((WorkspaceCreatePDU_planeParameters *)pWorkspaceEditPDU->planeEdits);
	}

#endif // 0
}

UINT WorkspaceObj::GetWorkspaceIdentifier(WorkspaceIdentifier *workspaceIdentifier)
{

	TRACE_DEBUG(("GetWorkspaceIdentifier choice = %d", workspaceIdentifier->choice));
	switch(workspaceIdentifier->choice)
	{
		case(activeWorkspace_chosen):
		{
			TRACE_MSG(("activeWorkspace = %d", workspaceIdentifier->u.activeWorkspace));
			return(workspaceIdentifier->u.activeWorkspace);
			break;
		}
//		case(archiveWorkspace_chosen):
//		{
//			break;
//		}
		default:
		{
		    ERROR_OUT(("Invalid workspaceIdentifier choice"));
			break;
		}
	}
	return -1;
}

void WorkspaceObj::CreateWorkspaceCreatePDU(WorkspaceCreatePDU * pWorkspaceCreatePDU)
{

	pWorkspaceCreatePDU->bit_mask = 0;
	//
	// Workspace Identifier, we have to ask GCC for an active unique workspace handle
	//
	pWorkspaceCreatePDU->workspaceIdentifier.choice = activeWorkspace_chosen;
	pWorkspaceCreatePDU->workspaceIdentifier.u.activeWorkspace = GetWorkspaceHandle();

	//
	// Application Roster Instance
	//
    pWorkspaceCreatePDU->appRosterInstance = (ASN1uint16_t)g_pNMWBOBJ->m_instanceNumber;

	//
	// Is Wokspace synchronized
	//
	pWorkspaceCreatePDU->synchronized = (ASN1bool_t)m_bsynchronized;

	//
	// Does workspace accept keyboard events
	//
	pWorkspaceCreatePDU->acceptKeyboardEvents = (ASN1bool_t)m_acceptKeyboardEvents;

	//
	// Does workspace accept mouse events
	//
	pWorkspaceCreatePDU->acceptPointingDeviceEvents = (ASN1bool_t)m_acceptPointingDeviceEvents;

	//
	// Workspace max width and height
	//
    pWorkspaceCreatePDU->workspaceSize.width = (USHORT)m_workspaceSize.x;
    pWorkspaceCreatePDU->workspaceSize.height = (USHORT)m_workspaceSize.y;


	//
	// Workspace plane parameters
	//
	PWorkspaceCreatePDU_planeParameters planeParameters;
	PWorkspaceCreatePDU_planeParameters_Seq_usage usage;
	PWorkspaceCreatePDU_planeParameters_Seq_usage pFirstUsage;

	//
	// Do the plane parameters
	//
	DBG_SAVE_FILE_LINE
	planeParameters = (PWorkspaceCreatePDU_planeParameters)new BYTE[sizeof(WorkspaceCreatePDU_planeParameters)];	
	pWorkspaceCreatePDU->planeParameters = planeParameters;
	planeParameters->value.bit_mask = planeAttributes_present;
	planeParameters->value.editable = TRUE;
	planeParameters->next = NULL;

	DBG_SAVE_FILE_LINE
	PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes pPlaneAttrib;
	pPlaneAttrib = (PWorkspaceCreatePDU_planeParameters_Seq_planeAttributes) new BYTE[sizeof(WorkspaceCreatePDU_planeParameters_Seq_planeAttributes)];
	pPlaneAttrib->value.choice = protection_chosen;
	pPlaneAttrib->value.u.protection.protectedplane = FALSE;
	pPlaneAttrib->next = NULL;
	
	planeParameters->value.planeAttributes = pPlaneAttrib;

	DBG_SAVE_FILE_LINE
	usage = (PWorkspaceCreatePDU_planeParameters_Seq_usage) new BYTE[sizeof(WorkspaceCreatePDU_planeParameters_Seq_usage)];
	pFirstUsage = usage;
	planeParameters->value.usage = usage;
	usage->value.choice = image_chosen;
	
	DBG_SAVE_FILE_LINE
	usage = (PWorkspaceCreatePDU_planeParameters_Seq_usage) new BYTE[sizeof(WorkspaceCreatePDU_planeParameters_Seq_usage)];
	planeParameters->value.usage->next = usage;
	usage->value.choice = annotation_chosen;
	usage->next = NULL;

	//
	// Do the plane parameters 2nd time
	//
	DBG_SAVE_FILE_LINE
	planeParameters->next = (PWorkspaceCreatePDU_planeParameters)new BYTE[sizeof(WorkspaceCreatePDU_planeParameters)];	
	planeParameters = planeParameters->next;
	planeParameters->value.bit_mask = planeAttributes_present;
	planeParameters->value.editable = TRUE;
	planeParameters->value.usage = pFirstUsage;
	planeParameters->next = NULL;
	planeParameters->value.planeAttributes = pPlaneAttrib;

	//
	// Do it hte 3rd time
	//
	planeParameters->next = (PWorkspaceCreatePDU_planeParameters)new BYTE[sizeof(WorkspaceCreatePDU_planeParameters)];	
	planeParameters = planeParameters->next;
	planeParameters->value.bit_mask = planeAttributes_present;
	planeParameters->value.editable = TRUE;
	planeParameters->value.usage = pFirstUsage;
	planeParameters->next = NULL;
	planeParameters->value.planeAttributes = pPlaneAttrib;


	pWorkspaceCreatePDU->viewParameters = NULL;
}

void WorkspaceObj::CreateWorkspaceDeletePDU(WorkspaceDeletePDU *pWorkspaceDeletePDU)
{
	pWorkspaceDeletePDU->bit_mask = 0;
	pWorkspaceDeletePDU->workspaceIdentifier.choice = activeWorkspace_chosen;
	pWorkspaceDeletePDU->workspaceIdentifier.u.activeWorkspace = GetWorkspaceHandle();
	pWorkspaceDeletePDU->reason.choice = userInitiated_chosen;
}

void WorkspaceObj::CreateWorkspaceEditPDU(WorkspaceEditPDU *pWorkspaceEditPDU)
{
	pWorkspaceEditPDU->bit_mask = 0;
	pWorkspaceEditPDU->workspaceIdentifier.choice = activeWorkspace_chosen;
	pWorkspaceEditPDU->workspaceIdentifier.u.activeWorkspace = GetWorkspaceHandle();

	PWorkspaceEditPDU_viewEdits_Set_action_editView pEditView = NULL;
	pWorkspaceEditPDU->viewEdits = NULL;
	
	if(HasUpatesEnabledStateChanged() || HasViewStateChanged())
	{
		pWorkspaceEditPDU->bit_mask |= viewEdits_present;
		DBG_SAVE_FILE_LINE
		pWorkspaceEditPDU->viewEdits = (PWorkspaceEditPDU_viewEdits)new BYTE[sizeof(WorkspaceEditPDU_viewEdits)];
		pWorkspaceEditPDU->viewEdits->next = NULL;
		pWorkspaceEditPDU->viewEdits->value.viewHandle = m_viewHandle;
		pWorkspaceEditPDU->viewEdits->value.action.choice = (ASN1choice_t)m_viewActionChoice;
		pWorkspaceEditPDU->viewEdits->value.action.u.editView = NULL;
	}
	
	if(HasUpatesEnabledStateChanged())
	{
		DBG_SAVE_FILE_LINE
		pEditView = (PWorkspaceEditPDU_viewEdits_Set_action_editView) new BYTE[sizeof (WorkspaceEditPDU_viewEdits_Set_action_editView)];
		pEditView->next = NULL;
		pEditView->value.choice = updatesEnabled_chosen;
		pEditView->value.u.updatesEnabled = (ASN1bool_t)GetUpdatesEnabled();
		pWorkspaceEditPDU->viewEdits->value.action.u.editView = pEditView;
	}


	if(HasViewStateChanged())
	{
		DBG_SAVE_FILE_LINE
		pEditView = (PWorkspaceEditPDU_viewEdits_Set_action_editView) new BYTE[sizeof (WorkspaceEditPDU_viewEdits_Set_action_editView)];
		pEditView->next = pWorkspaceEditPDU->viewEdits->value.action.u.editView;
		pEditView->value.choice = WorkspaceViewAttribute_viewState_chosen;
		pEditView->value.u.viewState.choice = (ASN1choice_t)GetViewState();
		pWorkspaceEditPDU->viewEdits->value.action.u.editView = pEditView;
	}
}


void WorkspaceObj::RemoveT126Object(T126Obj *pObj)
{

	//
	// The contents of the wb just changed
	//
	g_bContentsChanged = TRUE;

	//
	// Remove it from the List Of objcets in the workspace
	//
	WBPOSITION pos = m_T126ObjectsInWorkspace.GetPosition(pObj);

	m_T126ObjectsInWorkspace.RemoveAt(pos);

	//
	// Erase the drawing
	//
	pObj->DrawRect();
	pObj->UnselectDrawingObject();

	pObj->UnDraw();

	//
	// Put the object in the trash, don't delete it locally
	// but tell the other nodes to delete it
	//
	g_numberOfObjects--;

	g_pDraw->DeleteSelection();

	if(pObj != g_pMain->m_pLocalRemotePointer && pObj->WasDeletedLocally())
	{
		pObj->SetMyPosition(NULL);
		g_pTrash->AddTail( pObj );
		pObj->OnObjectDelete();
	}
	else
	{
		delete pObj;
	}
}


T126Obj* WorkspaceObj::FindObjectInWorkspace(UINT objectHandle)
{
	T126Obj* pObj;

	WBPOSITION pos;
	pos = m_T126ObjectsInWorkspace.GetTailPosition();
    while (pos != NULL)
    {
		pObj = (T126Obj*)m_T126ObjectsInWorkspace.GetPrevious(pos);

		if(pObj && pObj->GetThisObjectHandle() == objectHandle)
		{
			return pObj;
		}
	}

	return NULL;
}


BOOL WorkspaceObj::IsObjectInWorkspace(T126Obj* pObjToFind)
{
	T126Obj* pObj;

	WBPOSITION pos;
	pos = m_T126ObjectsInWorkspace.GetHeadPosition();
	while (pos != NULL)
	{
		pObj = (T126Obj*)m_T126ObjectsInWorkspace.GetNext(pos);
		if(pObj == pObjToFind)
		{
			return TRUE;
		}
	}
	return FALSE;
}


BOOL IsWorkspaceListed(T126Obj * pWorkspaceObj)
{
	T126Obj * pObj;

	WBPOSITION pos;
	pos = g_pListOfWorkspaces->GetHeadPosition();
	while (pos != NULL)
	{
		pObj =(T126Obj *) g_pListOfWorkspaces->GetNext(pos);

		if(pObj == pWorkspaceObj)
		{
			return TRUE;
		}
	}

	return FALSE;
}

//
// Add new workspace
//
void AddNewWorkspace(WorkspaceObj * pWorkspaceObj, BOOL bForcedResend)
{
	g_bContentsChanged = TRUE;

	//
	// Add it to the list of workspace objects
	//
	if(g_pConferenceWorkspace)
	{
		WBPOSITION pos = g_pConferenceWorkspace->GetMyPosition();
		pWorkspaceObj->SetMyPosition(g_pListOfWorkspaces->AddAt(pWorkspaceObj, pos));
	}
	else
	{
		pWorkspaceObj->SetMyPosition(g_pListOfWorkspaces->AddTail(pWorkspaceObj));

		g_pConferenceWorkspace = pWorkspaceObj;
		g_pCurrentWorkspace = pWorkspaceObj;	
		if(!g_pDraw->IsSynced())
		{
			g_pMain->OnSync();
		}
	}

	g_numberOfWorkspaces++;
	
	if(g_pDraw->IsSynced())
	{
		g_pMain->GotoPage(pWorkspaceObj, bForcedResend);
	}
	//
	// We are not synced but update the page butons anyway
	//
	else
	{
		g_pConferenceWorkspace = pWorkspaceObj;
		g_pMain->UpdatePageButtons();
	}
}

BitmapObj * WorkspaceObj::RectHitRemotePointer(LPRECT hitRect, int penThickness , WBPOSITION pos)
{
	if(pos == NULL)
	{
		pos = m_T126ObjectsInWorkspace.GetTailPosition();
	}
	else
	{
		m_T126ObjectsInWorkspace.GetPrevious(pos);
	}
	
	T126Obj* pPointer = (T126Obj*)m_T126ObjectsInWorkspace.GetFromPosition(pos);
	
	RECT pointerRect;
	RECT intersectRect;

	while(pos && pPointer && pPointer->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{
		pPointer->GetRect(&pointerRect);
		::InflateRect(&pointerRect, penThickness , penThickness);
		NormalizeRect(&pointerRect);
		NormalizeRect(hitRect);
		if(IntersectRect(&intersectRect, &pointerRect, hitRect))
		{
			return (BitmapObj *)pPointer;
		}
		pPointer = (T126Obj*) m_T126ObjectsInWorkspace.GetPrevious(pos);	
	}
	return NULL;
}


void WorkspaceObj::AddTail(T126Obj * pObj)
{
	//
	// The contents of the wb just changed
	//
	g_bContentsChanged = TRUE;
	
	pObj->SetMyWorkspace(this);
	T126Obj* pPointer = (T126Obj*)m_T126ObjectsInWorkspace.GetTail();

	//
	// Add the local remote pointer in the tail position
	// and other type of objects before all the remote pointers
	//
	if(!(pObj->GraphicTool() == TOOLTYPE_REMOTEPOINTER && pObj->IAmTheOwner()) &&
		pPointer && pPointer->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{
		WBPOSITION pos = m_T126ObjectsInWorkspace.GetTailPosition();
		WBPOSITION insertPos = NULL;
		
		//
		// Find the first object that is not a remote pointer
		//
		while(pPointer->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
		{
			insertPos = pos;
			if(pos == NULL)
			{
				break;
			}
			pPointer = (T126Obj*) m_T126ObjectsInWorkspace.GetPrevious(pos);	
		}
		
		if(insertPos)
		{
			pObj->SetMyPosition(m_T126ObjectsInWorkspace.AddAt(pObj, insertPos));
		}
		else
		{
			pObj->SetMyPosition(m_T126ObjectsInWorkspace.AddHead(pObj));
		}

		//
		// Make sure we repaint the area, if there was a handle it could be under it
		//
		if(pObj->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
		{
			((BitmapObj*)pObj)->CreateSaveBitmap();
		}

		RECT rect;
		pObj->GetBoundsRect(&rect);
		g_pDraw->InvalidateSurfaceRect(&rect,TRUE);
		
	}
	else	
	{
		pObj->SetMyPosition(m_T126ObjectsInWorkspace.AddTail(pObj));
	}
}


WorkspaceObj* RemoveWorkspace(WorkspaceObj * pWorkspaceObj)
{
	WorkspaceObj * pWrkspc;

	g_bContentsChanged = TRUE;
	
	WBPOSITION pos = pWorkspaceObj->GetMyPosition();
	WBPOSITION prevPos = pos;

	g_pListOfWorkspaces->GetPrevious(prevPos);

	g_pListOfWorkspaces->RemoveAt(pos);

	//
	// We just removed the first page
	//
	if(prevPos == NULL)
	{
		pWrkspc = (WorkspaceObj *)g_pListOfWorkspaces->GetHead();
	}
	else
	{
		pWrkspc = (WorkspaceObj *)g_pListOfWorkspaces->GetPrevious(prevPos);
	}

	//
	// The current workspace is pointing to the deleted object
	//
	if(g_pCurrentWorkspace == pWorkspaceObj)
	{
		::InvalidateRect(g_pDraw->m_hwnd, NULL, TRUE);


		//
		// If we were drawing/selecting or dragging something, finish now
		//
		g_pDraw->OnLButtonUp(0,0,0);

		//
		// If we are deleting the current workspace and we have the text editor active
		//
		if (g_pDraw->TextEditActive())
		{
			//
			// Finish the text
			//
   			g_pDraw->EndTextEntry(FALSE);
		}

		g_pCurrentWorkspace = NULL;
	}

	if(g_pConferenceWorkspace == pWorkspaceObj)
	{
		g_pConferenceWorkspace = NULL;

	}

	delete pWorkspaceObj;

	return pWrkspc;
}

UINT WorkspaceObj::EnumerateObjectsInWorkspace(void)
{
	UINT objects = 0;
	WBPOSITION pos;
	T126Obj* pObj;
	
	pos = GetHeadPosition();
	while(pos)
	{
		pObj = GetNextObject(pos);
		if(pObj && pObj->GraphicTool() != TOOLTYPE_REMOTEPOINTER)
		{
			objects++;
		}
	}
	return objects;
}


void ResendAllObjects(void)
{
 	//
	// Resend all objects
  	//
	WBPOSITION pos;
	WBPOSITION posObj;
	WorkspaceObj* pWorkspace;
	WorkspaceObj* pCurrentWorkspace;

	pCurrentWorkspace  = g_pCurrentWorkspace;

	T126Obj* pObj;
	pos = g_pListOfWorkspaces->GetHeadPosition();
	while(pos)
	{
		pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
		if(pWorkspace)
		{
			pWorkspace->SetAllAttribs();
			pWorkspace->SendNewObjectToT126Apps();
			posObj = pWorkspace->GetHeadPosition();
			while(posObj)
			{
				pObj = pWorkspace->GetNextObject(posObj);
				if(pObj)
				{
					pObj->ClearSelectionFlags();
					pObj->SetAllAttribs();
					pObj->SendNewObjectToT126Apps();

					//
					// Lines need to be saved in various pdus with 256 points in each pdu
					//
					if(pObj->GraphicTool() == TOOLTYPE_PEN || pObj->GraphicTool() == TOOLTYPE_HIGHLIGHT)
					{
						int nPoints = ((DrawObj*)pObj)->m_points->GetSize();
						int size = MAX_POINT_LIST_VALUES + 1;
						if(nPoints > (MAX_POINT_LIST_VALUES + 1))
						{
							while(size != nPoints)
							{
								if(nPoints > (size + MAX_POINT_LIST_VALUES + 1))
								{
									size += MAX_POINT_LIST_VALUES + 1;
								}
								else
								{
									size = nPoints;
								}

								//
								// Move to the next 256 points
								//

								((DrawObj*)pObj)->m_points->SetSize(size - 1);

								//
								// Send the next 256 points
								//
								pObj->ResetAttrib();
								((DrawObj*)pObj)->ChangedPointList();
								pObj->OnObjectEdit();
							}
							((DrawObj*)pObj)->m_points->SetSize(size);
						}
					}
				}
			}
		}
	}

	//
	// Syncronize page
	//
	if(g_pCurrentWorkspace)
	{
		g_pMain->GotoPage(g_pCurrentWorkspace);
		g_pCurrentWorkspace->SetViewState(focus_chosen);
		g_pCurrentWorkspace->SetViewActionChoice(editView_chosen);
		g_pCurrentWorkspace->OnObjectEdit();
	}
}

void RemoveObjectFromRequestHandleList(T126Obj * pObjRequest)
{
	T126Obj* pObj;
	WBPOSITION pos;
	WBPOSITION prevPos;
	pos = g_pListOfObjectsThatRequestedHandles->GetHeadPosition();
	while (pos != NULL)
	{
		prevPos = pos;
		pObj = (T126Obj*)g_pListOfObjectsThatRequestedHandles->GetNext(pos);
		if(pObj == pObjRequest)
		{
			g_pListOfObjectsThatRequestedHandles->RemoveAt(prevPos);
			break;
		}
	}
}


UINT GetSIPDUObjectHandle(SIPDU * sipdu)
{
	UINT ObjectHandle = 0;

	switch(sipdu->choice)
	{
		case bitmapAbortPDU_chosen:
			ObjectHandle = sipdu->u.bitmapAbortPDU.bitmapHandle;
		break;
		
		case bitmapCheckpointPDU_chosen:
			ObjectHandle = sipdu->u.bitmapCheckpointPDU.bitmapHandle;
		break;
		
		case bitmapCreatePDU_chosen:
			ObjectHandle = sipdu->u.bitmapCreatePDU.bitmapHandle;
		break;
		
		case bitmapCreateContinuePDU_chosen:
			ObjectHandle = sipdu->u.bitmapCreateContinuePDU.bitmapHandle;
		break;
		
		case bitmapDeletePDU_chosen:
			ObjectHandle = sipdu->u.bitmapDeletePDU.bitmapHandle;
		break;
		
		case bitmapEditPDU_chosen:
			ObjectHandle = sipdu->u.bitmapEditPDU.bitmapHandle;
		break;
		
		case drawingCreatePDU_chosen:
			ObjectHandle = sipdu->u.drawingCreatePDU.drawingHandle;
		break;
		
		case drawingDeletePDU_chosen:
			ObjectHandle = sipdu->u.drawingDeletePDU.drawingHandle;
		break;
		
		case drawingEditPDU_chosen:
			ObjectHandle = sipdu->u.drawingEditPDU.drawingHandle;
		break;
		
		case siNonStandardPDU_chosen:
		ObjectHandle = ((TEXTPDU_HEADER*) sipdu->u.siNonStandardPDU.nonStandardTransaction.data.value)->textHandle;
		break;
		
		case workspaceCreatePDU_chosen:
			ObjectHandle = WorkspaceObj::GetWorkspaceIdentifier(&sipdu->u.workspaceCreatePDU.workspaceIdentifier);
		break;
		
		case workspaceCreateAcknowledgePDU_chosen:
			ObjectHandle = WorkspaceObj::GetWorkspaceIdentifier(&sipdu->u.workspaceCreateAcknowledgePDU.workspaceIdentifier);
		break;
		
		case workspaceDeletePDU_chosen:
			ObjectHandle = WorkspaceObj::GetWorkspaceIdentifier(&sipdu->u.workspaceDeletePDU.workspaceIdentifier);
		break;
		
		case workspaceEditPDU_chosen:
			ObjectHandle = WorkspaceObj::GetWorkspaceIdentifier(&sipdu->u.workspaceEditPDU.workspaceIdentifier);
		break;
		
		case workspacePlaneCopyPDU_chosen:
			ObjectHandle = WorkspaceObj::GetWorkspaceIdentifier(&sipdu->u.workspacePlaneCopyPDU.sourceWorkspaceIdentifier);
		break;
		
		case workspaceReadyPDU_chosen:
			ObjectHandle = WorkspaceObj::GetWorkspaceIdentifier(&sipdu->u.workspaceReadyPDU.workspaceIdentifier);
		break;
		
	}

	return ObjectHandle;


}


BOOL RemoveObjectFromResendList(T126Obj * pObjRequest)
{
	BOOL bRemoved = FALSE;
	SIPDU* pPDU;
	WBPOSITION pos;
	WBPOSITION prevPos;

	UINT objectHandle = pObjRequest->GetThisObjectHandle();
	pos = g_pRetrySendList->GetHeadPosition();
	while (pos != NULL)
	{
		prevPos = pos;
		pPDU = (SIPDU*)g_pRetrySendList->GetNext(pos);
		if(GetSIPDUObjectHandle(pPDU) == objectHandle)
		{
			g_pRetrySendList->RemoveAt(prevPos);
			SIPDUCleanUp(pPDU);
			bRemoved = TRUE;
		}
	}

	return bRemoved;
}




void RemoveRemotePointer(MEMBER_ID nMemberID)
{
 	//
	// Resend all objects
  	//
	WBPOSITION pos;
	WBPOSITION posObj;
	WorkspaceObj* pWorkspace;
	ULONG ownerID;
	T126Obj* pObj;
	pos = g_pListOfWorkspaces->GetHeadPosition();
	while(pos)
	{
		pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
		if(pWorkspace)
		{
			posObj = pWorkspace->GetHeadPosition();
			while(posObj)
			{
				pObj = pWorkspace->GetNextObject(posObj);
				if(pObj && pObj->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
				{
					ownerID = GET_NODE_ID_FROM_MEMBER_ID(pObj->GetOwnerID());

					TRACE_DEBUG(("RemoveRemotePointer ownerID=%x member that left =%x " , ownerID, nMemberID));

					
					if(ownerID != g_MyMemberID)
					{
						if(nMemberID)
						{
							if(nMemberID == ownerID)					
							{
								pWorkspace->RemoveT126Object(pObj);
							}
						}
						else
						{
							pWorkspace->RemoveT126Object(pObj);
						}
					}
				}
			}
		}
	}

	//
	// Syncronize page
	//
	if(g_pCurrentWorkspace)
	{
		g_pCurrentWorkspace->SetViewActionChoice(editView_chosen);
		g_pCurrentWorkspace->OnObjectEdit();
	}
}


BOOL IsThereAnythingInAnyWorkspace(void)
{
	WBPOSITION pos;
	WBPOSITION posObj;
	WorkspaceObj* pWorkspace;
	T126Obj* pObj;
	pos = g_pListOfWorkspaces->GetHeadPosition();
	while(pos)
	{
		pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
		if(pWorkspace)
		{
			posObj = pWorkspace->GetHeadPosition();
			while(posObj)
			{
				pObj = pWorkspace->GetNextObject(posObj);
				if(pObj)
				{
					if(pObj->GraphicTool() != TOOLTYPE_REMOTEPOINTER)
					{
						return TRUE;
					}
				}
			}
		}
	}
	return FALSE;
}



//
// UI Edited the Workspace Object
//
void WorkspaceObj::OnObjectEdit(void)
{

	g_bContentsChanged = TRUE;

	//
	// If we are not synced don't bug the other nodes
	//
	if(!g_pDraw->IsSynced())
	{
		return;
	}

	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(!sipdu)
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        return;
	}

	sipdu->choice = workspaceEditPDU_chosen;
	CreateWorkspaceEditPDU(&sipdu->u.workspaceEditPDU);
	T120Error rc = SendT126PDU(sipdu);
	if(rc == T120_NO_ERROR)
	{
		SIPDUCleanUp(sipdu);
		ResetAttrib();
	}
}

//
// UI Deleted the Workspace Object
//
void WorkspaceObj::OnObjectDelete(void)
{
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = workspaceDeletePDU_chosen;
		CreateWorkspaceDeletePDU(&sipdu->u.workspaceDeletePDU);
		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}
}

void WorkspaceObj::GetEncodedCreatePDU(ASN1_BUF *pBuf)
{
	SIPDU *sipdu = NULL;
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = workspaceCreatePDU_chosen;
		CreateWorkspaceCreatePDU(&sipdu->u.workspaceCreatePDU);
		ASN1_BUF encodedPDU;
		g_pCoder->Encode(sipdu, pBuf);
		delete sipdu->u.workspaceCreatePDU.planeParameters->value.usage;
		delete sipdu->u.workspaceCreatePDU.planeParameters;
		delete sipdu;
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}
	
}


void SendWorkspaceRefreshPDU(BOOL bImtheRefresher)
{
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = workspaceRefreshStatusPDU_chosen;
		sipdu->u.workspaceRefreshStatusPDU.bit_mask = 0;
		sipdu->u.workspaceRefreshStatusPDU.refreshStatus = (ASN1bool_t)bImtheRefresher;
		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}

}

//
// UI Created a new Workspace Object
//
void WorkspaceObj::SendNewObjectToT126Apps(void)
{
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = workspaceCreatePDU_chosen;
		CreateWorkspaceCreatePDU(&sipdu->u.workspaceCreatePDU);
		TRACE_DEBUG(("Sending Workspace >> Workspace handle  = %d", sipdu->u.workspaceCreatePDU.workspaceIdentifier.u.activeWorkspace ));
		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}

		SetAllAttribs();
		SetViewActionChoice(createNewView_chosen);
		SetViewState(focus_chosen);
		OnObjectEdit();
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}
	
}


void WorkspaceObj::GetWorkSpaceViewEditParam(PWorkspaceEditPDU_viewEdits pViewEdits)
{
	m_viewHandle = pViewEdits->value.viewHandle;
	TRACE_DEBUG(("GetWorkSpaceViewEditParam View Handle = %d", m_viewHandle));
	TRACE_DEBUG(("GetWorkSpaceViewEditParam View Choice = %d", pViewEdits->value.action.choice));

	switch(pViewEdits->value.action.choice)
	{
		case(createNewView_chosen):
		{
			GetWorkSpaceViewParam((PWorkspaceCreatePDU_viewParameters_Set_viewAttributes)pViewEdits->value.action.u.createNewView);
		}
		break;

		case(editView_chosen):
		{
			GetWorkSpaceViewParam((PWorkspaceCreatePDU_viewParameters_Set_viewAttributes)pViewEdits->value.action.u.editView);
		}
		break;

		case(deleteView_chosen):
		{
			;
		}
		break;

//		case(nonStandardAction_chosen):
//		{
//		}
//		break;

		default:
		WARNING_OUT(("Invalid workspace view attribute"));
		break;
	}
}


void WorkspaceObj::GetWorkSpaceViewParam(PWorkspaceCreatePDU_viewParameters_Set_viewAttributes pViewAttributes)
{

	PWorkspaceCreatePDU_viewParameters_Set_viewAttributes attributes;
	attributes = pViewAttributes;
	while(attributes)
	{
		switch(attributes->value.choice)
		{
			case (viewRegion_chosen):
			{

				switch(attributes->value.u.viewRegion.choice)
				{
					case(fullWorkspace_chosen):
					{
						m_viewRegion.top = 0;
						m_viewRegion.left = 0;
						m_viewRegion.bottom = m_workspaceSize.x;
						m_viewRegion.right = m_workspaceSize.y;
						TRACE_DEBUG(("fullWorkspace_chosen View Region = (%d, %d)(%d, %d)",
									m_viewRegion.top,
									m_viewRegion.left,
									m_viewRegion.bottom,
									m_viewRegion.right));
						
					}
						case(partialWorkspace_chosen):
					{
						m_viewRegion.top = attributes->value.u.viewRegion.u.partialWorkspace.upperLeft.yCoordinate;
						m_viewRegion.left = attributes->value.u.viewRegion.u.partialWorkspace.upperLeft.xCoordinate;
						m_viewRegion.bottom = attributes->value.u.viewRegion.u.partialWorkspace.upperLeft.yCoordinate;
						m_viewRegion.right = attributes->value.u.viewRegion.u.partialWorkspace.upperLeft.xCoordinate;
						TRACE_DEBUG(("partialWorkspace_chosen View Region = (%d, %d)(%d, %d)",
									m_viewRegion.top,
									m_viewRegion.left,
									m_viewRegion.bottom,
									m_viewRegion.right));
					}
					break;
						default:
				    ERROR_OUT(("Invalid view region choice"));
					break;
					}
			}
			break;

			case (WorkspaceViewAttribute_viewState_chosen):
			{
				SetViewState(attributes->value.u.viewState.choice);
				TRACE_DEBUG(("View state = %d", attributes->value.u.viewState.choice));
			}
			break;

			case (updatesEnabled_chosen):
			{
 				SetUpdatesEnabled(attributes->value.u.updatesEnabled);
				if(!m_bUpdatesEnabled)
				{
					g_pNMWBOBJ->m_LockerID = GetOwnerID();
				}

				TRACE_DEBUG(("Updates enabled = %d", m_bUpdatesEnabled));
			}
			break;

//			case (sourceDisplayIndicator_chosen):
//			{
//				JOSEF what we do with these??????
//						attributes->value.u.sourceDisplayIndicator.displayAspectRatio;
//					    attributes->value.u.sourceDisplayIndicator.horizontalSizeRatio;
//					    attributes->value.u.sourceDisplayIndicator.horizontalPosition;
//					    attributes->value.u.sourceDisplayIndicator.verticalPosition;
//
//			}
//			break;

			default:
		    WARNING_OUT(("Invalid workspace view attribute"));
			break;
		}
	attributes = attributes->next;
	}
}


//
// JOSEF The following is not used but is part of the standard
// It is removed because we don't need it now
// We may need to add it for interop in the future
//
#ifdef _DEBUG

void WorkspaceObj::SetBackGroundColor(COLORREF rgb)
{
	m_backgroundColor.rgbtRed = GetRValue(rgb);
	m_backgroundColor.rgbtGreen = GetGValue(rgb);
	m_backgroundColor.rgbtBlue = GetBValue(rgb);
}




void WorkspaceObj::GetWorkSpaceAttrib(PWorkspaceCreatePDU_workspaceAttributes pWorkspaceAttributes)
{

	PWorkspaceCreatePDU_workspaceAttributes attributes;
	attributes = pWorkspaceAttributes;
	COLORREF rgb;
	while(attributes)
	{
		switch(attributes->value.choice)
		{
			case(backgroundColor_chosen):
			{
				switch(attributes->value.u.backgroundColor.choice)
				{
//					case(workspacePaletteIndex_chosen):
//					{
//						ASN1uint16_t workspacePaletteIndex = ((attributes->value.u.backgroundColor).u).workspacePaletteIndex;
//						break;
//					}
					case(rgbTrueColor_chosen):
					{
						rgb = RGB(attributes->value.u.backgroundColor.u.rgbTrueColor.r,
										attributes->value.u.backgroundColor.u.rgbTrueColor.g,
										attributes->value.u.backgroundColor.u.rgbTrueColor.b);
						SetBackGroundColor(rgb);
						TRACE_DEBUG(("Attribute penColor (r,g,b)=(%d, %d,%d)",
								attributes->value.u.backgroundColor.u.rgbTrueColor.r,
								attributes->value.u.backgroundColor.u.rgbTrueColor.g,
								attributes->value.u.backgroundColor.u.rgbTrueColor.b));
						break;
					}
					case(transparent_chosen):
					{
						SetBackGroundColor(0);
						TRACE_DEBUG(("Backgroundcolor transparent"));
						break;
					}
					default:
				    ERROR_OUT(("Invalid backgroundColor choice"));
					break;
				}
				break;
  			}

			case(preserve_chosen):
			{
				m_bPreserve = attributes->value.u.preserve;
				TRACE_DEBUG(("m_bPreserve %d", m_bPreserve));
			}	
			break;
		}
	
		attributes = attributes->next;
	}

}

void WorkspaceObj::GetWorkSpacePlaneParam(PWorkspaceCreatePDU_planeParameters pPlaneParameters)
{

		TRACE_DEBUG(("GetWorkSpacePlaneParam NYI"));

	;
}
#endif // 0



void TogleLockInAllWorkspaces(BOOL bLock, BOOL bResend)
{
	WorkspaceObj * pWorkspace;
	WBPOSITION pos = g_pListOfWorkspaces->GetHeadPosition();
    while (pos)
    {
		pWorkspace = (WorkspaceObj *) g_pListOfWorkspaces->GetNext(pos);

		pWorkspace->SetUpdatesEnabled(!bLock);
		if(bResend)
		{
			pWorkspace->SetViewActionChoice(editView_chosen);
			pWorkspace->OnObjectEdit();
		}
	}
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb\wrkspobj.hpp ===
//
// WRKSPOBJ.HPP
// Drawing objects: point, openpolyline, closepolyline, ellipse
//
// Copyright Microsoft 1998-
//
#ifndef __WRKSPOBJ_HPP_
#define __WRKSPOBJ_HPP_

#include "mcshelp.h"

void AddNewWorkspace(WorkspaceObj * pWorkspaceObj, BOOL bForcedResend = FALSE);
WorkspaceObj* RemoveWorkspace(WorkspaceObj * pWorkspaceObj);
void RemoveObjectFromRequestHandleList(T126Obj * pObjRequest);
BOOL RemoveObjectFromResendList(T126Obj * pObjRequest);
void RemoveRemotePointer(MEMBER_ID nMemberID);
void ResendAllObjects(void);
BOOL IsThereAnythingInAnyWorkspace(void);
BOOL IsWorkspaceListed(T126Obj * pWorkspaceObj);
void SendWorkspaceRefreshPDU(BOOL bImtheRefresher);
void TogleLockInAllWorkspaces(BOOL bLock, BOOL bResend = FALSE);

class BitmapObj;

class WorkspaceObj : public T126Obj
{

public:
	
	WorkspaceObj ( void );
	WorkspaceObj (WorkspaceCreatePDU * pworkspaceCreatePDU, BOOL bForcedResend);
	~WorkspaceObj( void );
	void WorkspaceEditObj ( WorkspaceEditPDU * pworkspaceEditPDU );

	BOOL m_bWorkspaceReady;

	void CreateWorkspaceCreatePDU(WorkspaceCreatePDU *);
	void CreateWorkspaceDeletePDU(WorkspaceDeletePDU *);
	void CreateWorkspaceEditPDU(WorkspaceEditPDU *);
	static UINT GetWorkspaceIdentifier(WorkspaceIdentifier *workspaceIdentifier);
	void GetWorkSpaceViewEditParam(PWorkspaceEditPDU_viewEdits pViewEdits);
	void GetWorkSpaceViewParam(PWorkspaceCreatePDU_viewParameters_Set_viewAttributes pViewAttributes);

	//
	// Workspace object list management
	//
	void AddTail(T126Obj * pObj);
	void AddHead(T126Obj * pObj){pObj->SetMyWorkspace(this); pObj->SetMyPosition(m_T126ObjectsInWorkspace.AddHead(pObj));}
	WBPOSITION GetTailPosition(void){return m_T126ObjectsInWorkspace.GetTailPosition();}
	WBPOSITION GetHeadPosition(void){return m_T126ObjectsInWorkspace.GetHeadPosition();}
	T126Obj*  GetHead(void){return (T126Obj*)m_T126ObjectsInWorkspace.GetHead();}
	T126Obj*  GetTail(void){return (T126Obj*)m_T126ObjectsInWorkspace.GetTail();}
	T126Obj*  GetNextObject(WBPOSITION& pos){return (T126Obj*)m_T126ObjectsInWorkspace.GetNext(pos);}
	T126Obj*  GetPreviousObject(WBPOSITION& pos){return (T126Obj*)m_T126ObjectsInWorkspace.GetPrevious(pos);}
	T126Obj*  RemoveAt(WBPOSITION& pos){return (T126Obj*)m_T126ObjectsInWorkspace.RemoveAt(pos);}
	void RemoveT126Object(T126Obj *pObj);
	T126Obj* FindObjectInWorkspace(UINT objectHandle);
	BOOL IsObjectInWorkspace(T126Obj* pObjToFind);
	UINT EnumerateObjectsInWorkspace(void);
	BitmapObj * RectHitRemotePointer(LPRECT rect, int, WBPOSITION pos);


	void SetBackGroundColor(COLORREF rgb);

	//
	// Base class overwrite
	//
	void Draw(HDC hDC = NULL, BOOL bForcedDraw = FALSE, BOOL bPrinting = FALSE){};
	void UnDraw(){};
	BOOL CheckReallyHit(LPCRECT pRectHit){return TRUE;};

	BOOL HasFillColor(void){return FALSE;}
	void SetFillColor(COLORREF cr, BOOL isPresent){}
    BOOL GetFillColor(COLORREF * pcr) {return FALSE;}
    BOOL GetFillColor(RGBTRIPLE* prgb) {return FALSE;}

	void SetPenColor(COLORREF cr, BOOL isPresent){}
    BOOL GetPenColor(COLORREF * pcr) {return FALSE;}
    BOOL GetPenColor(RGBTRIPLE * prgb) {return FALSE;}

	void ChangedAnchorPoint(void){};
	BOOL HasAnchorPointChanged(void){return FALSE;}
	void ChangedZOrder(void){};
	BOOL HasZOrderChanged(void){return FALSE;}
	void ChangedViewState(void){m_dwChangedAttrib |= 0x00000001;}
	void ChangedUpatesEnabledState(void){m_dwChangedAttrib |= 0x00000002;}
	BOOL HasViewStateChanged(void){return (m_dwChangedAttrib & 0x00000001);}
	BOOL HasUpatesEnabledStateChanged(void){return (m_dwChangedAttrib & 0x00000002);}
	void ResetAttrib(void){m_dwChangedAttrib = 0;}
	void SetAllAttribs(void){m_dwChangedAttrib = 0x00000003;};
	void ChangedPenThickness(void){};
	BOOL GetUpdatesEnabled(void){return m_bUpdatesEnabled;}
	void SetUpdatesEnabled(BOOL bUpdatesEnabled){m_bUpdatesEnabled = bUpdatesEnabled; ChangedUpatesEnabledState();}
	void SetViewActionChoice(UINT action){m_viewActionChoice = action;}
	void SetViewHandle(UINT viewHandle){m_viewHandle = viewHandle;}
	
	void OnObjectEdit(void);
	void OnObjectDelete(void);
	void SendNewObjectToT126Apps(void);
	void GetEncodedCreatePDU(ASN1_BUF *pBuf);

protected:
	DWORD			m_dwChangedAttrib;
	CWBOBLIST m_T126ObjectsInWorkspace;
	UINT m_appRosterInstance;
	BOOL m_bsynchronized;
	POINT m_workspaceSize;
	BOOL m_acceptKeyboardEvents;
	BOOL m_acceptPointingDeviceEvents;
	BOOL m_bUpdatesEnabled;
	ULONG m_viewHandle;
	RECT m_viewRegion;
	UINT m_viewActionChoice;
	COBLIST m_protectedPlaneAccessList;

#ifdef _DEBUG
	RGBTRIPLE	m_backgroundColor;
	BOOL m_bPreserve;

	void GetWorkSpaceAttrib(PWorkspaceCreatePDU_workspaceAttributes pWorkspaceAttributes);
	void GetWorkSpacePlaneParam(PWorkspaceCreatePDU_planeParameters pPlaneParameters);
#endif // 0
};

#endif // __WRKSPOBJ_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\callback.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       callback.h
//  Content:    This file contains the local asynchronous response
//              definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _CALLBACK_H_
#define _CALLBACK_H_

#define WM_ILS_LOCAL_ASYNC_RES              (WM_ILS_ASYNC_RES+0x1000)
#define WM_ILS_LOCAL_USER_INFO_CHANGED      (WM_ILS_LOCAL_ASYNC_RES+0) // 0       0
#define WM_ILS_LOCAL_SET_USER_INFO          (WM_ILS_LOCAL_ASYNC_RES+1) // uReqID  hResult
#define WM_ILS_LOCAL_REGISTER_PROTOCOL      (WM_ILS_LOCAL_ASYNC_RES+6) // uMsgID  hResult
#define WM_ILS_LOCAL_UNREGISTER_PROTOCOL    (WM_ILS_LOCAL_ASYNC_RES+7) // uMsgID  hResult
#define WM_ILS_LOCAL_REGISTER               (WM_ILS_LOCAL_ASYNC_RES+8) // uMsgID  hResult
#define WM_ILS_LOCAL_UNREGISTER             (WM_ILS_LOCAL_ASYNC_RES+9) // uMsgID  hResult

//****************************************************************************
// Private type definition
//****************************************************************************
//
typedef struct tagSimpleResultInfo {
    ULONG   uReqID;
    HRESULT hResult;
}   SRINFO, *PSRINFO;

typedef struct tagObjectResultInfo {
    ULONG   uReqID;
    HRESULT hResult;
    PVOID   pv;
}   OBJRINFO, *POBJRINFO;

typedef struct tagEnumResultInfo {
    ULONG   uReqID;
    HRESULT hResult;
    ULONG   cItems;
    PVOID   pv;
}   ENUMRINFO, *PENUMRINFO;

#endif //_CALLBACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\callback.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       callback.cpp
//  Content:    This file contains the ULS callback routine.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

#include "ulsp.h"
#include "callback.h"
#include "culs.h"
#include "localusr.h"
#include "attribs.h"
#include "localprt.h"
#include "ulsmeet.h"

//****************************************************************************
// void OnRegisterResult(UINT uMsg, ULONG uMsgID, HRESULT hResult)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnRegisterResult(UINT uMsg, ULONG uMsgID, HRESULT hResult)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(uMsg == ri.uReqType);
		CIlsUser *pUser = ReqInfo_GetUser (&ri);

        switch(uMsg)
        {
            case WM_ILS_REGISTER_CLIENT:              // lParam = hResult
                //
                // Call the appropriate object's member
                //
                ASSERT (pUser != NULL);
                if (pUser != NULL)
                	pUser->InternalRegisterNext(hResult);
                break;

            case WM_ILS_UNREGISTER_CLIENT:            // lParam = hResult
                //
                // Call the appropriate object's member
                //
                ASSERT (pUser != NULL);
                if (pUser != NULL)
                	pUser->InternalUnregisterNext(hResult);
                break;

            default:
                ASSERT(0);
                break;
        };

        // Release the objects
        //
        if (pUser != NULL)
        	pUser->Release ();
    }
    else
    {
        DPRINTF1(TEXT("OnRegisterResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };
    return;
}

//****************************************************************************
// void OnLocalRegisterResult(UINT uMsg, ULONG uReqID, HRESULT hResult)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnLocalRegisterResult(UINT uMsg, ULONG uReqID, HRESULT hResult)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = uReqID;
    ri.uMsgID = 0;

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(uMsg == ri.uReqType);
		CIlsUser *pUser = ReqInfo_GetUser (&ri);

        // Call the appropriate object's member
        //
        switch(uMsg)
        {
            case WM_ILS_LOCAL_REGISTER:
            	ASSERT (pUser != NULL);
            	if (pUser != NULL)
            		pUser->RegisterResult(uReqID, hResult);
                break;

            case WM_ILS_LOCAL_UNREGISTER:
            	ASSERT (pUser != NULL);
            	if (pUser != NULL)
            		pUser->UnregisterResult(uReqID, hResult);
                break;

            default:
                ASSERT(0);
                break;
        };

        // Release the objects
        //
        if (pUser != NULL)
        	pUser->Release ();
    }
    else
    {
        DPRINTF1(TEXT("OnLocalRegisterResult: No pending request for %x"),
                 uReqID);
        // ASSERT (0);
    };
    return;
}

//****************************************************************************
// void OnSetUserInfo(UINT uMsg, ULONG uID, HRESULT hResult)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnSetUserInfo(UINT uMsg, ULONG uID, HRESULT hResult)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    switch (uMsg)
    {
        case WM_ILS_SET_CLIENT_INFO:
            //
            // Look for the matching Ldap Message ID
            //
            ri.uReqID = 0;       // Mark that we are looking for the message ID
            ri.uMsgID = uID;     // Not the request ID
            break;

        default:
            ASSERT(0);
            break;
    };

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(uMsg == ri.uReqType);
		CIlsUser *pUser = ReqInfo_GetUser (&ri);

		ASSERT (pUser != NULL);
		if (pUser != NULL)
		{
	        // Call the appropriate object's member
	        //
	        pUser->UpdateResult(ri.uReqID, hResult);

	        // Release the objects
	        //
	        pUser->Release();
       	}
    }
    else
    {
        DPRINTF1(TEXT("OnSetUserInfo: No pending request for %x"),
                 uID);
        // ASSERT (0);
    };
    return;
}

//****************************************************************************
// void OnSetProtocol(UINT uMsg, ULONG uID, HRESULT hResult)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnSetProtocol(UINT uMsg, ULONG uID, HRESULT hResult)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    APP_CHANGE_PROT uCmd;

    switch (uMsg)
    {
        case WM_ILS_REGISTER_PROTOCOL:

            // Look for the matching request information
            //
            ri.uReqID = 0;      // Mark that we are looking for the message ID
            ri.uMsgID = uID;    // Not the request ID
            uCmd = ILS_APP_ADD_PROT;
            break;

        case WM_ILS_LOCAL_REGISTER_PROTOCOL:

            // Look for the matching request information
            //
            ri.uReqID = uID;    // Mark that we are looking for the request ID
            ri.uMsgID = 0;      // Not the message ID
            uCmd = ILS_APP_ADD_PROT;
            break;

        case WM_ILS_UNREGISTER_PROTOCOL:

            // Look for the matching request information
            //
            ri.uReqID = 0;      // Mark that we are looking for the message ID
            ri.uMsgID = uID;    // Not the request ID
            uCmd = ILS_APP_REMOVE_PROT;
            break;

        case WM_ILS_LOCAL_UNREGISTER_PROTOCOL:

            // Look for the matching request information
            //
            ri.uReqID = uID;    // Mark that we are looking for the request ID
            ri.uMsgID = 0;      // Not the message ID
            uCmd = ILS_APP_REMOVE_PROT;
            break;

        default:
            ASSERT(0);
            break;
    };

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(uMsg == ri.uReqType);
		CIlsUser *pUser = ReqInfo_GetUser (&ri);
		CLocalProt *pProtocol = ReqInfo_GetProtocol (&ri);

        // Check the request parameter
        //
        if (pProtocol == NULL)
        {
            switch(uMsg)
            {
                case WM_ILS_REGISTER_PROTOCOL:

                    // Call the appropriate object's member
                    //
                    ASSERT (pUser != NULL);
                    if (pUser != NULL)
                    	pUser->InternalRegisterNext(hResult);
                    break;

                case WM_ILS_UNREGISTER_PROTOCOL:

                    // Call the appropriate object's member
                    //
                    ASSERT (pUser != NULL);
                    if (pUser != NULL)
                    	pUser->InternalUnregisterNext(hResult);
                    break;

                default:
                    // Must be a response from server
                    //
                    ASSERT(0);
                    break;
            };

            // Release the objects
            //
            if (pUser != NULL)
            	pUser->Release();
        }
        else
        {
        	ASSERT (pUser != NULL && pProtocol != NULL);
            if (pUser != NULL && pProtocol != NULL)
            {
	            // Call the appropriate object's member
	            //
            	pUser->ProtocolChangeResult(pProtocol,
                                            ri.uReqID, hResult,
                                            uCmd);
	            // Release the objects
	            //
	            pUser->Release();
	            pProtocol->Release();
            }
        };
    }
    else
    {
        DPRINTF1(TEXT("OnSetProtocol: No pending request for %x"),
                 uID);
        // ASSERT (0);
    };
    return;
}

//****************************************************************************
// void OnEnumUserNamesResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnEnumUserNamesResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ENUM_CLIENTS == ri.uReqType);
		CIlsMain *pMain = ReqInfo_GetMain (&ri);

        // Call the appropriate object's member
        //
        ASSERT (pMain != NULL);
        if (pMain != NULL)
        {
        	pMain->EnumUserNamesResult(ri.uReqID, ple);
        }

        // If the enumeration was terminated, remove the pending request
        //
        if ((ple == NULL) ||
            (ple->hResult != NOERROR))
        {
            ri.uReqID = 0;
            ri.uMsgID = uMsgID;
            g_pReqMgr->RequestDone(&ri);

            // Release the objects
            //
    	    if (pMain != NULL)
    	    	pMain->Release();
        };
    }
    else
    {
        DPRINTF1(TEXT("OnEnumUserNamesResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    if (ple != NULL)
    {
        ::MemFree (ple);
    };
    return;
}

//****************************************************************************
// void OnEnumMeetingNamesResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
void OnEnumMeetingNamesResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ENUM_MEETINGS == ri.uReqType);
		CIlsMain *pMain = ReqInfo_GetMain (&ri);
		ASSERT (pMain != NULL);
		if (pMain != NULL)
		{
	        // Call the appropriate object's member
	        //
			pMain->EnumMeetingPlaceNamesResult(ri.uReqID, ple);
		}

        // If the enumeration was terminated, remove the pending request
        //
        if ((ple == NULL) ||
            (ple->hResult != NOERROR))
        {
            ri.uReqID = 0;
            ri.uMsgID = uMsgID;
            g_pReqMgr->RequestDone(&ri);

            // Release the objects
            //
			if (pMain != NULL)
            	pMain->Release();
        };
    }
    else
    {
        DPRINTF1(TEXT("OnEnumMeetingNamesResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    if (ple != NULL)
    {
        ::MemFree (ple);
    };
    return;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// void OnResolveUserResult(ULONG uMsgID, PLDAP_CLIENTINFO_RES puir)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnResolveUserResult(ULONG uMsgID, PLDAP_CLIENTINFO_RES puir)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(WM_ILS_RESOLVE_CLIENT == ri.uReqType);
		CIlsServer *pServer = ReqInfo_GetServer (&ri);
		CIlsMain *pMain = ReqInfo_GetMain (&ri);

        ASSERT (pMain != NULL && pServer != NULL);
        if (pMain != NULL && pServer != NULL)
        {
	        // Call the appropriate object's member
    	    //
        	pMain->GetUserResult(ri.uReqID, puir, pServer);

	        // Release the objects
	        //
	        pMain->Release();
			pServer->Release ();
		}
    }
    else
    {
        DPRINTF1(TEXT("OnResolveUserResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    ::MemFree (puir);
    return;
}

//****************************************************************************
// void OnEnumUsersResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnEnumUsersResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ENUM_CLIENTINFOS == ri.uReqType);

        // Call the appropriate object's member
        //
        CIlsServer *pServer = ReqInfo_GetServer (&ri);
		CIlsMain *pMain = ReqInfo_GetMain (&ri);

		ASSERT (pServer != NULL && pMain != NULL);
		if (pServer != NULL && pMain != NULL)
			pMain->EnumUsersResult(ri.uReqID, ple, pServer);

        // If the enumeration was terminated, remove the pending request
        //
        if ((ple == NULL) ||
            (ple->hResult != NOERROR))
        {
            ri.uReqID = 0;
            ri.uMsgID = uMsgID;
            g_pReqMgr->RequestDone(&ri);

            // Release the objects
            //
            if (pMain != NULL)
            	pMain->Release();

            if (pServer != NULL)
            	pServer->Release ();
        };
    }
    else
    {
        DPRINTF1(TEXT("EnumUsersResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    if (ple != NULL)
    {
        ::MemFree (ple);
    };
    return;
}

//****************************************************************************
// void OnEnumMeetingsResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
void OnEnumMeetingsResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ENUM_MEETINGINFOS == ri.uReqType);

        // Call the appropriate object's member
        //
        CIlsServer *pServer = ReqInfo_GetServer (&ri);
        CIlsMain *pMain = ReqInfo_GetMain (&ri);
        ASSERT (pServer != NULL && pMain != NULL);
        if (pServer != NULL && pMain != NULL)
        {
        	pMain->EnumMeetingPlacesResult(ri.uReqID, ple, pServer);
        }

        // If the enumeration was terminated, remove the pending request
        //
        if ((ple == NULL) ||
            (ple->hResult != NOERROR))
        {
            ri.uReqID = 0;
            ri.uMsgID = uMsgID;
            g_pReqMgr->RequestDone(&ri);

            // Release the objects
            //
            if (pMain != NULL)
            	pMain->Release ();

            if (pServer != NULL)
            	pServer->Release ();
        };
    }
    else
    {
        DPRINTF1(TEXT("EnumMeetingsResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    if (ple != NULL)
    {
        ::MemFree (ple);
    };
    return;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// void OnEnumProtocolsResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnEnumProtocolsResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(WM_ILS_ENUM_PROTOCOLS == ri.uReqType);
		CIlsUser *pUser = ReqInfo_GetUser (&ri);
		ASSERT (pUser != NULL);
		if (pUser != NULL)
		{
	        // Call the appropriate object's member
    	    //
        	pUser->EnumProtocolsResult(ri.uReqID, ple);

	        // Release the objects
        	//
    	    pUser->Release();
    	}
    }
    else
    {
        DPRINTF1(TEXT("EnumProtocolsResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    ::MemFree (ple);
    return;
}

//****************************************************************************
// void OnResolveProtocolResult(ULONG uMsgID, PLDAP_PROTINFO_RES ppir)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void OnResolveProtocolResult(ULONG uMsgID, PLDAP_PROTINFO_RES ppir)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(WM_ILS_RESOLVE_PROTOCOL == ri.uReqType);
		CIlsUser *pUser = ReqInfo_GetUser (&ri);
		ASSERT (pUser != NULL);
		if (pUser != NULL)
		{
        	// Call the appropriate object's member
        	//
        	pUser->GetProtocolResult(ri.uReqID, ppir);

	        // Release the objects
	        //
			pUser->Release();
		}
    }
    else
    {
        DPRINTF1(TEXT("OnResolveProtocolResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    ::MemFree (ppir);
    return;
}

//****************************************************************************
// VOID OnClientNeedRelogon ( BOOL fPrimary, VOID *pUnk)
//
// History:
//  Thur 07-Nov-1996 12:50:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

VOID OnClientNeedRelogon ( BOOL fPrimary, VOID *pUnk)
{
	ASSERT (pUnk != NULL);

    ((CIlsUser *)pUnk)->StateChanged (WM_ILS_CLIENT_NEED_RELOGON, fPrimary);
}

//****************************************************************************
// VOID OnClientNetworkDown ( BOOL fPrimary, VOID *pUnk)
//
// History:
//  Thur 07-Nov-1996 12:50:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

VOID OnClientNetworkDown ( BOOL fPrimary, VOID *pUnk)
{
	ASSERT (pUnk != NULL);

    ((CIlsUser *)pUnk)->StateChanged (WM_ILS_CLIENT_NETWORK_DOWN, fPrimary);
}


//****************************************************************************
// void OnResolveUserResult(ULONG uMsgID, PLDAP_CLIENTINFO_RES puir)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
void OnResolveMeetingPlaceResult (ULONG uMsgID, PLDAP_MEETINFO_RES pmir)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->RequestDone(&ri)))
    {
        ASSERT(WM_ILS_RESOLVE_MEETING == ri.uReqType);

        CIlsServer *pServer = ReqInfo_GetServer (&ri);
        CIlsMain *pMain = ReqInfo_GetMain (&ri);
        ASSERT (pMain != NULL && pServer != NULL);
        if (pMain != NULL && pServer != NULL)
        {
	        // Call the appropriate object's member
    	    //
        	pMain->GetMeetingPlaceResult(ri.uReqID, pmir, pIlsServer);

        	// Release the objects
        	//
			pServer->Release ();
	        pMain->Release();
		}
    }
    else
    {
        DPRINTF1(TEXT("OnResolveMeetingPlaceResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    ::MemFree (pmir);
    return;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnEnumMeetingPlacesResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
void OnEnumMeetingPlacesResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ENUM_MEETINGINFOS == ri.uReqType);
		CIlsServer *pServer = ReqInfo_GetServer (&ri);
		CIlsMain *pMain = ReqInfo_GetMain (&ri);

		ASSERT (pServer != NULL && pMain != NULL);
		if (pServer != NULL && pMain != NULL)
		{
	        // Call the appropriate object's member
	        //
	        pMain->EnumMeetingPlacesResult(ri.uReqID, ple, pServer);
		}

        // If the enumeration was terminated, remove the pending request
        //
        if ((ple == NULL) ||
            (ple->hResult != NOERROR))
        {
            ri.uReqID = 0;
            ri.uMsgID = uMsgID;
            g_pReqMgr->RequestDone(&ri);

            // Release the objects
            //
            if (pMain != NULL)
            	pMain->Release();

            if (pServer != NULL)
            	pServer->Release ();
        };
    }
    else
    {
        DPRINTF1(TEXT("EnumMeetingsResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    if (ple != NULL)
    {
        ::MemFree (ple);
    };
    return;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnEnumMeetingPlaceNamesResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
void OnEnumMeetingPlaceNamesResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ENUM_MEETINGS == ri.uReqType);

        // Call the appropriate object's member
        //
		CIlsMain *pMain = ReqInfo_GetMain (&ri);
		ASSERT (pMain != NULL);
		if (pMain != NULL)
		{
			pMain->EnumMeetingPlaceNamesResult(ri.uReqID, ple);
		}

        // If the enumeration was terminated, remove the pending request
        //
        if ((ple == NULL) ||
            (ple->hResult != NOERROR))
        {
            ri.uReqID = 0;
            ri.uMsgID = uMsgID;
            g_pReqMgr->RequestDone(&ri);

            // Release the objects
            //
            if (pMain != NULL)
            	pMain->Release();
        };
    }
    else
    {
        DPRINTF1(TEXT("OnEnumMeetingPlaceNamesResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    if (ple != NULL)
    {
        ::MemFree (ple);
    };
    return;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnRegisterMeetingPlaceResult(ULONG uMsgID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
VOID OnRegisterMeetingPlaceResult(ULONG uMsgID, HRESULT hr)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_REGISTER_MEETING == ri.uReqType);
        CIlsMeetingPlace *pMeeting = ReqInfo_GetMeeting (&ri);
        ASSERT (pMeeting != NULL);
        if (pMeeting != NULL)
        	pMeeting->RegisterResult(ri.uReqID, hr);

        ri.uReqID = 0;
        ri.uMsgID = uMsgID;
        g_pReqMgr->RequestDone(&ri);

        // Release the objects
        //
        if (pMeeting != NULL)
        	pMeeting->Release();
    }
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnUnregisterMeetingPlaceResult(ULONG uMsgID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
VOID OnUnregisterMeetingPlaceResult(ULONG uMsgID, HRESULT hr)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_UNREGISTER_MEETING == ri.uReqType);
        CIlsMeetingPlace *pMeeting = ReqInfo_GetMeeting (&ri);
        ASSERT (pMeeting != NULL);
        if (pMeeting != NULL)
        	pMeeting->UnregisterResult(ri.uReqID, hr);

        ri.uReqID = 0;
        ri.uMsgID = uMsgID;
        g_pReqMgr->RequestDone(&ri);

        // Release the objects
        //
        if (pMeeting != NULL)
        	pMeeting->Release();
    }
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnUpdateMeetingResult(ULONG uMsgID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
VOID OnUpdateMeetingResult(ULONG uMsgID, HRESULT hr)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_SET_MEETING_INFO == ri.uReqType);
        CIlsMeetingPlace *pMeeting = ReqInfo_GetMeeting (&ri);
        ASSERT (pMeeting != NULL);
        if (pMeeting != NULL)
        	pMeeting->UpdateResult(ri.uReqID, hr);

        ri.uReqID = 0;
        ri.uMsgID = uMsgID;
        g_pReqMgr->RequestDone(&ri);

        // Release the objects
        //
        if (pMeeting != NULL)
        	pMeeting->Release();
    }
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnAddAttendeeResult(ULONG uMsgID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
VOID OnAddAttendeeResult(ULONG uMsgID, HRESULT hr)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ADD_ATTENDEE == ri.uReqType);
        CIlsMeetingPlace *pMeeting = ReqInfo_GetMeeting (&ri);
        ASSERT (pMeeting != NULL);
        if (pMeeting != NULL)
			pMeeting->AddAttendeeResult(ri.uReqID, hr);

        ri.uReqID = 0;
        ri.uMsgID = uMsgID;
        g_pReqMgr->RequestDone(&ri);

        // Release the objects
        //
        if (pMeeting != NULL)
        	pMeeting->Release();
    }
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnRemoveAttendeeResult(ULONG uMsgID, HRESULT hr)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
VOID OnRemoveAttendeeResult(ULONG uMsgID, HRESULT hr)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_REMOVE_ATTENDEE == ri.uReqType);
        CIlsMeetingPlace *pMeeting = ReqInfo_GetMeeting (&ri);
        ASSERT (pMeeting != NULL);
        if (pMeeting != NULL)
			pMeeting->RemoveAttendeeResult(ri.uReqID, hr);

        ri.uReqID = 0;
        ri.uMsgID = uMsgID;
        g_pReqMgr->RequestDone(&ri);

        // Release the objects
        //
        if (pMeeting != NULL)
        	pMeeting->Release();
    }
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Routine:  OnEnumAttendeesResult(ULONG uMsgID, PLDAP_ENUM ple)
//
// Synopsis:
//
// Arguments:
//
// Returns: void
//
// History: 11/27/1996  Shishir Pardikar [shishirp] Created.
//
// Notes:
//
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
VOID OnEnumAttendeesResult(ULONG uMsgID, PLDAP_ENUM ple)
{
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    // Look for the matching request information
    //
    ri.uReqID = 0;
    ri.uMsgID = uMsgID;

    if (SUCCEEDED(g_pReqMgr->GetRequestInfo(&ri)))
    {
        ASSERT(WM_ILS_ENUM_ATTENDEES == ri.uReqType);

        // Call the appropriate object's member
        //
        CIlsMeetingPlace *pMeeting = ReqInfo_GetMeeting (&ri);
        ASSERT (pMeeting != NULL);
        if (pMeeting != NULL)
			pMeeting->EnumAttendeeNamesResult(ri.uReqID, ple);

        // If the enumeration was terminated, remove the pending request
        //
        if ((ple == NULL) ||
            (ple->hResult != NOERROR))
        {
            ri.uReqID = 0;
            ri.uMsgID = uMsgID;
            g_pReqMgr->RequestDone(&ri);

            // Release the objects
            //
	        if (pMeeting != NULL)
    	    	pMeeting->Release();
        };
    }
    else
    {
        DPRINTF1(TEXT("OnEnumUserNamesResult: No pending request for %x"),
                 uMsgID);
        // ASSERT (0);
    };

    // Free the information buffer
    //
    if (ple != NULL)
    {
        ::MemFree (ple);
    };
}
#endif // ENABLE_MEETING_PLACE


//****************************************************************************
// long CALLBACK ULSNotifyProc(HWND hwnd, UINT message, WPARAM wParam,
//                             LPARAM lParam)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

LRESULT CALLBACK ULSNotifyProc(HWND hwnd, UINT message, WPARAM wParam,
                            LPARAM lParam)
{
    switch (message)
    {
#ifdef ENABLE_MEETING_PLACE
        case WM_ILS_REGISTER_MEETING:
            ::OnRegisterMeetingPlaceResult(wParam, lParam);
            break;

        case WM_ILS_UNREGISTER_MEETING:
            ::OnUnregisterMeetingPlaceResult(wParam, lParam);
            break;

        case WM_ILS_SET_MEETING_INFO:
            ::OnUpdateMeetingResult(wParam, lParam);
            break;

        case WM_ILS_ADD_ATTENDEE:
            ::OnAddAttendeeResult(wParam, lParam);
            break;

        case WM_ILS_REMOVE_ATTENDEE:
            ::OnRemoveAttendeeResult(wParam, lParam);
            break;

        case WM_ILS_RESOLVE_MEETING:
			::OnResolveMeetingPlaceResult (wParam, (PLDAP_MEETINFO_RES) lParam);

        case WM_ILS_ENUM_MEETINGINFOS:
            ::OnEnumMeetingPlacesResult(wParam, (PLDAP_ENUM)lParam);
            break;

        case WM_ILS_ENUM_MEETINGS:
            ::OnEnumMeetingPlaceNamesResult(wParam, (PLDAP_ENUM)lParam);
            break;

        case WM_ILS_ENUM_ATTENDEES:
            ::OnEnumAttendeesResult(wParam, (PLDAP_ENUM)lParam);
            break;
#endif // ENABLE_MEETING_PLACE

        case WM_ILS_REGISTER_CLIENT:              // lParam = hResult
        case WM_ILS_UNREGISTER_CLIENT:            // lParam = hResult
            ::OnRegisterResult(message, (ULONG)wParam, (HRESULT)lParam);
            break;

        case WM_ILS_SET_CLIENT_INFO:              // lParam = hResult
            ::OnSetUserInfo (message, (ULONG)wParam, (HRESULT)lParam);
            break;


        case WM_ILS_REGISTER_PROTOCOL:          // lParam = hResult
        case WM_ILS_UNREGISTER_PROTOCOL:  // lParam = hResult
            ::OnSetProtocol (message, (ULONG)wParam, (HRESULT)lParam);
            break;

        case WM_ILS_LOCAL_REGISTER:             // lParam = hResult
        case WM_ILS_LOCAL_UNREGISTER:           // lParam = hResult
            ::OnLocalRegisterResult(message, (ULONG)wParam, (HRESULT)lParam);
            break;

        case WM_ILS_ENUM_CLIENTS:                 // lParam = PLDAP_ENUM
            ::OnEnumUserNamesResult((ULONG)wParam, (PLDAP_ENUM)lParam);
            break;

        case WM_ILS_RESOLVE_CLIENT:               // lParam = PLDAP_CLIENTINFO_RES
            ::OnResolveUserResult((ULONG)wParam, (PLDAP_CLIENTINFO_RES)lParam);
            break;

        case WM_ILS_ENUM_CLIENTINFOS:             // lParam = PLDAP_ENUM
            ::OnEnumUsersResult((ULONG)wParam, (PLDAP_ENUM)lParam);
            break;

        case WM_ILS_ENUM_PROTOCOLS:             // lParam = PLDAP_ENUM
            ::OnEnumProtocolsResult((ULONG)wParam, (PLDAP_ENUM)lParam);
            break;

        case WM_ILS_RESOLVE_PROTOCOL:           // lParam = PLDAP_PROTINFO_RES
            ::OnResolveProtocolResult((ULONG)wParam, (PLDAP_PROTINFO_RES)lParam);
            break;

		case WM_ILS_CLIENT_NEED_RELOGON:				// wParam=fPrimary, lParam=Object Pointer
			::OnClientNeedRelogon ((BOOL) wParam, (VOID *) lParam);
			break;

		case WM_ILS_CLIENT_NETWORK_DOWN:				// wParam=fPrimary, lParam=Object
			::OnClientNetworkDown ((BOOL) wParam, (VOID *) lParam);
			break;

       default:
            return DefWindowProc(hwnd, message, wParam, lParam);
    }

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\wb32stub\wb32stub.cpp ===
// File: wb32stub.cpp

#include <windows.h>
#include <tchar.h>
#include "SDKInternal.h"

#ifdef _DEBUG
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hInstPrev, LPTSTR lpCmdLine, int nCmdShow)
{
	lpCmdLine = GetCommandLine();
#else  // _DEBUG
int __cdecl main()
{
	LPTSTR lpCmdLine = GetCommandLine();
#endif // _DEBUG

	// All I have to do is find two quotes
	int nQuotes = 0;
	while((nQuotes != 2) && (*lpCmdLine))
	{	
		if(*lpCmdLine == '"')
		{
			++nQuotes;
		}

		lpCmdLine = CharNext(lpCmdLine);
	}

		// Skip the whitespace
	lpCmdLine = CharNext(lpCmdLine);

	CoInitialize(NULL);

	IInternalConfExe* pConf = NULL;

	if(SUCCEEDED(CoCreateInstance(CLSID_NmManager, NULL, CLSCTX_LOCAL_SERVER, IID_IInternalConfExe, reinterpret_cast<void**>(&pConf))))
	{	
		BSTR strCmdLine = NULL;
		bool bOldWB = true;
		if(*lpCmdLine)
		{
			if(('-' == lpCmdLine[0]) && (' ' == lpCmdLine[1]))
			{
				bOldWB = false;
				lpCmdLine = CharNext(lpCmdLine);
				lpCmdLine = CharNext(lpCmdLine);
			}

			int nConvertedLen = MultiByteToWideChar(CP_ACP, 0, lpCmdLine, -1, NULL, NULL) - 1;
			strCmdLine = ::SysAllocStringLen(NULL, nConvertedLen);
			if(strCmdLine != NULL)
			{
				MultiByteToWideChar(CP_ACP, 0, lpCmdLine, -1, strCmdLine, nConvertedLen);
			}
		}

		pConf->LaunchApplet(bOldWB ? NM_APPID_WHITEBOARD : NM_APPID_T126_WHITEBOARD, strCmdLine);
		pConf->Release();

		if(strCmdLine)
		{
			SysFreeString(strCmdLine);
		}
	}
	
	CoUninitialize();

#ifndef _DEBUG
	ExitProcess(0);
#endif

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\classfac.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       classfac.cpp
//  Content:    This file contains the class factory object.
//  History:
//      Tue 08-Oct-1996 08:56:46  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "culs.h"

//****************************************************************************
// Initialize GUIDs (should be done only and at-least once per DLL/EXE)
//****************************************************************************

#define INITGUID
#include <initguid.h>
#include <ilsguid.h>
#include "classfac.h"

//****************************************************************************
// Global Parameters
//****************************************************************************
//
CClassFactory*  g_pClassFactory = NULL;

//****************************************************************************
// CClassFactory::CClassFactory (void)
//
// History:
//  Tue 08-Oct-1996 09:00:10  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CClassFactory::
CClassFactory (void)
{
    cRef = 0;
    return;
}

//****************************************************************************
// STDMETHODIMP
// CClassFactory::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Tue 08-Oct-1996 09:00:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CClassFactory::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IClassFactory || riid == IID_IUnknown)
    {
        *ppv = (IClassFactory *) this;
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return ILS_E_NO_INTERFACE;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CClassFactory::AddRef (void)
//
// History:
//  Tue 08-Oct-1996 09:00:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CClassFactory::AddRef (void)
{
    DllLock();

	ASSERT (this == g_pClassFactory);

	MyDebugMsg ((DM_REFCOUNT, "CClassFactory::AddRef: ref=%ld\r\n", cRef));
    ::InterlockedIncrement ((LONG *) &cRef);
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CClassFactory::Release (void)
//
// History:
//  Tue 08-Oct-1996 09:00:33  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CClassFactory::Release (void)
{
    DllRelease();

	ASSERT (this == g_pClassFactory);
	ASSERT (cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CClassFactory::Release: ref=%ld\r\n", cRef));
    if (::InterlockedDecrement ((LONG *) &cRef) == 0)
    {
        delete this;
	    g_pClassFactory = NULL;
    };

    return cRef;
}

//****************************************************************************
// STDMETHODIMP
// CClassFactory::CreateInstance (LPUNKNOWN punkOuter, REFIID riid, void **ppv)
//
// History:
//  Tue 08-Oct-1996 09:00:40  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CClassFactory::CreateInstance (LPUNKNOWN punkOuter, REFIID riid, void **ppv)
{
    CIlsMain *pcu;
    HRESULT     hr;

    if (ppv == NULL)
    {
        return ILS_E_POINTER;
    };

    *ppv = NULL;

    if (punkOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    };

    // Allow only on instance of the ULS object
    //
    if (g_pCIls != NULL)
    {
        return ILS_E_FAIL;
    };

    pcu = new CIlsMain;

    if (pcu != NULL)
    {
        hr = pcu->Init();

        if (SUCCEEDED(hr))
        {
            *ppv = (IIlsMain *)pcu;
            pcu->AddRef();
        }
        else
        {
            delete pcu;
        };
    }
    else
    {
        hr = ILS_E_MEMORY;
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CClassFactory::LockServer (BOOL fLock)
//
// History:
//  Tue 08-Oct-1996 09:00:48  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CClassFactory::LockServer (BOOL fLock)
{
    if (fLock)
    {
        DllLock();
		MyDebugMsg ((DM_REFCOUNT, "CClassFactory::LockServer\r\n"));
    }
    else
    {
        DllRelease();
		MyDebugMsg ((DM_REFCOUNT, "CClassFactory::UNLockServer\r\n"));
    };
    return S_OK;
}

//****************************************************************************
// STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
//
// History:
//  Tue 08-Oct-1996 09:00:55  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (riid == IID_IClassFactory || riid == IID_IUnknown)
    {
        // Check the requested class
        //
        if (rclsid == CLSID_InternetLocationServices)
        {
        	if (g_pClassFactory == NULL)
        	{
			    g_pClassFactory = new CClassFactory;
			}
			ASSERT (g_pClassFactory != NULL);

            if ((*ppv = (void *) g_pClassFactory) != NULL)
            {
				g_pClassFactory->AddRef ();
                return NOERROR;
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        };
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\cserver.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\attribs.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       attribs.h
//  Content:    This file contains the attributes object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

#ifndef _ATTRIBS_H_
#define _ATTRIBS_H_

//****************************************************************************
// CAttributes definition
//****************************************************************************
//
class CAttributes : public IIlsAttributes
{
	friend class CIlsMain;
	friend class CIlsUser;
	friend class CIlsMeetingPlace;

private:
	LONG			m_cRef;
	ILS_ATTR_TYPE	m_AccessType;
	ULONG			m_cAttrs;
	ULONG			m_cchNames;
	ULONG			m_cchValues;
	CList			m_AttrList;

	// Private methods
	//
	HRESULT InternalSetAttribute ( TCHAR *pszName, TCHAR *pszValue );
	HRESULT InternalCheckAttribute ( TCHAR *pszName, BOOL fRemove );
	HRESULT InternalSetAttributeName ( TCHAR *pszName );

protected:

	VOID SetAccessType ( ILS_ATTR_TYPE AttrType ) { m_AccessType = AttrType; }

public:
	// Constructor and destructor
	//
	CAttributes ( VOID );
	~CAttributes ( VOID );

	// For internal use
	//
	ULONG GetCount ( VOID ) { return m_cAttrs; }

	ILS_ATTR_TYPE GetAccessType( void) { return m_AccessType; }
 
	HRESULT GetAttributeList ( TCHAR **ppszList, ULONG *pcList, ULONG *pcb );
	HRESULT GetAttributePairs ( TCHAR **ppszPairs, ULONG *pcList, ULONG *pcb );
	HRESULT SetAttributePairs( TCHAR *pszPairs, ULONG cPair );
	HRESULT SetAttributes ( CAttributes *pAttributes );
	HRESULT RemoveAttributes ( CAttributes *pAttributes);
    HRESULT CloneNameValueAttrib(CAttributes **ppClone);
	// IUnknown
	//
	STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
	STDMETHODIMP_(ULONG)    AddRef (void);
	STDMETHODIMP_(ULONG)    Release (void);

	// IIlsAttributes
	//

	// For ILS_ATTRTYPE_NAME_VALUE
	//
	STDMETHODIMP            SetAttribute (BSTR bstrName, BSTR bstrValue);
	STDMETHODIMP            GetAttribute (BSTR bstrName, BSTR *pbstrValue);
	STDMETHODIMP            EnumAttributes (IEnumIlsNames **ppEnumAttribute);

	// For ILS_ATTRTYPE_NAME_ONLY
	//
	STDMETHODIMP			SetAttributeName ( BSTR bstrName );

#ifdef DEBUG
	// For debugging
	//
	void                    DebugOut (void);
#endif // DEBUG
};

#endif //_ATTRIBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\attribs.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       attribs.cpp
//  Content:    This file contains the attributes object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

#include "ulsp.h"
#include "attribs.h"

//****************************************************************************
// CAttributes::CAttributes (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//  12/05/96 -by- Chu, Lon-Chan [lonchanc]
// Added access type.
//****************************************************************************

CAttributes::
CAttributes ( VOID )
:m_cRef (0),
 m_cAttrs (0),
 m_cchNames (0),
 m_cchValues (0),
 m_AccessType (ILS_ATTRTYPE_NAME_VALUE)
{
}

//****************************************************************************
// CAttributes::~CAttributes (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CAttributes::~CAttributes (void)
{
	ASSERT (m_cRef == 0);

    LPTSTR pszAttr;
    HANDLE hEnum;

    // Free all the attributes
    //
    m_AttrList.Enumerate(&hEnum);
    while (m_AttrList.Next(&hEnum, (LPVOID *)&pszAttr) == NOERROR)
    {
        ::MemFree (pszAttr);
    }
    m_AttrList.Flush();
    return;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CAttributes::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IIlsAttributes || riid == IID_IUnknown)
    {
        *ppv = (IIlsAttributes *) this;
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CAttributes::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CAttributes::AddRef (void)
{
	DllLock ();

	MyDebugMsg ((DM_REFCOUNT, "CAttribute::AddRef: ref=%ld\r\n", m_cRef));
    ::InterlockedIncrement (&m_cRef);
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CAttributes::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CAttributes::Release (void)
{
	DllRelease ();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CAttribute::Release: ref=%ld\r\n", m_cRef));
    if (::InterlockedDecrement (&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::InternalSetAttribute (LPTSTR szName, LPTSTR szValue)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CAttributes::
InternalSetAttribute ( TCHAR *pszName, TCHAR *pszValue )
{
    ULONG cName, cValue;
    LPTSTR  *ppszAttr;
    LPTSTR pszNewAttr;
    HANDLE hEnum;
    HRESULT hr;

    // Allocate the new attribute pair
    //
    cName = lstrlen(pszName);
	cValue = (pszValue != NULL) ? lstrlen (pszValue) : 0;
    pszNewAttr = (TCHAR *) ::MemAlloc (((cName+1) + (cValue+1)) * sizeof (TCHAR));
    if (pszNewAttr == NULL)
    {
        return ILS_E_MEMORY;
    };

    // Make the new attribute pair
    //
    lstrcpy(pszNewAttr, pszName);
    lstrcpy(pszNewAttr + cName + 1, (pszValue != NULL) ? pszValue : TEXT (""));

    // Look for the attribute in the list
    //
    hr = NOERROR;
    m_AttrList.Enumerate(&hEnum);
    while(m_AttrList.NextStorage(&hEnum, (PVOID *)&ppszAttr) == NOERROR)
    {
        // Match the attribute's name
        //
        if (!lstrcmpi(*ppszAttr, pszName))
        {
            // Found the specified attribute
            //
            break;
        };
    };

    if (ppszAttr != NULL)
    {
        // Replace the old pair
        //
        m_cchValues += (cValue + 1) -
                    (lstrlen(((LPTSTR)*ppszAttr)+cName+1)+1);
        ::MemFree (*ppszAttr);
        *ppszAttr = pszNewAttr;
    }
    else
    {
        // Insert the new attribute pair
        //
        hr = m_AttrList.Insert(pszNewAttr);

        if (SUCCEEDED(hr))
        {
            // Update the name buffer count
            //
            m_cchNames += cName+1;
            m_cchValues += cValue+1;
            m_cAttrs++;
        }
        else
        {
            ::MemFree (pszNewAttr);      
        };
    };

    return hr;
}

//****************************************************************************
// HRESULT
// CAttributes::InternalSetAttributeName ( TCHAR *pszName )
//
// History:
//  12/06/96 -by- Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

HRESULT CAttributes::
InternalSetAttributeName ( TCHAR *pszName )
{
	// We do not check for duplicate
	//
	HRESULT hr = m_AttrList.Insert (pszName);
	if (hr == S_OK)
	{
		// Update the name buffer count
		//
		m_cchNames += lstrlen (pszName) + 1;
		m_cAttrs++;
	}

	return hr;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::InternalRemoveAttribute (LPTSTR szName)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CAttributes::
InternalCheckAttribute ( TCHAR *pszName, BOOL fRemove )
{
    LPTSTR  pszAttr;
    HANDLE  hEnum;
    HRESULT hr;

    // Look for the attribute in the list
    //
    m_AttrList.Enumerate(&hEnum);
    while(m_AttrList.Next(&hEnum, (PVOID *)&pszAttr) == NOERROR)
    {
        // Match the attribute's name
        //
        if (! lstrcmpi(pszAttr, pszName))
        {
            // Found the specified attribute
            //
            break;
        };
    };

    // If found, we are asked to remove it, do so
    //
    if (pszAttr != NULL)
    {
        if (fRemove) {
            hr = m_AttrList.Remove(pszAttr);

            if (SUCCEEDED(hr))
            {
                ULONG   cName;

                // Update the name buffer count
                //
                cName = lstrlen(pszName);
                m_cchNames -= cName+1;
                m_cchValues -= lstrlen(pszAttr+cName+1)+1;
                m_cAttrs--;

                ::MemFree (pszAttr);
           };
        }
        else {
            hr = S_OK;
        }
    }
    else
    {
        hr = S_FALSE;
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::SetAttribute (BSTR bstrName, BSTR bstrValue)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//  12/06/96 -by- Chu, Lon-Chan [lonchanc]
// Added access type.
//****************************************************************************

STDMETHODIMP CAttributes::
SetAttribute ( BSTR bstrName, BSTR bstrValue )
{
    LPTSTR  szName;
    HRESULT hr;

	// Validate access type
	//
	if (m_AccessType != ILS_ATTRTYPE_NAME_VALUE)
		return ILS_E_ACCESS_CONTROL;

    // Validate parameters
    //
    if (bstrName == NULL)
        return ILS_E_POINTER;

    if (*bstrName == '\0')
        return ILS_E_PARAMETER;

    // Convert the name format
    //
    hr = BSTR_to_LPTSTR(&szName, bstrName);

    if (SUCCEEDED(hr))
    {
        // If bstrValue is NULL, remove the attribute
        //
        if (bstrValue == NULL)
        {
            hr = InternalCheckAttribute(szName, TRUE);
        }
        else
        {
            LPTSTR  szValue = NULL;

			if (bstrValue != NULL && *bstrValue != L'\0')
				hr = BSTR_to_LPTSTR(&szValue, bstrValue);

            if (SUCCEEDED(hr))
            {
                hr = InternalSetAttribute(szName, szValue);
                ::MemFree (szValue);
            };
        };

        // Free resources
        //
        ::MemFree (szName);
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::GetAttribute (BSTR bstrName, BSTR *pbstrValue)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//  12/06/96 -by- Chu, Lon-Chan [lonchanc]
// Added access type.
//****************************************************************************

STDMETHODIMP CAttributes::
GetAttribute ( BSTR bstrName, BSTR *pbstrValue )
{
    LPTSTR szName;
    HRESULT hr;

	// Validate access type
	//
	if (m_AccessType != ILS_ATTRTYPE_NAME_VALUE)
		return ILS_E_ACCESS_CONTROL;

    // Validate parameters
    //
    if (pbstrValue == NULL)
        return ILS_E_POINTER;

    // Assume failure
    //
    *pbstrValue = NULL;

    // Validate more parameters
    //
    if (bstrName == NULL)
        return ILS_E_POINTER;

    if (*bstrName == '\0')
        return ILS_E_PARAMETER;

    // Convert the name format
    //
    hr = BSTR_to_LPTSTR(&szName, bstrName);

    if (SUCCEEDED(hr))
    {
        HANDLE hEnum;
        LPTSTR pszAttr;

        // Look for the attribute in the list
        //
        m_AttrList.Enumerate(&hEnum);
        while(m_AttrList.Next(&hEnum, (PVOID *)&pszAttr) == NOERROR)
        {
            // Match the attribute's name
            //
            if (!lstrcmpi(pszAttr, szName))
            {
                // Found the specified attribute
                //
                break;
            };
        };

        // If found, return the value
        //
        if (pszAttr != NULL)
        {
            hr = LPTSTR_to_BSTR(pbstrValue, pszAttr+lstrlen(pszAttr)+1);
        }
        else
        {
            hr = ILS_E_FAIL;
        };
    };

    // Free resources
    //
    ::MemFree (szName);
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::EnumAttributes (IEnumIlsNames *pEnumAttribute)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//  12/06/96 -by- Chu, Lon-Chan [lonchanc]
// Added access type.
//****************************************************************************

STDMETHODIMP CAttributes::
EnumAttributes ( IEnumIlsNames **ppEnumAttribute )
{
    CEnumNames *pea;
    ULONG  cAttrs, cbAttrs;
    LPTSTR pszAttrs;
    HRESULT hr;

	// Validate access type
	//
	if (m_AccessType != ILS_ATTRTYPE_NAME_VALUE)
		return ILS_E_ACCESS_CONTROL;

    // Validate parameters
    //
    if (ppEnumAttribute == NULL)
        return ILS_E_POINTER;

    // Assume failure
    //
    *ppEnumAttribute = NULL;

    hr = GetAttributeList(&pszAttrs, &cAttrs, &cbAttrs);

    if (FAILED(hr))
    {
        return hr;
    };

    // Create a peer enumerator
    //
    pea = new CEnumNames;

    if (pea != NULL)
    {
        hr = pea->Init(pszAttrs, cAttrs);

        if (SUCCEEDED(hr))
        {
            // Get the enumerator interface
            //
            pea->AddRef();
            *ppEnumAttribute = pea;
        }
        else
        {
            delete pea;
        };
    }
    else
    {
        hr = ILS_E_MEMORY;
    };

    if (pszAttrs != NULL)
    {
        ::MemFree (pszAttrs);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::SetAttributeName (BSTR bstrName)
//
// History:
//  12/05/96 -by- Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

STDMETHODIMP CAttributes::
SetAttributeName ( BSTR bstrName )
{
	TCHAR *pszName;
	HRESULT hr;

	// Validate access type
	//
	if (m_AccessType != ILS_ATTRTYPE_NAME_ONLY)
		return ILS_E_ACCESS_CONTROL;

	// Validate parameters
	//
	if (bstrName == NULL)
		return ILS_E_POINTER;

	if (*bstrName == '\0')
		return ILS_E_PARAMETER;

	// Convert the name format
	//
	if (BSTR_to_LPTSTR (&pszName, bstrName) != S_OK)
		return ILS_E_MEMORY;

	// Set the attribute name
	//
	return InternalSetAttributeName (pszName);
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::GetAttributeList (LPTSTR *ppszList, ULONG *pcList, ULONG *pcb)
// 	Get attribute names only.
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CAttributes::
GetAttributeList ( TCHAR **ppszList, ULONG *pcList, ULONG *pcb )
{
    LPTSTR szAttrs, pszNext, pszAttr;
    HANDLE hEnum;
#ifdef DEBUG
    ULONG cAttrsDbg = 0;
#endif // DEBUG

    // Assume no list or failure
    //
    *ppszList = NULL;
    *pcList = 0;
    *pcb = 0;

    // If no list, return nothing
    //
    if (m_cAttrs == 0)
    {
        return NOERROR;
    };

    // Allocate the buffer for the attribute list
    //
    szAttrs = (TCHAR *) ::MemAlloc ((m_cchNames+1) * sizeof (TCHAR));
    if (szAttrs == NULL)
    {
        return ILS_E_MEMORY;
    };

    // Enumerate the list
    //
    pszNext = szAttrs;
    m_AttrList.Enumerate(&hEnum);
    while(m_AttrList.Next(&hEnum, (PVOID *)&pszAttr) == NOERROR)
    {
        // Attribute name
        //
        lstrcpy(pszNext, pszAttr);
        pszNext += lstrlen(pszNext)+1;
#ifdef DEBUG
        cAttrsDbg++;
#endif // DEBUG
    };
    *pszNext = '\0';
    ASSERT(cAttrsDbg == m_cAttrs);
    
    // return the attribute list
    //
    *pcList = m_cAttrs;
    *ppszList = szAttrs;
    *pcb = (m_cchNames+1)*sizeof(TCHAR);
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::GetAttributePairs (LPTSTR *ppszList, ULONG *pcList, ULONG *pcb)
//	Get pairs of attribute names and values.
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CAttributes::
GetAttributePairs ( TCHAR **ppszPairs, ULONG *pcList, ULONG *pcb )
{
    LPTSTR szAttrs, pszNext, pszAttr;
    ULONG cLen;
    HANDLE hEnum;
#ifdef DEBUG
    ULONG cAttrsDbg = 0;
#endif // DEBUG

	// Validate access type
	//
	if (m_AccessType != ILS_ATTRTYPE_NAME_VALUE)
		return ILS_E_ACCESS_CONTROL;

    // Assume no list or failure
    //
    *ppszPairs = NULL;
    *pcList = 0;
    *pcb = 0;

    // If no list, return nothing
    //
    if (m_cAttrs == 0)
    {
        return NOERROR;
    };

    // Allocate the buffer for the attribute list
    //
    szAttrs = (TCHAR *) ::MemAlloc ((m_cchNames+m_cchValues+1) * sizeof (TCHAR));
    if (szAttrs == NULL)
    {
        return ILS_E_MEMORY;
    };

    // Enumerate the list
    //
    pszNext = szAttrs;
    m_AttrList.Enumerate(&hEnum);
    while(m_AttrList.Next(&hEnum, (PVOID *)&pszAttr) == NOERROR)
    {
        // Attribute name
        //
        lstrcpy(pszNext, pszAttr);
        cLen = lstrlen(pszNext)+1;
        pszNext += cLen;

        // Attribute value
        //
        lstrcpy(pszNext, pszAttr+cLen);
        pszNext += lstrlen(pszNext)+1;

#ifdef DEBUG
        cAttrsDbg++;
#endif // DEBUG
    };
    *pszNext = '\0';
    ASSERT(cAttrsDbg == m_cAttrs);
    
    // return the attribute list
    //
    *pcList = m_cAttrs;
    *ppszPairs = szAttrs;
    *pcb = (m_cchNames+m_cchValues+1)*sizeof(TCHAR);
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::SetAttributePairs (LPTSTR pszList, ULONG cPair)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CAttributes::
SetAttributePairs ( TCHAR *pszList, ULONG cPair )
{
    LPTSTR pszName, pszValue;
    ULONG cLen, i;
    HRESULT hr;

	// Validate access type
	//
	if (m_AccessType != ILS_ATTRTYPE_NAME_VALUE)
		return ILS_E_ACCESS_CONTROL;

    // Do nothing if nothing to set
    //
    if ((cPair == 0) ||
        (pszList == NULL))
    {
        return NOERROR;
    };

    pszName = pszList;
    for (i = 0; i < cPair; i++)
    {
        pszValue = pszName + lstrlen(pszName) + 1;
        InternalSetAttribute(pszName, pszValue);
        pszName = pszValue + lstrlen(pszValue) + 1;
    };
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::SetAttributes (CAttributes *pAttributes)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CAttributes::
SetAttributes ( CAttributes *pAttrsEx )
{
    LPTSTR pszNextAttr;
    HANDLE hEnum;
    HRESULT hr;

	// Validate access type
	//
	if (m_AccessType != ILS_ATTRTYPE_NAME_VALUE)
		return ILS_E_ACCESS_CONTROL;

    // Enumerate the external attribute list
    //
    pAttrsEx->m_AttrList.Enumerate(&hEnum);
    while(pAttrsEx->m_AttrList.Next(&hEnum, (PVOID *)&pszNextAttr) == NOERROR)
    {
        hr = InternalSetAttribute(pszNextAttr,
                                  pszNextAttr+lstrlen(pszNextAttr)+1);
        ASSERT(SUCCEEDED(hr));
    };
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CAttributes::RemoveAttributes (CAttributes *pAttributes)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CAttributes::
RemoveAttributes ( CAttributes *pAttrsEx )
{
    LPTSTR pszNextAttr;
    HANDLE hEnum;

    // Enumerate the external attribute list
    //
    pAttrsEx->m_AttrList.Enumerate(&hEnum);
    while(pAttrsEx->m_AttrList.Next(&hEnum, (PVOID *)&pszNextAttr) == NOERROR)
    {
        InternalCheckAttribute(pszNextAttr, TRUE);
    };
    return NOERROR;
}

#ifdef MAYBE
HRESULT CAttributes::
SetOpsAttributes ( CAttributes *pAttrsEx, CAttributes **ppOverlap, CAttributes **ppIntersect )
{
    LPTSTR pszNextAttr;
    HANDLE hEnum;
    BOOL fFullOverlap=FALSE, fNoOverlap = TRUE;

    // Enumerate the external attribute list
    //
    pAttrsEx->m_AttrList.Enumerate(&hEnum);
    while(pAttrsEx->m_AttrList.Next(&hEnum, (PVOID *)&pszNextAttr) == NOERROR)
    {
        if (InternalCheckAttribute(pszNextAttr, FALSE)!=S_OK) {
            // didn't find this attribute
            if (ppOverlap) {
                if (!*ppOverlap) {

                    *ppOverlap = new CAttributes;
                    if (!*ppOverlap) {

                        goto bailout;

                    }

                    (*ppOverlap)->SetAccessType (ILS_ATTRTYPE_NAME_VALUE);

                }
                
            }

        }
        else {

        }
    };

bailout:

    return NOERROR;
}
#endif //MAYBE



#ifdef DEBUG
//****************************************************************************
// void
// CAttributes::DebugOut (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void
CAttributes::DebugOut (void)
{
    LPTSTR pszNextAttr;
    HANDLE hEnum;

    // The attribute pair count
    //
    DPRINTF1(TEXT("Number of attributes: %d\r\n"), m_cAttrs);

    // Each attribute pair
    //
    m_AttrList.Enumerate(&hEnum);
    while(m_AttrList.Next(&hEnum, (PVOID *)&pszNextAttr) == NOERROR)
    {
        DPRINTF2(TEXT("\t<%s> = <%s>"), pszNextAttr,
                 pszNextAttr+lstrlen(pszNextAttr)+1);
    };
    return;
}
#endif // DEBUG


//****************************************************************************
// STDMETHODIMP
// CAttributes::Clone(IIlsAttibutes **ppAttributes)
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// History: 1/22/1997  Shishir Pardikar [shishirp] Created.
//
// Notes:   this clones only attrib list which has both name and value
//
//****************************************************************************
HRESULT
CAttributes::CloneNameValueAttrib(CAttributes **ppAttributes)
{
    CAttributes *pAttributes = NULL;
    HRESULT hr;

    if (ppAttributes == NULL) {

        return (ILS_E_PARAMETER);

    }

    *ppAttributes = NULL;



    pAttributes = new CAttributes;

    if (!pAttributes) {

        return (ILS_E_MEMORY);

    }

	pAttributes->SetAccessType (m_AccessType);
    hr = pAttributes->SetAttributes(this);

    if (!SUCCEEDED(hr)) {

        delete pAttributes;
        return hr;            

    }

    *ppAttributes = pAttributes;


    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\classfac.h ===
#ifndef _CLASSFAC_H_
#define _CLASSFAC_H_

//****************************************************************************
// CClassFactory definition
//****************************************************************************
//
class CClassFactory : public IClassFactory
{
private:
    ULONG cRef;

public:
    // Constructor
    CClassFactory(void);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IClassFactory
    STDMETHODIMP            CreateInstance (LPUNKNOWN punkOuter, REFIID iid, void **ppv);
    STDMETHODIMP            LockServer (BOOL fLock);
};

extern CClassFactory*  g_pClassFactory;

#endif // ! _CLASSFAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\connpt.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       connpt.cpp
//  Content:    This file contains the conection point object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

#include "ulsp.h"
#include "connpt.h"

//****************************************************************************
// CEnumConnectionPoints::CEnumConnectionPoints (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumConnectionPoints::CEnumConnectionPoints (void)
{
    cRef = 0;
    iIndex = 0;
    pcnp = NULL;
    return;
}

//****************************************************************************
// CEnumConnectionPoints::~CEnumConnectionPoints (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumConnectionPoints::~CEnumConnectionPoints (void)
{
    if (pcnp != NULL)
    {
        pcnp->Release();
    };
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnectionPoints::Init (IConnectionPoint *pcnpInit)
//
// History:
//  Wed 17-Apr-1996 11:15:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnectionPoints::Init (IConnectionPoint *pcnpInit)
{
    iIndex = 0;
    pcnp = pcnpInit;

    if (pcnp != NULL)
    {
        pcnp->AddRef();
    };
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnectionPoints::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:15:31  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnectionPoints::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumConnectionPoints || riid == IID_IUnknown)
    {
        *ppv = (IEnumConnectionPoints *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumConnectionPoints::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:15:37  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumConnectionPoints::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CEnumConnectionPoints::AddRef: ref=%ld\r\n", cRef));
    ::InterlockedIncrement ((LONG *) &cRef);
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumConnectionPoints::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:15:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumConnectionPoints::Release (void)
{
    DllRelease();

	ASSERT (cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CEnumConnectionPoints::Release: ref=%ld\r\n", cRef));
	if (::InterlockedDecrement ((LONG *) &cRef) == 0)
    {
        delete this;
        return 0;
    }
    return cRef;
}

//****************************************************************************
// STDMETHODIMP 
// CEnumConnectionPoints::Next (ULONG cConnections,
//                              IConnectionPoint **rgpcn,
//                              ULONG *pcFetched)
//
// History:
//  Wed 17-Apr-1996 11:15:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP 
CEnumConnectionPoints::Next (ULONG cConnections,
                             IConnectionPoint **rgpcn,
                             ULONG *pcFetched)
{
    ULONG   cCopied;

    // Validate the pointer
    //
    if (rgpcn == NULL)
        return ILS_E_POINTER;

    // Validate the parameters
    //
    if ((cConnections == 0) ||
        ((cConnections > 1) && (pcFetched == NULL)))
        return ILS_E_PARAMETER;

    // Check the enumeration index
    //
    cCopied = 0;
    if ((pcnp != NULL) && (iIndex == 0))
    {
        // Return the only connection point
        //
        *rgpcn = pcnp;
        (*rgpcn)->AddRef();
        iIndex++;
        cCopied++;    
    };

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cConnections == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnectionPoints::Skip (ULONG cConnections)
//
// History:
//  Wed 17-Apr-1996 11:15:56  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnectionPoints::Skip (ULONG cConnections)
{
    // Validate the parameters
    //
    if (cConnections == 0) 
        return ILS_E_PARAMETER;

    // Check the enumeration index limit
    //
    if ((pcnp == NULL) || (iIndex > 0))
    {
        return S_FALSE;
    }
    else
    {
        // Skip the only elelment
        //
        iIndex++;
        return (cConnections == 1 ? S_OK : S_FALSE);
    };
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnectionPoints::Reset (void)
//
// History:
//  Wed 17-Apr-1996 11:16:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnectionPoints::Reset (void)
{
    iIndex = 0;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnectionPoints::Clone(IEnumConnectionPoints **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:16:11  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnectionPoints::Clone(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ILS_E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ILS_E_MEMORY;

    // Clone the information
    //
    pecp->iIndex = iIndex;
    pecp->pcnp = pcnp;

    if (pcnp != NULL)
    {
        pcnp->AddRef();
    };

    // Return the cloned enumerator
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// CConnectionPoint::CConnectionPoint (const IID *pIID,
//                                     IConnectionPointContainer *pCPCInit)
//
// History:
//  Wed 17-Apr-1996 11:16:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CConnectionPoint::CConnectionPoint (const IID *pIID,
                                    IConnectionPointContainer *pCPCInit)
{
    cRef = 0;
    riid = *pIID;
    pCPC = pCPCInit;
    dwNextCookie = COOKIE_INIT_VALUE;
    cSinkNodes = 0;
    pSinkList = NULL;
    return;
}

//****************************************************************************
// CConnectionPoint::~CConnectionPoint (void)
//
// History:
//  Wed 17-Apr-1996 11:16:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CConnectionPoint::~CConnectionPoint (void)
{
    PSINKNODE pSinkNode;

    // Traverse the sink list and free each one of them
    //
    while (pSinkList != NULL)
    {
        pSinkNode = pSinkList;
        pSinkList = pSinkNode->pNext;

        pSinkNode->pUnk->Release();
        delete pSinkNode;
    };
    return;
}

//****************************************************************************
// STDMETHODIMP
// CConnectionPoint::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:16:23  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CConnectionPoint::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IConnectionPoint || riid == IID_IUnknown)
    {
        *ppv = (IConnectionPoint *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CConnectionPoint::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:16:30  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CConnectionPoint::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CConnectionPoint::AddRef: ref=%ld\r\n", cRef));
    ::InterlockedIncrement ((LONG *) &cRef);
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CConnectionPoint::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:16:36  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CConnectionPoint::Release (void)
{
    DllRelease();

	ASSERT (cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CConnectionPoint::Release: ref=%ld\r\n", cRef));
	if (::InterlockedDecrement ((LONG *) &cRef) == 0)
    {
        delete this;
        return 0;
    }
    return cRef;
}

//****************************************************************************
// STDMETHODIMP
// CConnectionPoint::Notify(void *pv, CONN_NOTIFYPROC pfn)
//
// History:
//  Wed 17-Apr-1996 11:16:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CConnectionPoint::Notify(void *pv, CONN_NOTIFYPROC pfn)
{
    PSINKNODE  pSinkNode, pPrev;
    IUnknown   *pUnk;
    BOOL       fNeedClear;
    HRESULT    hr;

    // Enumerate each connection
    //
    pSinkNode = pSinkList;
    hr = S_OK;
    fNeedClear = FALSE;
    while((pSinkNode != NULL) && (SUCCEEDED(hr)))
    {
        // Important!! Important!!
        // Lock the sink object here. Need to do this in case that the sink
        // object calls back to Unadvise and we remove this sink node during
        // callback.
        //
        pSinkNode->uFlags |= SN_LOCKED;
        pUnk = pSinkNode->pUnk;

        // Calls the sink object
        // Note: Do not need to reference the sink object again.
        //       We already did when Advise was called.
        //
        hr = (*pfn)(pUnk, pv);

        pSinkNode->uFlags &= ~SN_LOCKED;
        if (pSinkNode->uFlags & SN_REMOVED)
        {
            fNeedClear = TRUE;
        };

        pSinkNode = pSinkNode->pNext;
    };

    // If there is at least one node to free
    //
    if (fNeedClear)
    {
        // Traverse the list for nodes to remove
        //
        pSinkNode = pSinkList;
        pPrev = NULL;

        while (pSinkNode != NULL)
        {
            // Release the sink object, if unadvise
            //
            if (pSinkNode->uFlags & SN_REMOVED)
            {
                PSINKNODE pNext;

                pNext = pSinkNode->pNext;
                if (pPrev == NULL)
                {
                    // This is the head of the list
                    //
                    pSinkList = pNext;
                }
                else
                {
                    pPrev->pNext = pNext;
                };

                pSinkNode->pUnk->Release();
                cSinkNodes--;
                delete pSinkNode;
                pSinkNode = pNext;
            }
            else
            {
                pPrev = pSinkNode;
                pSinkNode = pSinkNode->pNext;
            };
        };
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CConnectionPoint::GetConnectionInterface(IID *pIID)
//
// History:
//  Wed 17-Apr-1996 11:16:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CConnectionPoint::GetConnectionInterface(IID *pIID)
{
    // Validate the parameter
    //
    if (pIID == NULL)
        return ILS_E_POINTER;

    // Support only one connection interface
    //
    *pIID = riid;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
//
// History:
//  Wed 17-Apr-1996 11:16:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
    // Validate the parameter
    //
    if (ppCPC == NULL)
        return ILS_E_POINTER;

    // Return the container and add its reference count
    //
    *ppCPC = pCPC;

    if (pCPC != NULL)
    {
        // The container is still alive
        //
        pCPC->AddRef();
        return S_OK;
    }
    else
    {
        // The container no longer exists
        //
        return ILS_E_FAIL;
    };
}

//****************************************************************************
// STDMETHODIMP
// CConnectionPoint::Advise(IUnknown *pUnk, DWORD *pdwCookie)
//
// History:
//  Wed 17-Apr-1996 11:17:01  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CConnectionPoint::Advise(IUnknown *pUnk, DWORD *pdwCookie)
{
    PSINKNODE pSinkNode;
    IUnknown *pSinkInterface;

    // Validate the parameter
    //
    if ((pUnk == NULL) ||
        (pdwCookie == NULL))
        return ILS_E_PARAMETER;

    // Get the sink interface
    //
    if (FAILED(pUnk->QueryInterface(riid, (void **)&pSinkInterface)))
        return CONNECT_E_CANNOTCONNECT;

    // Create the sink node
    //
    pSinkNode = new SINKNODE;
    pSinkNode->pNext = pSinkList;
    pSinkNode->pUnk = pSinkInterface;
    pSinkNode->dwCookie = dwNextCookie;
    pSinkNode->uFlags = 0;
    *pdwCookie = dwNextCookie;

    // Put it in the sink list
    //
    pSinkList = pSinkNode;
    dwNextCookie++;
    cSinkNodes++;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CConnectionPoint::Unadvise(DWORD dwCookie)
//
// History:
//  Wed 17-Apr-1996 11:17:09  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CConnectionPoint::Unadvise(DWORD dwCookie)
{
    PSINKNODE pSinkNode, pPrev;

    // Search for the matching sink object
    //
    pPrev = NULL;
    pSinkNode = pSinkList;

    // Traverse the sink list to find the specified sink object
    //
    while (pSinkNode != NULL)
    {
        if (pSinkNode->dwCookie == dwCookie)
        {
            // Flag to remove
            //
            pSinkNode->uFlags |= SN_REMOVED;
            break;
        };

        pPrev = pSinkNode;
        pSinkNode = pSinkNode->pNext;
    };

    // Have we found the specified sink object?
    //
    if (pSinkNode == NULL)
    {
        // No, return failure
        //
        return CONNECT_E_NOCONNECTION;
    };

    // Release the sink object, if not locked
    //
    if ((pSinkNode->uFlags & SN_REMOVED) &&
        !(pSinkNode->uFlags & SN_LOCKED))
    {
        // Is there a previous node?
        //
        if (pPrev == NULL)
        {
            // This is the head of the list
            //
            pSinkList = pSinkNode->pNext;
        }
        else
        {
            pPrev->pNext = pSinkNode->pNext;
        };

        pSinkNode->pUnk->Release();
        cSinkNodes--;
        delete pSinkNode;
    };

    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CConnectionPoint::EnumConnections(IEnumConnections **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:17:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CConnectionPoint::EnumConnections(IEnumConnections **ppEnum)
{
    CEnumConnections *pecn;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ILS_E_POINTER;
    };

    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecn = new CEnumConnections;
    if (pecn == NULL)
        return ILS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecn->Init(pSinkList, cSinkNodes);

    if (FAILED(hr))
    {
        delete pecn;
        return hr;
    };

    pecn->AddRef();
    *ppEnum = pecn;
    return S_OK;
}

//****************************************************************************
// CEnumConnections::CEnumConnections(void)
//
// History:
//  Wed 17-Apr-1996 11:17:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumConnections::CEnumConnections(void)
{
    cRef = 0;
    iIndex = 0;
    cConnections = 0;
    pConnectData = NULL;
    return;
}

//****************************************************************************
// CEnumConnections::~CEnumConnections(void)
//
// History:
//  Wed 17-Apr-1996 11:17:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumConnections::~CEnumConnections(void)
{
    if (pConnectData != NULL)
    {
        UINT i;

        for (i = 0; i < cConnections; i++)
        {
            pConnectData[i].pUnk->Release();
        };
        delete [] pConnectData;
    };
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnections::Init(PSINKNODE pSinkList, ULONG cSinkNodes)
//
// History:
//  Wed 17-Apr-1996 11:17:34  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnections::Init(PSINKNODE pSinkList, ULONG cSinkNodes)
{
    HRESULT hr = S_OK;

    iIndex = 0;
    cConnections = 0;
    pConnectData = NULL;

    // Snapshot the connection list
    //
    if (cSinkNodes > 0)
    {
        UINT i;

        pConnectData = new CONNECTDATA[cSinkNodes];
        
        if (pConnectData != NULL)
        {
            for (i = 0; i < cSinkNodes && pSinkList != NULL; i++)
            {
                if (!(pSinkList->uFlags & SN_REMOVED))
                {
                    pConnectData[cConnections].pUnk = pSinkList->pUnk;
                    pConnectData[cConnections].pUnk->AddRef();
                    pConnectData[cConnections].dwCookie = pSinkList->dwCookie;
                    cConnections++;
                };
                pSinkList = pSinkList->pNext;
            };
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnections::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:17:40  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnections::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumConnections || riid == IID_IUnknown)
    {
        *ppv = (IEnumConnections *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumConnections::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:17:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumConnections::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CEnumConnections::AddRef: ref=%ld\r\n", cRef));
    ::InterlockedIncrement ((LONG *) &cRef);
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumConnections::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:17:59  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumConnections::Release (void)
{
    DllRelease();

	ASSERT (cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CEnumConnections::Release: ref=%ld\r\n", cRef));
    if (::InterlockedDecrement ((LONG *) &cRef) == 0)
    {
        delete this;
        return 0;
    }
    return cRef;
}

//****************************************************************************
// STDMETHODIMP 
// CEnumConnections::Next (ULONG cConnectionDatas, CONNECTDATA *rgpcd,
//                         ULONG *pcFetched)
//
// History:
//  Wed 17-Apr-1996 11:18:07  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP 
CEnumConnections::Next (ULONG cConnectDatas, CONNECTDATA *rgpcd,
                        ULONG *pcFetched)
{
    CONNECTDATA  *pConnect;
    ULONG        cCopied;

    // Validate the pointer
    //
    if (rgpcd == NULL)
        return ILS_E_POINTER;

    // Validate the parameters
    //
    if ((cConnectDatas == 0) ||
        ((cConnectDatas > 1) && (pcFetched == NULL)))
        return ILS_E_PARAMETER;

    // Check the enumeration index
    //
    pConnect = &pConnectData[iIndex];
    for (cCopied = 0; iIndex < cConnections && cCopied < cConnectDatas; cCopied++)
    {
        rgpcd[cCopied] = *pConnect;
        rgpcd[cCopied].pUnk->AddRef();
        iIndex++;
        pConnect++;
    };        

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cConnectDatas == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnections::Skip (ULONG cConnectDatas)
//
// History:
//  Wed 17-Apr-1996 11:18:15  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnections::Skip (ULONG cConnectDatas)
{
    // Validate the parameters
    //
    if (cConnectDatas == 0) 
        return ILS_E_PARAMETER;

    // Check the enumeration index limit
    //
    if ((iIndex+cConnectDatas) >= cConnections)
    {
        iIndex = cConnections;
        return S_FALSE;
    }
    else
    {
        // Skip as requested
        //
        iIndex += cConnectDatas;
        return S_OK;
    };
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnections::Reset (void)
//
// History:
//  Wed 17-Apr-1996 11:18:22  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnections::Reset (void)
{
    iIndex = 0;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumConnections::Clone(IEnumConnections **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:18:29  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumConnections::Clone(IEnumConnections **ppEnum)
{
    CEnumConnections *pecn;
    CONNECTDATA *pConnectDataClone;
    UINT i;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ILS_E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    pecn = new CEnumConnections;
    if (pecn == NULL)
        return ILS_E_MEMORY;

    // Clone the information
    //
    pConnectDataClone = new CONNECTDATA[cConnections];
    if (pConnectDataClone == NULL)
    {
        delete pecn;
        return ILS_E_MEMORY;
    };

    // Clone the connect data list
    //
    for (i = 0; i < cConnections; i++)
    {
        pConnectDataClone[i] = pConnectData[i];
        pConnectDataClone[i].pUnk->AddRef();
    };
    pecn->iIndex = iIndex;
    pecn->cConnections = cConnections;

    // Return the cloned enumerator
    //
    pecn->AddRef();
    *ppEnum = pecn;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\connpt.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       connpt.h
//  Content:    This file contains the connection container object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _CONNPT_H_
#define _CONNPT_H_

//****************************************************************************
// CEnumConnectionPoints definition
//****************************************************************************
//
class CEnumConnectionPoints : public IEnumConnectionPoints
{
private:
    ULONG                   cRef;
    ULONG                   iIndex;
    IConnectionPoint        *pcnp;

public:
    // Constructor and Initialization
    CEnumConnectionPoints (void);
    ~CEnumConnectionPoints (void);
    STDMETHODIMP            Init (IConnectionPoint *pcnpInit);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumConnectionPoints
    STDMETHODIMP            Next(ULONG cConnections, IConnectionPoint **rgpcn,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cConnections);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumConnectionPoints **ppEnum);
};

//****************************************************************************
// CConnectionPoint definition
//****************************************************************************
//
typedef struct tagSinkNode
{
    struct tagSinkNode      *pNext;
    IUnknown                *pUnk;
    ULONG                   uFlags;
    DWORD                   dwCookie;
}   SINKNODE, *PSINKNODE;

typedef HRESULT (*CONN_NOTIFYPROC)(IUnknown *pUnk, void *);

#define COOKIE_INIT_VALUE   1
#define SN_LOCKED           0x00000001
#define SN_REMOVED          0x00000002

class CConnectionPoint : public IConnectionPoint
{
private:
    ULONG                   cRef;
    IID                     riid;
    IConnectionPointContainer *pCPC;
    DWORD                   dwNextCookie;
    ULONG                   cSinkNodes;
    PSINKNODE               pSinkList;

public:
    // Constructor and destructor
    CConnectionPoint (const IID *pIID, IConnectionPointContainer *pCPCInit);
    ~CConnectionPoint (void);

    // Class public functions
    void                    ContainerReleased() {pCPC = NULL; return;}
    STDMETHODIMP            Notify (void *pv, CONN_NOTIFYPROC pfn);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IConnectionPoint
    STDMETHODIMP            GetConnectionInterface(IID *pIID);
    STDMETHODIMP            GetConnectionPointContainer(IConnectionPointContainer **ppCPC);
    STDMETHODIMP            Advise(IUnknown *pUnk, DWORD *pdwCookie);
    STDMETHODIMP            Unadvise(DWORD dwCookie);
    STDMETHODIMP            EnumConnections(IEnumConnections **ppEnum);
};

//****************************************************************************
// CEnumConnections definition
//****************************************************************************
//
class CEnumConnections : public IEnumConnections
{
private:
    ULONG                   cRef;
    ULONG                   iIndex;
    ULONG                   cConnections;
    CONNECTDATA             *pConnectData;

public:
    // Constructor and Initialization
    CEnumConnections (void);
    ~CEnumConnections (void);
    STDMETHODIMP            Init(PSINKNODE pSinkList, ULONG cSinkNodes);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumConnections
    STDMETHODIMP            Next(ULONG cConnections, CONNECTDATA *rgpcn,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cConnections);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumConnections **ppEnum);
};

#endif //_CONNPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\culs.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       culs.h
//  Content:    This file contains the ULS object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _CILS_H_
#define _CILS_H_

#include "connpt.h"
#include "spserver.h"

class CIlsServer;

//****************************************************************************
// CIls definition
//****************************************************************************
//

class CIlsMain : public IIlsMain,
             public IConnectionPointContainer 
{
private:

    LONG                    m_cRef;
    BOOL                    fInit;
    HWND                    hwndCallback;
    CConnectionPoint        *pConnPt;

    BOOL                    IsInitialized (void) {return fInit;}
    STDMETHODIMP            NotifySink (void *pv, CONN_NOTIFYPROC pfn);
	HRESULT					StringToFilter (TCHAR *pszFilter ,CFilter **ppFilter);

    HRESULT	EnumUsersEx (
			BOOL					fNameOnly,
			CIlsServer				*pServer,
			IIlsFilter				*pFilter,
			CAttributes				*pAttrib,
			ULONG					*puReqID );

	HRESULT EnumMeetingPlacesEx (
			BOOL					fNameOnly,
			CIlsServer				*pServer,
			IIlsFilter				*pFilter,
			CAttributes				*pAttrib,
			ULONG					*puReqID);

public:
    // Constructor and destructor
    CIlsMain (void);
    ~CIlsMain (void);
    STDMETHODIMP    Init (void);

    // Internal methods
    HWND            GetNotifyWindow(void) {return hwndCallback;}
    void            LocalAsyncRespond (ULONG msg, ULONG uReqID, LPARAM lParam)
                    {PostMessage(hwndCallback, msg, uReqID, lParam); return;}


    // Asynchronous response handler
    //
    STDMETHODIMP    GetUserResult (ULONG uReqID, PLDAP_CLIENTINFO_RES puir, CIlsServer *pIlsServer);
    STDMETHODIMP    EnumUserNamesResult (ULONG uReqID, PLDAP_ENUM ple);
    STDMETHODIMP    EnumUsersResult (ULONG uReqID, PLDAP_ENUM ple, CIlsServer *pIlsServer);
#ifdef ENABLE_MEETING_PLACE
    HRESULT    GetMeetingPlaceResult (ULONG uReqID, PLDAP_MEETINFO_RES pmir, CIlsServer *pIlsServer);
    HRESULT    EnumMeetingPlacesResult(ULONG ulReqID, PLDAP_ENUM  ple, CIlsServer *pIlsServer);
    HRESULT    EnumMeetingPlaceNamesResult( ULONG ulReqID, PLDAP_ENUM  ple);
#endif // ENABLE_MEETING_PLACE

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IIls
    STDMETHODIMP    Initialize (VOID);

    STDMETHODIMP    CreateServer ( BSTR bstrServerName, IIlsServer **ppServer );

    STDMETHODIMP    CreateUser( BSTR bstrUserID, BSTR bstrAppName, IIlsUser **ppUser);

    STDMETHODIMP    CreateAttributes ( ILS_ATTR_TYPE AttrType, IIlsAttributes **ppAttributes );

    STDMETHODIMP    EnumUserNames ( IIlsServer *pServer,
                                    IIlsFilter *pFilter,
                                    IEnumIlsNames   **ppEnumUserNames,
                                    ULONG *puReqID);

    STDMETHODIMP    GetUser (   IIlsServer *pServer,
                                BSTR bstrUserName,
                                BSTR bstrAppName,
                                BSTR bstrProtName,
                                IIlsAttributes *pAttrib,
                                IIlsUser **ppUser,
                                ULONG *puReqID);

    STDMETHODIMP    EnumUsers ( IIlsServer *pServer,
                                IIlsFilter *pFilter,
                                IIlsAttributes *pAttrib,
                                IEnumIlsUsers **ppEnumUser,
                                ULONG *puReqID);

#ifdef ENABLE_MEETING_PLACE
    STDMETHODIMP    CreateMeetingPlace( 
                                        BSTR   bstrMeetingPlaceID,
                                        LONG   lMeetingPlaceType,    // set to default
                                        LONG   lAttendeeType,    // set to default
                                        IIlsMeetingPlace **ppMeetingPlace
                                    );

    // Lightweight enumerator of MeetingPlaces for a given server
    // This returns only the names. If a caller wants more info than
    // the names he can get the name from here, and call the 
    // heavyweight enumerator (see below) with the filter specifying
    // the name.    

    STDMETHODIMP    EnumMeetingPlaceNames(
                                        IIlsServer *pServer,
                                        IIlsFilter *pFilter,
                                        IEnumIlsNames **ppEnumMeetingPlaceNames,
                                        ULONG   *pulID
                                        );

    // Slightly heavier enumerator. Returns the MeetingPlaces and
    // associated default attributes

    STDMETHODIMP    EnumMeetingPlaces(
                                        IIlsServer *pServer,
                                        IIlsFilter *pFilter,
                                        IIlsAttributes *pAttributes,
                                        IEnumIlsMeetingPlaces **ppEnumMeetingPlace,
                                        ULONG   *pulID
                                        );

    STDMETHODIMP    GetMeetingPlace( IIlsServer *pServer,
                                BSTR bstrMeetingPlaceID,
								IIlsAttributes	*pAttrib,
								IIlsMeetingPlace	**ppMtg,
                                ULONG *pulID);   
#endif // ENABLE_MEETING_PLACE

    STDMETHODIMP    Abort (ULONG uReqID);
    STDMETHODIMP    Uninitialize (void);

    // Filter methods
    STDMETHODIMP    CreateFilter ( ILS_FILTER_TYPE FilterType,
    								ILS_FILTER_OP FilterOp,
                                    IIlsFilter **ppFilter );
    STDMETHODIMP    StringToFilter (BSTR bstrFilterString, IIlsFilter **ppFilter);

    // IConnectionPointContainer
    STDMETHODIMP    EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
    STDMETHODIMP    FindConnectionPoint(REFIID riid,
                                        IConnectionPoint **ppcp);
};


class CIlsServer : public IIlsServer
{
private:

	LONG			m_cRefs;
	LONG			m_dwSignature;

	SERVER_INFO		m_ServerInfo;

public:

	CIlsServer ( VOID );
	~CIlsServer ( VOID );

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

	// IIlsServer
	STDMETHODIMP	SetAuthenticationMethod ( ILS_ENUM_AUTH_METHOD enumAuthMethod );
	STDMETHODIMP	SetLogonName ( BSTR bstrLogonName );
	STDMETHODIMP	SetLogonPassword ( BSTR bstrLogonPassword );
	STDMETHODIMP	SetDomain ( BSTR bstrDomain );
	STDMETHODIMP	SetCredential ( BSTR bstrCredential );
    STDMETHODIMP    SetTimeout ( ULONG uTimeoutInSecond );
	STDMETHODIMP	SetBaseDN ( BSTR bstrBaseDN );

	CIlsServer *Clone ( VOID );

	HRESULT SetServerName ( TCHAR *pszServerName );
	HRESULT SetServerName ( BSTR bstrServerName );
	TCHAR *DuplicateServerName ( VOID );
	BSTR DuplicateServerNameBSTR ( VOID );

	SERVER_INFO *GetServerInfo ( VOID ) { return &m_ServerInfo; }
	TCHAR *GetServerName ( VOID ) { return m_ServerInfo.pszServerName; }

	BOOL IsGoodServerName ( VOID ) { return ::MyIsGoodString (m_ServerInfo.pszServerName); }
	BOOL IsBadServerName ( VOID ) { return ::MyIsBadString (m_ServerInfo.pszServerName); }

	enum { ILS_SERVER_SIGNATURE = 0x12abcdef };
	BOOL IsGoodIlsServer ( VOID ) { return (m_dwSignature == ILS_SERVER_SIGNATURE); }
	BOOL IsBadIlsServer ( VOID ) { return (m_dwSignature != ILS_SERVER_SIGNATURE); }
};


inline BOOL MyIsBadServer ( CIlsServer *p )
{
	return (p == NULL || p->IsBadIlsServer () || p->IsBadServerName ());
}

inline BOOL MyIsBadServer ( IIlsServer *p )
{
	return MyIsBadServer ((CIlsServer *) p);
}

//****************************************************************************
// Global Parameters
//****************************************************************************
//
LRESULT CALLBACK ULSNotifyProc(HWND hwnd, UINT message, WPARAM wParam,
                            LPARAM lParam);

#endif //_CONFMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\cserver.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       cserver.cpp
//  Content:    This file contains the ULS server object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "culs.h"
#include "localusr.h"
#include "attribs.h"
#include "localprt.h"
#include "callback.h"



//****************************************************************************
// ILS_STATE
// CIlsUser::GetULSState(VOID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

ILS_STATE CIlsUser::
GetULSState ( VOID )
{
    ILS_STATE uULSState;

    switch(m_uState)
    {
        case ULSSVR_INVALID:
        case ULSSVR_INIT:
            uULSState = ILS_UNREGISTERED;
            break;

        case ULSSVR_REG_USER:
        case ULSSVR_REG_PROT:
            uULSState = ILS_REGISTERING;
            break;

        case ULSSVR_CONNECT:
            uULSState = ILS_REGISTERED;
            break;

        case ULSSVR_UNREG_PROT:
        case ULSSVR_UNREG_USER:
            uULSState = ILS_UNREGISTERING;
            break;

        case ULSSVR_RELOGON:
            uULSState = ILS_REGISTERED_BUT_INVALID;
            break;

        case ULSSVR_NETWORK_DOWN:
            uULSState = ILS_NETWORK_DOWN;
            break;

        default:
            ASSERT(0);
            uULSState = ILS_UNREGISTERED;
            break;
    };

    return uULSState;
}

//****************************************************************************
// void
// CIlsUser::NotifyULSRegister(HRESULT hr)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void
CIlsUser::NotifyULSRegister(HRESULT hr)
{
    g_pCIls->LocalAsyncRespond(WM_ILS_LOCAL_REGISTER, m_uReqID, hr);
    m_uReqID = 0;
    return;
}

//****************************************************************************
// void
// CIlsUser::NotifyULSUnregister(HRESULT hr)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void
CIlsUser::NotifyULSUnregister(HRESULT hr)
{
    g_pCIls->LocalAsyncRespond(WM_ILS_LOCAL_UNREGISTER, m_uReqID, hr);
    m_uReqID = 0;
    return;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::AddPendingRequest(ULONG uReqType, ULONG uMsgID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsUser::
AddPendingRequest(ULONG uReqType, ULONG uMsgID)
{
    // Add the request to the queue
    //
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    ri.uReqType = uReqType;
    ri.uMsgID = uMsgID;

    ReqInfo_SetUser (&ri, this);

    HRESULT hr = g_pReqMgr->NewRequest(&ri);
    if (SUCCEEDED(hr))
    {
        // Make sure the objects do not disappear before we get the response
        //
        this->AddRef();

        // Remember the last request
        //
        m_uLastMsgID = uMsgID;
    }

    return hr;
}


//****************************************************************************
// STDMETHODIMP
// CIlsUser::Register (CIlsUser *pUser, CLocalApp  *pApp, ULONG uReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsUser::
InternalRegister ( ULONG uReqID )
{
    LDAP_ASYNCINFO lai;
    PLDAP_CLIENTINFO pui;
    HANDLE hUser;
    HRESULT hr;

    ASSERT(uReqID != 0);

    // Validate the proper state
    //
    if (m_uState != ULSSVR_INIT)
        return ILS_E_FAIL;

    // Get the protocol enumerator
    //
    hr = EnumLocalProtocols(&m_pep);
    if (SUCCEEDED(hr))
    {
        // Remember the request ID
        //
        m_uReqID = uReqID;

        // Start the registration state machine
        //
        hr = InternalRegisterNext (NOERROR);
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::InternalRegisterNext (HRESULT hr)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsUser::
InternalRegisterNext (HRESULT hr)
{
// lonchanc:
// I need to change Viroon's logic here.
// We should simply send out a bunch of requests and
// wait for all of them to come back, rather than
// doing a state machine stuff!!!
    LDAP_ASYNCINFO lai;
    ULONG uReqType;

    // Clean up last request
    //
    m_uLastMsgID = 0;

    if (SUCCEEDED(hr))
    {
        switch (m_uState)
        {
            case ULSSVR_INIT:
            {
                PLDAP_CLIENTINFO pui;
                HANDLE hUser;

                // Snap-shot the user information now
                //
                hr = InternalGetUserInfo (TRUE, &pui, LU_MOD_ALL);

                if (SUCCEEDED(hr))
                {
                    // Register the user with the server
                    //
                    hr = ::UlsLdap_RegisterClient ( (DWORD_PTR) this,
								                    m_pIlsServer->GetServerInfo (),
								                    pui,
								                    &hUser,
								                    &lai);
                    if (SUCCEEDED(hr))
                    {
                        // We are registering the user
                        //
                        m_hLdapUser = hUser;
                        m_uState = ULSSVR_REG_USER;
                        uReqType = WM_ILS_REGISTER_CLIENT;
                    };
                    ::MemFree (pui);
                };
                break;
            }

            case ULSSVR_REG_USER:

                m_uState = ULSSVR_REG_PROT;
                //
                // Fall through to start registering the protocol
                //
            case ULSSVR_REG_PROT:
            {
                IIlsProtocol *plp;

                // Get the next protocol from the application
                //
                ASSERT (m_pep != NULL);
                hr = m_pep->Next(1, &plp, NULL);

                switch (hr)
                {
                    case NOERROR:
                    {
                    	ASSERT (plp != NULL);
                        hr = RegisterLocalProtocol(FALSE, (CLocalProt *)plp, &lai);
                    	plp->Release (); // AddRef by m_pep->Next()
                        uReqType = WM_ILS_REGISTER_PROTOCOL;
                        break;
                    }
                    case S_FALSE:
                    {
                        // The last protocol is done. Cleanup enumerator
                        //
                        m_pep->Release();
                        m_pep = NULL;

                        // Change to connect state and notify the ULS object
                        // We are done. Get out of here.
                        //
                        hr = NOERROR;
                        m_uState = ULSSVR_CONNECT;
                        NotifyULSRegister(NOERROR);
                        return NOERROR;
                    }
                    default:
                    {
                        // Fail the enumeration, bail out
                        //
                        break;
                    }
                };
                break;
            }
            default:
                ASSERT(0);
                break;
        };
    };

    if (SUCCEEDED(hr))
    {
        // Add a pending request to handle the response
        //
        hr = AddPendingRequest(uReqType, lai.uMsgID);
    };

    if (FAILED(hr))
    {
        // Oops ! the server failed us. Clean up the registration
        //
        InternalCleanupRegistration (TRUE);

        // Notify the ULS object for the failure
        //
        NotifyULSRegister(hr);
    };
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::CleanupRegistration (void)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
CIlsUser::InternalCleanupRegistration ( BOOL fKeepProtList )
{
    LDAP_ASYNCINFO lai;

    // Note: This is a fast cleanup. The idea is to unregister everything being
    // registered so far without waiting for the unregister result.
    //

    // Unregister each registered protocol
    //
    CLocalProt *plp = NULL;
    HANDLE hEnum = NULL;
    m_ProtList.Enumerate(&hEnum);
    if (fKeepProtList)
    {
	    while (m_ProtList.Next (&hEnum, (VOID **) &plp) == NOERROR)
	    {
	    	ASSERT (plp != NULL);
	        ::UlsLdap_VirtualUnRegisterProtocol(plp->GetProviderHandle());
	    	plp->SetProviderHandle (NULL);
	    }
    }
    else
    {
	    while(m_ProtList.Next (&hEnum, (VOID **) &plp) == NOERROR)
	    {
	    	ASSERT (plp != NULL);
	        ::UlsLdap_UnRegisterProtocol (plp->GetProviderHandle (), &lai);
	        plp->Release();
	    }
	    m_ProtList.Flush ();
	}

    //
    // Unregister user
    //
    if (m_hLdapUser != NULL)
    {
        ::UlsLdap_UnRegisterClient (m_hLdapUser, &lai);
        m_hLdapUser = NULL;
    };

    // Release all the resource
    //
    if (m_pep != NULL)
    {
        m_pep->Release();
        m_pep = NULL;
    };

    // Unwind the object to the initialize state
    //
    m_uState = ULSSVR_INIT;
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::Unregister (ULONG uReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
CIlsUser::InternalUnregister (ULONG uReqID)
{
    HRESULT hr;

    ASSERT(uReqID != 0);

    // Remove the last request, if any
    //
    if (m_uLastMsgID != 0)
    {
	    COM_REQ_INFO ri;
	    ReqInfo_Init (&ri);

        // Look for the matching request information
        //
        ri.uReqID = 0;
        ri.uMsgID = m_uLastMsgID;

        g_pReqMgr->RequestDone(&ri);
    };

    // If this is to cancel the current registration, we need to cancel the
    // registration then start unregistration.
    //
    if (m_uReqID != 0)
    {
        NotifyULSRegister(ILS_E_ABORT);
    };

    // Determine the starting state
    //
    hr = NOERROR;
    switch (m_uState)
    {
    	case ULSSVR_RELOGON:
    	case ULSSVR_NETWORK_DOWN:

        case ULSSVR_CONNECT:
        case ULSSVR_REG_PROT:
            //
            // In the middle of registering a protocol or an app
            // Unregistering the protocol then the app
            //
            m_uState = ULSSVR_UNREG_PROT;
            break;

        case ULSSVR_REG_USER:
            //
            // In the middle of registering the user
            // Unregistering the user
            //
            m_uState = ULSSVR_UNREG_USER;
            break;

        default:
            hr = ILS_E_FAIL;
            break;
    }

    // The initial request succeeds, remember the request ID
    //
    if (SUCCEEDED(hr))
    {
        // lonchanc: [11/15/96]
        // To fix the "OnLocalRegisterResult: No pending request for 0" problem,
        // we have to put uReqID because UnregisterNext() will use uReqID when
        // it fails to unregister app/user.
        //
        m_uReqID = uReqID;
        hr = InternalUnregisterNext(hr);

#if 0	// lonchanc: [11/15/96]
		// See the comment above.
        if (SUCCEEDED(hr))
        {
            m_uReqID = uReqID;
        };
#endif
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::InternalUnregisterNext (HRESULT hr)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
CIlsUser::InternalUnregisterNext (HRESULT hr)
{
    LDAP_ASYNCINFO lai;
    ULONG uReqType;

    // Clean up last request
    //
    m_uLastMsgID = 0;

    do
    {
        switch (m_uState)
        {
            case ULSSVR_UNREG_PROT:
            {
                // Is there another protocol?
                //
                CLocalProt *plp = NULL;
                HANDLE hEnum = NULL;
                m_ProtList.Enumerate(&hEnum);
                while (m_ProtList.Next(&hEnum, (VOID **)&plp) == S_OK)
                {
                	// Do not need to unregister protocols because
                	// UnregisterUser will delete the entire entry.
                	//
        	        ::UlsLdap_VirtualUnRegisterProtocol (plp->GetProviderHandle());

                    // Another protocol to clean up
                    //
                    plp->SetProviderHandle (NULL);

                    // Do not need to plp->Release() (cf. AddRef by RegisterLocalProtocol)
                    // because the user object still contain all the protocol objects
                    //
                }

                // Unregister the user
                //
                m_uState = ULSSVR_UNREG_USER;
                hr = ::UlsLdap_UnRegisterClient (m_hLdapUser, &lai);
                uReqType = WM_ILS_UNREGISTER_CLIENT;
                m_hLdapUser = NULL;
                break;
            }

            case ULSSVR_UNREG_USER:
                //
                // Put the object back into the init state
                //
                InternalCleanupRegistration(TRUE);
                NotifyULSUnregister(NOERROR);
                return NOERROR;

            default:
                ASSERT(0);
                return NOERROR;
        };
    }
    while (FAILED(hr));    // Unregistration failed, nohing to wait for

    if (SUCCEEDED(hr))
    {
        AddPendingRequest(uReqType, lai.uMsgID);
    };
    return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\debug.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       debug.cpp
//  Content:    This file contains miscellaneous debug routines.
//  History:
//      Thu 08-Apr-1993 09:43:46  -by-  Viroon  Touranachun [viroont]
//
//****************************************************************************

#include "ulsp.h"
#include "debug.h"

#ifdef  DEBUG

UINT DbgUlsTrace(LPCTSTR pszFormat, ...)
{
	if (F_ZONE_ENABLED(ghZoneUls, DM_TRACE))
	{
		va_list v1;
		va_start(v1, pszFormat);

		DbgPrintf(TEXT("ULS:Trace"), (PSTR) pszFormat, v1);

		va_end(v1);
	}
	return 0;
}


VOID DbgMsgUls(ULONG iZone, CHAR *pszFormat, ...)
{
	if (F_ZONE_ENABLED(ghZoneUls, iZone))
	{
		PCSTR pszPrefix;
		switch (iZone)
			{
		case DM_ERROR:    pszPrefix = "ILS:Error";    break;
		case DM_WARNING:  pszPrefix = "ILS:Warning";  break;
		case DM_TRACE:    pszPrefix = "ILS:Trace";    break;
		case DM_REFCOUNT: pszPrefix = "ILS:RefCount"; break;
		case ZONE_KA:     pszPrefix = "ILS:KA";       break;
		case ZONE_FILTER: pszPrefix = "ILS:Filter";   break;
		case ZONE_REQ:    pszPrefix = "ILS:Request";  break;
		case ZONE_RESP:   pszPrefix = "ILS:Response"; break;
		case ZONE_CONN:   pszPrefix = "ILS:Connection"; break;
		default:          pszPrefix = "ILS:???";      break;
			}
		
		va_list args;
		va_start(args, pszFormat);
		DbgPrintf(pszPrefix, pszFormat, args);
		va_end(args);
	}
}

#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\culs.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       culs.cpp
//  Content:    This file contains the ULS object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "culs.h"
#include "localusr.h"
#include "attribs.h"
#include "localprt.h"
#include "callback.h"
#include "filter.h"
#include "sputils.h"
#include "ulsmeet.h"

//****************************************************************************
// Constant and static text definition
//****************************************************************************
//
#define ILS_WND_CLASS       TEXT("UserLocationServicesClass")
#define ILS_WND_NAME        TEXT("ULSWnd")
#define ILS_DATABASE_MUTEX  TEXT("User Location Service Database")

//****************************************************************************
// Global Parameters
//****************************************************************************
//
CIlsMain  *g_pCIls   = NULL;
CReqMgr   *g_pReqMgr = NULL;
HWND      g_hwndCulsWindow = NULL;

//****************************************************************************
// Event Notifiers
//****************************************************************************
//
//****************************************************************************
// HRESULT
// OnNotifyEnumUserNamesResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyEnumUserNamesResult (IUnknown *pUnk, void *pv)
{
    CEnumNames  *penum   = NULL;
    PENUMRINFO  peri    = (PENUMRINFO)pv;
    HRESULT     hr      = peri->hResult;

    // Create the enumerator only when there is anything to be enumerated
    //
    if (hr == NOERROR)
    {
        ASSERT (peri->pv != NULL);

        // Create a UserName enumerator
        //
        penum = new CEnumNames;

        if (penum != NULL)
        {
            hr = penum->Init((LPTSTR)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IIlsNotify*)pUnk)->EnumUserNamesResult(peri->uReqID,
                                             penum != NULL ? 
                                             (IEnumIlsNames *)penum :
                                             NULL,
                                             hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}

//****************************************************************************
// HRESULT
// OnNotifyGetUserResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyGetUserResult (IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsNotify*)pUnk)->GetUserResult(pobjri->uReqID,
                                       (IIlsUser *)pobjri->pv,
                                       pobjri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyGetUserResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
HRESULT
OnNotifyGetMeetingPlaceResult (IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsNotify*)pUnk)->GetMeetingPlaceResult(pobjri->uReqID,
                                       (IIlsMeetingPlace *)pobjri->pv,
                                       pobjri->hResult);
    return S_OK;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// HRESULT
// OnNotifyEnumUsersResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyEnumUsersResult (IUnknown *pUnk, void *pv)
{
    CEnumUsers *penum   = NULL;
    PENUMRINFO peri     = (PENUMRINFO)pv;
    HRESULT    hr       = peri->hResult;

    if (hr == NOERROR)
    {
        ASSERT (peri->pv != NULL);

        // Create a UserName enumerator
        //
        penum = new CEnumUsers;

        if (penum != NULL)
        {
            hr = penum->Init((CIlsUser **)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IIlsNotify*)pUnk)->EnumUsersResult(peri->uReqID,
                                         penum != NULL ? 
                                         (IEnumIlsUsers *)penum :
                                         NULL,
                                         hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}

//****************************************************************************
// HRESULT
// OnNotifyEnumMeetingPlacesResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
HRESULT
OnNotifyEnumMeetingPlacesResult (IUnknown *pUnk, void *pv)
{
    CEnumMeetingPlaces *penum   = NULL;
    PENUMRINFO peri     = (PENUMRINFO)pv;
    HRESULT    hr       = peri->hResult;

    if (hr == NOERROR)
    {
        ASSERT (peri->pv != NULL);

        // Create a MeetingPlace enumerator
        //
        penum = new CEnumMeetingPlaces;

        if (penum != NULL)
        {
            // jam it with the data that we got
            hr = penum->Init((CIlsMeetingPlace **)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IIlsNotify*)pUnk)->EnumMeetingPlacesResult(peri->uReqID,
                                         penum != NULL ? 
                                         (IEnumIlsMeetingPlaces *)penum :
                                         NULL,
                                         hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// HRESULT
// OnNotifyEnumMeetingPlaceNamesResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
HRESULT
OnNotifyEnumMeetingPlaceNamesResult (IUnknown *pUnk, void *pv)
{
    CEnumNames  *penum   = NULL;
    PENUMRINFO  peri    = (PENUMRINFO)pv;
    HRESULT     hr      = peri->hResult;

    // Create the enumerator only when there is anything to be enumerated
    //
    if (hr == NOERROR)
    {
        ASSERT (peri->pv != NULL);

        // Create a MeetingPlaceName enumerator
        //
        penum = new CEnumNames;

        if (penum != NULL)
        {
            hr = penum->Init((LPTSTR)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IIlsNotify*)pUnk)->EnumMeetingPlaceNamesResult(peri->uReqID,
                                             penum != NULL ? 
                                             (IEnumIlsNames *)penum :
                                             NULL,
                                             hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// Class Implementation
//****************************************************************************
//
//****************************************************************************
// CIlsMain::CIls (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CIlsMain::
CIlsMain ( VOID )
:m_cRef (0),
 fInit (FALSE),
 hwndCallback (NULL),
 pConnPt (NULL)
{
    ::EnterCriticalSection (&g_ULSSem);
    g_pCIls = this;
    ::LeaveCriticalSection (&g_ULSSem);
}

//****************************************************************************
// CIlsMain::~CIls (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CIlsMain::
~CIlsMain ( VOID )
{
	ASSERT (m_cRef == 0);

    // Free up resources
    //
    Uninitialize();

    // Release the connection point
    //
    if (pConnPt != NULL)
    {
        pConnPt->ContainerReleased();
        ((IConnectionPoint*)pConnPt)->Release();
    };

    // We are gone now
    //
    ::EnterCriticalSection (&g_ULSSem);
    g_pCIls = NULL;
    ::LeaveCriticalSection (&g_ULSSem);

    return;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::Init (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::Init (void)
{
    HRESULT hr;

    // Make the connection point
    //
    pConnPt = new CConnectionPoint (&IID_IIlsNotify,
                                    (IConnectionPointContainer *)this);
    if (pConnPt != NULL)
    {
        ((IConnectionPoint*)pConnPt)->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = ILS_E_MEMORY;
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IIlsMain || riid == IID_IUnknown)
    {
        *ppv = (IIlsMain *) this;
    }
    else
    {
        if (riid == IID_IConnectionPointContainer)
        {
            *ppv = (IConnectionPointContainer *) this;
        };
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CIlsMain::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CIlsMain::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CIlsMain::AddRef: ref=%ld\r\n", m_cRef));
    ::InterlockedIncrement (&m_cRef);
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CIlsMain::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CIlsMain::Release (void)
{
    DllRelease();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CIlsMain::Release: ref=%ld\r\n", m_cRef));
	if (::InterlockedDecrement (&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::Initialize (BSTR bstrAppName, REFGUID rguid, BSTR bstrMimeType)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::Initialize ()
{
    WNDCLASS wc;
    HRESULT hr;

    if (IsInitialized())
    {
        return ILS_E_FAIL;
    };

    // Activate the services
    //
    hr = ILS_E_FAIL;
    fInit = TRUE;


    // Fill in window class structure with parameters that describe the
    // working window.
    //
    wc.style            = CS_NOCLOSE;
    wc.lpfnWndProc      = ULSNotifyProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_hInstance;
    wc.hIcon            = ::LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)COLOR_WINDOW;
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = ILS_WND_CLASS;

    if (::RegisterClass(&wc) != 0)
    {
        hwndCallback = ::CreateWindowEx(0L, ILS_WND_CLASS,
                                        ILS_WND_NAME,
                                        WS_OVERLAPPED, 
                                        0, 0, 100, 50,
                                        NULL, NULL, g_hInstance, NULL);
        if (hwndCallback != NULL)
        {
            // Initialize the request manager
            //
            g_pReqMgr = new CReqMgr;

            if (g_pReqMgr != NULL)
            {
                // Initialize the LDAP layer
                //
                hr = ::UlsLdap_Initialize(hwndCallback);

            }
            else
            {
                hr = ILS_E_MEMORY;
            };
        };
    };

    if (FAILED(hr))
    {
        Uninitialize();
    }
    else {

        g_hwndCulsWindow = hwndCallback;

    }

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::CreateUser
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsMain::
CreateUser (
    BSTR    	bstrUserID,
    BSTR    	bstrAppName,
    IIlsUser 	**ppUser)
{
    CIlsUser *plu;
    HRESULT     hr;

	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

    // Validate parameter
    //
    if (ppUser == NULL)
    {
        return ILS_E_POINTER;
    };

    // Assume failure
    //
    *ppUser = NULL;

    //
    // Allocate a new user object
    //
    plu = new CIlsUser;

    if (plu != NULL)
    {
        // Initialize the object
        //
        hr = plu->Init(bstrUserID, bstrAppName);

        if (SUCCEEDED(hr))
        {
            *ppUser = (IIlsUser *)plu;
            (*ppUser)->AddRef();
        }
        else
        {
            delete plu;
        };
    }
    else
    {
        hr = ILS_E_MEMORY;
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::Uninitialize (void)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::Uninitialize (void)
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

    // Uninitialize the LDAP layer
    //
    ::UlsLdap_Deinitialize();

    // Remove the request manager
    //
    if (g_pReqMgr != NULL)
    {
        delete g_pReqMgr;
        g_pReqMgr = NULL;
    };

    // Clear the callback window
    //
    if (hwndCallback != NULL)
    {
        ::DestroyWindow(hwndCallback);
        hwndCallback = NULL;
    };
    ::UnregisterClass(ILS_WND_CLASS, g_hInstance);

    // Flag that is is uninitialized
    //
    fInit = FALSE;

    return S_OK;
};

//****************************************************************************
// STDMETHODIMP
// CIlsMain::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
{
    HRESULT hr = S_OK;

    if (pConnPt != NULL)
    {
        hr = pConnPt->Notify(pv, pfn);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::CreateAttributes (ILS_ACCESS_CONTROL AccessControl, IIlsAttributes **ppAttributes)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//  12/05/96 -by- Chu, Lon-Chan [lonchanc]
// Added access control.
//****************************************************************************

STDMETHODIMP CIlsMain::
CreateAttributes ( ILS_ATTR_TYPE AttrType, IIlsAttributes **ppAttributes )
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

    CAttributes *pa;
    HRESULT hr;

    // Validate parameter
    //
    if (ppAttributes == NULL)
    {
        return ILS_E_POINTER;
    };

	// Validate access control
	//
	if (AttrType != ILS_ATTRTYPE_NAME_ONLY &&
		AttrType != ILS_ATTRTYPE_NAME_VALUE)
		return ILS_E_PARAMETER;

    // Assume failure
    //
    *ppAttributes = NULL;

    // Allocate an attributes object
    //
    pa = new CAttributes;
    if (pa != NULL)
    {
    	pa->SetAccessType (AttrType);
        pa->AddRef();
        *ppAttributes = pa;
        hr = NOERROR;
    }
    else
    {
        hr = ILS_E_MEMORY;
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::GetUser (BSTR bstrServerName, BSTR bstrUserID,
//                ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsMain::
GetUser (
	IIlsServer		*pIlsServer,
	BSTR			bstrUserID,
	BSTR			bstrAppID,
	BSTR			bstrProtID,
	IIlsAttributes	*pAttrib,
	IIlsUser		**ppUser,
	ULONG			*puReqID )
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

    LDAP_ASYNCINFO ldai; 
    HRESULT hr;

	// We do not implement synchronous operation
	//
	if (ppUser != NULL)
		return ILS_E_NOT_IMPL;

    // Validate parameters
    //
	if (::MyIsBadServer (pIlsServer) || bstrUserID == NULL || puReqID == NULL)
        return ILS_E_POINTER;

	// Clone the server object
	//
	pIlsServer = ((CIlsServer *) pIlsServer)->Clone ();
	if (pIlsServer == NULL)
		return ILS_E_MEMORY;

	// Get a list of extended attribute names
	//
    TCHAR *pszList = NULL;
    ULONG cList =0, cbList = 0;
    if (pAttrib != NULL)
    {
        hr = ((CAttributes *) pAttrib)->GetAttributeList (&pszList, &cList, &cbList);
        if (FAILED (hr))
        {
        	pIlsServer->Release ();
        	return hr;
        }
    }

	// Initialize locals
	//
    TCHAR *pszUserID = NULL, *pszAppID = NULL, *pszProtID = NULL;

    // Get from the specified server
    //
    hr = BSTR_to_LPTSTR(&pszUserID, bstrUserID);
    if (FAILED (hr))
		goto MyExit;

	// Get the app id if given
	//
	if (bstrAppID != NULL)
	{
        hr = BSTR_to_LPTSTR (&pszAppID, bstrAppID);
        if (FAILED (hr))
			goto MyExit;
	}

	// Get the protocol id if given
	//
	if (bstrProtID != NULL)
	{
        hr = BSTR_to_LPTSTR (&pszProtID, bstrProtID);
        if (FAILED (hr))
			goto MyExit;
	}

    hr = ::UlsLdap_ResolveClient (((CIlsServer *) pIlsServer)->GetServerInfo (),
            						pszUserID,
            						pszAppID,
            						pszProtID,
            						pszList,
            						cList,
            						&ldai);

    if (SUCCEEDED(hr))
    {
	    COM_REQ_INFO ri;
	    ReqInfo_Init (&ri);

        // If updating server was successfully requested, wait for the response
        //
        ri.uReqType = WM_ILS_RESOLVE_CLIENT;
        ri.uMsgID = ldai.uMsgID;

        ReqInfo_SetMain (&ri, this);

		ReqInfo_SetServer (&ri, pIlsServer);
		pIlsServer->AddRef ();

        hr = g_pReqMgr->NewRequest(&ri);
        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;
        }
    };

MyExit:

	// Release the server object
	//
   	pIlsServer->Release ();

	// Free the list of extended attribute names
	//
	::MemFree (pszList);

	// Free the names
	::MemFree (pszUserID);
	::MemFree (pszAppID);
	::MemFree (pszProtID);

	return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::GetUserResult (ULONG uReqID, PLDAP_CLIENTINFO_RES puir,
//                      LPTSTR szServer)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::GetUserResult (ULONG uReqID, PLDAP_CLIENTINFO_RES puir,
                     CIlsServer *pIlsServer)
{
    CIlsUser *pu;
    OBJRINFO objri;

    // Default to the server's result
    //
    objri.hResult = (puir != NULL) ? puir->hResult : ILS_E_MEMORY;

    if (SUCCEEDED(objri.hResult))
    {
    	ASSERT (! MyIsBadServer (pIlsServer));

        // The server returns CLIENTINFO, create a User object
        //
        pu = new CIlsUser;

        if (pu != NULL)
        {
            objri.hResult = pu->Init(pIlsServer, &puir->lci);
            if (SUCCEEDED(objri.hResult))
            {
                pu->AddRef();
            }
            else
            {
                delete pu;
                pu = NULL;
            };
        }
        else
        {
            objri.hResult = ILS_E_MEMORY;
        };
    }
    else
    {
        pu = NULL;
    };
    // Package the notification info
    //
    objri.uReqID = uReqID;
    objri.pv = (void *)(pu == NULL ? NULL : (IIlsUser *)pu);
    NotifySink((void *)&objri, OnNotifyGetUserResult);

    if (pu != NULL)
    {
        pu->Release();
    };
    return NOERROR;
}


//****************************************************************************
// STDMETHODIMP
// CIlsMain::EnumUserNames (BSTR bstrServerName, IIlsFilter *pFilter,
//                      ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsMain::
EnumUsersEx (
	BOOL		    fNameOnly,
	CIlsServer		*pIlsServer,
	IIlsFilter	    *pFilter,
    CAttributes		*pAttrib,
	ULONG		    *puReqID )
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr;

    // Validate parameter
    //
    if (::MyIsBadServer (pIlsServer) || puReqID == NULL)
        return ILS_E_POINTER;

	// Clone the server object
	//
	pIlsServer = ((CIlsServer *) pIlsServer)->Clone ();
	if (pIlsServer == NULL)
		return ILS_E_MEMORY;

	// Get a list of extended attribute names
	//
    TCHAR *pszList = NULL;
    ULONG cList =0, cbList = 0;
    if (pAttrib != NULL)
    {
        ASSERT (!fNameOnly);

        hr = pAttrib->GetAttributeList(&pszList, &cList, &cbList);
        if (FAILED(hr))
        {
        	pIlsServer->Release ();
        	return hr;
        }
    }

	// Construct default filter if needed
	//
	TCHAR *pszFilter = NULL;
	BOOL fDefaultRenderer = FALSE;
    if (pFilter == NULL)
    {
    	// Build default filter string
    	//
		TCHAR szLocalFilter[32];
    	wsprintf (&szLocalFilter[0], TEXT ("($%u=*)"), (UINT) ILS_STDATTR_USER_ID);

		// Render this filter
		//
		hr = StringToFilter (&szLocalFilter[0], (CFilter **) &pFilter);
		if (! SUCCEEDED (hr))
			goto MyExit;

		// Indicate we have default filter string
		//
		fDefaultRenderer = TRUE;
	}

	// Create a ldap-like filter
	//
	hr = ::FilterToLdapString ((CFilter *) pFilter, &pszFilter);
	if (hr != S_OK)
		goto MyExit;

	// Enumerate users
	//
    hr = fNameOnly ?	::UlsLdap_EnumClients (pIlsServer->GetServerInfo (),
    											pszFilter,
    											&ldai) :
						::UlsLdap_EnumClientInfos (pIlsServer->GetServerInfo (),
													pszList,
													cList,
													pszFilter,
													&ldai);
	if (hr != S_OK)
		goto MyExit;

	// If updating server was successfully requested, wait for the response
	//
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

	ri.uReqType = fNameOnly ? WM_ILS_ENUM_CLIENTS : WM_ILS_ENUM_CLIENTINFOS;
	ri.uMsgID   = ldai.uMsgID;

	ReqInfo_SetMain (&ri, this);

    if (! fNameOnly)
    {
    	ReqInfo_SetServer (&ri, pIlsServer);
		pIlsServer->AddRef ();
	}

	// Remember this request
	//
	hr = g_pReqMgr->NewRequest (&ri);

	if (hr == S_OK)
	{
	    // Make sure the objects do not disappear before we get the response
	    //
		this->AddRef ();

	    // Return the request ID
	    //
	    *puReqID = ri.uReqID;
	}

MyExit:

	// Release server object
	//
	pIlsServer->Release ();

	// Free the filter string
	//
	::MemFree (pszFilter);

	// Release default filter if needed
	//
    if (fDefaultRenderer && pFilter != NULL)
    	pFilter->Release ();

	// Free the list of extended attribute names
	//
    ::MemFree (pszList);

    return hr;
}


STDMETHODIMP
CIlsMain::EnumUserNames (
	IIlsServer		*pIlsServer,
	IIlsFilter		*pFilter,
    IEnumIlsNames   **ppEnumUserNames,
	ULONG			*puReqID )
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

	// We do not implement synchronous operation
	//
	if (ppEnumUserNames != NULL)
		return ILS_E_NOT_IMPL;

	return EnumUsersEx (TRUE,
						(CIlsServer *) pIlsServer,
						pFilter,
						NULL,
						puReqID);
}


//****************************************************************************
// STDMETHODIMP
// CIlsMain::EnumUserNamesResult (ULONG uReqID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::EnumUserNamesResult (ULONG uReqID, PLDAP_ENUM ple)
{
    ENUMRINFO eri;

    // Package the notification info
    //
    eri.uReqID  = uReqID;

    // PLDAP_ENUM is NULL when the enumeration is terminated successfully
    //
    if (ple != NULL)
    {
        eri.hResult = ple->hResult;
        eri.cItems  = ple->cItems;
        eri.pv      = (void *)(((PBYTE)ple)+ple->uOffsetItems);
    }
    else
    {
        eri.hResult = S_FALSE;
        eri.cItems  = 0;
        eri.pv      = NULL;
    };
    NotifySink((void *)&eri, OnNotifyEnumUserNamesResult);
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::EnumUsers (BSTR bstrServerName, IIlsFilter *pFilter,
//                  ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsMain::
EnumUsers (
	IIlsServer		*pIlsServer,
	IIlsFilter		*pFilter,
	IIlsAttributes	*pAttrib,
	IEnumIlsUsers	**ppEnumUsers,
	ULONG			*puReqID)
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

	// We do not implement synchronous operation
	//
	if (ppEnumUsers != NULL)
		return ILS_E_NOT_IMPL;

	return EnumUsersEx (FALSE,
						(CIlsServer *) pIlsServer,
						pFilter,
						(CAttributes *) pAttrib,
						puReqID);
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::EnumUsersResult (ULONG uReqID, PLDAP_ENUM ple, LPTSTR szServer)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::EnumUsersResult (ULONG uReqID, PLDAP_ENUM ple, CIlsServer *pIlsServer)
{
    CIlsUser **ppu;
    ULONG   cUsers;
    ENUMRINFO eri;
    HRESULT hr;

    if (ple != NULL)
    {
        eri.hResult = ple->hResult;
        cUsers = ple->cItems;
    }
    else
    {
        eri.hResult = S_FALSE;
        cUsers = 0;
    };
    eri.uReqID = uReqID;
    eri.cItems = 0;

    if ((eri.hResult == NOERROR) && (cUsers != 0))
    {
    	ASSERT (! MyIsBadServer (pIlsServer));

        // Build an array of User objects here
        //
        ppu = (CIlsUser **) ::MemAlloc (cUsers*sizeof(CIlsUser *));

        if (ppu != NULL)
        {
            CIlsUser       *pu;
            PLDAP_CLIENTINFO pui;
            ULONG          i;

            // Build one User object at a time
            //
            pui = (PLDAP_CLIENTINFO)(((PBYTE)ple)+ple->uOffsetItems);

            for (i = 0; i < cUsers; i++)
            {
                pu = new CIlsUser;

                if (pu != NULL)
                {
                    if (SUCCEEDED(pu->Init(pIlsServer, pui)))
                    {
                        pu->AddRef();
                        ppu[eri.cItems++] = pu;
                    }
                    else
                    {
                        delete pu;
                    };
                };
                pui++;
            };
        }
        else
        {
            eri.hResult = ILS_E_MEMORY;
        };
    }
    else
    {
        ppu = NULL;
    };

    // Package the notification info
    //
    eri.pv = (void *)ppu;
    NotifySink((void *)&eri, OnNotifyEnumUsersResult);

    // Free the resources
    //
    if (ppu != NULL)
    {
        for (; eri.cItems; eri.cItems--)
        {
            ppu[eri.cItems-1]->Release();
        };
        ::MemFree (ppu);
    };
    return NOERROR;
}


//****************************************************************************
// STDMETHODIMP
// CIlsMain::CreateMeetingPlace (BSTR bstrMeetingPlaceID, LONG lConfType, LONG lMemberType,
//                              IIlsMeetingPlace  **ppMeetingPlace);    
//
//
// History:
//  
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
STDMETHODIMP
CIlsMain::CreateMeetingPlace (
    BSTR bstrMeetingPlaceID,
    LONG lConfType,
    LONG lMemberType,
    IIlsMeetingPlace  **ppMeetingPlace)
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

    CIlsMeetingPlace *pCcr = NULL;
    HRESULT hr;

    // we are just createing a place holder object which when registered
    // will be visible by other users

	if (ppMeetingPlace == NULL || bstrMeetingPlaceID == NULL)
	{
		return ILS_E_POINTER;
	}

    *ppMeetingPlace = NULL;
    pCcr = new CIlsMeetingPlace;

    if (pCcr != NULL )
    {
        // succeeded in createing the object
        hr = pCcr->Init(bstrMeetingPlaceID, lConfType, lConfType);
        if (SUCCEEDED(hr))
        {
            *ppMeetingPlace = (IIlsMeetingPlace *) pCcr;
            (*ppMeetingPlace)->AddRef ();
        }
        else
        {
            delete pCcr;
        }
    }
    else
    {
        hr = ILS_E_MEMORY;
    }
    
    return (hr);
}
#endif // ENABLE_MEETING_PLACE


//****************************************************************************
// STDMETHODIMP
// CIlsMain::GetMeetingPlace (BSTR bstrServerName, BSTR bstrMeetingPlaceID, ULONG *puReqID)
//
// History:
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
STDMETHODIMP CIlsMain::
GetMeetingPlace (
	IIlsServer			*pIlsServer,
	BSTR				bstrMeetingPlaceID,
	IIlsAttributes		*pAttrib,
	IIlsMeetingPlace	**ppMeetingPlace,
	ULONG				*puReqID)
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

    LDAP_ASYNCINFO ldai; 
    LPTSTR pszMtgID = NULL;
    HRESULT hr;

	// We do not implement synchronous operation
	//
	if (ppMeetingPlace != NULL)
		return ILS_E_NOT_IMPL;

    // Validate parameters
    //
	if (::MyIsBadServer (pIlsServer) || bstrMeetingPlaceID == NULL || puReqID == NULL)
        return ILS_E_POINTER;

	// Clone the server object
	//
	pIlsServer = ((CIlsServer *) pIlsServer)->Clone ();
	if (pIlsServer == NULL)
		return ILS_E_MEMORY;

	// Get a list of extended attribute names
	//
    TCHAR *pszList = NULL;
    ULONG cList =0, cbList = 0;
    if (pAttrib != NULL)
    {
        hr = ((CAttributes *) pAttrib)->GetAttributeList (&pszList, &cList, &cbList);
        if (FAILED (hr))
        {
        	pIlsServer->Release ();
        	return hr;
        }
    }

    // Get from the specified server
    //
    hr = BSTR_to_LPTSTR(&pszMtgID, bstrMeetingPlaceID);
    if (SUCCEEDED(hr))
    {
        // BUGBUG AppID not given
        hr = ::UlsLdap_ResolveMeeting (((CIlsServer *) pIlsServer)->GetServerInfo (),
        								pszMtgID,
        								pszList,
        								cList,
        								&ldai);

        if (SUCCEEDED(hr))
        {
		    COM_REQ_INFO ri;
		    ReqInfo_Init (&ri);

            // If updating server was successfully requested, wait for the response
            //
            ri.uReqType = WM_ILS_RESOLVE_MEETING;
            ri.uMsgID = ldai.uMsgID;

            ReqInfo_SetMain (&ri, this);

            ReqInfo_SetServer (&ri, pIlsServer);
            pIlsServer->AddRef ();

            hr = g_pReqMgr->NewRequest(&ri);
            if (SUCCEEDED(hr))
            {
                // Make sure the objects do not disappear before we get the response
                //
                this->AddRef();

                // Return the request ID
                //
                *puReqID = ri.uReqID;
            }
        };
        ::MemFree (pszMtgID);
    };

	// Release the server object
	//
	pIlsServer->Release ();

	// Free the list of extended attribute names
	//
	::MemFree (pszList);

    return hr;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// HRESULT
// CIlsMain::GetMeetingPlaceResult (ULONG uReqID, LDAP_MEETINFO_RES pmir,
//                      LPTSTR szServer)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
HRESULT CIlsMain::
GetMeetingPlaceResult (ULONG uReqID, PLDAP_MEETINFO_RES pmir, CIlsServer *pIlsServer)
{
    CIlsMeetingPlace *pm;
    OBJRINFO objri;

    // Default to the server's result
    //
    objri.hResult = (pmir != NULL) ? pmir->hResult : ILS_E_MEMORY;
    if (SUCCEEDED (objri.hResult))
    {
    	ASSERT (! MyIsBadServer (pIlsServer));

        // The server returns CLIENTINFO, create a User object
        //
        pm = new CIlsMeetingPlace;
        if (pm != NULL)
        {
            objri.hResult = pm->Init (pIlsServer, &(pmir->lmi));
            if (SUCCEEDED (objri.hResult))
            {
                pm->AddRef();
            }
            else
            {
                delete pm;
                pm = NULL;
            };
        }
        else
        {
            objri.hResult = ILS_E_MEMORY;
        };
    }
    else
    {
        pm = NULL;
    };

    // Package the notification info
    //
    objri.uReqID = uReqID;
    objri.pv = (void *) (pm == NULL ? NULL : (IIlsMeetingPlace *) pm);
    NotifySink ((void *) &objri, OnNotifyGetMeetingPlaceResult);

    if (pm != NULL)
        pm->Release();

    return NOERROR;
}
#endif // ENABLE_MEETING_PLACE


//****************************************************************************
// STDMETHODIMP
// CIlsMain::EnumMeetingPlaces (BSTR bstrServerName, IIlsFilter *pFilter,
//                   IIlsAttributes *pAttributes, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
HRESULT CIlsMain::
EnumMeetingPlacesEx (
	BOOL					fNameOnly,
	CIlsServer				*pIlsServer,
	IIlsFilter				*pFilter,
	CAttributes				*pAttrib,
	ULONG					*puReqID)
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr;

    // Validate parameter
    //
    if (::MyIsBadServer (pIlsServer) || puReqID == NULL)
        return ILS_E_POINTER;

    if (pFilter != NULL)
        return ILS_E_PARAMETER;

	// Clone the server object
	//
	pIlsServer = ((CIlsServer *) pIlsServer)->Clone ();
	if (pIlsServer == NULL)
		return ILS_E_MEMORY;

	// Get a list of extended attribute names
	//
    TCHAR *pszList = NULL;
    ULONG cList =0, cbList = 0;
    if (pAttrib != NULL)
    {
        hr = ((CAttributes *) pAttrib)->GetAttributeList (&pszList, &cList, &cbList);
        if (FAILED (hr))
        {
        	pIlsServer->Release ();
        	return hr;
        }
    }

	// Construct default filter if needed
	//
	TCHAR *pszFilter = NULL;
	BOOL fDefaultRenderer = FALSE;
    if (pFilter == NULL)
    {
    	// Build default filter string
    	//
		TCHAR szLocalFilter[256];
    	wsprintf (&szLocalFilter[0], TEXT ("($%u=*)"), (INT) ILS_STDATTR_MEETING_ID );

		// Render this filter
		//
		hr = StringToFilter (&szLocalFilter[0], (CFilter **) &pFilter);
		if (! SUCCEEDED (hr))
			goto MyExit;

		// Indicate we have default filter string
		//
		fDefaultRenderer = TRUE;
	}

	// Create a ldap-like filter
	//
	hr = ::FilterToLdapString ((CFilter *) pFilter, &pszFilter);
	if (hr != S_OK)
		goto MyExit;

	// Enum meeting places
	//
    hr = fNameOnly ?	::UlsLdap_EnumMeetings (pIlsServer->GetServerInfo (),
    											pszFilter,
    											&ldai) :
						::UlsLdap_EnumMeetingInfos (pIlsServer->GetServerInfo (),
    												pszList,
    												cList,
			    									pszFilter,
			    									&ldai);
    if (SUCCEEDED(hr))
    {
	    COM_REQ_INFO ri;
	    ReqInfo_Init (&ri);

        // If updating server was successfully requested, wait for the response
        //
        ri.uReqType = fNameOnly ? WM_ILS_ENUM_MEETINGS : WM_ILS_ENUM_MEETINGINFOS;
        ri.uMsgID = ldai.uMsgID;

		ReqInfo_SetMain (&ri, this);

        if (! fNameOnly)
        {
        	ReqInfo_SetServer (&ri, pIlsServer);
			pIlsServer->AddRef ();
		}

        hr = g_pReqMgr->NewRequest(&ri);
        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;
        };
    };

MyExit:

	// Free the server object
	//
	pIlsServer->Release ();

	// Free the list of extended attribute names
	//
	::MemFree (pszList);

	// Free the filter string
	//
	::MemFree (pszFilter);

	// Release default filter if needed
	//
    if (fDefaultRenderer && pFilter != NULL)
    	pFilter->Release ();

    return hr;
}
#endif // ENABLE_MEETING_PLACE


#ifdef ENABLE_MEETING_PLACE
STDMETHODIMP CIlsMain::
EnumMeetingPlaces (
	IIlsServer				*pServer,
	IIlsFilter				*pFilter,
	IIlsAttributes			*pAttributes,
	IEnumIlsMeetingPlaces	**ppEnum,
	ULONG					*puReqID)
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

	// We do not implement synchronous operation
	//
	if (ppEnum != NULL)
		return ILS_E_NOT_IMPL;

 	return EnumMeetingPlacesEx (FALSE,
 								(CIlsServer *) pServer,
								pFilter,
								(CAttributes *) pAttributes,
								puReqID);
}
#endif // ENABLE_MEETING_PLACE


//****************************************************************************
// HRESULT
// CIlsMain::EnumMeetingPlacesResult (ULONG uReqID, PLDAP_ENUM ple, LPTSTR szServer)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
HRESULT
CIlsMain::EnumMeetingPlacesResult (ULONG uReqID, PLDAP_ENUM ple, CIlsServer *pIlsServer)
{
    CIlsMeetingPlace **ppm;
    ULONG   cMeetingPlaces;
    ENUMRINFO eri;
    HRESULT hr;

    if (ple != NULL)
    {
        eri.hResult = ple->hResult;
        cMeetingPlaces = ple->cItems;
    }
    else
    {
        eri.hResult = S_FALSE;
        cMeetingPlaces = 0;
    };
    eri.uReqID = uReqID;
    eri.cItems = 0;

    if ((eri.hResult == NOERROR) && (cMeetingPlaces != 0))
    {
		ASSERT (! MyIsBadServer (pIlsServer));

        // Build an array of MeetingPlace objects here
        //
        ppm = (CIlsMeetingPlace **) ::MemAlloc (cMeetingPlaces*sizeof(CIlsMeetingPlace *));

        if (ppm != NULL)
        {
            CIlsMeetingPlace       *pm;
            PLDAP_MEETINFO pmi;
            ULONG          i;

            
            // Build one MeetingPlace object at a time
            //
            pmi = (PLDAP_MEETINFO)(((PBYTE)ple)+ple->uOffsetItems);

            for (i = 0; i < cMeetingPlaces; i++)
            {
                pm = new CIlsMeetingPlace;

                if (pm != NULL)
                {
                    if (SUCCEEDED(pm->Init(pIlsServer, pmi)))
                    {
                        pm->AddRef();
                        ppm[eri.cItems++] = pm;
                    }
                    else
                    {
                        delete pm;
                    };
                };
                pmi++;
            };
        }
        else
        {
            eri.hResult = ILS_E_MEMORY;
        };
    }
    else
    {
        ppm = NULL;
    };

    // Package the notification info
    //
    eri.pv = (void *)ppm;
    NotifySink((void *)&eri, OnNotifyEnumMeetingPlacesResult);

    // Free the resources
    //
    if (ppm != NULL)
    {
        for (; eri.cItems; eri.cItems--)
        {
            ppm[eri.cItems-1]->Release();
        };
        ::MemFree (ppm);
    };
    return NOERROR;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// STDMETHODIMP
// CIlsMain::EnumMeetingPlaceNames (BSTR bstrServerName, IIlsFilter *pFilter,
//                      ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
STDMETHODIMP CIlsMain::
EnumMeetingPlaceNames (
	IIlsServer		*pServer,
	IIlsFilter		*pFilter,
	IEnumIlsNames	**ppEnum,
	ULONG			*puReqID)
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

	// We do not implement synchronous operation
	//
	if (ppEnum != NULL)
		return ILS_E_NOT_IMPL;

 	return EnumMeetingPlacesEx (TRUE,
 								(CIlsServer *) pServer,
								pFilter,
								NULL,
								puReqID);
}
#endif // ENABLE_MEETING_PLACE


//****************************************************************************
// HRESULT
// CIlsMain::EnumMeetingPlaceNamesResult (ULONG uReqID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

#ifdef ENABLE_MEETING_PLACE
HRESULT
CIlsMain::EnumMeetingPlaceNamesResult (ULONG uReqID, PLDAP_ENUM ple)
{
    ENUMRINFO eri;

    // Package the notification info
    //
    eri.uReqID  = uReqID;

    // PLDAP_ENUM is NULL when the enumeration is terminated successfully
    //
    if (ple != NULL)
    {
        eri.hResult = ple->hResult;
        eri.cItems  = ple->cItems;
        eri.pv      = (void *)(((PBYTE)ple)+ple->uOffsetItems);
    }
    else
    {
        eri.hResult = S_FALSE;
        eri.cItems  = 0;
        eri.pv      = NULL;
    };
    NotifySink((void *)&eri, OnNotifyEnumMeetingPlaceNamesResult);
    return NOERROR;
}
#endif // ENABLE_MEETING_PLACE

//****************************************************************************
// STDMETHODIMP
// CIlsMain::Abort (ULONG uReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::Abort (ULONG uReqID)
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    BOOL    fServerReq;
    HRESULT hr;

    // Look for the matching request information
    //
    ri.uReqID = uReqID;
    ri.uMsgID = 0; 
    hr = g_pReqMgr->GetRequestInfo(&ri);

    if (FAILED(hr))
    {
        return ILS_E_PARAMETER;
    };

    // Determine the request type
    //
    hr = NOERROR;
    switch(ri.uReqType)
    {
        //*************************************************************************
        // Fail if it is register request.
        // Cancelling register request must be done through unregister
        //*************************************************************************
        //
        case WM_ILS_LOCAL_REGISTER:
        case WM_ILS_LOCAL_UNREGISTER:
            return ILS_E_FAIL;

        //*************************************************************************
        // These requests are parts of register, they should not be exposed to
        // the caller.
        //*************************************************************************
        //
        case WM_ILS_REGISTER_CLIENT:
        case WM_ILS_UNREGISTER_CLIENT:
            ASSERT(0);
            break;

        //*************************************************************************
        // Release the objects and resources refernced or allocated for the request
        // See callback.cpp for the handler in the successful response case
        //*************************************************************************
        //
        case WM_ILS_REGISTER_PROTOCOL:
        case WM_ILS_UNREGISTER_PROTOCOL:
        case WM_ILS_LOCAL_REGISTER_PROTOCOL:
        case WM_ILS_LOCAL_UNREGISTER_PROTOCOL:
			{
				CIlsUser *pUser = ReqInfo_GetUser (&ri);
				if (pUser != NULL)
					pUser->Release ();

				CLocalProt *pProtocol = ReqInfo_GetProtocol (&ri);
				if (pProtocol != NULL)
					pProtocol->Release ();
            }
            break;

        case WM_ILS_SET_CLIENT_INFO:
        case WM_ILS_ENUM_PROTOCOLS:
        case WM_ILS_RESOLVE_PROTOCOL:
			{
				CIlsUser *pUser = ReqInfo_GetUser (&ri);
				if (pUser != NULL)
					pUser->Release ();
			}
            break;

        case WM_ILS_ENUM_CLIENTS:
			{
				CIlsMain *pMain = ReqInfo_GetMain (&ri);
				if (pMain != NULL)
					pMain->Release ();
			}
            break;

        case WM_ILS_RESOLVE_CLIENT:
        case WM_ILS_ENUM_CLIENTINFOS:
			{
				CIlsMain *pMain = ReqInfo_GetMain (&ri);
				if (pMain != NULL)
					pMain->Release ();

				CIlsServer *pServer = ReqInfo_GetServer (&ri);
				if (pServer != NULL)
					pServer->Release ();
			}
            break;


        //*************************************************************************
        // Fail if it is register request.
        // Cancelling register request must be done through unregister
        //*************************************************************************
        //
#ifdef ENABLE_MEETING_PLACE
		case WM_ILS_REGISTER_MEETING:
		case WM_ILS_UNREGISTER_MEETING:
            return ILS_E_FAIL;

		case WM_ILS_SET_MEETING_INFO:
		case WM_ILS_ADD_ATTENDEE:
		case WM_ILS_REMOVE_ATTENDEE:
		case WM_ILS_ENUM_ATTENDEES:
			{
				CIlsMeetingPlace *pMeeting = ReqInfo_GetMeeting (&ri);
				if (pMeeting != NULL)
					pMeeting->Release ();
			}
            break;

		case WM_ILS_RESOLVE_MEETING:
		case WM_ILS_ENUM_MEETINGINFOS:
			{
				CIlsMain *pMain = ReqInfo_GetMain (&ri);
				if (pMain != NULL)
					pMain->Release ();

				CIlsServer *pServer = ReqInfo_GetServer (&ri);
				if (pServer != NULL)
					pServer->Release ();
			}
			break;

		case WM_ILS_ENUM_MEETINGS:
			{
				CIlsMain *pMain = ReqInfo_GetMain (&ri);
				if (pMain != NULL)
					pMain->Release ();
			}
			break;
#endif // ENABLE_MEETING_PLACE

        default:
            // Unknown request
            //
            ASSERT(0);
            break;
    };

    // If it is a server request, cancel the request
    //
    if (ri.uMsgID != 0)
    {
        hr = UlsLdap_Cancel(ri.uMsgID);
    };

    if (SUCCEEDED(hr))
    {
        // Remove the request from the queue
        //
        hr = g_pReqMgr->RequestDone(&ri);
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:15:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ILS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ILS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecp->Init((IConnectionPoint *)pConnPt);
    if (FAILED(hr))
    {
        delete pecp;
        return hr;
    };

    // Give it back to the caller
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CIlsMain::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
//
// History:
//  Wed 17-Apr-1996 11:15:09  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsMain::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
{
    IID siid;
    HRESULT hr;

    // Validate parameters
    //
    if (ppcp == NULL)
    {
        return ILS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppcp = NULL;

    if (pConnPt != NULL)
    {
        hr = pConnPt->GetConnectionInterface(&siid);

        if (SUCCEEDED(hr))
        {
            if (riid == siid)
            {
                *ppcp = (IConnectionPoint *)pConnPt;
                (*ppcp)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = ILS_E_NO_INTERFACE;
            };
        };
    }
    else
    {
        hr = ILS_E_NO_INTERFACE;
    };

    return hr;
}

/* ----------------------------------------------------------------------
	CIlsMain::CreateFilter

	Output:
		ppFilter: a placeholder for the new filter object

	Input:
		FilterOp: a filter operation

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CIlsMain::
CreateFilter (
	ILS_FILTER_TYPE	FilterType,
	ILS_FILTER_OP	FilterOp,
	IIlsFilter		**ppFilter )
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

	// Make sure we have valid return pointer
	//
	if (ppFilter == NULL)
		return ILS_E_POINTER;

	// Make sure type/op are compatible
	//
	HRESULT hr = S_OK;
	switch (FilterType)
	{
	case ILS_FILTERTYPE_COMPOSITE:
		// Make sure type/op are compatible
		//
		switch (FilterOp)
		{
		case ILS_FILTEROP_AND:
			// Supported
			//
			break;
		case ILS_FILTEROP_OR:
		case ILS_FILTEROP_NOT:
			// Not supported
			//
			// lonchanc: let it fail at the server side
			hr = ILS_S_SERVER_MAY_NOT_SUPPORT;
			break;
		default:
			// Invalid
			//
			hr = ILS_E_PARAMETER;
			break;
		}
		break;

	case ILS_FILTERTYPE_SIMPLE:
		// Make sure type/op are compatible
		//
		switch (FilterOp)
		{
		case ILS_FILTEROP_EQUAL:
		case ILS_FILTEROP_EXIST:
		case ILS_FILTEROP_LESS_THAN:
		case ILS_FILTEROP_GREATER_THAN:
			// Supported
			//
			break;
		case ILS_FILTEROP_APPROX:
			// Not supported
			//
			hr = ILS_S_SERVER_MAY_NOT_SUPPORT;
			break;
		default:
			// Invalid
			//
			hr = ILS_E_PARAMETER;
			break;
		}
		break;

	default:
		hr = ILS_E_FILTER_TYPE;
		break;
	}

	// Create filter only if type/op are compatible
	//
	if (SUCCEEDED (hr))
	{
		CFilter *pFilter = new CFilter (FilterType);
		*ppFilter = pFilter;
		if (pFilter != NULL)
		{
			hr = S_OK;
			pFilter->AddRef ();
			pFilter->SetOp (FilterOp);
		}
		else
			hr = ILS_E_MEMORY;
	}

	return hr;
}


/* ----------------------------------------------------------------------
	CIlsMain::StringToFilter
	Output:
		ppFilter: a placeholder for the new filter object

	Input:
		bstrFilterString: an LDAP-like filter string

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CIlsMain::
StringToFilter ( BSTR bstrFilterString, IIlsFilter **ppFilter )
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

	// Make sure the filter string is valid
	//
	if (bstrFilterString == NULL)
		return ILS_E_POINTER;

	// Convert a bstr to an ansi string
	//
	TCHAR *pszFilter = NULL;
    HRESULT hr = ::BSTR_to_LPTSTR (&pszFilter, bstrFilterString);
    if (hr == S_OK)
    {
		ASSERT (pszFilter != NULL);

		// Render this filter
		//
		hr = StringToFilter (pszFilter, (CFilter **) ppFilter);

		// Free the temporary ansi string
		//
		::MemFree(pszFilter);
	}

	return hr;
}


HRESULT CIlsMain::
StringToFilter ( TCHAR *pszFilter, CFilter **ppFilter )
{
	// Construct a composite filter
	//
	CFilterParser FilterParser;
	return FilterParser.Expr (ppFilter, pszFilter);
}


STDMETHODIMP CIlsMain::
CreateServer ( BSTR bstrServerName, IIlsServer **ppServer )
{
	// Make sure ils main is initialized
	//
	if (! IsInitialized ())
	{
		return ILS_E_NOT_INITIALIZED;
	}

	if (bstrServerName == NULL || ppServer == NULL)
		return ILS_E_POINTER;

	HRESULT hr;
	CIlsServer *pIlsServer = new CIlsServer;
	if (pIlsServer != NULL)
	{
		hr = pIlsServer->SetServerName (bstrServerName);
		if (hr == S_OK)
		{
			pIlsServer->AddRef ();
		}
		else
		{
			delete pIlsServer;
			pIlsServer = NULL;
		}
	}
	else
	{
		hr = ILS_E_MEMORY;
	}

	*ppServer = (IIlsServer *) pIlsServer;
	return hr;
}



/* ---------- server authentication object ------------ */


CIlsServer::
CIlsServer ( VOID )
:m_cRefs (0),
 m_dwSignature (ILS_SERVER_SIGNATURE)
{
	::ZeroMemory (&m_ServerInfo, sizeof (m_ServerInfo));
	m_ServerInfo.AuthMethod = ILS_AUTH_ANONYMOUS;
}


CIlsServer::
~CIlsServer ( VOID )
{
	m_dwSignature = 0;
	::IlsFreeServerInfo (&m_ServerInfo);
}


STDMETHODIMP_(ULONG) CIlsServer::
AddRef ( VOID )
{
	DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CIlsServer::AddRef: ref=%ld\r\n", m_cRefs));
	::InterlockedIncrement (&m_cRefs);
	return m_cRefs;
}


STDMETHODIMP_(ULONG) CIlsServer::
Release ( VOID )
{
	DllRelease();

	ASSERT (m_cRefs > 0);

	MyDebugMsg ((DM_REFCOUNT, "CIlsServer::Release: ref=%ld\r\n", m_cRefs));
	if (::InterlockedDecrement (&m_cRefs) == 0)
	{
		delete this;
		return 0;
	}
	return m_cRefs;
}


STDMETHODIMP CIlsServer::
QueryInterface ( REFIID riid, VOID **ppv )
{
    *ppv = NULL;

    if (riid == IID_IIlsServer || riid == IID_IUnknown)
    {
        *ppv = (IIlsServer *) this;
    }

    if (*ppv != NULL)
    {
        ((LPUNKNOWN) *ppv)->AddRef();
        return S_OK;
    }

    return ILS_E_NO_INTERFACE;
}


STDMETHODIMP CIlsServer::
SetAuthenticationMethod ( ILS_ENUM_AUTH_METHOD enumAuthMethod )
{
	HRESULT hr;

	if (ILS_AUTH_ANONYMOUS <= enumAuthMethod &&
		enumAuthMethod < ILS_NUM_OF_AUTH_METHODS)
	{
		m_ServerInfo.AuthMethod = enumAuthMethod;
		hr = S_OK;
	}
	else
	{
		hr = ILS_E_PARAMETER;
	}

	return hr;
}


STDMETHODIMP CIlsServer::
SetLogonName ( BSTR bstrLogonName )
{
	// Make sure the filter string is valid
	//
	if (bstrLogonName == NULL)
		return ILS_E_POINTER;

	// Convert a bstr to an ansi string
	//
	TCHAR *psz = NULL;
    HRESULT hr = ::BSTR_to_LPTSTR (&psz, bstrLogonName);
    if (hr == S_OK)
    {
    	// Free the old string
    	//
	    ::MemFree (m_ServerInfo.pszLogonName);

		// Keep the new string
		//
    	m_ServerInfo.pszLogonName = psz;
	}

    return hr;
}


STDMETHODIMP CIlsServer::
SetLogonPassword ( BSTR bstrLogonPassword )
{
	// Make sure the filter string is valid
	//
	if (bstrLogonPassword == NULL)
		return ILS_E_POINTER;

	// Convert a bstr to an ansi string
	//
	TCHAR *psz = NULL;
    HRESULT hr = ::BSTR_to_LPTSTR (&psz, bstrLogonPassword);
    if (hr == S_OK)
    {
    	// Free the old string
    	//
	    ::MemFree (m_ServerInfo.pszLogonPassword);

		// Keep the new string
		//
    	m_ServerInfo.pszLogonPassword = psz;
	}

    return hr;
}


STDMETHODIMP CIlsServer::
SetDomain ( BSTR bstrDomain )
{
	// Make sure the filter string is valid
	//
	if (bstrDomain == NULL)
		return ILS_E_POINTER;

	// Convert a bstr to an ansi string
	//
	TCHAR *psz = NULL;
    HRESULT hr = ::BSTR_to_LPTSTR (&psz, bstrDomain);
    if (hr == S_OK)
    {
    	// Free the old string
    	//
	    ::MemFree (m_ServerInfo.pszDomain);

		// Keep the new string
		//
    	m_ServerInfo.pszDomain = psz;
	}

    return hr;
}


STDMETHODIMP CIlsServer::
SetCredential ( BSTR bstrCredential )
{
	// Make sure the filter string is valid
	//
	if (bstrCredential == NULL)
		return ILS_E_POINTER;

	// Convert a bstr to an ansi string
	//
	TCHAR *psz = NULL;
    HRESULT hr = ::BSTR_to_LPTSTR (&psz, bstrCredential);
    if (hr == S_OK)
    {
    	// Free the old string
    	//
	    ::MemFree (m_ServerInfo.pszCredential);

		// Keep the new string
		//
    	m_ServerInfo.pszCredential = psz;
	}

    return hr;
}


STDMETHODIMP CIlsServer::
SetTimeout ( ULONG uTimeoutInSecond )
{
    m_ServerInfo.uTimeoutInSecond = uTimeoutInSecond;
    return S_OK;
}


STDMETHODIMP CIlsServer::
SetBaseDN ( BSTR bstrBaseDN )
{
	// Make sure the filter string is valid
	//
	if (bstrBaseDN == NULL)
		return ILS_E_POINTER;

	// Convert a bstr to an ansi string
	//
	TCHAR *psz = NULL;
    HRESULT hr = ::BSTR_to_LPTSTR (&psz, bstrBaseDN);
    if (hr == S_OK)
    {
    	// Free the old string
    	//
	    ::MemFree (m_ServerInfo.pszBaseDN);

		// Keep the new string
		//
    	m_ServerInfo.pszBaseDN = psz;
	}

    return hr;
}


HRESULT CIlsServer::
SetServerName ( TCHAR *pszServerName )
{
	// Make sure the filter string is valid
	//
	if (pszServerName == NULL)
		return ILS_E_POINTER;

	// duplicate the server name
	//
	HRESULT hr;
	TCHAR *psz = ::My_strdup (pszServerName);
	if (psz != NULL)
	{
	    if (MyIsGoodString (psz))
	    {
	    	// Free the old string
	    	//
		    ::MemFree (m_ServerInfo.pszServerName);

			// Keep the new string
			//
	    	m_ServerInfo.pszServerName = psz;

	    	hr = S_OK;
		}
		else
		{
			::MemFree (psz);
			psz = NULL;
			hr = ILS_E_PARAMETER;
		}
	}
	else
	{
		hr = ILS_E_MEMORY;
	}

    return hr;
}



HRESULT CIlsServer::
SetServerName ( BSTR bstrServerName )
{
	// Make sure the filter string is valid
	//
	if (bstrServerName == NULL)
		return ILS_E_POINTER;

	// Convert a bstr to an ansi string
	//
	TCHAR *psz = NULL;
    HRESULT hr = ::BSTR_to_LPTSTR (&psz, bstrServerName);
    if (hr == S_OK)
    {
	    if (MyIsGoodString (psz))
	    {
	    	// Free the old string
	    	//
		    ::MemFree (m_ServerInfo.pszServerName);

			// Keep the new string
			//
	    	m_ServerInfo.pszServerName = psz;
	    }
	    else
	    {
	    	::MemFree (psz);
	    	psz = NULL;
	    	hr = ILS_E_PARAMETER;
	    }
	}

    return ((psz != NULL) ? S_OK : ILS_E_MEMORY);
}


TCHAR *CIlsServer::
DuplicateServerName ( VOID )
{
	return My_strdup (m_ServerInfo.pszServerName);
}


BSTR CIlsServer::
DuplicateServerNameBSTR ( VOID )
{
	BSTR bstr = NULL;
	TCHAR *psz = DuplicateServerName ();
	if (psz != NULL)
	{
		LPTSTR_to_BSTR (&bstr, psz);
	}

	return bstr;
}


CIlsServer *CIlsServer::
Clone ( VOID )
{
	CIlsServer *p = new CIlsServer;

	if (p != NULL)
	{
		if (::IlsCopyServerInfo (p->GetServerInfo (), GetServerInfo ()) == S_OK)
		{
			p->AddRef ();
		}
		else
		{
			::IlsFreeServerInfo (p->GetServerInfo ());
			::MemFree (p);
			p = NULL;
		}
	}

	return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\filter.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       filter.h
//  Content:    This file contains the filter object.
//  History:
//      Tue 12-Nov-1996 15:50:00  -by-  Chu, Lon-Chan [lonchanc]
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

#ifndef _FILTER_H_
#define _FILTER_H_


typedef enum 
{
	ILS_ATTRNAME_UNKNOWN,
	ILS_ATTRNAME_STANDARD,
	ILS_ATTRNAME_ARBITRARY,
}
	ILS_ATTR_NAME_TYPE;


//****************************************************************************
// CFilter definition
//****************************************************************************
//

class CFilter : public IIlsFilter
{
	friend class CFilterParser;

public:
	// Constructor and destructor
	//
	CFilter ( ILS_FILTER_TYPE Type );
	~CFilter ( VOID );

	// IUnknown
	//
	STDMETHODIMP            QueryInterface ( REFIID iid, VOID **ppv );
	STDMETHODIMP_(ULONG)    AddRef ( VOID );
	STDMETHODIMP_(ULONG)    Release ( VOID );

	// Composite filter operations
	//
	STDMETHODIMP	AddSubFilter ( IIlsFilter *pFilter );
	STDMETHODIMP	RemoveSubFilter ( IIlsFilter *pFilter );
	STDMETHODIMP	GetCount ( ULONG *pcElements );

	// Simple filter operations
	//
	STDMETHODIMP	SetStandardAttributeName ( ILS_STD_ATTR_NAME AttrName );
	STDMETHODIMP	SetExtendedAttributeName ( BSTR bstrAnyAttrName );
	STDMETHODIMP	SetAttributeValue ( BSTR bstrAttrValue );

	// Common operations
	//
	ILS_FILTER_TYPE GetType ( VOID ) { return m_Type; }
	ILS_FILTER_OP GetOp ( VOID ) { return m_Op; }
	VOID SetOp ( ILS_FILTER_OP Op ) { m_Op = Op; }

	enum { ILS_FILTER_SIGNATURE = 0x20698052 };
	BOOL IsValidFilter ( VOID ) { return (m_nSignature == ILS_FILTER_SIGNATURE); }
	BOOL IsBadFilter ( VOID ) { return (m_nSignature != ILS_FILTER_SIGNATURE); }

	HRESULT CalcFilterSize ( ULONG *pcbStringSize );
	HRESULT BuildLdapString ( TCHAR **ppszBuf );

protected:

	HRESULT RemoveAnySubFilter ( CFilter **ppFilter );

	HRESULT	SetExtendedAttributeName ( TCHAR *pszAnyAttrName );
	HRESULT SetAttributeValue ( TCHAR *pszAttrValue );

private:

	// Simple filter helpers
	//
	VOID FreeName ( VOID );
	VOID FreeValue ( VOID );

	// Common members
	//
	LONG				m_nSignature;
	LONG				m_cRefs;
	ILS_FILTER_TYPE		m_Type;	// filter type
	ILS_FILTER_OP		m_Op;	// filter op

	// Composite filter members
	//
	CList	m_SubFilters;
	ULONG	m_cSubFilters;

	// Simple filter members
	//
	ILS_ATTR_NAME_TYPE	m_NameType;
	union
	{
		ILS_STD_ATTR_NAME	std;
		TCHAR				*psz;
	}
		m_Name; 	// Attribute name
	TCHAR				*m_pszValue;

	#define FILTER_INTERNAL_SMALL_BUFFER_SIZE		16
	TCHAR				m_szInternalValueBuffer[FILTER_INTERNAL_SMALL_BUFFER_SIZE];
};



typedef enum
{
	ILS_TOKEN_NULL		= 0,
	ILS_TOKEN_LITERAL	= 1,
	ILS_TOKEN_STDATTR	= TEXT ('$'),	// $
	ILS_TOKEN_LP		= TEXT ('('),	// (
	ILS_TOKEN_RP		= TEXT (')'),	// )
	ILS_TOKEN_EQ		= TEXT ('='),	// =
	ILS_TOKEN_NEQ		= TEXT ('-'),	// !=
	ILS_TOKEN_APPROX	= TEXT ('~'),	// ~=
	ILS_TOKEN_GE		= TEXT ('>'),	// >=
	ILS_TOKEN_LE		= TEXT ('<'),	// <=
	ILS_TOKEN_AND		= TEXT ('&'),	// &
	ILS_TOKEN_OR		= TEXT ('|'),	// |
	ILS_TOKEN_NOT		= TEXT ('!'),	// !
}
	ILS_TOKEN_TYPE;


class CFilterParser
{
public:
	// Constructor and destructor
	//
	CFilterParser ( VOID );
	~CFilterParser ( VOID );

	HRESULT Expr ( CFilter **ppOutFilter, TCHAR *pszFilter );

protected:

private:

	HRESULT Expr ( CFilter **ppOutFilter );
	HRESULT TailExpr ( CFilter **ppOutFilter, CFilter *pInFilter );
	HRESULT GetToken ( VOID );

	// Cache of the filter string
	//
	TCHAR		*m_pszFilter;

	// Running pointer to parse the filter string
	//
	TCHAR		*m_pszCurr;

	// look ahead token for LL(1)
	//
	ILS_TOKEN_TYPE	m_TokenType;
	TCHAR			*m_pszTokenValue;
	LONG			m_nTokenValue;
};


HRESULT FilterToLdapString ( CFilter *pFilter, TCHAR **ppszFilter );


#endif // _FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\debug.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       debug.h
//  Content:    This file contains the debug-related declaration
//  History:
//      Tue 23-Feb-1993 14:08:25  -by-  Viroon  Touranachun [viroont]
//
//****************************************************************************

#ifndef _ULSDBG_H_
#define _ULSDBG_H_

#include <confdbg.h>

//****************************************************************************
// Macros
//****************************************************************************

#ifdef DEBUG

#define DM_ERROR    0x0000      // Error                       /* ;Internal */
#define DM_WARNING  0x0001      // Warning                     /* ;Internal */
#define DM_TRACE    0x0002      // Trace messages
#define DM_REFCOUNT 0x0003      // 

#define ZONE_KA     0x0004
#define ZONE_FILTER 0x0005
#define ZONE_REQ    0x0006
#define ZONE_RESP   0x0007
#define ZONE_CONN   0x0008

extern HDBGZONE ghZoneUls;
UINT DbgUlsTrace(LPCTSTR, ...);
VOID DbgMsgUls(ULONG uZone, CHAR *pszFormat, ...);

#define DPRINTF(sz)            DbgUlsTrace(sz)
#define DPRINTF1(sz,x)         DbgUlsTrace(sz, x)
#define DPRINTF2(sz,x,y)       DbgUlsTrace(sz, x, y)

#define DBG_REF               (!F_ZONE_ENABLED(ghZoneUls, DM_REFCOUNT)) ? 0 : DbgUlsTrace

#define MyAssert(expr)			ASSERT(expr)
#define MyDebugMsg(s)			DbgMsgUls s

#else // DEBUG

#define DPRINTF(sz)    
#define DPRINTF1(sz,x)
#define DPRINTF2(sz,x,y)

inline void WINAPI DbgUlsTrace(LPCTSTR, ...) { }
#define DBG_REF     1 ? (void)0 : ::DbgUlsTrace

#define MyAssert(expr)			
#define MyDebugMsg(s)			
#endif // DEBUG

#endif  //_ULSDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\filter.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       filter.cpp
//  Content:    This file contains the filter object.
//  History:
//      Tue 12-Nov-1996 15:50:00  -by-  Chu, Lon-Chan [lonchanc]
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

#include "ulsp.h"
#include "filter.h"
#include "sputils.h"


/* ----------------------------------------------------------------------
	CFilter::CFilter

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

CFilter::CFilter ( ILS_FILTER_TYPE Type )
:
 m_nSignature (ILS_FILTER_SIGNATURE),
 m_cRefs (0),
 m_Op (ILS_FILTEROP_NONE),
 m_cSubFilters (0),
 m_pszValue (NULL),
 m_NameType (ILS_ATTRNAME_UNKNOWN),
 m_Type (Type)
{
	// Initialize individual members based on filter type
	//
	ZeroMemory (&m_Name, sizeof (m_Name));
}


/* ----------------------------------------------------------------------
	CFilter::~CFilter

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

CFilter::~CFilter ( VOID )
{
	ASSERT (m_Type == ILS_FILTERTYPE_COMPOSITE || m_Type == ILS_FILTERTYPE_SIMPLE);

	// Common members
	//
	m_nSignature = -1;

	// Clean up individual members based on filter type
	//
	if (m_Type == ILS_FILTERTYPE_COMPOSITE)
	{
	    m_SubFilters.Flush();
	}
	else
	{
		FreeName ();
		FreeValue ();
	}	
}


/* ----------------------------------------------------------------------
	CFilter::QueryInterface

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CFilter::
QueryInterface ( REFIID riid, VOID **ppv )
{
	HRESULT hr = S_OK;
    *ppv = NULL;

    if (riid == IID_IIlsFilter || riid == IID_IUnknown)
    {
        *ppv = (IIlsFilter *) this;
    }

    if (*ppv != NULL)
        ((IUnknown *) *ppv)->AddRef();
    else
        hr = ILS_E_NO_INTERFACE;

    return hr;
}


/* ----------------------------------------------------------------------
	CFilter::AddRef

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP_(ULONG) CFilter::
AddRef ( VOID )
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CFilter::AddRef: ref=%ld\r\n", m_cRefs));
	::InterlockedIncrement (&m_cRefs);
    return m_cRefs;
}


/* ----------------------------------------------------------------------
	CFilter::Release

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP_(ULONG) CFilter::
Release ( VOID )
{
	ASSERT (m_cRefs > 0);

	DllRelease();

	MyDebugMsg ((DM_REFCOUNT, "CFilter::Release: ref=%ld\r\n", m_cRefs));
    if (::InterlockedDecrement (&m_cRefs) == 0)
    {
		if (m_Type == ILS_FILTERTYPE_COMPOSITE)
		{
	    	HANDLE hEnum;
	    	CFilter *pFilter;

		    // Free all the attributes
		    //
		    m_SubFilters.Enumerate (&hEnum);
		    while (m_SubFilters.Next (&hEnum, (VOID **) &pFilter) == NOERROR)
		    {
		    	if (pFilter != NULL)
		    	{
		    		pFilter->Release ();
		    	}
		    	else
		    	{
		    		ASSERT (FALSE);
		    	}
		    }
	    }
	    
        delete this;
        return 0;
	}

    return m_cRefs;
}


/* ----------------------------------------------------------------------
	CFilter::AddSubFilter

	Input:
		pFilter: A pointer to a filter object.

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CFilter::
AddSubFilter ( IIlsFilter *pFilter )
{
	// Make sure we have correct filter type
	//
	if (m_Type != ILS_FILTERTYPE_COMPOSITE)
		return ILS_E_FILTER_TYPE;

	// Make sure we have a valid sub-filter
	//
	if (pFilter == NULL || ((CFilter *) pFilter)->IsBadFilter ())
		return ILS_E_POINTER;

	HRESULT hr = m_SubFilters.Insert ((VOID *) pFilter);
	if (hr == S_OK)
		m_cSubFilters++;

	return hr;
}


/* ----------------------------------------------------------------------
	CFilter::RemoveSubFilter

	Input:
		pFilter: A placeholder to a pointer to a filter object.
				 If it is NULL, remove the first item.

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CFilter::
RemoveSubFilter ( IIlsFilter *pFilter )
{
	// Make sure we have correct filter type
	//
	if (m_Type != ILS_FILTERTYPE_COMPOSITE)
		return ILS_E_FILTER_TYPE;

	// Make sure we have a valid filter
	//
	if (pFilter == NULL || ((CFilter *) pFilter)->IsBadFilter ())
		return ILS_E_POINTER;

	HRESULT hr = m_SubFilters.Remove ((VOID *) pFilter);
	if (hr == S_OK)
	{
		ASSERT (m_cSubFilters > 0);
		m_cSubFilters--;
	}

	return hr;
}


HRESULT CFilter::
RemoveAnySubFilter ( CFilter **ppFilter )
{
	// Make sure we have correct filter type
	//
	if (m_Type != ILS_FILTERTYPE_COMPOSITE)
	{
		ASSERT (FALSE);
		return ILS_E_FILTER_TYPE;
	}

	// Make sure we have a valid filter
	//
	if (ppFilter == NULL)
	{
		ASSERT (FALSE);
		return ILS_E_POINTER;
	}

	HRESULT hr = S_OK;

	if (*ppFilter == NULL)
	{
		HANDLE hEnum;
		
		m_SubFilters.Enumerate (&hEnum);
		m_SubFilters.Next (&hEnum, (VOID **) ppFilter);
	}

	hr = m_SubFilters.Remove ((VOID *) *ppFilter);
	if (hr == S_OK)
	{
		ASSERT (m_cSubFilters > 0);
		m_cSubFilters--;
	}

	return hr;
}


/* ----------------------------------------------------------------------
	CFilter::GetCount

	Output:
		pcElements: A pointer to the count of filter elements.

	History:
	12/03/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CFilter::
GetCount ( ULONG *pcElements )
{
	// Make sure we have correct filter type
	//
	if (m_Type != ILS_FILTERTYPE_COMPOSITE)
		return ILS_E_FILTER_TYPE;

	HRESULT hr = S_OK;
	if (pcElements != NULL)
	{
		*pcElements = m_cSubFilters;
	}
	else
	{
		hr = ILS_E_POINTER;
	}

	return hr;
}


/* ----------------------------------------------------------------------
	CFilter::CalcFilterSize

	Input/Output:
		pcbStringSize: A pointer to the cumulative string size.

	History:
	12/03/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

HRESULT CFilter::
CalcFilterSize ( ULONG *pcbStringSize )
{
	ASSERT (pcbStringSize != NULL);

	HRESULT hr = S_OK;
	ULONG cbSize;
	TCHAR *psz;

	switch (m_Type)
	{
	case ILS_FILTERTYPE_COMPOSITE:
		{
			// First, count for "()"
			//
			cbSize = 4 * sizeof (TCHAR); // "(&)"

			// Second, enumerat every child
			//
			HANDLE hEnum;
			CFilter *pFilter = NULL;
		    m_SubFilters.Enumerate (&hEnum);
		    while (m_SubFilters.Next (&hEnum, (VOID **) &pFilter) == NOERROR)
		    {
		    	if (pFilter != NULL)
		    	{
		    		hr = pFilter->CalcFilterSize (pcbStringSize);
		    	}
		    	else
		    	{
		    		ASSERT (FALSE);
		    		hr = ILS_E_POINTER;
		    	}

				// Report error if needed
				//
		    	if (hr != S_OK)
		    		goto MyExit;
		    } // while
		} // case
		break;

	case ILS_FILTERTYPE_SIMPLE:
		{
			// First, count for "()"
			//
			cbSize = 3 * sizeof (TCHAR); // "()"

			// Second, count for attribute name
			//
			ASSERT (m_NameType == ILS_ATTRNAME_STANDARD || m_NameType == ILS_ATTRNAME_ARBITRARY);
			psz = (m_NameType == ILS_ATTRNAME_STANDARD) ?
					(TCHAR *) UlsLdap_GetStdAttrNameString (m_Name.std) :
					m_Name.psz;
			if (psz == NULL)
			{
				hr = ILS_E_POINTER;
				goto MyExit;
			}

			// Add up the string length
			//
			cbSize += lstrlen (psz) * sizeof (TCHAR);

			// Third, add up the equal sign, eg. "~="
			//
			cbSize += sizeof (TCHAR) * 2;

			// Fourth, count for attribute value
			//
			psz = m_pszValue;
			if (psz != NULL)
			{
				cbSize += lstrlen (psz) * sizeof (TCHAR);
			}
		}
		break;

	default:
		ASSERT (FALSE);
		hr = ILS_E_FILTER_TYPE;
		break;
	}

MyExit:

	// Clean up the size if failed
	//
	if (hr != S_OK)
		cbSize = 0;

	// Output the string size
	//
	*pcbStringSize += cbSize;

	return hr;
}


/* ----------------------------------------------------------------------
	CFilter::BuildLdapString

	Input/Output:
		ppszBuf: a pointer to where the next char of the rendering buffer is.

	History:
	12/03/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

HRESULT CFilter::
BuildLdapString ( TCHAR **ppszBuf )
{
	ASSERT (ppszBuf != NULL);

	// A running pointer
	//
	TCHAR *pszCurr = *ppszBuf;
	HRESULT hr = S_OK;

	// First, output "("
	//
	*pszCurr++ = TEXT ('(');

	// Second, output the operator if composite;
	// output the attribute name if simple
	//
	switch (m_Type)
	{
	case ILS_FILTERTYPE_COMPOSITE:
		{
			// Second, Output the operator
			//
			switch (GetOp ())
			{
			case ILS_FILTEROP_AND:
				*pszCurr++ = TEXT ('&');
				break;
			case ILS_FILTEROP_OR:
				*pszCurr++ = TEXT ('|');
				break;
			case ILS_FILTEROP_NOT:
				*pszCurr++ = TEXT ('!');
				break;
			default:
				hr = ILS_E_PARAMETER;
				goto MyExit;
			}

			// Third, enumerate every child
			//
			HANDLE hEnum;
			CFilter *pFilter;
		    m_SubFilters.Enumerate (&hEnum);
		    while (m_SubFilters.Next (&hEnum, (VOID **) &pFilter) == NOERROR)
		    {
		    	if (pFilter != NULL)
		    	{
	    			hr = pFilter->BuildLdapString (&pszCurr);
		    	}
		    	else
		    	{
		    		ASSERT (FALSE);
		    		hr = ILS_E_POINTER;
		    	}

				// Report error if needed
				//
				if (hr != S_OK)
					goto MyExit;
		    } // while
		} // case
		break;

	case ILS_FILTERTYPE_SIMPLE:
		{
			// Second, output attribute name
			//
			ASSERT (m_NameType == ILS_ATTRNAME_STANDARD || m_NameType == ILS_ATTRNAME_ARBITRARY);
			TCHAR *psz = (m_NameType == ILS_ATTRNAME_STANDARD) ?
							(TCHAR *) UlsLdap_GetStdAttrNameString (m_Name.std) :
							m_Name.psz;

			// Copy the attribute name
			//
			lstrcpy (pszCurr, psz);
			pszCurr += lstrlen (pszCurr);

			// Third, copy the comparison sign
			//
			switch (GetOp ())
			{
			case ILS_FILTEROP_EQUAL:
				*pszCurr++ = TEXT ('=');
				break;
			case ILS_FILTEROP_EXIST:
				*pszCurr++ = TEXT ('=');
				*pszCurr++ = TEXT ('*');
				break;
			case ILS_FILTEROP_APPROX:
				*pszCurr++ = TEXT ('~');
				*pszCurr++ = TEXT ('=');
				break;
			case ILS_FILTEROP_LESS_THAN:
				*pszCurr++ = TEXT ('<');
				*pszCurr++ = TEXT ('=');
				break;
			case ILS_FILTEROP_GREATER_THAN:
				*pszCurr++ = TEXT ('>');
				*pszCurr++ = TEXT ('=');
				break;
			default:
				ASSERT (FALSE);
				hr = ILS_E_PARAMETER;
				goto MyExit;
			}

			// Fourth, count for attribute value
			//
			psz = m_pszValue;
			if (psz != NULL)
			{
				lstrcpy (pszCurr, psz);
				pszCurr += lstrlen (pszCurr);
			}
		} // case
		break;

	default:
		ASSERT (FALSE);
		hr = ILS_E_FILTER_TYPE;
		goto MyExit;
	}

	// Finally, output ")"
	//
	*pszCurr++ = TEXT (')');

MyExit:

	// Output where the next char should go
	//
	*pszCurr = TEXT ('\0');
	*ppszBuf = pszCurr;

	return hr;
}


/* ----------------------------------------------------------------------
	CFilter::SetStandardAttributeName

	Input:
		AttrName: An index to identify a standard attribute name.

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CFilter::
SetStandardAttributeName ( ILS_STD_ATTR_NAME AttrName )
{
	// Make sure we have correct filter type
	//
	if (m_Type != ILS_FILTERTYPE_SIMPLE)
		return ILS_E_FILTER_TYPE;

	// Check standard attributes
	//
	if (((LONG) AttrName <= (LONG) ILS_STDATTR_NULL) ||
		((LONG) AttrName >= (LONG) ILS_NUM_OF_STDATTRS))
		return ILS_E_PARAMETER;

	// Free up the old string if needed
	//
	FreeName ();

	// Set the new standard attribute name
	//
	m_NameType = ILS_ATTRNAME_STANDARD;
	m_Name.std = AttrName;

	return S_OK;
}


/* ----------------------------------------------------------------------
	CFilter::SetExtendedAttributeName

	Input:
		pszAnyAttrName: A pointer to the name of an arbitrary attribute.

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CFilter::
SetExtendedAttributeName ( BSTR bstrAnyAttrName )
{
	// Make sure we have correct filter type
	//
	if (m_Type != ILS_FILTERTYPE_SIMPLE)
		return ILS_E_FILTER_TYPE;

	// Make sure the string is valid
	//
	if (bstrAnyAttrName == NULL)
		return ILS_E_POINTER;

	HRESULT hr = S_OK;

#ifdef _UNICODE
	hr = SetExtendedAttributeName ((WCHAR *) bstrAnyAttrName);
#else
	TCHAR *pszAnyAttrName = NULL;
	hr = BSTR_to_LPTSTR (&pszAnyAttrName, bstrAnyAttrName);
	if (hr == S_OK)
	{
		ASSERT (pszAnyAttrName != NULL);
		hr = SetExtendedAttributeName (pszAnyAttrName);
		::MemFree(pszAnyAttrName);
	}
#endif

	return hr;
}


HRESULT CFilter::
SetExtendedAttributeName ( TCHAR *pszAnyAttrName )
{
	ASSERT (pszAnyAttrName != NULL);

	// Set the new standard attribute name
	//
	HRESULT hr = S_OK;
	const TCHAR *pszPrefix = UlsLdap_GetExtAttrNamePrefix ();
	ULONG cchPrefix = (pszPrefix != NULL) ? lstrlen (pszPrefix) : 0; // don't put +1 here!!!
	TCHAR *psz = (TCHAR *) MemAlloc ((lstrlen (pszAnyAttrName) + 1 + cchPrefix) * sizeof (TCHAR));
	if (psz != NULL)
	{
		FreeName ();
		m_NameType = ILS_ATTRNAME_ARBITRARY;
		m_Name.psz = psz;
		if (pszPrefix != NULL)
		{
			lstrcpy (psz, pszPrefix);
			psz += cchPrefix;
		}
		lstrcpy (psz, pszAnyAttrName);
	}
	else
	{
		hr = ILS_E_MEMORY;
	}

	return hr;
}


/* ----------------------------------------------------------------------
	CFilter::SetAttributeValue

	Input:
		pszAttrValue: A pointer to the string value of an attribute.

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

STDMETHODIMP CFilter::
SetAttributeValue ( BSTR bstrAttrValue )
{
	// Make sure we have correct filter type
	//
	if (m_Type != ILS_FILTERTYPE_SIMPLE)
		return ILS_E_FILTER_TYPE;

	// Make sure we have valid string
	//
	if (bstrAttrValue == NULL)
		return ILS_E_POINTER;

	HRESULT hr = S_OK;

#ifdef _UNICODE
	hr = SetAttributeValue ((WCHAR *) bstrAttrValue);
#else
	TCHAR *pszAttrValue = NULL;
	hr = BSTR_to_LPTSTR (&pszAttrValue, bstrAttrValue);
	if (hr == S_OK)
	{
		ASSERT (pszAttrValue != NULL);
		hr = SetAttributeValue (pszAttrValue);
		::MemFree(pszAttrValue);
	}
#endif

	return hr;
}


HRESULT CFilter::
SetAttributeValue ( TCHAR *pszAttrValue )
{
	ASSERT (pszAttrValue != NULL);

	// Make a duplicate of the attribute value
	//
	HRESULT hr = S_OK;
	ULONG cch = My_lstrlen (pszAttrValue);
	if (cch < FILTER_INTERNAL_SMALL_BUFFER_SIZE)
	{
		FreeValue ();
		m_pszValue = &m_szInternalValueBuffer[0];
		My_lstrcpy (m_pszValue, pszAttrValue);
	}
	else
	{
		TCHAR *psz = My_strdup (pszAttrValue);
		if (psz != NULL)
		{
			FreeValue ();
			m_pszValue = psz;
		}
		else
		{
			hr = ILS_E_MEMORY;
		}
	}

	return S_OK;
}


/* ----------------------------------------------------------------------
	CFilter::FreeName

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

VOID CFilter::
FreeName ( VOID )
{
	ASSERT (m_Type == ILS_FILTERTYPE_SIMPLE);

	// Free the value field
	//
	if (m_NameType == ILS_ATTRNAME_ARBITRARY)
	{
		MemFree (m_Name.psz);
	}

	// Reset it to zero
	//
	ZeroMemory (&m_Name, sizeof (m_Name));

	// Reset name type
	//
	m_NameType = ILS_ATTRNAME_UNKNOWN;
}


/* ----------------------------------------------------------------------
	CFilter::FreeValue

	History:
	11/12/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

VOID CFilter::
FreeValue ( VOID )
{
	ASSERT (m_Type == ILS_FILTERTYPE_SIMPLE);

	// Free the value field
	//
	if (m_pszValue != &m_szInternalValueBuffer[0])
	{
		MemFree (m_pszValue);
	}

	m_pszValue = NULL;
}




CFilterParser::CFilterParser ( VOID )
:
 m_pszFilter (NULL),
 m_pszCurr (NULL),
 m_TokenType (ILS_TOKEN_NULL),
 m_pszTokenValue (NULL),
 m_nTokenValue (0)
{
}


CFilterParser::~CFilterParser ( VOID )
{
    ::MemFree(m_pszFilter);
}


HRESULT CFilterParser::
Expr ( CFilter **ppOutFilter, TCHAR *pszFilter )
{
	// Make sure we have a valid string
	//
	if (ppOutFilter == NULL || pszFilter == NULL)
		return ILS_E_POINTER;

	// Free old string if any
	//
	MemFree (m_pszFilter); // checking null inside

	// Find out how big the filter string
	//
	ULONG cch = lstrlen (pszFilter) + 1;
	if (cch < 32)
		cch = 32; // make sure we have some decent size of buffer

	// Allocate buffer to keep the filter string
	//
	m_pszFilter = (TCHAR *) MemAlloc (cch * sizeof (TCHAR) * 2);
	if (m_pszFilter == NULL)
		return ILS_E_MEMORY;

	// Copy filter string
	//
	lstrcpy (m_pszFilter, pszFilter);
	m_pszCurr = m_pszFilter;

	// Keep the rest for token value
	//
	m_pszTokenValue = m_pszFilter + cch;
	m_nTokenValue = 0;

	// Call the parser engine
	//
	return Expr (ppOutFilter);
}


HRESULT CFilterParser::
Expr ( CFilter **ppOutFilter )
{
	/* LR(1) Parsing Grammar
		<Expr> 		:=	'(' <Expr> ')' <TailExpr> |
						'!' '(' Expr ')' |
						AttrName EqualOp AttrValue <TailExpr> |
						NULL
		<TailExpr>	:=	RelOp Expr | NULL
		EqualOp		:=	'!=' | '='
		RelOp		:=	'&' | '|' | '!'
		AttrName	:=	'$' Integer | Alphanum
		AttrValue	:=	Alphanum
	 */

	// Clean up first
	//
	ASSERT (ppOutFilter != NULL);
	*ppOutFilter = NULL;
	HRESULT hr = S_OK;
	CFilter *pElement = NULL;

	// Look ahead by 1
	//
	GetToken ();
	switch (m_TokenType)
	{
	case ILS_TOKEN_NOT:
		// Make sure left parenthesis
		//
		GetToken ();
		if (m_TokenType != ILS_TOKEN_LP)
		{
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}

		// Fall through
		//

	case ILS_TOKEN_LP:
		// Parse the expression inside parentheses
		//
		hr = Expr (ppOutFilter);
		if (hr != S_OK)
			goto MyExit;

		// See if it is incomplete expr
		//
		if (*ppOutFilter == NULL)
		{
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}

		// Make sure right parenthesis ended
		// ILS_TOKEN_RP was taken in TrailExpr()
		//
		if (m_TokenType != ILS_TOKEN_RP)
		{
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}

		// Handle TailExpr
		//
		hr = TailExpr (ppOutFilter, *ppOutFilter);
		break;

	case ILS_TOKEN_STDATTR:
	case ILS_TOKEN_LITERAL:
		// Create a simple filter
		//
		pElement = new CFilter (ILS_FILTERTYPE_SIMPLE);
		if (pElement == NULL)
		{
			hr = ILS_E_MEMORY;
			goto MyExit;
		}
		pElement->AddRef ();

		// Set arbitrary attribute name
		//
		hr = (m_TokenType == ILS_TOKEN_STDATTR) ?
				pElement->SetStandardAttributeName ((ILS_STD_ATTR_NAME) m_nTokenValue) :
				pElement->SetExtendedAttributeName (m_pszTokenValue);
		if (hr != S_OK)
		{
			goto MyExit;
		}

		// Must be eq or neq
		//
		GetToken ();
		switch (m_TokenType)
		{
		case ILS_TOKEN_EQ:
		case ILS_TOKEN_NEQ:
			pElement->SetOp ((ILS_FILTER_OP) m_nTokenValue);
			break;
		default:
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}

		// Must be literal attribute value
		//
		GetToken ();
		if (m_TokenType != ILS_TOKEN_LITERAL)
		{
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}
		hr = pElement->SetAttributeValue (m_pszTokenValue);

		// Handle TailExpr
		//
		hr = TailExpr (ppOutFilter, pElement);
		break;

	case ILS_TOKEN_NULL:
		break;

	default:
		hr = ILS_E_FILTER_STRING;
		break;
	}

MyExit:

	if (hr != S_OK)
	{
		if (pElement != NULL)
			pElement->Release ();

		if (*ppOutFilter != NULL)
			(*ppOutFilter)->Release ();
	}

	return hr;
}


HRESULT CFilterParser::
TailExpr ( CFilter **ppOutFilter, CFilter *pInFilter )
{
	// Clean up first
	//
	ASSERT (ppOutFilter != NULL);
	ASSERT (pInFilter != NULL);
	*ppOutFilter = NULL;
	HRESULT hr = S_OK;

	// Look ahead
	//
	ILS_FILTER_OP FilterOp = ILS_FILTEROP_OR;
	GetToken ();
	switch (m_TokenType)
	{
	case ILS_TOKEN_AND:
		// Change filter op to AND
		//
		FilterOp = ILS_FILTEROP_AND;

		// Fall through
		//

	case ILS_TOKEN_OR:
		// Assume FilterOp is set properly
		//
		ASSERT (FilterOp == ILS_FILTEROP_OR ||
				FilterOp == ILS_FILTEROP_AND);

		// Parse the expr
		//
		hr = Expr (ppOutFilter);
		if (hr != S_OK)
			goto MyExit;

		// See if it is incomplete expr
		//
		if (*ppOutFilter == NULL)
		{
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}

		// If the out filter is a composite and has same op,
		//		then re-use the composite
		//		else create a new composite
		//
		if ((*ppOutFilter)->GetType () == ILS_FILTERTYPE_COMPOSITE &&
			(*ppOutFilter)->GetOp ()   == FilterOp)
		{
			// Re-use the composite
			//
			hr = ((CFilter *) (*ppOutFilter))->AddSubFilter (pInFilter);
			if (hr != S_OK)
			{
				goto MyExit;
			}
		}
		else
		{
			// Create a container for in filter and new filter from Expr
			//
			CFilter *pFilter = new CFilter (ILS_FILTERTYPE_COMPOSITE);
			if (pFilter == NULL)
			{
				hr = ILS_E_MEMORY;
				goto MyExit;
			}
			pFilter->AddRef ();

			// Set op
			//
			pFilter->SetOp (FilterOp);

			// Set up membership
			//
			hr = pFilter->AddSubFilter (*ppOutFilter);
			if (hr != S_OK)
			{
				pFilter->Release ();
				goto MyExit;
			}
			hr = pFilter->AddSubFilter (pInFilter);
			if (hr != S_OK)
			{
				pFilter->Release (); // recursively
				*ppOutFilter = NULL;
				goto MyExit;
			}

			// Output this new composite filter
			//
			*ppOutFilter = pFilter;
		}
		break;
		
	case ILS_TOKEN_NOT:
		// Should not have in filter at all
		//
		if (pInFilter != NULL)
		{
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}

		// Parse the expr
		//
		hr = Expr (ppOutFilter);
		if (hr != S_OK)
			goto MyExit;

		// If it is incomplete expr
		//
		if (*ppOutFilter == NULL)
		{
			hr = ILS_E_FILTER_STRING;
			goto MyExit;
		}

		// If the out filter is a composite and has same op,
		//		then re-use the composite
		//		else create a new composite
		//
		if ((*ppOutFilter)->GetType () == ILS_FILTERTYPE_COMPOSITE &&
			(*ppOutFilter)->GetOp ()   == ILS_FILTEROP_NOT)
		{
			// Remove the composite due to NOT NOT cancellation
			//
			CFilter *pFilter = NULL;
			hr = (*ppOutFilter)->RemoveAnySubFilter (&pFilter);
			if (hr != S_OK)
			{
				goto MyExit;
			}

			// Make sure we have a valid pFilter
			//
			if (pFilter == NULL)
			{
				hr = ILS_E_FILTER_STRING;
				goto MyExit;
			}

			// Free the old out filter
			//
			(*ppOutFilter)->Release ();

			// Output this filter
			//
			*ppOutFilter = pFilter;
		}
		else
		{
			// Create a container for in filter and new filter from Expr
			//
			CFilter *pFilter = new CFilter (ILS_FILTERTYPE_COMPOSITE);
			if (pFilter == NULL)
			{
				hr = ILS_E_MEMORY;
				goto MyExit;
			}
			pFilter->AddRef ();

			// Set op
			//
			pFilter->SetOp (ILS_FILTEROP_NOT);

			// Set up membership
			//
			hr = pFilter->AddSubFilter (*ppOutFilter);
			if (hr != S_OK)
			{
				pFilter->Release ();
				goto MyExit;
			}

			// Output this new composite filter
			//
			*ppOutFilter = pFilter;
		}
		break;

	case ILS_TOKEN_NULL:
	case ILS_TOKEN_RP:
		// No more expression, in filter is the out filter
		//
		*ppOutFilter = pInFilter;
		break;

	default:
		hr = ILS_E_PARAMETER;
		break;
	}

MyExit:

	if (hr != S_OK)
	{
		if (*ppOutFilter != NULL)
			(*ppOutFilter)->Release ();
	}

	return hr;
}


HRESULT CFilterParser::
GetToken ( VOID )
{
	// Set m_TokenType, m_pszTokenValue, m_nTokenValue
	TCHAR *psz;

	// Clean token
	//
	ASSERT (m_pszTokenValue != NULL);
	m_TokenType = ILS_TOKEN_NULL;
	*m_pszTokenValue = TEXT ('\0');
	m_nTokenValue = 0;

	// Have we finished?
	//
	if (m_pszCurr == NULL)
		return S_OK;

	// Skip any while spaces
	//
	while (::My_isspace (*m_pszCurr))
		m_pszCurr++;

	// Have we finished?
	//
	if (*m_pszCurr == TEXT ('\0'))
		return S_OK;

	// Look at the first character
	//
	HRESULT hr = S_OK;
	switch ((ILS_TOKEN_TYPE) *m_pszCurr)
	{
	case ILS_TOKEN_STDATTR:
		// Set token type
		//
		m_TokenType = ILS_TOKEN_STDATTR;

		// Set token string
		//
		psz = m_pszTokenValue;
		*psz++ = *m_pszCurr++;
		while (*m_pszCurr != TEXT ('\0'))
		{
			if (TEXT ('0') <= *m_pszCurr && *m_pszCurr <= TEXT ('9'))
				*psz++ = *m_pszCurr++;
			else		
				break;
		}
		*psz = TEXT ('\0');

		// Set token value
		//
		m_nTokenValue = ::GetStringLong (m_pszTokenValue + 1);
		break;

	case ILS_TOKEN_LP:
	case ILS_TOKEN_RP:
		// Set token type
		//
		m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr++;
		break;

	case ILS_TOKEN_EQ:
		// Set token value to be filter op
		//
		m_nTokenValue = (LONG) ILS_FILTEROP_EQUAL;

		// Set token type
		//
		m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr++;
		break;

	case ILS_TOKEN_APPROX:
		if (m_pszCurr[1] == TEXT ('='))
		{
			// Set token value to be filter op
			//
			m_nTokenValue = (LONG) ILS_FILTEROP_APPROX;

			// Set token type
			//
			m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr;
			m_pszCurr += 2;
		}
		else
		{
			hr = ILS_E_FILTER_STRING; 
		}
		break;

	case ILS_TOKEN_GE:
		if (m_pszCurr[1] == TEXT ('='))
		{
			// Set token value to be filter op
			//
			m_nTokenValue = (LONG) ILS_FILTEROP_GREATER_THAN;

			// Set token type
			//
			m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr;
			m_pszCurr += 2;
		}
		else
		{
			hr = ILS_E_FILTER_STRING; 
		}
		break;

	case ILS_TOKEN_LE:
		if (m_pszCurr[1] == TEXT ('='))
		{
			// Set token value to be filter op
			//
			m_nTokenValue = (LONG) ILS_FILTEROP_LESS_THAN;

			// Set token type
			//
			m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr;
			m_pszCurr += 2;
		}
		else
		{
			hr = ILS_E_FILTER_STRING; 
		}
		break;

	case ILS_TOKEN_AND:
		// Set token value to be filter op
		//
		m_nTokenValue = (LONG) ILS_FILTEROP_AND;

		// Set token type
		//
		m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr++;
		break;

	case ILS_TOKEN_OR:
		// Set token value to be filter op
		//
		m_nTokenValue = (LONG) ILS_FILTEROP_OR;

		// Set token type
		//
		m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr++;
		break;

	case ILS_TOKEN_NOT:
		// Look ahead for !=
		//
		if ((ILS_TOKEN_TYPE) *(m_pszCurr+1) == TEXT ('='))
		{
			// Set token type
			//
			m_TokenType = ILS_TOKEN_NEQ;
			m_pszCurr += 2;
		}
		else
		{
			// Set token value to be filter op
			//
			m_nTokenValue = (LONG) ILS_FILTEROP_NOT;

			// Set token type
			//
			m_TokenType = (ILS_TOKEN_TYPE) *m_pszCurr++;
		}
		break;		

	default: // Handle alpha numeric
		{
			// Set token string
			//
			BOOL fStayInLoop = (*m_pszCurr != TEXT ('\0'));
			psz = m_pszTokenValue;
			while (fStayInLoop)
			{
				// Stop only when encountering delimiters such as
				//
				switch (*m_pszCurr)
				{
				case ILS_TOKEN_STDATTR:
				case ILS_TOKEN_LP:
				case ILS_TOKEN_RP:
				case ILS_TOKEN_EQ:
				// case ILS_TOKEN_NEQ: // - is a valid char such as in ms-netmeeting
				case ILS_TOKEN_APPROX:
				case ILS_TOKEN_GE:
				case ILS_TOKEN_LE:
				case ILS_TOKEN_AND:
				case ILS_TOKEN_OR:
				case ILS_TOKEN_NOT:
					fStayInLoop = FALSE;
					break;
				default:
					*psz++ = *m_pszCurr++;
					fStayInLoop = (*m_pszCurr != TEXT ('\0'));
					break;
				}
			}
			*psz = TEXT ('\0');

			// Remove trailing spaces
			//
			psz--;
			while (psz >= m_pszCurr && ::My_isspace (*psz))
				*psz-- = TEXT ('\0');

			// Set token type
			//
			m_TokenType = (*m_pszTokenValue == TEXT ('\0')) ?
								ILS_TOKEN_NULL :
								ILS_TOKEN_LITERAL;
		}
		break;
	}

	return hr;
}



HRESULT FilterToLdapString ( CFilter *pFilter, TCHAR **ppszFilter )
{
	HRESULT hr;

	// Make sure we have valid pointers
	//
	if (pFilter == NULL || ppszFilter == NULL)
		return ILS_E_POINTER;

	// Clean up output
	//
	TCHAR *pszFilter = NULL;

	// Calculate the string size
	//
	ULONG cbSize = 0;
	hr = pFilter->CalcFilterSize (&cbSize);
	if (hr != S_OK)
		goto MyExit;

	// Allocate string buffer
	//
	pszFilter = (TCHAR *) MemAlloc (cbSize);
	if (pszFilter == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Make a copy of pszFilter because
	// FilterToLdapString() will change the value
	//
	TCHAR *pszFilterAux;
	pszFilterAux = pszFilter;

	// Render the filter string
	//
	hr = pFilter->BuildLdapString (&pszFilterAux);

MyExit:

	if (hr != S_OK)
	{
		MemFree (pszFilter);
		pszFilter = NULL;
	}

	*ppszFilter = pszFilter;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\localapp.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       localapp.h
//  Content:    This file contains the LocalApplication object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _CLOCALAPP_H_
#define _CLOCALAPP_H_

#include "connpt.h"

//****************************************************************************
// Enumeration type
//****************************************************************************
//
typedef enum {
    ULS_APP_SET_ATTRIBUTES,
    ULS_APP_REMOVE_ATTRIBUTES,
}   APP_CHANGE_ATTRS;

typedef enum {
    ULS_APP_ADD_PROT,
    ULS_APP_REMOVE_PROT,
}   APP_CHANGE_PROT;

//****************************************************************************
// CUls definition
//****************************************************************************
//
class CLocalApp : public IULSLocalApplication,
                  public IConnectionPointContainer 
{
private:
    ULONG                   cRef;
    LPTSTR                  szName;
    GUID                    guid;
    LPTSTR                  szMimeType;
    CAttributes             *pAttrs;
    CList                   ProtList;
    CConnectionPoint        *pConnPt;

    // Private methods
    STDMETHODIMP    NotifySink (void *pv, CONN_NOTIFYPROC pfn);
    STDMETHODIMP    ChangeAttributes (IULSAttributes *pAttributes,
                                      ULONG *puReqID,
                                      APP_CHANGE_ATTRS uCmd);
    STDMETHODIMP    ChangeProtocol (IULSLocalAppProtocol *pAttributes,
                                    ULONG *puReqID,
                                    APP_CHANGE_PROT uCmd);

public:
    // Constructor and destructor
    CLocalApp (void);
    ~CLocalApp (void);
    STDMETHODIMP    Init (BSTR bstrName, REFGUID rguid, BSTR bstrMimeType);

    // Internal methods
    STDMETHODIMP    GetAppInfo (PLDAP_APPINFO *ppAppInfo);

    // Asynchronous response handler
    //
    STDMETHODIMP    AttributesChangeResult (CAttributes *pAttributes,
                                            ULONG uReqID, HRESULT hResult,
                                            APP_CHANGE_ATTRS uCmd);
    STDMETHODIMP    ProtocolChangeResult (CLocalProt *pProtocol,
                                          ULONG uReqID, HRESULT hResult,
                                          APP_CHANGE_PROT uCmd);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IULSLocalApplication
    STDMETHODIMP    CreateProtocol (BSTR bstrProtocolID, ULONG uPortNumber,
                                    BSTR bstrMimeType,
                                    IULSLocalAppProtocol **ppProtocol);
    STDMETHODIMP    AddProtocol (IULSLocalAppProtocol *pProtocol,
                                 ULONG *puReqID);
    STDMETHODIMP    RemoveProtocol (IULSLocalAppProtocol *pProtocol,
                                    ULONG *puReqID);
    STDMETHODIMP    EnumProtocols (IEnumULSLocalAppProtocols **ppEnumProtocol);
    STDMETHODIMP    SetAttributes (IULSAttributes *pAttributes,
                                   ULONG *puReqID);
    STDMETHODIMP    RemoveAttributes (IULSAttributes *pAttributes,
                                      ULONG *puReqID);

    // IConnectionPointContainer
    STDMETHODIMP    EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
    STDMETHODIMP    FindConnectionPoint(REFIID riid,
                                        IConnectionPoint **ppcp);

#ifdef  DEBUG
    void            DebugProtocolDump(void);
#endif  // DEBUG
};

//****************************************************************************
// CEnumLocalAppProtocols definition
//****************************************************************************
//
class CEnumLocalAppProtocols : public IEnumULSLocalAppProtocols
{
private:
    ULONG                   cRef;
    CList                   ProtList;
    HANDLE                  hEnum;

public:
    // Constructor and Initialization
    CEnumLocalAppProtocols (void);
    ~CEnumLocalAppProtocols (void);
    STDMETHODIMP            Init (CList *pProtList);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumULSLocalAppProtocols
    STDMETHODIMP            Next(ULONG cProtocols, IULSLocalAppProtocol **rgpProt,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cProtocols);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumULSLocalAppProtocols **ppEnum);
};

#endif //_CLOCALAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\ldapstub.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       ldapstub.cpp
//  Content:    ULS/LDAP stubbed functions
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"

HWND    g_hwndCB = NULL;
ULONG   uMsgID;

//
// Initialization
//
HRESULT UlsLdap_Initialize (
    HWND            hwndCallback)
{
    uMsgID = 1;
    g_hwndCB = hwndCallback;
    return S_OK;
}

HRESULT UlsLdap_Deinitialize (void)
{
    uMsgID = 0;
    g_hwndCB = NULL;
    return S_OK;
}

HRESULT UlsLdap_Cancel (
    ULONG uReqID)
{
    return S_OK;
}


//
// Local machine information
//
HRESULT UlsLdap_RegisterUser (
    LPTSTR          pszServer,
    PLDAP_USERINFO  pUserInfo,
    PHANDLE         phUser,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    *phUser = (HANDLE)(0x11111111);
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_REGISTER_USER, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_RegisterApp (
    HANDLE          hUser, 
    PLDAP_APPINFO   pAppInfo,
    PHANDLE         phApp,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    if (hUser != (HANDLE)(0x11111111))
    {
        ASSERT(0);
        return ULS_E_FAIL;
    };

    *phApp = (HANDLE)(0x22222222);
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_REGISTER_APP, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}


HRESULT UlsLdap_RegisterProtocol (
    HANDLE          hApp,
    PLDAP_PROTINFO  pProtInfo,
    PHANDLE         phProtocol,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    if (hApp != (HANDLE)(0x22222222))
    {
        ASSERT(0);
        return ULS_E_FAIL;
    };

    *phProtocol = (HANDLE)(0x44444444);
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_REGISTER_PROTOCOL, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_UnRegisterUser (
    HANDLE          hUser,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    if (hUser != (HANDLE)(0x11111111))
    {
        ASSERT(0);
        return ULS_E_FAIL;
    };

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_UNREGISTER_USER, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_UnRegisterApp (
    HANDLE          hApp,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    if (hApp != (HANDLE)(0x22222222))
    {
        ASSERT(0);
        return ULS_E_FAIL;
    };

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_UNREGISTER_APP, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_UnRegisterProtocol (
    HANDLE          hProt,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    if (hProt != (HANDLE)(0x44444444))
    {
        ASSERT(0);
        return ULS_E_FAIL;
    };

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_UNREGISTER_PROTOCOL, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_SetUserInfo (
    HANDLE          hUser,
    PLDAP_USERINFO  pInfo,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_SET_USER_INFO, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_SetAppAttrs (
    HANDLE          hApp,
    ULONG           cAttrs,
    LPTSTR          pszAttrs,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_SET_APP_ATTRS, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_SetProtocolAttrs (
    HANDLE          hProt,
    ULONG           cAttrs,
    LPTSTR          pszAttrs,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_SET_PROTOCOL_ATTRS, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_RemoveAppAttrs (
    HANDLE          hApp,
    ULONG           cAttrs,
    LPTSTR          pszAttrNames,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_REMOVE_APP_ATTRS, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_RemoveProtocolAttrs (
    HANDLE          hApp,
    ULONG           cAttrs,
    LPTSTR          pszAttrNames,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_REMOVE_PROTOCOL_ATTRS, uMsgID, NOERROR);
    uMsgID++;
    return NOERROR;
}


//
// User Location Services request
//
static TCHAR c_szEnumNames_1[] = {TEXT("User_1") TEXT("\0")
                                  TEXT("User_2") TEXT("\0")
                                  TEXT("User_3") TEXT("\0")
                                  TEXT("User_4") TEXT("\0\0")};

static TCHAR c_szEnumNames_2[] = {TEXT("User_5") TEXT("\0")
                                  TEXT("User_6") TEXT("\0")
                                  TEXT("User_7") TEXT("\0")
                                  TEXT("User_8") TEXT("\0\0")};

HRESULT UlsLdap_EnumUsers (
    LPTSTR          pszServer,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    PLDAP_ENUM ple;

    // First batch
    //
    ple = (PLDAP_ENUM)LocalAlloc(LMEM_FIXED, sizeof(*ple)+sizeof(c_szEnumNames_1));
    ple->uSize = sizeof(*ple);
    ple->hResult = NOERROR;
    ple->cItems = 4;
    ple->uOffsetItems = ple->uSize;
    CopyMemory(((PBYTE)ple)+ple->uOffsetItems, c_szEnumNames_1,
               sizeof(c_szEnumNames_1));

    PostMessage(g_hwndCB, WM_ULS_ENUM_USERS, uMsgID, (LPARAM)ple);

    // Second batch
    //
    ple = (PLDAP_ENUM)LocalAlloc(LMEM_FIXED, sizeof(*ple)+sizeof(c_szEnumNames_2));
    ple->uSize = sizeof(*ple);
    ple->hResult = NOERROR;
    ple->cItems = 4;
    ple->uOffsetItems = ple->uSize;
    CopyMemory(((PBYTE)ple)+ple->uOffsetItems, c_szEnumNames_2,
               sizeof(c_szEnumNames_2));

    PostMessage(g_hwndCB, WM_ULS_ENUM_USERS, uMsgID, (LPARAM)ple);

    // Terminate
    //
    PostMessage(g_hwndCB, WM_ULS_ENUM_USERS, uMsgID, (LPARAM)NULL);

    pAsyncInfo->uMsgID = uMsgID;
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_ResolveUser (
    LPTSTR          pszServer,
    LPTSTR          pszUserName,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    PLDAP_USERINFO_RES plur;
    PLDAP_USERINFO     plu;
    ULONG   cLen;

    plur = (PLDAP_USERINFO_RES)LocalAlloc(LMEM_FIXED, sizeof(*plur)+
                                          (sizeof(TCHAR)*MAX_PATH));
    plur->uSize = sizeof(*plur);
    plur->hResult = NOERROR;

    plu = &(plur->lui);
    plu->uSize = sizeof(LDAP_USERINFO);
    plu->uOffsetName = plu->uSize;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetName), TEXT("%s"), pszUserName) + 1;

    plu->uOffsetFirstName = plu->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetFirstName), TEXT("%s_First"),
                    pszUserName) + 1;

    plu->uOffsetLastName = plu->uOffsetFirstName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetLastName), TEXT("%s_Last"),
                    pszUserName) + 1;

    plu->uOffsetEMailName = plu->uOffsetLastName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetEMailName), TEXT("%s"),
                    pszUserName) + 1;

    plu->uOffsetCityName = plu->uOffsetEMailName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCityName), TEXT("%sville"),
                    pszUserName) + 1;

    plu->uOffsetCountryName = plu->uOffsetCityName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCountryName), TEXT("%sland"),
                    pszUserName) + 1;

    plu->uOffsetComment = plu->uOffsetCountryName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetComment), TEXT("%s's comment"),
                    pszUserName) + 1;

    plu->uOffsetIPAddress = plu->uOffsetComment+cLen;
    lstrcpy((LPTSTR)(((PBYTE)plu)+plu->uOffsetIPAddress), TEXT("125.1.100.2"));
    plu->dwFlags = 1;

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_RESOLVE_USER, uMsgID, (LPARAM)plur);
    uMsgID++;
    return S_OK;
}

HRESULT UlsLdap_EnumUserInfos (
    LPTSTR          pszServer,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    PLDAP_ENUM ple;
    PLDAP_USERINFO plu;
    LPTSTR  pszUserName;
    ULONG   uOffsetLast;
    ULONG   cLen;

    // First batch
    //
    ple = (PLDAP_ENUM)LocalAlloc(LMEM_FIXED, sizeof(*ple)+
                                             3*sizeof(LDAP_USERINFO)+
                                             3*sizeof(TCHAR)*MAX_PATH);
    ple->uSize = sizeof(*ple);
    ple->hResult = NOERROR;
    ple->cItems = 3;
    ple->uOffsetItems = ple->uSize;

    // First batch--First guy
    //
    pszUserName = c_szEnumNames_1;
    plu = (PLDAP_USERINFO)(((PBYTE)ple)+ple->uOffsetItems);
    plu->uSize = sizeof(LDAP_USERINFO);
    plu->uOffsetName = sizeof(*plu)*3;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetName), TEXT("%s"), pszUserName) + 1;

    plu->uOffsetFirstName = plu->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetFirstName), TEXT("%s_First"),
                    pszUserName) + 1;

    plu->uOffsetLastName = plu->uOffsetFirstName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetLastName), TEXT("%s_Last"),
                    pszUserName) + 1;

    plu->uOffsetEMailName = plu->uOffsetLastName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetEMailName), TEXT("%s"),
                    pszUserName) + 1;

    plu->uOffsetCityName = plu->uOffsetEMailName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCityName), TEXT("%sville"),
                    pszUserName) + 1;

    plu->uOffsetCountryName = plu->uOffsetCityName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCountryName), TEXT("%sland"),
                    pszUserName) + 1;

    plu->uOffsetComment = plu->uOffsetCountryName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetComment), TEXT("%s's comment"),
                    pszUserName) + 1;

    plu->uOffsetIPAddress = plu->uOffsetComment+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetIPAddress), TEXT("125.1.100.2"))+1;
    plu->dwFlags = 1;
    uOffsetLast = plu->uOffsetIPAddress+cLen;

    // First batch--Second guy
    //
    pszUserName += lstrlen(pszUserName)+1;
    plu = (PLDAP_USERINFO)plu+1;
    plu->uSize = sizeof(LDAP_USERINFO);
    plu->uOffsetName = uOffsetLast-sizeof(*plu);
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetName), TEXT("%s"), pszUserName) + 1;

    plu->uOffsetFirstName = plu->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetFirstName), TEXT("%s_First"),
                    pszUserName) + 1;

    plu->uOffsetLastName = plu->uOffsetFirstName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetLastName), TEXT("%s_Last"),
                    pszUserName) + 1;

    plu->uOffsetEMailName = plu->uOffsetLastName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetEMailName), TEXT("%s"),
                    pszUserName) + 1;

    plu->uOffsetCityName = plu->uOffsetEMailName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCityName), TEXT("%sville"),
                    pszUserName) + 1;

    plu->uOffsetCountryName = plu->uOffsetCityName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCountryName), TEXT("%sland"),
                    pszUserName) + 1;

    plu->uOffsetComment = plu->uOffsetCountryName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetComment), TEXT("%s's comment"),
                    pszUserName) + 1;

    plu->uOffsetIPAddress = plu->uOffsetComment+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetIPAddress), TEXT("125.2.100.2"))+1;
    plu->dwFlags = 1;
    uOffsetLast = plu->uOffsetIPAddress+cLen;

    // First batch--Third guy
    //
    pszUserName += lstrlen(pszUserName)+1;
    plu = (PLDAP_USERINFO)plu+1;
    plu->uSize = sizeof(LDAP_USERINFO);
    plu->uOffsetName = uOffsetLast-sizeof(*plu);
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetName), TEXT("%s"), pszUserName) + 1;

    plu->uOffsetFirstName = plu->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetFirstName), TEXT("%s_First"),
                    pszUserName) + 1;

    plu->uOffsetLastName = plu->uOffsetFirstName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetLastName), TEXT("%s_Last"),
                    pszUserName) + 1;

    plu->uOffsetEMailName = plu->uOffsetLastName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetEMailName), TEXT("%s"),
                    pszUserName) + 1;

    plu->uOffsetCityName = plu->uOffsetEMailName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCityName), TEXT("%sville"),
                    pszUserName) + 1;

    plu->uOffsetCountryName = plu->uOffsetCityName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCountryName), TEXT("%sland"),
                    pszUserName) + 1;

    plu->uOffsetComment = plu->uOffsetCountryName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetComment), TEXT("%s's comment"),
                    pszUserName) + 1;

    plu->uOffsetIPAddress = plu->uOffsetComment+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetIPAddress), TEXT("125.3.100.2"))+1;
    plu->dwFlags = 1;
    uOffsetLast = plu->uOffsetIPAddress+cLen;

    PostMessage(g_hwndCB, WM_ULS_ENUM_USERINFOS, uMsgID, (LPARAM)ple);

    // Second batch
    //
    ple = (PLDAP_ENUM)LocalAlloc(LMEM_FIXED, sizeof(*ple)+
                                             3*sizeof(LDAP_USERINFO)+
                                             3*sizeof(TCHAR)*MAX_PATH);
    ple->uSize = sizeof(*ple);
    ple->hResult = NOERROR;
    ple->cItems = 3;
    ple->uOffsetItems = ple->uSize;

    // Second batch--First guy
    //
    pszUserName = c_szEnumNames_2;
    plu = (PLDAP_USERINFO)(((PBYTE)ple)+ple->uOffsetItems);
    plu->uSize = sizeof(LDAP_USERINFO);
    plu->uOffsetName = sizeof(*plu)*3;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetName), TEXT("%s"), pszUserName) + 1;

    plu->uOffsetFirstName = plu->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetFirstName), TEXT("%s_First"),
                    pszUserName) + 1;

    plu->uOffsetLastName = plu->uOffsetFirstName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetLastName), TEXT("%s_Last"),
                    pszUserName) + 1;

    plu->uOffsetEMailName = plu->uOffsetLastName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetEMailName), TEXT("%s"),
                    pszUserName) + 1;

    plu->uOffsetCityName = plu->uOffsetEMailName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCityName), TEXT("%sville"),
                    pszUserName) + 1;

    plu->uOffsetCountryName = plu->uOffsetCityName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCountryName), TEXT("%sland"),
                    pszUserName) + 1;

    plu->uOffsetComment = plu->uOffsetCountryName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetComment), TEXT("%s's comment"),
                    pszUserName) + 1;

    plu->uOffsetIPAddress = plu->uOffsetComment+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetIPAddress), TEXT("125.1.100.2"))+1;
    plu->dwFlags = 1;
    uOffsetLast = plu->uOffsetIPAddress+cLen;

    // Second batch--Second guy
    //
    pszUserName += lstrlen(pszUserName)+1;
    plu = (PLDAP_USERINFO)plu+1;
    plu->uSize = sizeof(LDAP_USERINFO);
    plu->uOffsetName = uOffsetLast-sizeof(*plu);
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetName), TEXT("%s"), pszUserName) + 1;

    plu->uOffsetFirstName = plu->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetFirstName), TEXT("%s_First"),
                    pszUserName) + 1;

    plu->uOffsetLastName = plu->uOffsetFirstName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetLastName), TEXT("%s_Last"),
                    pszUserName) + 1;

    plu->uOffsetEMailName = plu->uOffsetLastName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetEMailName), TEXT("%s"),
                    pszUserName) + 1;

    plu->uOffsetCityName = plu->uOffsetEMailName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCityName), TEXT("%sville"),
                    pszUserName) + 1;

    plu->uOffsetCountryName = plu->uOffsetCityName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCountryName), TEXT("%sland"),
                    pszUserName) + 1;

    plu->uOffsetComment = plu->uOffsetCountryName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetComment), TEXT("%s's comment"),
                    pszUserName) + 1;

    plu->uOffsetIPAddress = plu->uOffsetComment+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetIPAddress), TEXT("125.2.100.2"))+1;
    plu->dwFlags = 1;
    uOffsetLast = plu->uOffsetIPAddress+cLen;

    // Second batch--Third guy
    //
    pszUserName += lstrlen(pszUserName)+1;
    plu = (PLDAP_USERINFO)plu+1;
    plu->uSize = sizeof(LDAP_USERINFO);
    plu->uOffsetName = uOffsetLast-sizeof(*plu);
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetName), TEXT("%s"), pszUserName) + 1;

    plu->uOffsetFirstName = plu->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetFirstName), TEXT("%s_First"),
                    pszUserName) + 1;

    plu->uOffsetLastName = plu->uOffsetFirstName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetLastName), TEXT("%s_Last"),
                    pszUserName) + 1;

    plu->uOffsetEMailName = plu->uOffsetLastName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetEMailName), TEXT("%s"),
                    pszUserName) + 1;

    plu->uOffsetCityName = plu->uOffsetEMailName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCityName), TEXT("%sville"),
                    pszUserName) + 1;

    plu->uOffsetCountryName = plu->uOffsetCityName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetCountryName), TEXT("%sland"),
                    pszUserName) + 1;

    plu->uOffsetComment = plu->uOffsetCountryName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetComment), TEXT("%s's comment"),
                    pszUserName) + 1;

    plu->uOffsetIPAddress = plu->uOffsetComment+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plu)+plu->uOffsetIPAddress), TEXT("125.3.100.2"))+1;
    plu->dwFlags = 1;
    uOffsetLast = plu->uOffsetIPAddress+cLen;

    PostMessage(g_hwndCB, WM_ULS_ENUM_USERINFOS, uMsgID, (LPARAM)ple);

    // Termination
    //
    PostMessage(g_hwndCB, WM_ULS_ENUM_USERINFOS, uMsgID, (LPARAM)NULL);

    pAsyncInfo->uMsgID = uMsgID;
    uMsgID++;
    return NOERROR;
}

static TCHAR c_szEnumApps[] = {TEXT("App_1") TEXT("\0")
                               TEXT("App_2") TEXT("\0")
                               TEXT("App_3") TEXT("\0")
                               TEXT("App_4") TEXT("\0\0")};
HRESULT UlsLdap_EnumApps (
    LPTSTR          pszServer,
    LPTSTR          pszUserName,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    PLDAP_ENUM ple;

    ple = (PLDAP_ENUM)LocalAlloc(LMEM_FIXED, sizeof(*ple)+sizeof(c_szEnumApps));
    ple->uSize = sizeof(*ple);
    ple->hResult = NOERROR;
    ple->cItems = 4;
    ple->uOffsetItems = ple->uSize;
    CopyMemory(((PBYTE)ple)+ple->uOffsetItems, c_szEnumApps,
               sizeof(c_szEnumApps));

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_ENUM_APPS, uMsgID, (LPARAM)ple);
    uMsgID++;
    return NOERROR;
}

static TCHAR c_szAttributes[] = {TEXT("Attr_1") TEXT("\0") TEXT("Value_1") TEXT("\0")
                                 TEXT("Attr_2") TEXT("\0") TEXT("Value_2") TEXT("\0")
                                 TEXT("Attr_3") TEXT("\0") TEXT("Value_3") TEXT("\0")};

HRESULT UlsLdap_ResolveApp (
    LPTSTR          pszServer,
    LPTSTR          pszUserName,
    LPTSTR          pszAppName,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    PLDAP_APPINFO_RES plar;
    PLDAP_APPINFO     pla;
    ULONG   cLen;

    plar = (PLDAP_APPINFO_RES)LocalAlloc(LMEM_FIXED, sizeof(*plar)+
                                         (sizeof(TCHAR)*MAX_PATH));
    plar->uSize = sizeof(*plar);
    plar->hResult = NOERROR;

    pla = &(plar->lai);
    pla->uSize = sizeof(LDAP_APPINFO);
    pla->guid = IID_IEnumULSNames;

    pla->uOffsetName = pla->uSize;
    cLen = wsprintf((LPTSTR)(((PBYTE)pla)+pla->uOffsetName), TEXT("%s"), pszAppName) + 1;

    pla->uOffsetMimeType = pla->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)pla)+pla->uOffsetMimeType), TEXT("application\\%s"),
                    pszAppName) + 1;

    pla->cAttributes = 3;
    pla->uOffsetAttributes = pla->uOffsetMimeType+cLen;
    CopyMemory((LPBYTE)(((PBYTE)pla)+pla->uOffsetAttributes),
               c_szAttributes, sizeof(c_szAttributes));

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_RESOLVE_APP, uMsgID, (LPARAM)plar);
    uMsgID++;
    return S_OK;
}

static TCHAR c_szEnumProts[] = {TEXT("Prot_1") TEXT("\0")
                               TEXT("Prot_2") TEXT("\0")
                               TEXT("Prot_3") TEXT("\0")
                               TEXT("Prot_4") TEXT("\0\0")};
HRESULT UlsLdap_EnumProtocols (
    LPTSTR          pszServer,
    LPTSTR          pszUserName,
    LPTSTR          pszAppName,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    PLDAP_ENUM ple;

    ple = (PLDAP_ENUM)LocalAlloc(LMEM_FIXED, sizeof(*ple)+sizeof(c_szEnumProts));
    ple->uSize = sizeof(*ple);
    ple->hResult = NOERROR;
    ple->cItems = 4;
    ple->uOffsetItems = ple->uSize;
    CopyMemory(((PBYTE)ple)+ple->uOffsetItems, c_szEnumProts,
               sizeof(c_szEnumProts));

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_ENUM_PROTOCOLS, uMsgID, (LPARAM)ple);
    uMsgID++;
    return NOERROR;
}

HRESULT UlsLdap_ResolveProtocol (
    LPTSTR          pszServer,
    LPTSTR          pszUserName,
    LPTSTR          pszAppName,
    LPTSTR          pszProtName,
    PLDAP_ASYNCINFO pAsyncInfo )
{
    PLDAP_PROTINFO_RES plpr;
    PLDAP_PROTINFO     plp;
    ULONG   cLen;

    plpr = (PLDAP_PROTINFO_RES)LocalAlloc(LMEM_FIXED, sizeof(*plpr)+
                                         (sizeof(TCHAR)*MAX_PATH));
    plpr->uSize = sizeof(*plpr);
    plpr->hResult = NOERROR;

    plp = &(plpr->lpi);
    plp->uSize = sizeof(LDAP_PROTINFO);
    plp->uPortNumber = 80;

    plp->uOffsetName = plp->uSize;
    cLen = wsprintf((LPTSTR)(((PBYTE)plp)+plp->uOffsetName), TEXT("%s"), pszProtName) + 1;

    plp->uOffsetMimeType = plp->uOffsetName+cLen;
    cLen = wsprintf((LPTSTR)(((PBYTE)plp)+plp->uOffsetMimeType), TEXT("protocol\\%s"),
                    pszProtName) + 1;

    plp->cAttributes = 3;
    plp->uOffsetAttributes = plp->uOffsetMimeType+cLen;
    CopyMemory((LPBYTE)(((PBYTE)plp)+plp->uOffsetAttributes),
               c_szAttributes, sizeof(c_szAttributes));

    pAsyncInfo->uMsgID = uMsgID;
    PostMessage(g_hwndCB, WM_ULS_RESOLVE_PROTOCOL, uMsgID, (LPARAM)plpr);
    uMsgID++;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\ldapsp.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		ldapsp.cpp
	Content:	This file contains the ldap service provider interface.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

// Window handle of this layer's hidden window
//
HWND g_hWndHidden = NULL;

// Window handle of the COM layer's hidden window
//
HWND g_hWndNotify = NULL;

// Internal request thread
//
HANDLE g_hReqThread = NULL;
DWORD g_dwReqThreadID = 0;

// Hidden window class
//
extern TCHAR c_szWindowClassName[];

// Global generator for response ID
//
ULONG g_uRespID = 1;

// Global
//
DWORD g_dwClientSig = 0;

// Global counter for the times of initializations
//
LONG g_cInitialized = 0;


// Internal functions prototypes
//
VOID BuildStdAttrNameArray ( VOID );
TCHAR *AddBaseToFilter ( TCHAR *, const TCHAR * );
HRESULT _EnumClientsEx ( ULONG, TCHAR *, TCHAR *, ULONG, TCHAR *, LDAP_ASYNCINFO * );



/* ----------------------------------------------------------------------
	UlsLdap_Initialize

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
   ---------------------------------------------------------------------- */

HRESULT UlsLdap_Initialize ( HWND hWndCallback )
{
	HRESULT hr;

	// Make sure this service provider is not initialized twice
	//
	if (g_cInitialized++ != 0)
		return S_OK;

	#ifdef DEBUG
	// Validate handler table
	//
	extern VOID DbgValidateHandlerTable ( VOID );
	DbgValidateHandlerTable ();
	#endif

	// Validate standard attribute name table
	//
	#ifdef DEBUG
	extern VOID DbgValidateStdAttrNameArray ( VOID );
	DbgValidateStdAttrNameArray ();
	#endif

	// Clean up the events for safe rollback
	//
	ZeroMemory (&g_ahThreadWaitFor[0], NUM_THREAD_WAIT_FOR * sizeof (HANDLE));

	// Initialize global settings via registry
	//
	if (! GetRegistrySettings ())
	{
		MyAssert (FALSE);
	}

	// Make sure the uls window handle is valid
	//
	if (! MyIsWindow (hWndCallback))
	{
		MyAssert (FALSE);
		g_cInitialized--;
		MyAssert (g_cInitialized == 0);
		return ILS_E_HANDLE;
	}

	// Cache the uls window handle
	//
	g_hWndNotify = hWndCallback;

	// Initialize ILS specifics
	//
	hr = IlsInitialize ();
	if (hr != S_OK)
		return hr;

	// Create events for inter-thread synchronization
	//
	g_fExitNow = FALSE;
	for (INT i = 0; i < NUM_THREAD_WAIT_FOR; i++)
	{	
		g_ahThreadWaitFor[i] = CreateEvent (NULL,	// no security
											FALSE,	// auto reset
											FALSE,	// not signaled initially
											NULL);	// no event name
		if (g_ahThreadWaitFor[i] == NULL)
		{
			hr = ILS_E_FAIL;
			goto MyExit;
		}
	}

	// Create an internal session container
	//
	g_pSessionContainer = new SP_CSessionContainer;
	if (g_pSessionContainer == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Initialize the internal session container
	//
	hr = g_pSessionContainer->Initialize (8, NULL);
	if (hr != S_OK)
		goto MyExit;

	// Create an internal pending request queue
	//
	g_pReqQueue = new SP_CRequestQueue;
	if (g_pReqQueue == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create an internal pending response queue
	//
	g_pRespQueue = new SP_CResponseQueue;
	if (g_pRespQueue == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create an internal refresh scheduler
	//
	g_pRefreshScheduler = new SP_CRefreshScheduler;
	if (g_pRefreshScheduler == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create the hidden window
	//
	if (! MyCreateWindow ())
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Start WSA for subsequent host query in this service provider
	//
	WSADATA WSAData;
	if (WSAStartup (MAKEWORD (1, 1), &WSAData))
	{
		hr = ILS_E_WINSOCK;
		goto MyExit;
	}

	// Create an internal hidden request thread that
	// sends request and keep alive messages
	//
	g_hReqThread = CreateThread (NULL, 0,
								ReqThread,
								NULL, 0,
								&g_dwReqThreadID);
	if (g_hReqThread == NULL)
	{
		hr = ILS_E_THREAD;
		goto MyExit;
	}

	// Everything seems successful
	//
	hr = S_OK;

MyExit:

	if (hr != S_OK)
	{
		// Something wrong, roll back
		//
		g_cInitialized--;

		for (i = 0; i < NUM_THREAD_WAIT_FOR; i++)
		{
			if (g_ahThreadWaitFor[i] != NULL)
			{
				CloseHandle (g_ahThreadWaitFor[i]);
				g_ahThreadWaitFor[i] = NULL;
			}
		}

		IlsCleanup ();

		if (g_pSessionContainer != NULL)
		{
			delete g_pSessionContainer;
			g_pSessionContainer = NULL;
		}

		if (g_pReqQueue != NULL)
		{
			delete g_pReqQueue;
			g_pReqQueue = NULL;
		}

		if (g_pRespQueue != NULL)
		{
			delete g_pRespQueue;
			g_pRespQueue = NULL;
		}

		if (g_pRefreshScheduler != NULL)
		{
			delete g_pRefreshScheduler;
			g_pRefreshScheduler = NULL;
		}

		// Unconditional call to WSACleanup() will not cause any problem
		// because it simply returns WSAEUNINITIALIZED.
		//
		WSACleanup ();

		MyAssert (g_hReqThread == NULL);
		MyAssert (g_cInitialized == 0);
	}

	return hr;
}

/* ----------------------------------------------------------------------
	UlsLdap_Deinitialize

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
   ---------------------------------------------------------------------- */

HRESULT UlsLdap_Deinitialize ( VOID )
{
	HRESULT hr = S_OK;

	// Make sure this service provider is initialized
	//
	if (--g_cInitialized != 0)
	{
		if (g_cInitialized < 0)
		{
			MyAssert (FALSE);
			g_cInitialized = 0;
			return ILS_E_NOT_INITIALIZED;
		}
		return S_OK;
	}

	// Make sure we have a valid internal hidden window handle
	//
	if (MyIsWindow (g_hWndHidden))
	{
		// Kill poll timer
		//
		KillTimer (g_hWndHidden, ID_TIMER_POLL_RESULT);

		// Destroy the hidden window
		//
		DestroyWindow (g_hWndHidden);

		// Unregister the window class
		//
		UnregisterClass (c_szWindowClassName, g_hInstance);
	}
	else
	{
		MyAssert (FALSE);
	}

	// Is the request thread alive?
	//
	if (g_hReqThread != NULL)
	{
		// Signal the request thread to exit
		//
		SetEvent (g_hevExitReqThread);
		g_fExitNow = TRUE;

		// Wait for the request thread to respond
		//
		DWORD dwResult;
		#define REQ_THREAD_EXIT_TIMEOUT		10000	// 10 seconds timeout
		ULONG tcTimeout = REQ_THREAD_EXIT_TIMEOUT;
		ULONG tcTarget = GetTickCount () + tcTimeout;
		do
		{
			dwResult = (g_hReqThread != NULL) ?
						MsgWaitForMultipleObjects (
								1,
								&g_hReqThread,
								FALSE,
								tcTimeout,
								QS_ALLINPUT) :
						WAIT_OBJECT_0;

			if (dwResult == (WAIT_OBJECT_0 + 1))
			{
				// Insure that this thread continues to respond
				//
				if (! KeepUiResponsive ())
				{
					dwResult = WAIT_TIMEOUT;
					break;
				}
			}

			// Make sure we only wait for 90 seconds totally
			//
			tcTimeout = tcTarget - GetTickCount ();
		}
		// If the thread does not exit, let's continue to wait.
		//
		while (	dwResult == (WAIT_OBJECT_0 + 1) &&
				tcTimeout <= REQ_THREAD_EXIT_TIMEOUT);

		// Make sure we propagate back the error that
		// the internal request thread is not responding
		//
		if (dwResult == WAIT_TIMEOUT)
		{
		#ifdef _DEBUG
		    DBG_REF("ULS Terminating internal thread");
		#endif
			hr = ILS_E_THREAD;
			TerminateThread (g_hReqThread, (DWORD) -1);
		}

		// Clean up the internal hidden thread descriptor
		//
		CloseHandle (g_hReqThread);
		g_hReqThread = NULL;
		g_dwReqThreadID = 0;
	} // if (g_hReqThread != NULL)

	// Clean up inter-thread synchronization
	//
	for (INT i = 0; i < NUM_THREAD_WAIT_FOR; i++)
	{
		if (g_ahThreadWaitFor[i] != NULL)
		{
			CloseHandle (g_ahThreadWaitFor[i]);
			g_ahThreadWaitFor[i] = NULL;
		}
	}

    IlsCleanup();

	// Free the internal session container
	//
	if (g_pSessionContainer != NULL)
	{
		delete g_pSessionContainer;
		g_pSessionContainer = NULL;
	}

	// Free the internal pending request queue
	//
	if (g_pReqQueue != NULL)
	{
		delete g_pReqQueue;
		g_pReqQueue = NULL;
	}

	// Free the internal pending response queue
	//
	if (g_pRespQueue != NULL)
	{
		delete g_pRespQueue;
		g_pRespQueue = NULL;
	}

	// Free the refresh scheduler object
	//
	if (g_pRefreshScheduler != NULL)
	{
		delete g_pRefreshScheduler;
		g_pRefreshScheduler = NULL;
	}

	// Unconditional call to WSACleanup() will not cause any problem
	// because it simply returns WSAEUNINITIALIZED.
	//
	WSACleanup ();

	return hr;
}


/* ----------------------------------------------------------------------
	UlsLdap_Cancel

	History:
	10/30/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

HRESULT UlsLdap_Cancel ( ULONG uMsgID )
{
	HRESULT hr = ILS_E_FAIL;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	if (g_pRespQueue == NULL || g_pReqQueue == NULL)
	{
		MyAssert (FALSE);
		return ILS_E_FAIL;
	}

	// The locking order is
	// Lock(PendingOpQueue), Lock(RequestQueue), Lock (CurrOp)
	//
	g_pRespQueue->WriteLock ();
	g_pReqQueue->WriteLock ();
	g_pReqQueue->LockCurrOp ();

	// Redirect the call to the pending op queue object
	//
	hr = g_pRespQueue->Cancel (uMsgID);
	if (hr != S_OK)
	{
		// Redirect the call to the request queue object
		//
		hr = g_pReqQueue->Cancel (uMsgID);
	}

	// Unlock is always in the reverse order of lock
	//
	g_pReqQueue->UnlockCurrOp ();
	g_pReqQueue->WriteUnlock ();
	g_pRespQueue->WriteUnlock ();

	return S_OK;
}


LPARAM
AsynReq_Cancel ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_CANCEL);

	// Delinearize parameters
	//
	ULONG uRespID = (ULONG) MarshalReq_GetParam (pReq, 0);

	// Cancelling in request queue is easy and done in UlsLdap_Cancel()
	// because the request is not sent to the server yet.
	// Cancelling in CurrOp is also easy because the request thread will
	// find out that the current request is cancelled and then can call
	// g_pRespQueue->Cancel() in the request thread (not UI thread).
	// Cancelling in pending op queue is tricky. I have to marshal it to
	// the request thread to do it. This is why AsynReq_Cancel is called!!!

	// Redirect the call to the pending op queue object
	//
	if (g_pRespQueue != NULL)
	{
		hr = g_pRespQueue->Cancel (uRespID);
	}
	else
	{
		MyAssert (FALSE);
	}

	return (LPARAM) hr;
}

/* ----------------------------------------------------------------------
	UlsLdap_RegisterClient

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
	1/14/97		Chu, Lon-Chan [lonchanc]
				Collapsed user/app objects.
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_RegisterClient (
	DWORD_PTR		dwContext,
    SERVER_INFO     *pServer,
	LDAP_CLIENTINFO	*pInfo,
	HANDLE			*phClient,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Maks sure the server name is valid
	//
	if (MyIsBadServerInfo (pServer))
		return ILS_E_POINTER;

	// Make sure the returned handle
	//
	if (phClient == NULL)
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Make sure the client info structure is valid
	//
	#ifdef STRICT_CHECK
	if (MyIsBadWritePtr (pInfo, sizeof (*pInfo)))
		return ILS_E_POINTER;
	#endif

	// Make sure the unique id is valid
	//
	TCHAR *pszCN = (TCHAR *) ((BYTE *) pInfo + pInfo->uOffsetCN);
	if (pInfo->uOffsetCN == INVALID_OFFSET || *pszCN == TEXT ('\0'))
		return ILS_E_PARAMETER;

	// Make sure no modify/remove extended attributes
	// Registration only allows ToAdd
	//
	if (pInfo->cAttrsToModify != 0 || pInfo->cAttrsToRemove != 0)
		return ILS_E_PARAMETER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cParams = 3;
	ULONG cbSize = cbServer + pInfo->uSize;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_REGISTER_CLIENT, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Create a local client object
	//
	HRESULT hr;
	SP_CClient *pClient = new SP_CClient (dwContext);
	if (pClient == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Make sure this client object will not go away unexpectedly
	//
	pClient->AddRef ();

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pInfo, pInfo->uSize);
	MarshalReq_SetParam (pReq, 2, (DWORD_PTR) pClient, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

MyExit:

	if (hr == S_OK)
	{
		*phClient = (HANDLE) pClient;
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_RegisterClient ( MARSHAL_REQ *pReq )
{
	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_REGISTER_CLIENT);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	LDAP_CLIENTINFO	*pInfo = (LDAP_CLIENTINFO *) MarshalReq_GetParam (pReq, 1);
	SP_CClient *pClient = (SP_CClient *) MarshalReq_GetParam (pReq, 2);

	// Register the client object on the server
	//
	HRESULT hr = pClient->Register (pReq->uRespID, pServer, pInfo);
	if (hr != S_OK)
	{
		// Release this newly allocated local user object
		//
		pClient->Release ();
	}

	return (LPARAM) hr;
}


/* ----------------------------------------------------------------------
	UlsLdap_RegisterProtocol

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Blocked by ILS (7438, 7442)
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_RegisterProtocol (
	HANDLE			hClient,
	LDAP_PROTINFO	*pInfo,
	HANDLE			*phProt,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Convert handle to pointer
	//
	SP_CClient *pClient = (SP_CClient *) hClient;

	// Make sure the parent local app object is valid
	//
	if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
		! pClient->IsValidObject () ||
		! pClient->IsRegistered ())
		return ILS_E_HANDLE;

	// Make sure the returned handle
	//
	if (phProt == NULL)
		return ILS_E_POINTER;

	// Make sure the prot info structure is valid
	//
	#ifdef STRICT_CHECK
	if (MyIsBadWritePtr (pInfo, sizeof (*pInfo)))
		return ILS_E_POINTER;
	#endif

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Make sure the protocol name is valid
	//
	TCHAR *pszProtName = (TCHAR *) ((BYTE *) pInfo + pInfo->uOffsetName);
	if (pInfo->uOffsetName == INVALID_OFFSET || *pszProtName == TEXT ('\0'))
		return ILS_E_PARAMETER;

	// Compute the total size of the data
	//
	ULONG cParams = 3;
	ULONG cbSize = pInfo->uSize;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_REGISTER_PROTOCOL, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Create a local prot object
	//
	SP_CProtocol *pProt = new SP_CProtocol (pClient);
	if (pProt == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Make sure the local prot object will not be deleted randomly
	//
	pProt->AddRef ();

	// Linearize parameters
	//
	MarshalReq_SetParam (pReq, 0, (DWORD_PTR) pClient, 0);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pInfo, pInfo->uSize);
	MarshalReq_SetParam (pReq, 2, (DWORD_PTR) pProt, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

MyExit:

	if (hr == S_OK)
	{
		*phProt = (HANDLE) pProt;
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_RegisterProtocol ( MARSHAL_REQ *pReq )
{
	HRESULT hr;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_REGISTER_PROTOCOL);

	// Delinearize parameters
	//
	SP_CClient *pClient = (SP_CClient *) MarshalReq_GetParam (pReq, 0);
	LDAP_PROTINFO *pInfo = (LDAP_PROTINFO *) MarshalReq_GetParam (pReq, 1);
	SP_CProtocol *pProt = (SP_CProtocol *) MarshalReq_GetParam (pReq, 2);

	// Make sure the parent local app object is valid
	//
	if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
		! pClient->IsValidObject () ||
		! pClient->IsRegistered ())
	{
		hr = ILS_E_HANDLE;
	}
	else
	{
		// Make the local prot object do prot registration
		//
		hr = pProt->Register (pReq->uRespID, pInfo);
		if (hr != S_OK)
		{
			// Release the newly allocated local prot object
			//
			pProt->Release ();
		}
	}

	return (LPARAM) hr;
}


/* ----------------------------------------------------------------------
	UlsLdap_RegisterMeeting

	Input:
		pszServer: A pointer to the server name.
		pMeetInfo: A pointer to meeting info structure.
		phMtg: A return meeting object handle.
		pAsyncInfo: A pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT
UlsLdap_RegisterMeeting (
	DWORD			dwContext,
	SERVER_INFO		*pServer,
	LDAP_MEETINFO	*pInfo,
	HANDLE			*phMtg,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Maks sure the server name is valid
	//
	if (MyIsBadServerInfo (pServer))
		return ILS_E_POINTER;

	// Make sure the returned handle
	//
	if (phMtg == NULL)
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Make sure the user info structure is valid
	//
	#ifdef STRICT_CHECK
	if (MyIsBadWritePtr (pInfo, sizeof (*pInfo)))
		return ILS_E_POINTER;
	#endif

	// Make sure the unique id is valid
	//
	TCHAR *pszName = (TCHAR *) ((BYTE *) pInfo + pInfo->uOffsetMeetingPlaceID);
	if (pInfo->uOffsetMeetingPlaceID == INVALID_OFFSET || *pszName == TEXT ('\0'))
		return ILS_E_PARAMETER;

	// Make sure no modify/remove extended attributes
	// Registration only allows ToAdd
	//
	if (pInfo->cAttrsToModify != 0 || pInfo->cAttrsToRemove != 0)
		return ILS_E_PARAMETER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cParams = 3;
	ULONG cbSize = cbServer + pInfo->uSize;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_REGISTER_MEETING, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Create a local user object
	//
	SP_CMeeting *pMtg = new SP_CMeeting (dwContext);
	if (pMtg == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Make sure this local user object will not go away randomly
	//
	pMtg->AddRef ();

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD) pInfo, pInfo->uSize);
	MarshalReq_SetParam (pReq, 2, (DWORD) pMtg, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

MyExit:

	if (hr == S_OK)
	{
		*phMtg = (HANDLE) pMtg;
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_RegisterMeeting ( MARSHAL_REQ *pReq )
{
	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_REGISTER_MEETING);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	LDAP_MEETINFO *pInfo = (LDAP_MEETINFO *) MarshalReq_GetParam (pReq, 1);
	SP_CMeeting *pMtg = (SP_CMeeting *) MarshalReq_GetParam (pReq, 2);

	// Make the local meeting object do meeting registration
	//
	HRESULT hr = pMtg->Register (pReq->uRespID, pServer, pInfo);
	if (hr != S_OK)
	{
		// Release this newly allocated local user object
		//
		pMtg->Release ();
	}

	return (LPARAM) hr;
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_UnRegisterClient

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
	1/14/97		Chu, Lon-Chan [lonchanc]
				Collapsed user/app objects.
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_UnRegisterClient (
	HANDLE			hClient,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Convert handle to pointer
	//
	SP_CClient *pClient = (SP_CClient *) hClient;

	// Make sure the local client object is valid
	//
	if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
		! pClient->IsValidObject () ||
		! pClient->IsRegistered ())
		return ILS_E_HANDLE;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cParams = 1;
	ULONG cbSize = 0;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_UNREGISTER_CLIENT, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParam (pReq, 0, (DWORD_PTR) pClient, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_UnRegisterClient ( MARSHAL_REQ *pReq )
{
	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_UNREGISTER_CLIENT);

	// Delinearize parameters
	//
	SP_CClient *pClient = (SP_CClient *) MarshalReq_GetParam (pReq, 0);

	// Make sure the local client object is valid
	//
	HRESULT hr;
	if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
		! pClient->IsValidObject () ||
		! pClient->IsRegistered ())
	{
		// When submitting this request, the client object is fine
		// but now it is not, so it must have been unregistered and released.
		//
		MyAssert (FALSE); // to see if any one tries to break it this way!!!
		hr = S_OK;
	}
	else
	{
		// Make the client object do user unregistration
		//
		hr = pClient->UnRegister (pReq->uRespID);

		// Free this client object
		//
		pClient->Release ();
	}

	return (LPARAM) hr;
}

/* ----------------------------------------------------------------------
	UlsLdap_UnRegisterProtocol

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
   ---------------------------------------------------------------------- */

HRESULT UlsLdap_VirtualUnRegisterProtocol ( HANDLE hProt )
{
	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Convert handle to pointer
	//
	SP_CProtocol *pProt = (SP_CProtocol *) hProt;

	// Make sure the local prot object is valid
	//
	if (MyIsBadWritePtr (pProt, sizeof (*pProt)))
		return ILS_E_HANDLE;

	// Free this local prot object
	//
	pProt->Release ();

    return S_OK;
}

HRESULT UlsLdap_UnRegisterProtocol (
	HANDLE			hProt,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Convert handle to pointer
	//
	SP_CProtocol *pProt = (SP_CProtocol *) hProt;

	// Make sure the local prot object is valid
	//
	if (MyIsBadWritePtr (pProt, sizeof (*pProt)) ||
		! pProt->IsValidObject () ||
		! pProt->IsRegistered ())
		return ILS_E_HANDLE;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cParams = 1;
	ULONG cbSize = 0;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_UNREGISTER_PROTOCOL, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParam (pReq, 0, (DWORD_PTR) pProt, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_UnRegisterProt ( MARSHAL_REQ *pReq )
{
	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_UNREGISTER_PROTOCOL);

	// Delinearize parameters
	//
	SP_CProtocol *pProt = (SP_CProtocol *) MarshalReq_GetParam (pReq, 0);

	// Make sure the local prot object is valid
	//
	HRESULT hr;
	if (MyIsBadWritePtr (pProt, sizeof (*pProt)) ||
		! pProt->IsValidObject () ||
		! pProt->IsRegistered ())
	{
		// When submitting this request, the client object is fine
		// but now it is not, so it must have been unregistered and released.
		//
		MyAssert (FALSE); // to see if any one tries to break it this way!!!
		hr = S_OK;
	}
	else
	{
		// Make the local prot object do prot unregistration
		//
		hr = pProt->UnRegister (pReq->uRespID);

		// Free this local prot object
		//
		pProt->Release ();
	}

	return (LPARAM) hr;
}


/* ----------------------------------------------------------------------
	UlsLdap_UnRegisterMeeting

	Input:
		pszServer: server name.
		hMeeting: a handle to the meeting object.
		pAsyncInfo: a pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT UlsLdap_UnRegisterMeeting (
	HANDLE			hMtg,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Convert handle to pointer
	//
	SP_CMeeting *pMtg = (SP_CMeeting *) hMtg;

	// Make sure the local user object is valid
	//
	if (MyIsBadWritePtr (pMtg, sizeof (*pMtg)) ||
		! pMtg->IsValidObject () ||
		! pMtg->IsRegistered ())
		return ILS_E_HANDLE;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cParams = 1;
	ULONG cbSize = 0;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_UNREGISTER_MEETING, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParam (pReq, 0, (DWORD) pMtg, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_UnRegisterMeeting ( MARSHAL_REQ *pReq )
{
	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_UNREGISTER_MEETING);

	// Delinearize parameters
	//
	SP_CMeeting *pMtg = (SP_CMeeting *) MarshalReq_GetParam (pReq, 0);

	// Make sure the local user object is valid
	//
	HRESULT hr;
	if (MyIsBadWritePtr (pMtg, sizeof (*pMtg)) ||
		! pMtg->IsValidObject () ||
		! pMtg->IsRegistered ())
	{
		// When submitting this request, the client object is fine
		// but now it is not, so it must have been unregistered and released.
		//
		MyAssert (FALSE); // to see if any one tries to break it this way!!!
		hr = S_OK;
	}
	else
	{
		// Make the local user object do user unregistration
		//
		hr = pMtg->UnRegister (pReq->uRespID);

		// Free this local user object
		//
		pMtg->Release ();
	}

	return (LPARAM) hr;
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_SetClientInfo

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
	1/14/97		Chu, Lon-Chan [lonchanc]
				Collapsed user/app objects.
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_SetClientInfo (
	HANDLE			hClient,
	LDAP_CLIENTINFO	*pInfo,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Convert handle to pointer
	//
	SP_CClient *pClient = (SP_CClient *) hClient;

	// Make sure the client object is valid
	//
	if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
		! pClient->IsValidObject () ||
		! pClient->IsRegistered ())
		return ILS_E_HANDLE;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Make sure the user info structure is valid
	//
	#ifdef STRICT_CHECK
	if (MyIsBadWritePtr (pInfo, sizeof (*pInfo)))
		return ILS_E_POINTER;
	#endif

	// We should not change the app name here
	//
	if (pInfo->uOffsetAppName != INVALID_OFFSET || pInfo->uOffsetCN != INVALID_OFFSET)
		return ILS_E_PARAMETER; // ILS_E_READ_ONLY;

	// lonchanc: BUGS
	// ISBU requires us to block any change of components of dn
	//
	pInfo->uOffsetCountryName = 0;

	// Compute the total size of the data
	//
	ULONG cParams = 2;
	ULONG cbSize = pInfo->uSize;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_SET_CLIENT_INFO, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParam (pReq, 0, (DWORD_PTR) pClient, 0);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pInfo, pInfo->uSize);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_SetClientInfo ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_SET_CLIENT_INFO);

	// Delinearize parameters
	//
	SP_CClient *pClient = (SP_CClient *) MarshalReq_GetParam (pReq, 0);
	LDAP_CLIENTINFO *pInfo = (LDAP_CLIENTINFO *) MarshalReq_GetParam (pReq, 1);

	// Make sure the local client object is valid
	//
	if (MyIsBadWritePtr (pClient, sizeof (*pClient)) ||
		! pClient->IsValidObject () ||
		! pClient->IsRegistered ())
	{
		// When submitting this request, the client object is fine
		// but now it is not, so it must have been unregistered and released.
		//
		MyAssert (FALSE); // to see if any one tries to break it this way!!!
		hr = ILS_E_HANDLE;
	}
	else
	{
		// Set standard attributes
		//
		hr = pClient->SetAttributes (pReq->uRespID, pInfo);
	}

	return (LPARAM) hr;
}


/* ----------------------------------------------------------------------
	UlsLdap_SetProtocolInfo

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Blocked by ILS (7438, 7442)
   ---------------------------------------------------------------------- */

HRESULT UlsLdap_SetProtocolInfo (
	HANDLE			hProt,
	LDAP_PROTINFO	*pInfo,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Convert handle to pointer
	//
	SP_CProtocol *pProt = (SP_CProtocol *) hProt;

	// Make sure the local prot object is valid
	//
	if (MyIsBadWritePtr (pProt, sizeof (*pProt)) ||
		! pProt->IsValidObject () ||
		! pProt->IsRegistered ())
		return ILS_E_HANDLE;

	// Make sure the prot info structure is valid
	//
	#ifdef STRICT_CHECK
	if (MyIsBadWritePtr (pInfo, sizeof (*pInfo)))
		return ILS_E_POINTER;
	#endif

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cParams = 2;
	ULONG cbSize = pInfo->uSize;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_SET_PROTOCOL_INFO, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParam (pReq, 0, (DWORD_PTR) pProt, 0);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pInfo, pInfo->uSize);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_SetProtocolInfo ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_SET_PROTOCOL_INFO);

	// Delinearize parameters
	//
	SP_CProtocol *pProt = (SP_CProtocol *) MarshalReq_GetParam (pReq, 0);
	LDAP_PROTINFO *pInfo = (LDAP_PROTINFO *) MarshalReq_GetParam (pReq, 1);

	// Make sure the local client object is valid
	//
	if (MyIsBadWritePtr (pProt, sizeof (*pProt)) ||
		! pProt->IsValidObject () ||
		! pProt->IsRegistered ())
	{
		// When submitting this request, the client object is fine
		// but now it is not, so it must have been unregistered and released.
		//
		MyAssert (FALSE); // to see if any one tries to break it this way!!!
		hr = ILS_E_HANDLE;
	}
	else
	{
		// Set standard attributes
		//
		hr = pProt->SetAttributes (pReq->uRespID, pInfo);
	}

	return (LPARAM) hr;
}


/* ----------------------------------------------------------------------
	UlsLdap_SetMeetingInfo

	Input:
		pszServer: A server name.
		pszMtgName: A meeting id string.
		pMeetInfo: A pointer to meeting info structure.
		pAsyncInfo: A pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT UlsLdap_SetMeetingInfo (
	SERVER_INFO		*pServer,
	TCHAR			*pszMtgName,
	LDAP_MEETINFO	*pInfo,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Make sure we have valid pointers
	//
	if (MyIsBadServerInfo (pServer) || MyIsBadString (pszMtgName))
		return ILS_E_POINTER;

	// Make sure the app info structure is valid
	//
	#ifdef STRICT_CHECK
	if (MyIsBadWritePtr (pInfo, sizeof (*pInfo)))
		return ILS_E_POINTER;
	#endif

	// Make sure we do not change meeting name
	//
	if (pInfo->uOffsetMeetingPlaceID != 0)
		return ILS_E_PARAMETER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeMtgName = (lstrlen (pszMtgName) + 1) * sizeof (TCHAR);
	ULONG cParams = 3;
	ULONG cbSize = cbServer + cbSizeMtgName + pInfo->uSize;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_SET_MEETING_INFO, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD) pszMtgName, cbSizeMtgName);
	MarshalReq_SetParam (pReq, 2, (DWORD) pInfo, pInfo->uSize);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_SetMeetingInfo ( MARSHAL_REQ *pReq )
{
	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_SET_MEETING_INFO);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszMtgName = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	LDAP_MEETINFO *pInfo = (LDAP_MEETINFO *) MarshalReq_GetParam (pReq, 2);

	MyAssert (! MyIsBadServerInfo (pServer));
	MyAssert (MyIsGoodString (pszMtgName));
	MyAssert (! MyIsBadWritePtr (pInfo, pInfo->uSize));

	// Set standard/arbitrary attributes
	//
	return (LPARAM) MtgSetAttrs (pServer, pszMtgName, pInfo, pReq->uRespID);
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	My_EnumClientsEx

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
	1/14/97		Chu, Lon-Chan [lonchanc]
				Collapsed user/app objects.
   ---------------------------------------------------------------------- */

HRESULT
My_EnumClientsEx (
	ULONG			uNotifyMsg,
	SERVER_INFO		*pServer,
	TCHAR			*pszAnyAttrNameList,
	ULONG			cAnyAttrNames,
	TCHAR			*pszFilter,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure we only deal with the following messages
	//
	MyAssert (	uNotifyMsg == WM_ILS_ENUM_CLIENTINFOS ||
				uNotifyMsg == WM_ILS_ENUM_CLIENTS);

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Maks sure the server name is valid
	//
	if (MyIsBadServerInfo (pServer))
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeAnyAttrNames = 0;
	TCHAR *psz = pszAnyAttrNameList;
	ULONG cch;
	for (ULONG i = 0; i < cAnyAttrNames; i++)
	{
		cch = lstrlen (psz) + 1;
		cbSizeAnyAttrNames += cch * sizeof (TCHAR);
		psz += cch;
	}
	ULONG cbSizeFilter = (pszFilter != NULL) ? (lstrlen (pszFilter) + 1) * sizeof (TCHAR) : 0;
	ULONG cParams = 4;
	ULONG cbSize = cbServer + cbSizeAnyAttrNames + cbSizeFilter;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (uNotifyMsg, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pszAnyAttrNameList, cbSizeAnyAttrNames);
	MarshalReq_SetParam (pReq, 2, (DWORD) cAnyAttrNames, 0);
	MarshalReq_SetParam (pReq, 3, (DWORD_PTR) pszFilter, cbSizeFilter);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_EnumClientsEx ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	ULONG uNotifyMsg = pReq->uNotifyMsg;

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszAnyAttrNameList = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	ULONG cAnyAttrNames = (ULONG) MarshalReq_GetParam (pReq, 2);
	TCHAR *pszFilter = (TCHAR *) MarshalReq_GetParam (pReq, 3);

	// Clean locals
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;

	// Create an array of names of attributes to return
	//
	TCHAR *apszAttrNames[COUNT_ENUM_DIR_CLIENT_INFO+1];
	TCHAR **ppszNameList = &apszAttrNames[0];
	ULONG cTotalNames;

	// See the input filter string
	//
	if (pszFilter != NULL)
	{
		MyDebugMsg ((ZONE_FILTER, "EC: in-filter=[%s]\r\n", pszFilter));
	}

	// Create a enum client filter
	//
	pszFilter = AddBaseToFilter (pszFilter, STR_DEF_CLIENT_BASE_DN);
	if (pszFilter == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// See the enhanced filter string
	//
	if (pszFilter != NULL)
	{
		MyDebugMsg ((ZONE_FILTER, "EC: out-filter=[%s]\r\n", pszFilter));
	}

	// Ask directory standard attributes only if enum client info
	//
	if (uNotifyMsg == WM_ILS_ENUM_CLIENTINFOS)
	{
		// Default total number of attributes
		//
		cTotalNames = COUNT_ENUM_DIR_CLIENT_INFO;

		// Do we want any extended attribute to be returned?
		//
		if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
		{
			// Prefix arbitrary attribute names
			//
			pszAnyAttrNameList = IlsPrefixNameValueArray (FALSE, cAnyAttrNames,
										(const TCHAR *) pszAnyAttrNameList);
			if (pszAnyAttrNameList == NULL)
			{
				MemFree (pszFilter);
				hr = ILS_E_MEMORY;
				goto MyExit;
			}

			// Allocate memory for returned attributes' names
			//
			cTotalNames += cAnyAttrNames;
			ppszNameList = (TCHAR **) MemAlloc (sizeof (TCHAR *) * (cTotalNames + 1));
			if (ppszNameList == NULL)
			{
				MemFree (pszFilter);
				MemFree (pszAnyAttrNameList);
				hr = ILS_E_MEMORY;
				goto MyExit;
			}
		}
	}
	else
	{
		cTotalNames = 1;
	}

	// Ask to return cn only if enum names only
	//
	ppszNameList[0] = STR_CLIENT_CN;

	// Add names of standard/extended attributes to return
	//
	if (uNotifyMsg == WM_ILS_ENUM_CLIENTINFOS)
	{
		// Set up standard attribtues now
		//
		for (ULONG i = 1; i < COUNT_ENUM_DIR_CLIENT_INFO; i++)
		{
			ppszNameList[i] = (TCHAR *) c_apszClientStdAttrNames[i];
		}

		// Set arbitrary attribute names if needed
		//
		TCHAR *psz = pszAnyAttrNameList;
		for (i = COUNT_ENUM_DIR_CLIENT_INFO; i < cTotalNames; i++)
		{
			ppszNameList[i] = psz;
			psz += lstrlen (psz) + 1;
		}
	}

	// Terminate the list
	//
	ppszNameList[cTotalNames] = NULL;

	// Get a session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, pServer);
	if (hr == S_OK)
	{
		// Get an ldap session
		//
		MyAssert (pSession != NULL);
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Update options in ld
		//
		ld->ld_sizelimit = 0;	// no limit in the num of entries to return
		ld->ld_timelimit = 0;	// no limit on the time to spend on the search
		ld->ld_deref = LDAP_DEREF_ALWAYS;

		// Send search query
		//
		uMsgID = ldap_search (	ld,
								STR_DEF_CLIENT_BASE_DN, // base DN
								LDAP_SCOPE_BASE, // scope
								pszFilter, // filter
								ppszNameList, // attrs[]
								0);	// both type and value
		if (uMsgID == -1)
		{
			// This ldap_search failed.
			// Convert ldap error code to hr
			//
			hr = ::LdapError2Hresult (ld->ld_errno);

			// Free the session object
			//
			pSession->Disconnect ();
		}
	}

	// Free the filter string
	//
	MemFree (pszFilter);

	// Free the buffer holding all returned attribute names if needed
	//
	if (ppszNameList != &apszAttrNames[0])
		MemFree (ppszNameList);

	// Report failure if so
	//
	if (hr != S_OK)
	{
		// Free extended attribute name list
		//
		if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
			MemFree (pszAnyAttrNameList);

		// Report failure
		//
		goto MyExit;
	}

	// Construct a pending info structure
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, pReq->uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = uNotifyMsg;
	ri.cAnyAttrs = cAnyAttrNames;
	ri.pszAnyAttrNameList = pszAnyAttrNameList;

	// Queue this pending response
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		// Abort the ldap_search
		//
		ldap_abandon (ld, uMsgID);

		// Free the session object
		//
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

MyExit:

	LDAP_ENUM *pEnum = NULL;
	if (hr != S_OK)
	{
		pEnum = (LDAP_ENUM *) MemAlloc (sizeof (LDAP_ENUM));
		if (pEnum != NULL)
		{
			pEnum->uSize = sizeof (*pEnum);
			pEnum->hResult = hr;
		}
	}

	return (LPARAM) pEnum;
}


/* ----------------------------------------------------------------------
	UlsLdap_EnumClients

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
	1/14/97		Chu, Lon-Chan [lonchanc]
				Collapsed user/app objects.
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_EnumClients (
	SERVER_INFO		*pServer,
	TCHAR			*pszFilter,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	// Dispatch the call to a common subroutine
	//
	return My_EnumClientsEx (WM_ILS_ENUM_CLIENTS,
							pServer,
							NULL,
							0,
							pszFilter,
							pAsyncInfo);
}


/* ----------------------------------------------------------------------
	UlsLdap_EnumClientInfos

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
	1/14/97		Chu, Lon-Chan [lonchanc]
				Collapsed user/app objects.
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_EnumClientInfos (
	SERVER_INFO		*pServer,
	TCHAR			*pszAnyAttrNameList,
	ULONG			cAnyAttrNames,
	TCHAR			*pszFilter,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	// Dispatch the call to a common subroutine
	//
	return My_EnumClientsEx (WM_ILS_ENUM_CLIENTINFOS,
							pServer,
							pszAnyAttrNameList,
							cAnyAttrNames,
							pszFilter,
							pAsyncInfo);
}


/* ----------------------------------------------------------------------
	UlsLdap_EnumProtocols

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Blocked by ILS (7438, 7442)
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_EnumProtocols (
	SERVER_INFO		*pServer,
	TCHAR			*pszUserName,
	TCHAR			*pszAppName,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	if (MyIsBadServerInfo (pServer) || MyIsBadString (pszUserName) ||
		MyIsBadString (pszAppName))
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeUserName = (lstrlen (pszUserName) + 1) * sizeof (TCHAR);
	ULONG cbSizeAppName = (lstrlen (pszAppName) + 1) * sizeof (TCHAR);
	ULONG cParams = 3;
	ULONG cbSize = cbServer + cbSizeUserName + cbSizeAppName;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_ENUM_PROTOCOLS, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pszUserName, cbSizeUserName);
	MarshalReq_SetParam (pReq, 2, (DWORD_PTR) pszAppName, cbSizeAppName);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_EnumProtocols ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_ENUM_PROTOCOLS);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszUserName = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	TCHAR *pszAppName = (TCHAR *) MarshalReq_GetParam (pReq, 2);

	// Create enum protocols filter
	//
	TCHAR *pszFilter = ProtCreateEnumFilter (pszUserName, pszAppName);
	if (pszFilter == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Get the session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, pServer);
	if (hr != S_OK)
	{
		MemFree (pszFilter);
		goto MyExit;
	}
	MyAssert (pSession != NULL);

	// Get an ldap session
	//
	ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// Create an array of names of attributes to return
	//
	TCHAR *apszAttrNames[2];
	apszAttrNames[0] = (TCHAR *) c_apszProtStdAttrNames[ENUM_PROTATTR_NAME];
	apszAttrNames[1] = NULL;

	// Update options in ld
	//
	ld->ld_sizelimit = 0;	// no limit in the num of entries to return
	ld->ld_timelimit = 0;	// no limit on the time to spend on the search
	ld->ld_deref = LDAP_DEREF_ALWAYS;

	// Send the search query
	//
	uMsgID = ldap_search (ld, (TCHAR *) &c_szDefClientBaseDN[0],	// base DN
									LDAP_SCOPE_BASE,	// scope
									pszFilter,
									&apszAttrNames[0],	// attrs[]
									0);	// both type and value
	// Free the search filter
	//
	MemFree (pszFilter);

	// Check the return of ldap_search
	//
	if (uMsgID == -1)
	{
		// This ldap_search failed.
		// Convert ldap error code to hr
		//
		hr = ::LdapError2Hresult (ld->ld_errno);

		// Free the session object
		//
		pSession->Disconnect ();
		goto MyExit;
	}

	// Construct a pending info structure
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, pReq->uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_ENUM_PROTOCOLS;

	// Queue this pending response
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		// Abort the ldap_search
		//
		ldap_abandon (ld, uMsgID);

		// Free the session object
		//
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

MyExit:

	LDAP_ENUM *pEnum = NULL;
	if (hr != S_OK)
	{
		pEnum = (LDAP_ENUM *) MemAlloc (sizeof (LDAP_ENUM));
		if (pEnum != NULL)
		{
			pEnum->uSize = sizeof (*pEnum);
			pEnum->hResult = hr;
		}
	}

	return (LPARAM) pEnum;
}


/* ----------------------------------------------------------------------
	My_EnumMtgsEx

	Input:
		uNotifyMsg: A notification message.
		pszServer: A pointer to the server name.
		pszFilter: A pointer to a filter string.
		pAsyncInfo: A pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT
My_EnumMtgsEx (
	ULONG			uNotifyMsg,
	SERVER_INFO		*pServer,
	TCHAR			*pszAnyAttrNameList,
	ULONG			cAnyAttrNames,
	TCHAR			*pszFilter,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure we only deal with the following messages
	//
	MyAssert (	uNotifyMsg == WM_ILS_ENUM_MEETINGINFOS ||
				uNotifyMsg == WM_ILS_ENUM_MEETINGS);

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Maks sure the server name is valid
	//
	if (MyIsBadServerInfo (pServer))
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeAnyAttrNames = 0;
	TCHAR *psz = pszAnyAttrNameList;
	ULONG cch;
	for (ULONG i = 0; i < cAnyAttrNames; i++)
	{
		cch = lstrlen (psz) + 1;
		cbSizeAnyAttrNames += cch * sizeof (TCHAR);
		psz += cch;
	}
	ULONG cbSizeFilter = (pszFilter != NULL) ? (lstrlen (pszFilter) + 1) * sizeof (TCHAR) : 0;
	ULONG cParams = 4;
	ULONG cbSize = cbServer + cbSizeAnyAttrNames + cbSizeFilter;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (uNotifyMsg, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD) pszAnyAttrNameList, cbSizeAnyAttrNames);
	MarshalReq_SetParam (pReq, 2, (DWORD) cAnyAttrNames, 0);
	MarshalReq_SetParam (pReq, 3, (DWORD) pszFilter, cbSizeFilter);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_EnumMtgsEx ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	ULONG uNotifyMsg = pReq->uNotifyMsg;

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszAnyAttrNameList = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	ULONG cAnyAttrNames = (ULONG) MarshalReq_GetParam (pReq, 2);
	TCHAR *pszFilter = (TCHAR *) MarshalReq_GetParam (pReq, 3);

	// Clean locals
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;

	// Create an array of names of attributes to return
	//
	TCHAR *apszAttrNames[COUNT_ENUM_DIRMTGINFO+1];
	TCHAR **ppszNameList = &apszAttrNames[0];
	ULONG cTotalNames;

	// See the input filter string
	//
	if (pszFilter != NULL)
	{
		MyDebugMsg ((ZONE_FILTER, "EU: in-filter=[%s]\r\n", pszFilter));
	}

	// Create a enum user filter
	//
	pszFilter = AddBaseToFilter (pszFilter, &c_szDefMtgBaseDN[0]);
	if (pszFilter == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// See the enhanced filter string
	//
	if (pszFilter != NULL)
	{
		MyDebugMsg ((ZONE_FILTER, "EU: out-filter=[%s]\r\n", pszFilter));
	}

	// Ask directory standard attributes only if enum dir user info
	//
	if (uNotifyMsg == WM_ILS_ENUM_MEETINGINFOS)
	{
		// Default total number of attributes
		//
		cTotalNames = COUNT_ENUM_DIRMTGINFO;

		// Do we want any extended attribute to be returned?
		//
		if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
		{
			// Prefix arbitrary attribute names
			//
			pszAnyAttrNameList = IlsPrefixNameValueArray (FALSE, cAnyAttrNames,
													(const TCHAR *) pszAnyAttrNameList);
			if (pszAnyAttrNameList == NULL)
			{
				MemFree (pszFilter);
				hr = ILS_E_MEMORY;
				goto MyExit;
			}

			// Allocate memory for returned attributes' names
			//
			cTotalNames += cAnyAttrNames;
			ppszNameList = (TCHAR **) MemAlloc (sizeof (TCHAR *) * (cTotalNames + 1));
			if (ppszNameList == NULL)
			{
				MemFree (pszFilter);
				MemFree (pszAnyAttrNameList);
				hr = ILS_E_MEMORY;
				goto MyExit;
			}
		}
	}
	else
	{
		cTotalNames = 1;
	}

	// Ask to return cn only if enum names only
	//
	ppszNameList[0] = STR_MTG_NAME;

	// Add names of standard/extended attributes to return
	//
	if (uNotifyMsg == WM_ILS_ENUM_MEETINGINFOS)
	{
		// Set up standard attribtues now
		//
		for (ULONG i = 1; i < COUNT_ENUM_DIRMTGINFO; i++)
		{
			ppszNameList[i] = (TCHAR *) c_apszMtgStdAttrNames[i];
		}

		// Set arbitrary attribute names if needed
		//
		TCHAR *psz = pszAnyAttrNameList;
		for (i = COUNT_ENUM_DIRMTGINFO; i < cTotalNames; i++)
		{
			ppszNameList[i] = psz;
			psz += lstrlen (psz) + 1;
		}
	}

	// Terminate the list
	//
	ppszNameList[cTotalNames] = NULL;

	// Get a session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, pServer);
	if (hr == S_OK)
	{
		// Get an ldap session
		//
		MyAssert (pSession != NULL);
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Update options in ld
		//
		ld->ld_sizelimit = 0;	// no limit in the num of entries to return
		ld->ld_timelimit = 0;	// no limit on the time to spend on the search
		ld->ld_deref = LDAP_DEREF_ALWAYS;

		// Send search query
		//
		uMsgID = ldap_search (ld, (TCHAR *) &c_szDefMtgBaseDN[0],	// base DN
									LDAP_SCOPE_BASE,	// scope
									pszFilter,	// filter
									ppszNameList,	// attrs[]
									0);	// both type and value
		if (uMsgID == -1)
		{
			// This ldap_search failed.
			// Convert ldap error code to hr
			//
			hr = ::LdapError2Hresult (ld->ld_errno);

			// Free the session object
			//
			pSession->Disconnect ();
		}
	}

	// Free the filter string
	//
	MemFree (pszFilter);

	// Free the buffer holding all returned attribute names if needed
	//
	if (ppszNameList != &apszAttrNames[0])
		MemFree (ppszNameList);

	// Report failure if so
	//
	if (hr != S_OK)
	{
		// Free extended attribute name list
		//
		if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
			MemFree (pszAnyAttrNameList);

		// Report failure
		//
		goto MyExit;
	}

	// Construct a pending info structure
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, pReq->uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = uNotifyMsg;
	ri.cAnyAttrs = cAnyAttrNames;

	// Queue this pending response
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		// Abort the ldap_search
		//
		ldap_abandon (ld, uMsgID);

		// Free the session object
		//
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

MyExit:

	LDAP_ENUM *pEnum = NULL;
	if (hr != S_OK)
	{
		pEnum = (LDAP_ENUM *) MemAlloc (sizeof (LDAP_ENUM));
		if (pEnum != NULL)
		{
			pEnum->uSize = sizeof (*pEnum);
			pEnum->hResult = hr;
		}
	}

	return (LPARAM) pEnum;
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_EnumMeetingInfos

	Input:
		pszServer: server name.
		pszFilter: a filter string.
		pAsyncInfo: a pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT
UlsLdap_EnumMeetingInfos (
	SERVER_INFO		*pServer,
	TCHAR			*pszAnyAttrNameList,
	ULONG			cAnyAttrNames,
	TCHAR			*pszFilter,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	// Dispatch the call to a common subroutine
	//
	return My_EnumMtgsEx (WM_ILS_ENUM_MEETINGINFOS,
						pServer,
						pszAnyAttrNameList,
						cAnyAttrNames,
						pszFilter,
						pAsyncInfo);
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_EnumMeetings

	Input:
		pszServer: server name.
		pszFilter: a filter string.
		pAsyncInfo: a pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT
UlsLdap_EnumMeetings (
	SERVER_INFO		*pServer,
	TCHAR			*pszFilter,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Dispatch the call to a common subroutine
	//
	return My_EnumMtgsEx (WM_ILS_ENUM_MEETINGS,
						pServer,
						NULL,
						0,
						pszFilter,
						pAsyncInfo);
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_EnumAttendee

	Input:
		pszServer: server name.
		pszMeetingID: a meeting id string.
		pszFilter: a filter string.
		pAsyncInfo: a pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT
UlsLdap_EnumAttendees(
	SERVER_INFO		*pServer,
	TCHAR			*pszMtgName,
	TCHAR			*pszFilter,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	if (MyIsBadServerInfo (pServer) || MyIsBadString (pszMtgName))
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeMtgName = (lstrlen (pszMtgName) + 1) * sizeof (TCHAR);
	ULONG cbSizeFilter = (pszFilter != NULL) ? (lstrlen (pszFilter) + 1) * sizeof (TCHAR) : 0;
	ULONG cParams = 3;
	ULONG cbSize = cbServer + cbSizeMtgName + cbSizeFilter;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_ENUM_ATTENDEES, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD) pszMtgName, cbSizeMtgName);
	MarshalReq_SetParam (pReq, 2, (DWORD) pszFilter, cbSizeFilter);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_EnumAttendees ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_ENUM_ATTENDEES);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszMtgName = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	TCHAR *pszFilter = (TCHAR *) MarshalReq_GetParam (pReq, 2);

	// Clean up locals
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;

	// BUGS: ignore the input filter
	//
	pszFilter = MtgCreateEnumMembersFilter (pszMtgName);
	if (pszFilter == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create an array of names of attributes to return
	//
	TCHAR *apszAttrNames[3];
	apszAttrNames[0] = STR_MTG_NAME;
	apszAttrNames[1] = (TCHAR *) c_apszMtgStdAttrNames[ENUM_MTGATTR_MEMBERS];
	apszAttrNames[2] = NULL;

	// Get the session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, pServer);
	if (hr != S_OK)
	{
		MemFree (pszFilter);
		goto MyExit;
	}
	MyAssert (pSession != NULL);

	// Get an ldap session
	//
	ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// Update options in ld
	//
	ld->ld_sizelimit = 0;	// no limit in the num of entries to return
	ld->ld_timelimit = 0;	// no limit on the time to spend on the search
	ld->ld_deref = LDAP_DEREF_ALWAYS;

	// Send the search query
	//
	uMsgID = ldap_search (ld, (TCHAR *) &c_szDefMtgBaseDN[0],	// base DN
						LDAP_SCOPE_BASE,	// scope
						pszFilter,
						&apszAttrNames[0],	// attrs[]
						0);	// both type and value

	// Free the search filter
	//
	MemFree (pszFilter);

	// Check the return of ldap_search
	//
	if (uMsgID == -1)
	{
		// This ldap_search failed.
		// Convert ldap error code to hr
		//
		hr = ::LdapError2Hresult (ld->ld_errno);

		// Free the session object
		//
		pSession->Disconnect ();
		goto MyExit;
	}

	// Construct a pending info structure
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, pReq->uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_ENUM_ATTENDEES;

	// Queue this pending response
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		// Abort the ldap_search
		//
		ldap_abandon (ld, uMsgID);

		// Free the session object
		//
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

MyExit:

	LDAP_ENUM *pEnum = NULL;
	if (hr != S_OK)
	{
		pEnum = (LDAP_ENUM *) MemAlloc (sizeof (LDAP_ENUM));
		if (pEnum != NULL)
		{
			pEnum->uSize = sizeof (*pEnum);
			pEnum->hResult = hr;
		}
	}

	return (LPARAM) pEnum;
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_ResolveClient

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Tested on ILS (7438)
	1/14/97		Chu, Lon-Chan [lonchanc]
				Collapsed user/app objects.
   ---------------------------------------------------------------------- */

HRESULT
UlsLdap_ResolveClient (
	SERVER_INFO		*pServer,
	TCHAR			*pszCN,
	TCHAR			*pszAppName,
	TCHAR			*pszProtName,
	TCHAR			*pszAnyAttrNameList,
	ULONG			cAnyAttrNames,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Maks sure the server name is valid
	//
	if (MyIsBadServerInfo (pServer))
		return ILS_E_POINTER;

	// Maks sure the user name is valid
	//
	if (MyIsBadString (pszCN))
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeCN = (lstrlen (pszCN) + 1) * sizeof (TCHAR);
	ULONG cbSizeAppName = (pszAppName != NULL) ? (lstrlen (pszAppName) + 1) * sizeof (TCHAR) : 0;
	ULONG cbSizeProtName = (pszProtName != NULL) ? (lstrlen (pszProtName) + 1) * sizeof (TCHAR) : 0;
	ULONG cbSizeAnyAttrNames = 0;
	TCHAR *psz = pszAnyAttrNameList;
	ULONG cch;
	for (ULONG i = 0; i < cAnyAttrNames; i++)
	{
		cch = lstrlen (psz) + 1;
		cbSizeAnyAttrNames += cch * sizeof (TCHAR);
		psz += cch;
	}
	ULONG cParams = 6;
	ULONG cbSize =  cbServer + cbSizeCN + cbSizeAppName + cbSizeProtName + cbSizeAnyAttrNames;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_RESOLVE_CLIENT, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pszCN, cbSizeCN);
	MarshalReq_SetParam (pReq, 2, (DWORD_PTR) pszAppName, cbSizeAppName);
	MarshalReq_SetParam (pReq, 3, (DWORD_PTR) pszProtName, cbSizeProtName);
	MarshalReq_SetParam (pReq, 4, (DWORD_PTR) pszAnyAttrNameList, cbSizeAnyAttrNames);
	MarshalReq_SetParam (pReq, 5, (DWORD) cAnyAttrNames, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_ResolveClient ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_RESOLVE_CLIENT);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszCN = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	TCHAR *pszAppName = (TCHAR *) MarshalReq_GetParam (pReq, 2);
	TCHAR *pszProtName = (TCHAR *) MarshalReq_GetParam (pReq, 3);
	TCHAR *pszAnyAttrNameList = (TCHAR *) MarshalReq_GetParam (pReq, 4);
	ULONG cAnyAttrNames = (ULONG) MarshalReq_GetParam (pReq, 5);

	// Create a resolve client filter
	//
	TCHAR *pszFilter = ClntCreateResolveFilter (pszCN, pszAppName, pszProtName);
	if (pszFilter == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create an array of names of attributes to return
	//
	TCHAR *apszAttrNames[COUNT_ENUM_RES_CLIENT_INFO+1];
	TCHAR **ppszNameList;
	ppszNameList = &apszAttrNames[0];
	ULONG cTotalNames;
	cTotalNames = COUNT_ENUM_RES_CLIENT_INFO;
	if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
	{
		// Prefix arbitrary attribute names
		//
		pszAnyAttrNameList = IlsPrefixNameValueArray (FALSE, cAnyAttrNames,
									(const TCHAR *) pszAnyAttrNameList);
		if (pszAnyAttrNameList == NULL)
		{
			MemFree (pszFilter);
			hr = ILS_E_MEMORY;
			goto MyExit;
		}

		// NOTE that pszAnyAttrNameList must be freed if failed in this routine
		// If success, it will be freed in notification.

		// Allocate memory for keeping returned attributes' names
		//
		cTotalNames += cAnyAttrNames;
		ppszNameList = (TCHAR **) MemAlloc (sizeof (TCHAR *) * (cTotalNames + 1));
		if (ppszNameList == NULL)
		{
			MemFree (pszFilter);
			MemFree (pszAnyAttrNameList);
			hr = ILS_E_MEMORY;
			goto MyExit;
		}
	}

	// Set standard attribute names
	//
	ULONG i;
	for (i = 0; i < COUNT_ENUM_RES_CLIENT_INFO; i++)
	{
		ppszNameList[i] = (TCHAR *) c_apszClientStdAttrNames[i];
	}

	// Set arbitrary attribute names if needed
	//
	TCHAR *psz;
	psz = pszAnyAttrNameList;
	for (i = COUNT_ENUM_RES_CLIENT_INFO; i < cTotalNames; i++)
	{
		ppszNameList[i] = psz;
		psz += lstrlen (psz) + 1;
	}

	// Terminate the list
	//
	ppszNameList[cTotalNames] = NULL;

	// Get the session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, pServer);
	if (hr == S_OK)
	{
		// Get an ldap session
		//
		MyAssert (pSession != NULL);
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Update options in ld
		//
		ld->ld_sizelimit = 0;	// no limit in the num of entries to return
		ld->ld_timelimit = 0;	// no limit on the time to spend on the search
		ld->ld_deref = LDAP_DEREF_ALWAYS;

		// Send the search query
		//
		uMsgID = ldap_search (	ld,
								(TCHAR *) &c_szDefClientBaseDN[0], // base DN
								LDAP_SCOPE_BASE, // scope
								pszFilter, // filter
								ppszNameList, // attrs[]
								0); // both type and value
		if (uMsgID == -1)
		{
			// This ldap_search failed.
			// Convert ldap error code to hr
			//
			hr = ::LdapError2Hresult (ld->ld_errno);
			MyAssert (hr != S_OK);

			// Free the session object
			//
			pSession->Disconnect ();
		}
	}

	// Free the filter string
	//
	MemFree (pszFilter);

	// Free the buffer holding all returned attribute names if needed
	//
	if (ppszNameList != &apszAttrNames[0])
		MemFree (ppszNameList);

	// If failed, exit with cleanup
	//
	if (hr != S_OK)
	{
		// Free extended attribute names list if needed
		//
		if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
			MemFree (pszAnyAttrNameList);

		// Report failure
		//
		goto MyExit;
	}

	// Construct a pending info structure
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, pReq->uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_RESOLVE_CLIENT;
	ri.cAnyAttrs = cAnyAttrNames;
	ri.pszAnyAttrNameList = pszAnyAttrNameList;

	// Queue this pending response
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		// Abort the ldap_search
		//
		ldap_abandon (ld, uMsgID);

		// Free the session object
		//
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

MyExit:

	LDAP_CLIENTINFO_RES *pcir = NULL;
	if (hr != S_OK)
	{
		pcir = (LDAP_CLIENTINFO_RES *) MemAlloc (sizeof (LDAP_CLIENTINFO_RES));
		if (pcir != NULL)
		{
			pcir->uSize = sizeof (*pcir);
			pcir->hResult = hr;
		}
	}

	return (LPARAM) pcir;
}


/* ----------------------------------------------------------------------
	UlsLdap_ResolveProtocol

	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.
	10/30/96	Chu, Lon-Chan [lonchanc]
				Blocked by ILS (7438, 7442)
   ---------------------------------------------------------------------- */

HRESULT UlsLdap_ResolveProtocol (
	SERVER_INFO		*pServer,
	TCHAR			*pszUserName,
	TCHAR			*pszAppName,
	TCHAR			*pszProtName,
	TCHAR			*pszAnyAttrNameList,
	ULONG			cAnyAttrNames,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	if (MyIsBadServerInfo (pServer)  || MyIsBadString (pszUserName) ||
		MyIsBadString (pszAppName) || MyIsBadString (pszProtName) ||
		pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeUserName = (lstrlen (pszUserName) + 1) * sizeof (TCHAR);
	ULONG cbSizeAppName = (lstrlen (pszAppName) + 1) * sizeof (TCHAR);
	ULONG cbSizeProtName = (lstrlen (pszProtName) + 1) * sizeof (TCHAR);
	ULONG cbSizeAnyAttrNames = 0;
	TCHAR *psz = pszAnyAttrNameList;
	ULONG cch;
	for (ULONG i = 0; i < cAnyAttrNames; i++)
	{
		cch = lstrlen (psz) + 1;
		cbSizeAnyAttrNames += cch * sizeof (TCHAR);
		psz += cch;
	}
	ULONG cParams = 6;
	ULONG cbSize =  cbServer + cbSizeUserName + cbSizeAppName +
					cbSizeProtName + cbSizeAnyAttrNames;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_RESOLVE_PROTOCOL, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD_PTR) pszUserName, cbSizeUserName);
	MarshalReq_SetParam (pReq, 2, (DWORD_PTR) pszAppName, cbSizeAppName);
	MarshalReq_SetParam (pReq, 3, (DWORD_PTR) pszProtName, cbSizeProtName);
	MarshalReq_SetParam (pReq, 4, (DWORD_PTR) pszAnyAttrNameList, cbSizeAnyAttrNames);
	MarshalReq_SetParam (pReq, 5, (DWORD) cAnyAttrNames, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_ResolveProtocol ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_RESOLVE_PROTOCOL);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszUserName = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	TCHAR *pszAppName = (TCHAR *) MarshalReq_GetParam (pReq, 2);
	TCHAR *pszProtName = (TCHAR *) MarshalReq_GetParam (pReq, 3);
	TCHAR *pszAnyAttrNameList = (TCHAR *) MarshalReq_GetParam (pReq, 4);
	ULONG cAnyAttrNames = (ULONG) MarshalReq_GetParam (pReq, 5);

	TCHAR *pszFilter = NULL;

	// Duplicate the protocol name to resolve
	//
	TCHAR *pszProtNameToResolve = My_strdup (pszProtName);
	if (pszProtNameToResolve == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create a resolve client filter
	//
	pszFilter = ProtCreateResolveFilter (pszUserName, pszAppName, pszProtName);
	if (pszFilter == NULL)
	{
		MemFree (pszProtNameToResolve);
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create an array of names of attributes to return
	//
	TCHAR *apszAttrNames[COUNT_ENUM_PROTATTR+1];
	TCHAR **ppszNameList;
	ppszNameList = &apszAttrNames[0];
	ULONG cTotalNames;
	cTotalNames = COUNT_ENUM_PROTATTR;
	if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
	{
		// Prefix arbitrary attribute names
		//
		pszAnyAttrNameList = IlsPrefixNameValueArray (FALSE, cAnyAttrNames,
												(const TCHAR *) pszAnyAttrNameList);
		if (pszAnyAttrNameList == NULL)
		{
			MemFree (pszProtNameToResolve);
			MemFree (pszFilter);
			hr = ILS_E_MEMORY;
			goto MyExit;
		}

		// Allocate memory for returned attributes' names
		//
		cTotalNames += cAnyAttrNames;
		ppszNameList = (TCHAR **) MemAlloc (sizeof (TCHAR *) * (cTotalNames + 1));
		if (ppszNameList == NULL)
		{
			MemFree (pszProtNameToResolve);
			MemFree (pszFilter);
			MemFree (pszAnyAttrNameList);
			hr = ILS_E_MEMORY;
			goto MyExit;
		}
	}

	// Set standard attribute names
	//
	ULONG i;
	for (i = 0; i < COUNT_ENUM_PROTATTR; i++)
	{
		ppszNameList[i] = (TCHAR *) c_apszProtStdAttrNames[i];
	}

	// Set arbitrary attribute names if needed
	//
	TCHAR *psz;
	psz = pszAnyAttrNameList;
	for (i = COUNT_ENUM_PROTATTR; i < cTotalNames; i++)
	{
		ppszNameList[i] = psz;
		psz += lstrlen (psz) + 1;
	}

	// Terminate the list
	//
	ppszNameList[cTotalNames] = NULL;

	// Get the session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, pServer);
	if (hr == S_OK)
	{
		// Get an ldap session
		//
		MyAssert (pSession != NULL);
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Update options in ld
		//
		ld->ld_sizelimit = 0;	// no limit in the num of entries to return
		ld->ld_timelimit = 0;	// no limit on the time to spend on the search
		ld->ld_deref = LDAP_DEREF_ALWAYS;

		// Send the search query
		//
		uMsgID = ldap_search (ld, (TCHAR *) &c_szDefClientBaseDN[0],	// base DN
									LDAP_SCOPE_BASE,	// scope
									pszFilter,
									ppszNameList,	// attrs[]
									0);	// both type and value
		if (uMsgID == -1)
		{
			// This ldap_search failed.
			// Convert ldap error code to hr
			//
			hr = ::LdapError2Hresult (ld->ld_errno);
			MyAssert (hr != S_OK);

			// Free the session object
			//
			pSession->Disconnect ();
		}
	}

	// Free the filter string
	//
	MemFree (pszFilter);

	// Free the buffer holding all returned attribute names if needed
	//
	if (ppszNameList != &apszAttrNames[0])
		MemFree (ppszNameList);

	// If failed, exit with cleanup
	//
	if (hr != S_OK)
	{
		// Free duplicated protocol name
		//
		MemFree (pszProtNameToResolve);

		// Free extended attribute names list if needed
		//
		if (cAnyAttrNames != 0)
			MemFree (pszAnyAttrNameList);

		// Report failure
		//
		goto MyExit;
	}

	// Construct a pending info structure
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, pReq->uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_RESOLVE_PROTOCOL;
	ri.cAnyAttrs = cAnyAttrNames;
	ri.pszAnyAttrNameList = pszAnyAttrNameList;
	ri.pszProtNameToResolve = pszProtNameToResolve;

	// Queue this pending response
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		// Free duplicated protocol name
		//
		MemFree (pszProtNameToResolve);

		// Free extended attribute names list if needed
		//
		if (cAnyAttrNames != 0)
			MemFree (pszAnyAttrNameList);

		// Abort the ldap_search
		//
		ldap_abandon (ld, uMsgID);

		// Free the session object
		//
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

MyExit:

	LDAP_PROTINFO_RES *ppir = NULL;
	if (hr != S_OK)
	{
		ppir = (LDAP_PROTINFO_RES *) MemAlloc (sizeof (LDAP_PROTINFO_RES));
		if (ppir != NULL)
		{
			ppir->uSize = sizeof (*ppir);
			ppir->hResult = hr;
		}
	}

	return (LPARAM) ppir;
}


/* ----------------------------------------------------------------------
	UlsLdap_ResolveMeeting

	Input:
		pszServer: A server name.
		pszMeetingID: A meeting id string.
		pszAnyAttrName: A pointer to a series of strings.
		cAnyAttrNames: A count of strings in the series.
		pAsyncInfo: a pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT UlsLdap_ResolveMeeting (
	SERVER_INFO		*pServer,
	TCHAR			*pszMtgName,
	TCHAR			*pszAnyAttrNameList,
	ULONG			cAnyAttrNames,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	if (MyIsBadServerInfo (pServer) || MyIsBadString (pszMtgName))
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeMtgName = (lstrlen (pszMtgName) + 1) * sizeof (TCHAR);
	ULONG cbSizeAnyAttrNames = 0;
	TCHAR *psz = pszAnyAttrNameList;
	ULONG cch;
	for (ULONG i = 0; i < cAnyAttrNames; i++)
	{
		cch = lstrlen (psz) + 1;
		cbSizeAnyAttrNames += cch * sizeof (TCHAR);
		psz += cch;
	}
	ULONG cParams = 4;
	ULONG cbSize =  cbServer + cbSizeMtgName + cbSizeAnyAttrNames;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (WM_ILS_RESOLVE_MEETING, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD) pszMtgName, cbSizeMtgName);
	MarshalReq_SetParam (pReq, 2, (DWORD) pszAnyAttrNameList, cbSizeAnyAttrNames);
	MarshalReq_SetParam (pReq, 3, (DWORD) cAnyAttrNames, 0);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_ResolveMeeting ( MARSHAL_REQ *pReq )
{
	HRESULT hr = S_OK;
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;

	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (pReq->uNotifyMsg == WM_ILS_RESOLVE_MEETING);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszMtgName = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	TCHAR *pszAnyAttrNameList = (TCHAR *) MarshalReq_GetParam (pReq, 2);
	ULONG cAnyAttrNames = (ULONG) MarshalReq_GetParam (pReq, 3);

	// Create a resolve client filter
	//
	TCHAR *pszFilter = MtgCreateResolveFilter (pszMtgName);
	if (pszFilter == NULL)
	{
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Create an array of names of attributes to return
	//
	TCHAR *apszAttrNames[COUNT_ENUM_MTGATTR+1];
	TCHAR **ppszNameList;
	ppszNameList = &apszAttrNames[0];
	ULONG cTotalNames;
	cTotalNames = COUNT_ENUM_MTGATTR;
	if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
	{
		// Prefix arbitrary attribute names
		//
		pszAnyAttrNameList = IlsPrefixNameValueArray (FALSE, cAnyAttrNames,
												(const TCHAR *) pszAnyAttrNameList);
		if (pszAnyAttrNameList == NULL)
		{
			MemFree (pszFilter);
			hr = ILS_E_MEMORY;
			goto MyExit;
		}

		// Allocate memory for returned attributes' names
		//
		cTotalNames += cAnyAttrNames;
		ppszNameList = (TCHAR **) MemAlloc (sizeof (TCHAR *) * (cTotalNames + 1));
		if (ppszNameList == NULL)
		{
			MemFree (pszFilter);
			MemFree (pszAnyAttrNameList);
			hr = ILS_E_MEMORY;
			goto MyExit;
		}
	}

	// Set standard attribute names
	//
	ULONG i;
	for (i = 0; i < COUNT_ENUM_MTGATTR; i++)
	{
		ppszNameList[i] = (TCHAR *) c_apszMtgStdAttrNames[i];
	}

	// Set arbitrary attribute names if needed
	//
	TCHAR *psz;
	psz = pszAnyAttrNameList;
	for (i = COUNT_ENUM_MTGATTR; i < cTotalNames; i++)
	{
		ppszNameList[i] = psz;
		psz += lstrlen (psz) + 1;
	}

	// Terminate the list
	//
	ppszNameList[cTotalNames] = NULL;

	// Get the session object
	//
	hr = g_pSessionContainer->GetSession (&pSession, pServer);
	if (hr == S_OK)
	{
		// Get an ldap session
		//
		MyAssert (pSession != NULL);
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Update options in ld
		//
		ld->ld_sizelimit = 0;	// no limit in the num of entries to return
		ld->ld_timelimit = 0;	// no limit on the time to spend on the search
		ld->ld_deref = LDAP_DEREF_ALWAYS;

		// Send the search query
		//
		uMsgID = ldap_search (ld, (TCHAR *) &c_szDefMtgBaseDN[0],	// base DN
									LDAP_SCOPE_BASE,	// scope
									pszFilter,
									ppszNameList,	// attrs[]
									0);	// both type and value
		if (uMsgID == -1)
		{
			// This ldap_search failed.
			// Convert ldap error code to hr
			//
			hr = ::LdapError2Hresult (ld->ld_errno);
			MyAssert (hr != S_OK);

			// Free the session object
			//
			pSession->Disconnect ();
		}
	}

	// Free the filter string
	//
	MemFree (pszFilter);

	// Free the buffer holding all returned attribute names if needed
	//
	if (ppszNameList != &apszAttrNames[0])
		MemFree (ppszNameList);

	// If failed, exit with cleanup
	//
	if (hr != S_OK)
	{
		// Free extended attribute names list if needed
		//
		if (pszAnyAttrNameList != NULL && cAnyAttrNames != 0)
			MemFree (pszAnyAttrNameList);

		// Report failure
		//
		goto MyExit;
	}

	// Construct a pending info structure
	//
	RESP_INFO ri;
	FillDefRespInfo (&ri, pReq->uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_RESOLVE_MEETING;
	ri.cAnyAttrs = cAnyAttrNames;
	ri.pszAnyAttrNameList = pszAnyAttrNameList;

	// Queue this pending response
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		// Abort the ldap_search
		//
		ldap_abandon (ld, uMsgID);

		// Free the session object
		//
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

MyExit:

	LDAP_MEETINFO_RES *pmir = NULL;
	if (hr != S_OK)
	{
		pmir = (LDAP_MEETINFO_RES *) MemAlloc (sizeof (LDAP_MEETINFO_RES));
		if (pmir != NULL)
		{
			pmir->uSize = sizeof (*pmir);
			pmir->hResult = hr;
		}
	}

	return (LPARAM) pmir;
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_AddAttendee

	Input:
		pszServer: server name.
		pszMeetingID: a meeting id string.
		pszAttendeeID: an attendee id string.
		pAsyncInfo: a pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT My_UpdateAttendees (
	ULONG			uNotifyMsg,
	SERVER_INFO		*pServer,
	TCHAR			*pszMtgName,
	ULONG			cMembers,
	TCHAR			*pszMemberNames,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	HRESULT hr;

	MyAssert (	uNotifyMsg == WM_ILS_ADD_ATTENDEE ||
				uNotifyMsg == WM_ILS_REMOVE_ATTENDEE);

	// Make sure this service provider is initialized
	//
	if (g_cInitialized <= 0)
		return ILS_E_NOT_INITIALIZED;

	// Make sure we there are members to add
	//
	if (cMembers == 0)
		return ILS_E_PARAMETER;

	// Make sure we have valid pointers
	//
	if (MyIsBadServerInfo (pServer) || MyIsBadString (pszMtgName) ||
		MyIsBadString (pszMemberNames))
		return ILS_E_POINTER;

	// Make sure the async info structure is valid
	//
	if (pAsyncInfo == NULL)
		return ILS_E_POINTER;

	// Compute the total size of the data
	//
	ULONG cbServer = IlsGetLinearServerInfoSize (pServer);
	ULONG cbSizeMtgName = (lstrlen (pszMtgName) + 1) * sizeof (TCHAR);
	ULONG cbSizeMemberNames = 0;
	TCHAR *psz = pszMemberNames;
	for (ULONG i = 0; i < cMembers; i++)
	{
		ULONG cchName = lstrlen (psz) + 1;
		cbSizeMemberNames += cchName * sizeof (TCHAR);
		psz += cchName;
	}
	ULONG cParams = 4;
	ULONG cbSize =  cbServer + cbSizeMtgName + cbSizeMemberNames;

	// Allocate marshall request buffer
	//
	MARSHAL_REQ *pReq = MarshalReq_Alloc (uNotifyMsg, cbSize, cParams);
	if (pReq == NULL)
		return ILS_E_MEMORY;

	// Get the response ID
	//
	ULONG uRespID = pReq->uRespID;

	// Linearize parameters
	//
	MarshalReq_SetParamServer (pReq, 0, pServer, cbServer);
	MarshalReq_SetParam (pReq, 1, (DWORD) pszMtgName, cbSizeMtgName);
	MarshalReq_SetParam (pReq, 2, (DWORD) cMembers, 0);
	MarshalReq_SetParam (pReq, 3, (DWORD) pszMemberNames, cbSizeMemberNames);

	// Enter the request
	//
	if (g_pReqQueue != NULL)
	{
		hr = g_pReqQueue->Enter (pReq);
	}
	else
	{
		MyAssert (FALSE);
		hr = ILS_E_FAIL;
	}

	if (hr == S_OK)
	{
		pAsyncInfo->uMsgID = uRespID;
	}
	else
	{
		MemFree (pReq);
	}

	return hr;
}


LPARAM
AsynReq_UpdateAttendees ( MARSHAL_REQ *pReq )
{
	MyAssert (GetCurrentThreadId () == g_dwReqThreadID);

	MyAssert (pReq != NULL);
	MyAssert (	pReq->uNotifyMsg == WM_ILS_ADD_ATTENDEE ||
				pReq->uNotifyMsg == WM_ILS_REMOVE_ATTENDEE);

	// Delinearize parameters
	//
	SERVER_INFO *pServer = (SERVER_INFO *) MarshalReq_GetParam (pReq, 0);
	TCHAR *pszMtgName = (TCHAR *) MarshalReq_GetParam (pReq, 1);
	ULONG cMembers = (ULONG) MarshalReq_GetParam (pReq, 2);
	TCHAR *pszMemberNames = (TCHAR *) MarshalReq_GetParam (pReq, 3);

	// Set standard attributes
	//
	return (LPARAM) MtgUpdateMembers (pReq->uNotifyMsg,
									pServer,
									pszMtgName,
									cMembers,
									pszMemberNames,
									pReq->uRespID);
}
#endif // ENABLE_MEETING_PLACE



#ifdef ENABLE_MEETING_PLACE
HRESULT UlsLdap_AddAttendee(
	SERVER_INFO		*pServer,
	TCHAR			*pszMtgName,
	ULONG			cMembers,
	TCHAR			*pszMemberNames,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	return My_UpdateAttendees (	WM_ILS_ADD_ATTENDEE,
								pServer,
								pszMtgName,
								cMembers,
								pszMemberNames,
								pAsyncInfo);
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_RemoveAttendee

	Input:
		pszServer: server name.
		pszMeetingID: a meeting id string.
		pszAttendeeID: an attendee id string.
		pAsyncInfo: a pointer to async info structure.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

#ifdef ENABLE_MEETING_PLACE
HRESULT UlsLdap_RemoveAttendee(
	SERVER_INFO		*pServer,
	TCHAR			*pszMtgName,
	ULONG			cMembers,
	TCHAR			*pszMemberNames,
	LDAP_ASYNCINFO	*pAsyncInfo )
{
	return My_UpdateAttendees (	WM_ILS_REMOVE_ATTENDEE,
								pServer,
								pszMtgName,
								cMembers,
								pszMemberNames,
								pAsyncInfo);
}
#endif // ENABLE_MEETING_PLACE


/* ----------------------------------------------------------------------
	UlsLdap_GetStdAttrNameString

	Input:
		StdName: a standard attribute index.

	History:
	12/02/96	Chu, Lon-Chan [lonchanc]
				Created.
   ---------------------------------------------------------------------- */

typedef struct
{
	#ifdef DEBUG
	LONG		nIndex;
	#endif
	const TCHAR	**ppszName;
}
	ATTR_NAME_ENTRY;


const ATTR_NAME_ENTRY c_aAttrNameTbl[ILS_NUM_OF_STDATTRS] =
{
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_NULL,
		#endif
		NULL
	},

	// User standard attribute names
	//
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_USER_ID,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_CN]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_IP_ADDRESS,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_IP_ADDRESS]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_EMAIL_NAME,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_EMAIL_NAME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_FIRST_NAME,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_FIRST_NAME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_LAST_NAME,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_LAST_NAME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_CITY_NAME,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_CITY_NAME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_COUNTRY_NAME,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_C]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_COMMENT,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_COMMENT]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_FLAGS,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_FLAGS]
	},

	// Application standard attribute names
	//
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_APP_NAME,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_APP_NAME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_APP_MIME_TYPE,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_APP_MIME_TYPE]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_APP_GUID,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_APP_GUID]
	},

	// Protocol standard attribute names
	//
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_PROTOCOL_NAME,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_PROT_NAME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_PROTOCOL_MIME_TYPE,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_PROT_MIME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_PROTOCOL_PORT,
		#endif
		&c_apszClientStdAttrNames[ENUM_CLIENTATTR_PROT_PORT]
	},

#ifdef ENABLE_MEETING_PLACE
	// Meeting place attribute names
	//
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_MEETING_ID,
		#endif
		&c_apszMtgStdAttrNames[ENUM_MTGATTR_CN]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_MEETING_HOST_NAME,
		#endif
		&c_apszMtgStdAttrNames[ENUM_MTGATTR_HOST_NAME]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_MEETING_HOST_IP_ADDRESS,
		#endif
		&c_apszMtgStdAttrNames[ENUM_MTGATTR_IP_ADDRESS]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_MEETING_DESCRIPTION,
		#endif
		&c_apszMtgStdAttrNames[ENUM_MTGATTR_DESCRIPTION]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_MEETING_TYPE,
		#endif
		&c_apszMtgStdAttrNames[ENUM_MTGATTR_MTG_TYPE]
	},
	{
		#ifdef DEBUG
		(LONG) ILS_STDATTR_ATTENDEE_TYPE,
		#endif
		&c_apszMtgStdAttrNames[ENUM_MTGATTR_MEMBER_TYPE]
	},
#endif // ENABLE_MEETING_PLACE
};


const TCHAR *UlsLdap_GetStdAttrNameString ( ILS_STD_ATTR_NAME StdName )
{
	ULONG nIndex = (LONG) StdName;

	MyAssert (((LONG) ILS_STDATTR_NULL < nIndex) && (nIndex < (LONG) ILS_NUM_OF_STDATTRS));

	return *(c_aAttrNameTbl[nIndex].ppszName);
}


#ifdef DEBUG
VOID DbgValidateStdAttrNameArray ( VOID )
{
	MyAssert (ARRAY_ELEMENTS (c_aAttrNameTbl) == ILS_NUM_OF_STDATTRS);

	for (LONG i = 0; i < ILS_NUM_OF_STDATTRS; i++)
	{
		if (i == c_aAttrNameTbl[i].nIndex)
		{
			if (i != ILS_STDATTR_NULL &&
				My_lstrlen (*(c_aAttrNameTbl[i].ppszName)) == 0)
			{
				MyAssert (FALSE);
			}
		}
		else
		{
			MyAssert (FALSE);
			break;
		}
	}
}
#endif



/* =============== helper functions =============== */

const TCHAR g_szShowEntries[] = TEXT ("(cn=");
const INT g_nLengthShowEntries = ARRAY_ELEMENTS (g_szShowEntries) - 1;
const TCHAR g_szShowAllEntries[] = TEXT ("(cn=*)");
const INT g_nShowAllEntries = ARRAY_ELEMENTS (g_szShowAllEntries) - 1;

TCHAR *AddBaseToFilter ( TCHAR *pszFilter, const TCHAR *pszDefBase )
{
	MyAssert (pszDefBase != NULL);

	// Calculate the size for "(&(objectclass=RTPerson)())"
	//
	ULONG cbSize = (lstrlen (pszDefBase) + 8 + g_nShowAllEntries) * sizeof (TCHAR);

	// Look through the filter string to figure out that
	// will this string shows entries???
	//
	TCHAR *pszShowEntries = (TCHAR *) &g_szShowAllEntries[0];
	if (pszFilter != NULL)
	{
		for (TCHAR *psz = pszFilter; *psz != TEXT ('\0'); psz = CharNext (psz))
		{
			if (lstrlen (psz) > g_nLengthShowEntries)
			{
				TCHAR ch = psz[g_nLengthShowEntries]; // remember
				psz[g_nLengthShowEntries] = TEXT ('\0');

				INT nCmp = lstrcmpi (psz, &g_szShowEntries[0]);
				psz[g_nLengthShowEntries] = ch; // restore
				if (nCmp == 0)
				{
					// Matched
					//
					pszShowEntries = STR_EMPTY;
					break;
				}
			}
			else
			{
				// It is impossible to match it
				//
				break;
			}
		}
	}

	// If the filter is null, then only provide "(objectclass=RTPerson)"
	//
	if (pszFilter != NULL)
		cbSize += lstrlen (pszFilter) * sizeof (TCHAR);

	// Allocate new memory for filter
	//
	TCHAR *pszNewFilter = (TCHAR *) MemAlloc (cbSize);
	if (pszNewFilter != NULL)
	{
		wsprintf (pszNewFilter, TEXT ("(&(%s)%s"), pszDefBase, pszShowEntries);
		TCHAR *psz = pszNewFilter + lstrlen (pszNewFilter);

		if (pszFilter != NULL)
		{
			wsprintf (psz, (*pszFilter == TEXT ('(')) ? TEXT ("%s") : TEXT ("(%s)"),
							pszFilter);
		}
		lstrcat (psz, TEXT (")"));

		// Go through the filter and convert '*' to '%'
		//
		for (psz = pszNewFilter; *psz != TEXT ('\0'); psz = CharNext (psz))
		{
			if (*psz == TEXT ('*'))
				*psz = TEXT ('%');
		}
	}

	return pszNewFilter;
}


















=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\localprt.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       localprt.h
//  Content:    This file contains the LocalProtocol object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _CLOCALPROT_H_
#define _CLOCALPROT_H_

#include "connpt.h"

//****************************************************************************
// Enumeration type
//****************************************************************************
//
typedef enum {
    ILS_PROT_SET_ATTRIBUTES,
    ILS_PROT_REMOVE_ATTRIBUTES,
}   PROT_CHANGE_ATTRS;

//****************************************************************************
// CIls definition
//****************************************************************************
//
class CLocalProt : public IIlsProtocol,
                   public IConnectionPointContainer 
{
private:
    LONG                    m_cRef;
    BOOL                    m_fReadonly;
    HANDLE					m_hProt;
    LPTSTR                  m_pszUser;
    LPTSTR                  m_pszApp;
    LPTSTR                  m_szName;
    ULONG                   m_uPort;
    LPTSTR                  m_szMimeType;
    CAttributes             *m_pAttrs;
    CConnectionPoint        *m_pConnPt;

	// server object
	CIlsServer				*m_pIlsServer;

    // Private method
    //
    STDMETHODIMP    NotifySink (void *pv, CONN_NOTIFYPROC pfn);

public:
    // Constructor and destructor
    CLocalProt (void);
    ~CLocalProt (void);
    STDMETHODIMP    Init (BSTR bstrName, ULONG uPort, BSTR bstrMimeType);
    STDMETHODIMP            Init (CIlsServer *pIlsServer,
                                  LPTSTR szUserName,
                                  LPTSTR szAppName,
                                  PLDAP_PROTINFO ppi);

    // Internal methods
    STDMETHODIMP    IsSameAs (CLocalProt *pProtocol);
    STDMETHODIMP    GetProtocolInfo (PLDAP_PROTINFO *ppProtInfo);
	VOID			SetProviderHandle ( HANDLE hProt ) { m_hProt = hProt; };
	HANDLE			GetProviderHandle ( VOID ) { return m_hProt; };

    // Asynchronous response handler
    //

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IIlsLocalProtocol
    STDMETHODIMP IsWritable(
                BOOL *pValue);

    STDMETHODIMP GetPortNumber(ULONG *pulPortNumber);

    STDMETHODIMP GetStandardAttribute(
            ILS_STD_ATTR_NAME  enumUlsStdAttr,
            BSTR *pbstrName);

    STDMETHODIMP SetStandardAttribute(
            ILS_STD_ATTR_NAME  enumUlsStdAttr,
            BSTR pbstrName);

    STDMETHODIMP Update ( ULONG *puReqID );

    STDMETHODIMP GetExtendedAttribute ( BSTR bstrName, BSTR *pbstrValue );
    STDMETHODIMP SetExtendedAttribute ( BSTR bstrName, BSTR bstrValue );
    STDMETHODIMP RemoveExtendedAttribute ( BSTR bstrName );
    STDMETHODIMP GetAllExtendedAttributes ( IIlsAttributes **ppAttributes );

    // IConnectionPointContainer
    STDMETHODIMP    EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
    STDMETHODIMP    FindConnectionPoint(REFIID riid,
                                        IConnectionPoint **ppcp);
};


#endif //_CLOCALPROT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\localprt.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       localprt.cpp
//  Content:    This file contains the LocalProtocol object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "localprt.h"
#include "attribs.h"
#include "callback.h"
#include "culs.h"

//****************************************************************************
// Event Notifiers
//****************************************************************************
//
//****************************************************************************
// Class Implementation
//****************************************************************************
//
//****************************************************************************
// CLocalProt::CLocalProt (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CLocalProt::CLocalProt (void)
:m_cRef (0),
 m_fReadonly (FALSE),
 m_hProt (NULL),
 m_szName (NULL),
 m_uPort (0),
 m_szMimeType (NULL),
 m_pAttrs (NULL),
 m_pConnPt (NULL),
 m_pIlsServer (NULL),
 m_pszUser (NULL),
 m_pszApp (NULL)
{
}

//****************************************************************************
// CLocalProt::~CLocalProt (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CLocalProt::~CLocalProt (void)
{
    // Release the connection point
    //
    if (m_pConnPt != NULL)
    {
        m_pConnPt->ContainerReleased();
        ((IConnectionPoint*)m_pConnPt)->Release();
    };

    // Release the attributes object
    //
    if (m_pAttrs != NULL)
    {
        m_pAttrs->Release();
    };

    // Release the buffer resources
    //
    ::MemFree (m_szName);
    ::MemFree (m_szMimeType);
    ::MemFree (m_pszUser);
    ::MemFree (m_pszApp);

    if (m_pIlsServer != NULL)
        m_pIlsServer->Release ();

    if (m_hProt != NULL)
        ::UlsLdap_VirtualUnRegisterProtocol(m_hProt);
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::Init (BSTR bstrName, ULONG uPort, BSTR bstrMimeType)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::Init (BSTR bstrName, ULONG uPort, BSTR bstrMimeType)
{
    HRESULT hr;

    // Set the port number
    //
    this->m_uPort = uPort;

    hr = BSTR_to_LPTSTR(&m_szName, bstrName);
    if (SUCCEEDED(hr))
    {
        hr = BSTR_to_LPTSTR(&m_szMimeType, bstrMimeType);
        if (SUCCEEDED(hr))
        {
#ifdef LATER
            // Initialize the attributes list
            //
            m_pAttrs = new CAttributes;
            if (m_pAttrs != NULL)
            	m_pAttrs->SetAccessType (ILS_ATTRTYPE_NAME_VALUE);

#endif //LATER
                // Make the connection point
                //
                m_pConnPt = new CConnectionPoint (&IID_IIlsProtocolNotify,
                                                (IConnectionPointContainer *)this);
                if (m_pConnPt != NULL)
                {
                    ((IConnectionPoint*)m_pConnPt)->AddRef();
                    hr = NOERROR;
                }
                else
                {
                    hr = ILS_E_MEMORY;
                };
        };
    };

	// Make this as read/write access
	//
    ASSERT (! m_fReadonly);

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsProt::Init (LPTSTR szServerName, LPTSTR szUserName, 
//                 LPTSTR szAppName, PLDAP_PROTINFO ppi)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::Init (CIlsServer *pIlsServer, LPTSTR szUserName, 
                LPTSTR szAppName, PLDAP_PROTINFO ppi)
{
    HRESULT hr;

    // Validate parameter
    //
    if (ppi == NULL)
    	return ILS_E_POINTER;

    if (ppi->uSize != sizeof(*ppi))
        return ILS_E_PARAMETER;

    // Make this a readonly guy
	//
    m_fReadonly = TRUE;

    // Remember port name
    //
    m_uPort = ppi->uPortNumber;

    // Remember the server name
    //
    m_pIlsServer = pIlsServer;
    pIlsServer->AddRef ();

    hr = SetLPTSTR(&m_pszUser, szUserName);
    if (SUCCEEDED(hr))
    {
        hr = SetLPTSTR(&m_pszApp, szAppName);

        if (SUCCEEDED(hr))
        {
            hr = SetLPTSTR(&m_szName,
                           (LPCTSTR)(((PBYTE)ppi)+ppi->uOffsetName));

            if (SUCCEEDED(hr))
            {
                hr = SetLPTSTR(&m_szMimeType,
                               (LPCTSTR)(((PBYTE)ppi)+ppi->uOffsetMimeType));

            };
        };
    };

	// cleanup is done in destructor

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IIlsProtocol || riid == IID_IUnknown)
    {
        *ppv = (IIlsMain *) this;
    }
    else
    {
        if (riid == IID_IConnectionPointContainer)
        {
            *ppv = (IConnectionPointContainer *) this;
        };
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CLocalProt::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CLocalProt::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CLocalProt::AddRef: ref=%ld\r\n", m_cRef));
    ::InterlockedIncrement (&m_cRef);
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CLocalProt::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CLocalProt::Release (void)
{
    DllRelease();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CLocalProt::Release: ref=%ld\r\n", m_cRef));
    if (::InterlockedDecrement (&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::IsWritable (BOOL *pfWriteable)
//
//****************************************************************************
STDMETHODIMP
CLocalProt::IsWritable(BOOL *pfWriteable)
{
    HRESULT hr;

    if (pfWriteable)
    {
        *pfWriteable = !m_fReadonly;
		hr = S_OK;
    }
    else
    {
    	hr = ILS_E_POINTER;
    }

    return (hr);
}


//****************************************************************************
// STDMETHODIMP
// CLocalProt::GetStandardAttribute (ILS_STD_ATTR_NAME   stdAttr, BSTR *pbstrStdAttr)
//
// History:
//  1-16-97 Shishir Pardikar
// Created.
//****************************************************************************
STDMETHODIMP
CLocalProt::GetStandardAttribute(
    ILS_STD_ATTR_NAME   stdAttr,
    BSTR                *pbstrStdAttr
)
{
    LPTSTR lpszAttr = NULL;
    BOOL    fValid = TRUE;
    HRESULT hr;
	TCHAR sz[16];

    if (pbstrStdAttr == NULL) {

        return ILS_E_POINTER;

    }
    switch(stdAttr) {

    case ILS_STDATTR_PROTOCOL_PORT:
    	lpszAttr = &sz[0];
    	wsprintf (&sz[0], TEXT ("%lu"), m_uPort);
    	break;

    case ILS_STDATTR_PROTOCOL_NAME:
        lpszAttr = m_szName;
        break;
    case ILS_STDATTR_PROTOCOL_MIME_TYPE:
        lpszAttr = m_szMimeType;
        break;

    default:
        fValid = FALSE;
        break;
    }

    if (fValid) {
        if (lpszAttr){

            hr = LPTSTR_to_BSTR(pbstrStdAttr, lpszAttr);
        }
        else {

            *pbstrStdAttr = NULL;
            hr = NOERROR;

        }
    }
    else {

        hr = ILS_E_PARAMETER;

    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::SetStandardAttribute (ILS_STD_ATTR_NAME   stdAttr, BSTR bstrStdAttr)
//
// History:
//  1-16-97 Shishir Pardikar
// Created.
//****************************************************************************
STDMETHODIMP
CLocalProt::SetStandardAttribute(
    ILS_STD_ATTR_NAME   stdAttr,
    BSTR                bstrStdAttr
)
{
    return (ILS_E_FAIL);
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::Update(BSTR bstrServerName, ULONG *pulReqId)
//
// History:
//  1-16-97 Shishir Pardikar
// Created.
//****************************************************************************
STDMETHODIMP CLocalProt::
Update ( ULONG *pulReqID )
{
    return (ILS_E_FAIL);
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::IsSameAs (CLocalProt *pProtocol)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::IsSameAs (CLocalProt *pProtocol)
{
    return (!lstrcmp(pProtocol->m_szName, this->m_szName) ?
            NOERROR : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::GetProtocolInfo (PLDAP_PROTINFO *ppProtInfo)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::GetProtocolInfo (PLDAP_PROTINFO *ppProtInfo)
{
    PLDAP_PROTINFO ppi;
    ULONG cName, cMime;
    HRESULT hr;

    // Assume failure
    //
    *ppProtInfo = NULL;

    // Calculate the buffer size
    //
    cName = lstrlen(m_szName)+1;
    cMime = lstrlen(m_szMimeType)+1;

    // Allocate the buffer
    //
    ULONG cbTotalSize = sizeof (LDAP_PROTINFO) + (cName + cMime) * sizeof (TCHAR);
    ppi = (PLDAP_PROTINFO) ::MemAlloc (cbTotalSize);
    if (ppi == NULL)
    {
        hr = ILS_E_MEMORY;
    }
    else
    {
        // Fill the structure content
        //
        ppi->uSize              = cbTotalSize;
        ppi->uOffsetName        = sizeof(*ppi);
        ppi->uPortNumber        = m_uPort;
        ppi->uOffsetMimeType    = ppi->uOffsetName + (cName*sizeof(TCHAR));

        // Copy the user information
        //
        lstrcpy((LPTSTR)(((PBYTE)ppi)+ppi->uOffsetName), m_szName);
        lstrcpy((LPTSTR)(((PBYTE)ppi)+ppi->uOffsetMimeType), m_szMimeType);

        // Return the structure
        //
        *ppProtInfo = ppi;
    };

    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
{
    HRESULT hr = S_OK;

    if (m_pConnPt != NULL)
    {
        hr = m_pConnPt->Notify(pv, pfn);
    };
    return hr;
}


//****************************************************************************
// STDMETHODIMP
// CLocalProt::GetID (BSTR *pbstrID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::GetPortNumber (ULONG *pulPort)
{
    // Validate parameter
    //
    if (pulPort == NULL)
    {
        return ILS_E_POINTER;
    };

    *pulPort = m_uPort;

    return (NOERROR);
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::SetAttributes (IIlsAttributes *pAttributes, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CLocalProt::
SetExtendedAttribute ( BSTR bstrName, BSTR bstrValue )
{
	return ILS_E_NOT_IMPL;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::RemoveAttributes (IIlsAttributes *pAttributes, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CLocalProt::
RemoveExtendedAttribute ( BSTR bstrName )
{
    return ILS_E_NOT_IMPL;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::GetAttributes (IIlsAttributes **pAttributes)
//
//****************************************************************************

STDMETHODIMP CLocalProt::
GetExtendedAttribute ( BSTR bstrName, BSTR *pbstrValue )
{
    return ILS_E_NOT_IMPL;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::GetAllExtendedAttributes (IIlsAttributes **pAttributes)
//
//****************************************************************************

STDMETHODIMP CLocalProt::
GetAllExtendedAttributes ( IIlsAttributes **ppAttributes )
{
    return ILS_E_NOT_IMPL;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:15:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ILS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ILS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecp->Init((IConnectionPoint *)m_pConnPt);
    if (FAILED(hr))
    {
        delete pecp;
        return hr;
    };

    // Give it back to the caller
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CLocalProt::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
//
// History:
//  Wed 17-Apr-1996 11:15:09  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalProt::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
{
    IID siid;
    HRESULT hr;

    // Validate parameters
    //
    if (ppcp == NULL)
    {
        return ILS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppcp = NULL;

    if (m_pConnPt != NULL)
    {
        hr = m_pConnPt->GetConnectionInterface(&siid);

        if (SUCCEEDED(hr))
        {
            if (riid == siid)
            {
                *ppcp = (IConnectionPoint *)m_pConnPt;
                (*ppcp)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = ILS_E_NO_INTERFACE;
            };
        };
    }
    else
    {
        hr = ILS_E_NO_INTERFACE;
    };

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\localusr.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       localusr.cpp
//  Content:    This file contains the LocalUser object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "localusr.h"
#include "localprt.h"
#include "callback.h"
#include "attribs.h"
#include "culs.h"

#define DEFAULT_COUNTRY _T("-")

#ifdef OLD
//****************************************************************************
// Registry keys and values - defined in ULSREG.H
//****************************************************************************

#define REGSTR_ILS_CLIENT_KEY           ILS_REGISTRY TEXT("\\") ILS_REGFLD_CLIENT
#define REGSTR_ILS_FIRSTNAME_VALUE      ILS_REGKEY_FIRST_NAME
#define REGSTR_ILS_LASTNAME_VALUE       ILS_REGKEY_LAST_NAME
#define REGSTR_ILS_EMAIL_VALUE          ILS_REGKEY_EMAIL_NAME
#define REGSTR_ILS_CITY_VALUE           ILS_REGKEY_CITY
#define REGSTR_ILS_COUNTRY_VALUE        ILS_REGKEY_COUNTRY
#define REGSTR_ILS_COMMENT_VALUE        ILS_REGKEY_COMMENTS
#define REGSTR_ILS_FLAGS_VALUE          ILS_REGKEY_DONT_PUBLISH

#endif //OLD


#ifdef TEST
_cdecl main()
{
    return (0);
}
#endif //TEST

//****************************************************************************
// HRESULT
// OnNotifyRegisterResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyRegisterResult (IUnknown *pUnk, void *pv)
{
    PSRINFO psri = (PSRINFO)pv;

    ((IIlsUserNotify*)pUnk)->RegisterResult(psri->uReqID, psri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyUpdateUserResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyUpdateResult (IUnknown *pUnk, void *pv)
{
    PSRINFO psri = (PSRINFO)pv;

    ((IIlsUserNotify*)pUnk)->UpdateResult(psri->uReqID, psri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyProtocolChangeResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyProtocolChangeResult (IUnknown *pUnk, void *pv)
{
    PSRINFO psri = (PSRINFO)pv;

    ((IIlsUserNotify*)pUnk)->ProtocolChangeResult(psri->uReqID,
                                                      psri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyGetProtocolResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyGetProtocolResult (IUnknown *pUnk, void *pv)
{
    POBJRINFO pobjri = (POBJRINFO)pv;

    ((IIlsUserNotify*)pUnk)->GetProtocolResult(pobjri->uReqID,
                                                      (IIlsProtocol *)pobjri->pv,
                                                      pobjri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyEnumProtocolsResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyEnumProtocolsResult (IUnknown *pUnk, void *pv)
{
    CEnumNames  *penum  = NULL;
    PENUMRINFO  peri    = (PENUMRINFO)pv;
    HRESULT     hr      = peri->hResult;

    if (SUCCEEDED(hr))
    {
        penum = new CEnumNames;

        if (penum != NULL)
        {
            hr = penum->Init((LPTSTR)peri->pv, peri->cItems);

            if (SUCCEEDED(hr))
            {
                penum->AddRef();
            }
            else
            {
                delete penum;
                penum = NULL;
            };
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    // Notify the sink object
    //
    ((IIlsUserNotify*)pUnk)->EnumProtocolsResult(peri->uReqID,
                                                        penum != NULL ? 
                                                        (IEnumIlsNames *)penum :
                                                        NULL,
                                                        hr);

    if (penum != NULL)
    {
        penum->Release();
    };
    return hr;
}

#ifdef MAYBE
//****************************************************************************
// HRESULT
// OnNotifyStateChanged ( IUnknown *pUnk, LONG State, VOID *pv )
//
// History:
//  Thu 07-Nov-1996 13:05:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

HRESULT
CIlsUser::OnNotifyStateChanged ( IUnknown *pUnk, LONG State, BSTR bstrServerName, BOOL fPrimary )
{
    // If the server object does not exist, not registered
    //
    if (m_pServer == NULL)
        return NOERROR;

	// Set server internal state
	//
	SetULSState ((ULSSVRSTATE) State);

	// Notify the app to logoff and re-logon
	// This app must NOT pop up an UI upon receiving this
	//
    ((IIlsUserNotify *) pUnk)->StateChanged (fPrimary, bstrServerName);

    return NOERROR;
}

#endif //MAYBE

HRESULT
OnNotifyStateChanged_UI_NoSuchObject ( IUnknown *pUnk, VOID *pv )
{
	return ((IIlsUserNotify *)pUnk)->StateChanged (TRUE, (BSTR) pv);
}

HRESULT
OnNotifyStateChanged_NoUI_NoSuchObject ( IUnknown *pUnk, VOID *pv )
{
	return ((IIlsUserNotify *)pUnk)->StateChanged (FALSE, (BSTR) pv);
}

HRESULT
OnNotifyStateChanged_UI_NetworkDown ( IUnknown *pUnk, VOID *pv )
{
	return ((IIlsUserNotify *)pUnk)->StateChanged (TRUE, (BSTR) pv);
}

HRESULT
OnNotifyStateChanged_NoUI_NetworkDown ( IUnknown *pUnk, VOID *pv )
{
	return ((IIlsUserNotify *)pUnk)->StateChanged (FALSE, (BSTR) pv);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::ProtocolChangeResult ( IIlsProtocol *pProtocol, ULONG uReqID, HRESULT hResult,
//                                  APP_CHANGE_PROT uCmd)
//
//****************************************************************************

STDMETHODIMP
CIlsUser::ProtocolChangeResult ( IIlsProtocol *pProtocol, ULONG uReqID, HRESULT hResult,
                                 APP_CHANGE_PROT uCmd)
{
    SRINFO sri;

    // If the server accepts the changes, modify the local information
    //
    if (FAILED (hResult))
    {
        // Update based on the command.
        //
        switch(uCmd)
        {
            case ILS_APP_ADD_PROT:
				m_ProtList.Remove ((CLocalProt *) pProtocol);
				pProtocol->Release (); // AddRef by RegisterLocalProtocol
                break;

            case ILS_APP_REMOVE_PROT:
            	// Release already by UnregisterLocalProtocol
                break;

            default:
                ASSERT(0);
                break;
        };
    }


    if (uReqID) {
        // Notify the sink object
        //
        sri.uReqID = uReqID;
        sri.hResult = hResult;
        hResult = NotifySink((void *)&sri, OnNotifyProtocolChangeResult);
    }

#ifdef DEBUG
    DPRINTF (TEXT("CIlsUser--current Protocols********************\r\n"));
    DPRINTF (TEXT("\r\n*************************************************"));
#endif // DEBUG;

    return hResult;
}

//****************************************************************************
// CIlsUser::CIlsUser (HANDLE hMutex)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CIlsUser::CIlsUser ()
:
 m_cRef (0),
// user
 m_fReadonly (FALSE),
 m_uModify (LU_MOD_NONE),
 m_cLock (0),
 m_szID (NULL),
 m_szFirstName (NULL),
 m_szLastName (NULL),
 m_szEMailName (NULL),
 m_szCityName (NULL),
 m_szCountryName (NULL),
 m_szComment (NULL),
 m_dwFlags (1), // default is visible
 m_szIPAddr (NULL),
 m_szAppName (NULL),
 m_szMimeType (NULL),
 m_pIlsServer (NULL),
 m_pConnPt (NULL),
// server
 m_uState (ULSSVR_INVALID),
 m_hLdapUser (NULL),
 m_pep (NULL),
 m_uReqID (0),
 m_uLastMsgID (0)
{
    m_guid = GUID_NULL;
	m_ExtendedAttrs.SetAccessType (ILS_ATTRTYPE_NAME_VALUE);
		// m_szCountryName can't be a NULL string... see notes on NetMeeting 3.0 Bug 1643 for the reason why...
	m_szCountryName = static_cast<LPTSTR>(MemAlloc( lstrlen( DEFAULT_COUNTRY ) + sizeof(TCHAR) ));
	lstrcpy( m_szCountryName, DEFAULT_COUNTRY );

}

//****************************************************************************
// CIlsUser::~CIlsUser (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CIlsUser::~CIlsUser (void)
{
    /* ------ server ------ */

    // Unregister everything, including protocols
    //
    InternalCleanupRegistration(FALSE);

    // We expect someone explicitly unregister this
    //
    ASSERT ((m_uState == ULSSVR_INVALID) || (m_uState == ULSSVR_INIT));
    ASSERT (m_hLdapUser == NULL);
    ASSERT (m_pep == NULL);
    ASSERT (m_uReqID == 0);
    ASSERT (m_uLastMsgID == 0);

    /* ------ user ------ */

    ::MemFree (m_szID);
    ::MemFree (m_szFirstName);
    ::MemFree (m_szLastName);
    ::MemFree (m_szEMailName);
    ::MemFree (m_szCityName);
    ::MemFree (m_szCountryName);
    ::MemFree (m_szComment);
    ::MemFree (m_szIPAddr);

    // Release the protocol objects
    //
    CLocalProt *plp = NULL;
    HANDLE hEnum = NULL;
    m_ProtList.Enumerate(&hEnum);
    while(m_ProtList.Next (&hEnum, (PVOID *)&plp) == NOERROR)
    {
        plp->Release(); // AddRef by RegisterLocalProtocol or UpdateProtocol
    }
    m_ProtList.Flush();

    // Release the buffer resources
    //
    ::MemFree (m_szAppName);
    ::MemFree (m_szMimeType);

    // Release the connection point
    //
    if (m_pConnPt != NULL)
    {
        m_pConnPt->ContainerReleased();
        ((IConnectionPoint*)m_pConnPt)->Release();
    };

	// Free server object
	//
	if (m_pIlsServer != NULL)
		m_pIlsServer->Release ();
}


//****************************************************************************
// STDMETHODIMP
// CIlsUser::Clone
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
Clone ( IIlsUser **ppUser )
{
	if (ppUser == NULL)
		return ILS_E_POINTER;

	// Create a new user object
	//
	CIlsUser *p = new CIlsUser;
	if (p == NULL)
		return ILS_E_MEMORY;

    // Snap-shot the user information now
	//
	LDAP_CLIENTINFO	*pci = NULL;
	HRESULT hr = InternalGetUserInfo (TRUE, &pci, LU_MOD_ALL);
	if (SUCCEEDED (hr))
	{
		// Fake the size to make it consistent with what Init() wants
		//
		pci->uSize = sizeof (*pci);

		// Unpack the user information
		//
		hr = p->Init (NULL, pci);
	}

	if (FAILED (hr))
	{
		delete p;
		p = NULL;
	}

	p->AddRef ();
	p->m_fReadonly = FALSE;
	p->m_uState = ULSSVR_INIT;
	*ppUser = (IIlsUser *) p;
	
	return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::Init (BSTR bstrUserID, BSTR bstrAppName)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::Init (BSTR bstrUserID, BSTR bstrAppName)
{
    HRESULT hr;
    ASSERT(!m_szID && !m_szAppName);

    if (!bstrUserID || !bstrAppName) {

        return (ILS_E_PARAMETER);

    }

    hr = BSTR_to_LPTSTR(&m_szID, bstrUserID);

    if (FAILED(hr)) {

        m_szID = NULL;  // set it to NULL for safety
        return (hr);

    }

    hr = BSTR_to_LPTSTR(&m_szAppName, bstrAppName);
    
    if (SUCCEEDED(hr))
    {
        // Make the connection point
        //
        m_pConnPt = new CConnectionPoint (&IID_IIlsUserNotify,
                                        (IConnectionPointContainer *)this);
        if (m_pConnPt != NULL)
        {
            ((IConnectionPoint*)m_pConnPt)->AddRef();
            hr = NOERROR;

			m_ExtendedAttrs.SetAccessType (ILS_ATTRTYPE_NAME_VALUE);
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    if (FAILED(hr)) {

        ::MemFree (m_szID);
        ::MemFree (m_szAppName);
        m_szID = m_szAppName = NULL;

        return hr;
    }

    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::Init (LPTSTR szServerName, PLDAP_CLIENTINFO *pui)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::Init (CIlsServer *pIlsServer, PLDAP_CLIENTINFO pui)
{
    // Validate parameter
    //
    if ((pui->uSize != sizeof(*pui))    ||
        (pui->uOffsetCN       == 0)     /*||
        (pui->uOffsetAppName  == 0)*/
        )
    {
        return ILS_E_PARAMETER;
    };

    // Remember the server if necessary
    //
    if (pIlsServer != NULL)
    {
	    pIlsServer->AddRef ();
	}
	m_pIlsServer = pIlsServer;

	// Allocate strings
	//
	BOOL fSuccess = SUCCEEDED (SetOffsetString (&m_szID, (BYTE *) pui, pui->uOffsetCN)) && (m_szID != NULL);
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szAppName, (BYTE *) pui, pui->uOffsetAppName));
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szFirstName, (BYTE *) pui, pui->uOffsetFirstName));
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szLastName, (BYTE *) pui, pui->uOffsetLastName));
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szEMailName, (BYTE *) pui, pui->uOffsetEMailName));
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szCityName, (BYTE *) pui, pui->uOffsetCityName));
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szCountryName, (BYTE *) pui, pui->uOffsetCountryName));
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szComment, (BYTE *) pui, pui->uOffsetComment));
    fSuccess &= SUCCEEDED (SetOffsetString (&m_szIPAddr, (BYTE *) pui, pui->uOffsetIPAddress));
	fSuccess &= SUCCEEDED (SetOffsetString (&m_szMimeType, (BYTE *) pui, pui->uOffsetAppMimeType));

    HRESULT hr = fSuccess ? S_OK : ILS_E_MEMORY;
	if (SUCCEEDED(hr))
	{
		// Set non-allocation data
		//
        m_dwFlags = pui->dwFlags;
        m_guid = pui->AppGuid;

		// Set extended attributes
		//
		m_ExtendedAttrs.SetAccessType (ILS_ATTRTYPE_NAME_VALUE);
        if (pui->cAttrsReturned != 0)
        {
            hr = m_ExtendedAttrs.SetAttributePairs((LPTSTR)(((PBYTE)pui)+pui->uOffsetAttrsReturned),
                      pui->cAttrsReturned);
        }
    }

    if (SUCCEEDED(hr))
    {
        // Make the connection point
        //
        m_pConnPt = new CConnectionPoint (&IID_IIlsUserNotify,
                                        (IConnectionPointContainer *)this);
        if (m_pConnPt != NULL)
        {
            ((IConnectionPoint*)m_pConnPt)->AddRef();
            hr = NOERROR;

            m_fReadonly = TRUE;

        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };

    // cleanup is done in destructor

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::IsWritable (BOOL *pfWriteable)
//
//****************************************************************************
STDMETHODIMP
CIlsUser::IsWritable(BOOL *pfWriteable)
{
    HRESULT hr;

    if (pfWriteable != NULL)
    {
        *pfWriteable = !m_fReadonly;
		hr = S_OK;
    }
    else
    {
    	hr = ILS_E_POINTER;
    }
    return hr;
}


//****************************************************************************
// STDMETHODIMP
// CIlsUser::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IIlsUser || riid == IID_IUnknown)
    {
        *ppv = (IIlsUser *) this;
    }
    else
    {
        if (riid == IID_IConnectionPointContainer)
        {
            *ppv = (IConnectionPointContainer *) this;
        };
    }

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CIlsUser::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CIlsUser::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CIlsUser::AddRef: ref=%ld\r\n", m_cRef));
	::InterlockedIncrement (&m_cRef);
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CIlsUser::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CIlsUser::Release (void)
{
    DllRelease();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CIlsUser::Release: ref=%ld\r\n", m_cRef));
	if (::InterlockedDecrement (&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetStandardAttribute (ILS_STD_ATTR_NAME   stdAttr, BSTR *pbstrStdAttr)
//
// History:
//  1-16-97 Shishir Pardikar
// Created.
//****************************************************************************
STDMETHODIMP
CIlsUser::GetStandardAttribute(
    ILS_STD_ATTR_NAME   stdAttr,
    BSTR                *pbstrStdAttr
)
{
    LPTSTR lpszAttr = NULL;
    BOOL    fValid = TRUE;
    HRESULT hr;

    if (pbstrStdAttr == NULL) {

        return ILS_E_POINTER;

    }
    switch(stdAttr) {

    case ILS_STDATTR_USER_ID:
        lpszAttr = m_szID;
        break;
    case ILS_STDATTR_APP_NAME:
        lpszAttr = m_szAppName;
        break;
    case ILS_STDATTR_IP_ADDRESS:
        lpszAttr = m_szIPAddr;
        break;
    case ILS_STDATTR_EMAIL_NAME:
        lpszAttr = m_szEMailName;
        break;

	case ILS_STDATTR_FIRST_NAME:
        lpszAttr = m_szFirstName;
        break;

	case ILS_STDATTR_LAST_NAME:
        lpszAttr = m_szLastName;
        break;

	case ILS_STDATTR_CITY_NAME:
        lpszAttr = m_szCityName;
        break;

	case ILS_STDATTR_COUNTRY_NAME:
        lpszAttr = m_szCountryName;
        break;

	case ILS_STDATTR_COMMENT:
        lpszAttr = m_szComment;
        break;

    case ILS_STDATTR_APP_MIME_TYPE:
        lpszAttr = m_szMimeType;
        break;

    default:
        fValid = FALSE;
        break;
    }

    if (fValid) {
        if (lpszAttr){

            hr = LPTSTR_to_BSTR(pbstrStdAttr, lpszAttr);
        }
        else {

            *pbstrStdAttr = NULL;
            hr = NOERROR;

        }
    }
    else {

        hr = ILS_E_PARAMETER;

    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::SetStandardAttribute (ILS_STD_ATTR_NAME   stdAttr, BSTR bstrStdAttr)
//
// History:
//  1-16-97 Shishir Pardikar
// Created.
//****************************************************************************
STDMETHODIMP
CIlsUser::SetStandardAttribute(
    ILS_STD_ATTR_NAME   stdAttr,
    BSTR                bstrStdAttr
)
{
    LPTSTR *ppszAttr = NULL, pszNewAttr;
    BOOL    fValid = TRUE;
    ULONG   ulModBit = 0;
    HRESULT hr;

	// It is ok to have a null bstrStdAttr
	//

    // Make sure this is not a read-only object
    //
    if (m_fReadonly)
       return ILS_E_ACCESS_DENIED;

    switch(stdAttr) {

    case ILS_STDATTR_IP_ADDRESS:
        ppszAttr = &m_szIPAddr;
        ulModBit = LU_MOD_IP_ADDRESS;
        break;

    case ILS_STDATTR_EMAIL_NAME:
        ppszAttr = &m_szEMailName;
        ulModBit = LU_MOD_EMAIL;
        break;

	case ILS_STDATTR_FIRST_NAME:
        ppszAttr = &m_szFirstName;
        ulModBit = LU_MOD_FIRSTNAME;
        break;

	case ILS_STDATTR_LAST_NAME:
        ppszAttr = &m_szLastName;
        ulModBit = LU_MOD_LASTNAME;
        break;

	case ILS_STDATTR_CITY_NAME:
        ppszAttr = &m_szCityName;
        ulModBit = LU_MOD_CITY;
        break;

	case ILS_STDATTR_COUNTRY_NAME:
        ppszAttr = &m_szCountryName;
        ulModBit = LU_MOD_COUNTRY;
        break;

	case ILS_STDATTR_COMMENT:
        ppszAttr = &m_szComment;
        ulModBit = LU_MOD_COMMENT;
        break;

    case ILS_STDATTR_APP_MIME_TYPE:
        ppszAttr = &m_szMimeType;
        ulModBit = LU_MOD_MIME;
        break;

    default:
        fValid = FALSE;
        break;
    }

    if (fValid) {
		pszNewAttr = NULL;
		if (bstrStdAttr == NULL || *bstrStdAttr == L'\0')
		{
			// pszNewAttr is null now
			//
			hr = S_OK;
		}
		else
		{
			// Duplicate the string
			//
			hr = BSTR_to_LPTSTR (&pszNewAttr, bstrStdAttr);
		}

        if (SUCCEEDED(hr))
        {
            ::MemFree (*ppszAttr);
            *ppszAttr = pszNewAttr;
            m_uModify |= ulModBit;
        }
    }
    else {

        hr = ILS_E_PARAMETER;

    }

    return (hr);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetVisible ( DWORD *pfVisible )
//
// History:
//  Tue 05-Nov-1996 10:30:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::GetVisible ( DWORD *pfVisible )
{
	HRESULT hr = ILS_E_POINTER;
    if (pfVisible != NULL)
    {
	    *pfVisible = m_dwFlags;
	    hr = S_OK;
	}
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::SetVisible ( DWORD fVisible )
//
// History:
//  Tue 05-Nov-1996 10:30:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::SetVisible ( DWORD fVisible )
{
    // Make sure this is not a read-only object
    //
    if (m_fReadonly)
       return ILS_E_ACCESS_DENIED;

    m_dwFlags = fVisible;
    m_uModify |= LU_MOD_FLAGS;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetGuid ( GUID *pGuid )
//
// History:
//  Tue 05-Nov-1996 10:30:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::GetGuid ( GUID *pGuid )
{
	HRESULT hr = ILS_E_POINTER;
	if (pGuid != NULL)
	{
		*pGuid = m_guid;
		hr = S_OK;
	}
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::SetGuid ( GUID *pGuid )
//
// History:
//  Tue 05-Nov-1996 10:30:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::SetGuid ( GUID *pGuid )
{
    // Make sure this is not a read-only object
    //
    if (m_fReadonly)
       return ILS_E_ACCESS_DENIED;

	HRESULT hr = ILS_E_POINTER;
	if (pGuid != NULL)
	{
	    m_guid = *pGuid;
	    m_uModify |= LU_MOD_GUID;
	    hr = S_OK;
	}
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::InternalGetUserInfo (BOOL fAddNew, PLDAP_CLIENTINFO *ppUserInfo, ULONG uFields)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::InternalGetUserInfo (BOOL fAddNew, PLDAP_CLIENTINFO *ppUserInfo, ULONG uFields)
{
    PLDAP_CLIENTINFO pui;
    ULONG cFName,
          cLName,
          cEName,
          cCity,
          cCountry,
          cComment;
    ULONG cName, cAppName, cMime;
    LPTSTR szAttrs;
    ULONG uOffsetDstAnyAttrs;
    ULONG cAttrs, cbAttrs;
    HRESULT hr;
	ULONG cchIPAddr;

    // Should not call this guy if nothing has been updated
    //
    ASSERT(uFields);

    // Assume failure
    //
    *ppUserInfo = NULL;

    // Calculate the buffer size
    //
    ASSERT(m_szID && m_szAppName);

    cName  = lstrlen(m_szID)+1;
    cAppName = lstrlen(m_szAppName)+1;

    cFName = (((uFields & LU_MOD_FIRSTNAME) && m_szFirstName) ? lstrlen(m_szFirstName)+1    : 0);
    cLName = (((uFields & LU_MOD_LASTNAME) && m_szLastName) ? lstrlen(m_szLastName)+1     : 0);
    cEName = (((uFields & LU_MOD_EMAIL)&& m_szEMailName) ? lstrlen(m_szEMailName)+1    : 0);
    cCity  = (((uFields & LU_MOD_CITY)&& m_szCityName)   ? lstrlen(m_szCityName)+1     : 0);
    cCountry=(((uFields & LU_MOD_COUNTRY)&& m_szCountryName) ? lstrlen(m_szCountryName)+1  : 0);
    cComment=(((uFields & LU_MOD_COMMENT)&& m_szComment) ? lstrlen(m_szComment)+1      : 0);
    cMime =  (((uFields & LU_MOD_MIME)&&m_szMimeType) ? lstrlen(m_szMimeType)+1       : 0);

	cchIPAddr = (((uFields & LU_MOD_IP_ADDRESS) && m_szIPAddr != NULL) ? lstrlen(m_szIPAddr)+1       : 0);

    if (uFields & LU_MOD_ATTRIB) {    
        // Get the attribute pairs
        //
        hr = m_ExtendedAttrs.GetAttributePairs(&szAttrs, &cAttrs, &cbAttrs);
        if (FAILED(hr))
        {
            return hr;
        };
    }
    else {
        cAttrs = 0;
        cbAttrs = 0;
        szAttrs = NULL;
    }
    uOffsetDstAnyAttrs = 0;

    // Allocate the buffer
    //
    ULONG cbTotalSize = sizeof (LDAP_CLIENTINFO) +
                        (cName + cAppName + cFName + cLName + cEName + cchIPAddr +
                         cCity + cCountry + cComment + cMime+cbAttrs) * sizeof (TCHAR);
    pui = (PLDAP_CLIENTINFO) ::MemAlloc (cbTotalSize);
    if (pui == NULL)
    {
        hr = ILS_E_MEMORY;
        goto bailout;
    };

    // Fill the structure content
    //
    pui->uSize              = cbTotalSize;
    pui->uOffsetCN          = sizeof(*pui);
    pui->uOffsetAppName     = pui->uOffsetCN + (cName*sizeof(TCHAR));
    pui->uOffsetFirstName   = pui->uOffsetAppName + (cAppName*sizeof(TCHAR));
    pui->uOffsetLastName    = pui->uOffsetFirstName + (cFName*sizeof(TCHAR));
    pui->uOffsetEMailName   = pui->uOffsetLastName  + (cLName*sizeof(TCHAR));
    pui->uOffsetCityName    = pui->uOffsetEMailName + (cEName*sizeof(TCHAR));
    pui->uOffsetCountryName = pui->uOffsetCityName  + (cCity*sizeof(TCHAR));
    pui->uOffsetComment     = pui->uOffsetCountryName + (cCountry*sizeof(TCHAR));
    pui->uOffsetIPAddress   = pui->uOffsetComment + (cComment * sizeof (TCHAR));
    pui->uOffsetAppMimeType = pui->uOffsetIPAddress + (cchIPAddr * sizeof(TCHAR));
    pui->dwFlags            = m_dwFlags;
    pui->AppGuid            = m_guid;

	// Fill in extended attributes
	//
    uOffsetDstAnyAttrs = (cAttrs != 0) ?
                         pui->uOffsetAppMimeType  + (cMime*sizeof(TCHAR)) :
                         0;
    if (fAddNew)
    {
        pui->cAttrsToAdd        = cAttrs;
        pui->uOffsetAttrsToAdd  = uOffsetDstAnyAttrs;
    }
    else
    {
        pui->cAttrsToModify        = cAttrs;
        pui->uOffsetAttrsToModify  = uOffsetDstAnyAttrs;
    }

    // Copy the user information
    //
    lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetCN), m_szID);
    lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetAppName), m_szAppName);

    if ((uFields & LU_MOD_FIRSTNAME)&&m_szFirstName)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetFirstName), m_szFirstName);
    }
    else
    {
        pui->uOffsetFirstName = 0;
    };

    if ((uFields & LU_MOD_LASTNAME)&&m_szLastName)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetLastName), m_szLastName);
    }
    else
    {
        pui->uOffsetLastName = 0;
    };

    if ((uFields & LU_MOD_EMAIL)&&m_szEMailName)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetEMailName), m_szEMailName);
    }
    else
    {
        pui->uOffsetEMailName = 0;
    };

    if ((uFields & LU_MOD_CITY)&&m_szCityName)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetCityName), m_szCityName);
    }
    else
    {
        pui->uOffsetCityName = 0;
    };

    if ((uFields & LU_MOD_COUNTRY)&&m_szCountryName)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetCountryName), m_szCountryName);
    }
    else
    {
        pui->uOffsetCountryName = 0;
    };

    if ((uFields & LU_MOD_COMMENT)&&m_szComment)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetComment), m_szComment);
    }
    else
    {
        pui->uOffsetComment = 0;
    };

    if ((uFields & LU_MOD_MIME)&&m_szMimeType)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetAppMimeType), m_szMimeType);
    }
    else
    {
        pui->uOffsetAppMimeType = 0;
    }

    if ((uFields & LU_MOD_IP_ADDRESS) && m_szIPAddr != NULL)
    {
        lstrcpy((LPTSTR)(((PBYTE)pui)+pui->uOffsetIPAddress), m_szIPAddr);
    }
    else
    {
        pui->uOffsetIPAddress = 0;
    }

    if (cAttrs)
    {
        CopyMemory(((PBYTE)pui) + uOffsetDstAnyAttrs, szAttrs, cbAttrs);
    };

    // Return the structure
    //
    *ppUserInfo = pui;


    hr = NOERROR;

bailout:

    if (szAttrs != NULL)
    {
        ::MemFree (szAttrs);
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::Register (BSTR bstrServerName, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
Register (
	IIlsServer		*pIlsServer,
	ULONG			*puReqID)
{
    HRESULT hr;

	// Make sure it is not registered
	//
	if (GetULSState () != ILS_UNREGISTERED)
		return ILS_E_ALREADY_REGISTERED;

    // Validate parameter
    //
    if (::MyIsBadServer (pIlsServer) || puReqID == NULL)
        return ILS_E_POINTER;

    // Make sure this is not a read-only object
    //
    if (m_fReadonly)
       return ILS_E_ACCESS_DENIED;

	// Clone the server object
	//
	pIlsServer = ((CIlsServer *) pIlsServer)->Clone ();
	if (pIlsServer == NULL)
		return ILS_E_MEMORY;

	// Free the old server object if necessary
	//
	if (m_pIlsServer != NULL)
		m_pIlsServer->Release ();

	// Keep the new server object
	//
	m_pIlsServer = (CIlsServer *) pIlsServer;

	// Initialize the state
	//
	m_uState = ULSSVR_INIT;

    // Prepare the asynchronous request
    //
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

    ri.uReqType = WM_ILS_LOCAL_REGISTER;
    ri.uMsgID = 0;

	ReqInfo_SetUser (&ri, this);

	// Enter the request
	//
    hr = g_pReqMgr->NewRequest(&ri);
    if (SUCCEEDED(hr))
    {
        // Make sure the objects do not disappear before we get the response
        //
        this->AddRef();

        // Register the client
        //
        hr = InternalRegister (ri.uReqID);
        if (SUCCEEDED(hr))
        {
            Lock();
            *puReqID = ri.uReqID;
        }
        else
        {
            // Clean up the async pending request
            //
            this->Release();
            g_pReqMgr->RequestDone(&ri);
        };
    };
    
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::RegisterResult (ULONG uReqID, HRESULT hResult)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::RegisterResult (ULONG uReqID, HRESULT hResult)
{
    SRINFO sri;

    Unlock();

    // Notify the sink object
    //
    sri.uReqID = uReqID;
    sri.hResult = hResult;
    if (hResult == S_OK)
    {
    	m_uModify = LU_MOD_NONE;
    }
    hResult = NotifySink((void *)&sri, OnNotifyRegisterResult);
    return hResult;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::Unregister (BSTR bstrServerName, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
Unregister ( ULONG *puReqID )
{
    HRESULT hr;

	// Make sure it is registered somehow (network down, need relogon, or registered)
	//
	if (GetULSState () == ILS_UNREGISTERED)
		return ILS_E_NOT_REGISTERED;

    // Make sure this is not a read-only object
    //
    if (m_fReadonly)
       return ILS_E_ACCESS_DENIED;

    // If puReqID is null, do it synchronously
    //
    if (puReqID == NULL)
    {
		hr = InternalCleanupRegistration (TRUE);
	}
	else
	{
        // Prepare the asynchronous request
        //
	    COM_REQ_INFO ri;
	    ReqInfo_Init (&ri);

        ri.uReqType = WM_ILS_LOCAL_UNREGISTER;
        ri.uMsgID = 0;

		ReqInfo_SetUser (&ri, this);

		// Enter new request
		//
        hr = g_pReqMgr->NewRequest(&ri);
        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Unregister the application
            //
            hr = InternalUnregister (ri.uReqID);
            if (SUCCEEDED(hr))
            {
                Lock();
                *puReqID = ri.uReqID;
            }
            else
            {
                // Clean up the async pending request
                //
                this->Release();
                g_pReqMgr->RequestDone(&ri);
            };
        };
	}

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::UnregisterResult (ULONG uReqID, HRESULT hResult)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::UnregisterResult (ULONG uReqID, HRESULT hResult)
{
    SRINFO sri;

    Unlock();

    // Notify the sink object
    //
    sri.uReqID = uReqID;
    sri.hResult = hResult;
    hResult = NotifySink((void *)&sri, OnNotifyRegisterResult);
    return hResult;
}


//****************************************************************************
// STDMETHODIMP
// CIlsUser::Update(ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
Update ( ULONG *puReqID )
{
    PLDAP_CLIENTINFO pUserInfo;
    LDAP_ASYNCINFO ldai; 
    ULONG          uReqID;
    HRESULT        hr;

	if (GetULSState () != ILS_REGISTERED)
		return ILS_E_NOT_REGISTERED;

	if (puReqID == NULL)
		return ILS_E_POINTER;

	// We already registered with the server.
    // Get the user information
    //
    hr = (m_uModify == LU_MOD_NONE) ?
         S_FALSE :
         InternalGetUserInfo (FALSE, &pUserInfo, m_uModify);
    if (hr == NOERROR)
    {
		// Make sure that we do not update User ID and App Name
		//
		pUserInfo->uOffsetCN = INVALID_OFFSET;
		pUserInfo->uOffsetAppName = INVALID_OFFSET;

        // Some fields have been updated, notify the server first
        //
        hr = ::UlsLdap_SetClientInfo (m_hLdapUser, pUserInfo, &ldai);
        ::MemFree (pUserInfo);

        // If updating server was successfully requested, wait for the response
        //
	    COM_REQ_INFO ri;
	    ReqInfo_Init (&ri);

        ri.uReqType =  WM_ILS_SET_CLIENT_INFO;
        ri.uMsgID = ldai.uMsgID;

		ReqInfo_SetUser (&ri, this);

        hr = g_pReqMgr->NewRequest(&ri);

        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;

            Lock();
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::UpdateResult (ULONG uReqID, HRESULT hResult)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::UpdateResult (ULONG uReqID,
                        HRESULT hResult)
{
    SRINFO sri;

    Unlock ();

    // Notify the sink object
    //
    sri.uReqID = uReqID;
    sri.hResult = hResult;
	if (hResult == S_OK)
	{
		m_uModify = LU_MOD_NONE;
	}
    hResult = NotifySink((void *)&sri, OnNotifyUpdateResult);
    return hResult;
}


//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetProtocolHandle (CLocalProt *pLocalProt, PHANDLE phProt)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsUser::
GetProtocolHandle (CLocalProt *pLocalProt, PHANDLE phProt)
{
	ASSERT (pLocalProt != NULL);
	ASSERT (phProt != NULL);

    // Cannot retreive the handle if ULS is locked, i.e. registering something
    //
    if (IsLocked())
        return ILS_E_FAIL;

	/* ------ server ------ */

    if (m_uState != ULSSVR_CONNECT)
        return ILS_E_FAIL;

    // Find the matching protocol
    //
    *phProt = pLocalProt->GetProviderHandle ();
    return S_OK;
}


//****************************************************************************
// STDMETHODIMP
// CIlsUser::RegisterLocalProtocol (BOOL fAddToList, CLocalProt *plp, PLDAP_ASYNCINFO plai)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsUser::
RegisterLocalProtocol ( BOOL fAddToList, CLocalProt *plp, PLDAP_ASYNCINFO plai )
{
	ASSERT (plp != NULL);
	ASSERT (plai != NULL);

	// Let's register the protocol now
	//
    ASSERT (m_hLdapUser != NULL);
    PLDAP_PROTINFO ppi = NULL;
    HRESULT hr = plp->GetProtocolInfo(&ppi);
    if (SUCCEEDED(hr))
    {
        // Remember the protocol to register
        //
        if (fAddToList)
        {
        	plp->AddRef ();
        	hr = m_ProtList.Insert(plp);
        }

        if (SUCCEEDED(hr))
        {
        	HANDLE hProt = NULL;
            hr = ::UlsLdap_RegisterProtocol (m_hLdapUser, ppi, &hProt, plai);
            plp->SetProviderHandle (hProt);
            if (FAILED(hr) && fAddToList)
            {
                m_ProtList.Remove(plp);
            };
        };

        if (FAILED (hr) && fAddToList)
        {
            plp->Release ();
        };
        ::MemFree (ppi);
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::UnregisterLocalProtocol (CLocalProt *plp, PLDAP_ASYNCINFO plai)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsUser::
UnregisterLocalProtocol (CLocalProt *plp, PLDAP_ASYNCINFO plai)
{
	ASSERT (plp != NULL);
	ASSERT (plai != NULL);

    // Cannot retreive the handle if ULS is locked, i.e. registering something
    //
    if (IsLocked())
        return ILS_E_FAIL;

    // Must be registered to perform this operation
    //
    HRESULT hr;
    ILS_STATE uULSState = GetULSState ();
    if (uULSState == ILS_REGISTERED ||
    	uULSState == ILS_REGISTERED_BUT_INVALID ||
    	uULSState == ILS_NETWORK_DOWN)
    {
	    // Search for the protocol
	    //
	    if (m_ProtList.Remove (plp) == S_OK)
	    {
	    	ASSERT (plp != NULL);

	        // Another protocol to unregister
	        //
	        hr = ::UlsLdap_UnRegisterProtocol (plp->GetProviderHandle (), plai);
	        plp->Release (); // AddRef by RegisterLocalProtocol
	    }
	    else
	    {
	        hr = S_FALSE;
	    };
    }
    else
    {
        hr = ILS_E_FAIL;
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetState (BSTR bstrServerName, ULSSTATE *puULSState)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
GetState ( ILS_STATE *puULSState )
{
    HRESULT hr;

    if (puULSState != NULL)
    {
		*puULSState = GetULSState ();
		hr = S_OK;
    }
    else
    {
    	hr = ILS_E_POINTER;
    }

    return hr;
}


//****************************************************************************
// CEnumUsers::CEnumUsers (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumUsers::CEnumUsers (void)
{
    m_cRef    = 0;
    m_ppu     = NULL;
    m_cUsers  = 0;
    m_iNext   = 0;
    return;
}

//****************************************************************************
// CEnumUsers::~CEnumUsers (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumUsers::~CEnumUsers (void)
{
    ULONG i;

    if (m_ppu != NULL)
    {
        for (i = 0; i < m_cUsers; i++)
        {
            m_ppu[i]->Release();
        };
        ::MemFree (m_ppu);
    };
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Init (CIlsUser **ppuList, ULONG cUsers)
//
// History:
//  Wed 17-Apr-1996 11:15:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Init (CIlsUser **ppuList, ULONG cUsers)
{
    HRESULT hr = NOERROR;

    // If no list, do nothing
    //
    if (cUsers != 0)
    {
        ASSERT(ppuList != NULL);

        // Allocate the snapshot buffer
        //
        m_ppu = (CIlsUser **) ::MemAlloc (cUsers*sizeof(CIlsUser *));

        if (m_ppu != NULL)
        {
            ULONG i;

            // Snapshot the object list
            //
            for (i =0; i < cUsers; i++)
            {
                m_ppu[i] = ppuList[i];
                m_ppu[i]->AddRef();
            };
            this->m_cUsers = cUsers;
        }
        else
        {
            hr = ILS_E_MEMORY;
        };
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:15:31  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumIlsUsers || riid == IID_IUnknown)
    {
        *ppv = (IEnumIlsUsers *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumUsers::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:15:37  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumUsers::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CEnumUsers::AddRef: ref=%ld\r\n", m_cRef));
	::InterlockedIncrement (&m_cRef);
    return m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumUsers::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:15:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumUsers::Release (void)
{
    DllRelease();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CEnumUsers::Release: ref=%ld\r\n", m_cRef));
    if (::InterlockedDecrement (&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

//****************************************************************************
// STDMETHODIMP 
// CEnumUsers::Next (ULONG cUsers, IIlsUser **rgpu, ULONG *pcFetched)
//
// History:
//  Wed 17-Apr-1996 11:15:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP 
CEnumUsers::Next (ULONG cUsers, IIlsUser **rgpu, ULONG *pcFetched)
{
    ULONG   cCopied;
    HRESULT hr;

    // Validate the pointer
    //
    if (rgpu == NULL)
        return E_POINTER;

    // Validate the parameters
    //
    if ((cUsers == 0) ||
        ((cUsers > 1) && (pcFetched == NULL)))
        return ILS_E_PARAMETER;

    // Check the enumeration index
    //
    cCopied = 0;

    // Can copy if we still have more attribute names
    //
    while ((cCopied < cUsers) &&
           (m_iNext < this->m_cUsers))
    {
        m_ppu[m_iNext]->AddRef();
        rgpu[cCopied++] = m_ppu[m_iNext++];
    };

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cUsers == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Skip (ULONG cUsers)
//
// History:
//  Wed 17-Apr-1996 11:15:56  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Skip (ULONG cUsers)
{
    ULONG iNewIndex;

    // Validate the parameters
    //
    if (cUsers == 0) 
        return ILS_E_PARAMETER;

    // Check the enumeration index limit
    //
    iNewIndex = m_iNext+cUsers;
    if (iNewIndex <= this->m_cUsers)
    {
        m_iNext = iNewIndex;
        return S_OK;
    }
    else
    {
        m_iNext = this->m_cUsers;
        return S_FALSE;
    };
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Reset (void)
//
// History:
//  Wed 17-Apr-1996 11:16:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Reset (void)
{
    m_iNext = 0;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumUsers::Clone(IEnumIlsUsers **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:16:11  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumUsers::Clone(IEnumIlsUsers **ppEnum)
{
    CEnumUsers *peu;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    peu = new CEnumUsers;
    if (peu == NULL)
        return ILS_E_MEMORY;

    // Clone the information
    //
    hr = peu->Init(m_ppu, m_cUsers);

    if (SUCCEEDED(hr))
    {
        peu->m_iNext = m_iNext;

        // Return the cloned enumerator
        //
        peu->AddRef();
        *ppEnum = peu;
    }
    else
    {
        delete peu;
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::SetExtendedAttributes (IIlsAttributes *pAttributes, ULONG *puReqID)
//
// History:
//****************************************************************************

STDMETHODIMP CIlsUser::
SetExtendedAttribute ( BSTR bstrName, BSTR bstrValue )
{
    // Make sure this is not a read-only object
    //
    if (m_fReadonly)
       return ILS_E_ACCESS_DENIED;

	m_uModify |= LU_MOD_ATTRIB;
	return m_ExtendedAttrs.SetAttribute (bstrName, bstrValue);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::RemoveExtendedAttributes (IIlsAttributes *pAttributes, ULONG *puReqID)
//
// History:
//****************************************************************************

STDMETHODIMP CIlsUser::
RemoveExtendedAttribute ( BSTR bstrName )
{
    // Make sure this is not a read-only object
    //
    if (m_fReadonly)
       return ILS_E_ACCESS_DENIED;

	m_uModify |= LU_MOD_ATTRIB;
	return m_ExtendedAttrs.SetAttribute (bstrName, NULL);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetExtendedAttributes (IIlsAttributes **pAttributes)
//
//****************************************************************************
STDMETHODIMP CIlsUser::
GetExtendedAttribute ( BSTR bstrName, BSTR *pbstrValue )
{
	return m_ExtendedAttrs.GetAttribute (bstrName, pbstrValue);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetAllExtendedAttributes (IIlsAttributes **pAttributes)
//
//****************************************************************************
STDMETHODIMP CIlsUser::
GetAllExtendedAttributes ( IIlsAttributes **ppAttributes )
{
    if (ppAttributes == NULL)
        return ILS_E_PARAMETER;

    return m_ExtendedAttrs.CloneNameValueAttrib((CAttributes **) ppAttributes);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::CreateProtocol(
//         BSTR bstrProtocolID,
//         ULONG uPortNumber,
//         BSTR bstrMimeType,
//         IIlsProtocol **ppProtocol)
//****************************************************************************


STDMETHODIMP
CIlsUser::CreateProtocol(
        BSTR bstrProtocolID,
        ULONG uPortNumber,
        BSTR bstrMimeType,
        IIlsProtocol **ppProtocol)
{
    HRESULT hr= NOERROR;
    CLocalProt *pProt;

    if (!ppProtocol) {

        return (ILS_E_POINTER);

    }    

    *ppProtocol = NULL;

    pProt = new CLocalProt;

    if (!pProt) {

        return ILS_E_MEMORY;

    }

    hr = pProt->Init(bstrProtocolID, uPortNumber, bstrMimeType);

    if (SUCCEEDED(hr)) {

        pProt->QueryInterface(IID_IIlsProtocol, (void **)ppProtocol);

    }
    else {

        delete pProt;

    }
    return hr;
    
}


//****************************************************************************
// STDMETHODIMP
// CIlsUser::UpdateProtocol (IIlsProtocol *pProtocol,
//                            ULONG *puReqID, APP_CHANGE_PROT uCmd)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT CIlsUser::
UpdateProtocol (
	IIlsProtocol		*pProtocol,
	ULONG				*puReqID,
	APP_CHANGE_PROT		uCmd)
{
	ASSERT (uCmd == ILS_APP_ADD_PROT || uCmd == ILS_APP_REMOVE_PROT);

    // Validate parameters
    //
    if (pProtocol == NULL || puReqID == NULL)
        return ILS_E_POINTER;

    HRESULT hr;
    HANDLE  hLdapApp;
    LDAP_ASYNCINFO ldai; 

    // Check whether the protocol exists
    //
    CLocalProt *plp = NULL;
    HANDLE hEnum = NULL;
    m_ProtList.Enumerate(&hEnum);
    while(m_ProtList.Next(&hEnum, (VOID **)&plp) == NOERROR)
    {
    	ASSERT (plp != NULL);
        if (plp->IsSameAs((CLocalProt *)pProtocol) == NOERROR)
        {
            break;
        };

        plp = NULL;
    };

    if (plp != NULL)
    {
        // The protocol exists, fail if this add request
        //
        if (uCmd == ILS_APP_ADD_PROT)
        {
            return ILS_E_PARAMETER;
        };
    }
    else
    {
        // The protocol does not exist, fail if this remove request
        //
        if (uCmd == ILS_APP_REMOVE_PROT)
        {
            return ILS_E_PARAMETER;
        };
    };

	// Make sure we are not in the middle of registration/unregistration.
	//
	if (IsLocked ())
		return ILS_E_FAIL;

    // Must be registered to perform this operation
    //
    ILS_STATE uULSState = GetULSState ();
    if (uULSState == ILS_REGISTERED)
    {
        // Update the server information first
        //
        switch (uCmd)
        {
        case ILS_APP_ADD_PROT:
            hr = RegisterLocalProtocol(TRUE, (CLocalProt*)pProtocol, &ldai);
            break;

        case ILS_APP_REMOVE_PROT:
            hr = UnregisterLocalProtocol((CLocalProt*)pProtocol, &ldai);
            break;
        };
    
        switch (hr)
        {
        case NOERROR:
            //
            // Server starts updating the protocol successfullly
            // We will wait for the server response.
            //
            break;

        default:
            // ULS is locked. Return failure.
            //
            hr = ILS_E_ABORT;
            break; 
        }

        if (SUCCEEDED(hr))
        {
            ASSERT(ldai.uMsgID);

            ULONG   uMsg;
            switch(uCmd)
            {
            case ILS_APP_ADD_PROT:
                uMsg = WM_ILS_REGISTER_PROTOCOL;
                break;

            case ILS_APP_REMOVE_PROT:
                uMsg = WM_ILS_UNREGISTER_PROTOCOL;
                break;

            default:
                ASSERT(0);
                uCmd = ILS_APP_ADD_PROT;
                break;
            };

		    COM_REQ_INFO ri;
		    ReqInfo_Init (&ri);

            ri.uReqType = uMsg;
            ri.uMsgID = ldai.uMsgID;

			ReqInfo_SetUser (&ri, this);
			ReqInfo_SetProtocol (&ri, pProtocol);

            hr = g_pReqMgr->NewRequest(&ri);
            if (SUCCEEDED(hr))
            {
                // Make sure the objects do not disappear before we get the response
                //
                this->AddRef();
                pProtocol->AddRef();

                // Return the request ID
                //
                *puReqID = ri.uReqID;

            }
        }
    }
    else
    {
        // Just make local change
        //
        switch (uCmd)
        {
        case ILS_APP_ADD_PROT:
        	pProtocol->AddRef ();
        	hr = m_ProtList.Insert ((CLocalProt*)pProtocol);
            break;

        case ILS_APP_REMOVE_PROT:
        	ASSERT (plp != NULL && plp->IsSameAs((CLocalProt *)pProtocol) == S_OK);
        	if (plp != NULL)
        	{
	        	hr = m_ProtList.Remove (plp);
	        	if (hr == S_OK)
	        	{
	        		// The protocol object really exists in ths list
	        		//
	        		plp->Release (); // AddRef by above case
	        	}
        	}
            break;
        };

        *puReqID = 0;
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::AddProtocol (IIlsProtocol *pProtocol,
//                         ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
AddProtocol (IIlsProtocol *pProtocol, ULONG *puReqID)
{
    return UpdateProtocol (pProtocol, puReqID, ILS_APP_ADD_PROT);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::RemoveProtocol (IIlsProtocol *pProtocol,
//                            ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
RemoveProtocol ( IIlsProtocol *pProtocol, ULONG *puReqID )
{
    return UpdateProtocol (pProtocol, puReqID, ILS_APP_REMOVE_PROT);
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::EnumProtocols (IEnumIlsProtocols **ppEnumProtocol)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
CIlsUser::EnumLocalProtocols (IEnumIlsProtocols **ppEnumProtocol)
{
    CEnumProtocols *pep;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnumProtocol == NULL)
    {
        return ILS_E_POINTER;
    };

    // Assume failure
    //
    *ppEnumProtocol = NULL;

    // Create a peer enumerator
    //
    pep = new CEnumProtocols;

    if (pep != NULL)
    {
        hr = pep->Init(&m_ProtList);

        if (SUCCEEDED(hr))
        {
            // Get the enumerator interface
            //
            pep->AddRef();
            *ppEnumProtocol = pep;
        }
        else
        {
            delete pep;
        };
    }
    else
    {
        hr = ILS_E_MEMORY;
    };
    return hr;
}




//****************************************************************************
// STDMETHODIMP 
// CIlsUser::EnumProtocols(
//                        IIlsFilter     *pFilter,
//                        IIlsAttributes *pAttributes,
//                        IEnumIlsProtocols **pEnumProtocol,
//                        ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::EnumProtocols(
                       IIlsFilter     *pFilter,
                       IIlsAttributes *pAttributes,
                       IEnumIlsProtocols **ppEnumProtocol,
                       ULONG *puReqID)
{
    LDAP_ASYNCINFO ldai; 
    HRESULT hr=ILS_E_FAIL;

    // Validate parameter
    //
    if (puReqID == NULL)
    {
        return ILS_E_POINTER;
    };

    // We do not implement synchronous operation
    //
    if (ppEnumProtocol != NULL)
        return ILS_E_NOT_IMPL;

    if (m_fReadonly)
    {
        hr = ::UlsLdap_EnumProtocols (m_pIlsServer->GetServerInfo (), m_szID, m_szAppName, &ldai);
    }
    else
    {
        return ILS_E_ACCESS_DENIED;
    }

    if (SUCCEEDED(hr))
    {
	    COM_REQ_INFO ri;
	    ReqInfo_Init (&ri);

        // If updating server was successfully requested, wait for the response
        //
        ri.uReqType = WM_ILS_ENUM_PROTOCOLS;
        ri.uMsgID = ldai.uMsgID;

		ReqInfo_SetUser (&ri, this);

        hr = g_pReqMgr->NewRequest(&ri);

        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;
        };
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetProtocol (BSTR bstrProtocolID, IIlsAttributes *pAttributes,
//                          IIlsProtocol **ppProtocol, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP CIlsUser::
GetProtocol (
	BSTR				bstrProtocolID,
	IIlsAttributes		*pAttributes,
	IIlsProtocol		**ppProtocol,
	ULONG				*puReqID )
{
    LDAP_ASYNCINFO ldai;
    LPTSTR pszID;
    HRESULT hr;
	TCHAR *pszAttrNameList = NULL;
	ULONG cAttrNames = 0;
	ULONG cbNames = 0;

    // Validate parameter
    //
    if (bstrProtocolID == NULL || puReqID == NULL)
        return ILS_E_POINTER;

    // Make sure this is a read-only object from server
    //
    if (! m_fReadonly)
        return ILS_E_ACCESS_DENIED;

	// Make sure we have a valid server object
	//
	if (m_pIlsServer == NULL)
		return ILS_E_FAIL;

	// Convert protocol name
	//
    hr = BSTR_to_LPTSTR(&pszID, bstrProtocolID);
	if (hr != S_OK)
		return hr;

	// Get arbitrary attribute name list if any
	//
	if (pAttributes != NULL)
	{
		hr = ((CAttributes *) pAttributes)->GetAttributeList (&pszAttrNameList, &cAttrNames, &cbNames);
		if (hr != S_OK)
            goto MyExit;
	}

	hr = ::UlsLdap_ResolveProtocol (m_pIlsServer->GetServerInfo (),
									m_szID,
									m_szAppName,
									pszID,
									pszAttrNameList,
									cAttrNames,
									&ldai);
	if (hr != S_OK)
		goto MyExit;

	// If updating server was successfully requested, wait for the response
	//
    COM_REQ_INFO ri;
    ReqInfo_Init (&ri);

	ri.uReqType = WM_ILS_RESOLVE_PROTOCOL;
	ri.uMsgID = ldai.uMsgID;

	ReqInfo_SetUser (&ri, this);

	// Remember this request
	//
	hr = g_pReqMgr->NewRequest(&ri);
	if (SUCCEEDED(hr))
	{
	    // Make sure the objects do not disappear before we get the response
	    //
	    this->AddRef();

	    // Return the request ID
	    //
	    *puReqID = ri.uReqID;
	};

MyExit:

	::MemFree(pszAttrNameList);
	::MemFree (pszID);

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::EnumProtocolsResult (ULONG uReqID, PLDAP_ENUM ple)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::EnumProtocolsResult (ULONG uReqID, PLDAP_ENUM ple)
{
    ENUMRINFO eri;

    // Package the notification info
    //
    eri.uReqID  = uReqID;
    if (ple != NULL)
    {
	    eri.hResult = ple->hResult;
    	eri.cItems  = ple->cItems;
	    eri.pv      = (void *)(((PBYTE)ple)+ple->uOffsetItems);
	}
	else
	{
		eri.hResult = ILS_E_MEMORY;
		eri.cItems = 0;
		eri.pv = NULL;
	}
    NotifySink((void *)&eri, OnNotifyEnumProtocolsResult);
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::StateChanged ( BOOL fPrimary, TCHAR *pszServerName )
//
// History:
//  Thu 07-Nov-1996 12:52:00  -by-  Chu, Lon-Chan [lonchanc]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::StateChanged ( LONG Type, BOOL fPrimary )
{
	BSTR bstrServerName;
	HRESULT hr;

	if (m_pIlsServer != NULL)
	{
		bstrServerName = m_pIlsServer->DuplicateServerNameBSTR ();
	}
	else
	{
		bstrServerName = NULL;
		ASSERT (FALSE);
	}

	switch (Type)
	{
	case WM_ILS_CLIENT_NEED_RELOGON:
        SetULSState(ULSSVR_RELOGON);

	    hr = NotifySink (bstrServerName, fPrimary ?
   										OnNotifyStateChanged_UI_NoSuchObject :
   										OnNotifyStateChanged_NoUI_NoSuchObject);
   		break;
   	case WM_ILS_CLIENT_NETWORK_DOWN:

        SetULSState(ULSSVR_NETWORK_DOWN);

	    hr = NotifySink (bstrServerName, fPrimary ?
   										OnNotifyStateChanged_UI_NetworkDown :
   										OnNotifyStateChanged_NoUI_NetworkDown);
   		break;
   	}

   	return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::GetProtocolResult (ULONG uReqID, PLDAP_PROTINFO_RES ppir)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::GetProtocolResult (ULONG uReqID, PLDAP_PROTINFO_RES ppir)
{
    CLocalProt *pp;
    OBJRINFO objri;

    // Default to the server's result
    //
    objri.hResult = (ppir != NULL) ? ppir->hResult : ILS_E_MEMORY;

    if (SUCCEEDED(objri.hResult))
    {
        // The server returns PROTINFO, create a Application object
        //
        pp = new CLocalProt;

        if (pp != NULL)
        {
            objri.hResult = pp->Init(m_pIlsServer, m_szID, m_szAppName, &ppir->lpi);
            if (SUCCEEDED(objri.hResult))
            {
                pp->AddRef();
            }
            else
            {
                delete pp;
                pp = NULL;
            };
        }
        else
        {
            objri.hResult = ILS_E_MEMORY;
        };
    }
    else
    {
        pp = NULL;
    };

    // Package the notification info
    //
    objri.uReqID = uReqID;
    objri.pv = (void *)(pp == NULL ? NULL : (IIlsProtocol *)pp);
    NotifySink((void *)&objri, OnNotifyGetProtocolResult);

    if (pp != NULL)
    {
        pp->Release();
    };
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
{
    HRESULT hr = S_OK;

    if (m_pConnPt != NULL)
    {
        hr = m_pConnPt->Notify(pv, pfn);
    };
    return hr;
}

//****************************************************************************
// CEnumProtocols::CEnumProtocols (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumProtocols::CEnumProtocols (void)
{
    m_cRef = 0;
    hEnum = NULL;
    return;
}

//****************************************************************************
// CEnumProtocols::~CEnumProtocols (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumProtocols::~CEnumProtocols (void)
{
    CLocalProt *plp;

	ASSERT (m_cRef == 0);

    m_ProtList.Enumerate(&hEnum);
    while(m_ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR)
    {
        plp->Release();
    };
    m_ProtList.Flush();
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumProtocols::Init (CList *pProtList)
//
// History:
//  Wed 17-Apr-1996 11:15:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumProtocols::Init (CList *pProtList)
{
    CLocalProt *plp;
    HRESULT hr;

    // Duplicate the protocol list
    //
    hr = m_ProtList.Clone (pProtList, NULL);

    if (SUCCEEDED(hr))
    {
        // Add reference to each protocol object
        //
        m_ProtList.Enumerate(&hEnum);
        while(m_ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR)
        {
            plp->AddRef();
        };

        // Reset the enumerator
        //
        m_ProtList.Enumerate(&hEnum);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CEnumProtocols::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:15:31  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumProtocols::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumIlsProtocols || riid == IID_IUnknown)
    {
        *ppv = (IEnumIlsProtocols *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ILS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumProtocols::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:15:37  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumProtocols::AddRef (void)
{
    DllLock();

	MyDebugMsg ((DM_REFCOUNT, "CEnumProtocols::AddRef: ref=%ld\r\n", m_cRef));
	::InterlockedIncrement (&m_cRef);
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumProtocols::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:15:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumProtocols::Release (void)
{
    DllRelease();

	ASSERT (m_cRef > 0);

	MyDebugMsg ((DM_REFCOUNT, "CEnumProtocols::Release: ref=%ld\r\n", m_cRef));
    if (::InterlockedDecrement (&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return (ULONG) m_cRef;
}

//****************************************************************************
// STDMETHODIMP 
// CEnumProtocols::Next (ULONG cProtocols,
//                               IIlsProtocol **rgpProt,
//                               ULONG *pcFetched)
//
// History:
//  Wed 17-Apr-1996 11:15:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP 
CEnumProtocols::Next (ULONG cProtocols, IIlsProtocol **rgpProt,
                              ULONG *pcFetched)
{
    CLocalProt *plp;
    ULONG   cCopied;
    HRESULT hr;

    // Validate the pointer
    //
    if (rgpProt == NULL)
        return ILS_E_POINTER;

    // Validate the parameters
    //
    if ((cProtocols == 0) ||
        ((cProtocols > 1) && (pcFetched == NULL)))
        return ILS_E_PARAMETER;

    // Check the enumeration index
    //
    cCopied = 0;

    // Can copy if we still have more protocols
    //
    while ((cCopied < cProtocols) &&
           (m_ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR))
    {
        rgpProt[cCopied] = plp;
        plp->AddRef();
        cCopied++;
    };

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cProtocols == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumProtocols::Skip (ULONG cProtocols)
//
// History:
//  Wed 17-Apr-1996 11:15:56  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumProtocols::Skip (ULONG cProtocols)
{
    CLocalProt *plp;
    ULONG cSkipped;

    // Validate the parameters
    //
    if (cProtocols == 0) 
        return ILS_E_PARAMETER;

    // Check the enumeration index limit
    //
    cSkipped = 0;

    // Can skip only if we still have more attributes
    //
    while ((cSkipped < cProtocols) &&
           (m_ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR))
    {
        cSkipped++;
    };

    return (cProtocols == cSkipped ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumProtocols::Reset (void)
//
// History:
//  Wed 17-Apr-1996 11:16:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumProtocols::Reset (void)
{
    m_ProtList.Enumerate(&hEnum);
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumProtocols::Clone(IEnumIlsProtocols **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:16:11  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumProtocols::Clone(IEnumIlsProtocols **ppEnum)
{
    CEnumProtocols *pep;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ILS_E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    pep = new CEnumProtocols;
    if (pep == NULL)
        return ILS_E_MEMORY;

    // Clone the information
    //
    pep->hEnum = hEnum;
    hr = pep->m_ProtList.Clone (&m_ProtList, &(pep->hEnum));

    if (SUCCEEDED(hr))
    {
        CLocalProt *plp;
        HANDLE hEnumTemp;

        // Add reference to each protocol object
        //
        pep->m_ProtList.Enumerate(&hEnumTemp);
        while(pep->m_ProtList.Next(&hEnumTemp, (PVOID *)&plp) == NOERROR)
        {
            plp->AddRef();
        };

        // Return the cloned enumerator
        //
        pep->AddRef();
        *ppEnum = pep;
    }
    else
    {
        delete pep;
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:15:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return E_POINTER;
    };
    
    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ILS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecp->Init((IConnectionPoint *)m_pConnPt);
    if (FAILED(hr))
    {
        delete pecp;
        return hr;
    };

    // Give it back to the caller
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CIlsUser::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
//
// History:
//  Wed 17-Apr-1996 11:15:09  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CIlsUser::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
{
    IID siid;
    HRESULT hr;

    // Validate parameters
    //
    if (ppcp == NULL)
    {
        return E_POINTER;
    };
    
    // Assume failure
    //
    *ppcp = NULL;

    if (m_pConnPt != NULL)
    {
        hr = m_pConnPt->GetConnectionInterface(&siid);

        if (SUCCEEDED(hr))
        {
            if (riid == siid)
            {
                *ppcp = (IConnectionPoint *)m_pConnPt;
                (*ppcp)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = ILS_E_NO_INTERFACE;
            };
        };
    }
    else
    {
        hr = ILS_E_NO_INTERFACE;
    };

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\init.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       init.cpp
//  Content:    This file contains the module initialization.
//  History:
//      Tue 08-Oct-1996 08:51:15  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "regunreg.h"
#include <ilsguid.h>
#include "classfac.h"

//****************************************************************************
// Constants
//****************************************************************************

//****************************************************************************
// Global Parameters
//****************************************************************************

HINSTANCE           g_hInstance = NULL;
LONG                g_cDllRef = 0;
#ifdef _DEBUG
LONG				g_cCritSec = 0;
#endif
CRITICAL_SECTION    g_ULSSem;

#ifdef DEBUG
HDBGZONE ghZoneUls = NULL; // ULS zones
static PTCHAR _rgZonesUls[] = {
	TEXT("ILS"),
	TEXT("Error"),
	TEXT("Warning"),
	TEXT("Trace"),
	TEXT("RefCount"),
	TEXT("KA"),
	TEXT("Filter"),
	TEXT("Request"),
	TEXT("Response"),
	TEXT("Connection"),
};
#endif


//****************************************************************************
// BOOL _Processattach (HINSTANCE)
//
// This function is called when a process is attached to the DLL
//
// History:
//  Tue 08-Oct-1996 08:53:03  -by-  Viroon  Touranachun [viroont]
// Ported from Shell.
//****************************************************************************

BOOL _ProcessAttach(HINSTANCE hDll)
{
	// Tracking critical section leaks
	//
#ifdef _DEBUG
	g_cCritSec = 0;
	g_cDllRef = 0;
#endif

    g_hInstance = hDll;
    MyInitializeCriticalSection (&g_ULSSem);
    return TRUE;
}

//****************************************************************************
// BOOL _ProcessDetach (HINSTANCE)
//
// This function is called when a process is detached from the DLL
//
// History:
//  Tue 08-Oct-1996 08:53:11  -by-  Viroon  Touranachun [viroont]
// Ported from Shell.
//****************************************************************************

BOOL _ProcessDetach(HINSTANCE hDll)
{
    MyDeleteCriticalSection (&g_ULSSem);

#ifdef _DEBUG
    DBG_REF("ULS g_cCritSec=%d", g_cCritSec);
    DBG_REF("ULS RefCount=%d", g_cDllRef);
#endif

    return TRUE;
}

//****************************************************************************
// BOOL APIENTRY DllMain(HINSTANCE hDll, DWORD dwReason,  LPVOID lpReserved)
//
// This function is called when the DLL is loaded
//
// History:
//  Tue 08-Oct-1996 08:53:22  -by-  Viroon  Touranachun [viroont]
// Ported from Shell.
//****************************************************************************

BOOL APIENTRY DllMain(HINSTANCE hDll, DWORD dwReason,  LPVOID lpReserved)
{
    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
			DBGINIT(&ghZoneUls, _rgZonesUls);
            DisableThreadLibraryCalls(hDll);
            DBG_INIT_MEMORY_TRACKING(hDll);
            _ProcessAttach(hDll);
            break;

        case DLL_PROCESS_DETACH:
            _ProcessDetach(hDll);
            DBG_CHECK_MEMORY_TRACKING(hDll);
			DBGDEINIT(&ghZoneUls);
            break;

        default:
            break;

    } // end switch()

    return TRUE;
}

//****************************************************************************
// STDAPI DllCanUnLoadNow()
//
// This function is called to check whether it can be unloaded.
//
// History:
//  Tue 08-Oct-1996 08:53:35  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDAPI DllCanUnloadNow(void)
{
    if (g_cDllRef)
        return S_FALSE;

    return S_OK;
}

//****************************************************************************
// STDAPI DllRegisterServer(void)
//
// This function is called to check whether it can be unloaded.
//
// History:
//  Tue 08-Oct-1996 08:53:35  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDAPI DllRegisterServer(void)
{
    if (RegisterUnknownObject(TEXT("Internet Location Services"),
                              CLSID_InternetLocationServices))
        return S_OK;
    else
        return ILS_E_FAIL;
}

//****************************************************************************
// STDAPI DllUnregisterServer(void)
//
// This function is called to check whether it can be unloaded.
//
// History:
//  Tue 08-Oct-1996 08:53:35  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDAPI DllUnregisterServer(void)
{
    if (UnregisterUnknownObject(CLSID_InternetLocationServices))
        return S_OK;
    else
        return ILS_E_FAIL;
}

//****************************************************************************
// void DllLock()
//
// This function is called to prevent the DLL from being unloaded.
//
// History:
//  Tue 08-Oct-1996 08:53:45  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void DllLock(void)
{
    InterlockedIncrement(&g_cDllRef);
}

//****************************************************************************
// void DllRelease()
//
// This function is called to allow the DLL to be unloaded.
//
// History:
//  Tue 08-Oct-1996 08:53:52  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void DllRelease(void)
{
    InterlockedDecrement(&g_cDllRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\localapp.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       localapp.cpp
//  Content:    This file contains the LocalApplication object.
//  History:
//      Wed 17-Apr-1996 11:13:54  -by-  Viroon  Touranachun [viroont]
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "localapp.h"
#include "localprt.h"
#include "attribs.h"
#include "callback.h"
#include "culs.h"

//****************************************************************************
// Event Notifiers
//****************************************************************************
//
//****************************************************************************
// HRESULT
// OnNotifyLocalAppAttributesChangeResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyLocalAppAttributesChangeResult (IUnknown *pUnk, void *pv)
{
    PSRINFO psri = (PSRINFO)pv;

    ((IULSLocalAppNotify*)pUnk)->AttributesChangeResult(psri->uReqID,
                                                        psri->hResult);
    return S_OK;
}

//****************************************************************************
// HRESULT
// OnNotifyLocalAppProtocolChangeResult (IUnknown *pUnk, void *pv)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HRESULT
OnNotifyLocalAppProtocolChangeResult (IUnknown *pUnk, void *pv)
{
    PSRINFO psri = (PSRINFO)pv;

    ((IULSLocalAppNotify*)pUnk)->ProtocolChangeResult(psri->uReqID,
                                                      psri->hResult);
    return S_OK;
}

//****************************************************************************
// Class Implementation
//****************************************************************************
//
//****************************************************************************
// CLocalApp::CLocalApp (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CLocalApp::CLocalApp (void)
{
    cRef = 0;
    szName = NULL;
    guid = GUID_NULL;
    szMimeType = NULL;
    pAttrs = NULL;
    pConnPt = NULL;
    return;
}

//****************************************************************************
// CLocalApp::~CLocalApp (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CLocalApp::~CLocalApp (void)
{
    CLocalProt *plp;
    HANDLE hEnum;

    // Release the connection point
    //
    if (pConnPt != NULL)
    {
        pConnPt->ContainerReleased();
        ((IConnectionPoint*)pConnPt)->Release();
    };

    // Release the protocol objects
    //
    ProtList.Enumerate(&hEnum);
    while(ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR)
    {
        plp->Release();
    };
    ProtList.Flush();

    // Release the attributes object
    //
    if (pAttrs != NULL)
    {
        pAttrs->Release();
    };

    // Release the buffer resources
    //
    if (szName != NULL)
    {
        FreeLPTSTR(szName);
    };

    if (szMimeType != NULL)
    {
        FreeLPTSTR(szMimeType);
    };

    return;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::Init (BSTR bstrName, REFGUID rguid, BSTR bstrMimeType)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::Init (BSTR bstrName, REFGUID rguid, BSTR bstrMimeType)
{
    HRESULT hr;

    // Cache the application information
    //
    guid = rguid;

    hr = BSTR_to_LPTSTR(&szName, bstrName);
    if (SUCCEEDED(hr))
    {
        hr = BSTR_to_LPTSTR(&szMimeType, bstrMimeType);
        if (SUCCEEDED(hr))
        {
            // Initialize the attributes list
            //
            pAttrs = new CAttributes (ULS_ATTRACCESS_NAME_VALUE);

            if (pAttrs != NULL)
            {
                // Make the connection point
                //
                pConnPt = new CConnectionPoint (&IID_IULSLocalAppNotify,
                                                (IConnectionPointContainer *)this);
                if (pConnPt != NULL)
                {
                    ((IConnectionPoint*)pConnPt)->AddRef();
                    hr = NOERROR;
                }
                else
                {
                    hr = ULS_E_MEMORY;
                };
            }
            else
            {
                hr = ULS_E_MEMORY;
            };
        };
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:14:08  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::QueryInterface (REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IULSLocalApplication || riid == IID_IUnknown)
    {
        *ppv = (IULS *) this;
    }
    else
    {
        if (riid == IID_IConnectionPointContainer)
        {
            *ppv = (IConnectionPointContainer *) this;
        };
    };

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        return ULS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CLocalApp::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:14:17  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CLocalApp::AddRef (void)
{
    cRef++;
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CLocalApp::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:14:26  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CLocalApp::Release (void)
{
    cRef--;

    if (cRef == 0)
    {
        delete this;
        return 0;
    }
    else
    {
        return cRef;
    };
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::NotifySink (void *pv, CONN_NOTIFYPROC pfn)
{
    HRESULT hr = S_OK;

    if (pConnPt != NULL)
    {
        hr = pConnPt->Notify(pv, pfn);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::AttributesChangeResult (CAttributes *pAttributes,
//                                    ULONG uReqID, HRESULT hResult,
//                                    APP_CHANGE_ATTRS uCmd)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::AttributesChangeResult (CAttributes *pAttributes,
                                   ULONG uReqID, HRESULT hResult,
                                   APP_CHANGE_ATTRS uCmd)
{
    SRINFO sri;

    // If the server accepts the changes, modify the local information
    //
    if (SUCCEEDED(hResult))
    {
        // Update based on the command.
        //
        switch(uCmd)
        {
            case ULS_APP_SET_ATTRIBUTES:
                hResult = pAttrs->SetAttributes(pAttributes);
                break;

            case ULS_APP_REMOVE_ATTRIBUTES:
                hResult = pAttrs->RemoveAttributes(pAttributes);
                break;

            default:
                ASSERT(0);
                break;
        };
    };

    // Notify the sink object
    //
    sri.uReqID = uReqID;
    sri.hResult = hResult;
    hResult = NotifySink((void *)&sri, OnNotifyLocalAppAttributesChangeResult);

#ifdef DEBUG
    DPRINTF (TEXT("CLocalApp--current attributes********************\r\n"));
    pAttrs->DebugOut();
    DPRINTF (TEXT("\r\n*************************************************"));
#endif // DEBUG;

    return hResult;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::ProtocolChangeResult (CLocalProt *pProtocol,
//                                  ULONG uReqID, HRESULT hResult,
//                                  APP_CHANGE_PROT uCmd)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::ProtocolChangeResult (CLocalProt *pProtocol,
                                 ULONG uReqID, HRESULT hResult,
                                 APP_CHANGE_PROT uCmd)
{
    SRINFO sri;

    // If the server accepts the changes, modify the local information
    //
    if (SUCCEEDED(hResult))
    {
        // Update based on the command.
        //
        switch(uCmd)
        {
            case ULS_APP_ADD_PROT:
                hResult = ProtList.Insert((PVOID)pProtocol);
                if (SUCCEEDED(hResult))
                {
                    pProtocol->AddRef();
                };
                break;

            case ULS_APP_REMOVE_PROT:
                hResult = ProtList.Remove((PVOID)pProtocol);
                if (SUCCEEDED(hResult))
                {
                    pProtocol->Release();
                };
                break;

            default:
                ASSERT(0);
                break;
        };
    };

    // Notify the sink object
    //
    sri.uReqID = uReqID;
    sri.hResult = hResult;
    hResult = NotifySink((void *)&sri, OnNotifyLocalAppProtocolChangeResult);

#ifdef DEBUG
    DPRINTF (TEXT("CLocalApp--current Protocols********************\r\n"));
    DebugProtocolDump();
    DPRINTF (TEXT("\r\n*************************************************"));
#endif // DEBUG;

    return hResult;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::CreateProtocol (BSTR bstrProtocolID, ULONG uPortNumber,
//                            BSTR bstrMimeType,
//                            IULSLocalAppProtocol **ppProtocol)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::CreateProtocol (BSTR bstrProtocolID, ULONG uPortNumber,
                           BSTR bstrMimeType,
                           IULSLocalAppProtocol **ppProtocol)
{
    CLocalProt *plp;
    HRESULT hr;

    // Validate parameter
    //
    if (ppProtocol == NULL)
    {
        return ULS_E_POINTER;
    };

    // Assume failure
    //
    *ppProtocol = NULL;

    // Create a new object
    //
    plp = new CLocalProt;

    if (plp != NULL)
    {
        hr = plp->Init(bstrProtocolID, uPortNumber, bstrMimeType);

        if (SUCCEEDED(hr))
        {
            plp->AddRef();
            *ppProtocol = plp;
        };
    }
    else
    {
        hr = ULS_E_MEMORY;
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::ChangeProtocol (IULSLocalAppProtocol *pProtocol,
//                            ULONG *puReqID, APP_CHANGE_PROT uCmd)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::ChangeProtocol (IULSLocalAppProtocol *pProtocol,
                           ULONG *puReqID, APP_CHANGE_PROT uCmd)
{
    CLocalProt *plp;
    PVOID   pv;
    HRESULT hr;
    HANDLE  hLdapApp;
    LDAP_ASYNCINFO ldai; 
    HANDLE hEnum;

    // Validate parameters
    //
    if ((pProtocol == NULL) ||
        (puReqID == NULL))
    {
        return ULS_E_POINTER;
    };

    hr = pProtocol->QueryInterface(IID_IULSLocalAppProtocol, &pv);

    if (FAILED(hr))
    {
        return ULS_E_PARAMETER;
    };
    pProtocol->Release();

    // Check whether the protocol exists
    //
    ProtList.Enumerate(&hEnum);
    while(ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR)
    {
        if (plp->IsSameAs((CLocalProt *)pProtocol) == NOERROR)
        {
            break;
        };
    };

    if (plp != NULL)
    {
        // The protocol exists, fail if this add request
        //
        if (uCmd == ULS_APP_ADD_PROT)
        {
            return ULS_E_PARAMETER;
        };
    }
    else
    {
        // The protocol does not exist, fail if this remove request
        //
        if (uCmd == ULS_APP_REMOVE_PROT)
        {
            return ULS_E_PARAMETER;
        };
    };

    // Update the server information first
    //
    switch (uCmd)
    {
        case ULS_APP_ADD_PROT:
            hr = g_pCUls->RegisterLocalProtocol((CLocalProt*)pProtocol, &ldai);
            break;

        case ULS_APP_REMOVE_PROT:
            hr = g_pCUls->UnregisterLocalProtocol((CLocalProt*)pProtocol, &ldai);
            break;

        default:
            ASSERT(0);
            break;
    };
    
    switch (hr)
    {
        case NOERROR:
            //
            // Server starts updating the protocol successfullly
            // We will wait for the server response.
            //
            break;

        case S_FALSE:
            //
            // We have not registered, will do local response
            //
            hr = NOERROR;
            ldai.uMsgID = 0;    
            break;

        default:
            // ULS is locked. Return failure.
            //
            hr = ULS_E_ABORT;
            break; 
    }

    if (SUCCEEDED(hr))
    {
        REQUESTINFO ri;
        ULONG   uMsg;

        switch(uCmd)
        {
            case ULS_APP_ADD_PROT:
                uMsg = (ldai.uMsgID == 0 ? WM_ULS_LOCAL_REGISTER_PROTOCOL:
                                           WM_ULS_REGISTER_PROTOCOL);
                break;

            case ULS_APP_REMOVE_PROT:
                uMsg = (ldai.uMsgID == 0 ? WM_ULS_LOCAL_UNREGISTER_PROTOCOL :
                                           WM_ULS_UNREGISTER_PROTOCOL);
                break;

            default:
                ASSERT(0);
                break;
        };
 
        // If updating server was successfully requested, wait for the response
        //
        ri.uReqType = uMsg;
        ri.uMsgID = ldai.uMsgID;
        ri.pv     = (PVOID)this;
        ri.lParam = (LPARAM)((CLocalProt*)pProtocol);

        hr = g_pReqMgr->NewRequest(&ri);

        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();
            pProtocol->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;

            // If not registered with server, start async response ourselves
            //
            if (ldai.uMsgID == 0)
            {
                g_pCUls->LocalAsyncRespond(uMsg, ri.uReqID, NOERROR);
            };
        };
    };

    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::AddProtocol (IULSLocalAppProtocol *pProtocol,
//                         ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::AddProtocol (IULSLocalAppProtocol *pProtocol,
                        ULONG *puReqID)
{
    return ChangeProtocol(pProtocol, puReqID, ULS_APP_ADD_PROT);
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::RemoveProtocol (IULSLocalAppProtocol *pProtocol,
//                            ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::RemoveProtocol (IULSLocalAppProtocol *pProtocol,
                           ULONG *puReqID)
{
    return ChangeProtocol(pProtocol, puReqID, ULS_APP_REMOVE_PROT);
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::EnumProtocols (IEnumULSLocalAppProtocols **ppEnumProtocol)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::EnumProtocols (IEnumULSLocalAppProtocols **ppEnumProtocol)
{
    CEnumLocalAppProtocols *pep;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnumProtocol == NULL)
    {
        return ULS_E_POINTER;
    };

    // Assume failure
    //
    *ppEnumProtocol = NULL;

    // Create a peer enumerator
    //
    pep = new CEnumLocalAppProtocols;

    if (pep != NULL)
    {
        hr = pep->Init(&ProtList);

        if (SUCCEEDED(hr))
        {
            // Get the enumerator interface
            //
            pep->AddRef();
            *ppEnumProtocol = pep;
        }
        else
        {
            delete pep;
        };
    }
    else
    {
        hr = ULS_E_MEMORY;
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::ChangeAttributes (IULSAttributes *pAttributes, ULONG *puReqID,
//                              APP_CHANGE_ATTRS uCmd)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::ChangeAttributes (IULSAttributes *pAttributes, ULONG *puReqID,
                             APP_CHANGE_ATTRS uCmd)
{
    PVOID   pv;
    HRESULT hr;
    HANDLE  hLdapApp;
    LDAP_ASYNCINFO ldai; 

    // Validate parameters
    //
    if ((pAttributes == NULL) ||
        (puReqID == NULL))
    {
        return ULS_E_POINTER;
    };

    hr = pAttributes->QueryInterface(IID_IULSAttributes, &pv);

    if (FAILED(hr))
    {
        return ULS_E_PARAMETER;
    };

    // If no attributes, fails the call
    //
    if (((CAttributes*)pAttributes)->GetCount() == 0)
    {
        return ULS_E_PARAMETER;
    };

    // Check if already registered
    //
    hr = g_pCUls->GetAppHandle(&hLdapApp);

    switch (hr)
    {
        case NOERROR:
        {
            LPTSTR pAttrList;
            ULONG  cAttrs, cb;

            // Yes, get the attributes list
            //
            switch (uCmd)
            {
                case ULS_APP_SET_ATTRIBUTES:
                    hr = ((CAttributes*)pAttributes)->GetAttributePairs(&pAttrList,
                                                                        &cAttrs,
                                                                        &cb);
                    if (SUCCEEDED(hr))
                    {
                        hr = ::UlsLdap_SetAppAttrs(hLdapApp, cAttrs, pAttrList,
                                                   &ldai);
                        FreeLPTSTR(pAttrList);
                    };
                    break;

                case ULS_APP_REMOVE_ATTRIBUTES:
                    hr = ((CAttributes*)pAttributes)->GetAttributeList(&pAttrList,
                                                                        &cAttrs,
                                                                        &cb);

                    if (SUCCEEDED(hr))
                    {
                        hr = ::UlsLdap_RemoveAppAttrs(hLdapApp, cAttrs, pAttrList,
                                                      &ldai);
                        FreeLPTSTR(pAttrList);
                    };
                    break;

                default:
                    ASSERT(0);
                    break;
            };
            break;
        }
    
        case S_FALSE:
            //
            // Not registered, will do local response
            //
            hr = NOERROR;
            ldai.uMsgID = 0;
            break;

        default:
            // ULS is locked. Return failure.
            //
            hr = ULS_E_ABORT;
            break; 
    };

    if (SUCCEEDED(hr))
    {
        REQUESTINFO ri;
        ULONG   uMsg;

        switch(uCmd)
        {
            case ULS_APP_SET_ATTRIBUTES:
                uMsg = (ldai.uMsgID == 0 ? WM_ULS_LOCAL_SET_APP_ATTRS :
                                           WM_ULS_SET_APP_ATTRS);
                break;

            case ULS_APP_REMOVE_ATTRIBUTES:
                uMsg = (ldai.uMsgID == 0 ? WM_ULS_LOCAL_REMOVE_APP_ATTRS :
                                           WM_ULS_REMOVE_APP_ATTRS);
                break;

            default:
                ASSERT(0);
                break;
        };

        // If updating server was successfully requested, wait for the response
        //
        ri.uReqType = uMsg;
        ri.uMsgID = ldai.uMsgID;
        ri.pv     = (PVOID)this;
        ri.lParam = (LPARAM)((CAttributes *)pAttributes);

        hr = g_pReqMgr->NewRequest(&ri);

        if (SUCCEEDED(hr))
        {
            // Make sure the objects do not disappear before we get the response
            //
            this->AddRef();
            pAttributes->AddRef();

            // Return the request ID
            //
            *puReqID = ri.uReqID;

            // If not registered with server, start async response ourselves
            //
            if (ldai.uMsgID == 0)
            {
                g_pCUls->LocalAsyncRespond(uMsg, ri.uReqID, NOERROR);
            };
        };
    };

    // Matching the QueryInterface
    //
    pAttributes->Release();
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::SetAttributes (IULSAttributes *pAttributes, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::SetAttributes (IULSAttributes *pAttributes, ULONG *puReqID)
{
    return ChangeAttributes(pAttributes, puReqID, ULS_APP_SET_ATTRIBUTES);
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::RemoveAttributes (IULSAttributes *pAttributes, ULONG *puReqID)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::RemoveAttributes (IULSAttributes *pAttributes, ULONG *puReqID)
{
    return ChangeAttributes(pAttributes, puReqID, ULS_APP_REMOVE_ATTRIBUTES);
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::GetAppInfo (PLDAP_APPINFO *ppAppInfo)
//
// History:
//  Wed 17-Apr-1996 11:15:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::GetAppInfo (PLDAP_APPINFO *ppAppInfo)
{
    PLDAP_APPINFO pai;
    ULONG cName, cMime;
    LPTSTR szAttrs;
    ULONG cAttrs, cbAttrs;
    HRESULT hr;

    // Assume failure
    //
    *ppAppInfo = NULL;

    // Calculate the buffer size
    //
    cName = lstrlen(szName)+1;
    cMime = lstrlen(szMimeType)+1;

    // Get the attribute pairs
    //
    hr = pAttrs->GetAttributePairs(&szAttrs, &cAttrs, &cbAttrs);
    if (FAILED(hr))
    {
        return hr;
    };

    // Allocate the buffer
    //
    pai = (PLDAP_APPINFO)LocalAlloc(LPTR, sizeof(LDAP_APPINFO) +
                                                ((cName + cMime)* sizeof(TCHAR)) +
                                                cbAttrs);
    if (pai == NULL)
    {
        hr = ULS_E_MEMORY;
    }
    else
    {
        // Fill the structure content
        //
        pai->uSize              = sizeof(*pai);
        pai->guid               = guid;
        pai->uOffsetName        = sizeof(*pai);
        pai->uOffsetMimeType    = pai->uOffsetName + (cName*sizeof(TCHAR));
        pai->cAttributes        = cAttrs;
        pai->uOffsetAttributes  = (cAttrs != 0 ?
                                   pai->uOffsetMimeType  + (cMime*sizeof(TCHAR)) :
                                   0);

        // Copy the user information
        //
        lstrcpy((LPTSTR)(((PBYTE)pai)+pai->uOffsetName), szName);
        lstrcpy((LPTSTR)(((PBYTE)pai)+pai->uOffsetMimeType), szMimeType);
        if (cAttrs)
        {
            CopyMemory(((PBYTE)pai)+pai->uOffsetAttributes, szAttrs, cbAttrs);
        };

        // Return the structure
        //
        *ppAppInfo = pai;
    };

    if (szAttrs != NULL)
    {
        FreeLPTSTR(szAttrs);
    };
    return NOERROR;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:15:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    CEnumConnectionPoints *pecp;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ULS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppEnum = NULL;

    // Create an enumerator
    //
    pecp = new CEnumConnectionPoints;
    if (pecp == NULL)
        return ULS_E_MEMORY;

    // Initialize the enumerator
    //
    hr = pecp->Init((IConnectionPoint *)pConnPt);
    if (FAILED(hr))
    {
        delete pecp;
        return hr;
    };

    // Give it back to the caller
    //
    pecp->AddRef();
    *ppEnum = pecp;
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CLocalApp::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
//
// History:
//  Wed 17-Apr-1996 11:15:09  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CLocalApp::FindConnectionPoint(REFIID riid, IConnectionPoint **ppcp)
{
    IID siid;
    HRESULT hr;

    // Validate parameters
    //
    if (ppcp == NULL)
    {
        return ULS_E_POINTER;
    };
    
    // Assume failure
    //
    *ppcp = NULL;

    if (pConnPt != NULL)
    {
        hr = pConnPt->GetConnectionInterface(&siid);

        if (SUCCEEDED(hr))
        {
            if (riid == siid)
            {
                *ppcp = (IConnectionPoint *)pConnPt;
                (*ppcp)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = ULS_E_NO_INTERFACE;
            };
        };
    }
    else
    {
        hr = ULS_E_NO_INTERFACE;
    };

    return hr;
}

#ifdef DEBUG
//****************************************************************************
// void
// CLocalApp::DebugProtocolDump (void)
//
// History:
//  Wed 17-Apr-1996 11:14:03  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

void
CLocalApp::DebugProtocolDump (void)
{
    CLocalProt *plp;
    BSTR bstrID;
    LPTSTR pszID;
    ULONG  cCount;
    HANDLE hEnum;

    // Each protocol
    //
    cCount = 1;
    ProtList.Enumerate(&hEnum);
    while(ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR)
    {
        if (SUCCEEDED(plp->GetID (&bstrID)))
        {
            BSTR_to_LPTSTR(&pszID, bstrID);
            DPRINTF2(TEXT("%d> %s"), cCount++, pszID);
            FreeLPTSTR(pszID);
            SysFreeString(bstrID);
        };
    };
    return;
}
#endif // DEBUG

//****************************************************************************
// CEnumLocalAppProtocols::CEnumLocalAppProtocols (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumLocalAppProtocols::CEnumLocalAppProtocols (void)
{
    cRef = 0;
    hEnum = NULL;
    return;
}

//****************************************************************************
// CEnumLocalAppProtocols::~CEnumLocalAppProtocols (void)
//
// History:
//  Wed 17-Apr-1996 11:15:18  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

CEnumLocalAppProtocols::~CEnumLocalAppProtocols (void)
{
    CLocalProt *plp;

    ProtList.Enumerate(&hEnum);
    while(ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR)
    {
        plp->Release();
    };
    ProtList.Flush();
    return;
}

//****************************************************************************
// STDMETHODIMP
// CEnumLocalAppProtocols::Init (CList *pProtList)
//
// History:
//  Wed 17-Apr-1996 11:15:25  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumLocalAppProtocols::Init (CList *pProtList)
{
    CLocalProt *plp;
    HRESULT hr;

    // Duplicate the protocol list
    //
    hr = ProtList.Clone (pProtList, NULL);

    if (SUCCEEDED(hr))
    {
        // Add reference to each protocol object
        //
        ProtList.Enumerate(&hEnum);
        while(ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR)
        {
            plp->AddRef();
        };

        // Reset the enumerator
        //
        ProtList.Enumerate(&hEnum);
    };
    return hr;
}

//****************************************************************************
// STDMETHODIMP
// CEnumLocalAppProtocols::QueryInterface (REFIID riid, void **ppv)
//
// History:
//  Wed 17-Apr-1996 11:15:31  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumLocalAppProtocols::QueryInterface (REFIID riid, void **ppv)
{
    if (riid == IID_IEnumULSLocalAppProtocols || riid == IID_IUnknown)
    {
        *ppv = (IEnumULSLocalAppProtocols *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return ULS_E_NO_INTERFACE;
    };
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumLocalAppProtocols::AddRef (void)
//
// History:
//  Wed 17-Apr-1996 11:15:37  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumLocalAppProtocols::AddRef (void)
{
    cRef++;
    return cRef;
}

//****************************************************************************
// STDMETHODIMP_(ULONG)
// CEnumLocalAppProtocols::Release (void)
//
// History:
//  Wed 17-Apr-1996 11:15:43  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP_(ULONG)
CEnumLocalAppProtocols::Release (void)
{
    cRef--;

    if (cRef == 0)
    {
        delete this;
        return 0;
    }
    else
    {
        return cRef;
    };
}

//****************************************************************************
// STDMETHODIMP 
// CEnumLocalAppProtocols::Next (ULONG cProtocols,
//                               IULSLocalAppProtocol **rgpProt,
//                               ULONG *pcFetched)
//
// History:
//  Wed 17-Apr-1996 11:15:49  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP 
CEnumLocalAppProtocols::Next (ULONG cProtocols, IULSLocalAppProtocol **rgpProt,
                              ULONG *pcFetched)
{
    CLocalProt *plp;
    ULONG   cCopied;
    HRESULT hr;

    // Validate the pointer
    //
    if (rgpProt == NULL)
        return ULS_E_POINTER;

    // Validate the parameters
    //
    if ((cProtocols == 0) ||
        ((cProtocols > 1) && (pcFetched == NULL)))
        return ULS_E_PARAMETER;

    // Check the enumeration index
    //
    cCopied = 0;

    // Can copy if we still have more protocols
    //
    while ((cCopied < cProtocols) &&
           (ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR))
    {
        rgpProt[cCopied] = plp;
        plp->AddRef();
        cCopied++;
    };

    // Determine the returned information based on other parameters
    //
    if (pcFetched != NULL)
    {
        *pcFetched = cCopied;
    };
    return (cProtocols == cCopied ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumLocalAppProtocols::Skip (ULONG cProtocols)
//
// History:
//  Wed 17-Apr-1996 11:15:56  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumLocalAppProtocols::Skip (ULONG cProtocols)
{
    CLocalProt *plp;
    ULONG cSkipped;

    // Validate the parameters
    //
    if (cProtocols == 0) 
        return ULS_E_PARAMETER;

    // Check the enumeration index limit
    //
    cSkipped = 0;

    // Can skip only if we still have more attributes
    //
    while ((cSkipped < cProtocols) &&
           (ProtList.Next(&hEnum, (PVOID *)&plp) == NOERROR))
    {
        cSkipped++;
    };

    return (cProtocols == cSkipped ? S_OK : S_FALSE);
}

//****************************************************************************
// STDMETHODIMP
// CEnumLocalAppProtocols::Reset (void)
//
// History:
//  Wed 17-Apr-1996 11:16:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumLocalAppProtocols::Reset (void)
{
    ProtList.Enumerate(&hEnum);
    return S_OK;
}

//****************************************************************************
// STDMETHODIMP
// CEnumLocalAppProtocols::Clone(IEnumULSLocalAppProtocols **ppEnum)
//
// History:
//  Wed 17-Apr-1996 11:16:11  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

STDMETHODIMP
CEnumLocalAppProtocols::Clone(IEnumULSLocalAppProtocols **ppEnum)
{
    CEnumLocalAppProtocols *pep;
    HRESULT hr;

    // Validate parameters
    //
    if (ppEnum == NULL)
    {
        return ULS_E_POINTER;
    };

    *ppEnum = NULL;

    // Create an enumerator
    //
    pep = new CEnumLocalAppProtocols;
    if (pep == NULL)
        return ULS_E_MEMORY;

    // Clone the information
    //
    pep->hEnum = hEnum;
    hr = pep->ProtList.Clone (&ProtList, &(pep->hEnum));

    if (SUCCEEDED(hr))
    {
        CLocalProt *plp;
        HANDLE hEnumTemp;

        // Add reference to each protocol object
        //
        pep->ProtList.Enumerate(&hEnumTemp);
        while(pep->ProtList.Next(&hEnumTemp, (PVOID *)&plp) == NOERROR)
        {
            plp->AddRef();
        };

        // Return the cloned enumerator
        //
        pep->AddRef();
        *ppEnum = pep;
    }
    else
    {
        delete pep;
    };
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\localver.h ===
/* Version resource specific to uls.dll */

#define VER_DESCRIPTION_STR  "User Location Services Component Module\0"
#define VER_INTERNALNAME_STR "uls\0"
#define VER_ORIGNAME_STR     "uls.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\regunreg.h ===
//=--------------------------------------------------------------------------=
// RegUnReg.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains utilities that we will find useful.
//
#ifndef _REGUNREG_H_

//=--------------------------------------------------------------------------=
// registry helpers.
//
// takes some information about an Automation Object, and places all the
// relevant information about it in the registry.
//
BOOL RegisterUnknownObject(LPCTSTR pszObjectName, REFCLSID riidObject);
BOOL UnregisterUnknownObject(REFCLSID riidObject);

// deletes a key in the registr and all of it's subkeys
//
BOOL DeleteKeyAndSubKeys(HKEY hk, LPTSTR pszSubKey);


#define _REGUNREG_H_
#endif // _REGUNREG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\localusr.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       localusr.h
//  Content:    This file contains the User object definition.
//  History:
//      Wed 17-Apr-1996 11:18:47  -by-  Viroon  Touranachun [viroont]
//      Thu 1-16-97 combined localusr/localapp/ulsuser/ulsapp
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _LOCALUSER_H_
#define _LOCALUSER_H_

#include "connpt.h"
#include "attribs.h"
#include "culs.h"

//****************************************************************************
// Constant definition
//****************************************************************************
//
#define LU_MOD_NONE         0x00000000
#define LU_MOD_FIRSTNAME    0x00000001
#define LU_MOD_LASTNAME     0x00000002
#define LU_MOD_EMAIL        0x00000004
#define LU_MOD_CITY         0x00000008
#define LU_MOD_COUNTRY      0x00000010
#define LU_MOD_COMMENT      0x00000020
#define LU_MOD_FLAGS        0x00000040
#define LU_MOD_IP_ADDRESS   0x00000080
#define LU_MOD_GUID         0x00000100
#define LU_MOD_MIME         0x00000200
#define LU_MOD_ATTRIB       0x00000400
#define LU_MOD_ALL          (LU_MOD_FIRSTNAME + LU_MOD_LASTNAME + \
                             LU_MOD_EMAIL + LU_MOD_CITY + \
                             LU_MOD_COUNTRY + LU_MOD_COMMENT +\
                             LU_MOD_FLAGS +\
                             LU_MOD_IP_ADDRESS +\
                             LU_MOD_GUID + LU_MOD_MIME +\
                             LU_MOD_ATTRIB \
                            )

//****************************************************************************
// Enumeration type
//****************************************************************************
//
typedef enum {
    ILS_APP_SET_ATTRIBUTES,
    ILS_APP_REMOVE_ATTRIBUTES,
}   APP_CHANGE_ATTRS;

typedef enum {
    ILS_APP_ADD_PROT,
    ILS_APP_REMOVE_PROT,
}   APP_CHANGE_PROT;



// server

typedef enum {
    ULSSVR_INVALID  = 0,
    ULSSVR_INIT,
    ULSSVR_REG_USER,
    ULSSVR_REG_PROT,
    ULSSVR_CONNECT,
    ULSSVR_UNREG_PROT,
    ULSSVR_UNREG_USER,
    ULSSVR_RELOGON,
    ULSSVR_NETWORK_DOWN,
}   ULSSVRSTATE;



//****************************************************************************
// CIlsUser definition
//****************************************************************************
//
class CIlsUser : public IIlsUser,
                 public IConnectionPointContainer
{
private:

	/* ------ user ------ */

    LONG                    m_cRef;
    BOOL                    m_fReadonly;
    ULONG                   m_cLock;
    ULONG                   m_uModify;
    LPTSTR                  m_szID;
    LPTSTR                  m_szFirstName;
    LPTSTR                  m_szLastName;
    LPTSTR                  m_szEMailName;
    LPTSTR                  m_szCityName;
    LPTSTR                  m_szCountryName;
    LPTSTR                  m_szComment;
    DWORD					m_dwFlags;
    LPTSTR                  m_szIPAddr;

    LPTSTR                  m_szAppName;
    GUID                    m_guid;
    LPTSTR                  m_szMimeType;
    CAttributes             m_ExtendedAttrs;
    CList                   m_ProtList;
    CIlsServer				*m_pIlsServer;
    CConnectionPoint        *m_pConnPt;

	/* ------ server ------ */

    ULSSVRSTATE             m_uState;
    HANDLE                  m_hLdapUser;
    ULONG                   m_uReqID;
    ULONG                   m_uLastMsgID;
    IEnumIlsProtocols       *m_pep;


private: // user

    STDMETHODIMP            InternalGetUserInfo (BOOL fAddNew,
                                                 PLDAP_CLIENTINFO *ppUserInfo,
                                                 ULONG uFields);

	HRESULT					RemoveProtocolFromList ( CLocalProt *pLocalProt );

public: // user

    // Constructor and destructor
    CIlsUser (void);
    ~CIlsUser (void);

    // Lock and unlock User operation
    //
    ULONG           Lock(void)      {m_cLock++; return m_cLock;}
    ULONG           Unlock(void)    {m_cLock--; return m_cLock;}
    BOOL            IsLocked(void)  {return (m_cLock != 0);}

    STDMETHODIMP            Init (BSTR bstrUserID, BSTR bstrAppName);
    STDMETHODIMP            Init (CIlsServer *pIlsServer, PLDAP_CLIENTINFO pui);

    STDMETHODIMP RegisterResult(ULONG ulRegID, HRESULT hr);
    STDMETHODIMP UnregisterResult (ULONG uReqID, HRESULT hResult);
    STDMETHODIMP UpdateResult(ULONG ulUpdateID, HRESULT hr);
    STDMETHODIMP StateChanged ( LONG Type, BOOL fPrimary);
    STDMETHODIMP ProtocolChangeResult ( IIlsProtocol *pProtcol,
                                        ULONG uReqID, HRESULT hResult,
                                        APP_CHANGE_PROT uCmd);

    STDMETHODIMP GetProtocolResult (ULONG uReqID, PLDAP_PROTINFO_RES ppir);
    STDMETHODIMP EnumProtocolsResult (ULONG uReqID, PLDAP_ENUM ple);
    STDMETHODIMP NotifySink (void *pv, CONN_NOTIFYPROC pfn);

    // Internal methods
    STDMETHODIMP            SaveChanges (void);
#ifdef LATER
    void                    LocalAsyncRespond (ULONG msg, ULONG uReqID, LPARAM lParam)
                            {PostMessage(g_hwndCulsWindow, msg, uReqID, lParam); return;}
#endif //LATER
    // Ldap Information
    //
    HRESULT    GetProtocolHandle (CLocalProt *pLocalProt, PHANDLE phProt);
    HRESULT    RegisterLocalProtocol( BOOL fAddToList, CLocalProt *pProt, PLDAP_ASYNCINFO plai );
    HRESULT    UnregisterLocalProtocol( CLocalProt *pProt, PLDAP_ASYNCINFO plai );
    HRESULT    UpdateProtocol ( IIlsProtocol *pProtocol, ULONG *puReqID, APP_CHANGE_PROT uCmd );

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IIlsLocalUser

	STDMETHODIMP	Clone ( IIlsUser **ppUser );

    STDMETHODIMP    GetState (ILS_STATE *puULSState);

    STDMETHODIMP    GetStandardAttribute(
                    ILS_STD_ATTR_NAME   stdAttr,
                    BSTR                *pbstrStdAttr);

    STDMETHODIMP    SetStandardAttribute(
                    ILS_STD_ATTR_NAME   stdAttr,
                    BSTR                pbstrStdAttr);

    STDMETHODIMP GetExtendedAttribute ( BSTR bstrName, BSTR *pbstrValue );
    STDMETHODIMP SetExtendedAttribute ( BSTR bstrName, BSTR bstrValue );
    STDMETHODIMP RemoveExtendedAttribute ( BSTR bstrName );
    STDMETHODIMP GetAllExtendedAttributes ( IIlsAttributes **ppAttributes );

    STDMETHODIMP IsWritable ( BOOL *pValue);

    STDMETHODIMP Register ( IIlsServer *pServer, ULONG *puReqID );

    STDMETHODIMP Unregister( ULONG *puReqID );

    STDMETHODIMP Update ( ULONG *puReqID );

    STDMETHODIMP GetVisible ( DWORD *pfVisible );

    STDMETHODIMP SetVisible ( DWORD fVisible );

    STDMETHODIMP GetGuid ( GUID *pGuid );

    STDMETHODIMP SetGuid ( GUID *pGuid );

    STDMETHODIMP CreateProtocol(
                        BSTR bstrProtocolID,
                        ULONG uPortNumber,
                        BSTR bstrMimeType,
                        IIlsProtocol **ppProtocol);

    STDMETHODIMP AddProtocol(
                        IIlsProtocol *pProtocol,
                        ULONG *puReqID);

    STDMETHODIMP RemoveProtocol(
                        IIlsProtocol *pProtocol,
                        ULONG *puReqID);

    STDMETHODIMP GetProtocol(
                        BSTR bstrProtocolID,
                        IIlsAttributes  *pAttributes,
                        IIlsProtocol **ppProtocol,
                        ULONG *puReqID);

    STDMETHODIMP EnumProtocols(
                        IIlsFilter     *pFilter,
                        IIlsAttributes *pAttributes,
                        IEnumIlsProtocols **ppEnumProtocol,
                        ULONG *puReqID);


    // IConnectionPointContainer
    STDMETHODIMP    EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
    STDMETHODIMP    FindConnectionPoint(REFIID riid,
                                        IConnectionPoint **ppcp);

public: // server

    // Server registration result
    //
    HRESULT    InternalRegisterNext ( HRESULT );
    HRESULT    InternalUnregisterNext ( HRESULT );

    // Register/Unregister
    //
    HRESULT    InternalRegister (ULONG uReqID);
    HRESULT    InternalUnregister (ULONG uReqID);
    HRESULT    InternalCleanupRegistration ( BOOL fKeepProtList );
    HRESULT	   EnumLocalProtocols ( IEnumIlsProtocols **pEnumProtocol );

    // Server properties
    //
    ILS_STATE    GetULSState ( VOID );
    VOID		SetULSState ( ULSSVRSTATE State ) { m_uState = State; }

private: // server

    void       NotifyULSRegister(HRESULT hr);
    void       NotifyULSUnregister(HRESULT hr);
    HRESULT    AddPendingRequest(ULONG uReqType, ULONG uMsgID);
};

//****************************************************************************
// CEnumUsers definition
//****************************************************************************
//
class CEnumUsers : public IEnumIlsUsers
{
private:
    LONG                    m_cRef;
    CIlsUser                **m_ppu;
    ULONG                   m_cUsers;
    ULONG                   m_iNext;

public:
    // Constructor and Initialization
    CEnumUsers (void);
    ~CEnumUsers (void);
    STDMETHODIMP            Init (CIlsUser **ppuList, ULONG cUsers);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumIlsAttributes
    STDMETHODIMP            Next(ULONG cUsers, IIlsUser **rgpu,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cUsers);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumIlsUsers **ppEnum);
};

//****************************************************************************
// CEnumLocalAppProtocols definition
//****************************************************************************
//
class CEnumProtocols : public IEnumIlsProtocols
{
private:
    LONG                    m_cRef;
    CList                   m_ProtList;
    HANDLE                  hEnum;

public:
    // Constructor and Initialization
    CEnumProtocols (void);
    ~CEnumProtocols (void);
    STDMETHODIMP            Init (CList *pProtList);

    // IUnknown
    STDMETHODIMP            QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG)    AddRef (void);
    STDMETHODIMP_(ULONG)    Release (void);

    // IEnumIlsProtocols
    STDMETHODIMP            Next(ULONG cProtocols, IIlsProtocol **rgpProt,
                                 ULONG *pcFetched);
    STDMETHODIMP            Skip(ULONG cProtocols);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumIlsProtocols **ppEnum);
};


#endif //_LOCALUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\regunreg.cpp ===
//=--------------------------------------------------------------------------=
// RegUnReg.cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
#include "ulsp.h"
#include "regunreg.h"


//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=
// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL
//
#define GUID_STR_LEN    40

#define CLEANUP_ON_ERROR(l)    if (l != ERROR_SUCCESS) goto CleanUp


//=--------------------------------------------------------------------------=
// StringFromGuid
//=--------------------------------------------------------------------------=
// returns a string from a CLSID or GUID
//
// Parameters:
//    REFIID               - [in]  clsid to make string out of.
//    LPTSTR               - [in]  buffer in which to place resultant GUID.
//
// Output:
//    int                  - number of chars written out.
//
// Notes:
//
static int StringFromGuid
(
    REFIID   riid,
    LPTSTR   pszBuf
)
{
    return wsprintf(pszBuf, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
            riid.Data1, 
            riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], 
            riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);

}

//=--------------------------------------------------------------------------=
// RegisterUnknownObject
//=--------------------------------------------------------------------------=
// registers a simple CoCreatable object.  nothing terribly serious.
// we add the following information to the registry:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
//
// Parameters:
//    LPCSTR       - [in] Object Name
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't register it all
//
// Notes:
//
BOOL RegisterUnknownObject
(
    LPCTSTR  pszObjectName,
    REFCLSID riidObject
)
{
    HKEY  hk = NULL, hkSub = NULL;
    TCHAR szGuidStr[GUID_STR_LEN];
    DWORD dwPathLen, dwDummy;
    TCHAR szScratch[MAX_PATH];
    long  l;

    // clean out any garbage
    //
    UnregisterUnknownObject(riidObject);

    // HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32  @ThreadingModel = Apartment
    //
    if (!StringFromGuid(riidObject, szGuidStr)) goto CleanUp;
    wsprintf(szScratch, TEXT("CLSID\\%s"), szGuidStr);
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, TEXT("%s Object"), pszObjectName);
    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch,
                      (lstrlen(szScratch) + 1)*sizeof(TCHAR));
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, TEXT("InprocServer32"), 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    dwPathLen = GetModuleFileName(g_hInstance, szScratch, sizeof(szScratch)/sizeof(TCHAR));
    if (!dwPathLen) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, (dwPathLen + 1)*sizeof(TCHAR));
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, TEXT("ThreadingModel"), 0, REG_SZ, (BYTE *)TEXT("Apartment"),
                      sizeof(TEXT("Apartment")));
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    return TRUE;

    // we are not very happy!
    //
  CleanUp:
    if (hk) RegCloseKey(hk);
    if (hkSub) RegCloseKey(hkSub);
    return FALSE;

}

//=--------------------------------------------------------------------------=
// UnregisterUnknownObject
//=--------------------------------------------------------------------------=
// cleans up all the stuff that RegisterUnknownObject puts in the
// registry.
//
// Parameters:
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//    - WARNING: this routine will blow away all other keys under the CLSID
//      for this object.  mildly anti-social, but likely not a problem.
//
BOOL UnregisterUnknownObject
(
    REFCLSID riidObject
)
{
    TCHAR szScratch[MAX_PATH];
    HKEY hk;
    BOOL f;
    long l;

    // delete everybody of the form
    //   HKEY_CLASSES_ROOT\CLSID\<CLSID> [\] *
    //
    if (!StringFromGuid(riidObject, szScratch))
        return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    f = DeleteKeyAndSubKeys(hk, szScratch);
    RegCloseKey(hk);

    return f;
}

//=--------------------------------------------------------------------------=
// DeleteKeyAndSubKeys
//=--------------------------------------------------------------------------=
// delete's a key and all of it's subkeys.
//
// Parameters:
//    HKEY                - [in] delete the descendant specified
//    LPTSTR              - [in] i'm the descendant specified
//
// Output:
//    BOOL                - TRUE OK, FALSE baaaad.
//
// Notes:
//    - I don't feel too bad about implementing this recursively, since the
//      depth isn't likely to get all the great.
//    - Despite the win32 docs claiming it does, RegDeleteKey doesn't seem to
//      work with sub-keys under windows 95.
//
BOOL DeleteKeyAndSubKeys
(
    HKEY    hkIn,
    LPTSTR  pszSubKey
)
{
    HKEY  hk;
    TCHAR szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    BOOL  f;
    int   x;

    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // loop through all subkeys, blowing them away.
    //
    f = TRUE;
    x = 0;
    while (f) {
        dwTmpSize = MAX_PATH;
        l = RegEnumKeyEx(hk, x, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (l != ERROR_SUCCESS) break;
        f = DeleteKeyAndSubKeys(hk, szTmp);
        x++;
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    RegCloseKey(hk);
    l = RegDeleteKey(hkIn, pszSubKey);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by uls.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\request.cpp ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       request.cpp
//  Content:    CReqMgr and CRequest classes implementation
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#include "ulsp.h"
#include "request.h"


//****************************************************************************
// CReqMgr::CReqMgr(void)
//
// Purpose: Constructor for the CReqMgr class
//
// Parameters: None
//****************************************************************************

CReqMgr::CReqMgr(void)
{
    uNextReqID = REQUEST_ID_INIT;
    return;
}

//****************************************************************************
// CReqMgr::~CReqMgr(void)
//
// Purpose: Destructor for the CReqMgr class
//
// Parameters: None
//****************************************************************************

CReqMgr::~CReqMgr(void)
{
    COM_REQ_INFO *pRequest;
    HANDLE hEnum;

    // Free all the pending request
    //
    ReqList.Enumerate(&hEnum);
    while (ReqList.Next(&hEnum, (LPVOID *)&pRequest) == NOERROR)
    {
        ::MemFree (pRequest);
    }
    ReqList.Flush();
    return;
}

//****************************************************************************
// HRESULT
// CReqMgr::NewRequest  (COM_REQ_INFO *pri)
//
// Purpose: Add a new pending request
//
// Parameters: None
//****************************************************************************

HRESULT
CReqMgr::NewRequest  (COM_REQ_INFO *pri)
{
    COM_REQ_INFO *pRequest;
    HRESULT  hr;

    // Allocate a new request node
    //
    pri->uReqID = uNextReqID;
    pRequest = (COM_REQ_INFO *) ::MemAlloc (sizeof (COM_REQ_INFO));
    if (pRequest == NULL)
    {
        return ILS_E_MEMORY;
    };
    *pRequest = *pri;

    // Append the new request to the list
    //
    hr = ReqList.Append((PVOID)pRequest);

    if (FAILED(hr))
    {
        delete pRequest;
    }
    else
    {
        if (++uNextReqID == ILS_INVALID_REQ_ID)
        	uNextReqID = REQUEST_ID_INIT;
    };
    return hr;
}

//****************************************************************************
// HRESULT
// CReqMgr::FindRequest (COM_REQ_INFO *pri, BOOL fRemove)
//
// Purpose: Find the request.
//
// Parameters: None
//****************************************************************************

HRESULT
CReqMgr::FindRequest (COM_REQ_INFO *pri, BOOL fRemove)
{
    COM_REQ_INFO *pRequest;
    ULONG    uMatchingID;
    HANDLE   hEnum;
    HRESULT  hr;

    // Get the ID we want to match
    //
    uMatchingID = (pri->uMsgID != 0 ? pri->uMsgID : pri->uReqID);

    // Look for the request matching the message ID
    //
    ReqList.Enumerate(&hEnum);
    while (ReqList.Next(&hEnum, (PVOID *)&pRequest) == NOERROR)
    {
        if (uMatchingID == (pri->uMsgID != 0 ? pRequest->uMsgID : 
                                               pRequest->uReqID))
        {
            break;
        };
    };
    
    if (pRequest != NULL)
    {
        // Return the request associates
        //
        *pri = *pRequest;

        // Remove the request
        //
        if (fRemove)
        {
            ReqList.Remove((PVOID)pRequest);
            ::MemFree (pRequest);
        };
        hr = NOERROR;
    }
    else
    {
        hr = ILS_E_FAIL;
    };

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\request.h ===
//****************************************************************************
//
//  Module:     ULS.DLL
//  File:       request.h
//  Content:    Declaration CReqMgr and CRequest classes
//
//  Copyright (c) Microsoft Corporation 1996-1997
//
//****************************************************************************

#ifndef _REQUEST_H_
#define _REQUEST_H_

typedef struct  tagRequestInfo {
	DWORD	dwSignature;
    ULONG   uReqType;
    ULONG   uMsgID;
    ULONG   uReqID;
//    LPVOID  pv;
//    LPARAM  lParam;
	DWORD				dwFlags;
	CIlsServer			*pServer;
	CIlsMain			*pMain;
	CIlsUser			*pUser;
	CLocalProt			*pProtocol;
#ifdef ENABLE_MEETING_PLACE
	CIlsMeetingPlace	*pMeeting;
#endif
}   COM_REQ_INFO;

#define REQ_INFO_SIGNATURE	0x123456UL
VOID inline ReqInfo_Init ( COM_REQ_INFO *p )
{
	ZeroMemory (p, sizeof (*p));
	p->dwSignature = REQ_INFO_SIGNATURE;
}

BOOL inline ReqInfo_IsValid ( COM_REQ_INFO *p )
{
	return (p->dwSignature == REQ_INFO_SIGNATURE);
}

enum
{
	REQ_INFO_F_SERVER = 0x01, REQ_INFO_F_MAIN = 0x02,
	REQ_INFO_F_USER = 0x04, REQ_INFO_F_PROTOCOL = 0x08,
	REQ_INFO_F_MEETING = 0x10
};

VOID inline ReqInfo_SetServer ( COM_REQ_INFO *p, CIlsServer *pServer )
{
	ASSERT (p->pServer == NULL);
	p->dwFlags |= REQ_INFO_F_SERVER;
	p->pServer = pServer;
}

VOID inline ReqInfo_SetServer ( COM_REQ_INFO *p, IIlsServer *pServer )
{
	ReqInfo_SetServer (p, (CIlsServer *) pServer);
}

VOID inline ReqInfo_SetMain ( COM_REQ_INFO *p, CIlsMain *pMain )
{
	ASSERT (p->pMain == NULL);
	p->dwFlags |= REQ_INFO_F_MAIN;
	p->pMain = pMain;
}

VOID inline ReqInfo_SetUser ( COM_REQ_INFO *p, CIlsUser *pUser )
{
	ASSERT (p->pUser == NULL);
	p->dwFlags |= REQ_INFO_F_USER;
	p->pUser = pUser;
}

VOID inline ReqInfo_SetProtocol ( COM_REQ_INFO *p, CLocalProt *pProtocol )
{
	ASSERT (p->pProtocol == NULL);
	p->dwFlags |= REQ_INFO_F_PROTOCOL;
	p->pProtocol = pProtocol;
}

VOID inline ReqInfo_SetProtocol ( COM_REQ_INFO *p, IIlsProtocol *pProtocol )
{
	ReqInfo_SetProtocol (p, (CLocalProt *) pProtocol);
}

#ifdef ENABLE_MEETING_PLACE
VOID inline ReqInfo_SetMeeting ( COM_REQ_INFO *p, CIlsMeetingPlace *pMeeting )
{
	ASSERT (p->pMeeting == NULL);
	p->dwFlags |= REQ_INFO_F_MEETING;
	p->pMeeting = pMeeting;
}
#endif

CIlsServer inline *ReqInfo_GetServer ( COM_REQ_INFO *p )
{
	return ((p->dwFlags & REQ_INFO_F_SERVER) ? p->pServer : NULL);
}

CIlsMain inline *ReqInfo_GetMain ( COM_REQ_INFO *p )
{
	return ((p->dwFlags & REQ_INFO_F_MAIN) ? p->pMain : NULL);
}

CIlsUser inline *ReqInfo_GetUser ( COM_REQ_INFO *p )
{
	return ((p->dwFlags & REQ_INFO_F_USER) ? p->pUser : NULL);
}

CLocalProt inline *ReqInfo_GetProtocol ( COM_REQ_INFO *p )
{
	return ((p->dwFlags & REQ_INFO_F_PROTOCOL) ? p->pProtocol : NULL);
}

#ifdef ENABLE_MEETING_PLACE
CIlsMeetingPlace inline *ReqInfo_GetMeeting ( COM_REQ_INFO *p )
{
	return ((p->dwFlags & REQ_INFO_F_MEETING) ? p->pMeeting : NULL);
}
#endif

//****************************************************************************
// CReqMgr definition
//****************************************************************************
//
#define REQUEST_ID_INIT     1

class   CReqMgr
{
private:
    CList   ReqList;
    ULONG   uNextReqID;

    HRESULT FindRequest (COM_REQ_INFO *pri, BOOL fRemove);

public:
    CReqMgr (void);
    ~CReqMgr (void);

    HRESULT NewRequest  (COM_REQ_INFO *pri);
    HRESULT RequestDone (COM_REQ_INFO *pri)      {return FindRequest(pri,TRUE);}
    HRESULT GetRequestInfo (COM_REQ_INFO *pri)   {return FindRequest(pri,FALSE);}
};

#endif // _REQUEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spanyatt.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spanyatt.h
	Content:	This file contains the arbitrary-attribute object definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ULS_SP_ANYATTR_H_
#define _ULS_SP_ANYATTR_H_

#include <pshpack8.h>


// this structure is used to remember which arbitrary attributes
// have been created at the server side.
// in isbu server implementation, all the applications' and
// protocols' arbitrary attributes are under RTPerson; therefore,
// it is important to clean up arbitrary attributes propertly.
typedef struct tagAnyAttr
{
	struct tagAnyAttr *prev;
	struct tagAnyAttr *next;
	LONG	mod_op;	// used in temp list only
	TCHAR	*pszAttrName;
	// followed by attr name
}
	ANY_ATTR;


class UlsLdap_CAnyAttrs
{
	friend class UlsLdap_CLocalApp;
	friend class UlsLdap_CLocalProt;

public:

	UlsLdap_CAnyAttrs ( VOID );
	~UlsLdap_CAnyAttrs ( VOID );

protected:

	HRESULT SetAnyAttrs ( ULONG *puRespID, ULONG *puMsgID, ULONG uNotifyMsg,
				ULONG cPrefix, TCHAR *pszPrefix,
				ULONG cAttrs, TCHAR *pszAttrs,
				LONG ModOp,	SERVER_INFO *pServerInfo, TCHAR *pszDN );
	HRESULT RemoveAnyAttrs ( ULONG *puRespID, ULONG *puMsgID, ULONG uNotifyMsg,
				ULONG cPrefix, TCHAR *pszPrefix,
				ULONG cAttrs, TCHAR *pszAttrs,
				SERVER_INFO *pServerInfo, TCHAR *pszDN );
	HRESULT RemoveAllAnyAttrs ( ULONG *puMsgID, ULONG cPrefix, TCHAR *pszPrefix,
				SERVER_INFO *pServerInfo, TCHAR *pszDN );

	ULONG GetAnyAttrsCount ( VOID ) { return m_cAttrs; }

private:

	HRESULT RemoveAnyAttrsEx ( ULONG *puRespID, ULONG *puMsgID, ULONG uNotifyMsg,
				ULONG cPrefix, TCHAR *pszPrefix,
				ULONG cAttrs, TCHAR *pszAttrs,
				SERVER_INFO *pServerInfo, TCHAR *pszDN );

	HRESULT SetAttrsAux ( ULONG cAttrs, TCHAR *pszAttrs,
				ULONG cPrefix, TCHAR *pszPrefix, LONG ModOp,
				LDAPMod ***pppMod );
	HRESULT RemoveAttrsAux ( ULONG cAttrs, TCHAR *pszAttrs,
				ULONG cPrefix, TCHAR *pszPrefix,
				LDAPMod ***pppMod );

	VOID RemoveAttrFromList ( TCHAR *pszAttrName );
	VOID FreeAttrList ( ANY_ATTR *AttrList );
	ANY_ATTR *LocateAttr ( TCHAR *pszAttrName );

	ULONG		m_cAttrs;
	ANY_ATTR	*m_AttrList;
};


const TCHAR *SkipAnyAttrNamePrefix ( const TCHAR *pszAttrName );
const TCHAR *IsAnyAttrName ( const TCHAR *pszAttrName );
TCHAR *PrefixNameValueArray ( BOOL fPair, ULONG cAttrs, const TCHAR *pszAttrs );

#include <poppack.h>

#endif // _ULS_SP_ANYATTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spanyatt.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spanyatt.cpp
	Content:	This file contains the arbitrary-attribute object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"


/* ---------- public methods ----------- */


UlsLdap_CAnyAttrs::UlsLdap_CAnyAttrs ( VOID )
{
	m_cAttrs = 0;
	m_AttrList = NULL;
}


UlsLdap_CAnyAttrs::~UlsLdap_CAnyAttrs ( VOID )
{
	FreeAttrList (m_AttrList);
}


/* ---------- protected methods ----------- */


HRESULT UlsLdap_CAnyAttrs::SetAnyAttrs (
	ULONG 		*puRespID,
	ULONG		*puMsgID,
	ULONG		uNotifyMsg,
	ULONG		cAttrs,
	TCHAR		*pszAttrs,
	ULONG		cPrefix,
	TCHAR		*pszPrefix,
	LONG		ModOp,
	SERVER_INFO	*pServerInfo,
	TCHAR		*pszDN )
{
	MyAssert (puRespID != NULL || puMsgID != NULL);
	MyAssert (cAttrs != 0);
	MyAssert (pszAttrs != NULL);
	MyAssert (cPrefix != 0);
	MyAssert (pszPrefix != NULL);
	MyAssert (pServerInfo != NULL);
	MyAssert (pszDN != NULL);
	MyAssert (ModOp == LDAP_MOD_REPLACE || ModOp == LDAP_MOD_ADD);

	// create a prefix for each attr name in the following pair
	pszAttrs = PrefixNameValueArray (TRUE, cAttrs, pszAttrs);
	if (pszAttrs == NULL)
		return ULS_E_MEMORY;

	// build modify array for ldap_modify()
	LDAPMod **ppMod = NULL;
	HRESULT hr = SetAttrsAux (cAttrs, pszAttrs,	cPrefix, pszPrefix, ModOp, &ppMod);
	if (hr != S_OK)
	{
		MemFree (pszAttrs);
		return hr;
	}
	MyAssert (ppMod != NULL);

	// so far, we are done with local preparation

	// get the connection object
	UlsLdap_CSession *pSession = NULL;
	hr = g_pSessionContainer->GetSession (&pSession, pServerInfo);
	if (hr != S_OK)
	{
		MemFree (pszAttrs);
		MemFree (ppMod);
		return hr;
	}
	MyAssert (pSession != NULL);

	// get the ldap session
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// send the data over the wire
	ULONG uMsgID = ldap_modify (ld, pszDN, ppMod);
	MemFree (pszAttrs);
	MemFree (ppMod);
	if (uMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// if the caller does not ask for notify id
	// then do not queue a pending info
	if (puRespID != NULL)
	{
		PENDING_INFO PendingInfo;
		::FillDefPendingInfo (&PendingInfo, ld, uMsgID, INVALID_MSG_ID);
		PendingInfo.uLdapResType = LDAP_RES_MODIFY;
		PendingInfo.uNotifyMsg = uNotifyMsg;

		// queue it
		hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
		if (hr != S_OK)
		{
			ldap_abandon (ld, uMsgID);
			pSession->Disconnect ();
			MyAssert (FALSE);
		}

		*puRespID = PendingInfo.uRespID;
	}

	if (puMsgID)
		*puMsgID = uMsgID;

	return hr;
}


HRESULT UlsLdap_CAnyAttrs::RemoveAllAnyAttrs (
	ULONG		*puMsgID,
	ULONG		cPrefix,
	TCHAR		*pszPrefix,
	SERVER_INFO	*pServerInfo,
	TCHAR		*pszDN )
{
	ULONG cbAttrs = 0;
	ULONG cAttrs = 0;
	
	for (ANY_ATTR *p = m_AttrList; p != NULL; p = p->next)
	{
		cAttrs++;
		if (p->pszAttrName != NULL)
			cbAttrs += (lstrlen (p->pszAttrName) + 1) * sizeof (TCHAR);
	}

	MyAssert (cAttrs == m_cAttrs);

	TCHAR *pszAttrs = (TCHAR *) MemAlloc (cbAttrs);
	if (pszAttrs == NULL)
		return ULS_E_MEMORY;

	TCHAR *psz = pszAttrs;
	for (p = m_AttrList; p != NULL; p = p->next)
	{
		if (p->pszAttrName != NULL)
		{
			lstrcpy (psz, p->pszAttrName);
			psz += lstrlen (psz) + 1;
		}
	}

	HRESULT hr = RemoveAnyAttrsEx (	NULL,
									puMsgID,
									0,
									cAttrs,
									pszAttrs,
									cPrefix,
									pszPrefix,
									pServerInfo,
									pszDN);
	MemFree (pszAttrs);
	return hr;
}


HRESULT UlsLdap_CAnyAttrs::RemoveAnyAttrs (
	ULONG 		*puRespID,
	ULONG		*puMsgID,
	ULONG		uNotifyMsg,
	ULONG		cAttrs,
	TCHAR		*pszAttrs,
	ULONG		cPrefix,
	TCHAR		*pszPrefix,
	SERVER_INFO	*pServerInfo,
	TCHAR		*pszDN)
{
	MyAssert (puRespID != NULL || puMsgID != NULL);
	MyAssert (cAttrs != 0);
	MyAssert (pszAttrs != NULL);
	MyAssert (cPrefix != 0);
	MyAssert (pszPrefix != NULL);
	MyAssert (pServerInfo != NULL);
	MyAssert (pszDN != NULL);

	pszAttrs = PrefixNameValueArray (FALSE, cAttrs, pszAttrs);
	if (pszAttrs == NULL)
		return ULS_E_MEMORY;

	HRESULT hr = RemoveAnyAttrsEx (	puRespID,
									puMsgID,
									uNotifyMsg,
									cAttrs,
									pszAttrs,
									cPrefix,
									pszPrefix,
									pServerInfo,
									pszDN);
	MemFree (pszAttrs);
	return hr;
}


HRESULT UlsLdap_CAnyAttrs::RemoveAnyAttrsEx (
	ULONG 		*puRespID,
	ULONG		*puMsgID,
	ULONG		uNotifyMsg,
	ULONG		cAttrs,
	TCHAR		*pszAttrs,
	ULONG		cPrefix,
	TCHAR		*pszPrefix,
	SERVER_INFO	*pServerInfo,
	TCHAR		*pszDN)
{
	MyAssert (puRespID != NULL || puMsgID != NULL);
	MyAssert (cAttrs != 0);
	MyAssert (pszAttrs != NULL);
	MyAssert (cPrefix != 0);
	MyAssert (pszPrefix != NULL);
	MyAssert (pServerInfo != NULL);
	MyAssert (pszDN != NULL);

	// build modify array for ldap_modify()
	LDAPMod **ppMod = NULL;
	HRESULT hr = RemoveAttrsAux (cAttrs, pszAttrs, cPrefix, pszPrefix, &ppMod);
	if (hr != S_OK)
		return hr;
	MyAssert (ppMod != NULL);

	// so far, we are done with local preparation

	// get the connection object
	UlsLdap_CSession *pSession = NULL;
	hr = g_pSessionContainer->GetSession (&pSession, pServerInfo);
	if (hr != S_OK)
	{
		MemFree (ppMod);
		return hr;
	}
	MyAssert (pSession != NULL);

	// get the ldap session
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// send the data over the wire
	ULONG uMsgID = ldap_modify (ld, pszDN, ppMod);
	MemFree (ppMod);
	if (uMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// if the caller does not ask for notify id
	// then do not queue a pending info
	if (puRespID != NULL)
	{
		PENDING_INFO PendingInfo;
		::FillDefPendingInfo (&PendingInfo, ld, uMsgID, INVALID_MSG_ID);
		PendingInfo.uLdapResType = LDAP_RES_MODIFY;
		PendingInfo.uNotifyMsg = uNotifyMsg;

		hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
		if (hr != S_OK)
		{
			ldap_abandon (ld, uMsgID);
			pSession->Disconnect ();
			MyAssert (FALSE);
		}

		*puRespID = PendingInfo.uRespID;
	}
	else
	{
		if (puMsgID != NULL)
			*puMsgID = uMsgID;
	}

	return hr;
}


/* ---------- private methods ----------- */


HRESULT UlsLdap_CAnyAttrs::SetAttrsAux (
	ULONG		cAttrs,
	TCHAR		*pszAttrs,
	ULONG		cPrefix,
	TCHAR		*pszPrefix,
	LONG		ModOp,
	LDAPMod		***pppMod )
{
	MyAssert (cAttrs != 0);
	MyAssert (pszAttrs != NULL);
	MyAssert (cPrefix != 0);
	MyAssert (pszPrefix != NULL);
	MyAssert (ModOp == LDAP_MOD_REPLACE || ModOp == LDAP_MOD_ADD);
	MyAssert (pppMod != NULL);

	// create modify list
	ULONG cTotal = cPrefix + cAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
	{
		return ULS_E_MEMORY;
	}

	LDAPMod *pMod;
	for (ULONG i = 0; i < cTotal; i++)
	{
		pMod = ::IlsGetModifyListMod (pppMod, cTotal, i);
		(*pppMod)[i] = pMod;
		pMod->mod_values = (TCHAR **) (pMod + 1);

		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
		else
		{
			pMod->mod_op = ModOp;
			if (LocateAttr (pszAttrs) == NULL)
			{
				pMod->mod_op = LDAP_MOD_ADD;
				m_cAttrs++;
			}
			if (pMod->mod_op == LDAP_MOD_ADD)
			{
				ULONG cbAttrSize = sizeof (ANY_ATTR) + sizeof (TCHAR) *
									(lstrlen (pszAttrs) + 1);
				ANY_ATTR *pNew = (ANY_ATTR *) MemAlloc (cbAttrSize);
				if (pNew == NULL)
				{
					return ULS_E_MEMORY;
				}
				// fill in attr name
				pNew->pszAttrName = (TCHAR *) (pNew + 1);
				lstrcpy (pNew->pszAttrName, pszAttrs);
				// link to the list
				pNew->prev = NULL;
				pNew->next = m_AttrList;
				m_AttrList = pNew;
			}
			pMod->mod_type = pszAttrs;
			pszAttrs += lstrlen (pszAttrs) + 1;
			*(pMod->mod_values) = pszAttrs;
			pszAttrs += lstrlen (pszAttrs) + 1;
		}
	}

	(*pppMod)[cTotal] = NULL;
	::IlsFixUpModOp ((*pppMod)[0], ModOp, ISBU_MODOP_MODIFY_APP);
	return S_OK;
}


HRESULT UlsLdap_CAnyAttrs::RemoveAttrsAux (
	ULONG		cAttrs,
	TCHAR		*pszAttrs,
	ULONG		cPrefix,
	TCHAR		*pszPrefix,
	LDAPMod		***pppMod )
{
	MyAssert (cAttrs != 0);
	MyAssert (pszAttrs != NULL);
	MyAssert (cPrefix != 0);
	MyAssert (pszPrefix != NULL);
	MyAssert (pppMod != NULL);

	// create modify list
	ULONG cTotal = cPrefix + cAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
	{
		return ULS_E_MEMORY;
	}

	LDAPMod *pMod;
	for (ULONG i = 0; i < cTotal; i++)
	{
		pMod = ::IlsGetModifyListMod (pppMod, cTotal, i);
		(*pppMod)[i] = pMod;

		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			pMod->mod_values = (TCHAR **) (pMod + 1);
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
		else
		{
			pMod->mod_op = LDAP_MOD_DELETE;
			RemoveAttrFromList (pszAttrs);
			pMod->mod_type = pszAttrs;
			pszAttrs += lstrlen (pszAttrs) + 1;
		}
	}

	(*pppMod)[cTotal] = NULL;
	::IlsFixUpModOp ((*pppMod)[0], LDAP_MOD_REPLACE, ISBU_MODOP_MODIFY_APP);
	return S_OK;
}


VOID UlsLdap_CAnyAttrs::RemoveAttrFromList ( TCHAR *pszAttrName )
{
	ANY_ATTR *pOld = LocateAttr (pszAttrName);
	if (pOld != NULL)
	{
		// remove it
		if (pOld->prev != NULL)
		{
			pOld->prev->next = pOld->next;
		}
		else
		{
			m_AttrList = pOld->next;
		}
		if (pOld->next != NULL)
		{
			pOld->next->prev = pOld->prev;
		}

		MyAssert (m_cAttrs != 0);
		m_cAttrs--;
	}
}


VOID UlsLdap_CAnyAttrs::FreeAttrList ( ANY_ATTR *AttrList )
{
	ANY_ATTR *pCurr, *pNext;
	for (pCurr = AttrList; pCurr != NULL; pCurr = pNext)
	{
		pNext = pCurr->next;
		MemFree (pCurr);
	}
}


ANY_ATTR *UlsLdap_CAnyAttrs::LocateAttr ( TCHAR *pszAttrName )
{
	ANY_ATTR *pAttr;
	for (pAttr = m_AttrList; pAttr != NULL; pAttr = pAttr->next)
	{
		if (! My_lstrcmpi (pszAttrName, pAttr->pszAttrName))
		{
			break;
		}
	}
	return pAttr;
}

// const TCHAR c_szAnyAttrPrefix[] = TEXT ("ulsaan_");
const TCHAR c_szAnyAttrPrefix[] = TEXT ("ILSA");
#define SIZE_ANY_ATTR_PREFIX	(sizeof (c_szAnyAttrPrefix) / sizeof (TCHAR))

const TCHAR *SkipAnyAttrNamePrefix ( const TCHAR *pszAttrName )
{
	MyAssert (pszAttrName != NULL);

	const TCHAR *psz = IsAnyAttrName (pszAttrName);
	if (psz == NULL)
	{
		MyAssert (FALSE);
		psz = pszAttrName;
	}

	return psz;
}

const TCHAR *IsAnyAttrName ( const TCHAR *pszAttrName )
{
	BOOL fRet = FALSE;
	TCHAR *psz = (TCHAR *) pszAttrName;

	if (pszAttrName != NULL)
	{
		if (lstrlen (pszAttrName) > SIZE_ANY_ATTR_PREFIX)
		{
			TCHAR c = pszAttrName[SIZE_ANY_ATTR_PREFIX-1];
			psz[SIZE_ANY_ATTR_PREFIX-1] = TEXT ('\0');
			fRet = (My_lstrcmpi (pszAttrName, &c_szAnyAttrPrefix[0]) == 0);
			psz[SIZE_ANY_ATTR_PREFIX-1] = c;
		}
	}

	return (fRet ? &pszAttrName[SIZE_ANY_ATTR_PREFIX-1] : NULL);
}


TCHAR *PrefixNameValueArray ( BOOL fPair, ULONG cAttrs, const TCHAR *pszAttrs )
{
	if (cAttrs == 0 || pszAttrs == NULL)
	{
		MyAssert (FALSE);
		return NULL;
	}

	// compute the total size required
	ULONG cbTotalSize = 0;
	ULONG cbThisSize;
	TCHAR *pszSrc = (TCHAR *) pszAttrs;
	for (ULONG i = 0; i < cAttrs; i++)
	{
		// get name size
		cbThisSize = lstrlen (pszSrc) + 1;
		pszSrc += lstrlen (pszSrc) + 1;

		// get value size as needed
		if (fPair)
		{
			cbThisSize += lstrlen (pszSrc) + 1;
			pszSrc += lstrlen (pszSrc) + 1;
		}

		// adjust the size
		cbThisSize += SIZE_ANY_ATTR_PREFIX;
		cbThisSize *= sizeof (TCHAR);

		// accumulate it
		cbTotalSize += cbThisSize;
	}

	// allocate the new buffer
	TCHAR *pszPrefixAttrs = (TCHAR *) MemAlloc (cbTotalSize);
	if (pszPrefixAttrs == NULL)
		return NULL;

	// copy the strings over to the new buffer
	pszSrc = (TCHAR *) pszAttrs;
	TCHAR *pszDst = pszPrefixAttrs;
	for (i = 0; i < cAttrs; i++)
	{
		// copy prefix
		lstrcpy (pszDst, &c_szAnyAttrPrefix[0]);
		pszDst += lstrlen (pszDst); // no plus 1

		// copy name
		lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
		pszSrc += lstrlen (pszSrc) + 1;

		// copy value as needed
		if (fPair)
		{
			lstrcpy (pszDst, pszSrc);
			pszDst += lstrlen (pszDst) + 1;
			pszSrc += lstrlen (pszSrc) + 1;
		}
	}

	return pszPrefixAttrs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spclient.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spclient.cpp
	Content:	This file contains the client object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"


// Array of constant strings for user object's attribute names
//
const TCHAR *c_apszClientStdAttrNames[COUNT_ENUM_CLIENTATTR] =
{
	/* -- the following is for user -- */

	TEXT ("cn"),
	TEXT ("givenname"),
	TEXT ("surname"),
	TEXT ("rfc822mailbox"),
	TEXT ("location"),
	TEXT ("comment"),
	TEXT ("sipaddress"),
	TEXT ("sflags"),
	TEXT ("c"),

	/* -- the following is for app -- */

	TEXT ("sappid"),
	TEXT ("smimetype"),
	TEXT ("sappguid"),

	TEXT ("sprotid"),
	TEXT ("sprotmimetype"),
	TEXT ("sport"),

	/* -- the above are resolvable -- */

	TEXT ("ssecurity"),
	TEXT ("sttl"),

	/* -- the above are changeable standard attributes for RTPerson -- */

	TEXT ("objectClass"),
	TEXT ("o"),
};


/* ---------- public methods ----------- */


SP_CClient::
SP_CClient ( DWORD_PTR dwContext )
	:
	m_cRefs (0),						// Reference count
	m_uSignature (CLIENTOBJ_SIGNATURE),	// Client object's signature
	m_pszDN (NULL),						// Clean up DN
	m_pszAppPrefix (NULL),				// Clean up app prefix
	m_pszRefreshFilter (NULL),			// Clean up the refresh search filter
	m_fExternalIPAddress (FALSE),		// Default is I figure out the ip address
	m_dwIPAddress (0),					// Assume we are not connected to the network
	m_uTTL (ILS_DEF_REFRESH_MINUTE)		// Reset refresh time
{
	m_dwContext = dwContext;

	// Clean up attached server info structure
	//
	::ZeroMemory (&m_ServerInfo, sizeof (m_ServerInfo));

	// Clean up the scratch buffer for caching pointers to attribute values
	//
	::ZeroMemory (&m_ClientInfo, sizeof (m_ClientInfo));

	// Indicate this client is not registered yet
	//
	SetRegNone ();
}


SP_CClient::
~SP_CClient ( VOID )
{
	// Invalidate the client object's signature
	//
	m_uSignature = (ULONG) -1;

	// Free server info structure
	//
	::IlsFreeServerInfo (&m_ServerInfo);

	// Free DN and app prefix
	//
	MemFree (m_pszDN);
	MemFree (m_pszAppPrefix);

	// Free the refresh search filter
	//
	MemFree (m_pszRefreshFilter);

	// Release the previous prefix for extended attribute names
	//
	::IlsReleaseAnyAttrsPrefix (&(m_ClientInfo.AnyAttrs));
}


ULONG SP_CClient::
AddRef ( VOID )
{
	::InterlockedIncrement (&m_cRefs);
	return m_cRefs;
}


ULONG SP_CClient::
Release ( VOID )
{
	MyAssert (m_cRefs != 0);
	::InterlockedDecrement (&m_cRefs);

	ULONG cRefs = m_cRefs;
	if (cRefs == 0)
		delete this;

	return cRefs;
}


HRESULT SP_CClient::
Register (
	ULONG			uRespID,
	SERVER_INFO		*pServerInfo,
	LDAP_CLIENTINFO	*pInfo )
{
	MyAssert (pInfo != NULL);
	MyAssert (MyIsGoodString (pServerInfo->pszServerName));

	// Cache the server info
	//
	HRESULT hr = ::IlsCopyServerInfo (&m_ServerInfo, pServerInfo);
	if (hr != S_OK)
		return hr;

	// Cache client info
	//
	hr = CacheClientInfo (pInfo);
	if (hr != S_OK)
		return hr;

	// If the application sets an IP address,
	//		then we will use what the app provides,
	//		otherwise, we will get the IP address via winsock.
	//
	// CacheClientInfo() will set up the flag if ip address is passed in
	//
	if (IsExternalIPAddressPassedIn ())
	{
		// Use whatever passed in
		//
		m_fExternalIPAddress = TRUE;

		// Figure out the passed in ip address is done in CacheClientInfo()
		// The IP address string will be setup in CacheClientInfo() too.
		//
	}
	else
	{
		// I will figure out the ip address
		//
		m_fExternalIPAddress = FALSE;

		// Get IP address
		//
		hr = ::GetLocalIPAddress (&m_dwIPAddress);
		if (hr != S_OK)
			return hr;

		// Create IP address string
		//
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_IP_ADDRESS] = &m_ClientInfo.szIPAddress[0];
		::GetLongString (m_dwIPAddress, &m_ClientInfo.szIPAddress[0]);
	}

	// Create client signature string
	//
	m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CLIENT_SIG] = &m_ClientInfo.szClientSig[0];
	::GetLongString (g_dwClientSig, &m_ClientInfo.szClientSig[0]);

	// Create TTL string
	//
	m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_TTL] = &m_ClientInfo.szTTL[0];
	::GetLongString (m_uTTL + ILS_DEF_REFRESH_MARGIN_MINUTE, &m_ClientInfo.szTTL[0]);

	// Set object class RTPerson
	//
	m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_OBJECT_CLASS] = (TCHAR *) &c_szRTPerson[0];

	// Ideally, o= should be read in from registiry
	// but for now, we simply hard code it
	//
	m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_O] = (TCHAR *) &c_szDefO[0];

	// Build DN
	//
	m_pszDN = ::IlsBuildDN (m_ServerInfo.pszBaseDN,
							m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_C],
							m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_O],
							m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CN],
							m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_OBJECT_CLASS]);
	if (m_pszDN == NULL)
		return ILS_E_MEMORY;

	// Build refreh filter
	//
	m_pszRefreshFilter = ::ClntCreateRefreshFilter (m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CN]);
	if (m_pszRefreshFilter == NULL)
		return ILS_E_MEMORY;

	// Cache generic protocol info (per KevinMa's suggestion)
	//
	// m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_PROT_NAME] = TEXT ("h323");
	// m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_PROT_MIME] = TEXT ("text/h323");
	// m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_PROT_PORT] = TEXT ("1720");
	m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_PROT_NAME] = STR_EMPTY;
	m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_PROT_MIME] = STR_EMPTY;
	m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_PROT_PORT] = STR_EMPTY;

	// Allocate app prefix here
	//
	ULONG cbPrefix = g_cbUserPrefix + sizeof (TCHAR) * (2 +
				::lstrlen (STR_CLIENT_APP_NAME) +
				::lstrlen (m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_NAME]));
	m_pszAppPrefix = (TCHAR *) MemAlloc (cbPrefix);
	if (m_pszAppPrefix == NULL)
		return ILS_E_MEMORY;

	// Fill user prefix
	//
	::CopyMemory (m_pszAppPrefix, g_pszUserPrefix, g_cbUserPrefix);

	// Fill app prefix
	//
	TCHAR *psz = (TCHAR *) ((BYTE *) m_pszAppPrefix + g_cbUserPrefix);
	::lstrcpy (psz, STR_CLIENT_APP_NAME);
	psz += lstrlen (psz) + 1;
	::lstrcpy (psz, m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_NAME]);

	// Build modify array for ldap_add()
	//
	LDAPMod **ppModUser = NULL;
	hr = CreateRegUserModArr (&ppModUser);
	if (hr != S_OK)
	{
		return hr;
	}
	MyAssert (ppModUser != NULL);

	// Build modify array for ldap_modify()
	//
	LDAPMod **ppModApp = NULL;
	hr = CreateRegAppModArr (&ppModApp);
	if (hr != S_OK)
	{
		MemFree (ppModUser);
		return hr;
	}
	MyAssert (ppModApp != NULL);

	// so far, we are done with local preparation
	//

	// Get the session object
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgIDUser = (ULONG) -1, uMsgIDApp = (ULONG) -1;
	hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr == S_OK)
	{
		MyAssert (pSession != NULL);

		// Get the ldap session
		//
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		uMsgIDUser = ::ldap_add (ld, m_pszDN, ppModUser);
		if (uMsgIDUser != -1)
		{
			uMsgIDApp = ::ldap_modify (ld, m_pszDN, ppModApp);
			if (uMsgIDApp == -1)
			{
				hr = ::LdapError2Hresult (ld->ld_errno);
			}
		}
		else
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}
	}

	// Free modify arrays
	//
	MemFree (ppModUser);
	MemFree (ppModApp);

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Construct a pending info
	//
	RESP_INFO ri;
	::FillDefRespInfo (&ri, uRespID, ld, uMsgIDUser, uMsgIDApp);
	ri.uNotifyMsg = WM_ILS_REGISTER_CLIENT;
	ri.hObject = (HANDLE) this;

	// Queue the pending result
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	if (hr != S_OK)
	{
		if (uMsgIDUser != (ULONG) -1)
			::ldap_abandon (ld, uMsgIDUser);

		if (uMsgIDApp != (ULONG) -1)
			::ldap_abandon (ld, uMsgIDApp);

		if (pSession != NULL)
			pSession->Disconnect ();
	}

	return hr;
}


HRESULT SP_CClient::
UnRegister ( ULONG uRespID )
{
	MyAssert (MyIsGoodString (m_pszDN));

	// Make sure that there is not refresh scheduled for this object
	//
	if (g_pRefreshScheduler != NULL)
	{
		g_pRefreshScheduler->RemoveClientObject (this);
	}
	else
	{
		MyAssert (FALSE);
	}

	// If it is not registered on the server,
	// the simply report success
	//
	if (! IsRegRemotely ())
	{
		SetRegNone ();
		::PostMessage (g_hWndNotify, WM_ILS_UNREGISTER_CLIENT, uRespID, S_OK);
		return S_OK;
	}

	// Indicate that we are not registered at all
	//
	SetRegNone ();

	// Get the session object
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID = (ULONG) -1;
	HRESULT hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr == S_OK)
	{
		// Get the ldap session
		//
		MyAssert (pSession != NULL);
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		MyAssert (MyIsGoodString (m_pszDN));
		uMsgID = ::ldap_delete (ld, m_pszDN);
		if (uMsgID == -1)
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}
	}

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Construct a pending info
	//
	RESP_INFO ri;
	::FillDefRespInfo (&ri, uRespID, ld, uMsgID, INVALID_MSG_ID);
	ri.uNotifyMsg = WM_ILS_UNREGISTER_CLIENT;

	// Queue this pending result
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	if (hr != S_OK)
	{
		if (uMsgID != (ULONG) -1)
			::ldap_abandon (ld, uMsgID);

		if (pSession != NULL)
			pSession->Disconnect ();
	}

	return hr;
}


HRESULT SP_CClient::
SetAttributes (
	ULONG			uRespID,
	LDAP_CLIENTINFO	*pInfo )
{
	MyAssert (pInfo != NULL);

	MyAssert (MyIsGoodString (m_pszDN));

	// cache info
	//
	HRESULT hr = CacheClientInfo (pInfo);
	if (hr != S_OK)
		return hr;

	// Build modify array for user object's ldap_modify()
	//
	LDAPMod **ppModUser = NULL;
	hr = CreateSetUserAttrsModArr (&ppModUser);
	if (hr != S_OK)
		return hr;
	MyAssert (ppModUser != NULL);

	// Build modify array for app object's ldap_modify()
	//
	LDAPMod **ppModApp = NULL;
	hr = CreateSetAppAttrsModArr (&ppModApp);
	if (hr != S_OK)
	{
		MemFree (ppModUser);
		return hr;
	}
	MyAssert (ppModApp != NULL);

	// So far, we are done with local preparation
	//

	// Get the session object
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgIDUser = (ULONG) -1, uMsgIDApp = (ULONG) -1;
	hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr == S_OK)
	{
		MyAssert (pSession != NULL);

		// Get the ldap session
		//
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		uMsgIDUser = ::ldap_modify (ld, m_pszDN, ppModUser);
		if (uMsgIDUser != -1)
		{
			uMsgIDApp = ::ldap_modify (ld, m_pszDN, ppModApp);
			if (uMsgIDApp == -1)
			{
				hr = ::LdapError2Hresult (ld->ld_errno);
			}
		}
		else
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}
	}

	// Free modify arrays
	//
	MemFree (ppModUser);
	MemFree (ppModApp);

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Initialize pending info
	//
	RESP_INFO ri;
	::FillDefRespInfo (&ri, uRespID, ld, uMsgIDUser, uMsgIDApp);
	ri.uNotifyMsg = WM_ILS_SET_CLIENT_INFO;

	// Queue the pending result
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	if (hr != S_OK)
	{
		if (uMsgIDUser != (ULONG) -1)
			::ldap_abandon (ld, uMsgIDUser);

		if (uMsgIDApp != (ULONG) -1)
			::ldap_abandon (ld, uMsgIDApp);

		if (pSession != NULL)
			pSession->Disconnect ();
	}
	else
	{
		// If the user customizes the ip address
		// we need to remember this
		//
		m_fExternalIPAddress |= IsExternalIPAddressPassedIn ();
	}

	return hr;
}


HRESULT SP_CClient::
AddProtocol ( ULONG uNotifyMsg, ULONG uRespID, SP_CProtocol *pProt )
{
	HRESULT hr = m_Protocols.Append ((VOID *) pProt);
	if (hr == S_OK)
	{
		hr = UpdateProtocols (uNotifyMsg, uRespID, pProt);
	}

	return hr;
}


HRESULT SP_CClient::
RemoveProtocol ( ULONG uNotifyMsg, ULONG uRespID, SP_CProtocol *pProt )
{
	HRESULT hr = m_Protocols.Remove ((VOID *) pProt);
	if (hr == S_OK)
	{
		hr = UpdateProtocols (uNotifyMsg, uRespID, pProt);
	}
	else
	{
		hr = ILS_E_NOT_REGISTERED;
	}

	return hr;
}


HRESULT SP_CClient::
UpdateProtocols ( ULONG uNotifyMsg, ULONG uRespID, SP_CProtocol *pProt )
{
	MyAssert (	uNotifyMsg == WM_ILS_REGISTER_PROTOCOL ||
				uNotifyMsg == WM_ILS_UNREGISTER_PROTOCOL ||
				uNotifyMsg == WM_ILS_SET_PROTOCOL_INFO);
	
	MyAssert (MyIsGoodString (m_pszDN));

	HRESULT hr = S_OK;

	// Build modify array for protocol object's ldap_modify()
	//
	LDAPMod **ppModProt = NULL;
	hr = CreateSetProtModArr (&ppModProt);
	if (hr != S_OK)
		return hr;
	MyAssert (ppModProt != NULL);

	// So far, we are done with local preparation
	//

	// Get the session object
	//
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgIDProt = (ULONG) -1;
	hr = g_pSessionContainer->GetSession (&pSession, &m_ServerInfo);
	if (hr == S_OK)
	{
		MyAssert (pSession != NULL);

		// Get the ldap session
		//
		ld = pSession->GetLd ();
		MyAssert (ld != NULL);

		// Send the data over the wire
		//
		uMsgIDProt = ::ldap_modify (ld, m_pszDN, ppModProt);
		if (uMsgIDProt == -1)
		{
			hr = ::LdapError2Hresult (ld->ld_errno);
		}
	}

	// Free modify arrays
	//
	MemFree (ppModProt);

	// Report failure if so
	//
	if (hr != S_OK)
		goto MyExit;

	// Initialize pending info
	//
	RESP_INFO ri;
	::FillDefRespInfo (&ri, uRespID, ld, uMsgIDProt, INVALID_MSG_ID);
	ri.uNotifyMsg = uNotifyMsg;
	ri.hObject = (HANDLE) pProt;

	// Queue the pending result
	//
	hr = g_pRespQueue->EnterRequest (pSession, &ri);
	if (hr != S_OK)
	{
		MyAssert (FALSE);
		goto MyExit;
	}

MyExit:

	if (hr != S_OK)
	{
		if (uMsgIDProt != (ULONG) -1)
			::ldap_abandon (ld, uMsgIDProt);

		if (pSession != NULL)
			pSession->Disconnect ();
	}

	return hr;
}


HRESULT SP_CClient::
UpdateIPAddress ( VOID )
{
	MyAssert (MyIsGoodString (m_pszDN));

	// Update cached ip address
	//
	HRESULT hr = ::GetLocalIPAddress (&m_dwIPAddress);
	if (hr != S_OK)
		return hr;

	// Update the ip address string
	//
	::GetLongString (m_dwIPAddress, &m_ClientInfo.szIPAddress[0]);

	// Update IP address on the server
	//
	return ::IlsUpdateIPAddress (	&m_ServerInfo,
									m_pszDN,
									STR_CLIENT_IP_ADDR,
									&m_ClientInfo.szIPAddress[0],
									ISBU_MODOP_MODIFY_USER,
									1,
									g_pszUserPrefix);
}


/* ---------- protected methods ----------- */


HRESULT SP_CClient::
SendRefreshMsg ( VOID )
{
	MyAssert (m_pszRefreshFilter != NULL);

	HRESULT hr;

	// Send a refresh message to the server and parse the new TTL value
	//
	hr = ::IlsSendRefreshMsg (	&m_ServerInfo,
								STR_DEF_CLIENT_BASE_DN,
								STR_CLIENT_TTL,
								m_pszRefreshFilter,
								&m_uTTL);
	if (hr == ILS_E_NEED_RELOGON)
	{
		SetRegLocally ();
		::PostMessage (g_hWndNotify, WM_ILS_CLIENT_NEED_RELOGON,
							(WPARAM) this, (LPARAM) m_dwContext);
	}
	else
	if (hr == ILS_E_NETWORK_DOWN)
	{
		SetRegLocally ();
		::PostMessage (g_hWndNotify, WM_ILS_CLIENT_NETWORK_DOWN,
							(WPARAM) this, (LPARAM) m_dwContext);
	}

	// If the ip address is not provided by the app, then
	// we need to make sure that the current ip address is equal to
	// the one we used to register the user.
	//
	if (! m_fExternalIPAddress && hr == S_OK)
	{
		// Get local ip address
		//
		DWORD dwIPAddress = 0;
		if (::GetLocalIPAddress (&dwIPAddress) == S_OK)
		{
			// Now, the network appears to be up and running.
			// Update the ip address if they are different.
			//
			if (dwIPAddress != 0 && dwIPAddress != m_dwIPAddress)
				UpdateIPAddress ();
		}
	}

	return hr;
}


/* ---------- private methods ----------- */


HRESULT SP_CClient::
CreateRegUserModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	// Calculate the modify array size
	//
#ifdef ANY_IN_USER
	ULONG cStdAttrs = COUNT_ENUM_REG_USER;
	ULONG cAnyAttrs = m_ClientInfo.AnyAttrs.cAttrsToAdd;
	ULONG cTotal = cStdAttrs + cAnyAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
#else
	ULONG cStdAttrs = COUNT_ENUM_REG_USER;
	ULONG cTotal = cStdAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
#endif

	// Allocate the modify array
	//
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ILS_E_MEMORY;

	// Lay out the modify array
	//
	LDAPMod **apMod = *pppMod;
	LDAPMod *pMod;
	ULONG i, nIndex;
#ifdef ANY_IN_USER
	TCHAR *pszName2, *pszValue;
	pszName2 = m_ClientInfo.AnyAttrs.pszAttrsToAdd;
#endif
	for (i = 0; i < cTotal; i++)
	{
		// Locate modify element
		//
		pMod = ::IlsGetModifyListMod (pppMod, cTotal, i);
		pMod->mod_op = LDAP_MOD_ADD;
		apMod[i] = pMod;

#ifdef ANY_IN_USER
		if (i < cStdAttrs)
		{
			// Get attribute name and value
			//
			if (IsOverAppAttrLine (i))
			{
				nIndex = i + COUNT_ENUM_SKIP_APP_ATTRS;
			}
			else
			{
				nIndex = i;
			}

			// Put standard attributes
			//
			FillModArrAttr (pMod, nIndex);
		}
		else
		{
			// Put extended attributes
			//
			pszValue = pszName2 + lstrlen (pszName2) + 1;
			::IlsFillModifyListItem (pMod, pszName2, pszValue);
			pszName2 = pszValue + lstrlen (pszValue) + 1;
		}
#else
		// Get attribute name and value
		//
		if (IsOverAppAttrLine (i))
		{
			nIndex = i + COUNT_ENUM_SKIP_APP_ATTRS;
		}
		else
		{
			nIndex = i;
		}

		// Fill in modify element
		//
		FillModArrAttr (pMod, nIndex);
#endif
	}

	apMod[cTotal] = NULL;
	return S_OK;
}


HRESULT SP_CClient::
CreateRegAppModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	// Calculate the modify array size
	//
	ULONG cPrefix = 1; // Skip its own app id
	ULONG cStdAttrs = COUNT_ENUM_REG_APP;
#ifdef ANY_IN_USER
	ULONG cTotal = cPrefix + cStdAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
#else
	ULONG cAnyAttrs = m_ClientInfo.AnyAttrs.cAttrsToAdd;
	ULONG cTotal = cPrefix + cStdAttrs + cAnyAttrs;
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);
#endif

	// Allocate the modify array
	//
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ILS_E_MEMORY;

	// Lay out the modify array
	//
	LDAPMod **apMod = *pppMod;
	LDAPMod *pMod;
#ifdef ANY_IN_USER
	TCHAR *pszName1, *pszValue;
	pszName1 = m_pszAppPrefix;;
#else
	TCHAR *pszName1, *pszName2, *pszValue;
	pszName1 = m_pszAppPrefix;;
	pszName2 = m_ClientInfo.AnyAttrs.pszAttrsToAdd;
#endif
	for (ULONG i = 0; i < cTotal; i++)
	{
		// Locate modify element
		//
		pMod = ::IlsGetModifyListMod (pppMod, cTotal, i);
		pMod->mod_op = LDAP_MOD_ADD;
		apMod[i] = pMod;

		if (i < cPrefix)
		{
			// Put the prefix
			//
			pMod->mod_op = LDAP_MOD_REPLACE;
			pszValue = pszName1 + lstrlen (pszName1) + 1;
			::IlsFillModifyListItem (pMod, pszName1, pszValue);
			pszName1 = pszValue + lstrlen (pszValue) + 1;
		}
		else
#ifdef ANY_IN_USER
		{
			// Put standard attributes
			//
			FillModArrAttr (pMod, i - cPrefix + ENUM_CLIENTATTR_APP_NAME);
		}
#else
		if (i < cPrefix + cStdAttrs)
		{
			// Put standard attributes
			//
			FillModArrAttr (pMod, i - cPrefix + ENUM_CLIENTATTR_APP_NAME);
		}
		else
		{
			// Put extended attributes
			//
			pszValue = pszName2 + lstrlen (pszName2) + 1;
			::IlsFillModifyListItem (pMod, pszName2, pszValue);
			pszName2 = pszValue + lstrlen (pszValue) + 1;
		}
#endif
	}

	::IlsFixUpModOp (apMod[0], LDAP_MOD_ADD, ISBU_MODOP_ADD_APP);
	apMod[cTotal] = NULL;
	return S_OK;
}


HRESULT SP_CClient::
CreateSetUserAttrsModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	HRESULT hr;
	DWORD dwFlags = m_ClientInfo.dwFlags & CLIENTOBJ_F_USER_MASK;
#ifdef ANY_IN_USER
	ULONG cTotal  = m_ClientInfo.AnyAttrs.cAttrsToAdd +
					m_ClientInfo.AnyAttrs.cAttrsToModify +
					m_ClientInfo.AnyAttrs.cAttrsToRemove;
#else
	ULONG cTotal = 0; // must be initialized to zero
#endif

	// Lay out the modify array for modifying user standard attributes
	//
	hr = ::IlsFillDefStdAttrsModArr (pppMod,
									dwFlags,
									COUNT_ENUM_SET_USER_INFO,
									&cTotal,
									ISBU_MODOP_MODIFY_USER,
									1,
									g_pszUserPrefix);
	if (hr != S_OK)
		return hr;

	// Start to fill standard attributes
	//
	ULONG i = 1;
	LDAPMod **apMod = *pppMod;

	if (dwFlags & CLIENTOBJ_F_EMAIL_NAME)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_EMAIL_NAME);

	if (dwFlags & CLIENTOBJ_F_FIRST_NAME)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_FIRST_NAME);

	if (dwFlags & CLIENTOBJ_F_LAST_NAME)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_LAST_NAME);

	if (dwFlags & CLIENTOBJ_F_CITY_NAME)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_CITY_NAME);

	if (dwFlags & CLIENTOBJ_F_C)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_C);

	if (dwFlags & CLIENTOBJ_F_COMMENT)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_COMMENT);

	if (dwFlags & CLIENTOBJ_F_IP_ADDRESS)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_IP_ADDRESS);

	if (dwFlags & CLIENTOBJ_F_FLAGS)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_FLAGS);

#ifdef ANY_IN_USER
	// Start to fill extended attributes
	//
	::IlsFillModifyListForAnyAttrs (apMod, &i, &m_ClientInfo.AnyAttrs);
#else
#endif

	MyAssert (i == cTotal);
	return S_OK;
}


HRESULT SP_CClient::
CreateSetAppAttrsModArr ( LDAPMod ***pppMod )
{
	MyAssert (pppMod != NULL);

	HRESULT hr;
	DWORD dwFlags = m_ClientInfo.dwFlags & CLIENTOBJ_F_APP_MASK;
#ifdef ANY_IN_USER
	ULONG cTotal = 0; // must be initialized to zero
#else
	ULONG cTotal  = m_ClientInfo.AnyAttrs.cAttrsToAdd +
					m_ClientInfo.AnyAttrs.cAttrsToModify +
					m_ClientInfo.AnyAttrs.cAttrsToRemove;
#endif

	// Lay out the modify array for modifying app standard/extended attributes
	//
	hr = ::IlsFillDefStdAttrsModArr (pppMod,
									dwFlags,
									COUNT_ENUM_SET_APP_INFO,
									&cTotal,
									ISBU_MODOP_MODIFY_APP,
									2,
									m_pszAppPrefix);
	if (hr != S_OK)
		return hr;

	// Start to fill standard attributes
	//
	ULONG i = 2;
	LDAPMod **apMod = *pppMod;

	if (m_ClientInfo.dwFlags & CLIENTOBJ_F_APP_GUID)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_APP_GUID);

	if (m_ClientInfo.dwFlags & CLIENTOBJ_F_APP_NAME)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_APP_NAME);

	if (m_ClientInfo.dwFlags & CLIENTOBJ_F_APP_MIME_TYPE)
		FillModArrAttr (apMod[i++], ENUM_CLIENTATTR_APP_MIME_TYPE);

#ifdef ANY_IN_USER
#else
	// Start to fill extended attributes
	//
	::IlsFillModifyListForAnyAttrs (apMod, &i, &m_ClientInfo.AnyAttrs);
#endif

	MyAssert (i == cTotal);
	return S_OK;
}


HRESULT SP_CClient::
CreateSetProtModArr ( LDAPMod ***pppMod )
// We need to delete the attributes and then add the entire array back.
// This is due to the ILS server limitation. We agreed to live with that.
//
{
	MyAssert (pppMod != NULL);

	ULONG cPrefix = 2;
	TCHAR *pszPrefix = m_pszAppPrefix;

	ULONG cStdAttrs = COUNT_ENUM_PROTATTR;
	ULONG cTotal = cPrefix + cStdAttrs + cStdAttrs;
	ULONG cProts = 0;

	// Find out how many protocols
	//
   	HANDLE hEnum = NULL;
	SP_CProtocol *pProt;
    m_Protocols.Enumerate (&hEnum);
    while (m_Protocols.Next (&hEnum, (VOID **) &pProt) == NOERROR)
    	cProts++;

	// Calculate the modify array's total size
	//
	ULONG cbMod = ::IlsCalcModifyListSize (cTotal);

	// Add up for multi-valued attribute
	//
	if (cProts > 0)
	{
		cbMod += cStdAttrs * (cProts - 1) * sizeof (TCHAR *);
	}

	// Allocate the modify array
	//
	LDAPMod **apMod = *pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (apMod == NULL)
		return ILS_E_MEMORY;

	// Fill in the modify list
	//
	LDAPMod *pMod;
	BYTE *pbData = (BYTE *) apMod + (cTotal + 1) * sizeof (LDAPMod *);
	ULONG uDispPrefix = sizeof (LDAPMod) + 2 * sizeof (TCHAR *);
	ULONG uDispStdAttrs = sizeof (LDAPMod) + (cProts + 1) * sizeof (TCHAR *);
	for (ULONG uOffset = 0, i = 0; i < cTotal; i++)
	{
		// Locate the modify structure
		//
		pMod = (LDAPMod *) (pbData + uOffset);
		apMod[i] = pMod;
		pMod->mod_values = (TCHAR **) (pMod + 1);

		// Fill in the modify structure
		//
		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
		else
		if (i < cPrefix + cStdAttrs)
		{
			// Work around the ISBU server implementation!!!
			// We agreed that we can live with the server implementation.
			//
			pMod->mod_op = LDAP_MOD_DELETE;

			ULONG nIndex = i - cPrefix;

			// Fill in attribute name
			//
			pMod->mod_type = (TCHAR *) c_apszProtStdAttrNames[nIndex];
		}
		else
		{
			pMod->mod_op = LDAP_MOD_ADD;

			ULONG nIndex = i - cPrefix - cStdAttrs;

			// Fill in attribute name
			//
			pMod->mod_type = (TCHAR *) c_apszProtStdAttrNames[nIndex];

		    // Fill in multi-valued modify array
		    //
		    if (cProts > 0)
		    {
				ULONG j = 0; // must initialized to zero
				TCHAR *pszVal;

			    m_Protocols.Enumerate (&hEnum);
			    MyAssert (hEnum != NULL);
			    while (m_Protocols.Next (&hEnum, (VOID **) &pProt) == NOERROR)
			    {
			    	MyAssert (pProt != NULL);
			    	pszVal = (pProt->GetProtInfo ())->apszStdAttrValues[nIndex];
			    	(pMod->mod_values)[j++] = (pszVal != NULL) ? pszVal : STR_EMPTY;
			    }
		    }
		    else
		    {
		    	(pMod->mod_values)[0] = STR_EMPTY;
		    }
		}

		// Calculate the modify structure's offset relative to the array's end
		//
		uOffset += (i < cPrefix + cStdAttrs) ? uDispPrefix : uDispStdAttrs;
	}

	// Fix up the first and the last ones
	//
	IlsFixUpModOp (apMod[0], LDAP_MOD_REPLACE, ISBU_MODOP_MODIFY_APP);
	apMod[cTotal] = NULL;

	return S_OK;
}


VOID SP_CClient::
FillModArrAttr ( LDAPMod *pMod, INT nIndex )
{
	MyAssert (pMod != NULL);
	MyAssert (0 <= nIndex && nIndex <= COUNT_ENUM_CLIENTATTR);

	::IlsFillModifyListItem (	pMod,
								(TCHAR *) c_apszClientStdAttrNames[nIndex],
								m_ClientInfo.apszStdAttrValues[nIndex]);
}


HRESULT SP_CClient::
CacheClientInfo ( LDAP_CLIENTINFO *pInfo )
{
	MyAssert (pInfo != NULL);

	// Release the previous prefix for extended attribute names
	//
	::IlsReleaseAnyAttrsPrefix (&(m_ClientInfo.AnyAttrs));

	// Clean up the buffer
	//
	ZeroMemory (&m_ClientInfo, sizeof (m_ClientInfo));

	// Start to cache user standard attributes
	//

	if (pInfo->uOffsetCN != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CN] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetCN);
		// We do not want to change CN thru ldap_modify()
		// m_ClientInfo.dwFlags |= CLIENTOBJ_F_CN;
	}

	if (pInfo->uOffsetFirstName != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_FIRST_NAME] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetFirstName);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_FIRST_NAME;
	}

	if (pInfo->uOffsetLastName != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_LAST_NAME] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetLastName);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_LAST_NAME;
	}

	if (pInfo->uOffsetEMailName != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_EMAIL_NAME] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetEMailName);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_EMAIL_NAME;
	}

	if (pInfo->uOffsetCityName != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_CITY_NAME] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetCityName);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_CITY_NAME;
	}

	if (pInfo->uOffsetCountryName != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_C] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetCountryName);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_C;
	}

	if (pInfo->uOffsetComment != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_COMMENT] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetComment);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_COMMENT;
	}

	if (pInfo->uOffsetIPAddress != INVALID_OFFSET)
	{
		DWORD dwIPAddr = ::inet_addr ((TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetIPAddress));
		if (dwIPAddr != INADDR_NONE)
		{
			m_dwIPAddress = dwIPAddr;
			m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_IP_ADDRESS] = &m_ClientInfo.szIPAddress[0];
			::GetLongString (m_dwIPAddress, &m_ClientInfo.szIPAddress[0]);
			m_ClientInfo.dwFlags |= CLIENTOBJ_F_IP_ADDRESS;
		}
	}

	if (pInfo->dwFlags != INVALID_USER_FLAGS)
	{
		::GetLongString (pInfo->dwFlags, &m_ClientInfo.szFlags[0]);
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_FLAGS] = &m_ClientInfo.szFlags[0];
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_FLAGS;
	}

	// Start to cache app standard attributes
	//

	if (pInfo->uOffsetAppName != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_NAME] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAppName);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_APP_NAME;
	}

	if (pInfo->uOffsetAppMimeType != INVALID_OFFSET)
	{
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_MIME_TYPE] =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAppMimeType);
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_APP_MIME_TYPE;
	}

	if (::IsValidGuid (&(pInfo->AppGuid)))
	{
		::GetGuidString (&(pInfo->AppGuid), &m_ClientInfo.szGuid[0]);
		m_ClientInfo.apszStdAttrValues[ENUM_CLIENTATTR_APP_GUID] = &m_ClientInfo.szGuid[0];
		m_ClientInfo.dwFlags |= CLIENTOBJ_F_APP_GUID;
	}

	// Start to cache app extended attributes
	//

	if (pInfo->uOffsetAttrsToAdd != INVALID_OFFSET &&
		pInfo->cAttrsToAdd != 0)
	{
		m_ClientInfo.AnyAttrs.cAttrsToAdd = pInfo->cAttrsToAdd;
		m_ClientInfo.AnyAttrs.pszAttrsToAdd =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAttrsToAdd);
	}

	if (pInfo->uOffsetAttrsToModify != INVALID_OFFSET &&
		pInfo->cAttrsToModify != 0)
	{
		m_ClientInfo.AnyAttrs.cAttrsToModify = pInfo->cAttrsToModify;
		m_ClientInfo.AnyAttrs.pszAttrsToModify =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAttrsToModify);
	}

	if (pInfo->uOffsetAttrsToRemove != INVALID_OFFSET &&
		pInfo->cAttrsToRemove != 0)
	{
		m_ClientInfo.AnyAttrs.cAttrsToRemove = pInfo->cAttrsToRemove;
		m_ClientInfo.AnyAttrs.pszAttrsToRemove =
						(TCHAR *) (((BYTE *) pInfo) + pInfo->uOffsetAttrsToRemove);
	}

	// Create prefix for extended attribute names
	//
	return ::IlsCreateAnyAttrsPrefix (&(m_ClientInfo.AnyAttrs));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spclient.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spclient.h
	Content:	This file contains the client object definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ILS_SP_CLIENTOBJ_H_
#define _ILS_SP_CLIENTOBJ_H_

#include <pshpack8.h>

// Enumeration constants to represent client object members
//
enum
{
	/* -- the following is for user -- */

	ENUM_CLIENTATTR_CN,
	ENUM_CLIENTATTR_FIRST_NAME,
	ENUM_CLIENTATTR_LAST_NAME,
	ENUM_CLIENTATTR_EMAIL_NAME,
	ENUM_CLIENTATTR_CITY_NAME,
	ENUM_CLIENTATTR_COMMENT,
	ENUM_CLIENTATTR_IP_ADDRESS,
	ENUM_CLIENTATTR_FLAGS,
	ENUM_CLIENTATTR_C,

	/* -- the following is for app -- */

	ENUM_CLIENTATTR_APP_NAME,
	ENUM_CLIENTATTR_APP_MIME_TYPE,
	ENUM_CLIENTATTR_APP_GUID,

	ENUM_CLIENTATTR_PROT_NAME,
	ENUM_CLIENTATTR_PROT_MIME,
	ENUM_CLIENTATTR_PROT_PORT,

	/* -- the above are resolvable -- */

	ENUM_CLIENTATTR_CLIENT_SIG,
	ENUM_CLIENTATTR_TTL,

	/* -- the above are changeable standard attributes for RTPerson -- */

	/* --- DO NOT ADD NEW ATTRIBUTES BELOW THIS LINE --- */
	/* --- COUNT_ENUM_REG_USER relies on this ---- */

	ENUM_CLIENTATTR_OBJECT_CLASS,
	ENUM_CLIENTATTR_O,
	COUNT_ENUM_CLIENTATTR
};

// Derived constants
//
#define COUNT_ENUM_REG_APP				6
#define COUNT_ENUM_SET_APP_INFO			16
#define COUNT_ENUM_SKIP_APP_ATTRS		COUNT_ENUM_REG_APP

#define COUNT_ENUM_CLIENT_INFO			(ENUM_CLIENTATTR_TTL + 1)
#define COUNT_ENUM_REG_USER				(COUNT_ENUM_CLIENTATTR - 2 - COUNT_ENUM_SKIP_APP_ATTRS) // excluding o and objectClass
#define COUNT_ENUM_SET_USER_INFO		(ENUM_CLIENTATTR_C + 1)

#define COUNT_ENUM_DIR_CLIENT_INFO		(ENUM_CLIENTATTR_C + 1)	// count of attrs in dir dlg
#define COUNT_ENUM_RES_CLIENT_INFO		(ENUM_CLIENTATTR_CLIENT_SIG - 1) // count of attrs resolvable


// Shorthands for commonly used names
//
extern const TCHAR *c_apszClientStdAttrNames[];
#define STR_CLIENT_CN		(TCHAR *) c_apszClientStdAttrNames[ENUM_CLIENTATTR_CN]
#define STR_CLIENT_O		(TCHAR *) c_apszClientStdAttrNames[ENUM_CLIENTATTR_O]
#define STR_CLIENT_C		(TCHAR *) c_apszClientStdAttrNames[ENUM_CLIENTATTR_C]
#define STR_CLIENT_IP_ADDR	(TCHAR *) c_apszClientStdAttrNames[ENUM_CLIENTATTR_IP_ADDRESS]
#define STR_CLIENT_TTL		(TCHAR *) c_apszClientStdAttrNames[ENUM_CLIENTATTR_TTL]
#define STR_CLIENT_APP_NAME	(TCHAR *) c_apszClientStdAttrNames[ENUM_CLIENTATTR_APP_NAME]

// Flags to indicate which fields are valid in CLIENT_INFO
//
#define CLIENTOBJ_F_CN				0x0001
#define CLIENTOBJ_F_FIRST_NAME		0x0002
#define CLIENTOBJ_F_LAST_NAME		0x0004
#define CLIENTOBJ_F_EMAIL_NAME		0x0008
#define CLIENTOBJ_F_CITY_NAME		0x0010
#define CLIENTOBJ_F_C				0x0020
#define CLIENTOBJ_F_COMMENT			0x0040
#define CLIENTOBJ_F_IP_ADDRESS		0x0080
#define CLIENTOBJ_F_FLAGS			0x0100

#define CLIENTOBJ_F_APP_NAME		0x1000
#define CLIENTOBJ_F_APP_MIME_TYPE	0x2000
#define CLIENTOBJ_F_APP_GUID		0x4000

#define CLIENTOBJ_F_USER_MASK		0x0FFF
#define CLIENTOBJ_F_APP_MASK		0xF000

// Client Info structure
//
typedef struct
{
	DWORD		dwFlags;
	// the following is to cache attributes
	TCHAR		*apszStdAttrValues[COUNT_ENUM_CLIENTATTR];
	ANY_ATTRS	AnyAttrs;
	// the following is scratch buffers
	TCHAR		szIPAddress[INTEGER_STRING_LENGTH];
	TCHAR		szFlags[INTEGER_STRING_LENGTH];
	TCHAR		szTTL[INTEGER_STRING_LENGTH];
	TCHAR		szClientSig[INTEGER_STRING_LENGTH];
	TCHAR		szGuid[sizeof (GUID) * 2 + 2];
}
	CLIENT_INFO;

// A flag to indicate that this client object is valid
//
#define CLIENTOBJ_SIGNATURE	((ULONG) 0x12345678UL)


// Client class
//
class SP_CClient
{
	friend class SP_CRefreshScheduler;
	friend class SP_CProtocol;

public:

	SP_CClient ( DWORD_PTR dwContext );
	~SP_CClient ( VOID );

	ULONG AddRef ( VOID );
	ULONG Release ( VOID );

	HRESULT Register ( ULONG uRespID, SERVER_INFO *pServerInfo, LDAP_CLIENTINFO *pInfo );
	HRESULT UnRegister ( ULONG uRespID );

	HRESULT SetAttributes ( ULONG uRespID, LDAP_CLIENTINFO *pInfo );
	HRESULT UpdateIPAddress ( VOID );

	VOID SetRegNone ( VOID ) { m_RegStatus = ILS_REG_STATUS_NONE; }
	VOID SetRegLocally ( VOID ) { m_RegStatus = ILS_REG_STATUS_LOCALLY; }
	VOID SetRegRemotely ( VOID ) { m_RegStatus = ILS_REG_STATUS_REMOTELY; }

	BOOL IsRegistered ( VOID ) { return (m_RegStatus > ILS_REG_STATUS_NONE); }
	BOOL IsRegLocally ( VOID ) { return (m_RegStatus == ILS_REG_STATUS_LOCALLY); }
	BOOL IsRegRemotely ( VOID ) { return (m_RegStatus == ILS_REG_STATUS_REMOTELY); }

	BOOL IsValidObject ( VOID ) { return m_uSignature == CLIENTOBJ_SIGNATURE; }

	SERVER_INFO *GetServerInfo ( VOID ) { return &m_ServerInfo; }

	ULONG GetTTL ( VOID ) { return m_uTTL; }
	DWORD_PTR GetContext ( VOID ) { return m_dwContext; }

protected:

	HRESULT AddProtocol ( ULONG uNotifyMsg, ULONG uRespID, SP_CProtocol *pProt );
	HRESULT RemoveProtocol ( ULONG uNotifyMsg, ULONG uRespID, SP_CProtocol *pProt );
	HRESULT UpdateProtocols ( ULONG uNotifyMsg, ULONG uRespID, SP_CProtocol *pProt );

	TCHAR *GetDN ( VOID ) { return m_pszDN; }

	ULONG GetAppPrefixCount ( VOID ) { return 2; }
	TCHAR *GetAppPrefixString ( VOID ) { return m_pszAppPrefix; }

	HRESULT SendRefreshMsg ( VOID );

private:

	HRESULT RegisterUser ( VOID );
	HRESULT RegisterApp ( VOID );
	HRESULT UnRegisterUser ( VOID );
	HRESULT UnRegisterApp ( VOID );

	HRESULT SetUserAttributes ( VOID );
	HRESULT SetAppAttributes ( VOID );

	HRESULT CacheClientInfo ( LDAP_CLIENTINFO *pInfo );

	HRESULT CreateRegUserModArr ( LDAPMod ***pppMod );
	HRESULT CreateRegAppModArr ( LDAPMod ***pppMod );

	HRESULT CreateSetUserAttrsModArr ( LDAPMod ***pppMod );
	HRESULT CreateSetAppAttrsModArr ( LDAPMod ***pppMod );

	HRESULT CreateSetProtModArr ( LDAPMod ***pppMod );

	VOID FillModArrAttr ( LDAPMod *pMod, INT nIndex );

	BOOL IsOverAppAttrLine ( LONG i ) { return (ENUM_CLIENTATTR_APP_NAME <= (i)); }

	BOOL IsExternalIPAddressPassedIn ( VOID ) { return (m_ClientInfo.dwFlags & CLIENTOBJ_F_IP_ADDRESS); }

	LONG		m_cRefs;
	ULONG		m_uSignature;

	SERVER_INFO	m_ServerInfo;
	CLIENT_INFO	m_ClientInfo;
	CList		m_Protocols;

	TCHAR		*m_pszDN;
	TCHAR		*m_pszAppPrefix;

	TCHAR		*m_pszRefreshFilter;

	REG_STATUS	m_RegStatus;

	BOOL		m_fExternalIPAddress;
	DWORD		m_dwIPAddress;
	ULONG		m_uTTL;

	DWORD_PTR	m_dwContext;	// COM layer context
};


#include <poppack.h>

#endif // _ILS_SP_USEROBJ_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spconn.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spconn.h
	Content:	This file contains the ldap connection object definition.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _ILS_SP_CONNECT_H_
#define _ILS_SP_CONNECT_H_

#include <pshpack8.h>

extern ULONG g_uResponseTimeout;


#define LDAP_CONN_SIGNATURE		((DWORD) 0xF9369606)
#define MAX_LDAP_DN				256

#ifdef USE_DEFAULT_COUNTRY
extern const TCHAR c_szDefC[];
#endif
extern const TCHAR c_szDefO[];
extern const TCHAR c_szRTPerson[];
extern const TCHAR c_szRTConf[];
extern const TCHAR c_szDefClientBaseDN[];
extern const TCHAR c_szDefMtgBaseDN[];
extern const TCHAR c_szEmptyString[];

#define STR_DEF_CLIENT_BASE_DN	((TCHAR *) &c_szDefClientBaseDN[0])
#define STR_DEF_MTG_BASE_DN		((TCHAR *) &c_szDefMtgBaseDN[0])

#define STR_EMPTY				((TCHAR *) &c_szEmptyString[0])


class SP_CSession
{
	friend class SP_CSessionContainer;

public:

	SP_CSession ( VOID );
	~SP_CSession ( VOID );

	// session management
	LDAP *GetLd ( VOID ) { return m_ld; }
	HRESULT Disconnect ( VOID );

	// server timeout
	ULONG GetServerTimeoutInSecond ( VOID )
	{ 
		return ((m_ServerInfo.uTimeoutInSecond != 0) ?
					m_ServerInfo.uTimeoutInSecond :
					g_uResponseTimeout / 1000);
	}
	ULONG GetServerTimeoutInTickCount ( VOID )
	{ 
		return ((m_ServerInfo.uTimeoutInSecond != 0) ?
					m_ServerInfo.uTimeoutInSecond * 1000 :
					g_uResponseTimeout);
	}

protected:

	// session management
	HRESULT Connect ( SERVER_INFO *pInfo, ULONG cConns, BOOL fAbortable );
	BOOL SameServerInfo ( SERVER_INFO *pInfo ) { return IlsSameServerInfo (&m_ServerInfo, pInfo); }

	// array management
	BOOL IsUsed ( VOID ) { return m_fUsed; }
	VOID SetUsed ( VOID ) { m_fUsed = TRUE; }
	VOID ClearUsed ( VOID ) { m_fUsed = FALSE; }

private:

	VOID FillAuthIdentity ( SEC_WINNT_AUTH_IDENTITY *pai );
	HRESULT Bind ( BOOL fAbortable );
	VOID InternalCleanup ( VOID );

	DWORD			m_dwSignature;
	SERVER_INFO		m_ServerInfo;
	LONG			m_cRefs;
	LDAP			*m_ld;
	BOOL			m_fUsed;
};


class SP_CSessionContainer
{
public:

	SP_CSessionContainer ( VOID );
	~SP_CSessionContainer ( VOID );

	HRESULT Initialize ( ULONG cEntries, SP_CSession *ConnArr );

	HRESULT GetSession ( SP_CSession **ppConn, SERVER_INFO *pInfo, ULONG cConns, BOOL fAbortable );	
	HRESULT GetSession ( SP_CSession **ppConn, SERVER_INFO *pInfo, BOOL fAbortable ) { return GetSession (ppConn, pInfo, 1, fAbortable); }
	HRESULT GetSession ( SP_CSession **ppConn, SERVER_INFO *pInfo ) { return GetSession (ppConn, pInfo, 1, TRUE); }

protected:

private:

	VOID ReadLock ( VOID ) { EnterCriticalSection (&m_csSessContainer); }
	VOID ReadUnlock ( VOID ) { LeaveCriticalSection (&m_csSessContainer); }
	VOID WriteLock ( VOID ) { ReadLock (); }
	VOID WriteUnlock ( VOID ) { ReadUnlock (); }

	ULONG			m_cEntries;
	SP_CSession		*m_aConns;

	CRITICAL_SECTION m_csSessContainer;
};


extern SP_CSessionContainer *g_pSessionContainer;

#include <poppack.h>

#endif // _ILS_SP_CONNECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spconn.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spconn.cpp
	Content:	This file contains the ldap connection object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"
#include "rpcdce.h"

const TCHAR c_szRTPerson[] = TEXT ("RTPerson");
const TCHAR c_szRTConf[] = TEXT ("Conference");

const TCHAR c_szDefClientBaseDN[] = TEXT ("objectClass=RTPerson");
const TCHAR c_szDefMtgBaseDN[] = TEXT ("objectClass=Conference");

const TCHAR c_szDefO[] = TEXT ("Microsoft");
const TCHAR c_szEmptyString[] = TEXT ("");


SP_CSessionContainer *g_pSessionContainer = NULL;


/* ---------- public methods ----------- */


SP_CSession::
SP_CSession ( VOID ) :
	m_cRefs (0),
	m_dwSignature (0),
	m_ld (NULL),
	m_fUsed (FALSE)
{
	::ZeroMemory (&m_ServerInfo, sizeof (m_ServerInfo));
}


SP_CSession::
~SP_CSession ( VOID )
{
	InternalCleanup ();
}


/* ---------- public methods ----------- */


HRESULT SP_CSession::
Disconnect ( VOID )
{
	// if a connection is available, then simply the existing one
	if (m_dwSignature != LDAP_CONN_SIGNATURE)
	{
		return ILS_E_HANDLE;
	}

	MyAssert (m_cRefs > 0);

	HRESULT hr = S_OK;
	if (::InterlockedDecrement (&m_cRefs) == 0)
	{
		// m_cRefs == 0 now
		MyAssert (m_ld != NULL);

		InternalCleanup ();
		hr = S_OK;
	}

	return hr;
}


/* ---------- protected methods ----------- */


VOID SP_CSession::
FillAuthIdentity ( SEC_WINNT_AUTH_IDENTITY *pai )
{
	// Clean it up
	//
	::ZeroMemory (pai, sizeof (*pai));

	// Fill in NT auth identity
	//
	if ((pai->User = (BYTE *) m_ServerInfo.pszLogonName) != NULL)
		pai->UserLength = lstrlen (m_ServerInfo.pszLogonName);

	if ((pai->Domain = (BYTE *) m_ServerInfo.pszDomain) != NULL)
		pai->DomainLength = lstrlen (m_ServerInfo.pszDomain);

	if ((pai->Password = (BYTE *) m_ServerInfo.pszLogonPassword) != NULL)
		pai->PasswordLength = lstrlen (m_ServerInfo.pszLogonPassword);

#ifdef _UNICODE
	pai->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
#else
	pai->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
#endif
}

				
HRESULT SP_CSession::
Bind ( BOOL fAbortable )
{
	ULONG uLdapAuthMethod = LDAP_AUTH_SIMPLE;
	TCHAR *pszLogonName = m_ServerInfo.pszLogonName;
	TCHAR *pszLogonPassword = m_ServerInfo.pszLogonPassword;
	SEC_WINNT_AUTH_IDENTITY ai;
	BOOL fSyncBind = TRUE;
	HRESULT hr = S_OK;

	switch (m_ServerInfo.AuthMethod)
	{
	default:
		MyAssert (FALSE);
		// Fall through...

	case ILS_AUTH_ANONYMOUS:
		fSyncBind = FALSE;
		uLdapAuthMethod = LDAP_AUTH_SIMPLE;
		pszLogonName = STR_EMPTY;
		pszLogonPassword = STR_EMPTY;
		break;

	case ILS_AUTH_CLEAR_TEXT:
		fSyncBind = FALSE;
		uLdapAuthMethod = LDAP_AUTH_SIMPLE;
		break;

	case ILS_AUTH_NTLM:
		uLdapAuthMethod = LDAP_AUTH_NTLM;
		FillAuthIdentity (&ai);
		pszLogonName = NULL;
		pszLogonPassword = (TCHAR *) &ai;
		break;

	case ILS_AUTH_DPA:
		uLdapAuthMethod = LDAP_AUTH_DPA;
		break;

	case ILS_AUTH_MSN:
		uLdapAuthMethod = LDAP_AUTH_MSN;
		break;

	case ILS_AUTH_SICILY:
		uLdapAuthMethod = LDAP_AUTH_SICILY;
		break;

	case ILS_AUTH_SSPI:
		uLdapAuthMethod = LDAP_AUTH_SSPI;
		break;
	}

	if (fSyncBind)
	{
		INT nRetCode = ::ldap_bind_s (m_ld, pszLogonName,
									pszLogonPassword,
									uLdapAuthMethod);
		hr = (nRetCode == LDAP_SUCCESS) ? S_OK : ILS_E_BIND;
	}
	else
	{
		INT uMsgID = ::ldap_bind (m_ld, pszLogonName,
									pszLogonPassword,
									uLdapAuthMethod);

		INT ResultType;
		LDAP_TIMEVAL TimeVal;
		LDAPMessage *pMsg;

		LONG i, nTimeoutInSecond;
		nTimeoutInSecond = GetServerTimeoutInSecond ();
	    for (i = 0; i < nTimeoutInSecond; i++)
		{
			TimeVal.tv_usec = 0;
			TimeVal.tv_sec = 1;
			pMsg = NULL;

			ResultType = ::ldap_result (m_ld, uMsgID, LDAP_MSG_ALL, &TimeVal, &pMsg);
			if (ResultType == LDAP_RES_BIND)
			{
				break;
			}
			else
			{
				// deal with timeout or error
				if (ResultType == 0)
				{
					MyAssert (g_pReqQueue != NULL);
					if (fAbortable && g_pReqQueue != NULL &&
						g_pReqQueue->IsCurrentRequestCancelled ())
					{
						hr = ILS_E_ABORT;
					}
					else
					{
						continue;
					}
				}
				else
				if (ResultType == -1)
				{
					hr = ILS_E_BIND;
				}
				else
				{
                                        // lonchanc: AndyHe said the return value
                                        // can be anything. Thus, removed the assertion.
					hr = ILS_E_FAIL;
				}

				::ldap_abandon (m_ld, uMsgID);
				::ldap_unbind (m_ld);
				m_ld = NULL;
				return hr;
			}
		}

		// Check if it times out
		//
		if (i >= nTimeoutInSecond)
		{
			hr = ILS_E_TIMEOUT;
			::ldap_abandon (m_ld, uMsgID);
			::ldap_unbind (m_ld);
			m_ld = NULL;
			return hr;
		}

		MyAssert (pMsg != NULL);

		::ldap_msgfree (pMsg);
		hr = S_OK;
	}

	return hr;
}


HRESULT SP_CSession::
Connect (
	SERVER_INFO			*pInfo,
	ULONG				cConns,
	BOOL				fAbortable )
{
	// If a connection is available,
	// then simply the existing one
	//
	if (m_dwSignature == LDAP_CONN_SIGNATURE)
	{
		m_cRefs += cConns;
		return S_OK;
	}

	// We need to create a new connection
	// let's cache the server info
	//
	HRESULT hr = ::IlsCopyServerInfo (&m_ServerInfo, pInfo);
	if (hr != S_OK)
		return hr;

	// Connect to ldap server
	//
	ULONG ulPort = LDAP_PORT;
	LPTSTR pszServerName = My_strdup(m_ServerInfo.pszServerName);
	if (NULL == pszServerName)
	{
		return E_OUTOFMEMORY;
	}
	LPTSTR pszSeparator = My_strchr(pszServerName, _T(':'));
	if (NULL != pszSeparator)
	{
		*pszSeparator = _T('\0');
		ulPort = GetStringLong(pszSeparator + 1);
	}
	
	m_ld = ::ldap_open (pszServerName, ulPort);
	MemFree(pszServerName);
	if (m_ld == NULL)
	{
		// We need to know why ldap_open() failed.
		// Is it because server name is not valid?
		// Or is it because server does not support LDAP?
		//
		// hr = (gethostbyname (m_ServerInfo.pszServerName) != NULL) ?
		// Winsock will set ERROR_OPEN_FAILED, but wldap32.dll sets ERROR_HOST_UNREACHABLE
		// The down side is that when the server was down, the client will try ULP.
		//
		DWORD dwErr = ::GetLastError ();
		MyDebugMsg ((ZONE_REQ, "ULS: ldap_open failed, err=%lu)\r\n", dwErr));
		hr = (dwErr == ERROR_OPEN_FAILED || dwErr == ERROR_HOST_UNREACHABLE) ?
			ILS_E_SERVER_SERVICE : ILS_E_SERVER_NAME;
		goto MyExit;
	}

	// Do the bind
	//
	hr = Bind (fAbortable);
	if (hr == S_OK)
	{
		// remember the handle and increment the reference count
		m_cRefs = cConns;
		m_dwSignature = LDAP_CONN_SIGNATURE;
	}

MyExit:

	MyDebugMsg ((ZONE_CONN, "ILS: Connect: hr=0x%p, m_ld=0x%p, server=%s\r\n", (DWORD) hr, m_ld, m_ServerInfo.pszServerName));

	if (hr != S_OK)
	{
		InternalCleanup ();
	}

	return hr;
}


/* ---------- private methods ----------- */


VOID SP_CSession::
InternalCleanup ( VOID )
{
	if (IsUsed ())
	{
		MyDebugMsg ((ZONE_CONN, "ILS: InternalCleanup: m_ld=0x%p, server=%s\r\n", m_ld, m_ServerInfo.pszServerName));

		// Clean up these two ASAP because ldap_unbind may delay
		//
		m_dwSignature = 0;
		::IlsFreeServerInfo (&m_ServerInfo);

		// Free the ldap infor
		//
		if (m_ld != NULL)
		{
			ldap_unbind (m_ld);
			m_ld = NULL;
		}

		// Clear it out
		//
		ClearUsed ();
	}
}


/* ==================== container ========================= */


/* ---------- public methods ----------- */


SP_CSessionContainer::
SP_CSessionContainer ( VOID ) :
	m_cEntries (0),
	m_aConns (NULL)
{
	::MyInitializeCriticalSection (&m_csSessContainer);
}


SP_CSessionContainer::
~SP_CSessionContainer ( VOID )
{
	::MyDeleteCriticalSection (&m_csSessContainer);
	m_cEntries = 0;
	delete [] m_aConns;
}


HRESULT SP_CSessionContainer::
Initialize (
	ULONG			cEntries,
	SP_CSession		*ConnArr )
{
	m_cEntries = cEntries;
	m_aConns = new SP_CSession[cEntries];
	return ((m_aConns != NULL) ? S_OK : ILS_E_MEMORY);
}


HRESULT SP_CSessionContainer::
GetSession (
	SP_CSession			**ppConn,
	SERVER_INFO			*pInfo,
	ULONG				cConns,
	BOOL				fAbortable )
{
	MyAssert (ppConn != NULL);
	MyAssert (pInfo != NULL);

	*ppConn = NULL;

	HRESULT hr;

	WriteLock ();

	// The first pass is to see any existing connection
	//
	for (ULONG i = 0; i < m_cEntries; i++)
	{
		if (m_aConns[i].IsUsed ())
		{
			if (m_aConns[i].SameServerInfo (pInfo))
			{
				*ppConn = &m_aConns[i];
				hr = m_aConns[i].Connect (pInfo, cConns, fAbortable);
				goto MyExit;
			}
		}
	}

	// The second pass is to see any empty slot
	//
	for (i = 0; i < m_cEntries; i++)
	{
		if (! m_aConns[i].IsUsed ())
		{
			m_aConns[i].SetUsed ();
			*ppConn = &m_aConns[i];
			hr = m_aConns[i].Connect (pInfo, cConns, fAbortable);
			goto MyExit;
		}
	}

	hr = ILS_E_MEMORY;

MyExit:

	WriteUnlock ();
	return hr;
}


/* ---------- protected methods ----------- */

/* ---------- private methods ----------- */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spfilter.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spfilter.cpp
	Content:	This file contains the ldap filters.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

const TCHAR c_szClientRefreshFilter[] =
TEXT ("(&(objectClass=RTPerson)(cn=%s)(sttl=10))");
TCHAR *ClntCreateRefreshFilter ( TCHAR *pszClientName )
{
	TCHAR *pszFilter = (TCHAR *) MemAlloc (
							sizeof (c_szClientRefreshFilter) +
							(lstrlen (pszClientName) + 1) * sizeof (TCHAR));
	if (pszFilter != NULL)
	{
		wsprintf (	pszFilter,
					&c_szClientRefreshFilter[0],
					pszClientName);
	}

	return pszFilter;
}


const TCHAR c_szMtgRefreshFilter[] =
TEXT ("(&(objectClass=Conference)(cn=%s)(sttl=10))");
TCHAR *MtgCreateRefreshFilter ( TCHAR *pszMtgName )
{
	TCHAR *pszFilter = (TCHAR *) MemAlloc (
							sizeof (c_szMtgRefreshFilter) +
							(lstrlen (pszMtgName) + 1) * sizeof (TCHAR));
	if (pszFilter != NULL)
	{
		wsprintf (pszFilter, &c_szMtgRefreshFilter[0], pszMtgName);
	}

	return pszFilter;
}


const TCHAR c_szEnumProtsFilterFormat[] =
TEXT ("(&(objectClass=RTPerson)(cn=%s)(sappid=%s))");
TCHAR *ProtCreateEnumFilter ( TCHAR *pszUserName, TCHAR *pszAppName )
{
	TCHAR *pszFilter = (TCHAR *) MemAlloc (sizeof (c_szEnumProtsFilterFormat) +
										(lstrlen (pszUserName) + 1) * sizeof (TCHAR) +
										(lstrlen (pszAppName) + 1) * sizeof (TCHAR));
	if (pszFilter != NULL)
	{
		wsprintf (pszFilter, &c_szEnumProtsFilterFormat[0], pszUserName, pszAppName);
	}

	return pszFilter;
}



const TCHAR c_szResolveMtgFilterFormat[] =
TEXT ("(&(objectClass=Conference)(cn=%s))");
TCHAR *MtgCreateResolveFilter ( TCHAR *pszMtgName )
{
	TCHAR *pszFilter = (TCHAR *) MemAlloc (sizeof (c_szResolveMtgFilterFormat) +
										(lstrlen (pszMtgName) + 1) * sizeof (TCHAR));
	if (pszFilter != NULL)
	{
		wsprintf (pszFilter, &c_szResolveMtgFilterFormat[0], pszMtgName);
	}

	return pszFilter;
}


const TCHAR c_szResolveClientAppProt[] =
TEXT ("(&(objectClass=RTPerson)(cn=%s)(sappid=%s)(sprotid=%s))");
const TCHAR c_szResolveClientApp[] =
TEXT ("(&(objectClass=RTPerson)(cn=%s)(sappid=%s))");
const TCHAR c_szResolveClientProt[] =
TEXT ("(&(objectClass=RTPerson)(cn=%s)(sprotid=%s))");
const TCHAR c_szResolveClientOnly[] =
TEXT ("(&(objectClass=RTPerson)(cn=%s))");

TCHAR *ClntCreateResolveFilter ( TCHAR *pszClientName, TCHAR *pszAppName, TCHAR *pszProtName )
{
	ULONG cbSize = (lstrlen (pszClientName) + 1) * sizeof (TCHAR);
	LONG nChoice;

	enum { CLIENT_APP_PROT = 0, CLIENT_APP = 1, CLIENT_PROT = 2, CLIENT_ONLY = 3 };

	if (pszAppName != NULL)
	{
		if (pszProtName != NULL)
		{
			nChoice = CLIENT_APP_PROT;
			cbSize += sizeof (c_szResolveClientAppProt) +
						(lstrlen (pszAppName) + lstrlen (pszProtName)) * sizeof (TCHAR);
		}
		else
		{
			nChoice = CLIENT_APP;
			cbSize += sizeof (c_szResolveClientApp) +
						lstrlen (pszAppName) * sizeof (TCHAR);
		}
	}
	else
	{
		if (pszProtName != NULL)
		{
			nChoice = CLIENT_PROT;
			cbSize += sizeof (c_szResolveClientProt) +
						lstrlen (pszProtName) * sizeof (TCHAR);
		}
		else
		{
			nChoice = CLIENT_ONLY;
			cbSize += sizeof (c_szResolveClientOnly);
		}
	}

	TCHAR *pszFilter = (TCHAR *) MemAlloc (cbSize);
	if (pszFilter != NULL)
	{
		switch (nChoice)
		{
		case CLIENT_APP_PROT:
			wsprintf (pszFilter, &c_szResolveClientAppProt[0],
						pszClientName, pszAppName, pszProtName);
			break;
		case CLIENT_APP:
			wsprintf (pszFilter, &c_szResolveClientApp[0],
						pszClientName, pszAppName);
			break;
		case CLIENT_PROT:
			wsprintf (pszFilter, &c_szResolveClientProt[0],
						pszClientName, pszProtName);
			break;
		case CLIENT_ONLY:
			wsprintf (pszFilter, &c_szResolveClientOnly[0],
						pszClientName);
			break;
		default:
			MyAssert (FALSE);
			break;
		}
	}

	return pszFilter;
}


const TCHAR c_szResolveProtFilterFormat[] =
TEXT ("(&(objectClass=RTPerson)(cn=%s)(sappid=%s)(sprotid=%s))");
TCHAR *ProtCreateResolveFilter ( TCHAR *pszUserName, TCHAR *pszAppName, TCHAR *pszProtName )
{
	TCHAR *pszFilter = (TCHAR *) MemAlloc (sizeof (c_szResolveProtFilterFormat) +
										(lstrlen (pszUserName) + 1) * sizeof (TCHAR) +
										(lstrlen (pszAppName) + 1) * sizeof (TCHAR) +
										(lstrlen (pszProtName) + 1) * sizeof (TCHAR));
	if (pszFilter != NULL)
	{
		wsprintf (pszFilter, &c_szResolveProtFilterFormat[0], pszUserName, pszAppName, pszProtName);
	}

	return pszFilter;
}


TCHAR *MtgCreateEnumMembersFilter ( TCHAR *pszMtgName )
{
	return MtgCreateResolveFilter (pszMtgName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spinc.h ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spinc.h
	Content:	This file contains general definition for service provider.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#ifndef _SPINC_H_
#define _SPINC_H_

#include <windows.h>
#include <winsock.h>
#define LDAP_UNICODE	0
#include "winldap.h"
#define ANY_IN_USER  0
#include "spserver.h"
#include "ulsldap.h"
#include "uls.h"

// Timers
//
#define ID_TIMER_POLL_RESULT	1
#define KEEP_ALIVE_TIMER_BASE	100	// 100 -- 4196
#define CONN_PURGE_TIMER_BASE	10	// 10 and above

// Limits
//
#define INTEGER_STRING_LENGTH	16
#define MAX_DN_LENGTH			512

// General invalid IDs
//
#define INVALID_MSG_ID			((ULONG) -1)	// same as ldap_****()
#define INVALID_NOTIFY_ID		((ULONG) -1)

// Global enums
//
typedef enum
{
	ILS_REG_STATUS_NONE,
	ILS_REG_STATUS_LOCALLY,
	ILS_REG_STATUS_REMOTELY
}
	REG_STATUS;

// Extended attributes' cache for names/values lists
//
typedef struct
{
	ULONG	cAttrsToAdd;
	TCHAR	*pszAttrsToAdd;
	ULONG	cAttrsToModify;
	TCHAR	*pszAttrsToModify;
	ULONG	cAttrsToRemove;
	TCHAR	*pszAttrsToRemove;
}
	ANY_ATTRS;

// Service provider header files
//
extern TCHAR *g_pszUserPrefix;
extern TCHAR *g_pszMtgPrefix;
#include "spconn.h"
#include "spclient.h"
#include "splprot.h"
#include "splmtg.h"
#include "sppqueue.h"
#include "sputils.h"
#include "spserver.h"

// ldapsp.cpp
//
extern HINSTANCE g_hInstance;
extern HWND g_hWndHidden;
extern HWND g_hWndNotify;
extern DWORD g_dwReqThreadID;
extern ULONG g_uRespID;
extern DWORD g_dwClientSig;

// spils.cpp
//
extern const TCHAR c_szModOp[];
extern ULONG g_cbUserPrefix;
extern TCHAR *g_pszUserPrefix;
extern ULONG g_cbMtgPrefix;
extern TCHAR *g_pszMtgPrefix;
extern TCHAR c_szModOp_AddApp[];
extern TCHAR c_szModOp_DeleteApp[];
extern TCHAR c_szModOp_ModifyUser[];
extern TCHAR c_szModOp_ModifyApp[];
enum
{
	ISBU_MODOP_ADD_APP,
	ISBU_MODOP_DELETE_APP,
	ISBU_MODOP_MODIFY_USER,
	ISBU_MODOP_MODIFY_APP
};
HRESULT IlsInitialize ( VOID );
HRESULT IlsCleanup ( VOID );
ULONG IlsCalcModifyListSize ( ULONG cAttrs );
LDAPMod *IlsGetModifyListMod ( LDAPMod ***pppMod, ULONG cAttrs, LONG AttrIdx );
VOID IlsFillModifyListItem ( LDAPMod *pMod, TCHAR *pszAttrName, TCHAR *pszAttrValue );
VOID IlsFillModifyListForAnyAttrs ( LDAPMod *apMod[], ULONG *puIndex, ANY_ATTRS *pAnyAttrs );
VOID IlsFixUpModOp ( LDAPMod *pMod, LONG LdapModOp, LONG IsbuModOp );
HRESULT IlsParseRefreshPeriod ( LDAP *ld, LDAPMessage *pLdapMsg, const TCHAR *pszTtlAttrName, ULONG *puTTL );
HRESULT IlsUpdateOneAttr ( SERVER_INFO *pServerInfo, TCHAR *pszDN, TCHAR *pszAttrName, TCHAR *pszAttrValue, LONG nModifyMagic, ULONG cPrefix, TCHAR	*pszPrefix, SP_CSession **ppSession, ULONG *puMsgID );
HRESULT IlsUpdateIPAddress ( SERVER_INFO *pServerInfo, TCHAR *pszDN, TCHAR *pszIPAddrName, TCHAR *pszIPAddrValue, LONG nModifyMagic, ULONG cPrefix, TCHAR *pszPrefix );
HRESULT IlsSendRefreshMsg ( SERVER_INFO *pServerInfo, TCHAR *pszBaseDN, TCHAR *pszTTL, TCHAR *pszRefreshFilter, ULONG *puTTL );
HRESULT IlsFillDefStdAttrsModArr ( LDAPMod ***pppMod, DWORD dwFlags, ULONG cMaxAttrs, ULONG *pcTotal, LONG IsbuModOp, ULONG cPrefix, TCHAR *pszPrefix );
const TCHAR *IlsSkipAnyAttrNamePrefix ( const TCHAR *pszAttrName );
const TCHAR *IlsIsAnyAttrName ( const TCHAR *pszAttrName );
TCHAR *IlsPrefixNameValueArray ( BOOL fPair, ULONG cAttrs, const TCHAR *pszAttrs );
TCHAR *IlsBuildDN ( TCHAR *pszBaseDN, TCHAR *pszC, TCHAR *pszO, TCHAR *pszCN, TCHAR *pszObjectClass );
HRESULT IlsCreateAnyAttrsPrefix ( ANY_ATTRS *pAnyAttrs );
VOID IlsReleaseAnyAttrsPrefix ( ANY_ATTRS *pAnyAttrs );
TCHAR **my_ldap_get_values ( LDAP *ld, LDAPMessage *pEntry, TCHAR *pszRetAttrName );
ULONG my_ldap_count_1st_entry_attributes ( LDAP *ld, LDAPMessage *pLdapMsg );

// spnotify.cpp
//
ULONG GetUniqueNotifyID ( VOID );

// spfilter.cpp
//
TCHAR *ClntCreateRefreshFilter ( TCHAR *pszClientName );
TCHAR *MtgCreateRefreshFilter ( TCHAR *pszMtgName );
// TCHAR *ClntCreateEnumFilter ( VOID );
TCHAR *ProtCreateEnumFilter ( TCHAR *pszUserName, TCHAR *pszAppName );
TCHAR *ClntCreateResolveFilter ( TCHAR *pszClientName, TCHAR *pszAppName, TCHAR *pszProtName );
TCHAR *ProtCreateResolveFilter ( TCHAR *pszUserName, TCHAR *pszAppName, TCHAR *pszProtName );
TCHAR *MtgCreateResolveFilter ( TCHAR *pszMtgName );
TCHAR *MtgCreateEnumMembersFilter ( TCHAR *pszMtgName );

// sputils.cpp
//
enum
{
	THREAD_WAIT_FOR_EXIT,
	THREAD_WAIT_FOR_REQUEST,
	NUM_THREAD_WAIT_FOR,
};
extern BOOL g_fExitNow;
extern HANDLE g_ahThreadWaitFor[NUM_THREAD_WAIT_FOR];
#define g_hevExitReqThread		g_ahThreadWaitFor[THREAD_WAIT_FOR_EXIT]
#define g_hevNewRequest			g_ahThreadWaitFor[THREAD_WAIT_FOR_REQUEST]
#define g_hevReqThreadHasExited	g_ahThreadWaitFor[NUM_THREAD_WAIT_FOR]
DWORD WINAPI ReqThread ( VOID *lParam );
BOOL MyCreateWindow ( VOID );
VOID _MyAssert ( BOOL fAssertion );
HRESULT LdapError2Hresult ( ULONG );
HRESULT GetLocalIPAddress ( DWORD *pdwIPAddress );


#endif // _SPINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\spils.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		spils.cpp
	Content:	This file contains the ILS specifics.
	History:
	12/10/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

#include "winsock.h"
#include "ping.h"

// Constant string for ISBU's special modify-operation attribute
//
const TCHAR c_szModOp[] = { TEXT ('s'), TEXT ('m'), TEXT ('o'), TEXT ('d'),
							TEXT ('o'), TEXT ('p'), TEXT ('\0'),
							TEXT ('0'), TEXT ('\0')}; //TEXT ("smodop\0000");

ULONG g_cbUserPrefix = sizeof (c_szModOp);
TCHAR *g_pszUserPrefix = NULL;
ULONG g_cbMtgPrefix = sizeof (c_szModOp);
TCHAR *g_pszMtgPrefix = NULL;


CPing *g_pPing = NULL;


HRESULT
IlsInitialize ( VOID )
{
	// Allocate the ping object
	//
	g_pPing = new CPing;
	if (g_pPing == NULL)
		return ILS_E_MEMORY;

	// Allocate user prefix
	//
	g_pszUserPrefix = (TCHAR *) MemAlloc (g_cbUserPrefix);
	if (g_pszUserPrefix == NULL)
		return ILS_E_MEMORY;

	// Fill in user prefix string
	//
	TCHAR *psz = g_pszUserPrefix;
	lstrcpy (psz, &c_szModOp[0]);
	psz += lstrlen (psz) + 1;
	lstrcpy (psz, TEXT ("0"));

	// Allocate mtg prefix
	//
	g_pszMtgPrefix = (TCHAR *) MemAlloc (g_cbMtgPrefix);
	if (g_pszMtgPrefix == NULL)
	{
		MemFree (g_pszUserPrefix);
		g_pszUserPrefix = NULL;
		return ILS_E_MEMORY;
	}

	// Fill in mtg prefix string
	//
	psz = g_pszMtgPrefix;
	lstrcpy (psz, &c_szModOp[0]);
	psz += lstrlen (psz) + 1;
	lstrcpy (psz, TEXT ("0"));

	return S_OK;
}


HRESULT
IlsCleanup ( VOID )
{
	// Free the ping object
	//
	if (g_pPing != NULL)
	{
		delete g_pPing;
		g_pPing = NULL;
	}

	// Free user prefix string
	//
	MemFree (g_pszUserPrefix);
	g_pszUserPrefix = NULL;

	// Free mtg prefix string
	//
	MemFree (g_pszMtgPrefix);
	g_pszMtgPrefix = NULL;

	return S_OK;
}


ULONG
IlsCalcModifyListSize ( ULONG cAttrs )
{
	ULONG cbSize;

	// array itself
	cbSize = (cAttrs + 1) * sizeof (LDAPMod *);

	// array elements
	cbSize += cAttrs * sizeof (LDAPMod);

	// single valued attribute requires two pointers
	cbSize += cAttrs * 2 * sizeof (TCHAR *);

	return cbSize;
}


LDAPMod *
IlsGetModifyListMod ( LDAPMod ***pppMod, ULONG cAttrs, LONG AttrIdx )
{
	return (LDAPMod *) (((BYTE *) *pppMod) +
							(cAttrs + 1) * sizeof (LDAPMod *) +
							AttrIdx * (sizeof (LDAPMod) + 2 * sizeof (TCHAR *)));
}


VOID
IlsFillModifyListItem (
	LDAPMod		*pMod,
	TCHAR		*pszAttrName,
	TCHAR		*pszAttrValue )
{
	MyAssert (pMod != NULL);
	MyAssert (pszAttrName != NULL);

	// Set attribute name
	//
	pMod->mod_type = pszAttrName;

	// Set single valued attribute value
	//
	TCHAR **ppsz = (TCHAR **) (pMod + 1);
	pMod->mod_values = ppsz;
	*ppsz++ = (pszAttrValue != NULL) ?	pszAttrValue : STR_EMPTY;

	// Set null string to terminate this array of values
	//
	*ppsz = NULL;
}


VOID
IlsFillModifyListForAnyAttrs (
	LDAPMod			*apMod[],
	ULONG			*puIndex,
	ANY_ATTRS		*pAnyAttrs )
{
	LDAPMod *pMod;
	TCHAR *pszName, *pszValue;
	ULONG i = *puIndex, j;

	// Put in extended attributes to add
	//
	pszName = pAnyAttrs->pszAttrsToAdd;
	for (j = 0; j < pAnyAttrs->cAttrsToAdd; j++)
	{
		pMod = apMod[i++];
		pMod->mod_op = LDAP_MOD_ADD;
		pszValue = pszName + lstrlen (pszName) + 1;
		IlsFillModifyListItem (pMod, pszName, pszValue);
		pszName = pszValue + lstrlen (pszValue) + 1;
	}

	// Put in extended attributes to modify
	//
	pszName = pAnyAttrs->pszAttrsToModify;
	for (j = 0; j < pAnyAttrs->cAttrsToModify; j++)
	{
		pMod = apMod[i++];
		pMod->mod_op = LDAP_MOD_REPLACE;
		pszValue = pszName + lstrlen (pszName) + 1;
		IlsFillModifyListItem (pMod, pszName, pszValue);
		pszName = pszValue + lstrlen (pszValue) + 1;
	}

	// Put in extended attributes to remove
	//
	pszName = pAnyAttrs->pszAttrsToRemove;
	for (j = 0; j < pAnyAttrs->cAttrsToRemove; j++)
	{
		pMod = apMod[i++];
		pMod->mod_op = LDAP_MOD_DELETE;
		IlsFillModifyListItem (pMod, pszName, NULL);
		pszName = pszName + lstrlen (pszName) + 1;
	}

	// Return the running index
	//
	*puIndex = i;
}


TCHAR c_szModOp_AddApp[] = TEXT ("0");
TCHAR c_szModOp_DeleteApp[] = TEXT ("1");
TCHAR c_szModOp_ModifyUser[] = TEXT ("2");
TCHAR c_szModOp_ModifyApp[] = TEXT ("3");


VOID
IlsFixUpModOp ( LDAPMod *pMod, LONG LdapModOp, LONG IsbuModOp )
{
	MyAssert (pMod != NULL);

	pMod->mod_op = LdapModOp;
	// pMod->mod_op = LDAP_MOD_ADD; // lonchanc: MUST MUST MUST
	pMod->mod_type = (TCHAR *) &c_szModOp[0];
	pMod->mod_values = (TCHAR **) (pMod + 1);

	switch (IsbuModOp)
	{
	case ISBU_MODOP_ADD_APP:
		*(pMod->mod_values) = &c_szModOp_AddApp[0];
		break;
	case ISBU_MODOP_DELETE_APP:
		*(pMod->mod_values) = &c_szModOp_DeleteApp[0];
		break;
	case ISBU_MODOP_MODIFY_USER:
		*(pMod->mod_values) = &c_szModOp_ModifyUser[0];
		break;
	case ISBU_MODOP_MODIFY_APP:
		*(pMod->mod_values) = &c_szModOp_ModifyApp[0];
		break;
	default:
		MyAssert (FALSE);
		break;
	}
}



HRESULT
IlsParseRefreshPeriod (
	LDAP		*ld,
	LDAPMessage	*pLdapMsg,
	const TCHAR	*pszTtlAttrName,
	ULONG		*puTTL )
{
	MyAssert (ld != NULL);
	MyAssert (pLdapMsg != NULL);
	MyAssert (pszTtlAttrName != NULL);
	MyAssert (puTTL != NULL);

	HRESULT hr;
	ULONG uRefreshPeriod;	
	ULONG tcRefreshPeriod;	

	// Get the first entry
	//
	LDAPMessage *pEntry = ldap_first_entry (ld, pLdapMsg);
	if (pEntry == NULL)
	{
		MyAssert (FALSE);
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Get the sTTL attribute
	//
	TCHAR **ppszAttrVal;
	ppszAttrVal = my_ldap_get_values (ld, pEntry, (TCHAR *) pszTtlAttrName);
	if (ppszAttrVal == NULL || *ppszAttrVal == NULL)
	{
		MyAssert (FALSE);
		hr = ILS_E_MEMORY;
		goto MyExit;
	}

	// Convert string to long
	//
	uRefreshPeriod = ::GetStringLong (*ppszAttrVal);

	// Reserve two-minute overhead
	//
	if (uRefreshPeriod > ILS_DEF_REFRESH_MARGIN_MINUTE)
		uRefreshPeriod -= ILS_DEF_REFRESH_MARGIN_MINUTE;

	// Make sure we have a safe, reasonable refresh period at least
	//
	if (uRefreshPeriod < ILS_DEF_REFRESH_MARGIN_MINUTE)
		uRefreshPeriod = ILS_DEF_REFRESH_MARGIN_MINUTE;

	// Convert min to ms
	//
	tcRefreshPeriod = Minute2TickCount (uRefreshPeriod);

	// Free the attribute value
	//
	ldap_value_free (ppszAttrVal);

	// Update ttl
	//
	*puTTL = uRefreshPeriod; // in unit of minute

	hr = S_OK;

MyExit:

	if (hr != S_OK)
	{
		MyAssert (FALSE);
	}

	return hr;
}


HRESULT
IlsUpdateOneAttr (
	SERVER_INFO	*pServerInfo,
	TCHAR		*pszDN,
	TCHAR 		*pszAttrName,
	TCHAR		*pszAttrValue,
	LONG		nModifyMagic,
	ULONG		cPrefix,
	TCHAR		*pszPrefix,
	SP_CSession **ppSession,	// output
	ULONG		*puMsgID )			// output
{
	MyAssert (pServerInfo != NULL);
	MyAssert (pszDN != NULL);
	MyAssert (pszAttrName != NULL);
	MyAssert (pszAttrValue != NULL);
	MyAssert (	nModifyMagic == ISBU_MODOP_MODIFY_USER ||
				nModifyMagic == ISBU_MODOP_MODIFY_APP);
	MyAssert (ppSession != NULL);
	MyAssert (puMsgID != NULL);

	// Build modify array for ldap_modify()
	//
	LDAP *ld;
	LDAPMod **ppMod = NULL;
	ULONG cTotal = 0;
	HRESULT hr = IlsFillDefStdAttrsModArr (&ppMod,
										1, // one attribute (i.e. IP addr)
										1, // max? there is only one attr, come on
										&cTotal,
										nModifyMagic,
										cPrefix,
										pszPrefix);
	if (hr != S_OK)
		goto MyExit;

	// Fill in modify list
	//
	MyAssert (ppMod != NULL);
	LDAPMod *pMod;
	pMod = ppMod[cPrefix];
	MyAssert (pMod != NULL);
	pMod->mod_type = pszAttrName;

	// Put in ip address
	//
	pMod->mod_values = (TCHAR **) (pMod + 1);
	*(pMod->mod_values) = pszAttrValue;

	// Get the session object
	//
	hr = g_pSessionContainer->GetSession (ppSession, pServerInfo, FALSE);
	if (hr != S_OK)
		goto MyExit;
	MyAssert (*ppSession != NULL);

	// Get the ldap session
	//
	ld = (*ppSession)->GetLd ();
	MyAssert (ld != NULL);

	// Send the data over the wire
	//
	*puMsgID = ldap_modify (ld, pszDN, ppMod);
	if (*puMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		(*ppSession)->Disconnect ();
		goto MyExit;
	}

	// Success
	//
	hr = S_OK;
		
MyExit:

	MemFree (ppMod);
	return hr;
}


HRESULT
IlsUpdateIPAddress (
	SERVER_INFO	*pServerInfo,
	TCHAR		*pszDN,
	TCHAR 		*pszIPAddrName,
	TCHAR		*pszIPAddrValue,
	LONG		nModifyMagic,
	ULONG		cPrefix,
	TCHAR		*pszPrefix )
{
	SP_CSession *pSession = NULL;
	LDAP *ld;
	ULONG uMsgID;

	// Update the ip address attribute on the server
	//
	HRESULT hr = IlsUpdateOneAttr (	pServerInfo,
									pszDN,
									pszIPAddrName,
									pszIPAddrValue,
									nModifyMagic,
									cPrefix,
									pszPrefix,
									&pSession,
									&uMsgID);
	if (hr != S_OK)
		return hr;

	// Get the ldap session
	//
	MyAssert (pSession != NULL);
	ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// Let's wait for the result
	//
	LDAP_TIMEVAL TimeVal;
	TimeVal.tv_usec = 0;
	TimeVal.tv_sec = pSession->GetServerTimeoutInSecond ();

	// We don't care the result.
	// Should it fails, nothing we can do.
	// We can try it again in next keep alive time.
	//
	LDAPMessage *pLdapMsg;
	pLdapMsg = NULL;
	ldap_result (ld, uMsgID, LDAP_MSG_ALL, &TimeVal, &pLdapMsg);

	// Free message
	//
	if (pLdapMsg != NULL)
		ldap_msgfree (pLdapMsg);

	
	// Free up the session
	//
	if (pSession != NULL)
		pSession->Disconnect ();

	return S_OK;
}



HRESULT
IlsSendRefreshMsg (
	SERVER_INFO		*pServerInfo,
	TCHAR			*pszBaseDN,
	TCHAR			*pszTTL,
	TCHAR			*pszRefreshFilter,
	ULONG			*puTTL )
{
	MyAssert (pServerInfo != NULL);
	MyAssert (MyIsGoodString (pszBaseDN));
	MyAssert (MyIsGoodString (pszTTL));
	MyAssert (MyIsGoodString (pszRefreshFilter));
	MyAssert (puTTL != NULL);

	// Let's check to see if we need to use Ping...
	//
	if (g_pPing != NULL && g_pPing->IsAutodialEnabled ())
	{
		LPTSTR pszServerName = My_strdup(pServerInfo->pszServerName);
		if (NULL == pszServerName)
		{
			return E_OUTOFMEMORY;
		}
		LPTSTR pszSeparator = My_strchr(pszServerName, _T(':'));
		if (NULL != pszSeparator)
		{
			*pszSeparator = _T('\0');
		}
	
		DWORD dwIPAddr = inet_addr (pszServerName);
		MemFree(pszServerName);
		if (dwIPAddr != INADDR_NONE)
		{
			if (g_pPing->Ping (dwIPAddr, 10 * 1000, 9) == S_FALSE)
			{
				MyDebugMsg ((ZONE_KA, "KA: ping failed, network down\r\n"));

				// The "ping" operation failed, but other operations failed
				//
				return ILS_E_NETWORK_DOWN;
			}
		}
	}

	// Get the connection object
	//
	SP_CSession *pSession = NULL;
	HRESULT hr = g_pSessionContainer->GetSession (&pSession, pServerInfo, FALSE);
	if (hr != S_OK)
	{
		MyDebugMsg ((ZONE_KA, "KA: network down, hr=0x%lX\r\n", hr));

		// Report error
		//
		return ILS_E_NETWORK_DOWN;
	}
	MyAssert (pSession != NULL);

	// Get the ldap session
	//
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// Set attributes to return
	//
	TCHAR *apszAttrNames[2];
	apszAttrNames[0] = pszTTL;
	apszAttrNames[1] = NULL;

	// Update options in ld
	//
	ld->ld_sizelimit = 0;	// no limit in the num of entries to return
	ld->ld_timelimit = 0;	// no limit on the time to spend on the search
	ld->ld_deref = LDAP_DEREF_ALWAYS;

	// Send search query
	//
	MyDebugMsg ((ZONE_KA, "KA: calling ldap_search()...\r\n"));
	ULONG uMsgID = ::ldap_search (	ld,
									pszBaseDN, // base DN
									LDAP_SCOPE_BASE, // scope
									pszRefreshFilter, // filter
									&apszAttrNames[0], // attrs[]
									0);	// both type and value
	if (uMsgID == -1)
	{
		MyDebugMsg ((ZONE_KA, "KA: ldap_search() failed\r\n"));
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// Let's wait for the result
	//
	LDAP_TIMEVAL TimeVal;
	TimeVal.tv_usec = 0;
	TimeVal.tv_sec = pSession->GetServerTimeoutInSecond ();

	// Wait and get the result back
	//
	LDAPMessage *pLdapMsg = NULL;
	INT ResultType = ::ldap_result (ld, uMsgID, LDAP_MSG_ALL, &TimeVal, &pLdapMsg);
	if (ResultType == LDAP_RES_SEARCH_ENTRY ||
		ResultType == LDAP_RES_SEARCH_RESULT)
	{
		if (pLdapMsg != NULL)
		{
			switch (pLdapMsg->lm_returncode)
			{
			case LDAP_NO_SUCH_OBJECT:
				MyDebugMsg ((ZONE_KA, "KA: no such object!\r\n"));

				// Report error
				//
				hr = ILS_E_NEED_RELOGON;
				break;

			case LDAP_SUCCESS:
				// Get the new refresh period
				//
				hr = ::IlsParseRefreshPeriod (ld, pLdapMsg, pszTTL, puTTL);
				break;

			default:
				MyDebugMsg ((ZONE_KA, "KA: unknown lm_returncode=%ld\r\n", pLdapMsg->lm_returncode));
				MyAssert (FALSE);
				hr = ::LdapError2Hresult (ld->ld_errno);
				break;
			}
	
			// Free this message
			//
			ldap_msgfree (pLdapMsg);
		} // if (pLdapMsg != NULL)
		else
		{
			hr = ILS_E_FAIL;
		}
	} // not timeout
	else
	{
		// Timeout
		//
		hr = ILS_E_TIMEOUT;
	}

	// Free up the session
	//
	pSession->Disconnect ();
	return hr;
}


HRESULT
IlsFillDefStdAttrsModArr (
	LDAPMod			***pppMod,
	DWORD			dwFlags,
	ULONG			cMaxAttrs,
	ULONG			*pcTotal,	// in/out parameter!!!
	LONG			IsbuModOp,
	ULONG			cPrefix,
	TCHAR			*pszPrefix )
{

	MyAssert (pppMod != NULL);
	MyAssert (pcTotal != NULL);
	MyAssert (	(cPrefix == 0 && pszPrefix == NULL) ||
				(cPrefix != 0 && pszPrefix != NULL));

	// Figure out the num of attributes
	//
	ULONG cAttrs = 0;
	for (ULONG i = 0; i < cMaxAttrs; i++)
	{
		if (dwFlags & 0x01)
			cAttrs++;
		dwFlags >>= 1;
	}

	// Allocate modify list
	//
	ULONG cTotal = *pcTotal + cPrefix + cAttrs;
	ULONG cbMod = IlsCalcModifyListSize (cTotal);
	*pppMod = (LDAPMod **) MemAlloc (cbMod);
	if (*pppMod == NULL)
		return ILS_E_MEMORY;

	// Fill in the modify list
	//
	LDAPMod *pMod;
	for (i = 0; i < cTotal; i++)
	{
		pMod = IlsGetModifyListMod (pppMod, cTotal, i);
		(*pppMod)[i] = pMod;
		pMod->mod_values = (TCHAR **) (pMod + 1);

		if (i < cPrefix)
		{
			pMod->mod_op = LDAP_MOD_REPLACE;
			pMod->mod_type = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
			*(pMod->mod_values) = pszPrefix;
			pszPrefix += lstrlen (pszPrefix) + 1;
		}
	}

	// Fix up the first and the last ones
	//
	IlsFixUpModOp ((*pppMod)[0], LDAP_MOD_REPLACE, IsbuModOp);
	(*pppMod)[cTotal] = NULL;

	// Return the total number of entries
	//
	*pcTotal = cTotal;

	return S_OK;
}


const TCHAR c_szAnyAttrPrefix[] = TEXT ("ILSA");
#define SIZE_ANY_ATTR_PREFIX	(sizeof (c_szAnyAttrPrefix) / sizeof (TCHAR))


const TCHAR *
UlsLdap_GetExtAttrNamePrefix ( VOID )
{
	return &c_szAnyAttrPrefix[0];
}


const TCHAR *
IlsSkipAnyAttrNamePrefix ( const TCHAR *pszAttrName )
{
	MyAssert (pszAttrName != NULL);

	const TCHAR *psz = IlsIsAnyAttrName (pszAttrName);
	if (psz == NULL)
	{
		MyAssert (FALSE);
		psz = pszAttrName;
	}

	return psz;
}


const TCHAR *
IlsIsAnyAttrName ( const TCHAR *pszAttrName )
{
	BOOL fRet = FALSE;
	TCHAR *psz = (TCHAR *) pszAttrName;

	if (pszAttrName != NULL)
	{
		if (lstrlen (pszAttrName) > SIZE_ANY_ATTR_PREFIX)
		{
			TCHAR c = pszAttrName[SIZE_ANY_ATTR_PREFIX-1];
			psz[SIZE_ANY_ATTR_PREFIX-1] = TEXT ('\0');
			fRet = (My_lstrcmpi (pszAttrName, &c_szAnyAttrPrefix[0]) == 0);
			psz[SIZE_ANY_ATTR_PREFIX-1] = c;
		}
	}

	return (fRet ? &pszAttrName[SIZE_ANY_ATTR_PREFIX-1] : NULL);
}


TCHAR *
IlsPrefixNameValueArray (
	BOOL			fPair,
	ULONG			cAttrs,
	const TCHAR		*pszAttrs )
{
	if (cAttrs == 0 || pszAttrs == NULL)
	{
		MyAssert (FALSE);
		return NULL;
	}

	// compute the total size required
	ULONG cbTotalSize = 0;
	ULONG cbThisSize;
	TCHAR *pszSrc = (TCHAR *) pszAttrs;
	for (ULONG i = 0; i < cAttrs; i++)
	{
		// get name size
		cbThisSize = lstrlen (pszSrc) + 1;
		pszSrc += lstrlen (pszSrc) + 1;

		// get value size as needed
		if (fPair)
		{
			cbThisSize += lstrlen (pszSrc) + 1;
			pszSrc += lstrlen (pszSrc) + 1;
		}

		// adjust the size
		cbThisSize += SIZE_ANY_ATTR_PREFIX;
		cbThisSize *= sizeof (TCHAR);

		// accumulate it
		cbTotalSize += cbThisSize;
	}

	// allocate the new buffer
	TCHAR *pszPrefixAttrs = (TCHAR *) MemAlloc (cbTotalSize);
	if (pszPrefixAttrs == NULL)
		return NULL;

	// copy the strings over to the new buffer
	pszSrc = (TCHAR *) pszAttrs;
	TCHAR *pszDst = pszPrefixAttrs;
	for (i = 0; i < cAttrs; i++)
	{
		// copy prefix
		lstrcpy (pszDst, &c_szAnyAttrPrefix[0]);
		pszDst += lstrlen (pszDst); // no plus 1

		// copy name
		lstrcpy (pszDst, pszSrc);
		pszDst += lstrlen (pszDst) + 1;
		pszSrc += lstrlen (pszSrc) + 1;

		// copy value as needed
		if (fPair)
		{
			lstrcpy (pszDst, pszSrc);
			pszDst += lstrlen (pszDst) + 1;
			pszSrc += lstrlen (pszSrc) + 1;
		}
	}

	return pszPrefixAttrs;
}


TCHAR *
IlsBuildDN (
	TCHAR			*pszBaseDN,
	TCHAR			*pszC,
	TCHAR			*pszO,
	TCHAR			*pszCN,
	TCHAR			*pszObjectClass )
{
	MyAssert (MyIsGoodString (pszCN));
	MyAssert (MyIsGoodString (pszObjectClass));

	static TCHAR s_szC[] = TEXT ("c=");
	static TCHAR s_szO[] = TEXT ("o=");
	static TCHAR s_szCN[] = TEXT ("cn=");
	static TCHAR s_szObjectClass[] = TEXT ("objectClass=");
	static TCHAR s_szDelimiter[] = TEXT (", ");
	enum { C_LENGTH = 2 };
	enum { O_LENGTH = 2 };
	enum { CN_LENGTH = 3 };
	enum { OBJECTCLASS_LENGTH = 12 };
	enum { DELIMITER_LENGTH = 2 };

	ULONG	cchDN = 1;
	BOOL fInBaseDN;

	ASSERT(MyIsGoodString(pszC));

	cchDN += lstrlen (pszC) + DELIMITER_LENGTH + C_LENGTH;

	if (MyIsGoodString (pszBaseDN))
	{
		fInBaseDN = TRUE;

		cchDN += lstrlen (pszBaseDN) + DELIMITER_LENGTH;
	}
	else
	{
		fInBaseDN = FALSE;

		if (MyIsGoodString (pszO))
			cchDN += lstrlen (pszO) + DELIMITER_LENGTH + O_LENGTH;
	}

	if (MyIsGoodString (pszCN))
		cchDN += lstrlen (pszCN) + CN_LENGTH;

	if (MyIsGoodString (pszObjectClass))
		cchDN += lstrlen (pszObjectClass) + DELIMITER_LENGTH + OBJECTCLASS_LENGTH;

	TCHAR *pszDN = (TCHAR *) MemAlloc (cchDN * sizeof (TCHAR));
	if (pszDN != NULL)
	{
		TCHAR *psz = pszDN;
		psz[0] = TEXT ('\0');

		if (MyIsGoodString (pszC))
		{
			lstrcpy (psz, &s_szC[0]);
			psz += lstrlen (psz);
			lstrcpy (psz, pszC);
			psz += lstrlen (psz);
		}

		if (fInBaseDN)
		{
			if (psz != pszDN)
			{
				lstrcpy (psz, &s_szDelimiter[0]);
				psz += lstrlen (psz);
			}

			lstrcpy (psz, pszBaseDN);
			psz += lstrlen (psz);
		}
		else
		{
			if (MyIsGoodString (pszO))
			{
				if (psz != pszDN)
				{
					lstrcpy (psz, &s_szDelimiter[0]);
					psz += lstrlen (psz);
				}

				lstrcpy (psz, &s_szO[0]);
				psz += lstrlen (psz);
				lstrcpy (psz, pszO);
				psz += lstrlen (psz);
			}
		}

		if (MyIsGoodString (pszCN))
		{
			if (psz != pszDN)
			{
				lstrcpy (psz, &s_szDelimiter[0]);
				psz += lstrlen (psz);
			}

			lstrcpy (psz, &s_szCN[0]);
			psz += lstrlen (psz);
			lstrcpy (psz, pszCN);
			psz += lstrlen (psz);
		}

		if (MyIsGoodString (pszObjectClass))
		{
			if (psz != pszDN)
			{
				lstrcpy (psz, &s_szDelimiter[0]);
				psz += lstrlen (psz);
			}

			lstrcpy (psz, &s_szObjectClass[0]);
			psz += lstrlen (psz);
			lstrcpy (psz, pszObjectClass);
			psz += lstrlen (psz);
		}

		MyAssert (psz == pszDN + cchDN - 1);
	}

	return pszDN;
}



HRESULT
IlsCreateAnyAttrsPrefix ( ANY_ATTRS *pAnyAttrs )
{
	if (pAnyAttrs->cAttrsToAdd != 0)
	{
		MyAssert (pAnyAttrs->pszAttrsToAdd != NULL);
		pAnyAttrs->pszAttrsToAdd = IlsPrefixNameValueArray (
						TRUE,
						pAnyAttrs->cAttrsToAdd,
						(const TCHAR *) pAnyAttrs->pszAttrsToAdd);
		if (pAnyAttrs->pszAttrsToAdd == NULL)
			return ILS_E_MEMORY;
	}

	if (pAnyAttrs->cAttrsToModify != 0)
	{
		MyAssert (pAnyAttrs->pszAttrsToModify != NULL);
		pAnyAttrs->pszAttrsToModify = IlsPrefixNameValueArray (
						TRUE,
						pAnyAttrs->cAttrsToModify,
						(const TCHAR *) pAnyAttrs->pszAttrsToModify);
		if (pAnyAttrs->pszAttrsToModify == NULL)
		{
			MemFree (pAnyAttrs->pszAttrsToAdd);
			pAnyAttrs->pszAttrsToAdd = NULL;
			return ILS_E_MEMORY;
		}
	}

	if (pAnyAttrs->cAttrsToRemove != 0)
	{
		MyAssert (pAnyAttrs->pszAttrsToRemove != NULL);
		pAnyAttrs->pszAttrsToRemove = IlsPrefixNameValueArray (
						FALSE,
						pAnyAttrs->cAttrsToRemove,
						(const TCHAR *) pAnyAttrs->pszAttrsToRemove);
		if (pAnyAttrs->pszAttrsToRemove == NULL)
		{
			MemFree (pAnyAttrs->pszAttrsToAdd);
			MemFree (pAnyAttrs->pszAttrsToModify);
			pAnyAttrs->pszAttrsToAdd = NULL;
			pAnyAttrs->pszAttrsToModify = NULL;
			return ILS_E_MEMORY;
		}
	}

	return S_OK;
}


VOID
IlsReleaseAnyAttrsPrefix ( ANY_ATTRS *pAnyAttrs )
{
	MemFree (pAnyAttrs->pszAttrsToAdd);
	MemFree (pAnyAttrs->pszAttrsToModify);
	MemFree (pAnyAttrs->pszAttrsToRemove);
	ZeroMemory (pAnyAttrs, sizeof (*pAnyAttrs));
}




TCHAR **my_ldap_get_values ( LDAP *ld, LDAPMessage *pEntry, TCHAR *pszRetAttrName )
{
	MyAssert (ld != NULL);
	MyAssert (pEntry != NULL);
	MyAssert (pszRetAttrName != NULL);

	// Examine the first attribute
	//
	struct berelement *pContext = NULL;
	TCHAR *pszAttrName = ldap_first_attribute (ld, pEntry, &pContext);
	if (My_lstrcmpi (pszAttrName, pszRetAttrName) != 0)
	{
		// Examine the other attributes
		//
		while ((pszAttrName = ldap_next_attribute (ld, pEntry, pContext))
				!= NULL)
		{
			if (My_lstrcmpi (pszAttrName, pszRetAttrName) == 0)
				break;
		}
	}

	// Get the attribute value if needed
	//
	TCHAR **ppszAttrValue = NULL;
	if (pszAttrName != NULL)
		ppszAttrValue = ldap_get_values (ld, pEntry, pszAttrName);

	return ppszAttrValue;
}


ULONG my_ldap_count_1st_entry_attributes ( LDAP *ld, LDAPMessage *pLdapMsg )
{
	MyAssert (ld != NULL);
	MyAssert (pLdapMsg != NULL);

	ULONG cAttrs = 0;

	// there should be only an entry
	ULONG cEntries = ldap_count_entries (ld, pLdapMsg);
	if (cEntries > 0)
	{
		// there should be only one entry
		MyAssert (cEntries == 1);

		TCHAR *pszAttrName;

		// get this entry
		LDAPMessage *pEntry = ldap_first_entry (ld, pLdapMsg);
		if (pEntry == NULL)
		{
			MyAssert (FALSE);
			return cAttrs;
		}

		// examine the first attribute
		struct berelement *pContext = NULL;
		pszAttrName = ldap_first_attribute (ld, pEntry, &pContext);
		if (pszAttrName == NULL)
		{
			MyAssert (FALSE);
			return 0;
		}
		cAttrs = 1;

TCHAR **ppszAttrVal;
ppszAttrVal = ldap_get_values (ld, pEntry, pszAttrName);
if (ppszAttrVal != NULL)
	ldap_value_free (ppszAttrVal);

		// step through the others
		while ((pszAttrName = ldap_next_attribute (ld, pEntry, pContext)) != NULL)
		{
			cAttrs++;

ppszAttrVal = ldap_get_values (ld, pEntry, pszAttrName);
if (ppszAttrVal != NULL)
	ldap_value_free (ppszAttrVal);
		}
	} // if cEntries > 0

	return cAttrs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ulsldap\splapp.cpp ===
/* ----------------------------------------------------------------------

	Module:		ULS.DLL (Service Provider)
	File:		splapp.cpp
	Content:	This file contains the local application object.
	History:
	10/15/96	Chu, Lon-Chan [lonchanc]
				Created.

	Copyright (c) Microsoft Corporation 1996-1997

   ---------------------------------------------------------------------- */

#include "ulsp.h"
#include "spinc.h"

const TCHAR *c_apszAppStdAttrNames[COUNT_ENUM_APPATTR] =
{
	TEXT ("sappid"),
	TEXT ("smimetype"),
	TEXT ("sappguid"),		// app guid

	// protocol attributes
	TEXT ("sprotid"),
	TEXT ("sprotmimetype"),
	TEXT ("sport"),
};


/* ---------- public methods ----------- */


UlsLdap_CLocalApp::UlsLdap_CLocalApp ( UlsLdap_CLocalUser *pUser )
{
	MyAssert (pUser != NULL);

	m_cRefs = 0;
	m_uSignature = APPOBJ_SIGNATURE;
	m_pUser = pUser;

	m_cPrefix = 0;
	m_pszPrefix = NULL;
	ZeroMemory (&m_AppInfo, sizeof (m_AppInfo));
	SetRegNone ();
}


UlsLdap_CLocalApp::~UlsLdap_CLocalApp ( VOID )
{
	m_uSignature = (ULONG) -1;
	MemFree (m_pszPrefix);
}


ULONG UlsLdap_CLocalApp::AddRef ( VOID )
{
	InterlockedIncrement (&m_cRefs);
	return m_cRefs;
}


ULONG UlsLdap_CLocalApp::Release ( VOID )
{
	MyAssert (m_cRefs != 0);

	if (m_cRefs != 0)
	{
		InterlockedDecrement (&m_cRefs);
	}

	ULONG cRefs = m_cRefs;
	if (cRefs == 0)
		delete this;

	return cRefs;
}


HRESULT UlsLdap_CLocalApp::Register ( ULONG *puRespID, LDAP_APPINFO *pInfo )
{
	MyAssert (puRespID != NULL);
	MyAssert (pInfo != NULL);

	TCHAR *pszDN = GetDN ();
	if (pszDN == NULL)
	{
		MyAssert (FALSE);
		return ULS_E_HANDLE;
	}

	// get app name
	TCHAR *pszAppName = (TCHAR *) ((BYTE *) pInfo + pInfo->uOffsetName);
	if  (*pszAppName == TEXT ('\0'))
	{
		MyAssert (FALSE);
		return ULS_E_PARAMETER;
	}

	// cache app info
	HRESULT hr = CacheAppInfo (pInfo);
	if (hr != S_OK)
		return hr;

	// cache generic protocol info (per KevinMa's suggestion)
	m_AppInfo.apszStdAttrValues[ENUM_APPATTR_PROT_NAME] = TEXT ("h323");
	m_AppInfo.apszStdAttrValues[ENUM_APPATTR_PROT_MIME] = TEXT ("text/h323");
	m_AppInfo.apszStdAttrValues[ENUM_APPATTR_PROT_PORT] = TEXT ("1720");

	// create prefix info
	ULONG cbPrefix = sizeof (TCHAR) * (lstrlen (STR_APP_NAME) +
								lstrlen (pszAppName) + 2);

	ULONG cUserPrefix = GetUserPrefixCount ();
	TCHAR *pszUserPrefix = GetUserPrefixString ();
	for (ULONG i = 0; i < cUserPrefix; i++)
	{
		ULONG uLength = lstrlen (pszUserPrefix) + 1;
		cbPrefix += uLength * sizeof (TCHAR);
		pszUserPrefix += uLength;
		uLength = lstrlen (pszUserPrefix) + 1;
		cbPrefix += uLength * sizeof (TCHAR);
		pszUserPrefix += uLength;
	}

	TCHAR *psz = (TCHAR *) MemAlloc (cbPrefix);
	if (psz == NULL)
		return ULS_E_MEMORY;

	MemFree (m_pszPrefix);
	m_pszPrefix = psz;
	m_cPrefix = cUserPrefix + 1;

	// fill in prefix info
	pszUserPrefix = GetUserPrefixString ();
	for (i = 0; i < cUserPrefix; i++)
	{
		ULONG uLength = lstrlen (pszUserPrefix) + 1;
		lstrcpy (psz, pszUserPrefix);
		psz += uLength;
		pszUserPrefix += uLength;
		uLength = lstrlen (pszUserPrefix) + 1;
		lstrcpy (psz, pszUserPrefix);
		psz += uLength;
		pszUserPrefix += uLength;
	}
	lstrcpy (psz, STR_APP_NAME);
	psz += lstrlen (psz) + 1;
	lstrcpy (psz, pszAppName);

	// build modify array for ldap_modify()
	LDAPMod **ppMod = NULL;
	hr = CreateRegisterModArr (&ppMod);
	if (hr != S_OK)
		return hr;
	MyAssert (ppMod != NULL);

	// so far, we are done with local preparation

	// get the connection object
	UlsLdap_CSession *pSession = NULL;
	MyAssert (m_pUser != NULL);
	hr = g_pSessionContainer->GetSession (&pSession, GetServerInfo ());
	if (hr != S_OK)
	{
		MemFree (ppMod);
		return hr;
	}
	MyAssert (pSession != NULL);

	// get the ldap session
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	// send the data over the wire
	ULONG uMsgID = ldap_modify (ld, pszDN, ppMod);
	MemFree (ppMod);
	if (uMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// if there is any arbitrary attributes,
	// then do not create pending info and we will use
	// SetAttrs's pending info
	ULONG u2ndMsgID = INVALID_MSG_ID;
	if (pInfo->cAttributes != 0)
	{
		hr = UlsLdap_CAnyAttrs::SetAnyAttrs (	NULL, // notify id (ignored)
										&u2ndMsgID, // out msg id
										0,	// notify msg (ignored)
										pInfo->cAttributes,
										(TCHAR *) ((BYTE *) pInfo + pInfo->uOffsetAttributes),
										m_cPrefix,
										m_pszPrefix,
										LDAP_MOD_ADD,
										GetServerInfo (),
										pszDN);
		if (hr != S_OK)
		{
			ldap_abandon (ld, uMsgID);
			pSession->Disconnect ();
			return hr;
		}
	}

	PENDING_INFO PendingInfo;
	::FillDefPendingInfo (&PendingInfo, ld, uMsgID, u2ndMsgID);
	PendingInfo.uLdapResType = LDAP_RES_MODIFY;
	PendingInfo.uNotifyMsg = WM_ULS_REGISTER_APP;
	PendingInfo.hObject = (HANDLE) this;

	hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
	if (hr != S_OK)
	{
		ldap_abandon (ld, uMsgID);
		if (u2ndMsgID != INVALID_MSG_ID)
			ldap_abandon (ld, u2ndMsgID);
		pSession->Disconnect ();
		return hr;
	}

	*puRespID = PendingInfo.uRespID;
	return S_OK;
}


HRESULT UlsLdap_CLocalApp::UnRegister ( ULONG *puRespID )
{
	MyAssert (puRespID != NULL);

	if (! IsRegRemotely ())
	{
		*puRespID = ::GetUniqueNotifyID ();
		SetRegNone ();
		PostMessage (g_hWndNotify, WM_ULS_UNREGISTER_APP, *puRespID, S_OK);
		return S_OK;
	}

	SetRegNone ();

	TCHAR *pszDN = GetDN ();
	if (pszDN == NULL)
	{
		MyAssert (FALSE);
		return ULS_E_HANDLE;
	}

	// build modify array for ldap_modify()
	LDAPMod **ppMod = NULL;
	HRESULT hr = CreateUnRegisterModArr (&ppMod);
	if (hr != S_OK)
		return hr;
	MyAssert (ppMod != NULL);

	// get the connection object
	UlsLdap_CSession *pSession = NULL;
	MyAssert (m_pUser != NULL);
	hr = g_pSessionContainer->GetSession (&pSession, GetServerInfo ());
	if (hr != S_OK)
		return hr;
	MyAssert (pSession != NULL);

	// get the ldap session
	LDAP *ld = pSession->GetLd ();
	MyAssert (ld != NULL);

	ULONG u2ndMsgID = INVALID_MSG_ID;
	if (UlsLdap_CAnyAttrs::GetAnyAttrsCount () != 0)
	{
		hr = UlsLdap_CAnyAttrs::RemoveAllAnyAttrs (	&u2ndMsgID,
											m_cPrefix,
											m_pszPrefix,
											GetServerInfo (),
											pszDN);
		if (hr != S_OK)
		{
			pSession->Disconnect ();
			return hr;
		}
	}

	// send the data over the wire
	ULONG uMsgID = ldap_modify (ld, pszDN, ppMod);
	MemFree (ppMod);
	if (uMsgID == -1)
	{
		hr = ::LdapError2Hresult (ld->ld_errno);
		pSession->Disconnect ();
		return hr;
	}

	// construct a pending info
	PENDING_INFO PendingInfo;
	::FillDefPendingInfo (&PendingInfo, ld, uMsgID, u2ndMsgID);
	PendingInfo.uLdapResType = LDAP_RES_MODIFY;
	PendingInfo.uNotifyMsg = WM_ULS_UNREGISTER_APP;

	// queue it
	hr = g_pPendingQueue->EnterRequest (pSession, &PendingInfo);
	if (hr != S_OK)
	{
		ldap_abandon (ld, uMsgID);
		pSession->Disconnect ();
		MyAssert (FALSE);
	}

	*puRespID = PendingInfo.uRespID;
	return hr;
}


HRESULT UlsLdap_CLocalApp::SetStdAttrs (
	ULONG			*puRespID,
	LDAP_APPINFO	*pInfo )
{
	MyAssert (puRespID != NULL);
	MyAssert (pInfo != NULL);

	TCHAR *pszDN = GetDN ();
	if (pszDN == NULL)
	{
		MyAssert (FALSE);
		return ULS_E_HANDLE;
	}

	return UlsLdap_CStdAttrs::SetStdAttrs (	puRespID,
									NULL,
									WM_ULS_SET_APP_INFO,
									(VOID *) pInfo,
									GetServerInfo (),
									pszDN);
}


HRESULT UlsLdap_CLocalApp::SetAnyAttrs (
	ULONG	*puRespID,
	ULONG	cAttrs,
	TCHAR	*pszAttrs )
{
	MyAssert (puRespID != NULL);
	MyAssert (cAttrs != 0);
	MyAssert (pszAttrs != NULL);

	TCHAR *pszDN = GetDN ();
	if (pszDN == NULL)
	{
		MyAssert (FALSE);
		return ULS_E_HANDLE;
	}

	return UlsLdap_CAnyAttrs::SetAnyAttrs (	puRespID,
									NULL,
									WM_ULS_SET_APP_ATTRS,
									cAttrs,
									pszAttrs,
									m_cPrefix,
									m_pszPrefix,
									LDAP_MOD_REPLACE,
									GetServerInfo (),
									pszDN);
}


HRESULT UlsLdap_CLocalApp::RemoveAnyAttrs (
	ULONG	*puRespID,
	ULONG	cAttrs,
	TCHAR	*pszAttrs )
{
	MyAssert (puRespID != NULL);
	MyAssert (cAttrs != 0);
	MyAssert (pszAttrs != NULL);

	TCHAR *pszDN = GetDN ();
	if (pszDN == NULL)
	{
		MyAssert (FALSE);
		return ULS_E_HANDLE;
	}

	return UlsLdap_CAnyAttrs::RemoveAnyAttrs (	puRespID,
										NULL,
										WM_ULS_REMOVE_APP_ATTRS,
										cAttrs,
										pszAttrs,
										m_cPrefix,
										m_pszPrefix,
										GetServerInfo (),
										pszDN);
}


/* ---------- protected methods ----------- */


/* ---------- private methods ----------- */


HRESULT UlsLdap_CLocalApp::CacheInfo ( VOID *pInfo )
{
	return CacheAppInfo ((LDAP_APPINFO *) pInfo);
}


HRESULT UlsLdap_CLocalApp::CacheAppInfo ( LDAP_APPINFO *pInfo )
{
	ZeroMemory (&m_AppInfo, siz