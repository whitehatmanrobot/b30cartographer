xScreen = GetSystemMetrics(SM_CXSCREEN);
        g_cyScreen = GetSystemMetrics(SM_CYSCREEN);
        g_cxFrame  = GetSystemMetrics(SM_CXFRAME);
        g_cyFrame  = GetSystemMetrics(SM_CYFRAME);

        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);

        g_cxVScroll = g_cxScrollbar = (int)ncm.iScrollWidth;
        g_cyHScroll = g_cyScrollbar = (int)ncm.iScrollHeight;

        // this is true for 4.0 modules only
        // for 3.x modules user lies and adds one to these values
        // ASSERT(g_cxVScroll == GetSystemMetrics(SM_CXVSCROLL));
        // ASSERT(g_cyHScroll == GetSystemMetrics(SM_CYHSCROLL));

        g_cxIconMargin = g_cxBorder * 8;
        g_cyIconMargin = g_cyEdge;
        g_cyLabelSpace = g_cyIconMargin + (g_cyEdge);
        g_cxLabelMargin = g_cxEdge;

        g_cxDoubleClk = GetSystemMetrics(SM_CXDOUBLECLK);
        g_cyDoubleClk = GetSystemMetrics(SM_CYDOUBLECLK);

        g_fEnableBalloonTips = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("EnableBalloonTips"),
                        FALSE, // Don't ignore HKCU
                        TRUE);



    }

    SystemParametersInfo(SPI_GETMENUDROPALIGNMENT, 0, &g_fLeftAligned, 0);

    //NT 4.0 has this SPI_GETMOUSEHOVERTIME
    SystemParametersInfo(SPI_GETMOUSEHOVERTIME, 0, &g_dwHoverSelectTimeout, 0);
}

void RelayToToolTips(HWND hwndToolTips, HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    if(hwndToolTips) 
    {
        MSG msg;
        msg.lParam = lParam;
        msg.wParam = wParam;
        msg.message = wMsg;
        msg.hwnd = hWnd;
        SendMessage(hwndToolTips, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
    }
}

#define DT_SEARCHTIMEOUT    1000L       // 1 seconds

__inline BOOL IsISearchTimedOut(PISEARCHINFO pis)
{
    return GetMessageTime() - pis->timeLast > DT_SEARCHTIMEOUT &&
           !IsFlagSet(g_dwPrototype, PTF_NOISEARCHTO);

}

int GetIncrementSearchString(PISEARCHINFO pis, LPTSTR lpsz)
{
    if (IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf && lpsz) {
        lstrcpyn(lpsz, pis->pszCharBuf, pis->ichCharBuf + 1);
        lpsz[pis->ichCharBuf] = TEXT('\0');
    }
    return pis->ichCharBuf;
}

// Now only Korean version is interested in incremental search with composition string.
BOOL IncrementSearchImeCompStr(PISEARCHINFO pis, BOOL fCompStr, LPTSTR lpszCompStr, LPTSTR *lplpstr)
{
    BOOL fRestart = FALSE;

    if (!pis->fReplaceCompChar && IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf == 0)
    {
        fRestart = TRUE;
        pis->fReplaceCompChar = FALSE;
    }
    pis->timeLast = GetMessageTime();

    // Is there room for new character plus zero terminator?
    //
    if (!pis->fReplaceCompChar && pis->ichCharBuf + 1 + 1 > pis->cbCharBuf)
    {
        LPTSTR psz = ReAlloc(pis->pszCharBuf, sizeof(TCHAR)*(pis->cbCharBuf + 16));
        if (!psz)
            return fRestart;

        pis->cbCharBuf += 16;
        pis->pszCharBuf = psz;
    }

    if (pis->fReplaceCompChar)
    {
        if (lpszCompStr[0])
        {
            pis->pszCharBuf[pis->ichCharBuf-1] = lpszCompStr[0];
            pis->pszCharBuf[pis->ichCharBuf] = 0;
        }
        else
        {
            pis->ichCharBuf--;
            pis->pszCharBuf[pis->ichCharBuf] = 0;
        }
    }
    else
    {
        pis->pszCharBuf[pis->ichCharBuf++] = lpszCompStr[0];
        pis->pszCharBuf[pis->ichCharBuf] = 0;
    }

    pis->fReplaceCompChar = (fCompStr && lpszCompStr[0]);

    if (pis->ichCharBuf == 1 && pis->fReplaceCompChar)
        fRestart = TRUE;

    *lplpstr = pis->pszCharBuf;

    return fRestart;

}

/*
 * Thunk for LVM_GETISEARCHSTRINGA
 */
int GetIncrementSearchStringA(PISEARCHINFO pis, UINT uiCodePage, LPSTR lpsz)
{
    if (IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf && lpsz) {
        ConvertWToAN( uiCodePage, lpsz, pis->ichCharBuf, pis->pszCharBuf, pis->ichCharBuf );
        lpsz[pis->ichCharBuf] = '\0';
    }
    return pis->ichCharBuf;
}

// Beep only on the first failure.

void IncrementSearchBeep(PISEARCHINFO pis)
{
    if (!pis->iIncrSearchFailed)
    {
        pis->iIncrSearchFailed = TRUE;
        MessageBeep(0);
    }
}

//
//  IncrementSearchString - Add or clear the search string
//
//      ch == 0:  Reset the search string.  Return value meaningless.
//
//      ch != 0:  Append the character to the search string, starting
//                a new search string if we timed out the last one.
//                lplpstr receives the string so far.
//                Return value is TRUE if a new search string was
//                created, or FALSE if we appended to an existing one.
//

BOOL IncrementSearchString(PISEARCHINFO pis, UINT ch, LPTSTR *lplpstr)
{
    BOOL fRestart = FALSE;

    if (!ch) {
        pis->ichCharBuf =0;
        pis->iIncrSearchFailed = 0;
        return FALSE;
    }

    if (IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf == 0)
        fRestart = TRUE;

    pis->timeLast = GetMessageTime();

    // Is there room for new character plus zero terminator?
    //
    if (pis->ichCharBuf + 1 + 1 > pis->cbCharBuf)
    {
        LPTSTR psz = ReAlloc(pis->pszCharBuf, ((pis->cbCharBuf + 16) * sizeof(TCHAR)));
        if (!psz)
            return fRestart;

        pis->cbCharBuf += 16;
        pis->pszCharBuf = psz;
    }

    pis->pszCharBuf[pis->ichCharBuf++] = (TCHAR)ch;
    pis->pszCharBuf[pis->ichCharBuf] = 0;

    *lplpstr = pis->pszCharBuf;

    return fRestart;
}

// strips out the accelerators.  they CAN be the same buffers.
int StripAccelerators(LPTSTR lpszFrom, LPTSTR lpszTo, BOOL fAmpOnly)
{
    LPTSTR lpszStart = lpszTo;

    while (*lpszTo = *lpszFrom)
    {
        if (!fAmpOnly && (g_fDBCSInputEnabled))
        {
            if (*lpszFrom == TEXT('(') && *(lpszFrom + 1) == CH_PREFIX)
            {
                int i;
                LPTSTR psz = lpszFrom + 2;

                for(i = 0; i < 2 && *psz; i++, psz = FastCharNext(psz))
                {
                    ;
                }


                if (*psz == '\0')
                {
                    *lpszTo = 0;
                    break;
                }
                else if (i == 2 && *psz == TEXT(')'))
                {
                    lpszTo--;
                    lpszFrom = psz+1;
                    continue;
                }
            }
        }

        if (*lpszFrom == TEXT('\t'))
        {
            *lpszTo = TEXT('\0');
            break;
        }

        if ((*lpszFrom++ != CH_PREFIX) || (*lpszFrom == CH_PREFIX))
        {
            lpszTo++;
        }
    }

    return (int)(lpszTo - lpszStart);
}


void ScrollShrinkRect(int x, int y, LPRECT lprc)
{
    if (lprc) {
        if (x > 0) {
            lprc->left += x;
        } else {
            lprc->right += x;
        }

        if (y > 0) {
            lprc->top += y;
        } else {
            lprc->bottom += y;
        }

    }
}



// common control info helpers
void CIInitialize(LPCCONTROLINFO lpci, HWND hwnd, LPCREATESTRUCT lpcs)
{
    TEXTMETRIC tm;
    HFONT hfStatus;
    lpci->hwnd = hwnd;
    lpci->hwndParent = lpcs->hwndParent;
    lpci->style = lpcs->style;
    lpci->uiCodePage = CP_ACP;
    lpci->dwExStyle = lpcs->dwExStyle;
    lpci->iVersion = 6;
#ifdef DPITEST
    lpci->fDPIAware = TRUE;
#endif

    // See if the default listview font has no internal leading.
    // If not, then we have to inflate the focus rectangle so we
    // don't overlap the first pixel.
    //
    // Note that this is a global and not per-TextOut.
    // Otherwise controls with a mix of fonts will get
    // inconsistently-placed focus rectangles.
    //
    hfStatus = CCCreateStatusFont();
    if (hfStatus)
    {
        HDC hdc = GetDC(hwnd);
        if (hdc)
        {
            HFONT hfPrev = SelectFont(hdc, hfStatus);
            if (GetTextMetrics(hdc, &tm) &&
                tm.tmInternalLeading == 0)
            {
                g_cyCompensateInternalLeading = 1;
            }
            SelectFont(hdc, hfPrev);
            ReleaseDC(hwnd, hdc);
        }

        DeleteObject(hfStatus);
    }

    lpci->bUnicode = lpci->hwndParent &&
                     SendMessage (lpci->hwndParent, WM_NOTIFYFORMAT,
                                 (WPARAM)lpci->hwnd, NF_QUERY) == NFR_UNICODE;

    if (lpci->hwndParent)
    {
        LRESULT lRes = SendMessage(lpci->hwndParent, WM_QUERYUISTATE, 0, 0);
            lpci->wUIState = LOWORD(lRes);
    }
}

LRESULT CIHandleNotifyFormat(LPCCONTROLINFO lpci, LPARAM lParam)
{
    if (lParam == NF_QUERY) 
    {
        return NFR_UNICODE;
    } 
    else if (lParam == NF_REQUERY) 
    {
        LRESULT uiResult;

        uiResult = SendMessage (lpci->hwndParent, WM_NOTIFYFORMAT,
                                (WPARAM)lpci->hwnd, NF_QUERY);

        lpci->bUnicode = BOOLIFY(uiResult == NFR_UNICODE);

        return uiResult;
    }
    return 0;
}

UINT CCSwapKeys(WPARAM wParam, UINT vk1, UINT vk2)
{
    if (wParam == vk1)
        return vk2;
    if (wParam == vk2)
        return vk1;
    return (UINT)wParam;
}

UINT RTLSwapLeftRightArrows(CCONTROLINFO *pci, WPARAM wParam)
{
    if (pci->dwExStyle & RTL_MIRRORED_WINDOW) 
    {
        return CCSwapKeys(wParam, VK_LEFT, VK_RIGHT);
    }
    return (UINT)wParam;
}

//
//  New for v5.01:
//
//  Accessibility (and some other callers, sometimes even us) relies on
//  a XXM_GETITEM call filling the buffer and not just redirecting the
//  pointer.  Accessibility is particularly impacted by this because they
//  live outside the process, so the redirected pointer means nothing
//  to them.  Here, we copy the result back into the app buffer and return
//  the raw pointer.  The caller will return the raw pointer back to the
//  app, so the answer is in two places, either the app buffer, or in
//  the raw pointer.
//
//  Usage:
//
//      if (nm.item.mask & LVIF_TEXT)
//          pitem->pszText = CCReturnDispInfoText(nm.item.pszText,
//                              pitem->pszText, pitem->cchTextMax);
//
LPTSTR CCReturnDispInfoText(LPTSTR pszSrc, LPTSTR pszDest, UINT cchDest)
{
    // Test pszSrc != pszDest first since the common case is that they
    // are equal.
    if (pszSrc != pszDest && !IsFlagPtr(pszSrc) && !IsFlagPtr(pszDest))
        StrCpyN(pszDest, pszSrc, cchDest);
    return pszSrc;
}

#define SUBSCROLLS 100
#define abs(x) ( ( x > 0 ) ? x : -x)


#define DEFAULT_MAXSCROLLTIME ((GetDoubleClickTime() / 2) + 1)  // Ensure >= 1
#define DEFAULT_MINSCROLL 8
int SmoothScrollWindow(PSMOOTHSCROLLINFO psi)
{
    int dx = psi->dx;
    int dy = psi->dy;
    LPCRECT lprcSrc = psi->lprcSrc;
    LPCRECT lprcClip = psi->lprcClip;
    HRGN hrgnUpdate = psi->hrgnUpdate;
    LPRECT lprcUpdate = psi->lprcUpdate;
    UINT fuScroll = psi->fuScroll;
    int iRet = SIMPLEREGION;
    RECT rcUpdate;
    RECT rcSrc;
    RECT rcClip;
    int xStep;
    int yStep;
    int iSlicesDone = 0;
    int iSlices;
    DWORD dwTimeStart, dwTimeNow;
    HRGN hrgnLocalUpdate;
    UINT cxMinScroll = psi->cxMinScroll;
    UINT cyMinScroll = psi->cyMinScroll;
    UINT uMaxScrollTime = psi->uMaxScrollTime;
    int iSubScrolls;
    PFNSMOOTHSCROLLPROC pfnScrollProc;
    DWORD dwRedrawFlags = RDW_ERASE | RDW_ERASENOW | RDW_INVALIDATE;

    if (!lprcUpdate)
        lprcUpdate = &rcUpdate;

    SetRectEmpty(lprcUpdate);

    if (psi->cbSize != sizeof(SMOOTHSCROLLINFO))
    {
        return 0;
    }

    // check the defaults
    if (!(psi->fMask & SSIF_MINSCROLL )
        || cxMinScroll == SSI_DEFAULT)
    {
        cxMinScroll = DEFAULT_MINSCROLL;
    }

    if (!(psi->fMask & SSIF_MINSCROLL)
        || cyMinScroll == SSI_DEFAULT)
    {
        cyMinScroll = DEFAULT_MINSCROLL;
    }

    if (!(psi->fMask & SSIF_MAXSCROLLTIME)
        || uMaxScrollTime == SSI_DEFAULT)
    {
        uMaxScrollTime = DEFAULT_MAXSCROLLTIME;
    }

    if (uMaxScrollTime < SUBSCROLLS)
    {
        uMaxScrollTime = SUBSCROLLS;
    }


    if ((!(fuScroll & SSW_EX_IGNORESETTINGS)) &&
        (!g_fSmoothScroll))
    {
        fuScroll |= SSW_EX_IMMEDIATE;
    }

    if ((psi->fMask & SSIF_SCROLLPROC) && psi->pfnScrollProc)
    {
        pfnScrollProc = psi->pfnScrollProc;
    }
    else 
    {
        pfnScrollProc = ScrollWindowEx;
    }

#ifdef ScrollWindowEx
#undef ScrollWindowEx
#endif

    if (fuScroll & SSW_EX_IMMEDIATE) 
    {
        return pfnScrollProc(psi->hwnd, dx, dy, lprcSrc, lprcClip, hrgnUpdate,
                             lprcUpdate, LOWORD(fuScroll));
    }

    if (fuScroll & SSW_EX_UPDATEATEACHSTEP)
    {
        dwRedrawFlags |= RDW_UPDATENOW;
    }

    // copy input rects locally
    if (lprcSrc) 
    {
        rcSrc = *lprcSrc;
        lprcSrc = &rcSrc;
    }
    if (lprcClip)
    {
        rcClip = *lprcClip;
        lprcClip = &rcClip;
    }

    if (!hrgnUpdate)
        hrgnLocalUpdate = CreateRectRgn(0,0,0,0);
    else
        hrgnLocalUpdate = hrgnUpdate;

    //set up initial vars
    dwTimeStart = GetTickCount();

    if (fuScroll & SSW_EX_NOTIMELIMIT)
    {
        xStep = cxMinScroll * (dx < 0 ? -1 : 1);
        yStep = cyMinScroll * (dy < 0 ? -1 : 1);
    }
    else
    {
        iSubScrolls = (uMaxScrollTime / DEFAULT_MAXSCROLLTIME) * SUBSCROLLS;
        if (!iSubScrolls)
            iSubScrolls = SUBSCROLLS;
        xStep = dx / iSubScrolls;
        yStep = dy / iSubScrolls;
    }

    if (xStep == 0 && dx)
        xStep = dx < 0 ? -1 : 1;

    if (yStep == 0 && dy)
        yStep = dy < 0 ? -1 : 1;

    while (dx || dy)
    {
        int x,y;
        RECT rcTempUpdate;

        if (fuScroll & SSW_EX_NOTIMELIMIT) 
        {
            x = xStep;
            y = yStep;
            if (abs(x) > abs(dx))
                x = dx;

            if (abs(y) > abs(dy))
                y = dy;

        }
        else
        {
            int iTimePerScroll = uMaxScrollTime / iSubScrolls;
            if (!iTimePerScroll)
                iTimePerScroll = 1;
            
            dwTimeNow = GetTickCount();

            iSlices = ((dwTimeNow - dwTimeStart) / iTimePerScroll) - iSlicesDone;
            if (iSlices < 0)
                iSlices = 0;
            do 
            {

                int iRet = 0;

                iSlices++;
                if ((iSlicesDone + iSlices) <= iSubScrolls) 
                {
                    x = xStep * iSlices;
                    y = yStep * iSlices;

                    // this could go over if we rounded ?Step up to 1(-1) above
                    if (abs(x) > abs(dx))
                        x = dx;

                    if (abs(y) > abs(dy))
                        y = dy;

                }
                else 
                {
                    x = dx;
                    y = dy;
                }

                //DebugMsg(DM_TRACE, "SmoothScrollWindowCallback %d", iRet);

                if (x == dx && y == dy)
                    break;

                if ((((UINT)(abs(x)) >= cxMinScroll) || !x) &&
                    (((UINT)(abs(y)) >= cyMinScroll) || !y))
                    break;

            }
            while (1);
        }

        if (pfnScrollProc(psi->hwnd, x, y, lprcSrc, lprcClip, hrgnLocalUpdate, &rcTempUpdate, LOWORD(fuScroll)) == ERROR) 
        {
            iRet = ERROR;
            goto Bail;
        }

        UnionRect(lprcUpdate, &rcTempUpdate, lprcUpdate);

        RedrawWindow(psi->hwnd, NULL, hrgnLocalUpdate, dwRedrawFlags);

        ScrollShrinkRect(x,y, (LPRECT)lprcSrc);

        dx -= x;
        dy -= y;
        iSlicesDone += iSlices;
    }

Bail:
    if (fuScroll & SW_SCROLLCHILDREN) 
    {
        RedrawWindow(psi->hwnd, lprcUpdate, NULL, RDW_ERASE | RDW_UPDATENOW | RDW_INVALIDATE);
    }

    if (hrgnLocalUpdate != hrgnUpdate)
        DeleteObject(hrgnLocalUpdate);

    return iRet;
}

#define CCH_KEYMAX 256

void CCPlaySound(LPCTSTR lpszName)
{
    TCHAR szFileName[MAX_PATH];
    LONG cbSize = SIZEOF(szFileName);
    TCHAR szKey[CCH_KEYMAX];

    // check the registry first
    // if there's nothing registered, we blow off the play,
    // but we don't set the MM_DONTLOAD flag so taht if they register
    // something we will play it
    wsprintf(szKey, TEXT("AppEvents\\Schemes\\Apps\\.Default\\%s\\.current"), lpszName);
    if ((RegQueryValue(HKEY_CURRENT_USER, szKey, szFileName, &cbSize) == ERROR_SUCCESS) &&
        (cbSize > SIZEOF(szFileName[0])))
    {
        PlaySound(szFileName, NULL, SND_FILENAME | SND_ASYNC);
    }
}

BOOL CCForwardEraseBackground(HWND hwnd, HDC hdc)
{
    HWND hwndParent = GetParent(hwnd);
    LRESULT lres = 0;

    if (hwndParent)
    {
        // Adjust the origin so the parent paints in the right place
        POINT pt = {0,0};

        MapWindowPoints(hwnd, hwndParent, &pt, 1);
        OffsetWindowOrgEx(hdc, 
                          pt.x, 
                          pt.y, 
                          &pt);

        lres = SendMessage(hwndParent, WM_ERASEBKGND, (WPARAM) hdc, 0L);

        SetWindowOrgEx(hdc, pt.x, pt.y, NULL);
    }
    return(lres != 0);
}

HFONT CCGetHotFont(HFONT hFont, HFONT *phFontHot)
{
    if (!*phFontHot) {
        LOGFONT lf;

        // create the underline font
        GetObject(hFont, sizeof(lf), &lf);
#ifndef DONT_UNDERLINE
        lf.lfUnderline = TRUE;
#endif
        *phFontHot = CreateFontIndirect(&lf);
    }
    return *phFontHot;
}


HFONT CCCreateStatusFont(void)
{
    NONCLIENTMETRICS ncm;

    ncm.cbSize = sizeof(NONCLIENTMETRICS);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);

    return CreateFontIndirect(&ncm.lfStatusFont);
}

HFONT CCCreateUnderlineFont(HFONT hf)
{
    HFONT hUnderline = NULL;
    LOGFONT lf;
    if (hf && GetObject(hf, sizeof(lf), &lf))
    {
        lf.lfUnderline = TRUE;
        hUnderline = CreateFontIndirect(&lf);
    }

    return hUnderline;
}


void* CCLocalReAlloc(void* p, UINT uBytes)
{
    if (uBytes) {
        if (p) {
            return LocalReAlloc(p, uBytes, LMEM_MOVEABLE | LMEM_ZEROINIT);
        } else {
            return LocalAlloc(LPTR, uBytes);
        }
    } else {
        if (p)
            LocalFree(p);
        return NULL;
    }
}

/*----------------------------------------------------------
Purpose: This function provides the commctrl version info.  This
         allows the caller to distinguish running NT SUR vs.
         Win95 shell vs. Nashville, etc.

         This API was not supplied in Win95 or NT SUR, so
         the caller must GetProcAddress it.  If this fails,
         the caller is running on Win95 or NT SUR.

Returns: NO_ERROR
         ERROR_INVALID_PARAMETER if pinfo is invalid

Cond:    --
*/

// All we have to do is declare this puppy and CCDllGetVersion does the rest
// Note that we use VER_FILEVERSION_DW because comctl32 uses a funky
// version scheme
DLLVER_DUALBINARY(VER_FILEVERSION_DW, VER_PRODUCTBUILD_QFE);

//
// Translate the given font to a code page used for thunking text
//
UINT GetCodePageForFont (HFONT hFont)
{
#ifdef WINNT
    LOGFONT lf;
    TCHAR szFontName[MAX_PATH];
    CHARSETINFO csi;
    DWORD dwSize, dwType;
    HKEY hKey;


    if (!GetObject (hFont, sizeof(lf), &lf)) {
        return CP_ACP;
    }


    //
    // Check for font substitutes
    //

    lstrcpy (szFontName, lf.lfFaceName);

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = MAX_PATH * sizeof(TCHAR);
        RegQueryValueEx (hKey, lf.lfFaceName, NULL, &dwType,
                         (LPBYTE) szFontName, &dwSize);

        RegCloseKey (hKey);
    }


    //
    //  This is to fix office for locales that use non 1252 versions
    //  of Ms Sans Serif and Ms Serif.  These fonts incorrectly identify
    //  themselves as having an Ansi charset, so TranslateCharsetInfo will
    //  return the wrong value.
    //
    //  NT bug 260697: Office 2000 uses Tahoma.
    //
    if ((lf.lfCharSet == ANSI_CHARSET) &&
        (!lstrcmpi(L"Helv", szFontName) ||
         !lstrcmpi(L"Ms Sans Serif", szFontName) ||
         !lstrcmpi(L"Ms Serif", szFontName) ||
         !lstrcmpi(L"Tahoma", szFontName)))
    {
        return CP_ACP;
    }
    //
    //  This is to fix FE office95a and Pro. msofe95.dll sets wrong charset when create
    //  listview control. so TranslateCharsetInfo will return the wrong value.
    //  Korea  : DotumChe.
    //  Taiwan : New MingLight
    //  China  : SongTi

    if ((lf.lfCharSet == SHIFTJIS_CHARSET) &&
        (!lstrcmpi(L"\xb3cb\xc6c0\xccb4", lf.lfFaceName))        || // Korea
        (!lstrcmpi(L"\x65b0\x7d30\x660e\x9ad4", lf.lfFaceName))  || // Taiwan
        (!lstrcmpi(L"\x5b8b\x4f53", lf.lfFaceName)))                // PRC
    {
        return CP_ACP;
    }

    if (!TranslateCharsetInfo((DWORD *) lf.lfCharSet, &csi, TCI_SRCCHARSET)) {
        return CP_ACP;
    }

    return csi.ciACP;
#else

    return CP_ACP;

#endif
}

LONG GetMessagePosClient(HWND hwnd, LPPOINT ppt)
{
    LPARAM lParam;
    POINT pt;
    if (!ppt)
        ppt = &pt;
    
    lParam = GetMessagePos();
    ppt->x = GET_X_LPARAM(lParam);
    ppt->y = GET_Y_LPARAM(lParam);
    ScreenToClient(hwnd, ppt);

    return MAKELONG(ppt->x, ppt->y);
}


LPTSTR StrDup(LPCTSTR lpsz)
{
    LPTSTR lpszRet = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lpsz) + 1) * sizeof(TCHAR));
    if (lpszRet) {
        lstrcpy(lpszRet, lpsz);
    }
    return lpszRet;
}

#ifdef UNICODE
LPSTR StrDupA(LPCSTR lpsz)
{
    LPSTR lpszRet = (LPSTR)LocalAlloc(LPTR, (lstrlenA(lpsz) + 1) * sizeof(CHAR));
    if (lpszRet) {
        lstrcpyA(lpszRet, lpsz);
    }
    return lpszRet;
}

#endif

HWND GetDlgItemRect(HWND hDlg, int nIDItem, LPRECT prc) //relative to hDlg
{
    HWND hCtrl = NULL;
    if (prc)
    {
        hCtrl = GetDlgItem(hDlg, nIDItem);
        if (hCtrl)
        {
            GetWindowRect(hCtrl, prc);
            MapWindowRect(NULL, hDlg, prc);
        }
        else
            SetRectEmpty(prc);
    }
    return hCtrl;
} 


/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

*/
HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            hr = pfnri(g_hinst, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}

//
//  GOING AWAY: Need to implement setup changes to generate an assemly during setup.
//

#if defined(_IA64_)
#define CC_SIDEBYSIDE TEXT("\\ia64_comctl32_6.0.0.0_0000")
#elif defined(_X86_)
#define CC_SIDEBYSIDE TEXT("\\x86_comctl32_6.0.0.0_0000")
#elif defined(_AMD64_)
#define CC_SIDEBYSIDE TEXT("\\amd64_comctl32_6.0.0.0_0000")
#else
// If this error fires, it means that we've added support for a new platform.
// Add an appropriate definition for CC_SIDEBYSIDE here.
#error Unsupported platform - needs definition for CC_SIDEBYSIDE
#endif

HRESULT DoFusion()
{
#if 0

    // First, Get the module name
    TCHAR szDest[MAX_PATH];
    TCHAR szName[MAX_PATH];
    GetModuleFileName(HINST_THISDLL, szName, ARRAYSIZE(szName));

    GetWindowsDirectory(szDest, ARRAYSIZE(szDest));
    
    // Make sure %windir%\winsxs exists
    lstrcat(szDest, TEXT("\\winsxs"));
    CreateDirectory(szDest, NULL);

    // Make the x86_comctl32_6.0.0.0_0000 directory
    lstrcat(szDest, CC_SIDEBYSIDE);
    CreateDirectory(szDest, NULL);

    // Copy the file
    lstrcat(szDest, TEXT("\\comctl32.dll"));

    // Copy comctv6.dll to comctl32.dll
    if (!MoveFileEx(szName, szDest, MOVEFILE_DELAY_UNTIL_REBOOT | MOVEFILE_REPLACE_EXISTING))
        return HRESULT_FROM_WIN32(GetLastError());

    // Now generate a manifest
    GetWindowsDirectory(szDest, ARRAYSIZE(szDest));
    lstrcat(szDest, TEXT("\\winsxs") CC_SIDEBYSIDE TEXT("\\comctl32.manifest"));
    // Extract the fusion manifest from the resource.
    SHSquirtManifest(HINST_THISDLL, IDS_CCMANIFEST, szDest);
#endif
    return S_OK;
}

//
//  End going away
//


/*----------------------------------------------------------
Purpose: Install/uninstall user settings

*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hres = S_OK;
#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in DllInstall");
        DEBUG_BREAK;
    }
#endif

    if (bInstall)
    {
        hres = DoFusion();
        // Delete any old registration entries, then add the new ones.
        // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
        // (The inf engine doesn't guarantee DelReg/AddReg order, that's
        // why we explicitly unreg and reg here.)
        //
        CallRegInstall("RegDll");

    }
    else
    {
        CallRegInstall("UnregDll");
    }

    return hres;    
}    



//---------------------------------------------------------------------------------------
void FlipRect(LPRECT prc)
{
    SWAP(prc->left, prc->top, int);
    SWAP(prc->right, prc->bottom, int);
}


//---------------------------------------------------------------------------------------
//
//  Returns previous window bits.

DWORD SetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue)
{
    DWORD dwStyle;
    DWORD dwNewStyle;

    dwStyle = GetWindowLong(hWnd, iWhich);
    dwNewStyle = ( dwStyle & ~dwBits ) | (dwValue & dwBits);
    if (dwStyle != dwNewStyle) {
        dwStyle = SetWindowLong(hWnd, iWhich, dwNewStyle);
    }
    return dwStyle;
}

//---------------------------------------------------------------------------------------

BOOL CCDrawEdge(HDC hdc, LPRECT lprc, UINT edge, UINT flags, LPCOLORSCHEME lpclrsc)
{
    RECT    rc, rcD;
    UINT    bdrType;
    COLORREF clrTL, clrBR;    

    //
    // Enforce monochromicity and flatness
    //    

    // if (oemInfo.BitCount == 1)
    //    flags |= BF_MONO;
    if (flags & BF_MONO)
        flags |= BF_FLAT;    

    CopyRect(&rc, lprc);

    //
    // Draw the border segment(s), and calculate the remaining space as we
    // go.
    //
    if (bdrType = (edge & BDR_OUTER))
    {
DrawBorder:
        //
        // Get colors.  Note the symmetry between raised outer, sunken inner and
        // sunken outer, raised inner.
        //

        if (flags & BF_FLAT)
        {
            if (flags & BF_MONO)
                clrBR = (bdrType & BDR_OUTER) ? g_clrWindowFrame : g_clrWindow;
            else
                clrBR = (bdrType & BDR_OUTER) ? g_clrBtnShadow: g_clrBtnFace;
            
            clrTL = clrBR;
        }
        else
        {
            // 5 == HILIGHT
            // 4 == LIGHT
            // 3 == FACE
            // 2 == SHADOW
            // 1 == DKSHADOW

            switch (bdrType)
            {
                // +2 above surface
                case BDR_RAISEDOUTER:           // 5 : 4
                    clrTL = ((flags & BF_SOFT) ? g_clrBtnHighlight : g_clr3DLight);
                    clrBR = g_clr3DDkShadow;     // 1
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnHighlight;
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnShadow;
                    }                                            
                    break;

                // +1 above surface
                case BDR_RAISEDINNER:           // 4 : 5
                    clrTL = ((flags & BF_SOFT) ? g_clr3DLight : g_clrBtnHighlight);
                    clrBR = g_clrBtnShadow;       // 2
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnHighlight;
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnShadow;
                    }                                            
                    break;

                // -1 below surface
                case BDR_SUNKENOUTER:           // 1 : 2
                    clrTL = ((flags & BF_SOFT) ? g_clr3DDkShadow : g_clrBtnShadow);
                    clrBR = g_clrBtnHighlight;      // 5
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnShadow;
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnHighlight;                        
                    }
                    break;

                // -2 below surface
                case BDR_SUNKENINNER:           // 2 : 1
                    clrTL = ((flags & BF_SOFT) ? g_clrBtnShadow : g_clr3DDkShadow);
                    clrBR = g_clr3DLight;        // 4
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnShadow;
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnHighlight;                        
                    }
                    break;

                default:
                    return(FALSE);
            }
        }

        //
        // Draw the sides of the border.  NOTE THAT THE ALGORITHM FAVORS THE
        // BOTTOM AND RIGHT SIDES, since the light source is assumed to be top
        // left.  If we ever decide to let the user set the light source to a
        // particular corner, then change this algorithm.
        //
            
        // Bottom Right edges
        if (flags & (BF_RIGHT | BF_BOTTOM))
        {            
            // Right
            if (flags & BF_RIGHT)
            {       
                rc.right -= g_cxBorder;
                // PatBlt(hdc, rc.right, rc.top, g_cxBorder, rc.bottom - rc.top, PATCOPY);
                rcD.left = rc.right;
                rcD.right = rc.right + g_cxBorder;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom;

                FillRectClr(hdc, &rcD, clrBR);
            }
            
            // Bottom
            if (flags & BF_BOTTOM)
            {
                rc.bottom -= g_cyBorder;
                // PatBlt(hdc, rc.left, rc.bottom, rc.right - rc.left, g_cyBorder, PATCOPY);
                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.bottom;
                rcD.bottom = rc.bottom + g_cyBorder;

                FillRectClr(hdc, &rcD, clrBR);
            }
        }
        
        // Top Left edges
        if (flags & (BF_TOP | BF_LEFT))
        {
            // Left
            if (flags & BF_LEFT)
            {
                // PatBlt(hdc, rc.left, rc.top, g_cxBorder, rc.bottom - rc.top, PATCOPY);
                rc.left += g_cxBorder;

                rcD.left = rc.left - g_cxBorder;
                rcD.right = rc.left;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom; 

                FillRectClr(hdc, &rcD, clrTL);
            }
            
            // Top
            if (flags & BF_TOP)
            {
                // PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, g_cyBorder, PATCOPY);
                rc.top += g_cyBorder;

                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.top - g_cyBorder;
                rcD.bottom = rc.top;

                FillRectClr(hdc, &rcD, clrTL);
            }
        }
        
    }

    if (bdrType = (edge & BDR_INNER))
    {
        //
        // Strip this so the next time through, bdrType will be 0.
        // Otherwise, we'll loop forever.
        //
        edge &= ~BDR_INNER;
        goto DrawBorder;
    }

    //
    // Fill the middle & clean up if asked
    //
    if (flags & BF_MIDDLE)    
        FillRectClr(hdc, &rc, (flags & BF_MONO) ? g_clrWindow : g_clrBtnFace);

    if (flags & BF_ADJUST)
        CopyRect(lprc, &rc);

    return(TRUE);
}

BOOL CCThemeDrawEdge(HTHEME hTheme, HDC hdc, PRECT prc, int iPart, int iState, UINT edge, UINT flags, LPCOLORSCHEME pclrsc)
{
    RECT rc;
    if (!hTheme)
        return CCDrawEdge(hdc, prc, edge, flags, pclrsc);

    return S_OK == DrawThemeEdge(hTheme, hdc, iPart, iState, prc, edge, flags, &rc);
}



//---------------------------------------------------------------------------------------
//CCInvalidateFrame -- SWP_FRAMECHANGED, w/o all the extra params
//
void CCInvalidateFrame(HWND hwnd)
{
    SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_FRAMECHANGED|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
    return;
}

//---------------------------------------------------------------------------------------
// FlipPoint - flip the x and y coordinates of a point
//
void FlipPoint(LPPOINT lppt)
{
    SWAP(lppt->x, lppt->y, int);
}

//
//  When we want to turn a tooltip into an infotip, we set its
//  width to 300 "small pixels", where there are 72 small pixels
//  per inch when you are in small fonts mode.
//
//  Scale this value based on the magnification in effect
//  on the owner's monitor.  But never let the tooltip get
//  bigger than 3/4 of the screen.
//
void CCSetInfoTipWidth(HWND hwndOwner, HWND hwndToolTips)
{
    HDC hdc = GetDC(hwndOwner);
    int iWidth = MulDiv(GetDeviceCaps(hdc, LOGPIXELSX), 300, 72);
    int iMaxWidth = GetDeviceCaps(hdc, HORZRES) * 3 / 4;
    SendMessage(hwndToolTips, TTM_SETMAXTIPWIDTH, 0, min(iWidth, iMaxWidth));
    ReleaseDC(hwndOwner, hdc);
}

// Mirror a bitmap in a DC (mainly a text object in a DC)
//
// [samera]
//
void MirrorBitmapInDC( HDC hdc , HBITMAP hbmOrig )
{
  HDC     hdcMem;
  HBITMAP hbm;
  BITMAP  bm;


  if( !GetObject( hbmOrig , sizeof(BITMAP) , &bm ))
    return;

  hdcMem = CreateCompatibleDC( hdc );

  if( !hdcMem )
    return;

  hbm = CreateCompatibleBitmap( hdc , bm.bmWidth , bm.bmHeight );

  if( !hbm )
  {
    DeleteDC( hdcMem );
    return;
  }

  //
  // Flip the bitmap
  //
  SelectObject( hdcMem , hbm );
  SET_DC_RTL_MIRRORED(hdcMem);

  BitBlt( hdcMem , 0 , 0 , bm.bmWidth , bm.bmHeight ,
          hdc , 0 , 0 , SRCCOPY );

  SET_DC_LAYOUT(hdcMem,0);

  //
  // The offset by 1 is to solve the off-by-one (in hdcMem) problem. Solved.
  // [samera]
  //
  BitBlt( hdc , 0 , 0 , bm.bmWidth , bm.bmHeight ,
          hdcMem , 0 , 0 , SRCCOPY );


  DeleteDC( hdcMem );
  DeleteObject( hbm );

  return;
}

// returns TRUE if handled
BOOL CCWndProc(CCONTROLINFO* pci, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    if (uMsg >= CCM_FIRST && uMsg < CCM_LAST)
    {
        LRESULT lres = 0;
        switch (uMsg) 
        {
        case CCM_SETUNICODEFORMAT:
            lres = pci->bUnicode;
            pci->bUnicode = BOOLFROMPTR(wParam);
            break;

        case CCM_GETUNICODEFORMAT:
            lres = pci->bUnicode;
            break;
            
        case CCM_SETVERSION:
            lres = 6;
            break;

        case CCM_GETVERSION:
            lres = 6;
            break;

        case CCM_DPISCALE:
            pci->fDPIAware = (BOOL)wParam;
            lres = 1;
            break;

        }
        
        ASSERT(plres);
        *plres = lres;
        
        return TRUE;
    }
    
    return FALSE;
}

// Draws an insertmark.
void CCDrawInsertMark(HDC hdc, LPRECT prc, BOOL fHorizMode, COLORREF clr)
{
    HPEN hPnMark = CreatePen(PS_SOLID, 1, clr);
    HPEN hOldPn;
    POINT rgPoint[4];
    if (!hPnMark)
        hPnMark = (HPEN)GetStockObject(BLACK_PEN);    // fallback to draw with black pen
    hOldPn = (HPEN)SelectObject(hdc, (HGDIOBJ)hPnMark);

    if ( fHorizMode )
    {
        if (RECTWIDTH(*prc)>INSERTMARKSIZE && RECTHEIGHT(*prc)>3)
        {
            int iXCentre = prc->left + RECTWIDTH(*prc)/2;  // make sure we truncate towards prc->left (not towards 0!)

            rgPoint[0].x = iXCentre + 1;
            rgPoint[0].y = prc->top + 2;
            rgPoint[1].x = iXCentre + 3;
            rgPoint[1].y = prc->top;
            rgPoint[2].x = iXCentre - 2;
            rgPoint[2].y = prc->top;
            rgPoint[3].x = iXCentre;
            rgPoint[3].y = prc->top + 2;

            ASSERT(rgPoint[0].x >= prc->left && rgPoint[0].x < prc->right && rgPoint[0].y >= prc->top && rgPoint[0].y < prc->bottom);
            ASSERT(rgPoint[1].x >= prc->left && rgPoint[1].x < prc->right && rgPoint[1].y >= prc->top && rgPoint[1].y < prc->bottom);
            ASSERT(rgPoint[2].x >= prc->left && rgPoint[2].x < prc->right && rgPoint[2].y >= prc->top && rgPoint[2].y < prc->bottom);
            ASSERT(rgPoint[3].x >= prc->left && rgPoint[3].x < prc->right && rgPoint[3].y >= prc->top && rgPoint[3].y < prc->bottom);

            // draw the top bit...
            Polyline( hdc, rgPoint, 4 );

            rgPoint[0].x = iXCentre;
            rgPoint[0].y = prc->top;
            rgPoint[1].x = iXCentre;
            rgPoint[1].y = prc->bottom - 1;
            rgPoint[2].x = iXCentre + 1;
            rgPoint[2].y = prc->bottom - 1;
            rgPoint[3].x = iXCentre + 1;
            rgPoint[3].y = prc->top;

            ASSERT(rgPoint[0].x >= prc->left && rgPoint[0].x < prc->right && rgPoint[0].y >= prc->top && rgPoint[0].y < prc->bottom);
            ASSERT(rgPoint[1].x >= prc->left && rgPoint[1].x < prc->right && rgPoint[1].y >= prc->top && rgPoint[1].y < prc->bottom);
            ASSERT(rgPoint[2].x >= prc->left && rgPoint[2].x < prc->right && rgPoint[2].y >= prc->top && rgPoint[2].y < prc->bottom);
            ASSERT(rgPoint[3].x >= prc->left && rgPoint[3].x < prc->right && rgPoint[3].y >= prc->top && rgPoint[3].y < prc->bottom);

            // draw the middle...
            Polyline( hdc, rgPoint, 4 );

            rgPoint[0].x = iXCentre + 1;
            rgPoint[0].y = prc->bottom - 3;
            rgPoint[1].x = iXCentre + 3;
            rgPoint[1].y = prc->bottom - 1;
            rgPoint[2].x = iXCentre - 2;
            rgPoint[2].y = prc->bottom - 1;
            rgPoint[3].x = iXCentre;
            rgPoint[3].y = prc->bottom - 3;

            ASSERT(rgPoint[0].x >= prc->left && rgPoint[0].x < prc->right && rgPoint[0].y >= prc->top && rgPoint[0].y < prc->bottom);
            ASSERT(rgPoint[1].x >= prc->left && rgPoint[1].x < prc->right && rgPoint[1].y >= prc->top && rgPoint[1].y < prc->bottom);
            ASSERT(rgPoint[2].x >= prc->left && rgPoint[2].x < prc->right && rgPoint[2].y >= prc->top && rgPoint[2].y < prc->bottom);
            ASSERT(rgPoint[3].x >= prc->left && rgPoint[3].x < prc->right && rgPoint[3].y >= prc->top && rgPoint[3].y < prc->bottom);

            // draw the bottom bit...
            Polyline( hdc, rgPoint, 4 );
        }
    }
    else
    {
        if (RECTHEIGHT(*prc)>INSERTMARKSIZE && RECTWIDTH(*prc)>3)
        {
            int iYCentre = prc->top + RECTHEIGHT(*prc)/2;   // make sure we truncate towards prc->top (not towards 0!)

            rgPoint[0].x = prc->left + 2;
            rgPoint[0].y = iYCentre;
            rgPoint[1].x = prc->left;
            rgPoint[1].y = iYCentre - 2;
            rgPoint[2].x = prc->left;
            rgPoint[2].y = iYCentre + 3;
            rgPoint[3].x = prc->left + 2;
            rgPoint[3].y = iYCentre + 1;

            ASSERT(rgPoint[0].x >= prc->left && rgPoint[0].x < prc->right && rgPoint[0].y >= prc->top && rgPoint[0].y < prc->bottom);
            ASSERT(rgPoint[1].x >= prc->left && rgPoint[1].x < prc->right && rgPoint[1].y >= prc->top && rgPoint[1].y < prc->bottom);
            ASSERT(rgPoint[2].x >= prc->left && rgPoint[2].x < prc->right && rgPoint[2].y >= prc->top && rgPoint[2].y < prc->bottom);
            ASSERT(rgPoint[3].x >= prc->left && rgPoint[3].x < prc->right && rgPoint[3].y >= prc->top && rgPoint[3].y < prc->bottom);

            // draw the top bit...
            Polyline( hdc, rgPoint, 4 );

            rgPoint[0].x = prc->left;
            rgPoint[0].y = iYCentre;
            rgPoint[1].x = prc->right - 1;
            rgPoint[1].y = iYCentre;
            rgPoint[2].x = prc->right - 1;
            rgPoint[2].y = iYCentre + 1;
            rgPoint[3].x = prc->left;
            rgPoint[3].y = iYCentre + 1;

            ASSERT(rgPoint[0].x >= prc->left && rgPoint[0].x < prc->right && rgPoint[0].y >= prc->top && rgPoint[0].y < prc->bottom);
            ASSERT(rgPoint[1].x >= prc->left && rgPoint[1].x < prc->right && rgPoint[1].y >= prc->top && rgPoint[1].y < prc->bottom);
            ASSERT(rgPoint[2].x >= prc->left && rgPoint[2].x < prc->right && rgPoint[2].y >= prc->top && rgPoint[2].y < prc->bottom);
            ASSERT(rgPoint[3].x >= prc->left && rgPoint[3].x < prc->right && rgPoint[3].y >= prc->top && rgPoint[3].y < prc->bottom);

            // draw the middle...
            Polyline( hdc, rgPoint, 4 );

            rgPoint[0].x = prc->right - 3;
            rgPoint[0].y = iYCentre;
            rgPoint[1].x = prc->right - 1;
            rgPoint[1].y = iYCentre - 2;
            rgPoint[2].x = prc->right - 1;
            rgPoint[2].y = iYCentre + 3;
            rgPoint[3].x = prc->right - 3;
            rgPoint[3].y = iYCentre + 1;

            ASSERT(rgPoint[0].x >= prc->left && rgPoint[0].x < prc->right && rgPoint[0].y >= prc->top && rgPoint[0].y < prc->bottom);
            ASSERT(rgPoint[1].x >= prc->left && rgPoint[1].x < prc->right && rgPoint[1].y >= prc->top && rgPoint[1].y < prc->bottom);
            ASSERT(rgPoint[2].x >= prc->left && rgPoint[2].x < prc->right && rgPoint[2].y >= prc->top && rgPoint[2].y < prc->bottom);
            ASSERT(rgPoint[3].x >= prc->left && rgPoint[3].x < prc->right && rgPoint[3].y >= prc->top && rgPoint[3].y < prc->bottom);

            // draw the bottom bit...
            Polyline( hdc, rgPoint, 4 );
        }
    }

    SelectObject( hdc, hOldPn );
    DeleteObject((HGDIOBJ)hPnMark);
}

BOOL CCGetIconSize(LPCCONTROLINFO pCI, HIMAGELIST himl, int* pcx, int* pcy)
{
    BOOL f = ImageList_GetIconSize(himl, pcx, pcy);
    if (f && pCI->fDPIAware)
    {
        CCDPIScaleX(pcx);
        CCDPIScaleY(pcy);
    }

    return f;
}

// The return value tells if the state changed or not (TRUE == change)
BOOL CCOnUIState(LPCCONTROLINFO pControlInfo,
                                  UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    WORD wOldUIState = pControlInfo->wUIState;

    // That's the only message we handle
    if (WM_UPDATEUISTATE == uMessage)
    {
        switch (LOWORD(wParam))
        {
            case UIS_SET:
                pControlInfo->wUIState |= HIWORD(wParam);
                break;

            case UIS_CLEAR:
                pControlInfo->wUIState &= ~(HIWORD(wParam));
                break;
        }
    }

    // These message always need to be passed to DefWindowProc
    return (wOldUIState != pControlInfo->wUIState);
}

BOOL CCNotifyNavigationKeyUsage(LPCCONTROLINFO pControlInfo, WORD wFlag)
{
    BOOL fRet = FALSE;

    // do something only if not already in keyboard mode
    if ((CCGetUIState(pControlInfo) & (UISF_HIDEFOCUS | UISF_HIDEACCEL)) != wFlag)
    {
        SendMessage(pControlInfo->hwndParent, WM_CHANGEUISTATE, 
            MAKELONG(UIS_CLEAR, wFlag), 0);

        pControlInfo->wUIState &= ~(wFlag);

        // we did the notify
        fRet = TRUE;
    }

    return fRet;
}

BOOL CCGetUIState(LPCCONTROLINFO pControlInfo)
{
    return pControlInfo->wUIState;
}



#ifdef FULL_DEBUG
void DebugPaintInvalid(HWND hwnd, RECT* prc, HRGN rgn)
{
    if (GetKeyState(VK_SCROLL) < 0)
    {
        HDC hdc;
        HBRUSH hbrush;
        int bkMode;
        static int s_iclr;
        static COLORREF s_aclr[] =
        {
                RGB(0,   0,   0), 
                RGB(255, 0,   0), 
                RGB(0,   255, 0),
                RGB(0,   0,   255),
                RGB(255, 255, 0), 
                RGB(0,   255, 255),
                RGB(255, 255, 255), 
                RGB(255, 0,   255),
        };

        s_iclr = (s_iclr + 1) % ARRAYSIZE(s_aclr);
        hdc = GetDC(hwnd);
        hbrush = CreateHatchBrush(HS_DIAGCROSS, s_aclr[s_iclr]);
        bkMode = SetBkMode(hdc, TRANSPARENT);
        if (rgn)
        {
            FillRgn(hdc, rgn, hbrush);
        }
        else
        {
            RECT rc;
            if (prc == NULL)
            {
                prc = &rc;
                GetClientRect(hwnd, &rc);
                OffsetRect(&rc, -rc.left, -rc.top);
            }

            FillRect(hdc, prc, hbrush);
        }
        DeleteObject((HGDIOBJ)hbrush);
        SetBkMode(hdc, bkMode);
        ReleaseDC(hwnd, hdc);

        if (GetKeyState(VK_SHIFT) < 0)
            Sleep(500);
        else
            Sleep(120);
    }
}

void DebugPaintClip(HWND hwnd, HDC hdc)
{
    if (GetKeyState(VK_SCROLL) < 0)
    {
        HDC hdcH = GetDC(hwnd);
        HRGN hrgn = CreateRectRgn(0, 0, 0, 0);
        GetClipRgn(hdc, hrgn);
        InvertRgn(hdcH, hrgn);

        if (GetKeyState(VK_SHIFT) < 0)
            Sleep(500);
        else
            Sleep(120);

        InvertRgn(hdcH, hrgn);

        DeleteObject(hrgn);

        ReleaseDC(hwnd, hdcH);
    }
}

void DebugPaintRect(HDC hdc, PRECT prc)
{
    if (GetKeyState(VK_SCROLL) < 0)
    {
        HRGN hrgn = CreateRectRgnIndirect(prc);
        InvertRgn(hdc, hrgn);

        if (GetKeyState(VK_SHIFT) < 0)
            Sleep(500);
        else
            Sleep(120);

        InvertRgn(hdc, hrgn);

        DeleteObject(hrgn);
    }
}
#endif



void SHOutlineRectThickness(HDC hdc, const RECT* prc, COLORREF cr, COLORREF crDefault, int cp)
{
    RECT rc;
    COLORREF clrSave = SetBkColor(hdc, cr == CLR_DEFAULT ? crDefault : cr);

    // See if we overflow the bounding rect
    if (IsRectEmpty(prc))
    {
        return;
    }
    
    //top
    rc.left = prc->left;
    rc.top = prc->top;
    rc.right = prc->right;
    rc.bottom = prc->top + cp;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    //left
    rc.left = prc->left;
    rc.top = prc->top;
    rc.right = prc->left + cp;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    //right
    rc.left = prc->right - cp;
    rc.top = prc->top;
    rc.right = prc->right;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    // bottom
    rc.left = prc->left;
    rc.top = prc->bottom - cp;
    rc.right = prc->right;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    SetBkColor(hdc, clrSave);
}

BOOL IsUsingCleartype()
{
    int iSmoothingType = FE_FONTSMOOTHINGSTANDARD;

    SystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, &iSmoothingType, 0);

    return FE_FONTSMOOTHINGCLEARTYPE == iSmoothingType;
}

BOOL UseMenuSelectionStyle()
{
    BOOL fUseNewSelectionStyle = FALSE;
    SystemParametersInfo(SPI_GETFLATMENU, 0, (PVOID)&fUseNewSelectionStyle, 0);
    return fUseNewSelectionStyle;
}


//#define NO_UXTHEME_PRINTING

// Gets the bits from the parent for a rect relative to the client
BOOL CCSendPrintRect(CCONTROLINFO* pci, HDC hdc, RECT* prc)
{
#ifndef NO_UXTHEME_PRINTING


    // Call into UxTheme to get the background image. They have hooks to
    // tell us if an app processed this message.
    return (S_OK == DrawThemeParentBackground(pci->hwnd, hdc, prc));


#else
    HRGN hrgnOld = NULL;
    POINT pt;
    RECT rc;

    if (prc)
    {
        hrgnOld = CreateRectRgn(0,0,0,0);
        // Is there a clipping rgn set on the context already?
        if (GetClipRgn(hdc, hrgnOld) == 0)
        {
            // No, then get rid of the one I just created. NOTE: hrgnOld is NULL meaning we will 
            // remove the region later that we set in this next call to SelectClipRgn
            DeleteObject(hrgnOld);
            hrgnOld = NULL;
        }

        IntersectClipRect(hdc, prc->left, prc->top, prc->right, prc->bottom);
    }

    GetWindowRect(pci->hwnd, &rc);
    MapWindowPoints(NULL, pci->hwndParent, (POINT*)&rc, 2);

    GetViewportOrgEx(hdc, &pt);
    SetViewportOrgEx(hdc, pt.x - rc.left, pt.y - rc.top, NULL);
    SendMessage(pci->hwndParent, WM_PRINTCLIENT, (WPARAM)hdc, (LPARAM)PRF_CLIENT);
    SetViewportOrgEx(hdc, pt.x, pt.y, NULL);

    if (hrgnOld)
    {
        SelectClipRgn(hdc, hrgnOld);
        DeleteObject(hrgnOld);
    }
    return TRUE;
#endif
}

// Gets the bits from the parent for the whole control
BOOL CCSendPrint(CCONTROLINFO* pci, HDC hdc)
{
#ifndef NO_UXTHEME_PRINTING


    // Call into UxTheme to get the background image. They have hooks to
    // tell us if an app processed this message.
    return (S_OK == DrawThemeParentBackground(pci->hwnd, hdc, NULL));



#else
    return CCSendPrintRect(pci, hdc, NULL);
#endif
}

BOOL CCForwardPrint(CCONTROLINFO* pci, HDC hdc)
{
#ifndef NO_UXTHEME_PRINTING


    // Call into UxTheme to get the background image. They have hooks to
    // tell us if an app processed this message.
    return (S_OK == DrawThemeParentBackground(pci->hwnd, hdc, NULL));



#else
    return CCSendPrintRect(pci, hdc, NULL);
#endif
}


BOOL CCShouldAskForBits(CCONTROLINFO* pci, HTHEME hTheme, int iPart, int iState)
{
    // If the control is transparent, we assume composited.
    return !(pci->dwExStyle & WS_EX_TRANSPARENT) &&
            IsThemeBackgroundPartiallyTransparent(hTheme, iPart, iState);
}

BOOL AreAllMonitorsAtLeast(int iBpp)
{
    DISPLAY_DEVICE DisplayDevice = {sizeof(DISPLAY_DEVICE)};
    BOOL fAreAllMonitorsAtLeast = TRUE;
    int iEnum = 0;

    while (EnumDisplayDevices(NULL, iEnum, &DisplayDevice, 0))
    {
        if (DisplayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP)
        {

            HDC hdc = CreateDC(NULL, (LPTSTR)DisplayDevice.DeviceName, NULL, NULL);
            if (hdc)
            {
                int iBits = GetDeviceCaps(hdc, BITSPIXEL);

                if (iBits < iBpp)
                    fAreAllMonitorsAtLeast = FALSE;

                DeleteDC(hdc);
            }
        }

        ZeroMemory(&DisplayDevice, sizeof(DISPLAY_DEVICE));
        DisplayDevice.cb = sizeof(DISPLAY_DEVICE);
        iEnum++;
    }

    return fAreAllMonitorsAtLeast;
}


int CCGetScreenDPI()
{
    return g_iDPI;
}

BOOL CCIsHighDPI()
{
    return g_fScale;
}

int CCScaleX(int x)
{
    if (g_fScale)
        x = (int)( x * g_dScaleX);

    return x;
}

int CCScaleY(int y)
{
    if (g_fScale)
        y = (int)( y * g_dScaleY);

    return y;
}

void CCDPIScaleX(int* x)
{
    if (g_fScale)
        *x = (int)( *x * g_dScaleX);
}

void CCDPIScaleY(int* y)
{
    if (g_fScale)
        *y = (int)( *y * g_dScaleY);
}

void CCDPIUnScaleX(int* x)
{
    if (g_fScale)
        *x = (int)( *x / g_dScaleX);
}

void CCDPIUnScaleY(int* y)
{
    if (g_fScale)
        *y = (int)( *y / g_dScaleY);
}



void CCAdjustForBold(LOGFONT* plf)
{
    ASSERT(plf);
    plf->lfWeight = FW_BOLD;
}

#ifdef DEBUG
void DumpRgn(ULONGLONG qwFlags, char* trace, HRGN hrgn)
{
    int iSize = GetRegionData(hrgn, 0, NULL);
    if (iSize > 0)
    {
        RGNDATA* rd = (RGNDATA*)LocalAlloc(LPTR, iSize + sizeof(RGNDATA));
        if (rd)
        {
            DWORD i;
            RECT* prc;

            rd->rdh.dwSize = sizeof(rd->rdh);
            rd->rdh.iType = RDH_RECTANGLES;
            GetRegionData(hrgn, iSize, rd);

            prc = (RECT*)&rd->Buffer;
            for (i = 0; i < rd->rdh.nCount; i++)
            {
                TraceMsg(qwFlags, "%s: %d, %d, %d, %d", trace, prc[i].left, prc[i].top, prc[i].right, prc[i].bottom);
            }


            LocalFree(rd);
        }
    }
}
#endif


HDC CCBeginDoubleBuffer(HDC hdcIn, RECT* prc, CCDBUFFER* pdb)
{
    HDC hdc = hdcIn;
    
    ZeroMemory(pdb, sizeof(CCDBUFFER));

    pdb->hPaintDC = hdcIn;
    pdb->rc = *prc;

    pdb->hMemDC = CreateCompatibleDC(hdcIn);
    if (pdb->hMemDC)
    {
        pdb->hMemBm = CreateCompatibleBitmap(hdc, RECTWIDTH(pdb->rc), RECTHEIGHT(pdb->rc));
        if (pdb->hMemBm)
        {

            pdb->hOldBm = (HBITMAP) SelectObject(pdb->hMemDC, pdb->hMemBm);

            // Offset painting to paint in region
            OffsetWindowOrgEx(pdb->hMemDC, pdb->rc.left, pdb->rc.top, NULL);

            pdb->fInitialized = TRUE;

            hdc = pdb->hMemDC;
        }
        else
        {
            DeleteDC(pdb->hMemDC);
        }
    }

    return hdc;
}


void CCEndDoubleBuffer(CCDBUFFER* pdb)
{
    if (pdb->fInitialized)
    {
        BitBlt(pdb->hPaintDC, pdb->rc.left, pdb->rc.top, RECTWIDTH(pdb->rc), RECTHEIGHT(pdb->rc), pdb->hMemDC, pdb->rc.left, pdb->rc.top, SRCCOPY);

        SelectObject(pdb->hMemDC, pdb->hOldBm);

        DeleteObject(pdb->hMemBm);
        DeleteDC(pdb->hMemDC);
    }
}

#ifdef FEATURE_FOLLOW_FOCUS_RECT
HWND g_hwndFocus = NULL;

void CCLostFocus(HWND hwnd)
{
//    if (g_hwndFocus)
//        DestroyWindow(g_hwndFocus);
//    g_hwndFocus = NULL;
}

HDC CreateLayer(RECT* prc)
{
    HDC hdc;
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = RECTWIDTH(*prc);
    bi.bmiHeader.biHeight = RECTHEIGHT(*prc);
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    hdc = CreateCompatibleDC(NULL);
    if (hdc)
    {
        ULONG* prgb;
        HBITMAP hbmp = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, (void**)&prgb, NULL, 0);
        if (hbmp)
        {
            int z;
            SIZE sz = {RECTWIDTH(*prc), RECTHEIGHT(*prc)};
            RECT rc = {0, 0, sz.cx, sz.cy};
            int iTotalSize = sz.cx * sz.cy;
            DeleteObject(SelectObject(hdc, hbmp));

            InflateRect(&rc, -2, -2);
            SHOutlineRectThickness(hdc, &rc, RGB(0,0,255), RGB(0,0,255), 1);
            for (z = 0; z < iTotalSize; z++)
            {
                if (((PULONG)prgb)[z] != 0)
                    ((PULONG)prgb)[z] = 0xa0000000;
            }

            BlurBitmap(prgb, sz, RGB(0,0,255));
            InflateRect(&rc, -2, -2);
            FillRectClr(hdc, &rc, RGB(0,0,0));
        }
    }

    return hdc;
}


typedef struct tagEffect
{
    HDC hdcImage;
    RECT rcCurrent;
    RECT rcSrc;
    RECT rcDest;
    int iStep;
} Effect;

#define EW_SETFOCUS    WM_USER+1
#define EW_LOSTFOCUS   WM_USER+2

void Effect_GenerateRect(Effect* pe, RECT* prc)
{
    HDC hdcWin = GetDC(g_hwndFocus);

    if (hdcWin)
    {
        BLENDFUNCTION bf = {0};
        POINT pt = {0};
        POINT ptDest = {pe->rcCurrent.left, pe->rcCurrent.top};
        SIZE sz = {RECTWIDTH(*prc), RECTHEIGHT(*prc)};
        if (pe->hdcImage)
            DeleteDC(pe->hdcImage);
        pe->hdcImage = CreateLayer(prc);

        bf.BlendOp = AC_SRC_OVER;
        bf.AlphaFormat = AC_SRC_ALPHA;
        bf.SourceConstantAlpha = 255;


        UpdateLayeredWindow(g_hwndFocus, hdcWin, &ptDest, &sz, pe->hdcImage, &pt, 0, &bf, ULW_ALPHA);

        SetWindowPos(g_hwndFocus, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOACTIVATE | SWP_SHOWWINDOW);

        ReleaseDC(g_hwndFocus, hdcWin);
    }
}


LRESULT EffectWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    Effect* pe = (Effect*)GetWindowLongPtr(hwnd, GWL_USERDATA);
    if ( pe == NULL)
    {
        if (uMsg == WM_NCCREATE)
        {
            pe = LocalAlloc(LPTR, sizeof(Effect));
            SetWindowLong(hwnd, GWL_USERDATA, (LONG)pe);
        }

        if (pe == NULL)
            return 0;
    }
    else switch (uMsg)
    {
    case EW_SETFOCUS:
        {
            RECT* prc = (RECT*)lParam;
            if (IsRectEmpty(&pe->rcCurrent))
                pe->rcSrc = pe->rcCurrent = *prc;

            pe->rcDest = *prc;

            Effect_GenerateRect(pe, prc);

            KillTimer(hwnd, 1);
            pe->rcSrc = pe->rcCurrent;
            pe->iStep = 1;
            SetTimer(hwnd, 2, 5, NULL);
        }
        break;
    case EW_LOSTFOCUS:
        //SetTimer(hwnd, 1, 100, NULL);
        break;

    case WM_TIMER:
        if (wParam == 1)
        {
            DestroyWindow(hwnd);
            g_hwndFocus = NULL;
        }
        else if (wParam == 2)
        {
            BLENDFUNCTION bf = {0};
            POINT pt = {0};
            POINT ptDest;
            SIZE sz;
            if (pe->iStep >= 20 || IsRectEmpty(&pe->rcCurrent) || EqualRect(&pe->rcCurrent, &pe->rcDest))
            {
                pe->rcCurrent = pe->rcDest;
                pe->iStep = 0;
                KillTimer(hwnd, 2);
            }
            else
            {
                pe->rcCurrent.top += (pe->rcDest.top - pe->rcSrc.top) / 20;
                pe->rcCurrent.left += (pe->rcDest.left - pe->rcSrc.left) / 20;
                pe->rcCurrent.right += (pe->rcDest.right - pe->rcSrc.right) / 20;
                pe->rcCurrent.bottom += (pe->rcDest.bottom - pe->rcSrc.bottom) / 20;
                pe->iStep++;
            }

            sz.cx = RECTWIDTH(pe->rcCurrent);
            sz.cy = RECTHEIGHT(pe->rcCurrent);

            ptDest.x = pe->rcCurrent.left;
            ptDest.y = pe->rcCurrent.top;

            Effect_GenerateRect(pe, &pe->rcCurrent);
        }
        break;

    case WM_DESTROY:
        if (pe->hdcImage)
            DeleteDC(pe->hdcImage);
        LocalFree(pe);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 1;
}

void CCSetFocus(HWND hwnd, RECT* prc)
{
    RECT rc;
    if (prc == NULL)
    {
        prc = &rc;
        GetWindowRect(hwnd, &rc);
    }

    InflateRect(prc, 4, 4);

    if (!g_hwndFocus)
    {
        WNDCLASS wc ={0};
        wc.hbrBackground = GetStockObject(BLACK_BRUSH);
        wc.hInstance = HINST_THISDLL;
        wc.lpfnWndProc = EffectWndProc;
        wc.lpszClassName = TEXT("Effect");

        RegisterClass(&wc);

        g_hwndFocus = CreateWindowEx(WS_EX_TRANSPARENT | WS_EX_LAYERED | WS_EX_TOOLWINDOW, TEXT("Effect"),
            NULL, WS_POPUP, prc->left, prc->top, RECTWIDTH(*prc), RECTHEIGHT(*prc), 
            NULL, NULL, HINST_THISDLL, NULL);
    }


    if (g_hwndFocus)
    {
        SendMessage(g_hwndFocus, EW_SETFOCUS, (WPARAM)hwnd, (LPARAM)prc);
    }
}

#endif

BOOL CCDrawNonClientTheme(HTHEME hTheme, HWND hwnd, HRGN hRgnUpdate, HBRUSH hbr, int iPartId, int iStateId)
{
    BOOL fRet = FALSE;
    HDC  hdc;
    DWORD dwFlags = DCX_USESTYLE | DCX_WINDOW | DCX_LOCKWINDOWUPDATE;

    if (hRgnUpdate)
        dwFlags |= DCX_INTERSECTRGN | DCX_NODELETERGN;


    hdc = GetDCEx(hwnd, hRgnUpdate, dwFlags);

    if (hdc)
    {
        RECT rc;
        HRGN hrgn;
        int  cxBorder = g_cxBorder, cyBorder = g_cyBorder;

        if (SUCCEEDED(GetThemeInt(hTheme, iPartId, iStateId, TMT_SIZINGBORDERWIDTH, &cxBorder)))
        {
            cyBorder = cxBorder;
        }

        GetWindowRect(hwnd, &rc);            

        //
        // Create an update region without the client edge
        // to pass to DefWindowProc
        //
        InflateRect(&rc, -g_cxEdge, -g_cyEdge);
        hrgn = CreateRectRgn(rc.left, rc.top, rc.right, rc.bottom);
        if (hrgn)
        {
            if (hRgnUpdate)
            {
                CombineRgn(hrgn, hRgnUpdate, hrgn, RGN_AND);
            }

            //
            // Zero-origin the rect
            //
            OffsetRect(&rc, -rc.left, -rc.top);

            //
            // clip our drawing to the non-client edge
            //
            OffsetRect(&rc, g_cxEdge, g_cyEdge);
            ExcludeClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
            InflateRect(&rc, g_cxEdge, g_cyEdge);

            DrawThemeBackground(hTheme, hdc, iPartId, iStateId, &rc, 0);

            //
            // Fill with the control's brush first since the ThemeBackground
            // border may not be as thick as the client edge
            //
            if ((cxBorder < g_cxEdge) && (cyBorder < g_cyEdge))
            {
                InflateRect(&rc, cxBorder-g_cxEdge, cyBorder-g_cyEdge);
                FillRect(hdc, &rc, hbr);
            }

            DefWindowProc(hwnd, WM_NCPAINT, (WPARAM)hrgn, 0);

            DeleteObject(hrgn);
        }

        ReleaseDC(hwnd, hdc);
        fRet = TRUE;
    }


    return fRet;
}

void FillRectClr(HDC hdc, PRECT prc, COLORREF clr)
{
    COLORREF clrSave = SetBkColor(hdc, clr);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, prc, NULL, 0, NULL);
    SetBkColor(hdc, clrSave);
}

void FillPointClr(HDC hdc, POINT* ppt, COLORREF clr)
{
    RECT rc={ppt->x, ppt->y, ppt->x+1, ppt->y+1};
    COLORREF clrSave = SetBkColor(hdc, clr);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    SetBkColor(hdc, clrSave);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\ddproxy.cpp ===
#include "ctlspriv.h"

//------------------------------------------------------------------------------

STDAPI GetItemObject(CCONTROLINFO *pci, UINT uMsg, const IID *piid, LPNMOBJECTNOTIFY pnon)
{
    pnon->piid = piid;
    pnon->pObject = NULL;
    pnon->hResult = E_NOINTERFACE;

    CCSendNotify(pci, uMsg, &pnon->hdr);

    ASSERT(SUCCEEDED(pnon->hResult) ? (pnon->pObject != NULL) : (pnon->pObject == NULL));

    return pnon->hResult;
}

//------------------------------------------------------------------------------

class CDragProxy : public IDropTarget
{

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *, DWORD, POINTL, DWORD *);
    STDMETHODIMP DragOver(DWORD, POINTL, DWORD *);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *, DWORD, POINTL, DWORD *);

    CDragProxy(HWND hwnd, PFNDRAGCB pfn);
    BOOL Register();
    void RevokeAndFreeCB();

private:
    ~CDragProxy();

    int          _cRef;             // object reference count
    HWND         _hwnd;             // window that owns us
    PFNDRAGCB    _pfnCallback;      // callback for that window
    IDataObject *_pdtobj;           // data object being dragged
    IDropTarget *_pdtgtItem;        // drop target of item under mouse
    int          _idItem;           // id of item under mouse
    DWORD        _dwFlags;
    int          _idDefault;        // id to use when outside a drag etc
    DWORD        _dwEffectItem;     // DROPEFFECT returned for item under mouse
    DWORD        _fKeysLast;        // key flags from last DragOver
    POINTL       _ptLast;           // location of last DragOver
    DWORD        _dwEffectLast;     // effect available from last DragOver
    HMODULE      _hmodOLE;          // OLE32 ref, also indicates we did a Register()

    void SetTargetItem(int id, DWORD dwFlags);
    void SetDropTarget(IDropTarget *pdt);
    void UpdateSelection(DWORD dwEffect);
    LRESULT CallCB(UINT code, WPARAM wp, LPARAM lp);
};

//------------------------------------------------------------------------------

STDAPI_(HDRAGPROXY) CreateDragProxy(HWND hwnd, PFNDRAGCB pfn, BOOL bRegister)
{
    CDragProxy *pdp = new CDragProxy(hwnd, pfn);

    //
    // register as needed
    //
    if (pdp && bRegister && !pdp->Register())
    {
        pdp->Release();
        pdp = NULL;
    }

    return (HDRAGPROXY)pdp;
}

STDAPI_(void) DestroyDragProxy(HDRAGPROXY hdp)
{
    if (hdp)
    {
        ((CDragProxy *)hdp)->RevokeAndFreeCB();
        ((CDragProxy *)hdp)->Release();
    }
}

STDAPI GetDragProxyTarget(HDRAGPROXY hdp, IDropTarget **ppdtgt)
{
    if (hdp)
    {
        *ppdtgt = SAFECAST((CDragProxy *)hdp, IDropTarget *);
        ((CDragProxy *)hdp)->AddRef();
        return NOERROR;
    }

    *ppdtgt = NULL;
    return E_FAIL;
}


//------------------------------------------------------------------------------

CDragProxy::CDragProxy(HWND hwnd, PFNDRAGCB pfn)
    :   _hwnd(hwnd), _pfnCallback(pfn),
        _cRef(1),
        _hmodOLE(NULL),
        _pdtobj(NULL),
        _pdtgtItem(NULL),
        _dwEffectItem(DROPEFFECT_NONE)
{
    _idDefault = _idItem = (int)CallCB(DPX_DRAGHIT, 0, 0);
}

CDragProxy::~CDragProxy()
{
    DragLeave();

}

HRESULT CDragProxy::QueryInterface(REFIID iid, void **ppv)
{
    if (IsEqualIID(iid, IID_IDropTarget) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = SAFECAST(this, IDropTarget *);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    _cRef++;
    return NOERROR;
}

ULONG CDragProxy::AddRef()
{
    return ++_cRef;
}

ULONG CDragProxy::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDragProxy::DragEnter(IDataObject *pdo, DWORD fKeys, POINTL pt, DWORD *pdwEffect)
{
    //
    // some sanity
    //
    ASSERT(!_pdtgtItem);
    ASSERT(!_pdtobj);

    if (!pdo)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    //
    // make sure our callback will allow us to do d/d now
    //
    if (!CallCB(DPX_ENTER, 0, 0))
        return E_FAIL;

    //
    // save away the data object
    //
    pdo->AddRef();
    _pdtobj = pdo;

    //
    // and process this like a DragOver
    //
    DragOver(fKeys, pt, pdwEffect);

    //
    // always succeed DragEnter
    //
    return NOERROR;
}

HRESULT CDragProxy::DragLeave()
{
    //
    // release any drop target that we are holding
    //
    SetDropTarget(NULL);
    _idItem = _idDefault;

    //
    // if we had a data object then we were actually dragging
    //
    if (_pdtobj)
    {
        CallCB(DPX_LEAVE, 0, 0);

        IDataObject* p = _pdtobj;
        _pdtobj = NULL;
        p->Release();
    }

    //
    // all done
    //
    return NOERROR;
}

HRESULT CDragProxy::DragOver(DWORD fKeys, POINTL pt, DWORD *pdwEffect)
{
    DWORD dwFlags = 0;
    HRESULT hres;
    int id;
    ASSERT(_pdtobj);

    //
    // save the current drag state
    //
    _fKeysLast    = fKeys;
    _ptLast       = pt;
    _dwEffectLast = *pdwEffect;

    //
    // make sure we have the correct drop target for this location
    //
    id = (int)CallCB(DPX_DRAGHIT, (WPARAM)&dwFlags, (LPARAM)&pt);
    SetTargetItem(id, dwFlags);
    //
    // do we have a target to drop on?
    //
    if (_pdtgtItem)
    {
        //
        // forward the DragOver along to the item's drop target (if any)
        //
        hres = _pdtgtItem->DragOver(fKeys, pt, pdwEffect);
    }
    else
    {
        //
        // can't drop here
        //
        *pdwEffect = DROPEFFECT_NONE;
        hres = NOERROR;
    }

    //
    // and update our selection state accordingly
    //
    UpdateSelection(*pdwEffect);

    return hres;
}

HRESULT CDragProxy::Drop(IDataObject *pdo, DWORD fKeys, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hres;

    AddRef();

    //
    // do we have a target to drop on?
    //
    if (_pdtgtItem)
    {
        // From a comment in browseui, there's apparently a chance to put up UI
        // which could cause us to get re-entered.  Hard to believe, but see if
        // this fixes the fault:
        //
        IDropTarget * pdtCur = _pdtgtItem;
        _pdtgtItem = NULL;

        //
        // do the drop
        //
        hres = pdtCur->Drop(pdo, fKeys, pt, pdwEffect);

        //
        // we call our DragLeave below but we don't want the item's to be
        // called (since it already saw the Drop) so we release right away
        //
        pdtCur->Release();
    }
    else
    {
        //
        // can't drop here
        //
        *pdwEffect = DROPEFFECT_NONE;
        hres = NOERROR;
    }

    //
    // now clean up
    //
    DragLeave();

    Release();

    return hres;
}

void CDragProxy::SetTargetItem(int id, DWORD dwFlags)
{
    //
    // anything to do?
    //
    if (id == _idItem && dwFlags == _dwFlags)
        return;

    //
    // deselect the old item (if any)
    //
    // the GETOBJECT below could take a long time and we don't want a
    // lingering highlight on the object we are leaving
    //

    UpdateSelection(DROPEFFECT_NONE);

    //
    // get a drop target for the new item
    //
    _idItem = id;
    _dwFlags = dwFlags;

    NMOBJECTNOTIFY non;
    non.iItem = id;
    non.dwFlags = dwFlags;
    if (!_pdtobj || FAILED((HRESULT)CallCB(DPX_GETOBJECT, 0, (LPARAM)&non)))
        non.pObject = NULL;

        //
    // use this drop target (if any)
    //
    SetDropTarget((IDropTarget*)non.pObject);

    //
    // release our ref from the GETOBJECT above
    //
    if (non.pObject)
        ((IDropTarget*)non.pObject)->Release();
}

void CDragProxy::SetDropTarget(IDropTarget *pdt)
{
    //
    // NOTE: we intentionally skip the test for drop-target equality here
    // this allows controls owners to share a target among multiple items
    // while retaining the proper leave/enter sequence...
    //
    // BOGUS: we should actually compare here when the Internet Toolbar gets
    //  fixed (see comment in CDragProxy::SetTargetItem).  anybody who wants
    //  to share a target like this should just do the right hit-testing in
    //  their DragOver implementation
    //


    //
    // make sure nothing is selected
    //
    UpdateSelection(DROPEFFECT_NONE);

    //
    // leave/release the old item
    //
    if (_pdtgtItem)
    {
        _pdtgtItem->DragLeave();
        _pdtgtItem->Release();
    }

    //
    // store the new item
    //
    _pdtgtItem = pdt;

    //
    // addref/enter the new item
    //
    if (_pdtgtItem)
    {
        ASSERT(_pdtobj);    // must have a data object by now

        _pdtgtItem->AddRef();

        DWORD dwEffect = _dwEffectLast;
        if (FAILED(_pdtgtItem->DragEnter(_pdtobj, _fKeysLast, _ptLast, &dwEffect)))
            dwEffect = DROPEFFECT_NONE;

        //
        // update the selection
        //
        UpdateSelection(dwEffect);
    }
}

void CDragProxy::UpdateSelection(DWORD dwEffect)
{
    //
    // anything to do?
    //
    if (dwEffect == _dwEffectItem)
        return;

    //
    // update the flags and tell the callback they changed
    //
    _dwEffectItem = dwEffect;
    CallCB(DPX_SELECT, (WPARAM)_idItem, (LPARAM)dwEffect);
}

LRESULT CDragProxy::CallCB(UINT code, WPARAM wp, LPARAM lp)
{
    return _pfnCallback ? _pfnCallback(_hwnd, code, wp, lp) : (LRESULT)-1;
}

BOOL CDragProxy::Register()
{
    if (SUCCEEDED(CoInitialize(NULL)))
    {
        if (SUCCEEDED(RegisterDragDrop(_hwnd, this)))
            return TRUE;

        CoUninitialize();
    }
    return FALSE;
}

void CDragProxy::RevokeAndFreeCB()
{
    RevokeDragDrop(_hwnd);
    CoUninitialize();
    _pfnCallback = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\ctlspriv.h ===
#undef STRICT
#define STRICT

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntlsa.h"

#ifndef RC_INVOKED
// disable "non-standard extension" warnings in out code
#pragma warning(disable:4001)

// disable "nonstandard extension used : zero-sized array in struct/union"
// warning from immp.h
#pragma warning(disable:4200)
#endif

#include <w4warn.h>
/*
 *   Level 4 warnings to be turned on.
 *   Do not disable any more level 4 warnings.
 */
#pragma warning(disable:4127) // conditional expression is constant
#pragma warning(disable:4305) // 'type cast' : truncation from 'LPWSTR ' to 'WORD'
#pragma warning(disable:4189) // 'cyRet' : local variable is initialized but not referenced
#pragma warning(disable:4328) // indirection alignment of formal parameter 1 (4) is greater than the actual argument alignment (2)
#pragma warning(disable:4245) // 'initializing' : conversion from 'const int' to 'UINT', signed/unsigned mismatch
#pragma warning(disable:4706) // <func:#77> assignment within conditional expression
#pragma warning(disable:4701) // local variable 'crOldTextColor' may be used without having been initialized
#pragma warning(disable:4057) // 'function' : 'LONG *__ptr64 ' differs in indirection to slightly different base types 'UINT *__ptr64 '
#pragma warning(disable:4267) // 'initializing' : conversion from 'size_t' to 'UINT', possible loss of data
#pragma warning(disable:4131) // 'ComboBox_NcDestroyHandler' : uses old-style declarator
#pragma warning(disable:4310) // cast truncates constant value
#pragma warning(disable:4306) // 'type cast' : conversion from 'BYTE' to 'DWORD *__ptr64 ' of greater size
#pragma warning(disable:4054) // 'type cast' : from function pointer 'FARPROC ' to data pointer 'PLPKEDITCALLOUT '
#pragma warning(disable:4055) // 'type cast' : from data pointer 'IStream *__ptr64 ' to function pointer 'FARPROC '
#pragma warning(disable:4221) // nonstandard extension used : 'lprcClip' : cannot be initialized using address of automatic variable 'rcClip'
#pragma warning(disable:4702) // <func:#191 ".ListView_RedrawSelection"> unreachable code
#pragma warning(disable:4327) // '=' : indirection alignment of LHS (4) is greater than RHS (2)
#pragma warning(disable:4213) // nonstandard extension used : cast on l-value
#pragma warning(disable:4210) // nonstandard extension used : function given file scope


#define _COMCTL32_
#define _INC_OLE
#define _SHLWAPI_
#define CONST_VTABLE

#define CC_INTERNAL
#define OEMRESOURCE     // Get the OEM bitmaps OBM_XXX from winuser.h
#include <windows.h>
#include <uxtheme.h>
#include <tmschema.h>
#include <windowsx.h>
#include <ole2.h>               // to get IStream for image.c
#include <commctrl.h>
#include <wingdip.h>
#include <winuserp.h>
#define NO_SHLWAPI_UNITHUNK     // We have our own private thunks
#include <shlwapi.h>
#include <port32.h>

#define DISALLOW_Assert
#include <debug.h>
#include <winerror.h>
#include <ccstock.h>
#include <imm.h>
#include <immp.h>

#include <shfusion.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


#include "thunk.h"      // Ansi / Wide string conversions
#include "mem.h"
#include "rcids.h"
#include "cstrings.h"

#include "shobjidl.h"
#include <CommonControls.h>
#include "shpriv.h"

#ifndef DS_BIDI_RTL
#define DS_BIDI_RTL  0x8000
#endif

#define REGSTR_EXPLORER_ADVANCED TEXT("software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")


#define DCHF_TOPALIGN       0x00000002  // default is center-align
#define DCHF_HORIZONTAL     0x00000004  // default is vertical
#define DCHF_HOT            0x00000008  // default is flat
#define DCHF_PUSHED         0x00000010  // default is flat
#define DCHF_FLIPPED        0x00000020  // if horiz, default is pointing right
                                        // if vert, default is pointing up
#define DCHF_TRANSPARENT    0x00000040
#define DCHF_INACTIVE       0x00000080
#define DCHF_NOBORDER       0x00000100

extern void DrawCharButton(HDC hdc, LPRECT lprc, UINT wControlState, TCHAR ch, COLORREF rgbOveride);
extern void DrawScrollArrow(HDC hdc, LPRECT lprc, UINT wControlState, COLORREF rgbOveride);
extern void DrawChevron(HTHEME hTheme, int iPartId, HDC hdc, LPRECT lprc, DWORD dwFlags);


#define EVENT_OBJECT_CREATE             0x8000
#define EVENT_OBJECT_DESTROY            0x8001
#define EVENT_OBJECT_SHOW               0x8002
#define EVENT_OBJECT_HIDE               0x8003
#define EVENT_OBJECT_REORDER            0x8004
#define EVENT_OBJECT_FOCUS              0x8005
#define EVENT_OBJECT_SELECTION          0x8006
#define EVENT_OBJECT_SELECTIONADD       0x8007
#define EVENT_OBJECT_SELECTIONREMOVE    0x8008
#define EVENT_OBJECT_SELECTIONWITHIN    0x8009
#define EVENT_OBJECT_STATECHANGE        0x800A
#define EVENT_OBJECT_LOCATIONCHANGE     0x800B
#define EVENT_OBJECT_NAMECHANGE         0x800C
#define EVENT_OBJECT_DESCRIPTIONCHANGE  0x800D
#define EVENT_OBJECT_VALUECHANGE        0x800E

#define EVENT_SYSTEM_SOUND              0x0001
#define EVENT_SYSTEM_ALERT              0x0002
#define EVENT_SYSTEM_SCROLLINGSTART     0x0012
#define EVENT_SYSTEM_SCROLLINGEND       0x0013

// Secret SCROLLBAR index values
#define INDEX_SCROLLBAR_SELF            0
#define INDEX_SCROLLBAR_UP              1
#define INDEX_SCROLLBAR_UPPAGE          2
#define INDEX_SCROLLBAR_THUMB           3
#define INDEX_SCROLLBAR_DOWNPAGE        4
#define INDEX_SCROLLBAR_DOWN            5

#define INDEX_SCROLLBAR_MIC             1
#define INDEX_SCROLLBAR_MAC             5

#define INDEX_SCROLLBAR_LEFT            7
#define INDEX_SCROLLBAR_LEFTPAGE        8
#define INDEX_SCROLLBAR_HORZTHUMB       9
#define INDEX_SCROLLBAR_RIGHTPAGE       10
#define INDEX_SCROLLBAR_RIGHT           11

#define INDEX_SCROLLBAR_HORIZONTAL      6
#define INDEX_SCROLLBAR_GRIP            12

#define CHILDID_SELF                    0
#define INDEXID_OBJECT                  0
#define INDEXID_CONTAINER               0

#ifndef WM_GETOBJECT
#define WM_GETOBJECT                    0x003D
#endif

#define MSAA_CLASSNAMEIDX_BASE 65536L

#define MSAA_CLASSNAMEIDX_LISTBOX    (MSAA_CLASSNAMEIDX_BASE+0)
#define MSAA_CLASSNAMEIDX_BUTTON     (MSAA_CLASSNAMEIDX_BASE+2)
#define MSAA_CLASSNAMEIDX_STATIC     (MSAA_CLASSNAMEIDX_BASE+3)
#define MSAA_CLASSNAMEIDX_EDIT       (MSAA_CLASSNAMEIDX_BASE+4)
#define MSAA_CLASSNAMEIDX_COMBOBOX   (MSAA_CLASSNAMEIDX_BASE+5)
#define MSAA_CLASSNAMEIDX_SCROLLBAR  (MSAA_CLASSNAMEIDX_BASE+10)
#define MSAA_CLASSNAMEIDX_STATUS     (MSAA_CLASSNAMEIDX_BASE+11)
#define MSAA_CLASSNAMEIDX_TOOLBAR    (MSAA_CLASSNAMEIDX_BASE+12)
#define MSAA_CLASSNAMEIDX_PROGRESS   (MSAA_CLASSNAMEIDX_BASE+13)
#define MSAA_CLASSNAMEIDX_ANIMATE    (MSAA_CLASSNAMEIDX_BASE+14)
#define MSAA_CLASSNAMEIDX_TAB        (MSAA_CLASSNAMEIDX_BASE+15)
#define MSAA_CLASSNAMEIDX_HOTKEY     (MSAA_CLASSNAMEIDX_BASE+16)
#define MSAA_CLASSNAMEIDX_HEADER     (MSAA_CLASSNAMEIDX_BASE+17)
#define MSAA_CLASSNAMEIDX_TRACKBAR   (MSAA_CLASSNAMEIDX_BASE+18)
#define MSAA_CLASSNAMEIDX_LISTVIEW   (MSAA_CLASSNAMEIDX_BASE+19)
#define MSAA_CLASSNAMEIDX_UPDOWN     (MSAA_CLASSNAMEIDX_BASE+22)
#define MSAA_CLASSNAMEIDX_TOOLTIPS   (MSAA_CLASSNAMEIDX_BASE+24)
#define MSAA_CLASSNAMEIDX_TREEVIEW   (MSAA_CLASSNAMEIDX_BASE+25)
//
// End BOGUS insertion from \win\core\access\inc32\winable.h
//

#ifdef MAXINT
#undef MAXINT
#endif
#define MAXINT  (int)0x7FFFFFFF
// special value for pt.y or cyLabel indicating recomputation needed
// NOTE: icon ordering code considers (RECOMPUTE, RECOMPUTE) at end
// of all icons
//
#define RECOMPUTE  (DWORD)MAXINT
#define SRECOMPUTE ((short)0x7FFF)

#define RECTWIDTH(rc) ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)
#define ABS(i)  (((i) < 0) ? -(i) : (i))
#define BOUND(x,low,high)   max(min(x, high),low)

#define LPARAM_TO_POINT(lParam, pt)       ((pt).x = LOWORD(lParam), \
                                           (pt).y = HIWORD(lParam))

// common control info stuff

typedef struct tagControlInfo 
{
    HWND        hwnd;
    HWND        hwndParent;
    DWORD       style;
    DWORD       dwCustom;
    BITBOOL     bUnicode : 1;
    BITBOOL     bInFakeCustomDraw:1;
    BITBOOL     fDPIAware:1;
    UINT        uiCodePage;
    DWORD       dwExStyle;
    LRESULT     iVersion;
    WORD        wUIState;
} CCONTROLINFO, *LPCCONTROLINFO;

#define CCDPIScale(ci)  ((ci).fDPIAware)

BOOL CCGetIconSize(LPCCONTROLINFO pCI, HIMAGELIST himl, int* pcx, int* pcy);
BOOL CCOnUIState(LPCCONTROLINFO pCI, UINT uMessage, WPARAM wParam, LPARAM lParam);
BOOL CCGetUIState(LPCCONTROLINFO pControlInfo);
BOOL CCNotifyNavigationKeyUsage(LPCCONTROLINFO pControlInfo, WORD wFlag);
BOOL CCWndProc(CCONTROLINFO* pci, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
void CCDrawInsertMark(HDC hdc, LPRECT prc, BOOL fHorizMode, COLORREF clr);
void CIInitialize(LPCCONTROLINFO lpci, HWND hwnd, LPCREATESTRUCT lpcs);
LRESULT CIHandleNotifyFormat(LPCCONTROLINFO lpci, LPARAM lParam);
DWORD CICustomDrawNotify(LPCCONTROLINFO lpci, DWORD dwStage, LPNMCUSTOMDRAW lpnmcd);
DWORD CIFakeCustomDrawNotify(LPCCONTROLINFO lpci, DWORD dwStage, LPNMCUSTOMDRAW lpnmcd);
UINT RTLSwapLeftRightArrows(CCONTROLINFO *pci, WPARAM wParam);
UINT CCSwapKeys(WPARAM wParam, UINT vk1, UINT vk2);
LPTSTR CCReturnDispInfoText(LPTSTR pszSrc, LPTSTR pszDest, UINT cchDest);

void FillRectClr(HDC hdc, PRECT prc, COLORREF clr);
void FillPointClr(HDC hdc, POINT* ppt, COLORREF clr);


//
// helpers for drag-drop enabled controls
//
typedef LRESULT (*PFNDRAGCB)(HWND hwnd, UINT code, WPARAM wp, LPARAM lp);
#define DPX_DRAGHIT   (0)  // WP = (unused)  LP = POINTL*         ret = item id
#define DPX_GETOBJECT (1)  // LP = nmobjectnotify   ret = HRESULT
#define DPX_SELECT    (2)  // WP = item id   LP = DROPEFFECT_     ret = (unused)
#define DPX_ENTER     (3)  // WP = (unused)  LP = (unused)        ret = BOOL
#define DPX_LEAVE     (4)  // WP = (unused)  LP = (unused)        ret = (unused)


// ddproxy.cpp

DECLARE_HANDLE(HDRAGPROXY);

STDAPI_(HDRAGPROXY) CreateDragProxy(HWND hwnd, PFNDRAGCB pfn, BOOL bRegister);
STDAPI_(void) DestroyDragProxy(HDRAGPROXY hdp);
STDAPI GetDragProxyTarget(HDRAGPROXY hdp, IDropTarget **ppdtgt);
STDAPI GetItemObject(CCONTROLINFO *, UINT, const IID *, LPNMOBJECTNOTIFY);
STDAPI_(struct IImgCtx *) CBitmapImgCtx_Create(HBITMAP hbm);

#define SWAP(x,y, _type)  { _type i; i = x; x = y; y = i; }

//
// This is for widened dispatch loop stuff
//
#ifdef WIN32
typedef MSG MSG32;
typedef MSG32 *     LPMSG32;

#define GetMessage32(lpmsg, hwnd, min, max, f32)        GetMessage(lpmsg, hwnd, min, max)
#define PeekMessage32(lpmsg, hwnd, min, max, flags, f32)       PeekMessage(lpmsg, hwnd, min, max, flags)
#define TranslateMessage32(lpmsg, f32)  TranslateMessage(lpmsg)
#define DispatchMessage32(lpmsg, f32)   DispatchMessage(lpmsg)
#define CallMsgFilter32(lpmsg, u, f32)  CallMsgFilter(lpmsg, u)
#define IsDialogMessage32(hwnd, lpmsg, f32)   IsDialogMessage(hwnd, lpmsg)
#else


// This comes from ..\..\inc\usercmn.h--but I can't get commctrl to compile
// when I include it and I don't have the time to mess with this right now.

// DWORD wParam MSG structure
typedef struct tagMSG32
{
    HWND    hwnd;
    UINT    message;
    WPARAM  wParam;
    LPARAM  lParam;
    DWORD   time;
    POINT   pt;

    WPARAM  wParamHi;
} MSG32,* LPMSG32;

BOOL    WINAPI GetMessage32(LPMSG32, HWND, UINT, UINT, BOOL);
BOOL    WINAPI PeekMessage32(LPMSG32, HWND, UINT, UINT, UINT, BOOL);
BOOL    WINAPI TranslateMessage32(const MSG32*, BOOL);
LONG    WINAPI DispatchMessage32(const MSG32*, BOOL);
BOOL    WINAPI CallMsgFilter32(LPMSG32, int, BOOL);
BOOL    WINAPI IsDialogMessage32(HWND, LPMSG32, BOOL);

#endif // WIN32

//
// This is a very important piece of performance hack for non-DBCS codepage.
//
// was !defined(DBCS) || defined(UNICODE)

// FastCharNext and FastCharPrev are like CharNext and CharPrev except that
// they don't check if you are at the beginning/end of the string.

#define FastCharNext(pch) ((pch)+1)
#define FastCharPrev(pchStart, pch) ((pch)-1)

#define CH_PREFIX TEXT('&')


#ifdef UNICODE
#define lstrfns_StrEndN         lstrfns_StrEndNW
#define ChrCmp                  ChrCmpW
#define ChrCmpI                 ChrCmpIW

#else
#define lstrfns_StrEndN         lstrfns_StrEndNA
#define ChrCmp                  ChrCmpA
#define ChrCmpI                 ChrCmpIA

#endif
BOOL ChrCmpIA(WORD w1, WORD wMatch);
BOOL ChrCmpIW(WCHAR w1, WCHAR wMatch);
void  TruncateString(char *sz, int cch); // from strings.c

void InitGlobalMetrics(WPARAM);
void InitGlobalColors();

BOOL InitToolbarClass(HINSTANCE hInstance);
BOOL InitReBarClass(HINSTANCE hInstance);
BOOL InitToolTipsClass(HINSTANCE hInstance);
BOOL InitStatusClass(HINSTANCE hInstance);
BOOL InitHeaderClass(HINSTANCE hInstance);
BOOL InitButtonListBoxClass(HINSTANCE hInstance);
BOOL InitTrackBar(HINSTANCE hInstance);
BOOL InitUpDownClass(HINSTANCE hInstance);
BOOL InitProgressClass(HINSTANCE hInstance);
BOOL InitHotKeyClass(HINSTANCE hInstance);
BOOL InitToolTips(HINSTANCE hInstance);
BOOL InitDateClasses(HINSTANCE hinst);
BOOL InitButtonClass(HINSTANCE hinst);
BOOL InitStaticClass(HINSTANCE hinst);
BOOL InitEditClass(HINSTANCE hinst);
BOOL InitLinkClass(HINSTANCE hinst);
BOOL InitListBoxClass(HINSTANCE hinst);
BOOL InitComboboxClass(HINSTANCE hInstance);
BOOL InitComboLBoxClass(HINSTANCE hInstance);
BOOL InitScrollBarClass(HINSTANCE hInstance);
BOOL InitReaderModeClass(HINSTANCE hinst);

VOID InitEditLpk(VOID);

BOOL ChildOfActiveWindow(HWND hwnd);

/* cutils.c */

HFONT CCCreateUnderlineFont(HFONT hf);
HFONT CCGetHotFont(HFONT hFont, HFONT *phFontHot);
HFONT CCCreateStatusFont(void);
BOOL CCForwardEraseBackground(HWND hwnd, HDC hdc);
void CCPlaySound(LPCTSTR lpszName);
BOOL CheckForDragBegin(HWND hwnd, int x, int y);
void NewSize(HWND hWnd, int nHeight, LONG style, int left, int top, int width, int height);
BOOL MGetTextExtent(HDC hdc, LPCTSTR lpstr, int cnt, int * pcx, int * pcy);
void RelayToToolTips(HWND hwndToolTips, HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
int StripAccelerators(LPTSTR lpszFrom, LPTSTR lpszTo, BOOL fAmpOnly);
UINT GetCodePageForFont (HFONT hFont);
void* CCLocalReAlloc(void* p, UINT uBytes);
LONG GetMessagePosClient(HWND hwnd, LPPOINT ppt);
void FlipRect(LPRECT prc);
DWORD SetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue);
BOOL CCDrawEdge(HDC hdc, LPRECT lprc, UINT edge, UINT flags, LPCOLORSCHEME lpclrsc);
BOOL CCThemeDrawEdge(HTHEME hTheme, HDC hdc, LPRECT lprc, int iPart, int iState, UINT edge, UINT flags, LPCOLORSCHEME lpclrsc);
void CCInvalidateFrame(HWND hwnd);
void FlipPoint(LPPOINT lppt);
void CCSetInfoTipWidth(HWND hwndOwner, HWND hwndToolTips);
#define CCResetInfoTipWidth(hwndOwner, hwndToolTips) \
    SendMessage(hwndToolTips, TTM_SETMAXTIPWIDTH, 0, -1)

// Incremental search
typedef struct ISEARCHINFO 
{
    int iIncrSearchFailed;
    LPTSTR pszCharBuf;                  // isearch string lives here
    int cbCharBuf;                      // allocated size of pszCharBuf
    int ichCharBuf;                     // number of live chars in pszCharBuf
    DWORD timeLast;                     // time of last input event
#if defined(FE_IME) || !defined(WINNT)
    BOOL fReplaceCompChar;
#endif

} ISEARCHINFO, *PISEARCHINFO;

#if defined(FE_IME) || !defined(WINNT)
BOOL IncrementSearchImeCompStr(PISEARCHINFO pis, BOOL fCompStr, LPTSTR lpszCompChar, LPTSTR *lplpstr);
#endif
BOOL IncrementSearchString(PISEARCHINFO pis, UINT ch, LPTSTR *lplpstr);
int GetIncrementSearchString(PISEARCHINFO pis, LPTSTR lpsz);
int GetIncrementSearchStringA(PISEARCHINFO pis, UINT uiCodePage, LPSTR lpsz);
void IncrementSearchBeep(PISEARCHINFO pis);

#define IncrementSearchFree(pis) ((pis)->pszCharBuf ? Free((pis)->pszCharBuf) : 0)

// For RTL mirroring use
void MirrorBitmapInDC( HDC hdc , HBITMAP hbmOrig );

BOOL CCForwardPrint(CCONTROLINFO* pci, HDC hdc);
BOOL CCSendPrint(CCONTROLINFO* pci, HDC hdc);
BOOL CCSendPrintRect(CCONTROLINFO* pci, HDC hdc, RECT* prc);

// consider folding hTheme in with CControlInfo
BOOL CCShouldAskForBits(CCONTROLINFO* pci, HTHEME hTheme, int iPart, int iState);

BOOL AreAllMonitorsAtLeast(int iBpp);
void BlurBitmap(ULONG* plBitmapBits, int cx, int cy, COLORREF crFill);
int CCGetScreenDPI();
void CCDPIScaleX(int* x);
void CCDPIScaleY(int* y);
int CCScaleX(int x);
int CCScaleY(int y);
void CCDPIUnScaleX(int* x);
void CCDPIUnScaleY(int* y);
BOOL CCIsHighDPI();
void CCAdjustForBold(LOGFONT* plf);

typedef struct tagCCDBUFFER
{
    BOOL fInitialized;
    HDC hMemDC;
    HBITMAP hMemBm;
    HBITMAP hOldBm;
    HDC hPaintDC;
    RECT rc;
} CCDBUFFER;

HDC CCBeginDoubleBuffer(HDC hdcIn, RECT* prc, CCDBUFFER* pdb);
void CCEndDoubleBuffer(CCDBUFFER* pdb);

#ifdef FEATURE_FOLLOW_FOCUS_RECT
void CCSetFocus(HWND hwnd, RECT* prc);
void CCLostFocus(HWND hwnd);
#endif

BOOL CCDrawNonClientTheme(HTHEME hTheme, HWND hwnd, HRGN hRgnUpdate, HBRUSH hbr, int iPartId, int iStateId);

BOOL DSA_ForceGrow(HDSA hdsa, int iNumberToAdd);

#ifdef DEBUG
void DumpRgn(ULONGLONG qwFlags, char*trace, HRGN hrgn);
#else
#define DumpRgn(qwFlags, trace, hrgn)     0
#endif

// Locale manipulation (prsht.c)
//
//  The "proper thread locale" is the thread locale we should
//  be using for our UI elements.
//
//  If you need to change the thread locale temporarily
//  to the proper thread locale, use
//
//  LCID lcidPrev;
//  CCSetProperThreadLocale(&lcidPrev);
//  munge munge munge
//  CCRestoreThreadLocale(lcidPrev);
//
//  If you just want to retrieve the proper thread locale,
//  call CCGetProperThreadLocale(NULL).
//
//
LCID CCGetProperThreadLocale(OPTIONAL LCID *plcidPrev);

__inline void CCSetProperThreadLocale(LCID *plcidPrev) {
    SetThreadLocale(CCGetProperThreadLocale(plcidPrev));
}

#define CCRestoreThreadLocale(lcid) SetThreadLocale(lcid)

int CCLoadStringExInternal(HINSTANCE hInst, UINT uID, LPWSTR lpBuffer, int nBufferMax, WORD wLang);
int CCLoadStringEx(UINT uID, LPWSTR lpBuffer, int nBufferMax, WORD wLang);
int LocalizedLoadString(UINT uID, LPWSTR lpBuffer, int nBufferMax);
HRSRC FindResourceExRetry(HMODULE hmod, LPCTSTR lpType, LPCTSTR lpName, WORD wLang);

// assign most unlikely used value for the fake sublang id
#define SUBLANG_JAPANESE_ALTFONT 0x3f // max within 6bit

// used to get resource lang of shell32
#define DLG_EXITWINDOWS         1064

//
// Plug UI Setting funcions (commctrl.c)
//
LANGID WINAPI GetMUILanguage(void);

#ifdef UNICODE
//
// Tooltip thunking api's
//

BOOL ThunkToolTipTextAtoW (LPTOOLTIPTEXTA lpTttA, LPTOOLTIPTEXTW lpTttW, UINT uiCodePage);

#endif

HWND GetDlgItemRect(HWND hDlg, int nIDItem, LPRECT prc);

//
// Global variables
//
extern HINSTANCE g_hinst;
extern UINT uDragListMsg;
extern int g_iIncrSearchFailed;
extern ATOM g_atomThemeScrollBar;
extern UINT g_uiACP;
#ifndef QWORD
#define QWORD unsigned __int64
#endif
extern QWORD qw128;
extern QWORD qw1;

#define g_bMirroredOS TRUE
    
//
// Icon mirroring stuff
//
extern HDC g_hdc;
extern HDC g_hdcMask;


#define HINST_THISDLL   g_hinst

#ifdef WIN32

#ifdef DEBUG
#undef SendMessage
#define SendMessage  SendMessageD
#ifdef __cplusplus
extern "C"
{
#endif
LRESULT WINAPI SendMessageD(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int WINAPI Str_GetPtr0(LPCTSTR pszCurrent, LPTSTR pszBuf, int cchBuf);
#ifdef __cplusplus
}
#endif
#else  // !DEBUG
#define Str_GetPtr0     Str_GetPtr
#endif // DEBUG / !DEBUG

#endif // WIN32

// REVIEW, should this be a function? (inline may generate a lot of code)
#define CBBITMAPBITS(cx, cy, cPlanes, cBitsPerPixel)    \
        (((((cx) * (cBitsPerPixel) + 15) & ~15) >> 3)   \
        * (cPlanes) * (cy))

#define WIDTHBYTES(cx, cBitsPerPixel)   \
        ((((cx) * (cBitsPerPixel) + 31) / 32) * 4)

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))                          /* ;Internal */

#define InRange(id, idFirst, idLast)      ((UINT)((id)-(idFirst)) <= (UINT)((idLast)-(idFirst)))

void ColorDitherBrush_OnSysColorChange();
extern HBRUSH g_hbrMonoDither;              // gray dither brush from image.c
void InitDitherBrush();
void TerminateDitherBrush();


#ifndef DT_NOFULLWIDTHCHARBREAK
#define DT_NOFULLWIDTHCHARBREAK     0x00080000
#endif  // DT_NOFULLWIDTHCHARBREAK

#define SHDT_DRAWTEXT       0x00000001
#define SHDT_ELLIPSES       0x00000002
#define SHDT_CLIPPED        0x00000004
#define SHDT_SELECTED       0x00000008
#define SHDT_DESELECTED     0x00000010
#define SHDT_DEPRESSED      0x00000020
#define SHDT_EXTRAMARGIN    0x00000040
#define SHDT_TRANSPARENT    0x00000080
#define SHDT_SELECTNOFOCUS  0x00000100
#define SHDT_HOTSELECTED    0x00000200
#define SHDT_DTELLIPSIS     0x00000400
#ifdef WINDOWS_ME
#define SHDT_RTLREADING     0x00000800
#endif
#define SHDT_NODBCSBREAK    0x00001000
#define SHDT_VCENTER        0x00002000
#define SHDT_LEFT           0x00004000
#define SHDT_BORDERSELECT   0x00008000
// Do not draw text in selected style:
#define SHDT_NOSELECTED     0x00010000
#define SHDT_NOMARGIN       0x00020000
#define SHDT_SHADOWTEXT     0x00040000

void WINAPI SHDrawText(HDC hdc, LPCTSTR pszText, RECT* prc,
        int fmt, UINT flags, int cyChar, int cxEllipses,
        COLORREF clrText, COLORREF clrTextBk);

void WINAPI SHThemeDrawText(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCTSTR pszText, RECT* prc,
        int fmt, UINT flags, int cyChar, int cxEllipses,
        COLORREF clrText, COLORREF clrTextBk);


// notify.c
LRESULT WINAPI CCSendNotify(CCONTROLINFO * pci, int code, LPNMHDR pnm);
BOOL CCReleaseCapture(CCONTROLINFO * pci);
void CCSetCapture(CCONTROLINFO * pci, HWND hwndSet);


// treeview.c, listview.c for FE_IME code
LPTSTR GET_COMP_STRING(HIMC hImc, DWORD dwFlags);

// lvicon.c in-place editing
#define SEIPS_WRAP          0x0001
#ifdef DEBUG
#define SEIPS_NOSCROLL      0x0002      // Flag is used only in DEBUG
#endif
void SetEditInPlaceSize(HWND hwndEdit, RECT *prc, HFONT hFont, UINT seips);
HWND CreateEditInPlaceWindow(HWND hwnd, LPCTSTR lpText, int cbText, LONG style, HFONT hFont);
void RescrollEditWindow(HWND hwndEdit);
void SHOutlineRectThickness(HDC hdc, const RECT* prc, COLORREF cr, COLORREF crDefault, int cp);
#define SHOutlineRect(hdc, prc, cr, crDefault) SHOutlineRectThickness(hdc, prc, cr, crDefault, 1)

COLORREF GetSortColor(int iPercent, COLORREF clr);
COLORREF GetBorderSelectColor(int iPercent, COLORREF clr);
BOOL IsUsingCleartype();
BOOL UseMenuSelectionStyle();

// readermode.c auto scroll control entry point
BOOL EnterReaderMode(HWND hwnd);


// Global System metrics.

extern int g_cxEdge;
extern int g_cyEdge;
extern int g_cxEdgeScaled;
extern int g_cyEdgeScaled;
extern int g_cxBorder;
extern int g_cyBorder;
extern int g_cxScreen;
extern int g_cyScreen;
extern int g_cxDoubleClk;
extern int g_cyDoubleClk;

extern int g_cxSmIcon;
extern int g_cySmIcon;
//extern int g_cxIcon;
//extern int g_cyIcon;
extern int g_cxFrame;
extern int g_cyFrame;
extern int g_cxIconSpacing, g_cyIconSpacing;
extern int g_cxScrollbar, g_cyScrollbar;
extern int g_cxIconMargin, g_cyIconMargin;
extern int g_cyLabelSpace;
extern int g_cxLabelMargin;
//extern int g_cxIconOffset, g_cyIconOffset;
extern int g_cxVScroll;
extern int g_cyHScroll;
extern int g_cxHScroll;
extern int g_cyVScroll;
extern int g_fDragFullWindows;
extern int g_fDBCSEnabled;
extern int g_fMEEnabled;
extern int g_fDBCSInputEnabled;
extern int g_fIMMEnabled;
extern int g_cyCompensateInternalLeading;
extern int g_fLeftAligned;

extern COLORREF g_clrWindow;
extern COLORREF g_clrWindowText;
extern COLORREF g_clrWindowFrame;
extern COLORREF g_clrGrayText;
extern COLORREF g_clrBtnText;
extern COLORREF g_clrBtnFace;
extern COLORREF g_clrBtnShadow;
extern COLORREF g_clrBtnHighlight;
extern COLORREF g_clrHighlight;
extern COLORREF g_clrHighlightText;
extern COLORREF g_clrInfoText;
extern COLORREF g_clrInfoBk;
extern COLORREF g_clr3DDkShadow;
extern COLORREF g_clr3DLight;
extern COLORREF g_clrMenuHilight;
extern COLORREF g_clrMenuText;

extern HBRUSH g_hbrGrayText;
extern HBRUSH g_hbrWindow;
extern HBRUSH g_hbrWindowText;
extern HBRUSH g_hbrWindowFrame;
extern HBRUSH g_hbrBtnFace;
extern HBRUSH g_hbrBtnHighlight;
extern HBRUSH g_hbrBtnShadow;
extern HBRUSH g_hbrHighlight;
extern HBRUSH g_hbrMenuHilight;
extern HBRUSH g_hbrMenuText;

extern HFONT g_hfontSystem;
#define WHEEL_DELTA     120
extern UINT g_msgMSWheel;
extern UINT g_ucScrollLines;
extern int  gcWheelDelta;
extern UINT g_uDragImages;
extern BOOL g_fEnableBalloonTips;
extern BOOL g_fHighContrast;
extern double g_dScaleX;
extern double g_dScaleY;

#ifdef __cplusplus
}
#endif // __cplusplus
//
// Defining FULL_DEBUG makes us debug memory problems.
//
#if defined(FULL_DEBUG) && defined(WIN32)
#include "../inc/deballoc.h"
#endif // defined(FULL_DEBUG) && defined(WIN32)

// TRACE FLAGS
//
#define TF_MONTHCAL     0x00000100  // MonthCal and DateTimePick
#define TF_BKIMAGE      0x00000200  // ListView background image
#define TF_TOOLBAR      0x00000400  // Toolbar stuff
#define TF_PAGER        0x00000800  // Pager  Stuff
#define TF_REBAR        0x00001000  // Rebar
#define TF_LISTVIEW     0x00002000  // Listview
#define TF_TREEVIEW     0x00004000  // Treeview
#define TF_STATUS       0x00008000  // Status bar
#define TF_STANDARD     0x00010000  // Standard controls ported from user32
#define TF_IMAGELIST    0x00020000        

// Prototype flags
#define PTF_FLATLOOK    0x00000001  // Overall flatlook
#define PTF_NOISEARCHTO 0x00000002  // No incremental search timeout

#include <platform.h>

// Dummy union macros for code compilation on platforms not
// supporting nameless stuct/union

#ifdef NONAMELESSUNION
#define DUMMYUNION_MEMBER(member)   DUMMYUNIONNAME.member
#define DUMMYUNION2_MEMBER(member)  DUMMYUNIONNAME2.member
#define DUMMYUNION3_MEMBER(member)  DUMMYUNIONNAME3.member
#define DUMMYUNION4_MEMBER(member)  DUMMYUNIONNAME4.member
#define DUMMYUNION5_MEMBER(member)  DUMMYUNIONNAME5.member
#else
#define DUMMYUNION_MEMBER(member)    member
#define DUMMYUNION2_MEMBER(member)   member
#define DUMMYUNION3_MEMBER(member)   member
#define DUMMYUNION4_MEMBER(member)   member
#define DUMMYUNION5_MEMBER(member)   member
#endif

#ifdef FULL_DEBUG
#ifdef __cplusplus
extern "C" {
#endif
void DebugPaintInvalid(HWND hwnd, RECT* prc, HRGN rgn);
void DebugPaintClip(HWND hwnd, HDC hdc);
void DebugPaintRect(HDC hdc, RECT* prc);
#ifdef __cplusplus
}
#endif
#else
#define DebugPaintInvalid(hwnd, prc, rgn)   0
#define DebugPaintClip(hwnd, hdc)  0
#define DebugPaintRect(hdc, prc) 0
#endif

#define ALLOC_NULLHEAP(heap, size) Alloc( size )
#define COLOR_STRUCT DWORD
#define QUAD_PART(a) ((a)##.QuadPart)

#ifndef ISREMOTESESSION
#define ISREMOTESESSION() GetSystemMetrics(SM_REMOTESESSION)
#endif

EXTERN_C BOOL g_fCriticalInitialized;

#undef ENTERCRITICAL
#undef LEAVECRITICAL
#undef ASSERTCRITICAL
#define ENTERCRITICAL do { if (g_fCriticalInitialized) EnterCriticalSection(&g_csDll); } while (0);
#define LEAVECRITICAL do { if (g_fCriticalInitialized) LeaveCriticalSection(&g_csDll); } while (0); 
#define ASSERTCRITICAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\cstrings.h ===
extern TCHAR const c_szNULL[];
extern TCHAR const c_szSpace[];
extern TCHAR const c_szTabControlClass[];
extern TCHAR const c_szListViewClass[];
extern TCHAR const c_szHeaderClass[];
extern TCHAR const c_szTreeViewClass[];
extern TCHAR const c_szStatusClass[];
extern TCHAR const c_szSToolTipsClass[];
extern TCHAR const c_szToolbarClass[];
extern TCHAR const c_szReBarClass[];
extern TCHAR const c_szEllipses[];
extern TCHAR const c_szShell[];
extern TCHAR const c_szEdit[];
extern TCHAR const c_szSelect[];

extern const TCHAR s_szUpdownClass[];
extern const TCHAR s_szBUTTONLISTBOX[];
#define s_szEllipses c_szEllipses
#ifdef WANT_SUCKY_HEADER
extern const TCHAR s_szHeaderClass[];
#endif
extern const TCHAR s_szHOTKEY_CLASS[];
extern const TCHAR s_szSTrackBarClass[];
extern const TCHAR s_szPROGRESS_CLASS[];

extern const TCHAR c_szCC32Subclass[];

#define CCHELLIPSES 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\da.c ===
#include "ctlspriv.h"

//
// Heapsort is a bit slower, but it doesn't use any stack or memory...
// Mergesort takes a bit of memory (O(n)) and stack (O(log(n)), but very fast...
//
#define MERGESORT
// #define USEHEAPSORT

#ifdef DEBUG
#define DSA_MAGIC   ('S' | ('A' << 8))
#define IsDSA(pdsa) ((pdsa) && (pdsa)->magic == DSA_MAGIC)
#define DPA_MAGIC   ('P' | ('A' << 8))
#define IsDPA(pdpa) ((pdpa) && (pdpa)->magic == DPA_MAGIC)
#else
#define IsDSA(pdsa)
#define IsDPA(pdsa)
#endif


typedef struct {
    void** pp;
    PFNDPACOMPARE pfnCmp;
    LPARAM lParam;
    int cp;
#ifdef MERGESORT
    void** ppT;
#endif
} SORTPARAMS;

BOOL DPA_QuickSort(SORTPARAMS* psp);
BOOL DPA_QuickSort2(int i, int j, SORTPARAMS* psp);
BOOL DPA_HeapSort(SORTPARAMS* psp);
void DPA_HeapSortPushDown(int first, int last, SORTPARAMS* psp);
BOOL DPA_MergeSort(SORTPARAMS* psp);
void DPA_MergeSort2(SORTPARAMS* psp, int iFirst, int cItems);



//========== Dynamic structure array ====================================

// Dynamic structure array

typedef struct _DSA 
{
    // NOTE: The following field MUST be defined at the beginning of the
    // structure in order for GetItemCount() to work.
    int cItem;		// # of elements in dsa

    void* aItem;	// memory for elements
    int cItemAlloc;	// # items which fit in aItem
    int cbItem;		// size of each item
    int cItemGrow;	// # items to grow cItemAlloc by
#ifdef DEBUG
    UINT magic;
#endif
} DSA;

#define DSA_PITEM(pdsa, index)    ((void*)(((BYTE*)(pdsa)->aItem) + ((index) * (pdsa)->cbItem)))

#ifdef DEBUG
#define BF_ONDAVALIDATE     0x00001000

void DABreakFn(void)
{
    if (IsFlagSet(g_dwBreakFlags, BF_ONDAVALIDATE))
        ASSERT(0);
}

#define DABreak()    DABreakFn()
#else
#define DABreak()
#endif


HDSA WINAPI DSA_Create(int cbItem, int cItemGrow)
{
    HDSA pdsa = Alloc(sizeof(DSA));

    ASSERT(cbItem);

    if (pdsa)
    {
        ASSERT(pdsa->cItem == 0);
        ASSERT(pdsa->cItemAlloc == 0);
        pdsa->cbItem = cbItem;
        pdsa->cItemGrow = (cItemGrow == 0 ? 1 : cItemGrow);
        ASSERT(pdsa->aItem == NULL);
#ifdef DEBUG
        pdsa->magic = DSA_MAGIC;
#endif
    }
    return pdsa;
}

BOOL WINAPI DSA_Destroy(HDSA pdsa)
{

    if (pdsa == NULL)
    {
        // allow NULL for low memory cases
        return TRUE;
    }

    // Components rely on not having to check for NULL
    ASSERT(IsDSA(pdsa));

#ifdef DEBUG
    pdsa->cItem = 0;
    pdsa->cItemAlloc = 0;
    pdsa->cbItem = 0;
    pdsa->magic = 0;
#endif

    if (pdsa->aItem && !Free(pdsa->aItem))
    {
        return FALSE;
    }

    return Free(pdsa);
}

void WINAPI DSA_EnumCallback(HDSA pdsa, PFNDSAENUMCALLBACK pfnCB, void *pData)
{
    int i;
    
    if (!pdsa)
        return;
    
    ASSERT(IsDSA(pdsa));

    for (i = 0; i < pdsa->cItem; i++) {
        if (!pfnCB(DSA_GetItemPtr(pdsa, i), pData))
            break;
    }
}

void WINAPI DSA_DestroyCallback(HDSA pdsa, PFNDSAENUMCALLBACK pfnCB, void *pData)
{
    DSA_EnumCallback(pdsa, pfnCB, pData);
    DSA_Destroy(pdsa);
}


BOOL WINAPI DSA_GetItem(HDSA pdsa, int index, void* pitem)
{
    ASSERT(IsDSA(pdsa));
    ASSERT(pitem);

    if (index < 0 || index >= pdsa->cItem)
    {
#ifdef DEBUG
        // Don't assert if index == pdsa->cItems as some clients simply want to walk the list and no need to call getcount...

        if (index != pdsa->cItem)
        {
            DebugMsg(DM_ERROR, TEXT("DSA: GetItem: Invalid index: %d"), index);
            DABreak();
        }
#endif
        return FALSE;
    }

    CopyMemory(pitem, DSA_PITEM(pdsa, index), pdsa->cbItem);
    return TRUE;
}

void* WINAPI DSA_GetItemPtr(HDSA pdsa, int index)
{
    ASSERT(IsDSA(pdsa));

    if (index < 0 || index >= pdsa->cItem)
    {
#ifdef DEBUG
        // Don't assert if index == pdsa->cItems as some clients simply want to walk the list and no need to call getcount...

        if (index != pdsa->cItem)
        {
            DebugMsg(DM_ERROR, TEXT("DSA: GetItemPtr: Invalid index: %d"), index);
            // DABreak();   // caller knows
        }
#endif
        return NULL;
    }
    return DSA_PITEM(pdsa, index);
}

BOOL DSA_ForceGrow(HDSA pdsa, int iNumberToAdd)
{
    ASSERT(IsDSA(pdsa));

    if (!pdsa)
        return FALSE;

    if (pdsa->cItem + iNumberToAdd > pdsa->cItemAlloc)
    {
        int cItemAlloc = (((pdsa->cItemAlloc + iNumberToAdd) + pdsa->cItemGrow - 1) / pdsa->cItemGrow) * pdsa->cItemGrow;

        void* aItemNew = ReAlloc(pdsa->aItem, cItemAlloc * pdsa->cbItem);
        if (!aItemNew)
        {
            return FALSE;
        }

        pdsa->aItem = aItemNew;
        pdsa->cItemAlloc = cItemAlloc;
    }
    return TRUE;
}


BOOL WINAPI DSA_SetItem(HDSA pdsa, int index, void* pitem)
{
    ASSERT(pitem);
    ASSERT(IsDSA(pdsa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: SetItem: Invalid index: %d"), index);
        DABreak();
        return FALSE;
    }

    if (index >= pdsa->cItem)
    {
        if (index + 1 > pdsa->cItemAlloc)
        {
            int cItemAlloc = (((index + 1) + pdsa->cItemGrow - 1) / pdsa->cItemGrow) * pdsa->cItemGrow;

            void* aItemNew = ReAlloc(pdsa->aItem, cItemAlloc * pdsa->cbItem);
            if (!aItemNew)
            {
                return FALSE;
            }

            pdsa->aItem = aItemNew;
            pdsa->cItemAlloc = cItemAlloc;
        }
        pdsa->cItem = index + 1;
    }

    CopyMemory(DSA_PITEM(pdsa, index), pitem, pdsa->cbItem);

    return TRUE;
}

int WINAPI DSA_InsertItem(HDSA pdsa, int index, void* pitem)
{
    ASSERT(pitem);
    ASSERT(IsDSA(pdsa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: InsertItem: Invalid index: %d"), index);
        DABreak();
        return -1;
    }

    if (index > pdsa->cItem)
        index = pdsa->cItem;

    if (pdsa->cItem + 1 > pdsa->cItemAlloc)
    {
        void* aItemNew = ReAlloc(pdsa->aItem, (pdsa->cItemAlloc + pdsa->cItemGrow) * pdsa->cbItem);
        if (!aItemNew)
        {
            return -1;
        }

        pdsa->aItem = aItemNew;
        pdsa->cItemAlloc += pdsa->cItemGrow;
    }

    if (index < pdsa->cItem)
    {
        MoveMemory(DSA_PITEM(pdsa, index + 1),
                   DSA_PITEM(pdsa, index),
                   (pdsa->cItem - index) * pdsa->cbItem);
    }
    pdsa->cItem++;
    MoveMemory(DSA_PITEM(pdsa, index), pitem, pdsa->cbItem);

    return index;
}

BOOL WINAPI DSA_DeleteItem(HDSA pdsa, int index)
{
    ASSERT(IsDSA(pdsa));

    if (index < 0 || index >= pdsa->cItem)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: DeleteItem: Invalid index: %d"), index);
        DABreak();
        return FALSE;
    }

    if (index < pdsa->cItem - 1)
    {
        MoveMemory(DSA_PITEM(pdsa, index),
                   DSA_PITEM(pdsa, index + 1),
                   (pdsa->cItem - (index + 1)) * pdsa->cbItem);
    }
    pdsa->cItem--;

    if (pdsa->cItemAlloc - pdsa->cItem > pdsa->cItemGrow)
    {
        void* aItemNew = ReAlloc(pdsa->aItem, (pdsa->cItemAlloc - pdsa->cItemGrow) * pdsa->cbItem);
        if (aItemNew)
        {
            pdsa->aItem = aItemNew;
        }
        else
        {
            // If the shrink fails, then just continue with the old (slightly
            // too big) allocation.  Go ahead and let cItemAlloc decrease
            // so we don't keep trying to realloc smaller
        }
        pdsa->cItemAlloc -= pdsa->cItemGrow;
    }
    return TRUE;
}

BOOL WINAPI DSA_DeleteAllItems(HDSA pdsa)
{
    ASSERT(IsDSA(pdsa));

    if (pdsa->aItem && !Free(pdsa->aItem))
    {
        return FALSE;
    }

    pdsa->aItem = NULL;
    pdsa->cItem = pdsa->cItemAlloc = 0;
    return TRUE;
}


//================== Dynamic pointer array implementation ===========

typedef struct _DPA 
{
    // NOTE: The following two fields MUST be defined in this order, at
    // the beginning of the structure in order for the macro APIs to work.
    int cp;
    void** pp;

    HANDLE hheap;        // Heap to allocate from if NULL use shared

    int cpAlloc;
    int cpGrow;
#ifdef DEBUG
    UINT magic;
#endif
} DPA;



HDPA WINAPI DPA_Create(int cpGrow)
{
    return DPA_CreateEx(cpGrow, NULL);
}

// Should nuke the standard DPA above...
HDPA WINAPI DPA_CreateEx(int cpGrow, HANDLE hheap)
{
    HDPA pdpa;
    if (hheap == NULL)
    {
        hheap = GetProcessHeap();

        pdpa = ALLOC_NULLHEAP(hheap, sizeof(DPA));
    }
    else
        pdpa = ControlAlloc(hheap, sizeof(DPA));
    if (pdpa)
    {
        ASSERT(pdpa->cp == 0);
        ASSERT(pdpa->cpAlloc == 0);
        pdpa->cpGrow = (cpGrow < 8 ? 8 : cpGrow);
        ASSERT(pdpa->pp == NULL);
        pdpa->hheap = hheap;
#ifdef DEBUG
        pdpa->magic = DPA_MAGIC;
#endif
    }
    return pdpa;
}

BOOL WINAPI DPA_Destroy(HDPA pdpa)
{
    if (pdpa == NULL)       // allow NULL for low memory cases, still assert
        return TRUE;

    ASSERT(IsDPA(pdpa));

#ifndef UNIX
    ASSERT(pdpa->hheap);
#endif

#ifdef DEBUG
    pdpa->cp = 0;
    pdpa->cpAlloc = 0;
    pdpa->magic = 0;
#endif
    if (pdpa->pp && !ControlFree(pdpa->hheap, pdpa->pp))
        return FALSE;

    return ControlFree(pdpa->hheap, pdpa);
}

HDPA WINAPI DPA_Clone(HDPA pdpa, HDPA pdpaNew)
{
    BOOL fAlloc = FALSE;

    if (!pdpaNew)
    {
        pdpaNew = DPA_CreateEx(pdpa->cpGrow, pdpa->hheap);
        if (!pdpaNew)
        {
            return NULL;
        }

        fAlloc = TRUE;
    }

    if (!DPA_Grow(pdpaNew, pdpa->cpAlloc))
    {
        if (!fAlloc)
        {
            DPA_Destroy(pdpaNew);
        }
        return NULL;
    }

    pdpaNew->cp = pdpa->cp;
    CopyMemory(pdpaNew->pp, pdpa->pp, pdpa->cp * sizeof(void*));

    return pdpaNew;
}

void* WINAPI DPA_GetPtr(HDPA pdpa, INT_PTR index)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa || index < 0 || index >= pdpa->cp)
        return NULL;

    return pdpa->pp[index];
}

int WINAPI DPA_GetPtrIndex(HDPA pdpa, void* p)
{
    void** pp;
    void** ppMax;

    ASSERT(IsDPA(pdpa));
    if (pdpa && pdpa->pp)
    {
        pp = pdpa->pp;
        ppMax = pp + pdpa->cp;
        for ( ; pp < ppMax; pp++)
        {
            if (*pp == p)
                return (int) (pp - pdpa->pp);
        }
    }
    return -1;
}

BOOL WINAPI DPA_Grow(HDPA pdpa, int cpAlloc)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return FALSE;

    if (cpAlloc > pdpa->cpAlloc)
    {
        void** ppNew;

        cpAlloc = ((cpAlloc + pdpa->cpGrow - 1) / pdpa->cpGrow) * pdpa->cpGrow;

        if (pdpa->pp)
            ppNew = (void**)ControlReAlloc(pdpa->hheap, pdpa->pp, cpAlloc * sizeof(void*));
        else
            ppNew = (void**)ControlAlloc(pdpa->hheap, cpAlloc * sizeof(void*));
        if (!ppNew)
            return FALSE;

        pdpa->pp = ppNew;
        pdpa->cpAlloc = cpAlloc;

        //
        // Grow more agressively as we get bigger, up to a maximum of
        // 512 at a time.  Note, we'll only hit our outer bound growth
        // at a time limit once we've already got that many items in the
        // DPA anyway...
        //
        if (pdpa->cpGrow < 256)
        {
            pdpa->cpGrow = pdpa->cpGrow << 1;
        }
    }
    return TRUE;
}

BOOL WINAPI DPA_SetPtr(HDPA pdpa, int index, void* p)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return FALSE;

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: SetPtr: Invalid index: %d"), index);
        DABreak();
        return FALSE;
    }

    if (index >= pdpa->cp)
    {
        if (!DPA_Grow(pdpa, index + 1))
            return FALSE;
        // If we grew by more than one, must zero-init all the stuff in the middle
        ZeroMemory(pdpa->pp + pdpa->cp, sizeof(void *) * (index - pdpa->cp));
        pdpa->cp = index + 1;
    }

    pdpa->pp[index] = p;

    return TRUE;
}

int WINAPI DPA_InsertPtr(HDPA pdpa, int index, void* p)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return -1;

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: InsertPtr: Invalid index: %d"), index);
        DABreak();
        return -1;
    }
    if (index > pdpa->cp)
        index = pdpa->cp;

    // Make sure we have room for one more item
    //
    if (pdpa->cp + 1 > pdpa->cpAlloc)
    {
        if (!DPA_Grow(pdpa, pdpa->cp + 1))
            return -1;
    }

    // If we are inserting, we need to slide everybody up
    //
    if (index < pdpa->cp)
    {
        MoveMemory(&pdpa->pp[index + 1],
                   &pdpa->pp[index],
                   (pdpa->cp - index) * sizeof(void*));
    }

    pdpa->pp[index] = p;
    pdpa->cp++;

    return index;
}

void* WINAPI DPA_DeletePtr(HDPA pdpa, int index)
{
    void* p;

    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return FALSE;

    if (index < 0 || index >= pdpa->cp)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: DeltePtr: Invalid index: %d"), index);
        DABreak();
        return NULL;
    }

    p = pdpa->pp[index];

    if (index < pdpa->cp - 1)
    {
        MoveMemory(&pdpa->pp[index],
                   &pdpa->pp[index + 1],
                   (pdpa->cp - (index + 1)) * sizeof(void*));
    }
    pdpa->cp--;

    if (pdpa->cpAlloc - pdpa->cp > pdpa->cpGrow)
    {
        void** ppNew;
        ppNew = ControlReAlloc(pdpa->hheap, pdpa->pp, (pdpa->cpAlloc - pdpa->cpGrow) * sizeof(void*));

        if (ppNew)
            pdpa->pp = ppNew;
        else
        {
            // If the shrink fails, then just continue with the old (slightly
            // too big) allocation.  Go ahead and let cpAlloc decrease
            // so we don't keep trying to realloc smaller
        }
        pdpa->cpAlloc -= pdpa->cpGrow;
    }
    return p;
}

BOOL WINAPI DPA_DeleteAllPtrs(HDPA pdpa)
{
    if (!pdpa)
        return FALSE;

    ASSERT(IsDPA(pdpa));

    if (pdpa->pp && !ControlFree(pdpa->hheap, pdpa->pp))
        return FALSE;
    pdpa->pp = NULL;
    pdpa->cp = pdpa->cpAlloc = 0;
    return TRUE;
}

void WINAPI DPA_EnumCallback(HDPA pdpa, PFNDPAENUMCALLBACK pfnCB, void *pData)
{
    int i;
    
    if (!pdpa)
        return;
    
    ASSERT(IsDPA(pdpa));

    for (i = 0; i < pdpa->cp; i++) {
        if (!pfnCB(DPA_FastGetPtr(pdpa, i), pData))
            break;
    }
}

void WINAPI DPA_DestroyCallback(HDPA pdpa, PFNDPAENUMCALLBACK pfnCB, void *pData)
{
    DPA_EnumCallback(pdpa, pfnCB, pData);
    DPA_Destroy(pdpa);
}


typedef struct _DPASTREAMHEADER
{
    DWORD cbSize;       // Size of entire stream
    DWORD dwVersion;    // For versioning
    int   celem;
} DPASTREAMHEADER;

#define DPASTREAM_VERSION   1


/*----------------------------------------------------------
Purpose: Saves the DPA to a stream by writing out a header,
         and then calling the given callback to write each
         element.

         The callback can end the write early by returning 
         something other than S_OK.  Returning an error will
         cancel the entire write.  Returning S_FALSE will 
         stop the write.

Returns: S_OK or S_FALSE for success.  
         S_FALSE only if callback stops early
         errors
*/
HRESULT
WINAPI
DPA_SaveStream(
    IN HDPA         pdpa,
    IN PFNDPASTREAM pfn,
    IN IStream *    pstm,
    IN void *      pvInstData)
{
    HRESULT hres = E_INVALIDARG;

    if (IS_VALID_HANDLE(pdpa, DPA) &&
        IS_VALID_CODE_PTR(pstm, IStream *) &&
        IS_VALID_CODE_PTR(pfn, PFNDPASTREAM))
    {
        DPASTREAMHEADER header;
        LARGE_INTEGER dlibMove = { 0 };
        ULARGE_INTEGER ulPosBegin;

        // Get the current seek position, so we can update the header
        // once we know how much we've written
        hres = pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_CUR, &ulPosBegin);
        if (SUCCEEDED(hres))
        {
            // Write the header (we will update some of this once we're
            // finished)
            header.cbSize = 0;
            header.dwVersion = DPASTREAM_VERSION;
            header.celem = 0;

            // First write out the header
            hres = pstm->lpVtbl->Write(pstm, &header, sizeof(header), NULL);

            if (SUCCEEDED(hres))
            {
                DPASTREAMINFO info;
                int cel = DPA_GetPtrCount(pdpa);
                void **ppv = DPA_GetPtrPtr(pdpa);

                // This keeps the count of what is actually written
                info.iPos = 0;

                // Write each element
                for (; 0 < cel; cel--, ppv++) 
                {
                    info.pvItem = *ppv;
                    hres = pfn(&info, pstm, pvInstData);

                    // Returning S_FALSE from callback means it didn't
                    // write anything for this element, so don't increment 
                    // the iPos (which refers to the count written).

                    if (S_OK == hres)
                        info.iPos++;
                    else if (FAILED(hres))
                    {
                        hres = S_FALSE;
                        break;
                    }
                }

                if (FAILED(hres))
                {
                    // Reposition pointer to beginning
                    dlibMove.LowPart = ulPosBegin.LowPart;
                    dlibMove.HighPart = ulPosBegin.HighPart;
                    pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                }
                else
                {
                    ULARGE_INTEGER ulPosEnd;

                    // Calculate how much was written
                    hres = pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_CUR, 
                                              &ulPosEnd);
                    if (SUCCEEDED(hres))
                    {
                        // We only save the low part
                        ASSERT(ulPosEnd.HighPart == ulPosBegin.HighPart);

                        // Update the header
                        header.celem = info.iPos;
                        header.cbSize = ulPosEnd.LowPart - ulPosBegin.LowPart;

                        dlibMove.LowPart = ulPosBegin.LowPart;
                        dlibMove.HighPart = ulPosBegin.HighPart;
                        pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                        pstm->lpVtbl->Write(pstm, &header, sizeof(header), NULL);

                        // Reposition pointer
                        dlibMove.LowPart = ulPosEnd.LowPart;
                        dlibMove.HighPart = ulPosEnd.HighPart;
                        pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                    }
                }
            }
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Loads the DPA from a stream by calling the given callback 
         to read each element.

         The callback can end the read early by returning 
         something other than S_OK.  

Returns: S_OK on success
         S_FALSE if the callback aborted early or the stream ended
           abruptly. DPA is partially filled.
         error on anything else
*/
HRESULT
WINAPI
DPA_LoadStream(
    OUT HDPA *      ppdpa,
    IN PFNDPASTREAM pfn,
    IN IStream *    pstm,
    IN void *      pvInstData)
{
    HRESULT hres = E_INVALIDARG;

    if (IS_VALID_WRITE_PTR(ppdpa, HDPA) &&
        IS_VALID_CODE_PTR(pstm, IStream *) &&
        IS_VALID_CODE_PTR(pfn, PFNDPASTREAM))
    {
        DPASTREAMHEADER header;
        LARGE_INTEGER dlibMove = { 0 };
        ULARGE_INTEGER ulPosBegin;
        ULONG cbRead;

        *ppdpa = NULL;

        // Get the current seek position so we can position pointer 
        // correctly upon error.
        hres = pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_CUR, &ulPosBegin);
        if (SUCCEEDED(hres))
        {
            // Read the header
            hres = pstm->lpVtbl->Read(pstm, &header, sizeof(header), &cbRead);
            if (SUCCEEDED(hres))
            {
                if (sizeof(header) > cbRead ||
                    sizeof(header) > header.cbSize ||
                    DPASTREAM_VERSION != header.dwVersion)
                {
                    hres = E_FAIL;
                }
                else
                {
                    // Create the list 
                    HDPA pdpa = DPA_Create(header.celem);
                    if ( !pdpa || !DPA_Grow(pdpa, header.celem))
                        hres = E_OUTOFMEMORY;
                    else
                    {
                        // Read each element
                        DPASTREAMINFO info;
                        void **ppv = DPA_GetPtrPtr(pdpa);

                        for (info.iPos = 0; info.iPos < header.celem; ) 
                        {
                            info.pvItem = NULL;
                            hres = pfn(&info, pstm, pvInstData);

                            // Returning S_FALSE from the callback means
                            // it skipped this stream element.
                            // Don't increment iPos (which refers to the
                            // count read).
                            if (S_OK == hres)
                            {
                                *ppv = info.pvItem;

                                info.iPos++;
                                ppv++;    
                            }
                            else if (FAILED(hres))
                            {
                                hres = S_FALSE;
                                break;
                            }
                        }

                        pdpa->cp = info.iPos;
                        *ppdpa = pdpa;
                    }
                }

                // Reposition pointer if we failed
                if (S_OK != hres)
                {
                    if (S_FALSE == hres)
                    {
                        // Position pointer to the end
                        dlibMove.LowPart = ulPosBegin.LowPart + header.cbSize;
                    }
                    else
                    {
                        // Position pointer to beginning 
                        dlibMove.LowPart = ulPosBegin.LowPart;
                    }
                    dlibMove.HighPart = ulPosBegin.HighPart;
                    pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                }
            }
        }

        ASSERT(SUCCEEDED(hres) && *ppdpa ||
               FAILED(hres) && NULL == *ppdpa);
    }

    return hres;
}



/*----------------------------------------------------------
Purpose: Merge two DPAs.  This takes two arrays and merges the
         source array into the destination.   

         Merge options:

          DPAM_SORTED       The arrays are already sorted; don't sort
          DPAM_UNION        The resulting array is the union of all elements
                            in both arrays.
          DPAM_INTERSECT    Only elements in the source array that intersect
                            with the dest array are merged.  
          DPAM_NORMAL       Like DPAM_INTERSECT except the dest array 
                            also maintains its original, additional elements.


Returns: S_OK for success.  
         errors if merge fails

Cond:    --
*/
BOOL
WINAPI
DPA_Merge(
    IN HDPA          pdpaDest,
    IN HDPA          pdpaSrc,
    IN DWORD         dwFlags,
    IN PFNDPACOMPARE pfnCompare,
    IN PFNDPAMERGE   pfnMerge,
    IN LPARAM        lParam)
{
    BOOL bRet = FALSE;

    if (IS_VALID_HANDLE(pdpaSrc, DPA) &&
        IS_VALID_HANDLE(pdpaDest, DPA) &&
        IS_VALID_CODE_PTR(pfnCompare, PFNDPACOMPARE) &&
        IS_VALID_CODE_PTR(pfnMerge, PFNDPAMERGE))
    {
        int iSrc;
        int iDest;
        int nCmp;
        void **ppvSrc;
        void **ppvDest;

        bRet = TRUE;

        // Are the arrays already sorted?
        if ( !(dwFlags & DPAM_SORTED) )
        {
            // No; sort them
            DPA_Sort(pdpaSrc, pfnCompare, lParam);
            DPA_Sort(pdpaDest, pfnCompare, lParam);
        }

        // This merges in-place. The size of the resulting DPA 
        // depends on the options:
        //
        //   DPAM_NORMAL    Same size as the dest DPA before 
        //                  the merge.  
        //
        //   DPAM_UNION     Min size is the larger of the two.
        //                  Max size is the sum of the two.
        //
        //   DPAM_INTERSECT Min size is zero.
        //                  Max size is the smaller of the two.
        // 
        // We iterate backwards to minimize the amount of moves we 
        // incur by calling DPA_DeletePtr.
        //

        iSrc = pdpaSrc->cp - 1;
        iDest = pdpaDest->cp - 1;
        ppvSrc = &DPA_FastGetPtr(pdpaSrc, iSrc);
        ppvDest = &DPA_FastGetPtr(pdpaDest, iDest);

        while (0 <= iSrc && 0 <= iDest)
        {
            void *pv;

            nCmp = pfnCompare(*ppvDest, *ppvSrc, lParam);

            if (0 == nCmp)
            {
                // Elements match; merge them.  
                pv = pfnMerge(DPAMM_MERGE, *ppvDest, *ppvSrc, lParam);
                if (NULL == pv)
                {
                    bRet = FALSE;
                    break;
                }
                *ppvDest = pv;

                iSrc--;
                ppvSrc--;
                iDest--;
                ppvDest--;
            }
            else if (0 < nCmp)
            {
                // pvSrc < pvDest. The source array doesn't have pvDest.
                if (dwFlags & DPAM_INTERSECT)
                {
                    // Delete pvDest 
                    pfnMerge(DPAMM_DELETE, DPA_DeletePtr(pdpaDest, iDest), NULL, lParam);
                }
                else
                {
                    ; // Keep it (do nothing)
                }

                // Move onto the next element in the dest array
                iDest--;
                ppvDest--;
            }
            else
            {
                // pvSrc > pvDest. The dest array doesn't have pvSrc.
                if (dwFlags & DPAM_UNION)
                {
                    // Add pvSrc
                    pv = pfnMerge(DPAMM_INSERT, *ppvSrc, NULL, lParam);
                    if (NULL == pv)
                    {
                        bRet = FALSE;
                        break;
                    }

                    DPA_InsertPtr(pdpaDest, iDest+1, pv);
                    // DPA_InsertPtr may end up reallocating the pointer array
                    // thus making ppvDest invalid
                    ppvDest = &DPA_FastGetPtr(pdpaDest, iDest);
                }
                else
                {
                    ;  // Skip it (do nothing)
                }

                // Move onto the next element in the source array
                iSrc--;
                ppvSrc--;
            }
        }
        // there are some items left in src
        if ((dwFlags & DPAM_UNION) && 0 <= iSrc)
        {
            for (; 0 <= iSrc; iSrc--, ppvSrc--)
            {
                void *pv = pfnMerge(DPAMM_INSERT, *ppvSrc, NULL, lParam);
                if (NULL == pv)
                {
                    bRet = FALSE;
                    break;
                }
                DPA_InsertPtr(pdpaDest, 0, pv);
            }
        }
    }

    return bRet;
}


BOOL WINAPI DPA_Sort(HDPA pdpa, PFNDPACOMPARE pfnCmp, LPARAM lParam)
{
    SORTPARAMS sp;

    sp.cp = pdpa->cp;
    sp.pp = pdpa->pp;
    sp.pfnCmp = pfnCmp;
    sp.lParam = lParam;

#ifdef USEQUICKSORT
    return DPA_QuickSort(&sp);
#endif
#ifdef USEHEAPSORT
    return DPA_HeapSort(&sp);
#endif
#ifdef MERGESORT
    return DPA_MergeSort(&sp);
#endif
}

#ifdef USEQUICKSORT

BOOL DPA_QuickSort(SORTPARAMS* psp)
{
    return DPA_QuickSort2(0, psp->cp - 1, psp);
}

BOOL DPA_QuickSort2(int i, int j, SORTPARAMS* psp)
{
    void** pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNDPACOMPARE pfnCmp = psp->pfnCmp;

    int iPivot;
    void* pFirst;
    int k;
    int result;

    iPivot = -1;
    pFirst = pp[i];
    for (k = i + 1; k <= j; k++)
    {
        result = (*pfnCmp)(pp[k], pFirst, lParam);

        if (result > 0)
        {
            iPivot = k;
            break;
        }
        else if (result < 0)
        {
            iPivot = i;
            break;
        }
    }

    if (iPivot != -1)
    {
        int l = i;
        int r = j;
        void* pivot = pp[iPivot];

        do
        {
            void* p;

            p = pp[l];
            pp[l] = pp[r];
            pp[r] = p;

            while ((*pfnCmp)(pp[l], pivot, lParam) < 0)
                l++;
            while ((*pfnCmp)(pp[r], pivot, lParam) >= 0)
                r--;
        } while (l <= r);

        if (l - 1 > i)
            DPA_QuickSort2(i, l - 1, psp);
        if (j > l)
            DPA_QuickSort2(l, j, psp);
    }
    return TRUE;
}
#endif  // USEQUICKSORT

#ifdef USEHEAPSORT

void DPA_HeapSortPushDown(int first, int last, SORTPARAMS* psp)
{
    void** pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNDPACOMPARE pfnCmp = psp->pfnCmp;
    int r;
    int r2;
    void* p;

    r = first;
    while (r <= last / 2)
    {
        int wRTo2R;
        r2 = r * 2;

        wRTo2R = (*pfnCmp)(pp[r-1], pp[r2-1], lParam);

        if (r2 == last)
        {
            if (wRTo2R < 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2-1]; pp[r2-1] = p;
            }
            break;
        }
        else
        {
            int wR2toR21 = (*pfnCmp)(pp[r2-1], pp[r2+1-1], lParam);

            if (wRTo2R < 0 && wR2toR21 >= 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2-1]; pp[r2-1] = p;
                r = r2;
            }
            else if ((*pfnCmp)(pp[r-1], pp[r2+1-1], lParam) < 0 && wR2toR21 < 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2+1-1]; pp[r2+1-1] = p;
                r = r2 + 1;
            }
            else
            {
                break;
            }
        }
    }
}

BOOL DPA_HeapSort(SORTPARAMS* psp)
{
    void** pp = psp->pp;
    int c = psp->cp;
    int i;

    for (i = c / 2; i >= 1; i--)
        DPA_HeapSortPushDown(i, c, psp);

    for (i = c; i >= 2; i--)
    {
        void* p = pp[0]; pp[0] = pp[i-1]; pp[i-1] = p;

        DPA_HeapSortPushDown(1, i - 1, psp);
    }
    return TRUE;
}
#endif  // USEHEAPSORT

#if defined(MERGESORT)

#define SortCompare(psp, pp1, i1, pp2, i2) \
    (psp->pfnCmp(pp1[i1], pp2[i2], psp->lParam))

//
//  This function merges two sorted lists and makes one sorted list.
//   psp->pp[iFirst, iFirst+cItes/2-1], psp->pp[iFirst+cItems/2, iFirst+cItems-1]
//
void DPA_MergeThem(SORTPARAMS* psp, int iFirst, int cItems)
{
    //
    // Notes:
    //  This function is separated from DPA_MergeSort2() to avoid comsuming
    // stack variables. Never inline this.
    //
    int cHalf = cItems/2;
    int iIn1, iIn2, iOut;
    void **ppvSrc = &psp->pp[iFirst];

    // Copy the first part to temp storage so we can write directly into
    // the final buffer.  Note that this takes at most psp->cp/2 DWORD's
    CopyMemory(psp->ppT, ppvSrc, cHalf * sizeof(void*));

    for (iIn1=0, iIn2=cHalf, iOut=0;;)
    {
        if (SortCompare(psp, psp->ppT, iIn1, ppvSrc, iIn2) <= 0) {
            ppvSrc[iOut++] = psp->ppT[iIn1++];

            if (iIn1==cHalf) {
                // We used up the first half; the rest of the second half
                // should already be in place
                break;
            }
        } else {
            ppvSrc[iOut++] = ppvSrc[iIn2++];
            if (iIn2==cItems) {
                // We used up the second half; copy the rest of the first half
                // into place
                CopyMemory(&ppvSrc[iOut], &psp->ppT[iIn1], (cItems-iOut)*sizeof(void *));
                break;
            }
        }
    }
}

//
//  This function sorts a give list (psp->pp[iFirst,iFirst-cItems-1]).
//
void DPA_MergeSort2(SORTPARAMS* psp, int iFirst, int cItems)
{
    //
    // Notes:
    //   This function is recursively called. Therefore, we should minimize
    //  the number of local variables and parameters. At this point, we
    //  use one local variable and three parameters.
    //
    int cHalf;

    switch(cItems)
    {
    case 1:
        return;

    case 2:
        // Swap them, if they are out of order.
        if (SortCompare(psp, psp->pp, iFirst, psp->pp, iFirst+1) > 0)
        {
            psp->ppT[0] = psp->pp[iFirst];
            psp->pp[iFirst] = psp->pp[iFirst+1];
            psp->pp[iFirst+1] = psp->ppT[0];
        }
        break;

    default:
        cHalf = cItems/2;

        // Sort each half
        DPA_MergeSort2(psp, iFirst, cHalf);
        DPA_MergeSort2(psp, iFirst+cHalf, cItems-cHalf);
        // Then, merge them.
        DPA_MergeThem(psp, iFirst, cItems);
        break;
    }
}

BOOL DPA_MergeSort(SORTPARAMS* psp)
{
    if (psp->cp==0)
        return TRUE;

    // Note that we divide by 2 below; we want to round down
    psp->ppT = LocalAlloc(LPTR, psp->cp/2 * sizeof(void *));
    if (!psp->ppT)
        return FALSE;

    DPA_MergeSort2(psp, 0, psp->cp);
    LocalFree(psp->ppT);
    return TRUE;
}
#endif // MERGESORT

// Search function
//
int WINAPI DPA_Search(HDPA pdpa, void* pFind, int iStart,
            PFNDPACOMPARE pfnCompare, LPARAM lParam, UINT options)
{
    int cp = DPA_GetPtrCount(pdpa);

    ASSERT(pfnCompare);
    ASSERT(0 <= iStart);

    // Only allow these wierd flags if the list is sorted
    ASSERT((options & DPAS_SORTED) || !(options & (DPAS_INSERTBEFORE | DPAS_INSERTAFTER)));

    if (!(options & DPAS_SORTED))
    {
        // Not sorted: do linear search.
        int i;

        for (i = iStart; i < cp; i++)
        {
            if (0 == pfnCompare(pFind, DPA_FastGetPtr(pdpa, i), lParam))
                return i;
        }
        return -1;
    }
    else
    {
        // Search the array using binary search.  If several adjacent
        // elements match the target element, the index of the first
        // matching element is returned.

        int iRet = -1;      // assume no match
        BOOL bFound = FALSE;
        int nCmp = 0;
        int iLow = 0;       // Don't bother using iStart for binary search
        int iMid = 0;
        int iHigh = cp - 1;

        // (OK for cp == 0)
        while (iLow <= iHigh)
        {
            iMid = (iLow + iHigh) / 2;

            nCmp = pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid), lParam);

            if (0 > nCmp)
                iHigh = iMid - 1;       // First is smaller
            else if (0 < nCmp)
                iLow = iMid + 1;        // First is larger
            else
            {
                // Match; search back for first match
                bFound = TRUE;
                while (0 < iMid)
                {
                    if (0 != pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid-1), lParam))
                        break;
                    else
                        iMid--;
                }
                break;
            }
        }

        if (bFound)
        {
            ASSERT(0 <= iMid);
            iRet = iMid;
        }

        // Did the search fail AND
        // is one of the strange search flags set?
        if (!bFound && (options & (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)))
        {
            // Yes; return the index where the target should be inserted
            // if not found
            if (0 < nCmp)       // First is larger
                iRet = iLow;
            else
                iRet = iMid;
            // (We don't distinguish between the two flags anymore)
        }
        else if ( !(options & (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)) )
        {
            // Sanity check with linear search
            ASSERT(DPA_Search(pdpa, pFind, iStart, pfnCompare, lParam, options & ~DPAS_SORTED) == iRet);
        }
        return iRet;
    }
}

//===========================================================================
//
// String ptr management routines
//
// Copy as much of *psz to *pszBuf as will fit
//
// Warning:  this same code is duplicated below.
//
int WINAPI Str_GetPtr(LPCTSTR pszCurrent, LPTSTR pszBuf, int cchBuf)
{
    int cchToCopy;

    if (!pszCurrent)
    {
        ASSERT(FALSE);
        
        if (cchBuf > 0)
        {
            *pszBuf = TEXT('\0');
        }

        return 0;
    }

    cchToCopy = lstrlen(pszCurrent);

    // if pszBuf is NULL, or they passed cchBuf = 0, return the needed buff size
    if (!pszBuf || !cchBuf)
    {
        return cchToCopy + 1;
    }
    
    if (cchToCopy >= cchBuf)
    {
        cchToCopy = cchBuf - 1;
    }

    CopyMemory(pszBuf, pszCurrent, cchToCopy * sizeof(TCHAR));
    pszBuf[cchToCopy] = TEXT('\0');

    return cchToCopy + 1;
}

#ifdef DEBUG
//
//  Str_GetPtr0 is just like Str_GetPtr except that it doesn't assert if
//  pszCurrent = NULL.
//
int WINAPI Str_GetPtr0(LPCTSTR pszCurrent, LPTSTR pszBuf, int cchBuf)
{
    return Str_GetPtr(pszCurrent ? pszCurrent : c_szNULL, pszBuf, cchBuf);
}
#endif

#ifdef UNICODE
//
// If we are build Unicode, then this is the ANSI version
// of the above function.
//

int WINAPI Str_GetPtrA(LPCSTR pszCurrent, LPSTR pszBuf, int cchBuf)
{
    int cchToCopy;

    if (!pszCurrent)
    {
        ASSERT(FALSE);

        if (cchBuf > 0)
        {
            *pszBuf = '\0';
        }

        return 0;
    }

    cchToCopy = lstrlenA(pszCurrent);

    // if pszBuf is NULL, or they passed cchBuf = 0, return the needed buff size
    if (!pszBuf || !cchBuf)
    {
        return cchToCopy + 1;
    }
    
    if (cchToCopy >= cchBuf)
    {
        cchToCopy = cchBuf - 1;
    }

    CopyMemory(pszBuf, pszCurrent, cchToCopy * sizeof(CHAR));
    pszBuf[cchToCopy] = TEXT('\0');

    return cchToCopy + 1;
}

#else

//
// Unicode stub if this code is built ANSI
//

int WINAPI Str_GetPtrW(LPCWSTR psz, LPWSTR pszBuf, int cchBuf)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return -1;
}

#endif

//
// This function is not exported.
//

BOOL Str_Set(LPTSTR *ppsz, LPCTSTR psz)
{
    if (!psz || (psz == LPSTR_TEXTCALLBACK))
    {
        if (*ppsz)
        {
            if (*ppsz != (LPSTR_TEXTCALLBACK))
                LocalFree(*ppsz);
        }
        *ppsz = (LPTSTR)psz;
    }
    else
    {
        LPTSTR pszNew = *ppsz;
        UINT cbSize = (lstrlen(psz) + 1) * sizeof(TCHAR);

        if (pszNew == LPSTR_TEXTCALLBACK)
            pszNew = NULL;
        
        pszNew = CCLocalReAlloc(pszNew, cbSize);

        if (!pszNew)
            return FALSE;

        lstrcpy(pszNew, psz);
        *ppsz = pszNew;
    }
    return TRUE;
}

// Set *ppszCurrent to a copy of pszNew, and free the previous value, if necessary
//
// WARNING:  This same code is duplicated below
//
BOOL WINAPI Str_SetPtr(LPTSTR * ppszCurrent, LPCTSTR pszNew)
{
    int cchLength;
    LPTSTR pszOld;
    LPTSTR pszNewCopy = NULL;

    if (pszNew)
    {
        cchLength = lstrlen(pszNew);

        // alloc a new buffer w/ room for the null terminator
        pszNewCopy = (LPTSTR) Alloc((cchLength + 1) * sizeof(TCHAR));

        if (!pszNewCopy)
            return FALSE;

        lstrcpyn(pszNewCopy, pszNew, cchLength + 1);
    }
    
    pszOld = InterlockedExchangePointer((void **)ppszCurrent, pszNewCopy);

    if (pszOld)
        Free(pszOld);

    return TRUE;
}

#ifdef UNICODE
//
// ANSI stub when built Unicode.
//

BOOL WINAPI Str_SetPtrA(LPSTR * ppszCurrent, LPCSTR pszNew)
{
    int cchLength;
    LPSTR pszOld;
    LPSTR pszNewCopy = NULL;

    if (pszNew)
    {
        cchLength = lstrlenA(pszNew);

        // alloc a new buffer w/ room for the null terminator
        pszNewCopy = (LPSTR) Alloc((cchLength + 1) * sizeof(CHAR));

        if (!pszNewCopy)
            return FALSE;

        lstrcpynA(pszNewCopy, pszNew, cchLength + 1);
    }

    pszOld = InterlockedExchangePointer((void **)ppszCurrent, pszNewCopy);

    if (pszOld)
        Free(pszOld);

    return TRUE;
}

#else
// Unicode stub if this is built ANSI

BOOL WINAPI Str_SetPtrW(LPWSTR *ppwzCurrent, LPCWSTR pszNew)
{
    int cchLength;
    LPWSTR pwzOld;
    LPWSTR pwzNewCopy = NULL;

    if (pszNew)
    {
        cchLength = lstrlenW(pszNew);       // Yes this is implemented on Win95.

        // alloc a new buffer w/ room for the null terminator
        pwzNewCopy = (LPWSTR) Alloc((cchLength + 1) * sizeof(WCHAR));

        if (!pwzNewCopy)
            return FALSE;

        // lstrcpynW is thunked in unicwrap.cpp for Win95 machines.
        StrCpyNW(pwzNewCopy, pszNew, cchLength + 1);
    }

    pwzOld = InterlockedExchangePointer((void **)ppwzCurrent, pwzNewCopy);

    if (pwzOld)
        Free(pwzOld);

    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\dlgcvt.cpp ===
//
// This module provides the following functions:
//
//      CvtDlgToDlgEx - Converts a DLGTEMPLATE to a DLGTEMPLATEEX
//
//
#include "ctlspriv.h"


#include "dlgcvt.h"

//
// Define the amount (bytes) the stream buffer grows when required.
// It will grow enough to satisfy the required write PLUS this
// amount.
//
#ifdef DEBUG
#   define STREAM_GROW_BYTES 32     // Exercise stream growth.
#else
#   define STREAM_GROW_BYTES 512
#endif

//
// Simple MIN/MAX inline helpers.
//

#if (defined UNIX && defined ux10)
//IEUNIX: hp's version of "/usr/local/include/sys/param.h defines MAX and MIN
//macro's and breaks hp's build
#undef MAX(a,b)
#undef MIN(a,b)
#endif //UNIX && ux10

template <class T>
inline const T& MIN(const T& a, const T& b)
{
    return a < b ? a : b;
}

template <class T>
inline const T& MAX(const T& a, const T& b)
{
    return a > b ? a : b;
}

//
// This class implements a simple dynamic stream that grows as you
// add data to it.  It's modeled after the strstream class provided
// by the C++ std lib.  Unlike the std lib implementation, this one
// doesn't require C++ EH to be enabled.  If comctl32 compiled with
// C++ EH enabled, I would have used strstream instead.
// [brianau - 10/5/98]
// 
class CByteStream
{
    public:
        explicit CByteStream(int cbDefGrow = 512);
        ~CByteStream(void);

        //
        // Used as argument to AlignXXXX member functions.
        //
        enum AlignType { eAlignWrite, eAlignRead };
        //
        // Basic read/write functions.
        //
        int Read(LPVOID pb, int cb);
        int Write(const VOID *pb, int cb);
        //
        // Determine if there was an error when reading or 
        // writing to the stream.
        //
        bool ReadError(void) const
            { return m_bReadErr; }

        bool WriteError(void) const
            { return m_bWriteErr; }
        //
        // Reset the stream read or write pointer.
        //
        void ResetRead(void)
            { m_pbRead = m_pbBuf; m_bReadErr = false; }

        void ResetWrite(void)
            { m_pbWrite = m_pbBuf; m_bWriteErr = false; }
        //
        // Reset the stream.
        //
        void Reset(void);
        //
        // These functions align the read and write stream pointers.
        //
        void AlignReadWord(void)
            { Align(eAlignRead, sizeof(WORD)); }

        void AlignReadDword(void)
            { Align(eAlignRead, sizeof(DWORD)); }

        void AlignReadQword(void)
            { Align(eAlignRead, sizeof(ULONGLONG)); }

        void AlignWriteWord(void)
            { Align(eAlignWrite, sizeof(WORD)); }

        void AlignWriteDword(void)
            { Align(eAlignWrite, sizeof(DWORD)); }

        void AlignWriteQword(void)
            { Align(eAlignWrite, sizeof(ULONGLONG)); }

        //
        // GetBuffer returns the address of the stream buffer in memory.
        // The buffer is "frozen" so it will not be released if the stream
        // object is destroyed.  At this point, you own the buffer.
        // If bPermanent is false, you can call ReleaseBuffer to return 
        // control of the buffer to the stream object.
        //
        LPBYTE GetBuffer(bool bPermanent = false);
        //
        // ReleaseBuffer returns control of the buffer obtained with GetBuffer
        // to the stream object.
        //
        bool ReleaseBuffer(LPBYTE pbBuf);
        //
        // Overload the insertion and extraction operators so we can
        // work like a normal std lib stream class.
        //
        template <class T>
        CByteStream& operator >> (T& x)
            { Read(&x, sizeof(x)); return *this; }

        template <class T>
        CByteStream& operator << (const T& x)
            { Write(&x, sizeof(x)); return *this; }

    private:
        int    m_cbDefGrow;  // Default amount (bytes) to grow when expanding buffer.
        LPBYTE m_pbBuf;      // Addr of allocated buffer.
        LPBYTE m_pbRead;     // Addr for next read.
        LPBYTE m_pbWrite;    // Addr for next write.
        LPBYTE m_pbEnd;      // Addr of byte following last byte in buffer.
        bool   m_bWriteErr;  // Any read errors?
        bool   m_bReadErr;   // Any write errors?
        bool   m_bOwnsBuf;   // true == delete buffer in dtor.

        //
        // Expand the buffer as needed.
        //
        bool GrowBuffer(int cb = 0);
        //
        // Align the read or write buffer pointer.
        // Used internally by the AlignXXXXX member functions.
        //
        void Align(AlignType a, size_t n);
        //
        // Internal consistency checks for debug builds.
        //
        void Validate(void) const;
        //
        // Prevent copy.
        //
        CByteStream(const CByteStream& rhs);
        CByteStream& operator = (const CByteStream& rhs);
};


//
// Class for converting in-memory dialog templates between the two
// structures DLGTEMPLATE <-> DLGTEMPLATEEX.
//
// Currently, the object only converts from DLGTEMPLATE -> DLGTEMPLATEEX.
// It would be simple to create the code for the inverse conversion.  However,
// it's currently not needed so I didn't create it.
//
class CDlgTemplateConverter
{
    public:
        explicit CDlgTemplateConverter(int iCharSet = DEFAULT_CHARSET)
            : m_iCharset(iCharSet),
              m_stm(STREAM_GROW_BYTES) { }

        ~CDlgTemplateConverter(void) { }

        HRESULT DlgToDlgEx(LPDLGTEMPLATE pTemplateIn, LPDLGTEMPLATEEX *ppTemplateOut);

        HRESULT DlgExToDlg(LPDLGTEMPLATEEX pTemplateIn, LPDLGTEMPLATE *ppTemplateOut)
            { return E_NOTIMPL; }

    private:
        int         m_iCharset;
        CByteStream m_stm;       // For converted template.

#ifndef UNIX
        HRESULT DlgHdrToDlgEx(CByteStream& s, LPWORD *ppw);
        HRESULT DlgItemToDlgEx(CByteStream& s, LPWORD *ppw);
#else
        HRESULT DlgHdrToDlgEx(CByteStream& s, LPDWORD *ppw);
        HRESULT DlgItemToDlgEx(CByteStream& s, LPDWORD *ppw);
#endif

        HRESULT DlgExHdrToDlg(CByteStream& s, LPWORD *ppw)
            { return E_NOTIMPL; }
        HRESULT DlgExItemToDlg(CByteStream& s, LPWORD *ppw)
            { return E_NOTIMPL; }
        //
        // Copy a string from pszW into a CByteStream object.
        // Copies at most cch chars.  If cch is -1, assumes the string is 
        // nul-terminated and will copy all chars in string including
        // terminating NULL.
        //
        int CopyStringW(CByteStream& stm, LPWSTR pszW, int cch = -1);
        //
        // Prevent copy.
        //
        CDlgTemplateConverter(const CDlgTemplateConverter& rhs);
        CDlgTemplateConverter& operator = (const CDlgTemplateConverter& rhs);
};


//
// Generic alignment function.
// Give it an address and an alignment size and it returns
// the address adjusted for the requested alignment.
//
// n :  2 = 16-bit
//      4 = 32-bit
//      8 = 64-bit
//
LPVOID Align(LPVOID pv, size_t n)
{
    const ULONG_PTR x = static_cast<ULONG_PTR>(n) - 1;
    return reinterpret_cast<LPVOID>((reinterpret_cast<ULONG_PTR>(pv) + x) & ~x);
}

inline LPVOID AlignWord(LPVOID pv)
{
    return ::Align(pv, sizeof(WORD));
}

inline LPVOID AlignDWord(LPVOID pv)
{
    return ::Align(pv, sizeof(DWORD));
}

inline LPVOID AlignQWord(LPVOID pv)
{
    return ::Align(pv, sizeof(ULONGLONG));
}



CByteStream::CByteStream(
    int cbDefGrow
    ) : m_cbDefGrow(MAX(cbDefGrow, 1)),
        m_pbBuf(NULL),
        m_pbRead(NULL),
        m_pbWrite(NULL),
        m_pbEnd(NULL),
        m_bWriteErr(false),
        m_bReadErr(false),
        m_bOwnsBuf(true) 
{ 

}


CByteStream::~CByteStream(
    void
    )
{
    if (m_bOwnsBuf && NULL != m_pbBuf)
    {
        LocalFree(m_pbBuf);
    }
}

//
// Simple checks to validate stream state.
// In non-debug builds, this will be a no-op.
// Use ASSERT_VALIDSTREAM macro.
//
void
CByteStream::Validate(
    void
    ) const
{
    ASSERT(m_pbEnd >= m_pbBuf);
    ASSERT(m_pbWrite >= m_pbBuf);
    ASSERT(m_pbRead >= m_pbBuf);
    ASSERT(m_pbWrite <= m_pbEnd);
    ASSERT(m_pbRead <= m_pbEnd);
}

#ifdef DEBUG
#   define ASSERT_VALIDSTREAM(ps)  ps->Validate()
#else
#   define ASSERT_VALIDSTREAM(ps)
#endif

//
// Read "cb" bytes from the stream and write them to 
// the location specified in "pb".  Return number
// of bytes read.  Note that if we don't "own" the
// buffer (i.e. the client has called GetBuffer but
// not ReleaseBuffer), no read will occur.
//
int 
CByteStream::Read(
    LPVOID pb,
    int cb
    )
{
    ASSERT_VALIDSTREAM(this);

    int cbRead = 0;
    if (m_bOwnsBuf)
    {
        cbRead = MIN(static_cast<int>(m_pbEnd - m_pbRead), cb);
        CopyMemory(pb, m_pbRead, cbRead);
        m_pbRead += cbRead;
        if (cb != cbRead)
            m_bReadErr = true;
    }

    ASSERT_VALIDSTREAM(this);

    return cbRead;
}


//
// Write "cb" bytes from location "pb" into the stream.
// Return number of bytes written.  Note that if we don't "own" the
// buffer (i.e. the client has called GetBuffer but
// not ReleaseBuffer), no write will occur.
//
int 
CByteStream::Write(
    const VOID *pb,
    int cb
    )
{
    ASSERT_VALIDSTREAM(this);

    int cbWritten = 0;
    if (m_bOwnsBuf)
    {
        if (m_pbWrite + cb < m_pbEnd || 
            GrowBuffer(static_cast<int>(m_pbEnd - m_pbBuf) + cb + m_cbDefGrow))
        {
            CopyMemory(m_pbWrite, pb, cb);
            m_pbWrite += cb;
            cbWritten = cb;
        }
        else
            m_bWriteErr = true;
    }

    ASSERT_VALIDSTREAM(this);

    return cbWritten;
}

//
// Reallocate the buffer by cb or m_cbDefGrow.
// Copy existing contents to new buffer.  All internal
// pointers are updated.
//
bool 
CByteStream::GrowBuffer(
    int cb               // optional.  Default is 0 causing us to use m_cbDefGrow.
    )
{
    bool bResult         = false;
    int cbGrow           = 0 < cb ? cb : m_cbDefGrow;
    ULONG_PTR ulReadOfs  = m_pbRead - m_pbBuf;
    ULONG_PTR ulWriteOfs = m_pbWrite - m_pbBuf;
    ULONG_PTR cbAlloc    = m_pbEnd - m_pbBuf;
    LPBYTE pNew = static_cast<LPBYTE>(LocalAlloc(LPTR, cbAlloc + cbGrow));
    if (NULL != pNew)
    {
        if (NULL != m_pbBuf)
        {
            CopyMemory(pNew, m_pbBuf, cbAlloc);
            LocalFree(m_pbBuf);
        }
        m_pbBuf   = pNew;
        m_pbRead  = m_pbBuf + ulReadOfs;
        m_pbWrite = m_pbBuf + ulWriteOfs;
        m_pbEnd   = m_pbBuf + cbAlloc + cbGrow;
        bResult   = true;
    }

    ASSERT_VALIDSTREAM(this);
    return bResult;
}

//
// Align the read or write pointer on the stream.
// The write pointer is aligned by padding skipped bytes with 0.
//
void
CByteStream::Align(
    CByteStream::AlignType a,
    size_t n
    )
{
    static const BYTE fill[8] = {0};
    if (m_bOwnsBuf)
    {
        switch(a)
        {
            case eAlignWrite:
                Write(fill, static_cast<int>(reinterpret_cast<LPBYTE>(::Align(m_pbWrite, n)) - m_pbWrite));
                break;

            case eAlignRead:
                m_pbRead = reinterpret_cast<LPBYTE>(::Align(m_pbRead, n));
                if (m_pbRead >= m_pbEnd)
                    m_bReadErr = true;
                break;

            default:
                break;
        }
    }
    ASSERT_VALIDSTREAM(this);
}


//
// Caller takes ownership of the buffer.
//
LPBYTE 
CByteStream::GetBuffer(
    bool bPermanent       // optional.  Default is false.
    )
{ 
    LPBYTE pbRet = m_pbBuf;
    if (bPermanent)
    {
        //
        // Caller now permanently owns the buffer.
        // Can't return it through ReleaseBuffer().
        // Reset the internal stream control values.
        //
        m_pbBuf = m_pbWrite = m_pbRead = m_pbEnd = NULL;
        m_bWriteErr = m_bReadErr = false;
        m_bOwnsBuf = true;
    }
    else
    {
        //
        // Caller now owns the buffer but it can be returned
        // through ReleaseBuffer().
        //
        m_bOwnsBuf = false; 
    }
    return pbRet; 
}


//
// Take back ownership of the buffer.
// Returns:  
//
//      true   = CByteStream object took back ownership.
//      false  = CByteStream object couldn't take ownership.
//
bool 
CByteStream::ReleaseBuffer(
    LPBYTE pbBuf
    )
{
    if (pbBuf == m_pbBuf)
    {
        m_bOwnsBuf = true;
        return true;
    }
    return false;
}
     

//
// Reset the stream.
//
void 
CByteStream::Reset(
    void
    )
{
    if (NULL != m_pbBuf)
    {
        LocalFree(m_pbBuf);
    }
    m_pbBuf = m_pbWrite = m_pbRead = m_pbEnd = NULL;
    m_bWriteErr = m_bReadErr = false;
    m_bOwnsBuf = true;
}


//
// Copy one or more WORDs from the location provided in "pszW" into
// the stream.  If cch is -1, it's assumed that the string is nul-terminated.
// Returns the number of WCHARs written.
//    
int 
CDlgTemplateConverter::CopyStringW(
    CByteStream& stm,
    LPWSTR pszW,
    int cch
    )
{
    if (-1 == cch)
        cch = lstrlenW(pszW) + 1;
    return stm.Write(pszW, cch * sizeof(WCHAR)) / sizeof(WCHAR);
}

//
// Convert a DLGTEMPLATE structure to a DLGTEMPLATEEX structure.
// pti is the address of the DLGTEMPLATE to be converted.
// ppto points to a LPDLGTEMPLATEEX ptr to receive the address of the
// converted template structure.  Caller is responsible for freeing
// this buffer with LocalFree.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT
CDlgTemplateConverter::DlgToDlgEx(
    LPDLGTEMPLATE pti,
    LPDLGTEMPLATEEX *ppto
    )
{
    HRESULT hr = NOERROR;
#ifndef UNIX
    LPWORD pw = reinterpret_cast<LPWORD>(pti);
#else
    LPDWORD pw = reinterpret_cast<LPDWORD>(pti);
#endif

    *ppto = NULL;

    //
    // Reset the stream.
    //
    m_stm.Reset();
    //
    // Convert DLGTEMPLATE -> DLGTEMPLATEEX
    //
    hr = DlgHdrToDlgEx(m_stm, &pw);
    //
    // Convert each DLGITEMTEMPLATE -> DLGITEMTEMPLATEEX
    //
    for (int i = 0; i < pti->cdit && SUCCEEDED(hr); i++)
    {
#ifndef UNIX
        pw = reinterpret_cast<LPWORD>(::AlignDWord(pw));
#else
        pw = reinterpret_cast<LPDWORD>(::AlignDWord(pw));
#endif
        m_stm.AlignWriteDword();
        hr = DlgItemToDlgEx(m_stm, &pw);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Return the buffer to the caller.  Buffer is permanently
        // detached from the stream object so the stream's dtor
        // won't free it.
        //
        *ppto = reinterpret_cast<LPDLGTEMPLATEEX>(m_stm.GetBuffer(true));    
    }
    return hr;
};


//
// Convert DLGTEMPLATE -> DLGTEMPLATEEX
//
// s   = Stream to hold converted template.
// ppw = Address of current read pointer into the template being converted.
//       On exit, the referenced pointer is updated with the current read location.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT
CDlgTemplateConverter::DlgHdrToDlgEx(
    CByteStream& s,
#ifndef UNIX
    LPWORD *ppw
#else
    LPDWORD *ppw
#endif
    )
{
#ifndef UNIX
    LPWORD pw = *ppw;
#else
    LPDWORD pw = *ppw;
#endif
    LPDLGTEMPLATE pt = reinterpret_cast<LPDLGTEMPLATE>(pw);

    //
    // Convert the fixed-length stuff.
    //
    s << static_cast<WORD>(1)                        // wDlgVer
      << static_cast<WORD>(0xFFFF)                   // wSignature
      << static_cast<DWORD>(0)                       // dwHelpID
      << static_cast<DWORD>(pt->dwExtendedStyle)
      << static_cast<DWORD>(pt->style)
      << static_cast<WORD>(pt->cdit)
      << static_cast<short>(pt->x)
      << static_cast<short>(pt->y)
      << static_cast<short>(pt->cx)
      << static_cast<short>(pt->cy);

    //
    // Arrays are always WORD aligned.
    //
#ifndef UNIX
    pw = reinterpret_cast<LPWORD>(::AlignWord(reinterpret_cast<LPBYTE>(pw) + sizeof(DLGTEMPLATE)));
    s.AlignWriteWord();
#else
    pw = reinterpret_cast<LPDWORD>(::AlignDWord(reinterpret_cast<LPBYTE>(pw) + sizeof(DLGTEMPLATE)));
    s.AlignWriteDword();
#endif

    //
    // Copy the menu array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            //
            // Fall through...
            //
        case 0x0000:
            s << *pw++;
            break;
                        
        default:
#ifndef UNIX
            pw += CopyStringW(s, (LPWSTR)pw);
#else
            pw += CopyStringW (s, reinterpret_cast<LPWSTR>(pw));
#endif
            break;
    };
    //
    // Copy the class array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            //
            // Fall through...
            //
        case 0x0000:
            s << *pw++;
            break;
            
        default:
#ifndef UNIX
            pw += CopyStringW(s, (LPWSTR)pw);
#else
            pw += CopyStringW (s, reinterpret_cast<LPWSTR>(pw));
#endif
            break;
    };
    //
    // Copy the title array.
    //
    switch(*pw)
    {
        case 0x0000:
            s << *pw++;
            break;

        default:
#ifndef UNIX
            pw += CopyStringW(s, (LPWSTR)pw);
#else
            pw += CopyStringW (s, reinterpret_cast<LPWSTR>(pw));
#endif
            break;
    };
    //
    // Copy font information if it's present.
    //
    if (DS_SETFONT & pt->style)
    {
        s << *pw++;                              // pt size
        s << static_cast<WORD>(FW_NORMAL);       // weight (default, not in DLGTEMPLATE)
        s << static_cast<BYTE>(FALSE);           // italic (default, not in DLGTEMPLATE)
        s << static_cast<BYTE>(m_iCharset);        // charset (default if not given, 
                                                 //          not in DLGTEMPLATE)
#ifndef UNIX
        pw += CopyStringW(s, (LPWSTR)pw);
#else
        pw += CopyStringW (s, reinterpret_cast<LPWSTR>(pw));
#endif
    }

    *ppw = pw;

    return s.WriteError() ? E_OUTOFMEMORY : NOERROR;
}


//
// Convert DLGITEMTEMPLATE -> DLGITEMTEMPLATEEX
//
// s   = Stream to hold converted template.
// ppw = Address of current read pointer into the template being converted.
//       On exit, the referenced pointer is updated with the current read location.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT
CDlgTemplateConverter::DlgItemToDlgEx(
    CByteStream& s,
#ifndef UNIX
    LPWORD *ppw
#else
    LPDWORD *ppw
#endif
    )
{
#ifndef UNIX
    LPWORD pw = *ppw;
#else
    LPDWORD pw = *ppw;
#endif
    LPDLGITEMTEMPLATE pit = reinterpret_cast<LPDLGITEMTEMPLATE>(pw);

    //
    // Convert the fixed-length stuff.
    //
    s << static_cast<DWORD>(0)                     // dwHelpID
      << static_cast<DWORD>(pit->dwExtendedStyle)
      << static_cast<DWORD>(pit->style)
      << static_cast<short>(pit->x)
      << static_cast<short>(pit->y)
      << static_cast<short>(pit->cx)
      << static_cast<short>(pit->cy)
      << static_cast<DWORD>(pit->id);

    //
    // Arrays are always word aligned.
    //
#ifndef UNIX
    pw = reinterpret_cast<LPWORD>(::AlignWord(reinterpret_cast<LPBYTE>(pw) + sizeof(DLGITEMTEMPLATE)));
    s.AlignWriteWord();
#else
    pw = reinterpret_cast<LPDWORD>(::AlignWord(reinterpret_cast<LPBYTE>(pw) + sizeof(DLGITEMTEMPLATE)));
    s.AlignWriteDword();
#endif
    //
    // Copy the class array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            s << *pw++;   // Class code.
            break;
            
        default:
#ifndef UNIX
            pw += CopyStringW(s, (LPWSTR)pw);
#else
            pw += CopyStringW (s, reinterpret_cast<LPWSTR>(pw));
#endif
            break;
    };
    //
    // Copy the title array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            s << *pw++;   // Resource ordinal value.
            break;
            
        default:
#ifndef UNIX
            pw += CopyStringW(s, (LPWSTR)pw);
#else
            pw += CopyStringW (s, reinterpret_cast<LPWSTR>(pw));
#endif
            break;
    };
    //
    // Copy the creation data.
    // *pw is either 0 or the number of bytes of creation data,
    // including *pw.
    //
    switch(*pw)
    {
        case 0x0000:
            s << *pw++;
            break;

        default:
#ifndef UNIX
            pw += s.Write(pw, *pw) / sizeof(WORD);
#else
            pw += s.Write(pw, *pw) / sizeof(DWORD);
#endif
            break;
    };

    *ppw = pw;

    return s.WriteError() ? E_OUTOFMEMORY : NOERROR;
}


//
// This is the public function for converting a DLGTEMPLATE to
// a DLGTEMPLATEEX.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT 
CvtDlgToDlgEx(
    LPDLGTEMPLATE pTemplate, 
    LPDLGTEMPLATEEX *ppTemplateExOut,
    int iCharset
    )
{
    CDlgTemplateConverter dtc(iCharset);
    return dtc.DlgToDlgEx(pTemplate, ppTemplateExOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\draglist.c ===
#include "ctlspriv.h"

#define DF_ACTUALLYDRAG	0x0001
#define DF_DEFERRED	0x0002

#define INITLINESPERSECOND	6
#define VERTCHANGENUMLINES	25

#define TIMERID		238
#define TIMERLEN	50

#define DX_INSERT	16
#define DY_INSERT	16


typedef struct {
    HWND hwndDrag;
    UINT uFlags;
} DRAGPROP, *PDRAGPROP;

UINT uDragListMsg = 0;
#ifndef WINNT
#pragma data_seg(DATASEG_READONLY)
#endif
const TCHAR szDragListMsgString[] = DRAGLISTMSGSTRING;
#ifndef WINNT
#pragma data_seg()
#endif

BOOL PtInLBItem(HWND hLB, int nItem, POINT pt, int xInflate, int yInflate)
{
  RECT rc;

  if (nItem < 0)
      nItem = (int)SendMessage(hLB, LB_GETCURSEL, 0, 0L);

  if (SendMessage(hLB, LB_GETITEMRECT, nItem, (LPARAM)(LPRECT)&rc) == LB_ERR)
      return(FALSE);

  InflateRect(&rc, xInflate, yInflate);

  return(PtInRect(&rc, pt));
}


/*
 * DragListSubclassProc
 * --------------------
 *
 * Window procedure for subclassed list boxes
 */
LRESULT CALLBACK DragListSubclassProc(HWND hLB, UINT uMsg, WPARAM wParam,
      LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  PDRAGPROP pDragProp;
  DRAGLISTINFO sNotify;
  BOOL bDragging;
  POINT pt;

  pDragProp = (PDRAGPROP)dwRefData;
  bDragging = pDragProp->hwndDrag == hLB;

  switch (uMsg)
    {
      case WM_NCDESTROY:
        if (bDragging)
            SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);	/* cancel drag */

        RemoveWindowSubclass(hLB, DragListSubclassProc, 0);

        if (pDragProp)
            LocalFree((HLOCAL)pDragProp);
        break;

      case WM_LBUTTONDOWN:
        {
          int nItem;

          if (bDragging)				/* nested button-down */
              SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);	/* cancel drag */

          SetFocus(hLB);

          pt.x = GET_X_LPARAM(lParam);
          pt.y = GET_Y_LPARAM(lParam);
          ClientToScreen(hLB, &pt);
          nItem = LBItemFromPt(hLB, pt, FALSE);

          if (nItem >= 0)
            {
              SendMessage(hLB, LB_SETCURSEL, nItem, 0L);
              if (GetWindowLong(hLB, GWL_STYLE) & LBS_NOTIFY)
                  SendMessage(GetParent(hLB), WM_COMMAND,
                              GET_WM_COMMAND_MPS(GetDlgCtrlID(hLB), hLB, LBN_SELCHANGE));
              sNotify.uNotification = DL_BEGINDRAG;
              goto QueryParent;
            }
          else
              goto FakeDrag;
        }

      case WM_TIMER:
        if (wParam != TIMERID)
            break;
        lParam = GetMessagePosClient(hLB, &pt);


        // fall through
      case WM_MOUSEMOVE:
	if (bDragging)
	  {
	    HWND hwndParent;
	    LRESULT lResult;

	    /* We may be just simulating a drag, but not actually doing
	     * anything.
	     */
	    if (!(pDragProp->uFlags&DF_ACTUALLYDRAG))
		return(0L);

	    /* We don't want to do any dragging until the user has dragged
	     * outside of the current selection.
	     */
	    if (pDragProp->uFlags & DF_DEFERRED)
	      {
                pt.x = GET_X_LPARAM(lParam);
                pt.y = GET_Y_LPARAM(lParam);
		if (PtInLBItem(hLB, -1, pt, 0, 4))
		    return 0;
		pDragProp->uFlags &= ~DF_DEFERRED;
	      }

	    sNotify.uNotification = DL_DRAGGING;

QueryParent:
	    hwndParent = GetParent(hLB);
	    sNotify.hWnd = hLB;

            sNotify.ptCursor.x = GET_X_LPARAM(lParam);
            sNotify.ptCursor.y = GET_Y_LPARAM(lParam);
	    ClientToScreen(hLB, &sNotify.ptCursor);

            lResult = SendMessage(hwndParent, uDragListMsg, GetDlgCtrlID(hLB),
		  (LPARAM)(LPDRAGLISTINFO)&sNotify);

	    if (uMsg == WM_LBUTTONDOWN)
	      {
		/* Some things may not be draggable
		 */
		if (lResult)
		  {
		    SetTimer(hLB, TIMERID, TIMERLEN, NULL);
		    pDragProp->uFlags = DF_DEFERRED | DF_ACTUALLYDRAG;
		  }
		else
		  {
FakeDrag:
		    pDragProp->uFlags = 0;
		  }

		/* Set capture and change mouse cursor
		 */
		pDragProp->hwndDrag = hLB;

		SetCapture(hLB);
	      }
	    else
	      {
		switch (lResult)
		  {
		    case DL_STOPCURSOR:
                      SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_NO)));
		      break;

		    case DL_COPYCURSOR:
                      SetCursor(LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_COPY)));
		      break;

		    case DL_MOVECURSOR:
                      SetCursor(LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_MOVE)));
		      break;

		    default:
		      break;
		  }
	      }

	    /* Don't call the def proc, since it may try to change the
	     * selection or set timers or things like that.
	     */
	    return(0L);
	  }
	break;

      case  WM_RBUTTONDOWN:
      case  WM_LBUTTONUP:
	/* if we are capturing mouse - release it and check for acceptable place
	 * where mouse is now to decide drop or not
	 */
	if (bDragging)
	  {
	    HWND hwndParent;

	    pDragProp->hwndDrag = NULL;
	    KillTimer(hLB, TIMERID);
	    ReleaseCapture();
	    SetCursor(LoadCursor(NULL, IDC_ARROW));

	    hwndParent = GetParent(hLB);

	    sNotify.uNotification = uMsg==WM_LBUTTONUP ? DL_DROPPED : DL_CANCELDRAG;
	    sNotify.hWnd = hLB;
            sNotify.ptCursor.x = GET_X_LPARAM(lParam);
            sNotify.ptCursor.y = GET_Y_LPARAM(lParam);
	    ClientToScreen(hLB, &sNotify.ptCursor);

	    SendMessage(hwndParent, uDragListMsg, GetDlgCtrlID(hLB),
		  (LPARAM)(LPDRAGLISTINFO)&sNotify);

	    /* We need to make sure to return 0 in case this is from a
	     * keyboard message.
	     */
	    return(0L);
	  }
	break;

      case WM_GETDLGCODE:
	if (bDragging)
          {
            return (DefSubclassProc(hLB, uMsg, wParam, lParam) |
                DLGC_WANTMESSAGE);
          }
	break;

      case WM_KEYDOWN:
        if (wParam == VK_ESCAPE)
          {
            SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);
          }
        // fall through
      case WM_CHAR:
      case WM_KEYUP:
	/* We don't want the listbox processing this if we are dragging.
	 */
	if (bDragging)
	    return(0L);
	break;

      default:
	break;
    }

  return(DefSubclassProc(hLB, uMsg, wParam, lParam));
}


BOOL WINAPI MakeDragList(HWND hLB)
{
  PDRAGPROP pDragProp;

  if (!uDragListMsg)
      uDragListMsg = RegisterWindowMessage(szDragListMsgString);

  /* Check that we have not already subclassed this window.
   */
  if (GetWindowSubclass(hLB, DragListSubclassProc, 0, NULL))
      return(TRUE);

  pDragProp = (PDRAGPROP)LocalAlloc(LPTR, sizeof(DRAGPROP));
  if (!pDragProp)
      return(FALSE);

  if (!SetWindowSubclass(hLB, DragListSubclassProc, 0, (DWORD_PTR)pDragProp))
  {
      LocalFree((HLOCAL)pDragProp);
      return(FALSE);
  }

  return(TRUE);
}


int WINAPI LBItemFromPt(HWND hLB, POINT pt, BOOL bAutoScroll)
{
  static LONG dwLastScroll = 0;

  RECT rc;
  DWORD dwNow;
  int nItem;
  WORD wScrollDelay, wActualDelay;

  ScreenToClient(hLB, &pt);
  GetClientRect(hLB, &rc);

  nItem = (int)SendMessage(hLB, LB_GETTOPINDEX, 0, 0L);

  /* Is the point in the LB client area?
   */
  if (PtInRect(&rc, pt))
    {
      /* Check each visible item in turn.
       */
      for ( ; ; ++nItem)
	{
	  if (SendMessage(hLB, LB_GETITEMRECT, nItem, (LPARAM)(LPRECT)&rc)
		== LB_ERR)
	      break;

	  if (PtInRect(&rc, pt))
	      return(nItem);
	}
    }
  else
    {
      /* If we want autoscroll and the point is directly above or below the
       * LB, determine the direction and if it is time to scroll yet.
       */
      if (bAutoScroll && (UINT)pt.x<(UINT)rc.right)
	{
	  if (pt.y <= 0)
	    {
	      --nItem;
	    }
	  else
	    {
	      ++nItem;
	      pt.y = rc.bottom - pt.y;
	    }
	  wScrollDelay = (WORD)(1000 /
		(INITLINESPERSECOND - pt.y/VERTCHANGENUMLINES));

	  dwNow = GetTickCount();
	  wActualDelay = (WORD)(dwNow - dwLastScroll);

	  if (wActualDelay > wScrollDelay)
	    {
	      /* This will the actual number of scrolls per second to be
	       * much closer to the required number.
	       */
	      if (wActualDelay > wScrollDelay * 2)
		  dwLastScroll = dwNow;
	      else
		  dwLastScroll += wScrollDelay;

	      SendMessage(hLB, LB_SETTOPINDEX, nItem, 0L);
	    }
	}
    }

  return(-1);
}


void WINAPI DrawInsert(HWND hwndParent, HWND hLB, int nItem)
{
  static POINT ptLastInsert;
  static int nLastInsert = -1;

  RECT rc;

  /* Erase the old mark if necessary
   */
  if (nLastInsert>=0 && nItem!=nLastInsert)
    {
      rc.left = ptLastInsert.x;
      rc.top = ptLastInsert.y;
      rc.right = rc.left + DX_INSERT;
      rc.bottom = rc.top + DY_INSERT;

      /* Need to update immediately in case the insert rects overlap.
       */
      InvalidateRect(hwndParent, &rc, TRUE);
      UpdateWindow(hwndParent);

      nLastInsert = -1;
    }

  /* Draw a new mark if necessary
   */
  if (nItem!=nLastInsert && nItem>=0)
    {
      HICON hInsert = NULL;

      if (!hInsert)
	  hInsert = LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(IDI_INSERT));

      if (hInsert)
	{
	  HDC hDC;

	  GetWindowRect(hLB, &rc);
	  ScreenToClient(hLB, (LPPOINT)&rc);
	  ptLastInsert.x = rc.left - DX_INSERT;

	  SendMessage(hLB, LB_GETITEMRECT, nItem, (LPARAM)(LPRECT)&rc);
	  ptLastInsert.y = rc.top - DY_INSERT/2;

	  nLastInsert = nItem;

	  ClientToScreen(hLB, &ptLastInsert);
	  ScreenToClient(hwndParent, &ptLastInsert);

	  hDC = GetDC(hwndParent);
	  DrawIcon(hDC, ptLastInsert.x, ptLastInsert.y, hInsert);
	  ReleaseDC(hwndParent, hDC);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\dlgcset.cpp ===
//
// File: dlgcset.cpp
//
// This file contains the code that implements CNativeFont class.
//
// history:
//     7-21-97 created; 
// 
#include "ctlspriv.h"
#include "ccontrol.h"

#define THISCLASS CNativeFont
#define SUPERCLASS CControl

typedef enum 
{
    FAS_NOTINITIALIZED = 0,
    FAS_DISABLED,
    FAS_ENABLED,
} FASTATUS;

class CNativeFont : public CControl
{
public:
    //Function Memebers
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT NativeFontWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
protected:
    
    CNativeFont();
    
    //Function Members    

    virtual void v_OnPaint(HDC hdc) ;
    virtual LRESULT v_OnCreate();
    virtual void v_OnSize(int x, int y)  {};

    virtual LRESULT v_OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT v_OnNotify(WPARAM wParam, LPARAM lParam);
    virtual DWORD v_OnStyleChanged(WPARAM wParam, LPARAM lParam) { return 0; };    
    
    HRESULT _GetNativeDialogFont(HWND hDlg);
    static HRESULT _GetFontAssocStatus(FASTATUS  *uiAssoced);
    static BOOL _SetFontEnumProc(HWND hwnd, LPARAM lparam);
    static LRESULT _SubclassDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uIdSubclass, ULONG_PTR dwRefData);

    HFONT   m_hfontOrg;
    HFONT   m_hfontNative;
    HFONT   m_hfontDelete;
    typedef struct {
                HFONT hfontSet;
                DWORD dwStyle;
            } NFENUMCHILDDATA;
    static FASTATUS _s_uiFontAssocStatus;
};

// static variable initialization
FASTATUS CNativeFont::_s_uiFontAssocStatus = FAS_NOTINITIALIZED;

// reg keys
static const TCHAR s_szRegFASettings[] = TEXT("System\\CurrentControlSet\\Control\\FontAssoc\\Associated Charset");

CNativeFont::CNativeFont(void)
{
    m_hfontOrg = NULL;
    m_hfontNative = NULL;
    m_hfontDelete = NULL;
}

LRESULT THISCLASS::NativeFontWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CNativeFont *pn = (CNativeFont *)GetWindowLongPtr(hwnd, 0);
    if (uMsg == WM_CREATE) {
        ASSERT(!pn);
        pn = new CNativeFont();
        if (!pn)
            return 0L;
    } 

    if (pn) {
        return pn->v_WndProc(hwnd, uMsg, wParam, lParam);
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void THISCLASS::v_OnPaint(HDC hdc)
{
    return;
}

LRESULT THISCLASS::v_OnCommand(WPARAM wParam, LPARAM lParam)
{
    // forward to parent (do we really need this?)
    return SendMessage(ci.hwndParent, WM_COMMAND, wParam, lParam);
}

LRESULT THISCLASS::v_OnNotify(WPARAM wParam, LPARAM lParam)
{
    // forward to parent
    LPNMHDR lpNmhdr = (LPNMHDR)lParam;
    
    return SendNotifyEx(ci.hwndParent, (HWND) -1,
                         lpNmhdr->code, lpNmhdr, ci.bUnicode);
}

LRESULT THISCLASS::v_OnCreate()
{
    return TRUE;
}

BOOL THISCLASS::_SetFontEnumProc(HWND hwnd, LPARAM lparam)
{
     NFENUMCHILDDATA *  pdt = (NFENUMCHILDDATA *)lparam; 
     BOOL bMatch = FALSE;
     
     if (pdt && pdt->hfontSet)
     {
         if (pdt->dwStyle & NFS_ALL)
         {
             bMatch = TRUE;
         }
         else
         {
             TCHAR szClass[32];
             
             GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
             
             if (pdt->dwStyle & NFS_EDIT)
             {
                 bMatch |= (lstrcmpi(TEXT("Edit"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("RichEdit20A"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("RichEdit20W"), szClass) == 0);
             }
             
             if (pdt->dwStyle & NFS_STATIC)
                 bMatch |= (lstrcmpi(TEXT("Static"), szClass) == 0);
             
             if (pdt->dwStyle & NFS_BUTTON)
                 bMatch |= (lstrcmpi(TEXT("Button"), szClass) == 0);

             if (pdt->dwStyle & NFS_LISTCOMBO)
             {
                 bMatch |= (lstrcmpi(TEXT("ListBox"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("ComboBox"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("ComboBoxEx32"), szClass) == 0);
                 bMatch |= (lstrcmpi(WC_LISTVIEW, szClass) == 0);
             }
         }

         if (bMatch) 
             SendMessage(hwnd, WM_SETFONT, (WPARAM)pdt->hfontSet, MAKELPARAM(FALSE, 0));

         return TRUE;
     }
     else
         return FALSE;
}

LRESULT THISCLASS::_SubclassDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uIdSubclass, ULONG_PTR dwRefData)
{
    LRESULT lret = 0;
    CNativeFont * pnf = (CNativeFont *)dwRefData;
    
    if (pnf)
    {
    
        switch (uMsg)
        {
            case WM_INITDIALOG:
                // we enumerate its children so they get font 
                // in native charset selected if necessary
                // 
                if (S_OK == pnf->_GetNativeDialogFont(hdlg))
                {
                    // S_OK means we have different charset from 
                    // the default of the platform on which we're 
                    // running.
                    NFENUMCHILDDATA dt;
                    dt.hfontSet = pnf->m_hfontNative;
                    dt.dwStyle = pnf->ci.style;
                    EnumChildWindows(hdlg, pnf->_SetFontEnumProc, (LPARAM)&dt);
                }
                // we no longer need subclass procedure.
                // assumes no one has subclassed this dialog by now
                break;

            case WM_DESTROY:
                // if we've created a font, we have to clean it up.
                if (pnf->m_hfontDelete)
                {
                    NFENUMCHILDDATA dt;
                
                    dt.hfontSet = pnf->m_hfontOrg;
                    dt.dwStyle = pnf->ci.style;
                    // just in case anyone is still alive
                    EnumChildWindows(hdlg, pnf->_SetFontEnumProc, (LPARAM)&dt);
                    DeleteObject(pnf->m_hfontDelete);
                    pnf->m_hfontDelete = NULL;
                }
                RemoveWindowSubclass(hdlg, pnf->_SubclassDlgProc, 0);

                break;
        }
    
        lret = DefSubclassProc(hdlg, uMsg, wParam, lParam);
    }
 
    return lret;
}

LRESULT THISCLASS::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hdlg;
    
    switch (uMsg)
    {
        case WM_CREATE:
        // subclass the parent dialog just to get notified for WM_INITDIALOG
            hdlg = GetParent(hwnd);
            if (hdlg)
            {
                // if we had an error just do nothing, we have to succeed in creating
                // window anyway otherwise dialog fails.
                SetWindowSubclass(hdlg, _SubclassDlgProc, 0, (ULONG_PTR)this);
            }
            break;
    }
    return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
}

// _GetNativeDialogFont
//
// Retreive font handle in platform native character set
//
// returns S_OK if the given dialogbox requires setting font
//              in native charset
//         S_FALSE if the given dialogbox already has native
//              charset.
//         E_FAIL if anyother error occurs
//
HRESULT THISCLASS::_GetNativeDialogFont(HWND hDlg)
{
    HRESULT hres = E_FAIL;
    
    if(!m_hfontNative)
    {
        HFONT hfontNative, hfont = GetWindowFont(hDlg);
        LOGFONT lf, lfNative;
        FASTATUS uiFAStat = FAS_NOTINITIALIZED;
        GetObject(hfont, sizeof(LOGFONT), &lf);

        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lfNative, 0);
        
        // there are two cases we don't want to create/set font
        // for the platform native character set.
        // 1) we already have matching character set
        // 2) the platform has 'font assoc' enabled or 'font link'
        //    and our client wants to use it instead of
        //    setting the right character set. (NFS_USEFONTASSOC)
        //    this solution sometimes provides better
        //    appearance (thought it is broken in its 
        //    font metrics) because it would use 
        //    'western font' as is.
        if (ci.style & NFS_USEFONTASSOC)
        {
            _GetFontAssocStatus(&uiFAStat);
        }

        if ( uiFAStat == FAS_ENABLED
           || lfNative.lfCharSet == lf.lfCharSet)
        {
                
            m_hfontOrg = m_hfontNative = hfont;
        }
        else
        {
            // we have non-native charset for the platform
            // Save away the original font first.
            m_hfontOrg = hfont;
            
            // Use the height of original dialog font
            lfNative.lfHeight = lf.lfHeight;
            if (!(hfontNative=CreateFontIndirect(&lfNative)))
            {
                hfontNative = hfont;
            }

            // save it away so we can delete it later
            if (hfontNative != hfont)
                m_hfontDelete = hfont;
        
            // set this variable to avoid calling createfont twice
            // if we get called again.
            m_hfontNative = hfontNative;
        }
    }

    return hres = (m_hfontNative == m_hfontOrg ? S_FALSE : S_OK);
}

//
// _GetFontAssocStatus
//
// synopsis: check to see if the platform has "Font Association"
//           enabled or 'Font Link' capability
//
HRESULT THISCLASS::_GetFontAssocStatus(FASTATUS  *puiAssoced)
{
    HRESULT hr = S_OK;
    ASSERT(puiAssoced);
    
    // I assume the setting won't change without rebooting
    // the system
    //
    if (FAS_NOTINITIALIZED == _s_uiFontAssocStatus)
    {
        // NT5 has fontlink functionality
        _s_uiFontAssocStatus = FAS_ENABLED;
    }
    *puiAssoced = _s_uiFontAssocStatus;

    return hr;
}

extern "C" {
    
BOOL InitNativeFontCtl(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = THISCLASS::NativeFontWndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = WC_NATIVEFONTCTL;
    wc.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1); // NULL;
    wc.style           = CS_GLOBALCLASS;
    wc.cbWndExtra      = sizeof(LPVOID);
    wc.cbClsExtra      = 0;

    if (!RegisterClass(&wc) && !GetClassInfo(hinst, WC_NATIVEFONTCTL, &wc))
        return FALSE;

    return TRUE;
}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\edit.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "edit.h"

//---------------------------------------------------------------------------//
//
// Forwards
//
ICH     Edit_FindTabA(LPSTR, ICH);
ICH     Edit_FindTabW(LPWSTR, ICH);
HBRUSH  Edit_GetControlBrush(PED, HDC, LONG);

NTSYSAPI
VOID
NTAPI
RtlRunEncodeUnicodeString(
    PUCHAR          Seed        OPTIONAL,
    PUNICODE_STRING String
    );


NTSYSAPI
VOID
NTAPI
RtlRunDecodeUnicodeString(
    UCHAR           Seed,
    PUNICODE_STRING String
    );

//
// private export from GDI
//
UINT WINAPI QueryFontAssocStatus(void);

#define umin(a, b)      \
            ((unsigned)(a) < (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))

#define umax(a, b)      \
            ((unsigned)(a) > (unsigned)(b) ? (unsigned)(a) : (unsigned)(b))


#define UNICODE_CARRIAGERETURN ((WCHAR)0x0d)
#define UNICODE_LINEFEED ((WCHAR)0x0a)
#define UNICODE_TAB ((WCHAR)0x09)

//
// IME Menu IDs
//
#define ID_IMEOPENCLOSE      10001
#define ID_SOFTKBDOPENCLOSE  10002
#define ID_RECONVERTSTRING   10003


#define ID_EDITTIMER        10007
#define EDIT_TIPTIMEOUT     10000

#pragma code_seg(CODESEG_INIT)

//---------------------------------------------------------------------------//
//
//  InitEditClass() - Registers the control's window class 
//
BOOL InitEditClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = Edit_WndProc;
    wc.lpszClassName = WC_EDIT;
    wc.style         = CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PED);
    wc.hInstance     = hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_IBEAM);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;

    if (!RegisterClass(&wc) && !GetClassInfo(hInstance, WC_EDIT, &wc))
    {
        //ASSERTMSG(0, "Failed to register %s control for %x.%x", WC_EDIT, GetCurrentProcessId(), GetCurrentThreadId());
        return FALSE;
    }

    return TRUE;
}

#pragma code_seg()


//---------------------------------------------------------------------------//
//
PSTR Edit_Lock(PED ped)
{
    PSTR ptext = LocalLock(ped->hText);
    ped->iLockLevel++;

    //
    // If this is the first lock of the text and the text is encoded
    // decode the text.
    //

    //TraceMsg(TF_STANDARD, "EDIT: lock  : %d '%10s'", ped->iLockLevel, ptext);
    if (ped->iLockLevel == 1 && ped->fEncoded) 
    {
        //
        // rtlrundecode can't handle zero length strings
        //
        if (ped->cch != 0) 
        {
            STRING string;
            string.Length = string.MaximumLength = (USHORT)(ped->cch * ped->cbChar);
            string.Buffer = ptext;

            RtlRunDecodeUnicodeString(ped->seed, (PUNICODE_STRING)&string);
            //TraceMsg(TF_STANDARD, "EDIT: Decoding: '%10s'", ptext);
        }
        ped->fEncoded = FALSE;
    }

    return ptext;
}


//---------------------------------------------------------------------------//
//
VOID Edit_Unlock(PED ped)
{
    //
    // if we are removing the last lock on the text and the password
    // character is set then encode the text
    //

    //TraceMsg(TF_STANDARD, "EDIT: unlock: %d '%10s'", ped->iLockLevel, ped->ptext);
    if (ped->charPasswordChar && ped->iLockLevel == 1 && ped->cch != 0) 
    {
        UNICODE_STRING string;
        string.Length = string.MaximumLength = (USHORT)(ped->cch * ped->cbChar);
        string.Buffer = LocalLock(ped->hText);

        RtlRunEncodeUnicodeString(&(ped->seed), &string);
        //TraceMsg(TF_STANDARD, "EDIT: Encoding: '%10s'", ped->ptext);
        ped->fEncoded = TRUE;
        LocalUnlock(ped->hText);
    }

    LocalUnlock(ped->hText);
    ped->iLockLevel--;
}


//---------------------------------------------------------------------------//
//
// GetActualNegA()
//
// For a given strip of text, this function computes the negative A width
// for the whole strip and returns the value as a postive number.
// It also fills the NegAInfo structure with details about the postion
// of this strip that results in this Negative A.
//
UINT GetActualNegA(HDC hdc, PED ped, INT x, LPSTR lpstring, ICH ichString, INT nCount, LPSTRIPINFO NegAInfo)
{
    INT  iCharCount, i;
    INT  iLeftmostPoint = x;
    PABC pABCwidthBuff;
    UINT wCharIndex;
    INT  xStartPoint = x;
    ABC  abc;

    //
    // To begin with, let us assume that there is no negative A width for
    // this strip and initialize accodingly.
    //

    NegAInfo->XStartPos = x;
    NegAInfo->lpString = lpstring;
    NegAInfo->nCount  = 0;
    NegAInfo->ichString = ichString;

    //
    // If the current font is not a TrueType font, then there can not be any
    // negative A widths.
    //
    if (!ped->fTrueType) 
    {
        if(!ped->charOverhang) 
        {
            return 0;
        } 
        else 
        {
            NegAInfo->nCount = min(nCount, (INT)ped->wMaxNegAcharPos);
            return ped->charOverhang;
        }
    }

    //
    // How many characters are to be considered for computing Negative A ?
    //
    iCharCount = min(nCount, (INT)ped->wMaxNegAcharPos);

    //
    // Do we have the info on individual character's widths?
    //
    if(!ped->charWidthBuffer) 
    {
        //
        // No! So, let us tell them to consider all the characters.
        //
        NegAInfo->nCount = iCharCount;
        return (iCharCount * ped->aveCharWidth);
    }

    pABCwidthBuff = (PABC)ped->charWidthBuffer;

    if (ped->fAnsi) 
    {
        for (i = 0; i < iCharCount; i++) 
        {
            wCharIndex = (UINT)(*((PUCHAR)lpstring));
            if (*lpstring == VK_TAB) 
            {
                //
                // To play it safe, we assume that this tab results in a tab length of
                // 1 pixel because this is the minimum possible tab length.
                //
                x++;
            } 
            else 
            {
                if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH)
                {
                    //
                    // Add the 'A' width.
                    //
                    x += pABCwidthBuff[wCharIndex].abcA;
                }
                else 
                {
                    GetCharABCWidthsA(hdc, wCharIndex, wCharIndex, &abc);
                    x += abc.abcA;
                }

                if (x < iLeftmostPoint)
                {
                    //
                    // Reset the leftmost point.
                    //
                    iLeftmostPoint = x;
                }

                if (x < xStartPoint)
                {
                    //
                    // 'i' is index; To get the count add 1.
                    //
                    NegAInfo->nCount = i+1;
                }

                if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH) 
                {
                    x += pABCwidthBuff[wCharIndex].abcB + pABCwidthBuff[wCharIndex].abcC;
                } 
                else 
                {
                    x += abc.abcB + abc.abcC;
                }
            }

            lpstring++;
        }
    } 
    else 
    {
        LPWSTR lpwstring = (LPWSTR)lpstring;

        for (i = 0; i < iCharCount; i++) 
        {
            wCharIndex = *lpwstring ;
            if (*lpwstring == VK_TAB) 
            {
                //
                // To play it safe, we assume that this tab results in a tab length of
                // 1 pixel because this is the minimum possible tab length.
                //
                x++;
            } 
            else 
            {
                if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH)
                {
                    //
                    // Add the 'A' width.
                    //
                    x += pABCwidthBuff[wCharIndex].abcA;
                }
                else 
                {
                    GetCharABCWidthsW(hdc, wCharIndex, wCharIndex, &abc);
                    x += abc.abcA ;
                }

                if (x < iLeftmostPoint)
                {
                    //
                    // Reset the leftmost point.
                    //
                    iLeftmostPoint = x;
                }

                if (x < xStartPoint)
                {
                    //
                    // 'i' is index; To get the count add 1.
                    //
                    NegAInfo->nCount = i+1;
                }

                if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH)
                {
                    x += pABCwidthBuff[wCharIndex].abcB +
                         pABCwidthBuff[wCharIndex].abcC;
                }
                else
                {
                    x += abc.abcB + abc.abcC;
                }
            }

            lpwstring++;
        }
    }

    //
    // Let us return the negative A for the whole strip as a positive value.
    //
    return (UINT)(xStartPoint - iLeftmostPoint);
}


//---------------------------------------------------------------------------//
//
// Edit_IsAncestorActive()
//
// Returns whether or not we're the child of an "active" window.  Looks for
// the first parent window that has a caption.
//
// This is a function because we might use it elsewhere when getting left
//  clicked on, etc.
//
BOOL Edit_IsAncestorActive(HWND hwnd)
{
    BOOL fResult = TRUE;
    //
    // We want to return TRUE always for top level windows.  That's because
    // of how WM_MOUSEACTIVATE works.  If we see the click at all, the
    // window is active.  However, if we reach a child ancestor that has
    // a caption, return the frame-on style bit.
    //
    // Note that calling FlashWindow() will have an effect.  If the user
    // clicks on an edit field in a child window that is flashed off, nothing
    // will happen unless the window stops flashing and ncactivates first.
    //

    for(; hwnd != NULL; hwnd = GetParent(hwnd))
    {
        PWW pww = (PWW)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);
        //
        // Bail out if some parent window isn't 4.0 compatible or we've
        // reached the top.  Fixes compatibility problems with 3.x apps,
        // especially MFC samples.
        //
        if (!TESTFLAG(pww->dwState2, WS_S2_WIN40COMPAT) || !TESTFLAG(pww->dwStyle, WS_CHILD))
        {
            break;
        }
        else if (TESTFLAG(pww->dwState, WS_ST_CPRESENT))
        {
            fResult = (TESTFLAG(pww->dwState, WS_ST_FRAMEON) != 0);
            break;
        }
    }

    return fResult;
}

//---------------------------------------------------------------------------//
//
// Edit_SetIMEMenu()
//
// support IME specific context menu
//
BOOL Edit_SetIMEMenu(HMENU hMenu, HWND hwnd, EditMenuItemState state)
{
    MENUITEMINFO mii;
    HIMC  hIMC;
    HKL   hKL;
    HMENU hmenuSub;
    WCHAR szRes[32];
    INT   nPrevLastItem;
    INT   nItemsAdded = 0;

    UserAssert(g_fIMMEnabled && state.fIME);

    hKL = GetKeyboardLayout(0);
    if (!ImmIsIME(hKL))
    {
        return TRUE;
    }

    hIMC = ImmGetContext(hwnd);
    if (hIMC == NULL) 
    {
        //
        // early out
        //
        return FALSE;
    }

    hmenuSub = GetSubMenu(hMenu, 0);

    if (hmenuSub == NULL) 
    {
        return FALSE;
    }

    nPrevLastItem = GetMenuItemCount(hmenuSub);

    if (hIMC) 
    {
        if (LOWORD(HandleToUlong(hKL)) != 0x412) 
        {
            //
            // If Korean, do not show open/close menus
            //
            if (ImmGetOpenStatus(hIMC))
            {
                LoadString(HINST_THISDLL, IDS_IMECLOSE, szRes, ARRAYSIZE(szRes));
            }
            else
            {
                LoadString(HINST_THISDLL, IDS_IMEOPEN, szRes, ARRAYSIZE(szRes));
            }

            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID;
            mii.dwTypeData = szRes;
            mii.cch = 0xffff;
            mii.wID = ID_IMEOPENCLOSE;
            InsertMenuItem(hmenuSub, 0xffff, TRUE, &mii);
            ++nItemsAdded;
        }

        if (ImmGetProperty(hKL, IGP_CONVERSION) & IME_CMODE_SOFTKBD) 
        {
            DWORD fdwConversion;

            if (ImmGetConversionStatus(hIMC, &fdwConversion, NULL) && 
                (fdwConversion & IME_CMODE_SOFTKBD))
            {
               LoadString(HINST_THISDLL, IDS_SOFTKBDCLOSE, szRes, ARRAYSIZE(szRes));
            }
            else
            {
               LoadString(HINST_THISDLL, IDS_SOFTKBDOPEN, szRes, ARRAYSIZE(szRes));
            }

            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID;
            mii.dwTypeData = szRes;
            mii.cch = 0xffff;
            mii.wID = ID_SOFTKBDOPENCLOSE;
            InsertMenuItem(hmenuSub, 0xffff, TRUE, &mii);
            ++nItemsAdded;
        }

        if (LOWORD(HandleToUlong(hKL)) != 0x412) 
        {
            //
            // If Korean, do not show reconversion menus
            //
            DWORD dwSCS = ImmGetProperty(hKL, IGP_SETCOMPSTR);

            LoadString(HINST_THISDLL, IDS_RECONVERTSTRING, szRes, ARRAYSIZE(szRes));

            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID | MIIM_STATE;
            mii.dwTypeData = szRes;
            mii.fState = 0;
            mii.cch = 0xffff;
            mii.wID = ID_RECONVERTSTRING;

            if (state.fDisableCut ||
                    !(dwSCS & SCS_CAP_SETRECONVERTSTRING) ||
                    !(dwSCS & SCS_CAP_MAKEREAD)) 
            {
                mii.fState |= MFS_GRAYED;
            }

            InsertMenuItem(hmenuSub, 0xffff, TRUE, &mii);
            ++nItemsAdded;
        }
    }

    //
    // Add or remove the menu separator
    //
    if (state.fNeedSeparatorBeforeImeMenu && nItemsAdded != 0) 
    {
        //
        // If the menu for Middle East has left a separator,
        // fNeedSeparatorBeforeImeMenu is FALSE.
        // I.e. we don't need to add more.
        //
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_FTYPE;
        mii.fType = MFT_SEPARATOR;
        InsertMenuItem(hmenuSub, nPrevLastItem, TRUE, &mii);
    }
    else if (!state.fNeedSeparatorBeforeImeMenu && nItemsAdded == 0) 
    {
        //
        // Extra separator is left by ME menus. Remove it.
        //
        DeleteMenu(hmenuSub, nPrevLastItem - 1, MF_BYPOSITION);
    }

    ImmReleaseContext(hwnd, hIMC);

    return TRUE;
}


//---------------------------------------------------------------------------//
//
VOID Edit_InOutReconversionMode(PED ped, BOOL fIn)
{
    UserAssert(fIn == TRUE || fIn == FALSE);
    if (fIn != ped->fInReconversion) 
    {
        ped->fInReconversion = fIn;
        if (ped->fFocus) 
        {
            (fIn ? HideCaret: ShowCaret)(ped->hwnd);
        }
    }

}

//---------------------------------------------------------------------------//
//
BOOL Edit_EnumInputContextCB(HIMC hImc, LPARAM lParam)
{
    DWORD dwConversion = 0, dwSentence = 0, dwNewConversion = 0;

    ImmGetConversionStatus(hImc, &dwConversion, &dwSentence);

    if (lParam) 
    {
        dwNewConversion = dwConversion | IME_CMODE_SOFTKBD;
    } 
    else 
    {
        dwNewConversion = dwConversion & ~IME_CMODE_SOFTKBD;
    }

    if (dwNewConversion != dwConversion) 
    {
        ImmSetConversionStatus(hImc, dwNewConversion, dwSentence);
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// Edit_DoIMEMenuCommand()
//
// support IME specific context menu
//
BOOL Edit_DoIMEMenuCommand(PED ped, int cmd, HWND hwnd)
{
    HIMC hIMC;

    // early out
    switch (cmd) 
    {
    case ID_IMEOPENCLOSE:
    case ID_SOFTKBDOPENCLOSE:
    case ID_RECONVERTSTRING:
        break;
    default:
        return FALSE;
    }

    //
    // everybody needs hIMC, so get it here
    //
    hIMC = ImmGetContext(hwnd);
    if (hIMC == NULL) 
    {
        //
        // indicate to caller, that no further command processing needed
        //
        return TRUE;
    }

    switch (cmd) 
    {
    case ID_IMEOPENCLOSE:
    {
        // switch IME Open/Close status
        BOOL fOpen = ImmGetOpenStatus(hIMC);

        ImmSetOpenStatus(hIMC, !fOpen);
    }

    break;

    case ID_SOFTKBDOPENCLOSE:
    {
        DWORD fdwConversion;

        if (ImmGetConversionStatus(hIMC, &fdwConversion, NULL)) 
        {
            //
            // Toggle soft keyboard Open/Close status
            //
            ImmEnumInputContext(0, Edit_EnumInputContextCB,
                    (fdwConversion & IME_CMODE_SOFTKBD) != IME_CMODE_SOFTKBD);
        }
    }

    break;

    case ID_RECONVERTSTRING:
    {
        DWORD dwStrLen; // holds TCHAR count of recionversion string
        DWORD cbLen;    // holds BYTE SIZE of reconversion string
        DWORD dwSize;
        LPRECONVERTSTRING lpRCS;

        //
        // pass current selection to IME for reconversion
        //
        dwStrLen = ped->ichMaxSel - ped->ichMinSel;
        cbLen = dwStrLen * ped->cbChar;
        dwSize = cbLen + sizeof(RECONVERTSTRING) + 8;

        lpRCS = (LPRECONVERTSTRING)UserLocalAlloc(0, dwSize);

        if (lpRCS) 
        {
            LPBYTE pText;
            ICH    ichSelMinOrg;

            ichSelMinOrg = ped->ichMinSel;

            pText = Edit_Lock(ped);
            if (pText != NULL) 
            {
                LPBYTE lpDest;
                BOOL (WINAPI* fpSetCompositionStringAW)(HIMC, DWORD, LPVOID, DWORD, LPVOID, DWORD);

                lpRCS->dwSize = dwSize;
                lpRCS->dwVersion = 0;

                lpRCS->dwStrLen =
                lpRCS->dwCompStrLen =
                lpRCS->dwTargetStrLen = dwStrLen;

                lpRCS->dwStrOffset = sizeof(RECONVERTSTRING);
                lpRCS->dwCompStrOffset =
                lpRCS->dwTargetStrOffset = 0;

                lpDest = (LPBYTE)lpRCS + sizeof(RECONVERTSTRING);

                RtlCopyMemory(lpDest, pText + ped->ichMinSel * ped->cbChar, cbLen);
                if (ped->fAnsi) 
                {
                    LPBYTE psz = (LPBYTE)lpDest;
                    psz[cbLen] = '\0';
                    fpSetCompositionStringAW = ImmSetCompositionStringA;
                } 
                else 
                {
                    LPWSTR pwsz = (LPWSTR)lpDest;
                    pwsz[dwStrLen] = L'\0';
                    fpSetCompositionStringAW = ImmSetCompositionStringW;
                }

                Edit_Unlock(ped);

                UserAssert(fpSetCompositionStringAW != NULL);

                Edit_InOutReconversionMode(ped, TRUE);
                Edit_ImmSetCompositionWindow(ped, 0, 0); // x and y will be overriden anyway

                // Query the IME for a valid Reconvert string range first.
                fpSetCompositionStringAW(hIMC, SCS_QUERYRECONVERTSTRING, lpRCS, dwSize, NULL, 0);

                // If current IME updates the original reconvert structure,
                // it is necessary to update the text selection based on the 
                // new reconvert text range.
                if ((lpRCS->dwCompStrLen != dwStrLen) || (ichSelMinOrg != ped->ichMinSel)) 
                {
                    ICH ichSelStart;
                    ICH ichSelEnd;

                    ichSelStart = ichSelMinOrg + (lpRCS->dwCompStrOffset  / ped->cbChar);
                    ichSelEnd = ichSelStart + lpRCS->dwCompStrLen;

                    (ped->fAnsi ? SendMessageA : SendMessageW)(ped->hwnd, EM_SETSEL, ichSelStart, ichSelEnd);
                }

                fpSetCompositionStringAW(hIMC, SCS_SETRECONVERTSTRING, lpRCS, dwSize, NULL, 0);
            }

            UserLocalFree(lpRCS);
        }

        break;
    }

    default:
        //
        // should never reach here.
        //
        TraceMsg(TF_STANDARD, "EDIT: Edit_DoIMEMenuCommand: unknown command id %d; should never reach here.", cmd);
        return FALSE;
    }

    UserAssert(hIMC != NULL);
    ImmReleaseContext(hwnd, hIMC);

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// Edit_Menu()
//
// Handles context menu for edit fields.  Disables inappropriate commands.
// Note that this is NOT subclassing friendly, like most of our functions,
// for speed and convenience.
//
VOID Edit_Menu(HWND hwnd, PED ped, LPPOINT pt)
{
    HMENU   hMenu;
    INT     cmd = 0;
    INT     x;
    INT     y;
    UINT    uFlags = TPM_NONOTIFY | TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_RIGHTBUTTON;
    EditMenuItemState state = 
    {
        FALSE,              // fDisableCut
        TRUE,               // fDisablePaste
        TRUE,               // fNeedSeparatorBeforeImeMenu
        g_fIMMEnabled && ImmIsIME(GetKeyboardLayout(0)), // fIME
    };

    //
    // Set focus if we don't have its
    //
    if (!ped->fFocus)
    {
        SetFocus(hwnd);
    }

    //
    // Grab the menu from our resources...
    //
    hMenu = LoadMenu( HINST_THISDLL, MAKEINTRESOURCE( ID_EC_PROPERTY_MENU ));
    if (hMenu)
    {

        //
        // Undo -- not allowed if we have no saved undo info
        //
        if (ped->undoType == UNDO_NONE)
        {
            EnableMenuItem(hMenu, WM_UNDO, MF_BYCOMMAND | MFS_GRAYED);
        }

        if (ped->fReadOnly || ped->charPasswordChar) 
        {
            //
            // Cut and Delete -- not allowed if read-only or password
            //
            state.fDisableCut = TRUE;
        } 
        else 
        {
            //
            // Cut, Delete -- not allowed if there's no selection
            //
            if (ped->ichMinSel == ped->ichMaxSel)
            {
                state.fDisableCut = TRUE;
            }
        }

        //
        // Paste -- not allowed if there's no text on the clipboard
        // (this works for both OEM and Unicode)
        // Used to be always disabled for password edits MCostea #221035
        //

        if (IsClipboardFormatAvailable(CF_TEXT))
        {
            state.fDisablePaste = FALSE;
        }

        if (state.fDisableCut) 
        {
            EnableMenuItem(hMenu, WM_CUT,   MF_BYCOMMAND | MFS_GRAYED);
            EnableMenuItem(hMenu, WM_CLEAR, MF_BYCOMMAND | MFS_GRAYED);
        }

        if (state.fDisablePaste)
        {
            EnableMenuItem(hMenu, WM_PASTE, MF_BYCOMMAND | MFS_GRAYED);
        }

        //
        // Copy -- not allowed if there's no selection or password ec
        //
        if ((ped->ichMinSel == ped->ichMaxSel) || (ped->charPasswordChar))
        {
            EnableMenuItem(hMenu, WM_COPY, MF_BYCOMMAND | MFS_GRAYED);
        }

        //
        // Select All -- not allowed if there's no text or if everything is
        // selected.   Latter case takes care of first one.
        //
        if ((ped->ichMinSel == 0) && (ped->ichMaxSel == ped->cch))
        {
            EnableMenuItem(hMenu, EM_SETSEL, MF_BYCOMMAND | MFS_GRAYED);
        }

        if (ped->pLpkEditCallout) 
        {
            ped->pLpkEditCallout->EditSetMenu((PED0)ped, hMenu);
        } 
        else 
        {
            DeleteMenu(hMenu, ID_CNTX_DISPLAYCTRL, MF_BYCOMMAND);
            DeleteMenu(hMenu, ID_CNTX_RTL,         MF_BYCOMMAND);
            DeleteMenu(hMenu, ID_CNTX_INSERTCTRL,  MF_BYCOMMAND);

            if (state.fIME) 
            {
                //
                // One separator is left in the menu,
                // no need to add the one before IME menus
                //
                state.fNeedSeparatorBeforeImeMenu = FALSE;

            } 
            else 
            {
                //
                // Extra separator is left. Remove it.
                //
                HMENU hmenuSub = GetSubMenu(hMenu, 0);
                INT   nItems = GetMenuItemCount(hmenuSub) - 1;

                UserAssert(nItems >= 0);
                UserAssert(GetMenuState(hmenuSub, nItems, MF_BYPOSITION) & MF_SEPARATOR);

                //
                // remove needless separator
                //
                DeleteMenu(hmenuSub, nItems, MF_BYPOSITION);
            }
        }

        //
        // IME specific menu
        //
        if (state.fIME) 
        {
            Edit_SetIMEMenu(hMenu, hwnd, state);
        }

        //
        // BOGUS
        // We position the menu below & to the right of the point clicked on.
        // Is this cool?  I think so.  Excel 4.0 does the same thing.  It
        // seems like it would be neat if we could avoid obscuring the
        // selection.  But in actuality, it seems even more awkward to move
        // the menu out of the way of the selection.  The user can't click
        // and drag that way, and they have to move the mouse a ton.
        //
        // We need to use TPM_NONOTIFY because VBRUN100 and VBRUN200 GP-fault
        // on unexpected menu messages.
        //

        //
        // if message came via the keyboard then center on the control
        // We use -1 && -1 here not 0xFFFFFFFF like Win95 becuase we
        // previously converted the lParam to a point with sign extending.
        //
        if (pt->x == -1 && pt->y == -1) 
        {
            RECT rc;

            GetWindowRect(hwnd, &rc);
            x = rc.left + (rc.right - rc.left) / 2;
            y = rc.top + (rc.bottom - rc.top) / 2;
        } 
        else 
        {
            x = pt->x;
            y = pt->y;
        }

        if ( IS_BIDI_LOCALIZED_SYSTEM() )
        {
            uFlags |= TPM_LAYOUTRTL;
        }

        cmd = TrackPopupMenuEx(GetSubMenu(hMenu, 0), uFlags, x, y, hwnd, NULL);

        //
        // Free our menu
        //
        DestroyMenu(hMenu);

        if (cmd && (cmd != -1)) 
        {
            if (ped->pLpkEditCallout && cmd) 
            {
                ped->pLpkEditCallout->EditProcessMenu((PED0)ped, cmd);
            }
            if (!state.fIME || !Edit_DoIMEMenuCommand(ped, cmd, hwnd)) 
            {
                //
                // if cmd is not IME specific menu, send it.
                //
                SendMessage(hwnd, cmd, 0, (cmd == EM_SETSEL) ? 0xFFFFFFFF : 0L );
            }
        }
    }
}



//---------------------------------------------------------------------------//
//
// Edit_ClearText()
//
// Clears selected text.  Does NOT _send_ a fake char backspace.
//
VOID Edit_ClearText(PED ped)
{
    if (!ped->fReadOnly && (ped->ichMinSel < ped->ichMaxSel))
    {
        if (ped->fSingle)
        {
            EditSL_WndProc(ped, WM_CHAR, VK_BACK, 0L );
        }
        else
        {
            EditML_WndProc(ped, WM_CHAR, VK_BACK, 0L );
        }
    }

}


//---------------------------------------------------------------------------//
//
// Edit_CutText()
//
// Cuts selected text.  This removes and copies the selection to the clip,
// or if nothing is selected we delete (clear) the left character.
//
VOID Edit_CutText(PED ped)
{
    //
    // Cut selection--IE, remove and copy to clipboard, or if no selection,
    // delete (clear) character left.
    //
    if (!ped->fReadOnly &&
        (ped->ichMinSel < ped->ichMaxSel) &&
        SendMessage(ped->hwnd, WM_COPY, 0, 0L))
    {
        //
        // If copy was successful, delete the copied text by sending a
        // backspace message which will redraw the text and take care of
        // notifying the parent of changes.
        //
        Edit_ClearText(ped);
    }
}


//---------------------------------------------------------------------------//
//
// Edit_GetModKeys()
//
// Gets modifier key states.  Currently, we only check for VK_CONTROL and
// VK_SHIFT.
//
INT Edit_GetModKeys(INT keyMods) 
{
    INT scState;

    scState = 0;

    if (!keyMods) 
    {
        if (GetKeyState(VK_CONTROL) < 0)
        {
            scState |= CTRLDOWN;
        }

        if (GetKeyState(VK_SHIFT) < 0)
        {
            scState |= SHFTDOWN;
        }
    } 
    else if (keyMods != NOMODIFY)
    {
        scState = keyMods;
    }

    return scState;
}


//---------------------------------------------------------------------------//
//
// Edit_TabTheTextOut() AorW
// If fDrawText == FALSE, then this function returns the text extent of
// of the given strip of text. It does not worry about the Negative widths.
//
// If fDrawText == TRUE, this draws the given strip of Text expanding the
// tabs to proper lengths, calculates and fills up the NegCInfoForStrip with
// details required to draw the portions of this strip that goes beyond the
// xClipEndPos due to Negative C widths.
//
// Returns the max width AS A DWORD.  We don't care about the height
// at all.  No one uses it.  We keep a DWORD because that way we avoid
// overflow.
//
// NOTE: If the language pack is loaded EcTabTheTextOut is not used - the
// language pack must take care of all tab expansion and selection
// highlighting with full support for bidi layout and complex script
// glyph reordering.
//
UINT Edit_TabTheTextOut( 
    HDC hdc, 
    INT xClipStPos, 
    INT xClipEndPos, 
    INT xStart, 
    INT y, 
    LPSTR lpstring,
    INT nCount,
    ICH ichString,
    PED ped,
    INT iTabOrigin,
    BOOL fDraw,
    LPSTRIPINFO NegCInfoForStrip)
{
    INT     nTabPositions;         // Count of tabstops in tabstop array.
    LPINT   lpintTabStopPositions; // Tab stop positions in pixels.

    INT     cch;
    UINT    textextent;
    INT     xEnd;
    INT     pixeltabstop = 0;
    INT     i;
    INT     cxCharWidth;
    RECT    rc;
    BOOL    fOpaque;
    BOOL    fFirstPass = TRUE;
    PINT    charWidthBuff;

    INT     iTabLength;
    INT     nConsecutiveTabs;
    INT     xStripStPos;
    INT     xStripEndPos;
    INT     xEndOfStrip;
    STRIPINFO  RedrawStripInfo;
    STRIPINFO  NegAInfo;
    LPSTR    lpTab;
    LPWSTR   lpwTab;
    UINT     wNegCwidth, wNegAwidth;
    INT      xRightmostPoint = xClipStPos;
    INT      xTabStartPos;
    INT      iSavedBkMode = 0;
    WCHAR    wchar;
    SIZE     size = {0};
    ABC      abc ;

    COLORREF clrBkSave;
    COLORREF clrTextSave;
    HBRUSH   hbrBack = NULL;
    BOOL     fNeedDelete = FALSE;
    HRESULT  hr = E_FAIL;
    UINT     uRet;

    //
    // Algorithm: Draw the strip opaquely first. If a tab length is so
    // small that the portions of text on either side of a tab overlap with
    // the other, then this will result in some clipping. So, such portion
    // of the strip is remembered in "RedrawStripInfo" and redrawn
    // transparently later to compensate the clippings.
    //    NOTE: "RedrawStripInfo" can hold info about just one portion. So, if
    // more than one portion of the strip needs to be redrawn transparently,
    // then we "merge" all such portions into a single strip and redraw that
    // strip at the end.
    //

    if (fDraw) 
    {
        //
        // To begin with, let us assume that there is no Negative C for this
        // strip and initialize the Negative Width Info structure.
        //
        NegCInfoForStrip->nCount = 0;
        NegCInfoForStrip->XStartPos = xClipEndPos;

        //
        // We may not have to redraw any portion of this strip.
        //
        RedrawStripInfo.nCount = 0;

        fOpaque = (GetBkMode(hdc) == OPAQUE) || (fDraw == ECT_SELECTED);
    }
#if DBG
    else 
    {
        //
        // Both EditML_GetLineWidth() and Edit_CchInWidth() should be clipping
        // nCount to avoid overflow.
        //
        if (nCount > MAXLINELENGTH)
        {
            TraceMsg(TF_STANDARD, "EDIT: Edit_TabTheTextOut: %d > MAXLINELENGTH", nCount);
        }
    }
#endif

    //
    // Let us define the Clip rectangle.
    //
    rc.left   = xClipStPos;
    rc.right  = xClipEndPos;
    rc.top    = y;
    rc.bottom = y + ped->lineHeight;

#ifdef _USE_DRAW_THEME_TEXT_
    //
    // Check if we are themed.
    //
    if (ped->hTheme)
    {
        COLORREF clrBk;
        COLORREF clrText;
        INT iState;
        INT iProp;

        iState = (fDraw == ECT_SELECTED) ? ETS_SELECTED : Edit_GetStateId(ped);
        iProp = (fDraw == ECT_SELECTED) ? TMT_HIGHLIGHT : TMT_FILLCOLOR;
        hr = GetThemeColor(ped->hTheme, EP_EDITTEXT, iState, iProp, &clrBk);

        if (SUCCEEDED(hr))
        {
            iProp = (fDraw == ECT_SELECTED) ? TMT_HIGHLIGHTTEXT : TMT_TEXTCOLOR;
            hr = GetThemeColor(ped->hTheme, EP_EDITTEXT, iState, iProp, &clrText);

            if (SUCCEEDED(hr))
            {
                hbrBack     = CreateSolidBrush(clrBk);
                fNeedDelete = TRUE;
                clrBkSave   = SetBkColor(hdc, clrBk);
                clrTextSave = SetTextColor(hdc, clrText);
            }
        }
    }
#endif // _USE_DRAW_THEME_TEXT_

    if (!ped->hTheme || FAILED(hr))
    {
        if (fDraw == ECT_SELECTED)
        {
            //
            // use normal colors
            //
            hbrBack = GetSysColorBrush(COLOR_HIGHLIGHT);
            clrBkSave   = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
            clrTextSave = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
        else
        {
            hbrBack = Edit_GetBrush(ped, hdc, &fNeedDelete);
            clrBkSave = GetBkColor(hdc);
            clrTextSave = GetTextColor(hdc);
        }
    }


    //
    // Check if anything needs to be drawn.
    //
    if (!lpstring || !nCount) 
    {
        if (fDraw)
        {
            ExtTextOutW(hdc, xClipStPos, y,
                  (fOpaque ? ETO_OPAQUE | ETO_CLIPPED : ETO_CLIPPED),
                  &rc, L"", 0, 0L);
        }
        
        uRet = 0;
    }
    else
    {

        //
        // Starting position
        //
        xEnd = xStart;

        cxCharWidth  = ped->aveCharWidth;

        nTabPositions = (ped->pTabStops ? *(ped->pTabStops) : 0);
        if (ped->pTabStops) 
        {
            lpintTabStopPositions = (LPINT)(ped->pTabStops+1);
            if (nTabPositions == 1) 
            {
                pixeltabstop = lpintTabStopPositions[0];
                if (!pixeltabstop)
                {
                    pixeltabstop = 1;
                }
            }
        } 
        else 
        {
            lpintTabStopPositions = NULL;
            pixeltabstop = 8*cxCharWidth;
        }

        //
        // The first time we will draw the strip Opaquely. If some portions need
        // to be redrawn , then we will set the mode to TRANSPARENT and
        // jump to this location to redraw those portions.
        //

    RedrawStrip:
        while (nCount) 
        {
            wNegCwidth = ped->wMaxNegC;

            //
            // Search for the first TAB in this strip; also compute the extent
            // of the the strip upto and not including the tab character.
            //
            // Note - If the langpack is loaded, there will be no charWidthBuffer.
            //

            //
            // Do we have a character width buffer?
            //
            if (ped->charWidthBuffer) 
            {
                textextent = 0;
                cch = nCount;

                //
                // If so, does it have ABC widths?
                //
                if (ped->fTrueType) 
                {
                    UINT iRightmostPoint = 0;
                    UINT wCharIndex;
                    PABC pABCwidthBuff;

                    pABCwidthBuff = (PABC) ped->charWidthBuffer;

                    if (ped->fAnsi) 
                    {
                        for (i = 0; i < nCount; i++) 
                        {

                            if (lpstring[i] == VK_TAB) 
                            {
                                cch = i;
                                break;
                            }

                            wCharIndex = (UINT)(((PUCHAR)lpstring)[i]);
                            if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH) 
                            {
                                textextent += (UINT)(pABCwidthBuff[wCharIndex].abcA +
                                    pABCwidthBuff[wCharIndex].abcB);
                            } 
                            else 
                            {
                                //
                                // not in cache, will ask driver
                                //
                                GetCharABCWidthsA(hdc, wCharIndex, wCharIndex, &abc);
                                textextent += abc.abcA + abc.abcB ;
                            }

                            if (textextent > iRightmostPoint)
                            {
                                iRightmostPoint = textextent;
                            }

                            if (wCharIndex < CHAR_WIDTH_BUFFER_LENGTH) 
                            {
                                textextent += pABCwidthBuff[wCharIndex].abcC;
                            } 
                            else 
                            {
                                //
                                // not in cache
                                //
                                textextent += abc.abcC;
                            }

                            if (textextent > iRightmostPoint)
                            {
                                iRightmostPoint = textextent;
                            }
                        }

                    } 
                    else 
                    {
                        for (i = 0; i < nCount; i++) 
                        {
                            WCHAR UNALIGNED * lpwstring = (WCHAR UNALIGNED *)lpstring;

                            if (lpwstring[i] == VK_TAB) 
                            {
                                cch = i;

                                break;
                            }

                            wCharIndex = lpwstring[i] ;
                            if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH )
                            {
                                textextent += pABCwidthBuff[wCharIndex].abcA +
                                              pABCwidthBuff[wCharIndex].abcB;
                            }
                            else 
                            {
                                GetCharABCWidthsW(hdc, wCharIndex, wCharIndex, &abc) ;
                                textextent += abc.abcA + abc.abcB ;
                            }

                            //
                            // Note that abcC could be negative so we need this
                            // statement here *and* below
                            //
                            if (textextent > iRightmostPoint)
                            {
                                iRightmostPoint = textextent;
                            }

                            if ( wCharIndex < CHAR_WIDTH_BUFFER_LENGTH )
                            {
                                textextent += pABCwidthBuff[wCharIndex].abcC;
                            }
                            else
                            {
                                textextent += abc.abcC ;
                            }

                            if (textextent > iRightmostPoint)
                            {
                                iRightmostPoint = textextent;
                            }
                        }
                    }

                    wNegCwidth = (int)(iRightmostPoint - textextent);
                } 
                else 
                {
                    //
                    // No! This is not a TrueType font; So, we have only character
                    // width info in this buffer.
                    //

                    charWidthBuff = ped->charWidthBuffer;

                    if (ped->fAnsi) 
                    {
                        //
                        // Initially assume no tabs exist in the text so cch=nCount.
                        //
                        for (i = 0; i < nCount; i++) 
                        {
                            if (lpstring[i] == VK_TAB) 
                            {
                                cch = i;
                                break;
                            }

                            //
                            // Call GetTextExtentPoint for dbcs/hankaku characters
                            //
                            if (ped->fDBCS && (i+1 < nCount)
                                    && Edit_IsDBCSLeadByte(ped,lpstring[i])) 
                            {
                                GetTextExtentPointA(hdc, &lpstring[i], 2, &size);
                                textextent += size.cx;
                                i++;
                            } 
                            else if ((UCHAR)lpstring[i] >= CHAR_WIDTH_BUFFER_LENGTH) 
                            {
                                //
                                // Skip this GetExtentPoint call for non hankaku code points
                                // Or if the character is in the width cache.
                                //
                                GetTextExtentPointA(hdc, &lpstring[i], 1, &size);
                                textextent += size.cx;
                            } 
                            else 
                            {
                                textextent += (UINT)(charWidthBuff[(UINT)(((PUCHAR)lpstring)[i])]);
                            }
                        }
                    } 
                    else 
                    {
                        LPWSTR lpwstring = (LPWSTR) lpstring ;
                        INT    cchUStart;  // start of unicode character count

                        for (i = 0; i < nCount; i++) 
                        {
                            if (lpwstring[i] == VK_TAB) 
                            {
                                cch = i;
                                break;
                            }

                            wchar = lpwstring[i];
                            if (wchar >= CHAR_WIDTH_BUFFER_LENGTH) 
                            {
                                //
                                // We have a Unicode character that is not in our
                                // cache, get all the characters outside the cache
                                // before getting the text extent on this part of the
                                // string.
                                //
                                cchUStart = i;
                                while (wchar >= CHAR_WIDTH_BUFFER_LENGTH &&
                                        wchar != VK_TAB && i < nCount) 
                                {
                                    wchar = lpwstring[++i];
                                }

                                GetTextExtentPointW(hdc, (LPWSTR)lpwstring + cchUStart,
                                        i-cchUStart, &size);
                                textextent += size.cx;


                                if (wchar == VK_TAB || i >= nCount) 
                                {
                                    cch = i;
                                    break;
                                }

                                //
                                // We have a char that is in the cache, fall through.
                                //
                            }

                            //
                            // The width of this character is in the cache buffer.
                            //
                            textextent += ped->charWidthBuffer[wchar];
                        }
                    }
                }

                nCount -= cch;
            } 
            else 
            {
                //
                // Gotta call the driver to do our text extent.
                //
                if (ped->fAnsi) 
                {
                    cch = (INT)Edit_FindTabA(lpstring, nCount);
                    GetTextExtentPointA(hdc, lpstring, cch, &size);
                } 
                else 
                {
                    cch = (INT)Edit_FindTabW((LPWSTR) lpstring, nCount);
                    GetTextExtentPointW(hdc, (LPWSTR)lpstring, cch, &size);
                }
                nCount -= cch;

                //
                // Subtruct Overhang for Italic fonts.
                //
                textextent = size.cx - ped->charOverhang;
            }

            //
            // textextent is computed.
            //

            xStripStPos = xEnd;
            xEnd += (int)textextent;
            xStripEndPos = xEnd;

            //
            // We will consider the negative widths only if when we draw opaquely.
            //
            if (fFirstPass && fDraw) 
            {
                xRightmostPoint = max(xStripEndPos + (int)wNegCwidth, xRightmostPoint);

                //
                // Check if this strip peeps beyond the clip region.
                //
                if (xRightmostPoint > xClipEndPos) 
                {
                    if (!NegCInfoForStrip->nCount) 
                    {
                        NegCInfoForStrip->lpString = lpstring;
                        NegCInfoForStrip->ichString = ichString;
                        NegCInfoForStrip->nCount = nCount+cch;
                        NegCInfoForStrip->XStartPos = xStripStPos;
                    }
                }
            }

            if (ped->fAnsi)
            {
                //
                // Possibly Points to a tab character.
                //
                lpTab = lpstring + cch;
            }
            else
            {
                lpwTab = ((LPWSTR)lpstring) + cch ;
            }

            //
            // we must consider all the consecutive tabs and calculate the
            // the begining of next strip.
            //
            nConsecutiveTabs = 0;
            while (nCount &&
                   (ped->fAnsi ? (*lpTab == VK_TAB) : (*lpwTab == VK_TAB))) 
            {
                //
                // Find the next tab position and update the x value.
                //
                xTabStartPos = xEnd;
                if (pixeltabstop)
                {
                    xEnd = (((xEnd-iTabOrigin)/pixeltabstop)*pixeltabstop) +
                        pixeltabstop + iTabOrigin;
                }
                else 
                {
                    for (i = 0; i < nTabPositions; i++) 
                    {
                        if (xEnd < (lpintTabStopPositions[i] + iTabOrigin)) 
                        {
                            xEnd = (lpintTabStopPositions[i] + iTabOrigin);
                            break;
                        }
                     }

                    //
                    // Check if all the tabstops set are exhausted; Then start using
                    // default tab stop positions.
                    //
                    if (i == nTabPositions) 
                    {
                        pixeltabstop = 8*cxCharWidth;
                        xEnd = ((xEnd - iTabOrigin)/pixeltabstop)*pixeltabstop +
                            pixeltabstop + iTabOrigin;
                    }
                }

                if (fFirstPass && fDraw) 
                {
                    xRightmostPoint = max(xEnd, xRightmostPoint);

                    //
                    // Check if this strip peeps beyond the clip region
                    //
                    if (xRightmostPoint > xClipEndPos) 
                    {
                        if (!NegCInfoForStrip->nCount) 
                        {
                            NegCInfoForStrip->ichString = ichString + cch + nConsecutiveTabs;
                            NegCInfoForStrip->nCount = nCount;
                            NegCInfoForStrip->lpString = (ped->fAnsi ?
                                                            lpTab : (LPSTR) lpwTab);
                            NegCInfoForStrip->XStartPos = xTabStartPos;
                        }
                    }
                }

                nConsecutiveTabs++;
                nCount--;
                ped->fAnsi ? lpTab++ : (LPSTR) (lpwTab++) ;  // Move to the next character.
            }

            if (fDraw) 
            {
                if (fFirstPass) 
                {
                    //
                    // Is anything remaining to be drawn in this strip?
                    //
                    if (!nCount)
                    {
                        //
                        // No! We are done.
                        //
                        rc.right = xEnd;
                    }
                    else 
                    {
                        //
                        // "x" is the effective starting position of next strip.
                        //
                        iTabLength = xEnd - xStripEndPos;

                        //
                        // Check if there is a possibility of this tab length being too small
                        // compared to the negative A and C widths if any.
                        //
                        if ((wNegCwidth + (wNegAwidth = ped->wMaxNegA)) > (UINT)iTabLength) 
                        {
                            //
                            // Unfortunately, there is a possiblity of an overlap.
                            // Let us find out the actual NegA for the next strip.
                            //
                            wNegAwidth = GetActualNegA(
                                  hdc,
                                  ped,
                                  xEnd,
                                  lpstring + (cch + nConsecutiveTabs)*ped->cbChar,
                                  ichString + cch + nConsecutiveTabs,
                                  nCount,
                                  &NegAInfo);
                        }

                        //
                        // Check if they actually overlap
                        //
                        if ((wNegCwidth + wNegAwidth) <= (UINT)iTabLength) 
                        {
                            //
                            // No overlap between the strips. This is the ideal situation.
                            //
                            rc.right = xEnd - wNegAwidth;
                        } 
                        else 
                        {
                            //
                            // Yes! They overlap.
                            //
                            rc.right = xEnd;

                            //
                            // See if negative C width is too large compared to tab length.
                            //
                            if (wNegCwidth > (UINT)iTabLength) 
                            {
                                //
                                // Must redraw transparently a part of the current strip later.
                                //
                                if (RedrawStripInfo.nCount) 
                                {
                                    //
                                    // A previous strip also needs to be redrawn; So, merge this
                                    // strip to that strip.
                                    //
                                    RedrawStripInfo.nCount = (ichString -
                                        RedrawStripInfo.ichString) + cch;
                                } 
                                else 
                                {
                                    RedrawStripInfo.nCount = cch;
                                    RedrawStripInfo.lpString = lpstring;
                                    RedrawStripInfo.ichString = ichString;
                                    RedrawStripInfo.XStartPos = xStripStPos;
                                }
                            }

                            if (wNegAwidth) 
                            {
                                //
                                // Must redraw transparently the first part of the next strip later.
                                //
                                if (RedrawStripInfo.nCount) 
                                {
                                    //
                                    // A previous strip also needs to be redrawn; So, merge this
                                    // strip to that strip.
                                    //
                                    RedrawStripInfo.nCount = (NegAInfo.ichString - RedrawStripInfo.ichString) +
                                           NegAInfo.nCount;
                                } 
                                else
                                {
                                    RedrawStripInfo = NegAInfo;
                                }
                            }
                        }
                    }
                }

                if (rc.left < xClipEndPos) 
                {
                    if (fFirstPass) 
                    {
                        //
                        // If this is the end of the strip, then complete the rectangle.
                        //
                        if ((!nCount) && (xClipEndPos == MAXCLIPENDPOS))
                        {
                            rc.right = max(rc.right, xClipEndPos);
                        }
                        else
                        {
                            rc.right = min(rc.right, xClipEndPos);
                        }
                    }

                    //
                    // Draw the current strip.
                    //
                    if (rc.left < rc.right)
                    {
                        if (ped->fAnsi)
                        {
                            ExtTextOutA(hdc,
                                        xStripStPos,
                                        y,
                                        (fFirstPass && fOpaque ? (ETO_OPAQUE | ETO_CLIPPED) : ETO_CLIPPED),
                                        (LPRECT)&rc, lpstring, cch, 0L);
                        }
                        else
                        {
                            ExtTextOutW(hdc,
                                        xStripStPos,
                                        y,
                                        (fFirstPass && fOpaque ? (ETO_OPAQUE | ETO_CLIPPED) : ETO_CLIPPED),
                                        (LPRECT)&rc, (LPWSTR)lpstring, cch, 0L);
                        }
                    }
                }

                if (fFirstPass)
                {
                    rc.left = max(rc.right, xClipStPos);
                }
                ichString += (cch+nConsecutiveTabs);
            }

            //
            // Skip over the tab and the characters we just drew.
            //
            lpstring += (cch + nConsecutiveTabs) * ped->cbChar;
        }

        xEndOfStrip = xEnd;

        //
        // check if we need to draw some portions transparently.
        //
        if (fFirstPass && fDraw && RedrawStripInfo.nCount) 
        {
            iSavedBkMode = SetBkMode(hdc, TRANSPARENT);
            fFirstPass = FALSE;

            nCount = RedrawStripInfo.nCount;
            rc.left = xClipStPos;
            rc.right = xClipEndPos;
            lpstring = RedrawStripInfo.lpString;
            ichString = RedrawStripInfo.ichString;
            xEnd = RedrawStripInfo.XStartPos;

            //
            // Redraw Transparently.
            //
            goto RedrawStrip;
        }

        //
        // Did we change the Bk mode?
        //
        if (iSavedBkMode)
        {
            SetBkMode(hdc, iSavedBkMode);
        }

        uRet = (UINT)(xEndOfStrip - xStart);
    }

    SetTextColor(hdc, clrTextSave);
    SetBkColor(hdc, clrBkSave);
    if (hbrBack && fNeedDelete)
    {
        DeleteObject(hbrBack);
    }

    return uRet;
}


//---------------------------------------------------------------------------//
//
// Edit_CchInWidth AorW
//
// Returns maximum count of characters (up to cch) from the given
// string (starting either at the beginning and moving forward or at the
// end and moving backwards based on the setting of the fForward flag)
// which will fit in the given width. ie. Will tell you how much of
// lpstring will fit in the given width even when using proportional
// characters. WARNING: If we use kerning, then this loses...
// 
// NOTE: Edit_CchInWidth is not called if the language pack is loaded.
// 
ICH Edit_CchInWidth(
    PED   ped,
    HDC   hdc,
    LPSTR lpText,
    ICH   cch,
    INT   width,
    BOOL  fForward)
{
    INT stringExtent;
    INT cchhigh;
    INT cchnew = 0;
    INT cchlow = 0;
    SIZE size;
    LPSTR lpStart;

    if ((width <= 0) || !cch)
    {
        return (0);
    }

    //
    // Optimize nonproportional fonts for single line ec since they don't have
    // tabs.
    //

    //
    // Change optimize condition for fixed pitch font
    //
    if (ped->fNonPropFont && ped->fSingle && !ped->fDBCS) 
    {
        return Edit_AdjustIch(ped, lpText, umin(width/ped->aveCharWidth, (INT)cch));
    }

    //
    // Check if password hidden chars are being used.
    //
    if (ped->charPasswordChar) 
    {
        return (umin(width / ped->cPasswordCharWidth, (INT)cch));
    }

    //
    // ALWAYS RESTRICT TO AT MOST MAXLINELENGTH to avoid overflow...
    //
    cch = umin(MAXLINELENGTH, cch);

    cchhigh = cch + 1;
    while (cchlow < cchhigh - 1) 
    {
        cchnew = umax((cchhigh - cchlow) / 2, 1) + cchlow;

        lpStart = lpText;

        //
        // If we want to figure out how many fit starting at the end and moving
        // backwards, make sure we move to the appropriate position in the
        // string before calculating the text extent.
        //
        if (!fForward)
        {
            lpStart += (cch - cchnew)*ped->cbChar;
        }

        if (ped->fSingle) 
        {
            if (ped->fAnsi)
            {
                GetTextExtentPointA(hdc, (LPSTR)lpStart, cchnew, &size);
            }
            else
            {
                GetTextExtentPointW(hdc, (LPWSTR)lpStart, cchnew, &size);
            }

            stringExtent = size.cx;
        } 
        else 
        {
            stringExtent = Edit_TabTheTextOut(hdc, 0, 0, 0, 0,
                lpStart,
                cchnew, 0,
                ped, 0, ECT_CALC, NULL );
        }

        if (stringExtent > width) 
        {
            cchhigh = cchnew;
        } 
        else 
        {
            cchlow = cchnew;
        }
    }

    //
    // Call Edit_AdjustIch ( generic case )
    //
    cchlow = Edit_AdjustIch(ped, lpText, cchlow);

    return cchlow;
}


//---------------------------------------------------------------------------//
//
// Edit_FindTab
//
// Scans lpstr and return s the number of CHARs till the first TAB.
// Scans at most cch chars of lpstr.
//
ICH Edit_FindTabA(
    LPSTR lpstr,
    ICH cch)
{
    LPSTR copylpstr = lpstr;

    if (cch)
    {
        while (*lpstr != VK_TAB) 
        {
            lpstr++;
            if (--cch == 0)
            {
                break;
            }
        }
    }

    return (ICH)(lpstr - copylpstr);
}


//---------------------------------------------------------------------------//
//
ICH Edit_FindTabW(
    LPWSTR lpstr,
    ICH cch)
{
    LPWSTR copylpstr = lpstr;

    if (cch)
    {
        while (*lpstr != VK_TAB) 
        {
            lpstr++;
            if (--cch == 0)
            {
                break;
            }
        }
    }

    return ((ICH)(lpstr - copylpstr));
}

//---------------------------------------------------------------------------//
//
// Edit_GetBrush()
// 
// Gets appropriate background brush to erase with.
//
HBRUSH Edit_GetBrush(PED ped, HDC hdc, LPBOOL pfNeedDelete)
{
    HBRUSH   hbr;
    COLORREF clr;
    HRESULT  hr = E_FAIL;

#ifdef _USE_DRAW_THEME_TEXT_
    if (ped->hTheme)
    {
        INT iStateId = Edit_GetStateId(ped);

        hr = GetThemeColor(ped->hTheme, EP_EDITTEXT, iStateId, TMT_FILLCOLOR, &clr);
        if (SUCCEEDED(hr))
        {
            hbr = CreateSolidBrush(clr);

            if (pfNeedDelete)
            {
                //
                // tell the caller this brush needs to be deleted
                //
                *pfNeedDelete = TRUE;
            }
        }
    }
#endif // _USE_DRAW_THEME_TEXT_

    if (!ped->hTheme || FAILED(hr))
    {
        BOOL f40Compat;

        f40Compat = Is400Compat(UserGetVersion());

        //
        // Get background brush
        //
        if ((ped->fReadOnly || ped->fDisabled) && f40Compat) 
        {
            hbr = Edit_GetControlBrush(ped, hdc, WM_CTLCOLORSTATIC);
        } 
        else
        {
            hbr = Edit_GetControlBrush(ped, hdc, WM_CTLCOLOREDIT);
        }

        if (ped->fDisabled && (ped->fSingle || f40Compat)) 
        {
            //
            // Change text color
            //
            clr = GetSysColor(COLOR_GRAYTEXT);
            if (clr != GetBkColor(hdc))
            {
                SetTextColor(hdc, clr);
            }
        }
    }

    return hbr;
}


//---------------------------------------------------------------------------//
//
// NextWordCallBack
//
VOID NextWordCallBack(PED ped, ICH ichStart, BOOL fLeft, ICH  *pichMin, ICH  *pichMax)
{
    ICH ichMinSel;
    ICH ichMaxSel;
    LPSTR pText;

    pText = Edit_Lock(ped);

    if (fLeft || 
        (!(BOOL)CALLWORDBREAKPROC(ped->lpfnNextWord, (LPSTR)pText, ichStart, ped->cch, WB_ISDELIMITER) &&
        (ped->fAnsi ? (*(pText + ichStart) != VK_RETURN) : (*((LPWSTR)pText + ichStart) != VK_RETURN))))
    {
        ichMinSel = CALLWORDBREAKPROC(*ped->lpfnNextWord, (LPSTR)pText, ichStart, ped->cch, WB_LEFT);
    }
    else
    {
        ichMinSel = CALLWORDBREAKPROC(*ped->lpfnNextWord, (LPSTR)pText, ichStart, ped->cch, WB_RIGHT);
    }

    ichMaxSel = min(ichMinSel + 1, ped->cch);

    if (ped->fAnsi) 
    {
        if (*(pText + ichMinSel) == VK_RETURN) 
        {
            if (ichMinSel > 0 && *(pText + ichMinSel - 1) == VK_RETURN) 
            {
                //
                // So that we can treat CRCRLF as one word also.
                //
                ichMinSel--;
            } 
            else if (*(pText+ichMinSel + 1) == VK_RETURN) 
            {
                //
                // Move MaxSel on to the LF
                //
                ichMaxSel++;
            }
        }
    } 
    else 
    {
        if (*((LPWSTR)pText + ichMinSel) == VK_RETURN) 
        {
            if (ichMinSel > 0 && *((LPWSTR)pText + ichMinSel - 1) == VK_RETURN) 
            {
                //
                // So that we can treat CRCRLF as one word also.
                //
                ichMinSel--;
            } 
            else if (*((LPWSTR)pText+ichMinSel + 1) == VK_RETURN) 
            {
                //
                // Move MaxSel on to the LF
                //
                ichMaxSel++;
            }
        }
    }

    ichMaxSel = CALLWORDBREAKPROC(ped->lpfnNextWord, (LPSTR)pText, ichMaxSel, ped->cch, WB_RIGHT);
    Edit_Unlock(ped);

    if (pichMin)  
    {
        *pichMin = ichMinSel;
    }

    if (pichMax)
    {
        *pichMax = ichMaxSel;
    }
}


//---------------------------------------------------------------------------//
//
// NextWordLpkCallback
// 
// Identifies next/prev word position for complex scripts
//
VOID NextWordLpkCallBack(PED  ped, ICH  ichStart, BOOL fLeft, ICH *pichMin, ICH *pichMax)
{
    PSTR pText = Edit_Lock(ped);
    HDC  hdc   = Edit_GetDC(ped, TRUE);

    ped->pLpkEditCallout->EditNextWord((PED0)ped, hdc, pText, ichStart, fLeft, pichMin, pichMax);

    Edit_ReleaseDC(ped, hdc, TRUE);
    Edit_Unlock(ped);
}


//---------------------------------------------------------------------------//
//
// Edit_Word
//
// if fLeft, Returns the ichMinSel and ichMaxSel of the word to the
// left of ichStart. ichMinSel contains the starting letter of the word,
// ichmaxsel contains all spaces up to the first character of the next word.
// 
// if !fLeft, Returns the ichMinSel and ichMaxSel of the word to the right of
// ichStart. ichMinSel contains the starting letter of the word, ichmaxsel
// contains the first letter of the next word. If ichStart is in the middle
// of a word, that word is considered the left or right word.
// 
// A CR LF pair or CRCRLF triple is considered a single word in
// multiline edit controls.
//
VOID Edit_Word(PED ped, ICH ichStart, BOOL fLeft, LPICH pichMin, LPICH pichMax)
{
    BOOL charLocated = FALSE;
    BOOL spaceLocated = FALSE;

    if ((!ichStart && fLeft) || (ichStart == ped->cch && !fLeft)) 
    {
        //
        // We are at the beginning of the text (looking left) or we are at end
        // of text (looking right), no word here
        //
        if (pichMin)
        {
            *pichMin = 0;
        }

        if (pichMax)
        { 
            *pichMax = 0;
        }

        return;
    }

    //
    // Don't give out hints about word breaks if password chars are being used,
    //
    if (ped->charPasswordChar) 
    {
        if (pichMin)
        {
            *pichMin = 0;
        }

        if (pichMax) 
        {
            *pichMax = ped->cch;
        }

        return;
    }

    if (ped->fAnsi) 
    {
        PSTR pText; 
        PSTR pWordMinSel;
        PSTR pWordMaxSel;
        PSTR pPrevChar;

        UserAssert(ped->cbChar == sizeof(CHAR));

        if (ped->lpfnNextWord) 
        {
            NextWordCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        if (ped->pLpkEditCallout) 
        {
            NextWordLpkCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        pText = Edit_Lock(ped);
        pWordMinSel = pWordMaxSel = pText + ichStart;

        //
        // if fLeft: Move pWordMinSel to the left looking for the start of a word.
        // If we start at a space, we will include spaces in the selection as we
        // move left untill we find a nonspace character. At that point, we continue
        // looking left until we find a space. Thus, the selection will consist of
        // a word with its trailing spaces or, it will consist of any leading at the
        // beginning of a line of text.
        //

        //
        // if !fLeft: (ie. right word) Move pWordMinSel looking for the start of a
        // word. If the pWordMinSel points to a character, then we move left
        // looking for a space which will signify the start of the word. If
        // pWordMinSel points to a space, we look right till we come upon a
        // character. pMaxWord will look right starting at pMinWord looking for the
        // end of the word and its trailing spaces.
        //

        if (fLeft || !ISDELIMETERA(*pWordMinSel) && *pWordMinSel != 0x0D) 
        {
            //
            // If we are moving left or if we are moving right and we are not on a
            // space or a CR (the start of a word), then we was look left for the
            // start of a word which is either a CR or a character. We do this by
            // looking left till we find a character (or if CR we stop), then we
            // continue looking left till we find a space or LF.
            //
            while (pWordMinSel > pText && ((!ISDELIMETERA(*(pWordMinSel - 1)) &&
                    *(pWordMinSel - 1) != 0x0A) || !charLocated)) 
            {
                //
                // Treat double byte character as a word  ( in ansi pWordMinSel loop )
                //
                pPrevChar = Edit_AnsiPrev( ped, pText, pWordMinSel );

                //
                // are looking right ( !fLeft ).
                // current character is a double byte chararacter or
                // character is a double byte character, we
                // on the beggining of a word.
                //
                if ( !fLeft && ( ISDELIMETERA( *pPrevChar )           ||
                                 *pPrevChar == 0x0A                   ||
                                 Edit_IsDBCSLeadByte(ped, *pWordMinSel)  ||
                                 pWordMinSel - pPrevChar == 2 ) ) 
                {
                    //
                    // If we are looking for the start of the word right, then we
                    // stop when we have found it. (needed in case charLocated is
                    // still FALSE)
                    //
                    break;
                }

                if (pWordMinSel - pPrevChar == 2) 
                {
                    //
                    // character is a double byte character.
                    // we are in a word ( charLocated == TRUE )
                    // position is the beginning of the word
                    // we are not in a word ( charLocated == FALSE )
                    // previous character is what we looking for.
                    //
                    if (!charLocated) 
                    {
                        pWordMinSel = pPrevChar;
                    }

                    break;
                }

                pWordMinSel = pPrevChar;

                if (!ISDELIMETERA(*pWordMinSel) && *pWordMinSel != 0x0A) 
                {
                    //
                    // We have found the last char in the word. Continue looking
                    // backwards till we find the first char of the word
                    //
                    charLocated = TRUE;

                    //
                    // We will consider a CR the start of a word
                    //
                    if (*pWordMinSel == 0x0D)
                    {
                        break;
                    }
                }
            }
        } 
        else 
        {
            while ((ISDELIMETERA(*pWordMinSel) || *pWordMinSel == 0x0A) && pWordMinSel < pText + ped->cch)
            {
                pWordMinSel++;
            }
        }

        //
        // Adjust the initial position of pWordMaxSel ( in ansi )
        //
        pWordMaxSel = Edit_AnsiNext(ped, pWordMinSel);
        pWordMaxSel = min(pWordMaxSel, pText + ped->cch);

        //
        // pWordMinSel points a double byte character AND
        // points non space
        // then
        // pWordMaxSel points the beggining of next word.
        //
        if ((pWordMaxSel - pWordMinSel == 2) && !ISDELIMETERA(*pWordMaxSel))
        {
            goto FastReturnA;
        }

        if (*pWordMinSel == 0x0D) 
        {
            if (pWordMinSel > pText && *(pWordMinSel - 1) == 0x0D)
            {
                //
                // So that we can treat CRCRLF as one word also.
                //
                pWordMinSel--;
            }
            else if (*(pWordMinSel + 1) == 0x0D)
            {
                //
                // Move MaxSel on to the LF
                //
                pWordMaxSel++;
            }
        }

        //
        // Check if we have a one character word
        //
        if (ISDELIMETERA(*pWordMaxSel))
        {
            spaceLocated = TRUE;
        }

        //
        // Move pWordMaxSel to the right looking for the end of a word and its
        // trailing spaces. WordMaxSel stops on the first character of the next
        // word. Thus, we break either at a CR or at the first nonspace char after
        // a run of spaces or LFs.
        //
        while ((pWordMaxSel < pText + ped->cch) && (!spaceLocated || (ISDELIMETERA(*pWordMaxSel)))) 
        {
            if (*pWordMaxSel == 0x0D)
            {
                break;
            }

            //
            // Treat double byte character as a word ( in ansi pWordMaxSel loop )
            // if it's a double byte character then
            // we are at the beginning of next word
            // which is a double byte character.
            //
            if (Edit_IsDBCSLeadByte( ped, *pWordMaxSel))
            {
                break;
            }

            pWordMaxSel++;

            if (ISDELIMETERA(*pWordMaxSel))
            {
                spaceLocated = TRUE;
            }

            if (*(pWordMaxSel - 1) == 0x0A)
            {
                break;
            }
        }

        //
        // label for fast return ( for Ansi )
        //
FastReturnA:
        Edit_Unlock(ped);

        if (pichMin)
        {
            *pichMin = (ICH)(pWordMinSel - pText);
        }

        if (pichMax)
        {
            *pichMax = (ICH)(pWordMaxSel - pText);
        }
    } 
    else 
    {
        LPWSTR pwText;
        LPWSTR pwWordMinSel;
        LPWSTR pwWordMaxSel;
        BOOL   charLocated = FALSE;
        BOOL   spaceLocated = FALSE;
        PWSTR  pwPrevChar;

        UserAssert(ped->cbChar == sizeof(WCHAR));

        if (ped->lpfnNextWord) 
        {
            NextWordCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        if (ped->pLpkEditCallout) 
        {
            NextWordLpkCallBack(ped, ichStart, fLeft, pichMin, pichMax);
            return;
        }

        pwText = (LPWSTR)Edit_Lock(ped);
        pwWordMinSel = pwWordMaxSel = pwText + ichStart;

        //
        // if fLeft: Move pWordMinSel to the left looking for the start of a word.
        // If we start at a space, we will include spaces in the selection as we
        // move left untill we find a nonspace character. At that point, we continue
        // looking left until we find a space. Thus, the selection will consist of
        // a word with its trailing spaces or, it will consist of any leading at the
        // beginning of a line of text.
        //

        //
        // if !fLeft: (ie. right word) Move pWordMinSel looking for the start of a
        // word. If the pWordMinSel points to a character, then we move left
        // looking for a space which will signify the start of the word. If
        // pWordMinSel points to a space, we look right till we come upon a
        // character. pMaxWord will look right starting at pMinWord looking for the
        // end of the word and its trailing spaces.
        //

        if (fLeft || (!ISDELIMETERW(*pwWordMinSel) && *pwWordMinSel != 0x0D))
        {
            //
            // If we are moving left or if we are moving right and we are not on a
            // space or a CR (the start of a word), then we was look left for the
            // start of a word which is either a CR or a character. We do this by
            // looking left till we find a character (or if CR we stop), then we
            //
            // continue looking left till we find a space or LF.
            while (pwWordMinSel > pwText && ((!ISDELIMETERW(*(pwWordMinSel - 1)) && *(pwWordMinSel - 1) != 0x0A) || !charLocated))
            {
                //
                // Treat double byte character as a word  ( in unicode pwWordMinSel loop )
                //
                pwPrevChar = pwWordMinSel - 1;

                //
                // we are looking right ( !fLeft ).
                //  
                // if current character is a double width chararacter
                // or previous character is a double width character,
                // we are on the beggining of a word.
                //
                if (!fLeft && (ISDELIMETERW( *pwPrevChar)  ||
                               *pwPrevChar == 0x0A         ||
                               Edit_IsFullWidth(CP_ACP,*pwWordMinSel) ||
                               Edit_IsFullWidth(CP_ACP,*pwPrevChar)))
                {
                    //
                    // If we are looking for the start of the word right, then we
                    // stop when we have found it. (needed in case charLocated is
                    // still FALSE)
                    //
                    break;
                }

                if (Edit_IsFullWidth(CP_ACP,*pwPrevChar)) 
                {
                    //
                    // Previous character is a double width character.
                    // 
                    // if we are in a word ( charLocated == TRUE )
                    // current position is the beginning of the word
                    // if we are not in a word ( charLocated == FALSE )
                    // the previous character is what we looking for.
                    //
                    if ( !charLocated ) 
                    {
                        pwWordMinSel = pwPrevChar;
                    }

                    break;
                }

                pwWordMinSel = pwPrevChar;

                if (!ISDELIMETERW(*pwWordMinSel) && *pwWordMinSel != 0x0A)
                {
                    //
                    // We have found the last char in the word. Continue looking
                    // backwards till we find the first char of the word
                    //
                    charLocated = TRUE;

                    //
                    // We will consider a CR the start of a word
                    //
                    if (*pwWordMinSel == 0x0D)
                    {
                        break;
                    }
                }
            }
        } 
        else 
        {
            //
            // We are moving right and we are in between words so we need to move
            // right till we find the start of a word (either a CR or a character.
            //
            while ((ISDELIMETERW(*pwWordMinSel) || *pwWordMinSel == 0x0A) && pwWordMinSel < pwText + ped->cch)
            {
                pwWordMinSel++;
            }
        }

        pwWordMaxSel = min((pwWordMinSel + 1), (pwText + ped->cch));

        //
        // If pwWordMinSel points a double width character AND
        // pwWordMaxSel points non space then
        // pwWordMaxSel points the beggining of next word.
        //
        if (Edit_IsFullWidth(CP_ACP,*pwWordMinSel) && ! ISDELIMETERW(*pwWordMaxSel))
        {
            goto FastReturnW;
        }

        if (*pwWordMinSel == 0x0D) 
        {
            if (pwWordMinSel > pwText && *(pwWordMinSel - 1) == 0x0D)
            {
                //
                // So that we can treat CRCRLF as one word also.
                //
                pwWordMinSel--;
            }
            else if (*(pwWordMinSel + 1) == 0x0D)
            {
                //
                // Move MaxSel on to the LF
                //
                pwWordMaxSel++;
            }
        }

        //
        // Check if we have a one character word
        //
        if (ISDELIMETERW(*pwWordMaxSel))
        {
            spaceLocated = TRUE;
        }

        //
        // Move pwWordMaxSel to the right looking for the end of a word and its
        // trailing spaces. WordMaxSel stops on the first character of the next
        // word. Thus, we break either at a CR or at the first nonspace char after
        // a run of spaces or LFs.
        //
        while ((pwWordMaxSel < pwText + ped->cch) && (!spaceLocated || (ISDELIMETERW(*pwWordMaxSel)))) 
        {
            if (*pwWordMaxSel == 0x0D)
            {
                break;
            }

            //
            // treat double byte character as a word ( in unicode pwWordMaxSel loop )
            // if it's a double width character
            // then we are at the beginning of
            // the next word which is a double
            // width character.
            //
            if (Edit_IsFullWidth(CP_ACP,*pwWordMaxSel))
            {
                break;
            }

            pwWordMaxSel++;

            if (ISDELIMETERW(*pwWordMaxSel))
            {
                spaceLocated = TRUE;
            }


            if (*(pwWordMaxSel - 1) == 0x0A)
            {
                break;
            }
        }

        //
        // label for fast return ( for Unicode )
        //
FastReturnW:
        Edit_Unlock(ped);

        if (pichMin)
        {
            *pichMin = (ICH)(pwWordMinSel - pwText);
        }

        if (pichMax)
        {
            *pichMax = (ICH)(pwWordMaxSel - pwText);
        }
    }
}


//---------------------------------------------------------------------------//
//
// Edit_SaveUndo()
//
// Saves old undo information into given buffer, and clears out info in
// passed in undo buffer.  If we're restoring, pundoFrom and pundoTo are
// reversed.
//
VOID Edit_SaveUndo(PUNDO pundoFrom, PUNDO pundoTo, BOOL fClear)
{
    //
    // Save undo data
    //
    RtlCopyMemory(pundoTo, pundoFrom, sizeof(UNDO));

    //
    // Clear passed in undo buffer
    //
    if (fClear)
    {
        RtlZeroMemory(pundoFrom, sizeof(UNDO));
    }
}


//---------------------------------------------------------------------------//
//
// Edit_EmptyUndo AorW
//
// Empties the undo buffer.
//
VOID Edit_EmptyUndo(PUNDO pundo)
{
    if (pundo->hDeletedText)
    {
        GlobalFree(pundo->hDeletedText);
    }

    RtlZeroMemory(pundo, sizeof(UNDO));
}


//---------------------------------------------------------------------------//
//
// Edit_MergeUndoInsertInfo() -
//
// When an insert takes place, this function is called with the info about
// the new insertion (the insertion point and the count of chars inserted);
// This looks at the existing Undo info and merges the new new insert info
// with it.
//
VOID Edit_MergeUndoInsertInfo(PUNDO pundo, ICH ichInsert, ICH cchInsert)
{
    //
    // If undo buffer is empty, just insert the new info as UNDO_INSERT
    //
    if (pundo->undoType == UNDO_NONE) 
    {
        pundo->undoType    = UNDO_INSERT;
        pundo->ichInsStart = ichInsert;
        pundo->ichInsEnd   = ichInsert+cchInsert;
    } 
    else if (pundo->undoType & UNDO_INSERT) 
    {
        //
        // If there's already some undo insert info,
        // try to merge the two.
        //

        //
        // Check they are adjacent.
        //
        if (pundo->ichInsEnd == ichInsert)
        {
            //
            // if so, just concatenate.
            //
            pundo->ichInsEnd += cchInsert;
        }
        else 
        {
            //
            // The new insert is not contiguous with the old one.
            //
UNDOINSERT:
            //
            // If there is some UNDO_DELETE info already here, check to see
            // if the new insert takes place at a point different from where
            // that deletion occurred.
            //
            if ((pundo->undoType & UNDO_DELETE) && (pundo->ichDeleted != ichInsert))
            {
                //
                // User is inserting into a different point; So, let us
                // forget any UNDO_DELETE info;
                //
                if (pundo->hDeletedText)
                {
                    GlobalFree(pundo->hDeletedText);
                }

                pundo->hDeletedText = NULL;
                pundo->ichDeleted = 0xFFFFFFFF;
                pundo->undoType &= ~UNDO_DELETE;
            }

            //
            // Since the old insert and new insert are not adjacent, let us
            // forget everything about the old insert and keep just the new
            // insert info as the UNDO_INSERT.
            //
            pundo->ichInsStart = ichInsert;
            pundo->ichInsEnd   = ichInsert + cchInsert;
            pundo->undoType |= UNDO_INSERT;
        }
    } 
    else if (pundo->undoType == UNDO_DELETE) 
    {
        //
        // If there is some Delete Info already present go and handle it.
        //
        goto UNDOINSERT;
    }
}


//---------------------------------------------------------------------------//
//
// Edit_InsertText AorW
//
// Adds cch characters from lpText into the ped->hText starting at
// ped->ichCaret. Returns TRUE if successful else FALSE. Updates
// ped->cchAlloc and ped->cch properly if additional memory was allocated or
// if characters were actually added. Updates ped->ichCaret to be at the end
// of the inserted text. min and maxsel are equal to ichcaret.
//
BOOL Edit_InsertText(PED ped, LPSTR lpText, ICH* pcchInsert)
{
    PSTR pedText;
    PSTR pTextBuff;
    LONG style;
    HANDLE hTextCopy;
    DWORD allocamt;

    //
    // If the last byte (lpText[cchInsert - 1]) is a DBCS leading byte
    // we need to adjust it.
    //
    *pcchInsert = Edit_AdjustIch(ped, lpText, *pcchInsert);

    if (!*pcchInsert)
    {
        return TRUE;
    }

    //
    // Do we already have enough memory??
    //
    if (*pcchInsert >= (ped->cchAlloc - ped->cch)) 
    {
        //
        // Allocate what we need plus a little extra. Return FALSE if we are
        // unsuccessful.
        //
        allocamt = (ped->cch + *pcchInsert) * ped->cbChar;
        allocamt += CCHALLOCEXTRA;

        // if (!ped->fSingle) 
        // {
            hTextCopy = LocalReAlloc(ped->hText, allocamt, LHND);
            if (hTextCopy) 
            {
                ped->hText = hTextCopy;
            } 
            else 
            {
                return FALSE;
            }
        // } 
        // else 
        // {
        // if (!LocalReallocSafe(ped->hText, allocamt, LHND, pped))
        //                return FALSE;
        // }

        ped->cchAlloc = (ICH) LocalSize(ped->hText) / ped->cbChar;
    }

    //
    // Ok, we got the memory. Now copy the text into the structure
    // 
    pedText = Edit_Lock(ped);

    if (ped->pLpkEditCallout) 
    {
        HDC hdc;
        INT iResult;

        hdc = Edit_GetDC(ped, TRUE);
        iResult = ped->pLpkEditCallout->EditVerifyText((PED0)ped, hdc, pedText, ped->ichCaret, lpText, *pcchInsert);
        Edit_ReleaseDC (ped, hdc, TRUE);

        if (iResult == 0) 
        {
            Edit_Unlock (ped);
            return TRUE;
        }
    }

    //
    // Get a pointer to the place where text is to be inserted
    //
    pTextBuff = pedText + ped->ichCaret * ped->cbChar;

    if (ped->ichCaret != ped->cch) 
    {
        //
        // We are inserting text into the middle. We have to shift text to the
        // right before inserting new text.
        //
        memmove(pTextBuff + *pcchInsert * ped->cbChar, pTextBuff, (ped->cch-ped->ichCaret) * ped->cbChar);
    }

    //
    // Make a copy of the text being inserted in the edit buffer.
    // Use this copy for doing UPPERCASE/LOWERCASE ANSI/OEM conversions
    // Fix for Bug #3406 -- 01/29/91 -- SANKAR --
    //
    memmove(pTextBuff, lpText, *pcchInsert * ped->cbChar);
    ped->cch += *pcchInsert;

    //
    // Get the control's style
    //
    style = GET_STYLE(ped);

    //
    // Do the Upper/Lower conversion
    //
    if (style & ES_LOWERCASE) 
    {
        if (ped->fAnsi)
        {
            CharLowerBuffA((LPSTR)pTextBuff, *pcchInsert);
        }
        else
        {
            CharLowerBuffW((LPWSTR)pTextBuff, *pcchInsert);
        }
    } 
    else 
    {
        if (style & ES_UPPERCASE) 
        {
            if (ped->fAnsi) 
            {
                CharUpperBuffA(pTextBuff, *pcchInsert);
            } 
            else 
            {
                CharUpperBuffW((LPWSTR)pTextBuff, *pcchInsert);
            }
        }
    }

    //
    // Do the OEM conversion
    //
    // For backward compatibility with NT4, we don't perform OEM conversion
    // for older apps if the system locale is FarEast.
    //
    if ((style & ES_OEMCONVERT) &&
        (!g_fDBCSEnabled || Is500Compat(UserGetVersion()) || GetOEMCP() != GetACP())) 
    {
        ICH i;

        if (ped->fAnsi) 
        {
            for (i = 0; i < *pcchInsert; i++) 
            {
                //
                // We don't need to call CharToOemBuff etc. if the character
                // is a double byte character.  And, calling Edit_IsDBCSLeadByte is
                // faster and less complicated because we don't have to deal
                // with the 2 byte dbcs cases.
                //
                if (g_fDBCSEnabled && Edit_IsDBCSLeadByte(ped, *(lpText+i))) 
                {
                    i++;
                    continue;
                }

                if (IsCharLowerA(*(pTextBuff + i))) 
                {
                    CharUpperBuffA(pTextBuff + i, 1);
                    CharToOemBuffA(pTextBuff + i, pTextBuff + i, 1);
                    OemToCharBuffA(pTextBuff + i, pTextBuff + i, 1);
                    CharLowerBuffA(pTextBuff + i, 1);
                } 
                else 
                {
                    CharToOemBuffA(pTextBuff + i, pTextBuff + i, 1);
                    OemToCharBuffA(pTextBuff + i, pTextBuff + i, 1);
                }
            }
        } 
        else 
        {
            //
            // Because 'ch' may become DBCS, and have a space for NULL.
            //
            UCHAR ch[4];
            LPWSTR lpTextW = (LPWSTR)pTextBuff;

            for (i = 0; i < *pcchInsert; i++) 
            {
                if (*(lpTextW + i) == UNICODE_CARRIAGERETURN ||
                    *(lpTextW + i) == UNICODE_LINEFEED ||
                    *(lpTextW + i) == UNICODE_TAB) 
                {
                    continue;
                }

                if (IsCharLowerW(*(lpTextW + i))) 
                {
                    CharUpperBuffW(lpTextW + i, 1);

                    //
                    // make sure the null-terminate.
                    //
                    *(LPDWORD)ch = 0;
                    CharToOemBuffW(lpTextW + i, ch, 1);

                    //
                    // We assume any SBCS/DBCS character will converted
                    // to 1 Unicode char, Otherwise, we may overwrite
                    // next character...
                    //
                    OemToCharBuffW(ch, lpTextW + i, strlen(ch));
                    CharLowerBuffW(lpTextW + i, 1);
                }
                else 
                {
                    //
                    // make sure the null-terminate.
                    //
                    *(LPDWORD)ch = 0;
                    CharToOemBuffW(lpTextW + i, ch, 1);

                    //
                    // We assume any SBCS/DBCS character will converted
                    // to 1 Unicode char, Otherwise, we may overwrite
                    // next character...
                    //
                    OemToCharBuffW(ch, lpTextW + i, strlen(ch));
                }
            }
        }
    }

    //
    // Adjust UNDO fields so that we can undo this insert...
    //
    Edit_MergeUndoInsertInfo(Pundo(ped), ped->ichCaret, *pcchInsert);

    ped->ichCaret += *pcchInsert;

    if (ped->pLpkEditCallout) 
    {
        HDC hdc;

        hdc = Edit_GetDC(ped, TRUE);
        ped->ichCaret = ped->pLpkEditCallout->EditAdjustCaret((PED0)ped, hdc, pedText, ped->ichCaret);
        Edit_ReleaseDC (ped, hdc, TRUE);
    }

    ped->ichMinSel = ped->ichMaxSel = ped->ichCaret;

    Edit_Unlock(ped);

    //
    // Set dirty bit
    //
    ped->fDirty = TRUE;

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// Edit_DeleteText AorW
// 
// Deletes the text between ped->ichMinSel and ped->ichMaxSel. The
// character at ichMaxSel is not deleted. But the character at ichMinSel is
// deleted. ped->cch is updated properly and memory is deallocated if enough
// text is removed. ped->ichMinSel, ped->ichMaxSel, and ped->ichCaret are set
// to point to the original ped->ichMinSel. Returns the number of characters
// deleted.
//
ICH Edit_DeleteText(PED ped)
{
    PSTR   pedText;
    ICH    cchDelete;
    LPSTR  lpDeleteSaveBuffer;
    HANDLE hDeletedText;
    DWORD  bufferOffset;

    cchDelete = ped->ichMaxSel - ped->ichMinSel;

    if (cchDelete)
    {

        //
        // Ok, now lets delete the text.
        //
        pedText = Edit_Lock(ped);

        //
        // Adjust UNDO fields so that we can undo this delete...
        //
        if (ped->undoType == UNDO_NONE) 
        {
UNDODELETEFROMSCRATCH:
            if (ped->hDeletedText = GlobalAlloc(GPTR, (LONG)((cchDelete+1)*ped->cbChar))) 
            {
                ped->undoType = UNDO_DELETE;
                ped->ichDeleted = ped->ichMinSel;
                ped->cchDeleted = cchDelete;
                lpDeleteSaveBuffer = ped->hDeletedText;
                RtlCopyMemory(lpDeleteSaveBuffer, pedText + ped->ichMinSel*ped->cbChar, cchDelete*ped->cbChar);
                lpDeleteSaveBuffer[cchDelete*ped->cbChar] = 0;
            }
        } 
        else if (ped->undoType & UNDO_INSERT) 
        {
UNDODELETE:
            Edit_EmptyUndo(Pundo(ped));

            ped->ichInsStart = ped->ichInsEnd = 0xFFFFFFFF;
            ped->ichDeleted = 0xFFFFFFFF;
            ped->cchDeleted = 0;

            goto UNDODELETEFROMSCRATCH;

        } 
        else if (ped->undoType == UNDO_DELETE) 
        {
            if (ped->ichDeleted == ped->ichMaxSel) 
            {
                //
                // Copy deleted text to front of undo buffer
                //
                hDeletedText = GlobalReAlloc(ped->hDeletedText, (LONG)(cchDelete + ped->cchDeleted + 1)*ped->cbChar, GHND);
                if (!hDeletedText)
                {
                    goto UNDODELETE;
                }

                bufferOffset = 0;
                ped->ichDeleted = ped->ichMinSel;

            } 
            else if (ped->ichDeleted == ped->ichMinSel) 
            {
                //
                // Copy deleted text to end of undo buffer
                //
                hDeletedText = GlobalReAlloc(ped->hDeletedText, (LONG)(cchDelete + ped->cchDeleted + 1)*ped->cbChar, GHND);
                if (!hDeletedText)
                {
                    goto UNDODELETE;
                }

                bufferOffset = ped->cchDeleted*ped->cbChar;

            } 
            else 
            {
                //
                // Clear the current UNDO delete and add the new one since
                // the deletes aren't contiguous.
                //
                goto UNDODELETE;
            }

            ped->hDeletedText = hDeletedText;
            lpDeleteSaveBuffer = (LPSTR)hDeletedText;

            if (!bufferOffset) 
            {
                //
                // Move text in delete buffer up so that we can insert the next
                // text at the head of the buffer.
                //
                RtlMoveMemory(lpDeleteSaveBuffer + cchDelete*ped->cbChar, lpDeleteSaveBuffer, ped->cchDeleted*ped->cbChar);
            }

            RtlCopyMemory(lpDeleteSaveBuffer + bufferOffset, pedText + ped->ichMinSel*ped->cbChar, cchDelete*ped->cbChar);

            lpDeleteSaveBuffer[(ped->cchDeleted + cchDelete)*ped->cbChar] = 0;
            ped->cchDeleted += cchDelete;
        }

        if (ped->ichMaxSel != ped->cch) 
        {
            //
            // We are deleting text from the middle of the buffer so we have to
            // shift text to the left.
            //
            RtlMoveMemory(pedText + ped->ichMinSel*ped->cbChar, pedText + ped->ichMaxSel*ped->cbChar, (ped->cch - ped->ichMaxSel)*ped->cbChar);
        }

        if (ped->cchAlloc - ped->cch > CCHALLOCEXTRA) 
        {
            //
            // Free some memory since we deleted a lot
            //
            LocalReAlloc(ped->hText, (DWORD)(ped->cch + (CCHALLOCEXTRA / 2))*ped->cbChar, LHND);
            ped->cchAlloc = (ICH)LocalSize(ped->hText) / ped->cbChar;
        }

        ped->cch -= cchDelete;

        if (ped->pLpkEditCallout) 
        {
            HDC hdc;

            hdc = Edit_GetDC(ped, TRUE);
            ped->ichMinSel = ped->pLpkEditCallout->EditAdjustCaret((PED0)ped, hdc, pedText, ped->ichMinSel);
            Edit_ReleaseDC(ped, hdc, TRUE);
        }

        ped->ichCaret = ped->ichMaxSel = ped->ichMinSel;

        Edit_Unlock(ped);

        //
        // Set dirty bit
        //
        ped->fDirty = TRUE;

    }

    return cchDelete;
}


//---------------------------------------------------------------------------//
//
// Edit_NotifyParent AorW
// 
// Sends the notification code to the parent of the edit control
//
VOID Edit_NotifyParent(PED ped, INT notificationCode)
{
    //
    // wParam is NotificationCode (hiword) and WindowID (loword)
    // lParam is HWND of control sending the message
    // Windows 95 checks for hwndParent != NULL before sending the message, but
    // this is surely rare, and SendMessage NULL hwnd does nowt anyway (IanJa)
    //
    SendMessage(ped->hwndParent, WM_COMMAND,
            (DWORD)MAKELONG(GetWindowID(ped->hwnd), notificationCode),
            (LPARAM)ped->hwnd);
}


//---------------------------------------------------------------------------//
//
// Edit_SetClip AorW
// 
// Sets the clip rect for the hdc to the formatting rectangle intersected
// with the client area.
//
VOID Edit_SetClip(PED ped, HDC hdc, BOOL fLeftMargin)
{
    RECT rcClient;
    RECT rcClip;
    INT  cxBorder;
    INT  cyBorder;

    CopyRect(&rcClip, &ped->rcFmt);

    if (ped->pLpkEditCallout) 
    {
        //
        // Complex script handling chooses whether to write margins later
        //
        rcClip.left  -= ped->wLeftMargin;
        rcClip.right += ped->wRightMargin;
    } 
    else 
    {
        //
        // Should we consider the left margin?
        //
        if (fLeftMargin)
        {
            rcClip.left -= ped->wLeftMargin;
        }

        //
        // Should we consider the right margin?
        //
        if (ped->fWrap)
        {
            rcClip.right += ped->wRightMargin;
        }
    }

    //
    // Set clip rectangle to rectClient intersect rectClip
    // We must clip for single line edits also. -- B#1360
    //
    GetClientRect(ped->hwnd, &rcClient);
    if (ped->fFlatBorder)
    {
        cxBorder = GetSystemMetrics(SM_CXBORDER);
        cyBorder = GetSystemMetrics(SM_CYBORDER);
        InflateRect(&rcClient, cxBorder, cyBorder);
    }

    IntersectRect(&rcClient, &rcClient, &rcClip);
    IntersectClipRect(hdc,rcClient.left, rcClient.top,
            rcClient.right, rcClient.bottom);
}


//---------------------------------------------------------------------------//
//
// Edit_GetDC AorW
//
// Hides the caret, gets the DC for the edit control, and clips to
// the rcFmt rectangle specified for the edit control and sets the proper
// font. If fFastDC, just select the proper font but don't bother about clip
// regions or hiding the caret.
//
HDC Edit_GetDC(PED ped, BOOL fFastDC)
{
    HDC hdc;

    if (!fFastDC)
    {
        HideCaret(ped->hwnd);
    }

    hdc = GetDC(ped->hwnd);
    if (hdc != NULL) 
    {
        Edit_SetClip(ped, hdc, (BOOL)(ped->xOffset == 0));

        //
        // Select the proper font for this edit control's dc.
        //
        if (ped->hFont)
        {
            SelectObject(hdc, ped->hFont);
        }
    }

    return hdc;
}


//---------------------------------------------------------------------------//
//
// Edit_ReleaseDC AorW
// 
// Releases the DC (hdc) for the edit control and shows the caret.
// If fFastDC, just select the proper font but don't bother about showing the
// caret.
//
VOID Edit_ReleaseDC(PED ped, HDC hdc, BOOL fFastDC)
{
    //
    // Restoring font not necessary
    //
    ReleaseDC(ped->hwnd, hdc);

    if (!fFastDC)
    {
        ShowCaret(ped->hwnd);
    }
}


//---------------------------------------------------------------------------//
//
// Edit_ResetTextInfo() AorW
//
// Handles a global change to the text by resetting text offsets, emptying
// the undo buffer, and rebuilding the lines
//
VOID Edit_ResetTextInfo(PED ped)
{
    //
    // Reset caret, selections, scrolling, and dirty information.
    //
    ped->iCaretLine = ped->ichCaret = 0;
    ped->ichMinSel = ped->ichMaxSel = 0;
    ped->xOffset = ped->ichScreenStart = 0;
    ped->fDirty = FALSE;

    Edit_EmptyUndo(Pundo(ped));

    if (ped->fSingle) 
    {
        if (!ped->listboxHwnd)
        {
            Edit_NotifyParent(ped, EN_UPDATE);
        }
    } 
    else 
    {
        EditML_BuildchLines(ped, 0, 0, FALSE, NULL, NULL);
    }

    if (IsWindowVisible(ped->hwnd)) 
    {
        BOOL fErase;

        if (ped->fSingle)
        {
            fErase = FALSE;
        }
        else
        {
            fErase = ((ped->ichLinesOnScreen + ped->ichScreenStart) >= ped->cLines);
        }

        //
        // Always redraw whether or not the insert was successful.  We might
        // have NULL text.  Paint() will check the redraw flag for us.
        //
        Edit_InvalidateClient(ped, fErase);

        //
        // BACKWARD COMPAT HACK: RAID expects the text to have been updated,
        // so we have to do an UpdateWindow here.  It moves an edit control
        // around with fRedraw == FALSE, so it'll never get the paint message
        // with the control in the right place.
        //
        if (!ped->fWin31Compat)
        {
            UpdateWindow(ped->hwnd);
        }
    }

    if (ped->fSingle && !ped->listboxHwnd)
    {
        Edit_NotifyParent(ped, EN_CHANGE);
    }

    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
}


//---------------------------------------------------------------------------//
//
// Edit_SetEditText AorW
// 
// Copies the null terminated text in lpstr to the ped. Notifies the
// parent if there isn't enough memory. Sets the minsel, maxsel, and caret to
// the beginning of the inserted text. Returns TRUE if successful else FALSE
// if no memory (and notifies the parent).
//
BOOL Edit_SetEditText(PED ped, LPSTR lpstr)
{
    ICH cchLength;
    ICH cchSave = ped->cch;
    ICH ichCaretSave = ped->ichCaret;
    HWND hwndSave    = ped->hwnd;
    HANDLE hText;

    ped->cch = ped->ichCaret = 0;

    ped->cchAlloc = (ICH)LocalSize(ped->hText) / ped->cbChar;
    if (!lpstr) 
    {
        hText = LocalReAlloc(ped->hText, CCHALLOCEXTRA*ped->cbChar, LHND);
        if (hText != NULL) 
        {
            ped->hText = hText;
        } 
        else 
        {
            return FALSE;
        }
    } 
    else 
    {
        cchLength = (ped->fAnsi ? strlen((LPSTR)lpstr) : wcslen((LPWSTR)lpstr));

        //
        // Add the text
        //
        if (cchLength && !Edit_InsertText(ped, lpstr, &cchLength)) 
        {
            //
            // Restore original state and notify parent we ran out of memory.
            //
            ped->cch = cchSave;
            ped->ichCaret = ichCaretSave;
            Edit_NotifyParent(ped, EN_ERRSPACE);
            return FALSE;
        }
    }

    ped->cchAlloc = (ICH)LocalSize(ped->hText) / ped->cbChar;

    if (IsWindow(hwndSave))
    {
        Edit_ResetTextInfo(ped);
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// Edit_InvalidateClient()
//
// Invalidates client of edit field.  For old 3.x guys with borders,
// we draw it ourself (compatibility).  So we don't want to invalidate
// the border or we'll get flicker.
//
VOID Edit_InvalidateClient(PED ped, BOOL fErase)
{
    if (ped->fFlatBorder) 
    {
        RECT rcT;
        INT  cxBorder;
        INT  cyBorder;

        GetClientRect(ped->hwnd, &rcT);
        cxBorder = GetSystemMetrics(SM_CXBORDER);
        cyBorder = GetSystemMetrics(SM_CYBORDER);
        InflateRect(&rcT, cxBorder, cyBorder);
        InvalidateRect(ped->hwnd, &rcT, fErase);
    } 
    else 
    {
        InvalidateRect(ped->hwnd, NULL, fErase);
    }
}


//---------------------------------------------------------------------------//
//
// Edit_Copy AorW
// 
// Copies the text between ichMinSel and ichMaxSel to the clipboard.
// Returns the number of characters copied.
// 
ICH Edit_Copy(PED ped)
{
    HANDLE hData;
    char *pchSel;
    char *lpchClip;
    ICH cbData;

    //
    // Don't allow copies from password style controls
    //
    if (ped->charPasswordChar) 
    {

        Edit_ShowBalloonTipWrap(ped->hwnd, IDS_PASSWORDCUT_TITLE, IDS_PASSWORDCUT_MSG, TTI_ERROR);
        MessageBeep(0);

        return 0;
    }

    cbData = (ped->ichMaxSel - ped->ichMinSel) * ped->cbChar;

    if (!cbData)
    {
        return 0;
    }

    if (!OpenClipboard(ped->hwnd))
    {
        return 0;
    }

    EmptyClipboard();

    hData = GlobalAlloc(LHND, (LONG)(cbData + ped->cbChar));
    if (!hData) 
    {
        CloseClipboard();
        return 0;
    }

    lpchClip = GlobalLock(hData);
    UserAssert(lpchClip);
    pchSel = Edit_Lock(ped);
    pchSel = pchSel + (ped->ichMinSel * ped->cbChar);

    RtlCopyMemory(lpchClip, pchSel, cbData);

    if (ped->fAnsi)
    {
        *(lpchClip + cbData) = 0;
    }
    else
    {
        *(LPWSTR)(lpchClip + cbData) = (WCHAR)0;
    }

    Edit_Unlock(ped);
    GlobalUnlock(hData);

    SetClipboardData(ped->fAnsi ? CF_TEXT : CF_UNICODETEXT, hData);

    CloseClipboard();

    return cbData;
}


//---------------------------------------------------------------------------//
LRESULT Edit_TrackBalloonTip(PED ped)
{
    if (ped->hwndBalloon)
    {
        DWORD dwPackedCoords;
        HDC   hdc = Edit_GetDC(ped, TRUE);
        RECT  rcWindow;
        POINT pt;
        int   cxCharOffset = TESTFLAG(GET_EXSTYLE(ped), WS_EX_RTLREADING) ? -ped->aveCharWidth : ped->aveCharWidth;

        //
        // Get the caret position
        //
        if (ped->fSingle)
        {
            pt.x = EditSL_IchToLeftXPos(ped, hdc, ped->ichCaret) + cxCharOffset;
            pt.y = ped->rcFmt.bottom;
        }
        else
        {
            EditML_IchToXYPos(ped, hdc, ped->ichCaret, FALSE, &pt);
            pt.x += cxCharOffset;
            pt.y += ped->lineHeight;
        }

        //
        // Translate to window coords
        //
        GetWindowRect(ped->hwnd, &rcWindow);
        pt.x += rcWindow.left;
        pt.y += rcWindow.top;

        //
        // Position the tip stem at the caret position
        //
        dwPackedCoords = (DWORD) MAKELONG(pt.x, pt.y);
        SendMessage(ped->hwndBalloon, TTM_TRACKPOSITION, 0, (LPARAM) dwPackedCoords);

        Edit_ReleaseDC(ped, hdc, TRUE);

        return 1;
    }

    return 0;
}


//---------------------------------------------------------------------------//
LRESULT CALLBACK Edit_BalloonTipParentSubclassProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData)
{
    PED ped = (PED)dwRefData;
    switch (uMessage)
    {
    case WM_MOVE:
    case WM_SIZING:
        //
        // dismiss any showing tips
        //
        Edit_HideBalloonTip(ped->hwnd);

        break;

    case WM_DESTROY:
        // Clean up subclass
        RemoveWindowSubclass(hDlg, Edit_BalloonTipParentSubclassProc, (UINT_PTR) ped->hwnd);
        break;

    default:
        break;
    }

    return DefSubclassProc(hDlg, uMessage, wParam, lParam);
}


//---------------------------------------------------------------------------//
LRESULT Edit_BalloonTipSubclassParents(PED ped)
{
    // Subclass all windows along the parent chain from the edit control
    // and in the same thread (can only subclass windows with same thread affinity)
    HWND  hwndParent = GetAncestor(ped->hwnd, GA_PARENT);
    DWORD dwTid      = GetWindowThreadProcessId(ped->hwnd, NULL);

    while (hwndParent && (dwTid == GetWindowThreadProcessId(hwndParent, NULL)))
    {
        SetWindowSubclass(hwndParent, Edit_BalloonTipParentSubclassProc, (UINT_PTR)ped->hwnd, (DWORD_PTR)ped);
        hwndParent = GetAncestor(hwndParent, GA_PARENT);
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
HWND Edit_BalloonTipRemoveSubclasses(PED ped)
{
    HWND  hwndParent  = GetAncestor(ped->hwnd, GA_PARENT);
    HWND  hwndTopMost = NULL;
    DWORD dwTid       = GetWindowThreadProcessId(ped->hwnd, NULL);

    while (hwndParent && (dwTid == GetWindowThreadProcessId(hwndParent, NULL)))
    {
        RemoveWindowSubclass(hwndParent, Edit_BalloonTipParentSubclassProc, (UINT_PTR) ped->hwnd);
        hwndTopMost = hwndParent;
        hwndParent = GetAncestor(hwndParent, GA_PARENT);
    }

    return hwndTopMost;
}


//---------------------------------------------------------------------------//
LRESULT Edit_HideBalloonTipHandler(PED ped)
{
    if (ped->hwndBalloon)
    {
        HWND hwndParent;

        KillTimer(ped->hwnd, ID_EDITTIMER);

        SendMessage(ped->hwndBalloon, TTM_TRACKACTIVATE, FALSE, 0);
        DestroyWindow(ped->hwndBalloon);

        ped->hwndBalloon = NULL;

        hwndParent = Edit_BalloonTipRemoveSubclasses(ped);

        if (hwndParent && IsWindow(hwndParent))
        {
            InvalidateRect(hwndParent, NULL, TRUE);
            UpdateWindow(hwndParent);
        }

        if (hwndParent != ped->hwnd)
        {
            RedrawWindow(ped->hwnd, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
        }
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
__inline LRESULT Edit_ShowBalloonTipWrap(HWND hwnd, DWORD dwTitleId, DWORD dwMsgId, DWORD dwIconId)
{
    WCHAR szTitle[56];
    WCHAR szMsg[MAX_PATH];
    EDITBALLOONTIP ebt;

    LoadString(HINST_THISDLL, dwTitleId, szTitle, ARRAYSIZE(szTitle));
    LoadString(HINST_THISDLL, dwMsgId,   szMsg,   ARRAYSIZE(szMsg));

    ebt.cbStruct = sizeof(ebt);
    ebt.pszTitle = szTitle;
    ebt.pszText  = szMsg;
    ebt.ttiIcon  = dwIconId;

    return Edit_ShowBalloonTip(hwnd, &ebt);
}


//---------------------------------------------------------------------------//
LRESULT Edit_ShowBalloonTipHandler(PED ped, PEDITBALLOONTIP pebt)
{
    LRESULT lResult = FALSE;

    Edit_HideBalloonTipHandler(ped);

    if (sizeof(EDITBALLOONTIP) == pebt->cbStruct)
    {
        ped->hwndBalloon = CreateWindowEx(
                                (IS_BIDI_LOCALIZED_SYSTEM() ? WS_EX_LAYOUTRTL : 0), 
                                TOOLTIPS_CLASS, NULL,
                                WS_POPUP | TTS_NOPREFIX | TTS_BALLOON,
                                CW_USEDEFAULT, CW_USEDEFAULT,
                                CW_USEDEFAULT, CW_USEDEFAULT,
                                ped->hwnd, NULL, g_hinst,
                                NULL);

        if (NULL != ped->hwndBalloon)
        {
            TOOLINFO ti = {0};

            ti.cbSize = TTTOOLINFOW_V2_SIZE;
            ti.uFlags = TTF_IDISHWND | TTF_TRACK;
            ti.hwnd   = ped->hwnd;
            ti.uId    = (WPARAM)1;
            ti.lpszText = (LPWSTR)pebt->pszText;

            SendMessage(ped->hwndBalloon, TTM_ADDTOOL, 0, (LPARAM)&ti);
            SendMessage(ped->hwndBalloon, TTM_SETMAXTIPWIDTH, 0, 300);
            SendMessage(ped->hwndBalloon, TTM_SETTITLE, (WPARAM) pebt->ttiIcon, (LPARAM)pebt->pszTitle);

            Edit_TrackBalloonTip(ped);

            SendMessage(ped->hwndBalloon, TTM_TRACKACTIVATE, (WPARAM) TRUE, (LPARAM)&ti);

            SetFocus(ped->hwnd);

            Edit_BalloonTipSubclassParents(ped);

            //
            // set timeout to kill the tip
            //
            KillTimer(ped->hwnd, ID_EDITTIMER);
            SetTimer(ped->hwnd, ID_EDITTIMER, EDIT_TIPTIMEOUT, NULL);

            lResult = TRUE;
        }
    }

    return lResult;
}


//---------------------------------------------------------------------------//
BOOL Edit_ClientEdgePaint(PED ped, HRGN hRgnUpdate)
{
    HDC  hdc;
    BOOL bRet = FALSE;

    hdc = (hRgnUpdate != NULL) ? 
            GetDCEx(ped->hwnd, 
                    hRgnUpdate, 
                    DCX_USESTYLE | DCX_WINDOW | DCX_LOCKWINDOWUPDATE | DCX_INTERSECTRGN | DCX_NODELETERGN) :
            GetDCEx(ped->hwnd, 
                    NULL, 
                    DCX_USESTYLE | DCX_WINDOW | DCX_LOCKWINDOWUPDATE);

    if (hdc)
    {
        HBRUSH hbr;
        BOOL fDeleteBrush = FALSE;

        hbr = Edit_GetBrush(ped, hdc, &fDeleteBrush);

        if (hbr)
        {
            RECT rc;
            HRGN hrgn;
            INT  iStateId = Edit_GetStateId(ped);
            INT  cxBorder = 0, cyBorder = 0;

            if (SUCCEEDED(GetThemeInt(ped->hTheme, EP_EDITTEXT, iStateId, TMT_SIZINGBORDERWIDTH, &cxBorder)))
            {
                cyBorder = cxBorder;
            }
            else
            {
                cxBorder = g_cxBorder;
                cyBorder = g_cyBorder;
            }

            GetWindowRect(ped->hwnd, &rc);            

            //
            // Create an update region without the client edge
            // to pass to DefWindowProc
            //
            InflateRect(&rc, -g_cxEdge, -g_cyEdge);
            hrgn = CreateRectRgn(rc.left, rc.top, rc.right, rc.bottom);
            if (hRgnUpdate != NULL)
            {
                CombineRgn(hrgn, hRgnUpdate, hrgn, RGN_AND);
            }

            //
            // Zero-origin the rect
            //
            OffsetRect(&rc, -rc.left, -rc.top);

            //
            // clip our drawing to the non-client edge
            //
            OffsetRect(&rc, g_cxEdge, g_cyEdge);
            ExcludeClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
            InflateRect(&rc, g_cxEdge, g_cyEdge);

            DrawThemeBackground(ped->hTheme, hdc, EP_EDITTEXT, iStateId, &rc, 0);

            //
            // Fill with the control's brush first since the ThemeBackground
            // border may not be as thick as the client edge
            //
            if ((cxBorder < g_cxEdge) && (cyBorder < g_cyEdge))
            {
                InflateRect(&rc, cxBorder-g_cxEdge, cyBorder-g_cyEdge);
                FillRect(hdc, &rc, hbr);
            }

            DefWindowProc(ped->hwnd, WM_NCPAINT, (WPARAM)hrgn, 0);

            DeleteObject(hrgn);

            if (fDeleteBrush)
            {
                DeleteObject(hbr);
            }

            bRet = TRUE;
        }

        ReleaseDC(ped->hwnd, hdc);
    }

    return bRet;
}


//---------------------------------------------------------------------------//
//
// Edit_WndProc
//
// WndProc for all edit controls.
// Dispatches all messages to the appropriate handlers which are named
// as follows:
//     EditSL_ (single line) prefixes all single line edit control 
//     EditML_ (multi line) prefixes all multi- line edit controls
//     Edit_   (edit control) prefixes all common handlers
//
// The Edit_WndProc only handles messages common to both single and multi
// line edit controls. Messages which are handled differently between
// single and multi are sent to EditSL_WndProc or EditML_WndProc.
//
LRESULT Edit_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PED     ped;
    LRESULT lResult;

    //
    // Get the instance data for this edit control
    //
    ped = Edit_GetPtr(hwnd);
    if (!ped && uMsg != WM_NCCREATE)
    {
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    //
    // Dispatch the various messages we can receive
    //
    lResult = 1L;
    switch (uMsg) 
    {

    //
    // Messages which are handled the same way for both single and multi line
    // edit controls.
    //
    case WM_KEYDOWN:
        //
        // LPK handling of Ctrl/LShift, Ctrl/RShift
        //
        if (ped && ped->pLpkEditCallout && ped->fAllowRTL) 
        {
            //
            // Any keydown cancels a ctrl/shift reading order change
            //
            ped->fSwapRoOnUp = FALSE; 

            switch (wParam) 
            {
            case VK_SHIFT:

                if ((GetKeyState(VK_CONTROL) & 0x8000) && !(GetKeyState(VK_MENU) & 0x8000)) 
                {
                    //
                    // Left shift or right shift pressed while control held down
                    // Check that alt (VK_MENU) isn't down to avoid false firing 
                    // on AltGr which equals Ctrl+Alt.
                    //
                    if (MapVirtualKey((LONG)lParam>>16&0xff, 3) == VK_LSHIFT) 
                    {

                        //
                        // User wants left to right reading order
                        //
                        ped->fSwapRoOnUp = (ped->fRtoLReading) || (ped->format & ES_RIGHT);
                        ped->fLShift = TRUE;

                    } 
                    else 
                    {
                        //
                        // User wants right to left reading order
                        //
                        ped->fSwapRoOnUp = (!ped->fRtoLReading) || (ped->format & ES_RIGHT);
                        ped->fLShift = FALSE;

                    }
                }

                break;

            case VK_LEFT:

                if (ped->fRtoLReading) 
                {
                   wParam = VK_RIGHT;
                }

                break;

            case VK_RIGHT:

                if (ped->fRtoLReading) 
                {
                    wParam = VK_LEFT;
                }
                break;
            }
        }

        goto HandleEditMsg;

    case WM_KEYUP:

        if (ped && ped->pLpkEditCallout && ped->fAllowRTL && ped->fSwapRoOnUp) 
        {
            BOOL fReadingOrder;
            //
            // Complete reading order change detected earlier during keydown
            //

            ped->fSwapRoOnUp = FALSE;
            fReadingOrder = ped->fRtoLReading;

            //
            // Remove any overriding ES_CENTRE or ES_RIGHT format from dwStyle
            //
            SetWindowLong(hwnd, GWL_STYLE, (GET_STYLE(ped) & ~ES_FMTMASK));

            if (ped->fLShift) 
            {
                // 
                // Set Left to Right reading order and right scrollbar in EX_STYLE
                //
                SetWindowLong(hwnd, GWL_EXSTYLE, (GET_EXSTYLE(ped) & ~(WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR)));

                //
                // Edit control is LTR now, then notify the parent.
                //
                Edit_NotifyParent(ped, EN_ALIGN_LTR_EC);

                //
                // ? Select a keyboard layout appropriate to LTR operation
                //
            } 
            else 
            {
                //
                // Set Right to Left reading order, right alignment and left scrollbar
                //
                SetWindowLong(hwnd, 
                              GWL_EXSTYLE, 
                              GET_EXSTYLE(ped) | WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR);

                //
                // Edit control is RTL now, then notify the parent.
                //
                Edit_NotifyParent(ped, EN_ALIGN_RTL_EC);

                //
                // ? Select a keyboard layout appropriate to RTL operation
                //
            }

            //
            // If reading order didn't change, so we are sure the alignment 
            // changed and the edit window didn't invalidate yet.
            //

            if (fReadingOrder == (BOOL) ped->fRtoLReading) 
            {
              Edit_InvalidateClient(ped, TRUE);
            }
        }

        goto HandleEditMsg;

    case WM_INPUTLANGCHANGE:

        if (ped) 
        {
            //
            // EC_INSERT_COMPOSITION_CHAR : WM_INPUTLANGCHANGE - call Edit_InitInsert()
            //
            HKL hkl = GetKeyboardLayout(0);

            Edit_InitInsert(ped, hkl);

            if (ped->fInReconversion) 
            {
                Edit_InOutReconversionMode(ped, FALSE);
            }

            //
            // Font and caret position might be changed while
            // another keyboard layout is active. Set those
            // if the edit control has the focus.
            //
            if (ped->fFocus && ImmIsIME(hkl)) 
            {
                POINT pt;

                Edit_SetCompositionFont(ped);
                GetCaretPos(&pt);
                Edit_ImmSetCompositionWindow(ped, pt.x, pt.y);
            }
        }

        goto HandleEditMsg;

    case WM_COPY:

        //
        // wParam - not used
        // lParam - not used
        //
        lResult = (LONG)Edit_Copy(ped);

        break;

    case WM_CUT:

        //
        // wParam -- not used
        // lParam -- not used
        //
        Edit_CutText(ped);
        lResult = 0;

        break;

    case WM_CLEAR:

        //
        // wParam - not used
        // lParam - not used
        //
        Edit_ClearText(ped);
        lResult = 0;

        break;

    case WM_ENABLE:

        //
        // wParam - nonzero if window is enabled else disable window if 0.
        // lParam - not used
        //
        ped->fDisabled = !((BOOL)wParam);
        CCInvalidateFrame(hwnd);
        Edit_InvalidateClient(ped, TRUE);
        lResult = (LONG)ped->fDisabled;

        break;

    case WM_SYSCHAR:

        //
        // wParam - key value
        // lParam - not used
        //

        //
        // If this is a WM_SYSCHAR message generated by the UNDO
        // keystroke we want to EAT IT
        //
        if ((lParam & SYS_ALTERNATE) && 
            ((WORD)wParam == VK_BACK))
        {
            lResult = TRUE;
        }
        else 
        {
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
        }

        break;

    case EM_GETLINECOUNT:

        //
        // wParam - not used
        // lParam - not used
        //
        lResult = (LONG)ped->cLines;

        break;

    case EM_GETMODIFY:

        //
        // wParam - not used
        // lParam - not used
        //

        //
        // Gets the state of the modify flag for this edit control.
        //
        lResult = (LONG)ped->fDirty;

        break;

    case EM_SETMODIFY:

        //
        // wParam - specifies the new value for the modify flag
        // lParam - not used
        //

        //
        // Sets the state of the modify flag for 
        // this edit control.
        //
        ped->fDirty = (wParam != 0);

        break;

    case EM_GETRECT:

        //
        // wParam - not used
        // lParam - pointer to a RECT data structure that gets the dimensions.
        //

        //
        // Copies the rcFmt rect to *lpRect.
        //
        CopyRect((LPRECT)lParam, (LPRECT)&ped->rcFmt);
        lResult = (LONG)TRUE;

        break;

    case WM_GETFONT:

        //
        // wParam - not used
        // lParam - not used
        //
        lResult = (LRESULT)ped->hFont;

        break;

    case WM_SETFONT:

        //
        // wParam - handle to the font
        // lParam - redraw if true else don't
        //
        Edit_SetFont(ped, (HANDLE)wParam, (BOOL)LOWORD(lParam));

        break;

    case WM_GETTEXT:

        //
        // wParam - max number of _bytes_ (not characters) to copy
        // lParam - buffer to copy text to. Text is 0 terminated.
        //
        lResult = (LRESULT)Edit_GetTextHandler(ped, (ICH)wParam, (LPSTR)lParam, TRUE);
        break;

    case WM_SETTEXT:

        //
        // wParam - not used
        // lParam - LPSTR, null-terminated, with new text.
        //
        lResult = (LRESULT)Edit_SetEditText(ped, (LPSTR)lParam);
        break;

    case WM_GETTEXTLENGTH:

        //
        // Return count of CHARs!!!
        //
        lResult = (LONG)ped->cch;

        break;

    case WM_DESTROY:
        //
        // Make sure we unsubclass for the balloon tip, if appropriate
        //
        lResult = Edit_HideBalloonTipHandler(ped);
        break;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:

        //
        // wParam - not used
        // lParam - not used
        //
        Edit_NcDestroyHandler(hwnd, ped);
        lResult = 0;

        break;

    case WM_RBUTTONDOWN:

        //
        // Most apps (i.e. everyone but Quicken) don't pass on the rbutton
        // messages when they do something with 'em inside of subclassed
        // edit fields.  As such, we keep track of whether we saw the
        // down before the up.  If we don't see the up, then DefWindowProc
        // won't generate the context menu message, so no big deal.  If
        // we didn't see the down, then don't let WM_CONTEXTMENU do
        // anything.
        //
        // We also might want to not generate WM_CONTEXTMENUs for old
        // apps when the mouse is captured.
        //
        ped->fSawRButtonDown = TRUE;

        goto HandleEditMsg;

    case WM_RBUTTONUP:
        if (ped->fSawRButtonDown) 
        {
            ped->fSawRButtonDown = FALSE;

            if (!ped->fInReconversion) 
            {
                goto HandleEditMsg;
            }
        }

        //
        // Don't pass this on to DWP so WM_CONTEXTMENU isn't generated.
        //
        lResult = 0;

        break;

    case WM_CONTEXTMENU: 
    {
        POINT pt;
        INT   nHit = (INT)DefWindowProc(hwnd, WM_NCHITTEST, 0, lParam);

        if ((nHit == HTVSCROLL) || (nHit == HTHSCROLL)) 
        {
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
        else
        {
            POINTSTOPOINT(pt, lParam);

            if (!TESTFLAG(GET_STATE2(ped), WS_S2_OLDUI) && Edit_IsAncestorActive(hwnd))
            {
                Edit_Menu(hwnd, ped, &pt);
            }

            lResult = 0;
        }

        break;
    }

    case EM_CANUNDO:

        //
        // wParam - not used
        // lParam - not used
        //
        lResult = (LONG)(ped->undoType != UNDO_NONE);
        break;

    case EM_EMPTYUNDOBUFFER:

        //
        // wParam - not used
        // lParam - not used
        //
        Edit_EmptyUndo(Pundo(ped));

        break;

    case EM_GETMARGINS:

        //
        // wParam - not used
        // lParam - not used
        //
        lResult = MAKELONG(ped->wLeftMargin, ped->wRightMargin);

        break;

    case EM_SETMARGINS:

        //
        // wParam - EC_ margin flags
        // lParam - LOWORD is left, HIWORD is right margin
        //
        Edit_SetMargin(ped, (UINT)wParam, (DWORD)lParam, TRUE);
        lResult = 0;

        break;

    case EM_GETSEL:

        //
        // Gets the selection range for the given edit control. The
        // starting position is in the low order word. It contains the position
        // of the first nonselected character after the end of the selection in
        // the high order word.
        //
        if ((PDWORD)wParam != NULL) 
        {
           *((PDWORD)wParam) = ped->ichMinSel;
        }

        if ((PDWORD)lParam != NULL) 
        {
           *((PDWORD)lParam) = ped->ichMaxSel;
        }

        lResult = MAKELONG(ped->ichMinSel,ped->ichMaxSel);

        break;

    case EM_GETLIMITTEXT:

        //
        // wParam - not used
        // lParam - not used
        //
        lResult = ped->cchTextMax;

        break;

    case EM_SETLIMITTEXT:
    
        //
        // wParam - max number of CHARACTERS that can be entered
        // lParam - not used
        //

        //
        // Specifies the maximum number of characters of text the user may
        // enter. If maxLength is 0, we may enter MAXINT number of CHARACTERS.
        //
        if (ped->fSingle) 
        {
            if (wParam) 
            {
                wParam = min(0x7FFFFFFEu, wParam);
            } 
            else 
            {
                wParam = 0x7FFFFFFEu;
            }
        }

        if (wParam) 
        {
            ped->cchTextMax = (ICH)wParam;
        } 
        else 
        {
            ped->cchTextMax = 0xFFFFFFFFu;
        }

        break;

    case EM_POSFROMCHAR:

        //
        // Validate that char index is within text range
        //

        if (wParam >= ped->cch) 
        {
            lResult = -1L;
        }
        else
        {
            goto HandleEditMsg;
        }

        break;

    case EM_CHARFROMPOS: 
    {
        //
        // Validate that point is within client of edit field
        //
        RECT    rc;
        POINT   pt;

        POINTSTOPOINT(pt, lParam);
        GetClientRect(hwnd, &rc);
        if (!PtInRect(&rc, pt)) 
        {
            lResult = -1L;
        }
        else
        {
            goto HandleEditMsg;
        }

        break;
    }

    case EM_SETPASSWORDCHAR:

        //
        // wParam - sepecifies the new char to display instead of the
        // real text. if null, display the real text.
        //
        Edit_SetPasswordCharHandler(ped, (UINT)wParam);

        break;

    case EM_GETPASSWORDCHAR:

        lResult = (DWORD)ped->charPasswordChar;

        break;

    case EM_SETREADONLY:

        //
        // wParam - state to set read only flag to
        //
        ped->fReadOnly = (wParam != 0);
        if (wParam)
        {
            SetWindowState(hwnd, ES_READONLY);
        }
        else
        {
            ClearWindowState(hwnd, ES_READONLY);
        }

        lResult = 1L;

        if ( g_fIMMEnabled )
        {
            Edit_EnableDisableIME( ped );
        }

        //
        // We need to redraw the edit field so that the background color
        // changes.  Read-only edits are drawn in CTLCOLOR_STATIC while
        // others are drawn with CTLCOLOR_EDIT.
        //
        Edit_InvalidateClient(ped, TRUE);

        break;

    case EM_SETWORDBREAKPROC:

        // wParam - not used
        // lParam - PROC address of an app supplied call back function
        ped->lpfnNextWord = (EDITWORDBREAKPROCA)lParam;

        break;

    case EM_GETWORDBREAKPROC:

        lResult = (LRESULT)ped->lpfnNextWord;

        break;

    case EM_GETIMESTATUS:

        //
        // wParam == sub command
        //
        if (wParam == EMSIS_COMPOSITIONSTRING)
        {
            lResult = ped->wImeStatus;
        }

        break;

    case EM_SETIMESTATUS:

        //
        // wParam == sub command
        //
        if (wParam == EMSIS_COMPOSITIONSTRING) 
        {
            ped->wImeStatus = (WORD)lParam;
        }

        break;

    case WM_NCCREATE:

        ped = (PED)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(ED));
        if (ped)
        {
            //
            // Success... store the instance pointer.
            //
            TraceMsg(TF_STANDARD, "EDIT: Setting edit instance pointer.");
            Edit_SetPtr(hwnd, ped);

            lResult = Edit_NcCreate(ped, hwnd, (LPCREATESTRUCT)lParam);
        }
        else
        {
            //
            // Failed... return FALSE.
            //
            // From a WM_NCCREATE msg, this will cause the
            // CreateWindow call to fail.
            //
            TraceMsg(TF_STANDARD, "EDIT: Unable to allocate edit instance structure.");
            lResult = FALSE;
        }
        break;

    case WM_LBUTTONDOWN:

        //
        // B#3623
        // Don't set focus to edit field if it is within an inactive,
        // captioned child.
        // We might want to version switch this...  I haven't found
        // any problems by not, but you never know...
        //
        if (Edit_IsAncestorActive(hwnd)) 
        {
            //
            // Reconversion support: quit reconversion if left button is clicked.
            // Otherwise, if the current KL is Korean, finailize the composition string.
            //
            if (ped->fInReconversion || ped->fKorea) 
            {
                BOOLEAN fReconversion = (BOOLEAN)ped->fInReconversion;
                DWORD   dwIndex = fReconversion ? CPS_CANCEL : CPS_COMPLETE;
                HIMC hImc;

                ped->fReplaceCompChr = FALSE;

                hImc = ImmGetContext(ped->hwnd);
                if (hImc) 
                {
                    ImmNotifyIME(hImc, NI_COMPOSITIONSTR, dwIndex, 0);
                    ImmReleaseContext(ped->hwnd, hImc);
                }

                if (fReconversion) 
                {
                    Edit_InOutReconversionMode(ped, FALSE);
                }

                Edit_SetCaretHandler(ped);
            }

            goto HandleEditMsg;
        }

        break;

    case WM_MOUSELEAVE:

        if (ped->hTheme && ped->fHot)
        {
            ped->fHot = FALSE;
            SendMessage(ped->hwnd, WM_NCPAINT, 1, 0);
        }
        break;

    case WM_MOUSEMOVE:

        //
        // If the hot bit is not already set
        // and we are themed
        //
        if (ped->hTheme && !ped->fHot)
        {
            TRACKMOUSEEVENT tme;

            //
            // Set the hot bit and request that
            // we be notified when the mouse leaves
            //
            ped->fHot = TRUE;

            tme.cbSize      = sizeof(tme);
            tme.dwFlags     = TME_LEAVE;
            tme.hwndTrack   = ped->hwnd;
            tme.dwHoverTime = 0;

            TrackMouseEvent(&tme);
            SendMessage(ped->hwnd, WM_NCPAINT, 1, 0);
        }

        //
        // We only care about mouse messages when mouse is down.
        //
        if (ped->fMouseDown)
        {
            goto HandleEditMsg;
        }

        break;

    case WM_NCPAINT:

        //
        // Draw our own client edge border when themed
        //
        if (ped->hTheme && TESTFLAG(GET_EXSTYLE(ped), WS_EX_CLIENTEDGE))
        {
            if (Edit_ClientEdgePaint(ped, ((wParam != 1) ? (HRGN)wParam : NULL)))
            {
                break;
            }
        }

        goto HandleEditMsg;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        break;

    case WM_IME_SETCONTEXT:

        //
        // If ped->fInsertCompChr is TRUE, that means we will do
        // all the composition character drawing by ourself.
        //
        if (ped->fInsertCompChr ) 
        {
            lParam &= ~ISC_SHOWUICOMPOSITIONWINDOW;
        }

        if (wParam) 
        {
            PINPUTCONTEXT pInputContext;
            HIMC hImc;

            hImc = ImmGetContext(hwnd);
            pInputContext = ImmLockIMC(hImc);

            if (pInputContext != NULL) 
            {
                pInputContext->fdw31Compat &= ~F31COMPAT_ECSETCFS;
                ImmUnlockIMC( hImc );
            }

#if 0   // PORTPORT: Expose GetClientInfo()
            if (GetClientInfo()->CI_flags & CI_16BIT) 
            {
                ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0L);
            }
#endif

            ImmReleaseContext( hwnd, hImc );
        }

        lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);

        break;

    case WM_IME_ENDCOMPOSITION:

        Edit_InOutReconversionMode(ped, FALSE);

        if (ped->fReplaceCompChr) 
        {
            ICH ich;
            HDC hdc;

            //
            // we have a DBCS character to be replaced.
            // let's delete it before inserting the new one.
            //
            ich = (ped->fAnsi) ? 2 : 1;
            ped->fReplaceCompChr = FALSE;
            ped->ichMaxSel = min(ped->ichCaret + ich, ped->cch);
            ped->ichMinSel = ped->ichCaret;
            if (ped->fSingle) 
            {
                if (Edit_DeleteText( ped ) > 0) 
                {
                    //
                    // Update the display
                    //
                    Edit_NotifyParent(ped, EN_UPDATE);
                    hdc = Edit_GetDC(ped, FALSE);
                    EditSL_DrawText(ped, hdc, 0);
                    Edit_ReleaseDC(ped, hdc, FALSE);

                    //
                    // Tell parent our text contents changed.
                    //
                    Edit_NotifyParent(ped, EN_CHANGE);
                }
            }
            else 
            {
                EditML_DeleteText(ped);
            }

            Edit_SetCaretHandler( ped );
        }

        lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);

        break;

    case WM_IME_STARTCOMPOSITION:
        if ( ped->fInsertCompChr ) 
        {
            //
            // BUG BUG
            //
            // sending WM_IME_xxxCOMPOSITION will let
            // IME draw composition window. IME should
            // not do that since we cleared
            // ISC_SHOWUICOMPOSITIONWINDOW bit when
            // we got WM_IME_SETCONTEXT message.
            //
            // Korean IME should be fixed in the future.
            //
            break;

        } 
        else 
        {
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
        }

        break;

    case WM_IME_COMPOSITION:

        //
        // simple composition character support for FE IME.
        //
        lResult = Edit_ImeComposition(ped, wParam, lParam);

        break;

    case WM_IME_NOTIFY:

        if (ped->fInReconversion && (wParam == IMN_GUIDELINE))
        {
            HIMC hImc = ImmGetContext(hwnd);

            if ((hImc != NULL_HIMC) && (ImmGetGuideLine(hImc, GGL_LEVEL, NULL, 0) >= GL_LEVEL_WARNING))
            {
                // #266916 Restore the cursor if conversion failed. Conversion can fail
                //         if you try converting 100+ chars at once. 
                Edit_InOutReconversionMode(ped, FALSE);
            }
        }

        lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);

        break;

    case WM_KILLFOCUS:

        //
        // remove any tips
        //
        if (ped->hwndBalloon)
        {
            BOOL fClickedTip = (ped->hwndBalloon == (HWND)wParam) ? TRUE : FALSE;

            Edit_HideBalloonTip(ped->hwnd);

            if (fClickedTip)
            {
                //
                // Don't remove focus from the edit because they
                // clicked on the tip.
                //
                SetFocus(hwnd);
                break;
            }
        }

        //
        // when focus is removed from the window,
        // composition character should be finalized
        //
        if (ped && g_fIMMEnabled && ImmIsIME(GetKeyboardLayout(0))) 
        {
            HIMC hImc = ImmGetContext(hwnd);

            if (hImc != NULL_HIMC) 
            {
                if (ped->fReplaceCompChr || (ped->wImeStatus & EIMES_COMPLETECOMPSTRKILLFOCUS)) 
                {
                    //
                    // If the composition string to be determined upon kill focus,
                    // do it now.
                    //
                    ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
                } 
                else if (ped->fInReconversion) 
                {
                    //
                    // If the composition string it not to be determined,
                    // and if we're in reconversion mode, cancel reconversion now.
                    //
                    ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
                }

                //
                // Get out from reconversion mode
                //
                if (ped->fInReconversion) 
                {
                    Edit_InOutReconversionMode(ped, FALSE);
                }

                ImmReleaseContext(hwnd, hImc);
            }
        }

        goto HandleEditMsg;

        break;

    case WM_SETFOCUS:
        if (ped && !ped->fFocus) 
        {
            HKL hkl = GetKeyboardLayout(0);

            if (g_fIMMEnabled && ImmIsIME(hkl)) 
            {
                HIMC hImc;

                hImc = ImmGetContext(hwnd);
                if (hImc) 
                {
                    LPINPUTCONTEXT lpImc;

                    if (ped->wImeStatus & EIMES_CANCELCOMPSTRINFOCUS) 
                    {
                        //
                        // cancel when in-focus
                        //
                        ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
                    }

                    Edit_SetCompositionFont(ped);

                    if ((lpImc = ImmLockIMC(hImc)) != NULL) 
                    {

                        //
                        // We presume the CompForm will reset to CFS_DEFAULT,
                        // when the edit control loses Focus.
                        // IMEWndProc32 will call ImmSetCompositionWindow with
                        // CFS_DEFAULT, when it receive WM_IME_SETCONTEXT.
                        //
                        lpImc->fdw31Compat |= F31COMPAT_ECSETCFS;

                        ImmUnlockIMC(hImc);
                    }
                    ImmReleaseContext(hwnd, hImc);
                }

                //
                // force to set IME composition window when
                // first getting focus.
                //
                ped->ptScreenBounding.x = -1;
                ped->ptScreenBounding.y = -1;
            }

            Edit_InitInsert(ped, hkl);
        }

        goto HandleEditMsg;

        break;

    case WM_IME_REQUEST:
        //
        // simple ImeRequest Handler
        //

        lResult = Edit_RequestHandler(ped, wParam, lParam);

        break;
        
    case WM_CREATE:

        if (g_fIMMEnabled && ped)
        {
            Edit_EnableDisableIME(ped);
        }

        goto HandleEditMsg;

        break;

    case WM_GETOBJECT:

        if(lParam == OBJID_QUERYCLASSNAMEIDX)
        {
            lResult = MSAA_CLASSNAMEIDX_EDIT;
        }
        else
        {
            lResult = FALSE;
        }

        break;

    case WM_THEMECHANGED:

        if ( ped->hTheme )
        {
            CloseThemeData(ped->hTheme);
        }

        ped->hTheme = OpenThemeData(ped->hwnd, L"Edit");

        if ( ped->hFontSave )
        {
            Edit_SetFont(ped, ped->hFontSave, FALSE);
        }
        InvalidateRect(ped->hwnd, NULL, TRUE);

        lResult = TRUE;

        break;

    case EM_SHOWBALLOONTIP: 

        lResult = Edit_ShowBalloonTipHandler(ped, (PEDITBALLOONTIP) lParam);
        break;

    case EM_HIDEBALLOONTIP: 
        
        lResult = Edit_HideBalloonTipHandler(ped); 
        break;

    case WM_TIMER:

        if (wParam == ID_EDITTIMER)
        {
            KillTimer(ped->hwnd, ID_EDITTIMER);
            lResult = Edit_HideBalloonTip(ped->hwnd);
        }

        break;

    default:

HandleEditMsg:
        if (ped != NULL) 
        {
            if (ped->fSingle) 
            {
                lResult = EditSL_WndProc(ped, uMsg, wParam, lParam);
            } 
            else 
            {
                lResult = EditML_WndProc(ped, uMsg, wParam, lParam);
            }
        }
    }

    return lResult;
}


//---------------------------------------------------------------------------//
//
// Edit_FindXORblks
// 
// This finds the XOR of lpOldBlk and lpNewBlk and return s resulting blocks
// through the lpBlk1 and lpBlk2; This could result in a single block or
// at the maximum two blocks;
// If a resulting block is empty, then it's StPos field has -1.
//
// NOTE:
// When called from MultiLine edit control, StPos and EndPos fields of
// these blocks have the Starting line and Ending line of the block;
// When called from SingleLine edit control, StPos and EndPos fields
// of these blocks have the character index of starting position and
// ending position of the block.
//
VOID Edit_FindXORblks(LPSELBLOCK lpOldBlk, LPSELBLOCK lpNewBlk, LPSELBLOCK lpBlk1, LPSELBLOCK lpBlk2)
{
    if (lpOldBlk->StPos >= lpNewBlk->StPos) 
    {
        lpBlk1->StPos = lpNewBlk->StPos;
        lpBlk1->EndPos = min(lpOldBlk->StPos, lpNewBlk->EndPos);
    } 
    else 
    {
        lpBlk1->StPos = lpOldBlk->StPos;
        lpBlk1->EndPos = min(lpNewBlk->StPos, lpOldBlk->EndPos);
    }

    if (lpOldBlk->EndPos <= lpNewBlk->EndPos) 
    {
        lpBlk2->StPos = max(lpOldBlk->EndPos, lpNewBlk->StPos);
        lpBlk2->EndPos = lpNewBlk->EndPos;
    } 
    else 
    {
        lpBlk2->StPos = max(lpNewBlk->EndPos, lpOldBlk->StPos);
        lpBlk2->EndPos = lpOldBlk->EndPos;
    }
}


//---------------------------------------------------------------------------//
//
BOOL Edit_CalcChangeSelection(PED ped, ICH ichOldMinSel, ICH ichOldMaxSel, LPSELBLOCK OldBlk, LPSELBLOCK NewBlk)
{
    SELBLOCK Blk[2];
    int iBlkCount = 0;

    Blk[0].StPos = Blk[0].EndPos = Blk[1].StPos = Blk[1].EndPos = 0xFFFFFFFF;

    //
    // Check if the Old selection block existed
    //
    if (ichOldMinSel != ichOldMaxSel) 
    {
        //
        // Yes! Old block existed.
        //
        Blk[0].StPos = OldBlk->StPos;
        Blk[0].EndPos = OldBlk->EndPos;
        iBlkCount++;
    }

    //
    // Check if the new Selection block exists
    //
    if (ped->ichMinSel != ped->ichMaxSel) 
    {
        //
        // Yes! New block exists
        //
        Blk[1].StPos = NewBlk->StPos;
        Blk[1].EndPos = NewBlk->EndPos;
        iBlkCount++;
    }

    //
    // If both the blocks exist find the XOR of them
    //
    if (iBlkCount == 2) 
    {
        //
        // Check if both blocks start at the same character position
        //
        if (ichOldMinSel == ped->ichMinSel) 
        {
            //
            // Check if they end at the same character position
            //
            if (ichOldMaxSel == ped->ichMaxSel)
            {
                //
                // Nothing changes
                //
                return FALSE;
            }

            Blk[0].StPos = min(NewBlk -> EndPos, OldBlk -> EndPos);
            Blk[0].EndPos = max(NewBlk -> EndPos, OldBlk -> EndPos);
            Blk[1].StPos = 0xFFFFFFFF;

        } 
        else 
        {
            if (ichOldMaxSel == ped->ichMaxSel) 
            {
                Blk[0].StPos = min(NewBlk->StPos, OldBlk->StPos);
                Blk[0].EndPos = max(NewBlk->StPos, OldBlk->StPos);
                Blk[1].StPos = 0xFFFFFFFF;
            } 
            else 
            {
                Edit_FindXORblks(OldBlk, NewBlk, &Blk[0], &Blk[1]);
            }
        }
    }

    RtlCopyMemory(OldBlk, &Blk[0], sizeof(SELBLOCK));
    RtlCopyMemory(NewBlk, &Blk[1], sizeof(SELBLOCK));

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// Edit_GetControlBrush
// 
// Client side optimization replacement for NtUserGetControlBrush
// message is one of the WM_CTLCOLOR* messages.
//
HBRUSH Edit_GetControlBrush(PED ped, HDC hdc, LONG message)
{
    HWND hwndSend;

    hwndSend = (GET_STYLE(ped) & WS_POPUP) ? GetWindowOwner(ped->hwnd) : GetParent(ped->hwnd);
    if (!hwndSend)
    {
        hwndSend = ped->hwnd;
    }

    //
    // By using the correct A/W call we avoid a c/s transition
    // on this SendMessage().
    //
    return (HBRUSH)SendMessage(hwndSend, message, (WPARAM)hdc, (LPARAM)ped->hwnd);
}


//---------------------------------------------------------------------------//
//
// Edit_GetDBCSVector
//
// This function sets DBCS Vector for specified character set and sets
// ped->fDBCS flag if needed.
//
INT Edit_GetDBCSVector(PED ped, HDC hdc, BYTE CharSet)
{
    BOOL bDBCSCodePage = FALSE;
    static UINT fFontAssocStatus = 0xffff;

    //
    // if DEFAUT_CHARSET was passed, we will convert that to Shell charset..
    //
    if (CharSet == DEFAULT_CHARSET) 
    {
        CharSet = (BYTE)GetTextCharset(hdc);

        //
        // if CharSet is still DEFAULT_CHARSET, it means gdi has some problem..
        // then just return default.. we get charset from CP_ACP..
        //
        if (CharSet == DEFAULT_CHARSET) 
        {
            CharSet = (BYTE)GetACPCharSet();
        }
    }

    switch (CharSet) 
    {
    case SHIFTJIS_CHARSET:
    case HANGEUL_CHARSET:
    case CHINESEBIG5_CHARSET:
    case GB2312_CHARSET:

        bDBCSCodePage = TRUE;
        break;

    case ANSI_CHARSET:            // 0
    case SYMBOL_CHARSET:          // 2
    case OEM_CHARSET:             // 255

        if (fFontAssocStatus == 0xffff)
        {
            fFontAssocStatus = QueryFontAssocStatus();
        }

        if ((((CharSet + 2) & 0xf) & fFontAssocStatus)) 
        {
            bDBCSCodePage = TRUE;

            //
            // Bug 117558, etc.
            // Try to get a meaningful character set for associated font.
            //
            CharSet = (BYTE)GetACPCharSet();
        } 
        else 
        {
            bDBCSCodePage = FALSE;
        }

        break;

    default:
        bDBCSCodePage = FALSE;
    }

    if (bDBCSCodePage) 
    {
        CHARSETINFO CharsetInfo;
        DWORD CodePage;
        CPINFO CPInfo;
        INT lbIX;

        if (TranslateCharsetInfo((DWORD *)CharSet, &CharsetInfo, TCI_SRCCHARSET)) 
        {
            CodePage = CharsetInfo.ciACP;
        } 
        else 
        {
            CodePage = CP_ACP;
        }

        GetCPInfo(CodePage, &CPInfo);
        for (lbIX=0 ; CPInfo.LeadByte[lbIX] != 0 ; lbIX+=2) 
        {
            ped->DBCSVector[lbIX  ] = CPInfo.LeadByte[lbIX];
            ped->DBCSVector[lbIX+1] = CPInfo.LeadByte[lbIX+1];
        }
        ped->DBCSVector[lbIX  ] = 0x0;
        ped->DBCSVector[lbIX+1] = 0x0;
    }
    else 
    {
        ped->DBCSVector[0] = 0x0;
        ped->DBCSVector[1] = 0x0;
    }

    //
    // Final check: if the font supports DBCS glyphs
    //
    // If we've got a font with DBCS glyphs, let's mark PED so.
    // But since the font's primary charset is the one other than FE,
    // we can only support UNICODE Edit control.
    //
    //  a) GDI performs A/W conversion for ANSI apps based on the primary
    //     character set in hDC, so it will break anyway.
    //  b) ANSI applications are only supported on their native system locales:
    //     GetACPCharSet() is expected to return a FE code page.
    //  c) ANSI Edit control requires DBCSVector, which cannot be
    //     initialized without a FE code page.
    //
    if (!ped->fAnsi) 
    {
        FONTSIGNATURE fontSig;

        GetTextCharsetInfo(hdc, &fontSig, 0);
        if (fontSig.fsCsb[0] &FAREAST_CHARSET_BITS) 
        {
            //
            // Since this is UNICODE, we're not
            //
            bDBCSCodePage = TRUE;
        }
    }

    return bDBCSCodePage;
}


//---------------------------------------------------------------------------//
//
// Edit_AnsiNext
//
// This function advances string pointer for Edit Control use only.
//
LPSTR Edit_AnsiNext(PED ped, LPSTR lpCurrent)
{
    return lpCurrent+((Edit_IsDBCSLeadByte(ped,*lpCurrent)==TRUE) ? 2 : 1);
}


//---------------------------------------------------------------------------//
//
// Edit_AnsiPrev
// 
// This function decrements string pointer for Edit Control use only.
//
LPSTR Edit_AnsiPrev(PED ped, LPSTR lpBase, LPSTR lpStr )
{
    LPSTR lpCurrent = lpStr -1;

    if (!ped->fDBCS)
    {
        //
        // just return ( lpStr - 1 )
        //
        return lpCurrent;
    }

    if (lpBase >= lpCurrent)
    {
        return lpBase;
    }

    //
    // this check makes things faster
    //
    if (Edit_IsDBCSLeadByte(ped, *lpCurrent))
    {
        return (lpCurrent - 1);
    }

    do 
    {
        lpCurrent--;
        if (!Edit_IsDBCSLeadByte(ped, *lpCurrent)) 
        {
            lpCurrent++;
            break;
        }
    } 
    while(lpCurrent != lpBase);

    return lpStr - (((lpStr - lpCurrent) & 1) ? 1 : 2);
}


//---------------------------------------------------------------------------//
//
// Edit_NextIch
// 
// This function advances string pointer for Edit Control use only.
//
ICH Edit_NextIch( PED ped, LPSTR pStart, ICH ichCurrent )
{
    if (!ped->fDBCS || !ped->fAnsi) 
    {
        return (ichCurrent + 1);
    } 
    else 
    {

        ICH ichRet;
        LPSTR pText;

        if (pStart)
        {
            pText = pStart + ichCurrent;
        }
        else
        {
            pText = (LPSTR)Edit_Lock(ped) + ichCurrent;
        }

        ichRet = ichCurrent + ( Edit_IsDBCSLeadByte(ped, *pText) ? 2 : 1 );

        if (!pStart)
        {
            Edit_Unlock(ped);
        }

        return ichRet;
    }
}


//---------------------------------------------------------------------------//
//
// Edit_PrevIch
//
// This function decrements string pointer for Edit Control use only.
//
ICH Edit_PrevIch(PED ped, LPSTR pStart, ICH ichCurrent)
{
    LPSTR lpCurrent;
    LPSTR lpStr;
    LPSTR lpBase;

    if (!ped->fDBCS || !ped->fAnsi)
    {

        if (ichCurrent)
        {
            return (ichCurrent - 1);
        }
        else
        {
            return (ichCurrent);
        }
    }

    if (ichCurrent <= 1)
    {
        return 0;
    }

    if (pStart)
    {
        lpBase = pStart;
    }
    else
    {
        lpBase = Edit_Lock(ped);
    }


    lpStr = lpBase + ichCurrent;
    lpCurrent = lpStr - 1;
    if (Edit_IsDBCSLeadByte(ped,*lpCurrent)) 
    {
        if (!pStart)
        {
            Edit_Unlock(ped);
        }
        return (ichCurrent - 2);
    }

    do 
    {
        lpCurrent--;
        if (!Edit_IsDBCSLeadByte(ped, *lpCurrent)) 
        {
            lpCurrent++;
            break;
        }
    } 
    while(lpCurrent != lpBase);

    if (!pStart)
    {
        Edit_Unlock(ped);
    }

    return (ichCurrent - (((lpStr - lpCurrent) & 1) ? 1 : 2));

}


//---------------------------------------------------------------------------//
//
// Edit_IsDBCSLeadByte
// 
// IsDBCSLeadByte for Edit Control use only.
//
BOOL Edit_IsDBCSLeadByte(PED ped, BYTE cch)
{
    INT i;

    if (!ped->fDBCS || !ped->fAnsi)
    {
        return (FALSE);
    }

    for (i = 0; ped->DBCSVector[i]; i += 2) 
    {
        if ((ped->DBCSVector[i] <= cch) && (ped->DBCSVector[i+1] >= cch))
        {
            return (TRUE);
        }
    }

    return (FALSE);
}

//---------------------------------------------------------------------------//
//
// DbcsCombine
//
// Assemble two WM_CHAR messages to single DBCS character.
// If program detects first byte of DBCS character in WM_CHAR message,
// it calls this function to obtain second WM_CHAR message from queue.
// finally this routine assembles first byte and second byte into single
// DBCS character.
//
WORD DbcsCombine(HWND hwnd, WORD ch)
{
    MSG msg;
    INT i = 10; // loop counter to avoid the infinite loop

    while (!PeekMessageA(&msg, hwnd, WM_CHAR, WM_CHAR, PM_REMOVE)) 
    {
        if (--i == 0)
            return 0;
        Sleep(1);
    }

    return (WORD)ch | ((WORD)(msg.wParam) << 8);
}


//---------------------------------------------------------------------------//
//
// Edit_AdjustIch 
//
// This function adjusts a current pointer correctly. If a current
// pointer is lying between DBCS first byte and second byte, this
// function adjusts a current pointer to a first byte of DBCS position
// by decrement once.
//
ICH Edit_AdjustIch( PED ped, LPSTR lpstr, ICH ch )
{
    ICH newch = ch;

    if (!ped->fAnsi || !ped->fDBCS || newch == 0)
    {
        return ch;
    }

    if (!Edit_IsDBCSLeadByte(ped,lpstr[--newch]))
    {
        //
        // previous char is SBCS
        //
        return ch;
    }

    while (1) 
    {
        if (!Edit_IsDBCSLeadByte(ped,lpstr[newch])) 
        {
            newch++;
            break;
        }

        if (newch)
        {
            newch--;
        }
        else
        {
            break;
        }
    }

    return ((ch - newch) & 1) ? ch-1 : ch;
}


//---------------------------------------------------------------------------//
//
// Edit_AdjustIchNext
//
ICH Edit_AdjustIchNext(PED ped, LPSTR lpstr, ICH ch)
{
    ICH   ichNew = Edit_AdjustIch(ped,lpstr,ch);
    LPSTR lpnew  = lpstr + ichNew;

    //
    // if ch > ichNew then Edit_AdjustIch adjusted ich.
    //
    if (ch > ichNew)
    {
       lpnew = Edit_AnsiNext(ped, lpnew);
    }

    return (ICH)(lpnew-lpstr);
}


//---------------------------------------------------------------------------//
//
// Edit_UpdateFormat
//
// Computes ped->format and ped->fRtoLReading from dwStyle and dwExStyle.
// Refreshes the display if either are changed.
//
VOID Edit_UpdateFormat(PED ped, DWORD dwStyle, DWORD dwExStyle)
{
    UINT fNewRtoLReading;
    UINT uiNewFormat;

    //
    // Extract new format and reading order from style
    //
    fNewRtoLReading = dwExStyle & WS_EX_RTLREADING ? 1 : 0;
    uiNewFormat     = dwStyle & ES_FMTMASK;

    //
    // WS_EX_RIGHT is ignored unless dwStyle is ES_LEFT
    //
    if (uiNewFormat == ES_LEFT && dwExStyle & WS_EX_RIGHT) 
    {
        uiNewFormat = ES_RIGHT;
    }


    //
    // Internally ES_LEFT and ES_RIGHT are swapped for RtoLReading order
    // (Think of them as ES_LEADING and ES_TRAILING)
    //
    if (fNewRtoLReading) 
    {
        switch (uiNewFormat) 
        {
        case ES_LEFT:  
            uiNewFormat = ES_RIGHT; 
            break;

        case ES_RIGHT: 
            uiNewFormat = ES_LEFT;  
            break;
        }
    }


    //
    // Format change does not cause redisplay by itself
    //
    ped->format = uiNewFormat;

    //
    // Refresh display on change of reading order
    //
    if (fNewRtoLReading != ped->fRtoLReading) 
    {
        ped->fRtoLReading = fNewRtoLReading;

        if (ped->fWrap) 
        {
            //
            // Redo wordwrap
            //
            EditML_BuildchLines(ped, 0, 0, FALSE, NULL, NULL);
            EditML_UpdateiCaretLine(ped);
        } 
        else 
        {
            //
            // Refresh horizontal scrollbar display
            //
            EditML_Scroll(ped, FALSE, 0xffffffff, 0, TRUE);
        }

        Edit_InvalidateClient(ped, TRUE);
    }
}


//---------------------------------------------------------------------------//
//
// Edit_IsFullWidth
//
// Detects Far East FullWidth character.
//
BOOL Edit_IsFullWidth(DWORD dwCodePage,WCHAR wChar)
{
    INT index;
    INT cChars;

    static struct _FULLWIDTH_UNICODE 
    {
        WCHAR Start;
        WCHAR End;
    } FullWidthUnicodes[] = 
    {
       { 0x4E00, 0x9FFF }, // CJK_UNIFIED_IDOGRAPHS
       { 0x3040, 0x309F }, // HIRAGANA
       { 0x30A0, 0x30FF }, // KATAKANA
       { 0xAC00, 0xD7A3 }  // HANGUL
    };

    //
    // Early out for ASCII.
    //
    if (wChar < 0x0080) 
    {
        //
        // if the character < 0x0080, it should be a halfwidth character.
        //
        return FALSE;
    }

    //
    // Scan FullWdith definition table... most of FullWidth character is
    // defined here... this is more faster than call NLS API.
    //
    for (index = 0; index < ARRAYSIZE(FullWidthUnicodes); index++) 
    {
        if ((wChar >= FullWidthUnicodes[index].Start) &&
            (wChar <= FullWidthUnicodes[index].End)) 
        {
            return TRUE;
        }
    }

    //
    // if this Unicode character is mapped to Double-Byte character,
    // this is also FullWidth character..
    //
    cChars = WideCharToMultiByte((UINT)dwCodePage, 0, &wChar, 1, NULL, 0, NULL, NULL);

    return cChars > 1 ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\fontlink.h ===
#ifndef _FONTLINK_H_

#define SPACE_CHAR       0x20
#define EURODOLLAR_CHAR  0x20A0 // New Euro dollar symbol
#define CAPZCARON_CHAR   0x017D
#define SMALLZCARON_CHAR 0x017E

//
//  Unicode SubRange (USR) definitions
//
#define usrBasicLatin           0       // 0x20->0x7f
#define usrLatin1               1       // 0xa0->0xff
#define usrLatinXA              2       // 0x100->0x17f
#define usrLatinXB              3       // 0x180->0x24f
#define usrIPAExtensions        4       // 0x250->0x2af
#define usrSpacingModLetters    5       // 0x2b0->0x2ff
#define usrCombDiacritical      6       // 0x300->0x36f
#define usrBasicGreek           7       // 0x370->0x3cf
#define usrGreekSymbolsCop      8       // 0x3d0->0x3ff
#define usrCyrillic             9       // 0x400->0x4ff
#define usrArmenian             10      // 0x500->0x58f
#define usrBasicHebrew          11      // 0x5d0->0x5ff
#define usrHebrewXA             12      // 0x590->0x5cf
#define usrBasicArabic          13      // 0x600->0x652
#define usrArabicX              14      // 0x653->0x6ff
#define usrDevangari            15      // 0x900->0x97f
#define usrBengali              16      // 0x980->0x9ff
#define usrGurmukhi             17      // 0xa00->0xa7f
#define usrGujarati             18      // 0xa80->0xaff
#define usrOriya                19      // 0xb00->0xb7f
#define usrTamil                20      // 0x0B80->0x0BFF
#define usrTelugu               21      // 0x0C00->0x0C7F
#define usrKannada              22      // 0x0C80->0x0CFF
#define usrMalayalam            23      // 0x0D00->0x0D7F
#define usrThai                 24      // 0x0E00->0x0E7F
#define usrLao                  25      // 0x0E80->0x0EFF
#define usrBasicGeorgian        26      // 0x10D0->0x10FF
#define usrGeorgianExtended     27      // 0x10A0->0x10CF
#define usrHangulJamo           28      // 0x1100->0x11FF
#define usrLatinExtendedAdd     29      // 0x1E00->0x1EFF
#define usrGreekExtended        30      // 0x1F00->0x1FFF
#define usrGeneralPunct         31      // 0x2000->0x206F
#define usrSuperAndSubscript    32      // 0x2070->0x209F
#define usrCurrencySymbols      33      // 0x20A0->0x20CF
#define usrCombDiacriticsS      34      // 0x20D0->0x20FF   
#define usrLetterlikeSymbols    35      // 0x2100->0x214F   
#define usrNumberForms          36      // 0x2150->0x218F   
#define usrArrows               37      // 0x2190->0x21FF   
#define usrMathematicalOps      38      // 0x2200->0x22FF   
#define usrMiscTechnical        39      // 0x2300->0x23FF   
#define usrControlPictures      40      // 0x2400->0x243F   
#define usrOpticalCharRecog     41      // 0x2440->0x245F   
#define usrEnclosedAlphanum     42      // 0x2460->0x24FF   
#define usrBoxDrawing           43      // 0x2500->0x257F   
#define usrBlockElements        44      // 0x2580->0x259F   
#define usrGeometricShapes      45      // 0x25A0->0x25FF   
#define usrMiscDingbats         46      // 0x2600->0x26FF   
#define usrDingbats             47      // 0x2700->0x27BF   
#define usrCJKSymAndPunct       48      // 0x3000->0x303F   
#define usrHiragana             49      // 0x3040->0x309F   
#define usrKatakana             50      // 0x30A0->0x30FF   
#define usrBopomofo             51      // 0x3100->0x312F   
#define usrHangulCompatJamo     52      // 0x3130->0x318F   
#define usrCJKMisc              53      // 0x3190->0x319F   
#define usrEnclosedCJKLtMnth    54      // 0x3200->0x32FF   
#define usrCJKCompatibility     55      // 0x3300->0x33FF   
#define usrHangul               56      // 0xac00->0xd7a3
#define usrReserved1            57
#define usrReserved2            58
#define usrCJKUnifiedIdeo       59      // 0x4E00->0x9FFF   
#define usrPrivateUseArea       60      // 0xE000->0xF8FF   
#define usrCJKCompatibilityIdeographs   61      // 0xF900->0xFAFF   
#define usrAlphaPresentationForms       62      // 0xFB00->0xFB4F   
#define usrArabicPresentationFormsA     63      // 0xFB50->0xFDFF   
#define usrCombiningHalfMarks           64      // 0xFE20->0xFE2F   
#define usrCJKCompatForms               65      // 0xFE30->0xFE4F   
#define usrSmallFormVariants            66      // 0xFE50->0xFE6F   
#define usrArabicPresentationFormsB     67      // 0xFE70->0xFEFE   
#define usrHFWidthForms                 68      // 0xFF00->0xFFEF   
#define usrSpecials                     69      // 0xFFF0->0xFFFD   
#define usrMax                          70

#define FBetween(a, b, c)  (((unsigned)((a) - (b))) <= (c) - (b))

#endif  // _FONTLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\editrare.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "edit.h"


//---------------------------------------------------------------------------//
#define WS_EX_EDGEMASK (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)


#define GetCharABCWidthsAorW    ((ped)->fAnsi ? GetCharABCWidthsA : GetCharABCWidthsW)
#define GetCharWidthAorW        ((ped)->fAnsi ? GetCharWidthA : GetCharWidthW)


//---------------------------------------------------------------------------//
INT Edit_GetStateId(PED ped)
{
    INT iStateId;

    if (ped->fDisabled)
    {
        iStateId = ETS_DISABLED;
    }
    else if (ped->fReadOnly)
    {
        iStateId = ETS_READONLY;
    }
    else if (ped->fFocus)
    {
        iStateId = ETS_FOCUSED;
    }
    else if (ped->fHot)
    {
        iStateId = ETS_HOT;
    }
    else
    {
        iStateId = ETS_NORMAL;
    }

    return iStateId;
}


//---------------------------------------------------------------------------//
VOID Edit_SetMargin(PED ped, UINT  wFlags, long lMarginValues, BOOL fRedraw)
{
    BOOL fUseFontInfo = FALSE;
    UINT wValue, wOldLeftMargin, wOldRightMargin;


    if (wFlags & EC_LEFTMARGIN)
    {
        //
        // Set the left margin
        //
        if ((int) (wValue = (int)(short)LOWORD(lMarginValues)) < 0) 
        {
            fUseFontInfo = TRUE;
            wValue = min((ped->aveCharWidth / 2), (int)ped->wMaxNegA);
        }

        ped->rcFmt.left += wValue - ped->wLeftMargin;
        wOldLeftMargin = ped->wLeftMargin;
        ped->wLeftMargin = wValue;
    }

    if (wFlags & EC_RIGHTMARGIN)
    {
        //
        // Set the Right margin
        //
        if ((int) (wValue = (int)(short)HIWORD(lMarginValues)) < 0) 
        {
            fUseFontInfo = TRUE;
            wValue = min((ped->aveCharWidth / 2), (int)ped->wMaxNegC);
        }

        ped->rcFmt.right -= wValue - ped->wRightMargin;
        wOldRightMargin = ped->wRightMargin;
        ped->wRightMargin = wValue;
    }

    if (fUseFontInfo) 
    {
        if (ped->rcFmt.right - ped->rcFmt.left < 2 * ped->aveCharWidth) 
        {
            TraceMsg(TF_STANDARD, "EDIT: Edit_SetMargin: rcFmt is too narrow for EC_USEFONTINFO");

            if (wFlags & EC_LEFTMARGIN)
            {
                //
                // Reset the left margin
                //
                ped->rcFmt.left += wOldLeftMargin - ped->wLeftMargin;
                ped->wLeftMargin = wOldLeftMargin;
            }

            if (wFlags & EC_RIGHTMARGIN)
            {
                //
                // Reset the Right margin
                //
                ped->rcFmt.right -= wOldRightMargin - ped->wRightMargin;
                ped->wRightMargin = wOldRightMargin;
            }

            return;
        }
    }

    if (fRedraw) 
    {
        Edit_InvalidateClient(ped, TRUE);
    }
}


//---------------------------------------------------------------------------//
VOID Edit_CalcMarginForDBCSFont(PED ped, BOOL fRedraw)
{
    if (ped->fTrueType)
    {
        if (!ped->fSingle) 
        {
            //
            // wMaxNegA came from ABC CharWidth.
            //
            if (ped->wMaxNegA != 0) 
            {
                Edit_SetMargin(ped, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                        MAKELONG(EC_USEFONTINFO, EC_USEFONTINFO),fRedraw);
            }
        } 
        else 
        {
            int    iMaxNegA = 0, iMaxNegC = 0;
            int    i;
            PVOID  lpBuffer;
            LPABC  lpABCBuff;
            ABC    ABCInfo;
            HFONT  hOldFont;
            HDC    hdc = GetDC(ped->hwnd);

            if (!ped->hFont || !(hOldFont = SelectFont(hdc, ped->hFont))) 
            {
                ReleaseDC(ped->hwnd, hdc);
                return;
            }

            if (lpBuffer = UserLocalAlloc(0,sizeof(ABC) * 256)) 
            {
                lpABCBuff = lpBuffer;
                GetCharABCWidthsAorW(hdc, 0, 255, lpABCBuff);
            } 
            else 
            {
                lpABCBuff = &ABCInfo;
                GetCharABCWidthsAorW(hdc, 0, 0, lpABCBuff);
            }

            i = 0;
            while (TRUE) 
            {
                iMaxNegA = min(iMaxNegA, lpABCBuff->abcA);
                iMaxNegC = min(iMaxNegC, lpABCBuff->abcC);

                if (++i == 256)
                {
                    break;
                }

                if (lpBuffer) 
                {
                    lpABCBuff++;
                } 
                else 
                {
                    GetCharABCWidthsAorW(hdc, i, i, lpABCBuff);
                }
            }

            SelectFont(hdc, hOldFont);

            if (lpBuffer)
            {
                UserLocalFree(lpBuffer);
            }

            ReleaseDC(ped->hwnd, hdc);

            if ((iMaxNegA != 0) || (iMaxNegC != 0))
            {
               Edit_SetMargin(ped, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                        MAKELONG((UINT)(-iMaxNegC), (UINT)(-iMaxNegA)),fRedraw);
            }
        }

    }
}


//---------------------------------------------------------------------------//
//
// GetCharDimensionsEx(HDC hDC, HFONT hfont, LPTEXTMETRIC lptm, LPINT lpcy)
//
// if an app set a font for vertical writing, even though we don't
// handle it with EC, the escapement of tm can be NON 0. Then cxWidth from
// GetCharDimenstions() could be 0 in GetCharDimensions().
// This will break our caller who don't expect 0 at return. So I created
// this entry  for the case the caller set vertical font.
//
//
// PORTPORT: Duplicates functionality of GetCharDimensions() in prsht.c
int UserGetCharDimensionsEx(HDC hDC, HFONT hfont, LPTEXTMETRICW lptm, LPINT lpcy)
{
    static CONST WCHAR AveCharWidthData[] = L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    int         cxWidth;
    TEXTMETRICW tm;
    LOGFONTW    lf;
    WCHAR       wchFaceName[LF_FACESIZE];

    //
    // Is this font vertical font ??
    //
    wchFaceName[0] = 0;
    GetTextFaceW(hDC, LF_FACESIZE, wchFaceName);
    if (wchFaceName[0] != L'@') 
    {
        //
        // if not call GDI...
        //
        return(GdiGetCharDimensions(hDC, lptm, lpcy));
    }

    if (!lptm)
    {
        lptm = &tm;
    }

    GetTextMetricsW(hDC, lptm);

    // TMPF_FIXED_PITCH
    //
    //   If this bit is set the font is a variable pitch font.
    //   If this bit is clear the font is a fixed pitch font.
    // Note very carefully that those meanings are the opposite of what the constant name implies.
    //
    if (!(lptm->tmPitchAndFamily & TMPF_FIXED_PITCH)) 
    {
        //
        // This is fixed pitch font....
        //
        cxWidth = lptm->tmAveCharWidth;
    } 
    else 
    {
        //
        // This is variable pitch font...
        //
        if (hfont && GetObjectW(hfont, sizeof(LOGFONTW), &lf) && (lf.lfEscapement != 0)) 
        {
            cxWidth = lptm->tmAveCharWidth;
        } 
        else 
        {
            SIZE size;
            GetTextExtentPointW(hDC, AveCharWidthData, 52, &size);
            cxWidth = ((size.cx / 26) + 1) / 2;
        }
    }

    if (lpcy)
    {
        *lpcy = lptm->tmHeight;
    }

    return cxWidth;
}


//---------------------------------------------------------------------------//
//
// Edit_GetTextHandler AorW
//
// Copies at most maxCchToCopy chars to the buffer lpBuffer. Returns
// how many chars were actually copied. Null terminates the string based
// on the fNullTerminate flag:
// fNullTerminate --> at most (maxCchToCopy - 1) characters will be copied
// !fNullTerminate --> at most (maxCchToCopy) characters will be copied
//
ICH Edit_GetTextHandler(PED ped, ICH maxCchToCopy, LPSTR lpBuffer, BOOL fNullTerminate)
{
    PSTR pText;

    if (maxCchToCopy) 
    {
        //
        // Zero terminator takes the extra byte
        //
        if (fNullTerminate)
        {
            maxCchToCopy--;
        }
        maxCchToCopy = min(maxCchToCopy, ped->cch);

        //
        // Zero terminate the string
        //
        if (ped->fAnsi)
        {
            *(LPSTR)(lpBuffer + maxCchToCopy) = 0;
        }
        else
        {
            *(((LPWSTR)lpBuffer) + maxCchToCopy) = 0;
        }

        pText = Edit_Lock(ped);
        RtlCopyMemory(lpBuffer, pText, maxCchToCopy*ped->cbChar);
        Edit_Unlock(ped);
    }

    return maxCchToCopy;
}


//---------------------------------------------------------------------------//
BOOL Edit_NcCreate( PED ped, HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    BOOL    fAnsi;
    ULONG   ulStyle;
    ULONG   ulStyleEx;

    //
    // Initialize the ped
    //
    ped->hwnd = hwnd;
    ped->pww = (PWW)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);

    ulStyle = GET_STYLE(ped);
    ulStyleEx = GET_EXSTYLE(ped);

    //
    // (phellyar) All strings sent to us via standard WM_* messages or 
    //            control specific EM_* messages are expanded to unicode 
    //            for us by user. Therefore we need worry about 
    //            whether be are created by and ANSI app.
    //
    //fAnsi = TESTFLAG(GET_STATE(ped), WS_ST_ANSICREATOR);
    fAnsi = 0;

    ped->fEncoded = FALSE;
    ped->iLockLevel = 0;

    ped->chLines = NULL;
    ped->pTabStops = NULL;
    ped->charWidthBuffer = NULL;
    ped->fAnsi = fAnsi ? 1 : 0; // Force TRUE to be 1 because its a 1 bit field
    ped->cbChar = (WORD)(fAnsi ? sizeof(CHAR) : sizeof(WCHAR));
    ped->hInstance = lpCreateStruct->hInstance;
    // IME
    ped->hImcPrev = NULL_HIMC;

    {
        DWORD dwVer = UserGetVersion();

        ped->fWin31Compat = Is310Compat(dwVer);
        ped->f40Compat = Is400Compat(dwVer);

    }

    //
    // NOTE:
    // The order of the following two checks is important.  People can
    // create edit fields with a 3D and a normal border, and we don't
    // want to disallow that.  But we need to detect the "no 3D border"
    // border case too.
    //
    if ( ulStyleEx & WS_EX_EDGEMASK )
    {
        ped->fBorder = TRUE;
    }
    else if ( ulStyle & WS_BORDER )
    {
        ClearWindowState(hwnd, WS_BORDER);
        ped->fFlatBorder = TRUE;
        ped->fBorder = TRUE;
    }

    if ( !(ulStyle & ES_MULTILINE) )
    {
        ped->fSingle = TRUE;
    }

    if ( ulStyle & WS_DISABLED )
    {
        ped->fDisabled = TRUE;
    }

    if ( ulStyle & ES_READONLY) 
    {
        if (!ped->fWin31Compat) 
        {
            //
            // BACKWARD COMPATIBILITY HACK
            // 
            // "MileStone" unknowingly sets the ES_READONLY style. So, we strip this
            // style here for all Win3.0 apps (this style is new for Win3.1).
            // Fix for Bug #12982 -- SANKAR -- 01/24/92 --
            //
            ClearWindowState(hwnd, ES_READONLY);
        } 
        else
        {
            ped->fReadOnly = TRUE;
        }
    }


    //
    // Allocate storage for the text for the edit controls. Storage for single
    // line edit controls will always get allocated in the local data segment.
    // Multiline will allocate in the local ds but the app may free this and
    // allocate storage elsewhere...
    //
    ped->hText = LocalAlloc(LHND, CCHALLOCEXTRA*ped->cbChar);
    if (!ped->hText) 
    {
        return FALSE;
    }

    ped->cchAlloc = CCHALLOCEXTRA;
    ped->lineHeight = 1;

    ped->hwndParent = lpCreateStruct->hwndParent;
    ped->hTheme = OpenThemeData(ped->hwnd, L"Edit");

    ped->wImeStatus = 0;

    return (BOOL)DefWindowProc(hwnd, WM_NCCREATE, 0, (LPARAM)lpCreateStruct);
}


//---------------------------------------------------------------------------//
BOOL Edit_Create(PED ped, LONG windowStyle)
{
    HDC hdc;

    //
    // Get values from the window instance data structure and put 
    // them in the ped so that we can access them easier.
    //
    if ( windowStyle & ES_AUTOHSCROLL )
    {
        ped->fAutoHScroll = 1;
    }

    if ( windowStyle & ES_NOHIDESEL )
    {
        ped->fNoHideSel = 1;
    }

    ped->format = (LOWORD(windowStyle) & LOWORD(ES_FMTMASK));
    if ((windowStyle & ES_RIGHT) && !ped->format)
    {
        ped->format = ES_RIGHT;
    }

    //
    // Max # chars we will initially allow
    //
    ped->cchTextMax = MAXTEXT;

    //
    // Set up undo initial conditions... (ie. nothing to undo)
    //
    ped->ichDeleted = (ICH)-1;
    ped->ichInsStart = (ICH)-1;
    ped->ichInsEnd = (ICH)-1;

    //
    // initial charset value - need to do this BEFORE EditML_Create is called
    // so that we know not to fool with scrollbars if nessacary
    //
    hdc = Edit_GetDC(ped, TRUE);
    ped->charSet = (BYTE)GetTextCharset(hdc);
    Edit_ReleaseDC(ped, hdc, TRUE);

    //
    // FE_IME
    // EC_INSERT_COMPOSITION_CHARACTER: Edit_Create() - call Edit_InitInsert()
    //
    Edit_InitInsert(ped, GetKeyboardLayout(0));


    if( g_pLpkEditCallout )
    {
        ped->pLpkEditCallout = g_pLpkEditCallout;
    } 
    else
    {
        ped->pLpkEditCallout = NULL;
    }

    return ped->pLpkEditCallout ? ped->pLpkEditCallout->EditCreate((PED0)ped, ped->hwnd) : TRUE;
}


//---------------------------------------------------------------------------//
//
// Do this once at process startup. The edit control has special
// callouts in lpk.dll to help it render complex script languages
// such as Arabic. The registry probing alg executed here is the same
// as the one performed in win32k!InitializeGre.
//
// We then call GetModuleHandle rather than LoadLibrary, since lpk.dll
// will be guaranteed to be loaded and initialized already by gdi32. This 
// fixes the scenario in which the user turns on complex scripts but
// doesn't reboot, which caused us to try and load lpk without it having
// been initialized on the kernel side.
// 
VOID InitEditLpk()
{
    LONG lError;
    HKEY hKey;

    lError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\LanguagePack"),
                          0,
                          KEY_QUERY_VALUE,
                          &hKey);

    if (lError == ERROR_SUCCESS)
    {
        HANDLE hLpk;
        DWORD  dwLpkShapingDlls;
        DWORD  dwIndex;
        TCHAR  szTemp[256];
        DWORD  dwTempSize;
        DWORD  dwValueType;
        DWORD  dwValue;
        DWORD  dwValueSize;

        dwLpkShapingDlls = 0;
        dwIndex = 0;
        do 
        {
            dwTempSize  = ARRAYSIZE(szTemp);
            dwValueSize = SIZEOF(DWORD);
            lError = RegEnumValue(hKey,
                                  dwIndex++,
                                  szTemp,
                                  &dwTempSize,
                                  NULL,
                                  &dwValueType,
                                  (LPVOID)&dwValue,
                                  &dwValueSize);

            if ((lError == ERROR_SUCCESS) && (dwValueType == REG_DWORD))
            {
                dwLpkShapingDlls |= 1 << dwValue;
            }
        } 
        while (lError != ERROR_NO_MORE_ITEMS);

        if (dwLpkShapingDlls != 0)
        {
            hLpk = GetModuleHandle(TEXT("LPK"));
            if (hLpk != NULL)
            {
                g_pLpkEditCallout = (PLPKEDITCALLOUT)GetProcAddress(hLpk, "LpkEditControl");

                if (g_pLpkEditCallout == NULL)
                {
                    FreeLibrary(hLpk);
                }
            }
        }

        RegCloseKey(hKey);
    }
}


//---------------------------------------------------------------------------//
//
// Destroys the edit control ped by freeing up all memory used by it.
//
VOID Edit_NcDestroyHandler(HWND hwnd, PED ped)
{
    //
    // ped could be NULL if WM_NCCREATE failed to create it...
    //
    if (ped) 
    {
        //
        // Free the text buffer (always present?)
        //
        LocalFree(ped->hText);

        
        //
        // Free up undo buffer and line start array (if present)
        //
        if (ped->hDeletedText != NULL)
        {
            GlobalFree(ped->hDeletedText);
        }

        //
        // Free tab stop buffer (if present)
        //
        if (ped->pTabStops)
        {
            UserLocalFree(ped->pTabStops);
        }

        //
        // Free line start array (if present)
        //
        if (ped->chLines) 
        {
            UserLocalFree(ped->chLines);
        }

        //
        // Free the character width buffer (if present)
        //
        if (ped->charWidthBuffer)
        {
            UserLocalFree(ped->charWidthBuffer);
        }

        //
        // Free the cursor bitmap
        //
        if (ped->pLpkEditCallout && ped->hCaretBitmap)
        {
            DeleteObject(ped->hCaretBitmap);
        }

        //
        // Free the cached font handle
        //
        if ( ped->hFontSave )
        {
            DeleteObject(ped->hFontSave);
        }

        //
        // Close an open theme handle
        //
        if ( ped->hTheme )
        {
            CloseThemeData(ped->hTheme);
        }

        // 
        // Free the memory used by CueBannerText
        //
        Str_SetPtr(&(ped->pszCueBannerText), NULL);

        //
        // free the allocated password font
        //
        if ( ped->hFontPassword )
        {
            DeleteObject(ped->hFontPassword);
        }

        //
        // Last but not least, free the ped
        //
        UserLocalFree(ped);
    }

    TraceMsg(TF_STANDARD, "EDIT: Clearing edit instance pointer.");
    Edit_SetPtr(hwnd, NULL);

    // If we're part of a combo box, let it know we're gone
#if 0 // PORTPORT: Expose fnid field in WND struct.
    pwndParent = REBASEPWND(pwnd, spwndParent);
    if (pwndParent && GETFNID(pwndParent) == FNID_COMBOBOX) {
        ComboBoxWndProcWorker(pwndParent, WM_PARENTNOTIFY,
                MAKELONG(WM_DESTROY, PTR_TO_ID(pwnd->spmenu)), (LPARAM)HWq(pwnd), FALSE);
    }
#endif
}


//---------------------------------------------------------------------------//
// 
// Edit_SetPasswordCharHandler AorW
//
// Sets the password char to display.
//
VOID Edit_SetPasswordCharHandler(PED ped, UINT pwchar)
{
    HDC hdc;
    SIZE size = {0};

    ped->charPasswordChar = pwchar;

    if (pwchar) 
    {
        hdc = Edit_GetDC(ped, TRUE);

        if (ped->fAnsi)
        {
            GetTextExtentPointA(hdc, (LPSTR)&pwchar, 1, &size);
        }
        else
        {
            GetTextExtentPointW(hdc, (LPWSTR)&pwchar, 1, &size);
        }

        GetTextExtentPointW(hdc, (LPWSTR)&pwchar, 1, &size);
        ped->cPasswordCharWidth = max(size.cx, 1);
        Edit_ReleaseDC(ped, hdc, TRUE);
    }

    if (pwchar)
    {
        SetWindowState(ped->hwnd, ES_PASSWORD);
    }
    else
    {
        ClearWindowState(ped->hwnd, ES_PASSWORD);
    }

    if ( g_fIMMEnabled )
    {
        Edit_EnableDisableIME(ped);
    }
}


//---------------------------------------------------------------------------//
//
// GetNegABCwidthInfo()
//
// This function fills up the ped->charWidthBuffer buffer with the
// negative A,B and C widths for all the characters below 0x7f in the
// currently selected font.
//
// Returns:
//   TRUE, if the function succeeded.
//   FALSE, if GDI calls to get the char widths have failed.
//
// Note: not used if LPK installed
// 
BOOL GetNegABCwidthInfo(PED ped, HDC hdc)
{
    LPABC lpABCbuff;
    int   i;
    int   CharWidthBuff[CHAR_WIDTH_BUFFER_LENGTH]; // Local char width buffer.
    int   iOverhang;

    if (!GetCharABCWidthsA(hdc, 0, CHAR_WIDTH_BUFFER_LENGTH-1, (LPABC)ped->charWidthBuffer)) 
    {
        TraceMsg(TF_STANDARD, "UxEdit: GetNegABCwidthInfo: GetCharABCWidthsA Failed");
        return FALSE;
    }

    // 
    // The (A+B+C) returned for some fonts (eg: Lucida Caligraphy) does not
    // equal the actual advanced width returned by GetCharWidths() minus overhang.
    // This is due to font bugs. So, we adjust the 'B' width so that this
    // discrepancy is removed.
    // Fix for Bug #2932 --sankar-- 02/17/93
    //
    iOverhang = ped->charOverhang;
    GetCharWidthA(hdc, 0, CHAR_WIDTH_BUFFER_LENGTH-1, (LPINT)CharWidthBuff);
    lpABCbuff = (LPABC)ped->charWidthBuffer;
    for(i = 0; i < CHAR_WIDTH_BUFFER_LENGTH; i++) 
    {
         lpABCbuff->abcB = CharWidthBuff[i] - iOverhang
                 - lpABCbuff->abcA
                 - lpABCbuff->abcC;
         lpABCbuff++;
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// Edit_Size() -
//
// Handle sizing for an edit control's client rectangle.
// Use lprc as the bounding rectangle if specified; otherwise use the current
// client rectangle.
//
VOID Edit_Size(PED ped, LPRECT lprc, BOOL fRedraw)
{
    RECT rc;

    //
    // BiDi VB32 Creates an Edit Control and immediately sends a WM_SIZE
    // message which causes EXSize to be called before Edit_SetFont, which
    // in turn causes a divide by zero exception below. This check for
    // ped->lineHeight will pick it up safely. [samera] 3/5/97
    //
    if(ped->lineHeight == 0)
    {
        return;
    }

    //
    // assume that we won't be able to display the caret
    //
    ped->fCaretHidden = TRUE;


    if ( lprc )
    {
        CopyRect(&rc, lprc);
    }
    else
    {
        GetClientRect(ped->hwnd, &rc);
    }

    if (!(rc.right - rc.left) || !(rc.bottom - rc.top)) 
    {
        if (ped->rcFmt.right - ped->rcFmt.left)
        {
            return;
        }

        rc.left     = 0;
        rc.top      = 0;
        rc.right    = ped->aveCharWidth * 10;
        rc.bottom   = ped->lineHeight;
    }

    if (!lprc) 
    {
        //
        // subtract the margins from the given rectangle --
        // make sure that this rectangle is big enough to have these margins.
        //
        if ((rc.right - rc.left) > (int)(ped->wLeftMargin + ped->wRightMargin)) 
        {
            rc.left  += ped->wLeftMargin;
            rc.right -= ped->wRightMargin;
        }
    }

    //
    // Leave space so text doesn't touch borders.
    // For 3.1 compatibility, don't subtract out vertical borders unless
    // there is room.
    //
    if (ped->fBorder) 
    {
        INT cxBorder = GetSystemMetrics(SM_CXBORDER);
        INT cyBorder = GetSystemMetrics(SM_CYBORDER);

        if (ped->fFlatBorder)
        {
            cxBorder *= 2;
            cyBorder *= 2;
        }

        if (rc.bottom < rc.top + ped->lineHeight + 2*cyBorder)
        {
            cyBorder = 0;
        }

        InflateRect(&rc, -cxBorder, -cyBorder);
    }

    //
    // Is the resulting rectangle too small?  Don't change it then.
    //
    if ((!ped->fSingle) && ((rc.right - rc.left < (int) ped->aveCharWidth) ||
        ((rc.bottom - rc.top) / ped->lineHeight == 0)))
    {
        return;
    }

    //
    // now, we know we're safe to display the caret
    //
    ped->fCaretHidden = FALSE;

    CopyRect(&ped->rcFmt, &rc);

    if (ped->fSingle)
    {
        ped->rcFmt.bottom = min(rc.bottom, rc.top + ped->lineHeight);
    }
    else
    {
        EditML_Size(ped, fRedraw);
    }

    if (fRedraw) 
    {
        InvalidateRect(ped->hwnd, NULL, TRUE);
    }

    //
    // FE_IME
    // Edit_Size()  - call Edit_ImmSetCompositionWindow()
    //
    // normally this isn't needed because WM_SIZE will cause
    // WM_PAINT and the paint handler will take care of IME
    // composition window. However when the edit window is
    // restored from maximized window and client area is out
    // of screen, the window will not be redrawn.
    //
    if (ped->fFocus && g_fIMMEnabled && ImmIsIME(GetKeyboardLayout(0))) 
    {
        POINT pt;

        GetCaretPos(&pt);
        Edit_ImmSetCompositionWindow(ped, pt.x, pt.y);
    }
}


//---------------------------------------------------------------------------//
// 
// Edit_SetFont AorW
// 
// Sets the font used in the edit control.  Warning:  Memory compaction may
// occur if the font wasn't previously loaded.  If the font handle passed
// in is NULL, assume the system font.
//
BOOL Edit_SetFont(PED ped, HFONT hfont, BOOL fRedraw)
{
    TEXTMETRICW TextMetrics = {0};
    HDC         hdc;
    HFONT       hOldFont=NULL;
    DWORD       dwMaxOverlapChars;
    CHWIDTHINFO cwi;
    UINT        uExtracharPos;
    BOOL        fRet = FALSE;

    hdc = GetDC(ped->hwnd);
    if (hdc)
    {

#ifdef _USE_DRAW_THEME_TEXT_
        if (hfont)
        {
            ped->hFontSave = hfont;
        }

        if ( ped->hTheme )
        {
            //
            // use the theme font if we're themed
            //
            HRESULT hr;
            LOGFONT lf;
            hr = GetThemeFont(ped->hTheme, hdc, EP_EDITTEXT, 0, TMT_FONT, &lf);
            if ( SUCCEEDED(hr) )
            {
                hfont = CreateFontIndirect(&lf);
            }
        }
#endif // _USE_DRAW_THEME_TEXT_

        ped->hFont = hfont;
        if (ped->hFont)
        {
            //
            // Since the default font is the system font, no need to select it in
            // if that's what the user wants.
            //
            hOldFont = SelectObject(hdc, hfont);
            if (!hOldFont) 
            {
                hfont = ped->hFont = NULL;
            }

            //
            // Get the metrics and ave char width for the currently selected font
            //

            //
            // Call Vertical font-aware AveWidth compute function...
            //
            // FE_SB
            ped->aveCharWidth = UserGetCharDimensionsEx(hdc, hfont, &TextMetrics, &ped->lineHeight);

            //
            // This might fail when people uses network fonts (or bad fonts).
            //
            if (ped->aveCharWidth == 0) 
            {
                TraceMsg(TF_STANDARD, "EDIT: Edit_SetFont: GdiGetCharDimensions failed");
                if (hOldFont != NULL) 
                {
                    SelectObject(hdc, hOldFont);
                }

                //
                // We've messed up the ped so let's reset the font.
                // Note that we won't recurse more than once because we'll
                // pass hfont == NULL.
                // Too bad WM_SETFONT doesn't return a value.
                //
                return Edit_SetFont(ped, NULL, fRedraw);
            }
        } 
        else 
        {
            ped->aveCharWidth = UserGetCharDimensionsEx(hdc, hfont, &TextMetrics, &ped->lineHeight);

            // We should always be able to get the dimensions of the system font. Just in case
            // set these guys to known system font constants
            if ( ped->aveCharWidth == 0 )
            {
                ped->aveCharWidth = SYSFONT_CXCHAR;
                ped->lineHeight = SYSFONT_CYCHAR;
            }
        }

        ped->charOverhang = TextMetrics.tmOverhang;

        //
        // assume that they don't have any negative widths at all.
        //
        ped->wMaxNegA = ped->wMaxNegC = ped->wMaxNegAcharPos = ped->wMaxNegCcharPos = 0;

        //
        // Check if Proportional Width Font
        //
        // NOTE: as SDK doc says about TEXTMETRIC:
        // TMPF_FIXED_PITCH
        // If this bit is set the font is a variable pitch font. If this bit is clear
        // the font is a fixed pitch font. Note very carefully that those meanings are
        // the opposite of what the constant name implies.
        //
        // Thus we have to reverse the value using logical not (fNonPropFont has 1 bit width)
        //
        ped->fNonPropFont = !(TextMetrics.tmPitchAndFamily & FIXED_PITCH);

        //
        // Check for a TrueType font
        // Older app OZWIN chokes if we allocate a bigger buffer for TrueType fonts
        // So, for apps older than 4.0, no special treatment for TrueType fonts.
        //
        if (ped->f40Compat && (TextMetrics.tmPitchAndFamily & TMPF_TRUETYPE)) 
        {
            ped->fTrueType = GetCharWidthInfo(hdc, &cwi);
#if DBG
            if (!ped->fTrueType) 
            {
                TraceMsg(TF_STANDARD, "EDIT: Edit_SetFont: GetCharWidthInfo Failed");
            }
#endif
        } 
        else 
        {
            ped->fTrueType = FALSE;
        }

        // FE_SB
        //
        // In DBCS Windows, Edit Control must handle Double Byte Character
        // if tmCharSet field of textmetrics is double byte character set
        // such as SHIFTJIS_CHARSET(128:Japan), HANGEUL_CHARSET(129:Korea).
        //
        // We call Edit_GetDBCSVector even when fAnsi is false so that we could
        // treat ped->fAnsi and ped->fDBCS indivisually. I changed Edit_GetDBCSVector
        // function so that it returns 0 or 1, because I would like to set ped->fDBCS
        // bit field here.
        //
        ped->fDBCS = Edit_GetDBCSVector(ped,hdc,TextMetrics.tmCharSet);
        ped->charSet = TextMetrics.tmCharSet;

        if (ped->fDBCS) 
        {
            //
            // Free the character width buffer if ped->fDBCS.
            //
            // I expect single GetTextExtentPoint call is faster than multiple
            // GetTextExtentPoint call (because the graphic engine has a cache buffer).
            // See editec.c/ECTabTheTextOut().
            //
            if (ped->charWidthBuffer) 
            {
                LocalFree(ped->charWidthBuffer);
                ped->charWidthBuffer = NULL;
            }

            //
            // if FullWidthChar : HalfWidthChar == 2 : 1....
            //
            // TextMetrics.tmMaxCharWidth = FullWidthChar width
            // ped->aveCharWidth          = HalfWidthChar width
            //
            if (ped->fNonPropFont &&
                ((ped->aveCharWidth * 2) == TextMetrics.tmMaxCharWidth)) 
            {
                ped->fNonPropDBCS = TRUE;
            } 
            else 
            {
                ped->fNonPropDBCS = FALSE;
            }

        } 
        else 
        {
            //
            // Since the font has changed, let us obtain and save the character width
            // info for this font.
            //
            // First left us find out if the maximum chars that can overlap due to
            // negative widths. Since we can't access USER globals, we make a call here.
            //
            if (!(ped->fSingle || ped->pLpkEditCallout)) 
            {
                //
                // Is this a multiline edit control with no LPK present?
                //
                UINT  wBuffSize;
                LPINT lpCharWidthBuff;
                SHORT i;

                //
                // For multiline edit controls, we maintain a buffer that contains
                // the character width information.
                //
                wBuffSize = (ped->fTrueType) ? (CHAR_WIDTH_BUFFER_LENGTH * sizeof(ABC)) :
                                               (CHAR_WIDTH_BUFFER_LENGTH * sizeof(int));

                if (ped->charWidthBuffer) 
                {
                    //
                    // If buffer already present
                    //
                    lpCharWidthBuff = ped->charWidthBuffer;
                    ped->charWidthBuffer = UserLocalReAlloc(lpCharWidthBuff, wBuffSize, HEAP_ZERO_MEMORY);
                    if (ped->charWidthBuffer == NULL) 
                    {
                        UserLocalFree((HANDLE)lpCharWidthBuff);
                    }
                } 
                else 
                {
                    ped->charWidthBuffer = UserLocalAlloc(HEAP_ZERO_MEMORY, wBuffSize);
                }

                if (ped->charWidthBuffer != NULL) 
                {
                    if (ped->fTrueType) 
                    {
                        ped->fTrueType = GetNegABCwidthInfo(ped, hdc);
                    }

                    //
                    // It is possible that the above attempts could have failed and reset
                    // the value of fTrueType. So, let us check that value again.
                    //
                    if (!ped->fTrueType) 
                    {
                        if (!GetCharWidthA(hdc, 0, CHAR_WIDTH_BUFFER_LENGTH-1, ped->charWidthBuffer)) 
                        {
                            UserLocalFree((HANDLE)ped->charWidthBuffer);
                            ped->charWidthBuffer=NULL;
                        } 
                        else 
                        {
                            //
                            // We need to subtract out the overhang associated with
                            // each character since GetCharWidth includes it...
                            //
                            for (i=0;i < CHAR_WIDTH_BUFFER_LENGTH;i++)
                            {
                                ped->charWidthBuffer[i] -= ped->charOverhang;
                            }
                        }
                    }
                }
            }
        }

        {
            //
            // Calculate MaxNeg A C metrics
            //
#if 0 // PORTPORT: How to get this info in user mode? And if we
          //           set it to zero what is the effect?
            dwMaxOverlapChars = GetMaxOverlapChars();
#endif
            dwMaxOverlapChars = 0; 
            if (ped->fTrueType) 
            {
                if (cwi.lMaxNegA < 0)
                {
                    ped->wMaxNegA = -cwi.lMaxNegA;
                }
                else
                {
                    ped->wMaxNegA = 0;
                }

                if (cwi.lMaxNegC < 0)
                {
                    ped->wMaxNegC = -cwi.lMaxNegC;
                }
                else
                {
                    ped->wMaxNegC = 0;
                }

                if (cwi.lMinWidthD != 0) 
                {
                    ped->wMaxNegAcharPos = (ped->wMaxNegA + cwi.lMinWidthD - 1) / cwi.lMinWidthD;
                    ped->wMaxNegCcharPos = (ped->wMaxNegC + cwi.lMinWidthD - 1) / cwi.lMinWidthD;
                    if (ped->wMaxNegA + ped->wMaxNegC > (UINT)cwi.lMinWidthD) 
                    {
                        uExtracharPos = (ped->wMaxNegA + ped->wMaxNegC - 1) / cwi.lMinWidthD;
                        ped->wMaxNegAcharPos += uExtracharPos;
                        ped->wMaxNegCcharPos += uExtracharPos;
                    }
                } 
                else 
                {
                    ped->wMaxNegAcharPos = LOWORD(dwMaxOverlapChars);     // Left
                    ped->wMaxNegCcharPos = HIWORD(dwMaxOverlapChars);     // Right
                }

            } 
            else if (ped->charOverhang != 0) 
            {
                //
                // Some bitmaps fonts (i.e., italic) have under/overhangs;
                // this is pretty much like having negative A and C widths.
                //
                ped->wMaxNegA = ped->wMaxNegC = ped->charOverhang;
                ped->wMaxNegAcharPos = LOWORD(dwMaxOverlapChars);     // Left
                ped->wMaxNegCcharPos = HIWORD(dwMaxOverlapChars);     // Right
            }
        }

        if (!hfont) 
        {
            //
            // We are getting the stats for the system font so update the system
            // font fields in the ed structure since we use these when calculating
            // some spacing.
            //
            ped->cxSysCharWidth = ped->aveCharWidth;
            ped->cySysCharHeight= ped->lineHeight;
        } 
        else if (hOldFont)
        {
            SelectObject(hdc, hOldFont);
        }

        if (ped->fFocus) 
        {
            UINT cxCaret;

            SystemParametersInfo(SPI_GETCARETWIDTH, 0, (LPVOID)&cxCaret, 0);

            //
            // Update the caret.
            //
            HideCaret(ped->hwnd);
            DestroyCaret();

            if (ped->pLpkEditCallout) 
            {
                ped->pLpkEditCallout->EditCreateCaret((PED0)ped, hdc, cxCaret, ped->lineHeight, 0);
            }
            else 
            {
                CreateCaret(ped->hwnd, (HBITMAP)NULL, cxCaret, ped->lineHeight);
            }
            ShowCaret(ped->hwnd);
        }

        ReleaseDC(ped->hwnd, hdc);

        //
        // Update password character.
        //
        if (ped->charPasswordChar)
        {
            Edit_SetPasswordCharHandler(ped, ped->charPasswordChar);
        }

        //
        // If it is a TrueType font and it's a new app, set both the margins at the
        // max negative width values for all types of the edit controls.
        // (NOTE: Can't use ped->f40Compat here because edit-controls inside dialog
        // boxes without DS_LOCALEDIT style are always marked as 4.0 compat.
        // This is the fix for NETBENCH 3.0)
        //

        if (ped->fTrueType && ped->f40Compat)
        {
            if (ped->fDBCS) 
            {
                //
                // For DBCS TrueType Font, we calc margin from ABC width.
                //
                Edit_CalcMarginForDBCSFont(ped, fRedraw);
            } 
            else 
            {
                Edit_SetMargin(ped, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                            MAKELONG(EC_USEFONTINFO, EC_USEFONTINFO), fRedraw);
            }
        }

        //
        // We need to calc maxPixelWidth when font changes.
        // If the word-wrap is ON, then this is done in EditML_Size() called later.
        //
        if((!ped->fSingle) && (!ped->fWrap))
        {
            EditML_BuildchLines(ped, 0, 0, FALSE, NULL, NULL);
        }

        //
        // Recalc the layout.
        //
        Edit_Size(ped, NULL, fRedraw);

        if ( ped->fFocus && ImmIsIME(GetKeyboardLayout(0)) ) 
        {
            Edit_SetCompositionFont( ped );
        }

        fRet = TRUE;
    }

    return fRet;
}


//---------------------------------------------------------------------------//
//
// Edit_IsCharNumeric AorW
//
// Tests whether the character entered is a numeral.
// For multiline and singleline edit controls with the ES_NUMBER style.
// 
BOOL Edit_IsCharNumeric(PED ped, DWORD keyPress)
{
    WORD wCharType;

    if (ped->fAnsi) 
    {
        char ch = (char)keyPress;
        LCID lcid = (LCID)((ULONG_PTR)GetKeyboardLayout(0) & 0xFFFF);
        GetStringTypeA(lcid, CT_CTYPE1, &ch, 1, &wCharType);
    } 
    else 
    {
        WCHAR wch = (WCHAR)keyPress;
        GetStringTypeW(CT_CTYPE1, &wch, 1, &wCharType);
    }
    return (wCharType & C1_DIGIT ? TRUE : FALSE);
}


//---------------------------------------------------------------------------//
VOID Edit_EnableDisableIME(PED ped)
{
    if ( ped->fReadOnly || ped->charPasswordChar ) 
    {
        //
        // IME should be disabled
        //
        HIMC hImc;
        hImc = ImmGetContext( ped->hwnd );

        if ( hImc != NULL_HIMC ) 
        {
            ImmReleaseContext( ped->hwnd, hImc );
            ped->hImcPrev = ImmAssociateContext( ped->hwnd, NULL_HIMC );
        }

    } 
    else 
    {
        //
        // IME should be enabled
        //
        if ( ped->hImcPrev != NULL_HIMC ) 
        {
            ped->hImcPrev = ImmAssociateContext( ped->hwnd, ped->hImcPrev );

            //
            // Font and the caret position might be changed while
            // IME was being disabled. Set those now if the window
            // has the focus.
            //
            if ( ped->fFocus ) 
            {
                POINT pt;

                Edit_SetCompositionFont( ped );

                GetCaretPos( &pt );
                Edit_ImmSetCompositionWindow( ped, pt.x, pt.y  );
            }
        }
    }

    Edit_InitInsert(ped, GetKeyboardLayout(0));
}


//---------------------------------------------------------------------------//
VOID Edit_ImmSetCompositionWindow(PED ped, LONG x, LONG y)
{
    COMPOSITIONFORM cf  = {0};
    COMPOSITIONFORM cft = {0};
    RECT rcScreenWindow;
    HIMC hImc;

    hImc = ImmGetContext(ped->hwnd);
    if ( hImc != NULL_HIMC ) 
    {
        if ( ped->fFocus ) 
        {
            GetWindowRect( ped->hwnd, &rcScreenWindow);

            //
            // assuming RECT.left is the first and and RECT.top is the second field
            //
            MapWindowPoints( ped->hwnd, HWND_DESKTOP, (LPPOINT)&rcScreenWindow, 2);
            if (ped->fInReconversion) 
            {
                DWORD dwPoint = (DWORD)(ped->fAnsi ? SendMessageA : SendMessageW)(ped->hwnd, EM_POSFROMCHAR, ped->ichMinSel, 0);

                x = GET_X_LPARAM(dwPoint);
                y = GET_Y_LPARAM(dwPoint);

                TraceMsg(TF_STANDARD, "UxEdit: Edit_ImmSetCompositionWindow: fInReconversion (%d,%d)", x, y);
            }

            //
            // The window currently has the focus.
            //
            if (ped->fSingle) 
            {
                //
                // Single line edit control.
                //
                cf.dwStyle = CFS_POINT;
                cf.ptCurrentPos.x = x;
                cf.ptCurrentPos.y = y;
                SetRectEmpty(&cf.rcArea);

            } 
            else 
            {
                //
                // Multi line edit control.
                //
                cf.dwStyle = CFS_RECT;
                cf.ptCurrentPos.x = x;
                cf.ptCurrentPos.y = y;
                cf.rcArea = ped->rcFmt;
            }
            ImmGetCompositionWindow( hImc, &cft );
            if ( (!RtlEqualMemory(&cf,&cft,sizeof(COMPOSITIONFORM))) ||
                 (ped->ptScreenBounding.x != rcScreenWindow.left)    ||
                 (ped->ptScreenBounding.y  != rcScreenWindow.top) ) 
            {

                ped->ptScreenBounding.x = rcScreenWindow.left;
                ped->ptScreenBounding.y = rcScreenWindow.top;
                ImmSetCompositionWindow( hImc, &cf );
            }
        }
        ImmReleaseContext( ped->hwnd, hImc );
    }
}


//---------------------------------------------------------------------------//
VOID Edit_SetCompositionFont(PED ped)
{
    HIMC hImc;
    LOGFONTW lf;

    hImc = ImmGetContext( ped->hwnd );
    if (hImc != NULL_HIMC) 
    {
        if (ped->hFont) 
        {
            GetObjectW(ped->hFont, sizeof(LOGFONTW), (LPLOGFONTW)&lf);
        } 
        else 
        {
            GetObjectW(GetStockObject(SYSTEM_FONT), sizeof(LOGFONTW), (LPLOGFONTW)&lf);
        }

        ImmSetCompositionFontW( hImc, &lf );
        ImmReleaseContext( ped->hwnd, hImc );
    }
}


//---------------------------------------------------------------------------//
//
// Edit_InitInsert
//
// this function is called when:
// 1) a edit control window is initialized
// 2) active keyboard layout of current thread is changed
// 3) read only attribute of this edit control is changed
//
VOID Edit_InitInsert( PED ped, HKL hkl )
{
    ped->fKorea = FALSE;
    ped->fInsertCompChr = FALSE;
    ped->fNoMoveCaret = FALSE;
    ped->fResultProcess = FALSE;

    if (g_fIMMEnabled && ImmIsIME(hkl) ) 
    {
        if (PRIMARYLANGID(LOWORD(HandleToUlong(hkl))) == LANG_KOREAN ) 
        {
            ped->fKorea = TRUE;
        }

        //
        // LATER:this flag should be set based on the IME caps
        // retrieved from IME. (Such IME caps should be defined)
        // For now, we can safely assume that only Korean IMEs
        // set CS_INSERTCHAR.
        //
        if ( ped->fKorea ) 
        {
            ped->fInsertCompChr = TRUE;
        }
    }

    //
    // if we had a composition character, the shape of caret
    // is changed. We need to reset the caret shape.
    //
    if ( ped->fReplaceCompChr ) 
    {
        ped->fReplaceCompChr = FALSE;
        Edit_SetCaretHandler( ped );
    }
}


//---------------------------------------------------------------------------//
VOID Edit_SetCaretHandler(PED ped)
{
    HDC     hdc;
    PSTR    pText;
    SIZE    size = {0};

    //
    // In any case destroy caret beforehand otherwise SetCaretPos()
    // will get crazy.. win95d-B#992,B#2370
    //
    if (ped->fFocus) 
    {
        HideCaret(ped->hwnd);
        DestroyCaret();
        if ( ped->fReplaceCompChr ) 
        {

            hdc = Edit_GetDC(ped, TRUE );
            pText = Edit_Lock(ped);

            if ( ped->fAnsi)
            {
                 GetTextExtentPointA(hdc, pText + ped->ichCaret, 2, &size);
            }
            else
            {
                 GetTextExtentPointW(hdc, (LPWSTR)pText + ped->ichCaret, 1, &size);
            }

            Edit_Unlock(ped);
            Edit_ReleaseDC(ped, hdc, TRUE);

            CreateCaret(ped->hwnd, (HBITMAP)NULL, size.cx, ped->lineHeight);
        }
        else 
        {
            CreateCaret(ped->hwnd,
                        (HBITMAP)NULL,
                        (ped->cxSysCharWidth > ped->aveCharWidth ? 1 : 2),
                        ped->lineHeight);
        }

        hdc = Edit_GetDC(ped, TRUE );
        if ( ped->fSingle )
        {
            EditSL_SetCaretPosition( ped, hdc );
        }
        else
        {
            EditML_SetCaretPosition( ped, hdc );
        }

        Edit_ReleaseDC(ped, hdc, TRUE);
        ShowCaret(ped->hwnd);
    }
}


//---------------------------------------------------------------------------//
#define GET_COMPOSITION_STRING  (ped->fAnsi ? ImmGetCompositionStringA : ImmGetCompositionStringW)

BOOL Edit_ResultStrHandler(PED ped)
{
    HIMC himc;
    LPSTR lpStr;
    LONG dwLen;

    ped->fInsertCompChr = FALSE;    // clear the state
    ped->fNoMoveCaret = FALSE;

    himc = ImmGetContext(ped->hwnd);
    if ( himc == NULL_HIMC ) 
    {
        return FALSE;
    }

    dwLen = GET_COMPOSITION_STRING(himc, GCS_RESULTSTR, NULL, 0);

    if (dwLen == 0) 
    {
        ImmReleaseContext(ped->hwnd, himc);
        return FALSE;
    }

    dwLen *= ped->cbChar;
    dwLen += ped->cbChar;

    lpStr = (LPSTR)GlobalAlloc(GPTR, dwLen);
    if (lpStr == NULL) 
    {
        ImmReleaseContext(ped->hwnd, himc);
        return FALSE;
    }

    GET_COMPOSITION_STRING(himc, GCS_RESULTSTR, lpStr, dwLen);

    if (ped->fSingle) 
    {
        EditSL_ReplaceSel(ped, lpStr);
    } 
    else 
    {
        EditML_ReplaceSel(ped, lpStr);
    }

    GlobalFree((HGLOBAL)lpStr);

    ImmReleaseContext(ped->hwnd, himc);

    ped->fReplaceCompChr = FALSE;
    ped->fNoMoveCaret = FALSE;
    ped->fResultProcess = FALSE;

    Edit_SetCaretHandler(ped);

    return TRUE;
}


//---------------------------------------------------------------------------//
LRESULT Edit_ImeComposition(PED ped, WPARAM wParam, LPARAM lParam)
{
    INT ich;
    LRESULT lReturn = 1;
    HDC hdc;
    BOOL fSLTextUpdated = FALSE;
    ICH iResult;
    HIMC hImc;
    BYTE TextBuf[4];

    if (!ped->fInsertCompChr) 
    {
        if (lParam & GCS_RESULTSTR) 
        {
            Edit_InOutReconversionMode(ped, FALSE);

            if (!ped->fKorea && ped->wImeStatus & EIMES_GETCOMPSTRATONCE) 
            {
ResultAtOnce:
                Edit_ResultStrHandler(ped);
                lParam &= ~GCS_RESULTSTR;
            }
        }
        return DefWindowProc(ped->hwnd, WM_IME_COMPOSITION, wParam, lParam);
    }

    //
    // In case of Ansi edit control, the length of minimum composition string
    // is 2. Check here maximum byte of edit control.
    //
    if( ped->fAnsi && ped->cchTextMax == 1 ) 
    {
        HIMC hImc;

        hImc = ImmGetContext( ped->hwnd );
        ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0L);
        ImmReleaseContext( ped->hwnd, hImc );
        MessageBeep(MB_ICONEXCLAMATION);
        return lReturn;
    }

    //
    // Don't move this after CS_NOMOVECARET check.
    // In case if skip the message, fNoMoveCaret should not be set.
    //
    if ((lParam & CS_INSERTCHAR) && ped->fResultProcess) 
    {
        //
        // Now we're in result processing. GCS_RESULTSTR ends up
        // to WM_IME_CHAR and WM_CHAR. Since WM_CHAR is posted,
        // the message(s) will come later than this CS_INSERTCHAR
        // message. This composition character should be handled
        // after the WM_CHAR message(s).
        //
        if(ped->fAnsi)
        {
            PostMessageA(ped->hwnd, WM_IME_COMPOSITION, wParam, lParam);
        }
        else
        {
            PostMessageW(ped->hwnd, WM_IME_COMPOSITION, wParam, lParam);
        }

        ped->fResultProcess = FALSE;

        return lReturn;
    }

    if (lParam & GCS_RESULTSTR) 
    {
        if (!ped->fKorea && ped->wImeStatus & EIMES_GETCOMPSTRATONCE) 
        {
            goto ResultAtOnce;
        }

        ped->fResultProcess = TRUE;
        if ( ped->fReplaceCompChr ) 
        {
            //
            // we have a DBCS character to be replaced.
            // let's delete it before inserting the new one.
            //
            ich = (ped->fAnsi) ? 2 : 1;
            ped->fReplaceCompChr = FALSE;
            ped->ichMaxSel = min(ped->ichCaret + ich, ped->cch);
            ped->ichMinSel = ped->ichCaret;

            if ( Edit_DeleteText( ped ) > 0 ) 
            {
                if ( ped->fSingle ) 
                {
                    //
                    // Update the display
                    //
                    Edit_NotifyParent(ped, EN_UPDATE);
                    hdc = Edit_GetDC(ped,FALSE);
                    EditSL_DrawText(ped, hdc, 0);
                    Edit_ReleaseDC(ped,hdc,FALSE);
                    //
                    // Tell parent our text contents changed.
                    //
                    Edit_NotifyParent(ped, EN_CHANGE);
                }
            }
            Edit_SetCaretHandler( ped );
        }

    } 
    else if (lParam & CS_INSERTCHAR) 
    {

        //
        // If we are in the middle of a mousedown command, don't do anything.
        //
        if (ped->fMouseDown) 
        {
            return lReturn;
        }

        //
        // We can safely assume that interimm character is always DBCS.
        //
        ich = ( ped->fAnsi ) ? 2 : 1;

        if ( ped->fReplaceCompChr ) 
        {
            //
            // we have a character to be replaced.
            // let's delete it before inserting the new one.
            // when we have a composition characters, the
            // caret is placed before the composition character.
            //
            ped->ichMaxSel = min(ped->ichCaret+ich, ped->cch);
            ped->ichMinSel = ped->ichCaret;
        }

        //
        // let's delete current selected text or composition character
        //
        if ( ped->fSingle ) 
        {
            if ( Edit_DeleteText( ped ) > 0 ) 
            {
                fSLTextUpdated = TRUE;
            }
        } 
        else 
        {
            EditML_DeleteText( ped );
        }

        //
        // When the composition charcter is canceled, IME may give us NULL wParam,
        // with CS_INSERTCHAR flag on. We shouldn't insert a NULL character.
        //
        if ( wParam != 0 ) 
        {

            if ( ped->fAnsi ) 
            {
                TextBuf[0] = HIBYTE(LOWORD(wParam)); // leading byte
                TextBuf[1] = LOBYTE(LOWORD(wParam)); // trailing byte
                TextBuf[2] = '\0';
            } 
            else 
            {
                TextBuf[0] = LOBYTE(LOWORD(wParam));
                TextBuf[1] = HIBYTE(LOWORD(wParam));
                TextBuf[2] = '\0';
                TextBuf[3] = '\0';
            }

            if ( ped->fSingle ) 
            {
                iResult = EditSL_InsertText( ped, (LPSTR)TextBuf, ich );
                if (iResult == 0) 
                {
                    //
                    // Couldn't insert the text, for e.g. the text exceeded the limit.
                    //
                    MessageBeep(0);
                } 
                else if (iResult > 0) 
                {
                    //
                    // Remember we need to update the text.
                    //
                    fSLTextUpdated = TRUE;
                }

            } 
            else 
            {
                iResult = EditML_InsertText( ped, (LPSTR)TextBuf, ich, TRUE);
            }

            if ( iResult > 0 ) 
            {
                //
                // ped->fReplaceCompChr will be reset:
                //
                // 1) when the character is finalized.
                //    we will receive GCS_RESULTSTR
                //
                // 2) when the character is canceled.
                //
                //    we will receive WM_IME_COMPOSITION|CS_INSERTCHAR
                //    with wParam == 0 (in case of user types backspace
                //    at the first element of composition character).
                //
                //      or
                //
                //    we will receive WM_IME_ENDCOMPOSITION message
                //
                ped->fReplaceCompChr = TRUE;

                //
                // Caret should be placed BEFORE the composition
                // character.
                //
                ped->ichCaret = max( 0, (INT)ped->ichCaret - ich);
                Edit_SetCaretHandler( ped );
            } 
            else 
            {
                //
                // We failed to insert a character. We might run out
                // of memory, or reached to the text size limit. let's
                // cancel the composition character.
                //
                hImc = ImmGetContext(ped->hwnd);
                ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
                ImmReleaseContext(ped->hwnd, hImc);

                ped->fReplaceCompChr = FALSE;
                Edit_SetCaretHandler( ped );
            }
        } 
        else 
        {
            //
            // the composition character is canceled.
            //
            ped->fReplaceCompChr = FALSE;
            Edit_SetCaretHandler( ped );
        }

        //
        // We won't notify parent the text change
        // because the composition character has
        // not been finalized.
        //
        if ( fSLTextUpdated ) 
        {
            //
            // Update the display
            //
            Edit_NotifyParent(ped, EN_UPDATE);

            hdc = Edit_GetDC(ped,FALSE);

            if ( ped->fReplaceCompChr ) 
            {
                //
                // move back the caret to the original position
                // temporarily so that our new block cursor can
                // be located within the visible area of window.
                //
                ped->ichCaret = min( ped->cch, ped->ichCaret + ich);
                EditSL_ScrollText(ped, hdc);
                ped->ichCaret = max( 0, (INT)ped->ichCaret - ich);
            } 
            else 
            {
                EditSL_ScrollText(ped, hdc);
            }
            EditSL_DrawText(ped, hdc, 0);

            Edit_ReleaseDC(ped,hdc,FALSE);

            //
            // Tell parent our text contents changed.
            //
            Edit_NotifyParent(ped, EN_CHANGE);
        }
        return lReturn;
    }

    return DefWindowProc(ped->hwnd, WM_IME_COMPOSITION, wParam, lParam);
}


//---------------------------------------------------------------------------//
//
// HanjaKeyHandler
//
// VK_HANJA handler - Korean only
//
BOOL HanjaKeyHandler(PED ped)
{
    BOOL changeSelection = FALSE;

    if (ped->fKorea && !ped->fReadOnly) 
    {
        ICH oldCaret = ped->ichCaret;

        if (ped->fReplaceCompChr)
        {
            return FALSE;
        }

        if (ped->ichMinSel < ped->ichMaxSel)
        {
            ped->ichCaret = ped->ichMinSel;
        }

        if (!ped->cch || ped->cch == ped->ichCaret) 
        {
            ped->ichCaret = oldCaret;
            MessageBeep(MB_ICONEXCLAMATION);
            return FALSE;
        }

        if (ped->fAnsi) 
        {
            if (ImmEscapeA(GetKeyboardLayout(0), ImmGetContext(ped->hwnd),
                IME_ESC_HANJA_MODE, (Edit_Lock(ped) + ped->ichCaret * ped->cbChar))) 
            {
                changeSelection = TRUE;
            }
            else
            {
                ped->ichCaret = oldCaret;
            }

            Edit_Unlock(ped);
        }
        else 
        {
            if (ImmEscapeW(GetKeyboardLayout(0), ImmGetContext(ped->hwnd),
                IME_ESC_HANJA_MODE, (Edit_Lock(ped) + ped->ichCaret * ped->cbChar))) 
            {
                changeSelection = TRUE;
            }
            else
            {
                ped->ichCaret = oldCaret;
            }

            Edit_Unlock(ped);
        }
    }

    return changeSelection;
}



//---------------------------------------------------------------------------//
// Edit_RequestHandler()
//
// Handles WM_IME_REQUEST message originated by IME
//

#define MAX_ECDOCFEED 20


ICH Edit_ImeGetDocFeedMin(PED ped, LPSTR lpstr)
{
    ICH ich;


    if (ped->ichMinSel > MAX_ECDOCFEED) 
    {
        ich = ped->ichMinSel - MAX_ECDOCFEED;
        ich = Edit_AdjustIch(ped, lpstr, ich);
    } 
    else 
    {
        ich = 0;
    }

    return ich;
}

ICH Edit_ImeGetDocFeedMax(PED ped, LPSTR lpstr)
{
    ICH ich;

    if ((ped->cch - ped->ichMaxSel) > MAX_ECDOCFEED) 
    {
        ich = ped->ichMaxSel + MAX_ECDOCFEED;
        ich = Edit_AdjustIch(ped, lpstr, ich);
    } 
    else 
    {
        ich = ped->cch;
    }

    return ich;
}

LRESULT Edit_RequestHandler(PED ped, WPARAM dwSubMsg, LPARAM lParam)
{
    LRESULT lreturn = 0L;

    switch (dwSubMsg) 
    {
    case IMR_CONFIRMRECONVERTSTRING:

        //
        // CHECK VERSION of the structure
        //
        if (lParam && ((LPRECONVERTSTRING)lParam)->dwVersion != 0) 
        {
            TraceMsg(TF_STANDARD, "Edit_RequestHandler: RECONVERTSTRING dwVersion is not expected.",
                ((LPRECONVERTSTRING)lParam)->dwVersion);
            return 0L;
        }

        if (lParam && ped && ped->fFocus && ped->hText && ImmIsIME(GetKeyboardLayout(0))) 
        {
            LPVOID lpSrc;
            lpSrc = Edit_Lock(ped);
            if (lpSrc == NULL) 
            {
                TraceMsg(TF_STANDARD, "Edit_RequestHandler: LOCALLOCK(ped) failed.");
            } 
            else 
            {
                LPRECONVERTSTRING lpRCS = (LPRECONVERTSTRING)lParam;
                ICH ichStart;
                ICH ichEnd;
                UINT cchLen;

                ichStart = Edit_ImeGetDocFeedMin(ped, lpSrc);
                ichEnd = Edit_ImeGetDocFeedMax(ped, lpSrc);
                UserAssert(ichEnd >= ichStart);

                cchLen = ichEnd - ichStart;    // holds character count.

                Edit_Unlock(ped);

                if (lpRCS->dwStrLen != cchLen) 
                {
                    TraceMsg(TF_STANDARD, "Edit_RequestHandler: the given string length is not expected.");
                } 
                else 
                {
                    ICH ichSelStart;
                    ICH ichSelEnd;

                    ichSelStart = ichStart + (lpRCS->dwCompStrOffset  / ped->cbChar);
                    ichSelEnd = ichSelStart + lpRCS->dwCompStrLen;


                    (ped->fAnsi ? SendMessageA : SendMessageW)(ped->hwnd, EM_SETSEL, ichSelStart, ichSelEnd);

                    lreturn = 1L;
                }
            }
        }
        break;

    case IMR_RECONVERTSTRING:
        //
        // CHECK VERSION of the structure
        //
        if (lParam && ((LPRECONVERTSTRING)lParam)->dwVersion != 0) 
        {
            TraceMsg(TF_STANDARD, "UxEdit: Edit_RequestHandler: RECONVERTSTRING dwVersion is not expected.");

            return 0L;
        }

        if (ped && ped->fFocus && ped->hText && ImmIsIME(GetKeyboardLayout(0))) 
        {
            ICH ichStart;
            ICH ichEnd;
            UINT cchLen;
            UINT cchSelLen;
            LPVOID lpSrc;
            lpSrc = Edit_Lock(ped);
            if (lpSrc == NULL) 
            {
                TraceMsg(TF_STANDARD, "Edit_RequestHandler: LOCALLOCK(ped) failed.");
                return 0L;
            }

            ichStart = Edit_ImeGetDocFeedMin(ped, lpSrc);
            ichEnd = Edit_ImeGetDocFeedMax(ped, lpSrc);
            UserAssert(ichEnd >= ichStart);

            cchLen = ichEnd - ichStart;    // holds character count.
            cchSelLen = ped->ichMaxSel - ped->ichMinSel;    // holds character count.
            if (cchLen == 0) 
            {
                // if we have no selection,
                // just return 0.
                break;
            }

            UserAssert(ped->cbChar == sizeof(BYTE) || ped->cbChar == sizeof(WCHAR));

            // This Edit Control has selection.
            if (lParam == 0) 
            {
                //
                // IME just want to get required size for buffer.
                // cchLen + 1 is needed to reserve room for trailing L'\0'.
                //       ~~~~
                lreturn = sizeof(RECONVERTSTRING) + (cchLen + 1) * ped->cbChar;
            } 
            else 
            {
                LPRECONVERTSTRING lpRCS = (LPRECONVERTSTRING)lParam;
                LPVOID lpDest = (LPBYTE)lpRCS + sizeof(RECONVERTSTRING);

                // check buffer size
                // if the given buffer is smaller than actual needed size,
                // shrink our size to fit the buffer
                if ((INT)lpRCS->dwSize <= sizeof(RECONVERTSTRING) + cchLen * ped->cbChar) 
                {
                    TraceMsg(TF_STANDARD, "UxEdit: Edit_Request: ERR09");
                    cchLen = (lpRCS->dwSize - sizeof(RECONVERTSTRING)) / ped->cbChar - ped->cbChar;
                }

                lpRCS->dwStrOffset = sizeof(RECONVERTSTRING); // buffer begins just after RECONVERTSTRING
                lpRCS->dwCompStrOffset =
                lpRCS->dwTargetStrOffset = (ped->ichMinSel - ichStart) * ped->cbChar; // BYTE count offset
                lpRCS->dwStrLen = cchLen; // TCHAR count
                lpRCS->dwCompStrLen = 
                lpRCS->dwTargetStrLen = cchSelLen; // TCHAR count

                RtlCopyMemory(lpDest,
                              (LPBYTE)lpSrc + ichStart * ped->cbChar,
                              cchLen * ped->cbChar);
                // Null-Terminate the string
                if (ped->fAnsi) 
                {
                    LPBYTE psz = (LPBYTE)lpDest;
                    psz[cchLen] = '\0';
                } 
                else 
                {
                    LPWSTR pwsz = (LPWSTR)lpDest;
                    pwsz[cchLen] = L'\0';
                }
                Edit_Unlock(ped);
                // final buffer size
                lreturn = sizeof(RECONVERTSTRING) + (cchLen + 1) * ped->cbChar;

                Edit_InOutReconversionMode(ped, TRUE);
                Edit_ImmSetCompositionWindow(ped, 0, 0);
            }

        }
        break;
    }

    return lreturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\editml.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "edit.h"


//---------------------------------------------------------------------------//

//
// Number of lines to bump when reallocating index buffer
//
#define LINEBUMP 32

//
// Used for ML scroll updates
//
#define ML_REFRESH  0xffffffff


//---------------------------------------------------------------------------//
//
// Forwards
//
ICH  EditML_Line(PED, ICH);
VOID EditML_ShiftchLines(PED, ICH, int);
VOID EditML_Char(PED, DWORD, int);
VOID EditML_MouseMotion(PED, UINT, UINT, LPPOINT);
BOOL EditML_EnsureCaretVisible(PED);
VOID EditML_DrawText(PED, HDC, ICH, ICH, BOOL);
BOOL EditML_InsertCrCrLf(PED);
VOID EditML_StripCrCrLf(PED);
VOID EditML_SetHandle(PED, HANDLE);
LONG EditML_GetLine(PED, ICH, ICH, LPSTR);
ICH  EditML_LineIndex(PED, ICH);
ICH  EditML_LineLength(PED, ICH);
VOID EditML_SetSelection(PED, BOOL, ICH, ICH);
BOOL EditML_SetTabStops(PED, int, LPINT);
BOOL EditML_Undo(PED);
LONG EditML_Create(PED, LPCREATESTRUCT);


//---------------------------------------------------------------------------//
__inline void EditML_SanityCheck(PED ped)
{
    UNREFERENCED_PARAMETER(ped);    // For free build

    UserAssert(ped->cch >= ped->chLines[ped->cLines - 1]);
}


//---------------------------------------------------------------------------//
// 
// EditML_GetLineWidth
// 
// Returns the max width in a line.  Edit_TabTheTextOut() ensures that max
// width won't overflow.
//
UINT EditML_GetLineWidth(HDC hdc, LPSTR lpstr, int nCnt, PED ped)
{
    return Edit_TabTheTextOut(hdc, 0, 0, 0, 0, lpstr, nCnt, 0, ped, 0, ECT_CALC, NULL);
}


//---------------------------------------------------------------------------//
//
// EditML_Size
// 
// Handles resizing of the edit control window and updating thereof.
// 
// Sets the edit field's formatting area given the passed in "client area".
// We fudge it if it doesn't seem reasonable.
// 
VOID EditML_Size(PED ped, BOOL fRedraw)
{
    //
    // Calculate the # of lines we can fit in our rectangle.
    //
    ped->ichLinesOnScreen = (ped->rcFmt.bottom - ped->rcFmt.top) / ped->lineHeight;

    //
    // Make the format rectangle height an integral number of lines
    //
    ped->rcFmt.bottom = ped->rcFmt.top + ped->ichLinesOnScreen * ped->lineHeight;

    //
    // Rebuild the line array
    //
    if (ped->fWrap) 
    {
        EditML_BuildchLines(ped, 0, 0, FALSE, NULL, NULL);
        EditML_UpdateiCaretLine(ped);
    } 
    else 
    {
        EditML_Scroll(ped, TRUE,  ML_REFRESH, 0, fRedraw);
        EditML_Scroll(ped, FALSE, ML_REFRESH, 0, fRedraw);
    }
}


//---------------------------------------------------------------------------//
//
// EditML_CalcXOffset
// 
// Calculates the horizontal offset (indent) required for centered
// and right justified lines.
//
int EditML_CalcXOffset(PED ped, HDC hdc, int lineNumber)
{
    PSTR pText;
    ICH lineLength;
    ICH lineWidth;

    if (ped->format == ES_LEFT)
    {
        return 0;
    }

    lineLength = EditML_Line(ped, lineNumber);

    if (lineLength) 
    {
        pText = Edit_Lock(ped) + ped->chLines[lineNumber] * ped->cbChar;
        hdc = Edit_GetDC(ped, TRUE);
        lineWidth = EditML_GetLineWidth(hdc, pText, lineLength, ped);
        Edit_ReleaseDC(ped, hdc, TRUE);
        Edit_Unlock(ped);
    } 
    else 
    {
        lineWidth = 0;
    }

    //
    // If a SPACE or a TAB was eaten at the end of a line by EditML_BuildchLines
    // to prevent a delimiter appearing at the begining of a line, the
    // the following calculation will become negative causing this bug.
    // So, now, we take zero in such cases.
    // Fix for Bug #3566 --01/31/91-- SANKAR --
    //
    lineWidth = max(0, (int)(ped->rcFmt.right-ped->rcFmt.left-lineWidth));

    if (ped->format == ES_CENTER)
    {
        return (lineWidth / 2);
    }

    if (ped->format == ES_RIGHT) 
    {
        //
        // Subtract 1 so that the 1 pixel wide cursor will be in the visible
        // region on the very right side of the screen.
        //
        return max(0, (int)(lineWidth-1));
    }

    return 0;
}


//---------------------------------------------------------------------------//
//
// Edit_MoveSelection AorW
//
// Moves the selection character in the direction indicated. Assumes
// you are starting at a legal point, we decrement/increment the ich. Then,
// This decrements/increments it some more to get past CRLFs...
//
ICH Edit_MoveSelection(PED ped, ICH ich, BOOL fLeft)
{

    if (fLeft && ich > 0) 
    {
        //
        // Move left
        //
        ich = Edit_PrevIch( ped, NULL, ich );
        if (ich) 
        {
            if (ped->fAnsi) 
            {
                LPSTR pText;

                //
                // Check for CRLF or CRCRLF
                //
                pText = Edit_Lock(ped) + ich;

                //
                // Move before CRLF or CRCRLF
                //
                if (*(WORD UNALIGNED *)(pText - 1) == 0x0A0D) 
                {
                    ich--;
                    if (ich && *(pText - 2) == 0x0D)
                        ich--;
                }

                Edit_Unlock(ped);
            } 
            else 
            {
                LPWSTR pwText;

                //
                // Check for CRLF or CRCRLF
                //
                pwText = (LPWSTR)Edit_Lock(ped) + ich;

                //
                // Move before CRLF or CRCRLF
                //
                if (*(pwText - 1) == 0x0D && *pwText == 0x0A) 
                {
                    ich--;
                    if (ich && *(pwText - 2) == 0x0D)
                        ich--;
                }

                Edit_Unlock(ped);
            }
        }
    } 
    else if (!fLeft && ich < ped->cch) 
    {
        //
        // Move right.
        //
        ich = Edit_NextIch( ped, NULL, ich );
        if (ich < ped->cch) 
        {
            if (ped->fAnsi) 
            {
                LPSTR pText;
                pText = Edit_Lock(ped) + ich;

                //
                // Move after CRLF
                //
                if (*(WORD UNALIGNED *)(pText - 1) == 0x0A0D)
                {
                    ich++;
                }
                else 
                {
                    //
                    // Check for CRCRLF
                    //
                    if (ich && *(WORD UNALIGNED *)pText == 0x0A0D && *(pText - 1) == 0x0D)
                    {
                        ich += 2;
                    }
                }

                Edit_Unlock(ped);
            } 
            else 
            {
                LPWSTR pwText;
                pwText = (LPWSTR)Edit_Lock(ped) + ich;

                //
                // Move after CRLF
                //
                if (*(pwText - 1) == 0x0D && *pwText == 0x0A)
                {
                    ich++;
                }
                else 
                {
                    //
                    // Check for CRCRLF
                    //
                    if (ich && *(pwText - 1) == 0x0D && *pwText == 0x0D &&
                            *(pwText + 1) == 0x0A)
                    {
                        ich += 2;
                    }
                }

                Edit_Unlock(ped);
            }
        }
    }

    return ich;
}


//---------------------------------------------------------------------------//
//
// Edit_MoveSelectionRestricted AorW
// 
// Moves the selection like Edit_MoveSelection, but also obeys limitations
// imposed by some languages such as Thai, where the cursor cannot stop
// between a character and it's attached vowel or tone marks.
//
// Only called if the language pack is loaded.
//
ICH Edit_MoveSelectionRestricted(PED ped, ICH ich, BOOL fLeft)
{
    PSTR pText;
    HDC  hdc;
    ICH  ichResult;

    pText = Edit_Lock(ped);
    hdc = Edit_GetDC(ped, TRUE);
    ichResult = ped->pLpkEditCallout->EditMoveSelection((PED0)ped, hdc, pText, ich, fLeft);
    Edit_ReleaseDC(ped, hdc, TRUE);
    Edit_Unlock(ped);

    return ichResult;
}


//---------------------------------------------------------------------------//
//
// EditML_SetCaretPosition AorW
//
// If the window has the focus, find where the caret belongs and move
// it there.
//
VOID EditML_SetCaretPosition(PED ped, HDC hdc)
{
    POINT position;
    BOOL prevLine;
    int  x = -20000;
    int  y = -20000;

    //
    // We will only position the caret if we have the focus since we don't want
    // to move the caret while another window could own it.
    //
    if (!ped->fFocus || !IsWindowVisible(ped->hwnd))
    {
         return;
    }

    //
    // Find the position of the caret
    //
    if (!ped->fCaretHidden &&
        ((ICH) ped->iCaretLine >= ped->ichScreenStart) &&
        ((ICH) ped->iCaretLine <  (ped->ichScreenStart + ped->ichLinesOnScreen))) 
    {
        RECT rcRealFmt;

        if (ped->f40Compat)
        {
            GetClientRect(ped->hwnd, &rcRealFmt);
            IntersectRect(&rcRealFmt, &rcRealFmt, &ped->rcFmt);
        } 
        else 
        {
            CopyRect(&rcRealFmt, &ped->rcFmt);
        }

        if (ped->cLines - 1 != ped->iCaretLine && ped->ichCaret == ped->chLines[ped->iCaretLine + 1]) 
        {
            prevLine = TRUE;
        } 
        else 
        {
            prevLine = FALSE;
        }

        EditML_IchToXYPos(ped, hdc, ped->ichCaret, prevLine, &position);

        if ( (position.y >= rcRealFmt.top) &&
             (position.y <= rcRealFmt.bottom - ped->lineHeight)) 
        {
            int xPos = position.x;
            int cxCaret;
 
            SystemParametersInfo(SPI_GETCARETWIDTH, 0, (LPVOID)&cxCaret, 0);

            if (ped->fWrap ||
                ((xPos > (rcRealFmt.left - cxCaret)) &&
                 (xPos <= rcRealFmt.right))) 
            {
                //
                // Make sure the caret is in the visible region if word
                // wrapping. This is so that the caret will be visible if the
                // line ends with a space.
                //
                x = max(xPos, rcRealFmt.left);
                x = min(x, rcRealFmt.right - cxCaret);
                y = position.y;
            }
        }
    }

    if (ped->pLpkEditCallout) 
    {
        SetCaretPos(x + ped->iCaretOffset, y);
    } 
    else 
    {
        SetCaretPos(x, y);
    }

    //
    // FE_IME : EditML_SetCaretPosition -- ImmSetCompositionWindow(CFS_RECT)
    //
    if (g_fIMMEnabled && ImmIsIME(GetKeyboardLayout(0))) 
    {
        if (x != -20000 && y != -20000) 
        {
            Edit_ImmSetCompositionWindow(ped, x, y);
        }
    }
}


//---------------------------------------------------------------------------//
//
// EditML_Line
//
// Returns the length of the line (cch) given by lineNumber ignoring any
// CRLFs in the line.
//
ICH EditML_Line(PED ped, ICH lineNumber) 
{
    ICH result;

    if (lineNumber >= ped->cLines)
    {
        return 0;
    }

    if (lineNumber == ped->cLines - 1) 
    {
        //
        // Since we can't have a CRLF on the last line
        //
        return (ped->cch - ped->chLines[ped->cLines - 1]);
    } 
    else 
    {
        result = ped->chLines[lineNumber + 1] - ped->chLines[lineNumber];
        TraceMsg(TF_STANDARD, "Edit: MLLine result=%d", result);

        //
        // Now check for CRLF or CRCRLF at end of line
        //
        if (result > 1) 
        {
            if (ped->fAnsi) 
            {
                LPSTR pText;

                pText = Edit_Lock(ped) + ped->chLines[lineNumber + 1] - 2;
                if (*(WORD UNALIGNED *)pText == 0x0A0D) 
                {
                    result -= 2;
                    if (result && *(--pText) == 0x0D)
                    {
                        //
                        // In case there was a CRCRLF
                        //
                        result--;
                    }
                }
            } 
            else 
            {
                LPWSTR pwText;

                pwText = (LPWSTR)Edit_Lock(ped) + (ped->chLines[lineNumber + 1] - 2);
                if (*(DWORD UNALIGNED *)pwText == 0x000A000D) 
                {
                    result = result - 2;
                    if (result && *(--pwText) == 0x0D)
                    {
                        //
                        // In case there was a CRCRLF
                        //
                        result--;
                    }
                }

            }

            Edit_Unlock(ped);
        }
    }

    return result;
}


//---------------------------------------------------------------------------//
//
// EditML_IchToLine AorW
//
// Returns the line number (starting from 0) which contains the given
// character index. If ich is -1, return the line the first char in the
// selection is on (the caret if no selection)
//
INT EditML_IchToLine(PED ped, ICH ich)
{
    int iLo, iHi, iLine;

    iLo = 0;
    iHi = ped->cLines;

    if (ich == (ICH)-1)
    {
        ich = ped->ichMinSel;
    }

    while (iLo < iHi - 1) 
    {
        iLine = max((iHi - iLo)/2, 1) + iLo;

        if (ped->chLines[iLine] > ich) 
        {
            iHi = iLine;
        } 
        else 
        {
            iLo = iLine;
        }
    }

    return iLo;
}


//---------------------------------------------------------------------------//
//
// EditML_IchToYPos
//
// Given an ich, return its y coordinate with respect to the top line
// displayed in the window. If prevLine is TRUE and if the ich is at the
// beginning of the line, return the y coordinate of the
// previous line (if it is not a CRLF).
// 
// Added for the LPK (3Dec96) - with an LPK installed, calculating X position is
// a far more processor intensive job. Where only the Y position is required
// this routine should be called instead of EditML_IchToXYPos.
// 
// Called only when LPK installed.
//
INT EditML_IchToYPos( PED  ped, ICH  ich, BOOL prevLine)
{
    int  iline;
    int  yPosition;
    PSTR pText;

    //
    // Determine what line the character is on
    //
    iline = EditML_IchToLine(ped, ich);

    //
    // Calc. the yPosition now. Note that this may change by the height of one
    // char if the prevLine flag is set and the ICH is at the beginning of a line.
    //
    yPosition = (iline - ped->ichScreenStart) * ped->lineHeight + ped->rcFmt.top;

    pText = Edit_Lock(ped);
    if (prevLine && iline && (ich == ped->chLines[iline]) &&
            (!AWCOMPARECHAR(ped, pText + (ich - 2) * ped->cbChar, 0x0D) ||
             !AWCOMPARECHAR(ped, pText + (ich - 1) * ped->cbChar, 0x0A))) 
    {
        //
        // First char in the line. We want Y position of the previous
        // line if we aren't at the 0th line.
        //
        iline--;

        yPosition = yPosition - ped->lineHeight;
    }

    Edit_Unlock(ped);

    return yPosition;
}


//---------------------------------------------------------------------------//
//
// EditML_IchToXYPos
//
// Given an ich, return its x,y coordinates with respect to the top
// left character displayed in the window. Returns the coordinates of the top
// left position of the char. If prevLine is TRUE then if the ich is at the
// beginning of the line, we will return the coordinates to the right of the
// last char on the previous line (if it is not a CRLF).
//
VOID EditML_IchToXYPos(PED ped, HDC hdc, ICH ich, BOOL prevLine, LPPOINT ppt)
{
    int iline;
    ICH cch;
    int xPosition, yPosition;
    int xOffset;

    //
    // For horizontal scroll displacement on left justified text and
    // for indent on centered or right justified text
    //
    PSTR pText, pTextStart, pLineStart;

    //
    // Determine what line the character is on
    //
    iline = EditML_IchToLine(ped, ich);

    //
    // Calc. the yPosition now. Note that this may change by the height of one
    // char if the prevLine flag is set and the ICH is at the beginning of a line.
    //
    yPosition = (iline - ped->ichScreenStart) * ped->lineHeight + ped->rcFmt.top;

    //
    // Now determine the xPosition of the character
    //
    pTextStart = Edit_Lock(ped);

    if (prevLine && iline && (ich == ped->chLines[iline]) &&
            (!AWCOMPARECHAR(ped, pTextStart + (ich - 2) * ped->cbChar, 0x0D) ||
            !AWCOMPARECHAR(ped, pTextStart + (ich - 1) * ped->cbChar, 0x0A))) 
    {
        //
        // First char in the line. We want text extent upto end of the previous
        // line if we aren't at the 0th line.
        //
        iline--;

        yPosition = yPosition - ped->lineHeight;
        pLineStart = pTextStart + ped->chLines[iline] * ped->cbChar;

        //
        // Note that we are taking the position in front of any CRLFs in the
        // text.
        //
        cch = EditML_Line(ped, iline);

    } 
    else 
    {
        pLineStart = pTextStart + ped->chLines[iline] * ped->cbChar;
        pText = pTextStart + ich * ped->cbChar;

        //
        // Strip off CRLF or CRCRLF. Note that we may be pointing to a CR but in
        // which case we just want to strip off a single CR or 2 CRs.
        //

        //
        // We want pText to point to the first CR at the end of the line if
        // there is one. Thus, we will get an xPosition to the right of the last
        // visible char on the line otherwise we will be to the left of
        // character ich.
        //

        //
        // Check if we at the end of text
        //
        if (ich < ped->cch) 
        {
            if (ped->fAnsi) 
            {
                if (ich && *(WORD UNALIGNED *)(pText - 1) == 0x0A0D) 
                {
                    pText--;
                    if (ich > 2 && *(pText - 1) == 0x0D)
                    {
                        pText--;
                    }
                }
            } 
            else 
            {
                LPWSTR pwText = (LPWSTR)pText;

                if (ich && *(DWORD UNALIGNED *)(pwText - 1) == 0x000A000D) 
                {
                    pwText--;
                    if (ich > 2 && *(pwText - 1) == 0x0D)
                    {
                        pwText--;
                    }
                }

                pText = (LPSTR)pwText;
            }
        }

        if (pText < pLineStart)
        {
            pText = pLineStart;
        }

        cch = (ICH)(pText - pLineStart)/ped->cbChar;
    }

    //
    // Find out how many pixels we indent the line for funny formats
    //
    if (ped->pLpkEditCallout) 
    {
        //
        // Must find position at start of character offset cch from start of line.
        // This depends on the layout and the reading order
        //
        xPosition = ped->pLpkEditCallout->EditIchToXY(
                          (PED0)ped, hdc, pLineStart, EditML_Line(ped, iline), cch);
    } 
    else 
    {
        if (ped->format != ES_LEFT) 
        {
            xOffset = EditML_CalcXOffset(ped, hdc, iline);
        } 
        else 
        {
            xOffset = -(int)ped->xOffset;
        }

        xPosition = ped->rcFmt.left + xOffset +
                EditML_GetLineWidth(hdc, pLineStart, cch, ped);
    }

    Edit_Unlock(ped);

    ppt->x = xPosition;
    ppt->y = yPosition;

    return;
}


//---------------------------------------------------------------------------//
//
// EditML_MouseToIch AorW
//
// Returns the closest cch to where the mouse point is.  Also optionally
// returns lineindex in pline (So that we can tell if we are at the beginning
// of the line or end of the previous line.)
//
ICH EditML_MouseToIch(PED ped, HDC hdc, LPPOINT mousePt, LPICH pline)
{
    int xOffset;
    LPSTR pLineStart;
    int height = mousePt->y;
    int line; //WASINT
    int width = mousePt->x;
    ICH cch;
    ICH cLineLength;
    ICH cLineLengthNew;
    ICH cLineLengthHigh;
    ICH cLineLengthLow;
    ICH cLineLengthTemp;
    int textWidth;
    int iCurWidth;
    int lastHighWidth, lastLowWidth;

    //
    // First determine which line the mouse is pointing to.
    //
    line = ped->ichScreenStart;
    if (height <= ped->rcFmt.top) 
    {
        //
        // Either return 0 (the very first line, or one line before the top line
        // on the screen. Note that these are signed mins and maxes since we
        // don't expect (or allow) more than 32K lines.
        //
        line = max(0, line-1);
    } 
    else if (height >= ped->rcFmt.bottom) 
    {
        //
        // Are we below the last line displayed
        //
        line = min(line+(int)ped->ichLinesOnScreen, (int)(ped->cLines-1));
    } 
    else 
    {
        //
        // We are somewhere on a line visible on screen
        //
        line = min(line + (int)((height - ped->rcFmt.top) / ped->lineHeight),
                (int)(ped->cLines - 1));
    }

    //
    // Now determine what horizontal character the mouse is pointing to.
    //
    pLineStart = Edit_Lock(ped) + ped->chLines[line] * ped->cbChar;
    cLineLength = EditML_Line(ped, line); // Length is sans CRLF or CRCRLF
    TraceMsg(TF_STANDARD, "Edit: EditML_Line(ped=%x, line=%d) returned %d", ped, line, cLineLength);
    UserAssert((int)cLineLength >= 0);

    //
    // If the language pack is loaded, visual and logical character order
    // may differ.
    //
    if (ped->pLpkEditCallout) 
    {
        //
        // Use the language pack to find the character nearest the cursor.
        //
        cch = ped->chLines[line] + ped->pLpkEditCallout->EditMouseToIch
            ((PED0)ped, hdc, pLineStart, cLineLength, width);
    } 
    else 
    {
        //
        // xOffset will be a negative value for center and right justified lines.
        // ie. We will just displace the lines left by the amount of indent for
        // right and center justification. Note that ped->xOffset will be 0 for
        // these lines since we don't support horizontal scrolling with them.
        //
        if (ped->format != ES_LEFT) 
        {
            xOffset = EditML_CalcXOffset(ped, hdc, line);
        } 
        else 
        {
            //
            // So that we handle a horizontally scrolled window for left justified
            // text.
            //
            xOffset = 0;
        }

        width = width - xOffset;

        //
        // The code below is tricky... I depend on the fact that ped->xOffset is 0
        // for right and center justified lines
        //

        //
        // Now find out how many chars fit in the given width
        //
        if (width >= ped->rcFmt.right) 
        {
            //
            // Return 1+last char in line or one plus the last char visible
            //
            cch = Edit_CchInWidth(ped, hdc, pLineStart, cLineLength,
                    ped->rcFmt.right - ped->rcFmt.left + ped->xOffset, TRUE);

            //
            // Consider DBCS in case of width >= ped->rcFmt.right
            //
            // Since Edit_CchInWidth and EditML_LineLength takes care of DBCS, we only need to
            // worry about if the last character is a double byte character or not.
            //
            // cch = ped->chLines[line] + min( Edit_NextIch(ped, pLineStart, cch), cLineLength);
            //
            // we need to adjust the position. LiZ -- 5/5/93
            //
            if (ped->fAnsi && ped->fDBCS) 
            {
                ICH cch2 = min(cch+1,cLineLength);
                if (Edit_AdjustIch(ped, pLineStart, cch2) != cch2) 
                {
                    //
                    // Displayed character on the right edge is DBCS
                    //
                    cch = min(cch+2,cLineLength);
                } 
                else 
                {
                    cch = cch2;
                }

                cch += ped->chLines[line];
            } 
            else 
            {
                cch = ped->chLines[line] + min(cch + 1, cLineLength);
            }
        } 
        else if (width <= ped->rcFmt.left + ped->aveCharWidth / 2) 
        {
            //
            // Return first char in line or one minus first char visible. Note that
            // ped->xOffset is 0 for right and centered text so we will just return
            // the first char in the string for them. (Allow a avecharwidth/2
            // positioning border so that the user can be a little off...
            //
            cch = Edit_CchInWidth(ped, hdc, pLineStart, cLineLength, ped->xOffset, TRUE);
            if (cch)
            {
                cch--;
            }

            cch = Edit_AdjustIch( ped, pLineStart, cch );
            cch += ped->chLines[line];
        } 
        else 
        {
            if (cLineLength == 0) 
            {
                cch = ped->chLines[line];
                goto edUnlock;
            }

            iCurWidth = width + ped->xOffset - ped->rcFmt.left;

            //
            // If the user clicked past the end of the text, return the last character
            //
            lastHighWidth = EditML_GetLineWidth(hdc, pLineStart, cLineLength, ped);
            if (lastHighWidth <= iCurWidth) 
            {
                cLineLengthNew = cLineLength;
                goto edAdjust;
            }

            //
            // Now the mouse is somewhere on the visible portion of the text
            // remember cch contains the length of the line.
            //
            cLineLengthLow = 0;
            cLineLengthHigh = cLineLength + 1;
            lastLowWidth = 0;

            while (cLineLengthLow < cLineLengthHigh - 1) 
            {
                cLineLengthNew = (cLineLengthHigh + cLineLengthLow) / 2;

                if (ped->fAnsi && ped->fDBCS) 
                {
                    //
                    // EditML_GetLineWidth returns meaningless value for truncated DBCS.
                    //
                    cLineLengthTemp = Edit_AdjustIch(ped, pLineStart, cLineLengthNew);
                    textWidth = EditML_GetLineWidth(hdc, pLineStart, cLineLengthTemp, ped);

                } 
                else 
                {
                    textWidth = EditML_GetLineWidth(hdc, pLineStart, cLineLengthNew, ped);
                }

                if (textWidth > iCurWidth) 
                {
                    cLineLengthHigh = cLineLengthNew;
                    lastHighWidth = textWidth;
                } 
                else 
                {
                    cLineLengthLow = cLineLengthNew;
                    lastLowWidth = textWidth;
                }
            }

            //
            // When the while ends, you can't know the exact desired position.
            // Try to see if the mouse pointer was on the farest half
            // of the char we got and if so, adjust cch.
            //
            if (cLineLengthLow == cLineLengthNew) 
            {
                //
                // Need to compare with lastHighWidth
                //
                if ((lastHighWidth - iCurWidth) < (iCurWidth - textWidth)) 
                {
                    cLineLengthNew++;
                }
            } 
            else 
            {
                //
                // Need to compare with lastLowHigh
                //
                if ((iCurWidth - lastLowWidth) < (textWidth - iCurWidth)) 
                {
                    cLineLengthNew--;
                }
            }
edAdjust:
            cLineLength = Edit_AdjustIch( ped, pLineStart, cLineLengthNew );

            cch = ped->chLines[line] + cLineLength;
        }
    }

edUnlock:
    Edit_Unlock(ped);

    if (pline) 
    {
        *pline = line;
    }

    return cch;
}


//---------------------------------------------------------------------------//
//
// EditML_ChangeSelection AorW
// 
// Changes the current selection to have the specified starting and
// ending values. Properly highlights the new selection and unhighlights
// anything deselected. If NewMinSel and NewMaxSel are out of order, we swap
// them. Doesn't update the caret position.
//
VOID EditML_ChangeSelection(PED ped, HDC hdc, ICH ichNewMinSel, ICH ichNewMaxSel)
{

    ICH temp;
    ICH ichOldMinSel, ichOldMaxSel;

    if (ichNewMinSel > ichNewMaxSel) 
    {
        temp = ichNewMinSel;
        ichNewMinSel = ichNewMaxSel;
        ichNewMaxSel = temp;
    }

    ichNewMinSel = min(ichNewMinSel, ped->cch);
    ichNewMaxSel = min(ichNewMaxSel, ped->cch);

    //
    // Save the current selection
    //
    ichOldMinSel = ped->ichMinSel;
    ichOldMaxSel = ped->ichMaxSel;

    //
    // Set new selection
    //
    ped->ichMinSel = ichNewMinSel;
    ped->ichMaxSel = ichNewMaxSel;

    //
    // This finds the XOR of the old and new selection regions and redraws it.
    // There is nothing to repaint if we aren't visible or our selection
    // is hidden.
    //
    if (IsWindowVisible(ped->hwnd) && (ped->fFocus || ped->fNoHideSel)) 
    {

        SELBLOCK Blk[2];
        int i;

        if (ped->fFocus) 
        {
            HideCaret(ped->hwnd);
        }

        Blk[0].StPos = ichOldMinSel;
        Blk[0].EndPos = ichOldMaxSel;
        Blk[1].StPos = ped->ichMinSel;
        Blk[1].EndPos = ped->ichMaxSel;

        if (Edit_CalcChangeSelection(ped, ichOldMinSel, ichOldMaxSel, (LPSELBLOCK)&Blk[0], (LPSELBLOCK)&Blk[1])) 
        {
            //
            // Paint both Blk[0] and Blk[1], if they exist
            //
            for (i = 0; i < 2; i++) 
            {
                if (Blk[i].StPos != 0xFFFFFFFF)
                    EditML_DrawText(ped, hdc, Blk[i].StPos, Blk[i].EndPos, TRUE);
            }
        }

        //
        // Update caret.
        //
        EditML_SetCaretPosition(ped, hdc);

        if (ped->fFocus) 
        {
            ShowCaret(ped->hwnd);
        }
    }
}


//---------------------------------------------------------------------------//
//
// EditML_UpdateiCaretLine AorW
// 
// This updates the ped->iCaretLine field from the ped->ichCaret;
// Also, when the caret gets to the beginning of next line, pop it up to
// the end of current line when inserting text;
//
VOID EditML_UpdateiCaretLine(PED ped)
{
    PSTR pText;

    ped->iCaretLine = EditML_IchToLine(ped, ped->ichCaret);

    //
    // If caret gets to beginning of next line, pop it up to end of current line
    // when inserting text.
    //
    pText = Edit_Lock(ped) +
            (ped->ichCaret - 1) * ped->cbChar;
    if (ped->iCaretLine && ped->chLines[ped->iCaretLine] == ped->ichCaret &&
            (!AWCOMPARECHAR(ped, pText - ped->cbChar, 0x0D) ||
            !AWCOMPARECHAR(ped, pText, 0x0A)))
    {
        ped->iCaretLine--;
    }

    Edit_Unlock(ped);
}


//---------------------------------------------------------------------------//
//
// EditML_InsertText AorW
//
// Adds up to cchInsert characters from lpText to the ped starting at
// ichCaret. If the ped only allows a maximum number of characters, then we
// will only add that many characters to the ped. The number of characters
// actually added is return ed (could be 0). If we can't allocate the required
// space, we notify the parent with EN_ERRSPACE and no characters are added.
// do some stuff faster since we will be getting only one or two chars of input.
//
ICH EditML_InsertText(PED ped, LPSTR lpText, ICH cchInsert, BOOL fUserTyping)
{
    HDC hdc;
    ICH validCch = cchInsert;
    ICH oldCaret = ped->ichCaret;
    int oldCaretLine = ped->iCaretLine;
    BOOL fCRLF = FALSE;
    LONG ll, hl;
    POINT xyPosInitial;
    POINT xyPosFinal;
    HWND hwndSave = ped->hwnd;
    UNDO undo;
    ICH validCchTemp;

    xyPosInitial.x=0;
    xyPosInitial.y=0;
    xyPosFinal.x=0;
    xyPosFinal.y=0;

    if (validCch == 0)
    {
        return 0;
    }

    if (ped->cchTextMax <= ped->cch) 
    {
        //
        // When the max chars is reached already, notify parent
        // Fix for Bug #4183 -- 02/06/91 -- SANKAR --
        //
        Edit_NotifyParent(ped,EN_MAXTEXT);
        return 0;
    }

    //
    // Limit the amount of text we add
    //
    validCch = min(validCch, ped->cchTextMax - ped->cch);

    //
    // Make sure we don't split a CRLF in half
    //
    if (validCch) 
    {
        if (ped->fAnsi) 
        {
            if (*(WORD UNALIGNED *)(lpText + validCch - 1) == 0x0A0D)
            {
                validCch--;
            }
        } 
        else 
        {
            if (*(DWORD UNALIGNED *)(lpText + (validCch - 1) * ped->cbChar) == 0x000A000D)
            {
                validCch--;
            }
        }
    }

    if (!validCch) 
    {
        //
        // When the max chars is reached already, notify parent
        // Fix for Bug #4183 -- 02/06/91 -- SANKAR --
        //
        Edit_NotifyParent(ped,EN_MAXTEXT);
        return 0;
    }

    if (validCch == 2) 
    {
        if (ped->fAnsi) 
        {
            if (*(WORD UNALIGNED *)lpText == 0x0A0D)
            {
                fCRLF = TRUE;
            }
        } 
        else 
        {
            if (*(DWORD UNALIGNED *)lpText == 0x000A000D)
            {
                fCRLF = TRUE;
            }
        }
    }

    //
    // Save current undo state always, but clear it out only if !AutoVScroll
    //
    Edit_SaveUndo(Pundo(ped), (PUNDO)&undo, !ped->fAutoVScroll);

    hdc = Edit_GetDC(ped, FALSE);

    //
    // We only need the y position. Since with an LPK loaded
    // calculating the x position is an intensive job, just
    // call EditML_IchToYPos.
    //
    if (ped->cch)
    {
        if (ped->pLpkEditCallout)
        {
            xyPosInitial.y = EditML_IchToYPos(ped, ped->cch-1, FALSE);
        }
        else
        {
            EditML_IchToXYPos(ped, hdc, ped->cch - 1, FALSE, &xyPosInitial);
        }
    }

    //
    // Insert the text
    //
    validCchTemp = validCch;    // may not be needed, but just for precautions..
    if (!Edit_InsertText(ped, lpText, &validCchTemp)) 
    {
        //
        // Restore previous undo buffer if it was cleared
        //
        if (!ped->fAutoVScroll)
        {
            Edit_SaveUndo((PUNDO)&undo, Pundo(ped), FALSE);
        }

        Edit_ReleaseDC(ped, hdc, FALSE);
        Edit_NotifyParent(ped, EN_ERRSPACE);

        return 0;
    }

#if DBG
    if (validCch != validCchTemp) 
    {
        //
        // All characters in lpText has not been inserted to ped.
        // This could happen when cch is close to cchMax.
        // Better revisit this after NT5 ships.
        //
        TraceMsg(TF_STANDARD, "Edit: EditML_InsertText: validCch is changed (%x -> %x) in Edit_InsertText.",
            validCch, validCchTemp);
    }
#endif

    //
    // Note that ped->ichCaret is updated by Edit_InsertText
    //
    EditML_BuildchLines(ped, (ICH)oldCaretLine, (int)validCch, fCRLF?(BOOL)FALSE:fUserTyping, &ll, &hl);

    if (ped->cch)
    {
        //
        // We only need the y position. Since with an LPK loaded
        // calculating the x position is an intensive job, just
        // call EditML_IchToYPos.
        if (ped->pLpkEditCallout)
        {
            xyPosFinal.y = EditML_IchToYPos(ped, ped->cch-1, FALSE);
        }
        else
        {
            EditML_IchToXYPos(ped, hdc, ped->cch - 1, FALSE,&xyPosFinal);
        }
    }

    if (xyPosFinal.y < xyPosInitial.y && ((ICH)ped->ichScreenStart) + ped->ichLinesOnScreen >= ped->cLines - 1) 
    {
        RECT rc;

        CopyRect((LPRECT)&rc, (LPRECT)&ped->rcFmt);
        rc.top = xyPosFinal.y + ped->lineHeight;
        if (ped->pLpkEditCallout) 
        {
            int xFarOffset = ped->xOffset + ped->rcFmt.right - ped->rcFmt.left;

            //
            // Include left or right margins in display unless clipped
            // by horizontal scrolling.
            //
            if (ped->wLeftMargin) 
            {
                if (!(ped->format == ES_LEFT     // Only ES_LEFT (Nearside alignment) can get clipped
                      && (   (!ped->fRtoLReading && ped->xOffset > 0)  // LTR and first char not fully in view
                          || ( ped->fRtoLReading && xFarOffset < ped->maxPixelWidth)))) //RTL and last char not fully in view
                { 
                    rc.left  -= ped->wLeftMargin;
                }
            }

            //
            // Process right margin
            //
            if (ped->wRightMargin) 
            {
                if (!(ped->format == ES_LEFT     // Only ES_LEFT (Nearside alignment) can get clipped
                      && (( ped->fRtoLReading && ped->xOffset > 0)  // RTL and first char not fully in view
                          || (!ped->fRtoLReading && xFarOffset < ped->maxPixelWidth)))) // LTR and last char not fully in view
                { 
                    rc.right += ped->wRightMargin;
                }
            }
        }

        InvalidateRect(ped->hwnd, (LPRECT)&rc, TRUE);
    }

    if (!ped->fAutoVScroll) 
    {
        if (ped->ichLinesOnScreen < ped->cLines) 
        {
            EditML_Undo(ped);
            Edit_EmptyUndo(Pundo(ped));

            Edit_SaveUndo(&undo, Pundo(ped), FALSE);

            MessageBeep(0);
            Edit_ReleaseDC(ped, hdc, FALSE);

            //
            // When the max lines is reached already, notify parent
            // Fix for Bug #7586 -- 10/14/91 -- SANKAR --
            //
            Edit_NotifyParent(ped,EN_MAXTEXT);

            return 0;
        } 
        else 
        {
            Edit_EmptyUndo(&undo);
        }
    }

    if (fUserTyping && ped->fWrap) 
    {
        //
        // To avoid oldCaret points intermediate of DBCS character,
        // adjust oldCaret position if necessary.
        //
        // !!!CR If EditML_BuildchLines() returns reasonable value ( and I think
        //       it does), we don't probably need this. Check this out later.
        //
        if (ped->fDBCS && ped->fAnsi) 
        {
            oldCaret = Edit_AdjustIch(ped,
                                   Edit_Lock(ped),
                                   min((ICH)LOWORD(ll),oldCaret));
        } 
        else 
        {
            oldCaret = min((ICH)LOWORD(ll), oldCaret);
        }
    }

    //
    // Update ped->iCaretLine properly.
    //
    EditML_UpdateiCaretLine(ped);

    Edit_NotifyParent(ped, EN_UPDATE);

    //
    // Make sure window still exists.
    //
    if (!IsWindow(hwndSave))
    {
        return 0;
    }

    if (IsWindowVisible(ped->hwnd)) 
    {
        //
        // If the current font has negative A widths, we may have to start
        // drawing a few characters before the oldCaret position.
        //
        if (ped->wMaxNegAcharPos) 
        {
            int iLine = EditML_IchToLine(ped, oldCaret);
            oldCaret = max( ((int)(oldCaret - ped->wMaxNegAcharPos)),
                          ((int)(ped->chLines[iLine])));
        }

        //
        // Redraw to end of screen/text if CRLF or large insert
        //
        if (fCRLF || !fUserTyping) 
        {
            //
            // Redraw to end of screen/text if crlf or large insert.
            //
            EditML_DrawText(ped, hdc, (fUserTyping ? oldCaret : 0), ped->cch, FALSE);
        } 
        else
        {
            EditML_DrawText(ped, hdc, oldCaret, max(ped->ichCaret, (ICH)hl), FALSE);
        }
    }

    Edit_ReleaseDC(ped, hdc, FALSE);

    //
    // Make sure we can see the cursor
    //
    EditML_EnsureCaretVisible(ped);

    ped->fDirty = TRUE;

    Edit_NotifyParent(ped, EN_CHANGE);

    if (validCch < cchInsert)
    {
        Edit_NotifyParent(ped, EN_MAXTEXT);
    }

    if (validCch) 
    {
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }

    //
    // Make sure the window still exists.
    //
    return IsWindow(hwndSave) ? validCch : 0;
}


//---------------------------------------------------------------------------//
//
// EditML_ReplaceSel
// 
// Replaces currently selected text with the passed in text, WITH UNDO
// CAPABILITIES.
//
VOID EditML_ReplaceSel(PED ped, LPSTR lpText)
{
    ICH  cchText;

    //
    // Delete text, which will put it into the clean undo buffer.
    //
    Edit_EmptyUndo(Pundo(ped));
    EditML_DeleteText(ped);

    //
    // B#3356
    // Some apps do "clear" by selecting all of the text, then replacing
    // it with "", in which case EditML_InsertText() will return 0.  But that
    // doesn't mean failure...
    //
    if ( ped->fAnsi )
    {
        cchText = strlen(lpText);
    }
    else
    {
        cchText = wcslen((LPWSTR)lpText);
    }

    if (cchText) 
    {
        BOOL fFailed;
        UNDO undo;
        HWND hwndSave;

        //
        // B#1385,1427
        // Save undo buffer, but DO NOT CLEAR IT.  We want to restore it
        // if insertion fails due to OOM.
        //
        Edit_SaveUndo(Pundo(ped), (PUNDO)&undo, FALSE);

        hwndSave = ped->hwnd;
        fFailed = (BOOL) !EditML_InsertText(ped, lpText, cchText, FALSE);
        if (!IsWindow(hwndSave))
        {
            return;
        }

        if (fFailed) 
        {
            //
            // UNDO the previous edit
            //
            Edit_SaveUndo((PUNDO)&undo, Pundo(ped), FALSE);
            EditML_Undo(ped);
        }
    }
}


//---------------------------------------------------------------------------//
// 
// EditML_DeleteText AorW
//
// Deletes the characters between ichMin and ichMax. Returns the
// number of characters we deleted.
//
ICH EditML_DeleteText(PED ped)
{
    ICH minSel = ped->ichMinSel;
    ICH maxSel = ped->ichMaxSel;
    ICH cchDelete;
    HDC hdc;
    int minSelLine;
    int maxSelLine;
    POINT xyPos;
    RECT rc;
    BOOL fFastDelete = FALSE;
    LONG hl;
    INT  cchcount = 0;

    //
    // Get what line the min selection is on so that we can start rebuilding the
    // text from there if we delete anything.
    //
    minSelLine = EditML_IchToLine(ped, minSel);
    maxSelLine = EditML_IchToLine(ped, maxSel);

    //
    // Calculate fFastDelete and cchcount
    //
    if (ped->fAnsi && ped->fDBCS) 
    {
        if ((ped->fAutoVScroll) &&
            (minSelLine == maxSelLine) &&
            (ped->chLines[minSelLine] != minSel)  &&
            (Edit_NextIch(ped,NULL,minSel) == maxSel)) 
        {

                fFastDelete = TRUE;
                cchcount = ((maxSel - minSel) == 1) ? 0 : -1;
        }
    } 
    else if (((maxSel - minSel) == 1) && (minSelLine == maxSelLine) && (ped->chLines[minSelLine] != minSel)) 
    {
        fFastDelete = ped->fAutoVScroll ? TRUE : FALSE;
    }

    cchDelete = Edit_DeleteText(ped);
    if (!cchDelete)
    {
        return 0;
    }

    //
    // Start building lines at minsel line since caretline may be at the max sel
    // point.
    //
    if (fFastDelete) 
    {
        //
        // cchcount is (-1) if it's a double byte character
        //
        EditML_ShiftchLines(ped, minSelLine + 1, -2 + cchcount);
        EditML_BuildchLines(ped, minSelLine, 1, TRUE, NULL, &hl);
    } 
    else 
    {
        EditML_BuildchLines(ped, max(minSelLine-1,0), -(int)cchDelete, FALSE, NULL, NULL);
    }

    EditML_UpdateiCaretLine(ped);

    Edit_NotifyParent(ped, EN_UPDATE);

    if (IsWindowVisible(ped->hwnd)) 
    {
        //
        // Now update the screen to reflect the deletion
        //
        hdc = Edit_GetDC(ped, FALSE);

        //
        // Otherwise just redraw starting at the line we just entered
        //
        minSelLine = max(minSelLine-1,0);
        EditML_DrawText(ped, hdc, ped->chLines[minSelLine], fFastDelete ? hl : ped->cch, FALSE);

        CopyRect(&rc, &ped->rcFmt);
        rc.left  -= ped->wLeftMargin;
        rc.right += ped->wRightMargin;

        if (ped->cch) 
        {
            //
            //  Clear from end of text to end of window.
            //  
            //  We only need the y position. Since with an LPK loaded
            //  calculating the x position is an intensive job, just
            //  call EditML_IchToYPos.
            //
            if (ped->pLpkEditCallout)
            {
                xyPos.y = EditML_IchToYPos(ped, ped->cch, FALSE);
            }
            else
            {
                EditML_IchToXYPos(ped, hdc, ped->cch, FALSE, &xyPos);
            }

            rc.top = xyPos.y + ped->lineHeight;
        }

        InvalidateRect(ped->hwnd, &rc, TRUE);
        Edit_ReleaseDC(ped, hdc, FALSE);

        EditML_EnsureCaretVisible(ped);
    }

    ped->fDirty = TRUE;

    Edit_NotifyParent(ped, EN_CHANGE);

    if (cchDelete)
    {
        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }

    return cchDelete;
}


//---------------------------------------------------------------------------//
//
// EditML_InsertchLine AorW
//
// Inserts the line iline and sets its starting character index to be
// ich. All the other line indices are moved up. Returns TRUE if successful
// else FALSE and notifies the parent that there was no memory.
//
BOOL EditML_InsertchLine(PED ped, ICH iLine, ICH ich, BOOL fUserTyping)
{
    DWORD dwSize;

    if (fUserTyping && iLine < ped->cLines) 
    {
        ped->chLines[iLine] = ich;
        return TRUE;
    }

    dwSize = (ped->cLines + 2) * sizeof(int);

    if (dwSize > UserLocalSize(ped->chLines)) 
    {
        LPICH hResult;

        //
        // Grow the line index buffer
        //
        dwSize += LINEBUMP * sizeof(int);
        hResult = (LPICH)UserLocalReAlloc(ped->chLines, dwSize, 0);

        if (!hResult) 
        {
            Edit_NotifyParent(ped, EN_ERRSPACE);
            return FALSE;
        }
        ped->chLines = hResult;
    }

    //
    // Move indices starting at iLine up
    //
    if (ped->cLines != iLine)
    {
        RtlMoveMemory(&ped->chLines[iLine + 1], &ped->chLines[iLine],
                (ped->cLines - iLine) * sizeof(int));
    }

    ped->cLines++;
    ped->chLines[iLine] = ich;

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// EditML_ShiftchLines AorW
//
// Move the starting index of all lines iLine or greater by delta
// bytes.
//
void EditML_ShiftchLines(PED ped, ICH iLine, int delta)
{
    if (iLine < ped->cLines)
    {
        //
        // Just add delta to the starting point of each line after iLine
        //
        for (; iLine < ped->cLines; iLine++)
        {
            ped->chLines[iLine] += delta;
        }
    }
}


//---------------------------------------------------------------------------//
//
// EditML_BuildchLines AorW
// 
// Rebuilds the start of line array (ped->chLines) starting at line
// number ichLine.
//
void EditML_BuildchLines( PED ped, ICH iLine, int cchDelta, BOOL fUserTyping, PLONG pll, PLONG phl)
{
    PSTR ptext;     // Starting address of the text

    //
    // We keep these ICH's so that we can Unlock ped->hText when we have to grow
    // the chlines array. With large text handles, it becomes a problem if we
    // have a locked block in the way.
    //
    ICH ichLineStart;
    ICH ichLineEnd;
    ICH ichLineEndBeforeCRLF;
    ICH ichCRLF;

    ICH cch;
    HDC hdc;

    BOOL fLineBroken = FALSE;   // Initially, no new line breaks are made
    ICH minCchBreak;
    ICH maxCchBreak;
    BOOL fOnDelimiter;

    if (!ped->cch) 
    {
        ped->maxPixelWidth = 0;
        ped->xOffset = 0;
        ped->ichScreenStart = 0;
        ped->cLines = 1;

        if (pll)
        {
            *pll = 0;
        }

        if (phl)
        {
            *phl = 0;
        }

        goto UpdateScroll;
    }

    if (fUserTyping && cchDelta)
    {
        EditML_ShiftchLines(ped, iLine + 1, cchDelta);
    }

    hdc = Edit_GetDC(ped, TRUE);

    if (!iLine && !cchDelta && !fUserTyping) 
    {
        //
        // Reset maxpixelwidth only if we will be running through the whole
        // text. Better too long than too short.
        //
        ped->maxPixelWidth = 0;

        //
        // Reset number of lines in text since we will be running through all
        // the text anyway...
        //
        ped->cLines = 1;
    }

    //
    // Set min and max line built to be the starting line
    //
    minCchBreak = maxCchBreak = (cchDelta ? ped->chLines[iLine] : 0);

    ptext = Edit_Lock(ped);

    ichCRLF = ichLineStart = ped->chLines[iLine];

    while (ichLineStart < ped->cch) 
    {
        if (ichLineStart >= ichCRLF) 
        {
            ichCRLF = ichLineStart;

            //
            // Move ichCRLF ahead to either the first CR or to the end of text.
            //
            if (ped->fAnsi) 
            {
                while (ichCRLF < ped->cch) 
                {
                    if (*(ptext + ichCRLF) == 0x0D) 
                    {
                        if (*(ptext + ichCRLF + 1) == 0x0A ||
                                *(WORD UNALIGNED *)(ptext + ichCRLF + 1) == 0x0A0D)
                        {
                            break;
                        }
                    }

                    ichCRLF++;
                }
            } 
            else 
            {
                LPWSTR pwtext = (LPWSTR)ptext;

                while (ichCRLF < ped->cch) 
                {
                    if (*(pwtext + ichCRLF) == 0x0D) 
                    {
                        if (*(pwtext + ichCRLF + 1) == 0x0A ||
                                *(DWORD UNALIGNED *)(pwtext + ichCRLF + 1) == 0x000A000D)
                        {
                            break;
                        }
                    }

                    ichCRLF++;
                }
            }
        }

        if (!ped->fWrap) 
        {
            UINT  LineWidth;

            //
            // If we are not word wrapping, line breaks are signified by CRLF.
            //

            //
            // If we cut off the line at MAXLINELENGTH, we should
            // adjust ichLineEnd.
            //
            if ((ichCRLF - ichLineStart) <= MAXLINELENGTH) 
            {
                ichLineEnd = ichCRLF;
            } 
            else 
            {
                ichLineEnd = ichLineStart + MAXLINELENGTH;

                if (ped->fAnsi && ped->fDBCS) 
                {
                    ichLineEnd = Edit_AdjustIch( ped, (PSTR)ptext, ichLineEnd);
                }
            }

            //
            // We will keep track of what the longest line is for the horizontal
            // scroll bar thumb positioning.
            //
            if (ped->pLpkEditCallout) 
            {
                LineWidth = ped->pLpkEditCallout->EditGetLineWidth(
                    (PED0)ped, hdc, ptext + ichLineStart*ped->cbChar,
                    ichLineEnd - ichLineStart);
            } 
            else 
            {
                LineWidth = EditML_GetLineWidth(hdc, ptext + ichLineStart * ped->cbChar,
                                            ichLineEnd - ichLineStart,
                                            ped);
            }

            ped->maxPixelWidth = max(ped->maxPixelWidth,(int)LineWidth);

        } 
        else 
        {
            //
            // Check if the width of the edit control is non-zero;
            // a part of the fix for Bug #7402 -- SANKAR -- 01/21/91 --
            //
            if(ped->rcFmt.right > ped->rcFmt.left) 
            {
                //
                // Find the end of the line based solely on text extents
                //
                if (ped->pLpkEditCallout) 
                {
                    ichLineEnd = ichLineStart +
                        ped->pLpkEditCallout->EditCchInWidth(
                            (PED0)ped, hdc, ptext + ped->cbChar*ichLineStart,
                            ichCRLF - ichLineStart,
                            ped->rcFmt.right - ped->rcFmt.left);
                } 
                else 
                {
                    if (ped->fAnsi) 
                    {
                        ichLineEnd = ichLineStart +
                                 Edit_CchInWidth(ped, hdc,
                                              ptext + ichLineStart,
                                              ichCRLF - ichLineStart,
                                              ped->rcFmt.right - ped->rcFmt.left,
                                              TRUE);
                    } 
                    else 
                    {
                        ichLineEnd = ichLineStart +
                                 Edit_CchInWidth(ped, hdc,
                                              (LPSTR)((LPWSTR)ptext + ichLineStart),
                                              ichCRLF - ichLineStart,
                                              ped->rcFmt.right - ped->rcFmt.left,
                                              TRUE);
                    }
                }
            } 
            else 
            {
                ichLineEnd = ichLineStart;
            }

            if (ichLineEnd == ichLineStart && ichCRLF - ichLineStart) 
            {
                //
                // Maintain a minimum of one char per line
                // Since it might be a double byte char, so calling Edit_NextIch.
                //
                ichLineEnd = Edit_NextIch(ped, NULL, ichLineEnd);
            }

            //
            // Now starting from ichLineEnd, if we are not at a hard line break,
            // then if we are not at a space AND the char before us is
            // not a space,(OR if we are at a CR) we will look word left for the
            // start of the word to break at.
            // This change was done for TWO reasons:
            // 1. If we are on a delimiter, no need to look word left to break at.
            // 2. If the previous char is a delimter, we can break at current char.
            // Change done by -- SANKAR --01/31/91--
            //
            if (ichLineEnd != ichCRLF) 
            {
                if(ped->lpfnNextWord) 
                {
                     fOnDelimiter = (CALLWORDBREAKPROC(*ped->lpfnNextWord, ptext,
                            ichLineEnd, ped->cch, WB_ISDELIMITER) ||
                            CALLWORDBREAKPROC(*ped->lpfnNextWord, ptext, ichLineEnd - 1,
                            ped->cch, WB_ISDELIMITER));

                    //
                    // This change was done for FOUR reasons:
                    //
                    // 1. If we are on a delimiter, no need to look word left to break at.
                    // 2. If we are on a double byte character, we can break at current char.
                    // 3. If the previous char is a delimter, we can break at current char.
                    // 4. If the previous char is a double byte character, we can break at current char.
                    //
                } 
                else if (ped->fAnsi) 
                {
                    fOnDelimiter = (ISDELIMETERA(*(ptext + ichLineEnd)) ||
                                    Edit_IsDBCSLeadByte(ped, *(ptext + ichLineEnd)));

                    if (!fOnDelimiter) 
                    {
                        PSTR pPrev = Edit_AnsiPrev(ped,ptext,ptext+ichLineEnd);

                        fOnDelimiter = ISDELIMETERA(*pPrev) ||
                                       Edit_IsDBCSLeadByte(ped,*pPrev);
                    }
                } 
                else 
                { 
                    fOnDelimiter = (ISDELIMETERW(*((LPWSTR)ptext + ichLineEnd))     ||
                                    Edit_IsFullWidth(CP_ACP,*((LPWSTR)ptext + ichLineEnd))      ||
                                    ISDELIMETERW(*((LPWSTR)ptext + ichLineEnd - 1)) ||
                                    Edit_IsFullWidth(CP_ACP,*((LPWSTR)ptext + ichLineEnd - 1)));
                }

                if (!fOnDelimiter ||
                    (ped->fAnsi && *(ptext + ichLineEnd) == 0x0D) ||
                    (!ped->fAnsi && *((LPWSTR)ptext + ichLineEnd) == 0x0D)) 
                {
                    if (ped->lpfnNextWord != NULL) 
                    {
                        cch = CALLWORDBREAKPROC(*ped->lpfnNextWord, (LPSTR)ptext, ichLineEnd,
                                ped->cch, WB_LEFT);
                    } 
                    else 
                    {
                        ped->fCalcLines = TRUE;
                        Edit_Word(ped, ichLineEnd, TRUE, &cch, NULL);
                        ped->fCalcLines = FALSE;
                    }

                    if (cch > ichLineStart) 
                    {
                        ichLineEnd = cch;
                    }

                    //
                    // Now, if the above test fails, it means the word left goes
                    // back before the start of the line ie. a word is longer
                    // than a line on the screen. So, we just fit as much of
                    // the word on the line as possible. Thus, we use the
                    // pLineEnd we calculated solely on width at the beginning
                    // of this else block...
                    //
                }
            }
        }
#if 0
        if (!ISDELIMETERAW((*(ptext + (ichLineEnd - 1)*ped->cbChar))) && ISDELIMETERAW((*(ptext + ichLineEnd*ped->cbChar)))) #ERROR

            if ((*(ptext + ichLineEnd - 1) != ' ' &&
                        *(ptext + ichLineEnd - 1) != VK_TAB) &&
                        (*(ptext + ichLineEnd) == ' ' ||
                        *(ptext + ichLineEnd) == VK_TAB))
#endif
        if (AWCOMPARECHAR(ped,ptext + ichLineEnd * ped->cbChar, ' ') ||
                AWCOMPARECHAR(ped,ptext + ichLineEnd * ped->cbChar, VK_TAB)) 
        {
            //
            // Swallow the space at the end of a line.
            //
            if (ichLineEnd < ped->cch) 
            {
                ichLineEnd++;
            }
        }

        //
        // Skip over crlf or crcrlf if it exists. Thus, ichLineEnd is the first
        // character in the next line.
        //
        ichLineEndBeforeCRLF = ichLineEnd;

        if (ped->fAnsi) 
        {
            if (ichLineEnd < ped->cch && *(ptext + ichLineEnd) == 0x0D)
            {
                ichLineEnd += 2;
            }

            //
            // Skip over CRCRLF
            //
            if (ichLineEnd < ped->cch && *(ptext + ichLineEnd) == 0x0A)
            {
                ichLineEnd++;
            }
        } 
        else 
        {
            if (ichLineEnd < ped->cch && *(((LPWSTR)ptext) + ichLineEnd) == 0x0D)
            {
                ichLineEnd += 2;
            }

            //
            // Skip over CRCRLF
            //
            if (ichLineEnd < ped->cch && *(((LPWSTR)ptext) + ichLineEnd) == 0x0A) 
            {
                ichLineEnd++;
                TraceMsg(TF_STANDARD, "Edit: Skip over CRCRLF");
            }
        }
#if DBG
        if (ichLineEnd > ped->cch)
        {
            TraceMsg(TF_STANDARD, "Edit: ichLineEnd (%d)> ped->cch (%d)", ichLineEnd, ped->cch);
        }
#endif

        //
        // Now, increment iLine, allocate space for the next line, and set its
        // starting point
        //
        iLine++;

        if (!fUserTyping || (iLine > ped->cLines - 1) || (ped->chLines[iLine] != ichLineEnd)) 
        {
            //
            // The line break occured in a different place than before.
            //
            if (!fLineBroken) 
            {
                //
                // Since we haven't broken a line before, just set the min
                // break line.
                //
                fLineBroken = TRUE;

                if (ichLineEndBeforeCRLF == ichLineEnd)
                {
                    minCchBreak = maxCchBreak = (ichLineEnd ? ichLineEnd - 1 : 0);
                }
                else
                {
                    minCchBreak = maxCchBreak = ichLineEndBeforeCRLF;
                }
            }

            maxCchBreak = max(maxCchBreak, ichLineEnd);

            Edit_Unlock(ped);

            //
            // Now insert the new line into the array
            //
            if (!EditML_InsertchLine(ped, iLine, ichLineEnd, (BOOL)(cchDelta != 0)))
            {
                goto EndUp;
            }

            ptext = Edit_Lock(ped);
        } 
        else 
        {
            maxCchBreak = ped->chLines[iLine];

            //
            // Quick escape
            //
            goto UnlockAndEndUp;
        }

        ichLineStart = ichLineEnd;
    }


    if (iLine != ped->cLines) 
    {
        TraceMsg(TF_STANDARD, "Edit: chLines[%d] is being cleared.", iLine);
        ped->cLines = iLine;
        ped->chLines[ped->cLines] = 0;
    }

    //
    // Note that we incremented iLine towards the end of the while loop so, the
    // index, iLine, is actually equal to the line count
    //
    if (ped->cch && AWCOMPARECHAR(ped, ptext + (ped->cch - 1)*ped->cbChar, 0x0A) &&
            ped->chLines[ped->cLines - 1] < ped->cch) 
    {
        //
        // Make sure last line has no crlf in it
        //
        if (!fLineBroken) 
        {
            //
            // Since we haven't broken a line before, just set the min break
            // line.
            //
            fLineBroken = TRUE;
            minCchBreak = ped->cch - 1;
        }

        maxCchBreak = max(maxCchBreak, ichLineEnd);
        Edit_Unlock(ped);
        EditML_InsertchLine(ped, iLine, ped->cch, FALSE);
        EditML_SanityCheck(ped);
    } 
    else
    {
UnlockAndEndUp:
        Edit_Unlock(ped);
    }

EndUp:
    Edit_ReleaseDC(ped, hdc, TRUE);

    if (pll)
    {
        *pll = minCchBreak;
    }

    if (phl)
    {
        *phl = maxCchBreak;
    }

UpdateScroll:
    EditML_Scroll(ped, FALSE, ML_REFRESH, 0, TRUE);
    EditML_Scroll(ped, TRUE,  ML_REFRESH, 0, TRUE);

    EditML_SanityCheck(ped);

    return;
}


//---------------------------------------------------------------------------//
//
// EditML_Paint()
// 
// Response to WM_PAINT message.
//
VOID EditML_Paint(PED ped, HDC hdc, LPRECT lprc)
{
    HFONT  hOldFont;
    ICH    imin;
    ICH    imax;
    HBRUSH hbr;
    BOOL   fNeedDelete = FALSE;

    //
    // Do we need to draw the border ourself for old apps?
    //
    if (ped->fFlatBorder)
    {
        RECT    rcT;
        ULONG   ulStyle;
        INT     cxBorder;
        INT     cyBorder;
        INT     cxFrame;
        INT     cyFrame;

        ulStyle = GET_STYLE(ped);
        cxBorder = GetSystemMetrics(SM_CXBORDER);
        cyBorder = GetSystemMetrics(SM_CYBORDER);
        cxFrame  = GetSystemMetrics(SM_CXFRAME);
        cyFrame  = GetSystemMetrics(SM_CYFRAME);

        GetClientRect(ped->hwnd, &rcT);
        if (ulStyle & WS_SIZEBOX)
        {
            InflateRect(&rcT, cxBorder - cxFrame, cyBorder - cyFrame);
        }
        DrawFrame(hdc, &rcT, 1, DF_WINDOWFRAME);
    }

    Edit_SetClip(ped, hdc, (BOOL) (ped->xOffset == 0));

    if (ped->hFont)
    {
        hOldFont = SelectObject(hdc, ped->hFont);
    }

    if (!lprc) 
    {
        //
        // no partial rect given -- draw all text
        //
        imin = 0;
        imax = ped->cch;
    } 
    else 
    {
        //
        // only draw pertinent text
        //
        imin = (ICH) EditML_MouseToIch(ped, hdc, ((LPPOINT) &lprc->left), NULL) - 1;
        if (imin == -1)
        {
            imin = 0;
        }

        //
        // HACK_ALERT:
        // The 3 is required here because, EditML_MouseToIch() returns decremented
        // value; We must fix EditML_MouseToIch.
        //
        imax = (ICH) EditML_MouseToIch(ped, hdc, ((LPPOINT) &lprc->right), NULL) + 3;
        if (imax > ped->cch)
        {
            imax = ped->cch;
        }
    }

    hbr = Edit_GetBrush(ped, hdc, &fNeedDelete);
    if (hbr)
    {
        RECT rc;
        GetClientRect(ped->hwnd, &rc);
        FillRect(hdc, &rc, hbr);

        if (fNeedDelete)
        {
            DeleteObject(hbr);
        }
    }

    EditML_DrawText(ped, hdc, imin, imax, FALSE);

    if (ped->hFont)
    {
        SelectObject(hdc, hOldFont);
    }
}


//---------------------------------------------------------------------------//
//
// EditML_KeyDown AorW
// 
// Handles cursor movement and other VIRT KEY stuff. keyMods allows
// us to make EditML_KeyDownHandler calls and specify if the modifier keys (shift
// and control) are up or down. If keyMods == 0, we get the keyboard state
// using GetKeyState(VK_SHIFT) etc. Otherwise, the bits in keyMods define the
// state of the shift and control keys.
//
VOID EditML_KeyDown(PED ped, UINT virtKeyCode, int keyMods)
{
    HDC hdc;
    BOOL prevLine;
    POINT mousePt;
    int defaultDlgId;
    int iScrollAmt;

    //
    // Variables we will use for redrawing the updated text
    //

    //
    // new selection is specified by newMinSel, newMaxSel
    //
    ICH newMaxSel = ped->ichMaxSel;
    ICH newMinSel = ped->ichMinSel;

    //
    // Flags for drawing the updated text
    //
    BOOL changeSelection = FALSE;

    //
    // Comparisons we do often
    //
    BOOL MinEqMax = (newMaxSel == newMinSel);
    BOOL MinEqCar = (ped->ichCaret == newMinSel);
    BOOL MaxEqCar = (ped->ichCaret == newMaxSel);

    //
    // State of shift and control keys.
    //
    int scState;

    if (ped->fMouseDown) 
    {
        //
        // If we are in the middle of a mousedown command, don't do anything.
        //
        return;
    }

    if (ped->hwndBalloon)
    {
        Edit_HideBalloonTip(ped->hwnd);
    }

    scState = Edit_GetModKeys(keyMods);

    switch (virtKeyCode) 
    {
    case VK_ESCAPE:
        if (ped->fInDialogBox) 
        {
            //
            // This condition is removed because, if the dialogbox does not
            // have a CANCEL button and if ESC is hit when focus is on a
            // ML edit control the dialogbox must close whether it has cancel
            // button or not to be consistent with SL edit control;
            // DefDlgProc takes care of the disabled CANCEL button case.
            // Fix for Bug #4123 -- 02/07/91 -- SANKAR --
            //
#if 0
            if (GetDlgItem(ped->hwndParent, IDCANCEL))
#endif
                //
                // User hit ESC...Send a close message (which in turn sends a
                // cancelID to the app in DefDialogProc...
                //
                PostMessage(ped->hwndParent, WM_CLOSE, 0, 0L);
        }

        return;

    case VK_RETURN:
        if (ped->fInDialogBox) 
        {
            //
            // If this multiline edit control is in a dialog box, then we want
            // the RETURN key to be sent to the default dialog button (if there
            // is one). CTRL-RETURN will insert a RETURN into the text. Note
            // that CTRL-RETURN automatically translates into a linefeed (0x0A)
            // and in the EditML_CharHandler, we handle this as if a return was
            // entered.
            //
            if (scState != CTRLDOWN) 
            {
                if (GET_STYLE(ped) & ES_WANTRETURN) 
                {
                    //
                    // This edit control wants cr to be inserted so break out of
                    // case.
                    //
                    return;
                }

                defaultDlgId = (int)(DWORD)LOWORD(SendMessage(ped->hwndParent,
                        DM_GETDEFID, 0, 0L));
                if (defaultDlgId) 
                {
                    HWND hwnd = GetDlgItem(ped->hwndParent, defaultDlgId);
                    if (hwnd) 
                    {
                        SendMessage(ped->hwndParent, WM_NEXTDLGCTL, (WPARAM)hwnd, 1L);
                        if (!ped->fFocus)
                        {
                            PostMessage(hwnd, WM_KEYDOWN, VK_RETURN, 0L);
                        }
                    }
                }
            }

            return;
        }

        break;

    case VK_TAB:

        //
        // If this multiline edit control is in a dialog box, then we want the
        // TAB key to take you to the next control, shift TAB to take you to the
        // previous control. We always want CTRL-TAB to insert a tab into the
        // edit control regardless of weather or not we're in a dialog box.
        //
        if (scState == CTRLDOWN)
        {
            EditML_Char(ped, virtKeyCode, keyMods);
        }
        else if (ped->fInDialogBox)
        {
            SendMessage(ped->hwndParent, WM_NEXTDLGCTL, scState == SHFTDOWN, 0L);
        }

        return;

    case VK_LEFT:

        //
        // If the caret isn't at the beginning, we can move left
        //
        if (ped->ichCaret) 
        {
            //
            // Get new caret pos.
            //
            if (scState & CTRLDOWN) 
            {
                //
                // Move caret word left
                //
                Edit_Word(ped, ped->ichCaret, TRUE, &ped->ichCaret, NULL);
            } 
            else 
            {
                if (ped->pLpkEditCallout) 
                {
                    ped->ichCaret = Edit_MoveSelectionRestricted(ped, ped->ichCaret, TRUE);
                } 
                else 
                {
                    //
                    // Move caret char left
                    //
                    ped->ichCaret = Edit_MoveSelection(ped, ped->ichCaret, TRUE);
                }
            }

            //
            // Get new selection
            //
            if (scState & SHFTDOWN) 
            {
                if (MaxEqCar && !MinEqMax) 
                {
                    //
                    // Reduce selection
                    //
                    newMaxSel = ped->ichCaret;

                    UserAssert(newMinSel == ped->ichMinSel);
                }
                else 
                {
                    //
                    // Extend selection
                    //
                    newMinSel = ped->ichCaret;
                }
            } 
            else 
            {
                //
                // Clear selection
                //
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } 
        else 
        {
            //
            // If the user tries to move left and we are at the 0th
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) &&
                !(scState & SHFTDOWN) ) 
            {
                changeSelection = TRUE;
                newMaxSel = newMinSel = ped->ichCaret;
            }
        }

        break;

    case VK_RIGHT:

        //
        // If the caret isn't at the end, we can move right.
        //
        if (ped->ichCaret < ped->cch) 
        {
            //
            // Get new caret pos.
            //
            if (scState & CTRLDOWN) 
            {
                //
                // Move caret word right
                //
                Edit_Word(ped, ped->ichCaret, FALSE, NULL, &ped->ichCaret);
            } 
            else 
            {
                //
                // Move caret char right
                //
                if (ped->pLpkEditCallout) 
                {
                    ped->ichCaret = Edit_MoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } 
                else 
                {
                    ped->ichCaret = Edit_MoveSelection(ped, ped->ichCaret, FALSE);
                }
            }

            //
            // Get new selection.
            //
            if (scState & SHFTDOWN) 
            {
                if (MinEqCar && !MinEqMax) 
                {
                    //
                    // Reduce selection
                    //
                    newMinSel = ped->ichCaret;

                    UserAssert(newMaxSel == ped->ichMaxSel);
                }
                else 
                {
                    //
                    // Extend selection
                    //
                    newMaxSel = ped->ichCaret;
                }
            } 
            else 
            {
                //
                // Clear selection
                //
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } 
        else 
        {
            //
            // If the user tries to move right and we are at the last
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) &&
                !(scState & SHFTDOWN) ) 
            {
                newMaxSel = newMinSel = ped->ichCaret;
                changeSelection = TRUE;
            }
        }

        break;

    case VK_UP:
    case VK_DOWN:
        if (ped->cLines - 1 != ped->iCaretLine &&
                ped->ichCaret == ped->chLines[ped->iCaretLine + 1])
        {
            prevLine = TRUE;
        }
        else
        {
            prevLine = FALSE;
        }

        hdc = Edit_GetDC(ped, TRUE);
        EditML_IchToXYPos(ped, hdc, ped->ichCaret, prevLine, &mousePt);
        Edit_ReleaseDC(ped, hdc, TRUE);
        mousePt.y += 1 + (virtKeyCode == VK_UP ? -ped->lineHeight : ped->lineHeight);

        if (!(scState & CTRLDOWN)) 
        {
            //
            // Send fake mouse messages to handle this
            // If VK_SHIFT is down, extend selection & move caret up/down
            // 1 line.  Otherwise, clear selection & move caret.
            //
            EditML_MouseMotion(ped, WM_LBUTTONDOWN,
                            !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);
            EditML_MouseMotion(ped, WM_LBUTTONUP,
                            !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);
        }

        break;

    case VK_HOME:
        //
        // Update caret.
        //
        if (scState & CTRLDOWN) 
        {
            //
            // Move caret to beginning of text.
            //
            ped->ichCaret = 0;
        } 
        else 
        {
            //
            // Move caret to beginning of line.
            //
            ped->ichCaret = ped->chLines[ped->iCaretLine];
        }

        //
        // Update selection.
        //
        newMinSel = ped->ichCaret;

        if (scState & SHFTDOWN) 
        {
            if (MaxEqCar && !MinEqMax) 
            {
                if (scState & CTRLDOWN)
                {
                    newMaxSel = ped->ichMinSel;
                }
                else 
                {
                    newMinSel = ped->ichMinSel;
                    newMaxSel = ped->ichCaret;
                }
            }
        } 
        else 
        {
            //
            // Clear selection
            //
            newMaxSel = ped->ichCaret;
        }

        changeSelection = TRUE;

        break;

    case VK_END:
        //
        // Update caret.
        //
        if (scState & CTRLDOWN) 
        {
            //
            // Move caret to end of text.
            //
            ped->ichCaret = ped->cch;
        } 
        else 
        {
            //
            // Move caret to end of line.
            //
            ped->ichCaret = ped->chLines[ped->iCaretLine] +
                EditML_Line(ped, ped->iCaretLine);
        }

        //
        // Update selection.
        //
        newMaxSel = ped->ichCaret;

        if (scState & SHFTDOWN) 
        {
            if (MinEqCar && !MinEqMax) 
            {
                //
                // Reduce selection
                //
                if (scState & CTRLDOWN) 
                {
                    newMinSel = ped->ichMaxSel;
                } 
                else 
                {
                    newMinSel = ped->ichCaret;
                    newMaxSel = ped->ichMaxSel;
                }
            }
        } 
        else 
        {
            //
            // Clear selection
            //
            newMinSel = ped->ichCaret;
        }

        changeSelection = TRUE;

        break;

    //
    // FE_IME // EC_INSERT_COMPOSITION_CHAR : EditML_KeyDown() : VK_HANJA support
    //
    case VK_HANJA:
        if ( HanjaKeyHandler( ped ) ) 
        {
            changeSelection = TRUE;
            newMinSel = ped->ichCaret;
            newMaxSel = ped->ichCaret + (ped->fAnsi ? 2 : 1);
        }

        break;

    case VK_PRIOR:
    case VK_NEXT:
        if (!(scState & CTRLDOWN)) 
        {
            //
            // Vertical scroll by one visual screen
            //
            hdc = Edit_GetDC(ped, TRUE);
            EditML_IchToXYPos(ped, hdc, ped->ichCaret, FALSE, &mousePt);
            Edit_ReleaseDC(ped, hdc, TRUE);
            mousePt.y += 1;

            SendMessage(ped->hwnd, WM_VSCROLL, virtKeyCode == VK_PRIOR ? SB_PAGEUP : SB_PAGEDOWN, 0L);

            //
            // Move the cursor there
            //
            EditML_MouseMotion(ped, WM_LBUTTONDOWN, !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);
            EditML_MouseMotion(ped, WM_LBUTTONUP,   !(scState & SHFTDOWN) ? 0 : MK_SHIFT, &mousePt);

        } 
        else 
        {
            //
            // Horizontal scroll by one screenful minus one char
            //
            iScrollAmt = ((ped->rcFmt.right - ped->rcFmt.left) / ped->aveCharWidth) - 1;
            if (virtKeyCode == VK_PRIOR)
            {
                //
                // For previous page
                //
                iScrollAmt *= -1;
            }

            SendMessage(ped->hwnd, WM_HSCROLL, MAKELONG(EM_LINESCROLL, iScrollAmt), 0);

            break;
        }

        break;

    case VK_DELETE:
        if (ped->fReadOnly)
        {
            break;
        }

        switch (scState) 
        {
        case NONEDOWN:

            //
            // Clear selection. If no selection, delete (clear) character
            // right
            //
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) 
            {
                //
                // Move cursor forwards and send a backspace message...
                //
                if (ped->pLpkEditCallout) 
                {
                    ped->ichMinSel = ped->ichCaret;
                    ped->ichMaxSel = Edit_MoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } 
                else 
                {
                    ped->ichCaret = Edit_MoveSelection(ped, ped->ichCaret, FALSE);
                    ped->ichMaxSel = ped->ichMinSel = ped->ichCaret;
                }

                goto DeleteAnotherChar;
            }

            break;

        case SHFTDOWN:

            //
            // CUT selection ie. remove and copy to clipboard, or if no
            // selection, delete (clear) character left.
            //
            if (ped->ichMinSel == ped->ichMaxSel) 
            {
                goto DeleteAnotherChar;
            } 
            else 
            {
                SendMessage(ped->hwnd, WM_CUT, (UINT)0, 0L);
            }

            break;

        case CTRLDOWN:

            //
            // Clear selection, or delete to end of line if no selection
            //
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) 
            {
                ped->ichMaxSel = ped->ichCaret = ped->chLines[ped->iCaretLine] +
                                                 EditML_Line(ped, ped->iCaretLine);
            }

            break;
        }

        if (!(scState & SHFTDOWN) && (ped->ichMinSel != ped->ichMaxSel)) 
        {

DeleteAnotherChar:
            if (Is400Compat(UserGetVersion())) 
            {
                EditML_Char(ped, VK_BACK, 0);
            } 
            else 
            {
                SendMessage(ped->hwnd, WM_CHAR, VK_BACK, 0);
            }
        }

        //
        // No need to update text or selection since BACKSPACE message does it
        // for us.
        //
        break;

    case VK_INSERT:
        if (scState == CTRLDOWN || scState == SHFTDOWN) 
        {
            //
            // if CTRLDOWN Copy current selection to clipboard
            //

            //
            // if SHFTDOWN Paste clipboard
            //
            SendMessage(ped->hwnd, (UINT)(scState == CTRLDOWN ? WM_COPY : WM_PASTE), 0, 0);
        }

        break;
    }

    if (changeSelection) 
    {
        hdc = Edit_GetDC(ped, FALSE);
        EditML_ChangeSelection(ped, hdc, newMinSel, newMaxSel);

        //
        // Set the caret's line
        //
        ped->iCaretLine = EditML_IchToLine(ped, ped->ichCaret);

        if (virtKeyCode == VK_END &&
                // Next line: Win95 Bug#11822, EditControl repaint (Sankar)
                (ped->ichCaret == ped->chLines[ped->iCaretLine]) &&
                ped->ichCaret < ped->cch &&
                ped->fWrap && ped->iCaretLine > 0) 
        {
            LPSTR pText = Edit_Lock(ped);

            //
            // Handle moving to the end of a word wrapped line. This keeps the
            // cursor from falling to the start of the next line if we have word
            // wrapped and there is no CRLF.
            //
            if ( ped->fAnsi ) 
            {
                if (*(WORD UNALIGNED *)(pText + ped->chLines[ped->iCaretLine] - 2) != 0x0A0D) 
                {
                    ped->iCaretLine--;
                }
            } 
            else 
            {
                if (*(DWORD UNALIGNED *)(pText +
                     (ped->chLines[ped->iCaretLine] - 2)*ped->cbChar) != 0x000A000D) 
                {
                    ped->iCaretLine--;
                }
            }

            Edit_Unlock(ped);
        }

        //
        // Since drawtext sets the caret position
        //
        EditML_SetCaretPosition(ped, hdc);
        Edit_ReleaseDC(ped, hdc, FALSE);

        //
        // Make sure we can see the cursor
        //
        EditML_EnsureCaretVisible(ped);
    }
}


//---------------------------------------------------------------------------//
// 
// EditML_Char
//
// Handles character and virtual key input
//
VOID EditML_Char(PED ped, DWORD keyValue, int keyMods)
{
    WCHAR keyPress;
    BOOL  updateText = FALSE;

    //
    // keyValue is either:
    // a Virtual Key (eg: VK_TAB, VK_ESCAPE, VK_BACK)
    // a character (Unicode or "ANSI")
    //
    if (ped->fAnsi)
    {
        keyPress = LOBYTE(keyValue);
    }
    else
    {
        keyPress = LOWORD(keyValue);
    }

    if (ped->fMouseDown || keyPress == VK_ESCAPE) 
    {
        //
        // If we are in the middle of a mousedown command, don't do anything.
        // Also, just ignore it if we get a translated escape key which happens
        // with multiline edit controls in a dialog box.
        //
        return;
    }

    Edit_InOutReconversionMode(ped, FALSE);

    {
        int scState;
        scState = Edit_GetModKeys(keyMods);

        if (ped->fInDialogBox && scState != CTRLDOWN) 
        {
            //
            // If this multiline edit control is in a dialog box, then we want the
            // TAB key to take you to the next control, shift TAB to take you to the
            // previous control, and CTRL-TAB to insert a tab into the edit control.
            // We moved the focus when we received the keydown message so we will
            // ignore the TAB key now unless the ctrl key is down. Also, we want
            // CTRL-RETURN to insert a return into the text and RETURN to be sent to
            // the default button.
            //
            if (keyPress == VK_TAB || (keyPress == VK_RETURN && !(GET_STYLE(ped) & ES_WANTRETURN)))
            {
                return;
            }
        }

        //
        // Allow CTRL+C to copy from a read only edit control
        // Ignore all other keys in read only controls
        //
        if ((ped->fReadOnly) && !((keyPress == 3) && (scState == CTRLDOWN))) 
        {
            return;
        }
    }

    switch (keyPress) 
    {
    case 0x0A: 
        // linefeed
        keyPress = VK_RETURN;

        //
        // FALL THRU
        //

    case VK_RETURN:
    case VK_TAB:
    case VK_BACK:
DeleteSelection:
        if (EditML_DeleteText(ped))
        {
            updateText = TRUE;
        }

        break;

    default:
        if (keyPress >= TEXT(' ')) 
        {
            //
            // If this is in [a-z],[A-Z] and we are an ES_NUMBER
            // edit field, bail.
            //
            if (Is400Compat(UserGetVersion()) && GET_STYLE(ped) & ES_NUMBER) 
            {
                if (!Edit_IsCharNumeric(ped, keyPress)) 
                {
                    Edit_ShowBalloonTipWrap(ped->hwnd, IDS_NUMERIC_TITLE, IDS_NUMERIC_MSG, TTI_ERROR);
                    goto IllegalChar;
                }
            }

            goto DeleteSelection;
        }

        break;
    }

    //
    // Handle key codes
    //
    switch(keyPress) 
    {
    UINT msg;

    // Ctrl+Z == Undo
    case 26:
        msg = WM_UNDO;
        goto SendEditingMessage;
        break;

    // Ctrl+X == Cut
    case 24:
        if (ped->ichMinSel == ped->ichMaxSel)
        {
            goto IllegalChar;
        }
        else
        {
            msg = WM_CUT;
            goto SendEditingMessage;
        }
        break;

    // Ctrl+C == Copy
    case 3:
        msg = WM_COPY;
        goto SendEditingMessage;
        break;

    // Ctrl+V == Paste
    case 22:
        msg = WM_PASTE;
SendEditingMessage:
        SendMessage(ped->hwnd, msg, 0, 0L);
        break;

    case VK_BACK:
        //
        // Delete any selected text or delete character left if no sel
        //
        if (!updateText && ped->ichMinSel)
        {
            //
            // There was no selection to delete so we just delete
            // character left if available
            //
            ped->ichMinSel = Edit_MoveSelection(ped, ped->ichCaret, TRUE);
            EditML_DeleteText(ped);
        }
        break;

    default:
        if (keyPress == VK_RETURN)
        {
            if (ped->fAnsi)
            {
                keyValue = 0x0A0D;
            }
            else
            {
                keyValue = 0x000A000D;
            }
        }

        if (   keyPress >= TEXT(' ')
            || keyPress == VK_RETURN
            || keyPress == VK_TAB
            || keyPress == 0x1E     // RS - Unicode block separator
            || keyPress == 0x1F     // US - Unicode segment separator
            ) 
        {

            // Don't hide the cursor if someone has capture. 
            if (GetCapture() == NULL)
            {
                SetCursor(NULL);
            }
            if (ped->fAnsi) 
            {
                //
                // check if it's a leading byte of double byte character
                //
                if (Edit_IsDBCSLeadByte(ped,(BYTE)keyPress)) 
                {
                    int DBCSkey;

                    DBCSkey = DbcsCombine(ped->hwnd, keyPress);
                    if ( DBCSkey != 0)
                    {
                        keyValue = DBCSkey;
                    }
                }

                EditML_InsertText(ped, (LPSTR)&keyValue, HIBYTE(keyValue) ? 2 : 1, TRUE);
            } 
            else
            {
                EditML_InsertText(ped, (LPSTR)&keyValue, HIWORD(keyValue) ? 2 : 1, TRUE);
            }

        } 
        else 
        {
IllegalChar:
            MessageBeep(0);
        }
        break;
    }
}


//---------------------------------------------------------------------------//
//
// EditML_PasteText AorW
//
// Pastes a line of text from the clipboard into the edit control
// starting at ped->ichCaret. Updates ichMaxSel and ichMinSel to point to the
// end of the inserted text. Notifies the parent if space cannot be
// allocated. Returns how many characters were inserted.
//
ICH EditML_PasteText(PED ped)
{
    HANDLE hData;
    LPSTR lpchClip;
    ICH cchAdded = 0;
    HCURSOR hCursorOld;

#ifdef UNDO_CLEANUP           // #ifdef Added in Chicago  - johnl
    if (!ped->fAutoVScroll) 
    {
        //
        // Empty the undo buffer if this edit control limits the amount of text
        // the user can add to the window rect. This is so that we can undo this
        // operation if doing in causes us to exceed the window boundaries.
        //
        Edit_EmptyUndo(ped);
    }
#endif

    hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (!OpenClipboard(ped->hwnd))
    {
        goto PasteExitNoCloseClip;
    }

    if (!(hData = GetClipboardData(ped->fAnsi ? CF_TEXT : CF_UNICODETEXT)) ||
            (GlobalFlags(hData) == GMEM_INVALID_HANDLE)) 
    {
        TraceMsg(TF_STANDARD, "Edit: EditML_PasteText(): couldn't get a valid handle(%x)", hData);
        goto PasteExit;
    }

    //
    // See if any text should be deleted
    //
    EditML_DeleteText(ped);

    lpchClip = GlobalLock(hData);
    if (lpchClip == NULL) 
    {
        TraceMsg(TF_STANDARD, "Edit: EditML_PasteText: USERGLOBALLOCK(%x) failed.", hData);
        goto PasteExit;
    }

    //
    // Get the length of the addition.
    //
    if (ped->fAnsi)
    {
        cchAdded = strlen(lpchClip);
    }
    else
    {
        cchAdded = wcslen((LPWSTR)lpchClip);
    }

    //
    // Insert the text (EditML_InsertText checks line length)
    //
    cchAdded = EditML_InsertText(ped, lpchClip, cchAdded, FALSE);

    GlobalUnlock(hData);

PasteExit:
    CloseClipboard();

PasteExitNoCloseClip:
    SetCursor(hCursorOld);

    return cchAdded;
}


//---------------------------------------------------------------------------//
VOID EditML_MouseMotion(PED ped, UINT message, UINT virtKeyDown, LPPOINT mousePt)
{
    BOOL fChangedSel = FALSE;
    UINT dtScroll = GetDoubleClickTime() / 5;

    HDC hdc = Edit_GetDC(ped, TRUE);

    ICH ichMaxSel = ped->ichMaxSel;
    ICH ichMinSel = ped->ichMinSel;

    ICH mouseCch;
    ICH mouseLine;
    int i, j;
    LONG  ll, lh;

    mouseCch = EditML_MouseToIch(ped, hdc, mousePt, &mouseLine);

    //
    // Save for timer
    //
    ped->ptPrevMouse = *mousePt;
    ped->prevKeys = virtKeyDown;

    switch (message) 
    {
    case WM_LBUTTONDBLCLK:
        //
        // if shift key is down, extend selection to word we double clicked on
        // else clear current selection and select word.
        // LiZ -- 5/5/93
        //
        if (ped->fAnsi && ped->fDBCS) 
        {
            LPSTR pText = Edit_Lock(ped);
            Edit_Word(ped,ped->ichCaret,
                   Edit_IsDBCSLeadByte(ped, *(pText+(ped->ichCaret)))
                        ? FALSE :
                          (ped->ichCaret == ped->chLines[ped->iCaretLine]
                              ? FALSE : TRUE), &ll, &lh);
            Edit_Unlock(ped);
        } 
        else 
        {
            Edit_Word(ped, mouseCch, !(mouseCch == ped->chLines[mouseLine]), &ll, &lh);
        }
        if (!(virtKeyDown & MK_SHIFT)) 
        {
            //
            // If shift key isn't down, move caret to mouse point and clear
            // old selection
            //
            ichMinSel = ll;
            ichMaxSel = ped->ichCaret = lh;
        } 
        else 
        {
            //
            // Shiftkey is down so we want to maintain the current selection
            // (if any) and just extend or reduce it
            //
            if (ped->ichMinSel == ped->ichCaret) 
            {
                ichMinSel = ped->ichCaret = ll;
                Edit_Word(ped, ichMaxSel, TRUE, &ll, &lh);
            } 
            else 
            {
                ichMaxSel = ped->ichCaret = lh;
                Edit_Word(ped, ichMinSel, FALSE, &ll, &lh);
            }
        }

        ped->ichStartMinSel = ll;
        ped->ichStartMaxSel = lh;

        goto InitDragSelect;

    case WM_MOUSEMOVE:
        if (ped->fMouseDown) 
        {
            //
            // Set the system timer to automatically scroll when mouse is
            // outside of the client rectangle. Speed of scroll depends on
            // distance from window.
            //
            i = mousePt->y < 0 ? -mousePt->y : mousePt->y - ped->rcFmt.bottom;
            j = dtScroll - ((UINT)i << 4);
            if (j < 1)
            {
                j = 1;
            }
            SetTimer(ped->hwnd, IDSYS_SCROLL, (UINT)j, NULL);

            fChangedSel = TRUE;

            //
            // Extend selection, move caret right
            //
            if (ped->ichStartMinSel || ped->ichStartMaxSel) 
            {
                //
                // We're in WORD SELECT mode
                //
                BOOL fReverse = (mouseCch <= ped->ichStartMinSel);
                Edit_Word(ped, mouseCch, !fReverse, &ll, &lh);
                if (fReverse) 
                {
                    ichMinSel = ped->ichCaret = ll;
                    ichMaxSel = ped->ichStartMaxSel;
                } 
                else 
                {
                    ichMinSel = ped->ichStartMinSel;
                    ichMaxSel = ped->ichCaret = lh;
                }
            } 
            else if ((ped->ichMinSel == ped->ichCaret) &&
                    (ped->ichMinSel != ped->ichMaxSel))
            {
                //
                // Reduce selection extent
                //
                ichMinSel = ped->ichCaret = mouseCch;
            }
            else
            {
                //
                // Extend selection extent
                //
                ichMaxSel = ped->ichCaret = mouseCch;
            }

            ped->iCaretLine = mouseLine;
        }

        break;

    case WM_LBUTTONDOWN:
        ll = lh = mouseCch;

        if (!(virtKeyDown & MK_SHIFT)) 
        {
            //
            // If shift key isn't down, move caret to mouse point and clear
            // old selection
            //
            ichMinSel = ichMaxSel = ped->ichCaret = mouseCch;
        } 
        else 
        {
            //
            // Shiftkey is down so we want to maintain the current selection
            // (if any) and just extend or reduce it
            //
            if (ped->ichMinSel == ped->ichCaret)
            {
                ichMinSel = ped->ichCaret = mouseCch;
            }
            else
            {
                ichMaxSel = ped->ichCaret = mouseCch;
            }
        }

        ped->ichStartMinSel = ped->ichStartMaxSel = 0;

InitDragSelect:
        ped->iCaretLine = mouseLine;

        ped->fMouseDown = FALSE;
        SetCapture(ped->hwnd);
        ped->fMouseDown = TRUE;
        fChangedSel = TRUE;

        //
        // Set the timer so that we can scroll automatically when the mouse
        // is moved outside the window rectangle.
        //
        SetTimer(ped->hwnd, IDSYS_SCROLL, dtScroll, NULL);
        break;

    case WM_LBUTTONUP:
        if (ped->fMouseDown) 
        {
            //
            // Kill the timer so that we don't do auto mouse moves anymore
            //
            KillTimer(ped->hwnd, IDSYS_SCROLL);
            ReleaseCapture();
            EditML_SetCaretPosition(ped, hdc);
            ped->fMouseDown = FALSE;
        }

        break;
    }


    if (fChangedSel) 
    {
        EditML_ChangeSelection(ped, hdc, ichMinSel, ichMaxSel);
        EditML_EnsureCaretVisible(ped);
    }

    Edit_ReleaseDC(ped, hdc, TRUE);

    if (!ped->fFocus && (message == WM_LBUTTONDOWN)) 
    {
        //
        // If we don't have the focus yet, get it
        //
        SetFocus(ped->hwnd);
    }
}


//---------------------------------------------------------------------------//
LONG EditML_Scroll(PED ped, BOOL fVertical, int cmd, int iAmt, BOOL fRedraw)
{
    SCROLLINFO  si;
    int         dx = 0;
    int         dy = 0;
    BOOL        fIncludeLeftMargin;
    int         newPos;
    int         oldPos;
    BOOL        fUp = FALSE;
    UINT        wFlag;
    DWORD       dwTime = 0;

    if (fRedraw && (cmd != ML_REFRESH)) 
    {
        UpdateWindow(ped->hwnd);
    }

    if (ped->pLpkEditCallout && ped->fRtoLReading && !fVertical
        && ped->maxPixelWidth > ped->rcFmt.right - ped->rcFmt.left)  
    {
        //
        // Horizontal scoll of a right oriented window with a scrollbar.
        // Map the logical xOffset to visual coordinates.
        //
        oldPos = ped->maxPixelWidth
                 - ((int)ped->xOffset + ped->rcFmt.right - ped->rcFmt.left);
    } 
    else
    {
        oldPos = (int) (fVertical ? ped->ichScreenStart : ped->xOffset);
    }

    fIncludeLeftMargin = (ped->xOffset == 0);

    switch (cmd) 
    {
        case ML_REFRESH:
            newPos = oldPos;
            break;

        case EM_GETTHUMB:
            return oldPos;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:

            //
            // If the edit contains more than 0xFFFF lines
            // it means that the scrolbar can return a position
            // that cannot fit in a WORD (16 bits), so use
            // GetScrollInfo (which is slower) in this case.
            //
            if (ped->cLines < 0xFFFF) 
            {
                newPos = iAmt;
            } 
            else 
            {
                SCROLLINFO si;

                si.cbSize   = sizeof(SCROLLINFO);
                si.fMask    = SIF_TRACKPOS;

                GetScrollInfo( ped->hwnd, SB_VERT, &si);

                newPos = si.nTrackPos;
            }
            break;

        case SB_TOP:      // == SB_LEFT
            newPos = 0;
            break;

        case SB_BOTTOM:   // == SB_RIGHT
            if (fVertical)
            {
                newPos = ped->cLines;
            }
            else
            {
                newPos = ped->maxPixelWidth;
            }

            break;

        case SB_PAGEUP:   // == SB_PAGELEFT
            fUp = TRUE;

        case SB_PAGEDOWN: // == SB_PAGERIGHT

            if (fVertical)
            {
                iAmt = ped->ichLinesOnScreen - 1;
            }
            else
            {
                iAmt = (ped->rcFmt.right - ped->rcFmt.left) - 1;
            }

            if (iAmt == 0)
            {
                iAmt++;
            }

            if (fUp)
            {
                iAmt = -iAmt;
            }

            goto AddDelta;

        case SB_LINEUP:   // == SB_LINELEFT
            fUp = TRUE;

        case SB_LINEDOWN: // == SB_LINERIGHT

            dwTime = iAmt;

            iAmt = 1;

            if (fUp)
            {
                iAmt = -iAmt;
            }

            //   |             |
            //   |  FALL THRU  |
            //   V             V

        case EM_LINESCROLL:
            if (!fVertical)
            {
                iAmt *= ped->aveCharWidth;
            }

AddDelta:
            newPos = oldPos + iAmt;

            break;

        default:

            return(0L);
    }

    if (fVertical) 
    {
        if (si.nMax = ped->cLines)
        {
            si.nMax--;
        }

        if (!ped->hwndParent ||
            TestWF(ped->hwndParent, WFWIN40COMPAT))
        {
            si.nPage = ped->ichLinesOnScreen;
        }
        else
        {
            si.nPage = 0;
        }

        wFlag = WS_VSCROLL;
    }
    else
    {
        si.nMax  = ped->maxPixelWidth;
        si.nPage = ped->rcFmt.right - ped->rcFmt.left;

        wFlag = WS_HSCROLL;
    }

    if (TESTFLAG(GET_STYLE(ped), wFlag)) 
    {
        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_ALL | SIF_DISABLENOSCROLL;
        si.nMin  = 0;
        si.nPos = newPos;
        newPos = SetScrollInfo(ped->hwnd, fVertical ? SB_VERT : SB_HORZ,
                                     &si, fRedraw);
    } 
    else 
    {
        //
        // BOGUS -- this is duped code from ScrollBar code
        // but it's for the case when we want to limit the position without
        // actually having the scroll bar
        //
        int iMaxPos;

        //
        // Clip page to 0, range + 1
        //
        si.nPage = max(min((int)si.nPage, si.nMax + 1), 0);


        iMaxPos = si.nMax - (si.nPage ? si.nPage - 1 : 0);
        newPos = min(max(newPos, 0), iMaxPos);
    }

    oldPos -= newPos;

    if (!oldPos)
    {
        return 0;
    }


    if (ped->pLpkEditCallout && ped->fRtoLReading && !fVertical
        && ped->maxPixelWidth > ped->rcFmt.right - ped->rcFmt.left) 
    {
        //
        // Map visual oldPos and newPos back to logical coordinates
        //
        newPos = ped->maxPixelWidth
                 - (newPos + ped->rcFmt.right - ped->rcFmt.left);
        oldPos = -oldPos;
        if (newPos<0) 
        {
            //
            // Compensate for scroll bar returning pos > max-page
            //
            oldPos += newPos;
            newPos=0;
        }
    }

    if (fVertical) 
    {
        ped->ichScreenStart = newPos;
        dy = oldPos * ped->lineHeight;
    } 
    else 
    {
        ped->xOffset = newPos;
        dx = oldPos;
    }

    if (cmd != SB_THUMBTRACK)
    {
        //
        // We don't want to notify the parent of thumbtracking since they might
        // try to set the thumb position to something bogus.
        // NOTEPAD used to be guilty of this -- but I rewrote it so it's not.
        // The question is WHO ELSE does this? (jeffbog)
        //
        Edit_NotifyParent(ped, fVertical ? EN_VSCROLL : EN_HSCROLL);
    }

    if (fRedraw && IsWindowVisible(ped->hwnd)) 
    {
        RECT    rc;
        RECT    rcUpdate;
        RECT    rcClipRect;
        HDC     hdc;
        HBRUSH  hbr = NULL;
        BOOL    fNeedDelete = FALSE;
        

        GetClientRect(ped->hwnd, &rc);
        CopyRect(&rcClipRect, &ped->rcFmt);

        if (fVertical) 
        {
            rcClipRect.left -= ped->wLeftMargin;
            rcClipRect.right += ped->wRightMargin;
        }

        IntersectRect(&rc, &rc, &rcClipRect);
        rc.bottom++;

        //
        // Chicago has this HideCaret but there doesn't appear to be a
        // corresponding ShowCaret, so we lose the Caret under NT when the
        // EC scrolls - Johnl
        //
         
        // HideCaret(ped->hwnd);

        hdc = Edit_GetDC(ped, FALSE);
        Edit_SetClip(ped, hdc, fIncludeLeftMargin);
        if (ped->hFont)
        {
            SelectObject(hdc, ped->hFont);
        }

        hbr = Edit_GetBrush(ped, hdc, &fNeedDelete);
        if (hbr && fNeedDelete)
        {
            DeleteObject(hbr);
        }

        if (ped->pLpkEditCallout && !fVertical) 
        {
            //
            // Horizontal scroll with complex script support
            //
            int xFarOffset = ped->xOffset + ped->rcFmt.right - ped->rcFmt.left;

            rc = ped->rcFmt;
            if (dwTime != 0)
            {
                ScrollWindowEx(ped->hwnd, ped->fRtoLReading ? -dx : dx, dy, NULL, NULL, NULL,
                        &rcUpdate, MAKELONG(SW_SMOOTHSCROLL | SW_SCROLLCHILDREN, dwTime));
            }
            else
            {
                ScrollDC(hdc, ped->fRtoLReading ? -dx : dx, dy,
                               &rc, &rc, NULL, &rcUpdate);
            }

            //
            // Handle margins: Blank if clipped by horizontal scrolling,
            // display otherwise.
            //
            if (ped->wLeftMargin) 
            {
                rc.left  = ped->rcFmt.left - ped->wLeftMargin;
                rc.right = ped->rcFmt.left;
                if (   (ped->format != ES_LEFT)   // Always display margin for centred or far-aligned text
                    ||  // Display LTR left margin if first character fully visible
                        (!ped->fRtoLReading && ped->xOffset == 0)
                    ||  // Display RTL left margin if last character fully visible
                        (ped->fRtoLReading && xFarOffset >= ped->maxPixelWidth)) 
                {
                    UnionRect(&rcUpdate, &rcUpdate, &rc);
                } 
                else 
                {
                    ExtTextOutW(hdc, rc.left, rc.top,
                        ETO_CLIPPED | ETO_OPAQUE | ETO_GLYPH_INDEX,
                        &rc, L"", 0, 0L);
                }
            }

            if (ped->wRightMargin) 
            {
                rc.left  = ped->rcFmt.right;
                rc.right = ped->rcFmt.right + ped->wRightMargin;
                if (   (ped->format != ES_LEFT)   // Always display margin for centred or far-aligned text
                    ||  // Display RTL right margin if first character fully visible
                        (ped->fRtoLReading && ped->xOffset == 0)
                    ||  // Display LTR right margin if last character fully visible
                        (!ped->fRtoLReading && xFarOffset >= ped->maxPixelWidth)) 
                {
                    UnionRect(&rcUpdate, &rcUpdate, &rc);
                } 
                else 
                {
                    ExtTextOutW(hdc, rc.left, rc.top,
                        ETO_CLIPPED | ETO_OPAQUE | ETO_GLYPH_INDEX,
                        &rc, L"", 0, 0L);
                }
            }
        } 
        else 
        {
            if (dwTime != 0)
            {
                ScrollWindowEx(ped->hwnd, dx, dy, NULL, NULL, NULL,
                        &rcUpdate, MAKELONG(SW_SMOOTHSCROLL | SW_SCROLLCHILDREN, dwTime));
            }
            else
            {
                ScrollDC(hdc, dx, dy, &rc, &rc, NULL, &rcUpdate);
            }

            //
            // If we need to wipe out the left margin area
            //
            if (ped->wLeftMargin && !fVertical) 
            {
                //
                // Calculate the rectangle to be wiped out
                //
                rc.right = rc.left;
                rc.left = max(0, ped->rcFmt.left - (LONG)ped->wLeftMargin);
                if (rc.left < rc.right) 
                {
                    if (fIncludeLeftMargin && (ped->xOffset != 0)) 
                    {
                        ExtTextOutW(hdc, rc.left, rc.top, ETO_CLIPPED | ETO_OPAQUE,
                            &rc, L"", 0, 0L);
                    } 
                    else
                    {
                        if((!fIncludeLeftMargin) && (ped->xOffset == 0))
                        {
                            UnionRect(&rcUpdate, &rcUpdate, &rc);
                        }
                    }
                }
            }
        }

        EditML_SetCaretPosition(ped,hdc);

        Edit_ReleaseDC(ped, hdc, FALSE);
        InvalidateRect(ped->hwnd, &rcUpdate, TRUE);
        UpdateWindow(ped->hwnd);
    }

    return MAKELONG(-oldPos, 1);
}


//---------------------------------------------------------------------------//
//
// EditML_SetFocus AorW
//
// Gives the edit control the focus and notifies the parent
// EN_SETFOCUS.
//
void EditML_SetFocus(PED ped)
{
    HDC hdc;
    INT cxCaret;

    SystemParametersInfo(SPI_GETCARETWIDTH, 0, (LPVOID)&cxCaret, 0);

    if (!ped->fFocus) 
    {
        ped->fFocus = TRUE;
        InvalidateRect(ped->hwnd, NULL, TRUE);

        hdc = Edit_GetDC(ped, TRUE);

        //
        // Draw the caret. We need to do this even if the window is hidden
        // because in dlg box initialization time we may set the focus to a
        // hidden edit control window. If we don't create the caret etc, it will
        // never end up showing properly.
        //
        if (ped->pLpkEditCallout) 
        {
            ped->pLpkEditCallout->EditCreateCaret((PED0)ped, hdc, cxCaret, ped->lineHeight, 0);
        }
        else 
        {
            CreateCaret(ped->hwnd, (HBITMAP)NULL, cxCaret, ped->lineHeight);
        }
        ShowCaret(ped->hwnd);
        EditML_SetCaretPosition(ped, hdc);

        //
        // Show the current selection. Only if the selection was hidden when we
        // lost the focus, must we invert (show) it.
        //
        if (!ped->fNoHideSel && ped->ichMinSel != ped->ichMaxSel &&
                IsWindowVisible(ped->hwnd))
        {
            EditML_DrawText(ped, hdc, ped->ichMinSel, ped->ichMaxSel, TRUE);
        }

        Edit_ReleaseDC(ped, hdc, TRUE);

    }

#if 0
    EditML_EnsureCaretVisible(ped);
#endif

    //
    // Notify parent we have the focus
    //
    Edit_NotifyParent(ped, EN_SETFOCUS);
}


//---------------------------------------------------------------------------//
//
// EditML_KillFocus AorW
//
// The edit control loses the focus and notifies the parent via
// EN_KILLFOCUS.
//
VOID EditML_KillFocus(PED ped)
{
    HDC hdc;

    //
    // Reset the wheel delta count.
    //

    if (ped->fFocus) 
    {
        ped->fFocus = 0;

        //
        // Do this only if we still have the focus. But we always notify the
        // parent that we lost the focus whether or not we originally had the
        // focus.
        //

        //
        // Hide the current selection if needed
        //
#ifdef _USE_DRAW_THEME_TEXT_
        if (((!ped->fNoHideSel && ped->ichMinSel != ped->ichMaxSel &&
            IsWindowVisible(ped->hwnd))) || ped->hTheme) 
        {
            hdc = Edit_GetDC(ped, FALSE);
            if ( !ped->hTheme )
            {
                EditML_DrawText(ped, hdc, ped->ichMinSel, ped->ichMaxSel, TRUE);
            }
            else
            {
                InvalidateRect(ped->hwnd, NULL, TRUE);
            }
            Edit_ReleaseDC(ped, hdc, FALSE);
        }
#else
        if (((!ped->fNoHideSel && ped->ichMinSel != ped->ichMaxSel &&
            IsWindowVisible(ped->hwnd)))) 
        {
            hdc = Edit_GetDC(ped, FALSE);

            EditML_DrawText(ped, hdc, ped->ichMinSel, ped->ichMaxSel, TRUE);

            Edit_ReleaseDC(ped, hdc, FALSE);
        }
#endif // _USE_DRAW_THEME_TEXT_

        //
        // Destroy the caret
        //
        DestroyCaret();
    }

    //
    // Notify parent that we lost the focus.
    //
    Edit_NotifyParent(ped, EN_KILLFOCUS);
}


//---------------------------------------------------------------------------//
//
// EditML_EnsureCaretVisible AorW
// 
// Scrolls the caret into the visible region.
// Returns TRUE if scrolling was done else return s FALSE.
//
BOOL EditML_EnsureCaretVisible(PED ped)
{
    UINT   iLineMax;
    int    xposition;
    BOOL   fPrevLine;
    HDC    hdc;
    BOOL   fVScroll = FALSE;
    BOOL   fHScroll = FALSE;

    if (IsWindowVisible(ped->hwnd)) 
    {
        int iAmt;
        int iFmtWidth = ped->rcFmt.right - ped->rcFmt.left;

        if (ped->fAutoVScroll) 
        {
            iLineMax = ped->ichScreenStart + ped->ichLinesOnScreen - 1;

            if (fVScroll = (ped->iCaretLine > iLineMax))
            {
                iAmt = iLineMax;
            }
            else if (fVScroll = (ped->iCaretLine < ped->ichScreenStart))
            {
                iAmt = ped->ichScreenStart;
            }

            if (fVScroll)
            {
                EditML_Scroll(ped, TRUE, EM_LINESCROLL, ped->iCaretLine - iAmt, TRUE);
            }
        }

        if (ped->fAutoHScroll && ((int) ped->maxPixelWidth > iFmtWidth)) 
        {
            POINT pt;

            //
            // Get the current position of the caret in pixels
            //
            if ((UINT) (ped->cLines - 1) != ped->iCaretLine &&
                ped->ichCaret == ped->chLines[ped->iCaretLine + 1])
            {
                fPrevLine = TRUE;
            }
            else
            {
                fPrevLine = FALSE;
            }

            hdc = Edit_GetDC(ped,TRUE);
            EditML_IchToXYPos(ped, hdc, ped->ichCaret, fPrevLine, &pt);
            Edit_ReleaseDC(ped, hdc, TRUE);
            xposition = pt.x;

            //
            // Remember, EditML_IchToXYPos returns coordinates with respect to the
            // top left pixel displayed on the screen.  Thus, if xPosition < 0,
            // it means xPosition is less than current ped->xOffset.
            //

            iFmtWidth /= 3;
            if (fHScroll = (xposition < ped->rcFmt.left))
            {
                //
                // scroll to the left
                //
                iAmt = ped->rcFmt.left + iFmtWidth;
            }
            else if (fHScroll = (xposition > ped->rcFmt.right))
            {
                //
                // scroll to the right
                //
                iAmt = ped->rcFmt.right - iFmtWidth;
            }

            if (fHScroll)
            {
                EditML_Scroll(ped, FALSE, EM_LINESCROLL, (xposition - iAmt) / ped->aveCharWidth, TRUE);
            }
        }
    }
    return fVScroll;
}


//---------------------------------------------------------------------------//
// 
// EditML_WndProc
// 
// Class procedure for all multi line edit controls.
// Dispatches all messages to the appropriate handlers which are named
// as follows:
//
// EditSL_ (single line) prefixes all single line edit control procedures while
// Edit_   (edit control) prefixes all common handlers.
//
// The EditML_WndProc only handles messages specific to multi line edit
// controls.
//
LRESULT EditML_WndProc(PED ped, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    LPRECT      lprc;
    POINT       pt;
    DWORD       windowstyle;
    static INT  scWheelDelta;

    switch (message) 
    {

    case WM_INPUTLANGCHANGE:
        if (ped && ped->fFocus && ped->pLpkEditCallout) 
        {
            INT cxCaret;

            SystemParametersInfo(SPI_GETCARETWIDTH, 0, (LPVOID)&cxCaret, 0);

            HideCaret(ped->hwnd);
            hdc = Edit_GetDC(ped, TRUE);
            DestroyCaret();

            ped->pLpkEditCallout->EditCreateCaret((PED0)ped, hdc, cxCaret, ped->lineHeight, (UINT)lParam);

            EditML_SetCaretPosition(ped, hdc);
            Edit_ReleaseDC(ped, hdc, TRUE);
            ShowCaret(ped->hwnd);
        }
        goto PassToDefaultWindowProc;


    case WM_STYLECHANGED:
        if (ped && ped->pLpkEditCallout) 
        {
            switch (wParam) 
            {

                case GWL_STYLE:
                    Edit_UpdateFormat(ped,
                        ((LPSTYLESTRUCT)lParam)->styleNew,
                        GET_EXSTYLE(ped));

                    return 1L;

                case GWL_EXSTYLE:
                    Edit_UpdateFormat(ped,
                        GET_STYLE(ped),
                        ((LPSTYLESTRUCT)lParam)->styleNew);

                    return 1L;
            }
        }

        goto PassToDefaultWindowProc;

    case WM_CHAR:

        //
        // wParam - the value of the key
        // lParam - modifiers, repeat count etc (not used)
        //
        EditML_Char(ped, (UINT)wParam, 0);

        break;

    case WM_ERASEBKGND:  
    {
        RECT    rc;
        GetClientRect(ped->hwnd, &rc);
#ifdef _USE_DRAW_THEME_TEXT_
        if (!ped->hTheme)
#endif // _USE_DRAW_THEME_TEXT_
        {
            HBRUSH hbr = NULL;
            BOOL   fNeedDelete = FALSE;

            hbr = Edit_GetBrush(ped, (HDC)wParam, &fNeedDelete);
            if (hbr)
            {
                FillRect((HDC)wParam, &rc, hbr);

                if (fNeedDelete)
                {
                    DeleteObject(hbr);
                }
            }

        }
#ifdef _USE_DRAW_THEME_TEXT_
        else
        {
            HRESULT hr;
            INT     iStateId = Edit_GetStateId(ped);
            hr = DrawThemeBackground(ped->hTheme, (HDC)wParam, EP_EDITTEXT, iStateId, &rc, 0);
        }
#endif // _USE_DRAW_THEME_TEXT_
        return TRUE;

    }
    case WM_GETDLGCODE: 
    {
            LONG code = DLGC_WANTCHARS | DLGC_HASSETSEL | DLGC_WANTARROWS | DLGC_WANTALLKEYS;

            //
            // !!! JEFFBOG HACK !!!
            // Only set Dialog Box Flag if GETDLGCODE message is generated by
            // IsDialogMessage -- if so, the lParam will be a pointer to the
            // message structure passed to IsDialogMessage; otherwise, lParam
            // will be NULL. Reason for the HACK alert: the wParam & lParam
            // for GETDLGCODE is still not clearly defined and may end up
            // changing in a way that would throw this off
            //
            if (lParam)
            {
               // Mark ML edit ctrl as in a dialog box
               ped->fInDialogBox = TRUE;
            }

            //
            // If this is a WM_SYSCHAR message generated by the UNDO keystroke
            // we want this message so we can EAT IT in "case WM_SYSCHAR:"
            //
            if (lParam && (((LPMSG)lParam)->message == WM_SYSCHAR) &&
                    ((DWORD)((LPMSG)lParam)->lParam & SYS_ALTERNATE) &&
                    ((WORD)wParam == VK_BACK))
            {
                 code |= DLGC_WANTMESSAGE;
            }

            return code;
        }

    case EM_SCROLL:
        message = WM_VSCROLL;

        //
        // FALL THROUGH
        //

    case WM_HSCROLL:
    case WM_VSCROLL:
        return EditML_Scroll(ped, (message==WM_VSCROLL), LOWORD(wParam), HIWORD(wParam), TRUE);

    case WM_MOUSEWHEEL:
    {
        UINT ucWheelScrollLines;

        //
        // Don't handle zoom and datazoom.
        //
        if (wParam & (MK_SHIFT | MK_CONTROL)) 
        {
            goto PassToDefaultWindowProc;
        }

        scWheelDelta -= (short) HIWORD(wParam);
        windowstyle = GET_STYLE(ped);
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, (LPVOID)&ucWheelScrollLines, 0); 
        if (    abs(scWheelDelta) >= WHEEL_DELTA &&
                ucWheelScrollLines > 0 &&
                (windowstyle & (WS_VSCROLL | WS_HSCROLL))) 
        {
            int     cLineScroll;
            BOOL    fVert;
            int     cPage;

            if (windowstyle & WS_VSCROLL) 
            {
                fVert = TRUE;
                cPage = ped->ichLinesOnScreen;
            } 
            else 
            {
                fVert = FALSE;
                cPage = (ped->rcFmt.right - ped->rcFmt.left) / ped->aveCharWidth;
            }

            //
            // Limit a roll of one (1) WHEEL_DELTA to scroll one (1) page.
            //
            cLineScroll = (int) min(
                    (UINT) (max(1, (cPage - 1))),
                    ucWheelScrollLines);

            cLineScroll *= (scWheelDelta / WHEEL_DELTA);
            UserAssert(cLineScroll != 0);
            scWheelDelta = scWheelDelta % WHEEL_DELTA;
            EditML_Scroll(ped, fVert, EM_LINESCROLL, cLineScroll, TRUE);
        }

        break;

    }
    case WM_KEYDOWN:

        //
        // wParam - virt keycode of the given key
        // lParam - modifiers such as repeat count etc. (not used)
        //
        EditML_KeyDown(ped, (UINT)wParam, 0);
        break;

    case WM_KILLFOCUS:

        //
        // wParam - handle of the window that receives the input focus
        // lParam - not used
        //
        scWheelDelta = 0;
        EditML_KillFocus(ped);
        break;

    case WM_CAPTURECHANGED:
        //
        // wParam -- unused
        // lParam -- hwnd of window gaining capture.
        //
        if (ped->fMouseDown) 
        {
            //
            // We don't change the caret pos here.  If this is happening
            // due to button up, then we'll change the pos in the
            // handler after ReleaseCapture().  Otherwise, just end
            // gracefully because someone else has stolen capture out
            // from under us.
            //

            ped->fMouseDown = FALSE;
            KillTimer(ped->hwnd, IDSYS_SCROLL);
        }

        break;

    case WM_SYSTIMER:

        //
        // This allows us to automatically scroll if the user holds the mouse
        // outside the edit control window. We simulate mouse moves at timer
        // intervals set in MouseMotionHandler.
        //
        if (ped->fMouseDown)
        {
            EditML_MouseMotion(ped, WM_MOUSEMOVE, ped->prevKeys, &ped->ptPrevMouse);
        }

        break;

    case WM_MBUTTONDOWN:
        EnterReaderMode(ped->hwnd);

        break;

    case WM_MOUSEMOVE:
        UserAssert(ped->fMouseDown);

        //
        // FALL THROUGH
        //

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
        //
        // wParam - contains a value that indicates which virtual keys are down
        // lParam - contains x and y coords of the mouse cursor
        //
        POINTSTOPOINT(pt, lParam);
        EditML_MouseMotion(ped, message, (UINT)wParam, &pt);

        break;

    case WM_CREATE:

        //
        // wParam - handle to window being created
        // lParam - points to a CREATESTRUCT that contains copies of parameters
        // passed to the CreateWindow function.
        //
        return EditML_Create(ped, (LPCREATESTRUCT)lParam);

    case WM_PRINTCLIENT:
        EditML_Paint(ped, (HDC) wParam, NULL);

        break;

    case WM_PAINT:
        //
        // wParam - can be hdc from subclassed paint
        // lParam - not used
        //
        if (wParam) 
        {
            hdc = (HDC)wParam;
            lprc = NULL;
        } 
        else 
        {
            hdc = BeginPaint(ped->hwnd, &ps);
            lprc = &ps.rcPaint;
        }

        if (IsWindowVisible(ped->hwnd))
        {
            EditML_Paint(ped, hdc, lprc);
        }

        if (!wParam)
        {
            EndPaint(ped->hwnd, &ps);
        }

        break;

    case WM_PASTE:

        //
        // wParam - not used
        // lParam - not used
        //
        if (!ped->fReadOnly)
        {
            EditML_PasteText(ped);
        }

        break;

    case WM_SETFOCUS:

        //
        // wParam - handle of window that loses the input focus (may be NULL)
        // lParam - not used
        //
        EditML_SetFocus(ped);

        break;

    case WM_SIZE:

        //
        // wParam - defines the type of resizing fullscreen, sizeiconic,
        //          sizenormal etc.
        // lParam - new width in LOWORD, new height in HIGHWORD of client area
        //
        Edit_Size(ped, NULL, TRUE);

        break;

    case EM_FMTLINES:

        //
        // wParam - indicates disposition of end-of-line chars. If non
        // zero, the chars CR CR LF are placed at the end of a word
        // wrapped line. If wParam is zero, the end of line chars are
        // removed. This is only done when the user gets a handle (via
        // EM_GETHANDLE) to the text. lParam - not used.
        //
        if (wParam)
        {
            EditML_InsertCrCrLf(ped);
        }
        else
        {
            EditML_StripCrCrLf(ped);
        }

        EditML_BuildchLines(ped, 0, 0, FALSE, NULL, NULL);

        return (LONG)(wParam != 0);

    case EM_GETHANDLE:

        //
        // wParam - not used
        // lParam - not used
        //

        //
        // Returns a handle to the edit control's text.
        //

        //
        // Null terminate the string. Note that we are guaranteed to have the
        // memory for the NULL since Edit_InsertText allocates an extra
        // WCHAR for the NULL terminator.
        //

        if (ped->fAnsi)
        {
            *(Edit_Lock(ped) + ped->cch) = 0;
        }
        else
        {
            *((LPWSTR)Edit_Lock(ped) + ped->cch) = 0;
        }

        Edit_Unlock(ped);

        return ((LRESULT)ped->hText);

    case EM_GETLINE:

        //
        // wParam - line number to copy (0 is first line)
        // lParam - buffer to copy text to. First WORD is max # of bytes to
        // copy
        //
        return EditML_GetLine(ped, (ICH)wParam, (ICH)*(WORD UNALIGNED *)lParam, (LPSTR)lParam);

    case EM_LINEFROMCHAR:

        //
        // wParam - Contains the index value for the desired char in the text
        // of the edit control. These are 0 based.
        // lParam - not used
        //
        return (LRESULT)EditML_IchToLine(ped, (ICH)wParam);

    case EM_LINEINDEX:

        //
        // wParam - specifies the desired line number where the number of the
        // first line is 0. If linenumber = 0, the line with the caret is used.
        // lParam - not used.
        // This function return s the number of character positions that occur
        // preceeding the first char in a given line.
        //
        return (LRESULT)EditML_LineIndex(ped, (ICH)wParam);

    case EM_LINELENGTH:

        //
        // wParam - specifies the character index of a character in the
        // specified line, where the first line is 0. If -1, the length
        // of the current line (with the caret) is return ed not including the
        // length of any selected text.
        // lParam - not used
        //
        return (LRESULT)EditML_LineLength(ped, (ICH)wParam);

    case EM_LINESCROLL:

        //
        // wParam - not used
        // lParam - Contains the number of lines and char positions to scroll
        //
        EditML_Scroll(ped, TRUE,  EM_LINESCROLL, (INT)lParam, TRUE);
        EditML_Scroll(ped, FALSE, EM_LINESCROLL, (INT)wParam, TRUE);

        break;

    case EM_REPLACESEL:

        //
        // wParam - flag for 4.0+ apps saying whether to clear undo
        // lParam - Points to a null terminated replacement text.
        //
        EditML_ReplaceSel(ped, (LPSTR)lParam);

        if (!ped->f40Compat || !wParam)
        {
            Edit_EmptyUndo(Pundo(ped));
        }

        break;

    case EM_SETHANDLE:

        //
        // wParam - contains a handle to the text buffer
        // lParam - not used
        //
        EditML_SetHandle(ped, (HANDLE)wParam);

        break;

    case EM_SETRECT:
    case EM_SETRECTNP:

        //
        // wParamLo --    not used
        // lParam --    LPRECT with new formatting area
        //
        Edit_Size(ped, (LPRECT) lParam, (message != EM_SETRECTNP));

        break;

    case EM_SETSEL:

        //
        // wParam - Under 3.1, specifies if we should scroll caret into
        // view or not. 0 == scroll into view. 1 == don't scroll
        // lParam - starting pos in lowword ending pos in high word
        // 
        // Under Win32, wParam is the starting pos, lParam is the
        // ending pos, and the caret is not scrolled into view.
        // The message EM_SCROLLCARET forces the caret to be scrolled
        // into view.
        //
        EditML_SetSelection(ped, TRUE, (ICH)wParam, (ICH)lParam);

        break;

    case EM_SCROLLCARET:

        //
        // Scroll caret into view
        //
        EditML_EnsureCaretVisible(ped);
        break;

    case EM_GETFIRSTVISIBLELINE:

        //
        // Returns the first visible line for multiline edit controls.
        //
        return (LONG)ped->ichScreenStart;

    case WM_SYSKEYDOWN:
        if (((WORD)wParam == VK_BACK) && ((DWORD)lParam & SYS_ALTERNATE)) 
        {
            SendMessage(ped->hwnd, EM_UNDO, 0, 0L);
            break;
        }

        goto PassToDefaultWindowProc;

    case WM_UNDO:
    case EM_UNDO:
        return EditML_Undo(ped);

    case EM_SETTABSTOPS:

        //
        // This sets the tab stop positions for multiline edit controls.
        // wParam - Number of tab stops
        // lParam - Far ptr to a UINT array containing the Tab stop positions
        //
        return EditML_SetTabStops(ped, (int)wParam, (LPINT)lParam);

    case EM_POSFROMCHAR:
        //
        // wParam --    char index in text
        // lParam --    not used
        // This function returns the (x,y) position of the character
        //
    case EM_CHARFROMPOS:
        //
        // wParam --    unused
        // lParam --    pt in client coordinates
        // This function returns
        //      LOWORD: the position of the closest character
        //              to the passed in point.  Beware of
        //              points not actually in the edit client...
        //      HIWORD: the index of the line the char is on
        //
        {
            LONG  xyPos;
            LONG  line;

            hdc = Edit_GetDC(ped, TRUE);

            if (message == EM_POSFROMCHAR) 
            {
                EditML_IchToXYPos(ped, hdc, (ICH)wParam, FALSE, &pt);
                xyPos = MAKELONG(pt.x, pt.y);
            } 
            else 
            {
                POINTSTOPOINT(pt, lParam);
                xyPos = EditML_MouseToIch(ped, hdc, &pt, &line);
                xyPos = MAKELONG(xyPos, line);
            }

            Edit_ReleaseDC(ped, hdc, TRUE);

            return (LRESULT)xyPos;
        }

    case WM_SETREDRAW:
        DefWindowProc(ped->hwnd, message, wParam, lParam);
        if (wParam) 
        {
            //
            // Backwards compatability hack needed so that winraid's edit
            // controls work fine.
            //
            RedrawWindow(ped->hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME);
        }

        break;

    default:
PassToDefaultWindowProc:
        return DefWindowProc(ped->hwnd, message, wParam, lParam);
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// EditML_DrawText AorW
// 
// This function draws all the characters between ichStart and ichEnd for
// the given Multiline Edit Control.
//
// This function divides the block of text between ichStart and ichEnd
// into lines and each line into strips of text based on the selection
// attributes. It calls Edit_TabTheTextOut() to draw each strip.
// This takes care of the Negative A anc C widths of the current font, if
// it has any, on either side of each strip of text.
//
// NOTE: If the language pack is loaded the text is not divided into strips,
// nor is selection highlighting performed here. Whole lines are passed
// to the language pack to display with tab expansion and selection
// highlighting. (Since the language pack supports scripts with complex
// character re-ordering rules, only it can do this).
//
VOID EditML_DrawText(PED ped, HDC hdc, ICH ichStart, ICH ichEnd, BOOL fSelChange)
{
    DWORD   textColorSave;
    DWORD   bkColorSave;
    PSTR    pText;
    UINT    wCurLine;
    UINT    wEndLine;
    INT     xOffset;
    ICH     LengthToDraw;
    ICH     CurStripLength;
    ICH     ichAttrib, ichNewStart;
    ICH     ExtraLengthForNegA;
    ICH     ichT;
    INT     iRemainingLengthInLine;
    INT     xStPos, xClipStPos, xClipEndPos, yPos;

    BOOL    fFirstLineOfBlock   = TRUE;
    BOOL    fDrawEndOfLineStrip = FALSE;
    BOOL    fDrawOnSameLine     = FALSE;
    BOOL    fSelected           = FALSE;
    BOOL    fLineBegins         = FALSE;

    STRIPINFO   NegCInfo;
    POINT   pt;
    HBRUSH  hbr = NULL;
    BOOL    fNeedDelete = FALSE;
 
    //
    // Just return if nothing to draw
    //
    if (!ped->ichLinesOnScreen)
    {
        return;
    }

    hbr = Edit_GetBrush(ped, hdc, &fNeedDelete);
    if (hbr && fNeedDelete)
    {
        DeleteObject(hbr);
    }

    //
    // Adjust the value of ichStart such that we need to draw only those lines
    // visible on the screen.
    //
    if ((UINT)ichStart < (UINT)ped->chLines[ped->ichScreenStart]) 
    {
        ichStart = ped->chLines[ped->ichScreenStart];
        if (ichStart > ichEnd)
        {
            return;
        }
    }

    //
    // Adjust the value of ichEnd such that we need to draw only those lines
    // visible on the screen.
    //
    wCurLine = min(ped->ichScreenStart+ped->ichLinesOnScreen,ped->cLines-1);
    ichT = ped->chLines[wCurLine] + EditML_Line(ped, wCurLine);
    ichEnd = min(ichEnd, ichT);

    wCurLine = EditML_IchToLine(ped, ichStart);  // Starting line.
    wEndLine = EditML_IchToLine(ped, ichEnd);    // Ending line.

    UserAssert(ped->chLines[wCurLine] <= ped->cch + 1);
    UserAssert(ped->chLines[wEndLine] <= ped->cch + 1);

    if (fSelChange && (GetBkMode(hdc) != OPAQUE))
    {
        //
        // if changing selection on a transparent edit control, just
        // draw those lines from scratch
        //
        RECT rcStrip;
        CopyRect(&rcStrip, &ped->rcFmt);
        rcStrip.left -= ped->wLeftMargin;
        if (ped->pLpkEditCallout) 
        {
            rcStrip.right += ped->wRightMargin;
        }

        rcStrip.top += (wCurLine - ped->ichScreenStart) * ped->lineHeight;
        rcStrip.bottom = rcStrip.top + ((wEndLine - wCurLine) + 1) * ped->lineHeight;
        InvalidateRect(ped->hwnd, &rcStrip, TRUE);
        return;
    }

    //
    // If it is either centered or right-justified, then draw the whole lines.
    // Also draw whole lines if the language pack is handling line layout.
    //
    if ((ped->format != ES_LEFT) || (ped->pLpkEditCallout)) 
    {
        ichStart = ped->chLines[wCurLine];
        ichEnd = ped->chLines[wEndLine] + EditML_Line(ped, wEndLine);
    }

    pText = Edit_Lock(ped);

    HideCaret(ped->hwnd);

    //
    // If ichStart stays on Second byte of DBCS, we have to
    // adjust it. LiZ -- 5/5/93
    //
    if (ped->fAnsi && ped->fDBCS) 
    {
        ichStart = Edit_AdjustIch( ped, pText, ichStart );
    }
    UserAssert(ichStart <= ped->cch);
    UserAssert(ichEnd <= ped->cch);

    while (ichStart <= ichEnd) 
    {
        //
        // Pass whole lines to the language pack to display with selection
        // marking and tab expansion.
        //
        if (ped->pLpkEditCallout) 
        {
            ped->pLpkEditCallout->EditDrawText(
                (PED0)ped, hdc, pText + ped->cbChar*ichStart,
                EditML_Line(ped, wCurLine),
                (INT)ped->ichMinSel - (INT)ichStart, (INT)ped->ichMaxSel - (INT)ichStart,
                EditML_IchToYPos(ped, ichStart, FALSE));
        } 
        else 
        {
        
            //
            // xStPos:      The starting Position where the string must be drawn.
            // xClipStPos:  The starting position for the clipping rect for the block.
            // xClipEndPos: The ending position for the clipping rect for the block.
            //

            //
            // Calculate the xyPos of starting point of the block.
            //
            EditML_IchToXYPos(ped, hdc, ichStart, FALSE, &pt);
            xClipStPos = xStPos = pt.x;
            yPos = pt.y;

            //
            // The attributes of the block is the same as that of ichStart.
            //
            ichAttrib = ichStart;

            //
            // If the current font has some negative C widths and if this is the
            // begining of a block, we must start drawing some characters before the
            // block to account for the negative C widths of the strip before the
            // current strip; In this case, reset ichStart and xStPos.
            //

            if (fFirstLineOfBlock && ped->wMaxNegC) 
            {
                fFirstLineOfBlock = FALSE;
                ichNewStart = max(((int)(ichStart - ped->wMaxNegCcharPos)), ((int)ped->chLines[wCurLine]));

                //
                // If ichStart needs to be changed, then change xStPos also accordingly.
                //
                if (ichNewStart != ichStart) 
                {
                    if (ped->fAnsi && ped->fDBCS) 
                    {
                        //
                        // Adjust DBCS alignment...
                        //
                        ichNewStart = Edit_AdjustIchNext( ped, pText, ichNewStart );
                    }
                    EditML_IchToXYPos(ped, hdc, ichStart = ichNewStart, FALSE, &pt);
                    xStPos = pt.x;
                }
            }

            //
            // Calc the number of characters remaining to be drawn in the current line.
            //
            iRemainingLengthInLine = EditML_Line(ped, wCurLine) -
                                    (ichStart - ped->chLines[wCurLine]);

            //
            // If this is the last line of a block, we may not have to draw all the
            // remaining lines; We must draw only upto ichEnd.
            //
            if (wCurLine == wEndLine)
            {
                LengthToDraw = ichEnd - ichStart;
            }
            else
            {
                LengthToDraw = iRemainingLengthInLine;
            }

            //
            // Find out how many pixels we indent the line for non-left-justified
            // formats
            //
            if (ped->format != ES_LEFT)
            {
                xOffset = EditML_CalcXOffset(ped, hdc, wCurLine);
            }
            else
            {
                xOffset = -((int)(ped->xOffset));
            }

            //
            // Check if this is the begining of a line.
            //
            if (ichAttrib == ped->chLines[wCurLine]) 
            {
                fLineBegins = TRUE;
                xClipStPos = ped->rcFmt.left - ped->wLeftMargin;
            }

            //
            // The following loop divides this 'wCurLine' into strips based on the
            // selection attributes and draw them strip by strip.
            //
            do  
            {
                //
                // If ichStart is pointing at CRLF or CRCRLF, then iRemainingLength
                // could have become negative because MLLine does not include
                // CR and LF at the end of a line.
                //
                if (iRemainingLengthInLine < 0)  // If Current line is completed,
                {
                    break;                   // go on to the next line.
                }

                //
                // Check if a part of the block is selected and if we need to
                // show it with a different attribute.
                //
                if (!(ped->ichMinSel == ped->ichMaxSel ||
                            ichAttrib >= ped->ichMaxSel ||
                            ichEnd   <  ped->ichMinSel ||
                            (!ped->fNoHideSel && !ped->fFocus))) 
                {
                    //
                    // OK! There is a selection somewhere in this block!
                    // Check if this strip has selection attribute.
                    //
                    if (ichAttrib < ped->ichMinSel) 
                    {
                        fSelected = FALSE;  // This strip is not selected

                        // Calculate the length of this strip with normal attribute.
                        CurStripLength = min(ichStart+LengthToDraw, ped->ichMinSel)-ichStart;
                        fLineBegins = FALSE;
                    } 
                    else 
                    {
                        //
                        // The current strip has the selection attribute.
                        //
                        if (fLineBegins) // Is it the first part of a line?
                        {  
                            //
                            // Then, draw the left margin area with normal attribute.
                            //
                            fSelected = FALSE;
                            CurStripLength = 0;
                            xClipStPos = ped->rcFmt.left - ped->wLeftMargin;
                            fLineBegins = FALSE;
                        } 
                        else 
                        {
                            //
                            // Else, draw the strip with selection attribute.
                            //
                            fSelected = TRUE;
                            CurStripLength = min(ichStart+LengthToDraw, ped->ichMaxSel)-ichStart;

                            //
                            // Select in the highlight colors.
                            //
                            bkColorSave = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                            if (!ped->fDisabled)
                            {
                                textColorSave = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                            }
                        }
                    }
                } 
                else 
                {
                    //
                    // The whole strip has no selection attributes.
                    //
                    CurStripLength = LengthToDraw;
                }

                //
                // Other than the current strip, do we still have anything
                // left to be drawn in the current line?
                //
                fDrawOnSameLine = (LengthToDraw != CurStripLength);

                //
                // When we draw this strip, we need to draw some more characters
                // beyond the end of this strip to account for the negative A
                // widths of the characters that follow this strip.
                //
                ExtraLengthForNegA = min(iRemainingLengthInLine-CurStripLength, ped->wMaxNegAcharPos);

                //
                // The blank strip at the end of the line needs to be drawn with
                // normal attribute irrespective of whether the line has selection
                // attribute or not. Hence, if the last strip of the line has selection
                // attribute, then this blank strip needs to be drawn separately.
                // Else, we can draw the blank strip along with the last strip.
                //

                //
                // Is this the last strip of the current line?
                //
                if (iRemainingLengthInLine == (int)CurStripLength) 
                {
                    if (fSelected)  // Does this strip have selection attribute?
                    { 
                        //
                        // Then we need to draw the end of line strip separately.
                        //
                        fDrawEndOfLineStrip = TRUE;  // Draw the end of line strip.
                        EditML_IchToXYPos(ped, hdc, ichStart+CurStripLength, TRUE, &pt);
                        xClipEndPos = pt.x;
                    } 
                    else 
                    {
                        //
                        // Set the xClipEndPos to a big value sothat the blank
                        // strip will be drawn automatically when the last strip
                        // is drawn.
                        //
                        xClipEndPos = MAXCLIPENDPOS;
                    }
                } 
                else 
                {
                    //
                    // This is not the last strip of this line; So, set the ending
                    // clip position accurately.
                    //
                    EditML_IchToXYPos(ped, hdc, ichStart+CurStripLength, FALSE, &pt);
                    xClipEndPos = pt.x;
                }

                //
                // Draw the current strip starting from xStPos, clipped to the area
                // between xClipStPos and xClipEndPos. Obtain "NegCInfo" and use it
                // in drawing the next strip.
                //
                Edit_TabTheTextOut(hdc, xClipStPos, xClipEndPos,
                        xStPos, yPos, (LPSTR)(pText+ichStart*ped->cbChar),
                    CurStripLength+ExtraLengthForNegA, ichStart, ped,
                    ped->rcFmt.left+xOffset, fSelected ? ECT_SELECTED : ECT_NORMAL, &NegCInfo);

                if (fSelected) 
                {
                    //
                    // If this strip was selected, then the next strip won't have
                    // selection attribute
                    //
                    fSelected = FALSE;
                    SetBkColor(hdc, bkColorSave);
                    if (!ped->fDisabled)
                    {
                        SetTextColor(hdc, textColorSave);
                    }
                }

                //
                // Do we have one more strip to draw on the current line?
                //
                if (fDrawOnSameLine || fDrawEndOfLineStrip) 
                {
                    int  iLastDrawnLength;

                    //
                    // Next strip's attribute is decided based on the char at ichAttrib
                    //
                    ichAttrib = ichStart + CurStripLength;

                    //
                    // When drawing the next strip, start at a few chars before
                    // the actual start to account for the Neg 'C' of the strip
                    // just drawn.
                    //
                    iLastDrawnLength = CurStripLength +ExtraLengthForNegA - NegCInfo.nCount;
                    //
                    // Adjust DBCS alignment...
                    //
                    if (ped->fAnsi && ped->fDBCS) 
                    {
                        ichNewStart = Edit_AdjustIch(ped,pText,ichStart+iLastDrawnLength);
                        iLastDrawnLength = ichNewStart - ichStart;
                        ichStart = ichNewStart;
                    } 
                    else 
                    {
                        ichStart += iLastDrawnLength;
                    }
                    LengthToDraw -= iLastDrawnLength;
                    iRemainingLengthInLine -= iLastDrawnLength;

                    //
                    // The start of clip rect for the next strip.
                    //
                    xStPos = NegCInfo.XStartPos;
                    xClipStPos = xClipEndPos;
                }

                //
                // Draw the blank strip at the end of line seperately, if required.
                //
                if (fDrawEndOfLineStrip) 
                {
                    Edit_TabTheTextOut(hdc, xClipStPos, MAXCLIPENDPOS, xStPos, yPos,
                        (LPSTR)(pText+ichStart*ped->cbChar), LengthToDraw, ichStart,
                        ped, ped->rcFmt.left+xOffset, ECT_NORMAL, &NegCInfo);

                    fDrawEndOfLineStrip = FALSE;
                }
            }
            while(fDrawOnSameLine);   // do while loop ends here.
        }

        // Let us move on to the next line of this block to be drawn.
        wCurLine++;
        if (ped->cLines > wCurLine)
        {
            ichStart = ped->chLines[wCurLine];
        }
        else
        {
            ichStart = ichEnd+1;   // We have reached the end of the text.
        }
    }  // while loop ends here

    Edit_Unlock(ped);

    ShowCaret(ped->hwnd);
    EditML_SetCaretPosition(ped, hdc);
}


//---------------------------------------------------------------------------//
//
// Multi-Line Support Routines called Rarely


//---------------------------------------------------------------------------//
//
// EditML_InsertCrCrLf AorW
//
// Inserts CR CR LF characters into the text at soft (word-wrap) line
// breaks. CR LF (hard) line breaks are unaffected. Assumes that the text
// has already been formatted ie. ped->chLines is where we want the line
// breaks to occur. Note that ped->chLines is not updated to reflect the
// movement of text by the addition of CR CR LFs. Returns TRUE if successful
// else notify parent and return FALSE if the memory couldn't be allocated.
//
BOOL EditML_InsertCrCrLf(PED ped)
{
    ICH dch;
    ICH li;
    ICH lineSize;
    unsigned char *pchText;
    unsigned char *pchTextNew;

    if (!ped->fWrap || !ped->cch) 
    {
        //
        // There are no soft line breaks if word-wrapping is off or if no chars
        //
        return TRUE;
    }

    //
    // Calc an upper bound on the number of additional characters we will be
    // adding to the text when we insert CR CR LFs.
    //
    dch = 3 * ped->cLines;

    if (!LocalReAlloc(ped->hText, (ped->cch + dch) * ped->cbChar, 0)) 
    {
        Edit_NotifyParent(ped, EN_ERRSPACE);
        return FALSE;
    }

    ped->cchAlloc = ped->cch + dch;

    //
    // Move the text up dch bytes and then copy it back down, inserting the CR
    // CR LF's as necessary.
    //
    pchTextNew = pchText = Edit_Lock(ped);
    pchText += dch * ped->cbChar;

    //
    // We will use dch to keep track of how many chars we add to the text
    //
    dch = 0;

    //
    // Copy the text up dch bytes to pchText. This will shift all indices in
    // ped->chLines up by dch bytes.
    //
    memmove(pchText, pchTextNew, ped->cch * ped->cbChar);

    //
    // Now copy chars from pchText down to pchTextNew and insert CRCRLF at soft
    // line breaks.
    //
    if (ped->fAnsi) 
    {
        for (li = 0; li < ped->cLines - 1; li++) 
        {
            lineSize = ped->chLines[li + 1] - ped->chLines[li];
            memmove(pchTextNew, pchText, lineSize);
            pchTextNew += lineSize;
            pchText += lineSize;

            //
            // If last character in newly copied line is not a line feed, then we
            // need to add the CR CR LF triple to the end
            //
            if (*(pchTextNew - 1) != 0x0A) 
            {
                *pchTextNew++ = 0x0D;
                *pchTextNew++ = 0x0D;
                *pchTextNew++ = 0x0A;
                dch += 3;
            }
        }

        //
        // Now move the last line up. It won't have any line breaks in it...
        //
        memmove(pchTextNew, pchText, ped->cch - ped->chLines[ped->cLines - 1]);
    } 
    else 
    {
        LPWSTR pwchTextNew = (LPWSTR)pchTextNew;

        for (li = 0; li < ped->cLines - 1; li++) 
        {
            lineSize = ped->chLines[li + 1] - ped->chLines[li];
            memmove(pwchTextNew, pchText, lineSize * sizeof(WCHAR));
            pwchTextNew += lineSize;
            pchText += lineSize * sizeof(WCHAR);

            //
            // If last character in newly copied line is not a line feed, then we
            // need to add the CR CR LF triple to the end
            //
            if (*(pwchTextNew - 1) != 0x0A) 
            {
                *pwchTextNew++ = 0x0D;
                *pwchTextNew++ = 0x0D;
                *pwchTextNew++ = 0x0A;
                dch += 3;
            }
        }

        //
        // Now move the last line up. It won't have any line breaks in it...
        //
        memmove(pwchTextNew, pchText,
            (ped->cch - ped->chLines[ped->cLines - 1]) * sizeof(WCHAR));
    }

    Edit_Unlock(ped);

    if (dch) 
    {
        //
        // Update number of characters in text handle
        //
        ped->cch += dch;

        //
        // So that the next time we do anything with the text, we can strip the
        // CRCRLFs
        //
        ped->fStripCRCRLF = TRUE;

        return TRUE;
    }

    return FALSE;
}


//---------------------------------------------------------------------------//
//
// EditML_StripCrCrLf AorW
//
// Strips the CR CR LF character combination from the text. This
// shows the soft (word wrapped) line breaks. CR LF (hard) line breaks are
// unaffected.
//
void EditML_StripCrCrLf(PED ped)
{
    if (ped->cch) 
    {
        if (ped->fAnsi) 
        {
            unsigned char *pchSrc;
            unsigned char *pchDst;
            unsigned char *pchLast;

            pchSrc = pchDst = Edit_Lock(ped);
            pchLast = pchSrc + ped->cch;
            while (pchSrc < pchLast) 
            {
                if (   (pchSrc[0] == 0x0D)
                    && (pchSrc[1] == 0x0D)
                    && (pchSrc[2] == 0x0A)
                ) 
                {
                    pchSrc += 3;
                    ped->cch -= 3;
                } 
                else 
                {
                    *pchDst++ = *pchSrc++;
                }
            }
        }   
        else 
        {
            LPWSTR pwchSrc;
            LPWSTR pwchDst;
            LPWSTR pwchLast;

            pwchSrc = pwchDst = (LPWSTR)Edit_Lock(ped);
            pwchLast = pwchSrc + ped->cch;
            while (pwchSrc < pwchLast) 
            {
                if (   (pwchSrc[0] == 0x0D)
                    && (pwchSrc[1] == 0x0D)
                    && (pwchSrc[2] == 0x0A)
                ) 
                {
                    pwchSrc += 3;
                    ped->cch -= 3;
                } 
                else 
                {
                    *pwchDst++ = *pwchSrc++;
                }
            }
        }

        Edit_Unlock(ped);

        //
        // Make sure we don't have any values past the last character
        //
        if (ped->ichCaret > ped->cch)
        {
            ped->ichCaret  = ped->cch;
        }

        if (ped->ichMinSel > ped->cch)
        {
            ped->ichMinSel = ped->cch;
        }

        if (ped->ichMaxSel > ped->cch)
        {
            ped->ichMaxSel = ped->cch;
        }
    }
}


//---------------------------------------------------------------------------//
//
// EditML_SetHandle AorW
//
// Sets the ped to contain the given handle.
//
void EditML_SetHandle(PED ped, HANDLE hNewText)
{
    ICH newCch;

    ped->cch = ped->cchAlloc =
            (ICH)LocalSize(ped->hText = hNewText) / ped->cbChar;
    ped->fEncoded = FALSE;

    if (ped->cch) 
    {
        //
        // We have to do it this way in case the app gives us a zero size handle
        //
        if (ped->fAnsi)
        {
            ped->cch = strlen(Edit_Lock(ped));
        }
        else
        {
            ped->cch = wcslen((LPWSTR)Edit_Lock(ped));
        }

        Edit_Unlock(ped);
    }

    newCch = (ICH)(ped->cch + CCHALLOCEXTRA);

    //
    // We do this LocalReAlloc in case the app changed the size of the handle
    //
    if (LocalReAlloc(ped->hText, newCch*ped->cbChar, 0))
    {
        ped->cchAlloc = newCch;
    }

    Edit_ResetTextInfo(ped);
}


//---------------------------------------------------------------------------//
//
// EditML_GetLine AorW
//
// Copies maxCchToCopy bytes of line lineNumber to the buffer
// lpBuffer. The string is not zero terminated.
// 
// Returns number of characters copied
//
LONG EditML_GetLine(PED ped, ICH lineNumber, ICH maxCchToCopy, LPSTR lpBuffer)
{
    PSTR pText;
    ICH cchLen;

    if (lineNumber > ped->cLines - 1) 
    {
        TraceMsg(TF_STANDARD,
                "Edit: Invalid parameter \"lineNumber\" (%ld) to EditML_GetLine",
                lineNumber);

        return 0L;
    }

    cchLen = EditML_Line(ped, lineNumber);
    maxCchToCopy = min(cchLen, maxCchToCopy);

    if (maxCchToCopy) 
    {
        pText = Edit_Lock(ped) +
                ped->chLines[lineNumber] * ped->cbChar;
        memmove(lpBuffer, pText, maxCchToCopy*ped->cbChar);
        Edit_Unlock(ped);
    }

    return maxCchToCopy;
}


//---------------------------------------------------------------------------//
//
// EditML_LineIndex AorW
//
// This function return s the number of character positions that occur
// preceeding the first char in a given line.
//
ICH EditML_LineIndex( PED ped, ICH iLine)
{
    if (iLine == -1)
    {
        iLine = ped->iCaretLine;
    }

    if (iLine < ped->cLines) 
    {
        return ped->chLines[iLine];
    } 
    else 
    {
        TraceMsg(TF_STANDARD,
                "Edit: Invalid parameter \"iLine\" (%ld) to EditML_LineIndex",
                iLine);

        return (ICH)-1;
    }
}


//---------------------------------------------------------------------------//
//
// EditML_LineLength AorW
//
// if ich = -1, return the length of the lines containing the current
// selection but not including the selection. Otherwise, return the length of
// the line containing ich.
//
ICH EditML_LineLength(PED ped, ICH ich)
{
    ICH il1, il2;
    ICH temp;

    if (ich != 0xFFFFFFFF)
    {
        return (EditML_Line(ped, EditML_IchToLine(ped, ich)));
    }

    //
    // Find length of lines corresponding to current selection
    //
    il1 = EditML_IchToLine(ped, ped->ichMinSel);
    il2 = EditML_IchToLine(ped, ped->ichMaxSel);
    if (il1 == il2)
    {
        return (EditML_Line(ped, il1) - (ped->ichMaxSel - ped->ichMinSel));
    }

    temp = ped->ichMinSel - ped->chLines[il1];
    temp += EditML_Line(ped, il2);
    temp -= (ped->ichMaxSel - ped->chLines[il2]);

    return temp;
}


//---------------------------------------------------------------------------//
// 
// EditML_SetSelection AorW
//
// Sets the selection to the points given and puts the cursor at
// ichMaxSel.
//
VOID EditML_SetSelection(PED ped, BOOL fDoNotScrollCaret, ICH ichMinSel, ICH ichMaxSel)
{
    HDC hdc;

    if (ichMinSel == 0xFFFFFFFF) 
    {
        //
        // Set no selection if we specify -1
        //
        ichMinSel = ichMaxSel = ped->ichCaret;
    }

    //
    // Since these are unsigned, we don't check if they are greater than 0.
    //
    ichMinSel = min(ped->cch, ichMinSel);
    ichMaxSel = min(ped->cch, ichMaxSel);

#ifdef FE_SB // EditML_SetSelectionHander()
    //
    // To avoid position to half of DBCS, check and ajust position if necessary
    //
    // We check ped->fDBCS and ped->fAnsi though Edit_AdjustIch checks these bits
    // at first. We're worrying about the overhead of Edit_Lock and Edit_Unlock.
    //
    if ( ped->fDBCS && ped->fAnsi ) 
    {
        PSTR pText;

        pText = Edit_Lock(ped);

        ichMinSel = Edit_AdjustIch( ped, pText, ichMinSel );
        ichMaxSel = Edit_AdjustIch( ped, pText, ichMaxSel );

        Edit_Unlock(ped);
    }
#endif // FE_SB

    //
    // Set the caret's position to be at ichMaxSel.
    //
    ped->ichCaret = ichMaxSel;
    ped->iCaretLine = EditML_IchToLine(ped, ped->ichCaret);

    hdc = Edit_GetDC(ped, FALSE);
    EditML_ChangeSelection(ped, hdc, ichMinSel, ichMaxSel);

    EditML_SetCaretPosition(ped, hdc);
    Edit_ReleaseDC(ped, hdc, FALSE);

#ifdef FE_SB // EditML_SetSelectionHander()
    if (!fDoNotScrollCaret)
    {
        EditML_EnsureCaretVisible(ped);
    }

    //
    // #ifdef KOREA is history, with FE_SB (FarEast Single Binary).
    //
#else
#ifdef KOREA
    //
    // Extra parameter specified interim character mode
    //
    EditML_EnsureCaretVisible(ped,NULL);
#else
    if (!fDoNotScrollCaret)
    {
        EditML_EnsureCaretVisible(ped);
    }
#endif
#endif // FE_SB

}


//---------------------------------------------------------------------------//
//
// EditML_SetTabStops AorW
//
// This sets the tab stop positions set by the App by sending
// a EM_SETTABSTOPS message.
// 
// nTabPos : Number of tab stops set by the caller
// lpTabStops: array of tab stop positions in Dialog units.
// 
// Returns:
// TRUE if successful
// FALSE if memory allocation error.
//
BOOL EditML_SetTabStops(PED ped, int nTabPos, LPINT lpTabStops)
{
    int *pTabStops;

    //
    // Check if tab positions already exist
    //
    if (!ped->pTabStops) 
    {
        //
        // Check if the caller wants the new tab positions
        //
        if (nTabPos) 
        {
            //
            // Allocate the array of tab stops
            //
            pTabStops = (LPINT)UserLocalAlloc(HEAP_ZERO_MEMORY, (nTabPos + 1) * sizeof(int));
            if (!pTabStops) 
            {
                return FALSE;
            }
        } 
        else 
        {
            //
            // No stops then and no stops now!
            //
            return TRUE;
        }
    } 
    else 
    {
        //
        // Check if the caller wants the new tab positions
        //
        if (nTabPos) 
        {
            //
            // Check if the number of tab positions is different
            //
            if (ped->pTabStops[0] != nTabPos) 
            {
                //
                // Yes! So ReAlloc to new size
                //
                pTabStops = (LPINT)UserLocalReAlloc(ped->pTabStops, (nTabPos + 1) * sizeof(int), 0);
                if (!pTabStops)
                {
                    return FALSE;
                }
            } 
            else 
            {
                pTabStops = ped->pTabStops;
            }
        } 
        else 
        {
            //
            // Caller wants to remove all the tab stops; So, release
            //
            if (!UserLocalFree(ped->pTabStops))
            {
                return FALSE;
            }

            ped->pTabStops = NULL;

            goto RedrawAndReturn;
        }
    }

    //
    // Copy the new tab stops onto the tab stop array after converting the
    // dialog co-ordinates into the pixel co-ordinates
    //
    ped->pTabStops = pTabStops;

    //
    // First element contains the count
    //
    *pTabStops++ = nTabPos;
    while (nTabPos--) 
    {
        //
        // aveCharWidth must be used instead of cxSysCharWidth.
        // Fix for Bug #3871 --SANKAR-- 03/14/91
        //
        *pTabStops++ = MultDiv(*lpTabStops++, ped->aveCharWidth, 4);
    }

RedrawAndReturn:
    //
    // Because the tabstops have changed, we need to recompute the
    // maxPixelWidth. Otherwise, horizontal scrolls will have problems.
    // Fix for Bug #6042 - 3/15/94
    //
    EditML_BuildchLines(ped, 0, 0, FALSE, NULL, NULL);

    //
    // Caret may have changed line by the line recalc above.
    //
    EditML_UpdateiCaretLine(ped);

    EditML_EnsureCaretVisible(ped);

    //
    // Also, we need to redraw the whole window.
    //
    InvalidateRect(ped->hwnd, NULL, TRUE);

    return TRUE;
}

//---------------------------------------------------------------------------//
//
// EditML_Undo AorW
// 
// Handles Undo for multiline edit controls.
//
BOOL EditML_Undo(PED ped)
{
    HANDLE hDeletedText = ped->hDeletedText;
    BOOL fDelete = (BOOL)(ped->undoType & UNDO_DELETE);
    ICH cchDeleted = ped->cchDeleted;
    ICH ichDeleted = ped->ichDeleted;

    if (ped->undoType == UNDO_NONE) 
    {
        //
        // No undo...
        //
        return FALSE;
    }

    ped->hDeletedText = NULL;
    ped->cchDeleted = 0;
    ped->ichDeleted = (ICH)-1;
    ped->undoType &= ~UNDO_DELETE;

    if (ped->undoType == UNDO_INSERT) 
    {
        ped->undoType = UNDO_NONE;

        //
        // Set the selection to the inserted text
        //
        EditML_SetSelection(ped, FALSE, ped->ichInsStart, ped->ichInsEnd);
        ped->ichInsStart = ped->ichInsEnd = (ICH)-1;

        //
        // Now send a backspace to delete and save it in the undo buffer...
        //
        SendMessage(ped->hwnd, WM_CHAR, (WPARAM)VK_BACK, 0L);
    }

    if (fDelete) 
    {
        //
        // Insert deleted chars
        //

        //
        // Set the selection to the inserted text
        //
        EditML_SetSelection(ped, FALSE, ichDeleted, ichDeleted);
        EditML_InsertText(ped, hDeletedText, cchDeleted, FALSE);

        GlobalFree(hDeletedText);
        EditML_SetSelection(ped, FALSE, ichDeleted, ichDeleted + cchDeleted);
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
// 
// EditML_Create AorW
// 
// Creates the edit control for the window hwnd by allocating memory
// as required from the application's heap. Notifies parent if no memory
// error (after cleaning up if needed). Returns TRUE if no error else return s
// -1.
//
LONG EditML_Create(PED ped, LPCREATESTRUCT lpCreateStruct)
{
    LONG windowStyle;
    LPWSTR lpszName;

    //
    // Get values from the window instance data structure and put them in the
    // ped so that we can access them easier
    //
    windowStyle = GET_STYLE(ped);

    //
    // Do the standard creation stuff
    //
    if (!Edit_Create(ped, windowStyle)) 
    {
        return -1;
    }

    //
    // Allocate line start array in local heap and lock it down
    //
    ped->chLines = (LPICH)LocalAlloc(LPTR, 2 * sizeof(int));
    if (ped->chLines == NULL) 
    {
        return -1;
    }

    //
    // Call it one line of text...
    //
    ped->cLines = 1;

    //
    // If app wants WS_VSCROLL or WS_HSCROLL, it automatically gets AutoVScroll
    // or AutoHScroll.
    //
    if ((windowStyle & ES_AUTOVSCROLL) || (windowStyle & WS_VSCROLL)) 
    {
        ped->fAutoVScroll = 1;
    }

    if (ped->format != ES_LEFT)
    {
        //
        // If user wants right or center justified text, then we turn off
        // AUTOHSCROLL and WS_HSCROLL since non-left styles don't make sense
        // otherwise.
        //
        windowStyle &= ~WS_HSCROLL;
        ClearWindowState(ped->hwnd, WS_HSCROLL);
        ped->fAutoHScroll = FALSE;
    }
    else if (windowStyle & WS_HSCROLL) 
    {
        ped->fAutoHScroll = TRUE;
    }

    ped->fWrap = (!ped->fAutoHScroll && !(windowStyle & WS_HSCROLL));

    //
    // Max # chars we will allow user to enter
    //
    ped->cchTextMax = MAXTEXT;

    //
    // Set the default font to be the system font.
    //
    if ( !Edit_SetFont(ped, NULL, FALSE) )
    {

        // If setting the font fails, our textmetrics can potentially be left 
        // unitialized. Fail to create the control.
        return -1;
    }

    //
    // Set the window text if needed and notify parent if not enough memory to
    // set the initial text.
    //
#if 0
    if ((ULONG_PTR)lpCreateStruct->lpszName > gHighestUserAddress)
    {
        lpszName = REBASEPTR(ped->pwnd, (PVOID)lpCreateStruct->lpszName);
    }
    else
#endif
    {
        lpszName = (LPWSTR)lpCreateStruct->lpszName;
    }

    if (!Edit_SetEditText(ped, (LPSTR)lpszName))
    {
        return -1;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\edit.h ===
#if !defined(__Edit_h__INCLUDED)
#define __Edit_h__INCLUDED


// 
// Problems arising with edit control and DrawThemeText cause us not to
// render text using theme APIs. However, we still want to use a theme
// handle to draw out client edge.
// Uncomment the following to turn on theme defined text rendering 
// #define _USE_DRAW_THEME_TEXT_
//

//
// Edit WndProc Prototype
//
extern LRESULT Edit_WndProc(
    HWND   hwnd, 
    UINT   uMsg, 
    WPARAM wParam,
    LPARAM lParam);

#define DF_WINDOWFRAME      (COLOR_WINDOWFRAME << 3)

//
// Edit macros
//

//
// Instance data pointer access functions
//
#define Edit_GetPtr(hwnd)       \
            (PED)GetWindowPtr(hwnd, 0)

#define Edit_SetPtr(hwnd, p)    \
            (PED)SetWindowPtr(hwnd, 0, p)

//
// We don't need 64-bit intermediate precision so we use this macro
// instead of calling MulDiv.
//
#define MultDiv(x, y, z)    \
            (((INT)(x) * (INT)(y) + (INT)(z) / 2) / (INT)(z))

#define ISDELIMETERA(ch)    \
            ((ch == ' ') || (ch == '\t'))

#define ISDELIMETERW(ch)    \
            ((ch == L' ') || (ch == L'\t'))

#define AWCOMPARECHAR(ped,pbyte,awchar) \
            (ped->fAnsi ? (*(PUCHAR)(pbyte) == (UCHAR)(awchar)) : (*(LPWSTR)(pbyte) == (WCHAR)(awchar)))

#define CALLWORDBREAKPROC(proc, pText, iStart, cch, iAction)                \
        (* proc)(pText, iStart, cch, iAction)

#ifndef NULL_HIMC
#define NULL_HIMC        (HIMC)  0
#endif

#ifdef UNICODE 
#define EditWndProc EditWndProcW
#else
#define EditWndProc EditWndProcA
#endif

#define SYS_ALTERNATE           0x2000
#define FAREAST_CHARSET_BITS   (FS_JISJAPAN | FS_CHINESESIMP | FS_WANSUNG | FS_CHINESETRAD)

//
// Length of the buffer for ASCII character width caching: for characters
// 0x00 to 0xff (field charWidthBuffer in PED structure below).
// As the upper half of the cache was not used by almost anyone and fixing
// it's usage required a lot of conversion, we decided to get rid of it
// MCostea #174031
//
#define CHAR_WIDTH_BUFFER_LENGTH 128

//
// NOTE: Text handle is sized as multiple of this constant
//       (should be power of 2).
//
#define CCHALLOCEXTRA   0x20

//
// Maximum width in pixels for a line/rectangle
//
#define MAXPIXELWIDTH   30000
#define MAXCLIPENDPOS   32764


//
// Limit multiline edit controls to at most 1024 characters on a single line.
// We will force a wrap if the user exceeds this limit.
//
#define MAXLINELENGTH   1024

//
// Allow an initial maximum of 30000 characters in all edit controls since
// some apps will run into unsigned problems otherwise.  If apps know about
// the 64K limit, they can set the limit themselves.
//
#define MAXTEXT         30000

//
// Key modifiers which have been pressed.  Code in KeyDownHandler and
// CharHandler depend on these exact values.
//
#define NONEDOWN   0    // Neither shift nor control down
#define CTRLDOWN   1    // Control key only down
#define SHFTDOWN   2    // Shift key only down
#define SHCTDOWN   3    // Shift and control keys down = CTRLDOWN + SHFTDOWN
#define NOMODIFY   4    // Neither shift nor control down

#define IDSYS_SCROLL        0x0000FFFEL

//
// ECTabTheTextOut draw codes
//
#define ECT_CALC        0
#define ECT_NORMAL      1
#define ECT_SELECTED    2

typedef DWORD  ICH;
typedef ICH *LPICH;

//
// Types of undo supported in this ped
//
#define UNDO_NONE   0   // We can't undo the last operation.
#define UNDO_INSERT 1   // We can undo the user's insertion of characters
#define UNDO_DELETE 2   // We can undo the user's deletion of characters

typedef struct 
{
    DWORD fDisableCut : 1;
    DWORD fDisablePaste : 1;
    DWORD fNeedSeparatorBeforeImeMenu : 1;
    DWORD fIME : 1;
} EditMenuItemState;


//
// The following structure is used to store a selection block; In Multiline
// edit controls, "StPos" and "EndPos" fields contain the Starting and Ending
// lines of the block. In Single line edit controls, "StPos" and "EndPos"
// contain the Starting and Ending character positions of the block;
//
typedef struct tagSELBLOCK 
{
    ICH StPos;
    ICH EndPos;
} SELBLOCK, *LPSELBLOCK;


//
// The following structure is used to store complete information about a
// a strip of text.
//
typedef struct 
{
    LPSTR lpString;
    ICH   ichString;
    ICH   nCount;
    int   XStartPos;
}  STRIPINFO;
typedef  STRIPINFO *LPSTRIPINFO;


typedef struct tagUNDO 
{
    UINT  undoType;     // Current type of undo we support
    PBYTE hDeletedText; // Pointer to text which has been deleted (for
                        //   undo) -- note, the memory is allocated as fixed
    ICH   ichDeleted;   // Starting index from which text was deleted
    ICH   cchDeleted;   // Count of deleted characters in buffer
    ICH   ichInsStart;  // Starting index from which text was inserted
    ICH   ichInsEnd;    // Ending index of inserted text
} UNDO, *PUNDO;

#define Pundo(ped)             ((PUNDO)&(ped)->undoType)

typedef struct tagED0 *PED0;
//
// Language pack edit control callouts.
//
// Functions are accessed through the pLpkEditCallout pointer in the ED
// structure. pLpkEditCallout points to a structure containing a pointer
// to each callout routine.
//
#define DECLARE_LPK_CALLOUT(_ret, _fn, _args) \
            _ret (__stdcall *##_fn) _args


typedef struct tagLPKEDITCALLOUT 
{

    DECLARE_LPK_CALLOUT(BOOL, EditCreate,        (PED0, HWND));
    DECLARE_LPK_CALLOUT(INT,  EditIchToXY,       (PED0, HDC, PSTR, ICH, ICH));
    DECLARE_LPK_CALLOUT(ICH,  EditMouseToIch,    (PED0, HDC, PSTR, ICH, INT));
    DECLARE_LPK_CALLOUT(ICH,  EditCchInWidth,    (PED0, HDC, PSTR, ICH, INT));
    DECLARE_LPK_CALLOUT(INT,  EditGetLineWidth,  (PED0, HDC, PSTR, ICH));
    DECLARE_LPK_CALLOUT(VOID, EditDrawText,      (PED0, HDC, PSTR, INT, INT, INT, INT));
    DECLARE_LPK_CALLOUT(BOOL, EditHScroll,       (PED0, HDC, PSTR));
    DECLARE_LPK_CALLOUT(ICH,  EditMoveSelection, (PED0, HDC, PSTR, ICH, BOOL));
    DECLARE_LPK_CALLOUT(INT,  EditVerifyText,    (PED0, HDC, PSTR, ICH, PSTR, ICH));
    DECLARE_LPK_CALLOUT(VOID, EditNextWord ,     (PED0, HDC, PSTR, ICH, BOOL, LPICH, LPICH));
    DECLARE_LPK_CALLOUT(VOID, EditSetMenu,       (PED0, HMENU));
    DECLARE_LPK_CALLOUT(INT,  EditProcessMenu,   (PED0, UINT));
    DECLARE_LPK_CALLOUT(INT,  EditCreateCaret,   (PED0, HDC, INT, INT, UINT));
    DECLARE_LPK_CALLOUT(ICH,  EditAdjustCaret,   (PED0, HDC, PSTR, ICH));

} LPKEDITCALLOUT, *PLPKEDITCALLOUT;

PLPKEDITCALLOUT g_pLpkEditCallout;


#if defined(BUILD_WOW6432)

//
// In user a PWND is actually pointer to kernel memory, so
// it needs to be 64-bits on wow6432 as well.
//
typedef VOID * _ptr64 PWND;

#else

typedef VOID * PWND;

#endif


//
// ! WARNING ! Don't modify this struct. This is is the same user32's tagED struct.
//             Unfortunately the EditLpk callouts expect that struct. Change the 
//             tagED struct below.
//
typedef struct tagED0
{
    HANDLE  hText;              // Block of text we are editing
    ICH     cchAlloc;           // Number of chars we have allocated for hText
    ICH     cchTextMax;         // Max number bytes allowed in edit control
    ICH     cch;                // Current number of bytes of actual text
    ICH     cLines;             // Number of lines of text
    ICH     ichMinSel;          // Selection extent.  MinSel is first selected char
    ICH     ichMaxSel;          // MaxSel is first unselected character
    ICH     ichCaret;           // Caret location. Caret is on left side of char
    ICH     iCaretLine;         // The line the caret is on. So that if word
                                // wrapping, we can tell if the caret is at end
                                // of a line of at beginning of next line...
    ICH     ichScreenStart;     // Index of left most character displayed on
                                // screen for sl ec and index of top most line
                                // for multiline edit controls
    ICH     ichLinesOnScreen;   // Number of lines we can display on screen
    UINT    xOffset;            // x (horizontal) scroll position in pixels
                                // (for multiline text horizontal scroll bar)
    UINT    charPasswordChar;   // If non null, display this character instead
                                // of the real text. So that we can implement
                                // hidden text fields.
    INT     cPasswordCharWidth; // Width of password char
    HWND    hwnd;               // Window for this edit control
    PWND    pwnd;               // placeholder for compatability with user's PED struct
    RECT    rcFmt;              // Client rectangle
    HWND    hwndParent;         // Parent of this edit control window
                                // These vars allow us to automatically scroll
                                // when the user holds the mouse at the bottom
                                // of the multiline edit control window.
    POINT   ptPrevMouse;        // Previous point for the mouse for system timer.
    UINT    prevKeys;           // Previous key state for the mouse


    UINT     fSingle       : 1; // Single line edit control? (or multiline)
    UINT     fNoRedraw     : 1; // Redraw in response to a change?
    UINT     fMouseDown    : 1; // Is mouse button down? when moving mouse
    UINT     fFocus        : 1; // Does ec have the focus?
    UINT     fDirty        : 1; // Modify flag for the edit control
    UINT     fDisabled     : 1; // Window disabled?
    UINT     fNonPropFont  : 1; // Fixed width font?
    UINT     fNonPropDBCS  : 1; // Non-Propotional DBCS font
    UINT     fBorder       : 1; // Draw a border?
    UINT     fAutoVScroll  : 1; // Automatically scroll vertically
    UINT     fAutoHScroll  : 1; // Automatically scroll horizontally
    UINT     fNoHideSel    : 1; // Hide sel when we lose focus?
    UINT     fDBCS         : 1; // Are we using DBCS font set for editing?
    UINT     fFmtLines     : 1; // For multiline only. Do we insert CR CR LF at
                                // word wrap breaks?
    UINT     fWrap         : 1; // Do int  wrapping?
    UINT     fCalcLines    : 1; // Recalc ped->chLines array? (recalc line breaks?)
    UINT     fEatNextChar  : 1; // Hack for ALT-NUMPAD stuff with combo boxes.
                                // If numlock is up, we want to eat the next
                                // character generated by the keyboard driver
                                // if user enter num pad ascii value...
    UINT     fStripCRCRLF  : 1; // CRCRLFs have been added to text. Strip them
                                // before doing any internal edit control stuff
    UINT     fInDialogBox  : 1; // True if the ml edit control is in a dialog
                                // box and we have to specially treat TABS and ENTER
    UINT     fReadOnly     : 1; // Is this a read only edit control? Only
                                // allow scrolling, selecting and copying.
    UINT     fCaretHidden  : 1; // This indicates whether the caret is
                                // currently hidden because the width or height
                                // of the edit control is too small to show it.
    UINT     fTrueType     : 1; // Is the current font TrueType?
    UINT     fAnsi         : 1; // is the edit control Ansi or unicode
    UINT     fWin31Compat  : 1; // TRUE if created by Windows 3.1 app
    UINT     f40Compat     : 1; // TRUE if created by Windows 4.0 app
    UINT     fFlatBorder   : 1; // Do we have to draw this baby ourself?
    UINT     fSawRButtonDown : 1;
    UINT     fInitialized  : 1; // If any more bits are needed, then
    UINT     fSwapRoOnUp   : 1; // Swap reading order on next keyup
    UINT     fAllowRTL     : 1; // Allow RTL processing
    UINT     fDisplayCtrl  : 1; // Display unicode control characters
    UINT     fRtoLReading  : 1; // Right to left reading order

    BOOL    fInsertCompChr  :1; // means WM_IME_COMPOSITION:CS_INSERTCHAR will come
    BOOL    fReplaceCompChr :1; // means need to replace current composition str.
    BOOL    fNoMoveCaret    :1; // means stick to current caret pos.
    BOOL    fResultProcess  :1; // means now processing result.
    BOOL    fKorea          :1; // for Korea
    BOOL    fInReconversion :1; // In reconversion mode
    BOOL    fLShift         :1; // L-Shift pressed with Ctrl

    WORD    wImeStatus;         // current IME status

    WORD    cbChar;             // count of bytes in the char size (1 or 2 if unicode)
    LPICH   chLines;            // index of the start of each line

    UINT    format;             // Left, center, or right justify multiline text.
    EDITWORDBREAKPROCA lpfnNextWord;  // use CALLWORDBREAKPROC macro to call

                                // Next word function
    INT     maxPixelWidth;      // WASICH Width (in pixels) of longest line

    UNDO;                       // Undo buffer

    HANDLE  hFont;              // Handle to the font for this edit control.
                                //  Null if system font.
    INT     aveCharWidth;       // Ave width of a character in the hFont
    INT     lineHeight;         // Height of a line in the hFont
    INT     charOverhang;       // Overhang associated with the hFont
    INT     cxSysCharWidth;     // System font ave width
    INT     cySysCharHeight;    // System font height
    HWND    listboxHwnd;        // ListBox hwnd. Non null if we are a combobox
    LPINT   pTabStops;          // Points to an array of tab stops; First
                                // element contains the number of elements in
                                // the array
    LPINT   charWidthBuffer;
    BYTE    charSet;            // Character set for currently selected font
                                // needed for all versions
    UINT    wMaxNegA;           // The biggest negative A width
    UINT    wMaxNegAcharPos;    // and how many characters it can span accross
    UINT    wMaxNegC;           // The biggest negative C width,
    UINT    wMaxNegCcharPos;    // and how many characters it can span accross
    UINT    wLeftMargin;        // Left margin width in pixels.
    UINT    wRightMargin;       // Right margin width in pixels.

    ICH     ichStartMinSel;
    ICH     ichStartMaxSel;

    PLPKEDITCALLOUT pLpkEditCallout;
    HBITMAP hCaretBitmap;       // Current caret bitmap handle
    INT     iCaretOffset;       // Offset in pixels (for LPK use)

    HANDLE  hInstance;          // for WOW
    UCHAR   seed;               // used to encode and decode password text
    BOOLEAN fEncoded;           // is the text currently encoded
    INT     iLockLevel;         // number of times the text has been locked

    BYTE    DBCSVector[8];      // DBCS vector table
    HIMC    hImcPrev;           // place to save hImc if we disable IME
    POINT   ptScreenBounding;   // top left corner of edit window in screen
} ED0, *PED0;


typedef struct tagED
{
    ED0;                        // lpk callouts expect user32's ped struct 
                                // so for compatability we'll give it to them.
    HTHEME  hTheme;             // Handle to the theme manager
    PWW     pww;                // RO pointer into the pwnd to ExStyle, Style, State, State2
    HFONT   hFontSave;          // saved the font
    LPWSTR  pszCueBannerText;   // pointer to the text for the cue banner (grey help text)
    UINT    fHot          : 1;  // Is mouse over edit control?
    HWND    hwndBalloon;        // Balloon tip hwnd for EM_BALLOONTIP
    HFONT   hFontPassword;
} ED, *PED, **PPED;


//
//  Edit function prototypes. 
//

//
//  Defined in edit.c
//
PSTR    Edit_Lock(PED);
VOID    Edit_Unlock(PED);
VOID    Edit_InOutReconversionMode(PED, BOOL);
INT     Edit_GetModKeys(INT);
UINT    Edit_TabTheTextOut(HDC, INT, INT, INT, INT, LPSTR, INT, ICH, PED, INT, BOOL, LPSTRIPINFO);
ICH     Edit_CchInWidth(PED, HDC, LPSTR, ICH, INT, BOOL);
HBRUSH  Edit_GetBrush(PED, HDC, LPBOOL);
VOID    Edit_Word(PED, ICH, BOOL, LPICH, LPICH);
VOID    Edit_SaveUndo(PUNDO, PUNDO, BOOL);
VOID    Edit_EmptyUndo(PUNDO);
BOOL    Edit_InsertText(PED, LPSTR, LPICH);
ICH     Edit_DeleteText(PED);
VOID    Edit_NotifyParent(PED, INT);
VOID    Edit_SetClip(PED, HDC, BOOL);
HDC     Edit_GetDC(PED, BOOL);
VOID    Edit_ReleaseDC(PED, HDC, BOOL);
VOID    Edit_ResetTextInfo(PED);
BOOL    Edit_SetEditText(PED, LPSTR);
VOID    Edit_InvalidateClient(PED, BOOL);
BOOL    Edit_CalcChangeSelection(PED, ICH, ICH, LPSELBLOCK, LPSELBLOCK);
INT     Edit_GetDBCSVector(PED, HDC, BYTE);
LPSTR   Edit_AnsiNext(PED, LPSTR);
LPSTR   Edit_AnsiPrev(PED, LPSTR, LPSTR);
ICH     Edit_NextIch(PED, LPSTR, ICH);
ICH     Edit_PrevIch(PED, LPSTR, ICH);
BOOL    Edit_IsDBCSLeadByte(PED, BYTE);
WORD    DbcsCombine(HWND, WORD);
ICH     Edit_AdjustIch(PED, LPSTR, ICH);
ICH     Edit_AdjustIchNext(PED, LPSTR, ICH);
VOID    Edit_UpdateFormat(PED, DWORD, DWORD);
BOOL    Edit_IsFullWidth(DWORD,WCHAR);

__inline LRESULT Edit_ShowBalloonTipWrap(HWND, DWORD, DWORD, DWORD);


//
//  Defined in editrare.c
//
INT     Edit_GetStateId(PED ped);
VOID    Edit_SetMargin(PED, UINT, long, BOOL);
INT     UserGetCharDimensionsEx(HDC, HFONT, LPTEXTMETRICW, LPINT);
ICH     Edit_GetTextHandler(PED, ICH, LPSTR, BOOL);
BOOL    Edit_NcCreate(PED, HWND, LPCREATESTRUCT);
BOOL    Edit_Create(PED ped, LONG windowStyle);
VOID    Edit_NcDestroyHandler(HWND, PED);
VOID    Edit_SetPasswordCharHandler(PED, UINT);
BOOL    GetNegABCwidthInfo(PED ped, HDC hdc);
VOID    Edit_Size(PED ped, LPRECT lprc, BOOL fRedraw);
BOOL    Edit_SetFont(PED, HFONT, BOOL);
BOOL    Edit_IsCharNumeric(PED ped, DWORD keyPress);
VOID    Edit_EnableDisableIME(PED ped);
VOID    Edit_ImmSetCompositionWindow(PED ped, LONG, LONG);
VOID    Edit_SetCompositionFont(PED ped);
VOID    Edit_InitInsert(PED ped, HKL hkl);
VOID    Edit_SetCaretHandler(PED ped);
LRESULT Edit_ImeComposition(PED ped, WPARAM wParam, LPARAM lParam);
BOOL    HanjaKeyHandler(PED ped);  // Korean Support
LRESULT Edit_RequestHandler(PED, WPARAM, LPARAM);  // NT 5.0


//
//  Single line Edit function prototypes 
//
//  Defined in editsl.c
//
INT     EditSL_IchToLeftXPos(PED, HDC, ICH);
VOID    EditSL_SetCaretPosition(PED, HDC);
VOID    EditSL_DrawText(PED, HDC, ICH);
BOOL    EditSL_ScrollText(PED, HDC);
ICH     EditSL_InsertText(PED, LPSTR, ICH);
VOID    EditSL_ReplaceSel(PED, LPSTR);
LRESULT EditSL_WndProc(PED, UINT, WPARAM, LPARAM);


//
//  Multi line Edit function prototypes 
//
//  Defined in editsl.c
//
VOID    EditML_Size(PED, BOOL);
VOID    EditML_SetCaretPosition(PED,HDC);
VOID    EditML_IchToXYPos(PED, HDC, ICH, BOOL, LPPOINT);
VOID    EditML_UpdateiCaretLine(PED ped);
ICH     EditML_InsertText(PED, LPSTR, ICH, BOOL);
VOID    EditML_ReplaceSel(PED, LPSTR);
ICH     EditML_DeleteText(PED);
VOID    EditML_BuildchLines(PED, ICH, int, BOOL, PLONG, PLONG);
LONG    EditML_Scroll(PED, BOOL, int, int, BOOL);
LRESULT EditML_WndProc(PED, UINT, WPARAM, LPARAM);

#endif // __Edit_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\flat_sb.c ===
#include "ctlspriv.h"
#include "flat_sb.h"

HRESULT WINAPI UninitializeFlatSB(HWND hwnd)
{
    return S_OK;
}

BOOL WINAPI InitializeFlatSB(HWND hwnd)
{
    return TRUE;
}

int WINAPI FlatSB_GetScrollPos(HWND hwnd, int code)
{
    return GetScrollPos(hwnd, code);
}

BOOL WINAPI FlatSB_GetScrollPropPtr(HWND hwnd, int propIndex, PINT_PTR pValue)
{
    return FALSE;
}

#ifdef _WIN64

BOOL WINAPI FlatSB_GetScrollProp(HWND hwnd, int propIndex, LPINT pValue)
{
    return FALSE;
}
#endif

BOOL WINAPI FlatSB_GetScrollRange(HWND hwnd, int code, LPINT lpposMin, LPINT lpposMax)
{
    return GetScrollRange(hwnd, code, lpposMin, lpposMax);
}

BOOL WINAPI FlatSB_GetScrollInfo(HWND hwnd, int fnBar, LPSCROLLINFO lpsi)
{
    return GetScrollInfo(hwnd, fnBar, lpsi);
}

BOOL WINAPI FlatSB_ShowScrollBar(HWND hwnd, int fnBar, BOOL fShow)
{
    return ShowScrollBar(hwnd, fnBar, fShow);
}

BOOL WINAPI FlatSB_EnableScrollBar(HWND hwnd, int wSBflags, UINT wArrows)
{
    return EnableScrollBar(hwnd, wSBflags, wArrows);
}

int WINAPI FlatSB_SetScrollPos(HWND hwnd, int code, int pos, BOOL fRedraw)
{
    return SetScrollPos(hwnd, code, pos, fRedraw);
}

BOOL WINAPI FlatSB_SetScrollRange(HWND hwnd, int code, int nMin, int nMax, BOOL fRedraw)
{
    return SetScrollRange(hwnd, code, nMin, nMax, fRedraw);
}


int WINAPI FlatSB_SetScrollInfo(HWND hwnd, int code, LPSCROLLINFO lpsi, BOOL fRedraw)
{
    return SetScrollInfo(hwnd, code, lpsi, fRedraw);
}

BOOL WINAPI FlatSB_SetScrollProp(HWND hwnd, UINT index, INT_PTR newValue, BOOL fRedraw)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\flat_sb.h ===
#ifndef _NEW_WSBCONTROL_H
#define _NEW_WSBCONTROL_H
#endif  //  _NEW_WSBCONTROL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\editsl.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "edit.h"

//---------------------------------------------------------------------------//
//
// Language pack notes:
// With the language pack loaded all positional processing is based on
// ped->xOffset rather than ped->ichScreenStart. The non-lpk optimisation of
// maintaining ped->ichScreenStart doesn't work because of the
// glyph reordering features of complex scripts.
//


//---------------------------------------------------------------------------//
//
// Forwards
//
VOID EditSL_ChangeSelection(PED, HDC, ICH, ICH);
VOID EditSL_DrawLine(PED, HDC, int, int, ICH, int, BOOL);
BOOL EditSL_Undo(PED);


//---------------------------------------------------------------------------//
//
typedef BOOL (*FnGetTextExtentPoint)(HDC, PVOID, int, LPSIZE);


//---------------------------------------------------------------------------//
INT EditSL_CalcStringWidth(PED ped, HDC hdc, ICH ich, ICH cch)
{
    if (cch == 0)
    {
        return 0;
    }

    if (ped->charPasswordChar) 
    {
        return cch * ped->cPasswordCharWidth;
    } 
    else 
    {
        SIZE size;

        if (ped->fNonPropFont && !ped->fDBCS) 
        {
            size.cx = cch * ped->aveCharWidth;
        } 
        else 
        {
            PSTR pText = Edit_Lock(ped);

            if (ped->fAnsi) 
            {
                GetTextExtentPointA(hdc, (LPSTR)(pText + ich), cch, &size);
            } 
            else 
            {
                GetTextExtentPointW(hdc, (LPWSTR)pText + ich, cch, &size);
            }

            Edit_Unlock(ped);
        }

        return size.cx - ped->charOverhang;
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_CalcXOffsetLeft
//
// Calculates the starting offset for left-aligned strings.
//
INT EditSL_CalcXOffsetLeft(PED ped, HDC hdc, ICH ich)
{
    int cch = (int)(ich - ped->ichScreenStart);

    if (cch <= 0)
    {
        return 0;
    }

    return EditSL_CalcStringWidth(ped, hdc, ped->ichScreenStart, cch);
}


//---------------------------------------------------------------------------//
//
// EditSL_CalcXOffsetSpecial
//
// Calculates the horizontal offset (indent) required for right or center
// justified lines.
//
INT EditSL_CalcXOffsetSpecial(PED ped, HDC hdc, ICH ich)
{
    PSTR pText;
    ICH cch, ichStart = ped->ichScreenStart;
    int cx;

    //
    // Calc the number of characters from start to right end.
    //
    pText = Edit_Lock(ped);
    cch = Edit_CchInWidth(ped, hdc, (LPSTR)(pText + ichStart * ped->cbChar),
            ped->cch - ichStart, ped->rcFmt.right - ped->rcFmt.left, TRUE);
    Edit_Unlock(ped);

    //
    // Once the last character of the string has been scrolled out of
    // the view, use normal offset calculation.
    //
    if (ped->ichScreenStart + cch < ped->cch)
    {
        return EditSL_CalcXOffsetLeft(ped, hdc, ich);
    }

    cx = ped->rcFmt.right - ped->rcFmt.left - EditSL_CalcStringWidth(ped,
            hdc, ichStart, cch);

    if (ped->format == ES_CENTER) 
    {
         cx = max(0, cx / 2);
    } 
    else if (ped->format == ES_RIGHT) 
    {
        //
        // Subtract 1 so that the 1 pixel wide cursor will be in the visible
        // region on the very right side of the screen, mle does this.
        //
        cx = max(0, cx - 1);
    }

    return cx + EditSL_CalcStringWidth(ped, hdc, ichStart, ich - ichStart);
}


//---------------------------------------------------------------------------//
//
// EditSL_SetCaretPosition AorW
//
// If the window has the focus, find where the caret belongs and move
// it there.
//
VOID EditSL_SetCaretPosition(PED ped, HDC hdc)
{
    int xPosition;

    //
    // We will only position the caret if we have the focus since we don't want
    // to move the caret while another window could own it.
    //
    if (!ped->fFocus)
    {
        return;
    }

    if (ped->fCaretHidden) 
    {
        SetCaretPos(-20000, -20000);
        return;
    }

    xPosition = EditSL_IchToLeftXPos(ped, hdc, ped->ichCaret);

    //
    // Don't let caret go out of bounds of edit control if there is too much
    // text.
    //
    if (ped->pLpkEditCallout) 
    {
        xPosition += ped->iCaretOffset;
        xPosition = max(xPosition , 0);
        xPosition = min(xPosition, ped->rcFmt.right - 1 -
            ((ped->cxSysCharWidth > ped->aveCharWidth) ? 1 : 2));
    } 
    else 
    {
        xPosition = min(xPosition, ped->rcFmt.right -
            ((ped->cxSysCharWidth > ped->aveCharWidth) ? 1 : 2));
    }

    SetCaretPos(xPosition, ped->rcFmt.top);

    //
    // FE_IME EditSL_SetCaretPosition - ECImmSetCompostionWindow( CFS_POINT )
    //
    if (g_fIMMEnabled && ImmIsIME(GetKeyboardLayout(0))) 
    {
        Edit_ImmSetCompositionWindow(ped, xPosition, ped->rcFmt.top);
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_IchToLeftXPos AorW
//
// Given a character index, find its (left side) x coordinate within
// the ped->rcFmt rectangle assuming the character ped->ichScreenStart is at
// coordinates (ped->rcFmt.top, ped->rcFmt.left). A negative value is
// return ed if the character ich is to the left of ped->ichScreenStart. WARNING:
// ASSUMES AT MOST 1000 characters will be VISIBLE at one time on the screen.
// There may be 64K total characters in the editcontrol, but we can only
// display 1000 without scrolling. This shouldn't be a problem obviously.
//
INT EditSL_IchToLeftXPos(PED ped, HDC hdc, ICH ich)
{
    int textExtent;
    PSTR pText;
    SIZE size;
    int  cchDiff;

    if (ped->pLpkEditCallout) 
    {
       pText = Edit_Lock(ped);
       textExtent = ped->pLpkEditCallout->EditIchToXY((PED0)ped, hdc, pText, ped->cch, ich);
       Edit_Unlock(ped);

       return textExtent;

    }

    //
    // Check if we are adding lots and lots of chars. A paste for example could
    // cause this and GetTextExtents could overflow on this.
    //
    cchDiff = (int)ich - (int)ped->ichScreenStart;
    if (cchDiff > 1000)
    {
        return (30000);
    }
    else if (cchDiff < -1000)
    {
        return (-30000);
    }

    if (ped->format != ES_LEFT)
    {
        return (ped->rcFmt.left + EditSL_CalcXOffsetSpecial(ped, hdc, ich));
    }

    //
    // Caret position /w DBCS text, we can not optimize...
    //
    if (ped->fNonPropFont && !ped->fDBCS)
    {
        return (ped->rcFmt.left + cchDiff*ped->aveCharWidth);
    }

    //
    // Check if password hidden chars are being used.
    //
    if (ped->charPasswordChar)
    {
        return ( ped->rcFmt.left + cchDiff*ped->cPasswordCharWidth);
    }

    pText = Edit_Lock(ped);

    if (ped->fAnsi) 
    {
        if (cchDiff >= 0) 
        {

            GetTextExtentPointA(hdc, (LPSTR)(pText + ped->ichScreenStart),
                    cchDiff, &size);
            textExtent =  size.cx;

            //
            // In case of signed/unsigned overflow since the text extent may be
            // greater than maxint. This happens with long single line edit
            // controls. The rect we edit text in will never be greater than 30000
            // pixels so we are ok if we just ignore them.
            //
            if (textExtent < 0 || textExtent > 31000)
            {
                textExtent = 30000;
            }
        } 
        else 
        {
            GetTextExtentPointA(hdc,(LPSTR)(pText + ich), -cchDiff, &size);
            textExtent = (-1) * size.cx;
        }
    } 
    else 
    {
        if (cchDiff >= 0) 
        {

            GetTextExtentPointW(hdc, (LPWSTR)(pText + ped->ichScreenStart*sizeof(WCHAR)),
                    cchDiff, &size);
            textExtent =  size.cx;

            //
            // In case of signed/unsigned overflow since the text extent may be
            // greater than maxint. This happens with long single line edit
            // controls. The rect we edit text in will never be greater than 30000
            // pixels so we are ok if we just ignore them.
            //
            if (textExtent < 0 || textExtent > 31000)
            {
                textExtent = 30000;
            }
        } 
        else 
        {
            GetTextExtentPointW(hdc,(LPWSTR)(pText + ich*sizeof(WCHAR)), -cchDiff, &size);
            textExtent = (-1) * size.cx;
        }
    }

    Edit_Unlock(ped);

    return (ped->rcFmt.left + textExtent - (textExtent ? ped->charOverhang : 0));
}


//---------------------------------------------------------------------------//
//
// EditSL_SetSelection AorW
//
// Sets the PED to have the new selection specified.
//
VOID EditSL_SetSelection(PED ped, ICH ichSelStart, ICH ichSelEnd)
{
    HDC hdc = Edit_GetDC(ped, FALSE);

    if (ichSelStart == 0xFFFFFFFF) 
    {
        //
        // Set no selection if we specify -1
        //
        ichSelStart = ichSelEnd = ped->ichCaret;
    }

    //
    // Bounds ichSelStart, ichSelEnd are checked in EditSL_ChangeSelection...
    //
    EditSL_ChangeSelection(ped, hdc, ichSelStart, ichSelEnd);

    //
    // Put the caret at the end of the selected text
    //
    ped->ichCaret = ped->ichMaxSel;

    EditSL_SetCaretPosition(ped, hdc);

    //
    // We may need to scroll the text to bring the caret into view...
    //
    EditSL_ScrollText(ped, hdc);

    Edit_ReleaseDC(ped, hdc, FALSE);
}


//---------------------------------------------------------------------------//
VOID EditSL_GetClipRect(PED ped, HDC hdc, ICH ichStart, int iCount, LPRECT lpClipRect)
{
    int  iStCount;
    PSTR pText;

    if (ped->pLpkEditCallout) 
    {
        TraceMsg(TF_STANDARD, "UxEdit: EditSL_GetClipRect - Error - Invalid call with language pack loaded");
        memset(lpClipRect, 0, sizeof(RECT));

        return;
    }

    CopyRect(lpClipRect, &ped->rcFmt);

    pText = Edit_Lock(ped);

    //
    // Calculates the starting pos for this piece of text
    //
    if ((iStCount = (int)(ichStart - ped->ichScreenStart)) > 0) 
    {
        if (ped->format == ES_LEFT) 
        {
            lpClipRect->left += EditSL_CalcXOffsetLeft(ped, hdc, ichStart);
        }
    } 
    else 
    {
        //
        // Reset the values to visible portions
        //
        iCount -= (ped->ichScreenStart - ichStart);
        ichStart = ped->ichScreenStart;
    }

    if (ped->format != ES_LEFT) 
    {
        lpClipRect->left += EditSL_CalcXOffsetSpecial(ped, hdc, ichStart);
    }

    if (iCount < 0) 
    {
        //
        // This is not in the visible area of the edit control, so return
        // an empty rect.
        //
        SetRectEmpty(lpClipRect);
        Edit_Unlock(ped);

        return;
    }

    if (ped->charPasswordChar)
    {
        lpClipRect->right = lpClipRect->left + ped->cPasswordCharWidth * iCount;
    }
    else 
    {
        SIZE size;

        if ( ped->fAnsi) 
        {
            GetTextExtentPointA(hdc, pText + ichStart, iCount, &size);
        } 
        else 
        {
            GetTextExtentPointW(hdc, ((LPWSTR)pText) + ichStart, iCount, &size);
        }

        lpClipRect->right = lpClipRect->left + size.cx - ped->charOverhang;
    }

    Edit_Unlock(ped);
}


//---------------------------------------------------------------------------//
//
// EditSL_LpkEditDrawText
//
// lpk!EditDrawText always sets the BkMode for single line edits to OPAQUE.
// This causes painting problems for read-only edits in property sheets.
// Unfortunately, lpk.dll can't be changed since it would break the user32
// edit, so I'm faking lpk!EditDrawText into thinking this isn't a single
// line edit.
//
__inline VOID EditSL_LpkEditDrawText(PED ped, HDC hdc, PSTR pText)
{
    BOOL fSingleSave;
    fSingleSave = ped->fSingle;
    ped->fSingle = FALSE;
    ped->pLpkEditCallout->EditDrawText((PED0)ped, hdc, pText, ped->cch, ped->ichMinSel, ped->ichMaxSel, ped->rcFmt.top);
    ped->fSingle = fSingleSave;
    
}


//---------------------------------------------------------------------------//
//
// EditSL_ChangeSelection AorW
//
// Changes the current selection to have the specified starting and
// ending values. Properly highlights the new selection and unhighlights
// anything deselected. If NewMinSel and NewMaxSel are out of order, we swap
// them. Doesn't update the caret position.
//
VOID EditSL_ChangeSelection(PED ped, HDC hdc, ICH ichNewMinSel, ICH ichNewMaxSel)
{
    ICH temp;
    ICH ichOldMinSel;
    ICH ichOldMaxSel;

    if (ichNewMinSel > ichNewMaxSel) 
    {
        temp = ichNewMinSel;
        ichNewMinSel = ichNewMaxSel;
        ichNewMaxSel = temp;
    }

    ichNewMinSel = min(ichNewMinSel, ped->cch);
    ichNewMaxSel = min(ichNewMaxSel, ped->cch);

    //
    // To avoid position to half of DBCS, check and ajust position if necessary
    //
    // We check ped->fDBCS and ped->fAnsi though Edit_AdjustIch checks these bits.
    // We're worrying about the overhead of EcLock and EcUnlock.
    //
    if (ped->fDBCS && ped->fAnsi) 
    {
        PSTR pText;

        pText = Edit_Lock(ped);
        ichNewMinSel = Edit_AdjustIch( ped, pText, ichNewMinSel );
        ichNewMaxSel = Edit_AdjustIch( ped, pText, ichNewMaxSel );
        Edit_Unlock(ped);
    }

    //
    // Preserve the Old selection
    //
    ichOldMinSel = ped->ichMinSel;
    ichOldMaxSel = ped->ichMaxSel;

    //
    // Set new selection
    //
    ped->ichMinSel = ichNewMinSel;
    ped->ichMaxSel = ichNewMaxSel;

    //
    // We will find the intersection of current selection rectangle with the new
    // selection rectangle. We will then invert the parts of the two rectangles
    // not in the intersection.
    //
    if (IsWindowVisible(ped->hwnd) && (ped->fFocus || ped->fNoHideSel)) 
    {
        SELBLOCK Blk[2];
        int   i;
        RECT  rc;

        if (ped->fFocus)
        {
            HideCaret(ped->hwnd);
        }

        if (ped->pLpkEditCallout) 
        {
            //
            // The language pack handles display while complex script support present
            //
            PSTR   pText;
            HBRUSH hbr = NULL;
            BOOL   fNeedDelete = FALSE;

            //
            // Give user a chance to manipulate the DC
            //
            hbr = Edit_GetBrush(ped, hdc, &fNeedDelete);
            FillRect(hdc, &ped->rcFmt, hbr);
            pText = Edit_Lock(ped);
            EditSL_LpkEditDrawText(ped, hdc, pText);
            Edit_Unlock(ped);
            if (hbr && fNeedDelete)
            {
                DeleteObject(hbr);
            }
        } 
        else 
        {
            Blk[0].StPos = ichOldMinSel;
            Blk[0].EndPos = ichOldMaxSel;
            Blk[1].StPos = ped->ichMinSel;
            Blk[1].EndPos = ped->ichMaxSel;

            if (Edit_CalcChangeSelection(ped, ichOldMinSel, ichOldMaxSel,
                (LPSELBLOCK)&Blk[0], (LPSELBLOCK)&Blk[1])) 
            {
                //
                // Paint the rectangles where selection has changed.
                // Paint both Blk[0] and Blk[1], if they exist.
                //
                for (i = 0; i < 2; i++) 
                {
                    if (Blk[i].StPos != 0xFFFFFFFF) 
                    {
                           EditSL_GetClipRect(ped, hdc, Blk[i].StPos,
                                                   Blk[i].EndPos - Blk[i].StPos, (LPRECT)&rc);
                           EditSL_DrawLine(ped, hdc, rc.left, rc.right, Blk[i].StPos,
                                                Blk[i].EndPos - Blk[i].StPos,
                                      ((Blk[i].StPos >= ped->ichMinSel) &&
                                   (Blk[i].StPos < ped->ichMaxSel)));
                    }
                }
            }
        }

        //
        // Update caret.
        //
        EditSL_SetCaretPosition(ped, hdc);

        if (ped->fFocus)
        {
            ShowCaret(ped->hwnd);
        }
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_DrawLine()
//
// This draws the line starting from ichStart, iCount number of characters;
// fSelStatus is TRUE if we're to draw the text as selected.
//
VOID EditSL_DrawLine(PED ped, HDC hdc, int xClipStPos, int xClipEndPos, ICH ichStart, int iCount, BOOL fSelStatus)
{
    RECT    rc;
    RECT    rcClip;
    PSTR    pText;
    DWORD   rgbSaveBk;
    DWORD   rgbSaveText;
    DWORD   wSaveBkMode;
    int     iStCount;
    ICH     ichNewStart;
    HBRUSH  hbrBack = NULL;
    BOOL    fNeedDelete = FALSE;
    HRESULT  hr;

    if (ped->pLpkEditCallout) 
    {
        TraceMsg(TF_STANDARD, "UxEdit: EditSL_DrawLine - Error - Invalid call with language pack loaded");
        return;
    }

    //
    // Anything to draw?
    //
    // PORTPORT: Note the symantics of IsWindowVisible and _IsWindowVisible are
    //           slightly different.
    if (xClipStPos >= xClipEndPos || !IsWindowVisible(ped->hwnd) )
    {
        return;
    }

    if (ped->fAnsi && ped->fDBCS) 
    {
        PSTR pT,pTOrg;
        int iTCount;

        pText = Edit_Lock(ped);
        ichNewStart = 0;
        if (ichStart > 0) 
        {
            pT = pText + ichStart;
            ichNewStart = ichStart;

            while (ichNewStart &&
                  (ichStart - ichNewStart < ped->wMaxNegCcharPos)) 
            {
                pT = Edit_AnsiPrev(ped, pText, pT);
                ichNewStart = (ICH)(pT - pText);
                if (!ichNewStart)
                {
                    break;
                }
            }

            //
            // B#16152 - win95.
            // In case of T2, SLE always set an additional margin
            // to erase a character (iCount == 0 case), using aveCharWidth.
            // It erases unexpected an extra char if we don't use ichNewStart
            // and it happens when wMaxNegCcharPos == 0.
            //
            if (ped->wMaxNegCcharPos == 0 && iCount == 0) 
            {
                pT = Edit_AnsiPrev(ped, pText, pT);
                ichNewStart = (ICH)(pT - pText);
            }
        }

        iTCount = 0;
        if (ichStart + iCount < ped->cch) 
        {
            pTOrg = pT = pText + ichStart + iCount;
            while ((iTCount < (int)ped->wMaxNegAcharPos) &&
                   (ichStart + iCount + iTCount < ped->cch)) 
            {
                pT = Edit_AnsiNext(ped, pT);
                iTCount = (int)(pT - pTOrg);
            }
        }

        Edit_Unlock(ped);
        iCount = (int)(min(ichStart+iCount+iTCount, ped->cch) - ichNewStart);
    } 
    else 
    {
        //
        // Reset ichStart to take care of the negative C widths
        //
        ichNewStart = max((int)(ichStart - ped->wMaxNegCcharPos), 0);

        //
        // Reset ichCount to take care of the negative C and A widths
        //
        iCount = (int)(min(ichStart+iCount+ped->wMaxNegAcharPos, ped->cch)
                    - ichNewStart);
    }

    ichStart = ichNewStart;

    //
    // Reset ichStart and iCount to the first one visible on the screen
    //
    if (ichStart < ped->ichScreenStart) 
    {
        if (ichStart+iCount < ped->ichScreenStart)
        {
            return;
        }

        iCount -= (ped->ichScreenStart-ichStart);
        ichStart = ped->ichScreenStart;
    }

    CopyRect(&rc, &ped->rcFmt);

    //
    // Set the drawing rectangle
    //
    rcClip.left   = xClipStPos;
    rcClip.right  = xClipEndPos;
    rcClip.top    = rc.top;
    rcClip.bottom = rc.bottom;

    //
    // Set the proper clipping rectangle
    //
    Edit_SetClip(ped, hdc, TRUE);

    pText = Edit_Lock(ped);

    //
    // Calculate the starting pos for this piece of text
    //
    if (ped->format == ES_LEFT) 
    {
        if (iStCount = (int)(ichStart - ped->ichScreenStart)) 
        {
            rc.left += EditSL_CalcXOffsetLeft(ped, hdc, ichStart);
        }
    } 
    else 
    {
        rc.left += EditSL_CalcXOffsetSpecial(ped, hdc, ichStart);
    }

    //
    // Set the background mode before calling NtUserGetControlBrush so that the app
    // can change it to TRANSPARENT if it wants to.
    //
    SetBkMode(hdc, OPAQUE);

    hr = E_FAIL;
#ifdef _USE_DRAW_THEME_TEXT_
    if ( ped->hTheme )
    {
        INT iState;
        INT iProp;
        COLORREF clrBk;
        COLORREF clrText;

        iState = fSelStatus ? ETS_SELECTED : Edit_GetStateId(ped);
        iProp  = fSelStatus ? TMT_HIGHLIGHT : TMT_FILLCOLOR;
        hr = GetThemeColor(ped->hTheme, EP_EDITTEXT, iState, iProp, &clrBk);
        if ( SUCCEEDED(hr) )
        {
            iProp  = fSelStatus ? TMT_HIGHLIGHTTEXT : TMT_TEXTCOLOR;
            hr = GetThemeColor(ped->hTheme, EP_EDITTEXT, iState, iProp, &clrText);

            if ( SUCCEEDED(hr) )
            {
                hbrBack     = CreateSolidBrush(clrBk);
                fNeedDelete = TRUE;
                rgbSaveBk   = SetBkColor(hdc, clrBk);
                rgbSaveText = SetTextColor(hdc, clrText);
            }
        }
    }
#endif // _USE_DRAW_THEME_TEXT_

    if ( !ped->hTheme || FAILED(hr) )
    {
        if (fSelStatus)
        {
            //
            // if we're not themed or we are themed but failed
            // to get the highlight and highlighttext colors
            //
            // use normal colors
            //
            hbrBack = GetSysColorBrush(COLOR_HIGHLIGHT);
            if (hbrBack == NULL) 
            {
                goto sldl_errorexit;
            }

            rgbSaveBk = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
            rgbSaveText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));

        } 
        else
        {
            //
            // We always want to send this so that the app has a chance to muck
            // with the DC.
            //
            // Note that ReadOnly and Disabled edit fields are drawn as "static"
            // instead of as "active."
            //
            hbrBack = Edit_GetBrush(ped, hdc, &fNeedDelete);
            rgbSaveBk = GetBkColor(hdc);
            rgbSaveText = GetTextColor(hdc);
        }
    }

    //
    // Erase the rectangular area before text is drawn. Note that we inflate
    // the rect by 1 so that the selection color has a one pixel border around
    // the text.
    //
    InflateRect(&rcClip, 0, 1);
    FillRect(hdc, &rcClip, hbrBack);
    InflateRect(&rcClip, 0, -1);

    if (ped->charPasswordChar) 
    {
        wSaveBkMode = SetBkMode(hdc, TRANSPARENT);

        for (iStCount = 0; iStCount < iCount; iStCount++) 
        {
            if ( ped->fAnsi )
            {
                ExtTextOutA(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                            (LPSTR)&ped->charPasswordChar, 1, NULL);
            }
            else
            {
                ExtTextOutW(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                            (LPWSTR)&ped->charPasswordChar, 1, NULL);
            }

            rc.left += ped->cPasswordCharWidth;
        }

        SetBkMode(hdc, wSaveBkMode);
    } 
    else 
    {
        if ( ped->fAnsi )
        {
            ExtTextOutA(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                    pText+ichStart,iCount, NULL);
        }
        else
        {
            ExtTextOutW(hdc, rc.left, rc.top, ETO_CLIPPED, &rcClip,
                    ((LPWSTR)pText)+ichStart,iCount, NULL);
        }
    }

    SetTextColor(hdc, rgbSaveText);
    SetBkColor(hdc, rgbSaveBk);

    if (hbrBack && fNeedDelete)
    {
        DeleteObject(hbrBack);
    }

sldl_errorexit:

    Edit_Unlock(ped);
}


//---------------------------------------------------------------------------//
//
// EditSL_GetBlkEnd AorW
// 
// Given a Starting point and and end point, this function return s whether the
// first few characters fall inside or outside the selection block and if so,
// howmany characters?
//
INT EditSL_GetBlkEnd(PED ped, ICH ichStart, ICH ichEnd, BOOL *lpfStatus)
{
    *lpfStatus = FALSE;
    if (ichStart >= ped->ichMinSel) 
    {
        if (ichStart >= ped->ichMaxSel)
        {
            return (ichEnd - ichStart);
        }

        *lpfStatus = TRUE;

        return (min(ichEnd, ped->ichMaxSel) - ichStart);
    }

    return (min(ichEnd, ped->ichMinSel) - ichStart);
}


//---------------------------------------------------------------------------//
//
// EditSL_DrawCueBannerText (Unicode Only!)
//
// This function is called by EditSL_DrawText to display the cue banner text in
// the edit box.
// 
// Note:
//  May need to call pLpkEditCallout to support complex scripts.
//
VOID EditSL_DrawCueBannerText(PED ped, HDC hdc, RECT rc)
{
    //
    // Draw the overlay of the cue banner text.
    // Only draw this text if:
    //		1. has cue banner text to display
    //		2. the edit box is empty,  
    // 		3. does not have focus, 
    //		4. is not disabled 
    //      5. and is not read only
    //
    if (ped->pszCueBannerText
    	&& ped->cch == 0 
    	&& !ped->fFocus 
    	&& !ped->fDisabled
    	&& !ped->fReadOnly)
    {
        COLORREF crOldColor;
        UINT iOldAlign; 
    
        //
    	// Setup the font to be light gray
    	// NOTE: Should this be read from the theme manager?
    	//
    	crOldColor = SetTextColor(hdc, GetSysColor(COLOR_BTNSHADOW));
        
        //
    	// Setup the alignment for the text to display.
    	// We will match our alignment with the alignment that is
    	// actually used for text in the edit control
    	//
    	switch (ped->format)
    	{
    	case ES_LEFT:
    		iOldAlign = SetTextAlign(hdc, TA_LEFT);		
    		break;
    	case ES_RIGHT:
    		iOldAlign = SetTextAlign(hdc, TA_RIGHT);		
    		break;
    	case ES_CENTER:
    		iOldAlign = SetTextAlign(hdc, TA_CENTER);		
    		break;
    	}

    	// Draw the text to the box:
        ExtTextOutW(hdc, 				
                    rc.left,
                    rc.top,
                    ETO_CLIPPED, 		
                    &(ped->rcFmt),
                    ped->pszCueBannerText,          // Text
                    wcslen(ped->pszCueBannerText),  // Size of text
                    NULL);

        //
        // Reset the alignment
        //
        SetTextAlign(hdc, iOldAlign);

        //
        // Reset the color back:
        //
        SetTextColor(hdc, crOldColor);
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_DrawText AorW
//
// Draws text for a single line edit control in the rectangle
// specified by ped->rcFmt. If ichStart == 0, starts drawing text at the left
// side of the window starting at character index ped->ichScreenStart and draws
// as much as will fit. If ichStart > 0, then it appends the characters
// starting at ichStart to the end of the text showing in the window. (ie. We
// are just growing the text length and keeping the left side
// (ped->ichScreenStart to ichStart characters) the same. Assumes the hdc came
// from Edit_GetDC so that the caret and such are properly hidden.
//
VOID EditSL_DrawText(PED ped, HDC hdc, ICH ichStart)
{
    ICH    cchToDraw;
    RECT   rc;
    PSTR   pText;
    BOOL   fSelStatus;
    int    iCount, iStCount;
    ICH    ichEnd;
    BOOL   fNoSelection;
    BOOL   fCalcRect;
    BOOL   fDrawLeftMargin = FALSE;
    BOOL   fDrawEndOfLineStrip = FALSE;
    SIZE   size;
    HBRUSH hbr = NULL;
    BOOL   fNeedDelete = FALSE;

    //
    // PORTPORT: Note the symantics of IsWindowVisible and _IsWindowVisible are
    //           slightly different.
    //
    if (!IsWindowVisible(ped->hwnd))
    {
        return;
    }

    if (ped->pLpkEditCallout) 
    {
        //
        // The language pack handles display while complex script support present
        //

        //
        // Give user a chance to manipulate the DC
        //
        hbr = Edit_GetBrush(ped, hdc, &fNeedDelete);
        pText = Edit_Lock(ped);
        EditSL_LpkEditDrawText(ped, hdc, pText);
        Edit_Unlock(ped);
        EditSL_SetCaretPosition(ped, hdc);
        if (hbr && fNeedDelete)
        {
            DeleteObject(hbr);
        }

        return;
    }

    //
    // When drawing the entire visible content of special-aligned sle
    // erase the view.
    //
    if (ped->format != ES_LEFT && ichStart == 0)
    {
        hbr = Edit_GetBrush(ped, hdc, &fNeedDelete);
        FillRect(hdc, &ped->rcFmt, hbr);
        if (hbr && fNeedDelete)
        {
            DeleteObject(hbr);
        }
    }

    pText = Edit_Lock(ped);

    if (ichStart < ped->ichScreenStart) 
    {
#if DBG
        ICH ichCompare = Edit_AdjustIch(ped, pText, ped->ichScreenStart);
        UserAssert(ichCompare == ped->ichScreenStart);
#endif
        ichStart = ped->ichScreenStart;
    }
    else if (ped->fDBCS && ped->fAnsi) 
    {
        //
        // If ichStart stays on trailing byte of DBCS, we have to
        // adjust it.
        //
        ichStart = Edit_AdjustIch(ped, pText, ichStart);
    }

    CopyRect((LPRECT)&rc, (LPRECT)&ped->rcFmt);

    //
    // Find out how many characters will fit on the screen so that we don't do
    // any needless drawing.
    //
    cchToDraw = Edit_CchInWidth(ped, hdc,
            (LPSTR)(pText + ped->ichScreenStart * ped->cbChar),
            ped->cch - ped->ichScreenStart, rc.right - rc.left, TRUE);
    ichEnd = ped->ichScreenStart + cchToDraw;

    //
    // There is no selection if,
    // 1. MinSel and MaxSel are equal OR
    // 2. (This has lost the focus AND Selection is to be hidden)
    //
    fNoSelection = ((ped->ichMinSel == ped->ichMaxSel) || (!ped->fFocus && !ped->fNoHideSel));

    if (ped->format == ES_LEFT) 
    {
        if (iStCount = (int)(ichStart - ped->ichScreenStart)) 
        {
            rc.left += EditSL_CalcXOffsetLeft(ped, hdc, ichStart);
        }
    } 
    else 
    {
        rc.left += EditSL_CalcXOffsetSpecial(ped, hdc, ichStart);
    }

    //
    // If this is the begining of the whole line, we may have to draw a blank
    // strip at the begining.
    //
    if ((ichStart == 0) && ped->wLeftMargin)
    {
        fDrawLeftMargin = TRUE;
    }

    //
    // If there is nothing to draw, that means we need to draw the end of
    // line strip, which erases the last character.
    //
    if (ichStart == ichEnd) 
    {
        fDrawEndOfLineStrip = TRUE;
        rc.left -= ped->wLeftMargin;
    }

    while (ichStart < ichEnd) 
    {
        fCalcRect = TRUE;

        if (fNoSelection) 
        {
            fSelStatus = FALSE;
            iCount = ichEnd - ichStart;
        } 
        else 
        {
            if (fDrawLeftMargin) 
            {
                iCount = 0;
                fSelStatus = FALSE;
                fCalcRect = FALSE;
                rc.right = rc.left;
            } 
            else
            {
                iCount = EditSL_GetBlkEnd(ped, ichStart, ichEnd,
                    (BOOL  *)&fSelStatus);
            }
        }


        if (ichStart+iCount == ichEnd) 
        {
            if (fSelStatus)
            {
                fDrawEndOfLineStrip = TRUE;
            }
            else 
            {
                rc.right = ped->rcFmt.right + ped->wRightMargin;
                fCalcRect = FALSE;
            }
        }

        if (fCalcRect) 
        {
            if (ped->charPasswordChar)
            {
                rc.right = rc.left + ped->cPasswordCharWidth * iCount;
            }
            else 
            {
                if ( ped->fAnsi )
                {
                    GetTextExtentPointA(hdc, pText + ichStart,
                                        iCount, &size);
                }
                else
                {
                    GetTextExtentPointW(hdc, ((LPWSTR)pText) + ichStart,
                                        iCount, &size);
                }

                rc.right = rc.left + size.cx;

                //
                // The extent is equal to the advance width. So for TrueType fonts
                // we need to take care of Neg A and C. For non TrueType, the extent
                // includes the overhang.
                // If drawing the selection, draw only the advance width
                //
                if (fSelStatus) 
                {
                    rc.right -= ped->charOverhang;
                } 
                else if (ped->fTrueType) 
                {
                    rc.right += ped->wMaxNegC;
                    if (iStCount > 0) 
                    {
                        rc.right += ped->wMaxNegA;
                        iStCount = 0;
                    }
                }

            }

        }

        if (fDrawLeftMargin) 
        {
            fDrawLeftMargin = FALSE;
            rc.left -= ped->wLeftMargin;
            if (rc.right < rc.left) 
            {
                rc.right = rc.left;
            }
        }

        EditSL_DrawLine(ped, hdc, rc.left, rc.right, ichStart, iCount, fSelStatus);

        ichStart += iCount;
        rc.left = rc.right;

        //
        // If we're going to draw the selection, adjust rc.left
        // to include advance width of the selected text
        // For non TT fonts, ped->wMaxNegC equals ped->charOverhang
        //
        if (!fSelStatus && (iCount != 0) && (ichStart < ichEnd)) 
        {
            rc.left -= ped->wMaxNegC;
        }
    }
	   
    Edit_Unlock(ped);

    //
    // Check if anything to be erased on the right hand side
    //
    if (fDrawEndOfLineStrip &&
            (rc.left < (rc.right = (ped->rcFmt.right+ped->wRightMargin))))
    {
        EditSL_DrawLine(ped, hdc, rc.left, rc.right, ichStart, 0, FALSE);
    }

    EditSL_SetCaretPosition(ped, hdc);

    //
    // Call the function to display the cue banner text into the edit box
    //
    EditSL_DrawCueBannerText(ped, hdc, rc);
}


//---------------------------------------------------------------------------//
//
// EditSL_ScrollText AorW
//
// Scrolls the text to bring the caret into view. If the text is
// scrolled, the current selection is unhighlighted. Returns TRUE if the text
// is scrolled else return s false.
//
BOOL EditSL_ScrollText(PED ped, HDC hdc)
{
    PSTR pTextScreenStart;
    ICH scrollAmount;
    ICH newScreenStartX = ped->ichScreenStart;
    ICH cch;
    BOOLEAN fAdjustNext = FALSE;

    if (!ped->fAutoHScroll)
    {
        return FALSE;
    }

    if (ped->pLpkEditCallout) 
    {
        BOOL fChanged;

        //
        // With complex script glyph reordering, use lpk to do horz scroll
        //
        pTextScreenStart = Edit_Lock(ped);
        fChanged = ped->pLpkEditCallout->EditHScroll((PED0)ped, hdc, pTextScreenStart);
        Edit_Unlock(ped);

        if (fChanged) 
        {
            EditSL_DrawText(ped, hdc, 0);
        }

        return fChanged;
    }

    //
    // Calculate the new starting screen position
    //
    if (ped->ichCaret <= ped->ichScreenStart) 
    {
        //
        // Caret is to the left of the starting text on the screen we must
        // scroll the text backwards to bring it into view. Watch out when
        // subtracting unsigned numbers when we have the possibility of going
        // negative.
        //
        pTextScreenStart = Edit_Lock(ped);

        scrollAmount = Edit_CchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                ped->ichCaret, (ped->rcFmt.right - ped->rcFmt.left) / 4, FALSE);

        newScreenStartX = ped->ichCaret - scrollAmount;
        Edit_Unlock(ped);
    } 
    else if (ped->ichCaret != ped->ichScreenStart) 
    {
        pTextScreenStart = Edit_Lock(ped);
        pTextScreenStart += ped->ichScreenStart * ped->cbChar;

        cch = Edit_CchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                ped->ichCaret - ped->ichScreenStart,
                ped->rcFmt.right - ped->rcFmt.left, FALSE);

        if (cch < ped->ichCaret - ped->ichScreenStart) 
        {
            fAdjustNext = TRUE;

            //
            // Scroll Forward 1/4 -- if that leaves some empty space
            // at the end, scroll back enough to fill the space
            //
            newScreenStartX = ped->ichCaret - (3 * cch / 4);

            cch = Edit_CchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                    ped->cch - ped->ichScreenStart,
                    ped->rcFmt.right - ped->rcFmt.left, FALSE);

            if (newScreenStartX > (ped->cch - cch))
            {
                newScreenStartX = ped->cch - cch;
            }
        } 
        else if (ped->format != ES_LEFT) 
        {
            cch = Edit_CchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                    ped->cch - ped->ichScreenStart,
                    ped->rcFmt.right - ped->rcFmt.left, FALSE);

            //
            // Scroll the text hidden behind the left border back
            // into view.
            //
            if (ped->ichScreenStart == ped->cch - cch) 
            {
                pTextScreenStart -= ped->ichScreenStart * ped->cbChar;
                cch = Edit_CchInWidth(ped, hdc, (LPSTR)pTextScreenStart,
                        ped->cch, ped->rcFmt.right - ped->rcFmt.left, FALSE);

                newScreenStartX = ped->cch - cch;
            }
        }

        Edit_Unlock(ped);
    }

    //
    // Adjust newScreenStartX
    //
    if (ped->fAnsi && ped->fDBCS) 
    {
        newScreenStartX = (fAdjustNext ? Edit_AdjustIchNext : Edit_AdjustIch)(ped,
                                                                        Edit_Lock(ped),
                                                                        newScreenStartX);
        Edit_Unlock(ped);
    }

    if (ped->ichScreenStart != newScreenStartX) 
    {
        //
        // Check if we have to wipe out the left margin
        //
        if (ped->wLeftMargin && (ped->ichScreenStart == 0)) 
        {
            RECT   rc;
            HBRUSH hBrush = NULL;
            BOOL   fNeedDelete = FALSE;

            hBrush = Edit_GetBrush(ped, hdc, &fNeedDelete);

            CopyRect(&rc, &ped->rcFmt);
            InflateRect(&rc, 0, 1);
            rc.right = rc.left;
            rc.left -= ped->wLeftMargin;

            FillRect(hdc, &rc, hBrush);
            if (hBrush && fNeedDelete)
            {
                DeleteObject(hBrush);
            }
        }

        ped->ichScreenStart = newScreenStartX;
        EditSL_DrawText(ped, hdc, 0);

        //
        // Caret pos is set by EditSL_DrawText().
        //
        return TRUE;
    }

    return FALSE;
}


//---------------------------------------------------------------------------//
//
// EditSL_InsertText AorW
//
// Adds up to cchInsert characters from lpText to the ped starting at
// ichCaret. If the ped only allows a maximum number of characters, then we
// will only add that many characters to the ped and send a EN_MAXTEXT
// notification code to the parent of the ec. Also, if !fAutoHScroll, then we
// only allow as many chars as will fit in the client rectangle. The number of
// characters actually added is return ed (could be 0). If we can't allocate
// the required space, we notify the parent with EN_ERRSPACE and no characters
// are added.
//
ICH EditSL_InsertText(PED ped, LPSTR lpText, ICH cchInsert)
{
    HDC hdc;
    PSTR pText;
    ICH cchInsertCopy = cchInsert;
    ICH cchT;
    int textWidth;
    SIZE size;

    //
    // First determine exactly how many characters from lpText we can insert
    // into the ped.
    //
    if( ped->cchTextMax <= ped->cch)
    {
       cchInsert = 0;
    }
    else 
    {
        if (!ped->fAutoHScroll) 
        {
            pText = Edit_Lock(ped);
            hdc = Edit_GetDC(ped, TRUE);

            cchInsert = min(cchInsert, (unsigned)(ped->cchTextMax - ped->cch));
            if (ped->charPasswordChar)
            {
                textWidth = ped->cch * ped->cPasswordCharWidth;
            }
            else 
            {
                if (ped->fAnsi)
                {
                    GetTextExtentPointA(hdc, (LPSTR)pText,  ped->cch, &size);
                }
                else
                {
                    GetTextExtentPointW(hdc, (LPWSTR)pText, ped->cch, &size);
                }

                textWidth = size.cx;
            }

            cchT = Edit_CchInWidth(ped, hdc, lpText, cchInsert,
                                ped->rcFmt.right - ped->rcFmt.left -
                                textWidth, TRUE);
            cchInsert = min(cchInsert, cchT);

            Edit_Unlock(ped);
            Edit_ReleaseDC(ped, hdc, TRUE);
        } 
        else 
        {
            cchInsert = min((unsigned)(ped->cchTextMax - ped->cch), cchInsert);
        }
    }

    //
    // Now try actually adding the text to the ped
    //
    if (cchInsert && !Edit_InsertText(ped, lpText, &cchInsert)) 
    {
        Edit_NotifyParent(ped, EN_ERRSPACE);
        return 0;
    }
    if (cchInsert)
    {
        ped->fDirty = TRUE;
    }

    if (cchInsert < cchInsertCopy) 
    {
        //
        // Notify parent that we couldn't insert all the text requested
        //
        Edit_NotifyParent(ped, EN_MAXTEXT);
    }

    //
    // Update selection extents and the caret position. Note that Edit_InsertText
    // updates ped->ichCaret, ped->ichMinSel, and ped->ichMaxSel to all be after
    // the inserted text.
    //
    return cchInsert;
}


//---------------------------------------------------------------------------//
//
// EditSL_PasteText AorW
//
// Pastes a line of text from the clipboard into the edit control
// starting at ped->ichMaxSel. Updates ichMaxSel and ichMinSel to point to
// the end of the inserted text. Notifies the parent if space cannot be
// allocated. Returns how many characters were inserted.
//
ICH EditSL_PasteText(PED ped)
{
    HANDLE hData;
    LPSTR lpchClip;
    ICH cchAdded = 0;
    ICH clipLength;

    if (!OpenClipboard(ped->hwnd))
    {
        goto PasteExitNoCloseClip;
    }
    
    hData = GetClipboardData(ped->fAnsi ? CF_TEXT : CF_UNICODETEXT);
    if (!hData || (GlobalFlags(hData) == GMEM_INVALID_HANDLE)) 
    {
        TraceMsg(TF_STANDARD, "UxEdit: EditSL_PasteText(): couldn't get a valid handle(%x)", hData);
        goto PasteExit;
    }

    lpchClip = GlobalLock(hData);
    if (lpchClip == NULL) 
    {
        TraceMsg(TF_STANDARD, "UxEdit: EditSL_PasteText(): USERGLOBALLOCK(%x) failed.", hData);
        goto PasteExit;
    }

    if (ped->fAnsi) 
    {
        LPSTR lpchClip2 = lpchClip;

        //
        // Find the first carrage return or line feed. Just add text to that point.
        //
        clipLength = (UINT)strlen(lpchClip);
        for (cchAdded = 0; cchAdded < clipLength; cchAdded++)
        {
            if (*lpchClip2++ == 0x0D)
            {
                break;
            }
        }

    } 
    else 
    {
        LPWSTR lpwstrClip2 = (LPWSTR)lpchClip;

        //
        // Find the first carrage return or line feed. Just add text to that point.
        //
        clipLength = (UINT)wcslen((LPWSTR)lpchClip);
        for (cchAdded = 0; cchAdded < clipLength; cchAdded++)
        {
            if (*lpwstrClip2++ == 0x0D)
            {
                break;
            }
        }
    }

    //
    // Insert the text (EditSL_InsertText checks line length)
    //
    cchAdded = EditSL_InsertText(ped, lpchClip, cchAdded);

    GlobalUnlock(hData);

PasteExit:
    CloseClipboard();

PasteExitNoCloseClip:
    return cchAdded;
}


//---------------------------------------------------------------------------//
//
// EditSL_ReplaceSel AorW
//
// Replaces the text in the current selection with the given text.
//
VOID EditSL_ReplaceSel(PED ped, LPSTR lpText)
{
    UINT cchText;

    //
    // Delete text, putting it into the clean undo buffer.
    //
    Edit_EmptyUndo(Pundo(ped));
    Edit_DeleteText(ped);

    //
    // B#3356
    // Some apps do "clear" by selecting all of the text, then replacing it
    // with "", in which case EditSL_InsertText() will return 0.  But that
    // doesn't mean failure...
    //
    if ( ped->fAnsi )
    {
        cchText = strlen(lpText);
    }
    else
    {
        cchText = wcslen((LPWSTR)lpText);
    }

    if (cchText) 
    {
        BOOL fFailed;
        UNDO undo;
        HWND hwndSave;

        //
        // Save undo buffer, but DO NOT CLEAR IT!
        //
        Edit_SaveUndo(Pundo(ped), &undo, FALSE);

        hwndSave = ped->hwnd;
        fFailed = (BOOL) !EditSL_InsertText(ped, lpText, cchText);
        if (!IsWindow(hwndSave))
        {
            return;
        }

        if (fFailed) 
        {
            //
            // UNDO the previous edit.
            //
            Edit_SaveUndo(&undo, Pundo(ped), FALSE);
            EditSL_Undo(ped);
            return;
        }
    }

    //
    // Success.  So update the display
    //
    Edit_NotifyParent(ped, EN_UPDATE);

    // PORTPORT: Note the symantics of IsWindowVisible and _IsWindowVisible are
    //           slightly different.
    if (IsWindowVisible(ped->hwnd)) 
    {
        HDC hdc;

        hdc = Edit_GetDC(ped, FALSE);

        if (!EditSL_ScrollText(ped, hdc))
        {
            EditSL_DrawText(ped, hdc, 0);
        }

        Edit_ReleaseDC(ped, hdc, FALSE);
    }

    Edit_NotifyParent(ped, EN_CHANGE);

    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
}


//---------------------------------------------------------------------------//
//
// EditSL_Char AorW
// 
// Handles character input
//
VOID EditSL_Char(PED ped, DWORD keyValue)
{
    HDC hdc;
    WCHAR keyPress;
    BOOL updateText = FALSE;
    HWND hwndSave = ped->hwnd;
    int InsertTextLen = 1;
    int DBCSkey;

    if (ped->fAnsi)
    {
        keyPress = LOBYTE(keyValue);
    }
    else
    {
        keyPress = LOWORD(keyValue);
    }

    if (ped->fMouseDown || (ped->fReadOnly && keyPress != 3)) 
    {
        //
        // Don't do anything if we are in the middle of a mousedown deal or if
        // this is a read only edit control, with exception of allowing
        // ctrl-C in order to copy to the clipboard.
        //
        return;
    }

    if (g_fIMMEnabled) 
    {
        Edit_InOutReconversionMode(ped, FALSE);
    }

    switch (keyPress) 
    {
    case VK_BACK:
DeleteSelection:
        if (Edit_DeleteText(ped))
        {
            updateText = TRUE;
        }

        break;

    default:
        if (keyPress >= TEXT(' '))
        {
            //
            // If this is in [a-z],[A-Z] and we are an ES_NUMBER
            // edit field, bail.
            //
            if (ped->f40Compat && (GET_STYLE(ped) & ES_NUMBER)) 
            {
                if (!Edit_IsCharNumeric(ped, keyPress)) 
                {
                    Edit_ShowBalloonTipWrap(ped->hwnd, IDS_NUMERIC_TITLE, IDS_NUMERIC_MSG, TTI_ERROR);
                    goto IllegalChar;
                }
            }

            goto DeleteSelection;
        }

        break;
    }

    switch (keyPress) 
    {
    case 3:

        //
        // CTRL-C Copy
        //
        SendMessage(ped->hwnd, WM_COPY, 0, 0L);
        return;

    case VK_BACK:

        //
        // Delete any selected text or delete character left if no sel
        //
        if (!updateText && ped->ichMinSel) 
        {
            //
            // There was no selection to delete so we just delete character
            // left if available
            //
            // Calling PrevIch rather than just doing a decrement for VK_BACK
            //
            ped->ichMinSel = Edit_PrevIch( ped, NULL, ped->ichMinSel);
            Edit_DeleteText(ped);
            updateText = TRUE;
        }

        break;

    case 22:
        //
        // CTRL-V Paste
        //
        SendMessage(ped->hwnd, WM_PASTE, 0, 0L);
        return;

    case 24:
        //
        // CTRL-X Cut
        //
        if (ped->ichMinSel == ped->ichMaxSel)
        {
            goto IllegalChar;
        }

        SendMessage(ped->hwnd, WM_CUT, 0, 0L);
        return;

    case 26: 
        //
        // CTRL-Z Undo
        //
        SendMessage(ped->hwnd, EM_UNDO, 0, 0L);
        return;

    case VK_RETURN:
    case VK_ESCAPE:
        //
        // If this is an edit control for a combobox and the dropdown list
        // is visible, forward it up to the combo.
        //
        if (ped->listboxHwnd && SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0L)) 
        {
            SendMessage(ped->hwndParent, WM_KEYDOWN, (WPARAM)keyPress, 0L);
        } 
        else
        {
            goto IllegalChar;
        }

        return;

    default:
        if (keyPress >= 0x1E) 
        {
            //
            // 1E,1F are unicode block and segment separators
            //

            //
            // Hide the cursor if typing, if the mouse is captured, do not mess with this
            // as it is going to desapear forever (no WM_SETCURSOR is sent to restore it
            // at the first mouse-move)
            // MCostea #166951
            //
            if (GetCapture() == NULL)
            {
                SetCursor(NULL);
            }

            if (g_fDBCSEnabled && ped->fAnsi && (Edit_IsDBCSLeadByte(ped,(BYTE)keyPress))) 
            {
                if ((DBCSkey = DbcsCombine(ped->hwnd, keyPress)) != 0 &&
                     EditSL_InsertText(ped,(LPSTR)&DBCSkey, 2) == 2) 
                {
                    InsertTextLen = 2;
                    updateText = TRUE;
                } 
                else 
                {
                    MessageBeep(0);
                }
            } 
            else 
            {
                InsertTextLen = 1;
                if (EditSL_InsertText(ped, (LPSTR)&keyPress, 1))
                {
                    updateText = TRUE;
                }
                else
                {
                    //
                    // Beep. Since we couldn't add the text
                    //
                    MessageBeep(0);
                }
            }
        } 
        else 
        {
IllegalChar:
            MessageBeep(0);
        }

        if (!IsWindow(hwndSave))
        {
            return;
        }

        break;
    }

    if (updateText) 
    {
        //
        // Dirty flag (ped->fDirty) was set when we inserted text
        //
        Edit_NotifyParent(ped, EN_UPDATE);
        hdc = Edit_GetDC(ped, FALSE);
        if (!EditSL_ScrollText(ped, hdc)) 
        {
            if (ped->format == ES_LEFT) 
            {
                //
                // Call EditSL_DrawText with correct ichStart
                //
                EditSL_DrawText(ped, hdc, max(0, (int)(ped->ichCaret - InsertTextLen - ped->wMaxNegCcharPos)));
            } 
            else 
            {
                //
                // We can't just draw from ichStart because string may have
                // shifted because of alignment.
                //
                EditSL_DrawText(ped, hdc, 0);
            }
        }

        Edit_ReleaseDC(ped, hdc, FALSE);
        Edit_NotifyParent(ped, EN_CHANGE);

        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_MoveSelectionRestricted AorW
//
// Moves the selection like Edit_MoveSelection, but also obeys limitations
// imposed by some languages such as Thai, where the cursor cannot stop
// between a character and it's attached vowel or tone marks.
//
// Only called if the language pack is loaded.
//
ICH EditSL_MoveSelectionRestricted(PED ped, ICH ich, BOOL fLeft)
{
    PSTR pText;
    HDC  hdc;
    ICH  ichResult;

    pText = Edit_Lock(ped);
    hdc = Edit_GetDC(ped, TRUE);
    ichResult = ped->pLpkEditCallout->EditMoveSelection((PED0)ped, hdc, pText, ich, fLeft);
    Edit_ReleaseDC(ped, hdc, TRUE);
    Edit_Unlock(ped);

    return ichResult;
}


//---------------------------------------------------------------------------//
void EditSL_CheckCapsLock(PED ped)
{
    if ((GetKeyState(VK_CAPITAL) & 0x0001) != 0)
    {
        Edit_ShowBalloonTipWrap(ped->hwnd, IDS_CAPSLOCK_TITLE, IDS_CAPSLOCK_MSG, TTI_WARNING);
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_KeyDown AorW
//
// Handles cursor movement and other VIRT KEY stuff. keyMods allows
// us to make EditSL_KeyDownHandler calls and specify if the modifier keys (shift
// and control) are up or down. This is useful for imnplementing the
// cut/paste/clear messages for single line edit controls. If keyMods == 0,
// we get the keyboard state using GetKeyState(VK_SHIFT) etc. Otherwise, the
// bits in keyMods define the state of the shift and control keys.
//
VOID EditSL_KeyDown(PED ped, DWORD virtKeyCode, int keyMods)
{
    HDC hdc;

    //
    // Variables we will use for redrawing the updated text
    //
    ICH newMaxSel = ped->ichMaxSel;
    ICH newMinSel = ped->ichMinSel;

    //
    // Flags for drawing the updated text
    //
    BOOL updateText = FALSE;
    BOOL changeSelection = FALSE;   // new selection is specified by
                                    // newMinSel, newMaxSel

    //
    // Comparisons we do often
    //
    BOOL MinEqMax = (newMaxSel == newMinSel);
    BOOL MinEqCar = (ped->ichCaret == newMinSel);
    BOOL MaxEqCar = (ped->ichCaret == newMaxSel);

    //
    // State of shift and control keys.
    //
    int scState;

    //
    // Combo box support
    //
    BOOL fIsListVisible;
    BOOL fIsExtendedUI;

    if (ped->fMouseDown) 
    {
        //
        // If we are in the middle of a mouse down handler, then don't do
        // anything. ie. ignore keyboard input.
        //
        return;
    }

    if (ped->hwndBalloon)
    {
        Edit_HideBalloonTip(ped->hwnd);
    }

    scState = Edit_GetModKeys(keyMods);

    switch (virtKeyCode) 
    {
    case VK_UP:
        if ( ped->listboxHwnd ) 
        {
            //
            // Handle Combobox support
            //
            fIsExtendedUI = (BOOL)SendMessage(ped->hwndParent, CB_GETEXTENDEDUI, 0, 0);
            fIsListVisible = (BOOL)SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0);

            if (!fIsListVisible && fIsExtendedUI) 
            {
DropExtendedUIListBox:
                //
                // Since an extendedui combo box doesn't do anything on f4, we
                // turn off the extended ui, send the f4 to drop, and turn it
                // back on again.
                //
                SendMessage(ped->hwndParent, CB_SETEXTENDEDUI, 0, 0);
                SendMessage(ped->listboxHwnd, WM_KEYDOWN, VK_F4, 0);
                SendMessage(ped->hwndParent, CB_SETEXTENDEDUI, 1, 0);

                return;
            } 
            else
            {
                goto SendKeyToListBox;
            }
        }

    //
    // else fall through
    //
    case VK_LEFT:
        //
        // If the caret isn't at the beginning, we can move left
        //
        if (ped->ichCaret) 
        {
            //
            // Get new caret pos.
            //
            if (scState & CTRLDOWN) 
            {
                //
                // Move caret word left
                //
                Edit_Word(ped, ped->ichCaret, TRUE, &ped->ichCaret, NULL);
            } 
            else 
            {
                //
                // Move caret char left
                //
                if (ped->pLpkEditCallout) 
                {
                    ped->ichCaret = EditSL_MoveSelectionRestricted(ped, ped->ichCaret, TRUE);
                } 
                else
                {
                    ped->ichCaret = Edit_PrevIch(ped,NULL,ped->ichCaret);
                }
            }

            //
            // Get new selection
            //
            if (scState & SHFTDOWN) 
            {
                if (MaxEqCar && !MinEqMax) 
                {
                    //
                    // Reduce selection
                    //
                    newMaxSel = ped->ichCaret;

                    UserAssert(newMinSel == ped->ichMinSel);
                } 
                else 
                {
                    //
                    // Extend selection
                    //
                    newMinSel = ped->ichCaret;
                }
            } 
            else 
            {
                //
                // Clear selection
                //
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } 
        else 
        {
            //
            // If the user tries to move left and we are at the 0th
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) && !(scState & SHFTDOWN) ) 
            {
                changeSelection = TRUE;
                newMaxSel = newMinSel = ped->ichCaret;
            }
        }
        break;

    case VK_DOWN:
        if (ped->listboxHwnd) 
        {
            //
            // Handle Combobox support
            //
            fIsExtendedUI = (BOOL)SendMessage(ped->hwndParent, CB_GETEXTENDEDUI, 0, 0);
            fIsListVisible = (BOOL)SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0);

            if (!fIsListVisible && fIsExtendedUI) 
            {
                goto DropExtendedUIListBox;
            } 
            else
            {
                goto SendKeyToListBox;
            }
        }

    //
    // else fall through
    //
    case VK_RIGHT:
        //
        // If the caret isn't at the end, we can move right.
        //
        if (ped->ichCaret < ped->cch) 
        {
            //
            // Get new caret pos.
            //
            if (scState & CTRLDOWN) 
            {
                //
                // Move caret word right
                //
                Edit_Word(ped, ped->ichCaret, FALSE, NULL, &ped->ichCaret);
            } 
            else 
            {
                //
                // Move caret char right
                //
                if (ped->pLpkEditCallout) 
                {
                    ped->ichCaret = EditSL_MoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } 
                else
                {
                    ped->ichCaret = Edit_NextIch(ped,NULL,ped->ichCaret);
                }
            }

            //
            // Get new selection.
            //
            if (scState & SHFTDOWN) 
            {
                if (MinEqCar && !MinEqMax) 
                {
                    //
                    // Reduce selection
                    //
                    newMinSel = ped->ichCaret;

                    UserAssert(newMaxSel == ped->ichMaxSel);
                } 
                else 
                {
                    //
                    // Extend selection
                    //
                    newMaxSel = ped->ichCaret;
                }
            } 
            else 
            {
                //
                // Clear selection
                //
                newMaxSel = newMinSel = ped->ichCaret;
            }

            changeSelection = TRUE;
        } 
        else 
        {
            //
            // If the user tries to move right and we are at the last
            // character and there is a selection, then cancel the
            // selection.
            //
            if ( (ped->ichMaxSel != ped->ichMinSel) &&
                !(scState & SHFTDOWN) ) 
            {
                newMaxSel = newMinSel = ped->ichCaret;
                changeSelection = TRUE;
            }
        }
        break;

    case VK_HOME:
        //
        // Move caret to top.
        //
        ped->ichCaret = 0;

        //
        // Update selection.
        //
        if (scState & SHFTDOWN) 
        {
            if (MaxEqCar && !MinEqMax) 
            {
                //
                // Reduce selection
                //
                newMinSel = ped->ichCaret;
                newMaxSel = ped->ichMinSel;
            } 
            else 
            {
                //
                // Extend selection
                //
                newMinSel = ped->ichCaret;
            }
        } 
        else 
        {
            //
            // Clear selection
            //
            newMaxSel = newMinSel = ped->ichCaret;
        }

        changeSelection = TRUE;
        break;

    case VK_END:
        //
        // Move caret to end.
        //
        ped->ichCaret = ped->cch;

        //
        // Update selection.
        //
        newMaxSel = ped->ichCaret;
        if (scState & SHFTDOWN) 
        {
            if (MinEqCar && !MinEqMax) 
            {
                //
                // Reduce selection
                //
                newMinSel = ped->ichMaxSel;
            }
        } 
        else 
        {
            //
            // Clear selection
            //
            newMinSel = ped->ichCaret;
        }

        changeSelection = TRUE;
        break;

    case VK_DELETE:
        if (ped->fReadOnly)
        {
            break;
        }

        switch (scState) 
        {
        case NONEDOWN:

            //
            // Clear selection. If no selection, delete (clear) character
            // right.
            //
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) 
            {
                //
                // Move cursor forwards and simulate a backspace.
                //
                if (ped->pLpkEditCallout) 
                {
                    ped->ichMinSel = ped->ichCaret;
                    ped->ichMaxSel = ped->ichCaret = EditSL_MoveSelectionRestricted(ped, ped->ichCaret, FALSE);
                } 
                else 
                {
                    ped->ichCaret = Edit_NextIch(ped,NULL,ped->ichCaret);
                    ped->ichMaxSel = ped->ichMinSel = ped->ichCaret;
                }

                EditSL_Char(ped, (UINT)VK_BACK);
            }

            if (ped->ichMinSel != ped->ichMaxSel)
            {
                EditSL_Char(ped, (UINT)VK_BACK);
            }

            break;

        case SHFTDOWN:

            //
            // Send ourself a WM_CUT message if a selection exists.
            // Otherwise, delete the left character.
            //
            if (ped->ichMinSel == ped->ichMaxSel) 
            {
                UserAssert(!ped->fEatNextChar);
                EditSL_Char(ped, VK_BACK);
            } 
            else
            {
                SendMessage(ped->hwnd, WM_CUT, 0, 0L);
            }

            break;

        case CTRLDOWN:

            //
            // Delete to end of line if no selection else delete (clear)
            // selection.
            //
            if ((ped->ichMaxSel < ped->cch) && (ped->ichMinSel == ped->ichMaxSel)) 
            {
                //
                // Move cursor to end of line and simulate a backspace.
                //
                ped->ichMaxSel = ped->ichCaret = ped->cch;
            }

            if (ped->ichMinSel != ped->ichMaxSel)
            {
                EditSL_Char(ped, (UINT)VK_BACK);
            }

            break;

        }

        //
        // No need to update text or selection since BACKSPACE message does it
        // for us.
        //
        break;

    case VK_INSERT:
        switch (scState) 
        {
        case CTRLDOWN:

            //
            // Copy current selection to clipboard
            //
            SendMessage(ped->hwnd, WM_COPY, 0, 0);
            break;

        case SHFTDOWN:
            SendMessage(ped->hwnd, WM_PASTE, 0, 0L);
            break;
        }
        break;

    case VK_HANJA:
        //
        // VK_HANJA support
        //
        if ( HanjaKeyHandler( ped ) ) 
        {
            changeSelection = TRUE;
            newMinSel = ped->ichCaret;
            newMaxSel = ped->ichCaret + (ped->fAnsi ? 2 : 1);
        }

        break;

    case VK_CAPITAL:

        if (GET_STYLE(ped) & ES_PASSWORD)
        {
            EditSL_CheckCapsLock(ped);
        }

        break;

    case VK_F4:
    case VK_PRIOR:
    case VK_NEXT:

        //
        // Send keys to the listbox if we are a part of a combo box. This
        // assumes the listbox ignores keyup messages which is correct right
        // now.
        //
SendKeyToListBox:
        if (ped->listboxHwnd) 
        {
            //
            // Handle Combobox support
            //
            SendMessage(ped->listboxHwnd, WM_KEYDOWN, virtKeyCode, 0L);
            return;
        }
    }

    if (changeSelection || updateText) 
    {
        hdc = Edit_GetDC(ped, FALSE);

        //
        // Scroll if needed
        //
        EditSL_ScrollText(ped, hdc);

        if (changeSelection)
        {
            EditSL_ChangeSelection(ped, hdc, newMinSel, newMaxSel);
        }

        if (updateText)
        {
            EditSL_DrawText(ped, hdc, 0);
        }

        Edit_ReleaseDC(ped, hdc, FALSE);
        if (updateText) 
        {
            Edit_NotifyParent(ped, EN_CHANGE);

            NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
        }
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_MouseToIch AorW
//
// Returns the closest cch to where the mouse point is.
//
ICH EditSL_MouseToIch(PED ped, HDC hdc, LPPOINT mousePt)
{
    PSTR pText;
    int width = mousePt->x;
    int lastHighWidth, lastLowWidth;
    SIZE size;
    ICH cch;
    ICH cchLo, cchHi;
    LPSTR lpText;
    FnGetTextExtentPoint pGetTextExtentPoint;

    if (ped->pLpkEditCallout) 
    {
        pText = Edit_Lock(ped);
        cch = ped->pLpkEditCallout->EditMouseToIch((PED0)ped, hdc, pText, ped->cch, width);
        Edit_Unlock(ped);

        return cch;
    }

    if (width <= ped->rcFmt.left) 
    {
        //
        // Return either the first non visible character or return 0 if at
        // beginning of text
        //
        if (ped->ichScreenStart)
        {
            return (ped->ichScreenStart - 1);
        }
        else
        {
            return 0;
        }
    }

    if (width > ped->rcFmt.right) 
    {
        pText = Edit_Lock(ped);

        //
        // Return last char in text or one plus the last char visible
        //
        cch = Edit_CchInWidth(ped, hdc,
                (LPSTR)(pText + ped->ichScreenStart * ped->cbChar),
                ped->cch - ped->ichScreenStart, ped->rcFmt.right -
                ped->rcFmt.left, TRUE) + ped->ichScreenStart;

        //
        // This is marked as JAPAN in Win31J. But it should be a DBCS
        // issue. LiZ -- 5/5/93
        // We must check DBCS Lead byte. Because Edit_AdjustIch() pick up Prev Char.
        //  1993.3.9 by yutakas
        //
        if (ped->fAnsi && ped->fDBCS) 
        {
            if (cch >= ped->cch) 
            {
                cch = ped->cch;
            } 
            else 
            {
                if (Edit_IsDBCSLeadByte(ped,*(pText+cch))) 
                {
                    cch += 2;
                } 
                else 
                {
                    cch ++;
                }
            }

            Edit_Unlock(ped);

            return cch;
        } 
        else 
        {
            Edit_Unlock(ped);
            if (cch >= ped->cch)
            {
                return (ped->cch);
            }
            else
            {
                return (cch + 1);
            }
        }
    }

    if (ped->format != ES_LEFT) 
    {
        width -= EditSL_CalcXOffsetSpecial(ped, hdc, ped->ichScreenStart);
    }

    //
    // Check if password hidden chars are being used.
    //
    if (ped->charPasswordChar)
    {
        return min( (DWORD)( (width - ped->rcFmt.left) / ped->cPasswordCharWidth),
                    ped->cch);
    }

    if (!ped->cch)
    {
        return 0;
    }

    pText = Edit_Lock(ped);
    lpText = pText + ped->ichScreenStart * ped->cbChar;

    pGetTextExtentPoint = ped->fAnsi ? (FnGetTextExtentPoint)GetTextExtentPointA
                                     : (FnGetTextExtentPoint)GetTextExtentPointW;
    width -= ped->rcFmt.left;

    //
    // If the user clicked past the end of the text, return the last character
    //
    cchHi = ped->cch - ped->ichScreenStart;
    pGetTextExtentPoint(hdc, lpText, cchHi, &size);
    if (size.cx <= width) 
    {
        cch = cchHi;
        goto edAdjust;
    }

    //
    // Initialize Binary Search Bounds
    //
    cchLo = 0;
    cchHi ++;
    lastLowWidth = 0;
    lastHighWidth = size.cx;

    //
    // Binary search for closest char
    //
    while (cchLo < cchHi - 1) 
    {
        cch = (cchHi + cchLo) / 2;
        pGetTextExtentPoint(hdc, lpText, cch, &size);

        if (size.cx <= width) 
        {
            cchLo = cch;
            lastLowWidth = size.cx;
        } 
        else 
        {
            cchHi = cch;
            lastHighWidth = size.cx;
        }
    }

    //
    // When the while ends, you can't know the exact position.
    // Try to see if the mouse pointer was on the farest half
    // of the char we got and if so, adjust cch.
    //
    if (cchLo == cch) 
    {
        //
        // Need to compare with lastHighWidth
        //
        if ((lastHighWidth - width) < (width - size.cx)) 
        {
            cch++;
        }
    } 
    else 
    {
        //
        // Need to compare with lastLowWidth
        //
        if ((width - lastLowWidth) < (size.cx - width)) 
        {
            cch--;
        }
    }

edAdjust:
    //
    // Avoid to point the intermediate of double byte character
    //
    cch = Edit_AdjustIch(ped, pText, cch + ped->ichScreenStart);
    Edit_Unlock(ped);
    return cch;
}


//---------------------------------------------------------------------------//
VOID EditSL_MouseMotion(PED ped, UINT message, UINT virtKeyDown, LPPOINT mousePt)
{
    DWORD   selectionl;
    DWORD   selectionh;
    BOOL    changeSelection;
    ICH     newMaxSel;
    ICH     newMinSel;
    HDC     hdc;
    ICH     mouseIch;
    LPSTR   pText;

    changeSelection = FALSE;

    newMinSel = ped->ichMinSel;
    newMaxSel = ped->ichMaxSel;

    hdc = Edit_GetDC(ped, FALSE);
    mouseIch = EditSL_MouseToIch(ped, hdc, mousePt);

    switch (message) 
    {
        case WM_LBUTTONDBLCLK:

            //
            // if shift key is down, extend selection to word we double clicked on
            // else clear current selection and select word.
            //
            // in DBCS, we have different word breaking. LiZ -- 5/5/93
            // In Hangeul Environment we use word selection feature because Hangeul
            // use SPACE as word break
            //
            if (ped->fAnsi && ped->fDBCS) 
            {
                pText = Edit_Lock(ped) + mouseIch;
                Edit_Word(ped, mouseIch,
                       (Edit_IsDBCSLeadByte(ped,*pText) && mouseIch < ped->cch) ? FALSE : TRUE,
                       &selectionl, &selectionh);
                Edit_Unlock(ped);
            } 
            else 
            {
                Edit_Word(ped, mouseIch, (mouseIch) ? TRUE : FALSE, &selectionl, &selectionh);
            }

            if (!(virtKeyDown & MK_SHIFT)) 
            {
                //
                // If shift key isn't down, move caret to mouse point and clear
                // old selection
                //
                newMinSel = selectionl;
                newMaxSel = ped->ichCaret = selectionh;
            } 
            else 
            {
                //
                // Shiftkey is down so we want to maintain the current selection
                // (if any) and just extend or reduce it
                //
                if (ped->ichMinSel == ped->ichCaret) 
                {
                    newMinSel = ped->ichCaret = selectionl;
                    Edit_Word(ped, newMaxSel, TRUE, &selectionl, &selectionh);
                } 
                else 
                {
                    newMaxSel = ped->ichCaret = selectionh;
                    Edit_Word(ped, newMinSel, FALSE, &selectionl, &selectionh);
                }

                ped->ichMaxSel = ped->ichCaret;
            }

            ped->ichStartMinSel = selectionl;
            ped->ichStartMaxSel = selectionh;

            goto InitDragSelect;

        case WM_MOUSEMOVE:
            //
            // We know the mouse button's down -- otherwise the OPTIMIZE
            // test would've failed in EditSL_WndProc and never called
            //
            changeSelection = TRUE;

            //
            // Extend selection, move caret word right
            //
            if (ped->ichStartMinSel || ped->ichStartMaxSel) 
            {
                //
                // We're in WORD SELECT mode
                //
                BOOL fReverse = (mouseIch <= ped->ichStartMinSel);

                Edit_Word(ped, mouseIch, !fReverse, &selectionl, &selectionh);

                if (fReverse) 
                {
                    newMinSel = ped->ichCaret = selectionl;
                    newMaxSel = ped->ichStartMaxSel;
                } 
                else 
                {
                    newMinSel = ped->ichStartMinSel;
                    newMaxSel = ped->ichCaret = selectionh;
                }
            } 
            else if ((ped->ichMinSel == ped->ichCaret) &&
                (ped->ichMinSel != ped->ichMaxSel))
            {
                //
                // Reduce selection extent
                //
                newMinSel = ped->ichCaret = mouseIch;
            }
            else
            {
                // Extend selection extent
                newMaxSel = ped->ichCaret=mouseIch;
            }

            break;

        case WM_LBUTTONDOWN:
            //
            // If we currently don't have the focus yet, try to get it.
            //
            if (!ped->fFocus) 
            {
                if (!ped->fNoHideSel)
                {
                    //
                    // Clear the selection before setting the focus so that we
                    // don't get refresh problems and flicker. Doesn't matter
                    // since the mouse down will end up changing it anyway.
                    //
                    ped->ichMinSel = ped->ichMaxSel = ped->ichCaret;
                }

                SetFocus(ped->hwnd);

                //
                // BOGUS
                // (1) We should see if SetFocus() succeeds.
                // (2) We should ignore mouse messages if the first window
                //      ancestor with a caption isn't "active."
                //
                // If we are part of a combo box, then this is the first time
                // the edit control is getting the focus so we just want to
                // highlight the selection and we don't really want to position
                // the caret.
                //
                if (ped->listboxHwnd)
                {
                    break;
                }

                //
                // We yield at SetFocus -- text might have changed at that point
                // update selection and caret info accordingly
                // FIX for bug # 11743 -- JEFFBOG 8/23/91
                //
                newMaxSel = ped->ichMaxSel;
                newMinSel = ped->ichMinSel;
                mouseIch  = min(mouseIch, ped->cch);
            }

            if (ped->fFocus) 
            {
                //
                // Only do this if we have the focus since a clever app may not
                // want to give us the focus at the SetFocus call above.
                //
                if (!(virtKeyDown & MK_SHIFT)) 
                {
                    //
                    // If shift key isn't down, move caret to mouse point and
                    // clear old selection
                    //
                    newMinSel = newMaxSel = ped->ichCaret = mouseIch;
                } 
                else 
                {
                    //
                    // Shiftkey is down so we want to maintain the current
                    // selection (if any) and just extend or reduce it
                    //
                    if (ped->ichMinSel == ped->ichCaret)
                    {
                        newMinSel = ped->ichCaret = mouseIch;
                    }
                    else
                    {
                        newMaxSel = ped->ichCaret = mouseIch;
                    }
                }

                ped->ichStartMinSel = ped->ichStartMaxSel = 0;

InitDragSelect:
                ped->fMouseDown = FALSE;
                SetCapture(ped->hwnd);
                ped->fMouseDown = TRUE;
                changeSelection = TRUE;
            }

            break;

        case WM_LBUTTONUP:
            if (ped->fMouseDown) 
            {
                ped->fMouseDown = FALSE;
                ReleaseCapture();
            }

            break;
    }

    if (changeSelection) 
    {
        EditSL_ScrollText(ped,hdc);
        EditSL_ChangeSelection(ped, hdc, newMinSel, newMaxSel);
    }

    Edit_ReleaseDC(ped, hdc, FALSE);
}


//---------------------------------------------------------------------------//
//
// EditSL_Paint AorW
//
// Handles painting of the edit control window. Draws the border if
// necessary and draws the text in its current state.
//
VOID EditSL_Paint(PED ped, HDC hdc)
{
    RECT   rcEdit;
    HWND   hwnd = ped->hwnd;
    HBRUSH hBrushRemote = NULL;
    BOOL   fNeedDelete = FALSE;
    HANDLE hOldFont;

    //
    // Had to put in hide/show carets. The first one needs to be done before
    // beginpaint to correctly paint the caret if part is in the update region
    // and part is out. The second is for 1.03 compatibility. It breaks
    // micrografix's worksheet edit control if not there.
    //
    HideCaret(hwnd);

    if (IsWindowVisible(hwnd)) 
    {
        CCDBUFFER db;

        //
        // Erase the background since we don't do it in the erasebkgnd message.
        //
        GetClientRect(hwnd, &rcEdit);


        hdc = CCBeginDoubleBuffer(hdc, &rcEdit, &db);
#ifdef _USE_DRAW_THEME_TEXT_
        if (!ped->hTheme)
#endif // _USE_DRAW_THEME_TEXT_
        {
            hBrushRemote = Edit_GetBrush(ped, hdc, &fNeedDelete);
            if (hBrushRemote)
            {
                FillRect(hdc, &rcEdit, hBrushRemote);

                if (fNeedDelete)
                {
                    DeleteObject(hBrushRemote);
                }
            }

            if (ped->fFlatBorder)
            {
                DrawFrame(hdc, &rcEdit, 1, DF_WINDOWFRAME);
            }

        }
#ifdef _USE_DRAW_THEME_TEXT_
        else
        {
            HRESULT hr;
            INT     iStateId = Edit_GetStateId(ped);

            hr = DrawThemeBackground(ped->hTheme, hdc, EP_EDITTEXT, iStateId, &rcEdit, 0);
        }
#endif // _USE_DRAW_THEME_TEXT_

        if (ped->hFont != NULL) 
        {
            //
            // We have to select in the font since this may be a subclassed dc
            // or a begin paint dc which hasn't been initialized with out fonts
            // like Edit_GetDC does.
            //
            hOldFont = SelectObject(hdc, ped->hFont);
        }
        EditSL_DrawText(ped, hdc, 0);

        if (ped->hFont != NULL && hOldFont != NULL) 
        {
            SelectObject(hdc, hOldFont);
        }

        CCEndDoubleBuffer(&db);
    }

    ShowCaret(hwnd);
}


//---------------------------------------------------------------------------//
//
// EditSL_SetFocus AorW
//
// Gives the edit control the focus and notifies the parent
// EN_SETFOCUS.
//
VOID EditSL_SetFocus(PED ped)
{
    if (!ped->fFocus) 
    {
        HDC  hdc;
        UINT cxCaret;

        ped->fFocus = TRUE;
        InvalidateRect(ped->hwnd, NULL, TRUE);

        //
        // We don't want to muck with the caret since it isn't created.
        //
        hdc = Edit_GetDC(ped, TRUE);

        //
        // Show the current selection if necessary.
        //
        if (!ped->fNoHideSel)
        {
            EditSL_DrawText(ped, hdc, 0);
        }

        //
        // Create the caret
        //
        SystemParametersInfo(SPI_GETCARETWIDTH, 0, (LPVOID)&cxCaret, 0);
        if (ped->pLpkEditCallout) 
        {
            ped->pLpkEditCallout->EditCreateCaret ((PED0)ped, hdc, cxCaret,
                                                   ped->lineHeight, 0);
        }
        else 
        {
            CreateCaret(ped->hwnd, (HBITMAP)NULL, cxCaret, ped->lineHeight);
        }
        EditSL_SetCaretPosition(ped, hdc);
        Edit_ReleaseDC(ped, hdc, TRUE);
        ShowCaret(ped->hwnd);

        //
        // check the capslock key
        //
        if (GET_STYLE(ped) & ES_PASSWORD)
        {
            EditSL_CheckCapsLock(ped);
        }

    }

    //
    // Notify parent we have the focus
    //
    Edit_NotifyParent(ped, EN_SETFOCUS);
}


//---------------------------------------------------------------------------//
//
// EditSL_KillFocus
//
// The edit control loses the focus and notifies the parent via EN_KILLFOCUS.
//
void EditSL_KillFocus(PED ped, HWND newFocusHwnd)
{
    HWND hwnd = ped->hwnd;

    if (ped->fFocus) 
    {
        DestroyCaret();
        ped->fFocus = FALSE;

        //
        // Do this only if we still have the focus. But we always notify the
        // parent that we lost the focus whether or not we originally had the
        // focus.
        //
        // Hide the current selection if needed
        //
#ifdef _USE_DRAW_THEME_TEXT_
        if ((!ped->fNoHideSel && (ped->ichMinSel != ped->ichMaxSel)) || ped->hTheme) 
#else
        if ((!ped->fNoHideSel && (ped->ichMinSel != ped->ichMaxSel))) 
#endif // _USE_DRAW_THEME_TEXT_
        {
            InvalidateRect(hwnd, NULL, FALSE);
        }

    }

    //
    // If we aren't a combo box, notify parent that we lost the focus.
    //
    if (!ped->listboxHwnd)
    {
        Edit_NotifyParent(ped, EN_KILLFOCUS);
    }
    else 
    {
        //
        // This editcontrol is part of a combo box and is losing the focus. If
        // the focus is NOT being sent to another control in the combo box
        // window, then it means the combo box is losing the focus. So we will
        // notify the combo box of this fact.
        //
        if ((newFocusHwnd == NULL) || (!IsChild(ped->hwndParent, newFocusHwnd))) 
        {
            //
            // Excel has a slaker in it's midst.  They're not using our combo
            // boxes, but they still expect to get all the internal messages
            // that we give to OUR comboboxes.  And they expect them to be at
            // the same offset from WM_USER as they were in 3.1.
            //                                           (JEFFBOG - 01/26/94)

            //
            // Focus is being sent to a window which is not a child of the combo
            // box window which implies that the combo box is losing the focus.
            // Send a message to the combo box informing him of this fact so
            // that he can clean up...
            //
            SendMessage(ped->hwndParent, CBEC_KILLCOMBOFOCUS, 0, 0L);
        }
    }

    //
    // If we're still valid, invalidate to cause a redraw. It's common
    // for some controls be destroyed after losing focus.
    //
    if ( IsWindow(hwnd) )
    {
        InvalidateRect(hwnd, NULL, FALSE);
    }
}


//---------------------------------------------------------------------------//
//
// EditSL_Paste()
//
// Does actual text paste and update.
//
VOID EditSL_Paste(PED ped)
{
    HDC hdc;

    //
    // Insert contents of clipboard, after unhilighting current selection
    // and deleting it.
    //
    Edit_DeleteText(ped);
    EditSL_PasteText(ped);

    //
    // Update display
    //
    Edit_NotifyParent(ped, EN_UPDATE);

    hdc = Edit_GetDC(ped,FALSE);

    EditSL_ScrollText(ped, hdc);
    EditSL_DrawText(ped, hdc, 0);

    Edit_ReleaseDC(ped,hdc,FALSE);

    //
    // Tell parent our text contents changed.
    //
    Edit_NotifyParent(ped, EN_CHANGE);
    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
}


//---------------------------------------------------------------------------//
//
// EditSL_Create
//
// Creates the edit control for the window hwnd by allocating memory
// as required from the application's heap. Notifies parent if no memory
// error (after cleaning up if needed). Returns TRUE if no error else return s
// -1.
//
LONG EditSL_Create(PED ped, LPCREATESTRUCT lpCreateStruct)
{
    LPSTR lpWindowText;
    LONG windowStyle = GET_STYLE(ped);

    //
    // Do the standard creation stuff
    //
    if (!Edit_Create(ped, windowStyle))
    {
        return -1;
    }

    //
    // Single lines always have no undo and 1 line
    //
    ped->cLines = 1;
    ped->undoType = UNDO_NONE;

    //
    // Check if this edit control is part of a combobox and get a pointer to the
    // combobox structure.
    //
    if (windowStyle & ES_COMBOBOX)
    {
        ped->listboxHwnd = GetDlgItem(lpCreateStruct->hwndParent, CBLISTBOXID);
    }

    //
    // Set the default font to be the system font.
    //
    if ( !Edit_SetFont(ped, NULL, FALSE) )
    {

        // If setting the font fails, our textmetrics can potentially be left 
        // unitialize. Fail to create the control.
        return -1;
    }


    //
    // Set the window text if needed. Return false if we can't set the text
    // SLSetText notifies the parent in case there is a no memory error.
    //
#if 0
    if ((ULONG_PTR)lpCreateStruct->lpszName > gHighestUserAddress)
    {
        lpWindowText = REBASEPTR(ped->pwnd, (PVOID)lpCreateStruct->lpszName);
    }
    else
#endif
    {
        lpWindowText = (LPSTR)lpCreateStruct->lpszName;
    }

    if ((lpWindowText != NULL)
            && !IsEmptyString(lpWindowText, ped->fAnsi)
            && !Edit_SetEditText(ped, lpWindowText)) 
    {
        return -1;
    }

    if (windowStyle & ES_PASSWORD)
    {
        LOGFONT lfFont = {0};
        
        LoadString(HINST_THISDLL, IDS_PASSWORDCHARFONT, lfFont.lfFaceName, ARRAYSIZE(lfFont.lfFaceName));
        lfFont.lfWeight   = FW_NORMAL;
        lfFont.lfCharSet  = DEFAULT_CHARSET;

        ped->hFontPassword = CreateFontIndirect(&lfFont);   
        if (ped->hFontPassword && Edit_SetFont(ped, ped->hFontPassword, FALSE))
        {
            WCHAR szChar[10];
            UINT  uChar;

            LoadString(HINST_THISDLL, IDS_PASSWORDCHAR, szChar, ARRAYSIZE(szChar));
            uChar = StrToInt(szChar);
            Edit_SetPasswordCharHandler(ped, uChar);
        }
        else
        {
            Edit_SetPasswordCharHandler(ped, (UINT)'*');
        }
    }

    //
    // Since memory cleared to 0 when allocated, this should still be NULL
    //
    ASSERT(ped->pszCueBannerText == NULL);

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// EditSL_Undo AorW
//
// Handles UNDO for single line edit controls.
//
BOOL EditSL_Undo(PED ped)
{
    PBYTE hDeletedText = ped->hDeletedText;
    BOOL fDelete = (BOOL)(ped->undoType & UNDO_DELETE);
    ICH cchDeleted = ped->cchDeleted;
    ICH ichDeleted = ped->ichDeleted;
    BOOL fUpdate = FALSE;

    if (ped->undoType == UNDO_NONE) 
    {
        //
        // No undo...
        //
        return FALSE;
    }

    ped->hDeletedText = NULL;
    ped->cchDeleted = 0;
    ped->ichDeleted = (ICH)-1;
    ped->undoType &= ~UNDO_DELETE;

    if (ped->undoType == UNDO_INSERT) 
    {
        ped->undoType = UNDO_NONE;

        //
        // Set the selection to the inserted text
        //
        EditSL_SetSelection(ped, ped->ichInsStart, ped->ichInsEnd);
        ped->ichInsStart = ped->ichInsEnd = (ICH)-1;

        //
        // Delete the selected text and save it in undo buff.
        // Call Edit_DeleteText() instead of sending a VK_BACK message
        // which results in an EN_UPDATE notification send even before
        // we insert the deleted chars. This results in Bug #6610.
        // Fix for Bug #6610 -- SANKAR -- 04/19/91 --
        //
        if (Edit_DeleteText(ped)) 
        {
            //
            // Text was deleted -- flag for update and clear selection
            //
            fUpdate = TRUE;
            EditSL_SetSelection(ped, ichDeleted, ichDeleted);
        }
    }

    if (fDelete) 
    {
        HWND hwndSave = ped->hwnd; // Used for validation.

        //
        // Insert deleted chars. Set the selection to the inserted text.
        //
        EditSL_SetSelection(ped, ichDeleted, ichDeleted);
        EditSL_InsertText(ped, hDeletedText, cchDeleted);
        GlobalFree(hDeletedText);

        if (!IsWindow(hwndSave))
        {
            return FALSE;
        }

        EditSL_SetSelection(ped, ichDeleted, ichDeleted + cchDeleted);
        fUpdate = TRUE;
    }

    if (fUpdate) 
    {
        //
        // If we have something to update, send EN_UPDATE before and
        // EN_CHANGE after the actual update.
        // A part of the fix for Bug #6610 -- SANKAR -- 04/19/91 --
        //
        Edit_NotifyParent(ped, EN_UPDATE);

        if (IsWindowVisible(ped->hwnd)) 
        {
            Edit_InvalidateClient(ped, FALSE);
        }

        Edit_NotifyParent(ped, EN_CHANGE);

        NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ped->hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
    }

    return TRUE;
}



//---------------------------------------------------------------------------//
//
// EditSL_SetCueBanner (Unicode Only)
//
// Handles setting the cue banner text for an edit control.
//
BOOL EditSL_SetCueBanner(PED ped, LPCWSTR pszBanner)
{
    BOOL retVal = FALSE;

    if (pszBanner != NULL)
    {
        //
        // Store the input string into the ped's pointer.  Str_SetPtr will
        // allocate/free memory as needed.
        //
        retVal = Str_SetPtr(&(ped->pszCueBannerText), pszBanner);

        //
        // Redraw the control
        //
        InvalidateRect(ped->hwnd, NULL, FALSE);
    }

    return retVal;
}


//---------------------------------------------------------------------------//
//
// EditSL_WndProc
// 
// Class procedure for all single line edit controls.
// Dispatches all messages to the appropriate handlers which are named
// as follows:
// EditSL_ (single line) prefixes all single line edit control procedures while
// Edit_   (edit control) prefixes all common handlers.
//
// The EditSL_WndProc only handles messages specific to single line edit
// controls.
//
LRESULT EditSL_WndProc(PED ped, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    POINT       pt;

    switch (message) 
    {
    case WM_INPUTLANGCHANGE:
        if (ped && ped->fFocus && ped->pLpkEditCallout) 
        {
            UINT cxCaret;

            SystemParametersInfo(SPI_GETCARETWIDTH, 0, (LPVOID)&cxCaret, 0);
            HideCaret(ped->hwnd);
            hdc = Edit_GetDC(ped, TRUE);
            DestroyCaret();
            ped->pLpkEditCallout->EditCreateCaret ((PED0)ped, hdc, cxCaret, ped->lineHeight, (UINT)lParam);
            EditSL_SetCaretPosition(ped, hdc);
            Edit_ReleaseDC(ped, hdc, TRUE);
            ShowCaret(ped->hwnd);
        }
        goto PassToDefaultWindowProc;

    case WM_STYLECHANGED:
        if (ped && ped->pLpkEditCallout) 
        {
            switch (wParam) 
            {
            case GWL_STYLE:
                Edit_UpdateFormat(ped, ((LPSTYLESTRUCT)lParam)->styleNew, GET_EXSTYLE(ped));
                return 1L;

            case GWL_EXSTYLE:
                Edit_UpdateFormat(ped, GET_STYLE(ped), ((LPSTYLESTRUCT)lParam)->styleNew);
                return 1L;
            }
        }

        goto PassToDefaultWindowProc;

    case WM_CHAR:

        //
        // wParam - the value of the key
        // lParam - modifiers, repeat count etc (not used)
        //
        if (!ped->fEatNextChar)
        {
            EditSL_Char(ped, (UINT)wParam);
        }
        else
        {
            ped->fEatNextChar = FALSE;
        }
        break;

    case WM_ERASEBKGND:

        //
        // wParam - device context handle
        // lParam - not used
        // We do nothing on this message and we don't want DefWndProc to do
        // anything, so return 1
        //
        return 1;

    case WM_GETDLGCODE: 
    {
           LONG code = DLGC_WANTCHARS | DLGC_HASSETSEL | DLGC_WANTARROWS;

            //
            // If this is a WM_SYSCHAR message generated by the UNDO keystroke
            // we want this message so we can EAT IT in "case WM_SYSCHAR:"
            //
            if (lParam) 
            {
                switch (((LPMSG)lParam)->message) 
                {
                case WM_SYSCHAR:
                    if ((HIWORD(((LPMSG)lParam)->lParam) & SYS_ALTERNATE) &&
                        ((WORD)wParam == VK_BACK)) 
                    {
                        code |= DLGC_WANTMESSAGE;
                    }
                    break;

                case WM_KEYDOWN:
                    if (( (((WORD)wParam == VK_RETURN) ||
                           ((WORD)wParam == VK_ESCAPE)) &&
                        (ped->listboxHwnd)      &&
                        (GetWindowStyle(ped->hwndParent) & CBS_DROPDOWN) &&
                        SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0L))) 
                    {
                        code |= DLGC_WANTMESSAGE;
                    }
                    break;
                }
            }

            return code;
        }

        break;

    case WM_KEYDOWN:

        //
        // wParam - virt keycode of the given key
        // lParam - modifiers such as repeat count etc. (not used)
        //
        EditSL_KeyDown(ped, (UINT)wParam, 0);

        break;

    case WM_KILLFOCUS:

        //
        // wParam - handle of the window that receives the input focus
        // lParam - not used
        //
        EditSL_KillFocus(ped, (HWND)wParam);

        break;

    case WM_CAPTURECHANGED:
        if (ped->fMouseDown)
        {
            ped->fMouseDown = FALSE;
        }

        break;

    case WM_MOUSEMOVE:
        UserAssert(ped->fMouseDown);
        //
        // FALL THRU
        //
        
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
        //
        // wParam - contains a value that indicates which virtual keys are down
        // lParam - contains x and y coords of the mouse cursor
        //
        POINTSTOPOINT(pt, lParam);
        EditSL_MouseMotion(ped, message, (UINT)wParam, &pt);

        break;

    case WM_CREATE:

        //
        // wParam - handle to window being created
        // lParam - points to a CREATESTRUCT that contains copies of parameters
        //          passed to the CreateWindow function.
        //
        return EditSL_Create(ped, (LPCREATESTRUCT)lParam);

        break;

    case WM_PRINTCLIENT:
        //
        // wParam --    can be hdc from subclassed paint
        // lParam --    unused
        //
        EditSL_Paint(ped, (HDC) wParam);

        break;

    case WM_PAINT:

        //
        // wParam --    can be hdc from subclassed paint
        // lParam --    unused
        //
        if (wParam)
        {
            hdc = (HDC) wParam;
        }
        else 
        {
            //
            // this hide/show caret is outside Begin/EndPaint to handle the
            // case when the caret is half in/half out of the update region
            //
            HideCaret(ped->hwnd);
            hdc = BeginPaint(ped->hwnd, &ps);
        }

        //
        // PORTPORT: Note the symantics of IsWindowVisible and _IsWindowVisible are
        //           slightly different.
        //
        if (IsWindowVisible(ped->hwnd))
        {
            EditSL_Paint(ped, hdc);
        }

        if (!wParam) 
        {
            EndPaint(ped->hwnd, &ps);
            ShowCaret(ped->hwnd);
        }

        break;

    case WM_PASTE:

        //
        //  wParam - not used
        // lParam - not used
        //
        if (!ped->fReadOnly)
        {
            EditSL_Paste(ped);
        }

        break;

    case WM_SETFOCUS:

        //
        // wParam - handle of window that loses the input focus (may be NULL)
        // lParam - not used
        //
        EditSL_SetFocus(ped);

        break;

    case WM_SIZE:

        // wParam - defines the type of resizing fullscreen, sizeiconic,
        //          sizenormal etc.
        // lParam - new width in LOWORD, new height in HIGHWORD of client area
        Edit_Size(ped, NULL, TRUE);

        return 0;

    case WM_SYSKEYDOWN:
        //
        // wParam --    virtual key code
        // lParam --    modifiers
        //

        //
        // Are we in a combobox with the Alt key down?
        //
        if (ped->listboxHwnd && (lParam & 0x20000000L)) 
        {
            //
            // Handle Combobox support. We want alt up or down arrow to behave
            // like F4 key which completes the combo box selection
            //
            if (lParam & 0x1000000) 
            {
                //
                // This is an extended key such as the arrow keys not on the
                // numeric keypad so just drop the combobox.
                //
                if (wParam == VK_DOWN || wParam == VK_UP)
                {
                    goto DropCombo;
                }
                else
                {
                    goto SkipDropCombo;
                }
            }

            if (!(GetKeyState(VK_NUMLOCK) & 1) &&
                    (wParam == VK_DOWN || wParam == VK_UP)) 
            {
                //
                // NUMLOCK is up and the keypad up or down arrow hit:
                // eat character generated by keyboard driver.
                //
                ped->fEatNextChar = TRUE;
            } 
            else 
            {
                goto SkipDropCombo;
            }

DropCombo:
            if (SendMessage(ped->hwndParent, CB_GETEXTENDEDUI, 0, 0) & 0x00000001) 
            {
                //
                // Extended ui doesn't honor VK_F4.
                //
                if (SendMessage(ped->hwndParent, CB_GETDROPPEDSTATE, 0, 0))
                {
                    return SendMessage(ped->hwndParent, CB_SHOWDROPDOWN, 0, 0);
                }
                else
                {
                    return SendMessage(ped->hwndParent, CB_SHOWDROPDOWN, 1, 0);
                }
            } 
            else
            {
                return SendMessage(ped->listboxHwnd, WM_KEYDOWN, VK_F4, 0);
            }
        }

SkipDropCombo:
        if (wParam == VK_BACK) 
        {
            SendMessage(ped->hwnd, WM_UNDO, 0, 0L);
            break;
        }
        else
        {
            goto PassToDefaultWindowProc;
        }

        break;

    case EM_GETLINE:

        //
        // wParam - line number to copy (always the first line for SL)
        // lParam - buffer to copy text to. FIrst word is max # of bytes to copy
        //
        return Edit_GetTextHandler(ped, (*(LPWORD)lParam), (LPSTR)lParam, FALSE);

    case EM_LINELENGTH:

        //
        // wParam - ignored
        // lParam - ignored
        //
        return (LONG)ped->cch;

    case EM_SETSEL:
        //
        // wParam -- start pos
        // lParam -- end pos
        //
        EditSL_SetSelection(ped, (ICH)wParam, (ICH)lParam);

        break;

    case EM_REPLACESEL:

        //
        // wParam - flag for 4.0+ apps saying whether to clear undo
        // lParam - points to a null terminated string of replacement text
        //
        EditSL_ReplaceSel(ped, (LPSTR)lParam);
        if (!ped->f40Compat || !wParam)
        {
            Edit_EmptyUndo(Pundo(ped));
        }

        break;

    case EM_GETFIRSTVISIBLELINE:

        //
        // wParam - not used
        // lParam - not used
        // 
        // effects: Returns the first visible line for single line edit controls.
        //
        return ped->ichScreenStart;

    case EM_POSFROMCHAR:
        //
        // wParam --    char index in text
        // lParam --    not used
        // This function returns the (x,y) position of the character.
        //      y is always 0 for single.
        //
    case EM_CHARFROMPOS:
        //
        // wParam --    unused
        // lParam --    pt in edit client coords
        // This function returns
        //          LOWORD: the position of the _closest_ char
        //                  to the passed in point.
        //          HIWORD: the index of the line (always 0 for single)

        {
            LONG xyPos;

            hdc = Edit_GetDC(ped, TRUE);

            if (message == EM_POSFROMCHAR)
            {
                xyPos = MAKELONG(EditSL_IchToLeftXPos(ped, hdc, (ICH)wParam), 0);
            }
            else 
            {
                POINTSTOPOINT(pt, lParam);
                xyPos = EditSL_MouseToIch(ped, hdc, &pt);
            }

            Edit_ReleaseDC(ped, hdc, TRUE);
            return (LRESULT)xyPos;
        }

    case WM_UNDO:
    case EM_UNDO:
        EditSL_Undo(ped);
        break;

    case EM_SETCUEBANNER:
        //
        // This message passes in a LPCWSTR as the lParam to set the
        // cue banner text.
        //

        // Call function to set the text:
        return (LRESULT)EditSL_SetCueBanner(ped, (LPCWSTR) lParam);
        break;


    default:
PassToDefaultWindowProc:
        return DefWindowProc(ped->hwnd, message, wParam, lParam);
        break;
    }

    return 1L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\header.c ===
#include "ctlspriv.h"
#include "image.h"

#define CCHLABELMAX MAX_PATH            // borrowed from listview.h
#define HDDF_NOIMAGE  0x0001
#define HDDF_NOEDGE  0x0002

#define HDI_ALL95 0x001f

#define TF_HEADER TF_LISTVIEW

#define HD_EDITCHANGETIMER 0x100

#define c_cxFilterBarEdge (1)
#define c_cyFilterBarEdge (1)

#define c_cxFilterImage   (13)
#define c_cyFilterImage   (12)

typedef struct 
{
    int     x;              // this is the x position of the RIGHT side (divider) of this item
    int     cxy;
    int     fmt;
    LPTSTR  pszText;
    HBITMAP hbm;
    int     iImage;         // index of bitmap in imagelist
    LPARAM  lParam;
    int     xBm;            // cached values 
    int     xText;          // for implementing text and bitmap in header
    int     cxTextAndBm;    
    
    // information used for the filter contol
    UINT    idOperator;
    UINT    type;
    HD_TEXTFILTER textFilter;
    int     intFilter;

} HDI;

typedef struct 
{
    CCONTROLINFO ci;
    
    UINT flags;
    int cxEllipses;
    int cxDividerSlop;
    int cyChar;
    HFONT hfont;
    HFONT hfontSortArrow;

    HIMAGELIST hFilterImage;
    HDSA hdsaHDI;       // list of HDI's
    
    // tracking state info
    int iTrack;
    BITBOOL bTrackPress :1;		// is the button pressed?
    BITBOOL fTrackSet:1;
    BITBOOL fOwnerDraw:1;
    BITBOOL fFocus:1;
    BITBOOL fFilterChangePending:1;
    UINT flagsTrack;
    int dxTrack;                    // the distance from the divider that the user started tracking
    int xTrack;                     // the current track position (or starting track position on a button drag)
    int xMinTrack;                  // the x of the end of the previous item (left limit)
    int xTrackOldWidth;
    HIMAGELIST himl;            // handle to our image list

    HDSA hdsaOrder;     // this is an index array of the hdsaHDI items.
                        // this is the physical order of items
                        
    int iHot ;
    HIMAGELIST himlDrag;
    int iNewOrder;      // what's the new insertion point for a d/d?

    int iTextMargin; // The margin to place on either side of text or bitmaps
    int iBmMargin;   // Normally, 3 * g_cxLabelMargin

    int iFocus;         // focus object
    int iEdit;          // editing object
    int iButtonDown;
    int iFilterChangeTimeout;
    HWND hwndEdit;
    WNDPROC pfnEditWndProc;
    int typeOld;
    LPTSTR pszFilterOld;
    int intFilterOld;

    HTHEME hTheme;
} HD;


LRESULT CALLBACK Header_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Message handler functions

BOOL Header_OnCreate(HD* phd, CREATESTRUCT* lpCreateStruct);
void Header_OnNCDestroy(HD* phd);

HIMAGELIST Header_OnSetImageList(HD* phd, HIMAGELIST himl);
HIMAGELIST Header_OnGetImageList(HD* phd);

void Header_OnPaint(HD* phd, HDC hdcIn);
void Header_OnCommand(HD* phd, int id, HWND hwndCtl, UINT codeNotify);
void Header_OnEnable(HD* phd, BOOL fEnable);
UINT Header_OnGetDlgCode(HD* phd, MSG* lpmsg);
void Header_OnLButtonDown(HD* phd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
BOOL Header_IsTracking(HD* phd);
void Header_OnMouseMove(HD* phd, int x, int y, UINT keyFlags);
void Header_OnLButtonUp(HD* phd, int x, int y, UINT keyFlags);
void Header_OnSetFont(HD* plv, HFONT hfont, BOOL fRedraw);
int Header_OnHitTest(HD* phd, HD_HITTESTINFO *phdht);
HFONT Header_OnGetFont(HD* plv);
HIMAGELIST Header_OnCreateDragImage(HD* phd, int i);
BOOL Header_OnGetItemRect(HD* phd, int i, RECT* prc);
void Header_Draw(HD* phd, HDC hdc, RECT* prcClip);
void Header_InvalidateItem(HD* phd, int i, UINT uFlags );
void Header_GetDividerRect(HD* phd, int i, LPRECT prc);
LPARAM Header_OnSetHotDivider(HD* phd, BOOL fPos, LPARAM lParam);
void Header_GetFilterRects(LPRECT prcItem, LPRECT prcHeader, LPRECT prcEdit, LPRECT prcButton);
BOOL Header_BeginFilterEdit(HD* phd, int i);
VOID Header_StopFilterEdit(HD* phd, BOOL fDiscardChanges);
VOID Header_FilterChanged(HD* phd, BOOL fWait);
VOID Header_OnFilterButton(HD* phd, INT i);
LRESULT Header_OnClearFilter(HD* phd, INT i);

// HDM_* Message handler functions

int Header_OnInsertItem(HD* phd, int i, const HD_ITEM* pitem);
BOOL Header_OnDeleteItem(HD* phd, int i);
BOOL Header_OnGetItem(HD* phd, int i, HD_ITEM* pitem);
BOOL Header_OnSetItem(HD* phd, int i, const HD_ITEM* pitem);
BOOL Header_OnLayout(HD* phd, HD_LAYOUT* playout);
BOOL Header_OnSetCursor(HD* phd, HWND hwndCursor, UINT codeHitTest, UINT msg);
void Header_DrawDivider(HD* phd, int x);
int Header_OnInsertItemA(HD* phd, int i, HD_ITEMA* pitem);
BOOL Header_OnGetItemA(HD* phd, int i, HD_ITEMA* pitem);
BOOL Header_OnSetItemA(HD* phd, int i, HD_ITEMA* pitem);

void Header_EndDrag(HD* phd);
BOOL Header_SendChange(HD* phd, int i, int code, const HD_ITEM* pitem);
BOOL Header_Notify(HD* phd, int i, int iButton, int code);

#define Header_GetItemPtr(phd, i)   (HDI*)DSA_GetItemPtr((phd)->hdsaHDI, (i))
#define Header_GetCount(phd) (DSA_GetItemCount((phd)->hdsaHDI))
#define Header_IsFilter(phd) ((phd)->ci.style & HDS_FILTERBAR)

#pragma code_seg(CODESEG_INIT)

BOOL Header_Init(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = Header_WndProc;
    wc.hCursor         = NULL;	// we do WM_SETCURSOR handling
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = c_szHeaderClass;
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    wc.style           = CS_DBLCLKS | CS_GLOBALCLASS;
    wc.cbWndExtra      = sizeof(HD*);
    wc.cbClsExtra      = 0;

    if (!RegisterClass(&wc) && !GetClassInfo(hinst, c_szHeaderClass, &wc))
        return FALSE;

    return TRUE;
}
#pragma code_seg()

// returns -1 if failed to find the item
int Header_OnGetItemOrder(HD* phd, int i)
{
    int iIndex;

    // if there's no hdsaOrder, then it's in index order
    if (phd->hdsaOrder) {
        int j;
        int iData;
        
        iIndex = -1;
        
        for (j = 0; j < DSA_GetItemCount(phd->hdsaOrder); j++) {
            DSA_GetItem(phd->hdsaOrder, j, &iData);
            if (iData == i) {
                iIndex = j;
                break;
            }
        }
        
    } else {
        iIndex = i;
    }
    
    return iIndex;
}


int Header_ItemOrderToIndex(HD* phd, int iOrder)
{
    RIPMSG(iOrder < DSA_GetItemCount(phd->hdsaHDI), "HDM_ORDERTOINDEX: Invalid order %d", iOrder);
    if (phd->hdsaOrder) {
        ASSERT(DSA_GetItemCount(phd->hdsaHDI) == DSA_GetItemCount(phd->hdsaOrder));
#ifdef DEBUG
        // DSA_GetItem will assert on an invalid index, so filter it out
        // so all we get is the RIP above.
        if (iOrder < DSA_GetItemCount(phd->hdsaOrder))
#endif
        DSA_GetItem(phd->hdsaOrder, iOrder, &iOrder);
    }
    
    return iOrder;
}

HDI* Header_GetItemPtrByOrder(HD* phd, int iOrder)
{
    int iIndex = Header_ItemOrderToIndex(phd, iOrder);
    return Header_GetItemPtr(phd, iIndex);
}

HDSA Header_InitOrderArray(HD* phd) 
{
    int i;
    
    if (!phd->hdsaOrder && !(phd->ci.style & HDS_OWNERDATA)) {

        // not initialized yet..
        // create an array with i to i mapping
        phd->hdsaOrder = DSA_Create(sizeof(int), 4);

        if (phd->hdsaOrder) {
            for (i = 0; i < Header_GetCount(phd); i++) {
                if (DSA_InsertItem(phd->hdsaOrder, i, &i) == -1) {
                    // faild to add... bail
                    DSA_Destroy(phd->hdsaOrder);
                    phd->hdsaOrder = NULL;
                }
            }
        }
    }
    return phd->hdsaOrder;
}

// this moves all items starting from iIndex over by dx
void Header_ShiftItems(HD* phd, int iOrder, int dx)
{
    for(; iOrder < Header_GetCount(phd); iOrder++) {
        HDI* phdi = Header_GetItemPtrByOrder(phd, iOrder);
        phdi->x += dx;
    }
}

void Header_OnSetItemOrder(HD* phd, int iIndex, int iOrder)
{
    if (iIndex < Header_GetCount(phd) &&
        iOrder < Header_GetCount(phd) &&
        Header_InitOrderArray(phd)) {
        int iCurOrder = Header_OnGetItemOrder(phd, iIndex);
        
        // only do work if the order is changing
        if (iOrder != iCurOrder) {
        
            // delete the current order location
            HDI* phdi = Header_GetItemPtr(phd, iIndex);
            HDI* phdiOld = Header_GetItemPtrByOrder(phd, iOrder);

            // stop editing the filter    
            Header_StopFilterEdit(phd, FALSE);

            // remove iIndex from the current order
            // (slide stuff to the right down by our width)
            Header_ShiftItems(phd, iCurOrder + 1, -phdi->cxy);
            DSA_DeleteItem(phd->hdsaOrder, iCurOrder);
            
            // insert it into the order and slide everything else over
            // (slide stuff to the right of the new position up by our width)
            DSA_InsertItem(phd->hdsaOrder, iOrder, &iIndex);
            // set our right edge to where their left edge was
            Header_ShiftItems(phd, iOrder + 1, phdi->cxy);

            if (iOrder == 0) {
                phdi->x = phdi->cxy;
            } else {
                phdiOld = Header_GetItemPtrByOrder(phd, iOrder - 1);
                phdi->x = phdiOld->x + phdi->cxy;
            }
            
            RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }
}

void Header_SetHotItem(HD* phd, int i)
{
    if (i != phd->iHot) {
        Header_InvalidateItem(phd, i, RDW_INVALIDATE);
        Header_InvalidateItem(phd, phd->iHot, RDW_INVALIDATE);
        phd->iHot = i;
    }
}

LRESULT Header_OnGetOrderArray(HD* phd, int iCount, LPINT lpi)
{
    int i;
    
    if (Header_GetCount(phd) != iCount)
        return FALSE;
    
    for (i = 0; i < Header_GetCount(phd) ; i++) {
        lpi[i] = Header_ItemOrderToIndex(phd, i);
    }
    return TRUE;
}

LRESULT Header_OnSetOrderArray(HD* phd, int iCount, LPINT lpi)
{
    int i;
    
    if (Header_GetCount(phd) != iCount)
        return FALSE;
    
    for (i = 0; i < Header_GetCount(phd); i++) {
        Header_OnSetItemOrder(phd, lpi[i], i);
    }

    NotifyWinEvent(EVENT_OBJECT_REORDER, phd->ci.hwnd, OBJID_CLIENT, 0);

    return TRUE;
}

BOOL HDDragFullWindows(HD* phd)
{
    return (g_fDragFullWindows && (phd->ci.style & HDS_FULLDRAG));
}

LRESULT CALLBACK Header_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HD* phd = (HD*)GetWindowPtr(hwnd, 0);
    
    if (phd == NULL)
    {
        if (uMsg == WM_NCCREATE)
        {
            phd = (HD*)NearAlloc(sizeof(HD));

            if (phd == NULL)
                return 0L;

            phd->ci.hwnd = hwnd;
            phd->ci.hwndParent = ((LPCREATESTRUCT)lParam)->hwndParent;
            SetWindowPtr(hwnd, 0, phd);

            // fall through to call DefWindowProc
        }

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    else
    {
        if (uMsg == WM_THEMECHANGED)
        {
            if (phd->hTheme)
                CloseThemeData(phd->hTheme);

            phd->hTheme = OpenThemeData(phd->ci.hwnd, L"Header");
            InvalidateRect(phd->ci.hwnd, NULL, TRUE);
            return 0;
        }
        
        if (uMsg == WM_NCDESTROY)
        {
            Header_OnNCDestroy(phd);
            NearFree(phd);
            SetWindowInt(hwnd, 0, 0);
    
            return 0;
        }

        // if we loose capture, or the r-button goes down, or the user hits esc, then we abort the drag/resize
        if (uMsg == WM_CAPTURECHANGED ||
            uMsg == WM_RBUTTONDOWN || (GetKeyState(VK_ESCAPE) & 0x8000)) {

            if (phd->himlDrag) {
                // if this is the end of a drag, 
                // notify the user.
                HDITEM item;
                
                item.mask = HDI_ORDER;
                item.iOrder = -1; // abort order changing
                Header_EndDrag(phd);
                
                Header_SendChange(phd, phd->iTrack, HDN_ENDDRAG, &item);
                
            } else if (phd->flagsTrack & (HHT_ONDIVIDER | HHT_ONDIVOPEN)) {
                HD_ITEM item;
                item.mask = HDI_WIDTH;
                item.cxy = phd->xTrackOldWidth;

                phd->flagsTrack = 0;
                KillTimer(phd->ci.hwnd, 1);
                CCReleaseCapture(&phd->ci);

                Header_SendChange(phd, phd->iTrack, HDN_ENDTRACK, &item);
                if (HDDragFullWindows(phd)) {

                    // incase they changed something
                    item.mask = HDI_WIDTH;
                    item.cxy = phd->xTrackOldWidth;
                    Header_OnSetItem(phd, phd->iTrack, &item);

                    RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);

                } else {
                    // Undraw the last divider we displayed
                    Header_DrawDivider(phd, phd->xTrack);
                }
            }
        }

        if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST) &&
            (phd->hTheme || phd->ci.style & HDS_HOTTRACK) && !phd->fTrackSet) {

            TRACKMOUSEEVENT tme;

            phd->fTrackSet = TRUE;

            tme.cbSize = sizeof(tme);
            tme.hwndTrack = phd->ci.hwnd;
            tme.dwFlags = TME_LEAVE;

            TrackMouseEvent(&tme);
        }

        // ROBUSTNESS: keep this switch within the if (phd) block
        //
        switch (uMsg)
        {
            HANDLE_MSG(phd, WM_CREATE, Header_OnCreate);
            HANDLE_MSG(phd, WM_SETCURSOR, Header_OnSetCursor);
            HANDLE_MSG(phd, WM_MOUSEMOVE, Header_OnMouseMove);
            HANDLE_MSG(phd, WM_LBUTTONDOWN, Header_OnLButtonDown);
            HANDLE_MSG(phd, WM_LBUTTONDBLCLK, Header_OnLButtonDown);
            HANDLE_MSG(phd, WM_LBUTTONUP, Header_OnLButtonUp);
            HANDLE_MSG(phd, WM_GETDLGCODE, Header_OnGetDlgCode);
            HANDLE_MSG(phd, WM_SETFONT, Header_OnSetFont);
            HANDLE_MSG(phd, WM_GETFONT, Header_OnGetFont);
        
        case WM_COMMAND:
            if ( (phd->iEdit>=0) && ((HWND)lParam == phd->hwndEdit) )
            {
                // when filtering we will receive notifications that the filter
                // has been edited, therefore lets send those down to the
                // parent.

                if ( HIWORD(wParam)==EN_CHANGE )
                {
                    Header_FilterChanged(phd, TRUE);
                    return(0);
                }
            }
            break;

        case WM_TIMER:
            if (wParam == HD_EDITCHANGETIMER)
            {
                Header_FilterChanged(phd, FALSE);
                return(0);
            }
            break;

        case WM_SETFOCUS:
        case WM_KILLFOCUS:
            // filter bar and not editing then take caret into edit first column
            if (Header_IsFilter(phd)) 
            {
                phd->fFocus = (uMsg==WM_SETFOCUS);
                Header_InvalidateItem(phd, Header_ItemOrderToIndex(phd, phd->iFocus), RDW_INVALIDATE);
                UpdateWindow(phd->ci.hwnd);
                return(0);
            }
            break;

        case WM_KEYDOWN:
            if ( phd->fFocus )
            {
                // handle the key events that the header control receives, when the filter
                // bar is displayed we then allow the user to enter filter mode and drop the
                // filter menu.
                //
                //  F2 = enter filter mode
                //  F4 = drop filter menu
                //  -> = next column
                //  <- = previous column

                if ( wParam == VK_F2 )
                {
                    // start editing the currently focused column
                    Header_BeginFilterEdit(phd, Header_ItemOrderToIndex(phd, phd->iFocus));
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(phd->ci), UISF_HIDEFOCUS);
                    return 0L;
                }                                                                   
                else if ( wParam == VK_F4 )
                {
                    // drop the filter menu (this exits edit mode)
                    Header_OnFilterButton(phd, Header_ItemOrderToIndex(phd, phd->iFocus));
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(phd->ci), UISF_HIDEFOCUS);
                    return 0L;
                }
                else if ( (wParam == VK_LEFT)||(wParam == VK_RIGHT) )
                {
                    INT iFocus = phd->iFocus;

                    // move to previous or next column
                    if ( wParam == VK_RIGHT )
                    {
                        phd->iFocus = (iFocus+1) % Header_GetCount(phd);
                    }
                    else
                    {
                        phd->iFocus = iFocus-1;
                        if ( phd->iFocus < 0 )
                            phd->iFocus = max(Header_GetCount(phd)-1, 0);
                    }

                    // did the focused column change? if so then update the control
                    // as required.
                    if ( iFocus != phd->iFocus )
                    {                
                        Header_InvalidateItem(phd, Header_ItemOrderToIndex(phd, iFocus), RDW_INVALIDATE);
                        Header_InvalidateItem(phd, Header_ItemOrderToIndex(phd, phd->iFocus), RDW_INVALIDATE);
                        UpdateWindow(phd->ci.hwnd);
                    }
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(phd->ci), UISF_HIDEFOCUS);
                    return 0L;
                }
            }
            break;

        case WM_MOUSELEAVE:
            Header_SetHotItem(phd, -1);
            phd->fTrackSet = FALSE;
            break;

        case WM_ERASEBKGND:
            return 1;
        
        case WM_PRINTCLIENT:
        case WM_PAINT:
            Header_OnPaint(phd, (HDC)wParam);
            return(0);
        
        case WM_RBUTTONUP:
            if (CCSendNotify(&phd->ci, NM_RCLICK, NULL))
                return(0);
            break;
        
        case WM_STYLECHANGED:
            if (wParam == GWL_STYLE) {
                LPSTYLESTRUCT pss = (LPSTYLESTRUCT)lParam;
                
                phd->ci.style = pss->styleNew;

                // if the filter is changing then discard it if its active
                if ((pss->styleOld & HDS_FILTERBAR) != (pss->styleNew & HDS_FILTERBAR))
                    Header_StopFilterEdit(phd, TRUE);

                // we don't cache our style so relay out and invaidate
                InvalidateRect(phd->ci.hwnd, NULL, TRUE);
            }
            return(0);

        case WM_UPDATEUISTATE:
        {
            DWORD dwUIStateMask = MAKEWPARAM(0xFFFF, UISF_HIDEFOCUS);

            if (CCOnUIState(&(phd->ci), WM_UPDATEUISTATE, wParam & dwUIStateMask, lParam) &&
                phd->iFocus < DSA_GetItemCount(phd->hdsaHDI))
            {
                Header_InvalidateItem(phd, Header_ItemOrderToIndex(phd, phd->iFocus), RDW_INVALIDATE);
            }
            break;
        }
        
        case WM_NOTIFYFORMAT:
            return CIHandleNotifyFormat(&phd->ci, lParam);
        
        case HDM_GETITEMCOUNT:
            return (LPARAM)(UINT)DSA_GetItemCount(phd->hdsaHDI);
        
        case HDM_INSERTITEM:
            return (LPARAM)Header_OnInsertItem(phd, (int)wParam, (const HD_ITEM*)lParam);
        
        case HDM_DELETEITEM:
            return (LPARAM)Header_OnDeleteItem(phd, (int)wParam);
        
        case HDM_GETITEM:
            return (LPARAM)Header_OnGetItem(phd, (int)wParam, (HD_ITEM*)lParam);
        
        case HDM_SETITEM:
            return (LPARAM)Header_OnSetItem(phd, (int)wParam, (const HD_ITEM*)lParam);
        
        case HDM_LAYOUT:
            return (LPARAM)Header_OnLayout(phd, (HD_LAYOUT*)lParam);
            
        case HDM_HITTEST:
            return (LPARAM)Header_OnHitTest(phd, (HD_HITTESTINFO *)lParam);
            
        case HDM_GETITEMRECT:
            return (LPARAM)Header_OnGetItemRect(phd, (int)wParam, (LPRECT)lParam);
            
        case HDM_SETIMAGELIST:
            return (LRESULT)(ULONG_PTR)Header_OnSetImageList(phd, (HIMAGELIST)lParam);
            
        case HDM_GETIMAGELIST:
            return (LRESULT)(ULONG_PTR)phd->himl;
            
        case HDM_INSERTITEMA:
            return (LPARAM)Header_OnInsertItemA(phd, (int)wParam, (HD_ITEMA*)lParam);
        
        case HDM_GETITEMA:
            return (LPARAM)Header_OnGetItemA(phd, (int)wParam, (HD_ITEMA*)lParam);
        
        case HDM_SETITEMA:
            return (LPARAM)Header_OnSetItemA(phd, (int)wParam, (HD_ITEMA*)lParam);
            
        case HDM_ORDERTOINDEX:
            return Header_ItemOrderToIndex(phd, (int)wParam);
            
        case HDM_CREATEDRAGIMAGE:
            return (LRESULT)Header_OnCreateDragImage(phd, Header_OnGetItemOrder(phd, (int)wParam));
            
        case HDM_SETORDERARRAY:
            return Header_OnSetOrderArray(phd, (int)wParam, (LPINT)lParam);
            
        case HDM_GETORDERARRAY:
            return Header_OnGetOrderArray(phd, (int)wParam, (LPINT)lParam);
            
        case HDM_SETHOTDIVIDER:
            return Header_OnSetHotDivider(phd, (int)wParam, lParam);

        case HDM_SETBITMAPMARGIN:
            phd->iBmMargin = (int)wParam;
            TraceMsg(TF_HEADER, "Setting bmMargin = %d",wParam);
            return TRUE;

        case HDM_GETBITMAPMARGIN:
            return phd->iBmMargin;

        case HDM_EDITFILTER:
            Header_StopFilterEdit(phd, (BOOL)LOWORD(lParam));
            return Header_BeginFilterEdit(phd, (int)wParam);

        case HDM_SETFILTERCHANGETIMEOUT:
            if ( lParam ) {
                int iOldTimeout = phd->iFilterChangeTimeout;
                phd->iFilterChangeTimeout = (int)lParam;
                return(iOldTimeout);
            }
            return(phd->iFilterChangeTimeout);

        case HDM_CLEARFILTER:
            return Header_OnClearFilter(phd, (int)wParam);

        case WM_GETOBJECT:
            if( lParam == OBJID_QUERYCLASSNAMEIDX )
                return MSAA_CLASSNAMEIDX_HEADER;
            break;
            
        default:
        {
            LRESULT lres;
            if (CCWndProc(&phd->ci, uMsg, wParam, lParam, &lres))
                return lres;
        }
        }
        
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

}


BOOL Header_SendChange(HD* phd, int i, int code, const HD_ITEM* pitem)
{
    NMHEADER nm;

    nm.iItem = i;
    nm.pitem = (HD_ITEM*)pitem;
    nm.iButton = 0;
    
    return !(BOOL)CCSendNotify(&phd->ci, code, &nm.hdr);
}

BOOL Header_Notify(HD* phd, int i, int iButton, int code)
{
    NMHEADER nm;
    nm.iItem = i;
    nm.iButton = iButton;
    nm.pitem = NULL;

    return !(BOOL)CCSendNotify(&phd->ci, code, &nm.hdr);
}


void Header_NewFont(HD* phd, HFONT hfont)
{
    HDC hdc;
    SIZE siz = {0};
    HRESULT hr = E_FAIL;
    HFONT hFontOld = NULL;
    int cy;
    TEXTMETRIC tm;
    HFONT hfontSortArrow = NULL;

    hdc = GetDC(HWND_DESKTOP);

    if (phd->hTheme)
    {
        RECT rc = {0};
        RECT rcBound = {0};
        hr = GetThemeTextExtent(phd->hTheme, hdc, HP_HEADERITEM, 0, TEXT("M"), -1, 0, &rcBound, &rc);
        siz.cx = RECTWIDTH(rc);
        siz.cy = RECTHEIGHT(rc);
    }

    if (FAILED(hr))
    {
        if (hfont)
            SelectFont(hdc, hfont);

        GetTextExtentPoint(hdc, c_szEllipses, CCHELLIPSES, &siz);
    }

    if (phd->hfont)
        hFontOld = (HFONT)SelectObject(hdc, phd->hfont);

    GetTextMetrics(hdc, &tm);

    if (hFontOld)
        SelectObject(hdc, hFontOld);

    // Set the font height (based on original USER code)
    cy = ((tm.tmHeight + tm.tmExternalLeading + GetSystemMetrics(SM_CYBORDER)) & 0xFFFE) - 1;

    // Create the marlett font, so we can paint the arrows.
    hfontSortArrow = CreateFont(cy, 0, 0, 0, 0, FALSE, FALSE, FALSE, DEFAULT_CHARSET, 0, 0, 0, 0, 
        TEXT("Marlett"));

    phd->cxEllipses = siz.cx;
    phd->cyChar = siz.cy;
    phd->hfont = hfont;

    if (hfontSortArrow)
    {
        if (phd->hfontSortArrow)    // Do we have one to free?
        {
            DeleteObject(phd->hfontSortArrow);
        }

        phd->hfontSortArrow = hfontSortArrow;
    }
    phd->ci.uiCodePage = GetCodePageForFont(hfont);

    ReleaseDC(HWND_DESKTOP, hdc);
}

BOOL Header_OnCreate(HD* phd, CREATESTRUCT* lpCreateStruct)
{
    ASSERT(phd); // we are only called if phd is valid

    CIInitialize(&phd->ci, phd->ci.hwnd, (LPCREATESTRUCT)lpCreateStruct);

    phd->flags = 0;
    phd->hfont = NULL;
    phd->hFilterImage = NULL;

    phd->iNewOrder = -1;
    phd->iHot = -1;
    
    phd->iFocus = 0;
    phd->iEdit = -1;
    phd->iButtonDown = -1;
    phd->iFilterChangeTimeout = GetDoubleClickTime()*2;
    phd->hwndEdit = NULL;

    phd->hdsaHDI = DSA_Create(sizeof(HDI), 4);

    if (!phd->hdsaHDI)
        return FALSE;

    phd->cxDividerSlop = 8 * g_cxBorder;

    phd->hTheme = OpenThemeData(phd->ci.hwnd, L"Header");

    // Warning!  ListView_RSetColumnWidth knows these values.
    phd->iTextMargin = 3 * g_cxLabelMargin;
    phd->iBmMargin = 3 * g_cxLabelMargin;

    
    // phd->himl = NULL;   
    Header_NewFont(phd, NULL);
    return TRUE;
}

int Header_DestroyItemCallback(LPVOID p, LPVOID d)
{
    HDI * phdi = (HDI*)p;
    if (phdi)
    {
        Str_Set(&phdi->pszText, NULL);

        if ( (phdi->type & HDFT_ISMASK)==HDFT_ISSTRING )
            Str_Set(&phdi->textFilter.pszText, NULL);
    }
    return 1;
}

void Header_OnNCDestroy(HD* phd)
{
    // stop editing the filter    
    if ( phd->hFilterImage )
        ImageList_Destroy(phd->hFilterImage);

    Header_StopFilterEdit(phd, TRUE);

    // We must walk through and destroy all of the string pointers that
    // are contained in the structures before we pass it off to the
    // DSA_Destroy function...

    DSA_DestroyCallback(phd->hdsaHDI, Header_DestroyItemCallback, 0);
    phd->hdsaHDI = NULL;
    if (phd->hdsaOrder)
    {
        DSA_Destroy(phd->hdsaOrder);
        phd->hdsaOrder = NULL;
    }

    if (phd->hTheme)
        CloseThemeData(phd->hTheme);

    if (phd->hfontSortArrow)
        DeleteObject(phd->hfontSortArrow);
}

HIMAGELIST Header_OnSetImageList(HD* phd, HIMAGELIST himl)
{
    HIMAGELIST hImageOld = phd->himl;
    phd->himl = himl;
    return hImageOld;
}
    
void Header_OnPaint(HD* phd, HDC hdc)
{
    PAINTSTRUCT ps;
    HDC hdcUse;
    CCDBUFFER cdd;

    if (!phd)
        return;

    if (hdc)
    {
        hdcUse = hdc;
        GetClientRect(phd->ci.hwnd, &ps.rcPaint);
    }
    else
    {
        hdcUse = BeginPaint(phd->ci.hwnd, &ps);
    }

    hdcUse = CCBeginDoubleBuffer(hdcUse, &ps.rcPaint, &cdd);

    Header_Draw(phd, hdcUse, &ps.rcPaint);

    CCEndDoubleBuffer(&cdd);

    if (!hdc) 
    {
        EndPaint(phd->ci.hwnd, &ps);
    }
}

UINT Header_OnGetDlgCode(HD* phd, MSG* lpmsg)
{    
    return DLGC_WANTTAB | DLGC_WANTARROWS;
}


int Header_HitTest(HD* phd, int x, int y, UINT* pflags)
{
    UINT flags = 0;
    POINT pt;
    RECT rc;
    HDI* phdi;
    int i;

    pt.x = x; pt.y = y;

    GetClientRect(phd->ci.hwnd, &rc);

    flags = 0;
    i = -1;
    if (x < rc.left)
        flags |= HHT_TOLEFT;
    else if (x >= rc.right)
        flags |= HHT_TORIGHT;
    if (y < rc.top)
        flags |= HHT_ABOVE;
    else if (y >= rc.bottom)
        flags |= HHT_BELOW;

    if (flags == 0)
    {
        int cItems = DSA_GetItemCount(phd->hdsaHDI);
        int xPrev = 0;
        BOOL fPrevZero = FALSE;
        int xItem;
        int cxSlop;

        //DebugMsg(DM_TRACE, "Hit Test begin");
        for (i = 0; i <= cItems; i++, phdi++, xPrev = xItem)
        {
            if (i == cItems) 
                xItem = rc.right;
            else {
                phdi = Header_GetItemPtrByOrder(phd, i);
                xItem = phdi->x;
            }

            // DebugMsg(DM_TRACE, "x = %d xItem = %d xPrev = %d fPrevZero = %d", x, xItem, xPrev, xPrev == xItem);
            if (xItem == xPrev)
            {
                // Skip zero width items...
                //
                fPrevZero = TRUE;
                continue;
            }

            cxSlop = min((xItem - xPrev) / 4, phd->cxDividerSlop);

            if (x >= xPrev && x < xItem)
            {
                if ( Header_IsFilter(phd) )
                {
                    RECT rcItem;
                    RECT rcHeader, rcFilter, rcButton;

                    rcItem.left   = xPrev;
                    rcItem.top    = rc.top;
                    rcItem.right  = xItem;
                    rcItem.bottom = rc.bottom ;

                    Header_GetFilterRects(&rcItem, &rcHeader, &rcFilter, &rcButton);

                    if ( y >= rcFilter.top )
                    {
                        if ( x >= rcFilter.right )
                        {
                            // hit check the entire button, forget about the divider
                            // when over the filter glyph
                            flags = HHT_ONFILTERBUTTON;
                            break;
                        }
                        else
                        {
                            flags = HHT_ONFILTER;
                        }
                    }
                    else if ( y < rcHeader.bottom )
                        flags = HHT_ONHEADER;
                }
                else
                {
                    flags = HHT_ONHEADER;
                }

                if (i > 0 && x < xPrev + cxSlop)
                {
                    i--;
                    flags = HHT_ONDIVIDER;

                    if (fPrevZero && x > xPrev)
                    {
                        flags = HHT_ONDIVOPEN;
                    }
                }
                else if (x >= xItem - cxSlop)
                {
                    flags = HHT_ONDIVIDER;
                }

                break;
            }
            fPrevZero = FALSE;
        }
        if (i == cItems)
        {
            i = -1;
            flags = HHT_NOWHERE;
        } else {
            // now convert order index to real index
            i = Header_ItemOrderToIndex(phd, i);
        }
            
    }
    *pflags = flags;
    return i;
}

int Header_OnHitTest(HD* phd, HD_HITTESTINFO *phdht)
{
    if (phdht && phd) {
        phdht->iItem = Header_HitTest(phd, phdht->pt.x, phdht->pt.y, &phdht->flags);
        return phdht->iItem;
    } else
        return -1;
}

BOOL Header_OnSetCursor(HD* phd, HWND hwndCursor, UINT codeHitTest, UINT msg)
{
    POINT pt;
    UINT flags;
    LPCTSTR lpCur = MAKEINTRESOURCE(IDC_SIZEWE);
    HINSTANCE hinst = NULL;
    int iItem;
    int iDPI = CCGetScreenDPI();

    if (!phd)
        return FALSE;

    if (phd->ci.hwnd != hwndCursor || codeHitTest >= 0x8000)
        return FALSE;

    GetMessagePosClient(hwndCursor, &pt);

    iItem = Header_HitTest(phd, pt.x, pt.y, &flags);

    switch (flags)
    {
    case HHT_ONDIVIDER:
        if (iDPI <= 96)
        {
            lpCur = MAKEINTRESOURCE(IDC_DIVIDER);
            hinst = HINST_THISDLL;
        }
        break;
    case HHT_ONDIVOPEN:
        if (iDPI <= 96)
        {
            lpCur = MAKEINTRESOURCE(IDC_DIVOPEN);
            hinst = HINST_THISDLL;
        }

        break;

    case HHT_ONFILTER:
    {
        HDI* phdi = Header_GetItemPtrByOrder(phd, iItem);
        ASSERT(phdi);

        lpCur = IDC_ARROW;              // default to the arrow

        switch ( phdi->type & HDFT_ISMASK )
        {
            case HDFT_ISSTRING:
            case HDFT_ISNUMBER:
                lpCur = IDC_IBEAM;
                break;

            default:
// FEATURE: handle custom filters
                break;
        }
        break;
    }

    default:
        lpCur = IDC_ARROW;
        break;
    }
    SetCursor(LoadCursor(hinst, lpCur));
    return TRUE;
}

void Header_DrawDivider(HD* phd, int x)
{
    RECT rc;
    HDC hdc = GetDC(phd->ci.hwnd);

    GetClientRect(phd->ci.hwnd, &rc);
    rc.left = x;
    rc.right = x + g_cxBorder;

    InvertRect(hdc, &rc);

    ReleaseDC(phd->ci.hwnd, hdc);
}

int Header_PinDividerPos(HD* phd, int x)
{
    x += phd->dxTrack;
    if (x < phd->xMinTrack)
        x = phd->xMinTrack;
    return x;
}

void Header_OnLButtonDown(HD* phd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    HD_ITEM hd;
    int i;
    UINT flags;

    if (!phd)
        return;

    Header_StopFilterEdit(phd, FALSE);

    i = Header_HitTest(phd, x, y, &flags);
    if (flags & (HHT_ONDIVIDER))
    {
        if (fDoubleClick) {
            Header_SendChange(phd, i, HDN_DIVIDERDBLCLICK, NULL);
        }  
    }
    
    if ((flags & (HHT_ONDIVIDER | HHT_ONHEADER | HHT_ONDIVOPEN))
        && !fDoubleClick)
    {
        phd->iTrack = i;
        phd->flagsTrack = flags;
        phd->xTrack = x;
        SetCapture(phd->ci.hwnd);

        // this is just to get messages so we can
        // check for the escape key being hit
        SetTimer(phd->ci.hwnd, 1, 100, NULL);
        GetAsyncKeyState(VK_ESCAPE);
    }
    
    if (flags & (HHT_ONDIVIDER | HHT_ONDIVOPEN) &&
        !fDoubleClick)
    {
        //
        // We should first send out the HDN_BEGINTRACK notification
        //
        HDI * phdi;
        
        int iOrder = Header_OnGetItemOrder(phd, i);
        phdi = Header_GetItemPtr(phd, i);
        phd->xMinTrack = phdi->x - phdi->cxy;
        phd->xTrack = phdi->x;
        phd->dxTrack = phd->xTrack - x;
        phd->xTrackOldWidth = phdi->cxy;

        hd.mask = HDI_WIDTH;
        hd.cxy = phd->xTrackOldWidth;
        if (!Header_SendChange(phd, i, HDN_BEGINTRACK, &hd))
        {
            // They said no!
            phd->flagsTrack = 0;
            CCReleaseCapture(&phd->ci);
            KillTimer(phd->ci.hwnd, 1);
            return;
        }

        if (!HDDragFullWindows(phd)) {
            x = Header_PinDividerPos(phd, x);
            Header_DrawDivider(phd, x);
        }
    }
    else if ((flags & HHT_ONHEADER) && (phd->ci.style & HDS_BUTTONS))
    {
        if (fDoubleClick) {
            Header_SendChange(phd, i, HDN_ITEMDBLCLICK, NULL);
        } else {
            phd->bTrackPress = TRUE;
            Header_InvalidateItem(phd, phd->iTrack, RDW_INVALIDATE| RDW_ERASE);
        }
    }

    if ( flags & HHT_ONFILTER )
    {
        Header_BeginFilterEdit(phd, i);
    }

    if ( flags & HHT_ONFILTERBUTTON )
    {
        Header_OnFilterButton(phd, i);
    }
}

void Header_StartDrag(HD* phd, int i, int x, int y)
{
    RECT rc;

    if ((phd->ci.style & HDS_DRAGDROP) &&
        Header_Notify(phd, i, MK_LBUTTON, HDN_BEGINDRAG)) {
        // clear the hot bit and 
        // update before we do the BeginDrag so that the save bitmap won't
        // have the hot drawing on it.
        Header_SetHotItem(phd, -1);
        UpdateWindow(phd->ci.hwnd);


        phd->himlDrag = Header_OnCreateDragImage(phd, Header_OnGetItemOrder(phd,i));
        if (!phd->himlDrag)
            return;

        // find the delta between the start of the item and the cursor
        Header_OnGetItemRect(phd, i, &rc);
        phd->dxTrack = rc.left - x;

        ImageList_BeginDrag(phd->himlDrag, 0, 0, 0);
        ImageList_DragEnter(phd->ci.hwnd, x, 0);
    }
}

void Header_InvalidateDivider(HD* phd, int iItem)
{
    RECT rc;
    Header_GetDividerRect(phd, iItem, &rc);
    InvalidateRect(phd->ci.hwnd, &rc, FALSE);
}

void _Header_SetHotDivider(HD* phd, int iNewOrder)
{
    if (iNewOrder != phd->iNewOrder) {
        if (phd->himlDrag)
            ImageList_DragShowNolock(FALSE);
        Header_InvalidateDivider(phd, phd->iNewOrder);
        Header_InvalidateDivider(phd, iNewOrder);
        phd->iNewOrder = iNewOrder;
        UpdateWindow(phd->ci.hwnd);
        if (phd->himlDrag)
            ImageList_DragShowNolock(TRUE);
    }
}

LPARAM Header_OnSetHotDivider(HD* phd, BOOL fPos, LPARAM lParam)
{
    int iNewOrder = -1;
    if (fPos) {
        RECT rc;
        int y = GET_Y_LPARAM(lParam);
        int x = GET_X_LPARAM(lParam);
        
        // this means that lParam is the cursor position (in client coordinates)
    
        GetClientRect(phd->ci.hwnd, &rc);
        InflateRect(&rc, 0, g_cyHScroll * 2);

        // show only if the y point is reasonably close to the header
        // (a la scrollbar)
        if (y >= rc.top &&
            y <= rc.bottom) {

            //
            // find out the new insertion point
            //
            if (x <= 0) {
                iNewOrder = 0;
            } else {
                UINT flags;
                int iIndex;
                iIndex = Header_HitTest(phd, x, (rc.top + rc.bottom)/2, &flags);

                // if we didn't find an item, see if it's on the far right
                if (iIndex == -1) {

                    int iLast = Header_ItemOrderToIndex(phd, Header_GetCount(phd) -1);
                    if (Header_OnGetItemRect(phd, iLast, &rc)) {
                        if (x >= rc.right) {
                            iNewOrder = Header_GetCount(phd);
                        }
                    }

                } else {
                    Header_OnGetItemRect(phd, iIndex, &rc);
                    iNewOrder= Header_OnGetItemOrder(phd, iIndex);
                    // if it was past the midpoint, the insertion point is the next one
                    if (x > ((rc.left + rc.right)/2)) {
                        // get the next item... translate to item order then back to index.
                        iNewOrder++;
                    }
                }
            }
        }
    } else {
        iNewOrder = (int)lParam;
    }
    _Header_SetHotDivider(phd, iNewOrder);
    return iNewOrder;
}

void Header_MoveDrag(HD* phd, int x, int y)
{
    LPARAM iNewOrder = -1;
        
    iNewOrder = Header_OnSetHotDivider(phd, TRUE, MAKELONG(x, y));

    if (iNewOrder == -1) {
        ImageList_DragShowNolock(FALSE);
    } else {
        ImageList_DragShowNolock(TRUE);
        ImageList_DragMove(x + phd->dxTrack, 0);
    }
}

void Header_EndDrag(HD* phd)
{
    ImageList_EndDrag();
    ImageList_Destroy(phd->himlDrag);
    phd->himlDrag = NULL;
    _Header_SetHotDivider(phd, -1);
}

// iOrder
void Header_GetDividerRect(HD* phd, int iOrder, LPRECT prc)
{
    int iIndex;
    BOOL fLeft;

    if (iOrder == -1)
    {
        SetRectEmpty(prc);
        return;
    }
    
    // if we're getting the divider slot of < N then 
    // it's the left of the rect of item i.
    // otherwise it's the right of the last item.
    if (iOrder < Header_GetCount(phd)) {
        fLeft = TRUE;
    } else { 
        fLeft = FALSE;
        iOrder--;
    }
    
    iIndex = Header_ItemOrderToIndex(phd, iOrder);
    Header_OnGetItemRect(phd, iIndex, prc);
    if (fLeft) {
        prc->right = prc->left;
    } else {
        prc->left = prc->right;
    }
    InflateRect(prc, g_cxBorder, 0);
}

void Header_OnMouseMove(HD* phd, int x, int y, UINT keyFlags)
{
    UINT flags;
    int i;
    HD_ITEM hd;

    if (!phd)
        return;

    // do the hot tracking
    // but not if anything is ownerdraw or if we're in d/d mode
    if ((phd->hTheme || phd->ci.style & HDS_HOTTRACK) && !phd->fOwnerDraw && !phd->himlDrag) {
        // only do this if we're in button mode meaning you can actually click
        if (phd->ci.style & HDS_BUTTONS) {
            i = Header_HitTest(phd, x, y, &flags);
            Header_SetHotItem(phd, i);
        }
    }
    
    if (Header_IsTracking(phd))
    {
        if (phd->flagsTrack & (HHT_ONDIVIDER | HHT_ONDIVOPEN))
        {
            x = Header_PinDividerPos(phd, x);

            //
            // Let the Owner have a chance to update this.
            //
            hd.mask = HDI_WIDTH;
            hd.cxy = x - phd->xMinTrack;
            if (!HDDragFullWindows(phd) && !Header_SendChange(phd, phd->iTrack, HDN_TRACK, &hd))
            {
                // We need to cancel tracking
                phd->flagsTrack = 0;
                CCReleaseCapture(&phd->ci);
                KillTimer(phd->ci.hwnd, 1);

                // Undraw the last divider we displayed
                Header_DrawDivider(phd, phd->xTrack);
                return;
            }

            // We should update our x depending on what caller did
            x = hd.cxy + phd->xMinTrack;
            
            // if full window track is turned on, go ahead and set the width
            if (HDDragFullWindows(phd)) {            
                HD_ITEM item;

                item.mask = HDI_WIDTH;
                item.cxy = hd.cxy;

                DebugMsg(DM_TRACE, TEXT("Tracking header.  item %d gets width %d...  %d %d"), phd->iTrack, item.cxy, phd->xMinTrack, x);
                // Let the owner have a chance to say yes.
                Header_OnSetItem(phd, phd->iTrack, &item);

                UpdateWindow(phd->ci.hwnd);
            } else {

                // do the cheezy old stuff
                Header_DrawDivider(phd, phd->xTrack);
                Header_DrawDivider(phd, x);
            }
            
            phd->xTrack = x;
            
        }
        else if (phd->flagsTrack & HHT_ONHEADER)
        {
            i = Header_HitTest(phd, x, y, &flags);
            
            if (ABS(x - phd->xTrack) > 
                GetSystemMetrics(SM_CXDRAG)) {
                if (!phd->himlDrag) {
                    Header_StartDrag(phd, i, phd->xTrack, y);
                } 
            }
            
            if (phd->himlDrag) {
                Header_MoveDrag(phd, x, y);
            } else {
                // if pressing on button and it's not pressed, press it
                if (flags & HHT_ONHEADER && i == phd->iTrack)
                {
                    if ((!phd->bTrackPress) && (phd->ci.style & HDS_BUTTONS))
                    {
                        phd->bTrackPress = TRUE;
                        Header_InvalidateItem(phd, phd->iTrack, RDW_INVALIDATE| RDW_ERASE);
                    }
                }
                // tracked off of button.  if pressed, pop it
                else if ((phd->bTrackPress) && (phd->ci.style & HDS_BUTTONS))
                {
                    phd->bTrackPress = FALSE;
                    Header_InvalidateItem(phd, phd->iTrack, RDW_INVALIDATE| RDW_ERASE);
                }
            }
        }
    }
}

void Header_OnLButtonUp(HD* phd, int x, int y, UINT keyFlags)
{
    if (!phd)
        return;

    if (Header_IsTracking(phd))
    {
        if (phd->flagsTrack & (HHT_ONDIVIDER | HHT_ONDIVOPEN))
        {
            HD_ITEM item;

            if (!HDDragFullWindows(phd)) {
                Header_DrawDivider(phd, phd->xTrack);
            }

            item.mask = HDI_WIDTH;
            item.cxy = phd->xTrack - phd->xMinTrack;

            // Let the owner have a chance to say yes.


            if (Header_SendChange(phd, phd->iTrack, HDN_ENDTRACK, &item))
                Header_OnSetItem(phd, phd->iTrack, &item);

            RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
        else if ((phd->flagsTrack & HHT_ONHEADER)
                 && (phd->bTrackPress || phd->himlDrag))
        {
            if (phd->himlDrag) {
                // if this is the end of a drag, 
                // notify the user.
                HDITEM item;
                
                item.mask = HDI_ORDER;
                item.iOrder = phd->iNewOrder;
                
                
                if (item.iOrder > Header_OnGetItemOrder(phd, phd->iTrack)) {
                    // if the new order is greater than the old one,
                    // we subtract one because it's leaving the old place
                    // which decs the count by one.
                    item.iOrder--;
                }
                
                Header_EndDrag(phd);
                
                if (Header_SendChange(phd, phd->iTrack, HDN_ENDDRAG, &item)) {
                    if (item.iOrder != -1) {
                        // all's well... change the item order
                        Header_OnSetItemOrder(phd, phd->iTrack, item.iOrder);

                        NotifyWinEvent(EVENT_OBJECT_REORDER, phd->ci.hwnd, OBJID_CLIENT, 0);
                    }
                }
                
            } else {
                // Notify the owner that the item has been clicked
                Header_Notify(phd, phd->iTrack, 0, HDN_ITEMCLICK);
            }
            phd->bTrackPress = FALSE;
            Header_InvalidateItem(phd, phd->iTrack, RDW_INVALIDATE| RDW_ERASE);
        }
        
        phd->flagsTrack = 0;
        CCReleaseCapture(&phd->ci);
        KillTimer(phd->ci.hwnd, 1);
    }
}


BOOL Header_IsTracking(HD* phd)
{
    if (!phd->flagsTrack)
    {
        return FALSE;
    } else if  (GetCapture() != phd->ci.hwnd) {
        phd->flagsTrack = 0;
        return FALSE;
    }

    return TRUE;
}

void Header_OnSetFont(HD* phd, HFONT hfont, BOOL fRedraw)
{
    if (!phd)
        return;

    if (hfont != phd->hfont)
    {
        Header_NewFont(phd, hfont);
        
        if (fRedraw)
            RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
    }
}

HFONT Header_OnGetFont(HD* phd)
{
    if (!phd)
        return NULL;

    return phd->hfont;
}

//**********************************************************************

int Header_OnInsertItemA(HD* phd, int i, HD_ITEMA* pitem) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    HD_TEXTFILTERW textFilterW;
    LPHD_TEXTFILTERA ptextFilterA = NULL;
    int iRet;


    //HACK ALERT -- this code assumes that HD_ITEMA is exactly the same
    // as HD_ITEMW except for the pointer to the string.
    ASSERT(sizeof(HD_ITEMA) == sizeof(HD_ITEMW))

    if (!pitem || !phd)
        return -1;

    if ((pitem->mask & HDI_TEXT) && (pitem->pszText != LPSTR_TEXTCALLBACKA) &&
        (pitem->pszText != NULL)) {
        pszC = pitem->pszText;
        if ((pszW = ProduceWFromA(phd->ci.uiCodePage, pszC)) == NULL)
            return -1;
        pitem->pszText = (LPSTR)pszW;
    }

    if ( (pitem->mask & HDI_FILTER) &&
            ((pitem->type & HDFT_ISMASK) == HDFT_ISSTRING) ) {
        // pick up the filter if there is one for us to thunk
        if ( pitem->pvFilter ) {
            ptextFilterA = pitem->pvFilter;
            ASSERT(ptextFilterA);

            textFilterW.pszText = NULL;
            textFilterW.cchTextMax = ptextFilterA->cchTextMax;

            if ( !(pitem->type & HDFT_HASNOVALUE) ) {
                textFilterW.pszText = ProduceWFromA(phd->ci.uiCodePage, ptextFilterA->pszText);
                if ( !textFilterW.pszText ) {
                    if ( pszW )
                        FreeProducedString(pszW)
                    return -1;
                }
            }

            pitem->pvFilter = &textFilterW;
        }
    }

    iRet = Header_OnInsertItem(phd, i, (const HD_ITEM*) pitem);

    if (pszW != NULL) {
        pitem->pszText = pszC;

        FreeProducedString(pszW);
    }

    if (ptextFilterA)
    {
        pitem->pvFilter = ptextFilterA;
        FreeProducedString(textFilterW.pszText);
    }

    return iRet;
}

int Header_OnInsertItem(HD* phd, int i, const HD_ITEM* pitem)
{
    HDI hdi = {0};
    int x;
    HDI* phdi;
    int iOrder;
    int cxy;

    if (!pitem || !phd || i < 0)
    	return -1;
    	
    if (pitem->mask == 0)
        return -1;

    if (!DSA_ForceGrow(phd->hdsaHDI, 1))
    {
        return -1;
    }

    if (phd->hdsaOrder && !DSA_ForceGrow(phd->hdsaOrder, 1))
    {
        return -1;
    }

    cxy = pitem->cxy;
    if (cxy < 0)
        cxy = 0;

    x = cxy;

    if (i > DSA_GetItemCount(phd->hdsaHDI))
        i = DSA_GetItemCount(phd->hdsaHDI);

    // stop editing the filter    
    Header_StopFilterEdit(phd, FALSE);

    iOrder = i;    
    // can't have order info if it's owner data
    if (!(phd->ci.style & HDS_OWNERDATA)) 
    {

        // the iOrder field wasn't there in win95...
        // so access it only if the bit is there.
        if (pitem->mask & HDI_ORDER)
        {

            if ((pitem->iOrder != i) && (pitem->iOrder <= Header_GetCount(phd))) 
            {
                if (Header_InitOrderArray(phd))
                    iOrder = pitem->iOrder;
            }
        }
    }

    if (iOrder > 0)
    {

        phdi = Header_GetItemPtrByOrder(phd, iOrder - 1);
        if (phdi)
            x += phdi->x;

    }
    
    // move everything else over
    Header_ShiftItems(phd, iOrder, cxy);

    if (phd->hdsaOrder) 
    {
        int j;
        int iIndex = -1;
        
        // an index is added, all the current indices
        // need to be incr by one
        for (j = 0; j < DSA_GetItemCount(phd->hdsaOrder); j++) 
        {
            DSA_GetItem(phd->hdsaOrder, j, &iIndex);
            if (iIndex >= i) 
            {
                iIndex++;
                DSA_SetItem(phd->hdsaOrder, j, &iIndex);
            }
        }
        DSA_InsertItem(phd->hdsaOrder, iOrder, &i);
    }
    
    hdi.x = x;
    hdi.lParam = pitem->lParam;
    hdi.fmt = pitem->fmt;
    //hdi.pszText = NULL;
    //hdi.iImage = 0;
    hdi.cxy = cxy;
    hdi.xText = hdi.xBm = RECOMPUTE;
    hdi.type = HDFT_ISSTRING|HDFT_HASNOVALUE;
    //hdi.textFilter.pszText = NULL;
    hdi.textFilter.cchTextMax = MAX_PATH;

    if ((pitem->mask & HDI_TEXT) && (pitem->pszText != NULL))
    {
        if (!Str_Set(&hdi.pszText, pitem->pszText))
            return -1;

        // Unless ownerdraw make sure the text bit is on!
        if ((pitem->mask & HDF_OWNERDRAW) == 0)
            hdi.fmt |= HDF_STRING;
    }
    else
    {
        hdi.fmt &= ~(HDF_STRING);
    }

    if ((pitem->mask & HDI_BITMAP) && (pitem->hbm != NULL))
    {
        
        hdi.hbm = pitem->hbm;

        // Unless ownerdraw make sure the text bit is on!
        if ((pitem->mask & HDF_OWNERDRAW) == 0)
            hdi.fmt |= HDF_BITMAP;
    }
    else 
    {
        hdi.hbm = NULL;
        hdi.fmt &= ~(HDF_BITMAP);
    }
        
    if (pitem->mask & HDI_IMAGE) 
    {
        hdi.iImage = pitem->iImage;
        
        // Unless ownerdraw make sure the image bit is on!
        if ((pitem->mask & HDF_OWNERDRAW) == 0)
            hdi.fmt |= HDF_IMAGE;
    }

    if ( pitem->mask & HDI_FILTER )
    {
        // pick up the new filter, handling the case where the filter value is
        // being discarded, and/or there is none
        
        hdi.type = pitem->type;

        switch ( hdi.type & HDFT_ISMASK )
        {
            case HDFT_ISSTRING:
            {
                if ( pitem->pvFilter ) 
                {
                    LPHDTEXTFILTER ptextFilter = (LPHDTEXTFILTER)pitem->pvFilter;
                    ASSERT(ptextFilter);
    
                    if ( !(pitem->type & HDFT_HASNOVALUE) )
                        Str_Set(&hdi.textFilter.pszText, ptextFilter->pszText);                    
                    hdi.textFilter.cchTextMax = ptextFilter->cchTextMax;
                }
                break;
            }

            case HDFT_ISNUMBER:
            {
                if ( !(pitem->type & HDFT_HASNOVALUE) && pitem->pvFilter )
                    hdi.intFilter = *((int*)pitem->pvFilter);
                break;
            }
        }       
    }


    i = DSA_InsertItem(phd->hdsaHDI, i, &hdi);
    if (i == -1)
    {
        // failed to add
        Str_Set(&hdi.pszText, NULL);
        if ( (hdi.type & HDFT_ISMASK) == HDFT_ISSTRING )
            Str_Set(&hdi.textFilter.pszText, NULL);
    } 
    else
    {
        RECT rc;
        
        // succeeded!  redraw
        GetClientRect(phd->ci.hwnd, &rc);
        rc.left = x - cxy;
        RedrawWindow(phd->ci.hwnd, &rc, NULL, RDW_INVALIDATE | RDW_ERASE);

        NotifyWinEvent(EVENT_OBJECT_CREATE, phd->ci.hwnd, OBJID_CLIENT, i+1);
    }

    return i;
}

BOOL Header_OnDeleteItem(HD* phd, int i)
{
    HDI hdi;
    RECT rc;
    int iWidth;
    int iOrder;

    if (!phd)
        return FALSE;

    if (!DSA_GetItem(phd->hdsaHDI, i, &hdi))
        return FALSE;

    NotifyWinEvent(EVENT_OBJECT_DESTROY, phd->ci.hwnd, OBJID_CLIENT, i+1);

    Header_StopFilterEdit(phd, FALSE);
    phd->iFocus = 0;

    GetClientRect(phd->ci.hwnd, &rc);
    iWidth = rc.right;
    Header_OnGetItemRect(phd, i, &rc);
    InflateRect(&rc, g_cxBorder, g_cyBorder);

    // move everything else over
    iOrder = Header_OnGetItemOrder(phd, i);
    Header_ShiftItems(phd, iOrder, -hdi.cxy);

    if (!DSA_DeleteItem(phd->hdsaHDI, i))
        return FALSE;
    
    if (phd->hdsaOrder) {
        int j;
        int iIndex;
        DSA_DeleteItem(phd->hdsaOrder, iOrder);
        
        
        // an index is going away, all the current indices
        // need to be decremented by one
        for (j = 0; j < DSA_GetItemCount(phd->hdsaOrder); j++) {
            DSA_GetItem(phd->hdsaOrder, j, &iIndex);
            ASSERT(iIndex != i);
            if (iIndex > i) {
                iIndex--;
                DSA_SetItem(phd->hdsaOrder, j, &iIndex);
            }
        }

    }

    Header_DestroyItemCallback(&hdi, NULL);

    rc.right = iWidth;
    InvalidateRect(phd->ci.hwnd, &rc, TRUE);
    return TRUE;
}

BOOL Header_OnGetItemA(HD* phd, int i, HD_ITEMA* pitem) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    HD_TEXTFILTERW textFilterW;
    LPHD_TEXTFILTERA ptextFilterA = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that HD_ITEMA is exactly the same
    // as HD_ITEMW except for the pointer to the string.
    ASSERT(sizeof(HD_ITEMA) == sizeof(HD_ITEMW))

    if (!pitem || !phd)
        return FALSE;

    if ((pitem->mask & HDI_TEXT) && (pitem->pszText != LPSTR_TEXTCALLBACKA) &&
        (pitem->pszText != NULL)) {
        pszC = pitem->pszText;
        pszW = LocalAlloc(LMEM_FIXED, pitem->cchTextMax * sizeof(WCHAR));
        if (pszW == NULL)
            return FALSE;
        pitem->pszText = (LPSTR)pszW;
    }

    if ( (pitem->mask & HDI_FILTER) &&
            ((pitem->type & HDFT_ISMASK)==HDFT_ISSTRING) ) {
        if ( pitem->pvFilter ) {
            ptextFilterA = pitem->pvFilter;
            ASSERT(ptextFilterA);

            textFilterW.pszText = LocalAlloc(LMEM_FIXED, ptextFilterA->cchTextMax * sizeof(WCHAR));
            textFilterW.cchTextMax = ptextFilterA->cchTextMax;

            if ( !textFilterW.pszText ) {                    
                if ( pszW )
                    LocalFree(pszW);
                return FALSE;
            }

            pitem->pvFilter = &textFilterW;        
        }
    }

    fRet = Header_OnGetItem(phd, i, (HD_ITEM *) pitem);

    if (pszW != NULL) {
        ConvertWToAN(phd->ci.uiCodePage, pszC, pitem->cchTextMax, pszW, -1);
        pitem->pszText = pszC;

        LocalFree(pszW);
    }

    if (ptextFilterA)
    {
        ConvertWToAN(phd->ci.uiCodePage, ptextFilterA->pszText, ptextFilterA->cchTextMax, 
                                         textFilterW.pszText, -1);
        pitem->pvFilter = ptextFilterA;
    }

    return fRet;
}

BOOL Header_OnGetItem(HD* phd, int i, HD_ITEM* pitem)
{
    HDI* phdi;
    UINT mask;
    NMHDDISPINFO nm;

    ASSERT(pitem);

    if (!pitem || !phd)
    	return FALSE;

    // Crappy hack to fix norton commander.  MFC has a bug where it
    // passes in stack trash (in addition to the desired bits) to HDM_GETITEM.
    // Fix it here by stripping down to Win95 bits if more bits than the
    // current valid bits are defined. 
    if (pitem->mask & ~HDI_ALL)
        pitem->mask &= HDI_ALL95;
    
    nm.mask = 0;
    mask = pitem->mask;

#ifdef DEBUG
    if (i < 0 || i >= Header_GetCount(phd))
    {
        RIPMSG(0, "HDM_GETITEM: Invalid item number %d", i);
        return FALSE; // Return immediately so Header_GetItemPtr doesn't assert
    }
#endif

    phdi = Header_GetItemPtr(phd, i);
    if (!phdi)
        return FALSE;

    if (mask & HDI_WIDTH)
    {
        pitem->cxy = phdi->cxy;
    }

    if (mask & HDI_FORMAT)
    {
        pitem->fmt = phdi->fmt;
    }
    
    if (mask & HDI_ORDER)
    {
        pitem->iOrder = Header_OnGetItemOrder(phd, i);
    }

    if (mask & HDI_LPARAM)
    {
        pitem->lParam = phdi->lParam;
    }

    if (mask & HDI_TEXT)
    {
        if (phdi->pszText != LPSTR_TEXTCALLBACK) {
            
            // if pszText was NULL and you tried to retrieve it, we would bail
            // and return FALSE, now we may return TRUE.
            Str_GetPtr0(phdi->pszText, pitem->pszText, pitem->cchTextMax);
        }
        else {
            // need to recalc the xText because they could keep changing it on us
            phdi->xText = RECOMPUTE;
            nm.mask |= HDI_TEXT;
        }
    }
      
    if (mask & HDI_BITMAP)
        pitem->hbm = phdi->hbm;
    
    if (mask & HDI_IMAGE)
    {
        if (phdi->iImage == I_IMAGECALLBACK)
            nm.mask |= HDI_IMAGE;
        else
            pitem->iImage = phdi->iImage;
    }
    
    if (mask & HDI_FILTER)
    {
        if (pitem->pvFilter)
        {
            if ((phdi->type & HDFT_ISMASK) != (pitem->type & HDFT_ISMASK))
                return FALSE;

            switch (phdi->type & HDFT_ISMASK) 
            {
                case HDFT_ISSTRING:
                {
                    LPHDTEXTFILTER ptextFilter = (LPHDTEXTFILTER)pitem->pvFilter;
                    ASSERT(ptextFilter);

                    if ( !Str_GetPtr(phdi->textFilter.pszText, ptextFilter->pszText, ptextFilter->cchTextMax) )
                        return FALSE;
    
                    ptextFilter->cchTextMax = phdi->textFilter.cchTextMax;
                    break;
                }

                case HDFT_ISNUMBER:
                {
                    *((int*)pitem->pvFilter) = phdi->intFilter;
                    break;
                }

                default:
                    return FALSE;
            }
        }

        pitem->type = phdi->type;
    }

    if (nm.mask) {
        // just in case HDI_IMAGE is set and callback doesn't fill it in
        // ... we'd rather have a -1 than watever garbage is on the stack
        nm.iImage = -1;
        nm.lParam = phdi->lParam;
        
        if (nm.mask & HDI_TEXT) {
            ASSERT(pitem->pszText);
            nm.pszText = pitem->pszText;
            nm.cchTextMax = pitem->cchTextMax;
            
            // Make sure the buffer is zero terminated...
            if (nm.cchTextMax)
                *nm.pszText = 0;
        }
            
        CCSendNotify(&phd->ci, HDN_GETDISPINFO, &nm.hdr);
    
        if (nm.mask & HDI_IMAGE)
            pitem->iImage = nm.iImage;
        if (nm.mask & HDI_TEXT)
            pitem->pszText = CCReturnDispInfoText(nm.pszText, pitem->pszText, pitem->cchTextMax);
    }
    
    if (phdi && (nm.mask & HDI_DI_SETITEM)) {
        if (nm.mask & HDI_IMAGE)
            phdi->iImage = nm.iImage;
        
        if (nm.mask & HDI_TEXT)
            if (nm.pszText) {
                ASSERT(phdi->pszText == LPSTR_TEXTCALLBACK);
                Str_Set(&phdi->pszText, nm.pszText);
            }
    }
            
    pitem->mask = mask;
    return TRUE;
}

BOOL Header_OnSetItemA(HD* phd, int i, HD_ITEMA* pitem) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    HD_TEXTFILTERW textFilterW;
    LPHD_TEXTFILTERA ptextFilterA = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that HD_ITEMA is exactly the same
    // as HD_ITEMW except for the pointer to the string.
    ASSERT(sizeof(HD_ITEMA) == sizeof(HD_ITEMW));

    if (!pitem || !phd)
        return FALSE;


    if ((pitem->mask & HDI_TEXT) && (pitem->pszText != LPSTR_TEXTCALLBACKA) &&
        (pitem->pszText != NULL)) {
        pszC = pitem->pszText;
        if ((pszW = ProduceWFromA(phd->ci.uiCodePage, pszC)) == NULL)
            return FALSE;
        pitem->pszText = (LPSTR)pszW;
    }

    if ( (pitem->mask & HDI_FILTER) &&
            ((pitem->type & HDFT_ISMASK) == HDFT_ISSTRING) )
    {
        if ( pitem->pvFilter )
        {
            ptextFilterA = pitem->pvFilter;
            ASSERT(ptextFilterA);

            textFilterW.pszText = NULL;
            textFilterW.cchTextMax = ptextFilterA->cchTextMax;

            if ( !(pitem->type & HDFT_HASNOVALUE) )
            {
                textFilterW.pszText = ProduceWFromA(phd->ci.uiCodePage, ptextFilterA->pszText);
                if ( !textFilterW.pszText ) {
                    if ( pszW )
                        FreeProducedString(pszW)
                    return FALSE;
                }
            }

            pitem->pvFilter = &textFilterW;
        }
    }
    
    fRet = Header_OnSetItem(phd, i, (const HD_ITEM*) pitem);

    if (pszW != NULL) {
        pitem->pszText = pszC;
        FreeProducedString(pszW);
    }

    if (ptextFilterA)
    {
        pitem->pvFilter = ptextFilterA;
        FreeProducedString(textFilterW.pszText);
    }

    return fRet;

}

BOOL Header_OnSetItem(HD* phd, int i, const HD_ITEM* pitem)
{
    HDI* phdi;
    UINT mask;
    int xOld;
    BOOL fInvalidate = FALSE;
    
    ASSERT(pitem);

    if (!pitem || !phd)
    	return FALSE;
    	
#ifdef DEBUG
    if (i < 0 || i >= Header_GetCount(phd))
    {
        RIPMSG(0, "HDM_SETITEM: Invalid item number %d", i);
        return FALSE; // Return immediately so Header_GetItemPtr doesn't assert
    }
#endif

    phdi = Header_GetItemPtr(phd, i);
    if (!phdi)
        return FALSE;

    mask = pitem->mask;

    if (mask == 0)
        return TRUE;

    // stop editing the filter    
    //Header_StopFilterEdit(phd, FALSE);

    if (!Header_SendChange(phd, i, HDN_ITEMCHANGING, pitem))
        return FALSE;

    xOld = phdi->x;
    if (mask & HDI_WIDTH)
    {
        RECT rcClip;
        int iOrder;
        int dx;
        int cxy = pitem->cxy;
        
        if (cxy < 0)
            cxy = 0;

        DebugMsg(DM_TRACE, TEXT("Header--SetWidth x=%d, cxyOld=%d, cxyNew=%d, dx=%d"),
                 phdi->x, phdi->cxy, cxy, (cxy-phdi->cxy));
        dx = cxy - phdi->cxy;
        phdi->cxy = cxy;

        // scroll everything over
        GetClientRect(phd->ci.hwnd, &rcClip);
        rcClip.left = phdi->x; // we want to scroll the divider as well
        
        // the scrolling rect needs to be the largest rect of the before
        // and after.  so if dx is negative, we want to enlarge the rect
        if (dx < 0)
            rcClip.left += dx;
        iOrder = Header_OnGetItemOrder(phd, i);
        Header_ShiftItems(phd, iOrder, dx);
        
        phdi->xText = phdi->xBm = RECOMPUTE;
        
        {
            SMOOTHSCROLLINFO si = {
                sizeof(si),
                0,
                phd->ci.hwnd,
                dx,
                0,
                NULL,
                &rcClip, 
                NULL,
                NULL,
                SW_ERASE | SW_INVALIDATE,
            };

            SmoothScrollWindow(&si);
        }

        UpdateWindow(phd->ci.hwnd);
        // now invalidate this item itself
        Header_OnGetItemRect(phd, i, &rcClip);
        InvalidateRect(phd->ci.hwnd, &rcClip, TRUE);
        
    }
    if (mask & HDI_FORMAT) {
        phdi->fmt = pitem->fmt;
        phdi->xText = phdi->xBm = RECOMPUTE;
        fInvalidate = TRUE;
    }
    if (mask & HDI_LPARAM)
        phdi->lParam = pitem->lParam;

    if (mask & HDI_TEXT)
    {
        if (!Str_Set(&phdi->pszText, pitem->pszText))
            return FALSE;
        phdi->xText = RECOMPUTE;
        fInvalidate = TRUE;
    }

    if (mask & HDI_BITMAP)
    {
        phdi->hbm = pitem->hbm;
        
        phdi->xBm = RECOMPUTE;
        fInvalidate = TRUE;
    }
    
    if (mask & HDI_IMAGE)
    {
        phdi->iImage = pitem->iImage;
        phdi->xBm = RECOMPUTE;
        fInvalidate = TRUE;
    }
    
    if (mask & HDI_ORDER)
    {
        if (pitem->iOrder >= 0 && pitem->iOrder < Header_GetCount(phd))
        {
            Header_OnSetItemOrder(phd, i, pitem->iOrder);
            NotifyWinEvent(EVENT_OBJECT_REORDER, phd->ci.hwnd, OBJID_CLIENT, 0);
        }
    }

    if ( mask & HDI_FILTER )
    {
        if ( (phdi->type & HDFT_ISMASK) == HDFT_ISSTRING )
            Str_Set(&phdi->textFilter.pszText, NULL);

        // pick up the new filter, handling the case where the filter value is
        // being discarded, and/or there is none
        
        phdi->type = pitem->type;

        switch ( phdi->type & HDFT_ISMASK )
        {
            case HDFT_ISSTRING:
            {
                if ( pitem->pvFilter )
                {
                    LPHDTEXTFILTER ptextFilter = (LPHDTEXTFILTER)pitem->pvFilter;
                    ASSERT(ptextFilter);
    
                    if ( !(pitem->type & HDFT_HASNOVALUE) )
                        Str_Set(&phdi->textFilter.pszText, ptextFilter->pszText);                    
                    phdi->textFilter.cchTextMax = ptextFilter->cchTextMax;
                }
                break;
            }

            case HDFT_ISNUMBER:
            {
                if ( !(pitem->type & HDFT_HASNOVALUE) && pitem->pvFilter )
                    phdi->intFilter = *((int*)pitem->pvFilter);
                break;
            }
        }       

        fInvalidate = TRUE;
    }

    Header_SendChange(phd, i, HDN_ITEMCHANGED, pitem);
    
    if ( mask & HDI_FILTER )
    	Header_Notify(phd, i, 0, HDN_FILTERCHANGE);	       // send out a notify of change

    if (fInvalidate) {
        if (xOld == phdi->x) {
            // no change in x
            Header_InvalidateItem(phd, i, RDW_INVALIDATE| RDW_ERASE);
        } else {
            RECT rc;
            GetClientRect(phd->ci.hwnd, &rc);
            
            if (i > 0) {
                HDI * phdiTemp;
                phdiTemp = Header_GetItemPtrByOrder(phd, i - 1);
                if (phdiTemp) {
                    rc.left = phdi->x;
                }
            }
            RedrawWindow(phd->ci.hwnd, &rc, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }
 
    return TRUE;
}

// Compute layout for header bar, and leftover rectangle.
//
BOOL Header_OnLayout(HD* phd, HD_LAYOUT* playout)
{
    int cyHeader;
    WINDOWPOS* pwpos;
    RECT* prc;

    RIPMSG(playout != NULL, "HDM_LAYOUT: Invalid NULL pointer");

    if (!playout || !phd)
    	return FALSE;

    if (!(playout->pwpos && playout->prc))
	return FALSE;

    pwpos = playout->pwpos;
    prc = playout->prc;

    cyHeader = phd->cyChar + 2 * g_cyEdgeScaled;

    // when filter bar is enabled then lets show that region
    if ( Header_IsFilter(phd) )
        cyHeader += phd->cyChar + (2*g_cyEdgeScaled) + c_cyFilterBarEdge;

    // internal hack style for use with LVS_REPORT|LVS_NOCOLUMNHEADER! edh
    if (phd->ci.style & HDS_HIDDEN)
	    cyHeader = 0;

    pwpos->hwndInsertAfter = NULL;
    pwpos->flags = SWP_NOZORDER | SWP_NOACTIVATE;

    pwpos->x  = prc->left;
    pwpos->cx = prc->right - prc->left;
    pwpos->y  = prc->top;
    pwpos->cy = cyHeader;

    prc->top += cyHeader;
    return TRUE;
}

BOOL Header_OnGetItemRect(HD* phd, int i, RECT* prc)
{
    HDI* phdi;

    phdi = Header_GetItemPtr(phd, i);
    if (!phdi)
        return FALSE;

    GetClientRect(phd->ci.hwnd, prc);

    prc->right = phdi->x;
    prc->left = prc->right - phdi->cxy;
    return TRUE;
}

void Header_InvalidateItem(HD* phd, int i, UINT uFlags)
{
    RECT rc;

    if (i != -1) {
        Header_OnGetItemRect(phd, i, &rc);
        InflateRect(&rc, g_cxBorder, g_cyBorder);
        RedrawWindow(phd->ci.hwnd, &rc, NULL, uFlags);
    }
}

int _Header_DrawBitmap(HDC hdc, HIMAGELIST himl, HD_ITEM* pitem, 
                            RECT *prc, int fmt, UINT flags, LPRECT prcDrawn, int iMargin) 
{
    // This routine returns either the left of the image
    // or the right of the image depending on the justification.
    // This return value is used in order to properly tack on the 
    // bitmap when both the HDF_IMAGE and HDF_BITMAP flags are set.
    
    RECT rc;
    int xBitmap = 0;
    int yBitmap = 0;
    int cxBitmap;
    int cyBitmap;
    IMAGELISTDRAWPARAMS imldp;
    HBITMAP hbmOld;
    BITMAP bm;
    HDC hdcMem;
    int cxRc; 
    
    SetRectEmpty(prcDrawn);
    
    if (IsRectEmpty(prc)) 
        return prc->left;
        
    rc = *prc;
    
    rc.left  += iMargin;
    rc.right -= iMargin;

//  rc.right -= g_cxEdge; // handle edge

    if (rc.left >= rc.right) 
        return rc.left;
    
    if (pitem->fmt & HDF_IMAGE) 
        ImageList_GetIconSize(himl, &cxBitmap, &cyBitmap);

    else { // pitem->fmt & BITMAP
        if (GetObject(pitem->hbm, sizeof(bm), &bm) != sizeof(bm))
            return rc.left;     // could not get the info about bitmap.


        hdcMem = CreateCompatibleDC(hdc);
        
        if (!hdcMem || ((hbmOld = SelectObject(hdcMem, pitem->hbm)) == ERROR))
            return rc.left;     // an error happened.
        
        cxBitmap = bm.bmWidth;
        cyBitmap = bm.bmHeight;
    }

    if (flags & SHDT_DEPRESSED)
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    // figure out all the formatting...
    
    cxRc = rc.right - rc.left;          // cache this value

    if (fmt == HDF_LEFT)
    {
        if (cxBitmap > cxRc)
            cxBitmap = cxRc;
    }
    else if (fmt == HDF_CENTER)
    {
        if (cxBitmap > cxRc)
        {
            xBitmap =  (cxBitmap - cxRc) / 2;
            cxBitmap = cxRc;
        }
        else
            rc.left = (rc.left + rc.right - cxBitmap) / 2;
    }
    else  // fmt == HDF_RIGHT
    {
        if (cxBitmap > cxRc)
        {
            xBitmap =  cxBitmap - cxRc;
            cxBitmap = cxRc;
        }
        else
            rc.left = rc.right - cxBitmap;
    }

    // Now setup vertically
    if (cyBitmap > (rc.bottom - rc.top))
    {
        yBitmap = (cyBitmap - (rc.bottom - rc.top)) / 2;
        cyBitmap = rc.bottom - rc.top;
    }
    else
        rc.top = (rc.bottom - rc.top - cyBitmap) / 2;

    
    if (pitem->fmt & HDF_IMAGE) {
        imldp.cbSize = sizeof(imldp);
        imldp.himl   = himl;
        imldp.hdcDst = hdc;
        imldp.i      = pitem->iImage;
        imldp.x      = rc.left;
        imldp.y      = rc.top;
        imldp.cx     = cxBitmap;
        imldp.cy     = cyBitmap;
        imldp.xBitmap= xBitmap;
        imldp.yBitmap= yBitmap;
        imldp.rgbBk  = CLR_DEFAULT;
        imldp.rgbFg  = CLR_DEFAULT;
        imldp.fStyle = ILD_NORMAL;
        imldp.fState = 0;
    
        ImageList_DrawIndirect(&imldp);
    }
    
    else { // pitem->fmt & HDF_BITMAP
  
        TraceMsg(TF_HEADER, "h_db: BitBlt to (%d,%d) from (%d, %d)", rc.left, rc.top, xBitmap, yBitmap);
        // Last but not least we will do the bitblt.
        BitBlt(hdc, rc.left, rc.top, cxBitmap, cyBitmap,
                hdcMem, xBitmap, yBitmap, SRCCOPY);

        // Unselect our object from the DC
        SelectObject(hdcMem, hbmOld);
        
        // Also free any memory dcs we may have created
        DeleteDC(hdcMem);
    }
    
    *prcDrawn = rc;
    prcDrawn->bottom = rc.top + cyBitmap;
    prcDrawn->right = rc.left + cxBitmap;
    return ((pitem->fmt & HDF_RIGHT) ? rc.left : rc.left+cxBitmap);
}

void Header_DrawButtonEdges(HD* phd, HDC hdc, LPRECT prc, BOOL fItemSunken)
{
    UINT uEdge;
    UINT uBF;
    if (phd->ci.style & HDS_BUTTONS)
    {
        if (fItemSunken) {
            uEdge = EDGE_SUNKEN;
            uBF = BF_RECT | BF_SOFT | BF_FLAT;
        } else {
            uEdge = EDGE_RAISED;
            uBF = BF_RECT | BF_SOFT;
        }
    }                
    else
    {
        uEdge = EDGE_ETCHED;
        if (phd->ci.style & WS_BORDER)
            uBF = BF_RIGHT;
        else
            uBF = BF_BOTTOMRIGHT;
    }
    
    DrawEdge(hdc, prc, uEdge, uBF);
    
}

void Header_DrawFilterGlyph(HD* phd, HDC hdc, RECT* prc, BOOL fPressed)
{
    UINT uEdge = BDR_RAISEDOUTER|BDR_RAISEDINNER;
    UINT uBF = BF_RECT;
    RECT rc = *prc;

    if ( fPressed )
    {
        uEdge = EDGE_SUNKEN;
        uBF = BF_RECT | BF_SOFT | BF_FLAT;
    }
    
    if ( !phd->hFilterImage )
    {
        phd->hFilterImage = ImageList_LoadBitmap(HINST_THISDLL, MAKEINTRESOURCE(IDB_FILTERIMAGE), c_cxFilterImage, 0, RGB(128, 0, 0));

        if ( !phd->hFilterImage )
            return;
    }
        
    DrawEdge(hdc, &rc, uEdge, uBF|BF_MIDDLE);

    if (fPressed)
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    ImageList_Draw(phd->hFilterImage, 0, hdc, 
                    rc.left+(((rc.right-rc.left)-c_cxFilterImage)/2),
                    rc.top+(((rc.bottom-rc.top)-c_cyFilterImage)/2),
                    ILD_NORMAL);
}

//
//  Oh boy, here come the pictures.
//
//  For a left-justified header item, the items are arranged like this.
//
//          rcHeader.left                           rcHeader.right
//          |        iTextMargin   iTextMargin       |
//          |        ->| |<-        ->| |<-          |
//          |          | |            | |            |
//          v          |<--textSize-->| |            v
//          +----------------------------------------+
//          | |BMPBMP| | |TEXTTEXTTEXT| |            |
//          +----------------------------------------+
//          |<-bmSize->|              | |
//          | |      | |              | |
//        ->| |<-  ->| |<-            | |
//      iBmMargin iBmMargin           | |
//          |                         | |
//          |<-------cxTextAndBm------->|
//
//
//  For a right-justified header item, the items are arranged like this.
//
//          rcHeader.left                           rcHeader.right
//          |        iBmMargin   iBmMargin           |
//          |          ->| |<-  ->| |<-              |
//          |            | |      | |                |
//          v            |<-bmSize->|                v
//          +----------------------------------------+
//          |            | |BMPBMP| | |TEXTTEXTTEXT| |
//          +----------------------------------------+
//                       |          |<---textSize--->|
//                       |          | |            | |
//                       |        ->| |<-        ->| |<-
//                       |      iTextMargin     iTextMargin
//                       |                           |
//                       |<-------cxTextAndBm------->|
//
//  Obvious variations apply to center-justified, bitmap-on-right, etc.
//  The point is that all the sizes are accounted for in the manner above.
//  There are no gratuitous +1's or g_cxEdge's.
//

void Header_DrawItem(HD* phd, HDC hdc, int i, int iIndex, LPRECT prc, UINT uFlags)
{
    RECT rcHeader;      
    RECT rcFilter, rcButton;
    RECT rcText;                        // item text clipping rect
    RECT rcBm;                          // item bitmap clipping rect
    COLORREF clrText;
    COLORREF clrBk;
    DWORD dwRet = CDRF_DODEFAULT;
    HDI* phdi;                      // pointer to current header item
    BOOL fItemSunken;
    HD_ITEM item;                       // used for text callback
    BOOL fTracking = Header_IsTracking(phd);
    UINT uDrawTextFlags;
    NMCUSTOMDRAW nmcd;
    TCHAR ach[CCHLABELMAX];             // used for text callback
    HRGN hrgnClip = NULL;
    HRESULT hr = E_FAIL;
    int iStateId = HIS_NORMAL;

    
    rcHeader = rcFilter = *prc;         // private copies for us to dork

    phdi = Header_GetItemPtrByOrder(phd,i);

    fItemSunken = (fTracking && (phd->flagsTrack & HHT_ONHEADER) &&
                   (phd->iTrack == iIndex) && phd->bTrackPress);

    if (fItemSunken)
    {
        iStateId = HIS_PRESSED;
    }
    else if (iIndex == phd->iHot)
    {
        iStateId = HIS_HOT;
    }

    // Note that SHDT_EXTRAMARGIN requires phd->iTextMargin >= 3*g_cxLabelMargin
    uDrawTextFlags = SHDT_ELLIPSES | SHDT_EXTRAMARGIN | SHDT_CLIPPED;

    if(fItemSunken)
        uDrawTextFlags |= SHDT_DEPRESSED;

    if (phdi->fmt & HDF_OWNERDRAW)
    {
        DRAWITEMSTRUCT dis;

        phd->fOwnerDraw = TRUE;

        dis.CtlType = ODT_HEADER;
        dis.CtlID = GetWindowID(phd->ci.hwnd);
        dis.itemID = iIndex;
        dis.itemAction = ODA_DRAWENTIRE;
        dis.itemState = (fItemSunken) ? ODS_SELECTED : 0;
        dis.hwndItem = phd->ci.hwnd;
        dis.hDC = hdc;
        dis.rcItem = *prc;
        dis.itemData = phdi->lParam;

        // Now send it off to my parent...
        if (SendMessage(phd->ci.hwndParent, WM_DRAWITEM, dis.CtlID,
                        (LPARAM)(DRAWITEMSTRUCT *)&dis))
            goto DrawEdges;  //Ick, but it works
    } 
    else 
    {

        nmcd.dwItemSpec = iIndex;
        nmcd.hdc = hdc;
        nmcd.rc = *prc;
        nmcd.uItemState = (fItemSunken) ? CDIS_SELECTED : 0;
        nmcd.lItemlParam = phdi->lParam;
        if (!(CCGetUIState(&(phd->ci)) & UISF_HIDEFOCUS))
            nmcd.uItemState |= CDIS_SHOWKEYBOARDCUES;
        dwRet = CICustomDrawNotify(&phd->ci, CDDS_ITEMPREPAINT, &nmcd);

        if (dwRet & CDRF_SKIPDEFAULT) 
        {
            return;
        }
    }

    // this is to fetch out any changes the caller might have changed
    clrText = GetTextColor(hdc);
    clrBk = GetBkColor(hdc);
    
    //
    // Now neet to handle the different combinatations of
    // text, bitmaps, and images...
    //

    if ( Header_IsFilter(phd) )
        Header_GetFilterRects(prc, &rcHeader, &rcFilter, &rcButton);

    rcText = rcBm = rcHeader;

    if (phdi->fmt & (HDF_STRING | HDF_IMAGE | HDF_BITMAP)) 
    {
        item.mask = HDI_TEXT | HDI_IMAGE | HDI_FORMAT | HDI_BITMAP;
        item.pszText = ach;
        item.cchTextMax = ARRAYSIZE(ach);
        Header_OnGetItem(phd,iIndex,&item);
    }

    if (phd->hTheme)
    {
        GetThemeBackgroundContentRect(phd->hTheme, hdc, HP_HEADERITEM, iStateId, &rcHeader, &rcText);
        rcBm = rcText;
    }


    //
    // If we have a string and either an image or a bitmap...
    //

    if (phdi->fmt & HDF_STRING && 
        (phdi->fmt & (HDF_BITMAP | HDF_IMAGE) ||
         phdi->fmt & (HDF_SORTUP | HDF_SORTDOWN)))
    {
        // Begin Recompute
        if (phdi->xText == RECOMPUTE || 
            phdi->xBm == RECOMPUTE) 
        {
            BITMAP bm;                          // used to calculate bitmap width
            
            // calculate the placement of bitmap rect and text rect
            SIZE textSize,bmSize;  int dx; 

            // get total textwidth 
            if (phd->hTheme)
            {
                RECT rc = {0};
                RECT rcBound = {0};
                hr = GetThemeTextExtent(phd->hTheme, hdc, HP_HEADERITEM, iStateId, item.pszText, -1, 0, &rcBound, &rc);
                textSize.cx = RECTWIDTH(rc);
                textSize.cy = RECTHEIGHT(rc);
            }

            if (FAILED(hr))
            {
                GetTextExtentPoint(hdc,item.pszText,lstrlen(item.pszText),
                                   &textSize);
            }

            TraceMsg(TF_HEADER, "h_di: GetTextExtentPoint returns %d", textSize.cx);
            textSize.cx += 2 * phd->iTextMargin;

            // get total bitmap width
            if (phdi->fmt & HDF_IMAGE) 
            {
                ImageList_GetIconSize(phd->himl,(LPINT)&bmSize.cx,(LPINT)&bmSize.cy);
            }
            else if (phdi->fmt & (HDF_SORTUP | HDF_SORTDOWN))
            {
                // Make the size of the arrow a square based on height.
                bmSize.cx = textSize.cy + 2 * g_cxEdge;
                bmSize.cy = textSize.cy;
            }
            else
            {  
                // phdi->fmt & HDF_BITMAP
                GetObject(phdi->hbm,sizeof(bm), &bm);
                bmSize.cx = bm.bmWidth;
                TraceMsg(TF_HEADER, "h_di: Bitmap size is %d", bmSize.cx);
            }

            bmSize.cx += 2 * phd->iBmMargin; 

            phdi->cxTextAndBm = bmSize.cx + textSize.cx;

            // calculate how much extra space we have, if any.
            dx = rcHeader.right-rcHeader.left - phdi->cxTextAndBm;
            if (dx < 0)
            {
                dx = 0;
                phdi->cxTextAndBm = rcHeader.right-rcHeader.left;
            }

            if (phdi->fmt & HDF_BITMAP_ON_RIGHT ||
                phdi->fmt & (HDF_SORTUP | HDF_SORTDOWN))        // Sort arrows behave as if on right
            {
                switch (phdi->fmt & HDF_JUSTIFYMASK)
                {
                case HDF_LEFT: 
                    phdi->xText = rcText.left;  
                    break;
                case HDF_RIGHT: 
                    phdi->xText = rcText.right - phdi->cxTextAndBm;
                    break;
                case HDF_CENTER:
                    phdi->xText = rcText.left + dx/2; 
                    break;
                }

                // show as much of the bitmap as possible..
                // if we start running out of room, scoot the bitmap
                // back on.
                if (dx == 0) 
                    phdi->xBm = rcText.right - bmSize.cx;
                else
                    phdi->xBm = phdi->xText + textSize.cx;

                // clip the values
                if (phdi->xBm < rcHeader.left) 
                    phdi->xBm = rcHeader.left;
            }
            else
            { 
                // BITMAP_ON_LEFT
                switch (phdi->fmt & HDF_JUSTIFYMASK) 
                {
                case HDF_LEFT:
                    phdi->xBm = rcBm.left;  
                    break;
                case HDF_RIGHT:
                    phdi->xBm = rcBm.right - phdi->cxTextAndBm;
                    break;
                case HDF_CENTER:
                    phdi->xBm = rcBm.left + dx/2;  
                    break;
                }
                phdi->xText = phdi->xBm + bmSize.cx;
                // clip the values
                if (phdi->xText > rcHeader.right) 
                    phdi->xText = rcHeader.right;
            }

            // xBm and xText are now absolute coordinates..
            // change them to item relative coordinates
            phdi->xBm -= rcHeader.left;
            phdi->xText -= rcHeader.left;
            TraceMsg(TF_HEADER, "h_di: phdi->xBm = %d, phdi->xText=%d",phdi->xBm, phdi->xText );
        }
        // End Recompute


        // calculate text and bitmap rectangles
        rcBm.left = phdi->xBm + rcText.left;
        rcText.left = phdi->xText + rcText.left;

        if (phdi->fmt & HDF_BITMAP_ON_RIGHT ||
            phdi->fmt & (HDF_SORTUP | HDF_SORTDOWN)) 
        {
            rcBm.right = rcText.left + phdi->cxTextAndBm;
            rcText.right = rcBm.left;
        }
        else 
        { 
            // BITMAP_ON_LEFT
            rcBm.right = rcText.left;
            rcText.right = rcBm.left + phdi->cxTextAndBm;
        }
    }

    if (phd->hTheme)
    {
        DrawThemeBackground(phd->hTheme, hdc, HP_HEADERITEM, iStateId, &rcHeader, 0);
    }


    if (phdi->fmt & (HDF_SORTUP | HDF_SORTDOWN))
    {
        BOOL fUpArrow = phdi->fmt & HDF_SORTUP;

        if (phd->hfontSortArrow)
        {
            int cy;
            TEXTMETRIC tm;
            int bkMode = SetBkMode(hdc, TRANSPARENT);
            COLORREF cr = SetTextColor(hdc, g_clrGrayText);
            HFONT hFontOld = SelectObject(hdc, phd->hfontSortArrow);
            GetTextMetrics(hdc, &tm);

            // Set the font height (based on original USER code)
            cy = ((tm.tmHeight + tm.tmExternalLeading + GetSystemMetrics(SM_CYBORDER)) & 0xFFFE) - 1;

            ExtTextOut(hdc, rcBm.left, rcBm.top + (RECTHEIGHT(rcBm) - cy)/ 2, 0, &rcBm, fUpArrow? TEXT("5") : TEXT("6"), 1, NULL);

            SetTextColor(hdc, cr);
            SetBkMode(hdc, bkMode);

            SelectObject(hdc, hFontOld);
        }
    }
    else if (phdi->fmt & HDF_IMAGE || 
             phdi->fmt & HDF_BITMAP)             // If we have a bitmap and/or an image...
    {
        BOOL fDrawBoth = FALSE;
        RECT rcDrawn;
        HRGN hrgn1 = NULL, hrgn2 = NULL;

        int temp;   // used to determine placement of bitmap.

        if (phdi->fmt & HDF_IMAGE && 
            phdi->fmt & HDF_BITMAP) 
        {
            // we have to do both
            fDrawBoth = TRUE;

            // first do just the image... turn off the bitmap bit

            // HACK ALERT! -- Don't call _Header_DrawBitmap with
            //                both the bitmap and image flags on

            // Draw the image...
            item.fmt ^= HDF_BITMAP;    // turn off bitmap bit
        }

        if (!(uFlags & HDDF_NOIMAGE))
        {
            TraceMsg(TF_HEADER, "h_di: about to draw bitmap at rcBm= (%d,%d,%d,%d)",
                rcBm.left, rcBm.top, rcBm.right, rcBm.bottom );
            temp = _Header_DrawBitmap(hdc, phd->himl, &item, &rcBm,
                                      item.fmt & HDF_JUSTIFYMASK, uDrawTextFlags,
                                      &rcDrawn, phd->iBmMargin);
            hrgn1 = CreateRectRgnIndirect(&rcDrawn);
        }
        
        if (fDrawBoth)
        {
            // Tack on the bitmap...
            // Always tack the bitmap on the right of the image and
            // text unless we are right justified.  then, tack it on
            // left.

            item.fmt ^= HDF_BITMAP;    // turn on bitmap bit
            item.fmt ^= HDF_IMAGE;     // and turn off image bit
            if (item.fmt & HDF_RIGHT)
            {
                rcBm.right = temp;

                if (item.fmt & HDF_STRING)
                {
                    rcBm.right = ((rcBm.left < rcText.left) ?
                                  rcBm.left : rcText.left);
                }
                rcBm.left = rcHeader.left;
            }
            else
            {
                rcBm.left = temp;

                if (item.fmt & HDF_STRING)
                {
                    rcBm.left = ((rcBm.right > rcText.right) ? rcBm.right:rcText.right);
                }
                rcBm.right = rcHeader.right;
            }

            if (!(uFlags & HDDF_NOIMAGE)) 
            {
                _Header_DrawBitmap(hdc, phd->himl, &item, &rcBm,
                                   item.fmt & HDF_RIGHT, uDrawTextFlags,
                                   &rcDrawn, phd->iBmMargin);
                hrgn2 = CreateRectRgnIndirect(&rcDrawn);
            }
            
            item.fmt ^= HDF_IMAGE;     // turn on the image bit

        }

        // if there were any regions created, union them together
        if(hrgn1 && hrgn2)
        {
            hrgnClip = CreateRectRgn(0,0,0,0);
            CombineRgn(hrgnClip, hrgn1, hrgn2, RGN_OR);
            DeleteObject(hrgn1);
            DeleteObject(hrgn2);
        } 
        else if (hrgn1)
        {
            hrgnClip = hrgn1;
            hrgn1 = NULL;
        } 
        else if (hrgn2) 
        {
            hrgnClip = hrgn2;
            hrgn2 = NULL;
        }

        // this only happens in the drag/drop case
        if ((uFlags & HDDF_NOIMAGE) && !hrgnClip )
        {
            // this means we didn't draw the images, which means we 
            // don't have the rects for them,
            // which means we need to create a dummy empty hrgnClip;
            hrgnClip = CreateRectRgn(0,0,0,0);
        }
        
        SaveDC(hdc);
    }


    if (phdi->fmt & HDF_STRING)
    {

        if (item.fmt & HDF_RTLREADING)
        {
            uDrawTextFlags |= SHDT_RTLREADING;
        }

        if (phd->hTheme)
        {
            clrBk = CLR_NONE;
        }

        TraceMsg(TF_HEADER, "h_di: about to draw text rcText=(%d,%d,%d,%d)",
            rcText.left, rcText.top, rcText.right, rcText.bottom );
        SHThemeDrawText(phd->hTheme, hdc, HP_HEADERITEM, iStateId, item.pszText, &rcText,
                   item.fmt & HDF_JUSTIFYMASK,
                   uDrawTextFlags, phd->cyChar, phd->cxEllipses,
                   clrText, clrBk);
        if (hrgnClip) 
        {
            // if we're building a clipping region, add the text to it.
            HRGN hrgnText;
            
            hrgnText = CreateRectRgnIndirect(&rcText);
            CombineRgn(hrgnClip, hrgnText, hrgnClip, RGN_OR);
            DeleteObject(hrgnText);            
        }
    } 
    

    if (Header_IsFilter(phd))
    {
        TCHAR szBuffer[32] = {'\0'};
        LPTSTR pBuffer = szBuffer;
        DWORD dwButtonState = DFCS_BUTTONPUSH;

        uDrawTextFlags = SHDT_ELLIPSES | SHDT_EXTRAMARGIN | SHDT_CLIPPED;

        if (item.fmt & HDF_RTLREADING)
            uDrawTextFlags |= SHDT_RTLREADING;
       
        if (phdi->type & HDFT_HASNOVALUE)
        {
            LocalizedLoadString(IDS_ENTERTEXTHERE, szBuffer, ARRAYSIZE(szBuffer));
            clrText = g_clrGrayText;
        }
        else
        {
            clrText = g_clrWindowText;
            switch (phdi->type & HDFT_ISMASK)
            {
                case HDFT_ISSTRING:
                    pBuffer = phdi->textFilter.pszText;
                    break;

                case HDFT_ISNUMBER:
                    wsprintf(szBuffer, TEXT("%d"), phdi->intFilter);
                    break;

                default:
                    ASSERT(FALSE);
                    break;
            }
        }

        SHDrawText(hdc, pBuffer, &rcFilter, 
                   0, uDrawTextFlags, 
                   phd->cyChar, phd->cxEllipses,
                   clrText, g_clrWindow);

        PatBlt(hdc, rcFilter.left, rcFilter.bottom, rcFilter.right-rcFilter.left, c_cyFilterBarEdge, BLACKNESS);
        Header_DrawFilterGlyph(phd, hdc, &rcButton, (i==phd->iButtonDown));
        
        if (hrgnClip) {
            // if we're building a clipping region, add the text to it.
            HRGN hrgnFilter;

            hrgnFilter = CreateRectRgn( rcFilter.left, rcButton.top, rcButton.right, rcButton.bottom );
            CombineRgn(hrgnClip, hrgnFilter, hrgnClip, RGN_OR);
            DeleteObject(hrgnFilter);            
        }

        if ( phd->fFocus && (phd->iFocus == i) && 
            !(CCGetUIState(&(phd->ci)) & UISF_HIDEFOCUS))
        {
            InflateRect(&rcFilter, -g_cxEdge/2, -g_cyEdge/2);
            SetTextColor(hdc, g_clrWindowText);
            DrawFocusRect(hdc, &rcFilter);
        }
    }

    if (hrgnClip) 
    {
        if (!phd->hTheme)
        {
            // hrgnClip is the union of everyplace we've drawn..
            // we want just the opposite.. so xor it
            HRGN hrgnAll = CreateRectRgnIndirect(&rcHeader);
            if (hrgnAll)
            {
                HRGN hrgn = CreateRectRgn(0, 0,0,0);
                if (hrgn)
                {
                    CombineRgn(hrgn, hrgnAll, hrgnClip, RGN_XOR);
               
                    SelectClipRgn(hdc, hrgn);
               
                    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcHeader, NULL, 0, NULL);
                    RestoreDC(hdc, -1);
                    DeleteObject(hrgn);
                }
                DeleteObject(hrgnAll);
            }
        }
        DeleteObject(hrgnClip);
    }

DrawEdges:
    
    if (!phd->hTheme && (!(uFlags & HDDF_NOEDGE) && 
        !(phd->ci.style & HDS_FLAT) || 
        iIndex == phd->iHot))
    {
        Header_DrawButtonEdges(phd, hdc, &rcHeader, fItemSunken);
    }

    if (dwRet & CDRF_NOTIFYPOSTPAINT) 
    {
        CICustomDrawNotify(&phd->ci, CDDS_ITEMPOSTPAINT, &nmcd);
    }
    
}

void Header_Draw(HD* phd, HDC hdc, RECT* prcClip)
{
    int i;                          // index of current header item
    int cItems;                         // number of items in header
    
    RECT rc = { 0 };                            // item clipping rect
    BOOL fTracking;
    HFONT hfontOld = NULL;
    HDC hdcMem = NULL;
    int iIndex;
    NMCUSTOMDRAW nmcd;
    COLORREF clrText;
            
    fTracking = Header_IsTracking(phd);

    if (phd->hfont)
        hfontOld = SelectFont(hdc, phd->hfont);

    cItems = DSA_GetItemCount(phd->hdsaHDI);

    FillRectClr(hdc, prcClip, GetSysColor(COLOR_BTNFACE));

    
    nmcd.hdc = hdc;
    nmcd.uItemState = 0;
    nmcd.lItemlParam = 0;
    nmcd.rc = *prcClip;
    phd->ci.dwCustom = CICustomDrawNotify(&phd->ci, CDDS_PREPAINT, &nmcd);
    
    for (i = 0 ; i < cItems; i++)
    {
        
        iIndex = Header_ItemOrderToIndex(phd, i);
        Header_OnGetItemRect(phd, iIndex, &rc);

        if (prcClip)
        {
            if (rc.right < prcClip->left)
                continue;
            if (rc.left >= prcClip->right)
                break;
        }
        
        if (iIndex == phd->iHot) {
            clrText = GetSysColor(COLOR_HOTLIGHT);
        } else {
            clrText = g_clrBtnText;
        }

        SetTextColor(hdc, clrText);
        SetBkColor(hdc, g_clrBtnFace);
        
        Header_DrawItem(phd, hdc, i, iIndex, &rc, 0);
    }
    
    if (i == cItems) 
    {
        // we got through the loop... now we need to do the blank area on the right
        rc.left = rc.right;
        rc.right = 32000;
        if (phd->hTheme)
        {
            DrawThemeBackground(phd->hTheme, hdc, 0, 0, &rc, 0);
        }
        else if (phd->ci.style & HDS_FLAT)
        {
            FillRectClr(hdc, &rc, g_clrBtnFace);
        }
        else
        {
            Header_DrawButtonEdges(phd, hdc, &rc, FALSE);
        }
    }

    if (!HDDragFullWindows(phd) && fTracking && (phd->flagsTrack & (HHT_ONDIVIDER | HHT_ONDIVOPEN)))
        Header_DrawDivider(phd, phd->xTrack);
    
    // draw the hot divider
    if (phd->iNewOrder != -1) {
        RECT rc;
        COLORREF clrHot = GetSysColor(COLOR_HOTLIGHT);
        
        Header_GetDividerRect(phd, phd->iNewOrder, &rc);
        FillRectClr(hdc, &rc, clrHot);
        
    }

    if (phd->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
        CICustomDrawNotify(&phd->ci, CDDS_POSTPAINT, &nmcd);
    }
    
    if (hfontOld)
	SelectFont(hdc, hfontOld);
}

HIMAGELIST Header_OnCreateDragImage(HD* phd, int i)
{
    HDC hdcMem;
    RECT rc;
    HBITMAP hbmImage = NULL;
    HBITMAP hbmMask = NULL;
    HFONT hfontOld = NULL;
    HIMAGELIST himl = NULL;
    HIMAGELIST himlDither = NULL;
    HBITMAP hbmOld = NULL;
    BOOL bMirroredWnd = (phd->ci.dwExStyle&RTL_MIRRORED_WINDOW);
    int iIndex = Header_ItemOrderToIndex(phd, i);
    
    // IEUNIX : Fixing crash in OE while dragging the message 
    // header.
    if( !Header_OnGetItemRect(phd, iIndex, &rc) )
        goto Bail;

    // draw the header into this bitmap
    OffsetRect(&rc, -rc.left, -rc.top);
    
    if (!(hdcMem = CreateCompatibleDC(NULL)))
        goto Bail;
    
    if (!(hbmImage = CreateColorBitmap(rc.right, rc.bottom)))
        goto Bail;
    if (!(hbmMask = CreateMonoBitmap(rc.right, rc.bottom)))
	goto Bail;

    //
    // Mirror the memory DC so that the transition from
    // mirrored(memDC)->non-mirrored(imagelist DCs)->mirrored(screenDC)
    // is consistent. [samera]
    //
    if (bMirroredWnd) {
        SET_DC_RTL_MIRRORED(hdcMem);
    }

    if (phd->hfont)
        hfontOld = SelectFont(hdcMem, phd->hfont);

    if (!(himl = ImageList_Create(rc.right, rc.bottom, ILC_MASK, 1, 0)))
	goto Bail;

    if (!(himlDither = ImageList_Create(rc.right, rc.bottom, ILC_MASK, 1, 0)))
	goto Bail;
    

    // have the darker background
    SetTextColor(hdcMem, g_clrBtnText);
    SetBkColor(hdcMem, g_clrBtnShadow);
    hbmOld = SelectObject(hdcMem, hbmImage);
    Header_DrawItem(phd, hdcMem, i, iIndex, &rc, HDDF_NOEDGE);

    //
    // If the header is RTL mirrored, then
    // mirror the Memory DC, so that when copying back
    // we don't get any image-flipping. [samera]
    //
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmImage);
    
    // fill the mask with all black
    SelectObject(hdcMem, hbmMask);
    PatBlt(hdcMem, 0, 0, rc.right, rc.bottom, BLACKNESS);
    
    // put the image into an imagelist
    SelectObject(hdcMem, hbmOld);
    ImageList_SetBkColor(himl, CLR_NONE);
    ImageList_Add(himl, hbmImage, hbmMask);


    // have the darker background
    // now put the text in undithered.
    SetTextColor(hdcMem, g_clrBtnText);
    SetBkColor(hdcMem, g_clrBtnShadow);
    hbmOld = SelectObject(hdcMem, hbmImage);
    Header_DrawItem(phd, hdcMem, i, iIndex, &rc, HDDF_NOIMAGE | HDDF_NOEDGE);
    DrawEdge(hdcMem, &rc, EDGE_BUMP, BF_RECT | BF_FLAT);

    //
    // If the header is RTL mirrored, then
    // mirror the Memory DC, so that when copying back
    // we don't get any image-flipping. [samera]
    //
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmImage);

    /*
    // initialize this to transparent
    SelectObject(hdcMem, hbmImage);
    PatBlt(hdcMem, 0, 0, rc.right, rc.bottom, BLACKNESS);
    SelectObject(hdcMem, hbmMask);
    PatBlt(hdcMem, 0, 0, rc.right, rc.bottom, WHITENESS);
    */
    
    SelectObject(hdcMem, hbmOld);
    ImageList_AddMasked(himlDither, hbmImage, g_clrBtnShadow);
    
    // dither image into himlDithered
    ImageList_CopyDitherImage(himlDither, 0, 0, 0, 
                              himl, 0, 0);
    
Bail:
    
    if (himl) 
    {
        ImageList_Destroy(himl);
    }

    if (hdcMem) 
    {
        if (hbmOld) 
            SelectObject(hdcMem, hbmOld);
        if (hfontOld)
            SelectFont(hdcMem, hfontOld);

	    DeleteObject(hdcMem);
    }
    
    if (hbmImage)
	DeleteObject(hbmImage);
    if (hbmMask)
	DeleteObject(hbmMask);
    

    return himlDither;
} 

void Header_GetFilterRects(LPRECT prcItem, LPRECT prcHeader, LPRECT prcFilter, LPRECT prcButton)
{
    INT cyFilter = ((prcItem->bottom-prcItem->top)-c_cyFilterBarEdge)/2;
    *prcButton = *prcFilter = *prcHeader = *prcItem;
    prcHeader->bottom = prcHeader->top + cyFilter;  
    prcButton->left = prcFilter->right = prcFilter->right -= (g_cxBorder*4)+c_cxFilterImage;
    prcButton->top = prcFilter->top = prcHeader->bottom;
    prcFilter->bottom = prcFilter->top + cyFilter;
}

//
// Subclass the edit control to ensure we get the keys we are interested in
//

LRESULT CALLBACK Header_EditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HD* phd = (HD*)GetWindowPtr(GetParent(hwnd), 0);
    ASSERT(phd);

    switch (msg)
    {
        case WM_KILLFOCUS:
            Header_StopFilterEdit(phd, FALSE);
            return 0L;

        case WM_KEYDOWN:
        {
            if (wParam == VK_RETURN) 
            {
                Header_StopFilterEdit(phd, FALSE);
                return 0L;
            } 
            else if (wParam == VK_ESCAPE) 
            {
                Header_StopFilterEdit(phd, TRUE);
                return 0L;
            } 
            else if (wParam == VK_F4 )
            {
                Header_OnFilterButton(phd, phd->iEdit);
                return 0L;
            }
            break;
        }

        case WM_CHAR:
        {
            switch (wParam)
            {
                case VK_RETURN:
                case VK_ESCAPE:
                case VK_TAB:
                    return 0L;                              // eat these so we don't beep
            }
            //notify of navigation key usage
            CCNotifyNavigationKeyUsage(&(phd->ci), UISF_HIDEFOCUS);
            break;
        }

        case WM_GETDLGCODE:
            return DLGC_WANTALLKEYS | DLGC_HASSETSEL;        /* editing name, no dialog handling right now */
    }

    return CallWindowProc(phd->pfnEditWndProc, hwnd, msg, wParam, lParam);
}

//
// Begin to edit the given column, displaying the editor as required
//

BOOL Header_BeginFilterEdit(HD* phd, int i)
{
    RECT rc, rcHeader, rcFilter, rcButton;
    int iIndex = i;
    int cxEdit, cyEdit;
    TCHAR szBuffer[MAX_PATH];
    LPTSTR pBuffer = szBuffer;
    int cchBuffer = MAX_PATH;
    UINT uFlags = WS_CLIPSIBLINGS|WS_VISIBLE|WS_CHILD|ES_AUTOHSCROLL;
    HDI* phdi = Header_GetItemPtr(phd, i);
    
    if ( !phdi || (i < 0) )
        return FALSE;            // yikes

    // lets create an edit control that allows the user to 
    // modify the current filter, note that we first must
    // format the data to be displayed in the control
    
    Header_OnGetItemRect(phd, iIndex, &rc);
    Header_GetFilterRects(&rc, &rcHeader, &rcFilter, &rcButton);

    phd->typeOld = phdi->type;          // keep the type field safe

    switch (phdi->type & HDFT_ISMASK)
    {
        case HDFT_ISSTRING:
            Str_Set(&phd->pszFilterOld, phdi->textFilter.pszText);
            pBuffer = phdi->textFilter.pszText;
            // This count does not include the terminating null
            cchBuffer = phdi->textFilter.cchTextMax;
            break;

        case HDFT_ISNUMBER:
            phd->intFilterOld = phdi->intFilter;
            wsprintf(szBuffer, TEXT("%d"), phdi->intFilter);
            cchBuffer = 11;                                  // 10 digits, plus sign
            uFlags |= ES_NUMBER;
            break;

        default:
            return FALSE;
    }

    cxEdit = (rcFilter.right-rcFilter.left)-(g_cxLabelMargin*6);
    cyEdit = (rcFilter.bottom-rcFilter.top)-(g_cyEdge*2);
    phd->hwndEdit = CreateWindow(TEXT("EDIT"), 
                                 !(phdi->type & HDFT_HASNOVALUE) ? pBuffer:TEXT(""), 
                                 uFlags,
                                 rcFilter.left+(g_cxLabelMargin*3), 
                                 rcFilter.top+g_cyEdge,
                                 cxEdit, cyEdit,
                                 phd->ci.hwnd,
                                 NULL, HINST_THISDLL, NULL);
    if ( phd->hwndEdit ) 
    {
        INT iOldFocus = phd->iFocus;

        //
        // Setup the edit mode for this object?
        //

        phd->iEdit = i;                                 // now editing this column
        phd->iFocus = Header_OnGetItemOrder(phd, i);

        Header_OnGetItemRect(phd,  Header_ItemOrderToIndex(phd, iOldFocus), &rc);                     // nb: iOldFocus
        Header_GetFilterRects(&rc, &rcHeader, &rcFilter, &rcButton);
        RedrawWindow(phd->ci.hwnd, &rcFilter, NULL, RDW_INVALIDATE | RDW_ERASE);

        //
        // Now subclass the edit control so we can trap the keystrokes we are interested in
        //

        phd->pfnEditWndProc = SubclassWindow(phd->hwndEdit, Header_EditWndProc);
        ASSERT(phd->pfnEditWndProc);

        Edit_LimitText(phd->hwndEdit, cchBuffer);
        Edit_SetSel(phd->hwndEdit, 0, -1);
        FORWARD_WM_SETFONT(phd->hwndEdit, phd->hfont, FALSE, SendMessage);

        SetFocus(phd->hwndEdit);
    }

    return(phd->hwndEdit != NULL);
}

//
// Stop editing the fitler, discarding the change if we need to, otherwise
// the item has the correct information stored within it.
//

VOID Header_StopFilterEdit(HD* phd, BOOL fDiscardChanges)
{
    if ( phd->iEdit >= 0 )
    {
        HDI* phdi = Header_GetItemPtr(phd, phd->iEdit);
        HD_ITEM hdi;
        HD_TEXTFILTER textFilter;
        int intFilter;
        ASSERT(phdi);
    
        if ( fDiscardChanges )
        {
            hdi.mask = HDI_FILTER;
            hdi.type = phd->typeOld;

            switch (phdi->type & HDFT_ISMASK)
            {
                case HDFT_ISSTRING:
                    textFilter.pszText = phd->pszFilterOld;
                    textFilter.cchTextMax = phdi->textFilter.cchTextMax;
                    hdi.pvFilter = &textFilter;
                    break;

                case HDFT_ISNUMBER:
                    intFilter = phd->intFilterOld;                    
                    hdi.pvFilter = &intFilter;
                    break;
            }

            Header_OnSetItem(phd, phd->iEdit, &hdi);
        }
        else
        {
            Header_FilterChanged(phd, FALSE);          // ensure we flush the changes        
        }

        if ( phd->hwndEdit )
        {
            SubclassWindow(phd->hwndEdit, phd->pfnEditWndProc);
            DestroyWindow(phd->hwndEdit);
            phd->hwndEdit = NULL;
        }

        phd->iEdit = -1;
        phd->pszFilterOld = NULL;
    }
}

//
// Send a filter change to the parent, either now or wait until the timeout
// expires.  
//
 
VOID Header_FilterChanged(HD* phd, BOOL fWait)
{
    if ( phd->iEdit < 0 )
        return;

    if ( fWait )
    {
        // defering the notify, therefore lets set the timer (killing any
        // previous ones) and marking that we are waiting on it.

        KillTimer(phd->ci.hwnd, HD_EDITCHANGETIMER);
        SetTimer(phd->ci.hwnd, HD_EDITCHANGETIMER, phd->iFilterChangeTimeout, NULL);
        phd->fFilterChangePending = TRUE;
    }
    else
    {
        HDI* phdi = Header_GetItemPtrByOrder(phd, phd->iEdit);            
        ASSERT(phdi);

        // if we have a change notify pending then lets send it to
        // the parent window, otherwise we just swallow it.

        if ( phd->fFilterChangePending )
        {
            TCHAR szBuffer[MAX_PATH];
            HD_ITEM hdi;
            HD_TEXTFILTER textFilter;
            int intFilter;

            KillTimer(phd->ci.hwnd, HD_EDITCHANGETIMER);
            phd->fFilterChangePending = FALSE;
        
            hdi.mask = HDI_FILTER;
            hdi.type = phdi->type & ~HDFT_HASNOVALUE;

            if ( !GetWindowText(phd->hwndEdit, szBuffer, ARRAYSIZE(szBuffer)) )
                hdi.type |= HDFT_HASNOVALUE;
    
            switch (phdi->type & HDFT_ISMASK)
            {
                case HDFT_ISSTRING:
                    textFilter.pszText = szBuffer;
                    textFilter.cchTextMax = phdi->textFilter.cchTextMax;
                    hdi.pvFilter = &textFilter;
                    break;

                case HDFT_ISNUMBER:
                    intFilter = StrToInt(szBuffer);                    
                    hdi.pvFilter = &intFilter;
                    break;
            }

            Header_OnSetItem(phd, phd->iEdit, &hdi);
        }
    }
}

//
// Handle the user displaying the filter menu
//

VOID Header_OnFilterButton(HD* phd, INT i)
{
    NMHDFILTERBTNCLICK fbc;
    RECT rc, rcHeader, rcFilter;

    // filter button being depressed so depress it, then tell the user
    // that it went down so they can display the UI they want, before
    // we pop the button.  if the notify returns TRUE then send
    // a change notify around.

    Header_StopFilterEdit(phd, FALSE);

    ASSERT(phd->iButtonDown == -1);
    phd->iButtonDown = i;

    Header_InvalidateItem(phd, i, RDW_INVALIDATE);
    UpdateWindow(phd->ci.hwnd);

    ZeroMemory(&fbc, SIZEOF(fbc));
    fbc.iItem = i;
    // fbc.rc = { 0, 0, 0, 0 };

    Header_OnGetItemRect(phd, i, &rc);
    Header_GetFilterRects(&rc, &rcHeader, &rcFilter, &fbc.rc);

    if ( CCSendNotify(&phd->ci, HDN_FILTERBTNCLICK, &fbc.hdr) )
        Header_Notify(phd, i, 0, HDN_FILTERCHANGE);
  
    phd->iButtonDown = -1;
    Header_InvalidateItem(phd, i, RDW_INVALIDATE);
    UpdateWindow(phd->ci.hwnd);
}

//
// Handle clearing the filter for the given item
//

LRESULT Header_OnClearFilter(HD* phd, INT i)
{
    HDI* phdi;
    HD_ITEM hdi;
    INT iChanged = 0;
    
    Header_StopFilterEdit(phd, FALSE);

    if ( i == -1 )
    {
        //
        // clear all filters by setting setting the HDFT_HASNOVALUEFLAG on all items
        // remember to release the filter data.  For each item we also send an item
        // changing indicating that the filter is changing and then a item changed
        // to indicat that we really did fix the value.
        //
    
        for ( i = 0 ; i < DSA_GetItemCount(phd->hdsaHDI); i++ )
        {
            phdi = Header_GetItemPtrByOrder(phd, i);            
            ASSERT(phdi);

            if ( !(phdi->type & HDFT_HASNOVALUE) )
            {
                hdi.mask = HDI_FILTER;
                hdi.type = phdi->type|HDFT_HASNOVALUE;
                hdi.pvFilter = NULL;

                if ( Header_SendChange(phd, i, HDN_ITEMCHANGING, &hdi) )
                {
                    if ( (phdi->type & HDFT_ISMASK) == HDFT_ISSTRING )
                        Str_Set(&phdi->textFilter.pszText, NULL);

                    phdi->type |= HDFT_HASNOVALUE;                      // item is now empty

                    Header_SendChange(phd, i, HDN_ITEMCHANGED, &hdi);

                    iChanged++;
                }
            }
        }        

        if ( iChanged )
        {
            //
            // item == -1 indicating that we are cleared all filters, then invalidate
            // the window so that the filter values are no longer visible
            //

    	    Header_Notify(phd, -1, 0, HDN_FILTERCHANGE);	       // send out a notify of change
            RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }
    else
    {
        if ( (i < 0) || (i > DSA_GetItemCount(phd->hdsaHDI)) )
            return 0L;

        phdi = Header_GetItemPtrByOrder(phd, i);            
        ASSERT(phdi);

        if ( !(phdi->type & HDFT_HASNOVALUE) )
        {
            //
            // clear a single filter by setting the HDFT_HASNOVALUE flag 
            //

            hdi.mask = HDI_FILTER;
            hdi.type = phdi->type|HDFT_HASNOVALUE;
            hdi.pvFilter = NULL;

            Header_OnSetItem(phd, i, &hdi);
        }
    }

    return 1L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\fontlink.cpp ===
//---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       fontlink.cpp
//
//  Contents:   Exports that we available in downlevel comctrl. Note that
//              since v6 runs only on Winnt, we don't need the fonl link stuff
//              in this dll any more.
//
//----------------------------------------------------------------------------
#include "ctlspriv.h"
BOOL GetTextExtentPointWrap(HDC hdc, LPCWSTR lpwch, int cch, LPSIZE lpSize)
{
    return GetTextExtentPoint(hdc, lpwch, cch, lpSize);
}

BOOL GetTextExtentPoint32Wrap(HDC hdc, LPCWSTR lpwch, int cch, LPSIZE lpSize)
{
    return GetTextExtentPointWrap(hdc, lpwch, cch, lpSize);
}
 
BOOL ExtTextOutWrap(HDC hdc, int xp, int yp, UINT eto, CONST RECT *lprect, LPCWSTR lpwch, UINT cLen, CONST INT *lpdxp)
{
    return ExtTextOut(hdc, xp, yp, eto, lprect, lpwch, cLen, lpdxp);
}

BOOL GetCharWidthWrap(HDC hdc, UINT uFirstChar, UINT uLastChar, LPINT lpnWidths)
{
    return GetCharWidth(hdc, uFirstChar, uLastChar, lpnWidths);
}

BOOL TextOutWrap(HDC hdc, int xp, int yp, LPCWSTR lpwch, int cLen)
{
    return ExtTextOutWrap(hdc, xp, yp, 0, NULL, lpwch, cLen, NULL);
}    

int  DrawTextExPrivWrap(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, 
                        UINT dwDTformat, LPDRAWTEXTPARAMS lpDTparams)
{
    return DrawTextEx(hdc, lpchText, cchText, lprc, dwDTformat, lpDTparams);
}

int DrawTextWrap(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
{
    return DrawText(hdc, lpchText, cchText, lprc, format);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\hotkey.c ===
/*-----------------------------------------------------------------------
**
** Hotkey.c
**
** Hotkey edit control.
**
**-----------------------------------------------------------------------*/
//
// Win32 REVIEW:
//  See all the Get/SetWindowInt().
//
#include "ctlspriv.h"

#define F_EXT       0x01000000L

#define GWU_VIRTKEY  0
#define GWU_MODS     1*sizeof(ULONG_PTR)
#define GWU_INVALID  2*sizeof(ULONG_PTR)
#define GWU_DEFAULT  3*sizeof(ULONG_PTR)
#define GWU_HFONT    4*sizeof(ULONG_PTR)
#define GWU_YFONT    5*sizeof(ULONG_PTR)
#define GWU_HTHEME   6*sizeof(ULONG_PTR)
#define NUM_WND_EXTRA (GWU_HTHEME+sizeof(ULONG_PTR))

LRESULT CALLBACK HotKeyWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);

BOOL InitHotKeyClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = HotKeyWndProc;
    wc.lpszClassName = s_szHOTKEY_CLASS;
    wc.style         = CS_GLOBALCLASS;
    wc.hInstance     = hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = NUM_WND_EXTRA;

    if (!RegisterClass(&wc) && !GetClassInfo(hInstance, s_szHOTKEY_CLASS, &wc))
        return FALSE;

    return TRUE;
}

const UINT s_Combos[8] = {
                    HKCOMB_NONE,
                    HKCOMB_S,
                    HKCOMB_C,
                    HKCOMB_SC,
                    HKCOMB_A,
                    HKCOMB_SA,
                    HKCOMB_CA,
                    HKCOMB_SCA};

void SetHotKey(HWND hwnd, WORD wVirtKey, WORD wMods, BOOL fSendNotify)
{
    /* don't invalidate if it's the same
     */
    if (wVirtKey == GetWindowInt(hwnd, GWU_VIRTKEY) &&
        wMods == GetWindowInt(hwnd, GWU_MODS))
        return;

    SetWindowInt(hwnd, GWU_VIRTKEY ,wVirtKey);
    SetWindowInt(hwnd, GWU_MODS ,wMods);
    InvalidateRect(hwnd,NULL,TRUE);

    if (fSendNotify) {
        FORWARD_WM_COMMAND(GetParent(hwnd), GetDlgCtrlID(hwnd), hwnd, EN_CHANGE, SendMessage);
    }

    NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, hwnd, OBJID_CLIENT, 0);
}

void GetKeyName(UINT vk, LPTSTR lpsz, BOOL fExt)
{
    LONG scan;

    scan = (LONG)MapVirtualKey(vk,0) << 16;
    if (fExt)
        scan |= F_EXT;

    GetKeyNameText(scan,lpsz,50);
}

void PaintHotKey(register HWND hwnd)
{
    TCHAR sz[128];
    TCHAR szPlus[10];
    int cch;
    register HDC hdc;
    UINT wMods;
    UINT wVirtKey;
    PAINTSTRUCT ps;
    int x, y;
    HANDLE hFont;
    // DWORD dwColor;
    // DWORD dwBkColor;

    LocalizedLoadString(IDS_PLUS, szPlus, ARRAYSIZE(szPlus));

    wVirtKey = (UINT) GetWindowInt(hwnd, GWU_VIRTKEY);
    wMods = (UINT) GetWindowInt(hwnd, GWU_MODS);
    if (wVirtKey || wMods)
    {
        sz[0] = 0;
        cch = 0;
        if (wMods & HOTKEYF_CONTROL)
        {
            GetKeyName(VK_CONTROL, sz, FALSE);
            lstrcat(sz,(LPTSTR)szPlus);
        }
        if (wMods & HOTKEYF_SHIFT)
        {
            GetKeyName(VK_SHIFT, sz+lstrlen(sz), FALSE);
            lstrcat(sz,szPlus);
        }
        if (wMods & HOTKEYF_ALT)
        {
            GetKeyName(VK_MENU, sz+lstrlen(sz), FALSE);
            lstrcat(sz,szPlus);
        }

        GetKeyName(wVirtKey, sz+lstrlen(sz), wMods & HOTKEYF_EXT);
    }
    else
        LocalizedLoadString(IDS_NONE,sz,100);

    cch = lstrlen(sz);

    HideCaret(hwnd);

    InvalidateRect(hwnd, NULL, TRUE);
    hdc = BeginPaint(hwnd,&ps);


    hFont = SelectObject(hdc, (HFONT)GetWindowInt(hwnd,GWU_HFONT));

    x = g_cxBorder;
    y = g_cyBorder;

    if (IsWindowEnabled(hwnd))
    {
        SetBkColor(hdc, g_clrWindow);
        SetTextColor(hdc, g_clrWindowText);
        TextOut(hdc,x,y,sz,cch);
    }
    else
    {
        // set the background color to Grayed like edit controls
        SetBkColor(hdc, g_clrBtnFace);
        if (g_clrGrayText)
        {
            SetTextColor(hdc,g_clrGrayText);
            TextOut(hdc,x,y,sz,cch);
        }
        else
        {
            GrayString(hdc,NULL,NULL,(ULONG_PTR)(LPTSTR)sz,cch,x,y,0,0);
        }
    }

    MGetTextExtent(hdc, sz, cch, &x, NULL);
     if (GetFocus() == hwnd)
         SetCaretPos(x+g_cxBorder,
                    g_cyBorder);
    ShowCaret(hwnd);

    EndPaint(hwnd,&ps);
}

void HKMSetRules(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    SetWindowInt(hwnd, GWU_INVALID, wParam);
    SetWindowInt(hwnd, GWU_DEFAULT, lParam);
}

HFONT HKMSetFont(HWND hwnd, HFONT wParam)
{
    HFONT lParam;
    HDC hdc;
    INT cy;

    lParam = (HFONT)GetWindowInt(hwnd,GWU_HFONT);
    SetWindowInt(hwnd,GWU_HFONT,(LONG_PTR)wParam);
    hdc = GetDC(hwnd);
    if (wParam)
        wParam = SelectObject(hdc, wParam);
    MGetTextExtent(hdc, TEXT("C"), 1, NULL, &cy);
    SetWindowInt(hwnd,GWU_YFONT,cy);
    if (wParam)
        SelectObject(hdc, wParam);
    ReleaseDC(hwnd,hdc);
    InvalidateRect(hwnd,NULL,TRUE);
    return lParam;
}

LRESULT CALLBACK HotKeyWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    WORD wVirtKey;
    WORD wMods;
    RECT rc;
    HDC hdc;

    switch (wMsg)
    {
    case WM_NCCREATE:
        SetWindowBits(hwnd, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);
        InitGlobalColors();
        return TRUE;

    case WM_CREATE:
        {
            HTHEME hTheme;
            SetHotKey(hwnd, 0, 0, FALSE);
            HKMSetRules(hwnd, 0, 0);
            HKMSetFont(hwnd, g_hfontSystem);
            hTheme = OpenThemeData(hwnd, L"Combobox");
            if (hTheme)
                SetWindowLongPtr(hwnd, GWU_HTHEME, (ULONG_PTR)hTheme);
        }
        break;

    case WM_DESTROY:
        {
            HTHEME hTheme = (HTHEME)GetWindowLongPtr(hwnd, GWU_HTHEME);
            if (hTheme)
                CloseThemeData(hTheme);
        }
        break;

    case WM_NCPAINT:
        {
            HTHEME hTheme = (HTHEME)GetWindowLongPtr(hwnd, GWU_HTHEME);
            if (hTheme)
            {
                HRGN hrgn = (wParam != 1) ? (HRGN)wParam : NULL;
                HBRUSH hbr = (HBRUSH)GetClassLongPtr(hwnd, GCLP_HBRBACKGROUND);

                if (CCDrawNonClientTheme(hTheme, hwnd, hrgn, hbr, 0, CBXS_NORMAL))
                {
                    break;
                }
            }
        }
        goto DoDefault;

    case WM_THEMECHANGED:
        {
            HTHEME hTheme = (HTHEME)GetWindowLongPtr(hwnd, GWU_HTHEME);
            if (hTheme)
                CloseThemeData(hTheme);
                
            hTheme = OpenThemeData(hwnd, L"Combobox");

            SetWindowLongPtr(hwnd, GWU_HTHEME, (ULONG_PTR)hTheme);    // Set a NULL if OpenThemeData fails
        }
        break;



    case WM_SETFOCUS:
        InvalidateRect(hwnd,NULL,TRUE);
        CreateCaret(hwnd,NULL,0,(int)GetWindowInt(hwnd,GWU_YFONT));
        ShowCaret(hwnd);
        break;

    case WM_KILLFOCUS:
        if (!GetWindowInt(hwnd, GWU_VIRTKEY))
        SetHotKey(hwnd, 0, 0, TRUE);
        DestroyCaret();
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTCHARS | DLGC_WANTARROWS; // | DLGC_WANTALLKEYS;

    case HKM_SETHOTKEY:
        SetHotKey(hwnd, LOBYTE(wParam), HIBYTE(wParam), FALSE);
        break;

    case HKM_GETHOTKEY:
        return (256*(BYTE)GetWindowInt(hwnd, GWU_MODS)) +
                ((BYTE)GetWindowInt(hwnd, GWU_VIRTKEY));
        break;

    case HKM_SETRULES:
        HKMSetRules(hwnd, wParam, LOWORD(lParam));
        break;

    case WM_LBUTTONDOWN:
        SetFocus(hwnd);
        break;

    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_RETURN:
        case VK_TAB:
        case VK_SPACE:
        case VK_DELETE:
        case VK_ESCAPE:
        case VK_BACK:
        case VK_LWIN:
        case VK_RWIN:
        case VK_APPS:
            SetHotKey(hwnd, 0, 0, TRUE);
            return DefWindowProc(hwnd,wMsg,wParam,lParam);

        case VK_MENU:
        case VK_SHIFT:
        case VK_CONTROL:
            wVirtKey = 0;
            goto SetNewHotKey;

        default:
            wVirtKey = (WORD) wParam;
SetNewHotKey:
            wMods = 0;
            if (GetKeyState(VK_CONTROL) < 0)
                wMods |= HOTKEYF_CONTROL;
            if (GetKeyState(VK_SHIFT) < 0)
                wMods |= HOTKEYF_SHIFT;
            if (GetKeyState(VK_MENU) < 0)
                wMods |= HOTKEYF_ALT;

            #define IsFUNKEY(vk) ((vk) >= VK_F1 && (vk) <= VK_F24)
            #define IsNUMKEY(vk) ((vk) >= VK_NUMPAD0 && (vk) <= VK_DIVIDE)

            //
            //  dont enforce any rules on the Function keys or
            //  on the number pad keys.
            //
            // if this combination is invalid, use the default
            if (!IsFUNKEY(wVirtKey) &&
                !IsNUMKEY(wVirtKey) &&
                (s_Combos[wMods] & GetWindowInt(hwnd, GWU_INVALID)))
            {
                wMods = (WORD)GetWindowInt(hwnd, GWU_DEFAULT);
            }

            if (lParam & F_EXT)
                wMods |= HOTKEYF_EXT;

            SetHotKey(hwnd, wVirtKey, wMods, TRUE);
            break;
        }
        break;

    case WM_SYSKEYUP:
    case WM_CHAR:
    case WM_SYSCHAR:
    case WM_KEYUP:
        if (!GetWindowInt(hwnd, GWU_VIRTKEY))
            SetHotKey(hwnd, 0, 0, TRUE);
        break;

    case WM_GETFONT:
        return GetWindowInt(hwnd,GWU_HFONT);

    case WM_SETFONT:
        return (LRESULT)(UINT_PTR)HKMSetFont(hwnd, (HFONT)wParam);

    case WM_PAINT:
        PaintHotKey(hwnd);
        break;

    case WM_ERASEBKGND:
        HideCaret(hwnd);
        hdc = GetDC(hwnd);
        GetClientRect(hwnd, &rc);
        if (IsWindowEnabled(hwnd)) {
            FillRect(hdc, &rc, g_hbrWindow);
        } else {
            FillRect(hdc, &rc, g_hbrBtnFace);
        }
        ReleaseDC(hwnd, hdc);
        // lParam = DefWindowProc(hwnd,wMsg,wParam,lParam);
        ShowCaret(hwnd);
        return TRUE;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_HOTKEY;
        goto DoDefault;

    case WM_ENABLE:
        InvalidateRect(hwnd, NULL, TRUE);
        goto DoDefault;

    default:
DoDefault:
        return DefWindowProc(hwnd,wMsg,wParam,lParam);
    }
    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\image.cpp ===
#include "ctlspriv.h"
#include "image.h"
#include "math.h"

#ifndef AC_MIRRORBITMAP
#define AC_MIRRORBITMAP  0          // BUGBUG: Remove me
#endif

void ImageList_DeleteDragBitmaps();

BOOL ImageList_SetDragImage(HIMAGELIST piml, int i, int dxHotspot, int dyHotspot);

HDC g_hdcSrc = NULL;
HBITMAP g_hbmSrc = NULL;
HBITMAP g_hbmDcDeselect = NULL;

HDC g_hdcDst = NULL;
HBITMAP g_hbmDst = NULL;
int g_iILRefCount = 0;

HRESULT WINAPI HIMAGELIST_QueryInterface(HIMAGELIST himl, REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (himl)
    {
        // First Convert the HIMAGELIST to an IUnknown.
        IUnknown* punk = reinterpret_cast<IUnknown*>(himl);

        // Now, we need to validate the object. CImageListBase contains the goo needed to figure out if this
        // is a valid imagelist.
        CImageListBase* pval = FindImageListBase(punk);

        // Now we call some private member.
        if (pval->IsValid())
        {
            // If it's valid then we can QI safely.
            return punk->QueryInterface(riid, ppv);
        }
    }

    return E_POINTER;
}

HRESULT WimpyDrawEx(IImageList* pux, int i, HDC hdcDst, int x, int y, int cx, int cy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle)
{
    IMAGELISTDRAWPARAMS imldp = {0};

    imldp.cbSize = sizeof(imldp);
    imldp.himl   = reinterpret_cast<HIMAGELIST>(pux);
    imldp.i      = i;
    imldp.hdcDst = hdcDst;
    imldp.x      = x;
    imldp.y      = y;
    imldp.cx     = cx;
    imldp.cy     = cy;
    imldp.rgbBk  = rgbBk;
    imldp.rgbFg  = rgbFg;
    imldp.fStyle = fStyle;
    imldp.dwRop  = SRCCOPY;
    
    return pux->Draw(&imldp);
}

HRESULT WimpyDraw(IImageList* pux, int i, HDC hdcDst, int x, int y, UINT fStyle)
{
    IMAGELISTDRAWPARAMS imldp = {0};

    imldp.cbSize = sizeof(imldp);
    imldp.himl   = reinterpret_cast<HIMAGELIST>(pux);
    imldp.i      = i;
    imldp.hdcDst = hdcDst;
    imldp.x      = x;
    imldp.y      = y;
    imldp.rgbBk  = CLR_DEFAULT;
    imldp.rgbFg  = CLR_DEFAULT;
    imldp.fStyle = fStyle;
    imldp.dwRop  = SRCCOPY;
    
    return pux->Draw(&imldp);
}



CImageList::CImageList() : _cRef(1)
{
}

CImageList::~CImageList()
{
    if (_pimlMirror)
    {
        _pimlMirror->Release();
    }

    _Destroy();
}


DWORD CImageList::_GetItemFlags(int i)
{
    DWORD dw = 0;

    // NOTE: Currently we only add the flags in 32bit mode. If needed, you have
    // to modify ::Load in order to add items during a load. I'm just lazy
    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
        DSA_GetItem(_dsaFlags, i, &dw);
    return dw;
}

void CImageList::SetItemFlags(int i, DWORD dwFlags)
{
    if (_dsaFlags)
        DSA_SetItem(_dsaFlags, i, &dwFlags);
}


HRESULT CImageList::Initialize(int cxI, int cyI, UINT flagsI, int cInitialI, int cGrowI)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (cGrowI < 4)
    {
        cGrowI = 4;
    }
    else 
    {
        // round up by 4's
        cGrowI = (cGrowI + 3) & ~3;
    }
    _cStrip = 1;
    _cGrow = cGrowI;
    _cx = cxI;
    _cy = cyI;
    _clrBlend = CLR_NONE;
    _clrBk = CLR_NONE;
    _hbrBk = (HBRUSH)GetStockObject(BLACK_BRUSH);
    _fSolidBk = TRUE;
    _flags = flagsI;
    _pimlMirror = NULL;        

    //
    // Initialize the overlay indexes to -1 since 0 is a valid index.
    //

    for (int i = 0; i < NUM_OVERLAY_IMAGES; i++) 
    {
        _aOverlayIndexes[i] = -1;
    }

    _hdcImage = CreateCompatibleDC(NULL);

    if (_hdcImage)
    {
        hr = S_OK;
        if (_flags & ILC_MASK)
        {
            _hdcMask = CreateCompatibleDC(NULL);

            if (!_hdcMask)
                hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            hr = _ReAllocBitmaps(cInitialI + 1);
            if (FAILED(hr))
            {
                hr = _ReAllocBitmaps(2);
            }
        }
    }

    // Don't do this if we are already initialized, we just want to pass new information....
    if (!_fInitialized)
        g_iILRefCount++;

    _fInitialized = TRUE;

    return hr;
}


HRESULT CImageList::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CImageList, IImageListPriv),
        QITABENT(CImageList, IImageList),
        QITABENT(CImageList, IImageListPersistStream),
        QITABENT(CImageList, IPersistStream),
        QITABENTMULTI(CImageList, IPersist, IPersistStream),
        { 0 },
    };
    return QISearch(this, (LPCQITAB)qit, riid, ppv);
}

ULONG CImageList::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CImageList::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CImageList::GetPrivateGoo(HBITMAP* phbmp, HDC* phdc, HBITMAP* phbmpMask, HDC* phdcMask)
{
    if (phbmp)
        *phbmp = _hbmImage;

    if (phdc)
        *phdc = _hdcImage;

    if (phbmpMask)
        *phbmpMask = _hbmMask;

    if (phdcMask)
        *phdcMask = _hdcMask;

    return S_OK;
}

HRESULT CImageList::GetMirror(REFIID riid, void** ppv)
{
    if (_pimlMirror)
        return _pimlMirror->QueryInterface(riid, ppv);

    return E_NOINTERFACE;
}

//
// global work buffer, this buffer is always a DDB never a DIBSection
//
HBITMAP g_hbmWork = NULL;                   // work buffer.
BITMAP  g_bmWork = {0};                     // work buffer size

HBRUSH g_hbrMonoDither = NULL;              // gray dither brush for dragging
HBRUSH g_hbrStripe = NULL;

#define NOTSRCAND       0x00220326L
#define ROP_PSo         0x00FC008A
#define ROP_DPo         0x00FA0089
#define ROP_DPna        0x000A0329
#define ROP_DPSona      0x00020c89
#define ROP_SDPSanax    0x00E61ce8
#define ROP_DSna        0x00220326
#define ROP_PSDPxax     0x00b8074a

#define ROP_PatNotMask  0x00b8074a      // D <- S==0 ? P : D
#define ROP_PatMask     0x00E20746      // D <- S==1 ? P : D
#define ROP_MaskPat     0x00AC0744      // D <- P==1 ? D : S

#define ROP_DSo         0x00EE0086L
#define ROP_DSno        0x00BB0226L
#define ROP_DSa         0x008800C6L

static int g_iDither = 0;

void InitDitherBrush()
{
    HBITMAP hbmTemp;
    static const WORD graybits[] = {0xAAAA, 0x5555, 0xAAAA, 0x5555,
                       0xAAAA, 0x5555, 0xAAAA, 0x5555};

    if (g_iDither) 
    {
        g_iDither++;
    } 
    else 
    {
        // build the dither brush.  this is a fixed 8x8 bitmap
        hbmTemp = CreateBitmap(8, 8, 1, 1, graybits);
        if (hbmTemp)
        {
            // now use the bitmap for what it was really intended...
            g_hbrMonoDither = CreatePatternBrush(hbmTemp);
            DeleteObject(hbmTemp);
            g_iDither++;
        }
    }
}

void TerminateDitherBrush()
{
    g_iDither--;
    if (g_iDither == 0) 
    {
        DeleteObject(g_hbrMonoDither);
        g_hbrMonoDither = NULL;
    }
}

/*
** GetScreenDepth()
*/
int GetScreenDepth()
{
    int i;
    HDC hdc = GetDC(NULL);
    i = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
    ReleaseDC(NULL, hdc);
    return i;
}

//
// should we use a DIB section on the current device?
//
// the main goal of using DS is to save memory, but they draw slow
// on some devices.
//
// 4bpp Device (ie 16 color VGA)    dont use DS
// 8bpp Device (ie 256 color SVGA)  use DS if DIBENG based.
// >8bpp Device (ie 16bpp 24bpp)    always use DS, saves memory
//

#define CAPS1           94          /* other caps */
#define C1_DIBENGINE    0x0010      /* DIB Engine compliant driver          */

//
// create a bitmap compatible with the given ImageList
//
HBITMAP CImageList::_CreateBitmap(int cx, int cy, RGBQUAD** ppargb)
{
    HDC hdc;
    HBITMAP hbm;

    struct 
    {
        BITMAPINFOHEADER bi;
        DWORD            ct[256];
    } dib;

    hdc = GetDC(NULL);

    // no color depth was specifed
    //
    // if we are on a DIBENG based DISPLAY, we use 4bit DIBSections to save
    // memory.
    //
    if ((_flags & ILC_COLORMASK) == 0)
    {
        _flags |= ILC_COLOR4;
    }

    if ((_flags & ILC_COLORMASK) != ILC_COLORDDB)
    {
        dib.bi.biSize            = sizeof(BITMAPINFOHEADER);
        dib.bi.biWidth           = cx;
        dib.bi.biHeight          = cy;
        dib.bi.biPlanes          = 1;
        dib.bi.biBitCount        = (_flags & ILC_COLORMASK);
        dib.bi.biCompression     = BI_RGB;
        dib.bi.biSizeImage       = 0;
        dib.bi.biXPelsPerMeter   = 0;
        dib.bi.biYPelsPerMeter   = 0;
        dib.bi.biClrUsed         = 16;
        dib.bi.biClrImportant    = 0;
        dib.ct[0]                = 0x00000000;    // 0000  black
        dib.ct[1]                = 0x00800000;    // 0001  dark red
        dib.ct[2]                = 0x00008000;    // 0010  dark green
        dib.ct[3]                = 0x00808000;    // 0011  mustard
        dib.ct[4]                = 0x00000080;    // 0100  dark blue
        dib.ct[5]                = 0x00800080;    // 0101  purple
        dib.ct[6]                = 0x00008080;    // 0110  dark turquoise
        dib.ct[7]                = 0x00C0C0C0;    // 1000  gray
        dib.ct[8]                = 0x00808080;    // 0111  dark gray
        dib.ct[9]                = 0x00FF0000;    // 1001  red
        dib.ct[10]               = 0x0000FF00;    // 1010  green
        dib.ct[11]               = 0x00FFFF00;    // 1011  yellow
        dib.ct[12]               = 0x000000FF;    // 1100  blue
        dib.ct[13]               = 0x00FF00FF;    // 1101  pink (magenta)
        dib.ct[14]               = 0x0000FFFF;    // 1110  cyan
        dib.ct[15]               = 0x00FFFFFF;    // 1111  white

        if (dib.bi.biBitCount == 8)
        {
            HPALETTE hpal;
            int i;

            if (hpal = CreateHalftonePalette(NULL))
            {
                i = GetPaletteEntries(hpal, 0, 256, (LPPALETTEENTRY)&dib.ct[0]);
                DeleteObject(hpal);

                if (i > 64)
                {
                    dib.bi.biClrUsed = i;
                    for (i=0; i<(int)dib.bi.biClrUsed; i++)
                        dib.ct[i] = RGB(GetBValue(dib.ct[i]),GetGValue(dib.ct[i]),GetRValue(dib.ct[i]));
                }
            }
            else
            {
                dib.bi.biBitCount = (_flags & ILC_COLORMASK);
                dib.bi.biClrUsed = 256;
            }

            if (dib.bi.biClrUsed <= 16)
                dib.bi.biBitCount = 4;
        }

        hbm = CreateDIBSection(hdc, (LPBITMAPINFO)&dib, DIB_RGB_COLORS, (PVOID*)ppargb, NULL, 0);
    }
    else
    {
        hbm = CreateCompatibleBitmap(hdc, cx, cy);
    }

    ReleaseDC(NULL, hdc);

    return hbm;
}

EXTERN_C HBITMAP CreateColorBitmap(int cx, int cy)
{
    HBITMAP hbm;
    HDC hdc;

    hdc = GetDC(NULL);

    //
    // on a multimonitor system with mixed bitdepths
    // always use a 32bit bitmap for our work buffer
    // this will prevent us from losing colors when
    // blting to and from the screen.  this is mainly
    // important for the drag & drop offscreen buffers.
    //
    if (!(GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) &&
        GetSystemMetrics(SM_CMONITORS) > 1 &&
        GetSystemMetrics(SM_SAMEDISPLAYFORMAT) == 0)
    {
        void* p;
        BITMAPINFO bi = {sizeof(BITMAPINFOHEADER), cx, cy, 1, 32};
        hbm = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, &p, NULL, 0);
    }
    else
    {
        hbm = CreateCompatibleBitmap(hdc, cx, cy);
    }

    ReleaseDC(NULL, hdc);
    return hbm;
}

HBITMAP CreateDIB(HDC h, int cx, int cy, RGBQUAD** pprgb)
{
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    return CreateDIBSection(h, &bi, DIB_RGB_COLORS, (void**)pprgb, NULL, 0);
}

BOOL DIBHasAlpha(int cx, int cy, RGBQUAD* prgb)
{
    int cTotal = cx * cy;
    for (int i = 0; i < cTotal; i++)
    {
        if (prgb[i].rgbReserved != 0)
            return TRUE;
    }

    return FALSE;
}

void PreProcessDIB(int cx, int cy, RGBQUAD* pargb)
{
    int cTotal = cx * cy;
    for (int i = 0; i < cTotal; i++)
    {
        RGBQUAD* prgb = &pargb[i];
        if (prgb->rgbReserved != 0)
        {
            prgb->rgbRed      = ((prgb->rgbRed   * prgb->rgbReserved) + 128) / 255;
            prgb->rgbGreen    = ((prgb->rgbGreen * prgb->rgbReserved) + 128) / 255;
            prgb->rgbBlue     = ((prgb->rgbBlue  * prgb->rgbReserved) + 128) / 255;
        }
        else
        {
            *((DWORD*)prgb) = 0;
        }
    }
}

EXTERN_C HBITMAP CreateMonoBitmap(int cx, int cy)
{
#ifdef MONO_DIB
    struct 
    {
        BITMAPINFOHEADER bi;
        DWORD            ct[2];
    } dib = {0};
    dib.bi.biSize = sizeof(dib.bi);
    dib.bi.biWidth = cx;
    dib.bi.biHeight = cy;
    dib.bi.biPlanes = 1;
    dib.bi.biBitCount = 1;
    dib.bi.biCompression = BI_RGB;
    dib.ct[0] = 0x00000000;
    dib.ct[1] = 0x00ffffff;

    HBITMAP hbmp = NULL;
    HDC hdc = CreateCompatibleDC(NULL);
    if (hdc)
    {
        hbmp = CreateDIBSection(hdc, (BITMAPINFO*)&dib, DIB_PAL_COLORS, NULL, NULL, 0);
        DeleteDC(hdc);
    }

    return hbmp;
#else
    return CreateBitmap(cx, cy, 1, 1, NULL);
#endif
}

//============================================================================

BOOL CImageList::GlobalInit(void)
{
    HDC hdcScreen;
    static const WORD stripebits[] = {0x7777, 0xdddd, 0x7777, 0xdddd,
                         0x7777, 0xdddd, 0x7777, 0xdddd};
    HBITMAP hbmTemp;

    TraceMsg(TF_IMAGELIST, "CImageList::GlobalInit");

    // if already initialized, there is nothing to do
    if (g_hdcDst)
        return TRUE;

    hdcScreen = GetDC(HWND_DESKTOP);

    g_hdcSrc = CreateCompatibleDC(hdcScreen);
    g_hdcDst = CreateCompatibleDC(hdcScreen);

    InitDitherBrush();

    hbmTemp = CreateBitmap(8, 8, 1, 1, stripebits);
    if (hbmTemp)
    {
        // initialize the deselect 1x1 bitmap
        g_hbmDcDeselect = SelectBitmap(g_hdcDst, hbmTemp);
        SelectBitmap(g_hdcDst, g_hbmDcDeselect);

        g_hbrStripe = CreatePatternBrush(hbmTemp);
        DeleteObject(hbmTemp);
    }

    ReleaseDC(HWND_DESKTOP, hdcScreen);

    if (!g_hdcSrc || !g_hdcDst || !g_hbrMonoDither)
    {
        CImageList::GlobalUninit();
        TraceMsg(TF_ERROR, "ImageList: Unable to initialize");
        return FALSE;
    }
    return TRUE;
}

void CImageList::GlobalUninit()
{
    TerminateDitherBrush();

    if (g_hbrStripe)
    {
        DeleteObject(g_hbrStripe);
        g_hbrStripe = NULL;
    }

    ImageList_DeleteDragBitmaps();

    if (g_hdcDst)
    {
        CImageList::SelectDstBitmap(NULL);
        DeleteDC(g_hdcDst);
        g_hdcDst = NULL;
    }

    if (g_hdcSrc)
    {
        CImageList::SelectSrcBitmap(NULL);
        DeleteDC(g_hdcSrc);
        g_hdcSrc = NULL;
    }

    if (g_hbmWork)
    {
        DeleteBitmap(g_hbmWork);
        g_hbmWork = NULL;
    }
}

void CImageList::SelectDstBitmap(HBITMAP hbmDst)
{
    ASSERTCRITICAL;

    if (hbmDst != g_hbmDst)
    {
        // If it's selected in the source DC, then deselect it first
        //
        if (hbmDst && hbmDst == g_hbmSrc)
            CImageList::SelectSrcBitmap(NULL);

        SelectBitmap(g_hdcDst, hbmDst ? hbmDst : g_hbmDcDeselect);
        g_hbmDst = hbmDst;
    }
}

void CImageList::SelectSrcBitmap(HBITMAP hbmSrc)
{
    ASSERTCRITICAL;

    if (hbmSrc != g_hbmSrc)
    {
        // If it's selected in the dest DC, then deselect it first
        //
        if (hbmSrc && hbmSrc == g_hbmDst)
            CImageList::SelectDstBitmap(NULL);

        SelectBitmap(g_hdcSrc, hbmSrc ? hbmSrc : g_hbmDcDeselect);
        g_hbmSrc = hbmSrc;
    }
}

HDC ImageList_GetWorkDC(HDC hdc, BOOL f32bpp, int dx, int dy)
{
    ASSERTCRITICAL;
    int iDepth = GetDeviceCaps(hdc, BITSPIXEL);

    if (g_hbmWork == NULL ||
        iDepth != g_bmWork.bmBitsPixel ||
        g_bmWork.bmWidth  != dx || 
        g_bmWork.bmHeight != dy ||
        (f32bpp && iDepth != 32))
    {
        CImageList::_DeleteBitmap(g_hbmWork);
        g_hbmWork = NULL;

        if (dx == 0 || dy == 0)
            return NULL;

        if (f32bpp)
            g_hbmWork = CreateDIB(hdc, dx, dy, NULL);
        else
            g_hbmWork = CreateCompatibleBitmap(hdc, dx, dy);

        if (g_hbmWork)
        {
            GetObject(g_hbmWork, sizeof(g_bmWork), &g_bmWork);
        }
    }

    CImageList::SelectSrcBitmap(g_hbmWork);

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        HPALETTE hpal = (HPALETTE)SelectPalette(hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
        SelectPalette(g_hdcSrc, hpal, TRUE);
    }

    return g_hdcSrc;
}

void ImageList_ReleaseWorkDC(HDC hdc)
{
    ASSERTCRITICAL;
    ASSERT(hdc == g_hdcSrc);

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        SelectPalette(hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
    }
}

void CImageList::_DeleteBitmap(HBITMAP hbm)
{
    ASSERTCRITICAL;
    if (hbm)
    {
        if (g_hbmDst == hbm)
            CImageList::SelectDstBitmap(NULL);
        if (g_hbmSrc == hbm)
            CImageList::SelectSrcBitmap(NULL);
        DeleteBitmap(hbm);
    }
}


#define ILC_WIN95   (ILC_MASK | ILC_COLORMASK | ILC_SHARED | ILC_PALETTE)


//============================================================================

HRESULT CImageList::InitGlobals()
{
    HRESULT hr = S_OK;
    ENTERCRITICAL;
    if (!g_iILRefCount)
    {
        if (!CImageList::GlobalInit())
        {
            hr = E_OUTOFMEMORY;
        }
    }
    LEAVECRITICAL;

    return S_OK;
}

CImageList* CImageList::Create(int cx, int cy, UINT flags, int cInitial, int cGrow)
{
    CImageList* piml = NULL;
    HRESULT hr = S_OK;

    if (cx < 0 || cy < 0)
        return NULL;

    // Validate the flags
    if (flags & ~ILC_VALID)
        return NULL;

    hr = InitGlobals();


    ENTERCRITICAL;

    if (SUCCEEDED(hr))
    {
        piml = new CImageList();

        // allocate the bitmap PLUS one re-usable entry
        if (piml)
        {
            hr = piml->Initialize(cx, cy, flags, cInitial, cGrow);
            if (FAILED(hr))
            {
                piml->Release();
                piml = NULL;
            }
        }
    }

    LEAVECRITICAL;

    return piml;
}



void CImageList::_Destroy()
{
    ENTERCRITICAL;
    // nuke dc's
    if (_hdcImage)
    {
        SelectObject(_hdcImage, g_hbmDcDeselect);
        DeleteDC(_hdcImage);
    }
    if (_hdcMask)
    {
        SelectObject(_hdcMask, g_hbmDcDeselect);
        DeleteDC(_hdcMask);
    }

    // nuke bitmaps
    if (_hbmImage)
        _DeleteBitmap(_hbmImage);

    if (_hbmMask)
        _DeleteBitmap(_hbmMask);

    if (_hbrBk)
        DeleteObject(_hbrBk);

    //Clean up DSA
    if (_dsaFlags)
        DSA_Destroy(_dsaFlags);

    if (_fInitialized)
    {
        // one less use of imagelists.  if it's the last, terminate the imagelist
        g_iILRefCount--;
        if (!g_iILRefCount)
            CImageList::GlobalUninit();
    }
    LEAVECRITICAL;
}

HRESULT CImageList::GetImageCount(int* pi)
{
    *pi = _cImage;

    return S_OK;
}

HRESULT CImageList::SetImageCount(UINT uAlloc)
{
    ENTERCRITICAL;
    HRESULT hr = _ReAllocBitmaps(-((int)uAlloc + 2));   // Two because we need a spare image
    if (SUCCEEDED(hr))
    {
        _cImage = (int)uAlloc;
    }
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::GetIconSize(int* pcx, int* pcy)
{
    if (!pcx || !pcy)
        return E_INVALIDARG;

    *pcx = _cx;
    *pcy = _cy;

    return S_OK;
}

//
//  change the size of a existing image list
//  also removes all items
//
HRESULT CImageList::_SetIconSize(int cxImage, int cyImage)
{
    if (_cx == cxImage && _cy == cyImage)
        return S_FALSE;       // no change

    if (_cx < 0 || _cy < 0)
        return E_INVALIDARG;       // invalid dimensions

    _cx = cxImage;
    _cy = cyImage;

    return Remove(-1);
}

HRESULT CImageList::SetIconSize(int cxImage, int cyImage)
{
   if (_pimlMirror)
   {
       _pimlMirror->_SetIconSize(cxImage, cyImage);
   }

   return _SetIconSize(cxImage, cyImage);
}

//
//  ImageList_SetFlags
//
//  change the image list flags, then rebuilds the bitmaps.
//
//  the only reason to call this function is to change the
//  color depth of the image list, the shell needs to do this
//  when the screen depth changes and it wants to use HiColor icons.
//
HRESULT CImageList::SetFlags(UINT uFlags)
{
    HBITMAP hOldImage;
    // check for valid input flags
    if (uFlags & ~ILC_VALID)
        return E_INVALIDARG;

    // you cant change these flags.
    if ((uFlags ^ _flags) & ILC_SHARED)
        return E_INVALIDARG;

   if (_pimlMirror)
       _pimlMirror->SetFlags(uFlags);

    // now change the flags and rebuild the bitmaps.
    _flags = uFlags;

    // set the old bitmap to NULL, so when Imagelist_remove calls
    // ImageList_createBitmap, it will not call CreatecomptibleBitmap,
    // it will create the spec for the bitmap from scratch..
    hOldImage = _hbmImage;
    _hbmImage = NULL;
    
    Remove(-1);

    // imagelist::remove will have ensured that the old image is no longer selected
    // thus we can now delete it...
    if ( hOldImage )
        DeleteObject( hOldImage );
        
    return S_OK;
}

HRESULT CImageList::GetFlags(UINT* puFlags)
{
    *puFlags = (_flags & ILC_VALID) | (_pimlMirror ? ILC_MIRROR : 0);

    return S_OK;
}

// reset the background color of images iFirst through iLast

void CImageList::_ResetBkColor(int iFirst, int iLast, COLORREF clr)
{
    HBRUSH hbrT=NULL;
    DWORD  rop;

    if (_hdcMask == NULL)
        return;

    if (clr == CLR_BLACK || clr == CLR_NONE)
    {
        rop = ROP_DSna;
    }
    else if (clr == CLR_WHITE)
    {
        rop = ROP_DSo;
    }
    else
    {
        ASSERT(_hbrBk);
        ASSERT(_clrBk == clr);

        rop = ROP_PatMask;
        hbrT = SelectBrush(_hdcImage, _hbrBk);
    }

    for ( ;iFirst <= iLast; iFirst++)
    {
        RECT rc;

        GetImageRect(iFirst, &rc);
        if (_GetItemFlags(iFirst) == 0)
        {
            BitBlt(_hdcImage, rc.left, rc.top, _cx, _cy,
               _hdcMask, rc.left, rc.top, rop);
        }
    }

    if (hbrT)
        SelectBrush(_hdcImage, hbrT);
}

//
//  GetNearestColor is problematic.  If you have a 32-bit HDC with a 16-bit bitmap
//  selected into it, and you call GetNearestColor, GDI ignores the
//  color-depth of the bitmap and thinks you have a 32-bit bitmap inside,
//  so of course it returns the same color unchanged.
//
//  So instead, we have to emulate GetNearestColor with SetPixel.
//
COLORREF GetNearestColor32(HDC hdc, COLORREF rgb)
{
    COLORREF rgbT;

    rgbT = GetPixel(hdc, 0, 0);
    rgb = SetPixel(hdc, 0, 0, rgb);
    SetPixelV(hdc, 0, 0, rgbT);

    return rgb;
}

COLORREF CImageList::_SetBkColor(COLORREF clrBkI)
{
    COLORREF clrBkOld;

    // Quick out if there is no change in color
    if (_clrBk == clrBkI)
    {
        return _clrBk;
    }

    // The following code deletes the brush, resets the background color etc.,
    // so, protect it with a critical section.
    ENTERCRITICAL;
    
    if (_hbrBk)
    {
        DeleteBrush(_hbrBk);
    }

    clrBkOld = _clrBk;
    _clrBk = clrBkI;

    if (_clrBk == CLR_NONE)
    {
        _hbrBk = (HBRUSH)GetStockObject(BLACK_BRUSH);
        _fSolidBk = TRUE;
    }
    else
    {
        _hbrBk = CreateSolidBrush(_clrBk);
        _fSolidBk = GetNearestColor32(_hdcImage, _clrBk) == _clrBk;
    }

    if (_cImage > 0)
    {
        _ResetBkColor(0, _cImage - 1, _clrBk);
    }

    LEAVECRITICAL;
    
    return clrBkOld;
}

HRESULT CImageList::SetBkColor(COLORREF clrBk, COLORREF* pclr)
{
   if (_pimlMirror)
   {
       _pimlMirror->_SetBkColor(clrBk);
   }    

   *pclr = _SetBkColor(clrBk);
   return S_OK;
}

HRESULT CImageList::GetBkColor(COLORREF* pclr)
{
    *pclr = _clrBk;
    return S_OK;
}

HRESULT CImageList::_ReAllocBitmaps(int cAllocI)
{
    HBITMAP hbmImageNew = NULL;
    HBITMAP hbmMaskNew = NULL;
    RGBQUAD* pargbImageNew = NULL;
    int cxL, cyL;

    // HACK: don't shrink unless the caller passes a negative count
    if (cAllocI > 0)
    {
        if (_cAlloc >= cAllocI)
            return S_OK;
    }
    else
        cAllocI *= -1;


    cxL = _cx * _cStrip;
    cyL = _cy * ((cAllocI + _cStrip - 1) / _cStrip);
    if (cAllocI > 0)
    {
        if (_flags & ILC_MASK)
        {
            hbmMaskNew = CreateMonoBitmap(cxL, cyL);
            if (!hbmMaskNew)
            {
                TraceMsg(TF_ERROR, "ImageList: Can't create bitmap");
                return E_OUTOFMEMORY;
            }
        }
        hbmImageNew = _CreateBitmap(cxL, cyL, &pargbImageNew);
        if (!hbmImageNew)
        {
            if (hbmMaskNew)
                CImageList::_DeleteBitmap(hbmMaskNew);
            TraceMsg(TF_ERROR, "ImageList: Can't create bitmap");
            return E_OUTOFMEMORY;
        }

        if (_dsaFlags == NULL)
            _dsaFlags = DSA_Create(sizeof(DWORD), _cGrow);

        if (!_dsaFlags)
        {
            if (hbmMaskNew)
                CImageList::_DeleteBitmap(hbmMaskNew);
            if (hbmImageNew)
                CImageList::_DeleteBitmap(hbmImageNew);
            TraceMsg(TF_ERROR, "ImageList: Can't create flags array");
            return E_OUTOFMEMORY;

        }
    }

    if (_cImage > 0)
    {
        int cyCopy = _cy * ((min(cAllocI, _cImage) + _cStrip - 1) / _cStrip);

        if (_flags & ILC_MASK)
        {
            CImageList::SelectDstBitmap(hbmMaskNew);
            BitBlt(g_hdcDst, 0, 0, cxL, cyCopy, _hdcMask, 0, 0, SRCCOPY);
        }

        CImageList::SelectDstBitmap(hbmImageNew);
        BitBlt(g_hdcDst, 0, 0, cxL, cyCopy, _hdcImage, 0, 0, SRCCOPY);
    }

    // select into DC's, delete then assign
    CImageList::SelectDstBitmap(NULL);
    CImageList::SelectSrcBitmap(NULL);
    SelectObject(_hdcImage, hbmImageNew);

    if (_hdcMask)
        SelectObject(_hdcMask, hbmMaskNew);

    if (_hbmMask)
        CImageList::_DeleteBitmap(_hbmMask);

    if (_hbmImage)
        CImageList::_DeleteBitmap(_hbmImage);

    _hbmMask = hbmMaskNew;
    _hbmImage = hbmImageNew;
    _pargbImage = pargbImageNew;
    _clrBlend = CLR_NONE;

    _cAlloc = cAllocI;

    return S_OK;
}

HBITMAP CImageList::_CreateMirroredBitmap(HBITMAP hbmOrig, BOOL fMirrorEach, int cx)
{
    HBITMAP hbm = NULL, hOld_bm1, hOld_bm2;
    BITMAP  bm;

    if (!hbmOrig)
        return NULL;

    if (!GetObject(hbmOrig, sizeof(BITMAP), &bm))
        return NULL;

    // Grab the screen DC
    HDC hdc = GetDC(NULL);

    HDC hdcMem1 = CreateCompatibleDC(hdc);

    if (!hdcMem1)
    {
        ReleaseDC(NULL, hdc);
        return NULL;
    }
    
    HDC hdcMem2 = CreateCompatibleDC(hdc);
    if (!hdcMem2)
    {
        DeleteDC(hdcMem1);
        ReleaseDC(NULL, hdc);
        return NULL;
    }

    if (bm.bmBitsPixel == 32)
    {
        void* p;
        BITMAPINFO bi = {sizeof(BITMAPINFOHEADER), bm.bmWidth, bm.bmHeight, 1, 32};
        hbm = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, &p, NULL, 0);
    }
    else
    {
        hbm = CreateColorBitmap(bm.bmWidth, bm.bmHeight);
    }

    if (!hbm)
    {
        DeleteDC(hdcMem2);
        DeleteDC(hdcMem1);        
        ReleaseDC(NULL, hdc);
        return NULL;
    }

    //
    // Flip the bitmap
    //
    hOld_bm1 = (HBITMAP)SelectObject(hdcMem1, hbmOrig);
    hOld_bm2 = (HBITMAP)SelectObject(hdcMem2 , hbm );

    SET_DC_RTL_MIRRORED(hdcMem2);

    if (fMirrorEach)
    {
        for (int i = 0; i < bm.bmWidth; i += cx)        // Flip the bits in the imagelist...
        {
            BitBlt(hdcMem2, bm.bmWidth - i - cx, 0, cx, bm.bmHeight, hdcMem1, i, 0, SRCCOPY);
        }
    }
    else
    {
        BitBlt(hdcMem2, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, SRCCOPY);
    }

    SelectObject(hdcMem1, hOld_bm1 );
    SelectObject(hdcMem1, hOld_bm2 );
    
    DeleteDC(hdcMem2);
    DeleteDC(hdcMem1);
    ReleaseDC(NULL, hdc);

    return hbm;
}

HRESULT CImageList::SetColorTable(int start, int len, RGBQUAD *prgb, int* pi)
{
    // mark it that we have set the color table so that it won't be overwritten 
    // by the first bitmap add....
    _fColorsSet = TRUE;
    if (_hdcImage)
    {
        *pi = SetDIBColorTable(_hdcImage, start, len, prgb);

        return S_OK;
    }

    return E_FAIL;
}


BOOL CImageList::_HasAlpha(int i)
{
    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
    {
        RECT rc;
        if (SUCCEEDED(GetImageRectInverted(i, &rc)))
        {
            for (int y = rc.top; y < rc.bottom; y++)
            {
                for (int x = rc.left; x < rc.right; x++)
                {
                    if (_pargbImage[x + y * _cx].rgbReserved != 0)
                        return TRUE;
                }
            }
        }
    }

    return FALSE;
}

void CImageList::_ScanForAlpha()
{
    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
    {
        for (int i = 0; i < _cImage; i++)
        {
            SetItemFlags(i, _HasAlpha(i)? ILIF_ALPHA : 0);
        }
    }
}


BOOL CImageList::_PreProcessImage(int i)
{
    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
    {
        RECT rc;
        GetImageRectInverted(i, &rc);

#ifdef _X86_ 
        if (IsProcessorFeaturePresent(PF_MMX_INSTRUCTIONS_AVAILABLE))
        {
            _asm
            {
                pxor mm0, mm0
                pxor mm1, mm1
                pxor mm5, mm5
                movq mm6, qw128                 // mm6 is filled with 128
                movq mm7, qw1                   // mm7 is filled with 1
            }

            for (int y = rc.top; y < rc.bottom; y++)
            {
                int Offset = y * _cx;
                RGBQUAD* prgb = &_pargbImage[rc.left + Offset];
                for (int x = rc.left; x < rc.right; x++)
                {
                    _asm
                    {
                        push ecx
                        mov edx, dword ptr [prgb]                     // Read alpha channel
                        mov ecx, dword ptr [edx]
                        mov ebx, ecx
                        shr ebx, 24                     // a >> 24
                        mov eax, ebx                    // a -> b
                        or eax, eax
                        jz EarlyOut
                        shl ebx, 8                      // b << 8
                        or eax, ebx                     // a |= b
                        shl ebx, 8                      // b << 8
                        or eax, ebx                     // a |= b
                        shl ebx, 8                      // b << 8
                                                        // Note high byte of alpha is zero.
                        movd mm0, eax                   //  a -> mm0        
                            movd mm1, ecx                    // Load the pixel
                        punpcklbw mm0,mm5               //  mm0 -> Expands  <-   mm0 Contains the Alpha channel for this multiply

                            punpcklbw mm1,mm5               // Unpack the pixel
                        pmullw mm1, mm0                 // Multiply by the alpha channel <- mm1 contains c * alpha

                        paddusw mm1, mm6                 // perform the (c * alpha) + 128
                        psrlw mm1, 8                    // Divide by 255
                        paddusw mm1, mm7                 // Add 1 to finish the divide by 255
                        packuswb mm1, mm5

                        movd eax, mm1
                        or eax, ebx                     // Transfer alpha channel
                    EarlyOut:
                        mov dword ptr [edx], eax
                        pop ecx
                    }

                    prgb++;
                }
            }

            _asm emms
        }
        else
#endif
        {
            for (int y = rc.top; y < rc.bottom; y++)
            {
                int Offset = y * _cx;
                for (int x = rc.left; x < rc.right; x++)
                {
                    RGBQUAD* prgb = &_pargbImage[x + Offset];
                    if (prgb->rgbReserved)
                    {
                        prgb->rgbRed      = ((prgb->rgbRed   * prgb->rgbReserved) + 128) / 255;
                        prgb->rgbGreen    = ((prgb->rgbGreen * prgb->rgbReserved) + 128) / 255;
                        prgb->rgbBlue     = ((prgb->rgbBlue  * prgb->rgbReserved) + 128) / 255;
                    }
                    else
                    {
                        *((DWORD*)prgb) = 0;
                    }
                }
            }
        }
        return TRUE;
    }

    return FALSE;
}


HRESULT CImageList::_Add(HBITMAP hbmImageI, HBITMAP hbmMaskI, int cImageI, int xStart, int yStart, int* pi)
{
    int i = -1;
    HRESULT hr = S_OK;

    ENTERCRITICAL;

    //
    // if the ImageList is empty clone the color table of the first
    // bitmap you add to the imagelist.
    //
    // the ImageList needs to be a 8bpp image list
    // the bitmap being added needs to be a 8bpp DIBSection
    //
    if (hbmImageI && _cImage == 0 &&
        (_flags & ILC_COLORMASK) != ILC_COLORDDB)
    {
        if (!_fColorsSet)
        {
            int n;
            RGBQUAD argb[256];

            CImageList::SelectDstBitmap(hbmImageI);

            if (n = GetDIBColorTable(g_hdcDst, 0, 256, argb))
            {
                int i;
                SetColorTable(0, n, argb, &i);
            }

            CImageList::SelectDstBitmap(NULL);
        }
        
        _clrBlend = CLR_NONE;
    }

    if (_cImage + cImageI + 1 > _cAlloc)
    {
        hr = _ReAllocBitmaps(_cAlloc + max(cImageI, _cGrow) + 1);
    }

    if (SUCCEEDED(hr))
    {
        i = _cImage;
        _cImage += cImageI;

        if (hbmImageI)
        {
            hr = _Replace(i, cImageI, hbmImageI, hbmMaskI, xStart, yStart);

            if (FAILED(hr))
            {
                _cImage -= cImageI;
                i = -1;
            }
        }
    }

    LEAVECRITICAL;
    *pi = i;

    return hr;
}


HRESULT CImageList::_AddValidated(HBITMAP hbmImage, HBITMAP hbmMask, int* pi)
{
    BITMAP bm;
    int cImageI;

    if (GetObject(hbmImage, sizeof(bm), &bm) != sizeof(bm) || bm.bmWidth < _cx)
    {
        return E_INVALIDARG;
    }

    ASSERT(hbmImage);
    ASSERT(_cx);

    cImageI = bm.bmWidth / _cx;     // # of images in source

    // serialization handled within Add2.
    return  _Add(hbmImage, hbmMask, cImageI, 0, 0, pi);
}

HRESULT CImageList::Add(HBITMAP hbmImage, HBITMAP hbmMask, int* pi)
{
   if (_pimlMirror)
   {
       HBITMAP hbmMirroredImage = _CreateMirroredBitmap(hbmImage, (ILC_PERITEMMIRROR & _flags), _cx);
       HBITMAP hbmMirroredMask = _CreateMirroredBitmap(hbmMask, (ILC_PERITEMMIRROR & _flags), _cx);

       _pimlMirror->_AddValidated(hbmMirroredImage, hbmMirroredMask, pi);

       // The caller will take care of deleting hbmImage, hbmMask
       // He knows nothing about hbmMirroredImage, hbmMirroredMask
       DeleteObject(hbmMirroredImage);
       DeleteObject(hbmMirroredMask);
   }    

   return _AddValidated(hbmImage, hbmMask, pi);
}

HRESULT CImageList::_AddMasked(HBITMAP hbmImageI, COLORREF crMask, int* pi)
{
    HRESULT hr = S_OK;
    COLORREF crbO, crtO;
    HBITMAP hbmMaskI;
    int cImageI;
    int n,i;
    BITMAP bm;
    DWORD ColorTableSave[256];
    DWORD ColorTable[256];

    *pi = -1;

    if (GetObject(hbmImageI, sizeof(bm), &bm) != sizeof(bm))
        return E_INVALIDARG;

    hbmMaskI = CreateMonoBitmap(bm.bmWidth, bm.bmHeight);
    if (!hbmMaskI)
        return E_OUTOFMEMORY;

    ENTERCRITICAL;

    // copy color to mono, with crMask turning 1 and all others 0, then
    // punch all crMask pixels in color to 0
    CImageList::SelectSrcBitmap(hbmImageI);
    CImageList::SelectDstBitmap(hbmMaskI);

    // crMask == CLR_DEFAULT, means use the pixel in the upper left
    //
    if (crMask == CLR_DEFAULT)
        crMask = GetPixel(g_hdcSrc, 0, 0);

    // DIBSections dont do color->mono like DDBs do, so we have to do it.
    // this only works for <=8bpp DIBSections, this method does not work
    // for HiColor DIBSections.
    //
    // This code is a workaround for a problem in Win32 when a DIB is converted to 
    // monochrome. The conversion is done according to closeness to white or black
    // and without regard to the background color. This workaround is is not required 
    // under MainWin. 
    //
    // Please note, this code has an endianship problems the comparision in the if statement
    // below is sensitive to endianship
    // ----> if (ColorTableSave[i] == RGB(GetBValue(crMask),GetGValue(crMask),GetRValue(crMask))
    //
    if (bm.bmBits != NULL && bm.bmBitsPixel <= 8)
    {
        n = GetDIBColorTable(g_hdcSrc, 0, 256, (RGBQUAD*)ColorTableSave);

        for (i=0; i<n; i++)
        {
            if (ColorTableSave[i] == RGB(GetBValue(crMask),GetGValue(crMask),GetRValue(crMask)))
                ColorTable[i] = 0x00FFFFFF;
            else
                ColorTable[i] = 0x00000000;
        }

        SetDIBColorTable(g_hdcSrc, 0, n, (RGBQUAD*)ColorTable);
    }

    crbO = ::SetBkColor(g_hdcSrc, crMask);
    BitBlt(g_hdcDst, 0, 0, bm.bmWidth, bm.bmHeight, g_hdcSrc, 0, 0, SRCCOPY);
    ::SetBkColor(g_hdcSrc, 0x00FFFFFFL);
    crtO = SetTextColor(g_hdcSrc, 0x00L);
    BitBlt(g_hdcSrc, 0, 0, bm.bmWidth, bm.bmHeight, g_hdcDst, 0, 0, ROP_DSna);
    ::SetBkColor(g_hdcSrc, crbO);
    SetTextColor(g_hdcSrc, crtO);

    if (bm.bmBits != NULL && bm.bmBitsPixel <= 8)
    {
        SetDIBColorTable(g_hdcSrc, 0, n, (RGBQUAD*)ColorTableSave);
    }

    CImageList::SelectSrcBitmap(NULL);
    CImageList::SelectDstBitmap(NULL);

    ASSERT(_cx);
    cImageI = bm.bmWidth / _cx;    // # of images in source

    hr = _Add(hbmImageI, hbmMaskI, cImageI, 0, 0, pi);

    DeleteObject(hbmMaskI);
    LEAVECRITICAL;
    return hr;
}

HRESULT CImageList::AddMasked(HBITMAP hbmImage, COLORREF crMask, int* pi)
{
   if (_pimlMirror)
   {
       HBITMAP hbmMirroredImage = CImageList::_CreateMirroredBitmap(hbmImage, (ILC_PERITEMMIRROR & _flags), _cx);

       _pimlMirror->_AddMasked(hbmMirroredImage, crMask, pi);

       // The caller will take care of deleting hbmImage
       // He knows nothing about hbmMirroredImage
       DeleteObject(hbmMirroredImage);

   }    

   return _AddMasked(hbmImage, crMask, pi);
}

HRESULT CImageList::_ReplaceValidated(int i, HBITMAP hbmImage, HBITMAP hbmMask)
{
    HRESULT hr = E_INVALIDARG;
    if (!IsImageListIndex(i))
        return hr;

    ENTERCRITICAL;
    hr = _Replace(i, 1, hbmImage, hbmMask, 0, 0);
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::Replace(int i, HBITMAP hbmImage, HBITMAP hbmMask)
{
   if (_pimlMirror)
   {
       HBITMAP hbmMirroredImage = CImageList::_CreateMirroredBitmap(hbmImage, (ILC_PERITEMMIRROR & _flags), _cx);
       if (hbmMirroredImage)
       {
           HBITMAP hbmMirroredMask = NULL;
           
           if (hbmMask)
               hbmMirroredMask = CImageList::_CreateMirroredBitmap(hbmMask, (ILC_PERITEMMIRROR & _flags), _cx);

           _pimlMirror->_ReplaceValidated(i, hbmMirroredImage, hbmMirroredMask);

           if (hbmMirroredMask)
               DeleteObject(hbmMirroredMask);

           DeleteObject(hbmMirroredImage);
       }
   }    

   return _ReplaceValidated(i, hbmImage, hbmMask);
}


// replaces images in piml with images from bitmaps
//
// in:
//    piml
//    i    index in image list to start at (replace)
//    _cImage    count of images in source (hbmImage, hbmMask)
//

HRESULT CImageList::_Replace(int i, int cImageI, HBITMAP hbmImageI, HBITMAP hbmMaskI,
    int xStart, int yStart)
{
    RECT rcImage;
    int x, iImage;
    BOOL fBitmapIs32 = FALSE;

    ASSERT(_hbmImage);

    BITMAP bm;
    GetObject(hbmImageI, sizeof(bm), &bm);
    if (bm.bmBitsPixel == 32)
    {
        fBitmapIs32 = TRUE;
    }

    CImageList::SelectSrcBitmap(hbmImageI);
    if (_hdcMask) 
        CImageList::SelectDstBitmap(hbmMaskI); // using as just a second source hdc

    for (x = xStart, iImage = 0; iImage < cImageI; iImage++, x += _cx) 
    {
    
        GetImageRect(i + iImage, &rcImage);

        if (_hdcMask)
        {
            BitBlt(_hdcMask, rcImage.left, rcImage.top, _cx, _cy,
                    g_hdcDst, x, yStart, SRCCOPY);
        }

        BitBlt(_hdcImage, rcImage.left, rcImage.top, _cx, _cy,
                g_hdcSrc, x, yStart, SRCCOPY);

        if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
        {
            DWORD dw = 0;
            if (fBitmapIs32)
            {
                BOOL fHasAlpha = _HasAlpha(i + iImage);
                if (fHasAlpha)
                {
                    dw = ILIF_ALPHA;

                    _PreProcessImage(i + iImage);
                }
            }

            SetItemFlags(i + iImage, dw);
        }
    }

    _ResetBkColor(i, i + cImageI - 1, _clrBk);

    CImageList::SelectSrcBitmap(NULL);
    if (_hdcMask) 
        CImageList::SelectDstBitmap(NULL);

    return S_OK;
}

void UnPremultiply(RGBQUAD* pargb, int cx, int cy)
{
    int cTotal = cx * cy;
    for (int i = 0; i < cTotal; i++)
    {
        RGBQUAD* prgb = &pargb[i];
        if (prgb->rgbReserved != 0)
        {
            prgb->rgbRed = ((255 * prgb->rgbRed) - 128)/prgb->rgbReserved;
            prgb->rgbGreen = ((255 * prgb->rgbGreen) - 128)/prgb->rgbReserved;
            prgb->rgbBlue = ((255 * prgb->rgbBlue) - 128)/prgb->rgbReserved;
        }
    }
}

HRESULT CImageList::GetIcon(int i, UINT flags, HICON* phicon)
{
    UINT cxImage, cyImage;
    HICON hIcon = NULL;
    HBITMAP hbmMask = NULL;
    HBITMAP hbmColor = NULL;
    ICONINFO ii;
    HRESULT hr = E_OUTOFMEMORY;
    RGBQUAD* prgb;
    DWORD fHasAlpha = FALSE;

    ENTERCRITICAL;
    if (!IsImageListIndex(i))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        fHasAlpha = (_GetItemFlags(i) & ILIF_ALPHA);
    }
    LEAVECRITICAL;

    if (E_INVALIDARG == hr)
        return hr;

    cxImage = _cx;
    cyImage = _cy;
    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
    {
        // If the source image is not an alpha image, we need to create a lower than 32bpp dib.
        // We need to do this because if the overlay contains an alpha channel, this will
        // be propogated to the final icon, and the only visible portion will be the link item.
        BITMAPINFO bi = {0};
        bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
        bi.bmiHeader.biWidth = cxImage;
        bi.bmiHeader.biHeight = cyImage;
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biBitCount = fHasAlpha?32:24;
        bi.bmiHeader.biCompression = BI_RGB;

        HDC hdcScreen = GetDC(NULL);
        if (hdcScreen)
        {
            hbmColor = CreateDIBSection(hdcScreen, &bi, DIB_RGB_COLORS, (void**)&prgb, NULL, 0);
            ReleaseDC(NULL, hdcScreen);
        }

        flags |= ILD_PRESERVEALPHA;
    }
    else
    {
        hbmColor = CreateColorBitmap(cxImage, cyImage);
    }

    if (hbmColor)
    {
        hbmMask = CreateMonoBitmap(cxImage, cyImage);
        if (hbmMask)
        {
            ENTERCRITICAL;
            CImageList::SelectDstBitmap(hbmMask);
            PatBlt(g_hdcDst, 0, 0, cxImage, cyImage, WHITENESS);
            WimpyDraw(SAFECAST(this, IImageList*), i, g_hdcDst, 0, 0, ILD_MASK | flags);

            CImageList::SelectDstBitmap(hbmColor);
            PatBlt(g_hdcDst, 0, 0, cxImage, cyImage, BLACKNESS);
            WimpyDraw(SAFECAST(this, IImageList*), i, g_hdcDst, 0, 0, ILD_TRANSPARENT | flags);

            CImageList::SelectDstBitmap(NULL);
            LEAVECRITICAL;

            if (fHasAlpha)
            {
                UnPremultiply(prgb, _cx, _cy);
            }

            ii.fIcon    = TRUE;
            ii.xHotspot = 0;
            ii.yHotspot = 0;
            ii.hbmColor = hbmColor;
            ii.hbmMask  = hbmMask;
            hIcon = CreateIconIndirect(&ii);
            DeleteObject(hbmMask);

            hr = S_OK;
        }
        DeleteObject(hbmColor);
    }
    *phicon = hIcon;

    return hr;
}

// this removes an image from the bitmap but doing all the
// proper shuffling.
//
//   this does the following:
//    if the bitmap being removed is not the last in the row
//        it blts the images to the right of the one being deleted
//        to the location of the one being deleted (covering it up)
//
//    for all rows until the last row (where the last image is)
//        move the image from the next row up to the last position
//        in the current row.  then slide over all images in that
//        row to the left.

void CImageList::_RemoveItemBitmap(int i)
{
    RECT rc1;
    RECT rc2;
    int dx, y;
    int x;
    
    GetImageRect(i, &rc1);
    GetImageRect(_cImage - 1, &rc2);

    if (i < _cImage && 
        (_flags & ILC_COLORMASK) == ILC_COLOR32)
    {
        DSA_DeleteItem(_dsaFlags, i);
    }

    SetItemFlags(_cImage, 0);


    // the row with the image being deleted, do we need to shuffle?
    // amount of stuff to shuffle
    dx = _cStrip * _cx - rc1.right;

    if (dx) 
    {
        // yes, shuffle things left
        BitBlt(_hdcImage, rc1.left, rc1.top, dx, _cy, _hdcImage, rc1.right, rc1.top, SRCCOPY);
        if (_hdcMask)  
            BitBlt(_hdcMask,  rc1.left, rc1.top, dx, _cy, _hdcMask,  rc1.right, rc1.top, SRCCOPY);
    }

    y = rc1.top;    // top of row we are working on
    x = _cx * (_cStrip - 1); // x coord of last bitmaps in each row
    while (y < rc2.top) 
    {
    
        // copy first from row below to last image position on this row
        BitBlt(_hdcImage, x, y,
                   _cx, _cy, _hdcImage, 0, y + _cy, SRCCOPY);

            if (_hdcMask)
                BitBlt(_hdcMask, x, y,
                   _cx, _cy, _hdcMask, 0, y + _cy, SRCCOPY);

        y += _cy;    // jump to row to slide left

        if (y <= rc2.top) 
        {

            // slide the rest over to the left
            BitBlt(_hdcImage, 0, y, x, _cy,
                       _hdcImage, _cx, y, SRCCOPY);

            // slide the rest over to the left
            if (_hdcMask)
            {
                BitBlt(_hdcMask, 0, y, x, _cy,
                       _hdcMask, _cx, y, SRCCOPY);
            }
        }
    }
}

//
//  ImageList_Remove - remove a image from the image list
//
//  i - image to remove, or -1 to remove all images.
//
//  NOTE all images are "shifted" down, ie all image index's
//  above the one deleted are changed by 1
//
HRESULT CImageList::_Remove(int i)
{
    HRESULT hr = S_OK;

    ENTERCRITICAL;

    if (i == -1)
    {
        _cImage = 0;
        _cAlloc = 0;

        for (i=0; i<NUM_OVERLAY_IMAGES; i++)
            _aOverlayIndexes[i] = -1;

        if (_dsaFlags)
        {
            DSA_Destroy(_dsaFlags);
            _dsaFlags = NULL;
        }

        _ReAllocBitmaps(-_cGrow);
    }
    else
    {
        if (!IsImageListIndex(i))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            _RemoveItemBitmap(i);

            --_cImage;

            if (_cAlloc - (_cImage + 1) > _cGrow)
                _ReAllocBitmaps(_cAlloc - _cGrow);
        }
    }
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::Remove(int i)
{
    if (_pimlMirror)
    {
        _pimlMirror->_Remove(i);
    }

    return _Remove(i);
}

BOOL CImageList::_IsSameObject(IUnknown* punk)
{
    BOOL fRet = FALSE;
    IUnknown* me;
    IUnknown* them;

    if (punk == NULL)
        return FALSE;

    QueryInterface(IID_PPV_ARG(IUnknown, &me));
    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IUnknown, &them))))
    {
        fRet = (me == them);
        them->Release();
    }

    me->Release();

    return fRet;
}

//
//  ImageList_Copy - move an image in the image list
//
HRESULT CImageList::Copy(int iDst, IUnknown* punkSrc, int iSrc, UINT uFlags)
{
    RECT rcDst, rcSrc, rcTmp;
    CImageList* pimlTmp;
    CImageList* pimlSrc;
    HRESULT hr = E_FAIL;

    if (uFlags & ~ILCF_VALID)
    {
        // don't let hosers pass bogus flags
        RIPMSG(0, "ImageList_Copy: Invalid flags %08x", uFlags);
        return E_INVALIDARG;
    }

    // Not supported 
    if (!_IsSameObject(punkSrc))
    {
        return E_INVALIDARG;
    }


    // We only support copies on ourself... Weird
    pimlSrc = this;

    ENTERCRITICAL;
    pimlTmp = (uFlags & ILCF_SWAP)? pimlSrc : NULL;

    if (SUCCEEDED(GetImageRect(iDst, &rcDst)) &&
        SUCCEEDED(pimlSrc->GetImageRect(iSrc, &rcSrc)) &&
        (!pimlTmp || pimlTmp->GetSpareImageRect(&rcTmp)))
    {
        int cx = pimlSrc->_cx;
        int cy = pimlSrc->_cy;

        //
        // iff we are swapping we need to save the destination image
        //
        if (pimlTmp)
        {
            BitBlt(pimlTmp->_hdcImage, rcTmp.left, rcTmp.top, cx, cy,
                   _hdcImage, rcDst.left, rcDst.top, SRCCOPY);

            if (pimlTmp->_hdcMask)
            {
                BitBlt(pimlTmp->_hdcMask, rcTmp.left, rcTmp.top, cx, cy,
                       _hdcMask, rcDst.left, rcDst.top, SRCCOPY);
            }
        }

        //
        // copy the image
        //
        BitBlt(_hdcImage, rcDst.left, rcDst.top, cx, cy,
           pimlSrc->_hdcImage, rcSrc.left, rcSrc.top, SRCCOPY);

        if (pimlSrc->_hdcMask)
        {
            BitBlt(_hdcMask, rcDst.left, rcDst.top, cx, cy,
                   pimlSrc->_hdcMask, rcSrc.left, rcSrc.top, SRCCOPY);
        }

        //
        // iff we are swapping we need to copy the saved image too
        //
        if (pimlTmp)
        {
            BitBlt(pimlSrc->_hdcImage, rcSrc.left, rcSrc.top, cx, cy,
                   pimlTmp->_hdcImage, rcTmp.left, rcTmp.top, SRCCOPY);

            if (pimlSrc->_hdcMask)
            {
                BitBlt(pimlSrc->_hdcMask, rcSrc.left, rcSrc.top, cx, cy,
                       pimlTmp->_hdcMask, rcTmp.left, rcTmp.top, SRCCOPY);
            }
        }

        hr = S_OK;
    }

    LEAVECRITICAL;
    return hr;
}

// IS_WHITE_PIXEL, BITS_ALL_WHITE are macros for looking at monochrome bits
// to determine if certain pixels are white or black.  Note that within a byte
// the most significant bit represents the left most pixel.
//
#define IS_WHITE_PIXEL(pj,x,y,cScan) \
    ((pj)[((y) * (cScan)) + ((x) >> 3)] & (1 << (7 - ((x) & 7))))

#define BITS_ALL_WHITE(b) (b == 0xff)

// Set the image iImage as one of the special images for us in combine
// drawing.  to draw with these specify the index of this
// in:
//      piml    imagelist
//      iImage  image index to use in speical drawing
//      iOverlay        index of special image, values 1-4

HRESULT CImageList::_SetOverlayImage(int iImage, int iOverlay)
{
    RECT    rcImage;
    RECT    rc;
    int     x,y;
    int     cxI,cyI;
    ULONG   cScan;
    ULONG   cBits;
    HBITMAP hbmMem;
    HRESULT hr = S_FALSE;

    iOverlay--;         // make zero based
    if (_hdcMask == NULL ||
        iImage < 0 || iImage >= _cImage ||
        iOverlay < 0 || iOverlay >= NUM_OVERLAY_IMAGES)
    {
        return E_INVALIDARG;
    }

    if (_aOverlayIndexes[iOverlay] == (SHORT)iImage)
        return S_OK;

    _aOverlayIndexes[iOverlay] = (SHORT)iImage;

    //
    // find minimal rect that bounds the image
    //
    GetImageRect(iImage, &rcImage);
    SetRect(&rc, 0x7FFF, 0x7FFF, 0, 0);

    //
    // now compute the black box.  This is much faster than GetPixel but
    // could still be improved by doing more operations looking at entire
    // bytes.  We basicaly get the bits in monochrome form and then use
    // a private GetPixel.  This decreased time on NT from 50 milliseconds to
    // 1 millisecond for a 32X32 image.
    //
    cxI     = rcImage.right  - rcImage.left;
    cyI     = rcImage.bottom - rcImage.top;

    // compute the number of bytes in a scan.  Note that they are WORD alligned
    cScan  = (((cxI + (sizeof(SHORT)*8 - 1)) / 16) * 2);
    cBits  = cScan * cyI;

    hbmMem = CreateMonoBitmap(cxI,cyI);

    if (hbmMem)
    {
        HDC     hdcMem = CreateCompatibleDC(_hdcMask);

        if (hdcMem)
        {
            PBYTE   pBits  = (PBYTE)LocalAlloc(LMEM_FIXED,cBits);
            PBYTE   pScan;

            if (pBits)
            {
                SelectObject(hdcMem,hbmMem);

                //
                // map black pixels to 0, white to 1
                //
                BitBlt(hdcMem, 0, 0, cxI, cyI, _hdcMask, rcImage.left, rcImage.top, SRCCOPY);

                //
                // fill in the bits
                //
                GetBitmapBits(hbmMem,cBits,pBits);

                //
                // for each scan, find the bounds
                //
                for (y = 0, pScan = pBits; y < cyI; ++y,pScan += cScan)
                {
                    int i;

                    //
                    // first go byte by byte through white space
                    //
                    for (x = 0, i = 0; (i < (cxI >> 3)) && BITS_ALL_WHITE(pScan[i]); ++i)
                    {
                        x += 8;
                    }

                    //
                    // now finish the scan bit by bit
                    //
                    for (; x < cxI; ++x)
                    {
                        if (!IS_WHITE_PIXEL(pBits, x,y,cScan))
                        {
                            rc.left   = min(rc.left, x);
                            rc.right  = max(rc.right, x+1);
                            rc.top    = min(rc.top, y);
                            rc.bottom = max(rc.bottom, y+1);

                            // now that we found one, quickly jump to the known right edge

                            if ((x >= rc.left) && (x < rc.right))
                            {
                                x = rc.right-1;
                            }
                        }
                    }
                }

                if (rc.left == 0x7FFF) 
                {
                    rc.left = 0;
                    TraceMsg(TF_ERROR, "SetOverlayImage: Invalid image. No white pixels specified");
                }

                if (rc.top == 0x7FFF) 
                {
                    rc.top = 0;
                    TraceMsg(TF_ERROR, "SetOverlayImage: Invalid image. No white pixels specified");
                }

                _aOverlayDX[iOverlay] = (SHORT)(rc.right - rc.left);
                _aOverlayDY[iOverlay] = (SHORT)(rc.bottom- rc.top);
                _aOverlayX[iOverlay]  = (SHORT)(rc.left);
                _aOverlayY[iOverlay]  = (SHORT)(rc.top);
                _aOverlayF[iOverlay]  = 0;

                //
                // see if the image is non-rectanglar
                //
                // if the overlay does not require a mask to be drawn set the
                // ILD_IMAGE flag, this causes ImageList_DrawEx to just
                // draw the image, ignoring the mask.
                //
                for (y=rc.top; y<rc.bottom; y++)
                {
                    for (x=rc.left; x<rc.right; x++)
                    {
                        if (IS_WHITE_PIXEL(pBits, x, y,cScan))
                            break;
                    }

                    if (x != rc.right)
                        break;
                }

                if (y == rc.bottom)
                    _aOverlayF[iOverlay] = ILD_IMAGE;

                LocalFree(pBits);

                hr = S_OK;
            }

            DeleteDC(hdcMem);
        }

        DeleteObject(hbmMem);
    }

    return hr;
}

HRESULT CImageList::SetOverlayImage(int iImage, int iOverlay)
{
    if (_pimlMirror)
    {
        _pimlMirror->_SetOverlayImage(iImage, iOverlay);
    }

    return _SetOverlayImage(iImage, iOverlay);
}

/*
**  BlendCT
**
*/
void CImageList::BlendCTHelper(DWORD *pdw, DWORD rgb, UINT n, UINT count)
{
    UINT i;

    for (i=0; i<count; i++)
    {
        pdw[i] = RGB(
            ((UINT)GetRValue(pdw[i]) * (100-n) + (UINT)GetBValue(rgb) * (n)) / 100,
            ((UINT)GetGValue(pdw[i]) * (100-n) + (UINT)GetGValue(rgb) * (n)) / 100,
            ((UINT)GetBValue(pdw[i]) * (100-n) + (UINT)GetRValue(rgb) * (n)) / 100);
    }
}

/*
** BlendDither
**
**  copy the source to the dest blended with the given color.
**
**  simulate a blend with a dither pattern.
**
*/
void CImageList::BlendDither(HDC hdcDst, int xDst, int yDst, int x, int y, int cx, int cy, COLORREF rgb, UINT fStyle)
{
    HBRUSH hbr;
    HBRUSH hbrT;
    HBRUSH hbrMask;
    HBRUSH hbrFree = NULL;         // free if non-null

    ASSERT(GetTextColor(hdcDst) == CLR_BLACK);
    ASSERT(::GetBkColor(hdcDst) == CLR_WHITE);

    // choose a dither/blend brush

    switch (fStyle & ILD_BLENDMASK)
    {
        default:
        case ILD_BLEND50:
            hbrMask = g_hbrMonoDither;
            break;
    }

    // create (or use a existing) brush for the blend color

    switch (rgb)
    {
        case CLR_DEFAULT:
            hbr = g_hbrHighlight;
            break;

        case CLR_NONE:
            hbr = _hbrBk;
            break;

        default:
            if (rgb == _clrBk)
                hbr = _hbrBk;
            else
                hbr = hbrFree = CreateSolidBrush(rgb);
            break;
    }

    hbrT = (HBRUSH)SelectObject(hdcDst, hbr);
    PatBlt(hdcDst, xDst, yDst, cx, cy, PATCOPY);
    SelectObject(hdcDst, hbrT);

    hbrT = (HBRUSH)SelectObject(hdcDst, hbrMask);
    BitBlt(hdcDst, xDst, yDst, cx, cy, _hdcImage, x, y, ROP_MaskPat);
    SelectObject(hdcDst, hbrT);

    if (hbrFree)
        DeleteBrush(hbrFree);
}

/*
** BlendCT
**
**  copy the source to the dest blended with the given color.
**
*/
void CImageList::BlendCT(HDC hdcDst, int xDst, int yDst, int x, int y, int cx, int cy, COLORREF rgb, UINT fStyle)
{
    BITMAP bm;

    GetObject(_hbmImage, sizeof(bm), &bm);

    if (rgb == CLR_DEFAULT)
        rgb = GetSysColor(COLOR_HIGHLIGHT);

    ASSERT(rgb != CLR_NONE);

    //
    // get the DIB color table and blend it, only do this when the
    // blend color changes
    //
    if (_clrBlend != rgb)
    {
        int n,cnt;

        _clrBlend = rgb;

        GetObject(_hbmImage, sizeof(dib), &dib.bm);
        cnt = GetDIBColorTable(_hdcImage, 0, 256, (LPRGBQUAD)&dib.ct);

        if ((fStyle & ILD_BLENDMASK) == ILD_BLEND50)
            n = 50;
        else
            n = 25;

        BlendCTHelper(dib.ct, rgb, n, cnt);
    }

    //
    // draw the image with a different color table
    //
    StretchDIBits(hdcDst, xDst, yDst, cx, cy,
        x, dib.bi.biHeight-(y+cy), cx, cy,
        bm.bmBits, (LPBITMAPINFO)&dib.bi, DIB_RGB_COLORS, SRCCOPY);
}

//  RGB555 macros
#define RGB555(r,g,b)       (((((r)>>3)&0x1F)<<10) | ((((g)>>3)&0x1F)<<5) | (((b)>>3)&0x1F))
#define R_555(w)            (int)(((w) >> 7) & 0xF8)
#define G_555(w)            (int)(((w) >> 2) & 0xF8)
#define B_555(w)            (int)(((w) << 3) & 0xF8)

void CImageList::Blend16Helper(int xSrc, int ySrc, int xDst, int yDst, int cx, int cy, COLORREF rgb, int a)          // alpha value
{
    // If it's odd, Adjust. 
    if ((cx & 1) == 1)
    {
        cx++;
    }

    if (rgb == CLR_NONE)
    {
        // blending with the destination, we ignore the alpha and always
        // do 50% (this is what the old dither mask code did)

        int ys = ySrc;
        int yd = yDst;

        for (; ys < ySrc + cy; ys++, yd++)
        {
            WORD* pSrc = &((WORD*)_pargbImage)[xSrc + ys * cx];  // Cast because we've gotten to this case because we are a 555 imagelist
            WORD* pDst = &((WORD*)_pargbImage)[xDst + yd * cx];
            for (int x = 0; x < cx; x++)
            {
                *pDst++ = ((*pDst & 0x7BDE) >> 1) + ((*pSrc++ & 0x7BDE) >> 1);
            }

        }
    }
    else
    {
        // blending with a solid color

        // pre multiply source (constant) rgb by alpha
        int sr = GetRValue(rgb) * a;
        int sg = GetGValue(rgb) * a;
        int sb = GetBValue(rgb) * a;

        // compute inverse alpha for inner loop
        a = 256 - a;

        // special case a 50% blend, to avoid a multiply
        if (a == 128)
        {
            sr = RGB555(sr>>8,sg>>8,sb>>8);

            int ys = ySrc;
            int yd = yDst;
            for (; ys < ySrc + cy; ys++, yd++)
            {
                WORD* pSrc = &((WORD*)_pargbImage)[xSrc + ys * cx];
                WORD* pDst = &((WORD*)_pargbImage)[xDst + yd * cx];
                for (int x = 0; x < cx; x++)
                {
                    int i = *pSrc++;
                    i = sr + ((i & 0x7BDE) >> 1);
                    *pDst++ = (WORD) i;
                }
            }
        }
        else
        {
            int ys = ySrc;
            int yd = yDst;
            for (; ys < ySrc + cy; ys++, yd++)
            {
                WORD* pSrc = &((WORD*)_pargbImage)[xSrc + ys * cx];
                WORD* pDst = &((WORD*)_pargbImage)[xDst + yd * cx];
                for (int x = 0; x < cx; x++)
                {
                    int i = *pSrc++;
                    int r = (R_555(i) * a + sr) >> 8;
                    int g = (G_555(i) * a + sg) >> 8;
                    int b = (B_555(i) * a + sb) >> 8;
                    *pDst++ = RGB555(r,g,b);
                }
            }
        }
    }
}

/*
** ImageList_Blend16
**
**  copy the source to the dest blended with the given color.
**
**  source is assumed to be a 16 bit (RGB 555) bottom-up DIBSection
**  (this is the only kind of DIBSection we create)
*/
void CImageList::Blend16(HDC hdcDst, int xDst, int yDst, int iImage, int cx, int cy, COLORREF rgb, UINT fStyle)
{
    BITMAP bm;
    RECT rc;
    RECT rcSpare;
    RECT rcSpareInverted;
    int a, x, y;

    // get bitmap info for source bitmap
    GetObject(_hbmImage, sizeof(bm), &bm);
    ASSERT(bm.bmBitsPixel==16);

    // get blend RGB
    if (rgb == CLR_DEFAULT)
        rgb = GetSysColor(COLOR_HIGHLIGHT);

    // get blend factor as a fraction of 256
    // only 50% or 25% is currently used.
    if ((fStyle & ILD_BLENDMASK) == ILD_BLEND50)
        a = 128;
    else
        a = 64;

    GetImageRectInverted(iImage, &rc);
    x = rc.left;
    y = rc.top;


    // blend the image with the specified color and place at end of image list
    if (GetSpareImageRectInverted(&rcSpareInverted) &&
        GetSpareImageRect(&rcSpare))
    {
        // if blending with the destination, copy the dest to our work buffer
        if (rgb == CLR_NONE)
            BitBlt(_hdcImage, rcSpare.left, rcSpare.top, cx, cy, hdcDst, xDst, yDst, SRCCOPY);
        // sometimes the user can change the icon size (via plustab) between 32x32 and 48x48,
        // thus the values we have might be bigger than the actual bitmap. To prevent us from
        // crashing in Blend16 when this happens we do some bounds checks here
        if (rc.left + cx <= bm.bmWidth  &&
            rc.top  + cy <= bm.bmHeight &&
            x + cx       <= bm.bmWidth  &&
            y + cy       <= bm.bmHeight)
        {
            // Needs inverted coordinates
            Blend16Helper(x, y, rcSpareInverted.left, rcSpareInverted.top, cx, cy, rgb, a);
        }

        // blt blended image to the dest DC
        BitBlt(hdcDst, xDst, yDst, cx, cy, _hdcImage, rcSpare.left, rcSpare.top, SRCCOPY);
    }
}

#define ALPHA_50    128
#define ALPHA_25    64

void CImageList::_GenerateAlphaForImageUsingMask(int iImage, BOOL fSpare)
{
    RECT rcImage;
    RECT rcInverted;
    HRESULT hr;
    
    GetImageRect(iImage, &rcImage);
    
    if (fSpare)
    {
        hr = GetSpareImageRectInverted(&rcInverted);
    }
    else
    {
        hr = GetImageRectInverted(iImage, &rcInverted);
    }

    if (!SUCCEEDED(hr))
        return;

    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = _cx;
    bi.bmiHeader.biHeight = _cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    HDC hdcMem = CreateCompatibleDC(_hdcMask);
    if (hdcMem)
    {
        RGBQUAD* pbMask;
        HBITMAP hbmp = CreateDIBSection(hdcMem, &bi, DIB_RGB_COLORS, (void**)&pbMask, NULL, 0);

        if (hbmp)
        {
            HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcMem, hbmp);
            SetTextColor(hdcMem, RGB(0xFF, 0xFF, 0xFF));
            ::SetBkColor(hdcMem, RGB(0x0,0x0,0x0));

            BitBlt(hdcMem, 0, 0, _cx, _cy, _hdcMask, rcImage.left, rcImage.top, SRCCOPY);

            for (int y = 0; y < _cy; y++)
            {
                int Offset = (y + rcInverted.top) * _cx;
                int MaskOffset = y * _cx;
                for (int x = 0; x < _cx; x++)
                {
                    RGBQUAD* prgb = &_pargbImage[x + rcInverted.left + Offset];
                    if (pbMask[x + MaskOffset].rgbBlue != 0)
                    {
                        prgb->rgbReserved = 255;
                    }
                    else
                    {
                        *(DWORD*)prgb = 0;
                    }
                }
            }

            SelectObject(hdcMem, hbmpOld);
            DeleteObject(hbmp);
        }
        DeleteDC(hdcMem);
    }

    if (!fSpare)
    {
        SetItemFlags(iImage, ILIF_ALPHA);
        _PreProcessImage(iImage);
    }
}

void ScaleAlpha(RGBQUAD* prgbImage, RECT* prc, int aScale)
{
    int cx = RECTWIDTH(*prc);
    for (int y = prc->top; y < prc->bottom; y++)
    {
        int Offset = y * cx;
        for (int x = prc->left; x < prc->right; x++)
        {
            RGBQUAD* prgb = &prgbImage[x + Offset];
            if (prgb->rgbReserved != 0)
            {
                prgb->rgbReserved = (BYTE)(prgb->rgbReserved / aScale);      // New alpha
                prgb->rgbRed      = ((prgb->rgbRed   * prgb->rgbReserved) + 128) / 255;
                prgb->rgbGreen    = ((prgb->rgbGreen * prgb->rgbReserved) + 128) / 255;
                prgb->rgbBlue     = ((prgb->rgbBlue  * prgb->rgbReserved) + 128) / 255;
            }
        }
    }
}

#define COLORBLEND_ALPHA 128

BOOL CImageList::Blend32(HDC hdcDst, int xDst, int yDst, int iImage, int cx, int cy, COLORREF rgb, UINT fStyle)
{
    BITMAP bm;
    RECT rc;
    RECT rcSpare;
    RECT rcSpareInverted;
    int aScale;
    BOOL fBlendWithColor = FALSE;
    int r,g,b;

    // get bitmap info for source bitmap
    GetObject(_hbmImage, sizeof(bm), &bm);
    ASSERT(bm.bmBitsPixel==32);

    // get blend RGB
    if (rgb == CLR_DEFAULT)
    {
        rgb = GetSysColor(COLOR_HIGHLIGHT);
        fBlendWithColor = TRUE;
        r = GetRValue(rgb) * COLORBLEND_ALPHA;
        g = GetGValue(rgb) * COLORBLEND_ALPHA;
        b = GetBValue(rgb) * COLORBLEND_ALPHA;
    }

    // get blend factor as a fraction of 256
    // only 50% or 25% is currently used.
    if ((fStyle & ILD_BLENDMASK) == ILD_BLEND50 || rgb == CLR_NONE)
        aScale = 2;
    else
        aScale = 4;

    GetImageRect(iImage, &rc);
    if (GetSpareImageRectInverted(&rcSpareInverted) &&
        GetSpareImageRect(&rcSpare))
    {
        BitBlt(_hdcImage, rcSpare.left, rcSpare.top, _cx, _cy, _hdcImage, rc.left, rc.top, SRCCOPY);

        BOOL fHasAlpha = (_GetItemFlags(iImage) & ILIF_ALPHA);
        if (!fHasAlpha)
        {
            _GenerateAlphaForImageUsingMask(iImage, TRUE);
        }

        // if blending with the destination, copy the dest to our work buffer
        if (rgb == CLR_NONE)
        {
            ScaleAlpha(_pargbImage, &rcSpareInverted, aScale);

            BLENDFUNCTION bf = {0};
            bf.BlendOp = AC_SRC_OVER;
            bf.SourceConstantAlpha = 255;
            bf.AlphaFormat = AC_SRC_ALPHA;
            bf.BlendFlags = AC_MIRRORBITMAP | ((fStyle & ILD_DPISCALE)?AC_USE_HIGHQUALITYFILTER:0);
            GdiAlphaBlend(hdcDst,  xDst, yDst, cx, cy, _hdcImage, rcSpare.left, rcSpare.top, _cx, _cy, bf);
            return FALSE;
        }
        else
        {
            if (fBlendWithColor)
            {
                for (int y = rcSpareInverted.top; y < rcSpareInverted.bottom; y++)
                {
                    int Offset = y * _cx;
                    for (int x = rcSpareInverted.left; x < rcSpareInverted.right; x++)
                    {
                        RGBQUAD* prgb = &_pargbImage[x + Offset];
                        if (prgb->rgbReserved > 128)
                        {
                            prgb->rgbRed      = (prgb->rgbRed   * COLORBLEND_ALPHA + r) / 255;
                            prgb->rgbGreen    = (prgb->rgbGreen * COLORBLEND_ALPHA + g) / 255;
                            prgb->rgbBlue     = (prgb->rgbBlue  * COLORBLEND_ALPHA + b) / 255;
                        }
                    }
                }
            }
            else
            {
                ScaleAlpha(_pargbImage, &rcSpareInverted, aScale);

            }


            BitBlt(hdcDst, xDst, yDst, cx, cy, _hdcImage, rcSpare.left, rcSpare.top, SRCCOPY);
            return TRUE;
        }
    }

    return FALSE;
}


/*
** ImageList_Blend
**
**  copy the source to the dest blended with the given color.
**  top level function to decide what blend function to call
*/
BOOL CImageList::Blend(HDC hdcDst, int xDst, int yDst, int iImage, int cx, int cy, COLORREF rgb, UINT fStyle)
{
    BOOL fRet = FALSE;
    BITMAP bm;
    RECT rc;
    int bpp = GetDeviceCaps(hdcDst, BITSPIXEL);

    GetObject(_hbmImage, sizeof(bm), &bm);
    GetImageRect(iImage, &rc);

    //
    // if _hbmImage is a DIBSection and we are on a HiColor device
    // the do a "real" blend
    //
    if (bm.bmBits && bm.bmBitsPixel <= 8 && (bpp > 8 || bm.bmBitsPixel==8))
    {
        // blend from a 4bit or 8bit DIB
        BlendCT(hdcDst, xDst, yDst, rc.left, rc.top, cx, cy, rgb, fStyle);
    }
    else if (bm.bmBits && bm.bmBitsPixel == 16 && bpp > 8)
    {
        // blend from a 16bit 555 DIB
        Blend16(hdcDst, xDst, yDst, iImage, cx, cy, rgb, fStyle);
    }
    else if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
    {
        fRet = Blend32(hdcDst, xDst, yDst, iImage, cx, cy, rgb, fStyle);
    }
    else
    {
        // simulate a blend with a dither pattern.
        BlendDither(hdcDst, xDst, yDst, rc.left, rc.top, cx, cy, rgb, fStyle);
    }

    return fRet;
}

#define RGB_to_Gray(x) ((54 * GetRValue((x)) + 183 * GetGValue((x)) + 19 * GetBValue((x))) >> 8)

void TrueSaturateBits(void* pvBitmapBits, int Amount, int cx, int cy)
{
    ULONG* pulSrc = (ULONG*)pvBitmapBits;

    if ((cx > 0) && (cy > 0) && pulSrc)
    {
        for (int i = cx*cy - 1; i >= 0; i--)
        {
            /* 
            Enable this if you need true saturation adjustment
            justmann 25-JAN-2001

            ULONG ulR = GetRValue(*pulSrc);
            ULONG ulG = GetGValue(*pulSrc);
            ULONG ulB = GetBValue(*pulSrc);
            ulGray = (54 * ulR + 183 * ulG + 19 * ulB) >> 8;
            ULONG ulTemp = ulGray * (0xff - Amount);
            ulR = (ulR * Amount + ulTemp) >> 8;
            ulG = (ulG * Amount + ulTemp) >> 8;
            ulB = (ulB * Amount + ulTemp) >> 8;
            *pulSrc = (*pulSrc & 0xff000000) | RGB(R, G, B);
            */
            ULONG ulGray = RGB_to_Gray(*pulSrc);
            *pulSrc = (*pulSrc & 0xff000000) | RGB(ulGray, ulGray, ulGray);
            pulSrc++;
        }
    }
    else
    {
        // This should never happen, if it does somebody has a bogus DIB section or does not
        // understand what width or height is!
        ASSERT(0);
    }
}


BOOL CImageList::_MaskStretchBlt(BOOL fStretch, int i, HDC hdcDst, int xDst, int yDst, int cxDst, int cyDst,
                                   HDC hdcImage, int xSrc, int ySrc, int cxSrc, int cySrc,
                                   int xMask, int yMask,
                                   DWORD dwRop)
{
    BOOL fRet = TRUE;
    if (fStretch == FALSE)
    {
        fRet = MaskBlt(hdcDst, xDst, yDst, cxDst, cyDst, hdcImage, 
                xSrc, ySrc, _hbmMask, xMask, yMask, dwRop);
    }
    else
    {
        //
        //  we have some special cases:
        //
        //  if the background color is black, we just do a AND then OR
        //  if the background color is white, we just do a OR then AND
        //  otherwise change source, then AND then OR
        //

        COLORREF clrTextSave = SetTextColor(hdcDst, CLR_BLACK);
        COLORREF clrBkSave = ::SetBkColor(hdcDst, CLR_WHITE);

        // we cant do white/black special cases if we munged the mask or image

        if (i != -1 && _clrBk == CLR_WHITE)
        {
            StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, _hdcMask,  xMask, yMask, cxSrc, cySrc,  ROP_DSno);
            StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, hdcImage, xSrc, ySrc, cxSrc, cySrc, ROP_DSa);
        }
        else if (i != -1 && (_clrBk == CLR_BLACK || _clrBk == CLR_NONE))
        {
            StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, _hdcMask,  xMask, yMask, cxSrc, cySrc,  ROP_DSa);
            StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, hdcImage, xSrc, ySrc, cxSrc, cySrc, ROP_DSo);
        }
        else
        {
            // black out the source image.
            BitBlt(hdcImage, xSrc, ySrc, cxSrc, cySrc, _hdcMask, xMask, yMask, ROP_DSna);

            StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, _hdcMask, xMask, yMask, cxSrc, cySrc, ROP_DSa);
            StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, hdcImage, xSrc, ySrc, cxSrc, cySrc, ROP_DSo);

            if (i != -1)
                _ResetBkColor(i, i, _clrBk);
        }

        SetTextColor(hdcDst, clrTextSave);
        ::SetBkColor(hdcDst, clrBkSave);
    }

    return fRet;
}

BOOL CImageList::_StretchBlt(BOOL fStretch, HDC hdc, int x, int y, int cx, int cy, 
                             HDC hdcSrc, int xs, int ys, int cxs, int cys, DWORD dwRop)
{
    if (fStretch)
        return StretchBlt(hdc, x, y, cx, cy, 
                             hdcSrc, xs, ys, cxs, cys, dwRop);

    return BitBlt(hdc, x, y, cx, cy, hdcSrc, xs, ys, dwRop);
}

HRESULT CImageList::Draw(IMAGELISTDRAWPARAMS* pimldp) 
{
    RECT rcImage;
    RECT rc;
    HBRUSH  hbrT;

    BOOL fImage;
    HDC hdcMaskI;
    HDC hdcImageI;
    int xMask, yMask;
    int xImage, yImage;
    int cxSource, cySource;    
    DWORD dwOldStretchBltMode;
    BOOL fStretch;
    BOOL fDPIScale = FALSE;

    IMAGELISTDRAWPARAMS imldp = {0};


    if (pimldp->cbSize != sizeof(IMAGELISTDRAWPARAMS))
    {
        if (pimldp->cbSize == IMAGELISTDRAWPARAMS_V3_SIZE)
        {
            memcpy(&imldp, pimldp, IMAGELISTDRAWPARAMS_V3_SIZE);
            imldp.cbSize = sizeof(IMAGELISTDRAWPARAMS);
            pimldp = &imldp;
        }
        else
            return E_INVALIDARG;
    }
    
    if (!IsImageListIndex(pimldp->i))
        return E_INVALIDARG;

    //
    // If we need to use the mirrored imagelist, then let's set it.
    //
    if (_pimlMirror &&
        (IS_DC_RTL_MIRRORED(pimldp->hdcDst)))
    {
        return _pimlMirror->Draw(pimldp);
    }


    ENTERCRITICAL;

    dwOldStretchBltMode = SetStretchBltMode(pimldp->hdcDst, COLORONCOLOR);

    GetImageRect(pimldp->i, &rcImage);
    rcImage.left += pimldp->xBitmap;
    rcImage.top += pimldp->yBitmap;
        
    if (pimldp->rgbBk == CLR_DEFAULT)
        pimldp->rgbBk = _clrBk;

    if (pimldp->rgbBk == CLR_NONE)
        pimldp->fStyle |= ILD_TRANSPARENT;

    if (pimldp->cx == 0)
        pimldp->cx = RECTWIDTH(rcImage);

    if (pimldp->cy == 0)
        pimldp->cy = RECTHEIGHT(rcImage);

    BOOL    fImageHasAlpha = (_GetItemFlags(pimldp->i) & ILIF_ALPHA);
again:

    cxSource = RECTWIDTH(rcImage);
    cySource = RECTHEIGHT(rcImage);

    if (pimldp->cx <= 0 || pimldp->cy <= 0)
    {
        // caller asked to draw no (or negative) pixels; that's easy!
        // Early-out this case so other parts of the drawing
        // don't get confused.
        goto exit;
    }

    if (pimldp->fStyle & ILD_DPISCALE)
    {
        CCDPIScaleX(&pimldp->cx);
        CCDPIScaleY(&pimldp->cy);
        fDPIScale = TRUE;
    }

    fStretch = (pimldp->fStyle & ILD_SCALE) || (fDPIScale);

    if (fStretch)
    {
        dwOldStretchBltMode = SetStretchBltMode(pimldp->hdcDst, HALFTONE);
    }

    hdcMaskI = _hdcMask;
    xMask = rcImage.left;
    yMask = rcImage.top;

    hdcImageI = _hdcImage;
    xImage = rcImage.left;
    yImage = rcImage.top;

    if (pimldp->fStyle & ILD_BLENDMASK)
    {
        // make a copy of the image, because we will have to modify it
        hdcImageI = ImageList_GetWorkDC(pimldp->hdcDst, (_flags & ILC_COLORMASK) == ILC_COLOR32, pimldp->cx, pimldp->cy);
        xImage = 0;
        yImage = 0;

        //
        //  blend with the destination
        //  by "oring" the mask with a 50% dither mask
        //
        if (pimldp->rgbFg == CLR_NONE && hdcMaskI)
        {
            fImageHasAlpha = FALSE;
            if ((_flags & ILC_COLORMASK) == ILC_COLOR32 &&
                !(pimldp->fStyle & ILD_MASK))
            {
                // copy dest to our work buffer
                _StretchBlt(fStretch, hdcImageI, 0, 0, pimldp->cx, pimldp->cy, pimldp->hdcDst, pimldp->x, pimldp->y, cxSource, cySource, SRCCOPY);

                Blend32(hdcImageI, 0, 0, pimldp->i, pimldp->cx, pimldp->cy, pimldp->rgbFg, pimldp->fStyle);
            }
            else if ((_flags & ILC_COLORMASK) == ILC_COLOR16 &&
                !(pimldp->fStyle & ILD_MASK))
            {
                // copy dest to our work buffer
                _StretchBlt(fStretch, hdcImageI, 0, 0, pimldp->cx, pimldp->cy, pimldp->hdcDst, pimldp->x, pimldp->y, cxSource, cySource, SRCCOPY);

                // blend source into our work buffer
                Blend16(hdcImageI, 0, 0, pimldp->i, pimldp->cx, pimldp->cy, pimldp->rgbFg, pimldp->fStyle);
                pimldp->fStyle |= ILD_TRANSPARENT;
            }
            else
            {
                GetSpareImageRect(&rc);
                xMask = rc.left;
                yMask = rc.top;

                // copy the source image
                _StretchBlt(fStretch, hdcImageI, 0, 0, pimldp->cx, pimldp->cy,
                       _hdcImage, rcImage.left, rcImage.top, cxSource, cySource, SRCCOPY);

                // make a dithered copy of the mask
                hbrT = (HBRUSH)SelectObject(hdcMaskI, g_hbrMonoDither);
                _StretchBlt(fStretch, hdcMaskI, rc.left, rc.top, pimldp->cx, pimldp->cy,
                       _hdcMask, rcImage.left, rcImage.top, cxSource, cySource, ROP_PSo);
                SelectObject(hdcMaskI, hbrT);
                pimldp->fStyle |= ILD_TRANSPARENT;
            }

        }
        else
        {
            // blend source into our work buffer
            if (Blend(hdcImageI, 0, 0, pimldp->i, pimldp->cx, pimldp->cy, pimldp->rgbFg, pimldp->fStyle))
            {
                fImageHasAlpha = (_flags & ILC_COLORMASK) == ILC_COLOR32;
            }
        }
    }

    // is the source image from the image list (not hdcWork)
    fImage = hdcImageI == _hdcImage;

    if (pimldp->cbSize >= sizeof(IMAGELISTDRAWPARAMS) &&
        pimldp->fState & ILS_GLOW       || 
        pimldp->fState & ILS_SHADOW     ||
        pimldp->fState & ILS_SATURATE   ||
        pimldp->fState & ILS_ALPHA)
    {
        int z;
        ULONG* pvBits;
        HDC hdcMem = CreateCompatibleDC(pimldp->hdcDst);
        HBITMAP hbmpOld;
        HBITMAP hbmp;
        BITMAPINFO bi = {0};
        BLENDFUNCTION bf = {0};
        DWORD dwAlphaAmount = 0x000000ff;
        COLORREF crAlphaColor = pimldp->crEffect;        // Need to make this a selectable color
        int x, y;
        int xOffset, yOffset;
        SIZE size = {cxSource, cySource};

        if (hdcMem)
        {
            if (pimldp->fState & ILS_SHADOW)
            {
                x = 5;      // This is a "Blur fudge Factor"
                y = 5;      //
                xOffset = -(DROP_SHADOW - x);
                yOffset = -(DROP_SHADOW - y);
                size.cx = pimldp->cx + 10;
                size.cy = pimldp->cy + 10;
                dwAlphaAmount = 0x00000050;
                crAlphaColor = RGB(0, 0, 0);
            }
            else if (pimldp->fState & ILS_GLOW)
            {
                xOffset = x = 10;
                yOffset = y = 10;
                size.cx = pimldp->cx + (GLOW_RADIUS * 2);
                size.cy = pimldp->cy + (GLOW_RADIUS * 2);
            }
            else if (pimldp->fState & ILS_ALPHA)
            {
                xOffset = x = 0;
                yOffset = y = 0;
                size.cx = pimldp->cx;
                size.cy = pimldp->cy;
            }

            bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
            bi.bmiHeader.biWidth = size.cx;
            bi.bmiHeader.biHeight = size.cy;
            bi.bmiHeader.biPlanes = 1;
            bi.bmiHeader.biBitCount = 32;
            bi.bmiHeader.biCompression = BI_RGB;

            hbmp = CreateDIBSection(hdcMem, &bi, DIB_RGB_COLORS, (VOID**)&pvBits, NULL, 0);
            if (hbmp)
            {
                hbmpOld = (HBITMAP)SelectObject(hdcMem, hbmp);

                ZeroMemory(pvBits, size.cx * size.cy);

                if (pimldp->fState & ILS_SHADOW || pimldp->fState & ILS_GLOW || pimldp->fState & ILS_ALPHA)
                {
                    if (_hbmMask)
                    {
                        MaskBlt(hdcMem, pimldp->x, pimldp->y, size.cx, size.cy, 
                            hdcImageI, xImage, yImage, _hbmMask, xMask, yMask, 0xCCAA0000);
                    }
                    else if (pimldp->fState & ILS_SHADOW)
                    {
                        RECT rc = {x, y, size.cx, size.cy};
                        FillRectClr(hdcMem, &rc, RGB(0x0F, 0x0F, 0x0F));        // White so that it gets inverted into a shadow
                    }
                    else
                    {
                        BitBlt(hdcMem, x, y, size.cx, size.cy, hdcImageI, xImage, yImage, SRCCOPY);
                    }

                    int iTotalSize = size.cx * size.cy;

                    if (pimldp->fState & ILS_ALPHA)
                    {
                        for (z = 0; z < iTotalSize; z++)
                        {
                            RGBQUAD* prgb = &((RGBQUAD*)pvBits)[z];
                            prgb->rgbReserved  = (BYTE)(pimldp->Frame & 0xFF);
                            prgb->rgbRed      = ((prgb->rgbRed   * prgb->rgbReserved) + 128) / 255;
                            prgb->rgbGreen    = ((prgb->rgbGreen * prgb->rgbReserved) + 128) / 255;
                            prgb->rgbBlue     = ((prgb->rgbBlue  * prgb->rgbReserved) + 128) / 255;
                        }
                    }
                    else
                    {
                        for (z = 0; z < iTotalSize; z++)
                        {
                            if (((PULONG)pvBits)[z] != 0)
                                ((PULONG)pvBits)[z] = dwAlphaAmount;
                        }

                        BlurBitmap(pvBits, size.cx, size.cy, crAlphaColor);

                        if (!(pimldp->fState & ILS_SHADOW))
                        {
                            for (z = 0; z < iTotalSize; z++)
                            {
                                if (((PULONG)pvBits)[z] > 0x09000000)
                                    ((PULONG)pvBits)[z] = dwAlphaAmount;
                            }
                            BlurBitmap(pvBits, size.cx, size.cy, crAlphaColor);
                            BlurBitmap(pvBits, size.cx, size.cy, crAlphaColor);
                        }
                    }

                    bf.BlendOp = AC_SRC_OVER;
                    bf.SourceConstantAlpha = 255;
                    bf.AlphaFormat = AC_SRC_ALPHA;
                    bf.BlendFlags = fDPIScale?AC_USE_HIGHQUALITYFILTER:0;
                    // Do not mirror the bitmap. By this point it is correctly mirrored
                    GdiAlphaBlend(pimldp->hdcDst, pimldp->x - xOffset, pimldp->y - yOffset, pimldp->cx, pimldp->cy, 
                               hdcMem, 0, 0, size.cx, size.cy, bf);
                }
                else
                {
                    BitBlt(hdcMem, 0, 0, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, SRCCOPY);

                    TrueSaturateBits(pvBits, pimldp->Frame, size.cx, size.cy);

                    if (fImageHasAlpha)
                    {
                        bf.BlendOp = AC_SRC_OVER;
                        bf.SourceConstantAlpha = 150;
                        bf.AlphaFormat = AC_SRC_ALPHA;
                        // Do not mirror the bitmap. By this point it is correctly mirrored
                        GdiAlphaBlend(pimldp->hdcDst,  pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcMem, 0, 0, cxSource, cySource, bf);
                    }
                    else if (_hbmMask)
                    {
                        _MaskStretchBlt(fStretch, -1, hdcMem, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, 
                            hdcMem, 0, 0, cxSource, cySource, xMask, yMask, 0xCCAA0000);
                    }
                    else
                    {
                        _StretchBlt(fStretch, pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcMem, 0, 0, cxSource,cySource, SRCCOPY);
                    }
                }

                SelectObject(hdcMem, hbmpOld);
                DeleteObject(hbmp);
                pimldp->fStyle |= ILD_TRANSPARENT;
            }
            DeleteDC(hdcMem);
        }

        if (pimldp->fState & ILS_SHADOW || pimldp->fState & ILS_GLOW)
        {
            if (pimldp->fState & ILS_SHADOW)
            {
                pimldp->fState &= ~ILS_SHADOW;
                //pimldp->x -= DROP_SHADOW;
                //pimldp->y -= DROP_SHADOW;
            }
            else
            {
                pimldp->fState &= ~ILS_GLOW;
            }
            goto again;
        }
    }
    else if ((pimldp->fStyle & ILD_MASK) && hdcMaskI)
    {
    //
    // ILD_MASK means draw the mask only
    //
        DWORD dwRop;
        
        ASSERT(GetTextColor(pimldp->hdcDst) == CLR_BLACK);
        ASSERT(::GetBkColor(pimldp->hdcDst) == CLR_WHITE);
        
        if (pimldp->fStyle & ILD_ROP)
            dwRop = pimldp->dwRop;
        else if (pimldp->fStyle & ILD_TRANSPARENT)
            dwRop = SRCAND;
        else 
            dwRop = SRCCOPY;
        
        _StretchBlt(fStretch, pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcMaskI, xMask, yMask, cxSource, cySource, dwRop);
    }
    else if (fImageHasAlpha &&                      // this image has alpha
             !(pimldp->fStyle & ILD_PRESERVEALPHA)) // But not if we're trying to preserve it.
    {
        if (!(pimldp->fStyle & ILD_TRANSPARENT))
        {
            COLORREF clr = pimldp->rgbBk;
            if (clr == CLR_DEFAULT) 
                clr = _clrBk;

            RECT rc = {pimldp->x, pimldp->y, pimldp->x + pimldp->cx, pimldp->y + pimldp->cy};
            FillRectClr(pimldp->hdcDst, &rc, clr);
        }

        BLENDFUNCTION bf = {0};
        bf.BlendOp = AC_SRC_OVER;
        bf.SourceConstantAlpha = 255;
        bf.AlphaFormat = AC_SRC_ALPHA;
        bf.BlendFlags = AC_MIRRORBITMAP | (fDPIScale?AC_USE_HIGHQUALITYFILTER:0);
        GdiAlphaBlend(pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, cxSource, cySource, bf);
    }
    else if (pimldp->fStyle & ILD_IMAGE)
    {
        COLORREF clrBk = ::GetBkColor(hdcImageI);
        DWORD dwRop;
        
        if (pimldp->rgbBk != CLR_DEFAULT) 
        {
            ::SetBkColor(hdcImageI, pimldp->rgbBk);
        }
        
        if (pimldp->fStyle & ILD_ROP)
            dwRop = pimldp->dwRop;
        else
            dwRop = SRCCOPY;
        
        _StretchBlt(fStretch, pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, cxSource, cySource, dwRop);
        
        ::SetBkColor(hdcImageI, clrBk);
    }
    else if ((pimldp->fStyle & ILD_TRANSPARENT) && hdcMaskI)
    {
        _MaskStretchBlt(fStretch, fImage?pimldp->i:-1,pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, 
            hdcImageI, xImage, yImage, cxSource, cySource, xMask, yMask, 0xCCAA0000);
    }
    else if (fImage && pimldp->rgbBk == _clrBk && _fSolidBk)
    {
        _StretchBlt(fStretch, pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, cxSource, cySource, SRCCOPY);
    }
    else if (hdcMaskI && !fImageHasAlpha)
    {
        if (fImage && 
            ((pimldp->rgbBk == _clrBk && 
               !_fSolidBk) || 
              GetNearestColor32(hdcImageI, pimldp->rgbBk) != pimldp->rgbBk))
        {
            // make a copy of the image, because we will have to modify it
            hdcImageI = ImageList_GetWorkDC(pimldp->hdcDst, (_flags & ILC_COLORMASK) == ILC_COLOR32, pimldp->cx, pimldp->cy);
            xImage = 0;
            yImage = 0;
            fImage = FALSE;

            BitBlt(hdcImageI, 0, 0, pimldp->cx, pimldp->cy, _hdcImage, rcImage.left, rcImage.top, SRCCOPY);
        }

        SetBrushOrgEx(hdcImageI, xImage-pimldp->x, yImage-pimldp->y, NULL);
        hbrT = SelectBrush(hdcImageI, CreateSolidBrush(pimldp->rgbBk));
        BitBlt(hdcImageI, xImage, yImage, pimldp->cx, pimldp->cy, hdcMaskI, xMask, yMask, ROP_PatMask);
        DeleteObject(SelectBrush(hdcImageI, hbrT));
        SetBrushOrgEx(hdcImageI, 0, 0, NULL);

        _StretchBlt(fStretch, pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, cxSource, cySource, SRCCOPY);

        if (fImage)
            _ResetBkColor(pimldp->i, pimldp->i, _clrBk);
    }
    else
    {
        _StretchBlt(fStretch, pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, cxSource, cySource, SRCCOPY);
    }

    //
    // now deal with a overlay image, use the minimal bounding rect (and flags)
    // we computed in ImageList_SetOverlayImage()
    //
    if (pimldp->fStyle & ILD_OVERLAYMASK)
    {
        int n = OVERLAYMASKTOINDEX(pimldp->fStyle);

        if (n < NUM_OVERLAY_IMAGES) 
        {
            pimldp->i = _aOverlayIndexes[n];

            if (!fImageHasAlpha)
                pimldp->fStyle &= ~ILD_PRESERVEALPHA;

            if (pimldp->fStyle & ILD_PRESERVEALPHA &&
                !(_GetItemFlags(pimldp->i) & ILIF_ALPHA))
            {
                _GenerateAlphaForImageUsingMask(pimldp->i, FALSE);
            }

            fImageHasAlpha = (_GetItemFlags(pimldp->i) & ILIF_ALPHA);

            GetImageRect(pimldp->i, &rcImage);

            int xOverlay  = _aOverlayX[n];
            int yOverlay  = _aOverlayY[n];
            int cxOverlay = _aOverlayDX[n];
            int cyOverlay = _aOverlayDY[n];

            if (fDPIScale)
            {
                CCDPIScaleX(&xOverlay );
                CCDPIScaleY(&yOverlay );
            }


            pimldp->cx = cxOverlay;
            pimldp->cy = cyOverlay;
            pimldp->x += xOverlay;
            pimldp->y += yOverlay;

            rcImage.left += _aOverlayX[n] + pimldp->xBitmap;
            rcImage.top  += _aOverlayY[n] + pimldp->yBitmap;
            rcImage.right = rcImage.left + _aOverlayDX[n];
            rcImage.bottom = rcImage.top + _aOverlayDY[n];



            pimldp->fStyle &= ILD_MASK;
            pimldp->fStyle |= ILD_TRANSPARENT;
            pimldp->fStyle |= (fDPIScale?ILD_DPISCALE:0);
            pimldp->fStyle |= _aOverlayF[n];

            if (fImageHasAlpha)
                pimldp->fStyle &= ~(ILD_IMAGE);


            if (pimldp->cx > 0 && pimldp->cy > 0)
                goto again;
        }
    }

    if (!fImage)
    {
        ImageList_ReleaseWorkDC(hdcImageI);
    }

exit:
    SetStretchBltMode(pimldp->hdcDst, dwOldStretchBltMode);

    LEAVECRITICAL;

    return S_OK;
}


HRESULT CImageList::GetImageInfo(int i, IMAGEINFO * pImageInfo)
{
    RIPMSG(pImageInfo != NULL, "ImageList_GetImageInfo: Invalid NULL pointer");
    RIPMSG(IsImageListIndex(i), "ImageList_GetImageInfo: Invalid image index %d", i);
    if (!pImageInfo || !IsImageListIndex(i))
        return E_POINTER;

    pImageInfo->hbmImage      = _hbmImage;
    pImageInfo->hbmMask       = _hbmMask;

    return GetImageRect(i, &pImageInfo->rcImage);
}

//
// Parameter:
//  i -- -1 to add
//
HRESULT CImageList::_ReplaceIcon(int i, HICON hIcon, int* pi)
{
    HICON hIconT = hIcon;
    RECT rc;
    HRESULT hr = S_OK;

    TraceMsg(TF_IMAGELIST, "ImageList_ReplaceIcon");
    
    *pi = -1;
    
    // be win95 compatible
    if (i < -1)
        return E_INVALIDARG;
    

    //
    //  re-size the icon (iff needed) by calling CopyImage
    //
    hIcon = (HICON)CopyImage(hIconT, IMAGE_ICON, _cx, _cy, LR_COPYFROMRESOURCE | LR_COPYRETURNORG);

    if (hIcon == NULL)
        return E_OUTOFMEMORY;

    //
    //  alocate a slot for the icon
    //
    if (i == -1)
        hr = _Add(NULL,NULL,1,0,0,&i);

    if (i == -1)
        goto exit;

    ENTERCRITICAL;

    //
    //  now draw it into the image bitmaps
    //
    hr = GetImageRect(i, &rc);
    if (FAILED(hr))
        goto LeaveCritical;

    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
    {

        BOOL fSuccess = FALSE;
        ICONINFO io;
        if (GetIconInfo(hIcon, &io))
        {
            BITMAP bm;
            if (GetObject(io.hbmColor, sizeof(bm), &bm))
            {
                if (bm.bmBitsPixel == 32)
                {
                    HDC h = CreateCompatibleDC(_hdcImage);

                    if (h)
                    {
                        HBITMAP hbmpOld = (HBITMAP)SelectObject(h, io.hbmColor);

                        BitBlt(_hdcImage, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), h, 0, 0, SRCCOPY);

                        if (_HasAlpha(i))
                        {
                            SetItemFlags(i, ILIF_ALPHA);
                            _PreProcessImage(i);
                            fSuccess = TRUE;
                        }

                        SelectObject(h, hbmpOld);
                        DeleteDC(h);
                    }
                }
            }

            DeleteObject(io.hbmColor);
            DeleteObject(io.hbmMask);
        }

        if (!fSuccess)
        {
            // If it doesn't have alpha or we can't get info
            SetItemFlags(i, 0);
        }

    }

    if (_GetItemFlags(i) == 0)
    {
        FillRect(_hdcImage, &rc, _hbrBk);
        DrawIconEx(_hdcImage, rc.left, rc.top, hIcon, 0, 0, 0, NULL, DI_NORMAL);
    }

    if (_hdcMask)
        DrawIconEx(_hdcMask, rc.left, rc.top, hIcon, 0, 0, 0, NULL, DI_MASK);


    hr = S_OK;

    *pi = i;

LeaveCritical:
    LEAVECRITICAL;

exit:

    //
    // if we had user size a new icon, delete it.
    //
    if (hIcon != hIconT)
        DestroyIcon(hIcon);

    return hr;
}

HRESULT CImageList::ReplaceIcon(int i, HICON hIcon, int* pi)
{
    // Let's add it first to the mirrored image list, if one exists
    if (_pimlMirror)
    {
        HICON hIconT = CopyIcon(hIcon);
        if (hIconT)
        {
            MirrorIcon(&hIconT, NULL);
            _pimlMirror->_ReplaceIcon(i, hIconT, pi);
            DestroyIcon(hIconT);
        }
    }

    return _ReplaceIcon(i, hIcon,pi);
}

// make a dithered copy of the source image in the destination image.
// allows placing of the final image in the destination.

HRESULT CImageList::CopyDitherImage(WORD iDst, int xDst, int yDst, IUnknown* punkSrc, int iSrc, UINT fStyle)
{
    IImageList* pux;
    HRESULT hr = punkSrc->QueryInterface(IID_PPV_ARG(IImageList, &pux));

    if (FAILED(hr))
        return hr;

    RECT rc;
    int x, y;

    GetImageRect(iDst, &rc);

    // coordinates in destination image list
    x = xDst + rc.left;
    y = yDst + rc.top;

    fStyle &= ILD_OVERLAYMASK;
    WimpyDrawEx(pux, iSrc, _hdcImage, x, y, 0, 0, CLR_DEFAULT, CLR_NONE, ILD_IMAGE | fStyle);

    //
    // dont dither the mask on a hicolor device, we will draw the image
    // with blending while dragging.
    //
    if (_hdcMask && GetScreenDepth() > 8)
    {
        WimpyDrawEx(pux, iSrc, _hdcMask, x, y, 0, 0, CLR_NONE, CLR_NONE, ILD_MASK | fStyle);
    }
    else if (_hdcMask)
    {
        WimpyDrawEx(pux, iSrc, _hdcMask,  x, y, 0, 0, CLR_NONE, CLR_NONE, ILD_BLEND50|ILD_MASK | fStyle);
    }

    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
    {
        SetItemFlags(iDst, _HasAlpha(iDst)?ILIF_ALPHA:0);
    }


    _ResetBkColor(iDst, iDst+1, _clrBk);

    pux->Release();

    return hr;
}

//
// ImageList_CopyBitmap
//
// Worker function for ImageList_Duplicate.
//
// Given a bitmap and an hdc, creates and returns a copy of the passed in bitmap.
//
HBITMAP CImageList::_CopyBitmap(HBITMAP hbm, HDC hdc)
{
    ASSERT(hbm);

    BITMAP bm;
    HBITMAP hbmCopy = NULL;

    if (GetObject(hbm, sizeof(bm), &bm) == sizeof(bm))
    {
        ENTERCRITICAL;
        if (hbmCopy = CreateCompatibleBitmap(hdc, bm.bmWidth, bm.bmHeight))
        {
            CImageList::SelectDstBitmap(hbmCopy);

            BitBlt(g_hdcDst, 0, 0, bm.bmWidth, bm.bmHeight,
                    hdc, 0, 0, SRCCOPY);

            CImageList::SelectDstBitmap(NULL);
        }
        LEAVECRITICAL;
    }
    return hbmCopy;
}

HBITMAP CImageList::_CopyDIBBitmap(HBITMAP hbm, HDC hdc, RGBQUAD** ppargb)
{
    ASSERT(hbm);

    BITMAP bm;
    HBITMAP hbmCopy = NULL;

    if (GetObject(hbm, sizeof(bm), &bm) == sizeof(bm))
    {
        ENTERCRITICAL;
        hbmCopy = _CreateBitmap(bm.bmWidth, bm.bmHeight, ppargb);

        if (hbmCopy)
        {
            CImageList::SelectDstBitmap(hbmCopy);

            BitBlt(g_hdcDst, 0, 0, bm.bmWidth, bm.bmHeight,
                    hdc, 0, 0, SRCCOPY);

            CImageList::SelectDstBitmap(NULL);
        }
        LEAVECRITICAL;
    }
    return hbmCopy;
}


HRESULT CImageList::Clone(REFIID riid, void** ppv)
{
    HBITMAP hbmImageI;
    HBITMAP hbmMaskI = NULL;
    RGBQUAD* pargbImageI;
    HDSA dsaFlags = NULL;
    HRESULT hr = S_OK;
    CImageList* pimlCopy = NULL;

    *ppv = NULL;

    ENTERCRITICAL;

    hbmImageI = _CopyDIBBitmap(_hbmImage, _hdcImage, &pargbImageI);
    if (!hbmImageI)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
    {

        if (_hdcMask)
        {
            hbmMaskI = _CopyBitmap(_hbmMask, _hdcMask);
            if (!hbmMaskI)
                hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr) && (_flags & ILC_COLORMASK) == ILC_COLOR32)
        {
            dsaFlags = DSA_Create(sizeof(DWORD), _cGrow);
            if (dsaFlags)
            {
                DWORD dw;
                for (int i = 0; i < _cImage; i++)
                {
                    DSA_GetItem(_dsaFlags, i, &dw);
                    if (!DSA_SetItem(dsaFlags, i, &dw))
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            pimlCopy = CImageList::Create(_cx, _cy, _flags, 0, _cGrow);

            if (pimlCopy) 
            {
                // Slam in our bitmap copies and delete the old ones
                SelectObject(pimlCopy->_hdcImage, hbmImageI);
                CImageList::_DeleteBitmap(pimlCopy->_hbmImage);
                if (pimlCopy->_hdcMask) 
                {
                    SelectObject(pimlCopy->_hdcMask, hbmMaskI);
                    CImageList::_DeleteBitmap(pimlCopy->_hbmMask);
                }

                if (pimlCopy->_dsaFlags)
                    DSA_Destroy(pimlCopy->_dsaFlags);

                pimlCopy->_dsaFlags = dsaFlags;
                pimlCopy->_hbmImage = hbmImageI;
                pimlCopy->_pargbImage = pargbImageI;
                pimlCopy->_hbmMask = hbmMaskI;

                // Make sure other info is correct
                pimlCopy->_cImage = _cImage;
                pimlCopy->_cAlloc = _cAlloc;
                pimlCopy->_cStrip = _cStrip;
                pimlCopy->_clrBlend = _clrBlend;
                pimlCopy->_clrBk = _clrBk;

                // Delete the old brush and create the correct one
                if (pimlCopy->_hbrBk)
                    DeleteObject(pimlCopy->_hbrBk);
                if (pimlCopy->_clrBk == CLR_NONE)
                {
                    pimlCopy->_hbrBk = (HBRUSH)GetStockObject(BLACK_BRUSH);
                    pimlCopy->_fSolidBk = TRUE;
                }
                else
                {
                    pimlCopy->_hbrBk = CreateSolidBrush(pimlCopy->_clrBk);
                    pimlCopy->_fSolidBk = GetNearestColor32(pimlCopy->_hdcImage, pimlCopy->_clrBk) == pimlCopy->_clrBk;
                }
            } 
        }

        LEAVECRITICAL;
    }

    if (FAILED(hr))
    {
        if (hbmImageI)
            CImageList::_DeleteBitmap(hbmImageI);
        if (hbmMaskI)
            CImageList::_DeleteBitmap(hbmMaskI);
        if (dsaFlags)
            DSA_Destroy(dsaFlags);
    }

    if (pimlCopy)
    {
        hr = pimlCopy->QueryInterface(riid, ppv);
        pimlCopy->Release();
    }

    return hr;

}

void CImageList::_Merge(IImageList* pux, int i, int dx, int dy)
{
    if (_hdcMask)
    {
        IImageListPriv* puxp;
        if (SUCCEEDED(pux->QueryInterface(IID_PPV_ARG(IImageListPriv, &puxp))))
        {
            HDC hdcMaskI;
            if (SUCCEEDED(puxp->GetPrivateGoo(NULL, NULL, NULL, &hdcMaskI)) && hdcMaskI)
            {
                RECT rcMerge;
                int cxI, cyI;
                pux->GetIconSize(&cxI, &cyI);

                UINT uFlags = 0;
                puxp->GetFlags(&uFlags);
                pux->GetImageRect(i, &rcMerge);

                BitBlt(_hdcMask, dx, dy, cxI, cyI,
                       hdcMaskI, rcMerge.left, rcMerge.top, SRCAND);
            }
            puxp->Release();
        }
    }

    WimpyDraw(pux, i, _hdcImage, dx, dy, ILD_TRANSPARENT | ILD_PRESERVEALPHA);

    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
        SetItemFlags(i, _HasAlpha(i)? ILIF_ALPHA : 0);
}

HRESULT CImageList::_Merge(int i1, IUnknown* punk, int i2, int dx, int dy, CImageList** ppiml)
{
    CImageList* pimlNew = NULL;
    IImageListPriv* puxp;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IImageListPriv, &puxp));
    if (SUCCEEDED(hr))
    {
        IImageList* pux;
        hr = punk->QueryInterface(IID_PPV_ARG(IImageList, &pux));
        if (SUCCEEDED(hr))
        {
            RECT rcNew;
            RECT rc1;
            RECT rc2;
            int cxI, cyI;
            int c1, c2;
            UINT wFlags;
            UINT uSrcFlags;

            puxp->GetFlags(&uSrcFlags);
            pux->GetIconSize(&cxI, &cyI);

            ENTERCRITICAL;

            SetRect(&rc1, 0, 0, _cx, _cy);
            SetRect(&rc2, dx, dy, cxI + dx, cyI + dy);
            UnionRect(&rcNew, &rc1, &rc2);

            cxI = RECTWIDTH(rcNew);
            cyI = RECTHEIGHT(rcNew);

            //
            // If one of images are shared, create a shared image.
            //
            wFlags = (_flags | uSrcFlags) & ~ILC_COLORMASK;

            c1 = (_flags & ILC_COLORMASK);
            c2 = (uSrcFlags & ILC_COLORMASK);

            if ((c1 == 16 || c1 == 32) && c2 == ILC_COLORDDB)
            {
                c2 = c1;
            }

            wFlags |= max(c1,c2);

            pimlNew = CImageList::Create(cxI, cyI, ILC_MASK|wFlags, 1, 0);
            if (pimlNew)
            {
                pimlNew->_cImage++;

                if (pimlNew->_hdcMask) 
                    PatBlt(pimlNew->_hdcMask,  0, 0, cxI, cyI, WHITENESS);
                PatBlt(pimlNew->_hdcImage, 0, 0, cxI, cyI, BLACKNESS);

                pimlNew->_Merge(SAFECAST(this, IImageList*), i1, rc1.left - rcNew.left, rc1.top - rcNew.top);
                pimlNew->_Merge(pux, i2, rc2.left - rcNew.left, rc2.top - rcNew.top);
            }
            else
                hr = E_OUTOFMEMORY;

            LEAVECRITICAL;
            pux->Release();
        }
        puxp->Release();
    }

    *ppiml = pimlNew;

    return hr;
}

HRESULT CImageList::Merge(int i1, IUnknown* punk, int i2, int dx, int dy, REFIID riid, void** ppv)
{
    CImageList* piml;
    HRESULT hr = _Merge(i1, punk, i2, dx, dy, &piml);

    if (piml)
    {
        hr = piml->QueryInterface(riid, ppv);
        piml->Release();
    }

    return hr;
}

HRESULT CImageList::GetImageRectInverted(int i, RECT * prcImage)
{
    int x, y;
    ASSERT(prcImage);
    ASSERT(_cStrip == 1);   // If not, modify below to accomodate

    if (!prcImage || !IsImageListIndex(i))
        return E_FAIL;

    x = 0;
    y = (_cy * _cAlloc) - (_cy * i) - _cy;

    SetRect(prcImage, x, y, x + _cx, y + _cy);
    return S_OK;
}

HRESULT CImageList::GetImageRect(int i, RECT * prcImage)
{
    int x, y;
    ASSERT(prcImage);

    if (!prcImage || !IsImageListIndex(i))
        return E_FAIL;

    x = _cx * (i % _cStrip);
    y = _cy * (i / _cStrip);

    SetRect(prcImage, x, y, x + _cx, y + _cy);
    return S_OK;
}


BOOL CImageList::GetSpareImageRect(RECT * prcImage)
{
    BOOL fRet = FALSE;
    if (_cImage < _cAlloc)
    {
        // special hacking to use the one scratch image at tail of list :)
        _cImage++;
        fRet = (S_OK == GetImageRect(_cImage-1, prcImage));
        _cImage--;
    }

    return fRet;
}

BOOL CImageList::GetSpareImageRectInverted(RECT * prcImage)
{
    BOOL fRet = FALSE;
    if (_cImage < _cAlloc)
    {
        // special hacking to use the one scratch image at tail of list :)
        _cImage++;
        fRet = (S_OK == GetImageRectInverted(_cImage-1, prcImage));
        _cImage--;
    }

    return fRet;
}


// Drag Drop
// copy an image from one imagelist to another at x,y within iDst in pimlDst.
// pimlDst's image size should be larger than pimlSrc
void CImageList::_CopyOneImage(int iDst, int x, int y, CImageList* piml, int iSrc)
{
    RECT rcSrc, rcDst;


    piml->GetImageRect(iSrc, &rcSrc);
    GetImageRect(iDst, &rcDst);

    if (piml->_hdcMask && _hdcMask)
    {
        BitBlt(_hdcMask, rcDst.left + x, rcDst.top + y, piml->_cx, piml->_cy,
               piml->_hdcMask, rcSrc.left, rcSrc.top, SRCCOPY);

    }

    BitBlt(_hdcImage, rcDst.left + x, rcDst.top + y, piml->_cx, piml->_cy,
           piml->_hdcImage, rcSrc.left, rcSrc.top, SRCCOPY);


    if ((_flags & ILC_COLORMASK) == ILC_COLOR32)
        SetItemFlags(iDst, _HasAlpha(iDst)? ILIF_ALPHA : 0);
}


//
//  Cached bitmaps that we use during drag&drop. We re-use those bitmaps
// across multiple drag session as far as the image size is the same.
//
struct DRAGRESTOREBMP 
{
    int     BitsPixel;
    HBITMAP hbmOffScreen;
    HBITMAP hbmRestore;
    SIZE    sizeRestore;
} 
g_drb = 
{
    0, NULL, NULL, {-1,-1}
};

BOOL CImageList::CreateDragBitmaps()
{
    HDC hdc;

    hdc = GetDC(NULL);

    if (_cx != g_drb.sizeRestore.cx ||
        _cy != g_drb.sizeRestore.cy ||
        GetDeviceCaps(hdc, BITSPIXEL) != g_drb.BitsPixel)
    {
        ImageList_DeleteDragBitmaps();

        g_drb.BitsPixel      = GetDeviceCaps(hdc, BITSPIXEL);
        g_drb.sizeRestore.cx = _cx;
        g_drb.sizeRestore.cy = _cy;
        g_drb.hbmRestore   = CreateColorBitmap(g_drb.sizeRestore.cx, g_drb.sizeRestore.cy);
        g_drb.hbmOffScreen = CreateColorBitmap(g_drb.sizeRestore.cx * 2 - 1, g_drb.sizeRestore.cy * 2 - 1);


        if (!g_drb.hbmRestore || !g_drb.hbmOffScreen)
        {
            ImageList_DeleteDragBitmaps();
            ReleaseDC(NULL, hdc);
            return FALSE;
        }
    }
    ReleaseDC(NULL, hdc);
    return TRUE;
}

void ImageList_DeleteDragBitmaps()
{
    if (g_drb.hbmRestore)
    {
        CImageList::_DeleteBitmap(g_drb.hbmRestore);
        g_drb.hbmRestore = NULL;
    }
    if (g_drb.hbmOffScreen)
    {
        CImageList::_DeleteBitmap(g_drb.hbmOffScreen);
        g_drb.hbmOffScreen = NULL;
    }

    g_drb.sizeRestore.cx = -1;
    g_drb.sizeRestore.cy = -1;
}

//
//  Drag context. We don't reuse none of them across two different
// drag sessions. I'm planning to allocate it for each session
// to minimize critical sections.
//
struct DRAGCONTEXT 
{
    CImageList* pimlDrag;    // Image to be drawin while dragging
    IImageList* puxCursor;  // Overlap cursor image
    CImageList* pimlDither;  // Dithered image
    IImageList* puxDragImage; // The context of the drag.
    int        iCursor;     // Image index of the cursor
    POINT      ptDrag;      // current drag position (hwndDC coords)
    POINT      ptDragHotspot;
    POINT      ptCursor;
    BOOL       fDragShow;
    BOOL       fHiColor;
    HWND       hwndDC;
} 
g_dctx = 
{
    (CImageList*)NULL, (CImageList*)NULL, (CImageList*)NULL, (IImageList*)NULL,
    -1,
    {0, 0}, {0, 0}, {0, 0},
    FALSE,
    FALSE,
    (HWND)NULL
};

HDC ImageList_GetDragDC()
{
    HDC hdc = GetDCEx(g_dctx.hwndDC, NULL, DCX_WINDOW | DCX_CACHE | DCX_LOCKWINDOWUPDATE);
    //
    // If hdc is mirrored then mirror the 2 globals DCs.
    //
    if (IS_DC_RTL_MIRRORED(hdc)) 
    {
        SET_DC_RTL_MIRRORED(g_hdcDst);
        SET_DC_RTL_MIRRORED(g_hdcSrc);
    }
    return hdc;
}

void ImageList_ReleaseDragDC(HDC hdc)
{
    //
    // If the hdc is mirrored then unmirror the 2 globals DCs.
    //
    if (IS_DC_RTL_MIRRORED(hdc)) 
    {
        SET_DC_LAYOUT(g_hdcDst, 0);
        SET_DC_LAYOUT(g_hdcSrc, 0);
    }

    ReleaseDC(g_dctx.hwndDC, hdc);
}

//
//  x, y     -- Specifies the initial cursor position in the coords of hwndLock,
//              which is specified by the previous ImageList_StartDrag call.
//
HRESULT CImageList::DragMove(int x, int y)
{
    int IncOne = 0;
    ENTERCRITICAL;
    if (g_dctx.fDragShow)
    {
        RECT rcOld, rcNew, rcBounds;
        int dx, dy;

        dx = x - g_dctx.ptDrag.x;
        dy = y - g_dctx.ptDrag.y;
        rcOld.left = g_dctx.ptDrag.x - g_dctx.ptDragHotspot.x;
        rcOld.top = g_dctx.ptDrag.y - g_dctx.ptDragHotspot.y;
        rcOld.right = rcOld.left + g_drb.sizeRestore.cx;
        rcOld.bottom = rcOld.top + g_drb.sizeRestore.cy;
        rcNew = rcOld;
        OffsetRect(&rcNew, dx, dy);

        if (!IntersectRect(&rcBounds, &rcOld, &rcNew))
        {
            //
            // No intersection. Simply hide the old one and show the new one.
            //
            ImageList_DragShowNolock(FALSE);
            g_dctx.ptDrag.x = x;
            g_dctx.ptDrag.y = y;
            ImageList_DragShowNolock(TRUE);
        }
        else
        {
            //
            // Some intersection.
            //
            HDC hdcScreen;
            int cx, cy;

            UnionRect(&rcBounds, &rcOld, &rcNew);

            hdcScreen = ImageList_GetDragDC();
            if (hdcScreen)
            {
                //
                // If the DC is RTL mirrored, then restrict the
                // screen bitmap  not to go beyond the screen since 
                // we will end up copying the wrong bits from the
                // hdcScreen to the hbmOffScreen when the DC is mirrored.
                // GDI will skip invalid screen coord from the screen into
                // the destination bitmap. This will result in copying un-init
                // bits back to the screen (since the screen is mirrored).
                // [samera]
                //
                if (IS_DC_RTL_MIRRORED(hdcScreen))
                {
                    RECT rcWindow;
                    GetWindowRect(g_dctx.hwndDC, &rcWindow);
                    rcWindow.right -= rcWindow.left;

                    if (rcBounds.right > rcWindow.right)
                    {
                        rcBounds.right = rcWindow.right;
                    }

                    if (rcBounds.left < 0)
                    {
                        rcBounds.left = 0;
                    }
                }

                cx = rcBounds.right - rcBounds.left;
                cy = rcBounds.bottom - rcBounds.top;

                //
                // Copy the union rect from the screen to hbmOffScreen.
                //
                CImageList::SelectDstBitmap(g_drb.hbmOffScreen);
                BitBlt(g_hdcDst, 0, 0, cx, cy,
                        hdcScreen, rcBounds.left, rcBounds.top, SRCCOPY);

                //
                // Hide the cursor on the hbmOffScreen by copying hbmRestore.
                //
                CImageList::SelectSrcBitmap(g_drb.hbmRestore);
                BitBlt(g_hdcDst,
                        rcOld.left - rcBounds.left,
                        rcOld.top - rcBounds.top,
                        g_drb.sizeRestore.cx, g_drb.sizeRestore.cy,
                        g_hdcSrc, 0, 0, SRCCOPY);

                //
                // Copy the original screen bits to hbmRestore
                //
                BitBlt(g_hdcSrc, 0, 0, g_drb.sizeRestore.cx, g_drb.sizeRestore.cy,
                        g_hdcDst,
                        rcNew.left - rcBounds.left,
                        rcNew.top - rcBounds.top,
                        SRCCOPY);

                //
                // Draw the image on hbmOffScreen
                //
                if (g_dctx.fHiColor)
                {
                    WimpyDrawEx(SAFECAST(g_dctx.pimlDrag, IImageList*), 0, g_hdcDst,
                            rcNew.left - rcBounds.left + IncOne,
                            rcNew.top - rcBounds.top, 0, 0, CLR_NONE, CLR_NONE, ILD_BLEND50);

                    if (g_dctx.puxCursor)
                    {
                        WimpyDraw(g_dctx.puxCursor, g_dctx.iCursor, g_hdcDst,
                                rcNew.left - rcBounds.left + g_dctx.ptCursor.x + IncOne,
                                rcNew.top - rcBounds.top + g_dctx.ptCursor.y,
                                ILD_NORMAL);
                            
                    }
                }
                else
                {
                    WimpyDraw(SAFECAST(g_dctx.pimlDrag, IImageList*), 0, g_hdcDst,
                            rcNew.left - rcBounds.left + IncOne,
                            rcNew.top - rcBounds.top, ILD_NORMAL);
                }

                //
                // Copy the hbmOffScreen back to the screen.
                //
                BitBlt(hdcScreen, rcBounds.left, rcBounds.top, cx, cy,
                        g_hdcDst, 0, 0, SRCCOPY);

                ImageList_ReleaseDragDC(hdcScreen);
            }
            g_dctx.ptDrag.x = x;
            g_dctx.ptDrag.y = y;
        }
    }
    LEAVECRITICAL;
    return S_OK;
}

HRESULT CImageList::BeginDrag(int iTrack, int dxHotspot, int dyHotspot)
{
    HRESULT hr = E_ACCESSDENIED;
    ENTERCRITICAL;
    if (!g_dctx.pimlDrag)
    {
        UINT newflags;
        int cxI = 0, cyI = 0;

        g_dctx.fDragShow = FALSE;
        g_dctx.hwndDC = NULL;
        g_dctx.fHiColor = GetScreenDepth() > 8;

        newflags = _flags|ILC_SHARED;

        if (g_dctx.fHiColor)
        {
            UINT uColorFlag = ILC_COLOR16;
            if (GetScreenDepth() == 32 || GetScreenDepth() == 24)
            {
                uColorFlag = ILC_COLOR32;
            }

            newflags = (newflags & ~ILC_COLORMASK) | uColorFlag;
        }


        g_dctx.pimlDither = CImageList::Create(_cx, _cy, newflags, 1, 0);

        if (g_dctx.pimlDither)
        {
            g_dctx.pimlDither->_cImage++;
            g_dctx.ptDragHotspot.x = dxHotspot;
            g_dctx.ptDragHotspot.y = dyHotspot;

            g_dctx.pimlDither->_CopyOneImage(0, 0, 0, this, iTrack);

            hr = ImageList_SetDragImage(NULL, 0, dxHotspot, dyHotspot)? S_OK : E_FAIL;
        }
    }
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::DragEnter(HWND hwndLock, int x, int y)
{
    HRESULT hr = S_FALSE;

    hwndLock = hwndLock ? hwndLock : GetDesktopWindow();

    ENTERCRITICAL;
    if (!g_dctx.hwndDC)
    {
        g_dctx.hwndDC = hwndLock;

        g_dctx.ptDrag.x = x;
        g_dctx.ptDrag.y = y;

        ImageList_DragShowNolock(TRUE);
        hr = S_OK;
    }
    LEAVECRITICAL;

    return hr;
}


HRESULT CImageList::DragLeave(HWND hwndLock)
{
    HRESULT hr = S_FALSE;

    hwndLock = hwndLock ? hwndLock : GetDesktopWindow();

    ENTERCRITICAL;
    if (g_dctx.hwndDC == hwndLock)
    {
        ImageList_DragShowNolock(FALSE);
        g_dctx.hwndDC = NULL;
        hr = S_OK;
    }
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::DragShowNolock(BOOL fShow)
{
    HDC hdcScreen;
    int x, y;
    int IncOne = 0;

    x = g_dctx.ptDrag.x - g_dctx.ptDragHotspot.x;
    y = g_dctx.ptDrag.y - g_dctx.ptDragHotspot.y;

    if (!g_dctx.pimlDrag)
        return E_ACCESSDENIED;

    //
    // REVIEW: Why this block is in the critical section? We are supposed
    //  to have only one dragging at a time, aren't we?
    //
    ENTERCRITICAL;
    if (fShow && !g_dctx.fDragShow)
    {
        hdcScreen = ImageList_GetDragDC();

        CImageList::SelectSrcBitmap(g_drb.hbmRestore);

        BitBlt(g_hdcSrc, 0, 0, g_drb.sizeRestore.cx, g_drb.sizeRestore.cy,
                hdcScreen, x, y, SRCCOPY);

        if (g_dctx.fHiColor)
        {
            WimpyDrawEx(SAFECAST(g_dctx.pimlDrag, IImageList*), 0, hdcScreen, x + IncOne, y, 0, 0, CLR_NONE, CLR_NONE, ILD_BLEND50);
            
            if (g_dctx.puxCursor)
            {
                WimpyDraw(g_dctx.puxCursor, g_dctx.iCursor, hdcScreen,
                    x + g_dctx.ptCursor.x + IncOne, y + g_dctx.ptCursor.y, ILD_NORMAL);
            }
        }
        else
        {
            WimpyDraw(SAFECAST(g_dctx.pimlDrag, IImageList*), 0, hdcScreen, x + IncOne, y, ILD_NORMAL);
        }

        ImageList_ReleaseDragDC(hdcScreen);
    }
    else if (!fShow && g_dctx.fDragShow)
    {
        hdcScreen = ImageList_GetDragDC();

        CImageList::SelectSrcBitmap(g_drb.hbmRestore);

        BitBlt(hdcScreen, x, y, g_drb.sizeRestore.cx, g_drb.sizeRestore.cy,
                g_hdcSrc, 0, 0, SRCCOPY);

        ImageList_ReleaseDragDC(hdcScreen);
    }

    g_dctx.fDragShow = fShow;
    LEAVECRITICAL;

    return S_OK;
}

// this hotspot stuff is broken in design
BOOL ImageList_MergeDragImages(int dxHotspot, int dyHotspot)
{
    CImageList* pimlNew;
    BOOL fRet = FALSE;

    if (g_dctx.pimlDither)
    {
        if (g_dctx.puxCursor)
        {
            IImageList* pux = NULL;
            IImageListPriv* puxpCursor;
            if (SUCCEEDED(g_dctx.puxCursor->QueryInterface(IID_PPV_ARG(IImageListPriv, &puxpCursor))))
            {
                // If the cursor list has a mirrored list, let's use that.
                if (FAILED(puxpCursor->GetMirror(IID_PPV_ARG(IImageList, &pux))))
                {
                    pux = g_dctx.puxCursor;
                    if (pux)
                        pux->AddRef();
                }
                puxpCursor->Release();
            }
            g_dctx.pimlDither->_Merge(0, pux, g_dctx.iCursor, dxHotspot, dyHotspot, &pimlNew);

            if (pimlNew && pimlNew->CreateDragBitmaps())
            {
                // WARNING: Don't destroy pimlDrag if it is pimlDither.
                if (g_dctx.pimlDrag && (g_dctx.pimlDrag != g_dctx.pimlDither))
                {
                    g_dctx.pimlDrag->Release();
                }

                g_dctx.pimlDrag = pimlNew;
                fRet = TRUE;
            }

            pux->Release();
        }
        else
        {
            if (g_dctx.pimlDither->CreateDragBitmaps())
            {
                g_dctx.pimlDrag = g_dctx.pimlDither;
                fRet = TRUE;
            }
        }
    } 
    else 
    {
        // not an error case if both aren't set yet
        // only an error if we actually tried the merge and failed
        fRet = TRUE;
    }

    return fRet;
}

BOOL ImageList_SetDragImage(HIMAGELIST piml, int i, int dxHotspot, int dyHotspot)
{
    BOOL fVisible = g_dctx.fDragShow;
    BOOL fRet;

    ENTERCRITICAL;
    if (fVisible)
        ImageList_DragShowNolock(FALSE);

    // only do this last step if everything is there.
    fRet = ImageList_MergeDragImages(dxHotspot, dyHotspot);

    if (fVisible)
        ImageList_DragShowNolock(TRUE);

    LEAVECRITICAL;
    return fRet;
}

HRESULT CImageList::GetDragImage(POINT * ppt, POINT * pptHotspot, REFIID riid, void** ppv)
{
    if (ppt)
    {
        ppt->x = g_dctx.ptDrag.x;
        ppt->y = g_dctx.ptDrag.y;
    }
    if (pptHotspot)
    {
        pptHotspot->x = g_dctx.ptDragHotspot.x;
        pptHotspot->y = g_dctx.ptDragHotspot.y;
    }
    if (g_dctx.pimlDrag)
    {
        return g_dctx.pimlDrag->QueryInterface(riid, ppv);
    }

    return E_ACCESSDENIED;
}


HRESULT CImageList::GetItemFlags(int i, DWORD *dwFlags)
{
    if (IsImageListIndex(i) && _dsaFlags)
    {
        *dwFlags = _GetItemFlags(i);
        return S_OK;
    }

    return E_INVALIDARG;
}

HRESULT CImageList::GetOverlayImage(int iOverlay, int* piIndex)
{
    if (iOverlay <= 0 || iOverlay >= NUM_OVERLAY_IMAGES)
        return E_INVALIDARG;
        
    *piIndex = _aOverlayIndexes[iOverlay - 1];
    return S_OK;
}


HRESULT CImageList::SetDragCursorImage(IUnknown* punk, int i, int dxHotspot, int dyHotspot)
{
    HRESULT hr = E_INVALIDARG;
    BOOL fVisible = g_dctx.fDragShow;
    IImageList* pux;

    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IImageList, &pux))))
    {
        ENTERCRITICAL;

        // do work only if something has changed
        if ((g_dctx.puxCursor != pux) || (g_dctx.iCursor != i)) 
        {

            if (fVisible)
                ImageList_DragShowNolock(FALSE);

            IImageList* puxOld = g_dctx.puxCursor;
            g_dctx.puxCursor = pux;
            g_dctx.puxCursor->AddRef();

            if (puxOld)
                puxOld->Release();
            g_dctx.iCursor = i;
            g_dctx.ptCursor.x = dxHotspot;
            g_dctx.ptCursor.y = dyHotspot;

            hr = ImageList_MergeDragImages(dxHotspot, dyHotspot)? S_OK : E_FAIL;

            if (fVisible)
                ImageList_DragShowNolock(TRUE);
        }
        LEAVECRITICAL;

        pux->Release();
    }
    return hr;
}

HRESULT CImageList::EndDrag()
{
    ENTERCRITICAL;
    ImageList_DragShowNolock(FALSE);

    // WARNING: Don't destroy pimlDrag if it is pimlDither.
    if (g_dctx.pimlDrag && (g_dctx.pimlDrag != g_dctx.pimlDither))
    {
        g_dctx.pimlDrag->Release();
    }
    g_dctx.pimlDrag = NULL;

    if (g_dctx.pimlDither)
    {
        g_dctx.pimlDither->Release();
        g_dctx.pimlDither = NULL;
    }

    if (g_dctx.puxCursor)
    {
        g_dctx.puxCursor->Release();
        g_dctx.puxCursor = NULL;
    }

    g_dctx.iCursor = -1;
    g_dctx.hwndDC = NULL;
    LEAVECRITICAL;

    return S_OK;
}


// APIs

BOOL WINAPI ImageList_SetDragCursorImage(HIMAGELIST piml, int i, int dxHotspot, int dyHotspot)
{
    BOOL fRet = FALSE;
    IUnknown* punk;
    HRESULT hr = HIMAGELIST_QueryInterface(piml, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        if (g_dctx.puxDragImage)
        {
            fRet = (S_OK == g_dctx.puxDragImage->SetDragCursorImage(punk, i, dxHotspot, dyHotspot));
        }

        punk->Release();
    }

    return fRet;
}

HIMAGELIST WINAPI ImageList_GetDragImage(POINT * ppt, POINT * pptHotspot)
{
    if (g_dctx.puxDragImage)
    {
        IImageList* punk;
        g_dctx.puxDragImage->GetDragImage(ppt, pptHotspot, IID_PPV_ARG(IImageList, &punk));

        return reinterpret_cast<HIMAGELIST>(punk);
    }

    return NULL;
}



void WINAPI ImageList_EndDrag()
{
    ENTERCRITICAL;
    if (g_dctx.puxDragImage)
    {
        g_dctx.puxDragImage->EndDrag();
        g_dctx.puxDragImage->Release();
        g_dctx.puxDragImage = NULL;
    }
    LEAVECRITICAL;
}


BOOL WINAPI ImageList_BeginDrag(HIMAGELIST pimlTrack, int iTrack, int dxHotspot, int dyHotspot)
{
    IImageList* pux;

    if (SUCCEEDED(HIMAGELIST_QueryInterface(pimlTrack, IID_PPV_ARG(IImageList, &pux))))
    {
        if (SUCCEEDED(pux->BeginDrag(iTrack, dxHotspot, dyHotspot)))
        {
            g_dctx.puxDragImage = pux;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL WINAPI ImageList_DragEnter(HWND hwndLock, int x, int y)
{
    BOOL fRet = FALSE;
    if (g_dctx.puxDragImage)
    {
        fRet = (S_OK == g_dctx.puxDragImage->DragEnter(hwndLock, x, y));
    }

    return fRet;
}

BOOL WINAPI ImageList_DragMove(int x, int y)
{
    BOOL fRet = FALSE;
    if (g_dctx.puxDragImage)
    {
        fRet = (S_OK == g_dctx.puxDragImage->DragMove(x, y));
    }

    return fRet;
}

BOOL WINAPI ImageList_DragLeave(HWND hwndLock)
{
    BOOL fRet = FALSE;
    if (g_dctx.puxDragImage)
    {
        fRet = (S_OK == g_dctx.puxDragImage->DragLeave(hwndLock));
    }

    return fRet;
}

BOOL WINAPI ImageList_DragShowNolock(BOOL fShow)
{
    BOOL fRet = FALSE;
    if (g_dctx.puxDragImage)
    {
        fRet = (S_OK == g_dctx.puxDragImage->DragShowNolock(fShow));
    }

    return fRet;
}


//============================================================================
// ImageList_Clone - clone a image list
//
// create a new imagelist with the same properties as the given
// imagelist, except mabey a new icon size
//
//      piml    - imagelist to clone
//      cx,cy   - new icon size (0,0) to use clone icon size.
//      flags   - new flags (used if no clone)
//      cInitial- initial size
//      cGrow   - grow value (used if no clone)
//============================================================================

EXTERN_C HIMAGELIST WINAPI ImageList_Clone(HIMAGELIST himl, int cx, int cy, UINT flags, int cInitial, int cGrow)
{
    IImageListPriv* puxp;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageListPriv, &puxp))))
    {
        // always use the clone flags
        puxp->GetFlags(&flags);
        
        IUnknown* punkMirror;
        if (SUCCEEDED(puxp->GetMirror(IID_PPV_ARG(IUnknown, &punkMirror))))
        {
            flags |= ILC_MIRROR;
            punkMirror->Release();
        }

        IImageList* pux;
        if (SUCCEEDED(puxp->QueryInterface(IID_PPV_ARG(IImageList, &pux))))
        {
            int cxI, cyI;
            pux->GetIconSize(&cxI, &cyI);

            if (cx == 0)           
                cx = cxI;
            if (cy == 0)           
                cy = cyI;

            pux->Release();
        }

        puxp->Release();
    }

    return ImageList_Create(cx,cy,flags,cInitial,cGrow);
}


HRESULT WINAPI ImageList_CreateInstance(int cx, int cy, UINT flags, int cInitial, int cGrow, REFIID riid, void** ppv)
{
    CImageList* piml=NULL;
    HRESULT hr = E_OUTOFMEMORY;

    *ppv = NULL;

    piml = CImageList::Create(cx, cy, flags, cInitial, cGrow);

    if (piml)
    {
        //
        // Let's create a mirrored imagelist, if requested.
        //
        if (piml->_flags & ILC_MIRROR)
        {
            piml->_flags &= ~ILC_MIRROR;
            piml->_pimlMirror = CImageList::Create(cx, cy, flags, cInitial, cGrow);
            if (piml->_pimlMirror)
            {
                piml->_pimlMirror->_flags &= ~ILC_MIRROR;
            }
        }

        hr = piml->QueryInterface(riid, ppv);
        piml->Release();
    }

    return hr;

}

HIMAGELIST WINAPI ImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow)
{
    IImageList* pux;
    ImageList_CreateInstance(cx, cy, flags, cInitial, cGrow, IID_PPV_ARG(IImageList, &pux));
    return reinterpret_cast<HIMAGELIST>(pux);
}

//
// When this code is compiled Unicode, this implements the
// ANSI version of the ImageList_LoadImage api.
//

HIMAGELIST WINAPI ImageList_LoadImageA(HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags)
{
   HIMAGELIST lpResult;
   LPWSTR   lpBmpW;

   if (!IS_INTRESOURCE(lpbmp)) 
   {
       lpBmpW = ProduceWFromA(CP_ACP, lpbmp);

       if (!lpBmpW) 
       {
           return NULL;
       }

   }  
   else 
   {
       lpBmpW = (LPWSTR)lpbmp;
   }

   lpResult = ImageList_LoadImageW(hi, lpBmpW, cx, cGrow, crMask, uType, uFlags);

   if (!IS_INTRESOURCE(lpbmp))
       FreeProducedString(lpBmpW);

   return lpResult;
}

HIMAGELIST WINAPI ImageList_LoadImageW(HINSTANCE hi, LPCTSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags)
{
    HBITMAP hbmImage;
    HIMAGELIST piml = NULL;
    BITMAP bm;
    int cy, cInitial;
    UINT flags;

    hbmImage = (HBITMAP)LoadImage(hi, lpbmp, uType, 0, 0, uFlags);
    if (hbmImage && (sizeof(bm) == GetObject(hbmImage, sizeof(bm), &bm)))
    {
        // If cx is not stated assume it is the same as cy.
        // ASSERT(cx);
        cy = bm.bmHeight;

        if (cx == 0)
            cx = cy;

        cInitial = bm.bmWidth / cx;

        ENTERCRITICAL;

        flags = 0;
        if (crMask != CLR_NONE)
            flags |= ILC_MASK;
        if (bm.bmBits)
            flags |= (bm.bmBitsPixel & ILC_COLORMASK);

        piml = ImageList_Create(cx, cy, flags, cInitial, cGrow);
        if (piml)
        {
            int added;

            if (crMask == CLR_NONE)
                added = ImageList_Add(piml, hbmImage, NULL);
            else
                added = ImageList_AddMasked(piml, hbmImage, crMask);

            if (added < 0)
            {
                ImageList_Destroy(piml);
                piml = NULL;
            }
        }
        LEAVECRITICAL;
    }

    if (hbmImage)
        DeleteObject(hbmImage);

    return reinterpret_cast<HIMAGELIST>((IImageList*)piml);
}

//
//
#undef ImageList_AddIcon
EXTERN_C int WINAPI ImageList_AddIcon(HIMAGELIST himl, HICON hIcon)
{
    return ImageList_ReplaceIcon(himl, -1, hIcon);
}

EXTERN_C void WINAPI ImageList_CopyDitherImage(HIMAGELIST himlDst, WORD iDst,
    int xDst, int yDst, HIMAGELIST himlSrc, int iSrc, UINT fStyle)
{
    IImageListPriv* puxp;

    if (SUCCEEDED(HIMAGELIST_QueryInterface(himlDst, IID_PPV_ARG(IImageListPriv, &puxp))))
    {
        IUnknown* punk;
        if (SUCCEEDED(HIMAGELIST_QueryInterface(himlSrc, IID_PPV_ARG(IUnknown, &punk))))
        {
            puxp->CopyDitherImage(iDst, xDst, yDst, punk, iSrc, fStyle);
            punk->Release();
        }
        puxp->Release();
    }
}

//
// ImageList_Duplicate
//
// Makes a copy of the passed in imagelist.
//
HIMAGELIST  WINAPI ImageList_Duplicate(HIMAGELIST himl)
{
    IImageList* pret = NULL;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->Clone(IID_PPV_ARG(IImageList, &pret));
        pux->Release();
    }

    return reinterpret_cast<HIMAGELIST>(pret);
}

BOOL WINAPI ImageList_Write(HIMAGELIST himl, LPSTREAM pstm)
{
    BOOL fRet = FALSE;
    IPersistStream* pps;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IPersistStream, &pps))))
    {
        if (SUCCEEDED(pps->Save(pstm, TRUE)))
        {
            fRet = TRUE;
        }
        pps->Release();
    }

    return fRet;
}

HIMAGELIST WINAPI ImageList_Read(LPSTREAM pstm)
{
    CImageList* piml = new CImageList();
    if (piml)
    {
        if (SUCCEEDED(piml->Load(pstm)))
        {
            return reinterpret_cast<HIMAGELIST>((IImageList*)piml);
        }

        piml->Release();
    }

    return NULL;

}

WINCOMMCTRLAPI HRESULT WINAPI ImageList_ReadEx(DWORD dwFlags, LPSTREAM pstm, REFIID riid, PVOID* ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CImageList* piml = new CImageList();
    if (piml)
    {
        hr = piml->LoadEx(dwFlags, pstm);
        if (SUCCEEDED(hr))
        {
            hr = piml->QueryInterface(riid, ppv);
        }

        piml->Release();
    }

    return hr;
}

WINCOMMCTRLAPI HRESULT WINAPI ImageList_WriteEx(HIMAGELIST himl, DWORD dwFlags, LPSTREAM pstm)
{
    IImageListPersistStream* pps;
    HRESULT hr = HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageListPersistStream, &pps));
    if (SUCCEEDED(hr))
    {
        hr = pps->SaveEx(dwFlags, pstm);
        pps->Release();
    }

    return hr;

}

BOOL WINAPI ImageList_GetImageRect(HIMAGELIST himl, int i, RECT * prcImage)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        if (SUCCEEDED(pux->GetImageRect(i, prcImage)))
        {
            fRet = TRUE;
        }
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_Destroy(HIMAGELIST himl)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    // Weirdness: We are doing a Query Interface first to verify that 
    // this is actually a valid imagelist, then we are calling release twice
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        // Release the interface we QI'd for
        pux->Release();

        // Release a second time to destroy the object
        pux->Release();

        fRet = TRUE;
    }

    return fRet;
}

int         WINAPI ImageList_GetImageCount(HIMAGELIST himl)
{
    int fRet = 0;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->GetImageCount(&fRet);
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_SetImageCount(HIMAGELIST himl, UINT uNewCount)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->SetImageCount(uNewCount));
        pux->Release();
    }

    return fRet;
}
int         WINAPI ImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask)
{
    int fRet = -1;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->Add(hbmImage, hbmMask, &fRet);
        pux->Release();
    }

    return fRet;
}

int         WINAPI ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon)
{
    int fRet = -1;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->ReplaceIcon(i, hicon, &fRet);
        pux->Release();
    }

    return fRet;
}

COLORREF    WINAPI ImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk)
{
    COLORREF fRet = clrBk;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->SetBkColor(clrBk, &fRet);
        pux->Release();
    }

    return fRet;
}

COLORREF    WINAPI ImageList_GetBkColor(HIMAGELIST himl)
{
    COLORREF fRet = RGB(0,0,0);
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->GetBkColor(&fRet);
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->SetOverlayImage(iImage, iOverlay));
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_Replace(HIMAGELIST himl, int i, HBITMAP hbmImage, HBITMAP hbmMask)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->Replace(i, hbmImage, hbmMask));
        pux->Release();
    }

    return fRet;
}

int         WINAPI ImageList_AddMasked(HIMAGELIST himl, HBITMAP hbmImage, COLORREF crMask)
{
    int fRet = -1;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->AddMasked(hbmImage, crMask, &fRet);
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        IMAGELISTDRAWPARAMS imldp = {0};
        imldp.cbSize = sizeof(imldp);
        imldp.himl   = himl;
        imldp.i      = i;
        imldp.hdcDst = hdcDst;
        imldp.x      = x;
        imldp.y      = y;
        imldp.cx     = dx;
        imldp.cy     = dy;
        imldp.rgbBk  = rgbBk;
        imldp.rgbFg  = rgbFg;
        imldp.fStyle = fStyle;

        fRet = (S_OK == pux->Draw(&imldp));
        pux->Release();
    }

    return fRet;
}

BOOL WINAPI ImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        IMAGELISTDRAWPARAMS imldp = {0};
        imldp.cbSize = sizeof(imldp);
        imldp.himl   = himl;
        imldp.i      = i;
        imldp.hdcDst = hdcDst;
        imldp.x      = x;
        imldp.y      = y;
        imldp.rgbBk  = CLR_DEFAULT;
        imldp.rgbFg  = CLR_DEFAULT;
        imldp.fStyle = fStyle;
    
        fRet = (S_OK == pux->Draw(&imldp));
        pux->Release();
    }

    return fRet;
}



// Note: no distinction between failure case (bad himl) and no flags set
DWORD      WINAPI ImageList_GetItemFlags(HIMAGELIST himl, int i)
{
    DWORD dwFlags = 0;

    if (himl)
    {
        IImageList* pux;
        if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
        {
            pux->GetItemFlags(i, &dwFlags);
            pux->Release();
        }
    }

    return dwFlags;
}



BOOL        WINAPI ImageList_DrawIndirect(IMAGELISTDRAWPARAMS* pimldp)
{
    BOOL fRet = FALSE;
    IImageList* pux;

    if (!pimldp)
        return fRet;

    if (SUCCEEDED(HIMAGELIST_QueryInterface(pimldp->himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->Draw(pimldp));
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_Remove(HIMAGELIST himl, int i)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->Remove(i));
        pux->Release();
    }

    return fRet;
}

HICON       WINAPI ImageList_GetIcon(HIMAGELIST himl, int i, UINT flags)
{
    HICON fRet = NULL;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->GetIcon(i, flags, &fRet);
        pux->Release();
    }

    return fRet;
}
BOOL        WINAPI ImageList_Copy(HIMAGELIST himlDst, int iDst, HIMAGELIST himlSrc, int iSrc, UINT uFlags)
{
    BOOL fRet = FALSE;

    if (himlDst == himlSrc)
    {
        IImageList* pux;
        if (SUCCEEDED(HIMAGELIST_QueryInterface(himlDst, IID_PPV_ARG(IImageList, &pux))))
        {
            fRet = (S_OK == pux->Copy(iDst,(IUnknown*)pux, iSrc, uFlags));
            pux->Release();
        }

    }

    return fRet;
}

BOOL        WINAPI ImageList_GetIconSize(HIMAGELIST himl, int *cx, int *cy)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->GetIconSize(cx, cy));
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_SetIconSize(HIMAGELIST himl, int cx, int cy)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->SetIconSize(cx, cy));
        pux->Release();
    }

    return fRet;
}
BOOL        WINAPI ImageList_GetImageInfo(HIMAGELIST himl, int i, IMAGEINFO* pImageInfo)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->GetImageInfo(i, pImageInfo));
        pux->Release();
    }

    return fRet;
}

HIMAGELIST  WINAPI ImageList_Merge(HIMAGELIST himl1, int i1, HIMAGELIST himl2, int i2, int dx, int dy)
{
    IImageList* fRet = NULL;
    IImageList* pux1;
    IImageList* pux2;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl1, IID_PPV_ARG(IImageList, &pux1))))
    {
        if (SUCCEEDED(HIMAGELIST_QueryInterface(himl2, IID_PPV_ARG(IImageList, &pux2))))
        {
            pux1->Merge(i1, (IUnknown*)pux2, i2, dx, dy, IID_PPV_ARG(IImageList, &fRet));
            pux2->Release();

        }
        pux1->Release();
    }

    return reinterpret_cast<HIMAGELIST>(fRet);
}

BOOL        WINAPI ImageList_SetFlags(HIMAGELIST himl, UINT flags)
{
    BOOL fRet = FALSE;
    IImageListPriv* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageListPriv, &pux))))
    {
        fRet = (S_OK == pux->SetFlags(flags));
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_SetFilter(HIMAGELIST himl, PFNIMLFILTER pfnFilter, LPARAM lParamFilter)
{
    return FALSE;
}

int         ImageList_SetColorTable(HIMAGELIST himl, int start, int len, RGBQUAD *prgb)
{
    int fRet = -1;
    IImageListPriv* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageListPriv, &pux))))
    {
        pux->SetColorTable(start, len, prgb, &fRet);
        pux->Release();
    }

    return fRet;
}

UINT        WINAPI ImageList_GetFlags(HIMAGELIST himl)
{
    UINT fRet = 0;
    IImageListPriv* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageListPriv, &pux))))
    {
        pux->GetFlags(&fRet);
        pux->Release();
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\fwd.c ===
//============================================================================
//
// 
//
//
//============================================================================

#include "ctlspriv.h"


LPSTR 
FwdStrChrA(
    LPCSTR lpStart, 
    WORD wMatch)
    {
    return StrChrA(lpStart, wMatch);
    }


LPWSTR 
FwdStrChrW(
    LPCWSTR lpStart, 
    WORD wMatch)
    {
    return StrChrW(lpStart, wMatch);
    }


LPSTR 
FwdStrRChrA(
    LPCSTR lpStart, 
    LPCSTR lpEnd, 
    WORD wMatch)
    {
    return StrRChrA(lpStart, lpEnd, wMatch);
    }

LPWSTR 
FwdStrRChrW(
    LPCWSTR lpStart, 
    LPCWSTR lpEnd, 
    WORD wMatch)
    {
    return StrRChrW(lpStart, lpEnd, wMatch);
    }


int 
FwdStrCmpNA(
    LPCSTR lpStr1, 
    LPCSTR lpStr2, 
    int nChar)
    {
    return StrCmpNA(lpStr1, lpStr2, nChar);
    }


int 
FwdStrCmpNW(
    LPCWSTR lpStr1, 
    LPCWSTR lpStr2, 
    int nChar)
    {
    return StrCmpNW(lpStr1, lpStr2, nChar);
    }


LPSTR 
FwdStrStrA(
    LPCSTR lpFirst, 
    LPCSTR lpSrch)
    {
    return StrStrA(lpFirst, lpSrch);
    }


LPWSTR 
FwdStrStrW(
    LPCWSTR lpFirst, 
    LPCWSTR lpSrch)
    {
    return StrStrW(lpFirst, lpSrch);
    }


int 
FwdStrCmpNIA(
    LPCSTR lpStr1, 
    LPCSTR lpStr2, 
    int nChar)
    {
    return StrCmpNIA(lpStr1, lpStr2, nChar);
    }


int 
FwdStrCmpNIW(
    LPCWSTR lpStr1, 
    LPCWSTR lpStr2, 
    int nChar)
    {
    return StrCmpNIW(lpStr1, lpStr2, nChar);
    }


LPSTR 
FwdStrStrIA(
    LPCSTR lpFirst, 
    LPCSTR lpSrch)
    {
    return StrStrIA(lpFirst, lpSrch);
    }


LPWSTR 
FwdStrStrIW(
    LPCWSTR lpFirst, 
    LPCWSTR lpSrch)
    {
    return StrStrIW(lpFirst, lpSrch);
    }


int 
FwdStrCSpnA(
    LPCSTR lpStr, 
    LPCSTR lpSet)
    {
    return StrCSpnA(lpStr, lpSet);
    }


int 
FwdStrCSpnW(
    LPCWSTR lpStr, 
    LPCWSTR lpSet)
    {
    return StrCSpnW(lpStr, lpSet);
    }


int 
FwdStrToIntA(
    LPCSTR lpSrc)
    {
    return StrToIntA(lpSrc);
    }


int 
FwdStrToIntW(
    LPCWSTR lpSrc)
    {
    return StrToIntW(lpSrc);
    }


LPSTR 
FwdStrChrIA(
    LPCSTR lpStart, 
    WORD wMatch)
    {
    return StrChrIA(lpStart, wMatch);
    }


LPWSTR 
FwdStrChrIW(
    LPCWSTR lpStart, 
    WORD wMatch)
    {
    return StrChrIW(lpStart, wMatch);
    }


LPSTR 
FwdStrRChrIA(
    LPCSTR lpStart, 
    LPCSTR lpEnd, 
    WORD wMatch)
    {
    return StrRChrIA(lpStart, lpEnd, wMatch);
    }


LPWSTR 
FwdStrRChrIW(
    LPCWSTR lpStart, 
    LPCWSTR lpEnd, 
    WORD wMatch)
    {
    return StrRChrIW(lpStart, lpEnd, wMatch);
    }


LPSTR 
FwdStrRStrIA(
    LPCSTR lpSource, 
    LPCSTR lpLast, 
    LPCSTR lpSrch)
    {
    return StrRStrIA(lpSource, lpLast, lpSrch);
    }


LPWSTR 
FwdStrRStrIW(
    LPCWSTR lpSource, 
    LPCWSTR lpLast, 
    LPCWSTR lpSrch)
    {
    return StrRStrIW(lpSource, lpLast, lpSrch);
    }


int 
FwdStrCSpnIA(
    LPCSTR lpStr, 
    LPCSTR lpSet)
    {
    return StrCSpnIA(lpStr, lpSet);
    }


int 
FwdStrCSpnIW(
    LPCWSTR lpStr, 
    LPCWSTR lpSet)
    {
    return StrCSpnIW(lpStr, lpSet);
    }


LPSTR
FwdStrPBrkA(
    LPCSTR psz, 
    LPCSTR pszSet)
    {
    return StrPBrkA(psz, pszSet);
    }


LPWSTR
FwdStrPBrkW(
    LPCWSTR psz, 
    LPCWSTR pszSet)
    {
    return StrPBrkW(psz, pszSet);
    }


int
FwdStrSpnA(
    LPCSTR psz,
    LPCSTR pszSet)
    {
    return StrSpnA(psz, pszSet);
    }


int
FwdStrSpnW(
    LPCWSTR psz,
    LPCWSTR pszSet)
    {
    return StrSpnW(psz, pszSet);
    }


BOOL 
FwdStrToIntExA(
    LPCSTR    pszString,
    DWORD     dwFlags,          // STIF_ bitfield 
    int * piRet)
    {
    return StrToIntExA(pszString, dwFlags, piRet);
    }


BOOL 
FwdStrToIntExW(
    LPCWSTR   pszString,
    DWORD     dwFlags,          // STIF_ bitfield 
    int * piRet)
    {
    return StrToIntExW(pszString, dwFlags, piRet);
    }


LPWSTR 
FwdStrCpyW(
    LPWSTR psz1, 
    LPCWSTR psz2)
    {
    return StrCpyW(psz1, psz2);
    }


LPSTR 
FwdStrDupA(
    LPCSTR lpsz)
    {
    return StrDupA(lpsz);
    }


LPWSTR 
FwdStrDupW(
    LPCWSTR lpsz)
    {
    return StrDupW(lpsz);
    }


int 
FwdStrCmpW(
    LPCWSTR lpsz1, 
    LPCWSTR lpsz2)
    {
    return StrCmpW(lpsz1, lpsz2);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\image.h ===
#ifndef _INC_IMAGE
#define _INC_IMAGE


// internal image stuff
EXTERN_C void InitDitherBrush(void);
EXTERN_C void TerminateDitherBrush(void);

EXTERN_C HBITMAP CreateMonoBitmap(int cx, int cy);
EXTERN_C HBITMAP CreateColorBitmap(int cx, int cy);

EXTERN_C void WINAPI ImageList_CopyDitherImage(HIMAGELIST pimlDest, WORD iDst,
    int xDst, int yDst, HIMAGELIST pimlSrc, int iSrc, UINT fStyle);

// function to create a imagelist using the params of a given image list
EXTERN_C HIMAGELIST WINAPI ImageList_Clone(HIMAGELIST himl, int cx, int cy,
    UINT flags, int cInitial, int cGrow);

EXTERN_C DWORD WINAPI ImageList_GetItemFlags(HIMAGELIST himl, int i);
EXTERN_C HBITMAP CreateDIB(HDC h, int cx, int cy, RGBQUAD** pprgb);
EXTERN_C BOOL DIBHasAlpha(int cx, int cy, RGBQUAD* prgb);
EXTERN_C void PreProcessDIB(int cx, int cy, RGBQUAD* pargb);

#define GLOW_RADIUS     10
#define DROP_SHADOW     3

#ifndef ILC_COLORMASK
#define ILC_COLORMASK   0x00FE
#define ILD_BLENDMASK   0x000E
#endif
#undef ILC_COLOR
#undef ILC_BLEND

#define CLR_WHITE   0x00FFFFFFL
#define CLR_BLACK   0x00000000L

#define IsImageListIndex(i) ((i) >= 0 && (i) < _cImage)

#define IMAGELIST_SIG   mmioFOURCC('H','I','M','L') // in memory magic
#define IMAGELIST_MAGIC ('I' + ('L' * 256))         // file format magic
// Version has to stay 0x0101 if we want both back ward and forward compatibility for
// our imagelist_read code
#define IMAGELIST_VER0  0x0101                      // file format ver
#define IMAGELIST_VER6  0x0600                      // Comctl32 version 6 imagelist

#define BFTYPE_BITMAP   0x4D42      // "BM"

#define CBDIBBUF        4096

#ifdef __cplusplus
// Define this structure such that it will read and write the same
// format for both 16 and 32 bit applications...
#pragma pack(2)
typedef struct _ILFILEHEADER
{
    WORD    magic;
    WORD    version;
    SHORT   cImage;
    SHORT   cAlloc;
    SHORT   cGrow;
    SHORT   cx;
    SHORT   cy;
    COLORREF clrBk;
    SHORT    flags;
    SHORT       aOverlayIndexes[NUM_OVERLAY_IMAGES];  // array of special images
} ILFILEHEADER;

// This is the old size which has only 4 overlay slots
#define ILFILEHEADER_SIZE0 (SIZEOF(ILFILEHEADER) - SIZEOF(SHORT) * (NUM_OVERLAY_IMAGES - NUM_OVERLAY_IMAGES_0)) 

#pragma pack()



#include "../CommonImageList.h"

class CImageList : public CImageListBase, 
                   public IImageList, 
                   public IImageListPriv, 
                   public IPersistStream,
                   public IImageListPersistStream

{
    long _cRef;

    ~CImageList();
    void _Destroy();

public:
    CImageList();

    static HRESULT InitGlobals();
    HRESULT Initialize(int cx, int cy, UINT flags, int cInitial, int cGrow);
    void _RemoveItemBitmap(int i);
    BOOL _IsSameObject(IUnknown* punk);
    HRESULT _SetIconSize(int cxImage, int cyImage);
    HBITMAP _CreateMirroredBitmap(HBITMAP hbmOrig, BOOL fMirrorEach, int cx);
    HRESULT _ReAllocBitmaps(int cAlloc);
    HRESULT _Add(HBITMAP hbmImage, HBITMAP hbmMask, int cImage, int xStart, int yStart, int* pi);
    HRESULT _AddMasked(HBITMAP hbmImage, COLORREF crMask, int* pi);
    HRESULT _AddValidated(HBITMAP hbmImage, HBITMAP hbmMask, int* pi);
    HRESULT _ReplaceValidated(int i, HBITMAP hbmImage, HBITMAP hbmMask);
    HRESULT _Replace(int i, int cImage, HBITMAP hbmImage, HBITMAP hbmMask, int xStart, int yStart);
    HRESULT _Remove(int i);
    HRESULT _SetOverlayImage(int iImage, int iOverlay);
    HRESULT _ReplaceIcon(int i, HICON hIcon, int* pi);
    HBITMAP _CopyBitmap(HBITMAP hbm, HDC hdc);
    HBITMAP _CopyDIBBitmap(HBITMAP hbm, HDC hdc, RGBQUAD** ppargb);
    HRESULT LoadNormal(IStream* pstm);
    HRESULT SaveNormal(IStream* pstm);

    
    void    _Merge(IImageList* pux, int i, int dx, int dy);
    HRESULT _Merge(int i1, IUnknown* punk, int i2, int dx, int dy, CImageList** ppiml);
    HRESULT _Read(ILFILEHEADER *pilfh, HBITMAP hbmImage, PVOID pvBits, HBITMAP hbmMask);
    BOOL    _MoreOverlaysUsed();
    BOOL GetSpareImageRect(RECT * prcImage);
    BOOL GetSpareImageRectInverted(RECT * prcImage);
    void _CopyOneImage(int iDst, int x, int y, CImageList* piml, int iSrc);
    BOOL CreateDragBitmaps();
    COLORREF _SetBkColor(COLORREF clrBk);
    HBITMAP _CreateBitmap(int cx, int cy, RGBQUAD** ppargb);
    void _ResetBkColor(int iFirst, int iLast, COLORREF clr);
    BOOL _HasAlpha(int i);
    void _ScanForAlpha();
    BOOL _PreProcessImage(int i);
    inline DWORD _GetItemFlags(int i);
    BOOL _MaskStretchBlt(BOOL fStretch, int i, HDC hdcDest, int xDst, int yDst, int cxDst, int cyDst,
                                   HDC hdcImage, int xSrc, int ySrc, int cxSrc, int cySrc,
                                   int xMask, int yMask,
                                   DWORD dwRop);
    BOOL _StretchBlt(BOOL fStretch, HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int xs, int ys, int cxs, int cys, DWORD dwRop);

    inline void SetItemFlags(int i, DWORD dwFlag);
    void _GenerateAlphaForImageUsingMask(int iImage, BOOL fSpare);
    void BlendCTHelper(DWORD *pdw, DWORD rgb, UINT n, UINT count);
    void BlendCT(HDC hdcDst, int xDst, int yDst, int x, int y, int cx, int cy, COLORREF rgb, UINT fStyle);
    void BlendDither(HDC hdcDst, int xDst, int yDst, int x, int y, int cx, int cy, COLORREF rgb, UINT fStyle);
    void Blend16Helper(int xSrc, int ySrc, int xDst, int yDst, int cx, int cy, COLORREF rgb, int a);
    void Blend16(HDC hdcDst, int xDst, int yDst, int iImage, int cx, int cy, COLORREF rgb, UINT fStyle);
    BOOL Blend32(HDC hdcDst, int xDst, int yDst, int iImage, int cx, int cy, COLORREF rgb, UINT fStyle);
    BOOL Blend(HDC hdcDst, int xDst, int yDst, int iImage, int cx, int cy, COLORREF rgb, UINT fStyle);
    HRESULT GetImageRectInverted(int i, RECT * prcImage);

    static BOOL GlobalInit(void);
    static void GlobalUninit(void);
    static void SelectDstBitmap(HBITMAP hbmDst);
    static void SelectSrcBitmap(HBITMAP hbmSrc);
    static CImageList* Create(int cx, int cy, UINT flags, int cInitial, int cGrow);
    static void    _DeleteBitmap(HBITMAP hbmp);

    BOOL        _fInitialized;
    BOOL        _fSolidBk;   // is the bkcolor a solid color (in hbmImage)
    BOOL        _fColorsSet;  // The DIB colors have been set with SetColorTable()
    int         _cImage;     // count of images in image list
    int         _cAlloc;     // # of images we have space for
    int         _cGrow;      // # of images to grow bitmaps by
    int         _cx;         // width of each image
    int         _cy;         // height
    int         _cStrip;     // # images in horizontal strip
    UINT        _flags;      // ILC_* flags
    COLORREF    _clrBlend;   // last blend color
    COLORREF    _clrBk;      // bk color or CLR_NONE for transparent.
    HBRUSH      _hbrBk;      // bk brush or black
    HBITMAP     _hbmImage;   // all images are in here
    HBITMAP     _hbmMask;    // all image masks are in here.
    HDSA        _dsaFlags;    // Flags for the images
    RGBQUAD*    _pargbImage;    // The alpha values of the imagelist.
    HDC         _hdcImage;
    HDC         _hdcMask;
    int         _aOverlayIndexes[NUM_OVERLAY_IMAGES];    // array of special images
    int         _aOverlayX[NUM_OVERLAY_IMAGES];          // x offset of image
    int         _aOverlayY[NUM_OVERLAY_IMAGES];          // y offset of image
    int         _aOverlayDX[NUM_OVERLAY_IMAGES];         // cx offset of image
    int         _aOverlayDY[NUM_OVERLAY_IMAGES];         // cy offset of image
    int         _aOverlayF[NUM_OVERLAY_IMAGES];          // ILD_ flags for image
    CImageList* _pimlMirror;  // Set only when another mirrored imagelist is needed (ILC_MIRROR)    

    //
    // used for "blending" effects on a HiColor display.
    // assumes layout of a DIBSECTION.
    //
    struct 
    {
        BITMAP              bm;
        BITMAPINFOHEADER    bi;
        DWORD               ct[256];
    }   dib;

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG)AddRef();
    STDMETHODIMP_(ULONG)Release();


    // *** IImageList ***
    STDMETHODIMP Add(HBITMAP hbmImage, HBITMAP hbmMask, int* pi);
    STDMETHODIMP ReplaceIcon(int i, HICON hIcon, int* pi);
    STDMETHODIMP SetOverlayImage(int iImage, int iOverlay);
    STDMETHODIMP Replace(int i, HBITMAP hbmImage, HBITMAP hbmMask);
    STDMETHODIMP AddMasked(HBITMAP hbmImage, COLORREF crMask, int* pi);
    STDMETHODIMP Draw(IMAGELISTDRAWPARAMS* pimldp);
    STDMETHODIMP Remove(int i);
    STDMETHODIMP GetIcon(int i, UINT flags, HICON* phicon);
    STDMETHODIMP GetImageInfo(int i, IMAGEINFO * pImageInfo);
    STDMETHODIMP Copy(int iDst, IUnknown* punkSrc, int iSrc, UINT uFlags);
    STDMETHODIMP Merge(int i1, IUnknown* punk, int i2, int dx, int dy, REFIID riid, void** ppv);
    STDMETHODIMP Clone(REFIID riid, void** ppv);
    STDMETHODIMP GetImageRect(int i, RECT * prcImage);
    STDMETHODIMP SetIconSize(int cxImage, int cyImage);
    STDMETHODIMP GetIconSize(int* pcx, int* pcy);
    STDMETHODIMP SetImageCount(UINT uAlloc);
    STDMETHODIMP GetImageCount(int* pi);
    STDMETHODIMP SetBkColor(COLORREF clrBk, COLORREF* pclr);
    STDMETHODIMP GetBkColor(COLORREF* pclr);
    STDMETHODIMP BeginDrag(int iTrack, int dxHotspot, int dyHotspot);
    STDMETHODIMP DragEnter(HWND hwndLock, int x, int y);
    STDMETHODIMP DragMove(int x, int y);
    STDMETHODIMP DragLeave(HWND hwndLock);
    STDMETHODIMP EndDrag();
    STDMETHODIMP SetDragCursorImage(IUnknown* punk, int i, int dxHotspot, int dyHotspot);
    STDMETHODIMP DragShowNolock(BOOL fShow);
    STDMETHODIMP GetDragImage(POINT * ppt, POINT * pptHotspot, REFIID riid, void** ppv);
    STDMETHODIMP GetItemFlags(int i, DWORD *dwFlags);
    STDMETHODIMP GetOverlayImage(int iOverlay, int *piIndex);

    // *** IImageListPriv ***
    STDMETHODIMP SetFlags(UINT uFlags);
    STDMETHODIMP GetFlags(UINT* puFlags);
    STDMETHODIMP SetColorTable(int start, int len, RGBQUAD *prgb, int* pi);
    STDMETHODIMP GetPrivateGoo(HBITMAP* hbmp, HDC* hdc, HBITMAP* hbmpMask, HDC* hdcMask);
    STDMETHODIMP GetMirror(REFIID riid, void** ppv);
    STDMETHODIMP CopyDitherImage(WORD iDst, int xDst, int yDst, IUnknown* punkSrc, int iSrc, UINT fStyle);

    // *** IPersist ***
    STDMETHODIMP GetClassID(CLSID *pClassID)    {   *pClassID = CLSID_ImageList; return S_OK;   }
    STDMETHODIMP IsDirty()                      {   return E_NOTIMPL; }

    // *** IPersistStream ***
    STDMETHODIMP Load(IStream *pStm);
    STDMETHODIMP Save(IStream *pStm, int fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize)   { return E_NOTIMPL; }

    // *** IImageListPersistStream ***
    STDMETHODIMP LoadEx(DWORD dwFlags, IStream* pstm);
    STDMETHODIMP SaveEx(DWORD dwFlags, IStream* pstm);

};
#endif // __cplusplus
#endif  // _INC_IMAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\listbox.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "listbox.h"


//---------------------------------------------------------------------------//
//
// Forwards
//
VOID ListBox_CalcItemRowsAndColumns(PLBIV);
LONG ListBox_Create(PLBIV, HWND, LPCREATESTRUCT);
VOID ListBox_Destroy(PLBIV, HWND);
VOID ListBox_SetFont(PLBIV, HANDLE, BOOL);
VOID ListBox_Size(PLBIV, INT, INT, BOOL);
BOOL ListBox_SetTabStopsHandler(PLBIV, INT, LPINT);
VOID ListBox_DropObjectHandler(PLBIV, PDROPSTRUCT);
int  ListBox_GetSetItemHeightHandler(PLBIV, UINT, int, UINT);


//---------------------------------------------------------------------------//
//
//  InitListBoxClass() - Registers the control's window class 
//
BOOL InitListBoxClass(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = ListBox_WndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = WC_LISTBOX;
    wc.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1); // NULL;
    wc.style           = CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS;
    wc.cbWndExtra      = sizeof(PLBIV);
    wc.cbClsExtra      = 0;

    if (!RegisterClass(&wc) && !GetClassInfo(hinst, WC_LISTBOX, &wc))
        return FALSE;

    return TRUE;

}


//---------------------------------------------------------------------------//
//
// ListBox_WndProc
//
// Window Procedure for ListBox AND ComboLBox controls.
//
LRESULT APIENTRY ListBox_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PLBIV   plb;
    UINT    wFlags;
    LRESULT lReturn = FALSE;

    //
    // Get the instance data for this listbox control
    //
    plb = ListBox_GetPtr(hwnd);
    if (!plb && uMsg != WM_NCCREATE)
    {
        goto CallDWP;
    }

    switch (uMsg) 
    {
    case LB_GETTOPINDEX:
        //
        // Return index of top item displayed.
        //
        return plb->iTop;

    case LB_SETTOPINDEX:
        if (wParam && ((INT)wParam < 0 || (INT)wParam >= plb->cMac)) 
        {
            TraceMsg(TF_STANDARD, "Invalid index");
            return LB_ERR;
        }

        if (plb->cMac) 
        {
            ListBox_NewITop(plb, (INT)wParam);
        }

        break;

    case WM_STYLECHANGED:
        plb->fRtoLReading = ((GET_EXSTYLE(plb) & WS_EX_RTLREADING) != 0);
        plb->fRightAlign  = ((GET_EXSTYLE(plb) & WS_EX_RIGHT) != 0);
        ListBox_CheckRedraw(plb, FALSE, 0);

        break;

    case WM_WINDOWPOSCHANGED:
        //
        // If we are in the middle of creation, ignore this
        // message because it will generate a WM_SIZE message.
        // See ListBox_Create().
        //
        if (!plb->fIgnoreSizeMsg)
        {
            goto CallDWP;
        }

        break;

    case WM_SIZE:
        //
        // If we are in the middle of creation, ignore size
        // messages.  See ListBox_Create().
        //
        if (!plb->fIgnoreSizeMsg)
        {
            ListBox_Size(plb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), FALSE);
        }

        break;

    case WM_ERASEBKGND:
    {
        HDC    hdcSave = plb->hdc;
        HBRUSH hbr;

        plb->hdc = (HDC)wParam;
        hbr = ListBox_GetBrush(plb, NULL);
        if (hbr)
        {
            RECT rcClient;

            GetClientRect(hwnd, &rcClient);
            FillRect(plb->hdc, &rcClient, hbr);

            lReturn = TRUE;
        }

        plb->hdc = hdcSave;
        break;
    }
    case LB_RESETCONTENT:
        ListBox_ResetContentHandler(plb);

        break;

    case WM_TIMER:
        if (wParam == IDSYS_LBSEARCH) 
        {
            plb->iTypeSearch = 0;
            KillTimer(hwnd, IDSYS_LBSEARCH);
            ListBox_InvertItem(plb, plb->iSel, TRUE);

            break;
        }

        uMsg = WM_MOUSEMOVE;
        ListBox_TrackMouse(plb, uMsg, plb->ptPrev);

        break;

    case WM_LBUTTONUP:

        //
        // 295135: if the combobox dropdown button is pressed and the listbox
        // covers the combobox, the ensuing buttonup message gets sent to
        // list instead of the combobox, which causes the dropdown to be 
        // closed immediately.
        //

        //
        // send this to the combo if it hasn't processed buttonup yet after
        // dropping the list.
        //
        if (plb->pcbox && plb->pcbox->hwnd && plb->pcbox->fButtonPressed)
        {
            return SendMessage(plb->pcbox->hwnd, uMsg, wParam, lParam);
        }

        // fall through

    case WM_MOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    {
        POINT pt;

        POINTSTOPOINT(pt, lParam);
        ListBox_TrackMouse(plb, uMsg, pt);

        break;
    }
    case WM_MBUTTONDOWN:
        EnterReaderMode(hwnd);

        break;

    case WM_CAPTURECHANGED:
        //
        // Note that this message should be handled only on unexpected
        // capture changes currently.
        //
        ASSERT(TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT));

        if (plb->fCaptured)
        {
            ListBox_ButtonUp(plb, LBUP_NOTIFY);
        }

        break;

    case LBCB_STARTTRACK:
        //
        // Start tracking mouse moves in the listbox, setting capture
        //
        if (!plb->pcbox)
        {
            break;
        }

        plb->fCaptured = FALSE;
        if (wParam) 
        {
            POINT pt;

            POINTSTOPOINT(pt, lParam);

            ScreenToClient(hwnd, &pt);
            ListBox_TrackMouse(plb, WM_LBUTTONDOWN, pt);
        } 
        else 
        {
            SetCapture(hwnd);
            plb->fCaptured = TRUE;
            plb->iLastSelection = plb->iSel;
        }

        break;

    case LBCB_ENDTRACK:
        //
        // Kill capture, tracking, etc.
        //
        if ( plb->fCaptured || (GetCapture() == plb->hwndParent) )
        {
            ListBox_ButtonUp(plb, LBUP_RELEASECAPTURE | (wParam ? LBUP_SELCHANGE :
                LBUP_RESETSELECTION));
        }

        break;

    case WM_PRINTCLIENT:
        ListBox_Paint(plb, (HDC)wParam, NULL);

        break;

    case WM_NCPAINT:
        if (plb->hTheme && (GET_EXSTYLE(plb) & WS_EX_CLIENTEDGE))
        {
            HRGN hrgn = (wParam != 1) ? (HRGN)wParam : NULL;
            HBRUSH hbr = (HBRUSH)GetClassLongPtr(hwnd, GCLP_HBRBACKGROUND);

            if (CCDrawNonClientTheme(plb->hTheme, hwnd, hrgn, hbr, 0, 0))
            {
                break;
            }
        }
        goto CallDWP;

    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC         hdc;
        LPRECT      lprc;

        if (wParam) 
        {
            hdc = (HDC) wParam;
            lprc = NULL;
        } 
        else 
        {
            hdc = BeginPaint(hwnd, &ps);
            lprc = &(ps.rcPaint);
        }

        if (IsLBoxVisible(plb))
        {
            ListBox_Paint(plb, hdc, lprc);
        }

        if (!wParam)
        {
            EndPaint(hwnd, &ps);
        }

        break;

    }
    case WM_NCDESTROY:
    case WM_FINALDESTROY:
        ListBox_Destroy(plb, hwnd);

        break;

    case WM_SETFOCUS:
        CaretCreate(plb);
        ListBox_SetCaret(plb, TRUE);
        ListBox_NotifyOwner(plb, LBN_SETFOCUS);
        ListBox_Event(plb, EVENT_OBJECT_FOCUS, plb->iSelBase);

        break;

    case WM_KILLFOCUS:
        //
        // Reset the wheel delta count.
        //
        gcWheelDelta = 0;

        ListBox_SetCaret(plb, FALSE);
        ListBox_CaretDestroy(plb);
        ListBox_NotifyOwner(plb, LBN_KILLFOCUS);

        if (plb->iTypeSearch) 
        {
            plb->iTypeSearch = 0;
            KillTimer(hwnd, IDSYS_LBSEARCH);
        }

        if (plb->pszTypeSearch) 
        {
            ControlFree(GetProcessHeap(), plb->pszTypeSearch);
            plb->pszTypeSearch = NULL;
        }

        break;

    case WM_MOUSEWHEEL:
    {
        int     cDetants;
        int     cPage;
        int     cLines;
        RECT    rc;
        int     windowWidth;
        int     cPos;
        UINT    ucWheelScrollLines;

        //
        // Don't handle zoom and datazoom.
        //
        if (wParam & (MK_SHIFT | MK_CONTROL)) 
        {
            goto CallDWP;
        }

        lReturn = 1;
        gcWheelDelta -= (short) HIWORD(wParam);
        cDetants = gcWheelDelta / WHEEL_DELTA;
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &ucWheelScrollLines, 0);
        if (    cDetants != 0 &&
                ucWheelScrollLines > 0 &&
                (GET_STYLE(plb) & (WS_VSCROLL | WS_HSCROLL))) 
        {
            gcWheelDelta = gcWheelDelta % WHEEL_DELTA;

            if (GET_STYLE(plb) & WS_VSCROLL) 
            {
                cPage = max(1, (plb->cItemFullMax - 1));
                cLines = cDetants *
                        (int) min((UINT) cPage, ucWheelScrollLines);

                cPos = max(0, min(plb->iTop + cLines, plb->cMac - 1));
                if (cPos != plb->iTop) 
                {
                    ListBox_VScroll(plb, SB_THUMBPOSITION, cPos);
                    ListBox_VScroll(plb, SB_ENDSCROLL, 0);
                }
            } 
            else if (plb->fMultiColumn) 
            {
                cPage = max(1, plb->numberOfColumns);
                cLines = cDetants * (int) min((UINT) cPage, ucWheelScrollLines);
                cPos = max(
                        0,
                        min((plb->iTop / plb->itemsPerColumn) + cLines,
                            plb->cMac - 1 - ((plb->cMac - 1) % plb->itemsPerColumn)));

                if (cPos != plb->iTop) 
                {
                    ListBox_HSrollMultiColumn(plb, SB_THUMBPOSITION, cPos);
                    ListBox_HSrollMultiColumn(plb, SB_ENDSCROLL, 0);
                }
            } 
            else 
            {
                GetClientRect(plb->hwnd, &rc);
                windowWidth = rc.right;
                cPage = max(plb->cxChar, (windowWidth / 3) * 2) /
                        plb->cxChar;

                cLines = cDetants *
                        (int) min((UINT) cPage, ucWheelScrollLines);

                cPos = max(
                        0,
                        min(plb->xOrigin + (cLines * plb->cxChar),
                            plb->maxWidth));

                if (cPos != plb->xOrigin) {
                    ListBox_HScroll(plb, SB_THUMBPOSITION, cPos);
                    ListBox_HScroll(plb, SB_ENDSCROLL, 0);
                }
            }
        }

        break;
    }
    case WM_VSCROLL:
        ListBox_VScroll(plb, LOWORD(wParam), HIWORD(wParam));

        break;

    case WM_HSCROLL:
        ListBox_HScroll(plb, LOWORD(wParam), HIWORD(wParam));

        break;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS | DLGC_WANTCHARS;

    case WM_CREATE:
        return ListBox_Create(plb, hwnd, (LPCREATESTRUCT)lParam);

    case WM_SETREDRAW:
        //
        // If wParam is nonzero, the redraw flag is set
        // If wParam is zero, the flag is cleared
        //
        ListBox_SetRedraw(plb, (wParam != 0));

        break;

    case WM_ENABLE:
        ListBox_InvalidateRect(plb, NULL, !plb->OwnerDraw);

        break;

    case WM_SETFONT:
        ListBox_SetFont(plb, (HANDLE)wParam, LOWORD(lParam));

        break;

    case WM_GETFONT:
        return (LRESULT)plb->hFont;

    case WM_DRAGSELECT:
    case WM_DRAGLOOP:
    case WM_DRAGMOVE:
    case WM_DROPFILES:
        return SendMessage(plb->hwndParent, uMsg, wParam, lParam);

    case WM_QUERYDROPOBJECT:
    case WM_DROPOBJECT:

        //
        // fix up control data, then pass message to parent
        //
        ListBox_DropObjectHandler(plb, (PDROPSTRUCT)lParam);
        return SendMessage(plb->hwndParent, uMsg, wParam, lParam);

    case LB_GETITEMRECT:
        return ListBox_GetItemRectHandler(plb, (INT)wParam, (LPRECT)lParam);

    case LB_GETITEMDATA:
        //
        // wParam = item index
        //
        return ListBox_GetItemDataHandler(plb, (INT)wParam);

    case LB_SETITEMDATA:

        //
        // wParam is item index
        //
        return ListBox_SetItemDataHandler(plb, (INT)wParam, lParam);

    case LB_ADDSTRINGUPPER:
        wFlags = UPPERCASE | LBI_ADD;
        goto CallInsertItem;

    case LB_ADDSTRINGLOWER:
        wFlags = LOWERCASE | LBI_ADD;
        goto CallInsertItem;

    case LB_ADDSTRING:
        wFlags = LBI_ADD;
        goto CallInsertItem;

    case LB_INSERTSTRINGUPPER:
        wFlags = UPPERCASE;
        goto CallInsertItem;

    case LB_INSERTSTRINGLOWER:
        wFlags = LOWERCASE;
        goto CallInsertItem;

    case LB_INSERTSTRING:
        wFlags = 0;

CallInsertItem:
        // Validate the lParam. If the listbox does not have HASSTRINGS,
        // the lParam is a data value. Otherwise, it is a string 
        // pointer, fail if NULL.
        if ( !TESTFLAG(GET_STYLE(plb), LBS_HASSTRINGS) || lParam )
        {
            lReturn = (LRESULT)ListBox_InsertItem(plb, (LPWSTR) lParam, (int) wParam, wFlags);
            if (!plb->fNoIntegralHeight)
            {
                ListBox_Size(plb, 0, 0, TRUE);
            }
        }
        else
        {
            lReturn = LB_ERR;
        }

        break;

    case LB_INITSTORAGE:
        return ListBox_InitStorage(plb, FALSE, (INT)wParam, (INT)lParam);

    case LB_DELETESTRING:
        return ListBox_DeleteStringHandler(plb, (INT)wParam);

    case LB_DIR:
        //
        // wParam - Dos attribute value.
        // lParam - Points to a file specification string
        //
        lReturn = ListBox_DirHandler(plb, (INT)wParam, (LPWSTR)lParam);

        break;

    case LB_ADDFILE:
        lReturn = ListBox_InsertFile(plb, (LPWSTR)lParam);

        break;

    case LB_SETSEL:
        return ListBox_SetSelHandler(plb, (wParam != 0), (INT)lParam);

    case LB_SETCURSEL:
        //
        // If window obscured, update so invert will work correctly
        //
        return ListBox_SetCurSelHandler(plb, (INT)wParam);

    case LB_GETSEL:
        if (wParam >= (UINT)plb->cMac)
        {
            return (LRESULT)LB_ERR;
        }

        return ListBox_IsSelected(plb, (INT)wParam, SELONLY);

    case LB_GETCURSEL:
        if (plb->wMultiple == SINGLESEL) 
        {
            return plb->iSel;
        }

        return plb->iSelBase;

    case LB_SELITEMRANGE:
        if (plb->wMultiple == SINGLESEL) 
        {
            //
            // Can't select a range if only single selections are enabled
            //
            TraceMsg(TF_STANDARD, "Invalid index passed to LB_SELITEMRANGE");
            return LB_ERR;
        }

        ListBox_SetRange(plb, LOWORD(lParam), HIWORD(lParam), (wParam != 0));

        break;

    case LB_SELITEMRANGEEX:
        if (plb->wMultiple == SINGLESEL) 
        {
            //
            // Can't select a range if only single selections are enabled
            //
            TraceMsg(TF_STANDARD, "LB_SELITEMRANGEEX:Can't select a range if only single selections are enabled");
            return LB_ERR;
        } 
        else 
        {
            BOOL fHighlight = ((DWORD)lParam > (DWORD)wParam);
            if (fHighlight == FALSE) 
            {
                ULONG_PTR temp = lParam;
                lParam = wParam;
                wParam = temp;
            }

            ListBox_SetRange(plb, (INT)wParam, (INT)lParam, fHighlight);
        }

        break;

    case LB_GETTEXTLEN:
        if (lParam != 0) 
        {
            TraceMsg(TF_WARNING, "LB_GETTEXTLEN with lParam = %lx\n", lParam);
        }

        lReturn = ListBox_GetTextHandler(plb, TRUE, FALSE, (INT)wParam, NULL);

        break;

    case LB_GETTEXT:
        lReturn = ListBox_GetTextHandler(plb, FALSE, FALSE, (INT)wParam, (LPWSTR)lParam);

        break;

    case LB_GETCOUNT:
        return (LRESULT)plb->cMac;

    case LB_SETCOUNT:
        return ListBox_SetCount(plb, (INT)wParam);

    case LB_SELECTSTRING:
    case LB_FINDSTRING:
    {
        int iSel = Listbox_FindStringHandler(plb, (LPWSTR)lParam, (INT)wParam, PREFIX, TRUE);

        if (uMsg == LB_FINDSTRING || iSel == LB_ERR) 
        {
            lReturn = iSel;
        } 
        else 
        {
            lReturn = ListBox_SetCurSelHandler(plb, iSel);
        }

        break;
    }
    case LB_GETLOCALE:
        return plb->dwLocaleId;

    case LB_SETLOCALE:
    {
        DWORD   dwRet;

        //
        // Validate locale
        //
        wParam = ConvertDefaultLocale((LCID)wParam);
        if (!IsValidLocale((LCID)wParam, LCID_INSTALLED))
        {
            return LB_ERR;
        }

        dwRet = plb->dwLocaleId;
        plb->dwLocaleId = (DWORD)wParam;

        return dwRet;

    }
    case LB_GETLISTBOXINFO:

        //
        // wParam - not used
        // lParam - not used
        //
        if (plb->fMultiColumn)
        {
            lReturn = (LRESULT)plb->itemsPerColumn;
        }
        else
        {
            lReturn = (LRESULT)plb->cMac;
        }

        break;

    case CB_GETCOMBOBOXINFO:
        //
        // wParam - not used
        // lParam - pointer to COMBOBOXINFO struct
        //
        if (plb->pcbox && plb->pcbox->hwnd && IsWindow(plb->pcbox->hwnd))
        {
            lReturn = SendMessage(plb->pcbox->hwnd, uMsg, wParam, lParam);
        }
        break;

    case CB_SETMINVISIBLE:
        if (!plb->fNoIntegralHeight)
        {
            ListBox_Size(plb, 0, 0, TRUE);
        }

        break;

    case WM_KEYDOWN:

        //
        // IanJa: Use LOWORD() to get low 16-bits of wParam - this should
        // work for Win16 & Win32.  The value obtained is the virtual key
        //
        ListBox_KeyInput(plb, uMsg, LOWORD(wParam));

        break;

    case WM_CHAR:
        ListBox_CharHandler(plb, LOWORD(wParam), FALSE);

        break;

    case LB_GETSELITEMS:
    case LB_GETSELCOUNT:
        //
        // IanJa/Win32 should this be LPWORD now?
        //
        return ListBox_GetSelItemsHandler(plb, (uMsg == LB_GETSELCOUNT), (INT)wParam, (LPINT)lParam);

    case LB_SETTABSTOPS:

        //
        // IanJa/Win32: Tabs given by array of INT for backwards compatability
        //
        return ListBox_SetTabStopsHandler(plb, (INT)wParam, (LPINT)lParam);

    case LB_GETHORIZONTALEXTENT:
        //
        // Return the max width of the listbox used for horizontal scrolling
        //
        return plb->maxWidth;

    case LB_SETHORIZONTALEXTENT:
        //
        // Set the max width of the listbox used for horizontal scrolling
        //
        if (plb->maxWidth != (INT)wParam) 
        {
            plb->maxWidth = (INT)wParam;

            //
            // When horizontal extent is set, Show/hide the scroll bars.
            // NOTE: ListBox_ShowHideScrollBars() takes care if Redraw is OFF.
            // Fix for Bug #2477 -- 01/14/91 -- SANKAR --
            //

            //
            // Try to show or hide scroll bars
            //
            ListBox_ShowHideScrollBars(plb);
            if (plb->fHorzBar && plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw)) 
            {
                //
                // origin to right
                //
                ListBox_HScroll(plb, SB_BOTTOM, 0);
            }
        }

        break;

    case LB_SETCOLUMNWIDTH:

        //
        // Set the width of a column in a multicolumn listbox
        //
        plb->cxColumn = (INT)wParam;
        ListBox_CalcItemRowsAndColumns(plb);

        if (IsLBoxVisible(plb))
        {
            InvalidateRect(hwnd, NULL, TRUE);
        }

        ListBox_ShowHideScrollBars(plb);

        break;

    case LB_SETANCHORINDEX:
        if ((INT)wParam >= plb->cMac) 
        {
            TraceMsg(TF_ERROR, "Invalid index passed to LB_SETANCHORINDEX");
            return LB_ERR;
        }

        plb->iMouseDown = (INT)wParam;
        plb->iLastMouseMove = (INT)wParam;

        ListBox_InsureVisible(plb, (int) wParam, (BOOL)(lParam != 0));

        break;

    case LB_GETANCHORINDEX:
        return plb->iMouseDown;

    case LB_SETCARETINDEX:
        if ( (plb->iSel == -1) || ((plb->wMultiple != SINGLESEL) &&
                    (plb->cMac > (INT)wParam))) 
        {
            //
            // Set's the iSelBase to the wParam
            // if lParam, then don't scroll if partially visible
            // else scroll into view if not fully visible
            //
            ListBox_InsureVisible(plb, (INT)wParam, (BOOL)LOWORD(lParam));
            ListBox_SetISelBase(plb, (INT)wParam);

            break;
        } 
        else 
        {
            if ((INT)wParam >= plb->cMac) 
            {
                TraceMsg(TF_ERROR, "Invalid index passed to LB_SETCARETINDEX");
            }

            return LB_ERR;
        }

        break;

    case LB_GETCARETINDEX:
        return plb->iSelBase;

    case LB_SETITEMHEIGHT:
    case LB_GETITEMHEIGHT:
        return ListBox_GetSetItemHeightHandler(plb, uMsg, (INT)wParam, LOWORD(lParam));

    case LB_FINDSTRINGEXACT:
        return Listbox_FindStringHandler(plb, (LPWSTR)lParam, (INT)wParam, EQ, TRUE);

    case LB_ITEMFROMPOINT: 
    {
        POINT pt;
        BOOL bOutside;
        DWORD dwItem;

        POINTSTOPOINT(pt, lParam);
        bOutside = ListBox_ISelFromPt(plb, pt, &dwItem);
        ASSERT(bOutside == 1 || bOutside == 0);

        return (LRESULT)MAKELONG(dwItem, bOutside);
    }

    case LBCB_CARETON:

        //
        // Internal message for combo box support
        //

        CaretCreate(plb);

        //
        // Set up the caret in the proper location for drop downs.
        //
        plb->iSelBase = plb->iSel;
        ListBox_SetCaret(plb, TRUE);

        if (IsWindowVisible(hwnd) || (GetFocus() == hwnd)) 
        {
            ListBox_Event(plb, EVENT_OBJECT_FOCUS, plb->iSelBase);
        }

        return plb->iSel;

    case LBCB_CARETOFF:

        //
        // Internal message for combo box support
        //
        ListBox_SetCaret(plb, FALSE);
        ListBox_CaretDestroy(plb);

        break;

    case WM_NCCREATE:

        //
        // Allocate the listbox instance stucture
        //
        plb = (PLBIV)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(LBIV));
        if(plb)
        {
            ULONG ulStyle;

            //
            // Success... store the instance pointer.
            //
            TraceMsg(TF_STANDARD, "LISTBOX: Setting listbox instance pointer.");
            ListBox_SetPtr(hwnd, plb);

            plb->hwnd = hwnd;
            plb->pww = (PWW)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);

            ulStyle = GET_STYLE(plb);
            if ( (ulStyle & LBS_MULTICOLUMN) && 
                 (ulStyle & WS_VSCROLL))
            {
                DWORD dwMask = WS_VSCROLL;
                DWORD dwFlags = 0;

                if (!TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT)) 
                {
                    dwMask |= WS_HSCROLL;
                    dwFlags = WS_HSCROLL;
                }

                AlterWindowStyle(hwnd, dwMask, dwFlags);
            }

            goto CallDWP;
        }
        else
        {
            //
            // Failed... return FALSE.
            //
            // From a WM_NCCREATE msg, this will cause the
            // CreateWindow call to fail.
            //
            TraceMsg(TF_STANDARD, "LISTBOX: Unable to allocate listbox instance structure.");
            lReturn = FALSE;
        }

        break;

    case WM_GETOBJECT:

        if(lParam == OBJID_QUERYCLASSNAMEIDX)
        {
            lReturn = MSAA_CLASSNAMEIDX_LISTBOX;
        }
        else
        {
            lReturn = FALSE;
        }

        break;

    case WM_THEMECHANGED:

        if ( plb->hTheme )
        {
            CloseThemeData(plb->hTheme);
        }

        plb->hTheme = OpenThemeData(plb->hwnd, L"Listbox");

        InvalidateRect(plb->hwnd, NULL, TRUE);

        lReturn = TRUE;

        break;

    default:

CallDWP:
        lReturn = DefWindowProcW(hwnd, uMsg, wParam, lParam);
    }

    return lReturn;
}


//---------------------------------------------------------------------------//
//
// Function:       GetWindowBorders
//
// Synopsis:       Calculates # of borders around window
//
// Algorithm:      Calculate # of window borders and # of client borders
//
int GetWindowBorders(LONG lStyle, DWORD dwExStyle, BOOL fWindow, BOOL fClient)
{
    int cBorders = 0;
    DWORD dwTemp;

    if (fWindow) 
    {
        //
        // Is there a 3D border around the window?
        //
        if (dwExStyle & WS_EX_WINDOWEDGE)
        {
            cBorders += 2;
        }
        else if (dwExStyle & WS_EX_STATICEDGE)
        {
            ++cBorders;
        }

        //
        // Is there a single flat border around the window?  This is true for
        // WS_BORDER, WS_DLGFRAME, and WS_EX_DLGMODALFRAME windows.
        //
        if ( (lStyle & WS_CAPTION) || (dwExStyle & WS_EX_DLGMODALFRAME) )
        {
            ++cBorders;
        }

        //
        // Is there a sizing flat border around the window?
        //
        if (lStyle & WS_SIZEBOX)
        {
            if(SystemParametersInfo(SPI_GETBORDER, 0, &dwTemp, 0))
            {
                cBorders += dwTemp;
            }
            else
            {
                ASSERT(0);
            }
        }
                
    }

    if (fClient) 
    {
        //
        // Is there a 3D border around the client?
        //
        if (dwExStyle & WS_EX_CLIENTEDGE)
        {
            cBorders += 2;
        }
    }

    return cBorders;
}


//---------------------------------------------------------------------------//
//
// GetLpszItem
//
// Returns a far pointer to the string belonging to item sItem
// ONLY for Listboxes maintaining their own strings (pLBIV->fHasStrings == TRUE)
//
LPWSTR GetLpszItem(PLBIV pLBIV, INT sItem)
{
    LONG offsz;
    lpLBItem plbi;

    if (sItem < 0 || sItem >= pLBIV->cMac) 
    {
        TraceMsg(TF_ERROR, "Invalid parameter \"sItem\" (%ld) to GetLpszItem", sItem);
        return NULL;
    }

    //
    // get pointer to item index array
    // NOTE: NOT OWNERDRAW
    //
    plbi = (lpLBItem)(pLBIV->rgpch);
    offsz = plbi[sItem].offsz;

    return (LPWSTR)((PBYTE)(pLBIV->hStrings) + offsz);
}


//---------------------------------------------------------------------------//
//
// Multi column Listbox functions 
//


//---------------------------------------------------------------------------//
//
// ListBox_CalcItemRowsAndColumns
//
// Calculates the number of columns (including partially visible)
// in the listbox and calculates the number of items per column
//
void ListBox_CalcItemRowsAndColumns(PLBIV plb)
{
    RECT rc;

    GetClientRect(plb->hwnd, &rc);

    //
    // B#4155
    // We need to check if plb->cyChar has been initialized.  This is because
    // we remove WS_BORDER from old listboxes and add on WS_EX_CLIENTEDGE.
    // Since listboxes are always inflated by CXBORDER and CYBORDER, a
    // listbox that was created empty always ends up 2 x 2.  Since this isn't
    // big enough to fit the entire client border, we don't mark it as
    // present.  Thus the client isn't empty in VER40, although it was in
    // VER31 and before.  It is possible to get to this spot without
    // plb->cyChar having been initialized yet if the listbox  is
    // multicolumn && ownerdraw variable.
    //

    if (rc.bottom && rc.right && plb->cyChar) 
    {
        //
        // Only make these calculations if the width & height are positive
        //
        plb->itemsPerColumn = (INT)max(rc.bottom / plb->cyChar, 1);
        plb->numberOfColumns = (INT)max(rc.right / plb->cxColumn, 1);

        plb->cItemFullMax = plb->itemsPerColumn * plb->numberOfColumns;

        //
        // Adjust iTop so it's at the top of a column
        //
        ListBox_NewITop(plb, plb->iTop);
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_HSrollMultiColumn
//
// Supports horizontal scrolling of multicolumn listboxes
//
void ListBox_HSrollMultiColumn(PLBIV plb, INT cmd, INT xAmt)
{
    INT iTop = plb->iTop;

    if (!plb->cMac)  
    {
        return;
    }

    switch (cmd) 
    {
    case SB_LINEUP:
        if (plb->fRightAlign)
        {
            goto ReallyLineDown;
        }

ReallyLineUp:
        iTop -= plb->itemsPerColumn;

        break;

    case SB_LINEDOWN:
        if (plb->fRightAlign)
        {
            goto ReallyLineUp;
        }

ReallyLineDown:
        iTop += plb->itemsPerColumn;

        break;

    case SB_PAGEUP:
        if (plb->fRightAlign)
        {
            goto ReallyPageDown;
        }

ReallyPageUp:
        iTop -= plb->itemsPerColumn * plb->numberOfColumns;

        break;

    case SB_PAGEDOWN:
        if (plb->fRightAlign)
        {
            goto ReallyPageUp;
        }

ReallyPageDown:
        iTop += plb->itemsPerColumn * plb->numberOfColumns;

        break;

    case SB_THUMBTRACK:
    case SB_THUMBPOSITION:
        if (plb->fRightAlign) 
        {
            int  iCols = plb->cMac ? ((plb->cMac-1) / plb->itemsPerColumn) + 1 : 0;

            xAmt = iCols - (xAmt + plb->numberOfColumns);
            if (xAmt < 0)
            {
                xAmt=0;
            }
        }

        iTop = xAmt * plb->itemsPerColumn;

        break;

    case SB_TOP:
        if (plb->fRightAlign)
        {
            goto ReallyBottom;
        }

ReallyTop:
        iTop = 0;

        break;

    case SB_BOTTOM:
        if (plb->fRightAlign)
        {
            goto ReallyTop;
        }
ReallyBottom:
        iTop = plb->cMac - 1 - ((plb->cMac - 1) % plb->itemsPerColumn);

        break;

    case SB_ENDSCROLL:
        plb->fSmoothScroll = TRUE;
        ListBox_ShowHideScrollBars(plb);

        break;
    }

    ListBox_NewITop(plb, iTop);
}


//---------------------------------------------------------------------------//
//
// ListBox variable height owner draw functions 
//


//---------------------------------------------------------------------------//
//
// ListBox_GetVarHeightItemHeight
//
// Returns the height of the given item number. Assumes variable
// height owner draw.
//
INT ListBox_GetVarHeightItemHeight(PLBIV plb, INT itemNumber)
{
    BYTE itemHeight;
    UINT offsetHeight;

    if (plb->cMac) 
    {
        if (plb->fHasStrings)
        {
            offsetHeight = plb->cMac * sizeof(LBItem);
        }
        else
        {
            offsetHeight = plb->cMac * sizeof(LBODItem);
        }

        if (plb->wMultiple)
        {
            offsetHeight += plb->cMac;
        }

        offsetHeight += itemNumber;

        itemHeight = *(plb->rgpch+(UINT)offsetHeight);

        return (INT)itemHeight;

    }

    //
    // Default, we return the height of the system font.  This is so we can draw
    // the focus rect even though there are no items in the listbox.
    //
    return SYSFONT_CYCHAR;
}


//---------------------------------------------------------------------------//
//
// ListBox_SetVarHeightItemHeight
//
// Sets the height of the given item number. Assumes variable height
// owner draw, a valid item number and valid height.
//
void ListBox_SetVarHeightItemHeight(PLBIV plb, INT itemNumber, INT itemHeight)
{
    int offsetHeight;

    if (plb->fHasStrings)
        offsetHeight = plb->cMac * sizeof(LBItem);
    else
        offsetHeight = plb->cMac * sizeof(LBODItem);

    if (plb->wMultiple)
        offsetHeight += plb->cMac;

    offsetHeight += itemNumber;

    *(plb->rgpch + (UINT)offsetHeight) = (BYTE)itemHeight;

}


//---------------------------------------------------------------------------//
//
// ListBox_VisibleItemsVarOwnerDraw
//
// Returns the number of items which can fit in a variable height OWNERDRAW
// list box. If fDirection, then we return the number of items which
// fit starting at sTop and going forward (for page down), otherwise, we are
// going backwards (for page up). (Assumes var height ownerdraw) If fPartial,
// then include the partially visible item at the bottom of the listbox.
//
INT ListBox_VisibleItemsVarOwnerDraw(PLBIV plb, BOOL fPartial)
{
    RECT rect;
    INT sItem;
    INT clientbottom;

    GetClientRect(plb->hwnd, (LPRECT)&rect);
    clientbottom = rect.bottom;

    //
    // Find the number of var height ownerdraw items which are visible starting
    // from plb->iTop.
    //
    for (sItem = plb->iTop; sItem < plb->cMac; sItem++) 
    {
        //
        // Find out if the item is visible or not
        //
        if (!ListBox_GetItemRectHandler(plb, sItem, (LPRECT)&rect)) 
        {
            //
            // This is the first item which is completely invisible, so return
            // how many items are visible.
            //
            return (sItem - plb->iTop);
        }

        if (!fPartial && rect.bottom > clientbottom) 
        {
            //
            // If we only want fully visible items, then if this item is
            // visible, we check if the bottom of the item is below the client
            // rect, so we return how many are fully visible.
            //
            return (sItem - plb->iTop - 1);
        }
    }

    //
    // All the items are visible
    //
    return (plb->cMac - plb->iTop);
}


//---------------------------------------------------------------------------//
//
// ListBox_Page
//
// For variable height ownerdraw listboxes, calaculates the new iTop we must
// move to when paging (page up/down) through variable height listboxes.
//
INT ListBox_Page(PLBIV plb, INT startItem, BOOL fPageForwardDirection)
{
    INT     i;
    INT height;
    RECT    rc;

    if (plb->cMac == 1)
    {
        return 0;
    }

    GetClientRect(plb->hwnd, &rc);
    height = rc.bottom;
    i = startItem;

    if (fPageForwardDirection) 
    {
        while ((height >= 0) && (i < plb->cMac))
        {
            height -= ListBox_GetVarHeightItemHeight(plb, i++);
        }

        return (height >= 0) ? (plb->cMac - 1) : max(i - 2, startItem + 1);

    } 
    else 
    {
        while ((height >= 0) && (i >= 0))
        {
            height -= ListBox_GetVarHeightItemHeight(plb, i--);
        }

        return (height >= 0) ? 0 : min(i + 2, startItem - 1);
    }

}


//---------------------------------------------------------------------------//
//
// ListBox_CalcVarITopScrollAmt
//
// Changing the top most item in the listbox from iTopOld to iTopNew we
// want to calculate the number of pixels to scroll so that we minimize the
// number of items we will redraw.
//
INT ListBox_CalcVarITopScrollAmt(PLBIV plb, INT iTopOld, INT iTopNew)
{
    RECT rc;
    RECT rcClient;

    GetClientRect(plb->hwnd, (LPRECT)&rcClient);

    //
    // Just optimize redrawing when move +/- 1 item.  We will redraw all items
    // if moving more than 1 item ahead or back.  This is good enough for now.
    //
    if (iTopOld + 1 == iTopNew) 
    {
        //
        // We are scrolling the current iTop up off the top off the listbox so
        // return a negative number.
        //
        ListBox_GetItemRectHandler(plb, iTopOld, (LPRECT)&rc);

        return (rcClient.top - rc.bottom);
    }

    if (iTopOld - 1 == iTopNew) 
    {
        //
        // We are scrolling the current iTop down and the previous item is
        // becoming the new iTop so return a positive number.
        //
        ListBox_GetItemRectHandler(plb, iTopNew, (LPRECT)&rc);

        return -rc.top;
    }

    return rcClient.bottom - rcClient.top;
}


//---------------------------------------------------------------------------//
//
// (supposedly) Rarely called Listbox functions 
//


//---------------------------------------------------------------------------//
void ListBox_SetCItemFullMax(PLBIV plb)
{
    if (plb->OwnerDraw != OWNERDRAWVAR) 
    {
        plb->cItemFullMax = ListBox_CItemInWindow(plb, FALSE);
    } 
    else if (plb->cMac < 2) 
    {
        plb->cItemFullMax = 1;
    } 
    else 
    {
        int     height;
        RECT    rect;
        int     i;
        int     j = 0;

        GetClientRect(plb->hwnd, &rect);
        height = rect.bottom;

        plb->cItemFullMax = 0;
        for (i = plb->cMac - 1; i >= 0; i--, j++) 
        {
            height -= ListBox_GetVarHeightItemHeight(plb, i);

            if (height < 0) 
            {
                plb->cItemFullMax = j;

                break;
            }
        }

        if (!plb->cItemFullMax)
        {
            plb->cItemFullMax = j;
        }
    }
}


//---------------------------------------------------------------------------//
LONG ListBox_Create(PLBIV plb, HWND hwnd, LPCREATESTRUCT lpcs)
{
    UINT style;
    DWORD ExStyle;
    MEASUREITEMSTRUCT measureItemStruct;
    HDC hdc;
    HWND hwndParent;
    SIZE size;

    //
    // Once we make it here, nobody can change the ownerdraw style bits
    // by calling SetWindowLong. The window style must match the flags in plb
    //
    plb->fInitialized = TRUE;

    style = lpcs->style;
    ExStyle = lpcs->dwExStyle;
    hwndParent = lpcs->hwndParent;

    plb->hwndParent = hwndParent;
    plb->hTheme = OpenThemeData(plb->hwnd, L"Listbox");

    //
    // Break out the style bits
    //
    plb->fRedraw = ((style & LBS_NOREDRAW) == 0);
    plb->fDeferUpdate = FALSE;
    plb->fNotify = (UINT)((style & LBS_NOTIFY) != 0);
    plb->fVertBar = ((style & WS_VSCROLL) != 0);
    plb->fHorzBar = ((style & WS_HSCROLL) != 0);

    if (!TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT)) 
    {
        //
        // for 3.x apps, if either scroll bar was specified, the app got BOTH
        //
        if (plb->fVertBar || plb->fHorzBar)
        {
            plb->fVertBar = plb->fHorzBar = TRUE;
        }
    }

    plb->fRtoLReading = (ExStyle & WS_EX_RTLREADING)!= 0;
    plb->fRightAlign  = (ExStyle & WS_EX_RIGHT) != 0;
    plb->fDisableNoScroll = ((style & LBS_DISABLENOSCROLL) != 0);

    plb->fSmoothScroll = TRUE;

    //
    // LBS_NOSEL gets priority over any other selection style.  Next highest
    // priority goes to LBS_EXTENDEDSEL. Then LBS_MULTIPLESEL.
    //
    if (TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT) && (style & LBS_NOSEL)) 
    {
        plb->wMultiple = SINGLESEL;
        plb->fNoSel = TRUE;
    } 
    else if (style & LBS_EXTENDEDSEL) 
    {
        plb->wMultiple = EXTENDEDSEL;
    } 
    else 
    {
        plb->wMultiple = (UINT)((style & LBS_MULTIPLESEL) ? MULTIPLESEL : SINGLESEL);
    }

    plb->fNoIntegralHeight = ((style & LBS_NOINTEGRALHEIGHT) != 0);
    plb->fWantKeyboardInput = ((style & LBS_WANTKEYBOARDINPUT) != 0);
    plb->fUseTabStops = ((style & LBS_USETABSTOPS) != 0);

    if (plb->fUseTabStops) 
    {
        //
        // Set tab stops every <default> dialog units.
        //
        ListBox_SetTabStopsHandler(plb, 0, NULL);
    }

    plb->fMultiColumn = ((style & LBS_MULTICOLUMN) != 0);
    plb->fHasStrings = TRUE;
    plb->iLastSelection = -1;

    //
    // Anchor point for multi selection
    //
    plb->iMouseDown = -1;
    plb->iLastMouseMove = -1;

    //
    // Get ownerdraw style bits
    //
    if ((style & LBS_OWNERDRAWFIXED)) 
    {
        plb->OwnerDraw = OWNERDRAWFIXED;
    } 
    else if ((style & LBS_OWNERDRAWVARIABLE) && !plb->fMultiColumn) 
    {
        plb->OwnerDraw = OWNERDRAWVAR;

        //
        // Integral height makes no sense with var height owner draw
        //
        plb->fNoIntegralHeight = TRUE;
    }

    if (plb->OwnerDraw && !(style & LBS_HASSTRINGS)) 
    {
        //
        // If owner draw, do they want the listbox to maintain strings?
        //
        plb->fHasStrings = FALSE;
    }

    //
    // If user specifies sort and not hasstrings, then we will send
    // WM_COMPAREITEM messages to the parent.
    //
    plb->fSort = ((style & LBS_SORT) != 0);

    //
    // "No data" lazy-eval listbox mandates certain other style settings
    //
    plb->fHasData = TRUE;

    if (style & LBS_NODATA) 
    {
        if (plb->OwnerDraw != OWNERDRAWFIXED || plb->fSort || plb->fHasStrings) 
        {
            TraceMsg(TF_STANDARD, "NODATA listbox must be OWNERDRAWFIXED, w/o SORT or HASSTRINGS");
        } 
        else 
        {
            plb->fHasData = FALSE;
        }
    }

    plb->dwLocaleId = GetThreadLocale();

    //
    // Check if this is part of a combo box
    //
    if ((style & LBS_COMBOBOX) != 0) 
    {
        //
        // Get the pcbox structure contained in the parent window's extra data
        // pointer.  Check cbwndExtra to ensure compatibility with SQL windows.
        //
        plb->pcbox = ComboBox_GetPtr(hwndParent);
    }

    plb->iSel = -1;
    plb->hdc = NULL;

    //
    // Set the keyboard state so that when the user keyboard clicks he selects
    // an item.
    //
    plb->fNewItemState = TRUE;

    ListBox_InitHStrings(plb);

    if (plb->fHasStrings && plb->hStrings == NULL) 
    {
        return -1L;
    }

    hdc = GetDC(hwnd);
    GetCharDimensions(hdc, &size);
    plb->cxChar = size.cx; 
    plb->cyChar = size.cy;
    ReleaseDC(hwnd, hdc);

    if ((plb->cxChar == 0) || (plb->cyChar == 0))
    {
        TraceMsg(TF_STANDARD, "LISTBOX: GetCharDimensions failed.");
        plb->cxChar = SYSFONT_CXCHAR;
        plb->cyChar = SYSFONT_CYCHAR;
    }

    if (plb->OwnerDraw == OWNERDRAWFIXED) 
    {
        //
        // Query for item height only if we are fixed height owner draw.  Note
        // that we don't care about an item's width for listboxes.
        //
        measureItemStruct.CtlType = ODT_LISTBOX;
        measureItemStruct.CtlID = GetDlgCtrlID(hwnd);

        //
        // System font height is default height
        //
        measureItemStruct.itemHeight = plb->cyChar;
        measureItemStruct.itemWidth = 0;
        measureItemStruct.itemData = 0;

        //
        // IanJa: #ifndef WIN16 (32-bit Windows), plb->id gets extended
        // to LONG wParam automatically by the compiler
        //
        SendMessage(plb->hwndParent, WM_MEASUREITEM,
                measureItemStruct.CtlID,
                (LPARAM)&measureItemStruct);

        //
        // Use default height if given 0.  This prevents any possible future
        // div-by-zero errors.
        //
        if (measureItemStruct.itemHeight)
        {
            plb->cyChar = measureItemStruct.itemHeight;
        }

        if (plb->fMultiColumn) 
        {
            //
            // Get default column width from measure items struct if we are a
            // multicolumn listbox.
            //
            plb->cxColumn = measureItemStruct.itemWidth;
        }
    } 
    else if (plb->OwnerDraw == OWNERDRAWVAR)
    {
        plb->cyChar = 0;
    }


    if (plb->fMultiColumn) 
    {
        //
        // Set these default values till we get the WM_SIZE message and we
        // calculate them properly.  This is because some people create a
        // 0 width/height listbox and size it later.  We don't want to have
        // problems with invalid values in these fields
        //
        if (plb->cxColumn <= 0)
        {
            plb->cxColumn = 15 * plb->cxChar;
        }

        plb->numberOfColumns = plb->itemsPerColumn = 1;
    }

    ListBox_SetCItemFullMax(plb);

    //
    // Don't do this for 4.0 apps.  It'll make everyone's lives easier and
    // fix the anomaly that a combo & list created the same width end up
    // different when all is done.
    // B#1520
    //
    if (!TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT)) 
    {
        plb->fIgnoreSizeMsg = TRUE;
        MoveWindow(hwnd,
             lpcs->x - SYSMET(CXBORDER),
             lpcs->y - SYSMET(CYBORDER),
             lpcs->cx + SYSMET(CXEDGE),
             lpcs->cy + SYSMET(CYEDGE),
             FALSE);
        plb->fIgnoreSizeMsg = FALSE;
    }

    if (!plb->fNoIntegralHeight) 
    {
        //
        // Send a message to ourselves to resize the listbox to an integral
        // height.  We need to do it this way because at create time we are all
        // mucked up with window rects etc...
        // IanJa: #ifndef WIN16 (32-bit Windows), wParam 0 gets extended
        // to wParam 0L automatically by the compiler.
        //
        PostMessage(hwnd, WM_SIZE, 0, 0L);
    }

    return 1L;
}


//---------------------------------------------------------------------------//
//
// ListBox_DoDeleteItems
// 
// Send DELETEITEM message for all the items in the ownerdraw listbox.
//
void ListBox_DoDeleteItems(PLBIV plb)
{
    INT sItem;

    //
    // Send WM_DELETEITEM message for ownerdraw listboxes which are
    // being deleted.  (NODATA listboxes don't send such, though.)
    //
    if (plb->OwnerDraw && plb->cMac && plb->fHasData) 
    {
        for (sItem = plb->cMac - 1; sItem >= 0; sItem--) 
        {
            ListBox_DeleteItem(plb, sItem);
        }
    }
}


//---------------------------------------------------------------------------//
VOID ListBox_Destroy(PLBIV plv, HWND hwnd)
{

    if (plv != NULL) 
    {
        //
        // If ownerdraw, send deleteitem messages to parent
        //
        ListBox_DoDeleteItems(plv);

        if (plv->rgpch != NULL) 
        {
            ControlFree(GetProcessHeap(), plv->rgpch);
            plv->rgpch = NULL;
        }

        if (plv->hStrings != NULL) 
        {
            ControlFree(GetProcessHeap(), plv->hStrings);
            plv->hStrings = NULL;
        }

        if (plv->iTabPixelPositions != NULL) 
        {
            ControlFree(GetProcessHeap(), (HANDLE)plv->iTabPixelPositions);
            plv->iTabPixelPositions = NULL;
        }

        if (plv->pszTypeSearch) 
        {
            ControlFree(GetProcessHeap(), plv->pszTypeSearch);
        }


        if (plv->hTheme != NULL)
        {
            CloseThemeData(plv->hTheme);
        }

        //
        // If we're part of a combo box, let it know we're gone
        //
        if (plv->hwndParent && plv->pcbox) 
        {
            ComboBox_WndProc(plv->hwndParent, WM_PARENTNOTIFY,
                    MAKEWPARAM(WM_DESTROY, GetWindowID(hwnd)), (LPARAM)hwnd);
        }

        UserLocalFree(plv);
    }

    TraceMsg(TF_STANDARD, "LISTBOX: Clearing listbox instance pointer.");
    ListBox_SetPtr(hwnd, NULL);
}


//---------------------------------------------------------------------------//
void ListBox_SetFont(PLBIV plb, HANDLE hFont, BOOL fRedraw)
{
    HDC    hdc;
    HANDLE hOldFont = NULL;
    SIZE   size;

    plb->hFont = hFont;

    hdc = GetDC(plb->hwnd);

    if (hFont) 
    {
        hOldFont = SelectObject(hdc, hFont);

        if (!hOldFont) 
        {
            plb->hFont = NULL;
        }
    }

    GetCharDimensions(hdc, &size);
    if ((size.cx == 0) || (size.cy == 0))
    {
        TraceMsg(TF_STANDARD, "LISTBOX: GetCharDimensions failed.");
        size.cx = SYSFONT_CXCHAR;
        size.cy = SYSFONT_CYCHAR;
    }
    plb->cxChar = size.cx;

    if (!plb->OwnerDraw && (plb->cyChar != size.cy)) 
    {
        //
        // We don't want to mess up the cyChar height for owner draw listboxes
        // so don't do this.
        //
        plb->cyChar = size.cy;

        //
        // Only resize the listbox for 4.0 dudes, or combo dropdowns.
        // Macromedia Director 4.0 GP-faults otherwise.
        //
        if (!plb->fNoIntegralHeight &&
                (plb->pcbox || TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT))) 
        {
            RECT rcClient;

            GetClientRect(plb->hwnd, &rcClient);
            ListBox_Size(plb, rcClient.right  - rcClient.left, rcClient.bottom - rcClient.top, FALSE);
        }
    }

    if (hOldFont) 
    {
        SelectObject(hdc, hOldFont);
    }

    ReleaseDC(plb->hwnd, hdc);

    if (plb->fMultiColumn) 
    {
        ListBox_CalcItemRowsAndColumns(plb);
    }

    ListBox_SetCItemFullMax(plb);

    if (fRedraw)
    {
        ListBox_CheckRedraw(plb, FALSE, 0);
    }
}


//---------------------------------------------------------------------------//
void ListBox_Size(PLBIV plb, INT cx, INT cy, BOOL fSizeMinVisible)
{
    RECT rc, rcWindow;
    int  iTopOld;
    int  cBorder;
    BOOL fSizedSave;

    if (!plb->fNoIntegralHeight) 
    {
        int cBdrs = GetWindowBorders(GET_STYLE(plb), GET_EXSTYLE(plb), TRUE, TRUE);

        GetWindowRect(plb->hwnd, &rcWindow);
        cBorder = SYSMET(CYBORDER);
        CopyRect(&rc, &rcWindow);
        InflateRect(&rc, 0, -cBdrs * cBorder);

        //
        // Size the listbox to fit an integral # of items in its client
        //
        if ((plb->cyChar && ((rc.bottom - rc.top) % plb->cyChar)) || fSizeMinVisible) 
        {
            int iItems = (rc.bottom - rc.top);

            //
            // B#2285 - If its a 3.1 app its SetWindowPos needs
            // to be window based dimensions not Client !
            // this crunches Money into using a scroll bar
            //
            if (!TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT))
            {
                //
                // so add it back in
                //
                iItems += (cBdrs * SYSMET(CYEDGE));
            }

            iItems /= plb->cyChar;

            //
            // If we're in a dropdown list, size the listbox to accomodate 
            // a minimum number of items before needing to show scrolls.
            //
            if (plb->pcbox && 
               (plb->pcbox->CBoxStyle & SDROPPABLE) &&
               (((iItems < plb->pcbox->iMinVisible) && 
               (iItems < plb->cMac)) || fSizeMinVisible))
            {
                iItems = min(plb->pcbox->iMinVisible, plb->cMac);
            }

            SetWindowPos(plb->hwnd, HWND_TOP, 0, 0, rc.right - rc.left,
                    iItems * plb->cyChar + (SYSMET(CYEDGE) * cBdrs),
                    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);

            //
            // Changing the size causes us to recurse.  Upon return
            // the state is where it should be and nothing further
            // needs to be done.
            //
            return;
        }
    }

    if (plb->fMultiColumn) 
    {
        //
        // Compute the number of DISPLAYABLE rows and columns in the listbox
        //
        ListBox_CalcItemRowsAndColumns(plb);
    } 
    else 
    {
        //
        // Adjust the current horizontal position to eliminate as much
        // empty space as possible from the right side of the items.
        //
        GetClientRect(plb->hwnd, &rc);

        if ((plb->maxWidth - plb->xOrigin) < (rc.right - rc.left))
        {
            plb->xOrigin = max(0, plb->maxWidth - (rc.right - rc.left));
        }
    }

    ListBox_SetCItemFullMax(plb);

    //
    // Adjust the top item in the listbox to eliminate as much empty space
    // after the last item as possible
    // (fix for bugs #8490 & #3836)
    //
    iTopOld = plb->iTop;
    fSizedSave = plb->fSized;
    plb->fSized = FALSE;
    ListBox_NewITop(plb, plb->iTop);

    //
    // If changing the top item index caused a resize, there is no
    // more work to be done here.
    //
    if (plb->fSized)
    {
        return;
    }

    plb->fSized = fSizedSave;

    if (IsLBoxVisible(plb)) 
    {
        //
        // This code no longer blows because it's fixed right!!!  We could
        // optimize the fMultiColumn case with some more code to figure out
        // if we really need to invalidate the whole thing but note that some
        // 3.0 apps depend on this extra invalidation (AMIPRO 2.0, bug 14620)
        // 
        // For 3.1 apps, we blow off the invalidaterect in the case where
        // cx and cy are 0 because this happens during the processing of
        // the posted WM_SIZE message when we are created which would otherwise
        // cause us to flash.
        //
        if ((plb->fMultiColumn && !(cx == 0 && cy == 0)) || plb->iTop != iTopOld)
        {
            InvalidateRect(plb->hwnd, NULL, TRUE);
        }
        else if (plb->iSelBase >= 0) 
        {
            //
            // Invalidate the item with the caret so that if the listbox
            // grows horizontally, we redraw it properly.
            //
            ListBox_GetItemRectHandler(plb, plb->iSelBase, &rc);
            InvalidateRect(plb->hwnd, &rc, FALSE);
        }
    } 
    else if (!plb->fRedraw)
    {
        plb->fDeferUpdate = TRUE;
    }

    //
    // Send "fake" scroll bar messages to update the scroll positions since we
    // changed size.
    //
    if (TESTFLAG(GET_STYLE(plb), WS_VSCROLL)) 
    {
        ListBox_VScroll(plb, SB_ENDSCROLL, 0);
    }

    //
    // We count on this to call ListBox_ShowHideScrollBars except when plb->cMac == 0!
    //
    ListBox_HScroll(plb, SB_ENDSCROLL, 0);

    //
    // Show/hide scroll bars depending on how much stuff is visible...
    // 
    // Note:  Now we only call this guy when cMac == 0, because it is
    // called inside the ListBox_HScroll with SB_ENDSCROLL otherwise.
    //
    if (plb->cMac == 0)
    {
        ListBox_ShowHideScrollBars(plb);
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_SetTabStopsHandler
//
// Sets the tab stops for this listbox. Returns TRUE if successful else FALSE.
//
BOOL ListBox_SetTabStopsHandler(PLBIV plb, INT count, LPINT lptabstops)
{
    PINT ptabs;

    if (!plb->fUseTabStops) 
    {
        TraceMsg(TF_STANDARD, "Calling SetTabStops without the LBS_TABSTOPS style set");

        return FALSE;
    }

    if (count) 
    {
        //
        // Allocate memory for the tab stops.  The first byte in the
        // plb->iTabPixelPositions array will contain a count of the number
        // of tab stop positions we have.
        //
        ptabs = (LPINT)ControlAlloc(GetProcessHeap(), (count + 1) * sizeof(int));

        if (ptabs == NULL)
        {
            return FALSE;
        }

        if (plb->iTabPixelPositions != NULL)
        {
            ControlFree(GetProcessHeap(), plb->iTabPixelPositions);
        }

        plb->iTabPixelPositions = ptabs;

        //
        // Set the count of tab stops
        // 
        *ptabs++ = count;

        for (; count > 0; count--) 
        {
            //
            // Convert the dialog unit tabstops into pixel position tab stops.
            //
            *ptabs++ = MultDiv(*lptabstops, plb->cxChar, 4);
            lptabstops++;
        }
    } 
    else 
    {
        //
        // Set default 8 system font ave char width tabs.  So free the memory
        // associated with the tab stop list.
        //
        if (plb->iTabPixelPositions != NULL) 
        {
            ControlFree(GetProcessHeap(), (HANDLE)plb->iTabPixelPositions);
            plb->iTabPixelPositions = NULL;
        }
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
void ListBox_InitHStrings(PLBIV plb)
{
    if (plb->fHasStrings) 
    {
        plb->ichAlloc = 0;
        plb->cchStrings = 0;
        plb->hStrings = ControlAlloc(GetProcessHeap(), 0);  
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_DropObjectHandler
//
// Handles a WM_DROPITEM message on this listbox
//
void ListBox_DropObjectHandler(PLBIV plb, PDROPSTRUCT pds)
{
    LONG mouseSel;

    if (ListBox_ISelFromPt(plb, pds->ptDrop, &mouseSel)) 
    {
        //
        // User dropped in empty space at bottom of listbox
        //
        pds->dwControlData = (DWORD)-1L;
    } 
    else 
    {
        pds->dwControlData = mouseSel;
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_GetSetItemHeightHandler()
//
// Sets/Gets the height associated with each item.  For non ownerdraw
// and fixed height ownerdraw, the item number is ignored.
//
int ListBox_GetSetItemHeightHandler(PLBIV plb, UINT message, int item, UINT height)
{
    if (message == LB_GETITEMHEIGHT) 
    {
        //
        // All items are same height for non ownerdraw and for fixed height
        // ownerdraw.
        //
        if (plb->OwnerDraw != OWNERDRAWVAR)
        {
            return plb->cyChar;
        }

        if (plb->cMac && item >= plb->cMac) 
        {
            TraceMsg(TF_STANDARD, 
                "Invalid parameter \"item\" (%ld) to ListBox_GetSetItemHeightHandler", item);

            return LB_ERR;
        }

        return (int)ListBox_GetVarHeightItemHeight(plb, (INT)item);
    }

    if (!height || height > 255) 
    {
        TraceMsg(TF_STANDARD, 
            "Invalid parameter \"height\" (%ld) to ListBox_GetSetItemHeightHandler", height);

        return LB_ERR;
    }

    if (plb->OwnerDraw != OWNERDRAWVAR)
    {
        plb->cyChar = height;
    }
    else 
    {
        if (item < 0 || item >= plb->cMac) 
        {
            TraceMsg(TF_STANDARD, 
                "Invalid parameter \"item\" (%ld) to ListBox_GetSetItemHeightHandler", item);

            return LB_ERR;
        }

        ListBox_SetVarHeightItemHeight(plb, (INT)item, (INT)height);
    }

    if (plb->fMultiColumn)
    {
        ListBox_CalcItemRowsAndColumns(plb);
    }

    ListBox_SetCItemFullMax(plb);

    return 0;
}


//---------------------------------------------------------------------------//
//
// ListBox_Event()
//
// This is for item focus & selection events in listboxes.
//
void ListBox_Event(PLBIV plb, UINT uEvent, int iItem)
{

    switch (uEvent) 
    {
    case EVENT_OBJECT_SELECTIONREMOVE:
        if (plb->wMultiple != SINGLESEL) 
        {
            break;
        }
        iItem = -1;

        //
        // FALL THRU
        //

    case EVENT_OBJECT_SELECTIONADD:
        if (plb->wMultiple == MULTIPLESEL) 
        {
            uEvent = EVENT_OBJECT_SELECTION;
        }
        break;

    case EVENT_OBJECT_SELECTIONWITHIN:
        iItem = -1;
        break;
    }

    NotifyWinEvent(uEvent, plb->hwnd, OBJID_CLIENT, iItem+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\listbox_ctl1.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "listbox.h"


//---------------------------------------------------------------------------//

//
//  Number of list box items we allocated whenever we grow the list box
//  structures.
//
#define CITEMSALLOC     32


//---------------------------------------------------------------------------//
//
// Forwards
//
INT ListBox_BinarySearchString(PLBIV plb,LPWSTR lpstr);


//---------------------------------------------------------------------------//
//
// Routine Description:
//
//    This functions determines how many bytes would be needed to represent
//    the specified Unicode source string as an ANSI string (not counting the
//    null terminator)
//
BOOL UnicodeToMultiByteSize( OUT PULONG BytesInMultiByteString, IN PWCH UnicodeString, IN ULONG BytesInUnicodeString)
{
    //
    //This should just tell us how much buffer is needed
    //
    ULONG cbSize = WideCharToMultiByte(CP_THREAD_ACP, WC_SEPCHARS, UnicodeString, -1, NULL, 0, NULL, NULL);

    if(cbSize)
    {
        *BytesInMultiByteString = cbSize;
        return TRUE;
    }

    return FALSE;
}


//---------------------------------------------------------------------------//
//
// ListBox_SetScrollParms()
// 
// Sets the scroll range, page, and position
//
int ListBox_SetScrollParms(PLBIV plb, int nCtl)
{
    int         iPos;
    int         cItems;
    UINT        iPage;
    SCROLLINFO  si;
    BOOL        fNoScroll = FALSE;
    PSCROLLPOS  psp;
    BOOL        fCacheInitialized;
    int         iReturn;

    if (nCtl == SB_VERT) 
    {
        iPos = plb->iTop;
        cItems = plb->cMac;
        iPage = plb->cItemFullMax;

        if (!plb->fVertBar)
        {
            fNoScroll = TRUE;
        }

        psp = &plb->VPos;

        fCacheInitialized = plb->fVertInitialized;
    } 
    else 
    {
        if (plb->fMultiColumn) 
        {
            iPos   = plb->iTop / plb->itemsPerColumn;
            cItems = plb->cMac ? ((plb->cMac - 1) / plb->itemsPerColumn) + 1 : 0;
            iPage = plb->numberOfColumns;

            if (plb->fRightAlign && cItems)
            {
                iPos = cItems - iPos - 1;
            }
        } 
        else 
        {
            RECT r = {0};
            GetClientRect(plb->hwnd, &r);
            iPos = plb->xOrigin;
            cItems = plb->maxWidth;
            iPage = RECTWIDTH(r);
        }

        if (!plb->fHorzBar)
        {
            fNoScroll = TRUE;
        }

        psp = &plb->HPos;

        fCacheInitialized = plb->fHorzInitialized;
    }

    if (cItems)
    {
        cItems--;
    }

    if (fNoScroll) 
    {
        //
        // Limit page to 0, posMax + 1
        //
        iPage = max(min((int)iPage, cItems + 1), 0);

        //
        // Limit pos to 0, posMax - (page - 1).
        //
        return max(min(iPos, cItems - ((iPage) ? (int)(iPage - 1) : 0)), 0);
    } 
    else 
    {
        si.fMask    = SIF_ALL;

        if (plb->fDisableNoScroll)
        {
            si.fMask |= SIF_DISABLENOSCROLL;
        }

        //
        // If the scrollbar is already where we want it, do nothing.
        //
        if (fCacheInitialized) 
        {
            if (psp->fMask == si.fMask &&
                    psp->cItems == cItems && psp->iPage == iPage &&
                    psp->iPos == iPos)
            {
                return psp->iReturn;
            }
        } 
        else if (nCtl == SB_VERT) 
        {
            plb->fVertInitialized = TRUE;
        } 
        else 
        {
            plb->fHorzInitialized = TRUE;
        }

        si.cbSize   = sizeof(SCROLLINFO);
        si.nMin     = 0;
        si.nMax     = cItems;
        si.nPage    = iPage;

        if (plb->fMultiColumn && plb->fRightAlign)
        {
            si.nPos =  (iPos+1) > (int)iPage ? iPos - iPage + 1 : 0;
        }
        else
        {
            si.nPos = iPos;
        }

        iReturn = SetScrollInfo(plb->hwnd, nCtl, &si, plb->fRedraw);

        if (plb->fMultiColumn && plb->fRightAlign)
        {
            iReturn = cItems - (iReturn + iPage - 1);
        }

        //
        // Update the position cache
        //
        psp->fMask = si.fMask;
        psp->cItems = cItems;
        psp->iPage = iPage;
        psp->iPos = iPos;
        psp->iReturn = iReturn;

        return iReturn;
    }
}


//---------------------------------------------------------------------------//
void ListBox_ShowHideScrollBars(PLBIV plb)
{
    BOOL fVertDone = FALSE;
    BOOL fHorzDone = FALSE;

    //
    // Don't do anything if there are no scrollbars or if parents
    // are invisible.
    //
    if ((!plb->fHorzBar && !plb->fVertBar) || !plb->fRedraw)
    {
        return;
    }

    //
    // Adjust iTop if necessary but DO NOT REDRAW PERIOD.  We never did
    // in 3.1.  There's a potential bug:
    //      If someone doesn't have redraw off and inserts an item in the
    // same position as the caret, we'll tell them to draw before they may
    // have called LB_SETITEMDATA for their item.  This is because we turn
    // the caret off & on inside of ListBox_NewITop(), even if the item isn't
    // changing.
    //      So we just want to reflect the position/scroll changes.
    // ListBox_CheckRedraw() will _really_ redraw the visual changes later if
    // redraw isn't off.
    //

    if (!plb->fFromInsert) 
    {
        ListBox_NewITop(plb, plb->iTop);
        fVertDone = TRUE;
    }

    if (!plb->fMultiColumn) 
    {
        if (!plb->fFromInsert) 
        {
            fHorzDone = TRUE;
            ListBox_HScroll(plb, SB_THUMBPOSITION, plb->xOrigin);
        }

        if (!fVertDone)
        {
            ListBox_SetScrollParms(plb, SB_VERT);
        }
    }

    if (!fHorzDone)
    {
        ListBox_SetScrollParms(plb, SB_HORZ);
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_GetItemDataHandler
//
// returns the long value associated with listbox items. -1 if error
//
LONG_PTR ListBox_GetItemDataHandler(PLBIV plb, INT sItem)
{
    LONG_PTR buffer;
    LPBYTE lpItem;

    if (sItem < 0 || sItem >= plb->cMac) 
    {
        TraceMsg(TF_STANDARD, "Invalid index");

        return LB_ERR;
    }

    //
    // No-data listboxes always return 0L
    //
    if (!plb->fHasData) 
    {
        return 0L;
    }

    lpItem = (plb->rgpch +
            (sItem * (plb->fHasStrings ? sizeof(LBItem) : sizeof(LBODItem))));
    buffer = (plb->fHasStrings ? ((lpLBItem)lpItem)->itemData : ((lpLBODItem)lpItem)->itemData);

    return buffer;
}


//---------------------------------------------------------------------------//
//
// ListBox_GetTextHandler
// 
// Copies the text associated with index to lpbuffer and returns its length.
// If fLengthOnly, just return the length of the text without doing a copy.
// 
// Waring: for size only querries lpbuffer is the count of ANSI characters
// 
// Returns count of chars
//
INT ListBox_GetTextHandler(PLBIV plb, BOOL fLengthOnly, BOOL fAnsi, INT index, LPWSTR lpbuffer)
{
    LPWSTR lpItemText;
    INT cchText;

    if (index < 0 || index >= plb->cMac) 
    {
        TraceMsg(TF_STANDARD, "Invalid index");
        return LB_ERR;
    }

    if (!plb->fHasStrings && plb->OwnerDraw) 
    {
        //
        // Owner draw without strings so we must copy the app supplied DWORD
        // value.
        //
        cchText = sizeof(ULONG_PTR);

        if (!fLengthOnly) 
        {
            LONG_PTR UNALIGNED *p = (LONG_PTR UNALIGNED *)lpbuffer;
            *p = ListBox_GetItemDataHandler(plb, index);
        }
    } 
    else 
    {
        lpItemText = GetLpszItem(plb, index);

        if (!lpItemText)
        {
            return LB_ERR;
        }

        //
        // These are strings so we are copying the text and we must include
        // the terminating 0 when doing the RtlMoveMemory.
        //
        cchText = wcslen(lpItemText);

        if (fLengthOnly) 
        {
            if (fAnsi)
            {
                UnicodeToMultiByteSize(&cchText, lpItemText, cchText*sizeof(WCHAR));
            }
        } 
        else 
        {
            if (fAnsi) 
            {

#ifdef FE_SB // ListBox_GetTextHandler()
                cchText = WCSToMB(lpItemText, cchText+1, &((LPSTR)lpbuffer), (cchText+1)*sizeof(WORD), FALSE);

                //
                // Here.. cchText contains null-terminate char, subtract it... Because, we pass cchText+1 to
                // above Unicode->Ansi convertsion to make sure the string is terminated with null.
                //
                cchText--;
#else
                WCSToMB(lpItemText, cchText+1, &((LPSTR)lpbuffer), cchText+1, FALSE);
#endif // FE_SB

            } 
            else 
            {
                CopyMemory(lpbuffer, lpItemText, (cchText+1)*sizeof(WCHAR));
            }
        }

    }

    return cchText;
}


//---------------------------------------------------------------------------//
BOOL ListBox_GromMem(PLBIV plb, INT numItems)

{
    LONG cb;
    HANDLE hMem;

    //
    // Allocate memory for pointers to the strings.
    //
    cb = (plb->cMax + numItems) *
            (plb->fHasStrings ? sizeof(LBItem)
                              : (plb->fHasData ? sizeof(LBODItem)
                                              : 0));

    //
    // If multiple selection list box (MULTIPLESEL or EXTENDEDSEL), then
    // allocate an extra byte per item to keep track of it's selection state.
    //
    if (plb->wMultiple != SINGLESEL) 
    {
        cb += (plb->cMax + numItems);
    }

    //
    // Extra bytes for each item so that we can store its height.
    //
    if (plb->OwnerDraw == OWNERDRAWVAR) 
    {
        cb += (plb->cMax + numItems);
    }

    //
    // Don't allocate more than 2G of memory
    //
    if (cb > MAXLONG)
    {
        return FALSE;
    }

    if (plb->rgpch == NULL) 
    {
        plb->rgpch = ControlAlloc(GetProcessHeap(), (LONG)cb);
        if ( plb->rgpch == NULL) 
        {
            return FALSE;
        }
    } 
    else 
    {
        hMem = ControlReAlloc(GetProcessHeap(), plb->rgpch, (LONG)cb);
        if ( hMem == NULL)
        {
            return FALSE;
        }

        plb->rgpch = hMem;
    }

    plb->cMax += numItems;

    return TRUE;
}


//---------------------------------------------------------------------------//
LONG ListBox_InitStorage(PLBIV plb, BOOL fAnsi, INT cItems, INT cb)
{
    HANDLE hMem;
    INT    cbChunk;

    //
    // if the app is talking ANSI, then adjust for the worst case in unicode
    // where each single ansi byte translates to one 16 bit unicode value
    //
    if (fAnsi) 
    {
        cb *= sizeof(WCHAR);
    }

    //
    // Fail if either of the parameters look bad.
    //
    if ((cItems < 0) || (cb < 0)) 
    {
        ListBox_NotifyOwner(plb, LBN_ERRSPACE);
        return LB_ERRSPACE;
    }

    //
    // try to grow the pointer array (if necessary) accounting for the free space
    // already available.
    //
    cItems -= plb->cMax - plb->cMac;
    if ((cItems > 0) && !ListBox_GromMem(plb, cItems)) 
    {
        ListBox_NotifyOwner(plb, LBN_ERRSPACE);
        return LB_ERRSPACE;
    }

    //
    // now grow the string space if necessary
    //
    if (plb->fHasStrings) 
    {
        cbChunk = (plb->ichAlloc + cb);
        if (cbChunk > plb->cchStrings) 
        {
            //
            // Round up to the nearest 256 byte chunk.
            //
            cbChunk = (cbChunk & ~0xff) + 0x100;

            hMem = ControlReAlloc(GetProcessHeap(), plb->hStrings, (LONG)cbChunk);
            if (!hMem) 
            {
                ListBox_NotifyOwner(plb, LBN_ERRSPACE);

                return LB_ERRSPACE;
            }

            plb->hStrings = hMem;
            plb->cchStrings = cbChunk;
        }
    }

    //
    // return the number of items that can be stored
    //
    return plb->cMax;
}


//---------------------------------------------------------------------------//
//
// ListBox_InsertItem
// 
// Insert an item at a specified position.
//
// For owner draw listboxes without LBS_HASSTRINGS style, lpsz 
// is a 4 byte value we will store for the app.
//
//
INT ListBox_InsertItem(PLBIV plb, LPWSTR lpsz, INT index, UINT wFlags)
{
    INT cbString;
    INT cbChunk;
    PBYTE lp;
    PBYTE lpT;
    PBYTE lpHeightStart;
    LONG cbItem;        // sizeof the Item in rgpch
    HANDLE hMem;
    HDC hdc;

    if (wFlags & LBI_ADD)
    {
        index = (plb->fSort) ? ListBox_BinarySearchString(plb, lpsz) : -1;
    }

    if (!plb->rgpch) 
    {
        if (index != 0 && index != -1) 
        {
            TraceMsg(TF_STANDARD, "Invalid index");

            return LB_ERR;
        }

        plb->iSel = -1;
        plb->iSelBase = 0;
        plb->cMax = 0;
        plb->cMac = 0;
        plb->iTop = 0;
        plb->rgpch = ControlAlloc(GetProcessHeap(), 0L); 

        if (!plb->rgpch)
        {
            return LB_ERR;
        }
    }

    if (index == -1) 
    {
        index = plb->cMac;
    }

    if (index > plb->cMac || plb->cMac >= MAXLONG) 
    {
        TraceMsg(TF_STANDARD, "Invalid index");
        return LB_ERR;
    }

    if (plb->fHasStrings) 
    {
        //
        // we must store the string in the hStrings memory block.
        //
        cbString = (wcslen(lpsz) + 1)*sizeof(WCHAR);

        cbChunk = (plb->ichAlloc + cbString);
        if ( cbChunk > plb->cchStrings) 
        {
            //
            // Round up to the nearest 256 byte chunk.
            //
            cbChunk = (cbChunk & ~0xff) + 0x100;

            hMem = ControlReAlloc(GetProcessHeap(), plb->hStrings, (LONG)cbChunk);
            if (!hMem) 
            {
                ListBox_NotifyOwner(plb, LBN_ERRSPACE);

                return LB_ERRSPACE;
            }

            plb->hStrings = hMem;
            plb->cchStrings = cbChunk;
        }

        //
        // Note difference between Win 95 code with placement of new string
        //
        if (wFlags & UPPERCASE)
        {
            CharUpperBuffW((LPWSTR)lpsz, cbString / sizeof(WCHAR));
        }
        else if (wFlags & LOWERCASE)
        {
            CharLowerBuffW((LPWSTR)lpsz, cbString / sizeof(WCHAR));
        }

        lp = (PBYTE)(plb->hStrings);

        MoveMemory(lp + plb->ichAlloc, lpsz, cbString);
    }

    //
    // Now expand the pointer array.
    //
    if (plb->cMac >= plb->cMax) 
    {
        if (!ListBox_GromMem(plb, CITEMSALLOC)) 
        {
            ListBox_NotifyOwner(plb, LBN_ERRSPACE);

            return LB_ERRSPACE;
        }
    }

    lpHeightStart = lpT = lp = plb->rgpch;

    //
    // Now calculate how much room we must make for the string pointer (lpsz).
    // If we are ownerdraw without LBS_HASSTRINGS, then a single DWORD
    // (LBODItem.itemData) stored for each item, but if we have strings with
    // each item then a LONG string offset (LBItem.offsz) is also stored.
    //
    cbItem = (plb->fHasStrings ? sizeof(LBItem)
                               : (plb->fHasData ? sizeof(LBODItem):0));
    cbChunk = (plb->cMac - index) * cbItem;

    if (plb->wMultiple != SINGLESEL) 
    {
        //
        // Extra bytes were allocated for selection flag for each item
        //
        cbChunk += plb->cMac;
    }

    if (plb->OwnerDraw == OWNERDRAWVAR) 
    {
        //
        // Extra bytes were allocated for each item's height
        //
        cbChunk += plb->cMac;
    }

    //
    // First, make room for the 2 byte pointer to the string or the 4 byte app
    // supplied value.
    //
    lpT += (index * cbItem);
    MoveMemory(lpT + cbItem, lpT, cbChunk);
    if (!plb->fHasStrings && plb->OwnerDraw) 
    {
        if (plb->fHasData) 
        {
            //
            // Ownerdraw so just save the DWORD value
            //
            lpLBODItem p = (lpLBODItem)lpT;
            p->itemData = (ULONG_PTR)lpsz;
        }
    } 
    else 
    {
        lpLBItem p = ((lpLBItem)lpT);

        //
        // Save the start of the string.  Let the item data field be 0
        //
        p->offsz = (LONG)(plb->ichAlloc);
        p->itemData = 0;
        plb->ichAlloc += cbString;
    }

    //
    // Now if Multiple Selection lbox, we have to insert a selection status
    // byte.  If var height ownerdraw, then we also have to move up the height
    // bytes.
    //
    if (plb->wMultiple != SINGLESEL) 
    {
        lpT = lp + ((plb->cMac + 1) * cbItem) + index;
        MoveMemory(lpT + 1, lpT, plb->cMac - index +
                (plb->OwnerDraw == OWNERDRAWVAR ? plb->cMac : 0));

        *lpT = 0;   // fSelected = FALSE
    }

    //
    // Increment count of items in the listbox now before we send a message to
    // the app.
    //
    plb->cMac++;

    //
    // If varheight ownerdraw, we much insert an extra byte for the item's
    // height.
    //
    if (plb->OwnerDraw == OWNERDRAWVAR) 
    {
        MEASUREITEMSTRUCT measureItemStruct;

        //
        // Variable height owner draw so we need to get the height of each item.
        //
        lpHeightStart += (plb->cMac * cbItem) + index +
                (plb->wMultiple ? plb->cMac : 0);

        MoveMemory(lpHeightStart + 1, lpHeightStart, plb->cMac - 1 - index);

        //
        // Query for item height only if we are var height owner draw.
        //
        measureItemStruct.CtlType = ODT_LISTBOX;
        measureItemStruct.CtlID = GetDlgCtrlID(plb->hwnd);
        measureItemStruct.itemID = index;

        //
        // System font height is default height
        //
        measureItemStruct.itemHeight = SYSFONT_CYCHAR;

        hdc = GetDC(plb->hwnd);
        if (hdc)
        {
            SIZE size = {0};
            GetCharDimensions(hdc, &size);
            ReleaseDC(plb->hwnd, hdc);

            if(size.cy)
            {
                measureItemStruct.itemHeight = (UINT)size.cy;
            }
            else
            {
                ASSERT(0);//GetCharDimensions
            }
        }

        measureItemStruct.itemData = (ULONG_PTR)lpsz;

        //
        // If "has strings" then add the special thunk bit so the client data
        // will be thunked to a client side address.  LB_DIR sends a string
        // even if the listbox is not HASSTRINGS so we need to special
        // thunk this case.  HP Dashboard for windows send LB_DIR to a non
        // HASSTRINGS listbox needs the server string converted to client.
        // WOW needs to know about this situation as well so we mark the
        // previously uninitialized itemWidth as FLAT.
        //

        SendMessage(plb->hwndParent,
                WM_MEASUREITEM,
                measureItemStruct.CtlID,
                (LPARAM)&measureItemStruct);

        *lpHeightStart = (BYTE)measureItemStruct.itemHeight;
    }


    //
    // If the item was inserted above the current selection then move
    // the selection down one as well.
    //
    if ((plb->wMultiple == SINGLESEL) && (plb->iSel >= index))
    {
        plb->iSel++;
    }

    if (plb->OwnerDraw == OWNERDRAWVAR)
    {
        ListBox_SetCItemFullMax(plb);
    }

    //
    // Check if scroll bars need to be shown/hidden
    //
    plb->fFromInsert = TRUE;
    ListBox_ShowHideScrollBars(plb);

    if (plb->fHorzBar && plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw)) 
    {
        //
        // origin to right
        //
        ListBox_HScroll(plb, SB_BOTTOM, 0);
    }

    plb->fFromInsert = FALSE;

    ListBox_CheckRedraw(plb, TRUE, index);

    ListBox_Event(plb, EVENT_OBJECT_CREATE, index);

    return index;
}


//---------------------------------------------------------------------------//
//
// ListBox_lstrcmpi
//
// This is a version of lstrcmpi() specifically used for listboxes
// This gives more weight to '[' characters than alpha-numerics;
// The US version of lstrcmpi() and lstrcmp() are similar as far as
// non-alphanumerals are concerned; All non-alphanumerals get sorted
// before alphanumerals; This means that subdirectory strings that start
// with '[' will get sorted before; But we don't want that; So, this
// function takes care of it;
//
INT ListBox_lstrcmpi(LPWSTR lpStr1, LPWSTR lpStr2, DWORD dwLocaleId)
{

    //
    // NOTE: This function is written so as to reduce the number of calls
    // made to the costly IsCharAlphaNumeric() function because that might
    // load a language module; It 'traps' the most frequently occurring cases
    // like both strings starting with '[' or both strings NOT starting with '['
    // first and only in abosolutely necessary cases calls IsCharAlphaNumeric();
    //
    if (*lpStr1 == TEXT('[')) 
    {
        if (*lpStr2 == TEXT('[')) 
        {
            goto LBL_End;
        }

        if (IsCharAlphaNumeric(*lpStr2)) 
        {
            return 1;
        }
    }

    if ((*lpStr2 == TEXT('[')) && IsCharAlphaNumeric(*lpStr1)) 
    {
        return -1;
    }

LBL_End:
    return (INT)CompareStringW((LCID)dwLocaleId, NORM_IGNORECASE,
            lpStr1, -1, lpStr2, -1 ) - 2;
}


//---------------------------------------------------------------------------//
//
// ListBox_BinarySearchString
//
// Does a binary search of the items in the SORTED listbox to find
// out where this item should be inserted.  Handles both HasStrings and item
// long WM_COMPAREITEM cases.
//
INT ListBox_BinarySearchString(PLBIV plb, LPWSTR lpstr) 
{
    BYTE **lprgpch;
    INT sortResult;
    COMPAREITEMSTRUCT cis;
    LPWSTR pszLBBase;
    LPWSTR pszLB;
    INT itemhigh;
    INT itemnew = 0;
    INT itemlow = 0;


    if (!plb->cMac)
    {
        return 0;
    }

    lprgpch = (BYTE **)(plb->rgpch);
    if (plb->fHasStrings) 
    {
        pszLBBase = plb->hStrings;
    }

    itemhigh = plb->cMac - 1;
    while (itemlow <= itemhigh) 
    {
        itemnew = (itemhigh + itemlow) / 2;

        if (plb->fHasStrings) 
        {

            //
            // Searching for string matches.
            //
            pszLB = (LPWSTR)((LPSTR)pszLBBase + ((lpLBItem)lprgpch)[itemnew].offsz);
            sortResult = ListBox_lstrcmpi(pszLB, lpstr, plb->dwLocaleId);
        } 
        else 
        {
            //
            // Send compare item messages to the parent for sorting
            //
            cis.CtlType = ODT_LISTBOX;
            cis.CtlID = GetDlgCtrlID(plb->hwnd);
            cis.hwndItem = plb->hwnd;
            cis.itemID1 = itemnew;
            cis.itemData1 = ((lpLBODItem)lprgpch)[itemnew].itemData;
            cis.itemID2 = (UINT)-1;
            cis.itemData2 = (ULONG_PTR)lpstr;
            cis.dwLocaleId = plb->dwLocaleId;
            sortResult = (INT)SendMessage(plb->hwndParent, WM_COMPAREITEM,
                    cis.CtlID, (LPARAM)&cis);
        }

        if (sortResult < 0) 
        {
            itemlow = itemnew + 1;
        } 
        else if (sortResult > 0) 
        {
            itemhigh = itemnew - 1;
        } 
        else 
        {
            itemlow = itemnew;
            goto FoundIt;
        }
    }

FoundIt:

    return max(0, itemlow);
}


//---------------------------------------------------------------------------//
BOOL ListBox_ResetContentHandler(PLBIV plb)
{
    if (!plb->cMac)
    {
        return TRUE;
    }

    ListBox_DoDeleteItems(plb);

    if (plb->rgpch != NULL) 
    {
        ControlFree(GetProcessHeap(), plb->rgpch);
        plb->rgpch = NULL;
    }

    if (plb->hStrings != NULL) 
    {
        ControlFree(GetProcessHeap(), plb->hStrings);
        plb->hStrings = NULL;
    }

    ListBox_InitHStrings(plb);

    if (TESTFLAG(GET_STATE2(plb), WS_S2_WIN31COMPAT))
    {
        ListBox_CheckRedraw(plb, FALSE, 0);
    }
    else if (IsWindowVisible(plb->hwnd))
    {
        InvalidateRect(plb->hwnd, NULL, TRUE);
    }

    plb->iSelBase =  0;
    plb->iTop =  0;
    plb->cMac =  0;
    plb->cMax =  0;
    plb->xOrigin =  0;
    plb->iLastSelection =  0;
    plb->iSel = -1;

    ListBox_ShowHideScrollBars(plb);

    return TRUE;
}


//---------------------------------------------------------------------------//
INT ListBox_DeleteStringHandler(PLBIV plb, INT sItem)
{
    LONG cb;
    LPBYTE lp;
    LPBYTE lpT;
    RECT rc;
    int cbItem;
    LPWSTR lpString;
    PBYTE pbStrings;
    INT cbStringLen;
    LPBYTE itemNumbers;
    INT sTmp;

    if (sItem < 0 || sItem >= plb->cMac) 
    {
        TraceMsg(TF_STANDARD, "Invalid index");

        return LB_ERR;
    }

    ListBox_Event(plb, EVENT_OBJECT_DESTROY, sItem);

    if (plb->cMac == 1) 
    {
        //
        // When the item count is 0, we send a resetcontent message so that we
        // can reclaim our string space this way.
        //
        SendMessageW(plb->hwnd, LB_RESETCONTENT, 0, 0);

        goto FinishUpDelete;
    }

    //
    // Get the rectangle associated with the last item in the listbox.  If it is
    // visible, we need to invalidate it.  When we delete an item, everything
    // scrolls up to replace the item deleted so we must make sure we erase the
    // old image of the last item in the listbox.
    //
    if (ListBox_GetItemRectHandler(plb, (INT)(plb->cMac - 1), &rc)) 
    {
        ListBox_InvalidateRect(plb, &rc, TRUE);
    }

    //
    // 3.1 and earlier used to only send WM_DELETEITEMs if it was an ownerdraw
    // listbox.  4.0 and above will send WM_DELETEITEMs for every item that has
    // nonzero item data.
    //
    if (TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT) || (plb->OwnerDraw && plb->fHasData)) 
    {
        ListBox_DeleteItem(plb, sItem);
    }

    plb->cMac--;

    cbItem = (plb->fHasStrings ? sizeof(LBItem)
                               : (plb->fHasData ? sizeof(LBODItem): 0));
    cb = ((plb->cMac - sItem) * cbItem);

    //
    // Byte for the selection status of the item.
    //
    if (plb->wMultiple != SINGLESEL) 
    {
        cb += (plb->cMac + 1);
    }

    if (plb->OwnerDraw == OWNERDRAWVAR) 
    {
        //
        // One byte for the height of the item.
        //
        cb += (plb->cMac + 1);
    }

    //
    // Might be nodata and singlesel, for instance.
    // but what out for the case where cItem == cMac (and cb == 0).
    //
    if ((cb != 0) || plb->fHasStrings) 
    {
        lp = plb->rgpch;

        lpT = (lp + (sItem * cbItem));

        if (plb->fHasStrings) 
        {
            //
            // If we has strings with each item, then we want to compact the string
            // heap so that we can recover the space occupied by the string of the
            // deleted item.
            //
             
            //
            // Get the string which we will be deleting
            //
            pbStrings = (PBYTE)(plb->hStrings);
            lpString = (LPTSTR)(pbStrings + ((lpLBItem)lpT)->offsz);
            cbStringLen = (wcslen(lpString) + 1) * sizeof(WCHAR);

            //
            // Now compact the string array
            //
            plb->ichAlloc = plb->ichAlloc - cbStringLen;

            MoveMemory(lpString, (PBYTE)lpString + cbStringLen,
                    plb->ichAlloc + (pbStrings - (LPBYTE)lpString));

            //
            // We have to update the string pointers in plb->rgpch since all the
            // string after the deleted string have been moved down stringLength
            // bytes.  Note that we have to explicitly check all items in the list
            // box if the string was allocated after the deleted item since the
            // LB_SORT style allows a lower item number to have a string allocated
            // at the end of the string heap for example.
            //
            itemNumbers = lp;
            for (sTmp = 0; sTmp <= plb->cMac; sTmp++) 
            {
                lpLBItem p =(lpLBItem)itemNumbers;
                if ( (LPTSTR)(p->offsz + pbStrings) > lpString ) 
                {
                    p->offsz -= cbStringLen;
                }

                p++;
                itemNumbers=(LPBYTE)p;
            }
        }

        //
        // Now compact the pointers to the strings (or the long app supplied values
        // if ownerdraw without strings).
        //
        MoveMemory(lpT, lpT + cbItem, cb);

        //
        // Compress the multiselection bytes
        //
        if (plb->wMultiple != SINGLESEL) 
        {
            lpT = (lp + (plb->cMac * cbItem) + sItem);
            MoveMemory(lpT, lpT + 1, plb->cMac - sItem +
                    (plb->OwnerDraw == OWNERDRAWVAR ? plb->cMac + 1 : 0));
        }

        if (plb->OwnerDraw == OWNERDRAWVAR) 
        {
            //
            // Compress the height bytes
            //
            lpT = (lp + (plb->cMac * cbItem) + (plb->wMultiple ? plb->cMac : 0)
                    + sItem);
            MoveMemory(lpT, lpT + 1, plb->cMac - sItem);
        }

    }

    if (plb->wMultiple == SINGLESEL) 
    {
        if (plb->iSel == sItem) 
        {
            plb->iSel = -1;

            if (plb->pcbox != NULL) 
            {
                ComboBox_InternalUpdateEditWindow(plb->pcbox, NULL);
            }
        } 
        else if (plb->iSel > sItem)
        {
            plb->iSel--;
        }
    }

    if ((plb->iMouseDown != -1) && (sItem <= plb->iMouseDown))
    {
        plb->iMouseDown = -1;
    }

    if (plb->iSelBase && sItem == plb->iSelBase)
    {
        plb->iSelBase--;
    }

    if (plb->cMac) 
    {
        plb->iSelBase = min(plb->iSelBase, plb->cMac - 1);
    } 
    else 
    {
        plb->iSelBase = 0;
    }

    if ((plb->wMultiple == EXTENDEDSEL) && (plb->iSel == -1))
    {
        plb->iSel = plb->iSelBase;
    }

    if (plb->OwnerDraw == OWNERDRAWVAR)
    {
        ListBox_SetCItemFullMax(plb);
    }

    //
    // We always set a new iTop.  The iTop won't change if it doesn't need to
    // but it will change if:  1.  The iTop was deleted or 2.  We need to change
    // the iTop so that we fill the listbox.
    //
    ListBox_InsureVisible(plb, plb->iTop, FALSE);

FinishUpDelete:

    //
    // Check if scroll bars need to be shown/hidden
    //
    plb->fFromInsert = TRUE;
    ListBox_ShowHideScrollBars(plb);
    plb->fFromInsert = FALSE;

    ListBox_CheckRedraw(plb, TRUE, sItem);
    ListBox_InsureVisible(plb, plb->iSelBase, FALSE);

    return plb->cMac;
}


//---------------------------------------------------------------------------//
//
// ListBox_DeleteItem
//
// Sends a WM_DELETEITEM message to the owner of an ownerdraw listbox
//
void ListBox_DeleteItem(PLBIV plb, INT sItem)
{
    DELETEITEMSTRUCT dis;
    HWND hwndParent;

    if (plb->hwnd == NULL)
    {
        return;
    }    

    hwndParent = plb->hwndParent;

    //
    // No need to send message if no data!
    //
    if (!plb->fHasData) 
    {
        return;
    }

    //
    // Fill the DELETEITEMSTRUCT
    //
    dis.CtlType = ODT_LISTBOX;
    dis.CtlID = GetDlgCtrlID(plb->hwnd);
    dis.itemID = sItem;
    dis.hwndItem = plb->hwnd;

    //
    // Bug 262122 - joejo
    // Fixed in 93 so that ItemData was passed. For some reason, not
    // merged in.
    //
    dis.itemData = ListBox_GetItemDataHandler(plb, sItem);

    if (hwndParent != NULL) 
    {
        SendMessage(hwndParent, WM_DELETEITEM, dis.CtlID, (LPARAM)&dis);
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_CalcAllocNeeded
//
// Calculate the number of bytes needed in rgpch to accommodate a given
// number of items.
//
UINT ListBox_CalcAllocNeeded(PLBIV plb, INT cItems)
{
    UINT cb;

    //
    // Allocate memory for pointers to the strings.
    //
    cb = cItems * (plb->fHasStrings ? sizeof(LBItem)
                                    : (plb->fHasData ? sizeof(LBODItem)
                                                    : 0));

    //
    // If multiple selection list box (MULTIPLESEL or EXTENDEDSEL), then
    // allocate an extra byte per item to keep track of it's selection state.
    //
    if (plb->wMultiple != SINGLESEL) 
    {
        cb += cItems;
    }

    //
    // Extra bytes for each item so that we can store its height.
    //
    if (plb->OwnerDraw == OWNERDRAWVAR) 
    {
        cb += cItems;
    }

    return cb;
}


//---------------------------------------------------------------------------//
//
// ListBox_SetCount
//
// Sets the number of items in a lazy-eval (fNoData) listbox.
//
// Calling SetCount scorches any existing selection state.  To preserve
// selection state, call Insert/DeleteItem instead.
//
INT ListBox_SetCount(PLBIV plb, INT cItems)
{
    UINT cbRequired;
    BOOL fRedraw;

    //
    // SetCount is only valid on lazy-eval ("nodata") listboxes.
    // All other lboxen must add their items one at a time, although
    // they may SetCount(0) via RESETCONTENT.
    //
    if (plb->fHasStrings || plb->fHasData) 
    {
        return LB_ERR;
    }

    if (cItems == 0) 
    {
        SendMessage(plb->hwnd, LB_RESETCONTENT, 0, 0);

        return 0;
    }

    //
    // If redraw isn't turned off, turn it off now
    //
    if (fRedraw = plb->fRedraw)
    {
        ListBox_SetRedraw(plb, FALSE);
    }

    cbRequired = ListBox_CalcAllocNeeded(plb, cItems);

    //
    // Reset selection and position
    //
    plb->iSelBase = 0;
    plb->iTop = 0;
    plb->cMax = 0;
    plb->xOrigin = 0;
    plb->iLastSelection = 0;
    plb->iSel = -1;

    if (cbRequired != 0) 
    { 
        //
        // Only if record instance data required
        //

        //
        // If listbox was previously empty, prepare for the
        // realloc-based alloc strategy ahead.
        //
        if (plb->rgpch == NULL) 
        {
            plb->rgpch = ControlAlloc(GetProcessHeap(), 0L); 
            plb->cMax = 0;

            if (plb->rgpch == NULL) 
            {
                ListBox_NotifyOwner(plb, LBN_ERRSPACE);

                return LB_ERRSPACE;
            }
        }

        //
        // rgpch might not have enough room for the new record instance
        // data, so check and realloc as necessary.
        //
        if (cItems >= plb->cMax) 
        {
            INT    cMaxNew;
            UINT   cbNew;
            HANDLE hmemNew;

            //
            // Since ListBox_GromMem presumes a one-item-at-a-time add schema,
            // SetCount can't use it.  Too bad.
            //
            cMaxNew = cItems+CITEMSALLOC;
            cbNew = ListBox_CalcAllocNeeded(plb, cMaxNew);
            hmemNew = ControlReAlloc(GetProcessHeap(), plb->rgpch, cbNew);

            if (hmemNew == NULL) 
            {
                ListBox_NotifyOwner(plb, LBN_ERRSPACE);

                return LB_ERRSPACE;
            }

            plb->rgpch = hmemNew;
            plb->cMax = cMaxNew;
        }

        //
        // Reset the item instance data (multisel annotations)
        //
        ZeroMemory(plb->rgpch, cbRequired);
    }

    plb->cMac = cItems;

    //
    // Turn redraw back on
    //
    if (fRedraw)
    {
        ListBox_SetRedraw(plb, TRUE);
    }

    ListBox_InvalidateRect(plb, NULL, TRUE);
    ListBox_ShowHideScrollBars(plb); // takes care of fRedraw

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\listbox_ctl2.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include <limits.h>
#include "usrctl32.h"
#include "listbox.h"


//---------------------------------------------------------------------------//
//
//  Defines and common macros
//

#define LB_KEYDOWN  WM_USER+1

#define NOMODIFIER  0                       // No modifier is down
#define SHIFTDOWN   1                       // Shift alone
#define CTLDOWN     2                       // Ctl alone
#define SHCTLDOWN   (SHIFTDOWN + CTLDOWN)   // Ctrl + Shift

//
// Variables for incremental type search support
//
#define MAX_TYPESEARCH  256

//
// LATER IanJa: these vary by country!  For US they are VK_OEM_2 VK_OEM_5.
//       Change lboxctl2.c MapVirtualKey to character - and fix the spelling?
//
#define VERKEY_SLASH        0xBF    // Vertual key for '/' character
#define VERKEY_BACKSLASH    0xDC    // Vertual key for '\' character


//---------------------------------------------------------------------------//
//
// Forwards
//
VOID ListBox_NewITopEx(PLBIV, INT, DWORD);
VOID ListBox_FillDrawItem(PLBIV, INT, UINT, UINT, LPRECT);
VOID ListBox_BlockHilite(PLBIV, INT, BOOL);
VOID ListBox_AlterHilite(PLBIV, INT, INT, BOOL, INT, BOOL);


//---------------------------------------------------------------------------//
//
// ListBox_TermDC
//
// Cleans up when done with listbox dc.
//
__inline void ListBox_TermDC(PLBIV plb)
{
    if (plb->hFont)
    {
        SelectObject(plb->hdc, GetStockObject(SYSTEM_FONT));
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_InitDC
//
// Initializes dc for listbox
//
void ListBox_InitDC(PLBIV plb)
{
    RECT rc;

    //
    // Set font
    //
    if (plb->hFont)
    {
        SelectObject(plb->hdc, plb->hFont);
    }

    //
    // Set clipping area
    //
    GetClientRect(plb->hwnd, &rc);
    IntersectClipRect(plb->hdc, rc.left, rc.top, rc.right, rc.bottom);

    OffsetWindowOrgEx(plb->hdc, plb->xOrigin, 0, NULL);
}


//---------------------------------------------------------------------------//
//
// ListBox_GetDC
//
// Returns a DC which can be used by a list box even if parentDC is in effect
//
BOOL ListBox_GetDC(PLBIV plb)
{
    if (plb->hdc)
    {
        return FALSE;
    }

    plb->hdc = GetDC(plb->hwnd);

    ListBox_InitDC(plb);

    return TRUE;
}


//---------------------------------------------------------------------------//
void ListBox_ReleaseDC(PLBIV plb)
{
    ListBox_TermDC(plb);
    ReleaseDC(plb->hwnd, plb->hdc);
    plb->hdc = NULL;
}


//---------------------------------------------------------------------------//
//
// ListBox_InvalidateRect()
//
// If the listbox is visible, invalidates a rectangle in the listbox.
// If the listbox is not visible, sets the defer update flag for the listbox
//
BOOL ListBox_InvalidateRect(PLBIV plb, LPRECT lprc, BOOL fErase)
{
    if (IsLBoxVisible(plb)) 
    {
        InvalidateRect(plb->hwnd, lprc, fErase);

        return TRUE;
    }

    if (!plb->fRedraw)
    {
        plb->fDeferUpdate = TRUE;
    }

    return FALSE;
}


//---------------------------------------------------------------------------//
//
// ListBox_GetBrush
//
// Gets background brush & colors for listbox.
//
HBRUSH ListBox_GetBrush(PLBIV plb, HBRUSH *phbrOld)
{
    HBRUSH  hbr;
    HBRUSH  hbrOld;
    HWND hwndParent = plb->hwndParent;

    SetBkMode(plb->hdc, OPAQUE);

    //
    // Get brush & colors
    //

    // copied from windows\core\ntuser\kernel\random.c
    if (hwndParent == NULL || hwndParent == GetDesktopWindow()) 
    {
        hbr = (HBRUSH)SendMessage(plb->hwnd, WM_CTLCOLORLISTBOX, (WPARAM)plb->hdc, (LPARAM)plb->hwnd);
    } 
    else
    {
        hbr = (HBRUSH)SendMessage(hwndParent, WM_CTLCOLORLISTBOX, (WPARAM)plb->hdc, (LPARAM)plb->hwnd);
    }

    ASSERT(hbr != 0);

    //
    // Select brush into dc
    //
    if (hbr != NULL) 
    {
        hbrOld = SelectObject(plb->hdc, hbr);
        if (phbrOld)
        {
            *phbrOld = hbrOld;
        }
    }

    return hbr;
}


//---------------------------------------------------------------------------//
//
// ListBox_GetItemRectHandler
//
// Return the rectangle that the item will be drawn in with respect to the
// listbox window.  Returns TRUE if any portion of the item's rectangle
// is visible (ie. in the listbox client rect) else returns FALSE.
//
BOOL ListBox_GetItemRectHandler(PLBIV plb, INT sItem, LPRECT lprc)
{
    INT sTmp;
    int clientbottom;

    //
    // Always allow an item number of 0 so that we can draw the caret which
    // indicates the listbox has the focus even though it is empty.
    //
    // FreeHand 3.1 passes in -1 as the itemNumber and expects
    // a non-null rectangle. So we check for -1 specifically.
    // BUGTAG: Fix for Bug #540 --Win95B-- SANKAR -- 2/20/95 --
    //

    if (sItem && (sItem != -1) && ((UINT)sItem >= (UINT)plb->cMac))
    {
        SetRectEmpty(lprc);
        TraceMsg(TF_STANDARD, "Invalid index");

        return LB_ERR;
    }

    GetClientRect(plb->hwnd, lprc);

    if (plb->fMultiColumn) 
    {
        //
        // itemHeight * sItem mod number ItemsPerColumn (itemsPerColumn)
        //
        lprc->top = plb->cyChar * (sItem % plb->itemsPerColumn);
        lprc->bottom = lprc->top + plb->cyChar;  //+(plb->OwnerDraw ? 0 : 1);

        ASSERT(plb->itemsPerColumn);

        if (plb->fRightAlign) 
        {
            lprc->right = lprc->right - plb->cxColumn *
                 ((sItem / plb->itemsPerColumn) - (plb->iTop / plb->itemsPerColumn));

            lprc->left = lprc->right - plb->cxColumn;
        } 
        else 
        {
            //
            // Remember, this is integer division here...
            //
            lprc->left += plb->cxColumn *
                      ((sItem / plb->itemsPerColumn) - (plb->iTop / plb->itemsPerColumn));

            lprc->right = lprc->left + plb->cxColumn;
        }
    } 
    else if (plb->OwnerDraw == OWNERDRAWVAR) 
    {
        //
        // Var height owner draw
        //
        lprc->right += plb->xOrigin;
        clientbottom = lprc->bottom;

        if (sItem >= plb->iTop) 
        {
            for (sTmp = plb->iTop; sTmp < sItem; sTmp++) 
            {
                lprc->top = lprc->top + ListBox_GetVarHeightItemHeight(plb, sTmp);
            }

            //
            // If item number is 0, it may be we are asking for the rect
            // associated with a nonexistant item so that we can draw a caret
            // indicating focus on an empty listbox.
            //
            lprc->bottom = lprc->top + (sItem < plb->cMac ? ListBox_GetVarHeightItemHeight(plb, sItem) : plb->cyChar);

            return (lprc->top < clientbottom);
        } 
        else 
        {
            //
            // Item we want the rect of is before plb->iTop.  Thus, negative
            // offsets for the rect and it is never visible.
            //
            for (sTmp = sItem; sTmp < plb->iTop; sTmp++) 
            {
                lprc->top = lprc->top - ListBox_GetVarHeightItemHeight(plb, sTmp);
            }

            lprc->bottom = lprc->top + ListBox_GetVarHeightItemHeight(plb, sItem);

            return FALSE;
        }
    } 
    else 
    {
        //
        // For fixed height listboxes
        //
        if (plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw) && plb->fHorzBar)
            lprc->right += plb->xOrigin + (plb->xRightOrigin - plb->xOrigin);
        else
            lprc->right += plb->xOrigin;
        lprc->top = (sItem - plb->iTop) * plb->cyChar;
        lprc->bottom = lprc->top + plb->cyChar;
    }

    return (sItem >= plb->iTop) &&
            (sItem < (plb->iTop + ListBox_CItemInWindow(plb, TRUE)));
}


//---------------------------------------------------------------------------//
//
// ListBox_PrintCallback
//
// Called back from DrawState
//
BOOL CALLBACK ListBox_PrintCallback(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy)
{
    LPWSTR  lpstr = (LPWSTR)lData;
    PLBIV   plb = (PLBIV)wData;
    int     xStart;
    UINT    cLen;
    RECT    rc;
    UINT    oldAlign;

    if (!lpstr) 
    {
        return FALSE;
    }

    xStart = plb->fMultiColumn ? 0 : 2;

    if (plb->fRightAlign) 
    {
        oldAlign = SetTextAlign(hdc, TA_RIGHT | GetTextAlign(hdc));
        xStart = cx - xStart;
    }

    cLen = wcslen(lpstr);

    if (plb->fUseTabStops) 
    {
        TabbedTextOut(hdc, xStart, 0, lpstr, cLen,
            (plb->iTabPixelPositions ? plb->iTabPixelPositions[0] : 0),
            (plb->iTabPixelPositions ? (LPINT)&plb->iTabPixelPositions[1] : NULL),
            plb->fRightAlign ? cx : 0); //, TRUE, GetTextCharset(plb->hdc));
    } 
    else 
    {
        rc.left     = 0;
        rc.top      = 0;
        rc.right    = cx;
        rc.bottom   = cy;

        if (plb->wMultiple)
        {
            ExtTextOut(hdc, xStart, 0, ETO_OPAQUE, &rc, lpstr, cLen, NULL);
        }
        else if (plb->fMultiColumn)
        {
            ExtTextOut(hdc, xStart, 0, ETO_CLIPPED, &rc, lpstr, cLen, NULL);
        }
        else 
        {
            ExtTextOut(hdc, xStart, 0, 0, NULL, lpstr, cLen, NULL);

            //
            // When the listbox is in the incremental search mode and the item
            // is highlighted (so we only draw in the current item), draw the
            // caret for search indication.
            //
            if ((plb->iTypeSearch != 0) && (plb->OwnerDraw == 0) &&
                    (GetBkColor(hdc) == SYSRGB(HIGHLIGHT))) 
            {
                SIZE size;
                GetTextExtentPointW(hdc, lpstr, plb->iTypeSearch, &size);
                PatBlt(hdc, xStart + size.cx - 1, 1, 1, cy - 2, DSTINVERT);
            }
        }
    }

    if (plb->fRightAlign)
    {
        SetTextAlign(hdc, oldAlign);
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
void ListBox_DrawItem(PLBIV plb, INT sItem, LPRECT lprect, BOOL fHilite, HBRUSH hbr)
{
    LPWSTR lpstr;
    DWORD rgbSave;
    DWORD rgbBkSave;
    UINT    uFlags;
    HDC     hdc = plb->hdc;
    UINT  oldAlign;
    HBRUSH hNewBrush;


    //
    // If the item is selected, then fill with highlight color
    //
    if (fHilite) 
    {
        FillRectClr(hdc, lprect, SYSRGB(HIGHLIGHT));
        
        rgbBkSave = SetBkColor(hdc, SYSRGB(HIGHLIGHT));
        rgbSave = SetTextColor(hdc, SYSRGB(HIGHLIGHTTEXT));
    } 
    else 
    {
        //
        // If fUseTabStops, we must fill the background, because later we use
        // LBTabTheTextOutForWimps(), which fills the background only partially
        // Fix for Bug #1509 -- 01/25/91 -- SANKAR --
        //
        if ((hbr != NULL) && ((sItem == plb->iSelBase) || (plb->fUseTabStops))) 
        {
            FillRect(hdc, lprect, hbr);
        }
    }

    uFlags = DST_COMPLEX;
    lpstr = GetLpszItem(plb, sItem);

    if (TESTFLAG(GET_STYLE(plb), WS_DISABLED)) 
    {
        if ((COLORREF)SYSRGB(GRAYTEXT) != GetBkColor(hdc))
        {
            SetTextColor(hdc, SYSRGB(GRAYTEXT));
        }
        else
        {
            uFlags |= DSS_UNION;
        }
    }

    if (plb->fRightAlign)
    {
        uFlags |= DSS_RIGHT;
    }

    if (plb->fRtoLReading)
    {
        oldAlign = SetTextAlign(hdc, TA_RTLREADING | GetTextAlign(hdc));
    }

    hNewBrush = CreateSolidBrush(SYSRGB(WINDOWTEXT));

    DrawState(hdc, hNewBrush,
        ListBox_PrintCallback,
        (LPARAM)lpstr,
        (WPARAM)plb,
        lprect->left,
        lprect->top,
        lprect->right-lprect->left,
        lprect->bottom-lprect->top,
        uFlags);

    if (hNewBrush)
    {
        DeleteObject(hNewBrush);
    }

    if (plb->fRtoLReading)
    {
        SetTextAlign(hdc, oldAlign);
    }

    if (fHilite) 
    {
        SetTextColor(hdc, rgbSave);
        SetBkColor(hdc, rgbBkSave);
    }
}


//---------------------------------------------------------------------------//
void ListBox_SetCaret(PLBIV plb, BOOL fSetCaret)
{
    RECT    rc;
    BOOL    fNewDC;

    if (plb->fCaret && ((BOOL) plb->fCaretOn != !!fSetCaret)) 
    {
        if (IsLBoxVisible(plb)) 
        {
            //
            // Turn the caret (located at plb->iSelBase) on
            //
            fNewDC = ListBox_GetDC(plb);

            ListBox_GetItemRectHandler(plb, plb->iSelBase, &rc);

            if (fNewDC) 
            {
                SetBkColor(plb->hdc, SYSRGB(WINDOW));
                SetTextColor(plb->hdc, SYSRGB(WINDOWTEXT));
            }

            if (plb->OwnerDraw) 
            {
                //
                // Fill in the drawitem struct
                //
                UINT itemState = (fSetCaret) ? ODS_FOCUS : 0;

                if (ListBox_IsSelected(plb, plb->iSelBase, HILITEONLY))
                {
                    itemState |= ODS_SELECTED;
                }

                ListBox_FillDrawItem(plb, plb->iSelBase, ODA_FOCUS, itemState, &rc);
            } 
            else if (!TESTFLAG(GET_EXSTYLE(plb), WS_EXP_UIFOCUSHIDDEN)) 
            {
                COLORREF crBk = SetBkColor(plb->hdc, SYSRGB(WINDOW));
                COLORREF crText = SetTextColor(plb->hdc, SYSRGB(WINDOWTEXT));

                DrawFocusRect(plb->hdc, &rc);

                SetBkColor(plb->hdc, crBk);
                SetTextColor(plb->hdc, crText);
            }

            if (fNewDC)
            {
                ListBox_ReleaseDC(plb);
            }
        }

        plb->fCaretOn = !!fSetCaret;
    }
}


//---------------------------------------------------------------------------//
BOOL ListBox_IsSelected(PLBIV plb, INT sItem, UINT wOpFlags)
{
    LPBYTE lp;

    if ((sItem >= plb->cMac) || (sItem < 0)) 
    {
        TraceMsg(TF_STANDARD, "Invalid index");

        return FALSE;
    }

    if (plb->wMultiple == SINGLESEL) 
    {
        return (sItem == plb->iSel);
    }

    lp = plb->rgpch + sItem +
             (plb->cMac * (plb->fHasStrings
                                ? sizeof(LBItem)
                                : (plb->fHasData
                                    ? sizeof(LBODItem)
                                    : 0)));
    sItem = *lp;

    if (wOpFlags == HILITEONLY) 
    {
        sItem >>= 4;
    } 
    else 
    {
        //
        // SELONLY
        //
        sItem &= 0x0F;
    }

    return sItem;
}


//---------------------------------------------------------------------------//
//
// ListBox_CItemInWindow
//
// Returns the number of items which can fit in a list box.  It
// includes the partially visible one at the bottom if fPartial is TRUE. For
// var height ownerdraw, return the number of items visible starting at iTop
// and going to the bottom of the client rect.
//
INT ListBox_CItemInWindow(PLBIV plb, BOOL fPartial)
{
    RECT rect;

    if (plb->OwnerDraw == OWNERDRAWVAR) 
    {
        return ListBox_VisibleItemsVarOwnerDraw(plb, fPartial);
    }

    if (plb->fMultiColumn) 
    {
        return plb->itemsPerColumn * (plb->numberOfColumns + (fPartial ? 1 : 0));
    }

    GetClientRect(plb->hwnd, &rect);

    //
    // fPartial must be considered only if the listbox height is not an
    // integral multiple of character height.
    // A part of the fix for Bug #3727 -- 01/14/91 -- SANKAR --
    //
    ASSERT(plb->cyChar);

    if (!plb->cyChar)
    {
        plb->cyChar = SYSFONT_CYCHAR;
    }

    return (INT)((rect.bottom / plb->cyChar) +
            ((rect.bottom % plb->cyChar)? (fPartial ? 1 : 0) : 0));
}


//---------------------------------------------------------------------------//
//
// ListBox_VScroll
// 
// Handles vertical scrolling of the listbox
//
void ListBox_VScroll(PLBIV plb, INT cmd, int yAmt)
{
    INT iTopNew;
    INT cItemPageScroll;
    DWORD dwTime = 0;

    if (plb->fMultiColumn) 
    {
        //
        // Don't allow vertical scrolling on a multicolumn list box.  Needed
        // in case app sends WM_VSCROLL messages to the listbox.
        //
        return;
    }

    cItemPageScroll = plb->cItemFullMax;

    if (cItemPageScroll > 1)
    {
        cItemPageScroll--;
    }

    if (plb->cMac) 
    {
        iTopNew = plb->iTop;

        switch (cmd) 
        {
        case SB_LINEUP:
            dwTime = yAmt;
            iTopNew--;

            break;

        case SB_LINEDOWN:
            dwTime = yAmt;
            iTopNew++;

            break;

        case SB_PAGEUP:
            if (plb->OwnerDraw == OWNERDRAWVAR) 
            {
                iTopNew = ListBox_Page(plb, plb->iTop, FALSE);
            } 
            else 
            {
                iTopNew -= cItemPageScroll;
            }

            break;

        case SB_PAGEDOWN:
            if (plb->OwnerDraw == OWNERDRAWVAR) 
            {
                iTopNew = ListBox_Page(plb, plb->iTop, TRUE);
            } 
            else 
            {
                iTopNew += cItemPageScroll;
            }

            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION: 
            //
            // If the listbox contains more than 0xFFFF items
            // it means that the scrolbar can return a position
            // that cannot fit in a WORD (16 bits), so use
            // GetScrollInfo (which is slower) in this case.
            //
            if (plb->cMac < 0xFFFF) 
            {
                iTopNew = yAmt;
            } 
            else 
            {
                SCROLLINFO si;

                si.cbSize   = sizeof(SCROLLINFO);
                si.fMask    = SIF_TRACKPOS;

                GetScrollInfo( plb->hwnd, SB_VERT, &si);

                iTopNew = si.nTrackPos;
            }

            break;

        case SB_TOP:
            iTopNew = 0;

            break;

        case SB_BOTTOM:
            iTopNew = plb->cMac - 1;

            break;

        case SB_ENDSCROLL:
            plb->fSmoothScroll = TRUE;
            ListBox_SetCaret(plb, FALSE);
            ListBox_ShowHideScrollBars(plb);
            ListBox_SetCaret(plb, TRUE);

            return;
        }

        ListBox_NewITopEx(plb, iTopNew, dwTime);
    }
}


//---------------------------------------------------------------------------//
DWORD ListBox_GetScrollFlags(PLBIV plb, DWORD dwTime)
{
    DWORD dwFlags;
    BOOL bUIEffects, bLBSmoothScroll;

    SystemParametersInfo(SPI_GETUIEFFECTS, 0, &bUIEffects, 0);
    SystemParametersInfo(SPI_GETLISTBOXSMOOTHSCROLLING, 0, &bLBSmoothScroll, 0);

    if (dwTime != 0) 
    {
        dwFlags = MAKELONG(SW_SCROLLWINDOW | SW_SMOOTHSCROLL | SW_SCROLLCHILDREN, dwTime);
    } 
    else if (bUIEffects && bLBSmoothScroll && plb->fSmoothScroll) 
    {
        dwFlags = SW_SCROLLWINDOW | SW_SMOOTHSCROLL | SW_SCROLLCHILDREN;
        plb->fSmoothScroll = FALSE;
    } 
    else 
    {
        //
        // NoSmoothScrolling:
        //
        dwFlags = SW_SCROLLWINDOW | SW_INVALIDATE | SW_ERASE | SW_SCROLLCHILDREN;
    }

    return dwFlags;
}


//---------------------------------------------------------------------------//
//
// ListBox_HScroll
//
// Supports horizontal scrolling of listboxes
//
void ListBox_HScroll(PLBIV plb, INT cmd, int xAmt)
{
    int newOrigin = plb->xOrigin;
    int oldOrigin = plb->xOrigin;
    int windowWidth;
    RECT rc;
    DWORD dwTime = 0;

    //
    // Update the window so that we don't run into problems with invalid
    // regions during the horizontal scroll.
    //
    if (plb->fMultiColumn) 
    {
        //
        // Handle multicolumn scrolling in a separate segment
        //
        ListBox_HSrollMultiColumn(plb, cmd, xAmt);

        return;
    }

    GetClientRect(plb->hwnd, &rc);
    windowWidth = rc.right;

    if (plb->cMac) 
    {

        switch (cmd) 
        {
        case SB_LINEUP:
            dwTime = xAmt;
            newOrigin -= plb->cxChar;

            break;

        case SB_LINEDOWN:
            dwTime = xAmt;
            newOrigin += plb->cxChar;

            break;

        case SB_PAGEUP:
            newOrigin -= (windowWidth / 3) * 2;

            break;

        case SB_PAGEDOWN:
            newOrigin += (windowWidth / 3) * 2;

            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            newOrigin = xAmt;

            break;

        case SB_TOP:
            newOrigin = 0;

            break;

        case SB_BOTTOM:
            newOrigin = plb->maxWidth;

            break;

        case SB_ENDSCROLL:
            plb->fSmoothScroll = TRUE;
            ListBox_SetCaret(plb, FALSE);
            ListBox_ShowHideScrollBars(plb);
            ListBox_SetCaret(plb, TRUE);

            return;
        }

        ListBox_SetCaret(plb, FALSE);

        plb->xOrigin = newOrigin;
        plb->xOrigin = ListBox_SetScrollParms(plb, SB_HORZ);

        if ((cmd == SB_BOTTOM) && plb->fRightAlign) 
        {
            //
            // so we know where to draw from.
            //
            plb->xRightOrigin = plb->xOrigin;
        }

        if(oldOrigin != plb->xOrigin)  
        {
            DWORD dwFlags;

            dwFlags = ListBox_GetScrollFlags(plb, dwTime);
            ScrollWindowEx(plb->hwnd, oldOrigin-plb->xOrigin,
                0, NULL, &rc, NULL, NULL, dwFlags);
            UpdateWindow(plb->hwnd);
        }

        ListBox_SetCaret(plb, TRUE);
    } 
    else 
    {
        //
        // this is a less-than-ideal fix for ImageMind ScreenSaver (Win95
        // B#8252) but it works and it doesn't hurt anybody -- JEFFBOG 10/28/94
        //
        ListBox_SetScrollParms(plb, SB_HORZ);
    }
}


//---------------------------------------------------------------------------//
void ListBox_Paint(PLBIV plb, HDC hdc, LPRECT lprcBounds)
{
    INT i;
    RECT rect;
    RECT    scratchRect;
    BOOL    fHilite;
    INT iLastItem;
    HBRUSH hbrSave = NULL;
    HBRUSH hbrControl;
    BOOL fCaretOn;
    RECT    rcBounds;
    HDC     hdcSave;

    if (lprcBounds == NULL) 
    {
        lprcBounds = &rcBounds;
        GetClientRect(plb->hwnd, lprcBounds);
    }

    hdcSave = plb->hdc;
    plb->hdc = hdc;

    //
    // Initialize dc.
    //
    ListBox_InitDC(plb);

    //
    // Turn caret off
    //
    fCaretOn = plb->fCaretOn;
    if (fCaretOn)
    {
        ListBox_SetCaret(plb, FALSE);
    }

    hbrSave = NULL;
    hbrControl = ListBox_GetBrush(plb, &hbrSave);

    //
    // Get listbox's client
    //
    GetClientRect(plb->hwnd, &rect);

    //
    // Adjust width of client rect for scrolled amount
    // fix for #140, t-arthb
    //
    if (plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw) && plb->fHorzBar)
    {
        rect.right += plb->xOrigin + (plb->xRightOrigin - plb->xOrigin);
    }
    else
    {
        rect.right += plb->xOrigin;
    }

    //
    // Get the index of the last item visible on the screen. This is also
    // valid for var height ownerdraw.
    //
    iLastItem = plb->iTop + ListBox_CItemInWindow(plb,TRUE);
    iLastItem = min(iLastItem, plb->cMac - 1);

    //
    // Fill in the background of the listbox if it's an empty listbox
    // or if we're doing a control print
    //
    if (iLastItem == -1)
    {
        FillRect(plb->hdc, &rect, hbrControl);
    }


    //
    // Allow AnimateWindow() catch the apps that do not use our DC when
    // drawing the list box
    //
    SetBoundsRect(plb->hdc, NULL, DCB_RESET | DCB_ENABLE);

    for (i = plb->iTop; i <= iLastItem; i++) 
    {
        //
        // Note that rect contains the clientrect from when we did the
        // GetClientRect so the width is correct.  We just need to adjust
        // the top and bottom of the rectangle to the item of interest.
        //
        rect.bottom = rect.top + plb->cyChar;

        if ((UINT)i < (UINT)plb->cMac) 
        {
            //
            // If var height, get the rectangle for the item.
            //
            if (plb->OwnerDraw == OWNERDRAWVAR || plb->fMultiColumn) 
            {
                ListBox_GetItemRectHandler(plb, i, &rect);
            }

            if (IntersectRect(&scratchRect, lprcBounds, &rect)) 
            {
                fHilite = !plb->fNoSel && ListBox_IsSelected(plb, i, HILITEONLY);

                if (plb->OwnerDraw) 
                {
                    //
                    // Fill in the drawitem struct
                    //
                    ListBox_FillDrawItem(plb, i, ODA_DRAWENTIRE,
                            (UINT)(fHilite ? ODS_SELECTED : 0), &rect);
                } 
                else 
                {
                    ListBox_DrawItem(plb, i, &rect, fHilite, hbrControl);
                }
            }
        }
        rect.top = rect.bottom;
    }

    if (hbrSave != NULL)
    {
        SelectObject(hdc, hbrSave);
    }

    if (fCaretOn)
    {
        ListBox_SetCaret(plb, TRUE);
    }

    ListBox_TermDC(plb);

    plb->hdc = hdcSave;
}


//---------------------------------------------------------------------------//
//
// ListBox_ISelFromPt
//
// In the loword, returns the closest item number the pt is on. The high
// word is 0 if the point is within bounds of the listbox client rect and is
// 1 if it is outside the bounds.  This will allow us to make the invertrect
// disappear if the mouse is outside the listbox yet we can still show the
// outline around the item that would be selected if the mouse is brought back
// in bounds...
BOOL ListBox_ISelFromPt(PLBIV plb, POINT pt, LPDWORD piItem)
{
    RECT rect;
    int y;
    UINT mouseHighWord = 0;
    INT sItem;
    INT sTmp;

    GetClientRect(plb->hwnd, &rect);

    if (pt.y < 0) 
    {
        //
        // Mouse is out of bounds above listbox
        //
        *piItem = plb->iTop;

        return TRUE;
    } 
    else if ((y = pt.y) > rect.bottom) 
    {
        y = rect.bottom;
        mouseHighWord = 1;
    }

    if (pt.x < 0 || pt.x > rect.right)
    {
        mouseHighWord = 1;
    }

    //
    // Now just need to check if y mouse coordinate intersects item's rectangle
    //
    if (plb->OwnerDraw != OWNERDRAWVAR) 
    {
        if (plb->fMultiColumn) 
        {
            if (y < plb->itemsPerColumn * plb->cyChar) 
            {
                if (plb->fRightAlign)
                {
                    sItem = plb->iTop + (INT)((y / plb->cyChar) +
                            ((rect.right - pt.x) / plb->cxColumn) * plb->itemsPerColumn);
                }
                else
                {
                    sItem = plb->iTop + (INT)((y / plb->cyChar) +
                            (pt.x / plb->cxColumn) * plb->itemsPerColumn);
                }
            } 
            else 
            {
                //
                // User clicked in blank space at the bottom of a column.
                // Just select the last item in the column.
                //
                mouseHighWord = 1;
                sItem = plb->iTop + (plb->itemsPerColumn - 1) +
                        (INT)((pt.x / plb->cxColumn) * plb->itemsPerColumn);
            }
        } 
        else 
        {
            sItem = plb->iTop + (INT)(y / plb->cyChar);
        }
    } 
    else 
    {
        //
        // VarHeightOwnerdraw so we gotta do this the hardway...   Set the x
        // coordinate of the mouse down point to be inside the listbox client
        // rectangle since we no longer care about it.  This lets us use the
        // point in rect calls.
        //
        pt.x = 8;
        pt.y = y;

        for (sTmp = plb->iTop; sTmp < plb->cMac; sTmp++) 
        {
            ListBox_GetItemRectHandler(plb, sTmp, &rect);

            if (PtInRect(&rect, pt)) 
            {
                *piItem = sTmp;

                return mouseHighWord;
            }
        }

        //
        // Point was at the empty area at the bottom of a not full listbox
        //
        *piItem = plb->cMac - 1;

        return mouseHighWord;
    }

    //
    // Check if user clicked on the blank area at the bottom of a not full list.
    // Assumes > 0 items in the listbox.
    //
    if (sItem > plb->cMac - 1) 
    {
        mouseHighWord = 1;
        sItem = plb->cMac - 1;
    }

    *piItem = sItem;

    return mouseHighWord;
}


//---------------------------------------------------------------------------//
//
// ListBox_SetSelected
//
// This is used for button initiated changes of selection state.
// 
// fSelected : TRUE  if the item is to be set as selected, FALSE otherwise
// 
// wOpFlags : HILITEONLY = Modify only the Display state (hi-nibble)
//            SELONLY    = Modify only the Selection state (lo-nibble)
//            HILITEANDSEL = Modify both of them;
//
void ListBox_SetSelected(PLBIV plb, INT iSel, BOOL fSelected, UINT wOpFlags)
{
    LPSTR lp;
    BYTE cMask;
    BYTE cSelStatus;

    if (iSel < 0 || iSel >= plb->cMac)
    {
        return;
    }

    if (plb->wMultiple == SINGLESEL) 
    {
        if (fSelected)
        {
            plb->iSel = iSel;
        }
    } 
    else 
    {
        cSelStatus = (BYTE)fSelected;

        switch (wOpFlags) 
        {
        case HILITEONLY:
            //
            // Mask out lo-nibble
            //
            cSelStatus = (BYTE)(cSelStatus << 4);
            cMask = 0x0F;

            break;

        case SELONLY:
            //
            // Mask out hi-nibble
            //
            cMask = 0xF0;

            break;

        case HILITEANDSEL:
            //
            // Mask the byte fully
            //
            cSelStatus |= (cSelStatus << 4);
            cMask = 0;

            break;
        }

        lp = (LPSTR)(plb->rgpch) + iSel +
                (plb->cMac * (plb->fHasStrings
                                ? sizeof(LBItem)
                                : (plb->fHasData ? sizeof(LBODItem) : 0)));

        *lp = (*lp & cMask) | cSelStatus;
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_LastFullVisible
//
// Returns the last fully visible item in the listbox. This is valid
// for ownerdraw var height and fixed height listboxes.
//
INT ListBox_LastFullVisible(PLBIV plb)
{
    INT iLastItem;

    if (plb->OwnerDraw == OWNERDRAWVAR || plb->fMultiColumn) 
    {
        iLastItem = plb->iTop + ListBox_CItemInWindow(plb, FALSE) - 1;
        iLastItem = max(iLastItem, plb->iTop);
    } 
    else 
    {
        iLastItem = min(plb->iTop + plb->cItemFullMax - 1, plb->cMac - 1);
    }

    return iLastItem;
}


//---------------------------------------------------------------------------//
void ListBox_InvertItem( PLBIV plb, INT i, BOOL fHilite)
{
    RECT rect;
    BOOL fCaretOn;
    HBRUSH hbrControl;
    BOOL    fNewDC;

    //
    // Skip if item isn't showing.
    //
    if (plb->fNoSel || (i < plb->iTop) || (i >= (plb->iTop + ListBox_CItemInWindow(plb, TRUE))))
    {
        return;
    }

    if (IsLBoxVisible(plb)) 
    {
        ListBox_GetItemRectHandler(plb, i, &rect);

        //
        // Only turn off the caret if it is on.  This avoids annoying caret
        // flicker when nesting CaretOns and CaretOffs.
        //
        fCaretOn = plb->fCaretOn;
        if (fCaretOn) 
        {
            ListBox_SetCaret(plb, FALSE);
        }

        fNewDC = ListBox_GetDC(plb);

        hbrControl = ListBox_GetBrush(plb, NULL);

        if (!plb->OwnerDraw) 
        {
            if (!fHilite) 
            {
                FillRect(plb->hdc, &rect, hbrControl);
                hbrControl = NULL;
            }

            ListBox_DrawItem(plb, i, &rect, fHilite, hbrControl);
        } 
        else 
        {
            //
            // We are ownerdraw so fill in the drawitem struct and send off
            // to the owner.
            //
            ListBox_FillDrawItem(plb, i, ODA_SELECT,
                    (UINT)(fHilite ? ODS_SELECTED : 0), &rect);
        }

        if (fNewDC)
        {
            ListBox_ReleaseDC(plb);
        }

        //
        // Turn the caret back on only if it was originally on.
        //
        if (fCaretOn) 
        {
            ListBox_SetCaret(plb, TRUE);
        }
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_ResetWorld
//
// Resets everyone's selection and hilite state except items in the
// range sStItem to sEndItem (Both inclusive).
void ListBox_ResetWorld(PLBIV plb, INT iStart, INT iEnd, BOOL fSelect)
{
    INT i;
    INT iLastInWindow;
    BOOL fCaretOn;

    //
    // If iStart and iEnd are not in correct order we swap them
    //
    if (iStart > iEnd) 
    {
        i = iStart;
        iStart = iEnd;
        iEnd = i;
    }

    if (plb->wMultiple == SINGLESEL) 
    {
        if (plb->iSel != -1 && ((plb->iSel < iStart) || (plb->iSel > iEnd))) 
        {
            ListBox_InvertItem(plb, plb->iSel, fSelect);
            plb->iSel = -1;
        }

        return;
    }

    iLastInWindow = plb->iTop + ListBox_CItemInWindow(plb, TRUE);

    fCaretOn = plb->fCaretOn;
    if (fCaretOn)
    {
        ListBox_SetCaret(plb, FALSE);
    }

    for (i = 0; i < plb->cMac; i++) 
    {
        if (i == iStart)
        {
            //
            // skip range to be preserved
            //
            i = iEnd;
        }
        else 
        {
            if ((plb->iTop <= i) && (i <= iLastInWindow) &&
                (fSelect != ListBox_IsSelected(plb, i, HILITEONLY)))
            {
                //
                // Only invert the item if it is visible and present Selection
                // state is different from what is required.
                //
                ListBox_InvertItem(plb, i, fSelect);
            }

            //
            // Set all items outside of preserved range to unselected
            //
            ListBox_SetSelected(plb, i, fSelect, HILITEANDSEL);
        }
    }

    if (fCaretOn)
    {
        ListBox_SetCaret(plb, TRUE);
    }

}


//---------------------------------------------------------------------------//
void ListBox_NotifyOwner(PLBIV plb, INT sEvt)
{
    HWND hwndParent = plb->hwndParent;
    if (hwndParent)
    {
        SendMessage(hwndParent, WM_COMMAND, MAKELONG(GetWindowID(plb->hwnd), sEvt), (LPARAM)(plb->hwnd));
    }
}


//---------------------------------------------------------------------------//
void ListBox_SetISelBase(PLBIV plb, INT sItem)
{
    ListBox_SetCaret(plb, FALSE);
    plb->iSelBase = sItem;
    ListBox_SetCaret(plb, TRUE);

    ListBox_InsureVisible(plb, plb->iSelBase, FALSE);

    if (IsWindowVisible(plb->hwnd) || (GetFocus() == plb->hwnd)) 
    {
        ListBox_Event(plb, EVENT_OBJECT_FOCUS, sItem);
    }
}


//---------------------------------------------------------------------------//
void ListBox_TrackMouse(PLBIV plb, UINT wMsg, POINT pt)
{
    INT iSelFromPt;
    INT iSelTemp;
    BOOL mousetemp;
    BOOL fMouseInRect;
    RECT rcClient;
    UINT wModifiers = 0;
    BOOL fSelected;
    UINT uEvent = 0;
    INT trackPtRetn;
    HWND hwnd = plb->hwnd;
    RECT rcWindow;

    //
    // Optimization:  do nothing if mouse not captured
    //
    if ((wMsg != WM_LBUTTONDOWN) && (wMsg != WM_LBUTTONDBLCLK)) 
    {
        if (!plb->fCaptured) 
        {
            return;
        }

        //
        // If we are processing a WM_MOUSEMOVE but the mouse has not moved from
        // the previous point, then we may be dealing with a mouse "jiggle" sent
        // from the kernel (see zzzInvalidateDCCache).  If we process this, we will
        // snap the listbox selection back to where the mouse cursor is pointing,
        // even if the user has not touched the mouse.  FritzS: NT5 bug 220722.
        // Some apps (like MSMoney98) rely on this, so added the bLastRITWasKeyboard
        // check.  MCostea #244450
        //
        if ((wMsg == WM_MOUSEMOVE) && RtlEqualMemory(&pt, &(plb->ptPrev), sizeof(POINT)) ) 
        {
            TraceMsg(TF_STANDARD, "ListBox_TrackMouse ignoring WM_MOUSEMOVE with no mouse movement");

            return;
        }
    }

    mousetemp = ListBox_ISelFromPt(plb, pt, &iSelFromPt);

    //
    // If we allow the user to cancel his selection then fMouseInRect is true if
    // the mouse is in the listbox client area otherwise it is false.  If we
    // don't allow the user to cancel his selection, then fMouseInRect will
    // always be true.  This allows us to implement cancelable selection
    // listboxes ie.  The selection reverts to the origional one if the user
    // releases the mouse outside of the listbox.
    //
    fMouseInRect = !mousetemp || !plb->pcbox;

    GetClientRect(plb->hwnd, &rcClient);

    switch (wMsg) 
    {
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
        //
        // We want to divert mouse clicks.  If the user clicks outside
        // of a dropped down listbox, we want to popup it up, using
        // the current selection.
        //
        if (plb->fCaptured) 
        {
            //
            // If plb->pcbox is NULL, this is a listbox that
            // received a WM_LBUTTONDOWN again w/o receiving
            // a WM_LBUTTONUP for the previous WM_LBUTTONDOWN bug
            //
            if (plb->pcbox && mousetemp) 
            {
                // Translate pt and rcClient to screen rel coords
                ClientToScreen(plb->hwnd, &pt);
                ClientToScreen(plb->hwnd, (LPPOINT)&rcClient.left );
                ClientToScreen(plb->hwnd, (LPPOINT)&rcClient.right );

                GetWindowRect(plb->hwnd, &rcWindow);

                if (!PtInRect(&rcWindow, pt)) 
                {
                    //
                    // Cancel selection if clicked outside of combo;
                    // Accept if clicked on combo button or item.
                    //
                    ComboBox_HideListBoxWindow(plb->pcbox, TRUE, FALSE);
                } 
                else if (!PtInRect(&rcClient, pt)) 
                {
                    //
                    // Let it pass through.  Save, restore capture in
                    // case user is clicking on scrollbar.
                    //
    
                    plb->fCaptured = FALSE;
                    
                    ReleaseCapture();

                    SendMessageW(plb->hwnd, WM_NCLBUTTONDOWN,
                        (WPARAM)SendMessageW(plb->hwnd, WM_NCHITTEST, 0, POINTTOPOINTS(pt)), POINTTOPOINTS(pt));

                    SetCapture(hwnd);
                    
                    plb->fCaptured = TRUE;
                }

                break;
            }

            plb->fCaptured = FALSE;
            ReleaseCapture();
        }

        if (plb->pcbox) 
        {
            //
            // If this listbox is in a combo box, set the focus to the combo
            // box window so that the edit control/static text is also
            // activated
            //
            SetFocus(plb->pcbox->hwndEdit);
        } 
        else 
        {
            //
            // Get the focus if the listbox is clicked in and we don't
            // already have the focus.  If we don't have the focus after
            // this, run away...
            //
            SetFocus(hwnd);

            if (!plb->fCaret)
            {
                return;
            }
        }

        if (plb->fAddSelMode) 
        {
            //
            // If it is in "Add" mode, quit it using shift f8 key...
            // However, since we can't send shift key state, we have to turn
            // this off directly...
            //

            //
            // Switch off the Caret blinking
            //
            KillTimer(hwnd, IDSYS_CARET);

            //
            // Make sure the caret does not vanish
            //
            ListBox_SetCaret(plb, TRUE);
            plb->fAddSelMode = FALSE;
        }

        if (!plb->cMac) 
        {
            //
            // Don't even bother handling the mouse if no items in the
            // listbox since the code below assumes >0 items in the
            // listbox.  We will just get the focus (the statement above) if
            // we don't already have it.
            //
            break;
        }

        if (mousetemp && plb->fCaptured) 
        {
            //
            // Mouse down occurred in a empty spot. And we're tracking the list.
            // Just ignore it.
            //
            break;
        }
        

        plb->fDoubleClick = (wMsg == WM_LBUTTONDBLCLK);

        if (!plb->fDoubleClick) 
        {
            //
            // This hack put in for the shell.  Tell the shell where in the
            // listbox the user clicked and at what item number.  The shell
            // can return 0 to continue normal mouse tracking or TRUE to
            // abort mouse tracking.
            //
            trackPtRetn = (INT)SendMessage(plb->hwndParent, WM_LBTRACKPOINT,
                    (DWORD)iSelFromPt, MAKELONG(pt.x+plb->xOrigin, pt.y));
            if (trackPtRetn) 
            {
                return;
            }
        }

        if (plb->pcbox) 
        {
            //
            // Save the last selection if this is a combo box.  So that it
            // can be restored if user decides to cancel the selection by up
            // clicking outside the listbox.
            //
            plb->iLastSelection = plb->iSel;
        }

        //
        // Save for timer
        //
        plb->ptPrev = pt;

        plb->fMouseDown = TRUE;
        SetCapture(hwnd);
        plb->fCaptured = TRUE;

        if (plb->fDoubleClick) 
        {
            //
            // Double click.  Fake a button up and exit
            //
            ListBox_TrackMouse(plb, WM_LBUTTONUP, pt);

            return;
        }

        //
        // Set the system timer so that we can autoscroll if the mouse is
        // outside the bounds of the listbox rectangle
        //
        SetTimer(hwnd, IDSYS_SCROLL, SCROLL_TIMEOUT(), NULL);

        //
        // If extended multiselection listbox, are any modifier key pressed?
        //
        if (plb->wMultiple == EXTENDEDSEL) 
        {
            if (GetKeyState(VK_SHIFT) < 0)
            {
                wModifiers = SHIFTDOWN;
            }
    
            if (GetKeyState(VK_CONTROL) < 0)
            {
                wModifiers += CTLDOWN;
            }

            //
            // Please Note that (SHIFTDOWN + CTLDOWN) == (SHCTLDOWN)
            //
        }


        switch (wModifiers) 
        {
        case NOMODIFIER:
MouseMoveHandler:
            if (plb->iSelBase != iSelFromPt) 
            {
                ListBox_SetCaret(plb, FALSE);
            }

            //
            // We only look at the mouse if the point it is pointing to is
            // not selected.  Since we are not in ExtendedSelMode, anywhere
            // the mouse points, we have to set the selection to that item.
            // Hence, if the item isn't selected, it means the mouse never
            // pointed to it before so we can select it.  We ignore already
            // selected items so that we avoid flashing the inverted
            // selection rectangle.  Also, we could get WM_SYSTIMER simulated
            // mouse moves which would cause flashing otherwise...
            //

            if ( mousetemp || (plb->pcbox && plb->pcbox->fButtonPressed))
            {
                // We're outside the list but haven't begun tracking the list yet.
                // Select the item that is already selected.
                iSelTemp = plb->iSel;
            }
            else
            {
                iSelTemp = (fMouseInRect ? iSelFromPt : -1);
            }

            //
            // If the LB is either SingleSel or Extended multisel, clear all
            // old selections except the new one being made.
            //
            if (plb->wMultiple != MULTIPLESEL) 
            {
                ListBox_ResetWorld(plb, iSelTemp, iSelTemp, FALSE);

                //
                // This will be TRUE if iSelTemp isn't -1 (like below)
                // and also if it is but there is a current selection.
                //
                if ((iSelTemp == -1) && (plb->iSel != -1)) 
                {
                    uEvent = EVENT_OBJECT_SELECTIONREMOVE;
                }
            }

            fSelected = ListBox_IsSelected(plb, iSelTemp, HILITEONLY);
            if (iSelTemp != -1) 
            {
                //
                // If it is MULTIPLESEL, then toggle; For others, only if
                // not selected already, select it.
                //
                if (((plb->wMultiple == MULTIPLESEL) && (wMsg != WM_LBUTTONDBLCLK)) || !fSelected) 
                {
                    ListBox_SetSelected(plb, iSelTemp, !fSelected, HILITEANDSEL);

                    //
                    // And invert it
                    //
                    ListBox_InvertItem(plb, iSelTemp, !fSelected);
                    fSelected = !fSelected;     // Set the new state
                    if (plb->wMultiple == MULTIPLESEL) 
                    {
                        uEvent = (fSelected ? EVENT_OBJECT_SELECTIONADD :
                                EVENT_OBJECT_SELECTIONREMOVE);
                    } 
                    else 
                    {
                        uEvent = EVENT_OBJECT_SELECTION;
                    }
                }
            }

            //
            // We have to set iSel in case this is a multisel lb.
            //
            plb->iSel = iSelTemp;

            //
            // Set the new anchor point
            //
            plb->iMouseDown = iSelFromPt;
            plb->iLastMouseMove = iSelFromPt;
            plb->fNewItemState = fSelected;

            break;

        case SHIFTDOWN:

            //
            // This is so that we can handle click and drag for multisel
            // listboxes using Shift modifier key .
            //
            plb->iLastMouseMove = plb->iSel = iSelFromPt;

            //
            // Check if an anchor point already exists
            //
            if (plb->iMouseDown == -1) 
            {
                plb->iMouseDown = iSelFromPt;

                //
                // Reset all the previous selections
                //
                ListBox_ResetWorld(plb, plb->iMouseDown, plb->iMouseDown, FALSE);

                //
                // Select the current position
                //
                ListBox_SetSelected(plb, plb->iMouseDown, TRUE, HILITEANDSEL);
                ListBox_InvertItem(plb, plb->iMouseDown, TRUE);

                //
                // We are changing the selction to this item only
                //
                uEvent = EVENT_OBJECT_SELECTION;
            } 
            else 
            {
                //
                // Reset all the previous selections
                //
                ListBox_ResetWorld(plb, plb->iMouseDown, plb->iMouseDown, FALSE);

                //
                // Select all items from anchor point upto current click pt
                //
                ListBox_AlterHilite(plb, plb->iMouseDown, iSelFromPt, HILITE, HILITEONLY, FALSE);
                uEvent = EVENT_OBJECT_SELECTIONWITHIN;
            }

            plb->fNewItemState = (UINT)TRUE;

            break;

        case CTLDOWN:

            //
            // This is so that we can handle click and drag for multisel
            // listboxes using Control modifier key.
            //

            //
            // Reset the anchor point to the current point
            //
            plb->iMouseDown = plb->iLastMouseMove = plb->iSel = iSelFromPt;

            //
            // The state we will be setting items to
            //
            plb->fNewItemState = (UINT)!ListBox_IsSelected(plb, iSelFromPt, (UINT)HILITEONLY);

            //
            // Toggle the current point
            //
            ListBox_SetSelected(plb, iSelFromPt, plb->fNewItemState, HILITEANDSEL);
            ListBox_InvertItem(plb, iSelFromPt, plb->fNewItemState);

            uEvent = (plb->fNewItemState ? EVENT_OBJECT_SELECTIONADD :
                    EVENT_OBJECT_SELECTIONREMOVE);
            break;

        case SHCTLDOWN:

            //
            // This is so that we can handle click and drag for multisel
            // listboxes using Shift and Control modifier keys.
            //

            //
            // Preserve all the previous selections
            //

            //
            // Deselect only the selection connected with the last
            // anchor point; If the last anchor point is associated with a
            // de-selection, then do not do it
            // 
            if (plb->fNewItemState) 
            {
                ListBox_AlterHilite(plb, plb->iMouseDown, plb->iLastMouseMove, FALSE, HILITEANDSEL, FALSE);
            }

            plb->iLastMouseMove = plb->iSel = iSelFromPt;

            //
            // Check if an anchor point already exists
            //
            if (plb->iMouseDown == -1) 
            {
                //
                // No existing anchor point; Make the current pt as anchor
                //
                plb->iMouseDown = iSelFromPt;
            }

            //
            // If one exists preserve the most recent anchor point
            //

            //
            // The state we will be setting items to
            //
            plb->fNewItemState = (UINT)ListBox_IsSelected(plb, plb->iMouseDown, HILITEONLY);

            //
            // Select all items from anchor point upto current click pt
            //
            ListBox_AlterHilite(plb, plb->iMouseDown, iSelFromPt, plb->fNewItemState, HILITEONLY, FALSE);
            uEvent = EVENT_OBJECT_SELECTIONWITHIN;

            break;
        }

        //
        // Set the new base point (the outline frame caret).  We do the check
        // first to avoid flashing the caret unnecessarly.
        //
        if (plb->iSelBase != iSelFromPt) 
        {
            //
            // Since ListBox_SetISelBase always turns on the caret, we don't need to
            // do it here...
            //
            ListBox_SetISelBase(plb, iSelFromPt);
        }

        //
        // ListBox_SetISelBase will change the focus and send a focus event.
        // Then we send the selection event.
        //
        if (uEvent) 
        {
            ListBox_Event(plb, uEvent, iSelFromPt);
        }

        if (wMsg == WM_LBUTTONDOWN && (GET_EXSTYLE(plb) & WS_EX_DRAGOBJECT)!=0) 
        {
            if (DragDetect(hwnd, pt)) 
            {
                //
                // User is trying to drag object...
                //

                //
                // Fake an up click so that the item is selected...
                //
                ListBox_TrackMouse(plb, WM_LBUTTONUP, pt);

                //
                // Notify parent
                // #ifndef WIN16 (32-bit Windows), plb->iSelBase gets
                // zero-extended to LONG wParam automatically by the compiler.
                //
                SendMessage(plb->hwndParent, WM_BEGINDRAG, plb->iSelBase, (LPARAM)hwnd);
            } 
            else 
            {
                ListBox_TrackMouse(plb, WM_LBUTTONUP, pt);
            }

            return;
        }

        break;

    case WM_MOUSEMOVE: 
    {
        int dist;
        int iTimer;

        //
        // Save for timer.
        //
        plb->ptPrev = pt;

        //
        // Autoscroll listbox if mouse button is held down and mouse is
        // moved outside of the listbox
        //
        if (plb->fMouseDown) 
        {
            if (plb->fMultiColumn) 
            {
                if ((pt.x < 0) || (pt.x >= rcClient.right - 1)) 
                {
                    //
                    // Reset timer interval based on distance from listbox.
                    // use a longer default interval because each multicolumn
                    // scrolling increment is larger
                    //
                    dist = pt.x < 0 ? -pt.x : (pt.x - rcClient.right + 1);
                    iTimer = ((SCROLL_TIMEOUT() * 3) / 2) - ((WORD) dist << 4);

                    if (plb->fRightAlign)
                    {
                        ListBox_HSrollMultiColumn(plb, (pt.x < 0 ? SB_LINEDOWN : SB_LINEUP), 0);
                    }
                    else
                    {
                        ListBox_HSrollMultiColumn(plb, (pt.x < 0 ? SB_LINEUP : SB_LINEDOWN), 0);
                    }

                    goto SetTimerAndSel;
                }
            } 
            else if ((pt.y < 0) || (pt.y >= rcClient.bottom - 1)) 
            {
                //
                // Reset timer interval based on distance from listbox.
                //
                dist = pt.y < 0 ? -pt.y : (pt.y - rcClient.bottom + 1);
                iTimer = SCROLL_TIMEOUT() - ((WORD) dist << 4);

                ListBox_VScroll(plb, (pt.y < 0 ? SB_LINEUP : SB_LINEDOWN), 0);
SetTimerAndSel:
                SetTimer(hwnd, IDSYS_SCROLL, max(iTimer, 1), NULL);
                ListBox_ISelFromPt(plb, pt, &iSelFromPt);
            }
        } 
        else 
        {
            //
            // Ignore if not in client since we don't autoscroll
            //
            if (!PtInRect(&rcClient, pt))
            {
                break;
            }
        }

        switch (plb->wMultiple) 
        {
        case SINGLESEL:

            //
            // If it is a single selection or plain multisel list box
            //
            goto MouseMoveHandler;

        case MULTIPLESEL:
        case EXTENDEDSEL:

            //
            // Handle mouse movement with extended selection of items
            //
            if (plb->iSelBase != iSelFromPt) 
            {
                ListBox_SetISelBase(plb, iSelFromPt);

                //
                // If this is an extended Multi sel list box, then
                // adjust the display of the range due to the mouse move
                //
                if (plb->wMultiple == EXTENDEDSEL) 
                {
                    ListBox_BlockHilite(plb, iSelFromPt, FALSE);
                    ListBox_Event(plb, EVENT_OBJECT_SELECTIONWITHIN, iSelFromPt);
                }
                plb->iLastMouseMove = iSelFromPt;
            }

            break;
        }

        break;
    }
    case WM_LBUTTONUP:
        if (plb->fMouseDown)
        {
            ListBox_ButtonUp(plb, LBUP_RELEASECAPTURE | LBUP_NOTIFY |
                (mousetemp ? LBUP_RESETSELECTION : 0) |
                (fMouseInRect ? LBUP_SUCCESS : 0));
        }
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_ButtonUp
//
// Called in response to both WM_CAPTURECHANGED and WM_LBUTTONUP.
//
void ListBox_ButtonUp(PLBIV plb, UINT uFlags)
{
    //
    // If the list box is an Extended listbox, then change the select status
    // of all items between the anchor and the last mouse position to the
    // newItemState
    //
    if (plb->wMultiple == EXTENDEDSEL)
    {
        ListBox_AlterHilite(plb, plb->iMouseDown, plb->iLastMouseMove,
            plb->fNewItemState, SELONLY, FALSE);
    }

    //
    // This is a combo box and user upclicked outside the listbox
    // so we want to restore the original selection.
    //
    if (plb->pcbox && (uFlags & LBUP_RESETSELECTION)) 
    {
        int iSelOld;

        iSelOld = plb->iSel;

        if (iSelOld >= 0)
        {
            ListBox_InvertItem(plb, plb->iSel, FALSE);
        }

        plb->iSel = plb->iLastSelection;
        ListBox_InvertItem(plb, plb->iSel, TRUE);

        //
        // Note that we always send selection events before we tell the
        // app.  This is on purpose--the app may turn around and select
        // something else when notified.  In which case our event would
        // be out of order.
        //
        ListBox_Event(plb, EVENT_OBJECT_SELECTION, plb->iSel);

        //
        // On win-95 and NT4 the check used to be !(uFlags & LBUP_NOTIFY) which
        // is a bug because we would notify even when the lb is not LBUP_NOTIFY
        //
        if ((uFlags & LBUP_NOTIFY) && plb->fNotify && (iSelOld != plb->iSel))
        {
            ListBox_NotifyOwner(plb, LBN_SELCHANGE);
        }
    }

    KillTimer(plb->hwnd, IDSYS_SCROLL);
    plb->fMouseDown = FALSE;

    if ( plb->fCaptured || (GetCapture() == plb->hwndParent) ) 
    {
        plb->fCaptured = FALSE;
        if (uFlags & LBUP_RELEASECAPTURE)
        {
            ReleaseCapture();
        }
    }

    //
    // Don't scroll item as long as any part of it is visible
    //
    if (plb->iSelBase < plb->iTop ||
        plb->iSelBase > plb->iTop + ListBox_CItemInWindow(plb, TRUE))
    {
        ListBox_InsureVisible(plb, plb->iSelBase, FALSE);
    }

    if (plb->fNotify) 
    {
        if (uFlags & LBUP_NOTIFY)  
        {
            if (uFlags & LBUP_SUCCESS) 
            {
                //
                // ArtMaster needs this SELCHANGE notification now!
                //
                if ((plb->fDoubleClick) && !TESTFLAG(GET_STATE2(plb), WS_S2_WIN31COMPAT))
                {
                    ListBox_NotifyOwner(plb, LBN_SELCHANGE);
                }

                //
                // Notify owner of click or double click on selection
                //
                ListBox_NotifyOwner(plb, (plb->fDoubleClick) ? LBN_DBLCLK : LBN_SELCHANGE);
            } 
            else 
            {
                //
                // Notify owner that the attempted selection was cancelled.
                //
                ListBox_NotifyOwner(plb, LBN_SELCANCEL);
            }
        } 
        else if (uFlags & LBUP_SELCHANGE) 
        {
            //
            // Did we do some semi-selecting with mouse moves, then hit Enter?
            // If so, we need to make sure the app knows that something was
            // really truly selected.
            //
            ASSERT(TESTFLAG(GET_STATE2(plb), WS_S2_WIN40COMPAT));

            if (plb->iLastSelection != plb->iSel)
            {
                ListBox_NotifyOwner(plb, LBN_SELCHANGE);
            }

        }
    }
}


//---------------------------------------------------------------------------//
INT ListBox_IncrementISel(PLBIV plb, INT iSel, INT sInc)
{
    //
    // Assumes cMac > 0, return iSel+sInc in range [0..cmac).
    //
    iSel += sInc;
    if (iSel < 0) 
    {
        return 0;
    } 
    else if (iSel >= plb->cMac) 
    {
        return plb->cMac - 1;
    }

    return iSel;
}


//---------------------------------------------------------------------------//
void ListBox_NewITop(PLBIV plb, INT iTopNew)
{
    ListBox_NewITopEx(plb, iTopNew, 0);
}


//---------------------------------------------------------------------------//
void ListBox_NewITopEx(PLBIV plb, INT iTopNew, DWORD dwTime)
{
    int  iTopOld;
    BOOL fCaretOn;
    BOOL fMulti = plb->fMultiColumn;


    //
    // Always try to turn off caret whether or not redraw is on
    //
    if (fCaretOn = plb->fCaretOn)
    {
        ListBox_SetCaret(plb, FALSE);
    }

    iTopOld = (fMulti) ? (plb->iTop / plb->itemsPerColumn) : plb->iTop;
    plb->iTop = iTopNew;
    iTopNew = ListBox_SetScrollParms(plb, (fMulti) ? SB_HORZ : SB_VERT);
    plb->iTop = (fMulti) ? (iTopNew * plb->itemsPerColumn) : iTopNew;

    if (!IsLBoxVisible(plb)) 
    {
        return;
    }

    if (iTopNew != iTopOld) 
    {
        int     xAmt, yAmt;
        RECT    rc;
        DWORD   dwFlags;

        GetClientRect(plb->hwnd, &rc);

        if (fMulti) 
        {
            yAmt = 0;
            if (abs(iTopNew - iTopOld) > plb->numberOfColumns)
            {
                //
                // Handle scrolling a large number of columns properly so that
                // we don't overflow the size of a rect.
                //
                xAmt = 32000;
            }
            else 
            {
                xAmt = (iTopOld - iTopNew) * plb->cxColumn;
                if (plb->fRightAlign)
                {
                    xAmt = -xAmt;
                }
            }
        } 
        else 
        {
            xAmt = 0;
            if (plb->OwnerDraw == OWNERDRAWVAR) 
            {
                //
                // Have to fake iTopOld for OWNERDRAWVAR listboxes so that
                // the scrolling amount calculations work properly.
                //
                plb->iTop = iTopOld;
                yAmt = ListBox_CalcVarITopScrollAmt(plb, iTopOld, iTopNew);
                plb->iTop = iTopNew;
            } 
            else if (abs(iTopNew - iTopOld) > plb->cItemFullMax)
            {
                yAmt = 32000;
            }
            else
            {
                yAmt = (iTopOld - iTopNew) * plb->cyChar;
            }
        }

        dwFlags = ListBox_GetScrollFlags(plb, dwTime);
        ScrollWindowEx(plb->hwnd, xAmt, yAmt, NULL, &rc, NULL, NULL, dwFlags);
        UpdateWindow(plb->hwnd);
    }

    //
    // Note that although we turn off the caret regardless of redraw, we
    // only turn it on if redraw is true. Slimy thing to fixup many
    // caret related bugs...
    //
    if (fCaretOn)
    {
        // Turn the caret back on only if we turned it off. This avoids
        // annoying caret flicker.
        ListBox_SetCaret(plb, TRUE);
    }
}


//---------------------------------------------------------------------------//
void ListBox_InsureVisible( PLBIV plb, INT iSel, BOOL fPartial)
{
    INT sLastVisibleItem;

    if (iSel < plb->iTop) 
    {
        ListBox_NewITop(plb, iSel);
    } 
    else 
    {
        if (fPartial) 
        {
            //
            // 1 must be subtracted to get the last visible item
            // A part of the fix for Bug #3727 -- 01/14/91 -- SANKAR
            //
            sLastVisibleItem = plb->iTop + ListBox_CItemInWindow(plb, TRUE) - (INT)1;
        } 
        else 
        {
            sLastVisibleItem = ListBox_LastFullVisible(plb);
        }

        if (plb->OwnerDraw != OWNERDRAWVAR) 
        {
            if (iSel > sLastVisibleItem) 
            {
                if (plb->fMultiColumn) 
                {
                    ListBox_NewITop(plb,
                        ((iSel / plb->itemsPerColumn) -
                        max(plb->numberOfColumns-1,0)) * plb->itemsPerColumn);
                } 
                else 
                {
                    ListBox_NewITop(plb, (INT)max(0, iSel - sLastVisibleItem + plb->iTop));
                }
            }
        } 
        else if (iSel > sLastVisibleItem)
        {
            ListBox_NewITop(plb, ListBox_Page(plb, iSel, FALSE));
        }
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_CareBlinker
//
// Timer callback function toggles Caret
// Since it is a callback, it is APIENTRY
//
VOID ListBox_CareBlinker(HWND hwnd, UINT wMsg, UINT_PTR nIDEvent, DWORD dwTime)
{
    PLBIV plb;

    //
    // Standard parameters for a timer callback function that aren't used.
    // Mentioned here to avoid compiler warnings
    //
    UNREFERENCED_PARAMETER(wMsg);
    UNREFERENCED_PARAMETER(nIDEvent);
    UNREFERENCED_PARAMETER(dwTime);

    plb = ListBox_GetPtr(hwnd);

    //
    // leave caret on, don't blink it off (prevents rapid blinks?)
    //
    if (ISREMOTESESSION() && plb->fCaretOn) 
    {
        return;
    }

    //
    // Check if the Caret is ON, if so, switch it OFF
    //
    ListBox_SetCaret(plb, !plb->fCaretOn);
}


//---------------------------------------------------------------------------//
//
// ListBox_KeyInput
//
// If msg == LB_KEYDOWN, vKey is the number of the item to go to,
// otherwise it is the virtual key.
//
void ListBox_KeyInput(PLBIV plb, UINT msg, UINT vKey)
{
    INT i;
    INT iNewISel;
    INT cItemPageScroll;
    PCBOX pcbox;
    BOOL fDropDownComboBox;
    BOOL fExtendedUIComboBoxClosed;
    UINT wModifiers = 0;
    BOOL fSelectKey = FALSE;    // assume it is a navigation key
    UINT uEvent = 0;
    HWND hwnd = plb->hwnd;

    BOOL hScrollBar = (GET_STYLE(plb)&WS_HSCROLL)!=0;

    pcbox = plb->pcbox;

    //
    // Is this a dropdown style combo box/listbox ?
    //
    fDropDownComboBox = pcbox && (pcbox->CBoxStyle & SDROPPABLE);

    //
    // Is this an extended ui combo box which is closed?
    //
    fExtendedUIComboBoxClosed = fDropDownComboBox && pcbox->fExtendedUI &&
                              !pcbox->fLBoxVisible;

    if (plb->fMouseDown || (!plb->cMac && vKey != VK_F4)) 
    {
        //
        // Ignore keyboard input if we are in the middle of a mouse down deal or
        // if there are no items in the listbox. Note that we let F4's go
        // through for combo boxes so that the use can pop up and down empty
        // combo boxes.
        //
        return;
    }

    //
    // Modifiers are considered only in EXTENDED sel list boxes.
    //
    if (plb->wMultiple == EXTENDEDSEL) 
    {
        //
        // If multiselection listbox, are any modifiers used ?
        //
        if (GetKeyState(VK_SHIFT) < 0)
        {
            wModifiers = SHIFTDOWN;
        }

        if (GetKeyState(VK_CONTROL) < 0)
        {
            wModifiers += CTLDOWN;
        }

        //
        // Please Note that (SHIFTDOWN + CTLDOWN) == (SHCTLDOWN)
        //
    }

    if (msg == LB_KEYDOWN) 
    {
        //
        // This is a listbox "go to specified item" message which means we want
        // to go to a particular item number (given by vKey) directly.  ie.  the
        // user has typed a character and we want to go to the item which
        // starts with that character.
        //
        iNewISel = (INT)vKey;

        goto TrackKeyDown;
    }

    cItemPageScroll = plb->cItemFullMax;

    if (cItemPageScroll > 1)
    {
        cItemPageScroll--;
    }

    if (plb->fWantKeyboardInput) 
    {
        //
        // Note: msg must not be LB_KEYDOWN here or we'll be in trouble...
        //
        iNewISel = (INT)SendMessage(plb->hwndParent, WM_VKEYTOITEM,
                MAKELONG(vKey, plb->iSelBase), (LPARAM)hwnd);

        if (iNewISel == -2) 
        {
            //
            // Don't move the selection...
            //
            return;
        }

        if (iNewISel != -1) 
        {
            //
            // Jump directly to the item provided by the app
            //
            goto TrackKeyDown;
        }

        //
        // else do default processing of the character.
        //
    }

    switch (vKey) 
    {
    //
    // LATER IanJa: not language independent!!!
    // We could use VkKeyScan() to find out which is the '\' key
    // This is VK_OEM_5 '\|' for US English only.
    // Germans, Italians etc. have to type CTRL+^ (etc) for this.
    // This is documented as File Manager behaviour for 3.0, but apparently
    // not for 3.1., although functionality remains. We should still fix it,
    // although German (etc?) '\' is generated with AltGr (Ctrl-Alt) (???)
    //
    case VERKEY_BACKSLASH:  
        //
        // '\' character for US English
        //

        //
        // Check if this is CONTROL-\ ; If so Deselect all items
        //
        if ((wModifiers & CTLDOWN) && (plb->wMultiple != SINGLESEL)) 
        {
            ListBox_SetCaret(plb, FALSE);
            ListBox_ResetWorld(plb, plb->iSelBase, plb->iSelBase, FALSE);

            //
            // And select the current item
            //
            ListBox_SetSelected(plb, plb->iSelBase, TRUE, HILITEANDSEL);
            ListBox_InvertItem(plb, plb->iSelBase, TRUE);

            uEvent = EVENT_OBJECT_SELECTION;
            goto CaretOnAndNotify;
        }

        return;

    case VK_DIVIDE:     
        //
        // NumPad '/' character on enhanced keyboard
        //

        //
        // LATER IanJa: not language independent!!!
        // We could use VkKeyScan() to find out which is the '/' key
        // This is VK_OEM_2 '/?' for US English only.
        // Germans, Italians etc. have to type CTRL+# (etc) for this.
        //
    case VERKEY_SLASH:  
        //
        // '/' character
        //

        //
        // Check if this is CONTROL-/ ; If so select all items
        //
        if ((wModifiers & CTLDOWN) && (plb->wMultiple != SINGLESEL)) 
        {
            ListBox_SetCaret(plb, FALSE);
            ListBox_ResetWorld(plb, -1, -1, TRUE);

            uEvent = EVENT_OBJECT_SELECTIONWITHIN;

CaretOnAndNotify:
            ListBox_SetCaret(plb, TRUE);
            ListBox_Event(plb, uEvent, plb->iSelBase);
            ListBox_NotifyOwner(plb, LBN_SELCHANGE);
        }

        return;

    case VK_F8:

        //
        // The "Add" mode is possible only in Multiselection listboxes...  Get
        // into it via SHIFT-F8...  (Yes, sometimes these UI people are sillier
        // than your "typical dumb user"...)
        //
        if (plb->wMultiple != SINGLESEL && wModifiers == SHIFTDOWN) 
        {
            //
            // We have to make the caret blink! Do something...
            //
            if (plb->fAddSelMode) 
            {
                //
                // Switch off the Caret blinking
                //
                KillTimer(hwnd, IDSYS_CARET);

                //
                // Make sure the caret does not vanish
                //
                ListBox_SetCaret(plb, TRUE);
            } 
            else 
            {
                //
                // Create a timer to make the caret blink
                //
                SetTimer(hwnd, IDSYS_CARET, GetCaretBlinkTime(),
                        ListBox_CareBlinker);
            }

            //
            // Toggle the Add mode flag
            //
            plb->fAddSelMode = (UINT)!plb->fAddSelMode;
        }

        return;

    case VK_SPACE:  
        //
        // Selection key is space
        //
        i = 0;
        fSelectKey = TRUE;

        break;

    case VK_PRIOR:
        if (fExtendedUIComboBoxClosed) 
        {
            //
            // Disable movement keys for TandyT.
            //
            return;
        }

        if (plb->OwnerDraw == OWNERDRAWVAR) 
        {
            i = ListBox_Page(plb, plb->iSelBase, FALSE) - plb->iSelBase;
        } 
        else 
        {
            i = -cItemPageScroll;
        }

        break;

    case VK_NEXT:
        if (fExtendedUIComboBoxClosed) 
        {
            //
            // Disable movement keys for TandyT.
            //
            return;
        }

        if (plb->OwnerDraw == OWNERDRAWVAR) 
        {
            i = ListBox_Page(plb, plb->iSelBase, TRUE) - plb->iSelBase;
        } 
        else 
        {
            i = cItemPageScroll;
        }

        break;

    case VK_HOME:
        if (fExtendedUIComboBoxClosed) 
        {
            //
            // Disable movement keys for TandyT.
            //
            return;
        }

        i = (INT_MIN/2)+1;  // A very big negative number

        break;

    case VK_END:
        if (fExtendedUIComboBoxClosed) 
        {
            //
            // Disable movement keys for TandyT.
            //
            return;
        }

        i = (INT_MAX/2)-1;  // A very big positive number

        break;

    case VK_LEFT:
        if (plb->fMultiColumn) 
        {
            if (plb->fRightAlign
#ifdef USE_MIRRORING
                                 ^ (!!TESTFLAG(GET_EXSTYLE(plb), WS_EX_LAYOUTRTL))

#endif
               )
            {
                goto ReallyRight;
            }

ReallyLeft:
            if (plb->iSelBase / plb->itemsPerColumn == 0) 
            {
                i = 0;
            } 
            else 
            {
                i = -plb->itemsPerColumn;
            }

            break;
        }

        if (hScrollBar) 
        {
            goto HandleHScrolling;
        } 
        else 
        {
            //
            // Fall through and handle this as if the up arrow was pressed.
            //
            vKey = VK_UP;
        }

        //
        // Fall through
        //

    case VK_UP:
        if (fExtendedUIComboBoxClosed)
        {
            //
            // Disable movement keys for TandyT.
            //
            return;
        }

        i = -1;

        break;

    case VK_RIGHT:
        if (plb->fMultiColumn) 
        {
            if (plb->fRightAlign
#ifdef USE_MIRRORING
                                 ^ (!!TESTFLAG(GET_EXSTYLE(plb), WS_EX_LAYOUTRTL))

#endif
               )
            {
                goto ReallyLeft;
            }

ReallyRight:
            if (plb->iSelBase / plb->itemsPerColumn == plb->cMac / plb->itemsPerColumn) 
            {
                i = 0;
            } 
            else 
            {
                i = plb->itemsPerColumn;
            }

            break;
        }

        if (hScrollBar) 
        {
HandleHScrolling:
            PostMessage(hwnd, WM_HSCROLL,
                    (vKey == VK_RIGHT ? SB_LINEDOWN : SB_LINEUP), 0L);
            return;
        } 
        else 
        {
            //
            // Fall through and handle this as if the down arrow was
            // pressed.
            //
            vKey = VK_DOWN;
        }

        //
        // Fall through
        //

    case VK_DOWN:
        if (fExtendedUIComboBoxClosed) 
        {
            //
            // If the combo box is closed, down arrow should open it.
            //
            if (!pcbox->fLBoxVisible) 
            {
                //
                // If the listbox isn't visible, just show it
                //
                ComboBox_ShowListBoxWindow(pcbox, TRUE);
            }

            return;
        }

        i = 1;

        break;

    case VK_ESCAPE:
    case VK_RETURN:
        if (!fDropDownComboBox || !pcbox->fLBoxVisible)
        {
            return;
        }

        //
        // |  If this is a dropped listbox for a combobox and the ENTER  |
        // |  key is pressed, close up the listbox, so FALLTHRU          |
        // V                                                             V
        //

    case VK_F4:
        if (fDropDownComboBox && !pcbox->fExtendedUI) 
        {
            //
            // If we are a dropdown combo box/listbox we want to process
            // this key.  BUT for TandtT, we don't do anything on VK_F4 if we
            // are in extended ui mode.
            //
            if (!pcbox->fLBoxVisible) 
            {
                //
                // If the listbox isn't visible, just show it
                //
                ComboBox_ShowListBoxWindow(pcbox, (vKey != VK_ESCAPE));
            } 
            else 
            {
                //
                // Ok, the listbox is visible.  So hide the listbox window.
                //
                ComboBox_HideListBoxWindow(pcbox, TRUE, (vKey != VK_ESCAPE));
            }
        }

        //
        // Fall through to the return
        //

    default:
        return;
    }

    //
    // Find out what the new selection should be
    //
    iNewISel = ListBox_IncrementISel(plb, plb->iSelBase, i);

    if (plb->wMultiple == SINGLESEL) 
    {
        if (plb->iSel == iNewISel) 
        {
            //
            // If we are single selection and the keystroke is moving us to an
            // item which is already selected, we don't have to do anything...
            //
            return;
        }

        uEvent = EVENT_OBJECT_SELECTION;

        plb->iTypeSearch = 0;
        if ((vKey == VK_UP || vKey == VK_DOWN) &&
                !ListBox_IsSelected(plb, plb->iSelBase, HILITEONLY)) 
        {
            //
            // If the caret is on an unselected item and the user just hits the
            // up or down arrow key (ie. with no shift or ctrl modifications),
            // then we will just select the item the cursor is at. This is
            // needed for proper behavior in combo boxes but do we always want
            // to run this code??? Note that this is only used in single
            // selection list boxes since it doesn't make sense in the
            // multiselection case. Note that an LB_KEYDOWN message must not be
            // checked here because the vKey will be an item number not a
            // VK_and we will goof. Thus, trackkeydown label is below this to
            // fix a bug caused by it being above this...
            //
            iNewISel = (plb->iSelBase == -1) ? 0 : plb->iSelBase;
        }
    }

TrackKeyDown:

    ListBox_SetISelBase(plb, iNewISel);

    ListBox_SetCaret(plb, FALSE);

    if (wModifiers & SHIFTDOWN) 
    {
        //
        // Check if iMouseDown is un-initialised
        //
        if (plb->iMouseDown == -1)
        {
            plb->iMouseDown = iNewISel;
        }

        if (plb->iLastMouseMove == -1)
        {
            plb->iLastMouseMove = iNewISel;
        }

        //
        // Check if we are in ADD mode
        //
        if (plb->fAddSelMode) 
        {
            //
            // Preserve all the pre-existing selections except the
            // ones connected with the last anchor point; If the last
            // Preserve all the previous selections
            //

            //
            // Deselect only the selection connected with the last
            // anchor point; If the last anchor point is associated
            // with de-selection, then do not do it
            //

            if (!plb->fNewItemState)
            {
                plb->iLastMouseMove = plb->iMouseDown;
            }

            //
            // We haven't done anything here because, ListBox_BlockHilite()
            // will take care of wiping out the selection between
            // Anchor point and iLastMouseMove and select the block
            // between anchor point and current cursor location
            //
        } 
        else 
        {
            //
            // We are not in ADD mode
            //

            //
            // Remove all selections except between the anchor point
            // and last mouse move because it will be taken care of in
            // ListBox_BlockHilite
            //
            ListBox_ResetWorld(plb, plb->iMouseDown, plb->iLastMouseMove, FALSE);
        }

        uEvent = EVENT_OBJECT_SELECTIONWITHIN;

        //
        // ListBox_BlockHilite takes care to deselect the block between
        // the anchor point and iLastMouseMove and select the block
        // between the anchor point and the current cursor location
        //

        //
        // Toggle all items to the same selection state as the item
        // item at the anchor point) from the anchor point to the
        // current cursor location.
        //
        plb->fNewItemState = ListBox_IsSelected(plb, plb->iMouseDown, SELONLY);
        ListBox_BlockHilite(plb, iNewISel, TRUE);

        plb->iLastMouseMove = iNewISel;

        //
        // Preserve the existing anchor point
        //
    } 
    else 
    {
        //
        // Check if this is in ADD mode
        //
        if ((plb->fAddSelMode) || (plb->wMultiple == MULTIPLESEL)) 
        {
            //
            // Preserve all pre-exisiting selections
            //
            if (fSelectKey) 
            {
                //
                // Toggle the selection state of the current item
                //
                plb->fNewItemState = !ListBox_IsSelected(plb, iNewISel, SELONLY);
                ListBox_SetSelected(plb, iNewISel, plb->fNewItemState, HILITEANDSEL);

                ListBox_InvertItem(plb, iNewISel, plb->fNewItemState);

                //
                // Set the anchor point at the current location
                //
                plb->iLastMouseMove = plb->iMouseDown = iNewISel;
                uEvent = (plb->fNewItemState ? EVENT_OBJECT_SELECTIONADD :
                        EVENT_OBJECT_SELECTIONREMOVE);
            }
        } 
        else 
        {
            //
            // We are NOT in ADD mode
            //

            //
            // Remove all existing selections except iNewISel, to
            // avoid flickering.
            //
            ListBox_ResetWorld(plb, iNewISel, iNewISel, FALSE);

            //
            // Select the current item
            //
            ListBox_SetSelected(plb, iNewISel, TRUE, HILITEANDSEL);
            ListBox_InvertItem(plb, iNewISel, TRUE);

            //
            // Set the anchor point at the current location
            //
            plb->iLastMouseMove = plb->iMouseDown = iNewISel;
            uEvent = EVENT_OBJECT_SELECTION;
        }
    }

    //
    //  Move the cursor to the new location
    //
    ListBox_InsureVisible(plb, iNewISel, FALSE);
    ListBox_ShowHideScrollBars(plb);

    ListBox_SetCaret(plb, TRUE);

    if (uEvent) 
    {
        ListBox_Event(plb, uEvent, iNewISel);
    }

    //
    // Should we notify our parent?
    //
    if (plb->fNotify) 
    {
        if (fDropDownComboBox && pcbox->fLBoxVisible) 
        {
            //
            // If we are in a drop down combo box/listbox and the listbox is
            // visible, we need to set the fKeyboardSelInListBox bit so that the
            // combo box code knows not to hide the listbox since the selchange
            // message is caused by the user keyboarding through...
            //
            pcbox->fKeyboardSelInListBox = TRUE;
            plb->iLastSelection = iNewISel;
        }

        ListBox_NotifyOwner(plb, LBN_SELCHANGE);
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_Compare
//
// Is lpstr1 equal/prefix/less-than/greater-than lsprst2 (case-insensitive) ?
// 
// LATER IanJa: this assume a longer string is never a prefix of a longer one.
// Also assumes that removing 1 or more characters from the end of a string will
// give a string tahs sort before the original.  These assumptions are not valid
// for all languages.  We nedd better support from NLS. (Consider French
// accents, Spanish c/ch, ligatures, German sharp-s/SS, etc.)
//
INT ListBox_Compare(LPCWSTR pwsz1, LPCWSTR pwsz2, DWORD dwLocaleId)
{
    UINT len1 = wcslen(pwsz1);
    UINT len2 = wcslen(pwsz2);
    INT result;

    //
    // CompareStringW returns:
    //  1 = pwsz1  <  pwsz2
    //  2 = pwsz1  == pwsz2
    //  3 = pwsz1  >  pwsz2
    //
    result = CompareStringW((LCID)dwLocaleId, NORM_IGNORECASE,
            pwsz1, min(len1,len2), pwsz2, min(len1, len2));

    if (result == CSTR_LESS_THAN) 
    {
       return LT;
    } 
    else if (result == CSTR_EQUAL) 
    {
        if (len1 == len2) 
        {
            return EQ;
        } 
        else if (len1 < len2) 
        {
            //
            // LATER IanJa: should not assume shorter string is a prefix
            // Spanish "c" and "ch", ligatures, German sharp-s/SS etc.
            //
            return PREFIX;
        }
    }

    return GT;
}


//---------------------------------------------------------------------------//
//
// Listbox_FindStringHandler
//
// Scans for a string in the listbox prefixed by or equal to lpstr.
// For OWNERDRAW listboxes without strings and without the sort style, we
// try to match the long app supplied values.
//
INT Listbox_FindStringHandler(PLBIV plb, LPWSTR lpstr, INT sStart, INT code, BOOL fWrap)
{
    //
    // Search for a prefix match (case-insensitive equal/prefix)
    // sStart == -1 means start from beginning, else start looking at sStart+1
    // assumes cMac > 0.
    //
    INT sInd;       // index of string
    INT sStop;      // index to stop searching at
    lpLBItem pRg;
    INT sortResult;

    //
    // Owner-Draw version of pRg
    //
    #define pODRg ((lpLBODItem)pRg)

    COMPAREITEMSTRUCT cis;
    LPWSTR listboxString;

    
    if (plb->fHasStrings && (!lpstr || !*lpstr))
    {
        return LB_ERR;
    }

    if (!plb->fHasData) 
    {
        TraceMsg(TF_STANDARD, "Listbox_FindStringHandler called on NODATA lb");

        return LB_ERR;
    }

    if ((sInd = sStart + 1) >= plb->cMac)
    {
        sInd = (fWrap ? 0 : plb->cMac - 1);
    }

    sStop = (fWrap ? sInd : 0);

    //
    // If at end and no wrap, stop right away
    //
    if (((sStart >= plb->cMac - 1) && !fWrap) || (plb->cMac < 1)) 
    {
        return LB_ERR;
    }

    //
    // Apps could pass in an invalid sStart like -2 and we would blow up.
    // Win 3.1 would not so we need to fixup sInd to be zero
    //
    if (sInd < 0)
    {
        sInd = 0;
    }

    pRg = (lpLBItem)(plb->rgpch);

    do 
    {
        if (plb->fHasStrings) 
        {
            //
            // Searching for string matches.
            //
            listboxString = (LPWSTR)((LPBYTE)plb->hStrings + pRg[sInd].offsz);

            if (code == PREFIX &&
                listboxString &&
                *lpstr != TEXT('[') &&
                *listboxString == TEXT('[')) 
            {
                //
                // If we are looking for a prefix string and the first items
                // in this string are [- then we ignore them.  This is so
                // that in a directory listbox, the user can goto drives
                // by selecting the drive letter.
                //
                listboxString++;

                if (*listboxString == TEXT('-'))
                {
                    listboxString++;
                }
            }

            if (ListBox_Compare(lpstr, listboxString, plb->dwLocaleId) <= code) 
            {
               goto FoundIt;
            }

        } 
        else 
        {
            if (plb->fSort) 
            {
                //
                // Send compare item messages to the parent for sorting
                //
                cis.CtlType = ODT_LISTBOX;
                cis.CtlID = GetDlgCtrlID(plb->hwnd);
                cis.hwndItem = plb->hwnd;
                cis.itemID1 = (UINT)-1;
                cis.itemData1 = (ULONG_PTR)lpstr;
                cis.itemID2 = (UINT)sInd;
                cis.itemData2 = pODRg[sInd].itemData;
                cis.dwLocaleId = plb->dwLocaleId;

                sortResult = (INT)SendMessage(plb->hwndParent, WM_COMPAREITEM,
                        cis.CtlID, (LPARAM)&cis);


                if (sortResult == -1) 
                {
                   sortResult = LT;
                } 
                else if (sortResult == 1) 
                {
                   sortResult = GT;
                } 
                else 
                {
                   sortResult = EQ;
                }

                if (sortResult <= code) 
                {
                    goto FoundIt;
                }
            } 
            else 
            {
                //
                // Searching for app supplied long data matches.
                //
                if ((ULONG_PTR)lpstr == pODRg[sInd].itemData)
                {
                    goto FoundIt;
                }
            }
        }

        //
        // Wrap round to beginning of list
        //
        if (++sInd == plb->cMac)
        {
            sInd = 0;
        }
    } 
    while (sInd != sStop);

    sInd = -1;

FoundIt:
    return sInd;
}


//---------------------------------------------------------------------------//
void ListBox_CharHandler(PLBIV plb, UINT inputChar, BOOL fAnsi)
{
    INT iSel;
    BOOL fControl;

    if (plb->cMac == 0 || plb->fMouseDown) 
    {
        //
        // Get out if we are in the middle of mouse routines or if we have no
        // items in the listbox, we just return without doing anything.
        //
        return;
    }

    fControl = (GetKeyState(VK_CONTROL) < 0);

    switch (inputChar) 
    {
    case VK_ESCAPE:
        plb->iTypeSearch = 0;
        if (plb->pszTypeSearch)
        {
            plb->pszTypeSearch[0] = 0;
        }

        break;

    case VK_BACK:
        if (plb->iTypeSearch) 
        {
            plb->pszTypeSearch[plb->iTypeSearch--] = 0;
            if (plb->fSort) 
            {
                iSel = -1;
                goto TypeSearch;
            }
        }

        break;

    case VK_SPACE:
        if (plb->fAddSelMode || plb->wMultiple == MULTIPLESEL)
        {
            break;
        }
        //
        // Otherwise, for single/extended selection listboxes not in add
        // selection mode, let the  space go thru as a type search character
        //

        //
        // FALL THRU
        //
    default:

        //
        // Move selection to first item beginning with the character the
        // user typed.  We don't want do this if we are using owner draw.
        //
        if (fAnsi && IsDBCSLeadByteEx(CP_ACP, (BYTE)inputChar)) 
        {
            WCHAR wch;
            LPWSTR lpwstr = &wch;

            inputChar = DbcsCombine(plb->hwnd, (BYTE)inputChar);
            if (inputChar == 0) 
            {
                TraceMsg(TF_STANDARD, "ListBox_CharHandler: cannot combine two DBCS. LB=0x%02x", inputChar);

                break;
            }

            //
            // If it is DBCS, let's ignore the ctrl status.
            //
            fControl = FALSE;

            //
            // Convert DBCS to UNICODE.
            // Note: Leading byte is in the low byte, trailing byte is in high byte.
            // Let's assume Little Endian CPUs only, so inputChar can directly be
            // input for MBSToWCSEx as an ANSI string.
            //
            if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPCSTR)&inputChar, 2, lpwstr, 1) == 0) 
            {
                TraceMsg(TF_STANDARD, "ListBox_CharHandler: cannot convert 0x%04x to UNICODE.", inputChar);

                break;
            }

            inputChar = wch;
        }

        if (plb->fHasStrings) 
        {
            //
            // Incremental Type Search processing
            //
            // update szTypeSearch string and then move to the first item from
            // the current selection whose prefix matches szTypeSearch
            //
            // the szTypeSearch will continue to grow until a "long enough"
            // gap between key entries is encountered -- at which point any
            // more searching will start over
            //

            //
            // Undo CONTROL-char to char
            //
            if (fControl && inputChar < 0x20)
            {
                inputChar += 0x40;
            }

            if (plb->iTypeSearch == MAX_TYPESEARCH) 
            {
                MessageBeep(0);

                break;
            }

            iSel = -1;

            if (plb->pszTypeSearch == NULL)
            {
                plb->pszTypeSearch = (LPWSTR)ControlAlloc(GetProcessHeap(), sizeof(WCHAR) * (MAX_TYPESEARCH + 1));
            }

            if (plb->pszTypeSearch == NULL) 
            {
                MessageBeep(0);

                break;
            }

            plb->pszTypeSearch[plb->iTypeSearch++] = (WCHAR) inputChar;
            plb->pszTypeSearch[plb->iTypeSearch]   = 0;

TypeSearch:
            if (plb->fSort) 
            {
                //
                // Set timer to determine when to kill incremental searching
                //
                SetTimer(plb->hwnd, IDSYS_LBSEARCH,
                               GetDoubleClickTime()*4, NULL);
            } 
            else 
            {
                //
                // If this is not a sorted listbox, no incremental search.
                //
                plb->iTypeSearch = 0;
                iSel = plb->iSelBase;
            }

            //
            // Search for the item beginning with the given character starting
            // at iSel+1.  We will wrap the search to the beginning of the
            // listbox if we don't find the item.   If SHIFT is down and we are
            // a multiselection lb, then the item's state will be set to
            // plb->fNewItemState according to the current mode.
            //
            iSel = Listbox_FindStringHandler(plb, plb->pszTypeSearch, iSel, PREFIX, TRUE);
            if (iSel == -1) 
            {
                //
                // no match found -- check for prefix match
                // (i.e. "p" find FIRST item that starts with 'p',
                //       "pp" find NEXT item that starts with 'p')
                //
                if(plb->iTypeSearch)
                {
                    plb->iTypeSearch--;
                    if ((plb->iTypeSearch == 1) && (plb->pszTypeSearch[0] == plb->pszTypeSearch[1]))
                    {
                        plb->pszTypeSearch[1] = 0;
                        iSel = Listbox_FindStringHandler(plb, plb->pszTypeSearch, plb->iSelBase, PREFIX, TRUE);
                    }
                }
            }

            //
            // if match is found -- select it
            //
            if (iSel != -1)
            {
CtlKeyInput:
                ListBox_KeyInput(plb, LB_KEYDOWN, iSel);

            }
        } 
        else 
        {
            HWND hwndParent = plb->hwndParent;

            if (hwndParent != NULL) 
            {
                if(fAnsi)
                {
                    iSel = (INT)SendMessageA(hwndParent, WM_CHARTOITEM,
                        MAKELONG(inputChar, plb->iSelBase), (LPARAM)plb->hwnd);
                }
                else
                {
                    iSel = (INT)SendMessageW(hwndParent, WM_CHARTOITEM,
                        MAKELONG(inputChar, plb->iSelBase), (LPARAM)plb->hwnd);
                }
            } 
            else
            {
                iSel = -1;
            }

            if (iSel != -1 && iSel != -2)
            {
                goto CtlKeyInput;
            }
        }

        break;
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_GetSelItemsHandler
//
// effects: For multiselection listboxes, this returns the total number of
// selection items in the listbox if fCountOnly is true.  or it fills an array
// (lParam) with the items numbers of the first wParam selected items.
//
int ListBox_GetSelItemsHandler(PLBIV plb, BOOL fCountOnly, int wParam, LPINT lParam)
{
    int i;
    int itemsselected = 0;

    if (plb->wMultiple == SINGLESEL)
    {
        return LB_ERR;
    }

    for (i = 0; i < plb->cMac; i++) 
    {
        if (ListBox_IsSelected(plb, i, SELONLY)) 
        {
            if (!fCountOnly) 
            {
                if (itemsselected < wParam)
                {
                    *lParam++ = i;
                }
                else 
                {
                    //
                    // That's all the items we can fit in the array.
                    //
                    return itemsselected;
                }
            }

            itemsselected++;
        }
    }

    return itemsselected;
}


//---------------------------------------------------------------------------//
//
// ListBox_SetRedraw
//
// Handle WM_SETREDRAW message
//
void ListBox_SetRedraw(PLBIV plb, BOOL fRedraw)
{
    if (fRedraw)
    {
        fRedraw = TRUE;
    }

    if (plb->fRedraw != (UINT)fRedraw) 
    {
        plb->fRedraw = !!fRedraw;

        if (fRedraw) 
        {
            ListBox_SetCaret(plb, TRUE);
            ListBox_ShowHideScrollBars(plb);

            if (plb->fDeferUpdate) 
            {
                plb->fDeferUpdate = FALSE;
                RedrawWindow(plb->hwnd, NULL, NULL,
                        RDW_INVALIDATE | RDW_ERASE |
                        RDW_FRAME | RDW_ALLCHILDREN);
            }
        }
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_SetRange
//
// Selects the range of items between i and j, inclusive.
//
void ListBox_SetRange(PLBIV plb, int iStart, int iEnd, BOOL fnewstate)
{
    DWORD temp;
    RECT rc;

    if (iStart > iEnd) 
    {
        temp = iEnd;
        iEnd = iStart;
        iStart = temp;
    }

    //
    // We don't want to loop through items that don't exist.
    //
    iEnd = min(plb->cMac, iEnd);
    iStart = max(iStart, 0);
    if (iStart > iEnd)
    {
        return;
    }

    //
    // iEnd could be equal to MAXINT which is why we test temp and iEnd
    // as DWORDs.
    //
    for (temp = iStart; temp <= (DWORD)iEnd; temp++) 
    {
        if (ListBox_IsSelected(plb, temp, SELONLY) != fnewstate) 
        {
            ListBox_SetSelected(plb, temp, fnewstate, HILITEANDSEL);
            ListBox_GetItemRectHandler(plb, temp, &rc);

            ListBox_InvalidateRect(plb, (LPRECT)&rc, FALSE);
        }
    }

    ASSERT(plb->wMultiple);

    ListBox_Event(plb, EVENT_OBJECT_SELECTIONWITHIN, iStart);
}


//---------------------------------------------------------------------------//
int ListBox_SetCurSelHandler(PLBIV plb, int iSel) 
{

    if (!(plb->wMultiple || iSel < -1 || iSel >= plb->cMac)) 
    {
        ListBox_SetCaret(plb, FALSE);

        if (plb->iSel != -1) 
        {
            //
            // This prevents scrolling when iSel == -1
            //
            if (iSel != -1)
            {
                ListBox_InsureVisible(plb, iSel, FALSE);
            }

            //
            // Turn off old selection
            //
            ListBox_InvertItem(plb, plb->iSel, FALSE);
        }

        if (iSel != -1) 
        {
            ListBox_InsureVisible(plb, iSel, FALSE);
            plb->iSelBase = plb->iSel = iSel;

            //
            // Highlight new selection
            //
            ListBox_InvertItem(plb, plb->iSel, TRUE);
        } 
        else 
        {
            plb->iSel = -1;

            if (plb->cMac)
            {
                plb->iSelBase = min(plb->iSelBase, plb->cMac-1);
            }
            else
            {
                plb->iSelBase = 0;
            }
        }

        //
        // Send both focus and selection events
        //
        if (IsWindowVisible(plb->hwnd) || (GetFocus() == plb->hwnd)) 
        {
            ListBox_Event(plb, EVENT_OBJECT_FOCUS, plb->iSelBase);
            ListBox_Event(plb, EVENT_OBJECT_SELECTION, plb->iSel);
        }

        ListBox_SetCaret(plb, TRUE);

        return plb->iSel;
    }

    return LB_ERR;
}


//---------------------------------------------------------------------------//
//
// ListBox_SetItemDataHandler
//
// Makes the item at index contain the data given.
//
int ListBox_SetItemDataHandler(PLBIV plb, int index, LONG_PTR data)
{
    LPSTR lpItemText;

    //
    // v-ronaar: fix bug #25865, don't allow negative indices!
    //
    if ((index != -1) && ((UINT) index >= (UINT) plb->cMac)) 
    {
        TraceMsg(TF_STANDARD, "ListBox_SetItemDataHandler with invalid index %x", index);

        return LB_ERR;
    }

    //
    // No-data listboxes just ignore all LB_SETITEMDATA calls
    //
    if (!plb->fHasData) 
    {
        return TRUE;
    }

    lpItemText = (LPSTR)plb->rgpch;

    if (index == -1) 
    {
        //
        // index == -1 means set the data to all the items
        //
        if (plb->fHasStrings) 
        {
            for (index = 0; index < plb->cMac; index++) 
            {
                ((lpLBItem)lpItemText)->itemData = data;
                lpItemText += sizeof(LBItem);
            }
        } 
        else 
        {
            for (index = 0; index < plb->cMac; index++) 
            {
                ((lpLBODItem)lpItemText)->itemData = data;
                lpItemText += sizeof(LBODItem);
            }
        }

        return TRUE;
    }

    if (plb->fHasStrings) 
    {
        lpItemText = (LPSTR)(lpItemText + (index * sizeof(LBItem)));
        ((lpLBItem)lpItemText)->itemData = data;
    } 
    else 
    {
        lpItemText = (LPSTR)(lpItemText + (index * sizeof(LBODItem)));
        ((lpLBODItem)lpItemText)->itemData = data;
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
void ListBox_CheckRedraw(PLBIV plb, BOOL fConditional, INT sItem)
{
    if (fConditional && plb->cMac &&
            (sItem > (plb->iTop + ListBox_CItemInWindow(plb, TRUE))))
    {
        return;
    }

    //
    // Don't do anything if the parent is not visible.
    //
    ListBox_InvalidateRect(plb, (LPRECT)NULL, TRUE);
}


//---------------------------------------------------------------------------//
void ListBox_CaretDestroy(PLBIV plb)
{
    //
    // We're losing the focus.  Act like up clicks are happening so we release
    // capture, set the current selection, notify the parent, etc.
    //
    if (plb->fCaptured)
    {
        //
        // If we have the capture and we lost the focus, that means we already
        // changed the selection and we have to notify also the parent about
        // this. So we need to add also the LBUP_SUCCESS flag in this case.
        //
        ListBox_ButtonUp(plb, LBUP_RELEASECAPTURE | LBUP_NOTIFY |
            (plb->fMouseDown ? LBUP_SUCCESS : 0));
    }

    if (plb->fAddSelMode) 
    {
        //
        // Switch off the Caret blinking
        //
        KillTimer(plb->hwnd, IDSYS_CARET);

        //
        // Make sure the caret goes away
        //
        ListBox_SetCaret(plb, FALSE);
        plb->fAddSelMode = FALSE;
    }

    plb->fCaret = FALSE;
}


//---------------------------------------------------------------------------//
LONG ListBox_SetSelHandler(PLBIV plb, BOOL fSelect, INT iSel)
{
    INT sItem;
    RECT rc;
    UINT uEvent = 0;

    //
    // Bug 17656. WinZip's accelerator key for 'DeSelect All' sends a LB_SETSEL
    // message with lparam = 0x0000ffff instead of 0xffffffff(-1). If iSel
    // is equal to  0x0000ffff and there are less than 0xffff elements in the
    // list we set iSel equal to 0xffffffff.
    //
    if ((iSel == (UINT)0xffff) && (iSel >= plb->cMac)) 
    {
        iSel = -1;

        TraceMsg(TF_STANDARD, "Sign extending iSel=0xffff to 0xffffffff");
    }


    if ((plb->wMultiple == SINGLESEL) || (iSel != -1 && iSel >= plb->cMac)) 
    {
        TraceMsg(TF_STANDARD, "Invalid index");

        return LB_ERR;
    }

    ListBox_SetCaret(plb, FALSE);

    if (iSel == -1)
    {
        //
        // Set/clear selection from all items if -1
        //
        for (sItem = 0; sItem < plb->cMac; sItem++) 
        {
            if (ListBox_IsSelected(plb, sItem, SELONLY) != fSelect) 
            {
                ListBox_SetSelected(plb, sItem, fSelect, HILITEANDSEL);

                if (ListBox_GetItemRectHandler(plb, sItem, &rc)) 
                {
                    ListBox_InvalidateRect(plb, &rc, FALSE);
                }
            }
        }

        ListBox_SetCaret(plb, TRUE);
        uEvent = EVENT_OBJECT_SELECTIONWITHIN;

    } 
    else 
    {
        if (fSelect) 
        {
            //
            // Check if the item if fully hidden and scroll it into view if it
            // is.  Note that we don't want to scroll partially visible items
            // into full view because this breaks the shell...
            //
            ListBox_InsureVisible(plb, iSel, TRUE);
            plb->iSelBase = plb->iSel = iSel;

            plb->iMouseDown = plb->iLastMouseMove = iSel;
            uEvent = EVENT_OBJECT_FOCUS;
        } 
        else 
        {
            uEvent = EVENT_OBJECT_SELECTIONREMOVE;
        }

        ListBox_SetSelected(plb, iSel, fSelect, HILITEANDSEL);

        //
        // Note that we set the caret on bit directly so that we avoid flicker
        // when drawing this item.  ie.  We turn on the caret, redraw the item and
        // turn it back on again.
        //
        if (!fSelect && plb->iSelBase != iSel) 
        {
            ListBox_SetCaret(plb, TRUE);
        } 
        else if (plb->fCaret) 
        {
            plb->fCaretOn = TRUE;
        }

        if (ListBox_GetItemRectHandler(plb, iSel, &rc)) 
        {
            ListBox_InvalidateRect(plb, &rc, FALSE);
        }
    }

    if (IsWindowVisible(plb->hwnd) || (GetFocus() == plb->hwnd)) 
    {
        if (uEvent == EVENT_OBJECT_FOCUS) 
        {
            ListBox_Event(plb, uEvent, plb->iSelBase);
            uEvent = EVENT_OBJECT_SELECTION;
        }

        ListBox_Event(plb, uEvent, iSel);
    }

    return 0;
}


//---------------------------------------------------------------------------//
//
// ListBox_FillDrawItem
//
// This fills the draw item struct with some constant data for the given
// item.  The caller will only have to modify a small part of this data
// for specific needs.
//
void ListBox_FillDrawItem(PLBIV plb, INT item, UINT itemAction, UINT itemState, LPRECT lprect)
{
    DRAWITEMSTRUCT dis;

    //
    // Fill the DRAWITEMSTRUCT with the unchanging constants
    //

    dis.CtlType = ODT_LISTBOX;
    dis.CtlID = GetDlgCtrlID(plb->hwnd);

    //
    // Use -1 if an invalid item number is being used.  This is so that the app
    // can detect if it should draw the caret (which indicates the lb has the
    // focus) in an empty listbox
    //
    dis.itemID = (UINT)(item < plb->cMac ? item : -1);
    dis.itemAction = itemAction;
    dis.hwndItem = plb->hwnd;
    dis.hDC = plb->hdc;
    dis.itemState = itemState |
            (UINT)((GET_STYLE(plb)&WS_DISABLED) ? ODS_DISABLED : 0);

    if (TESTFLAG(GET_EXSTYLE(plb), WS_EXP_UIFOCUSHIDDEN)) 
    {
        dis.itemState |= ODS_NOFOCUSRECT;
    }

    if (TESTFLAG(GET_EXSTYLE(plb), WS_EXP_UIACCELHIDDEN)) 
    {
        dis.itemState |= ODS_NOACCEL;
    }

    //
    // Set the app supplied data
    //
    if (!plb->cMac || !plb->fHasData) 
    {
        //
        // If no strings or no items, just use 0 for data.  This is so that we
        // can display a caret when there are no items in the listbox.
        // 
        // Lazy-eval listboxes of course have no data to pass - only itemID.
        //
        dis.itemData = 0L;
    } 
    else 
    {
        dis.itemData = ListBox_GetItemDataHandler(plb, item);
    }

    CopyRect(&dis.rcItem, lprect);

    //
    // Set the window origin to the horizontal scroll position.  This is so that
    // text can always be drawn at 0,0 and the view region will only start at
    // the horizontal scroll offset. We pass this as wParam
    //

    SendMessage(plb->hwndParent, WM_DRAWITEM, dis.CtlID, (LPARAM)&dis);
}


//---------------------------------------------------------------------------//
//
// ListBox_BlockHilite
//
// In Extended selection mode for multiselection listboxes, when
// mouse is draged to a new position, the range being marked should be
// properly sized(parts of which will be highlighted/dehighlighted).
// NOTE: This routine assumes that iSelFromPt and LasMouseMove are not
// equal because only in that case this needs to be called;
// NOTE: This routine calculates the region whose display attribute is to
// be changed in an optimised way. Instead of de-highlighting the
// the old range completely and highlight the new range, it omits
// the regions that overlap and repaints only the non-pverlapping
// area.
// fKeyBoard = TRUE if this is called for Keyboard interface
// FALSE if called from Mouse interface routines
//
void ListBox_BlockHilite(PLBIV plb, INT iSelFromPt, BOOL fKeyBoard)
{
    INT sCurPosOffset;
    INT sLastPosOffset;
    INT sHiliteOrSel;
    BOOL fUseSelStatus;
    BOOL DeHiliteStatus;

    if (fKeyBoard) 
    {
        //
        // Set both Hilite and Selection states
        //
        sHiliteOrSel = HILITEANDSEL;

        //
        // Do not use the Selection state while de-hiliting
        //
        fUseSelStatus = FALSE;
        DeHiliteStatus = FALSE;
    } 
    else 
    {
        //
        // Set/Reset only the Hilite state
        //
        sHiliteOrSel = HILITEONLY;

        //
        // Use the selection state for de-hilighting
        //
        fUseSelStatus = TRUE;
        DeHiliteStatus = plb->fNewItemState;
    }

    //
    // The idea of the routine is to :
    //  1.  De-hilite the old range (iMouseDown to iLastMouseDown)  and
    //  2.  Hilite the new range (iMouseDwon to iSelFromPt)
    //

    //
    // Offset of current mouse position from the anchor point
    //
    sCurPosOffset = plb->iMouseDown - iSelFromPt;

    //
    // Offset of last mouse position from the anchor point
    //
    sLastPosOffset = plb->iMouseDown - plb->iLastMouseMove;

    //
    // Check if both current position and last position lie on the same
    // side of the anchor point.
    //
    if ((sCurPosOffset * sLastPosOffset) >= 0) 
    {
        //
        // Yes they are on the same side; So, highlight/dehighlight only
        // the difference.
        //
        if (abs(sCurPosOffset) > abs(sLastPosOffset)) 
        {
            ListBox_AlterHilite(plb, plb->iLastMouseMove, iSelFromPt,
                    plb->fNewItemState, sHiliteOrSel, FALSE);
        } 
        else 
        {
            ListBox_AlterHilite(plb, iSelFromPt, plb->iLastMouseMove, DeHiliteStatus,
                    sHiliteOrSel, fUseSelStatus);
        }
    } 
    else 
    {
        ListBox_AlterHilite(plb, plb->iMouseDown, plb->iLastMouseMove,
                DeHiliteStatus, sHiliteOrSel, fUseSelStatus);

        ListBox_AlterHilite(plb, plb->iMouseDown, iSelFromPt,
                plb->fNewItemState, sHiliteOrSel, FALSE);
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_AlterHilite
//
// Changes the hilite state of (i..j] (ie. excludes i, includes j in case
// you've forgotten this notation) to fHilite. It inverts this changes
// the hilite state.
//
// OpFlags:  
//      HILITEONLY      Only change the display state of the items
//      SELONLY         Only Change the selection state of the items
//      HILITEANDSELECT Do both.
//
// fHilite:
//      HILITE/TRUE
//      DEHILITE/FALSE
//
// fSelStatus:
//      if TRUE, use the selection state of the item to hilite/dehilite
//      if FALSE, use the fHilite parameter to hilite/dehilite
//
void ListBox_AlterHilite(PLBIV plb, INT i, INT j, BOOL fHilite, INT OpFlags, BOOL fSelStatus)
{
    INT low;
    INT high;
    INT sLastInWindow;
    BOOL fCaretOn;
    BOOL fSelected;

    sLastInWindow = plb->iTop + ListBox_CItemInWindow(plb, TRUE);
    sLastInWindow = min(sLastInWindow, plb->cMac - 1);
    high = max(i, j) + 1;

    if (fCaretOn = plb->fCaretOn) 
    {
        ListBox_SetCaret(plb, FALSE);
    }

    for (low = min(i, j); low < high; low++) 
    {
        if (low != i) 
        {
            if (OpFlags & HILITEONLY) 
            {
                if (fSelStatus) 
                {
                    fSelected = ListBox_IsSelected(plb, low, SELONLY);
                } 
                else 
                {
                    fSelected = fHilite;
                }

                if (ListBox_IsSelected(plb, low, HILITEONLY) != fSelected) 
                {
                    if (plb->iTop <= low && low <= sLastInWindow) 
                    {
                        //
                        // Invert the item only if it is visible
                        //
                        ListBox_InvertItem(plb, low, fSelected);
                    }

                    ListBox_SetSelected(plb, low, fSelected, HILITEONLY);
                }
            }

            if (OpFlags & SELONLY) 
            {
                ListBox_SetSelected(plb, low, fHilite, SELONLY);
            }
        }
    }

    if (fCaretOn) 
    {
        ListBox_SetCaret(plb, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\imagestream.cpp ===
#include "ctlspriv.h"
#include "image.h"
HRESULT Stream_WriteBitmap(LPSTREAM pstm, HBITMAP hbm, int cBitsPerPixel);
HRESULT Stream_ReadBitmap(LPSTREAM pstm, int iExpectedBitdepth, HBITMAP* hbmp, PVOID* pvBits);

HRESULT CImageList::_Read(ILFILEHEADER *pilfh, HBITMAP hbmImageI, PVOID pvBits, HBITMAP hbmMaskI)
{
    int i;
    HRESULT hr = Initialize(pilfh->cx, pilfh->cy, pilfh->flags, 1, pilfh->cGrow);

    if (SUCCEEDED(hr))
    {
        // select into DC's before deleting existing bitmaps
        // patch in the bitmaps we loaded
        SelectObject(_hdcImage, hbmImageI);
        DeleteObject(_hbmImage);
        _hbmImage = hbmImageI;
        _pargbImage = (RGBQUAD*)pvBits;
        _clrBlend = CLR_NONE;

        // Same for the mask (if necessary)
        if (_hdcMask) 
        {
            SelectObject(_hdcMask, hbmMaskI);
            DeleteObject(_hbmMask);
            _hbmMask = hbmMaskI;
        }

        _cAlloc = pilfh->cAlloc;

        //
        // Call ImageList_SetBkColor with 0 in piml->_cImage to avoid
        // calling expensive ImageList__ResetBkColor
        //
        _cImage = 0;
        _SetBkColor(pilfh->clrBk);
        _cImage = pilfh->cImage;

        for (i=0; i<NUM_OVERLAY_IMAGES; i++)
            _SetOverlayImage(pilfh->aOverlayIndexes[i], i+1);

    }
    else
    {
        DeleteObject(hbmImageI);
        DeleteObject(hbmMaskI);
    }
    return hr;
}

// Object: Create a 1 strip bitmap from a 4 strip bitmap.
BOOL CreateUplevelBitmap(int cx, int cy, int cCount, BOOL f32bpp, BOOL fMono, HBITMAP* phbmpDest, PVOID* ppvBits)
{
    BOOL fRet = FALSE;

    // src contains a 4 x cx bitmap

    HDC hdcSrc = CreateCompatibleDC(NULL);
    if (hdcSrc)
    {
        HBITMAP hbmpOldSrc = (HBITMAP)SelectObject(hdcSrc, *phbmpDest);

        HDC hdcDest = CreateCompatibleDC(NULL);
        if (hdcDest)
        {
            HBITMAP hbmpDest;
            if (fMono)
            {
                hbmpDest = CreateMonoBitmap(cx, cy * cCount);
            }
            else
            {
                if (f32bpp)
                {
                    hbmpDest = CreateDIB(hdcSrc, cx, cy * cCount, (RGBQUAD**)ppvBits);
                }
                else
                {
                    hbmpDest = CreateCompatibleBitmap(hdcSrc, cx, cy * cCount);
                    if (hbmpDest)
                    {
                        BITMAP bm;
                        GetObject(hbmpDest, sizeof(bm), &bm);
                        *ppvBits = bm.bmBits;
                    }
                }
            }

            if (hbmpDest)
            {
                HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcDest, hbmpDest);

                for (int i = 0; i < cCount; i++)
                {
                    int xSrc = cx * (i % 4);
                    int ySrc = cy * (i / 4);

                    int yDst = cy * i;


                    BitBlt(hdcDest, 0, yDst, cx, cy, hdcSrc, xSrc, ySrc, SRCCOPY);
                }
                fRet = TRUE;

                SelectObject(hdcDest, hbmpOld);

                DeleteObject(*phbmpDest);
                *phbmpDest = hbmpDest;
            }
            DeleteDC(hdcDest);
        }

        SelectObject(hdcSrc, hbmpOldSrc);
        DeleteDC(hdcSrc);
    }

    return fRet;
}



STDMETHODIMP CImageList::LoadEx(DWORD dwFlags, IStream* pstm)
{
    if (pstm == NULL)
        return E_INVALIDARG;

    HRESULT hr = InitGlobals();

    if (SUCCEEDED(hr))
    {
        ENTERCRITICAL;
        ILFILEHEADER ilfh = {0};
        HBITMAP hbmImageI = NULL;
        HBITMAP hbmMaskI = NULL;

        HBITMAP hbmMirroredImage;
        HBITMAP hbmMirroredMask;
        BOOL bMirroredIL = FALSE;

   
        // fist read in the old struct
        hr = pstm->Read(&ilfh, ILFILEHEADER_SIZE0, NULL);

        if (SUCCEEDED(hr) && (ilfh.magic != IMAGELIST_MAGIC ||
                              (ilfh.version != IMAGELIST_VER6 && ilfh.version != IMAGELIST_VER0)))
        {
            hr = E_FAIL;
        }

        if (ilfh.version == IMAGELIST_VER0)
            dwFlags |= ILP_DOWNLEVEL;

        if (ilfh.version == IMAGELIST_VER6)
            dwFlags &= ~ILP_DOWNLEVEL;          // Uplevel, Don't run in compat mode. 

        if (SUCCEEDED(hr))
        {
            PVOID pvBits, pvBitsMirror;
            hbmMaskI = NULL;
            hbmMirroredMask = NULL;
            hr = Stream_ReadBitmap(pstm, (ilfh.flags&ILC_COLORMASK), &hbmImageI, &pvBits);

            if (SUCCEEDED(hr))
            {
                if (dwFlags & ILP_DOWNLEVEL)
                    CreateUplevelBitmap(ilfh.cx, ilfh.cy, ilfh.cAlloc, (ilfh.flags & ILC_COLOR32), FALSE, &hbmImageI, &pvBits);
                if (ilfh.flags & ILC_MASK)
                {
                    hr = Stream_ReadBitmap(pstm, 1, &hbmMaskI, NULL);
                    if (FAILED(hr))
                    {
                        DeleteBitmap(hbmImageI);
                        hbmImageI = NULL;
                    }
                    else if (dwFlags & ILP_DOWNLEVEL)
                    {
                        CreateUplevelBitmap(ilfh.cx, ilfh.cy, ilfh.cAlloc, FALSE, TRUE, &hbmMaskI, NULL);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    // Read in the rest of the struct, new overlay stuff.
                    if (ilfh.flags & ILC_MOREOVERLAY)
                    {
                        hr = pstm->Read((LPBYTE)&ilfh + ILFILEHEADER_SIZE0, sizeof(ilfh) - ILFILEHEADER_SIZE0, NULL);
                        if (SUCCEEDED(hr))
                        {
                            ilfh.flags &= ~ILC_MOREOVERLAY;
                        }
                    }
                    else
                    {
                        // Properly initialize the new stuff since we are not reading it in...
                        for (int i = NUM_OVERLAY_IMAGES_0; i < NUM_OVERLAY_IMAGES; i++)
                            ilfh.aOverlayIndexes[i] = -1;
                    }
                }

                if (SUCCEEDED(hr))
                {
                    if (ilfh.flags & ILC_MIRROR)
                    {
                        ilfh.flags &= ~ILC_MIRROR;
                        bMirroredIL = TRUE;
                        hr = Stream_ReadBitmap(pstm, (ilfh.flags&ILC_COLORMASK), &hbmMirroredImage, &pvBitsMirror);

                        if (SUCCEEDED(hr))
                        {
                            if (dwFlags & ILP_DOWNLEVEL)
                                CreateUplevelBitmap(ilfh.cx, ilfh.cy, ilfh.cAlloc, (ilfh.flags & ILC_COLOR32), FALSE, &hbmMirroredImage, &pvBitsMirror);

                            if (ilfh.flags & ILC_MASK)
                            {
                                hr = Stream_ReadBitmap(pstm, 1, &hbmMirroredMask, NULL);
                                if (FAILED(hr))
                                {
                                    DeleteBitmap(hbmMirroredImage);
                                    hbmMirroredImage = NULL;
                                }
                                else if (dwFlags & ILP_DOWNLEVEL)
                                {
                                    CreateUplevelBitmap(ilfh.cx, ilfh.cy, ilfh.cAlloc, FALSE, TRUE, &hbmMirroredMask, NULL);
                                }
                            }
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = _Read(&ilfh, hbmImageI, pvBits, hbmMaskI);

                        if(SUCCEEDED(hr))
                        {
                            _ScanForAlpha();
                            if (bMirroredIL)
                            {
                                hr = E_OUTOFMEMORY;
                                _pimlMirror = new CImageList();
                                if (_pimlMirror)
                                {
                                    hr = _pimlMirror->_Read(&ilfh, hbmMirroredImage, pvBitsMirror, hbmMirroredMask);
                                    if (SUCCEEDED(hr))
                                        _pimlMirror->_ScanForAlpha();
                                }
                            }
                        }
                    }


                    if (FAILED(hr))
                    {
                        if (hbmImageI)
                            DeleteBitmap(hbmImageI);

                        if (hbmMaskI)
                            DeleteBitmap(hbmMaskI);
                    }
                }
            }
        }

        LEAVECRITICAL;
    }
    
    return hr;
}

BOOL CImageList::_MoreOverlaysUsed()
{
    int i;
    for (i = NUM_OVERLAY_IMAGES_0; i < NUM_OVERLAY_IMAGES; i++)
        if (_aOverlayIndexes[i] != -1)
            return TRUE;
    return FALSE;
}


// Object: Create a 4 strip bitmap from a single strip bitmap.
BOOL CreateDownlevelBitmap(int cx, int cy, int cCount, HDC hdc, HBITMAP hbmp, HBITMAP* hbmpDest)
{
    BOOL fRet = FALSE;
    HDC hdcDest = CreateCompatibleDC(hdc);
    if (hdcDest)
    {
        *hbmpDest = CreateCompatibleBitmap(hdc, 4 * cx, cy * ((cCount / 4) + 1));
        if (*hbmpDest)
        {
            HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcDest, *hbmpDest);

            for (int i = 0; i < cCount; i++)
            {
                int xDest = cx * (i % 4);
                int yDest = cy * (i / 4);

                int ySrc = cy * i;


                BitBlt(hdcDest, xDest, yDest, cx, cy, hdc, 0, ySrc, SRCCOPY);
            }
            fRet = TRUE;

            SelectObject(hdcDest, hbmpOld);
        }
        DeleteDC(hdcDest);
    }

    return fRet;
}

STDMETHODIMP CImageList::SaveEx(DWORD dwFlags, IStream* pstm)
{
    int i;
    ILFILEHEADER ilfh;
    HRESULT hr = S_OK;
    HBITMAP hbmpMask = _hbmMask;
    HBITMAP hbmpImage = _hbmImage;

    if (pstm == NULL)
        return E_INVALIDARG;

    ilfh.magic   = IMAGELIST_MAGIC;
    if (dwFlags == ILP_NORMAL)
        ilfh.version = IMAGELIST_VER6;
    else
        ilfh.version = IMAGELIST_VER0;
    ilfh.cImage  = (SHORT) _cImage;
    ilfh.cAlloc  = (SHORT) _cAlloc;
    ilfh.cGrow   = (SHORT) _cGrow;
    ilfh.cx      = (SHORT) _cx;
    ilfh.cy      = (SHORT) _cy;
    ilfh.clrBk   = _clrBk;
    ilfh.flags   = (SHORT) _flags;

    if (dwFlags == ILP_DOWNLEVEL)
    {
        CreateDownlevelBitmap(_cx, _cy, _cImage, _hdcImage, _hbmImage, &hbmpImage);
        if (_hbmMask)
            CreateDownlevelBitmap(_cx, _cy, _cImage, _hdcMask, _hbmMask, &hbmpMask);
    }

    //
    // Store mirror flags
    //
    if (_pimlMirror)
        ilfh.flags |= ILC_MIRROR;   

    if (_MoreOverlaysUsed())
        ilfh.flags |= ILC_MOREOVERLAY;
    
    for (i=0; i < NUM_OVERLAY_IMAGES; i++)
        ilfh.aOverlayIndexes[i] =  (SHORT) _aOverlayIndexes[i];

    hr = pstm->Write(&ilfh, ILFILEHEADER_SIZE0, NULL);

    if (SUCCEEDED(hr))
    {
        hr = Stream_WriteBitmap(pstm, hbmpImage, 0);

        if (SUCCEEDED(hr))
        {
            if (_hdcMask)
            {
                hr = Stream_WriteBitmap(pstm, hbmpMask, 1);
            }

            if (SUCCEEDED(hr))
            {
                if (ilfh.flags & ILC_MOREOVERLAY)
                    hr = pstm->Write((LPBYTE)&ilfh + ILFILEHEADER_SIZE0, sizeof(ilfh) - ILFILEHEADER_SIZE0, NULL);

                if (_pimlMirror)
                {
                    HBITMAP hbmpImageM = _pimlMirror->_hbmImage;
                    HBITMAP hbmpMaskM = _pimlMirror->_hbmMask;

                    if (dwFlags == ILP_DOWNLEVEL)
                    {
                        CreateDownlevelBitmap(_cx, _cy, _pimlMirror->_cImage, _pimlMirror->_hdcImage, _pimlMirror->_hbmImage, &hbmpImageM);
                        if (_hbmMask)
                            CreateDownlevelBitmap(_cx, _cy, _pimlMirror->_cImage, _pimlMirror->_hdcMask, _pimlMirror->_hbmMask, &hbmpMaskM);
                    }

                    
                    // Don't call pidlMirror's Save, because of the header difference.
                    hr = Stream_WriteBitmap(pstm, hbmpImageM, 0);

                    if (_pimlMirror->_hdcMask)
                    {
                        hr = Stream_WriteBitmap(pstm, hbmpMaskM, 1);
                    }

                    if (hbmpMaskM && (hbmpMaskM != _pimlMirror->_hbmMask))
                        DeleteObject(hbmpMaskM);

                    if (hbmpImageM && (hbmpImageM != _pimlMirror->_hbmImage))
                        DeleteObject(hbmpImageM);
                
                }
            }
        }
    }

    if (hbmpMask && (hbmpMask != _hbmMask))
        DeleteObject(hbmpMask);

    if (hbmpImage && (hbmpImage != _hbmImage))
        DeleteObject(hbmpImage);
    
        
    return hr;
}

STDMETHODIMP CImageList::Load(IStream* pstm)
{
    return LoadEx(ILP_NORMAL, pstm);
}

STDMETHODIMP CImageList::Save(IStream* pstm, int fClearDirty)
{
    return SaveEx(ILP_NORMAL, pstm);
}

HRESULT Stream_WriteBitmap(LPSTREAM pstm, HBITMAP hbm, int cBitsPerPixel)
{
    BOOL fSuccess;
    BITMAP bm;
    int cx, cy;
    BITMAPFILEHEADER bf;
    BITMAPINFOHEADER bi;
    BITMAPINFOHEADER * pbi;
    BYTE * pbuf;
    HDC hdc;
    UINT cbColorTable;
    int cLines;
    int cLinesWritten;
    HRESULT hr = E_INVALIDARG;

    ASSERT(pstm);

    fSuccess = FALSE;
    hdc = NULL;
    pbi = NULL;
    pbuf = NULL;

    if (GetObject(hbm, sizeof(bm), &bm) != sizeof(bm))
        goto Error;

    hdc = GetDC(HWND_DESKTOP);

    cx = bm.bmWidth;
    cy = bm.bmHeight;

    if (cBitsPerPixel == 0)
        cBitsPerPixel = bm.bmPlanes * bm.bmBitsPixel;

    if (cBitsPerPixel <= 8)
        cbColorTable = (1 << cBitsPerPixel) * sizeof(RGBQUAD);
    else
        cbColorTable = 0;

    bi.biSize           = sizeof(bi);
    bi.biWidth          = cx;
    bi.biHeight         = cy;
    bi.biPlanes         = 1;
    bi.biBitCount       = (WORD) cBitsPerPixel;
    bi.biCompression    = BI_RGB;       // RLE not supported!
    bi.biSizeImage      = 0;
    bi.biXPelsPerMeter  = 0;
    bi.biYPelsPerMeter  = 0;
    bi.biClrUsed        = 0;
    bi.biClrImportant   = 0;

    bf.bfType           = BFTYPE_BITMAP;
    bf.bfOffBits        = sizeof(BITMAPFILEHEADER) +
                          sizeof(BITMAPINFOHEADER) + cbColorTable;
    bf.bfSize           = bf.bfOffBits + bi.biSizeImage;
    bf.bfReserved1      = 0;
    bf.bfReserved2      = 0;

    hr = E_OUTOFMEMORY;
    pbi = (BITMAPINFOHEADER *)LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER) + cbColorTable);

    if (!pbi)
        goto Error;

    // Get the color table and fill in the rest of *pbi
    //
    *pbi = bi;
    if (GetDIBits(hdc, hbm, 0, cy, NULL, (BITMAPINFO *)pbi, DIB_RGB_COLORS) == 0)
        goto Error;

    if (cBitsPerPixel == 1)
    {
        ((DWORD *)(pbi+1))[0] = CLR_BLACK;
        ((DWORD *)(pbi+1))[1] = CLR_WHITE;
    }

    pbi->biSizeImage = WIDTHBYTES(cx, cBitsPerPixel) * cy;

    hr = pstm->Write(&bf, sizeof(bf), NULL);
    if (FAILED(hr))
        goto Error;

    hr = pstm->Write(pbi, sizeof(bi) + cbColorTable, NULL);
    if (FAILED(hr))
        goto Error;

    //
    // if we have a DIBSection just write the bits out
    //
    if (bm.bmBits != NULL)
    {
        hr = pstm->Write(bm.bmBits, pbi->biSizeImage, NULL);
        if (FAILED(hr))
            goto Error;

        goto Done;
    }

    // Calculate number of horizontal lines that'll fit into our buffer...
    //
    cLines = CBDIBBUF / WIDTHBYTES(cx, cBitsPerPixel);

    hr = E_OUTOFMEMORY;
    pbuf = (PBYTE)LocalAlloc(LPTR, CBDIBBUF);

    if (!pbuf)
        goto Error;

    for (cLinesWritten = 0; cLinesWritten < cy; cLinesWritten += cLines)
    {
        hr = E_OUTOFMEMORY;
        if (cLines > cy - cLinesWritten)
            cLines = cy - cLinesWritten;

        if (GetDIBits(hdc, hbm, cLinesWritten, cLines,
                pbuf, (BITMAPINFO *)pbi, DIB_RGB_COLORS) == 0)
            goto Error;

        hr = pstm->Write(pbuf, WIDTHBYTES(cx, cBitsPerPixel) * cLines, NULL);
        if (FAILED(hr))
            goto Error;
    }

Done:
    hr = S_OK;

Error:
    if (hdc)
        ReleaseDC(HWND_DESKTOP, hdc);
    if (pbi)
        LocalFree((HLOCAL)pbi);
    if (pbuf)
        LocalFree((HLOCAL)pbuf);

    return hr;
}

HRESULT Stream_ReadBitmap(LPSTREAM pstm, int iExpectedBitdepth, HBITMAP* phbmp, PVOID* ppvBits)
{
    HDC hdc = NULL;
    HBITMAP hbm = NULL;
    BITMAPFILEHEADER bf;
    BITMAPINFOHEADER bi;
    BITMAPINFOHEADER * pbi = NULL;
    BYTE * pbuf=NULL;
    int cBitsPerPixel;
    UINT cbColorTable;
    int cx, cy;
    int cLines, cLinesRead;

    HRESULT hr = pstm->Read(&bf, sizeof(bf), NULL);
    if (FAILED(hr))
        goto Error;

    hr = E_INVALIDARG;
    if (bf.bfType != BFTYPE_BITMAP)
        goto Error;

    hr = pstm->Read(&bi, sizeof(bi), NULL);
    if (FAILED(hr))
        goto Error;

    hr = E_INVALIDARG;
    if (bi.biSize != sizeof(bi))
        goto Error;

    cx = (int)bi.biWidth;
    cy = (int)bi.biHeight;

    cBitsPerPixel = (int)bi.biBitCount * (int)bi.biPlanes;

    if (iExpectedBitdepth != ILC_COLORDDB &&
        cBitsPerPixel != iExpectedBitdepth)
    {
        goto Error;
    }

    if (cBitsPerPixel <= 8)
        cbColorTable = (1 << cBitsPerPixel) * sizeof(RGBQUAD);
    else
        cbColorTable = 0;

    hr = E_OUTOFMEMORY;
    pbi = (BITMAPINFOHEADER*)LocalAlloc(LPTR, sizeof(bi) + cbColorTable);
    if (!pbi)
        goto Error;
    *pbi = bi;

    pbi->biSizeImage = WIDTHBYTES(cx, cBitsPerPixel) * cy;

    if (cbColorTable)
    {
        hr = pstm->Read(pbi + 1, cbColorTable, NULL);
        if (FAILED(hr))
            goto Error;
    }

    hdc = GetDC(HWND_DESKTOP);

    //
    //  see if we can make a DIBSection
    //
    if ((cBitsPerPixel > 1) && (iExpectedBitdepth != ILC_COLORDDB))
    {
        //
        // create DIBSection and read the bits directly into it!
        //
        hr = E_OUTOFMEMORY;
        hbm = CreateDIBSection(hdc, (LPBITMAPINFO)pbi, DIB_RGB_COLORS, (void**)&pbuf, NULL, 0);

        if (hbm == NULL)
            goto Error;

        hr = pstm->Read(pbuf, pbi->biSizeImage, NULL);
        if (FAILED(hr))
            goto Error;

        if (ppvBits)
            *ppvBits = pbuf;
        pbuf = NULL;        // dont free this
        goto Done;
    }

    //
    //  cant make a DIBSection make a mono or color bitmap.
    //
    else if (cBitsPerPixel > 1)
        hbm = CreateColorBitmap(cx, cy);
    else
        hbm = CreateMonoBitmap(cx, cy);

    hr = E_OUTOFMEMORY;
    if (!hbm)
        goto Error;

    // Calculate number of horizontal lines that'll fit into our buffer...
    //
    cLines = CBDIBBUF / WIDTHBYTES(cx, cBitsPerPixel);

    hr = E_OUTOFMEMORY;
    pbuf = (PBYTE)LocalAlloc(LPTR, CBDIBBUF);

    if (!pbuf)
        goto Error;

    for (cLinesRead = 0; cLinesRead < cy; cLinesRead += cLines)
    {
        if (cLines > cy - cLinesRead)
            cLines = cy - cLinesRead;

        hr = pstm->Read(pbuf, WIDTHBYTES(cx, cBitsPerPixel) * cLines, NULL);
        if (FAILED(hr))
            goto Error;

        hr = E_OUTOFMEMORY;
        if (!SetDIBits(hdc, hbm, cLinesRead, cLines,
                pbuf, (BITMAPINFO *)pbi, DIB_RGB_COLORS))
        {
            goto Error;
        }
    }

Done:
    hr = S_OK;

Error:
    if (hdc)
        ReleaseDC(HWND_DESKTOP, hdc);
    if (pbi)
        LocalFree((HLOCAL)pbi);
    if (pbuf)
        LocalFree((HLOCAL)pbuf);

    if (FAILED(hr) && hbm)
    {
        DeleteBitmap(hbm);
        hbm = NULL;
    }

    *phbmp = hbm;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\link.cpp ===
//-------------------------------------------------------------------------//
//  link.cpp - implementation of CLink
//
//  [scotthan] - created 10/7/98
//  [markfi]   - ported to UxCtrl 3/00
//  [t-jklann] - uses markup 7/00

// issues: removed window capture functionality; shouldn't change much

#include <ctlspriv.h>
#include <markup.h>
#include <oleacc.h>

#define DllAddRef()
#define DllRelease()

typedef WCHAR TUCHAR, *PTUCHAR;

#define LINKCOLOR_BKGND     COLOR_WINDOW

void _InitializeUISTATE(IN HWND hwnd, IN OUT UINT* puFlags);
BOOL _HandleWM_UPDATEUISTATE(IN WPARAM wParam, IN LPARAM lParam, IN OUT UINT* puFlags);

inline void MakePoint(LPARAM lParam, OUT LPPOINT ppt)
{
    POINTS pts = MAKEPOINTS(lParam);
    ppt->x = pts.x;
    ppt->y = pts.y;
}

STDAPI_(BOOL) IsWM_GETOBJECT(UINT uMsg)
{
    return WM_GETOBJECT == uMsg;
}

//  common IAccessible implementation.
class CAccessibleBase : public IAccessible, public IOleWindow
{
public:
    CAccessibleBase(const HWND& hwnd)
        :   _cRef(1), _ptiAcc(NULL), _hwnd(hwnd)
    { 
        DllAddRef();
    }
    
    virtual ~CAccessibleBase()
    { 
        ATOMICRELEASE(_ptiAcc);
    }

    //  IUnknown
    STDMETHODIMP         QueryInterface(REFIID riid, void** ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //  IOleWindow
    STDMETHODIMP GetWindow(HWND* phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
                                LCID lcid, DISPID * rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                         DISPPARAMS * pdispparams, VARIANT * pvarResult, 
                         EXCEPINFO * pexcepinfo, UINT * puArgErr);
    //  IAccessible
    STDMETHODIMP get_accParent(IDispatch ** ppdispParent);
    STDMETHODIMP get_accChildCount(long * pcChildren);
    STDMETHODIMP get_accChild(VARIANT varChildIndex, IDispatch ** ppdispChild);
    STDMETHODIMP get_accValue(VARIANT varChild, BSTR* pbstrValue);
    STDMETHODIMP get_accDescription(VARIANT varChild, BSTR * pbstrDescription);
    STDMETHODIMP get_accRole(VARIANT varChild, VARIANT *pvarRole);
    STDMETHODIMP get_accState(VARIANT varChild, VARIANT *pvarState);
    STDMETHODIMP get_accHelp(VARIANT varChild, BSTR* pbstrHelp);
    STDMETHODIMP get_accHelpTopic(BSTR* pbstrHelpFile, VARIANT varChild, long* pidTopic);
    STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR* pbstrKeyboardShortcut);
    STDMETHODIMP get_accFocus(VARIANT  * pvarFocusChild);
    STDMETHODIMP get_accSelection(VARIANT  * pvarSelectedChildren);
    STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR* pbstrDefaultAction);
    STDMETHODIMP accSelect(long flagsSelect, VARIANT varChild);
    STDMETHODIMP accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
    STDMETHODIMP accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
    STDMETHODIMP accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
    STDMETHODIMP put_accName(VARIANT varChild, BSTR bstrName);
    STDMETHODIMP put_accValue(VARIANT varChild, BSTR bstrValue);

protected:
    virtual UINT GetDefaultActionStringID() const = 0;
    
private:
    ULONG       _cRef;
    ITypeInfo*  _ptiAcc;
    const HWND& _hwnd;

    //  Thunked OLEACC defs from winuser.h
    #ifndef OBJID_WINDOW
    #define OBJID_WINDOW        0x00000000
    #endif//OBJID_WINDOW

    #ifndef OBJID_TITLEBAR
    #define OBJID_TITLEBAR      0xFFFFFFFE
    #endif//OBJID_TITLEBAR

    #ifndef OBJID_CLIENT
    #define OBJID_CLIENT        0xFFFFFFFC
    #endif//OBJID_CLIENT

    #ifndef CHILDID_SELF
    #define CHILDID_SELF        0
    #endif//CHILDID_SELF

    #define VALIDATEACCCHILD(varChild, idChild, hrFail) \
        if (!(VT_I4 == varChild.vt && idChild == varChild.lVal)) {return hrFail;}

} ;

#define TEST_CAPTURE(fTest)           ((_fCapture & fTest) != 0)
#define MODIFY_CAPTURE(fSet, fRemove) {if (fSet){_fCapture |= fSet;} if (fRemove){_fCapture &= ~fRemove;}}
#define RESET_CAPTURE()               {_fCapture=0;}

class CLink : public CAccessibleBase, public IMarkupCallback
{
public:
    CLink();
    virtual ~CLink();

    //  IUnknown
    STDMETHODIMP         QueryInterface(REFIID riid, void** ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IMarkupCallback
    STDMETHODIMP GetState(UINT uState);
    STDMETHODIMP Notify(int nCode, int iLink);
    STDMETHODIMP InvalidateRect(RECT* prc);
    STDMETHODIMP OnCustomDraw(DWORD dwDrawStage, HDC hdc, const RECT *prc, DWORD dwItemSpec, UINT uItemState, LRESULT *pdwResult);

    //  IAccessible specialization
    STDMETHODIMP get_accName(VARIANT varChild, BSTR* pbstrName);
    STDMETHODIMP accDoDefaultAction(VARIANT varChild);

private:
    //  CAccessibleBase overrides
    UINT GetDefaultActionStringID() const   { return IDS_LINKWINDOW_DEFAULTACTION; }

    //  Utility methods
    void    Paint(HDC hdc, IN OPTIONAL LPCRECT prcClient = NULL, LPCRECT prcClip = NULL);    
    
    //  Message handlers
    static  LRESULT WINAPI WndProc(HWND, UINT, WPARAM, LPARAM);
    LRESULT SendNotify(UINT nCode, int iLink, BOOL fGetLinkText) const;
    LRESULT GetItem(OUT LITEM* pItem);
    LRESULT SetItem(IN LITEM* pItem);

    void UpdateTabstop();

    //  Data
    HFONT        _hfStatic;
    HFONT        _hfUnderline;
    HWND         _hwnd;
    UINT         _fKeyboardCues;                     
    BOOL         _bTransparent;
    BOOL         _bIgnoreReturn;
    BOOL         _fEatTabChar;
    BOOL         _fTabStop;
    IControlMarkup*   _pMarkup;
    UINT         _cRef;
    HRESULT Initialize();
    friend BOOL InitLinkClass(HINSTANCE);
    friend BOOL UnInitLinkClass(HINSTANCE);
};

BOOL WINAPI InitLinkClass(HINSTANCE hInstance)
{
    WNDCLASSEX wc = {0};
    
    wc.cbSize        = sizeof(wc);
    wc.style         = CS_GLOBALCLASS;
    wc.lpfnWndProc   = CLink::WndProc;
    wc.hInstance     = hInstance;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(LINKCOLOR_BKGND+1);
    wc.lpszClassName = WC_LINK;

    if (!RegisterClassEx(&wc) && !GetClassInfoEx(hInstance, WC_LINK, &wc))
        return FALSE;

    return TRUE;
}

BOOL WINAPI UnInitLinkClass(HINSTANCE)
{
    return ::UnregisterClass(WC_LINK, HINST_THISDLL);
}

CLink::CLink()
    :   CAccessibleBase(_hwnd),
        _hwnd(NULL),        
        _fKeyboardCues(0),
        _pMarkup(NULL),
        _cRef(1)
{
}

CLink::~CLink()
{
    if (_pMarkup) 
    {
        _pMarkup->Release();
        _pMarkup = NULL;
    }
}

HRESULT CLink::Initialize()
{
    // NOTE - this is the same code the old linkwindow had to find its parent's font
    // I this is bogus - WM_GETFONT is spec'ed as being sent from parent to control, not 
    // child control to parent... We should probably find a better way of doing this.
    _hfStatic = NULL;
    _hfUnderline = NULL;
    for (HWND hwnd = _hwnd; NULL == _hfStatic && hwnd != NULL; hwnd = GetParent(hwnd))
        _hfStatic = (HFONT)::SendMessage( hwnd, WM_GETFONT, 0, 0L );

    if (_hfStatic)
    {
        _hfUnderline = CCCreateUnderlineFont(_hfStatic);
    }

    // ... get a markup
    return Markup_Create(SAFECAST(this, IMarkupCallback*), _hfStatic, _hfUnderline, IID_PPV_ARG(IControlMarkup, &_pMarkup));
}


//-------------------------------------------------------------------------//
//  CLink IUnknown implementation override (from CAccessibleBase)
//-------------------------------------------------------------------------//

// override QueryInterface from CAccessibleBase!
STDMETHODIMP CLink::QueryInterface(REFIID riid, void** ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAccessibleBase, IDispatch),
        QITABENT(CAccessibleBase, IAccessible),
        QITABENT(CAccessibleBase, IOleWindow),
        QITABENT(CLink, IMarkupCallback),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CLink::AddRef()
{
    return InterlockedIncrement((LONG*)&_cRef);
}

STDMETHODIMP_(ULONG) CLink::Release()
{
    ULONG cRef = InterlockedDecrement((LONG*)&_cRef);
    if (cRef <= 0)
    {
        DllRelease();
        delete this;
    }
    return cRef;
}
                
//-------------------------------------------------------------------------//
//  CLink IMarkupCallback implementation
//-------------------------------------------------------------------------//

STDMETHODIMP CLink::GetState(UINT uState)
{
    HRESULT hr = E_FAIL;

    switch(uState)
    {
        case MARKUPSTATE_FOCUSED: 
            hr = (GetFocus()==_hwnd) ? S_OK : S_FALSE;
            break;

        case MARKUPSTATE_ALLOWMARKUP:
            hr = S_OK;
            break;
    }
    return hr;
}


HRESULT CLink::OnCustomDraw(DWORD dwDrawStage, HDC hdc, const RECT *prc, DWORD dwItemSpec, UINT uItemState, LRESULT *pdwResult)
{
    NMCUSTOMDRAW nmcd;
    ZeroMemory(&nmcd, sizeof(nmcd) );

    nmcd.hdr.hwndFrom = _hwnd;
    nmcd.hdr.idFrom   = (UINT_PTR)GetWindowLong( _hwnd, GWL_ID );
    nmcd.hdr.code     = NM_CUSTOMDRAW;
    nmcd.dwDrawStage  = dwDrawStage;
    nmcd.hdc          = hdc;
    if (prc)
        CopyRect(&nmcd.rc, prc);
    nmcd.dwItemSpec   = dwItemSpec;
    nmcd.uItemState   = uItemState;

    LRESULT dwRes = SendMessage(GetParent(_hwnd), WM_NOTIFY, nmcd.hdr.idFrom, (LPARAM)&nmcd);
    if (pdwResult)
        *pdwResult = dwRes;
    return S_OK;
}

STDMETHODIMP CLink::Notify(int nCode, int iLink)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (_pMarkup)
    {
        switch (nCode)
        {
        case MARKUPMESSAGE_WANTFOCUS:
            // Markup wants focus
            SetFocus(_hwnd);
            break;

        case MARKUPMESSAGE_KEYEXECUTE:
            SendNotify(NM_RETURN, iLink, TRUE);
            break;

        case MARKUPMESSAGE_CLICKEXECUTE:
            SendNotify(NM_CLICK, iLink, TRUE);
            break;
        }
    }

    return hr;
}

STDMETHODIMP CLink::InvalidateRect(RECT* prc)
{
    HRESULT hr = E_FAIL;

    if (! ::InvalidateRect(_hwnd, prc, TRUE))
        hr=S_OK;

    return hr;
}

//  CLink IAccessible impl
//
//  Note: Currently, this IAccessible implementation does not supports only
//  single links; multiple links are not supported.   All child delegation
//  is to/from self.  This allows us to blow off the IEnumVARIANT and IDispatch
//  implementations.
//
//  To shore this up the implementation, we need to implement each link
//  as a child IAccessible object and delegate accordingly.
//
STDMETHODIMP CLink::get_accName(VARIANT varChild, BSTR* pbstrName)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    if (NULL == pbstrName)
    {
        return E_POINTER;
    }

    if (NULL == _pMarkup)
    {
        return E_OUTOFMEMORY;
    }

    *pbstrName = NULL;
    DWORD dwCch;
    HRESULT hr;
    if (S_OK == (hr = _pMarkup->GetText(FALSE, NULL, &dwCch)))
    {
        *pbstrName = SysAllocStringLen(NULL, dwCch);
        if (*pbstrName)
            hr = _pMarkup->GetText(FALSE, *pbstrName, &dwCch);
        else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CLink::accDoDefaultAction(VARIANT varChild)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    SendNotify(NM_RETURN, NULL, FALSE);
    return S_OK;
}

//  CLink window implementation

void CLink::Paint(HDC hdcClient, LPCRECT prcClient, LPCRECT prcClip)
{
    if (!_pMarkup)
    {
        return;
    }

    RECT rcClient;
    if (!prcClient)
    {
        GetClientRect(_hwnd, &rcClient);
        prcClient = &rcClient;
    }

    if (RECTWIDTH(*prcClient) <= 0 || 
        RECTHEIGHT(*prcClient) <= 0)
    {
        return;
    }

    HDC  hdc = hdcClient ? hdcClient : GetDC(_hwnd);
    RECT rcDraw = *prcClient;             // initialize line rect

    HBRUSH hbrOld = NULL;

    //  initialize background
    HBRUSH hbr = (HBRUSH)SendMessage(GetParent(_hwnd), WM_CTLCOLORSTATIC, 
                (WPARAM)hdc, (LPARAM)_hwnd);
    if (hbr)
        hbrOld = (HBRUSH)SelectObject(hdc, hbr);

    if (_bTransparent)
    {
        SetBkMode(hdc, TRANSPARENT); 
    }
    else
    {
        // Clear the background
        RECT rcFill = *prcClient;
        rcFill.top = rcDraw.top;
        FillRect(hdc, &rcFill, hbr);
    }

    // draw the text
    _pMarkup->DrawText(hdc, &rcDraw);

    if (hbr)
    {
        SelectObject(hdc, hbrOld);
    }

    if (NULL == hdcClient && hdc)  // release DC if we acquired it.
    {
        ReleaseDC(_hwnd, hdc);
    }
}

LRESULT CLink::SetItem(IN LITEM* pItem)
{
    HRESULT hr = E_FAIL;

    if (!_pMarkup)
    {
        return 0;
    }

    if (NULL == pItem || 
        0 == (pItem->mask & LIF_ITEMINDEX))
    {
        return 0; //FEATURE: need to open up search keys to LIF_ITEMID and LIF_URL.
    }

    if (pItem->iLink>-1)
    {                   
        if (pItem->mask & LIF_STATE)
        {
            // Ask the markup callback to set state
            hr = _pMarkup->SetState(pItem->iLink, pItem->stateMask, pItem->state);

            // Deal with LIS_ENABLED
            if (pItem->stateMask & LIS_ENABLED)
            {
                if (!IsWindowEnabled(_hwnd))
                {
                    EnableWindow(_hwnd, TRUE);
                }
            }
        }

        if (pItem->mask & LIF_ITEMID)
        {           
            hr = _pMarkup->SetLinkText(pItem->iLink, MARKUPLINKTEXT_ID, pItem->szID);
        }

        if (pItem->mask & LIF_URL)
        {
            hr = _pMarkup->SetLinkText(pItem->iLink, MARKUPLINKTEXT_URL, pItem->szUrl);
        }
    }

    UpdateTabstop();

    return SUCCEEDED(hr);
}

LRESULT CLink::GetItem(OUT LITEM* pItem)
{
    HRESULT hr = E_FAIL;

    if (!_pMarkup)
    {
        return 0;
    }

    if (NULL == pItem || 0 == (pItem->mask & LIF_ITEMINDEX))
    {
        return 0; //FEATURE: need to open up search keys to LIF_ITEMID and LIF_URL.
    }

    if (pItem->iLink > -1)
    {
        if (pItem->mask & LIF_STATE)
        {
            hr = _pMarkup->GetState(pItem->iLink, pItem->stateMask, &pItem->state);            
        }

        if (pItem->mask & LIF_ITEMID)
        {
            DWORD dwCch = ARRAYSIZE(pItem->szID);
            hr = _pMarkup->GetLinkText(pItem->iLink, MARKUPLINKTEXT_ID, pItem->szID, &dwCch);
        }

        if (pItem->mask & LIF_URL)
        {
            DWORD dwCch = ARRAYSIZE(pItem->szUrl);
            hr = _pMarkup->GetLinkText(pItem->iLink, MARKUPLINKTEXT_URL, pItem->szUrl, &dwCch);
        }
    }

    return SUCCEEDED(hr);
}

LRESULT CLink::SendNotify(UINT nCode, int iLink, BOOL fGetLinkText) const
{
    NMLINK nm;
    ZeroMemory(&nm, sizeof(nm));

    nm.hdr.hwndFrom = _hwnd;
    nm.hdr.idFrom   = (UINT_PTR)GetWindowLong(_hwnd, GWL_ID);
    nm.hdr.code     = nCode;
    nm.item.iLink   = iLink;        

    if (fGetLinkText)
    {
        DWORD dwCch;

        dwCch = ARRAYSIZE(nm.item.szID);
        _pMarkup->GetLinkText(iLink, MARKUPLINKTEXT_ID, nm.item.szID, &dwCch);

        dwCch = ARRAYSIZE(nm.item.szUrl);
        _pMarkup->GetLinkText(iLink, MARKUPLINKTEXT_URL, nm.item.szUrl, &dwCch);
    }

    return SendMessage(GetParent(_hwnd), WM_NOTIFY, nm.hdr.idFrom, (LPARAM)&nm);
}

void CLink::UpdateTabstop()
{
    if (_fTabStop)
        SetWindowBits(_hwnd, GWL_STYLE, WS_TABSTOP, (_pMarkup->IsTabbable() == S_OK)?WS_TABSTOP:0);
}


LRESULT WINAPI CLink::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0L;
    CLink* pThis = NULL;

    if (uMsg == WM_NCCREATE)
    {
        pThis = new CLink;
        if (NULL == pThis)
        {
            TraceMsg(TF_WARNING, "CLink: Failed to allocate CLink in WM_NCCREATE.");
            SetWindowPtr(hwnd, GWLP_USERDATA, 0);
            return FALSE;
        }

        pThis->_hwnd = hwnd;
        SetWindowPtr(hwnd, GWLP_USERDATA, pThis);

        return TRUE;
    }
    else
    {
        pThis = (CLink*)GetWindowPtr(hwnd, GWLP_USERDATA);
    }

    if (pThis != NULL)
    {
        ASSERT(pThis->_hwnd == hwnd);

        switch(uMsg)
        {
            case WM_SETFONT:
                {
                    if (pThis->_hfUnderline)
                    {
                        DeleteObject(pThis->_hfUnderline);
                        pThis->_hfUnderline = NULL;
                    }

                    pThis->_hfStatic = (HFONT)wParam;
                    if (pThis->_hfStatic)
                        pThis->_hfUnderline = CCCreateUnderlineFont(pThis->_hfStatic);

                    if (pThis->_pMarkup)
                        pThis->_pMarkup->SetFonts(pThis->_hfStatic, pThis->_hfUnderline);
                }
                break;

            case WM_NCHITTEST:
            {
                POINT pt;
                UINT idLink;
                MakePoint(lParam, &pt);
                MapWindowPoints(HWND_DESKTOP, hwnd, &pt, 1);
                if (pThis->_pMarkup && pThis->_pMarkup->HitTest(pt, &idLink) == S_OK)
                {
                    return HTCLIENT;
                }
                return HTTRANSPARENT;
            }

            case WM_PAINT:
            {
                PAINTSTRUCT ps;
                HDC         hdc;

                if ((hdc = BeginPaint(pThis->_hwnd, &ps)) != NULL)
                {
                    pThis->Paint(hdc);
                    EndPaint(pThis->_hwnd, &ps);
                }
                return lRet;
            }

            case WM_PRINTCLIENT:
                pThis->Paint((HDC)wParam);
                return lRet;

            case WM_WINDOWPOSCHANGING:
            {
                WINDOWPOS* pwp = (WINDOWPOS*)lParam;
                RECT rc;
                GetClientRect(pThis->_hwnd, &rc);
                if (0 == (pwp->flags & SWP_NOSIZE) &&
                    !(pwp->cx == RECTWIDTH(rc) &&
                       pwp->cy == RECTHEIGHT(rc)))
                {
                    //  FEATURE: implement LS_AUTOHEIGHT style by
                    //  calling CalcIdealHeight() to compute the height for
                    //  the given width.
                }
                break;
            }

            case WM_SIZE:
            {
                pThis->Paint(NULL);
                break;
            }

            case WM_CREATE:
            {
                if ((lRet = DefWindowProc(hwnd, uMsg, wParam, lParam)) == 0)
                {
                    CREATESTRUCT* pcs = (CREATESTRUCT*)lParam;

                    if (FAILED(pThis->Initialize()))
                        return -1;
                    _InitializeUISTATE(hwnd, &pThis->_fKeyboardCues);
                    pThis->_fTabStop = (pcs->style & WS_TABSTOP);
                    pThis->_pMarkup->SetText(pcs->lpszName);
                    pThis->UpdateTabstop();
                    pThis->_bTransparent = (pcs->style & LWS_TRANSPARENT);
                    pThis->_bIgnoreReturn = (pcs->style & LWS_IGNORERETURN);
                }
                return lRet;
            }

            case WM_SETTEXT:
                pThis->_pMarkup->SetText((LPCTSTR) lParam);
                pThis->UpdateTabstop();
                ::InvalidateRect(pThis->_hwnd, NULL, FALSE);
                break;

            case WM_GETTEXT:
            {
                DWORD dwCch = (DWORD)wParam;
                pThis->_pMarkup->GetText(TRUE, (LPTSTR)lParam, &dwCch);
                return lstrlen((LPTSTR)lParam);
            }

            case WM_GETTEXTLENGTH:
            {
                DWORD dwCch;
                pThis->_pMarkup->GetText(TRUE, NULL, &dwCch);
                return dwCch-1; // return length in chars, not including NULL
            }

            case WM_SETFOCUS:
                pThis->_pMarkup->SetFocus();
                pThis->SendNotify(NM_SETFOCUS, NULL, NULL);
                pThis->InvalidateRect(NULL);
            
                return 0L;

            case WM_KILLFOCUS:
                pThis->_pMarkup->KillFocus();
                return lRet;

            case WM_LBUTTONDOWN:
            {
                POINT pt;
                MakePoint(lParam, &pt);
                pThis->_pMarkup->OnButtonDown(pt);
                break;
            }

            case WM_LBUTTONUP:
            {
                POINT pt;
                MakePoint(lParam, &pt);
                pThis->_pMarkup->OnButtonUp(pt);
                break;
            }

            case WM_MOUSEMOVE:
            {
                POINT pt;
                UINT idLink;
                MakePoint(lParam, &pt);
                if (pThis->_pMarkup->HitTest(pt, &idLink) == S_OK) 
                {
                    pThis->_pMarkup->SetLinkCursor();
                }
                break;
            }

            case LM_HITTEST:  // wParam: n/a, lparam: PLITEM, ret: BOOL
            {
                LHITTESTINFO* phti = (LHITTESTINFO*)lParam;
                if (phti)
                {
                    if (SUCCEEDED(pThis->_pMarkup->HitTest(phti->pt, (UINT*)&phti->item.iLink)))
                    {
                        DWORD cch = ARRAYSIZE(phti->item.szID);
                        return (S_OK == pThis->_pMarkup->GetLinkText(phti->item.iLink, MARKUPLINKTEXT_ID, phti->item.szID, &cch));
                    }
                }
                return lRet;
            }
    
            case LM_SETITEM:
                return pThis->SetItem((LITEM*)lParam);

            case LM_GETITEM:
                return pThis->GetItem((LITEM*)lParam);

            case LM_GETIDEALHEIGHT:  // wParam: cx, lparam: n/a, ret: cy
            {
                HDC hdc = GetDC(hwnd);
                if (hdc)
                {
                    RECT rc;
                    SetRect(&rc, 0, 0, (int)wParam, 0);
                    pThis->_pMarkup->CalcIdealSize(hdc, MARKUPSIZE_CALCHEIGHT, &rc);
                    ReleaseDC(hwnd, hdc);
                    return rc.bottom;
                }
                return -1;
            }

            case WM_NCDESTROY:
            {
                lRet = DefWindowProc(hwnd, uMsg, wParam, lParam);
                SetWindowPtr(hwnd, GWLP_USERDATA, 0);

                if (pThis->_pMarkup)
                    pThis->_pMarkup->SetCallback(NULL);

                if (pThis->_hfUnderline)
                    DeleteObject(pThis->_hfUnderline);

                pThis->_hwnd = NULL;
                pThis->Release();
                return lRet;
            }

            case WM_GETDLGCODE:
            {
                MSG* pmsg;
                lRet = DLGC_STATIC;

                if ((pmsg = (MSG*)lParam))
                {
                    if ((WM_KEYDOWN == pmsg->message || WM_KEYUP == pmsg->message))
                    {
                        switch(pmsg->wParam)
                        {
                        case VK_TAB:
                            if (pThis->_pMarkup->IsTabbable() == S_OK)
                            {
                                lRet |= DLGC_WANTTAB;
                                pThis->_fEatTabChar = TRUE;
                            }
                            break;

                        case VK_RETURN:
                            if (pThis->_bIgnoreReturn)
                                break;
                            // deliberate drop through..
                        case VK_SPACE:
                            lRet |= DLGC_WANTALLKEYS;
                            break;
                        }
                    }
                    else if (WM_CHAR == pmsg->message)
                    {
                        if (VK_RETURN == pmsg->wParam)
                        {
                            //  Eat VK_RETURN WM_CHARs; we don't want
                            //  Dialog manager to beep when IsDialogMessage gets it.
                            lRet |= DLGC_WANTMESSAGE;
                        }
                        else if (VK_TAB == pmsg->wParam &&
                            pThis->_fEatTabChar)
                        {
                            pThis->_fEatTabChar = FALSE;
                            lRet |= DLGC_WANTTAB;
                        }
                    }
                }

                return lRet;
            }

            case WM_KEYDOWN:
                pThis->_pMarkup->OnKeyDown((UINT)wParam);
            case WM_KEYUP:
            case WM_CHAR:
                return lRet;

            case WM_UPDATEUISTATE:
                if (_HandleWM_UPDATEUISTATE(wParam, lParam, &pThis->_fKeyboardCues))
                {
                    RedrawWindow(hwnd, NULL, NULL, 
                                  RDW_ERASE | RDW_INVALIDATE | RDW_UPDATENOW);
                }
                break;

            default:
                // oleacc defs thunked for WINVER < 0x0500
                if (IsWM_GETOBJECT(uMsg) && OBJID_CLIENT == lParam)
                {
                    return LresultFromObject(IID_IAccessible, wParam, SAFECAST(pThis, IAccessible*));
                }

                break;
        }
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

//  CAccessibleBase IUnknown impl
STDMETHODIMP CAccessibleBase::QueryInterface(REFIID riid, void** ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAccessibleBase, IDispatch),
        QITABENT(CAccessibleBase, IAccessible),
        QITABENT(CAccessibleBase, IOleWindow),
        { 0 },
    };

    return QISearch(this, (LPCQITAB)qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CAccessibleBase::AddRef()
{
    return InterlockedIncrement((LONG*)&_cRef);
}

STDMETHODIMP_(ULONG) CAccessibleBase::Release()
{
    ULONG cRef = InterlockedDecrement((LONG*)&_cRef);
    if (cRef <= 0)
    {
        DllRelease();
        delete this;
    }
    return cRef;
}

//  IOleWindow impl
STDMETHODIMP CAccessibleBase::GetWindow(HWND* phwnd)
{
    *phwnd = _hwnd;
    return IsWindow(_hwnd) ? S_OK : S_FALSE;
}

//-------------------------------------------------------------------------//
//  CAccessibleBase IDispatch impl
//-------------------------------------------------------------------------//

static BOOL _accLoadTypeInfo(ITypeInfo** ppti)
{
    ITypeLib* ptl;
    HRESULT hr = LoadTypeLib(L"oleacc.dll", &ptl);

    if (SUCCEEDED(hr))
    {
        hr = ptl->GetTypeInfoOfGuid(IID_IAccessible, ppti);
        ATOMICRELEASE(ptl);
    }

    return SUCCEEDED(hr);
}

STDMETHODIMP CAccessibleBase::GetTypeInfoCount(UINT * pctinfo) 
{ 
    *pctinfo = 1;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{ 
    HRESULT hr = E_FAIL;
    if (NULL == _ptiAcc && FAILED((hr = _accLoadTypeInfo(&_ptiAcc))))
    {
        return hr;
    }

    *pptinfo = _ptiAcc;
    (*pptinfo)->AddRef();
    return S_OK;
}

STDMETHODIMP CAccessibleBase::GetIDsOfNames(
    REFIID riid, 
    OLECHAR** rgszNames, 
    UINT cNames,
    LCID lcid, DISPID * rgdispid)
{
    HRESULT hr = E_FAIL;

    if (IID_NULL != riid && IID_IAccessible != riid)
    {
        return DISP_E_UNKNOWNINTERFACE;
    }

    if (NULL == _ptiAcc && FAILED((hr = _accLoadTypeInfo(&_ptiAcc))))
    {
        return hr;
    }

    return _ptiAcc->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

STDMETHODIMP CAccessibleBase::Invoke(
    DISPID  dispidMember, 
    REFIID  riid, 
    LCID    lcid, 
    WORD    wFlags,
    DISPPARAMS * pdispparams, 
    VARIANT * pvarResult, 
    EXCEPINFO * pexcepinfo, 
    UINT * puArgErr)
{
    HRESULT hr = E_FAIL;
    if (IID_NULL != riid && IID_IAccessible != riid)
    {
        return DISP_E_UNKNOWNINTERFACE;
    }

    if (NULL == _ptiAcc && FAILED((hr = _accLoadTypeInfo(&_ptiAcc))))
    {
        return hr;
    }

    return _ptiAcc->Invoke(this, dispidMember, wFlags, pdispparams, 
                            pvarResult, pexcepinfo, puArgErr);
}

STDMETHODIMP CAccessibleBase::get_accParent(IDispatch ** ppdispParent)
{
    *ppdispParent = NULL;
    if (IsWindow(_hwnd))
    {
        return AccessibleObjectFromWindow(_hwnd, OBJID_WINDOW,
                                           IID_IDispatch, (void **)ppdispParent);
    }
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accChildCount(long * pcChildren)
{
    *pcChildren = 0;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::get_accChild(VARIANT varChildIndex, IDispatch ** ppdispChild)
{
    *ppdispChild = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accValue(VARIANT varChild, BSTR* pbstrValue)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrValue = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accDescription(VARIANT varChild, BSTR * pbstrDescription)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrDescription = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    pvarRole->vt    = VT_I4;
    pvarRole->lVal  = ROLE_SYSTEM_LINK;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = STATE_SYSTEM_DEFAULT ;

    if (GetFocus() == _hwnd)
    {
        pvarState->lVal |= STATE_SYSTEM_FOCUSED;
    }
    else if (IsWindowEnabled(_hwnd))
    {
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
    }

    if (!IsWindowVisible(_hwnd))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
    }

    return S_OK;
}

STDMETHODIMP CAccessibleBase::get_accHelp(VARIANT varChild, BSTR* pbstrHelp)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrHelp = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accHelpTopic(BSTR* pbstrHelpFile, VARIANT varChild, long* pidTopic)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrHelpFile = NULL;
    *pidTopic    = -1;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accKeyboardShortcut(VARIANT varChild, BSTR* pbstrKeyboardShortcut)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrKeyboardShortcut = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accFocus(VARIANT  * pvarFocusChild)
{
    HWND hwndFocus;
    if ((hwndFocus = GetFocus()) == _hwnd || IsChild(_hwnd, hwndFocus))
    {
        pvarFocusChild->vt = VT_I4;
        pvarFocusChild->lVal = CHILDID_SELF;
        return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accSelection(VARIANT  * pvarSelectedChildren)
{
    return get_accFocus(pvarSelectedChildren);  // implemented same as focus.
}

STDMETHODIMP CAccessibleBase::get_accDefaultAction(VARIANT varChild, BSTR* pbstrDefaultAction)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    WCHAR wsz[128];
    if (LoadStringW(HINST_THISDLL, GetDefaultActionStringID(), wsz, ARRAYSIZE(wsz)))
    {
        if (NULL == (*pbstrDefaultAction = SysAllocString(wsz)))
        {
            return E_OUTOFMEMORY;
        }
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP CAccessibleBase::accSelect(long flagsSelect, VARIANT varChild)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    if (flagsSelect & SELFLAG_TAKEFOCUS)
    {
        SetFocus(_hwnd);
        return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    RECT rc;
    GetWindowRect(_hwnd, &rc);
    *pxLeft = rc.left;
    *pyTop  = rc.top;
    *pcxWidth  = RECTWIDTH(rc);
    *pcyHeight = RECTHEIGHT(rc);

    varChild.vt = VT_I4;
    varChild.lVal = CHILDID_SELF;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    pvarChildAtPoint->vt   = VT_I4;
    pvarChildAtPoint->lVal = CHILDID_SELF;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::put_accName(VARIANT varChild, BSTR bstrName)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::put_accValue(VARIANT varChild, BSTR bstrValue)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    return S_FALSE;
}

//-------------------------------------------------------------------------//
//  KEYBOARDCUES helpes
BOOL _HandleWM_UPDATEUISTATE(
    IN WPARAM wParam, 
    IN LPARAM lParam, 
    IN OUT UINT* puFlags)
{
    UINT uFlags = *puFlags;

    switch(LOWORD(wParam))
    {
    case UIS_CLEAR:
        *puFlags &= ~(HIWORD(wParam));
        break;

    case UIS_SET:
        *puFlags |= HIWORD(wParam);
        break;
    }

    return uFlags != *puFlags;
}

void _InitializeUISTATE(IN HWND hwnd, IN OUT UINT* puFlags)
{
    HWND hwndParent = GetParent(hwnd);
    *puFlags = (UINT)SendMessage(hwndParent, WM_QUERYUISTATE, 0, 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\ipaddr.c ===
/* Copyright (c) 1991, Microsoft Corporation, all rights reserved

 ipaddr.c - TCP/IP Address custom control

 November 9, 1992    Greg Strange
 */

#include "ctlspriv.h"


// The character that is displayed between address fields.
#define FILLER          TEXT('.')
#define SZFILLER        TEXT(".")
#define SPACE           TEXT(' ')
#define BACK_SPACE      8

/* Min, max values */
#define NUM_FIELDS      4
#define CHARS_PER_FIELD 3
#define HEAD_ROOM       1       // space at top of control
#define LEAD_ROOM       3       // space at front of control
#define MIN_FIELD_VALUE 0       // default minimum allowable field value
#define MAX_FIELD_VALUE 255     // default maximum allowable field value


// All the information unique to one control is stuffed in one of these
// structures in global memory and the handle to the memory is stored in the
// Windows extra space.

typedef struct tagFIELD {
    HANDLE      hWnd;
    WNDPROC     lpfnWndProc;
    BYTE        byLow;  // lowest allowed value for this field.
    BYTE        byHigh; // Highest allowed value for this field.
} FIELD;

typedef struct tagIPADDR
 {
    HWND        hwndParent;
    HWND        hwnd;
    UINT        uiFieldWidth;
    UINT        uiFillerWidth;
    BOOL        fEnabled : 1;
    BOOL        fPainted : 1;
    BOOL        bControlInFocus : 1;        // TRUE if the control is already in focus, dont't send another focus command
    BOOL        bCancelParentNotify : 1;    // Don't allow the edit controls to notify parent if TRUE
    BOOL        fInMessageBox : 1;  // Set when a message box is displayed so that
    BOOL        fFontCreated :1;
    HFONT       hfont;
    // we don't send a EN_KILLFOCUS message when
    // we receive the EN_KILLFOCUS message for the
    // current field.
    FIELD       Children[NUM_FIELDS];

    HTHEME      hTheme;
} IPADDR;


// The following macros extract and store the CONTROL structure for a control.
#define    IPADDRESS_EXTRA            sizeof(DWORD)

#define GET_IPADDR_HANDLE(hWnd)        ((HGLOBAL)(GetWindowLongPtr((hWnd), GWLP_USERDATA)))
#define SAVE_IPADDR_HANDLE(hWnd,x)     (SetWindowLongPtr((hWnd), GWLP_USERDATA, (LONG_PTR)(x)))


/* internal IPAddress function prototypes */
LRESULT IPAddressWndFn( HWND, UINT, WPARAM, LPARAM );
LRESULT IPAddressFieldProc(HWND, UINT, WPARAM, LPARAM);
BOOL SwitchFields(IPADDR *, int, int, WORD, WORD);
void EnterField(FIELD *, WORD, WORD);
BOOL ExitField(IPADDR *, int iField);
int GetFieldValue(FIELD *);
void SetFieldValue(IPADDR *pipa, int iField, int iValue);
BOOL IsDBCS();





/*
 IPAddrInit() - IPAddress custom control initialization
 call
 hInstance = library or application instance
 return
 TRUE on success, FALSE on failure.

 This function does all the one time initialization of IPAddress custom
 controls.  Specifically it creates the IPAddress window class.
 */
int InitIPAddr(HANDLE hInstance)
{
    WNDCLASS        wc;

    wc.lpszClassName = WC_IPADDRESS;
    wc.hCursor =       LoadCursor(NULL,IDC_IBEAM);
    wc.hIcon           = NULL;
    wc.lpszMenuName =  (LPCTSTR)NULL;
    wc.style =         CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS|CS_GLOBALCLASS;
    wc.lpfnWndProc =   IPAddressWndFn;
    wc.hInstance =     hInstance;
    wc.hIcon =         NULL;
    wc.cbWndExtra =    IPADDRESS_EXTRA;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1 );
    wc.cbClsExtra      = 0;

    if (!RegisterClass(&wc) && !GetClassInfo(hInstance, WC_IPADDRESS, &wc))
        return FALSE;

    return TRUE;
}


/*
 IPAddressWndFn() - Main window function for an IPAddress control.

 call
 hWnd    handle to IPAddress window
 wMsg    message number
 wParam  word parameter
 lParam  long parameter
 */

void FormatIPAddress(LPTSTR pszString, DWORD* dwValue)
{
    int nField, nPos;
    BOOL fFinish = FALSE;

    dwValue[0] = 0; dwValue[1] = 0; dwValue[2] = 0; dwValue[3] = 0;

    if (pszString[0] == 0)
        return;

    for( nField = 0, nPos = 0; !fFinish; nPos++)
    {
        if (( pszString[nPos]<TEXT('0')) || (pszString[nPos]>TEXT('9')))
        {
            // not a number
            nField++;
            fFinish = (nField == 4);
        }
        else
        {
            dwValue[nField] *= 10;
            dwValue[nField] += (pszString[nPos]-TEXT('0'));
        }
    }
}

void IP_OnSetFont(IPADDR* pipa, HFONT hfont, BOOL fRedraw)
{
    int i;
    RECT rect;
    HFONT OldFont;
    BOOL fNewFont = FALSE;
    UINT uiFieldStart;
    HDC hdc;
    
    if (hfont) {
        fNewFont = TRUE;
    } else {
        hfont = (HFONT)SendMessage(pipa->hwnd, WM_GETFONT, 0, 0);
    }
    
    hdc = GetDC(pipa->hwnd);
    OldFont = SelectObject(hdc, hfont);
    GetCharWidth(hdc, FILLER, FILLER,
                 (int *)(&pipa->uiFillerWidth));
    SelectObject(hdc, OldFont);
    ReleaseDC(pipa->hwnd, hdc);
    
    GetClientRect(pipa->hwnd, &rect);
    pipa->hfont = hfont;
    pipa->uiFieldWidth = (RECTWIDTH(rect)
                          - LEAD_ROOM
                          - pipa->uiFillerWidth
                          *(NUM_FIELDS-1))
        / NUM_FIELDS;


    uiFieldStart = LEAD_ROOM;

    for (i = 0; i < NUM_FIELDS; i++) {

        HWND hwnd = pipa->Children[i].hWnd;
        
        if (fNewFont)
            SendMessage(hwnd, WM_SETFONT, (WPARAM)hfont, (LPARAM)fRedraw);
        
        SetWindowPos(hwnd, NULL,
                     uiFieldStart,
                     HEAD_ROOM,
                     pipa->uiFieldWidth,
                     (rect.bottom-rect.top),
                     SWP_NOACTIVATE);

        uiFieldStart += pipa->uiFieldWidth
            + pipa->uiFillerWidth;

    }
    
}

LRESULT IPAddressWndFn( hWnd, wMsg, wParam, lParam )
    HWND            hWnd;
    UINT            wMsg;
    WPARAM            wParam;
    LPARAM            lParam;
{
    LRESULT lResult;
    IPADDR *pipa;
    int i;

    pipa = (IPADDR *)GET_IPADDR_HANDLE(hWnd);
    lResult = TRUE;

    switch( wMsg )
    {

        // use empty string (not NULL) to set to blank
        case WM_SETTEXT:
        {
            TCHAR szBuf[CHARS_PER_FIELD+1];
            DWORD dwValue[4];
            LPTSTR pszString = (LPTSTR)lParam;

            FormatIPAddress(pszString, &dwValue[0]);
            pipa->bCancelParentNotify = TRUE;

            for (i = 0; i < NUM_FIELDS; ++i)
            {
                if (pszString[0] == 0)
                {
                    szBuf[0] = 0;
                }
                else
                {
                    wsprintf(szBuf, TEXT("%d"), dwValue[i]);
                }
                SendMessage(pipa->Children[i].hWnd, WM_SETTEXT,
                            0, (LPARAM) (LPSTR) szBuf);
            }

            pipa->bCancelParentNotify = FALSE;

            SendMessage(pipa->hwndParent, WM_COMMAND,
                        MAKEWPARAM(GetDlgCtrlID(hWnd), EN_CHANGE), (LPARAM)hWnd);
        }
        break;

    case WM_GETTEXTLENGTH:
    case WM_GETTEXT:
    {
        int iFieldValue;
        DWORD dwValue[4];
        TCHAR pszResult[30];
        TCHAR *pszDest = (TCHAR *)lParam;

        lResult = 0;
        dwValue[0] = 0;
        dwValue[1] = 0;
        dwValue[2] = 0;
        dwValue[3] = 0;
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            iFieldValue = GetFieldValue(&(pipa->Children[i]));
            if (iFieldValue == -1)
                iFieldValue = 0;
            else
                ++lResult;
            dwValue[i] = iFieldValue;
        }
        wsprintf( pszResult, TEXT("%d.%d.%d.%d"), dwValue[0], dwValue[1], dwValue[2], dwValue[3] );
        if (wMsg == WM_GETTEXT)
        {
            StrCpyN(pszDest, pszResult, (int) wParam);
            lResult = lstrlen( pszDest );
        } 
        else 
        {
            lResult = lstrlen( pszResult );
        }
    }
        break;

    case WM_GETDLGCODE :
        lResult = DLGC_WANTCHARS;
        break;

    case WM_NCCREATE:
        SetWindowBits(hWnd, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);
        SetWindowBits(hWnd, GWL_EXSTYLE, RTL_MIRRORED_WINDOW, 0);

        lResult = TRUE;
        break;

    case WM_THEMECHANGED:
        {
            if (pipa->hTheme)
                CloseThemeData(pipa->hTheme);
                
            pipa->hTheme = OpenThemeData(hWnd, L"Combobox");

            InvalidateRect(hWnd, NULL, TRUE);
        }
        break;


    case WM_CREATE : /* create pallette window */
    {
        LONG id;

        pipa = (IPADDR*)LocalAlloc(LPTR, sizeof(IPADDR));

        if (pipa)
        {
            CREATESTRUCT* pcs = ((CREATESTRUCT *)lParam);
            SAVE_IPADDR_HANDLE(hWnd, pipa);

            pipa->fEnabled = TRUE;
            pipa->hwndParent = pcs->hwndParent;
            pipa->hwnd = hWnd;
            pipa->hTheme = OpenThemeData(hWnd, L"Combobox");

            id = GetDlgCtrlID(hWnd);
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                pipa->Children[i].byLow = MIN_FIELD_VALUE;
                pipa->Children[i].byHigh = MAX_FIELD_VALUE;

                pipa->Children[i].hWnd = CreateWindowEx(0,
                                                        TEXT("Edit"),
                                                        NULL,
                                                        WS_CHILD |
                                                        ES_CENTER, 
                                                        0, 10, 100, 100,
                                                        hWnd,
                                                        (HMENU)(LONG_PTR)id,
                                                        pcs->hInstance,
                                                        (LPVOID)NULL);

                SAVE_IPADDR_HANDLE(pipa->Children[i].hWnd, i);
                SendMessage(pipa->Children[i].hWnd, EM_LIMITTEXT,
                            CHARS_PER_FIELD, 0L);

                pipa->Children[i].lpfnWndProc =
                    (WNDPROC) GetWindowLongPtr(pipa->Children[i].hWnd,
                                               GWLP_WNDPROC);

                SetWindowLongPtr(pipa->Children[i].hWnd,
                                 GWLP_WNDPROC, (LONG_PTR)IPAddressFieldProc);

            }

            IP_OnSetFont(pipa, NULL, FALSE);
            for (i = 0; i < NUM_FIELDS; ++i)
                ShowWindow(pipa->Children[i].hWnd, SW_SHOW);


#undef pcs
        }
        else
            DestroyWindow(hWnd);
    }
        lResult = 0;
        break;

    case WM_PAINT: /* paint IPADDR window */
    {
        PAINTSTRUCT Ps;
        RECT rect;
        COLORREF TextColor;
        COLORREF cRef;
        HFONT OldFont;

        BeginPaint(hWnd, (LPPAINTSTRUCT)&Ps);
        OldFont = SelectObject( Ps.hdc, pipa->hfont);
        GetClientRect(hWnd, &rect);
        if (pipa->fEnabled)
        {
            TextColor = GetSysColor(COLOR_WINDOWTEXT);
            cRef = GetSysColor(COLOR_WINDOW);
        }
        else
        {
            TextColor = GetSysColor(COLOR_GRAYTEXT);
            cRef = GetSysColor(COLOR_3DFACE);
        }

        FillRectClr(Ps.hdc, &rect, cRef);
        SetRect(&rect, 0, HEAD_ROOM, pipa->uiFillerWidth, (rect.bottom-rect.top));


        SetBkColor(Ps.hdc, cRef);
        SetTextColor(Ps.hdc, TextColor);

        for (i = 0; i < NUM_FIELDS-1; ++i)
        {
            rect.left += pipa->uiFieldWidth + pipa->uiFillerWidth;
            rect.right += rect.left + pipa->uiFillerWidth;
            ExtTextOut(Ps.hdc, rect.left, HEAD_ROOM, ETO_OPAQUE, &rect, SZFILLER, 1, NULL);
        }

        pipa->fPainted = TRUE;

        SelectObject(Ps.hdc, OldFont);
        EndPaint(hWnd, &Ps);
    }
        break;

    case WM_SETFOCUS : /* get focus - display caret */
        EnterField(&(pipa->Children[0]), 0, CHARS_PER_FIELD);
        break;
        
        HANDLE_MSG(pipa, WM_SETFONT, IP_OnSetFont);

    case WM_LBUTTONDOWN : /* left button depressed - fall through */
        SetFocus(hWnd);
        break;

    case WM_ENABLE:
    {
        pipa->fEnabled = (BOOL)wParam;
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            EnableWindow(pipa->Children[i].hWnd, (BOOL)wParam);
        }
        if (pipa->fPainted)    
            InvalidateRect(hWnd, NULL, FALSE);
    }
    break;

    case WM_NCPAINT:
        {
            if (pipa->hTheme)
            {
                HRGN hrgn = (wParam != 1) ? (HRGN)wParam : NULL;
                HBRUSH hbr = (HBRUSH)GetClassLongPtr(hWnd, GCLP_HBRBACKGROUND);

                if (CCDrawNonClientTheme(pipa->hTheme, hWnd, hrgn, hbr, 0, CBXS_NORMAL))
                {
                    return TRUE;
                }
            }
        }
        goto DoDefault;


    case WM_DESTROY :
        // Restore all the child window procedures before we delete our memory block.
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            SendMessage(pipa->Children[i].hWnd, WM_DESTROY, 0, 0);
            SetWindowLongPtr(pipa->Children[i].hWnd, GWLP_WNDPROC,
                             (LONG_PTR)pipa->Children[i].lpfnWndProc);
        }

        if (pipa->hTheme)
            CloseThemeData(pipa->hTheme);

        LocalFree(pipa);
        break;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
            // One of the fields lost the focus, see if it lost the focus to another field
            // of if we've lost the focus altogether.  If its lost altogether, we must send
            // an EN_KILLFOCUS notification on up the ladder.
            case EN_KILLFOCUS:
            {
                HWND hFocus;

                if (!pipa->fInMessageBox)
                {
                    hFocus = GetFocus();
                    for (i = 0; i < NUM_FIELDS; ++i)
                        if (pipa->Children[i].hWnd == hFocus)
                            break;

                    if (i >= NUM_FIELDS)
                    {
                        SendMessage(pipa->hwndParent, WM_COMMAND,
                                    MAKEWPARAM(GetDlgCtrlID(hWnd),
                                               EN_KILLFOCUS), (LPARAM)hWnd);
                        pipa->bControlInFocus = FALSE;
                    }
                }
            }
            break;

        case EN_SETFOCUS:
        {
            HWND hFocus;

            if (!pipa->fInMessageBox)
            {
                hFocus = (HWND)lParam;

                for (i = 0; i < NUM_FIELDS; ++i)
                    if (pipa->Children[i].hWnd == hFocus)
                        break;

                // send a focus message when the
                if (i < NUM_FIELDS && pipa->bControlInFocus == FALSE)
                {
                    SendMessage(pipa->hwndParent, WM_COMMAND,
                                MAKEWPARAM(GetDlgCtrlID(hWnd),
                                           EN_SETFOCUS), (LPARAM)hWnd);

                    pipa->bControlInFocus = TRUE; // only set the focus once
                }
            }
        }
            break;

        case EN_CHANGE:
            if (pipa->bCancelParentNotify == FALSE)
            {
                SendMessage(pipa->hwndParent, WM_COMMAND,
                            MAKEWPARAM(GetDlgCtrlID(hWnd), EN_CHANGE), (LPARAM)hWnd);

            }
            break;
        }
        break;

        // Get the value of the IP Address.  The address is placed in the DWORD pointed
        // to by lParam and the number of non-blank fields is returned.
        case IPM_GETADDRESS:
        {
            int iFieldValue;
            DWORD dwValue;

            lResult = 0;
            dwValue = 0;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                iFieldValue = GetFieldValue(&(pipa->Children[i]));
                if (iFieldValue == -1)
                    iFieldValue = 0;
                else
                    ++lResult;
                dwValue = (dwValue << 8) + iFieldValue;
            }
            *((DWORD *)lParam) = dwValue;
        }
        break;

        // Clear all fields to blanks.
        case IPM_CLEARADDRESS:
        {
            pipa->bCancelParentNotify = TRUE;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                SendMessage(pipa->Children[i].hWnd, WM_SETTEXT,
                            0, (LPARAM) (LPSTR) TEXT(""));
            }
            pipa->bCancelParentNotify = FALSE;
            SendMessage(pipa->hwndParent, WM_COMMAND,
                        MAKEWPARAM(GetDlgCtrlID(hWnd), EN_CHANGE), (LPARAM)hWnd);
        }
        break;

        // Set the value of the IP Address.  The address is in the lParam with the
        // first address byte being the high byte, the second being the second byte,
        // and so on.  A lParam value of -1 removes the address.
        case IPM_SETADDRESS:
        {
            pipa->bCancelParentNotify = TRUE;

            for (i = 0; i < NUM_FIELDS; ++i)
            {
                BYTE bVal = HIBYTE(HIWORD(lParam));
                if (pipa->Children[i].byLow <= bVal &&
                    bVal <= pipa->Children[i].byHigh) {
                    SetFieldValue(pipa, i, bVal);

                } else {
                    lResult = FALSE;
                }

                lParam <<= 8;
            }

            pipa->bCancelParentNotify = FALSE;

            SendMessage(pipa->hwndParent, WM_COMMAND,
                        MAKEWPARAM(GetDlgCtrlID(hWnd), EN_CHANGE), (LPARAM)hWnd);
        }
        break;

    case IPM_SETRANGE:
        if (wParam < NUM_FIELDS && LOBYTE(LOWORD(lParam)) <= HIBYTE(LOWORD(lParam)))
        {
            lResult = MAKEIPRANGE(pipa->Children[wParam].byLow, pipa->Children[wParam].byHigh);
            pipa->Children[wParam].byLow = LOBYTE(LOWORD(lParam));
            pipa->Children[wParam].byHigh = HIBYTE(LOWORD(lParam));
            break;
        }
        lResult = 0;
        break;

        // Set the focus to this IPADDR.
        // wParam = the field number to set focus to, or -1 to set the focus to the
        // first non-blank field.
    case IPM_SETFOCUS:

        if (wParam >= NUM_FIELDS)
        {
            for (wParam = 0; wParam < NUM_FIELDS; ++wParam)
                if (GetFieldValue(&(pipa->Children[wParam])) == -1)   break;
            if (wParam >= NUM_FIELDS)    wParam = 0;
        }
        EnterField(&(pipa->Children[wParam]), 0, CHARS_PER_FIELD);
        break;

        // Determine whether all four subfields are blank
    case IPM_ISBLANK:

        lResult = TRUE;
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            if (GetFieldValue(&(pipa->Children[i])) != -1)
            {
                lResult = FALSE;
                break;
            }
        }
        break;

    default:
DoDefault:
        lResult = DefWindowProc( hWnd, wMsg, wParam, lParam );
        break;
    }
    return( lResult );
}




/*
 IPAddressFieldProc() - Edit field window procedure

 This function sub-classes each edit field.
 */
LRESULT IPAddressFieldProc(HWND hWnd,
                                   UINT wMsg,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    IPADDR *pipa;
    FIELD *pField;
    HWND hIPADDRWindow;
    WORD wChildID;
    LRESULT lresult;

    if (!(hIPADDRWindow = GetParent(hWnd)))
        return 0;

    pipa = (IPADDR *)GET_IPADDR_HANDLE(hIPADDRWindow);
    if (!pipa)
        return 0;
    
    wChildID = (WORD)GET_IPADDR_HANDLE(hWnd);
    pField = &(pipa->Children[wChildID]);

    if (pField->hWnd != hWnd)    
        return 0;

    switch (wMsg)
    {
    case WM_DESTROY:
        DeleteObject((HGDIOBJ)SendMessage(hWnd, WM_GETFONT, 0, 0));
        return 0;

    case WM_CHAR:

        // Typing in the last digit in a field, skips to the next field.
        if (wParam >= TEXT('0') && wParam <= TEXT('9'))
        {
            LRESULT lResult;

            lResult = CallWindowProc(pipa->Children[wChildID].lpfnWndProc,
                                      hWnd, wMsg, wParam, lParam);
            lResult = SendMessage(hWnd, EM_GETSEL, 0, 0L);

            if (lResult == MAKELPARAM(CHARS_PER_FIELD, CHARS_PER_FIELD)
                && ExitField(pipa, wChildID)
                && wChildID < NUM_FIELDS-1)
            {
                EnterField(&(pipa->Children[wChildID+1]),
                           0, CHARS_PER_FIELD);
            }
            return lResult;
        }

        // spaces and periods fills out the current field and then if possible,
        // goes to the next field.
        else if (wParam == FILLER || wParam == SPACE )
        {
            LRESULT lResult;
            lResult = SendMessage(hWnd, EM_GETSEL, 0, 0L);
            if (lResult != 0L && HIWORD(lResult) == LOWORD(lResult)
                && ExitField(pipa, wChildID))
            {
                if (wChildID >= NUM_FIELDS-1)
                    MessageBeep((UINT)-1);
                else
                {
                    EnterField(&(pipa->Children[wChildID+1]),
                               0, CHARS_PER_FIELD);
                }
            }
            return 0;
        }

        // Backspaces go to the previous field if at the beginning of the current field.
        // Also, if the focus shifts to the previous field, the backspace must be
        // processed by that field.
        else if (wParam == BACK_SPACE)
        {
            if (wChildID > 0 && SendMessage(hWnd, EM_GETSEL, 0, 0L) == 0L)
            {
                if (SwitchFields(pipa, wChildID, wChildID-1,
                                 CHARS_PER_FIELD, CHARS_PER_FIELD)
                    && SendMessage(pipa->Children[wChildID-1].hWnd,
                                   EM_LINELENGTH, 0, 0L) != 0L)
                {
                    SendMessage(pipa->Children[wChildID-1].hWnd,
                                wMsg, wParam, lParam);
                }
                return 0;
            }
        }

        // Any other printable characters are not allowed.
        else if (wParam > SPACE)
        {
            MessageBeep((UINT)-1);
            return 0;
        }
        break;

    case WM_KEYDOWN:
        switch (wParam)
        {

            // Arrow keys move between fields when the end of a field is reached.
            case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            if (GetKeyState(VK_CONTROL) < 0)
            {
                if ((wParam == VK_LEFT || wParam == VK_UP) && wChildID > 0)
                {
                    SwitchFields(pipa, wChildID, wChildID-1,
                                 0, CHARS_PER_FIELD);
                    return 0;
                }
                else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                         && wChildID < NUM_FIELDS-1)
                {
                    SwitchFields(pipa, wChildID, wChildID+1,
                                 0, CHARS_PER_FIELD);
                    return 0;
                }
            }
            else
            {
                DWORD dwResult;
                WORD wStart, wEnd;

                dwResult = (DWORD)SendMessage(hWnd, EM_GETSEL, 0, 0L);
                wStart = LOWORD(dwResult);
                wEnd = HIWORD(dwResult);
                if (wStart == wEnd)
                {
                    if ((wParam == VK_LEFT || wParam == VK_UP)
                        && wStart == 0
                        && wChildID > 0)
                    {
                        SwitchFields(pipa, wChildID, wChildID-1,
                                     CHARS_PER_FIELD, CHARS_PER_FIELD);
                        return 0;
                    }
                    else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                             && wChildID < NUM_FIELDS-1)
                    {
                        dwResult = (DWORD)SendMessage(hWnd, EM_LINELENGTH, 0, 0L);
                        if (wStart >= dwResult)
                        {
                            SwitchFields(pipa, wChildID, wChildID+1, 0, 0);
                            return 0;
                        }
                    }
                }
            }
            break;

            // Home jumps back to the beginning of the first field.
            case VK_HOME:
                if (wChildID > 0)
                {
                    SwitchFields(pipa, wChildID, 0, 0, 0);
                    return 0;
                }
            break;

            // End scoots to the end of the last field.
            case VK_END:
                if (wChildID < NUM_FIELDS-1)
                {
                    SwitchFields(pipa, wChildID, NUM_FIELDS-1,
                                 CHARS_PER_FIELD, CHARS_PER_FIELD);
                    return 0;
                }
            break;


        } // switch (wParam)

        break;

    case WM_KILLFOCUS:
        if ( !ExitField( pipa, wChildID ))
        {
            return 0;
        }

    } // switch (wMsg)

    lresult = CallWindowProc( pipa->Children[wChildID].lpfnWndProc,
                             hWnd, wMsg, wParam, lParam);
    return lresult;
}




/*
 Switch the focus from one field to another.
 call
 pipa = Pointer to the IPADDR structure.
 iOld = Field we're leaving.
 iNew = Field we're entering.
 hNew = Window of field to goto
 wStart = First character selected
 wEnd = Last character selected + 1
 returns
 TRUE on success, FALSE on failure.

 Only switches fields if the current field can be validated.
 */
BOOL SwitchFields(IPADDR *pipa, int iOld, int iNew, WORD wStart, WORD wEnd)
{
    if (!ExitField(pipa, iOld))    return FALSE;
    EnterField(&(pipa->Children[iNew]), wStart, wEnd);
    return TRUE;
}



/*
 Set the focus to a specific field's window.
 call
 pField = pointer to field structure for the field.
 wStart = First character selected
 wEnd = Last character selected + 1
 */
void EnterField(FIELD *pField, WORD wStart, WORD wEnd)
{
    SetFocus(pField->hWnd);
    SendMessage(pField->hWnd, EM_SETSEL, wStart, wEnd);
}

void SetFieldValue(IPADDR *pipa, int iField, int iValue)
{
    TCHAR szBuf[CHARS_PER_FIELD+1];
    FIELD* pField = &(pipa->Children[iField]);

    wsprintf(szBuf, TEXT("%d"), iValue);
    SendMessage(pField->hWnd, WM_SETTEXT, 0, (LPARAM) (LPSTR) szBuf);
}

/*
 Exit a field.
 call
 pipa = pointer to IPADDR structure.
 iField = field number being exited.
 returns
 TRUE if the user may exit the field.
 FALSE if he may not.
 */
BOOL ExitField(IPADDR  *pipa, int iField)
{
    FIELD *pField;
    int i;
    NMIPADDRESS nm;
    int iOldValue;

    pField = &(pipa->Children[iField]);
    i = GetFieldValue(pField);
    iOldValue = i;
    
    nm.iField = iField;
    nm.iValue = i;
    
    SendNotifyEx(pipa->hwndParent, pipa->hwnd, IPN_FIELDCHANGED, &nm.hdr, FALSE);
    i = nm.iValue;
    
    if (i != -1) {

        if (i < (int)(UINT)pField->byLow || i > (int)(UINT)pField->byHigh)
        {
            
            if ( i < (int)(UINT) pField->byLow )
            {
                /* too small */
                i = (int)(UINT)pField->byLow;
            }
            else
            {
                /* must be bigger */
                i = (int)(UINT)pField->byHigh;
            }
            SetFieldValue(pipa, iField, i);
            // FEATURE: send notify up
            return FALSE;
        }
    } 

    if (iOldValue != i) {
        SetFieldValue(pipa, iField, i);
    }
    return TRUE;
}


/*
 Get the value stored in a field.
 call
 pField = pointer to the FIELD structure for the field.
 returns
 The value (0..255) or -1 if the field has not value.
 */
int GetFieldValue(FIELD *pField)
{
    WORD wLength;
    TCHAR szBuf[CHARS_PER_FIELD+1];
    INT i;

    *(WORD *)szBuf = (sizeof(szBuf)/sizeof(TCHAR)) - 1;
    wLength = (WORD)SendMessage(pField->hWnd,EM_GETLINE,0,(LPARAM)(LPSTR)szBuf);
    if (wLength != 0)
    {
        szBuf[wLength] = TEXT('\0');
        i = StrToInt(szBuf);
        return i;
    }
    else
        return -1;
}



BOOL IsDBCS()
{
    LANGID langid;
    langid = PRIMARYLANGID(GetThreadLocale());
    if (langid == LANG_CHINESE || langid == LANG_JAPANESE || langid == LANG_KOREAN)
    {
        return (TRUE);
    }
    else
    {
        return (FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\listbox.h ===
#ifndef __LISTBOX_H__
#define __LISTBOX_H__

#include "combo.h"  // for CBOX defn

//
//  Return Values
//
#define EQ              0
#define PREFIX          1
#define LT              2
#define GT              3

#define SINGLESEL       0
#define MULTIPLESEL     1
#define EXTENDEDSEL     2

#define LBI_ADD     0x0004


//
//  The various bits of wFileDetails field are used as mentioned below:
//    0x0001    Should the file name be in upper case.
//    0x0002    Should the file size be shown.
//    0x0004    Date stamp of the file to be shown ?
//    0x0008    Time stamp of the file to be shown ?
//    0x0010    The dos attributes of the file ?
//    0x0020    In DlgDirSelectEx(), along with file name
//              all other details also will be returned
//
#define LBUP_RELEASECAPTURE 0x0001
#define LBUP_RESETSELECTION 0x0002
#define LBUP_NOTIFY         0x0004
#define LBUP_SUCCESS        0x0008
#define LBUP_SELCHANGE      0x0010


//
//  System timer IDs used be listbox
//
#define IDSYS_LBSEARCH      0x0000FFFCL
#define IDSYS_SCROLL        0x0000FFFEL
#define IDSYS_CARET         0x0000FFFFL


//
//  Parameter for AlterHilite()
//
#define HILITEONLY          0x0001
#define SELONLY             0x0002
#define HILITEANDSEL        (HILITEONLY + SELONLY)

#define HILITE     1


//
//  Listbox macros
//
#define IsLBoxVisible(plb)  \
            (plb->fRedraw && IsWindowVisible(plb->hwnd))

#define CaretCreate(plb)    \
            ((plb)->fCaret = TRUE)

//
//from sysmet.c
//
#define SCROLL_TIMEOUT()    \
            ((GetDoubleClickTime()*4)/5)

//
//  We don't need 64-bit intermediate precision so we use this macro
//  instead of calling MulDiv.
//
#define MultDiv(x, y, z)    \
            (((INT)(x) * (INT)(y) + (INT)(z) / 2) / (INT)(z))

//
// Instance data pointer access functions
//
#define ListBox_GetPtr(hwnd)    \
            (PLBIV)GetWindowPtr(hwnd, 0)

#define ListBox_SetPtr(hwnd, p) \
            (PLBIV)SetWindowPtr(hwnd, 0, p)

//
//  List Box
//
typedef struct tagSCROLLPOS 
{
    INT     cItems;
    UINT    iPage;
    INT     iPos;
    UINT    fMask;
    INT     iReturn;
} SCROLLPOS, *PSCROLLPOS;

typedef struct tagLBIV 
{
    HWND    hwnd;           // lbox ctl window
    HWND    hwndParent;     // lbox parent
    HTHEME  hTheme;         // Handle to the theme manager
    PWW     pww;            // RO pointer into the pwnd to ExStyle, Style, State, State2
    INT     iTop;           // index of top item displayed
    INT     iSel;           // index of current item selected
    INT     iSelBase;       // base sel for multiple selections
    INT     cItemFullMax;   // cnt of Fully Visible items. Always contains
                            // result of ListBox_CItemInWindow(plb, FALSE) for fixed
                            // height listboxes. Contains 1 for var height
                            // listboxes.
    INT     cMac;           // cnt of items in listbox
    INT     cMax;           // cnt of total # items allocated for rgpch.
                            // Not all are necessarly in use
    PBYTE   rgpch;          // pointer to array of string offsets
    LPWSTR  hStrings;       // string storage handle
    INT     cchStrings;     // Size in bytes of hStrings
    INT     ichAlloc;       // Pointer to end of hStrings (end of last valid
                            // string)
    INT     cxChar;         // Width of a character
    INT     cyChar;         // height of line
    INT     cxColumn;       // width of a column in multicolumn listboxes
    INT     itemsPerColumn; // for multicolumn listboxes
    INT     numberOfColumns;// for multicolumn listboxes
    POINT   ptPrev;         // coord of last tracked mouse pt. used for auto
                            //   scrolling the listbox during timer's

    UINT    OwnerDraw:2;    // Owner draw styles. Non-zero if ownerdraw.
    UINT    fRedraw:1;      // if TRUE then do repaints
    UINT    fDeferUpdate:1; 
    UINT    wMultiple:2;    // SINGLESEL allows a single item to be selected.
                            // MULTIPLESEL allows simple toggle multi-selection
                            // EXTENDEDSEL allows extended multi selection;

    UINT    fSort:1;        // if TRUE the sort list
    UINT    fNotify:1;      // if TRUE then Notify parent
    UINT    fMouseDown:1;   // if TRUE then process mouse moves/mouseup
    UINT    fCaptured:1;    // if TRUE then process mouse messages
    UINT    fCaret:1;       // flashing caret allowed
    UINT    fDoubleClick:1; // mouse down in double click
    UINT    fCaretOn:1;     // if TRUE then caret is on
    UINT    fAddSelMode:1;  // if TRUE, then it is in ADD selection mode */
    UINT    fHasStrings:1;  // True if the listbox has a string associated
                            // with each item else it has an app suppled LONG
                            // value and is ownerdraw

    UINT    fHasData:1;     // if FALSE, then lb doesn't keep any line data
                            // beyond selection state, but instead calls back
                            // to the client for each line's definition.
                            // Forces OwnerDraw==OWNERDRAWFIXED, !fSort,
                            // and !fHasStrings.

    UINT    fNewItemState:1;// select/deselect mode? for multiselection lb
    UINT    fUseTabStops:1; // True if the non-ownerdraw listbox should handle tabstops
    UINT    fMultiColumn:1; // True if this is a multicolumn listbox
    UINT    fNoIntegralHeight:1;    // True if we don't want to size the listbox
                                    // an integral lineheight
    UINT    fWantKeyboardInput:1;   // True if we should pass on WM_KEY & CHAR
                                    // so that the app can go to special items
                                    // with them.
    UINT    fDisableNoScroll:1;     // True if the listbox should
                                    // automatically Enable/disable
                                    // it's scroll bars. If false, the scroll
                                    // bars will be hidden/Shown automatically
                                    // if they are present.
    UINT    fHorzBar:1;     // TRUE if WS_HSCROLL specified at create time

    UINT    fVertBar:1;     // TRUE if WS_VSCROLL specified at create time
    UINT    fFromInsert:1;  // TRUE if client drawing should be deferred during delete/insert ops
    UINT    fNoSel:1;

    UINT    fHorzInitialized : 1;   // Horz scroll cache initialized
    UINT    fVertInitialized : 1;   // Vert scroll cache initialized

    UINT    fSized : 1;             // Listbox was resized.
    UINT    fIgnoreSizeMsg : 1;     // If TRUE, ignore WM_SIZE message

    UINT    fInitialized : 1;

    UINT    fRightAlign:1;  // used primarily for MidEast right align
    UINT    fRtoLReading:1; // used only for MidEast, text rtol reading order
    UINT    fSmoothScroll:1;// allow just one smooth-scroll per scroll cycle

    int     xRightOrigin;   // For horizontal scrolling. The current x origin

    INT     iLastSelection; // Used for cancelable selection. Last selection
                            // in listbox for combo box support
    INT     iMouseDown;     // For multiselection mouse click & drag extended
                            // selection. It is the ANCHOR point for range selections
    INT     iLastMouseMove; // selection of listbox items
    
    // IanJa/Win32: Tab positions remain int for 32-bit API ??
    LPINT   iTabPixelPositions; // List of positions for tabs
    HANDLE  hFont;          // User settable font for listboxes
    int     xOrigin;        // For horizontal scrolling. The current x origin
    int     maxWidth;       // Maximum width of listbox in pixels for
                            // horizontal scrolling purposes
    PCBOX   pcbox;          // Combo box pointer
    HDC     hdc;            // hdc currently in use
    DWORD   dwLocaleId;     // Locale used for sorting strings in list box
    int     iTypeSearch;
    LPWSTR  pszTypeSearch;
    SCROLLPOS HPos;
    SCROLLPOS VPos;
} LBIV, *PLBIV;

//
// rgpch is set up as follows:  First there are cMac 2 byte pointers to the
// start of the strings in hStrings or if ownerdraw, it is 4 bytes of data
// supplied by the app and hStrings is not used.  Then if multiselection
// listboxes, there are cMac 1 byte selection state bytes (one for each item
// in the list box).  If variable height owner draw, there will be cMac 1 byte
// height bytes (once again, one for each item in the list box.).
//
// CHANGES DONE BY SANKAR:
// The selection byte in rgpch is divided into two nibbles. The lower
// nibble is the selection state (1 => Selected; 0 => de-selected)
// and higher nibble is the display state(1 => Hilited and 0 => de-hilited).
// You must be wondering why on earth we should store this selection state and
// the display state seperately.Well! The reason is as follows:
// While Ctrl+Dragging or Shift+Ctrl+Dragging, the user can adjust the
// selection before the mouse button is up. If the user enlarges a range and
// and before the button is up if he shrinks the range, then the old selection
// state has to be preserved for the individual items that do not fall in the
// range finally.
// Please note that the display state and the selection state for an item
// will be the same except when the user is dragging his mouse. When the mouse
// is dragged, only the display state is updated so that the range is hilited
// or de-hilited) but the selection state is preserved. Only when the button
// goes up, for all the individual items in the range, the selection state is
// made the same as the display state.
//


typedef struct tagLBItem 
{
    LONG offsz;
    ULONG_PTR itemData;
} LBItem, *lpLBItem;


typedef struct tagLBODItem 
{
    ULONG_PTR itemData;
} LBODItem, *lpLBODItem;


extern WORD DbcsCombine(HWND hwnd, WORD ch);
extern VOID GetCharDimensions(HDC hDC, SIZE *psiz);

//
// Listbox function prototypes
//

extern LRESULT ListBox_WndProc(
    HWND hwnd, 
    UINT msg, 
    WPARAM wParam,
    LPARAM lParam);


// in listbox.c
LPWSTR GetLpszItem(PLBIV, INT);
VOID   ListBox_HSrollMultiColumn(PLBIV, INT, INT);
INT    ListBox_GetVarHeightItemHeight(PLBIV, INT);
INT    ListBox_VisibleItemsVarOwnerDraw(PLBIV, BOOL);
INT    ListBox_Page(PLBIV, INT, BOOL);
INT    ListBox_CalcVarITopScrollAmt(PLBIV, INT, INT);
VOID   ListBox_SetCItemFullMax(PLBIV);
VOID   ListBox_DoDeleteItems(PLBIV);
void   ListBox_InitHStrings(PLBIV);
VOID   ListBox_Event(PLBIV, UINT, int);


// in listbox_ctl1.c
int      ListBox_SetScrollParms(PLBIV plb, int nCtl);
VOID     ListBox_ShowHideScrollBars(PLBIV);
LONG_PTR ListBox_GetItemDataHandler(PLBIV, INT);
INT      ListBox_GetTextHandler(PLBIV, BOOL, BOOL, INT, LPWSTR);
LONG     ListBox_InitStorage(PLBIV plb, BOOL fAnsi, INT cItems, INT cb);
int      ListBox_InsertItem(PLBIV, LPWSTR, int, UINT);
BOOL     ListBox_ResetContentHandler(PLBIV plb);
INT      ListBox_DeleteStringHandler(PLBIV, INT);
VOID     ListBox_DeleteItem(PLBIV, INT);
INT      ListBox_SetCount(PLBIV, INT);


// in listbox_ctl2.c
BOOL    ListBox_InvalidateRect(PLBIV plb, LPRECT lprc, BOOL fErase);
HBRUSH  ListBox_GetBrush(PLBIV plb, HBRUSH *phbrOld);
BOOL    ListBox_GetItemRectHandler(PLBIV, INT, LPRECT);
VOID    ListBox_SetCaret(PLBIV, BOOL);
BOOL    ListBox_IsSelected(PLBIV, INT, UINT);
INT     ListBox_CItemInWindow(PLBIV, BOOL);
VOID    ListBox_VScroll(PLBIV, INT, INT);
VOID    ListBox_HScroll(PLBIV, INT, INT);
VOID    ListBox_Paint(PLBIV, HDC, LPRECT);
BOOL    ListBox_ISelFromPt(PLBIV, POINT, LPDWORD);
VOID    ListBox_InvertItem(PLBIV, INT, BOOL);
VOID    ListBox_NotifyOwner(PLBIV, INT);
VOID    ListBox_SetISelBase(PLBIV, INT);
VOID    ListBox_TrackMouse(PLBIV, UINT, POINT);
void    ListBox_ButtonUp(PLBIV plb, UINT uFlags);
VOID    ListBox_NewITop(PLBIV, INT);
VOID    ListBox_InsureVisible(PLBIV, INT, BOOL);
VOID    ListBox_KeyInput(PLBIV, UINT, UINT);
int     Listbox_FindStringHandler(PLBIV, LPWSTR, INT, INT, BOOL);
VOID    ListBox_CharHandler(PLBIV, UINT, BOOL);
INT     ListBox_GetSelItemsHandler(PLBIV, BOOL, INT, LPINT);
VOID    ListBox_SetRedraw(PLBIV plb, BOOL fRedraw);
VOID    ListBox_SetRange(PLBIV, INT, INT, BOOL);
INT     ListBox_SetCurSelHandler(PLBIV, INT);
int     ListBox_SetItemDataHandler(PLBIV, INT, LONG_PTR);
VOID    ListBox_CheckRedraw(PLBIV, BOOL, INT);
VOID    ListBox_CaretDestroy(PLBIV);
LONG    ListBox_SetSelHandler(PLBIV, BOOL, INT);


// in listbox_ctl3.c
INT  ListBox_DirHandler(PLBIV, UINT, LPWSTR);
INT  ListBox_InsertFile(PLBIV, LPWSTR);


#endif // __LISTBOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\listbox_ctl3.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "listbox.h"


//---------------------------------------------------------------------------//
//
// Directory ListBox Routines
//


//---------------------------------------------------------------------------//
//
// ListBox_CreateLine
//
// This creates a character string that contains all the required
// details of a file;( Name)
//
VOID ListBox_CreateLine(PWIN32_FIND_DATA pffd, LPWSTR lpBuffer)
{
    BYTE   bAttribute;
    LPWSTR lpch;

    lpch = lpBuffer;

    bAttribute = (BYTE)pffd->dwFileAttributes;
    if (bAttribute & DDL_DIRECTORY)
    {
        //
        // Is it a directory
        //
        *lpch++ = TEXT('[');
    }

    wcscpy(lpch, pffd->cFileName);

    lpch = (LPWSTR)(lpch + wcslen(lpch));

    if (bAttribute & DDL_DIRECTORY)
    {
        //
        // Is it a directory
        //
        *lpch++ = TEXT(']');
    }

    *lpch = TEXT('\0');

#ifndef UNICODE
    OemToChar(lpBuffer, lpBuffer);
#endif

    *lpch = TEXT('\0');  // Null terminate
}


//---------------------------------------------------------------------------//
//
// ListBox_DirHandler
//
// Note that these FILE_ATTRIBUTE_* values map directly with
// their DDL_* counterparts, with the exception of FILE_ATTRIBUTE_NORMAL.
//
#define FIND_ATTR ( \
        FILE_ATTRIBUTE_NORMAL | \
        FILE_ATTRIBUTE_DIRECTORY | \
        FILE_ATTRIBUTE_HIDDEN | \
        FILE_ATTRIBUTE_SYSTEM | \
        FILE_ATTRIBUTE_ARCHIVE | \
        FILE_ATTRIBUTE_READONLY )
#define EXCLUDE_ATTR ( \
        FILE_ATTRIBUTE_DIRECTORY | \
        FILE_ATTRIBUTE_HIDDEN | \
        FILE_ATTRIBUTE_SYSTEM )

INT ListBox_DirHandler(PLBIV plb, UINT attrib, LPWSTR lhszFileSpec)
{
    INT    result;
    BOOL   fWasVisible, bRet;
    WCHAR  Buffer[MAX_PATH + 1];
    WCHAR  Buffer2[MAX_PATH + 1];
    HANDLE hFind;
    WIN32_FIND_DATA ffd;
    UINT   attribFile;
    DWORD  mDrives;
    INT    cDrive;
    UINT   attribInclMask, attribExclMask;


    //
    // Make sure the buffer is valid and copy it onto the stack. Why? Because
    // there is a chance that lhszFileSpec is pointing to an invalid string
    // because some app posted a CB_DIR or LB_DIR without the DDL_POSTMSGS
    // bit set.
    //
    try 
    {
        wcsncpy(Buffer2, lhszFileSpec, ARRAYSIZE(Buffer2));
        lhszFileSpec = Buffer2;
    } 
    except (UnhandledExceptionFilter( GetExceptionInformation() )) 
    {
        return -1;
    }
    __endexcept

    result = -1;

#ifndef UNICODE
    CharToOem(lhszFileSpec, lhszFileSpec);
#endif

    fWasVisible = IsLBoxVisible(plb);
    if (fWasVisible) 
    {
        SendMessage(plb->hwnd, WM_SETREDRAW, FALSE, 0);
    }

    //
    // First we add the files then the directories and drives.
    // If they only wanted drives then skip the file query
    // Also under Windows specifing only 0x8000 (DDL_EXCLUSIVE) adds no files).
    //


    // if ((attrib != (DDL_EXCLUSIVE | DDL_DRIVES)) && (attrib != DDL_EXCLUSIVE) &&
    if (attrib != (DDL_EXCLUSIVE | DDL_DRIVES | DDL_NOFILES)) 
    {
        hFind = FindFirstFile(lhszFileSpec, &ffd);

        if (hFind != INVALID_HANDLE_VALUE) 
        {

            //
            // If this is not an exclusive search, include normal files.
            //
            attribInclMask = attrib & FIND_ATTR;
            if (!(attrib & DDL_EXCLUSIVE))
            {
                attribInclMask |= FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_READONLY |
                        FILE_ATTRIBUTE_ARCHIVE;
            }

            //
            // Make a mask of the attributes to be excluded from
            // the search.
            //
            attribExclMask = ~attrib & EXCLUDE_ATTR;

            //
            // LATER BUG - scottlu
            // Win3 assumes doing a LoadCursor here will return the same wait cursor that
            // has already been created, whereas calling ServerLoadCursor creates a new
            // one every time!
            // hCursorT = NtUserSetCursor(ServerLoadCursor(NULL, IDC_WAIT));


            // FindFirst/Next works different in NT then DOS.  Under DOS you passed in
            // a set of attributes under NT you get back a set of attributes and have
            // to test for those attributes (Dos input attributes were Hidden, System
            // and Directoy) the dos find first always returned ReadOnly and archive files

            // we are going to select a file in one of two cases.
            // 1) if any of the attrib bits are set on the file.
            // 2) if we want normal files and the file is a notmal file (the file attrib
            //    bits don't contain any NOEXCLBITS
            //

            do 
            {
                attribFile = (UINT)ffd.dwFileAttributes;
                if (attribFile == FILE_ATTRIBUTE_COMPRESSED) 
                {
                    attribFile = FILE_ATTRIBUTE_NORMAL;
                }
                attribFile &= ~FILE_ATTRIBUTE_COMPRESSED;

                //
                // Accept those files that have only the
                // attributes that we are looking for.
                //
                if ((attribFile & attribInclMask) != 0 &&
                        (attribFile & attribExclMask) == 0) 
                {
                    BOOL fCreate = TRUE;
                    if (attribFile & DDL_DIRECTORY) 
                    {

                        //
                        // Don't include '.' (current directory) in list.
                        //
                        if (*((LPDWORD)&ffd.cFileName[0]) == 0x0000002E)
                        {
                            fCreate = FALSE;
                        }

                        //
                        // If we're not looking for dirs, ignore it
                        //
                        if (!(attrib & DDL_DIRECTORY))
                        {
                            fCreate = FALSE;
                        }

                    } 
                    else if (attrib & DDL_NOFILES) 
                    {
                        //
                        // Don't include files if DDL_NOFILES is set.
                        //
                        fCreate = FALSE;
                    }

                    if (fCreate)
                    {
                        ListBox_CreateLine(&ffd, Buffer);
                        result = ListBox_InsertItem(plb, Buffer, 0, LBI_ADD);
                    }
                }
                bRet = FindNextFile(hFind, &ffd);

            } 
            while (result >= -1 && bRet);

            FindClose(hFind);

            // LATER see above comment
            // NtUserSetCursor(hCursorT);
        }
    }

    //
    // If drive bit set, include drives in the list.
    //
    if (result != LB_ERRSPACE && (attrib & DDL_DRIVES)) 
    {
        ffd.cFileName[0] = TEXT('[');
        ffd.cFileName[1] = ffd.cFileName[3] = TEXT('-');
        ffd.cFileName[4] = TEXT(']');
        ffd.cFileName[5] = 0;

        mDrives = GetLogicalDrives();

        for (cDrive = 0; mDrives; mDrives >>= 1, cDrive++) 
        {
            if (mDrives & 1) 
            {
                ffd.cFileName[2] = (WCHAR)(TEXT('A') + cDrive);

                //
                // We have to set the SPECIAL_THUNK bit because we are
                // adding a server side string to a list box that may not
                // be HASSTRINGS so we have to force the server-client
                // string thunk.
                //
                if ((result = ListBox_InsertItem(plb, CharLower(ffd.cFileName), -1,
                        0)) < 0) 
                {
                    break;
                }
            }
        }
    }

    if (result == LB_ERRSPACE) 
    {
        ListBox_NotifyOwner(plb, LB_ERRSPACE);
    }

    if (fWasVisible) 
    {
        SendMessage(plb->hwnd, WM_SETREDRAW, TRUE, 0);
    }

    ListBox_ShowHideScrollBars(plb);

    ListBox_CheckRedraw(plb, FALSE, 0);

    if (result != LB_ERRSPACE) 
    {
        //
        // Return index of last item in the listbox.  We can't just return
        // result because that is the index of the last item added which may
        // be in the middle somewhere if the LBS_SORT style is on.
        //
        return plb->cMac - 1;
    } 
    else 
    {
        return result;
    }
}


//---------------------------------------------------------------------------//
//
// ListBox_InsertFile
//
// Yet another CraigC shell hack... This responds to LB_ADDFILE messages
// sent to directory windows in the file system as a response to the
// WM_FILESYSCHANGE message.  That way, we don't reread the whole
// directory when we copy files.
//
INT ListBox_InsertFile(PLBIV plb, LPWSTR lpFile)
{
    WCHAR  chBuffer[MAX_PATH + 1];
    INT    result = -1;
    HANDLE hFind;
    WIN32_FIND_DATA ffd;

    hFind = FindFirstFile(lpFile, &ffd);
    if (hFind != INVALID_HANDLE_VALUE) 
    {
        FindClose(hFind);
        ListBox_CreateLine(&ffd, chBuffer);
        result = ListBox_InsertItem(plb, chBuffer, 0, LBI_ADD);
    }

    if (result == LB_ERRSPACE) 
    {
        ListBox_NotifyOwner(plb, result);
    }

    ListBox_CheckRedraw(plb, FALSE, 0);

    return result;
}




//---------------------------------------------------------------------------//
//
// Public ListBox APIs support.
//

// Uncomment the following to include support for these
//#define INCLUDE_LISTBOX_FUNCTIONS
#ifdef  INCLUDE_LISTBOX_FUNCTIONS



//---------------------------------------------------------------------------//
//
//  Defines and common macros
//

#define TABCHAR        TEXT('\t')

#define DDL_PRIVILEGES  (DDL_READONLY | DDL_HIDDEN | DDL_SYSTEM | DDL_ARCHIVE)
#define DDL_TYPE        (DDL_DRIVES | DDL_DIRECTORY | DDL_POSTMSGS)

#define CHARSTOBYTES(cch) ((cch) * sizeof(TCHAR))

#define CCH_CHOPTEXT_EXTRA 7
#define AWCHLEN(a) ((sizeof(a)/sizeof(a[0])) - 1)



//---------------------------------------------------------------------------//
//
// Globals
//
WCHAR awchSlashStar[] = L"\\*";
CHAR  achSlashStar[] = "\\*";
WCHAR szSLASHSTARDOTSTAR[] = TEXT("\\*");  /* This is a single "\"  */


//---------------------------------------------------------------------------//
//
// ChopText
//
// Chops the given path at 'lpchBuffer' + CCH_CHOPTEXT_EXTRA to fit in the
// field of the static control with id 'idStatic' in the dialog box 'hwndDlg'.
// If the path is too long, an ellipsis prefix is added to the beginning of the
// chopped text ("x:\...\")
//
// If the supplied path does not fit and the last directory appended to
// ellipsis (i.e. "c:\...\eee" in the case of "c:\aaa\bbb\ccc\ddd\eee")
// does not fit, then "x:\..." is returned.
//
// Pathological case:
// "c:\SW\MW\R2\LIB\SERVICES\NT" almost fits into static control, while
// "c:\...\MW\R2\LIB\SERVICES\NT" does fit - although it is more characters.
// In this case, ChopText substitutes the first 'n' characters of the path with
// a prefix containing MORE than 'n' characters!  The extra characters will
// be put in front of lpch, so there must be space reserved for them or they
// will trash the stack.  lpch contains CCH_CHOPTEXT_EXTRA chars followed by
// the path.
//
// In practice CCH_CHOPTEXT_EXTRA probably never has to be more than 1 or 2,
// but in case the font is weird, set it to the number of chars in the prefix.
// This guarantees enough space to prepend the prefix.
//
LPWSTR ChopText(HWND hwndDlg, INT idStatic, LPWSTR lpchBuffer)
{
    HWND   hwndStatic;
    LPWSTR lpszRet;

    lpszRet = NULL;

    // 
    // Get length of static field.
    //
    hwndStatic = GetDlgItem(hwndDlg, idStatic);
    if (hwndStatic)
    {
        //
        // Declaring szPrefix this way ensures CCH_CHOPTEXT_EXTRA is big enough
        //
        WCHAR  szPrefix[CCH_CHOPTEXT_EXTRA + 1] = L"x:\\...\\";
        INT    cxField;
        RECT   rc;
        SIZE   size;
        PSTAT  pstat;
        HDC    hdc;
        HFONT  hOldFont;
        INT    cchPath;
        LPWSTR lpch;
        LPWSTR lpchPath;
        TCHAR  szClassName[MAX_PATH];

        GetClientRect(hwndStatic, &rc);
        cxField = rc.right - rc.left;

        //
        // Set up DC appropriately for the static control.
        //
        hdc = GetDC(hwndStatic);

        //
        // Only assume this is a static window if this window uses the 
        // static window wndproc.
        //
        hOldFont = NULL;
        if (GetClassName(hwndStatic, szClassName, ARRAYSIZE(szClassName) &&
            lstrcmpi(WC_STATIC, szClassName) == 0))
        {
            pstat = Static_GetPtr(hwndStatic);
            if (pstat != NULL && pstat != (PSTAT)-1 && pstat->hFont)
            {
                hOldFont = SelectObject(hdc, pstat->hFont);
            }
        }

        //
        // Check horizontal extent of string.
        //
        lpch = lpchPath = lpchBuffer + CCH_CHOPTEXT_EXTRA;
        cchPath = wcslen(lpchPath);
        GetTextExtentPoint(hdc, lpchPath, cchPath, &size);
        if (size.cx > cxField) 
        {

            //
            // String is too long to fit in the static control; chop it.
            // Set up new prefix and determine remaining space in control.
            //
            szPrefix[0] = *lpchPath;
            GetTextExtentPoint(hdc, szPrefix, AWCHLEN(szPrefix), &size);

            //
            // If the field is too small to display all of the prefix,
            // copy only the prefix.
            //
            if (cxField < size.cx) 
            {
                RtlCopyMemory(lpch, szPrefix, sizeof(szPrefix));
            } 
            else
            {
                cxField -= size.cx;

                //
                // Advance a directory at a time until the remainder 
                // of the string fits into the static control after 
                // the "x:\...\" prefix.
                //
                while (TRUE) 
                {
                    INT cchT;

                    while (*lpch && (*lpch++ != L'\\'));

                    cchT = cchPath - (INT)(lpch - lpchPath);
                    GetTextExtentPoint(hdc, lpch, cchT, &size);
                    if (*lpch == 0 || size.cx <= cxField) 
                    {
                        if (*lpch == 0) 
                        {
                            //
                            // Nothing could fit after the prefix; remove 
                            // the final "\" from the prefix
                            //
                            szPrefix[AWCHLEN(szPrefix) - 1] = 0;
                        }

                        // 
                        // rest of string fits -- back up and stick 
                        // prefix on front. We are guaranteed to have 
                        // at least CCH_CHOPTEXT_EXTRA chars backing up 
                        // space, so we won't trash any stack. #26453
                        // 
                        lpch -= AWCHLEN(szPrefix);

                        UserAssert(lpch >= lpchBuffer);

                        RtlCopyMemory(lpch, szPrefix, sizeof(szPrefix) - sizeof(WCHAR));
                        break;
                    }
                }
            }
        }

        if (hOldFont)
        {
            SelectObject(hdc, hOldFont);
        }

        ReleaseDC(hwndStatic, hdc);

        lpszRet = lpch;
    }

    return lpszRet;
}


//---------------------------------------------------------------------------//
//
// DlgDirListHelper
//
//  NOTE:  If idStaticPath is < 0, then that parameter contains the details
//         about what should be in each line of the list box
//
DWORD FindCharPosition(LPWSTR lpString, WCHAR ch)
{
    DWORD dwPos = 0L;

    while (*lpString && *lpString != ch) 
    {
        ++lpString;
        ++dwPos;
    }

    return dwPos;
}


//---------------------------------------------------------------------------//
BOOL DlgDirListHelper(
    HWND   hwndDlg,
    LPWSTR lpszPathSpec,
    LPBYTE lpszPathSpecClient,
    INT    idListBox,
    INT    idStaticPath,
    UINT   attrib,
    BOOL   fListBox)  // Listbox or ComboBox?
{
    HWND   hwndLB;
    BOOL   fDir = TRUE;
    BOOL   fRoot, bRet;
    BOOL   fPostIt;
    INT    cch;
    WCHAR  ch;
    WCHAR  szStaticPath[CCH_CHOPTEXT_EXTRA + MAX_PATH];
    LPWSTR pszCurrentDir;
    UINT   wDirMsg;
    LPWSTR lpchFile;
    LPWSTR lpchDirectory;
    PLBIV  plb;
    BOOL   fWasVisible = FALSE;
    BOOL   fWin40Compat;
    PCBOX  pcbox;
    BOOL   bResult;

    bResult = FALSE;

    //
    // Strip the private bit DDL_NOFILES out - KidPix passes it in my mistake!
    //
    if (attrib & ~DDL_VALID) 
    {
        TraceMsg(TF_STANDARD, "Invalid flags, %x & ~%x != 0", attrib, DDL_VALID);
        bResult = FALSE;
    }
    else
    {
        if (attrib & DDL_NOFILES)
        {
            TraceMsg(TF_STANDARD, "DlgDirListHelper: stripping DDL_NOFILES");
            attrib &= ~DDL_NOFILES;
        }

        //
        // Case:Works is an app that calls DlgDirList with a NULL has hwndDlg;
        // This is allowed because he uses NULL for idStaticPath and idListBox.
        // So, the validation layer has been modified to allow a NULL for hwndDlg.
        // But, we catch the bad apps with the following check.
        // Fix for Bug #11864 --SANKAR-- 08/22/91 --
        //
        if (!hwndDlg && (idStaticPath || idListBox)) 
        {
            TraceMsg(TF_STANDARD, "Passed NULL hwnd but valide control id");
            bResult = FALSE;
        }
        else
        {
            plb = NULL;

            //
            // Do we need to add date, time, size or attribute info?
            // Windows checks the Atom but misses if the class has been sub-classed
            // as in VB.
            //
            hwndLB = GetDlgItem(hwndDlg, idListBox);
            if (hwndLB)
            {
                TCHAR szClassName[MAX_PATH];

                szClassName[0] = 0;
                GetClassName(hwndLB, szClassName, ARRAYSIZE(szClassName));
                if (((lstrcmpi(WC_LISTBOX, szClassName) == 0) && fListBox) ||
                    ((lstrcmpi(WC_COMBOBOX, szClassName) == 0) && !fListBox))
                {
                    if (fListBox) 
                    {
                        plb = ListBox_GetPtr(hwndLB);
                    } 
                    else 
                    {
                        pcbox = ComboBox_GetPtr(hwndLB);
                        plb   = ListBox_GetPtr(pcbox->hwndList);
                    }
                } 
                else 
                {
                    TraceMsg(TF_STANDARD, "Listbox not found in hwnd = %#.4x", hwndDlg);
                }
            } 
            else if (idListBox != 0) 
            {
                //
                // Yell if the app passed an invalid list box id and keep from using a
                // bogus plb.  PLB is NULLed above.
                //
                TraceMsg(TF_STANDARD, "Listbox control id = %d not found in hwnd = %#.4x", 
                         idListBox, hwndDlg);
            }

            if (idStaticPath < 0 && plb != NULL) 
            {
                //
                // Clear idStaticPath because its purpose is over.
                //
                idStaticPath = 0;
            }

            fPostIt = (attrib & DDL_POSTMSGS);

            if (lpszPathSpec) 
            {
                cch = lstrlenW(lpszPathSpec);
                if (!cch) 
                {
                    if (lpszPathSpecClient != (LPBYTE)lpszPathSpec) 
                    {
                        lpszPathSpecClient = achSlashStar;
                    }

                    lpszPathSpec = awchSlashStar;

                } 
                else 
                {
                    //
                    // Make sure we won't overflow our buffers...
                    //
                    if (cch > MAX_PATH)
                    {
                        return FALSE;
                    }

                    //
                    // Convert lpszPathSpec into an upper case, OEM string.
                    //
                    CharUpper(lpszPathSpec);
                    lpchDirectory = lpszPathSpec;

                    lpchFile = szSLASHSTARDOTSTAR + 1;

                    if (*lpchDirectory) 
                    {

                        cch = wcslen(lpchDirectory);

                        //
                        // If the directory name has a * or ? in it, don't bother trying
                        // the (slow) SetCurrentDirectory.
                        //
                        if (((INT)FindCharPosition(lpchDirectory, TEXT('*')) != cch) ||
                            ((INT)FindCharPosition(lpchDirectory, TEXT('?')) != cch) ||
                            !SetCurrentDirectory(lpchDirectory)) 
                        {

                            //
                            // Set 'fDir' and 'fRoot' accordingly.
                            //
                            lpchFile = lpchDirectory + cch;
                            fDir = *(lpchFile - 1) == TEXT('\\');
                            fRoot = 0;
                            while (cch--) 
                            {
                                ch = *(lpchFile - 1);
                                if (ch == TEXT('*') || ch == TEXT('?'))
                                {
                                    fDir = TRUE;
                                }

                                if (ch == TEXT('\\') || ch == TEXT('/') || ch == TEXT(':')) 
                                {
                                    fRoot = (cch == 0 || *(lpchFile - 2) == TEXT(':') ||
                                            (ch == TEXT(':')));
                                    break;
                                }

                                lpchFile--;
                            }

                            //
                            // To remove Bug #16, the following error return is to be removed.
                            // In order to prevent the existing apps from breaking up, it is
                            // decided that the bug will not be fixed and will be mentioned
                            // in the documentation.
                            // --SANKAR-- Sep 21
                            //

                            //
                            // If no wildcard characters, return error.
                            //
                            if (!fDir) 
                            {
                                TraceMsg(TF_ERROR, "No Wildcard characters");
                                return FALSE;
                            }

                            //
                            // Special case for lpchDirectory == "\"
                            //
                            if (fRoot)
                            {
                                lpchFile++;
                            }

                            //
                            // Do we need to change directories?
                            //
                            if (fRoot || cch >= 0) 
                            {

                                //
                                // Replace the Filename's first char with a nul.
                                //
                                ch = *--lpchFile;
                                *lpchFile = TEXT('\0');

                                //
                                // Change the current directory.
                                //
                                if (*lpchDirectory) 
                                {
                                    bRet = SetCurrentDirectory(lpchDirectory);
                                    if (!bRet) 
                                    {

                                        //
                                        // Restore the filename before we return...
                                        //
                                        *((LPWSTR)lpchFile)++ = ch;
                                        return FALSE;
                                    }
                                }

                                //
                                // Restore the filename's first character.
                                //
                                *lpchFile++ = ch;
                            }

                            //
                            // Undo damage caused by special case above.
                            //
                            if (fRoot) 
                            {
                                lpchFile--;
                            }
                        }
                    }

                    //
                    // This is copying on top of the data the client passed us! Since
                    // the LB_DIR or CB_DIR could be posted, and since we need to
                    // pass a client side string pointer when we do that, we need
                    // to copy this new data back to the client!
                    //
                    if (fPostIt && lpszPathSpecClient != (LPBYTE)lpszPathSpec) 
                    {
                        WCSToMB(lpchFile, -1, &lpszPathSpecClient, MAXLONG, FALSE);
                    }
                    wcscpy(lpszPathSpec, lpchFile);
                }
            }

            //
            // In some cases, the ChopText requires extra space ahead of the path:
            // Give it CCH_CHOPTEXT_EXTRA extra spaces. (See ChopText() above).
            //
            pszCurrentDir = szStaticPath + CCH_CHOPTEXT_EXTRA;
            GetCurrentDirectory(
                    sizeof(szStaticPath)/sizeof(WCHAR) - CCH_CHOPTEXT_EXTRA,
                    pszCurrentDir);

            //
            // Fill in the static path item.
            //
            if (idStaticPath) 
            {

                //
                // To fix a bug OemToAnsi() call is inserted; SANKAR--Sep 16th
                //

                // OemToChar(szCurrentDir, szCurrentDir);
                CharLower(pszCurrentDir);
                SetDlgItemText(hwndDlg, idStaticPath, ChopText(hwndDlg, idStaticPath, szStaticPath));
            }

            //
            // Fill in the directory List/ComboBox if it exists.
            //
            if (idListBox && hwndLB != NULL) 
            {
                wDirMsg = (UINT)(fListBox ? LB_RESETCONTENT : CB_RESETCONTENT);

                if (fPostIt) 
                {
                    PostMessage(hwndLB, wDirMsg, 0, 0L);
                } 
                else 
                {
                    if (plb != NULL && (fWasVisible = IsLBoxVisible(plb))) 
                    {
                        SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
                    }
                    SendMessage(hwndLB, wDirMsg, 0, 0L);
                }

                wDirMsg = (UINT)(fListBox ? LB_DIR : CB_DIR);

                if (attrib == DDL_DRIVES)
                {
                    attrib |= DDL_EXCLUSIVE;
                }

                //
                // Hack for DDL_EXCLUSIVE to REALLY work.
                //
                fWin40Compat = TestWF(hwndLB, WFWIN40COMPAT);

                //
                // BACKWARDS COMPATIBILITY HACK
                //
                // We want DDL_EXCLUSIVE to _really_ work for new apps.  I.E., we
                // want apps to be able to specify DDL_DRIVES/DDL_VOLUMES with
                // DDL_EXCLUSIVE and privilege bits -- and have only those items
                // matching show up, w/out files.
                //
                if (attrib & DDL_EXCLUSIVE)
                {
                    if (fWin40Compat)
                    {
                        if (attrib & (DDL_DRIVES | DDL_DIRECTORY))
                            attrib |= DDL_NOFILES;
                    }
                    else
                    {
                        if (attrib == (DDL_DRIVES | DDL_EXCLUSIVE))
                            attrib |= DDL_NOFILES;
                    }
                }

                if (!(attrib & DDL_NOFILES)) 
                {

                    //
                    // Add everything except the subdirectories and disk drives.
                    //
                    if (fPostIt) 
                    {
                        //
                        // Post lpszPathSpecClient, the client side pointer.
                        //
#ifdef WASWIN31
                        PostMessage(hwndLB, wDirMsg, attrib &
                                ~(DDL_DIRECTORY | DDL_DRIVES | DDL_POSTMSGS),
                                (LPARAM)lpszPathSpecClient);
#else
                        //
                        // On NT, keep DDL_POSTMSGS in wParam because we need to know
                        // in the wndproc whether the pointer is clientside or server
                        // side.
                        //
                        PostMessage(hwndLB, wDirMsg,
                                attrib & ~(DDL_DIRECTORY | DDL_DRIVES),
                                (LPARAM)lpszPathSpecClient);
#endif

                    } 
                    else 
                    {

                        // IanJa: #ifndef WIN16 (32-bit Windows), attrib gets extended
                        // to LONG wParam automatically by the compiler
                        SendMessage(hwndLB, wDirMsg,
                                attrib & ~(DDL_DIRECTORY | DDL_DRIVES),
                                (LPARAM)lpszPathSpec);
                    }

#ifdef WASWIN31
                    //
                    // Strip out just the subdirectory and drive bits.
                    //
                    attrib &= (DDL_DIRECTORY | DDL_DRIVES);
#else
                    //
                    // B#1433
                    // The old code stripped out read-only, hidden, system, and archive
                    // information for subdirectories, making it impossible to have
                    // a listbox w/ hidden directories!
                    //

                    //
                    // Strip out just the subdirectory and drive bits. ON NT, keep
                    // the DDL_POSTMSG bit so we know how to thunk this message.
                    //
                    if (!fWin40Compat)
                    {
                        attrib &= DDL_TYPE;
                    }
                    else
                    {
                        attrib &= (DDL_TYPE | (attrib & DDL_PRIVILEGES));
                        attrib |= DDL_NOFILES;
                    }
                    // attrib &= (DDL_DIRECTORY | DDL_DRIVES | DDL_POSTMSGS);
#endif
                }

                //
                // Add directories and volumes to the listbox.
                //
                if (attrib & DDL_TYPE) 
                {
                    //
                    // Add the subdirectories and disk drives.
                    //
                    lpszPathSpec = szSLASHSTARDOTSTAR + 1;

                    attrib |= DDL_EXCLUSIVE;

                    if (fPostIt) 
                    {
                        // Post lpszPathSpecClient, the client side pointer (see text
                        // above).
                        PostMessage(hwndLB, wDirMsg, attrib, (LPARAM)lpszPathSpecClient);
                    } 
                    else 
                    {
                        SendMessage(hwndLB, wDirMsg, attrib, (LPARAM)lpszPathSpec);
                    }
                }

                if (!fPostIt && fWasVisible) 
                {
                    SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
                    InvalidateRect(hwndLB, NULL, TRUE);
                }
            }

            bResult = TRUE;
        }
    }

    return bResult;
}


//---------------------------------------------------------------------------//
BOOL DlgDirListA(
    HWND  hwndDlg,
    LPSTR lpszPathSpecClient,
    INT   idListBox,
    INT   idStaticPath,
    UINT  attrib)
{
    LPWSTR lpszPathSpec;
    BOOL   fRet;

    fRet = FALSE;
    if (hwndDlg)
    {

        lpszPathSpec = NULL;
        if (lpszPathSpecClient && (!MBToWCS(lpszPathSpecClient, -1, &lpszPathSpec, -1, TRUE)) )
        {
            fRet =  FALSE;
        }
        else
        {
            //
            // The last parameter is TRUE to indicate ListBox (not ComboBox)
            //
            fRet = DlgDirListHelper(hwndDlg, lpszPathSpec, lpszPathSpecClient,
                    idListBox, idStaticPath, attrib, TRUE);

            if (lpszPathSpec) 
            {
                if (fRet) 
                {
                    //
                    // Non-zero retval means some text to copy out.  Copy out up to
                    // the nul terminator (buffer will be big enough).
                    //
                    WCSToMB(lpszPathSpec, -1, &lpszPathSpecClient, MAXLONG, FALSE);
                }
                UserLocalFree(lpszPathSpec);
            }
        }
    }

    return fRet;
}


//---------------------------------------------------------------------------//
BOOL DlgDirListW(
    HWND   hwndDlg,
    LPWSTR lpszPathSpecClient,
    INT    idListBox,
    INT    idStaticPath,
    UINT   attrib)
{
    LPWSTR lpszPathSpec;
    BOOL fRet;

    fRet = FALSE;
    if (hwndDlg)
    {

        lpszPathSpec = lpszPathSpecClient;

        //
        // The last parameter is TRUE to indicate ListBox (not ComboBox)
        //
        fRet = DlgDirListHelper(hwndDlg, lpszPathSpec, (LPBYTE)lpszPathSpecClient,
                idListBox, idStaticPath, attrib, TRUE);
    }

    return fRet;
}


//---------------------------------------------------------------------------//
BOOL DlgDirSelectHelper(
    LPWSTR lpszPathSpec,
    INT    chCount,
    HWND   hwndListBox)
{
    INT    cch;
    LPWSTR lpchFile;
    BOOL   fDir;
    INT    sItem;
    LPWSTR lpchT;
    WCHAR  rgch[MAX_PATH + 2];
    INT    cchT;
    LARGE_UNICODE_STRING str;
    BOOL   bRet;

    bRet = FALSE;
    //
    // Callers such as DlgDirSelectEx do not validate the existance
    // of hwndListBox
    //
    if (hwndListBox == NULL) 
    {
        TraceMsg(TF_STANDARD, "Controls Id not found");
        bRet = FALSE;
    }
    else
    {
        sItem = (INT)SendMessage(hwndListBox, LB_GETCURSEL, 0, 0L);

        if (sItem < 0)
        {
            bRet = FALSE;
        }
        else
        {

            cchT = (INT)SendMessage(hwndListBox, LB_GETTEXT, sItem, (LPARAM)rgch);
            UserAssert(cchT < (sizeof(rgch)/sizeof(rgch[0])));

            lpchFile = rgch;
            fDir = (*rgch == TEXT('['));

            //
            // Check if all details along with file name are to be returned.  Make sure
            // we can find the listbox because with drop down combo boxes, the
            // GetDlgItem will fail.
            //  
            // Make sure this window has been using the listbox window proc because
            // we store some data as a window long.
            //

            //
            // Only the file name is to be returned.  Find the end of the filename.
            //
            lpchT = lpchFile;
            while ((*lpchT) && (*lpchT != TABCHAR))
            {
                lpchT++;
            }
            *lpchT = TEXT('\0');

            cch = wcslen(lpchFile);

            //
            // Selection is drive or directory.
            //
            if (fDir) 
            {
                lpchFile++;
                cch--;
                *(lpchFile + cch - 1) = TEXT('\\');

                //
                // Selection is drive
                //
                if (rgch[1] == TEXT('-')) 
                {
                    lpchFile++;
                    cch--;
                    *(lpchFile + 1) = TEXT(':');
                    *(lpchFile + 2) = 0;
                }
            } 
            else 
            {

                //
                // Selection is file.  If filename has no extension, append '.'
                //
                lpchT = lpchFile;
                for (; (cch > 0) && (*lpchT != TABCHAR); cch--, lpchT++) 
                {
                    if (*lpchT == TEXT('.'))
                    {
                        break;
                    }
                }

                if (*lpchT == TABCHAR) 
                {
                    memmove(lpchT + 1, lpchT, CHARSTOBYTES(cch + 1));
                    *lpchT = TEXT('.');
                } 
                else if (cch <= 0) 
                {
                    *lpchT++ = TEXT('.');
                    *lpchT = 0;
                }
            }

            bRet = fDir;
        }
    }

    RtlInitLargeUnicodeString(&str, lpchFile, (UINT)-1);
    TextCopy(&str, lpszPathSpec, (UINT)chCount);

    return bRet;
}


//---------------------------------------------------------------------------//
BOOL DlgDirSelectExA(
    HWND  hwndDlg,
    LPSTR lpszPathSpec,
    INT   chCount,
    INT   idListBox)
{
    LPWSTR lpwsz;
    BOOL   fRet;

    lpwsz = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, chCount * sizeof(WCHAR));
    if (!lpwsz) 
    {
        fRet = FALSE;
    }
    else
    {
        fRet = DlgDirSelectHelper(lpwsz, chCount, GetDlgItem(hwndDlg, idListBox));
        WCSToMB(lpwsz, -1, &lpszPathSpec, chCount, FALSE);
        UserLocalFree(lpwsz);
    }

    return fRet;
}


//---------------------------------------------------------------------------//
BOOL DlgDirSelectExW(
    HWND   hwndDlg,
    LPWSTR lpszPathSpec,
    INT    chCount,
    INT    idListBox)
{
    return DlgDirSelectHelper(lpszPathSpec, chCount, GetDlgItem(hwndDlg, idListBox));
}


#endif  // INCLUDE_LISTBOX_FUNCTIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\lvrept.c ===
// report view stuff (details)

#include "ctlspriv.h"
#include "listview.h"
#include <limits.h>

#define LV_DETAILSPADDING   1
#define LV_ICONINDENT       2

void ListView_RGetRectsEx(LV* plv, int iItem, int iSubItem, LPRECT prcIcon, LPRECT prcLabel);
int ListView_RXHitTest(LV* plv, int x);

void ListView_RInitialize(LV* plv, BOOL fInval)
{
    MEASUREITEMSTRUCT mi;

    if (plv && (plv->ci.style & LVS_OWNERDRAWFIXED)) 
    {

        int iOld = plv->cyItem;

        mi.CtlType = ODT_LISTVIEW;
        mi.CtlID = GetDlgCtrlID(plv->ci.hwnd);
        mi.itemHeight = plv->cyItem;  // default
        SendMessage(plv->ci.hwndParent, WM_MEASUREITEM, mi.CtlID, (LPARAM)(MEASUREITEMSTRUCT *)&mi);
        plv->cyItem = max(mi.itemHeight, 1); // never let app set height=0 or we fault-o-rama!
        if (fInval && (iOld != plv->cyItem)) 
        {
            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }
}

DWORD ListView_RApproximateViewRect(LV* plv, int iCount, int iWidth, int iHeight)
{
    RECT rc;

    ListView_RGetRects(plv, iCount, NULL, NULL, &rc, NULL);
    rc.bottom += plv->ptlRptOrigin.y;
    rc.right += plv->ptlRptOrigin.x;

    return MAKELONG(rc.right, rc.bottom);
}

void CCDrawRect(HDC hdc, int x, int y, int dx, int dy)
{
    RECT    rc;

    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}


void ListView_RAfterRedraw(LV* plv, HDC hdc)
{
    if (plv->exStyle & LVS_EX_GRIDLINES && !plv->fGroupView) 
    {
        int i;
        int x;
        COLORREF clrBk;

        clrBk = SetBkColor(hdc, g_clrBtnFace);

        x = -plv->ptlRptOrigin.x;
        for (i = 0 ; (i < plv->cCol) && (x < plv->sizeClient.cx); i++) 
        {
            HD_ITEM hitem;

            hitem.mask = HDI_WIDTH;
            Header_GetItem(plv->hwndHdr,
                           SendMessage(plv->hwndHdr, HDM_ORDERTOINDEX, i, 0),
                           &hitem);
            x += hitem.cxy;

            if (x > 0) 
            {
                CCDrawRect(hdc, x, 0, g_cxBorder, plv->sizeClient.cy);
            }
        }

        for (x = plv->yTop - 1; (x < plv->sizeClient.cy); x += plv->cyItem) 
        {
            CCDrawRect(hdc, 0, x, plv->sizeClient.cx, g_cxBorder);
        }

        SetBkColor(hdc, clrBk);
    }
}


//
// Internal function to Get the CXLabel, taking into account if the listview
// has no item data and also if RECOMPUTE needs to happen.
//
SHORT ListView_RGetCXLabel(LV* plv, int i, LISTITEM* pitem,
        HDC hdc, BOOL fUseItem)
{
    SHORT cxLabel = SRECOMPUTE;


    if (!ListView_IsOwnerData( plv )) 
    {

        cxLabel = pitem->cxSingleLabel;
    }

    if (cxLabel == SRECOMPUTE)
    {
        LISTITEM item;

        if (!pitem)
        {
            ASSERT(!fUseItem)
            pitem = &item;
            fUseItem = FALSE;
        }

        ListView_IRecomputeLabelSize(plv, pitem, i, hdc, fUseItem);
        cxLabel = pitem->cxSingleLabel;

    }

    // add on the space around the label taken up by the select rect
    cxLabel += 2*g_cxLabelMargin;
    return(cxLabel);
}

#define    SATURATEBYTE(percent, x)  { if (x + (percent * 10 * (x)) / 1000 > 0xFF) { if (fAllowDesaturation) x -= (x) / 30;  else x = 0xFF; } else x += (percent * 10 * (x)) / 1000; }
COLORREF GetSortColor(int iPercent, COLORREF clr)
{
    BOOL fAllowDesaturation;
    BYTE r, g, b;
    if (clr == 0) // Black huh?
    {
        return RGB(128,128,128);
    }

    // Doing this is less expensive than Luminance adjustment
    fAllowDesaturation = FALSE;
    r = GetRValue(clr);
    g = GetGValue(clr);
    b = GetBValue(clr);
    // If all colors are above positive saturation, allow a desaturation
    if (r > 0xF0 && g > 0xF0 && b > 0xF0)
    {
        fAllowDesaturation = TRUE;
    }

    SATURATEBYTE(iPercent, r);
    SATURATEBYTE(iPercent, g);
    SATURATEBYTE(iPercent, b);

    return RGB(r,g,b);
}


//
// Returns FALSE if no more items to draw.
//
BOOL ListView_RDrawItem(PLVDRAWITEM plvdi)
{
    BOOL fDrawFocusRect = FALSE;
    BOOL fSelected = FALSE;
    RECT rcIcon;
    RECT rcLabel;
    RECT rcBounds;
    RECT rcT;
    LV* plv = plvdi->plv;
    int iCol = 0;
    LVITEM item;
    HDITEM hitem;
    TCHAR ach[CCHLABELMAX];
    UINT fText = 0;
    UINT uSubItemFlags;
    int iIndex = 0;
    int xOffset = 0;
    int yOffset = 0;
    ListView_RGetRects(plv, (int)plvdi->nmcd.nmcd.dwItemSpec, NULL, NULL, &rcBounds, NULL);

    if (rcBounds.bottom <= plv->yTop)
        return TRUE;

    if (plvdi->prcClip)
    {
        if (rcBounds.top >= plvdi->prcClip->bottom)
            return plv->fGroupView;       // no more items need painting, unless we are in group view. 
                                          // In group view, we can have the items out of order.

        // Probably this condition won't happen very often...
        if (!IntersectRect(&rcT, &rcBounds, plvdi->prcClip))
            return TRUE;
    }


    // REVIEW: this would be faster if we did the GetClientRect
    // outside the loop.
    //
    if (rcBounds.top >= plv->sizeClient.cy)
        return plv->fGroupView;     // See above comment about groupview.

    if (plvdi->lpptOrg)
    {
        xOffset = plvdi->lpptOrg->x - rcBounds.left;
        yOffset = plvdi->lpptOrg->y - rcBounds.top;
        OffsetRect(&rcBounds, xOffset, yOffset);
    }


    item.iItem = (int)plvdi->nmcd.nmcd.dwItemSpec;
    item.stateMask = LVIS_ALL;

    // for first ListView_OnGetItem call
    item.state = 0;

    if (plv->ci.style & LVS_OWNERDRAWFIXED) 
    {
        goto SendOwnerDraw;
    }

    SetRectEmpty(&rcT);
    for (; iCol < plv->cCol; iCol++)
    {
        DWORD dwCustom = 0;
        UINT uImageFlags;
        COLORREF crBkSave = plv->clrBk;
        COLORREF clrTextBk;

        iIndex = (int) SendMessage(plv->hwndHdr, HDM_ORDERTOINDEX, iCol, 0);

    SendOwnerDraw:

        if (iIndex == 0) 
        {
            item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_INDENT;
        } 
        else 
        {
            // Next time through, we only want text for subitems...
            item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
        }

        item.iImage = -1;
        item.iSubItem = iIndex;
        item.pszText = ach;
        item.cchTextMax = ARRAYSIZE(ach);
        ListView_OnGetItem(plv, &item);

        uSubItemFlags = plvdi->flags;

        if (iIndex == 0) 
        {

            // if it's owner draw, send off a message and return.
            // do this after we've collected state information above though
            if (plv->ci.style & LVS_OWNERDRAWFIXED) 
            {
                DRAWITEMSTRUCT di = {0};
                di.CtlType = ODT_LISTVIEW;
                di.CtlID = GetDlgCtrlID(plv->ci.hwnd);
                di.itemID = (int)plvdi->nmcd.nmcd.dwItemSpec;
                di.itemAction = ODA_DRAWENTIRE;
                di.hwndItem = plv->ci.hwnd;
                di.hDC = plvdi->nmcd.nmcd.hdc;
                di.rcItem = rcBounds;
                if (plvdi->pitem)
                    di.itemData = plvdi->pitem->lParam;
                if (item.state & LVIS_FOCUSED) 
                {
                    di.itemState |= ODS_FOCUS;
                }
                if (item.state & LVIS_SELECTED) 
                {
                    di.itemState |= ODS_SELECTED;
                }
                SendMessage(plv->ci.hwndParent, WM_DRAWITEM, di.CtlID,
                            (LPARAM)(DRAWITEMSTRUCT *)&di);
                return TRUE;
            }

        }

        hitem.mask = HDI_WIDTH | HDI_FORMAT;
        Header_GetItem(plv->hwndHdr, iIndex, &hitem);

        // first get the rects...
        ListView_RGetRectsEx(plv, (int)plvdi->nmcd.nmcd.dwItemSpec, iIndex, &rcIcon, &rcLabel);
        OffsetRect(&rcIcon, xOffset, yOffset);
        OffsetRect(&rcLabel, xOffset, yOffset);

        if (plvdi->dwCustom & CDRF_NOTIFYSUBITEMDRAW) 
        {
            RECT rcTemp;
            UINT uItemStateOld = plvdi->nmcd.nmcd.uItemState, uItemStateNew;
            SendMessage(plv->hwndHdr, HDM_GETITEMRECT, iIndex, (LPARAM)&rcTemp);
            plvdi->nmcd.nmcd.rc.left = rcTemp.left;
            plvdi->nmcd.nmcd.rc.right = rcTemp.right;
            plvdi->nmcd.iSubItem = iIndex;

            dwCustom = CICustomDrawNotify(&plvdi->plv->ci, CDDS_SUBITEM | CDDS_ITEMPREPAINT, &plvdi->nmcd.nmcd);

            uItemStateNew = plvdi->nmcd.nmcd.uItemState;
            plvdi->nmcd.nmcd.uItemState = uItemStateOld;

            if (dwCustom & CDRF_SKIPDEFAULT)
                continue;

            uSubItemFlags &= ~(LVDI_FOCUS | LVDI_SELECTED | LVDI_SELECTNOFOCUS | LVDI_HOTSELECTED);
            if (uItemStateNew & CDIS_FOCUS)
                uSubItemFlags |= LVDI_FOCUS;

            if (uItemStateNew & CDIS_SELECTED) 
            {
                if (plvdi->plv->flags & LVF_FOCUSED)
                    uSubItemFlags |= LVDI_SELECTED;
                else
                    uSubItemFlags |= LVDI_SELECTNOFOCUS;
                if (plvdi->plv->iHot == (int)plvdi->nmcd.nmcd.dwItemSpec &&
                    ((plv->exStyle & LVS_EX_ONECLICKACTIVATE) ||
                     (plv->exStyle & LVS_EX_TWOCLICKACTIVATE)))
                {
                    uSubItemFlags |= LVDI_HOTSELECTED;
                }
            }
        }

        if (iIndex != 0)
        {
            // for right now, add this in because the get rects for
            // non 0 doesn't account for the icon (yet)
            if (item.iImage != -1)
                rcLabel.left += plv->cxSmIcon + LV_ICONINDENT;

        }

        uImageFlags = uSubItemFlags;

        fText = ListView_GetTextSelectionFlags(plv, &item, uSubItemFlags);
        fSelected = fText & (SHDT_SELECTED | SHDT_SELECTNOFOCUS);
    
        clrTextBk = plvdi->nmcd.clrTextBk;

        if (plv->pImgCtx || ListView_IsWatermarked(plv))
        {
            clrTextBk = CLR_NONE;
        }

        if (iIndex == plv->iLastColSort &&
            !(plv->pImgCtx && plv->fImgCtxComplete) &&
            !plv->fGroupView)
        {
            plv->clrBk = GetSortColor(10, plv->clrBk);
            clrTextBk = plv->clrBk;
        }

        if (item.iImage == -1) 
        {

            if (iIndex != 0)
            {
                // just use ListView_DrawImage to get the fText
                uImageFlags |= LVDI_NOIMAGE;
            }
        }
        else if (ListView_FullRowSelect(plv) && 
                (fSelected || !(plv->pImgCtx && plv->fImgCtxComplete)))	// Don't do this unless we are selected or we don't have an image
        {
            int iLeft = rcIcon.left;
            int iRight = rcIcon.right;

            if (iIndex == 0) 
            {
                rcIcon.left -= plv->cxState + LV_ICONTOSTATEOFFSET(plv) + g_cxEdge;
            }

            rcIcon.right = rcLabel.right;
            FillRectClr(plvdi->nmcd.nmcd.hdc, &rcIcon, plv->clrBk);

            rcIcon.left = iLeft;
            rcIcon.right = iRight;
        }

        ListView_DrawImageEx(plv, &item, plvdi->nmcd.nmcd.hdc,
                                   rcIcon.left, rcIcon.top, plv->clrBk, uSubItemFlags, rcLabel.right);


        if (ListView_FullRowSelect(plv) && (uSubItemFlags & LVDI_FOCUS)) 
        {
            // if we're doing a full row selection, collect the union
            // of the labels for the focus rect
            UnionRect(&rcT, &rcT, &rcLabel);
        }


        if (item.pszText)
        {
            int xLabelRight = rcLabel.right;
            UINT textflags;


            // give all but the first columns extra margins so
            // left and right justified things don't stick together

            textflags = (iIndex == 0) ? SHDT_ELLIPSES : SHDT_ELLIPSES | SHDT_EXTRAMARGIN;

            // rectangle limited to the size of the string
            textflags |= fText;

            if ((!ListView_FullRowSelect(plv)) &&
                ((fText & (SHDT_SELECTED | SHDT_SELECTNOFOCUS)) || (item.state & LVIS_FOCUSED)))
            {
                int cxLabel;

                // if selected or focused, the rectangle is more
                // meaningful and should correspond to the string
                //
                if (iIndex == 0) 
                {
                    LISTITEM litem;
                    LISTITEM *pitem = plvdi->pitem;

                    if (!pitem) 
                    {
                        pitem = &litem;
                        litem.pszText = item.pszText;
                    }
                    cxLabel = ListView_RGetCXLabel(plv, (int)plvdi->nmcd.nmcd.dwItemSpec, pitem, plvdi->nmcd.nmcd.hdc, TRUE);
                } 
                else 
                {
                    // add g_cxLabelMargin * 6 because we use SHDT_EXTRAMARGIN
                    // on iIndex != 0
                    // and if you look inside shdrawtext, there are 6 cxlabelmargins added...
                    cxLabel = ListView_OnGetStringWidth(plv, item.pszText, plvdi->nmcd.nmcd.hdc) + g_cxLabelMargin * 6;
                }

                if (rcLabel.right > rcLabel.left + cxLabel)
                {
                    rcLabel.right = rcLabel.left + cxLabel;
                }
            }

            if ((iIndex != 0) || (plv->iEdit != (int)plvdi->nmcd.nmcd.dwItemSpec))
            {
                COLORREF clrText;
                HFONT hFontTemp = NULL;
                int cxEllipses;
                HRESULT hr = E_FAIL;

                clrText = plvdi->nmcd.clrText;
                if ((clrText == GetSysColor(COLOR_HOTLIGHT)) ||
                    ((plv->exStyle & LVS_EX_UNDERLINEHOT) &&
                     ((plv->exStyle & LVS_EX_ONECLICKACTIVATE) ||
                      ((plvdi->plv->exStyle & LVS_EX_TWOCLICKACTIVATE) &&
                       ListView_OnGetItemState(plvdi->plv, (int) plvdi->nmcd.nmcd.dwItemSpec, LVIS_SELECTED))))) 
                {
                    if (iIndex != 0 && !ListView_FullRowSelect(plv)) 
                    {

                        hFontTemp = SelectFont(plvdi->nmcd.nmcd.hdc, plv->hfontLabel);
                        if (hFontTemp != plv->hFontHot) 
                        {
                            // they've overridden... leave it.
                            SelectFont(plvdi->nmcd.nmcd.hdc, hFontTemp);
                            hFontTemp = NULL;
                        }
                        clrText = plv->clrText;
                    }
                }


                if ((textflags & SHDT_SELECTED) && (uSubItemFlags & LVDI_HOTSELECTED))
                    textflags |= SHDT_HOTSELECTED;

                if( plv->dwExStyle & WS_EX_RTLREADING)
                {
                    //
                    // temp hack for the find.files to see if LtoR/RtoL mixing
                    // works. if ok, we'll take this out and make that lv ownerdraw
                    //
                    if ((item.pszText[0] != '\xfd') && (item.pszText[lstrlen(item.pszText)-1] != '\xfd'))
                        textflags |= SHDT_RTLREADING;
                }
                //
                //  If the app customized the font, we need to get the new
                //  ellipsis size.  We could try to optimize not doing this
                //  if ellipses aren't needed, but tough.  That's what you
                //  get if you use customdraw.
                //
                if ((plvdi->dwCustom | dwCustom) & CDRF_NEWFONT)
                {
                    SIZE siz;
                    GetTextExtentPoint(plvdi->nmcd.nmcd.hdc, c_szEllipses, CCHELLIPSES, &siz);
                    cxEllipses = siz.cx;
                }
                else
                    cxEllipses = plv->cxEllipses;

                SHDrawText(plvdi->nmcd.nmcd.hdc, item.pszText, &rcLabel,
                           hitem.fmt & HDF_JUSTIFYMASK, textflags,
                           plv->cyLabelChar, cxEllipses,
                           clrText, clrTextBk);

                // draw a focus rect on the first column of a focus item
                if ((uSubItemFlags & LVDI_FOCUS) && 
                    (item.state & LVIS_FOCUSED) && 
                    !(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS))
                {
                    if (ListView_FullRowSelect(plv)) 
                    {
                        fDrawFocusRect = TRUE;
                        // if we're doing a full row selection, collect the union
                        // of the labels for the focus rect
                        UnionRect(&rcT, &rcT, &rcLabel);
                    } 
                    else 
                    {
                        DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcLabel);
                    }
                }

                // restore the font
                if (hFontTemp)
                    SelectFont(plvdi->nmcd.nmcd.hdc, hFontTemp);


            }
        }

        if (dwCustom & CDRF_NOTIFYPOSTPAINT) 
        {
            CICustomDrawNotify(&plvdi->plv->ci, CDDS_SUBITEM | CDDS_ITEMPOSTPAINT, &plvdi->nmcd.nmcd);
        }

        plv->clrBk = crBkSave;
    }

    if (fDrawFocusRect)
    {
       DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcT);
    }

    return TRUE;
}

BOOL_PTR ListView_CreateHeader(LV* plv)
{
    // enable drag drop always here... just fail the notify
    // if the bit in listview isn't set
    DWORD dwStyle = HDS_HORZ | WS_CHILD | HDS_DRAGDROP;

    if (plv->ci.style & LVS_NOCOLUMNHEADER)
        dwStyle |= HDS_HIDDEN;
    if (!(plv->ci.style & LVS_NOSORTHEADER))
        dwStyle |= HDS_BUTTONS;

    dwStyle |= HDS_FULLDRAG;

    plv->hwndHdr = CreateWindowEx(0L, c_szHeaderClass, // WC_HEADER,
        NULL, dwStyle, 0, 0, 0, 0, plv->ci.hwnd, (HMENU)LVID_HEADER, GetWindowInstance(plv->ci.hwnd), NULL);

    if (plv->hwndHdr) 
    {
        FORWARD_WM_SETFONT(plv->hwndHdr, plv->hfontLabel, FALSE, SendMessage);
        if (plv->himlSmall)
            SendMessage(plv->hwndHdr, HDM_SETIMAGELIST, 0, (LPARAM)plv->himlSmall);
    }
    return (BOOL_PTR)plv->hwndHdr;
}

int ListView_OnInsertColumnA(LV* plv, int iCol, LV_COLUMNA * pcol) 
{
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    int iRet;

    //HACK ALERT -- this code assumes that LV_COLUMNA is exactly the same
    // as LV_COLUMNW except for the pointer to the string.
    ASSERT(sizeof(LV_COLUMNA) == sizeof(LV_COLUMNW));

    if (!pcol)
        return -1;

    if ((pcol->mask & LVCF_TEXT) && (pcol->pszText != NULL)) 
    {
        pszC = pcol->pszText;
        if ((pszW = ProduceWFromA(plv->ci.uiCodePage, pszC)) == NULL)
        {
            // NT's IE4 returned -1, so we keep doing it in IE5.
            return -1;
        } 
        else 
        {
            pcol->pszText = (LPSTR)pszW;
        }
    }

    iRet = ListView_OnInsertColumn(plv, iCol, (const LV_COLUMN*) pcol);

    if (pszW != NULL) 
    {
        pcol->pszText = pszC;

        FreeProducedString(pszW);
    }

    return iRet;
}

int ListView_OnInsertColumn(LV* plv, int iCol, const LV_COLUMN* pcol)
{
    int idpa = -1;
    HD_ITEM item;

    ASSERT(LVCFMT_LEFT == HDF_LEFT);
    ASSERT(LVCFMT_RIGHT == HDF_RIGHT);
    ASSERT(LVCFMT_CENTER == HDF_CENTER);

    if (iCol < 0 || !pcol)
        return -1;

    if (!plv->hwndHdr && !ListView_CreateHeader(plv))
        return -1;

    item.mask    = (HDI_WIDTH | HDI_HEIGHT | HDI_FORMAT | HDI_LPARAM);

    if (pcol->mask & LVCF_IMAGE) {
        // do this only if this bit is set so that we don't fault on
        // old binaries
        item.iImage  = pcol->iImage;
        item.mask |= HDI_IMAGE;
    }

    if (pcol->mask & LVCF_TEXT) {
        item.pszText = pcol->pszText;
        item.mask |= HDI_TEXT;
    }

    if (pcol->mask & LVCF_ORDER) {
        item.iOrder = pcol->iOrder;
        item.mask |= HDI_ORDER;
    }


    item.cxy     = pcol->mask & LVCF_WIDTH ? pcol->cx : 10; // some random default
    item.fmt     = ((pcol->mask & LVCF_FMT) && (iCol > 0)) ? pcol->fmt : LVCFMT_LEFT;
    item.hbm     = NULL;

    item.lParam = pcol->mask & LVCF_SUBITEM ? pcol->iSubItem : 0;

    // Column 0 refers to the item list.  If we've already added a
    // column, make sure there are plv->cCol - 1 subitem ptr slots
    // in hdpaSubItems...
    //
    if (plv->cCol > 0)
    {
        if (!plv->hdpaSubItems)
        {
            plv->hdpaSubItems = DPA_CreateEx(8, plv->hheap);
            if (!plv->hdpaSubItems)
                return -1;
        }

        // WARNING:  the max(0, iCol-1) was min in Win95, which was
        // just wrong.  hopefully(!) no one has relied on this brokeness
        // if so, we may have to version switch it.
        idpa = DPA_InsertPtr(plv->hdpaSubItems, max(0, iCol - 1), NULL);
        if (idpa == -1)
            return -1;
    }

    iCol = Header_InsertItem(plv->hwndHdr, iCol, &item);
    if (iCol == -1)
    {
        if (plv->hdpaSubItems && (idpa != -1))
            DPA_DeletePtr(plv->hdpaSubItems, idpa);
        return -1;
    }
    plv->xTotalColumnWidth = RECOMPUTE;
    plv->cCol++;
    ListView_UpdateScrollBars(plv);
    if (ListView_IsReportView(plv) && ListView_RedrawEnabled(plv)) {
        RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
    }
    return iCol;
}

int ListView_FreeColumnData(LPVOID d, LPVOID p)
{
    PLISTSUBITEM plsi = (PLISTSUBITEM)d;
    ListView_FreeSubItem(plsi);
    return 1;
}


BOOL ListView_OnDeleteColumn(LV* plv, int iCol)
{
    if (iCol < 0 || iCol >= plv->cCol)    // validate column index
    {
        RIPMSG(0, "LVM_DELETECOLUMN: Invalid column index: %d", iCol);
        return FALSE;
    }

    if (plv->hdpaSubItems)
    {
        int iDeleteColumn = iCol;  // This is the column we want to delete

        if (iCol == 0 &&                    // Trying to delete column Zero?
            plv->cCol >= 2 &&               // Do we have two or more columns?
            !ListView_IsOwnerData(plv))
        {
            // if deleting column 0,
            // we have to do something a little special...
            // set all item 0 strings to what column 1 has and
            // delete column 1
            int i;
            int iCount = ListView_Count(plv);
            for (i = 0; i < iCount; i++) 
            {

                LISTSUBITEM lsi;
                LVITEM lvi;
                ListView_GetSubItem(plv, i, 1, &lsi);
                lvi.iSubItem = 0;
                lvi.iItem = i;
                lvi.mask = LVIF_TEXT | LVIF_IMAGE;
                lvi.iImage = lsi.iImage;
                lvi.pszText = lsi.pszText;
                lvi.state = lsi.state;
                lvi.stateMask = 0xffffffff;
                ListView_OnSetItem(plv, &lvi);
            }
            iDeleteColumn = 1;
        }

        if (iDeleteColumn > 0) 
        {
            HDPA hdpa = (HDPA)DPA_DeletePtr(plv->hdpaSubItems, iDeleteColumn - 1);
            DPA_DestroyCallback(hdpa, ListView_FreeColumnData, 0);
        }
    }

    if (!Header_DeleteItem(plv->hwndHdr, iCol))
        return FALSE;

    plv->cCol--;
    plv->xTotalColumnWidth = RECOMPUTE;
    ListView_UpdateScrollBars(plv);

    if (ListView_IsReportView(plv) && ListView_RedrawEnabled(plv))
    {
        RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
    }
    return TRUE;
}

int ListView_RGetColumnWidth(LV* plv, int iCol)
{
    HD_ITEM item = {0};
    item.mask = HDI_WIDTH;

    Header_GetItem(plv->hwndHdr, iCol, &item);

    return item.cxy;
}

// The FakeCustomDraw functions are used when you want the customdraw client
// to set up a HDC so you can do stuff like GetTextExtent.
//
//  Usage:
//
//      LVFAKEDRAW lvfd;
//      LV_ITEM item;
//      ListView_BeginFakeCustomDraw(plv, &lvfd, &item);
//      for each item you care about {
//          item.iItem = iItem;
//          item.iItem = iSubItem;
//          item.lParam = <item lParam>; // use ListView_OnGetItem to get it
//          ListView_BeginFakeItemDraw(&lvfd);
//          <party on the HDC in lvfd.nmcd.nmcd.hdc>
//          ListView_EndFakeItemDraw(&lvfd);
//      }
//      ListView_EndFakeCustomDraw(&lvfd);
//

void ListView_BeginFakeCustomDraw(LV* plv, PLVFAKEDRAW plvfd, LV_ITEM *pitem)
{
    plvfd->nmcd.nmcd.hdc = GetDC(plv->ci.hwnd);
    plvfd->nmcd.nmcd.uItemState = 0;
    plvfd->nmcd.nmcd.dwItemSpec = 0;
    plvfd->nmcd.nmcd.lItemlParam = 0;
    plvfd->hfontPrev = SelectFont(plvfd->nmcd.nmcd.hdc, plv->hfontLabel);

    plvfd->nmcd.dwItemType = 0;

    //
    //  Since we aren't actually painting anything, we pass an empty
    //  paint rectangle.  Gosh, I hope no app faults when it sees an
    //  empty paint rectangle.
    //
    SetRectEmpty(&plvfd->nmcd.nmcd.rc);

    plvfd->plv = plv;
    plvfd->dwCustomPrev = plv->ci.dwCustom;
    plvfd->pitem = pitem;

    plv->ci.dwCustom = CIFakeCustomDrawNotify(&plv->ci, CDDS_PREPAINT, &plvfd->nmcd.nmcd);
}

DWORD ListView_BeginFakeItemDraw(PLVFAKEDRAW plvfd)
{
    LV *plv = plvfd->plv;
    LV_ITEM *pitem;

    // Early-out:  If client doesn't use CustomDraw, then stop immediately.
    if (!(plv->ci.dwCustom & CDRF_NOTIFYITEMDRAW))
        return CDRF_DODEFAULT;

    pitem = plvfd->pitem;

        // Note that if the client says CDRF_SKIPDEFAULT (i.e., is owner-draw)
    // we measure the item anyway, because that's what IE4 did.

    // Make sure we do have the lParam.  Office will fault if you give
    // bogus lParams during customdraw callbacks.
    plvfd->nmcd.nmcd.dwItemSpec = pitem->iItem;
    if (ListView_IsOwnerData(plv))
    {
        // OwnerData always gets lItemlParam = 0
        ASSERT(plvfd->nmcd.nmcd.lItemlParam == 0);  // should still be 0
    } else {
        ASSERT(pitem->mask & LVIF_PARAM);
        plvfd->nmcd.nmcd.lItemlParam = pitem->lParam;
    }

    if (!(plv->ci.dwCustom & CDRF_SKIPDEFAULT)) {
        plvfd->nmcd.iSubItem = 0;
        plvfd->dwCustomItem = CIFakeCustomDrawNotify(&plv->ci, CDDS_ITEMPREPAINT, &plvfd->nmcd.nmcd);
    } else {
        plvfd->dwCustomItem = CDRF_DODEFAULT;
    }

    //
    //  Only report view supports sub-items.
    //
    if (!ListView_IsReportView(plv))
        plvfd->dwCustomItem &= ~CDRF_NOTIFYSUBITEMDRAW;

    if (plvfd->dwCustomItem & CDRF_NOTIFYSUBITEMDRAW) {
        plvfd->nmcd.iSubItem = pitem->iSubItem;
        plvfd->dwCustomSubItem = CIFakeCustomDrawNotify(&plv->ci, CDDS_SUBITEM | CDDS_ITEMPREPAINT, &plvfd->nmcd.nmcd);
    } else {
        plvfd->dwCustomSubItem = CDRF_DODEFAULT;
    }

    return plvfd->dwCustomItem | plvfd->dwCustomSubItem;
}

void ListView_EndFakeItemDraw(PLVFAKEDRAW plvfd)
{
    LV *plv = plvfd->plv;

    // Early-out:  If client doesn't use CustomDraw, then stop immediately.
    if (!(plv->ci.dwCustom & CDRF_NOTIFYITEMDRAW))
        return;

    if (!(plvfd->dwCustomSubItem & CDRF_SKIPDEFAULT) &&
         (plvfd->dwCustomSubItem & CDRF_NOTIFYPOSTPAINT)) {
        ASSERT(plvfd->dwCustomItem & CDRF_NOTIFYSUBITEMDRAW);
        ASSERT(plvfd->nmcd.iSubItem == plvfd->pitem->iSubItem);
        CIFakeCustomDrawNotify(&plv->ci, CDDS_SUBITEM | CDDS_ITEMPOSTPAINT, &plvfd->nmcd.nmcd);
    }

    if ((plvfd->dwCustomItem | plvfd->dwCustomSubItem) & CDRF_NEWFONT) // App changed font, so
        SelectFont(plvfd->nmcd.nmcd.hdc, plv->hfontLabel);   // restore default font

    if (!(plvfd->dwCustomItem & CDRF_SKIPDEFAULT) &&
         (plvfd->dwCustomItem & CDRF_NOTIFYPOSTPAINT)) {
        plvfd->nmcd.iSubItem = 0;
        CIFakeCustomDrawNotify(&plv->ci, CDDS_ITEMPOSTPAINT, &plvfd->nmcd.nmcd);
    }
}

void ListView_EndFakeCustomDraw(PLVFAKEDRAW plvfd)
{
    LV *plv = plvfd->plv;

    // notify parent afterwards if they want us to
    if (!(plv->ci.dwCustom & CDRF_SKIPDEFAULT) &&
        plv->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
        CIFakeCustomDrawNotify(&plv->ci, CDDS_POSTPAINT, &plvfd->nmcd.nmcd);
    }

    // Restore previous state
    plv->ci.dwCustom = plvfd->dwCustomPrev;

    SelectObject(plvfd->nmcd.nmcd.hdc, plvfd->hfontPrev);
    ReleaseDC(plv->ci.hwnd, plvfd->nmcd.nmcd.hdc);
}


BOOL hasVertScroll
(
    LV* plv
)
{
    RECT rcClient;
    RECT rcBounds;
    int cColVis;
    BOOL fHorSB;

    // Get the horizontal bounds of the items.
    ListView_GetClientRect(plv, &rcClient, FALSE, NULL);
    ListView_RGetRects(plv, 0, NULL, NULL, &rcBounds, NULL);
    fHorSB = (rcBounds.right - rcBounds.left > rcClient.right);
    cColVis = (rcClient.bottom - plv->yTop -
               (fHorSB ? ListView_GetCyScrollbar(plv) : 0)) / plv->cyItem;

    // check to see if we need a vert scrollbar
    if ((int)cColVis < ListView_Count(plv))
        return(TRUE);
    else
        return(FALSE);
}

BOOL ListView_RSetColumnWidth(LV* plv, int iCol, int cx)
{
    HD_ITEM item;
    HD_ITEM colitem;

    SIZE    siz;

    LV_ITEM lviItem;
    int     i;
    int     ItemWidth = 0;
    int     HeaderWidth = 0;
    TCHAR   szLabel[CCHLABELMAX + 4];      // CCHLABLEMAX == MAX_PATH
    int     iBegin;
    int     iEnd;

    // Should we compute the width based on the widest string?
    // If we do, include the Width of the Label, and if this is the
    // Last column, set the width so the right side is at the list view's right edge
    if (cx <= LVSCW_AUTOSIZE)
    {
        LVFAKEDRAW lvfd;                    // in case client uses customdraw

        if (cx == LVSCW_AUTOSIZE_USEHEADER)
        {
            // Special Cases:
            // 1) There is only 1 column.  Set the width to the width of the listview
            // 2) This is the rightmost column, set the width so the right edge of the
            //    column coinsides with to right edge of the list view.

            if (plv->cCol == 1)
            {
                RECT    rcClient;

                ListView_GetClientRect(plv, &rcClient, FALSE, NULL);
                HeaderWidth = rcClient.right - rcClient.left;
            }
            else if (iCol == (plv->cCol-1))
            {
                // REARCHITECT:  This will only work if the listview as NOT
                // been previously horizontally scrolled
                RECT    rcClient;
                RECT    rcHeader;

                ListView_GetClientRect(plv, &rcClient, FALSE, NULL);
                if (!Header_GetItemRect(plv->hwndHdr, plv->cCol - 2, &rcHeader))
                    rcHeader.right = 0;

                // Is if visible
                if (rcHeader.right < (rcClient.right-rcClient.left))
                {
                    HeaderWidth = (rcClient.right-rcClient.left) - rcHeader.right;
                }
            }

            // If we have a header width, then is is one of these special ones, so
            // we need to account for a vert scroll bar since we are using Client values
            if (HeaderWidth && hasVertScroll(plv))
            {
                HeaderWidth -= g_cxVScroll;
            }

            // Get the Width of the label.
            // We assume that the app hasn't changed any attributes
            // of the header control - still has default font, margins, etc.
            colitem.mask = HDI_TEXT | HDI_FORMAT;
            colitem.pszText = szLabel;
            colitem.cchTextMax = ARRAYSIZE(szLabel);
            if (Header_GetItem(plv->hwndHdr, iCol, &colitem))
            {
                HTHEME hThemeHeader;
                HDC hdc = GetDC(plv->ci.hwnd);
                HFONT hfPrev = SelectFont(hdc, plv->hfontLabel);

                GetTextExtentPoint(hdc, colitem.pszText,
                                   lstrlen(colitem.pszText), &siz);
                siz.cx += 2 * (3 * g_cxLabelMargin);    // phd->iTextMargin
                if (colitem.fmt & HDF_IMAGE)
                {
                    siz.cx += plv->cxSmIcon;
                    siz.cx += 2 * (3 * g_cxLabelMargin);    // pdh->iBmMargin
                }

                hThemeHeader = OpenThemeData(plv->hwndHdr, L"Header");
                if (hThemeHeader)
                {
                    RECT rc = {0, 0, siz.cx, siz.cy};
                    GetThemeBackgroundExtent(hThemeHeader, hdc, HP_HEADERITEM, 0, &rc, &rc);

                    siz.cx = RECTWIDTH(rc);
                    siz.cy = RECTHEIGHT(rc);

                    CloseThemeData(hThemeHeader);
                }

                HeaderWidth = max(HeaderWidth, siz.cx);

                SelectFont(hdc, hfPrev);
                ReleaseDC(plv->ci.hwnd, hdc);
            }
        }


        iBegin = 0;
        iEnd = ListView_Count( plv );

        //
        // Loop for each item in the view
        //
        if (ListView_IsOwnerData( plv ))
        {
            iBegin = (int)((plv->ptlRptOrigin.y - plv->yTop)
                        / plv->cyItem);
            iEnd = (int)((plv->ptlRptOrigin.y + plv->sizeClient.cy  - plv->yTop)
                        / plv->cyItem) + 1;

            iBegin = max( 0, iBegin );
            iEnd = max(iEnd, iBegin + 1);
            iEnd = min( iEnd, ListView_Count( plv ) );

            ListView_NotifyCacheHint( plv, iBegin, iEnd-1 );
        }

        //
        //  To obtain the widths of the strings, we have to pretend that
        //  we are painting them, in case the custom-draw client wants
        //  to play with fonts (e.g., Athena).
        //
        ListView_BeginFakeCustomDraw(plv, &lvfd, &lviItem);

        //
        //  If column 0, then we also need to take indent into account.
        //
        lviItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        if (iCol == 0) {
            lviItem.mask |= LVIF_INDENT;
        }

        // Loop for each item in the List
        for (i = iBegin; i < iEnd; i++)
        {
            lviItem.iImage = -1;
            lviItem.iItem = i;
            lviItem.iSubItem = iCol;
            lviItem.pszText = szLabel;
            lviItem.cchTextMax = ARRAYSIZE(szLabel);
            lviItem.iIndent = 0;
            lviItem.stateMask = 0;
            ListView_OnGetItem(plv, &lviItem);

            // If there is a Text item, get its width
            if (lviItem.pszText || (lviItem.iImage != -1))
            {
                if (lviItem.pszText) 
                {

                    ListView_BeginFakeItemDraw(&lvfd);

                    GetTextExtentPoint(lvfd.nmcd.nmcd.hdc, lviItem.pszText,
                                       lstrlen(lviItem.pszText), &siz);

                    ListView_EndFakeItemDraw(&lvfd);

                } 
                else 
                {
                    siz.cx = 0;
                }

                if (lviItem.iImage != -1)
                {
                    siz.cx += plv->cxSmIcon + g_cxEdge + LV_ICONINDENT;
                }

                siz.cx += lviItem.iIndent * plv->cxSmIcon;
                ItemWidth = max(ItemWidth, siz.cx);
            }
        }

        ListView_EndFakeCustomDraw(&lvfd);

        // Adjust by a reasonable border amount.
        // If col 0, add 2*g_cxLabelMargin + g_szSmIcon.
        // Otherwise add 6*g_cxLabelMargin.
        // These amounts are based on Margins added automatically
        // to the ListView in ShDrawText.

        // REARCHITECT ListView Report format currently assumes and makes
        // room for a Small Icon.
        if (iCol == 0)
        {
            ItemWidth += plv->cxState + LV_ICONTOSTATEOFFSET(plv) + g_cxEdge;
            ItemWidth += 2*g_cxLabelMargin;
        }
        else
        {
            ItemWidth += 6*g_cxLabelMargin;
        }

        TraceMsg(TF_LISTVIEW, "ListView: HeaderWidth:%d ItemWidth:%d", HeaderWidth, ItemWidth);
        item.cxy = max(HeaderWidth, ItemWidth);
    }
    else
    {
        // Use supplied width
        item.cxy = cx;
    }
    plv->xTotalColumnWidth = RECOMPUTE;

    item.mask = HDI_WIDTH;
    return Header_SetItem(plv->hwndHdr, iCol, &item);
}

BOOL ListView_OnGetColumnA(LV* plv, int iCol, LV_COLUMNA* pcol) 
{
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that LV_COLUMNA is exactly the same
    // as LV_COLUMNW except for the pointer to the string.
    ASSERT(sizeof(LV_COLUMNA) == sizeof(LV_COLUMNW))

    if (!pcol) return FALSE;

    if ((pcol->mask & LVCF_TEXT) && (pcol->pszText != NULL)) 
    {
        pszC = pcol->pszText;
        pszW = LocalAlloc(LMEM_FIXED, pcol->cchTextMax * sizeof(WCHAR));
        if (pszW == NULL)
            return FALSE;
        pcol->pszText = (LPSTR)pszW;
    }

    fRet = ListView_OnGetColumn(plv, iCol, (LV_COLUMN*) pcol);

    if (pszW != NULL) 
    {
        if (fRet && pcol->cchTextMax)
            ConvertWToAN(plv->ci.uiCodePage, pszC, pcol->cchTextMax, pszW, -1);
        pcol->pszText = pszC;

        LocalFree(pszW);
    }

    return fRet;

}

BOOL ListView_OnGetColumn(LV* plv, int iCol, LV_COLUMN* pcol)
{
    HD_ITEM item;
    UINT mask;

    if (!pcol) 
    {
        RIPMSG(0, "LVM_GETCOLUMN: Invalid pcol = NULL");
        return FALSE;
    }

    mask = pcol->mask;

    if (!mask)
        return TRUE;

    item.mask = HDI_FORMAT | HDI_WIDTH | HDI_LPARAM | HDI_ORDER | HDI_IMAGE;

    if (mask & LVCF_TEXT)
    {
        if (pcol->pszText)
        {
            item.mask |= HDI_TEXT;
            item.pszText = pcol->pszText;
            item.cchTextMax = pcol->cchTextMax;
        } else {
            // For compatibility reasons, we don't fail the call if they
            // pass NULL.
            RIPMSG(0, "LVM_GETCOLUMN: Invalid pcol->pszText = NULL");
        }
    }

    if (!Header_GetItem(plv->hwndHdr, iCol, &item))
    {
        RIPMSG(0, "LVM_GETCOLUMN: Invalid column number %d", iCol);
        return FALSE;
    }

    if (mask & LVCF_SUBITEM)
        pcol->iSubItem = (int)item.lParam;

    if (mask & LVCF_ORDER)
        pcol->iOrder = (int)item.iOrder;

    if (mask & LVCF_IMAGE)
        pcol->iImage = item.iImage;

    if (mask & LVCF_FMT)
        pcol->fmt = item.fmt;

    if (mask & LVCF_WIDTH)
        pcol->cx = item.cxy;

    return TRUE;
}

BOOL ListView_OnSetColumnA(LV* plv, int iCol, LV_COLUMNA* pcol) 
{
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that LV_COLUMNA is exactly the same
    // as LV_COLUMNW except for the pointer to the string.
    ASSERT(sizeof(LV_COLUMNA) == sizeof(LV_COLUMNW));

    if (!pcol) return FALSE;

    if ((pcol->mask & LVCF_TEXT) && (pcol->pszText != NULL)) 
    {
        pszC = pcol->pszText;
        if ((pszW = ProduceWFromA(plv->ci.uiCodePage, pszC)) == NULL)
            return FALSE;
        pcol->pszText = (LPSTR)pszW;
    }

    fRet = ListView_OnSetColumn(plv, iCol, (const LV_COLUMN*) pcol);

    if (pszW != NULL) {
        pcol->pszText = pszC;

        FreeProducedString(pszW);
    }

    return fRet;

}

BOOL ListView_OnSetColumn(LV* plv, int iCol, const LV_COLUMN* pcol)
{
    HD_ITEM item;
    UINT mask;

    if (!pcol) return FALSE;

    mask = pcol->mask;
    if (!mask)
        return TRUE;

    item.mask = 0;
    if (mask & LVCF_SUBITEM)
    {
        item.mask |= HDI_LPARAM;
        item.lParam = iCol;
    }

    if (mask & LVCF_FMT)
    {
        item.mask |= HDI_FORMAT;
        item.fmt = (pcol->fmt | HDF_STRING);
    }

    if (mask & LVCF_WIDTH)
    {
        item.mask |= HDI_WIDTH;
        item.cxy = pcol->cx;
    }

    if (mask & LVCF_TEXT)
    {
        RIPMSG(pcol->pszText != NULL, "LVM_SETCOLUMN: LV_COLUMN.pszText should not be NULL");

        item.mask |= HDI_TEXT;
        item.pszText = pcol->pszText;
        item.cchTextMax = 0;
    }

    if (mask & LVCF_IMAGE)
    {
        item.mask |= HDI_IMAGE;
        item.iImage = pcol->iImage;
    }

    if (mask & LVCF_ORDER)
    {
        item.mask |= HDI_ORDER;
        item.iOrder = pcol->iOrder;
    }


    plv->xTotalColumnWidth = RECOMPUTE;
    return Header_SetItem(plv->hwndHdr, iCol, &item);
}

BOOL ListView_SetSubItem(LV* plv, const LV_ITEM* plvi)
{
    LISTSUBITEM lsi;
    BOOL fChanged = FALSE;
    int i;
    int idpa;
    HDPA hdpa;

    if (plvi->mask & ~(LVIF_DI_SETITEM | LVIF_TEXT | LVIF_IMAGE | LVIF_STATE))
    {
        RIPMSG(0, "ListView: Invalid mask: %04x", plvi->mask);
        return FALSE;
    }

    if (!(plvi->mask & (LVIF_TEXT | LVIF_IMAGE | LVIF_STATE)))
        return TRUE;

    i = plvi->iItem;
    if (!ListView_IsValidItemNumber(plv, i))
    {
        RIPMSG(0, "LVM_SETITEM: Invalid iItem: %d", plvi->iItem);
        return FALSE;
    }

    // sub item indices are 1-based...
    //
    idpa = plvi->iSubItem - 1;
    if (idpa < 0 || idpa >= plv->cCol - 1)
    {
        RIPMSG(0, "LVM_SETITEM: Invalid iSubItem: %d", plvi->iSubItem);
        return FALSE;
    }

    hdpa = ListView_GetSubItemDPA(plv, idpa);
    if (!hdpa)
    {
        hdpa = DPA_CreateEx(LV_HDPA_GROW, plv->hheap);
        if (!hdpa)
            return FALSE;

        DPA_SetPtr(plv->hdpaSubItems, idpa, (void*)hdpa);
    }

    ListView_GetSubItem(plv, i, plvi->iSubItem, &lsi);

    if (plvi->mask & LVIF_TEXT) {
        if (lsi.pszText != plvi->pszText) {
            Str_Set(&lsi.pszText, plvi->pszText);
            fChanged = TRUE;
        }
    }

    if (plvi->mask & LVIF_IMAGE) {
        if (plvi->iImage != lsi.iImage) {
            lsi.iImage = (short) plvi->iImage;
            fChanged = TRUE;
        }
    }

    if (plvi->mask & LVIF_STATE) {
        DWORD dwChange;

        dwChange = (lsi.state ^ plvi->state ) & plvi->stateMask;

        if (dwChange) {
            lsi.state ^= dwChange;
            fChanged = TRUE;
        }
    }

    if (fChanged) {
        PLISTSUBITEM plsiReal = DPA_GetPtr(hdpa, i);
        if (!plsiReal) {
            plsiReal = LocalAlloc(LPTR, sizeof(LISTSUBITEM));
            if (!plsiReal) {
                // fail!  bail out
                return FALSE;
            }
        }
        *plsiReal = lsi;
        if (!DPA_SetPtr(hdpa, i, (void*)plsiReal)) {

            ListView_FreeSubItem(plsiReal);
            return FALSE;
        }
    }

    // all's well... let's invalidate this
    if (ListView_IsReportView(plv)) {
        RECT rc;
        ListView_RGetRectsEx(plv, plvi->iItem, plvi->iSubItem, NULL, &rc);
        RedrawWindow(plv->ci.hwnd, &rc, NULL, RDW_ERASE | RDW_INVALIDATE);
    }
    else if (ListView_IsTileView(plv))
    {
        LISTITEM *pitem = ListView_GetItemPtr(plv, i);
        if (pitem)
        {
            ListView_SetSRecompute(pitem);
            // For tile view, we need to recompute the item
            plv->rcView.left = RECOMPUTE;
        
            if (plv->iItemDrawing != i)
                ListView_InvalidateItemEx(plv, i, FALSE, RDW_ERASE | RDW_INVALIDATE, LVIF_TEXT);
        }
    }
    return TRUE;
}


int ListView_RDestroyColumn(LPVOID d, LPVOID p)
{
    HDPA hdpa = (HDPA)d;
    DPA_DestroyCallback(hdpa, ListView_FreeColumnData, 0);
    return 1;
}

void ListView_RDestroy(LV* plv)
{
    DPA_DestroyCallback(plv->hdpaSubItems, ListView_RDestroyColumn, 0);
    plv->hdpaSubItems = NULL;
}

VOID ListView_RHeaderTrack(LV* plv, HD_NOTIFY * pnm)
{
    // We want to update to show where the column header will be.
    HDC hdc;
    RECT rcBounds;

    // Statics needed from call to call
    static int s_xLast = -32767;

    hdc = GetDC(plv->ci.hwnd);
    if (hdc == NULL)
        return;

    //
    // First undraw the last marker we drew.
    //
    if (s_xLast > 0)
    {
        PatBlt(hdc, s_xLast, plv->yTop, g_cxBorder, plv->sizeClient.cy - plv->yTop, PATINVERT);
    }

    if (pnm->hdr.code == HDN_ENDTRACK)
    {
        s_xLast = -32767;       // Some large negative number...
    }
    else
    {

        RECT rc;

        //
        // First we need to calculate the X location of the column
        // To do this, we will need to know where this column begins
        // Note: We need the bounding rects to help us know the origin.
        ListView_GetRects(plv, 0, QUERY_DEFAULT, NULL, NULL, &rcBounds, NULL);

        if (!Header_GetItemRect(plv->hwndHdr, pnm->iItem, &rc)) {
            rc.left = 0;
        }
        rcBounds.left += rc.left;

        // Draw the new line...
        s_xLast = rcBounds.left + pnm->pitem->cxy;
        PatBlt(hdc, s_xLast, plv->yTop, g_cxBorder, plv->sizeClient.cy - plv->yTop, PATINVERT);
    }

    ReleaseDC(plv->ci.hwnd, hdc);
}

// try to use scrollwindow to adjust the columns rather than erasing
// and redrawing.
void ListView_AdjustColumn(LV * plv, int iWidth)
{
    int x;
    RECT rcClip;
    int dx = iWidth - plv->iSelOldWidth;

    if (iWidth == plv->iSelOldWidth)
        return;

    // find the x coord of the left side of the iCol
    // use rcClip as a temporary...
    if (!Header_GetItemRect(plv->hwndHdr, plv->iSelCol, &rcClip)) {
        x = 0;
    } else {
        x = rcClip.left;
    }
    x -= plv->ptlRptOrigin.x;

    // compute the area to the right of the adjusted column
    GetWindowRect(plv->hwndHdr, &rcClip);

    rcClip.left = x;
    rcClip.top = RECTHEIGHT(rcClip);
    rcClip.right = plv->sizeClient.cx;
    rcClip.bottom = plv->sizeClient.cy;

    if (plv->fGroupView || ListView_IsWatermarkedBackground(plv) || ListView_IsWatermarked(plv))
    {
        plv->xTotalColumnWidth = RECOMPUTE;
        ListView_UpdateScrollBars(plv);

        RedrawWindow(plv->ci.hwnd, NULL, NULL,
                     RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);

    }
    else if ((plv->pImgCtx == NULL) && 
             (plv->clrBk != CLR_NONE) &&
             (plv->clrTextBk != CLR_NONE))
    {
        //
        // We have a solid color background,
        // so we can smooth scroll the right side columns.
        //
        SMOOTHSCROLLINFO si = {0};

        si.cbSize =  sizeof(si),
        si.hwnd = plv->ci.hwnd,
        si.dx = dx,
        si.lprcClip = &rcClip;
        si.fuScroll = SW_ERASE | SW_INVALIDATE,
        rcClip.left += min(plv->iSelOldWidth, iWidth);
        SmoothScrollWindow(&si);

        // if we shrunk, invalidate the right most edge because
        // there might be junk there
        if (iWidth < plv->iSelOldWidth) 
        {
            rcClip.right = rcClip.left + g_cxEdge;
            InvalidateRect(plv->ci.hwnd, &rcClip, TRUE);
        }

        plv->xTotalColumnWidth = RECOMPUTE;

        // adjust clipping rect to only redraw the adjusted column
        rcClip.left = x;
        rcClip.right = max(rcClip.left, x+iWidth);

        // Make the rectangle origin-based because ListView_UpdateScrollBars
        // may scroll us around.
        OffsetRect(&rcClip, plv->ptlRptOrigin.x, plv->ptlRptOrigin.y);

        ListView_UpdateScrollBars(plv);

        // Okay, now convert it back to client coordinates
        OffsetRect(&rcClip, -plv->ptlRptOrigin.x, -plv->ptlRptOrigin.y);

        // call update because scrollwindowex might have erased the right
        // we don't want this invalidate to then enlarge the region
        // and end up erasing everything.
        UpdateWindow(plv->ci.hwnd);

        RedrawWindow(plv->ci.hwnd, &rcClip, NULL,
                     RDW_INVALIDATE | RDW_UPDATENOW);
    }
    else
    {
        //
        // We don't have a solid color background,
        // erase and redraw the adjusted column and
        // everything to the right (sigh).
        //
        plv->xTotalColumnWidth = RECOMPUTE;
        ListView_UpdateScrollBars(plv);

        rcClip.left = x;
        RedrawWindow(plv->ci.hwnd, &rcClip, NULL,
                     RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
    }
}

BOOL ListView_ForwardHeaderNotify(LV* plv, HD_NOTIFY *pnm)
{
    return BOOLFROMPTR(SendNotifyEx(plv->ci.hwndParent, pnm->hdr.hwndFrom, pnm->hdr.code,
                       (NMHDR *)pnm, plv->ci.bUnicode));
}

LRESULT ListView_HeaderNotify(LV* plv, HD_NOTIFY *pnm)
{
    LRESULT lres = 0;
    switch (pnm->hdr.code)
    {
    case HDN_BEGINDRAG:
        if (!(plv->exStyle & LVS_EX_HEADERDRAGDROP))
            return TRUE;

        return ListView_ForwardHeaderNotify(plv, pnm);

    case HDN_ENDDRAG:
        if (pnm->pitem->iOrder != -1) {
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
            return ListView_ForwardHeaderNotify(plv, pnm);
        }
        goto DoDefault;

    case HDN_ITEMCHANGING:
        if (pnm->pitem->mask & HDI_WIDTH) {
            HD_ITEM hitem;

            hitem.mask = HDI_WIDTH;
            Header_GetItem(plv->hwndHdr, pnm->iItem, &hitem);
            plv->iSelCol = pnm->iItem;
            plv->iSelOldWidth = hitem.cxy;
            TraceMsg(TF_LISTVIEW, "HDN_ITEMCHANGING %d %d", hitem.cxy, pnm->pitem->cxy);
            return ListView_ForwardHeaderNotify(plv, pnm);
        }
        else if (pnm->pitem->mask & HDI_FILTER) {
            return ListView_ForwardHeaderNotify(plv, pnm);
        }
        goto DoDefault;

    case HDN_ITEMCHANGED:
        if (pnm->pitem->mask & HDI_WIDTH)
        {
            ListView_DismissEdit(plv, FALSE);
            if (pnm->iItem == plv->iSelCol) {
                // Must do this even if there are no items, since
                // we have to redo the scrollbar, and the client
                // may have custom-drawn gridlines or something.
                ListView_AdjustColumn(plv, pnm->pitem->cxy);
            } else {
                // sanity check.  we got confused, so redraw all
                RedrawWindow(plv->ci.hwnd, NULL, NULL,
                             RDW_ERASE | RDW_INVALIDATE);
            }
            plv->iSelCol = -1;
            lres = ListView_ForwardHeaderNotify(plv, pnm);
        }
        else if (pnm->pitem->mask & HDI_FILTER) {
            lres = ListView_ForwardHeaderNotify(plv, pnm);
        } else
            goto DoDefault;
        break;


    case HDN_ITEMCLICK:
        {
            //
            // Need to pass this and other HDN_ notifications back to
            // parent.  Should we simply pass up the HDN notifications
            // or should we define equivlent LVN_ notifications...
            //
            // Pass column number in iSubItem, not iItem...
            //
            NMHEADER* pnmH = (NMHEADER*)pnm;
            ListView_DismissEdit(plv, FALSE);
            ListView_Notify(plv, -1, pnm->iItem, LVN_COLUMNCLICK);
            lres = ListView_ForwardHeaderNotify(plv, pnm);
            SetFocus(plv->ci.hwnd);
        }
        break;

    case HDN_TRACK:
    case HDN_ENDTRACK:
        ListView_DismissEdit(plv, FALSE);
        ListView_RHeaderTrack(plv, pnm);
        lres = ListView_ForwardHeaderNotify(plv, pnm);
        SetFocus(plv->ci.hwnd);
        break;

    case HDN_DIVIDERDBLCLICK:
        ListView_DismissEdit(plv, FALSE);
        ListView_RSetColumnWidth(plv, pnm->iItem, -1);
        lres = ListView_ForwardHeaderNotify(plv, pnm);
        SetFocus(plv->ci.hwnd);
        break;

    case HDN_FILTERCHANGE:
    case HDN_FILTERBTNCLICK:
        return ListView_ForwardHeaderNotify(plv, pnm);

    case NM_RCLICK:
        return (UINT)SendNotifyEx(plv->ci.hwndParent, plv->hwndHdr, NM_RCLICK, NULL, plv->ci.bUnicode);

    default:
DoDefault:
        return ListView_ForwardHeaderNotify(plv, pnm);
        break;
    }

    // in v < 5 we always returned 0
    // but for newer clients we'd like to have them deal with the notify
    return lres;
}

int ListView_RYHitTest(LV* plv, int cy)
{
    if (plv->fGroupView)
    {
        int iHit;
        for (iHit = 0; iHit < ListView_Count(plv); iHit++)
        {
            RECT rc;
            ListView_GetRects(plv, iHit, QUERY_DEFAULT, NULL, NULL, &rc, NULL);

            if (cy >= rc.top && cy < rc.bottom)
                return iHit;
        }
    }
    else
        return (cy + plv->ptlRptOrigin.y - plv->yTop) / plv->cyItem;

    return -1;
}

/*----------------------------------------------------------------
** Check for a hit in a report view.
**
** a hit only counts if it's on the icon or the string in the first
** column.  so we gotta figure out what this means exactly.  yuck.
**
** BONUS FEATURE:  If piSubItem is non-NULL, then we also hit-test
** against subitems.  But if we find nothing, we return iSubItem = 0
** for compatibility with the other hit-test functions.
**----------------------------------------------------------------*/
int ListView_RItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem)
{
    int iHit;
    int i, iSub;
    UINT flags;
    RECT rcLabel;
    RECT rcIcon;

    if (piSubItem)
        *piSubItem = 0;

    if (plv->rcView.left == RECOMPUTE && plv->fGroupView)
        ListView_Recompute(plv);

    flags = LVHT_NOWHERE;
    iHit = -1;

    i = ListView_RYHitTest(plv, y);
    if (ListView_IsValidItemNumber(plv, i))
    {
        if (plv->ci.style & LVS_OWNERDRAWFIXED) 
        {
            flags = LVHT_ONITEM;
            iHit = i;
        } 
        else 
        {
            RECT rcSelect;
            ListView_GetRects(plv, i, QUERY_DEFAULT, &rcIcon, &rcLabel, NULL, &rcSelect);

            // is the hit in the first column?
            if ((x < rcIcon.left - g_cxEdge) && x > (rcIcon.left - plv->cxState - LV_ICONTOSTATEOFFSET(plv)))
            {
                iHit = i;
                flags = LVHT_ONITEMSTATEICON;
            }
            else if ((x >= rcIcon.left) && (x < rcIcon.right))
            {
                iHit = i;
                flags = LVHT_ONITEMICON;
            }
            else if (x >= rcLabel.left && (x < rcSelect.right))
            {
                iHit = i;
                flags = LVHT_ONITEMLABEL;

                if (ListView_FullRowSelect(plv)) {
                    // this is kinda funky...  in full row select mode
                    // we're only really on the label if x is <= rcLabel.left + cxLabel
                    // because GetRects returns a label rect of the full column width
                    // and rcSelect has the full row in FullRowSelect mode
                    // (it has the label only width in non-fullrow select mode.
                    //
                    // go figure..
                    //
                    int cxLabel;
                    LISTITEM* pitem = NULL;

                    if (!ListView_IsOwnerData( plv ))
                    {
                        pitem = ListView_FastGetItemPtr(plv, i);
                    }
                    cxLabel = ListView_RGetCXLabel(plv, i, pitem, NULL, FALSE);

                    if (x >= min(rcLabel.left + cxLabel, rcLabel.right)) {
                        if (!piSubItem)
                            flags = LVHT_ONITEM;
                        else
                            goto CheckSubItem;
                    }
                }
            } else if (x < rcSelect.right && ListView_FullRowSelect(plv)) {
                // we can fall into this case if columns have been re-ordered
                iHit = i;
                flags = LVHT_ONITEM;
            } else if (piSubItem) {
            CheckSubItem:
                iSub = ListView_RXHitTest(plv, x);
                if (iSub >= 0) {
                    iHit = i;
                    *piSubItem = iSub;
                    // Flags still say LVHT_NOWHERE
                }
            }
        }
    }

    *pflags = flags;
    return iHit;
}

void ListView_GetSubItem(LV* plv, int i, int iSubItem, PLISTSUBITEM plsi)
{
    HDPA hdpa;
    PLISTSUBITEM plsiSrc = NULL;

    ASSERT( !ListView_IsOwnerData( plv ));

    // Sub items are indexed starting at 1...
    //
    RIPMSG(iSubItem > 0 && iSubItem < plv->cCol, "ListView: Invalid iSubItem: %d", iSubItem);

#ifdef DEBUG
    // Avoid the assert in DPA_GetPtr if somebdy tries to get a subitem
    // when no columns have been added.  We already RIP'd above.
    hdpa = plv->cCol ? ListView_GetSubItemDPA(plv, iSubItem - 1) : NULL;
#else
    hdpa = ListView_GetSubItemDPA(plv, iSubItem - 1);
#endif
    if (hdpa) {
        plsiSrc = DPA_GetPtr(hdpa, i);
    }


    if (plsiSrc) {
        *plsi = *plsiSrc;
    } else {

        // item data exists.. give defaults
        plsi->pszText = LPSTR_TEXTCALLBACK;
        plsi->iImage = I_IMAGECALLBACK;
        plsi->state = 0;
    }
}

LPTSTR ListView_RGetItemText(LV* plv, int i, int iSubItem)
{
    LISTSUBITEM lsi;

    ListView_GetSubItem(plv, i, iSubItem, &lsi);
    return lsi.pszText;
}

// this will return the rect of a subitem as requested.
void ListView_RGetRectsEx(LV* plv, int iItem, int iSubItem, LPRECT prcIcon, LPRECT prcLabel)
{
    int x;
    int y;
    LONG ly;
    RECT rcLabel;
    RECT rcIcon;
    RECT rcHeader;

    if (iSubItem == 0) 
    {
        ListView_RGetRects(plv, iItem, prcIcon, prcLabel, NULL, NULL);
        return;
    }

    ly = (LONG)iItem * plv->cyItem - plv->ptlRptOrigin.y + plv->yTop;
    // otherwise it's just the header's column right and left and the item's height
    if (plv->fGroupView && ListView_Count(plv) > 0)
    {
        LISTITEM* pitem = ListView_FastGetItemPtr(plv, iItem);
        if (pitem && LISTITEM_HASGROUP(pitem))
        {
            ly = pitem->pt.y - plv->ptlRptOrigin.y + plv->yTop;
        }
    }
    
    x = - (int)plv->ptlRptOrigin.x;

    //
    // Need to check for y overflow into rectangle structure
    // if so we need to return something reasonable...
    // For now will simply set it to the max or min that will fit...
    //
    if (ly >= (INT_MAX - plv->cyItem))
        y = INT_MAX - plv->cyItem;
    else if ( ly < INT_MIN)
        y = INT_MIN;
    else
        y = (int)ly;

    ASSERT(iSubItem < plv->cCol);
    Header_GetItemRect(plv->hwndHdr, iSubItem, &rcHeader);

    rcLabel.left = x + rcHeader.left;
    rcLabel.right = x + rcHeader.right;
    rcLabel.top = y;
    rcLabel.bottom = rcLabel.top + plv->cyItem;

    rcIcon = rcLabel;
    rcIcon.right = rcIcon.left + plv->cxSmIcon;

    if (SELECTOROF(prcIcon))
        *prcIcon = rcIcon;
    if (SELECTOROF(prcLabel))
        *prcLabel = rcLabel;
}

int ListView_RGetTotalColumnWidth(LV* plv)
{
    if (plv->xTotalColumnWidth == RECOMPUTE)
    {
        plv->xTotalColumnWidth = 0;
        if (plv->cCol) 
        {
            RECT rcLabel;
            int iIndex;

            // find the right edge of the last ordered item to get the total column width
            iIndex = (int) SendMessage(plv->hwndHdr, HDM_ORDERTOINDEX, plv->cCol - 1, 0);
            Header_GetItemRect(plv->hwndHdr, iIndex, &rcLabel);
            plv->xTotalColumnWidth = rcLabel.right;
        }
    }
    return plv->xTotalColumnWidth;
}

// get the rects for report view
void ListView_RGetRects(LV* plv, int iItem, RECT* prcIcon,
        RECT* prcLabel, RECT* prcBounds, RECT* prcSelectBounds)
{
    RECT rcIcon;
    RECT rcLabel;
    int x;
    int y;
    int cItems = ListView_Count(plv);
    LONG ly = 0;
    LVITEM lvitem;
    BOOL fItemSpecific = (prcIcon || prcLabel || prcSelectBounds);

    // If the item being asked for exceeds array bounds, use old calculation method
    // This isn't a problem because listview typically is asking for bounds, or invalidation rects.
    if (plv->fGroupView && iItem >= 0 && iItem < cItems)    
    {
        LISTITEM* pitem = ListView_FastGetItemPtr(plv, iItem);
        if (pitem && LISTITEM_HASGROUP(pitem))
        {
            ly = pitem->pt.y - plv->ptlRptOrigin.y + plv->yTop;
        }
    }
    else
    {
        ly = (LONG)iItem * plv->cyItem - plv->ptlRptOrigin.y + plv->yTop;
    }
    x = - (int)plv->ptlRptOrigin.x;

    //
    // Need to check for y overflow into rectangle structure
    // if so we need to return something reasonable...
    // For now will simply set it to the max or min that will fit...
    //
    if (ly >= (INT_MAX - plv->cyItem))
        y = INT_MAX - plv->cyItem;
    else
        y = (int)ly;


    if (ListView_Count(plv) && fItemSpecific) 
    {
        //  move this over by the indent level as well
        lvitem.mask = LVIF_INDENT;
        lvitem.iItem = iItem;
        lvitem.iSubItem = 0;
        ListView_OnGetItem(plv, &lvitem);
    } 
    else 
    {
        lvitem.iIndent = 0;
    }

    rcIcon.left   = x + plv->cxState + LV_ICONTOSTATEOFFSET(plv) + (lvitem.iIndent * plv->cxSmIcon) + g_cxEdge + LV_ICONINDENT;
    rcIcon.right  = rcIcon.left + plv->cxSmIcon;
    rcIcon.top    = y;
    rcIcon.bottom = rcIcon.top + plv->cyItem;

    rcLabel.left  = rcIcon.right;
    rcLabel.top   = rcIcon.top;
    rcLabel.bottom = rcIcon.bottom;

    //
    // The label is assumed to be the first column.
    //
    rcLabel.right = x;
    if (plv->cCol > 0 && fItemSpecific)
    {
        RECT rc;
        Header_GetItemRect(plv->hwndHdr, 0, &rc);
        rcLabel.right = x + rc.right;
        rcLabel.left += rc.left;
        rcIcon.left += rc.left;
        rcIcon.right += rc.left;
    }

    if (SELECTOROF(prcIcon))
        *prcIcon = rcIcon;

    // Save away the label bounds.
    if (SELECTOROF(prcLabel)) 
    {
        *prcLabel = rcLabel;
    }

    // See if they also want the Selection bounds of the item
    if (prcSelectBounds)
    {
        if (ListView_FullRowSelect(plv)) 
        {

            prcSelectBounds->left = x;
            prcSelectBounds->top = y;
            prcSelectBounds->bottom = rcLabel.bottom;
            prcSelectBounds->right = prcSelectBounds->left + ListView_RGetTotalColumnWidth(plv);

        } 
        else 
        {
            int cxLabel;
            LISTITEM* pitem = NULL;

            if (!ListView_IsOwnerData( plv ))
            {
                pitem = ListView_FastGetItemPtr(plv, iItem);
            }
            cxLabel = ListView_RGetCXLabel(plv, iItem, pitem, NULL, FALSE);

            *prcSelectBounds = rcIcon;
            prcSelectBounds->right = rcLabel.left + cxLabel;
            if (prcSelectBounds->right > rcLabel.right)
                prcSelectBounds->right = rcLabel.right;
        }
    }

    // And also the Total bounds

    //
    // and now for the complete bounds...
    //
    if (SELECTOROF(prcBounds))
    {
        prcBounds->left = x;
        prcBounds->top = y;
        prcBounds->bottom = rcLabel.bottom;

        prcBounds->right = prcBounds->left + ListView_RGetTotalColumnWidth(plv);
    }
}

BOOL ListView_OnGetSubItemRect(LV* plv, int iItem, LPRECT lprc)
{
    LPRECT pRects[LVIR_MAX];
    RECT rcTemp;

    int iSubItem;
    int iCode;

    if (!lprc)
        return FALSE;

    iSubItem = lprc->top;
    iCode = lprc->left;

    if (iSubItem == 0) 
    {

        return ListView_OnGetItemRect(plv, iItem, lprc);
    }

    if (!ListView_IsReportView(plv) ||
        (iCode != LVIR_BOUNDS && iCode != LVIR_ICON && iCode != LVIR_LABEL)) 
    {
        return FALSE;
    }

    pRects[0] = NULL;
    pRects[1] = &rcTemp;  // LVIR_ICON
    pRects[2] = &rcTemp;  // LVIR_LABEL
    pRects[3] = NULL;

    if (iCode != LVIR_BOUNDS) 
    {
        pRects[iCode] = lprc;
    } 
    else 
    {
        // choose either
        pRects[LVIR_ICON] = lprc;
    }

    ListView_RGetRectsEx(plv, iItem, iSubItem,
                        pRects[LVIR_ICON], pRects[LVIR_LABEL]);

    if (iCode == LVIR_BOUNDS) 
    {
        UnionRect(lprc, lprc, &rcTemp);
    }
    return TRUE;
}

int ListView_RXHitTest(LV* plv, int x)
{
    int iSubItem;

    for (iSubItem = plv->cCol - 1; iSubItem >= 0; iSubItem--) 
    {
        RECT rc;

        // see if its in this rect,
        if (!Header_GetItemRect(plv->hwndHdr, iSubItem, &rc))
            return -1;

        OffsetRect(&rc, -plv->ptlRptOrigin.x, 0);
        if (rc.left <= x && x < rc.right) 
        {
            break;
        }
    }
    return iSubItem;
}

int ListView_OnSubItemHitTest(LV* plv, LPLVHITTESTINFO plvhti)
{
    int i = -1;
    int iSubItem = 0;
    UINT uFlags = LVHT_NOWHERE;

    if (!plvhti) 
    {
        return -1;
    }

    if (ListView_IsReportView(plv)) 
    {
        iSubItem = ListView_RXHitTest(plv, plvhti->pt.x);
        if (iSubItem == -1) 
        {
            goto Bail;
        }
    }

    if (iSubItem == 0) 
    {
        // if we're in column 0, just hand it off to the old stuff
        ListView_OnHitTest(plv, plvhti);
        plvhti->iSubItem = 0;
        return plvhti->iItem;
    }

    if (!ListView_IsReportView(plv)) 
    {
        goto Bail;
    }

    i = ListView_RYHitTest(plv, plvhti->pt.y);
    if (i < ListView_Count(plv))
    {
        RECT rcIcon, rcLabel;

        if (i != -1)  
        {
            ListView_RGetRectsEx(plv, i, iSubItem, &rcIcon, &rcLabel);
            if (plvhti->pt.x >= rcIcon.left && plvhti->pt.x <= rcIcon.right) 
            {
                uFlags = LVHT_ONITEMICON;
            } 
            else if (plvhti->pt.x >= rcLabel.left && plvhti->pt.x <= rcLabel.right)
            {
                uFlags = LVHT_ONITEMLABEL;
            } 
            else
                uFlags = LVHT_ONITEM;
        }
    } 
    else 
    {
        i = -1;
    }

Bail:

    plvhti->iItem = i;
    plvhti->iSubItem = iSubItem;
    plvhti->flags = uFlags;

    return plvhti->iItem;
}



// See whether entire string will fit in *prc; if not, compute number of chars
// that will fit, including ellipses.  Returns length of string in *pcchDraw.
//
BOOL ListView_NeedsEllipses(HDC hdc, LPCTSTR pszText, RECT* prc, int* pcchDraw, int cxEllipses)
{
    int cchText;
    int cxRect;
    int ichMin, ichMax, ichMid;
    SIZE siz;

    cxRect = prc->right - prc->left;

    cchText = lstrlen(pszText);

    if (cchText == 0)
    {
        *pcchDraw = cchText;
        return FALSE;
    }

    GetTextExtentPoint(hdc, pszText, cchText, &siz);

    if (siz.cx <= cxRect)
    {
        *pcchDraw = cchText;
        return FALSE;
    }

    cxRect -= cxEllipses;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxRect > 0)
    {
        // Binary search to find character that will fit
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax)
        {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            //
            ichMid = (ichMin + ichMax + 1) / 2;

            GetTextExtentPoint(hdc, &pszText[ichMin], ichMid - ichMin, &siz);

            if (siz.cx < cxRect)
            {
                ichMin = ichMid;
                cxRect -= siz.cx;
            }
            else if (siz.cx > cxRect)
            {
                ichMax = ichMid - 1;
            }
            else
            {
                // Exact match up up to ichMid: just exit.
                //
                ichMax = ichMid;
                break;
            }
        }

        // Make sure we always show at least the first character...
        //
        if (ichMax < 1)
            ichMax = 1;
    }

    *pcchDraw = ichMax;
    return TRUE;
}

// in lvicon
DWORD ListView_GetClientRect(LV* plv, RECT* prcClient, BOOL fSubScroll, RECT *prcViewRect);

void ListView_RUpdateScrollBars(LV* plv)
{
    HD_LAYOUT layout;
    RECT rcClient;
    RECT rcBounds;
    WINDOWPOS wpos;
    int cColVis, cyColVis, iNewPos, iyDelta = 0, ixDelta = 0;
    BOOL fHorSB, fReupdate = FALSE;
    SCROLLINFO si;
    int iMin, iMax, iScreen, iPos;

    ListView_GetClientRect(plv, &rcClient, FALSE, NULL);

    if (!plv->hwndHdr)
        ListView_CreateHeader(plv);

    if (!plv->hwndHdr)
        TraceMsg(TF_WARNING, "ListView_RUpdateScrollBars could not create hwndHdr");

    layout.pwpos = &wpos;
    // For now lets try to handle scrolling the header by setting
    // its window pos.
    rcClient.left -= (int)plv->ptlRptOrigin.x;
    layout.prc = &rcClient;
    Header_Layout(plv->hwndHdr, &layout);
    rcClient.left += (int)plv->ptlRptOrigin.x;    // Move it back over!

    SetWindowPos(plv->hwndHdr, wpos.hwndInsertAfter, wpos.x, wpos.y,
                 wpos.cx, wpos.cy, wpos.flags | SWP_SHOWWINDOW);

    // Get the horizontal bounds of the items.
    ListView_RGetRects(plv, 0, NULL, NULL, &rcBounds, NULL);

    plv->yTop = rcClient.top;

    if (plv->fGroupView)
    {
        RECT rcView;
        ListView_GetClientRect(plv, &rcClient, TRUE, &rcView);
        iMin = 0;
        iMax = RECTHEIGHT(rcView) - 1;
        iScreen = RECTHEIGHT(rcClient);
        iPos = rcClient.top - rcView.top;
    }
    else
    {
        // fHorSB = Do I need a horizontal scrollbar?
        // cyColVis = number of pixels per screenful
        fHorSB = (rcBounds.right - rcBounds.left > rcClient.right);  // First guess.
        cyColVis = rcClient.bottom - rcClient.top -
                   (fHorSB ? ListView_GetCyScrollbar(plv) : 0);

        // If screen can't fit the entire listview...
        if (cyColVis < ListView_Count(plv) * plv->cyItem) 
        {
            //then we're going to have a vertical scrollbar.. make sure our horizontal count is correct
            rcClient.right -= ListView_GetCxScrollbar(plv);

            if (!fHorSB) 
            {
                // if we previously thought we weren't going to have a scrollbar, we could be wrong..
                // since the vertical bar shrunk our area
                fHorSB = (rcBounds.right - rcBounds.left > rcClient.right);  // First guess.
                cyColVis = rcClient.bottom - rcClient.top -
                           (fHorSB ? ListView_GetCyScrollbar(plv) : 0);
            }
        }

        // cColVis = number of completely visible items per screenful
        cColVis = cyColVis / plv->cyItem;
        iMin = 0;
        iMax = ListView_Count(plv) - 1;
        iScreen = cColVis;
        iPos = (int)(plv->ptlRptOrigin.y / plv->cyItem);
    }

    si.cbSize = sizeof(SCROLLINFO);

    si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
    si.nPos = iPos;
    si.nPage = iScreen;
    si.nMin = iMin;
    si.nMax = iMax;
    ListView_SetScrollInfo(plv, SB_VERT, &si, TRUE);

    // make sure our position and page doesn't hang over max
    if ((si.nPos > (int)si.nMax - (int)si.nPage + 1) && si.nPos > 0) 
    {
        iNewPos = (int)si.nMax - (int)si.nPage + 1;
        if (iNewPos < 0) iNewPos = 0;
        if (iNewPos != si.nPos) 
        {
            iyDelta = iNewPos - (int)si.nPos;
            fReupdate = TRUE;
        }
    }

    si.nPos = (int)plv->ptlRptOrigin.x;
    si.nPage = rcClient.right - rcClient.left;

    // We need to subtract 1 here because nMax is 0 based, and nPage is the actual
    // number of page pixels.  So, if nPage and nMax are the same we will get a
    // horz scroll, since there is 1 more pixel than the page can show, but... rcBounds
    // is like rcRect, and is the actual number of pixels for the whole thing, so
    // we need to set nMax so that: nMax - 0 == rcBounds.right - rcBound.left
    si.nMax = rcBounds.right - rcBounds.left - 1;
    ListView_SetScrollInfo(plv, SB_HORZ, &si, TRUE);

    // SWP_FRAMECHANGED redraws the background if the client
    // area has changed (taking into account scrollbars and
    // the Header window).  SetScrollInfo does this automatically
    // when it creates a scrollbar - we do it ourselves when
    // there is no scrollbar.
    if ((UINT)si.nPage > (UINT)si.nMax &&
        ((plv->pImgCtx && plv->fImgCtxComplete) || plv->hbmBkImage))
        SetWindowPos(plv->ci.hwnd, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);

    // make sure our position and page doesn't hang over max
    if ((si.nPos + (LONG)si.nPage - 1 > si.nMax) && si.nPos > 0) 
    {
        iNewPos = (int)si.nMax - (int)si.nPage + 1;
        if (iNewPos < 0) iNewPos = 0;
        if (iNewPos != si.nPos) 
        {
            ixDelta = iNewPos - (int)si.nPos;
            fReupdate = TRUE;
        }
    }

    if (fReupdate) 
    {
        // we shouldn't recurse because the second time through, si.nPos >0
        ListView_RScroll2(plv, ixDelta, iyDelta, 0);
        ListView_RUpdateScrollBars(plv);
        TraceMsg(TF_LISTVIEW, "LISTVIEW: ERROR: We had to recurse!");
    }
}

//
//  We need a smoothscroll callback so our background image draws
//  at the correct origin.  If we don't have a background image,
//  then this work is superfluous but not harmful either.
//
int CALLBACK ListView_RScroll2_SmoothScroll(
    HWND hwnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags)
{
    LV* plv = ListView_GetPtr(hwnd);
    if (plv)
    {
        plv->ptlRptOrigin.x -= dx;
        plv->ptlRptOrigin.y -= dy;
    }

    // Now do what SmoothScrollWindow would've done if we weren't
    // a callback

    if (ListView_IsWatermarkedBackground(plv) || 
        ListView_IsWatermarked(plv))
    {
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        return TRUE;
    }
    else
        return ScrollWindowEx(hwnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
}



void ListView_RScroll2(LV* plv, int dx, int dy, UINT uSmooth)
{
    LONG ldy;

    if (dx | dy)
    {
        RECT rc;

        GetClientRect(plv->ci.hwnd, &rc);

        rc.top = plv->yTop;

        // We can not do a simple multiply here as we may run into
        // a case where this will overflow an int..

        if (plv->fGroupView)
        {
            ldy = (LONG)dy;
        }
        else
        {
            ldy = (LONG)dy * plv->cyItem;
        }

        // handle case where dy is large (greater than int...)
        if ((ldy > rc.bottom) || (ldy < -rc.bottom)) 
        {
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
            plv->ptlRptOrigin.x += dx;
            plv->ptlRptOrigin.y += ldy;
        } 
        else
        {
            SMOOTHSCROLLINFO si;

            si.cbSize = sizeof(si);
            si.fMask = SSIF_SCROLLPROC;
            si.hwnd = plv->ci.hwnd;
            si.dx = -dx;
            si.dy = (int)-ldy;
            si.lprcSrc = NULL;
            si.lprcClip = &rc;
            si.hrgnUpdate = NULL;
            si.lprcUpdate = NULL;
            si.fuScroll =SW_INVALIDATE | SW_ERASE | uSmooth;
            si.pfnScrollProc = ListView_RScroll2_SmoothScroll;
            SmoothScrollWindow(&si);

            /// this causes horrible flicker/repaint on deletes.
            // if this is a problem with UI scrolling, we'll have to pass through a
            // flag when to use this
            ///UpdateWindow(plv->ci.hwnd);
        }

        // if Horizontal scrolling, we should update the location of the
        // left hand edge of the window...
        //
        if (dx != 0)
        {
            RECT rcHdr;
            GetWindowRect(plv->hwndHdr, &rcHdr);
            MapWindowRect(HWND_DESKTOP, plv->ci.hwnd, &rcHdr);
            SetWindowPos(plv->hwndHdr, NULL, rcHdr.left - dx, rcHdr.top,
                    rcHdr.right - rcHdr.left + dx,
                    rcHdr.bottom - rcHdr.top,
                    SWP_NOZORDER | SWP_NOACTIVATE);
        }
    }
}

//-------------------------------------------------------------------
// Make sure that specified item is visible for report view.
// Must handle Large number of items...
BOOL ListView_ROnEnsureVisible(LV* plv, int iItem, BOOL fPartialOK)
{
    LONG dy;
    LONG yTop;
    LONG lyTop;

    yTop = plv->yTop;

    // lyTop = where our item is right now
    if (plv->fGroupView)
    {
        LISTITEM* pitem = ListView_GetItemPtr(plv, iItem);
        RECT rcBounds;
        ListView_RGetRects(plv, iItem, NULL, NULL, &rcBounds, NULL);
        if (pitem)
        {
            LISTGROUP* pgrp = ListView_FindFirstVisibleGroup(plv);
            if (pitem->pGroup == pgrp && pgrp)
            {
                rcBounds.top -= max(pgrp->cyTitle + 6, plv->rcBorder.top) + plv->paddingTop;
            }
        }

        lyTop = rcBounds.top;
    }
    else
    {
        lyTop = (LONG)iItem * plv->cyItem - plv->ptlRptOrigin.y + plv->yTop;
    }

    // If visible below yTop and our bottom is visible above client bottom,
    // then we're happy.
    if ((lyTop >= (LONG)yTop) &&
            ((lyTop + plv->cyItem) <= (LONG)plv->sizeClient.cy))
        return(TRUE);       // we are visible

    dy = lyTop - yTop;
    if (dy >= 0)
    {
        // dy = how many pixels we need to scroll to come into view
        dy = lyTop + plv->cyItem - plv->sizeClient.cy;
        if (dy < 0)
            dy = 0;
    }

    if (dy)
    {
        int iRound = ((dy > 0) ? 1 : -1) * (plv->cyItem - 1);

        if (!plv->fGroupView)
        {
            // Now convert into the number of items to scroll...
            // Groupview uses pixels not items, so this calculation is not needed in groupview.
            dy = (dy + iRound) / plv->cyItem;
        }

        ListView_RScroll2(plv, 0, (int)dy, 0);
        if (ListView_RedrawEnabled(plv)) 
        {
            ListView_UpdateScrollBars(plv);
        }
        else
        {
            ListView_DeleteHrgnInval(plv);
            plv->hrgnInval = (HRGN)ENTIRE_REGION;
            plv->flags |= LVF_ERASE;
        }
    }
    return TRUE;
}

int ListView_RGetScrollUnitsPerLine(LV* plv, UINT sb)
{
    int cLine;
    if (sb == SB_VERT)
    {
        if (plv->fGroupView)
        {
            cLine = plv->cyItem;
        }
        else
        {
            cLine = 1;
        }
    }
    else
    {
        cLine = plv->cxLabelChar;
    }

    return cLine;
}

void ListView_ROnScroll(LV* plv, UINT code, int posNew, UINT sb)
{
    int cLine = ListView_RGetScrollUnitsPerLine(plv, sb);

    ListView_ComOnScroll(plv, code, posNew, sb, cLine, -1);
}

BOOL ListView_RRecomputeEx(LV* plv, HDPA hdpaSort, int iFrom, BOOL fForce)
{
    if (plv->fGroupView && plv->hdpaGroups)
    {
        LISTGROUP* pgrp;
        int cGroups;
        int iAccumulatedHeight = 0;
        int i;
        int cItems = ListView_Count(plv);
        int iGroupItem;
        LISTITEM* pitem;


        for (iGroupItem = 0; iGroupItem < cItems; iGroupItem++)
        {
            LV_ITEM item = {0};
            pitem = ListView_FastGetItemPtr(plv, iGroupItem);
            if (!pitem)
                break;

            item.iItem = iGroupItem;
            item.lParam = pitem->lParam;

            if (!LISTITEM_HASASKEDFORGROUP(pitem))
            {
                item.mask = LVIF_GROUPID;
                ListView_OnGetItem(plv, &item);
            }
        }

        if (iFrom > 0)
        {
            LISTGROUP* pgrpPrev = DPA_FastGetPtr(plv->hdpaGroups, iFrom - 1);
            iAccumulatedHeight = pgrpPrev->rc.bottom + plv->paddingBottom;
        }

        // Need to do this afterwards because we may have added groups in the above block
        cGroups = DPA_GetPtrCount(plv->hdpaGroups);

        for (i = iFrom; i < cGroups; i++)
        {
            pgrp = DPA_FastGetPtr(plv->hdpaGroups, i);

            if (!pgrp)  // Huh?
                break;

            cItems = DPA_GetPtrCount(pgrp->hdpa);

            if (cItems == 0)
            {
                SetRect(&pgrp->rc, 0,  0,  0, 0);
            }
            else
            {
                int iGroupItem;
                RECT rcBoundsPrev = {0};

                if (pgrp->pszHeader && (pgrp->cyTitle == 0 || fForce))
                {
                    RECT rc = {0, 0, 1000, 0};
                    HDC hdc = GetDC(plv->ci.hwnd);
                    HFONT hfontOld = SelectObject(hdc, plv->hfontGroup);

                    DrawText(hdc, pgrp->pszHeader, -1, &rc, DT_LV | DT_CALCRECT);

                    SelectObject(hdc, hfontOld);
                    ReleaseDC(plv->ci.hwnd, hdc);

                    pgrp->cyTitle = RECTHEIGHT(rc);
                }

                iAccumulatedHeight += max(plv->rcBorder.top, pgrp->cyTitle + 6) + plv->paddingTop;

                SetRect(&pgrp->rc, plv->rcBorder.left,  iAccumulatedHeight,  
                    plv->sizeClient.cx - plv->rcBorder.right, iAccumulatedHeight + cItems * (plv->cyItem + LV_DETAILSPADDING) + plv->paddingBottom);

                iAccumulatedHeight += RECTHEIGHT(pgrp->rc);
                for (iGroupItem = 0; iGroupItem < cItems; iGroupItem++)
                {
                    LISTITEM* pitem = DPA_FastGetPtr(pgrp->hdpa, iGroupItem);
                    if (!pitem)
                        break;

                    pitem->pt.x = 0;
                    pitem->pt.y = pgrp->rc.top + iGroupItem * (plv->cyItem + LV_DETAILSPADDING);
                }
            }
        }


        SetRectEmpty(&plv->rcView);
        // Find the first group with an item in it.
        for (i = 0; i < cGroups; i++)
        {
            pgrp = DPA_FastGetPtr(plv->hdpaGroups, i);
            if (DPA_GetPtrCount(pgrp->hdpa) > 0)
            {
                plv->rcView.top = pgrp->rc.top - max(plv->rcBorder.top, pgrp->cyTitle + 6) - plv->paddingTop;
                plv->rcView.left = pgrp->rc.left - plv->rcBorder.left - plv->paddingLeft;
                break;
            }
        }

        for (i = cGroups - 1; i >= 0; i--)
        {
            pgrp = DPA_FastGetPtr(plv->hdpaGroups, i);
            if (DPA_GetPtrCount(pgrp->hdpa))
            {
                plv->rcView.bottom = pgrp->rc.bottom + plv->rcBorder.bottom + plv->paddingBottom;
                break;
            }
        }

        ListView_UpdateScrollBars(plv);

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\lvicon.c ===
// large icon view stuff

#include "ctlspriv.h"
#include "listview.h"

#if defined(FE_IME) || !defined(WINNT)
static TCHAR const szIMECompPos[]=TEXT("IMECompPos");
#endif

__inline int ICONCXLABEL(LV *plv, LISTITEM *pitem)
{
    if (plv->ci.style & LVS_NOLABELWRAP) {
        ASSERT(pitem->cxSingleLabel == pitem->cxMultiLabel);
    }
    return pitem->cxMultiLabel;
}

int LV_GetNewColWidth(LV* plv, int iFirst, int iLast);
void LV_AdjustViewRectOnMove(LV* plv, LISTITEM *pitem, int x, int y);
void ListView_RecalcRegion(LV *plv, BOOL fForce, BOOL fRedraw);
void ListView_ArrangeOrSnapToGrid(LV *plv);
extern BOOL g_fSlowMachine;

void _GetCurrentItemSize(LV* plv, int * pcx, int *pcy)
{
    if (ListView_IsSmallView(plv))
    {
        *pcx = plv->cxItem;
        *pcy = plv->cyItem;
    }
    else if (ListView_IsTileView(plv))
    {
        *pcx = plv->sizeTile.cx;
        *pcy = plv->sizeTile.cy;
    }
    else
    {
        *pcx = plv->cxIconSpacing;
        *pcy = plv->cyIconSpacing;
    }
}

BOOL ListView_IDrawItem(PLVDRAWITEM plvdi)
{
    RECT rcIcon;
    RECT rcLabel;
    RECT rcBounds;
    RECT rcBiasedBounds;
    RECT rcT;
    TCHAR ach[CCHLABELMAX];
    LV_ITEM item;
    int i = (int) plvdi->nmcd.nmcd.dwItemSpec;
    LV* plv = plvdi->plv;
    LISTITEM* pitem;
    BOOL fUnfolded;

    if (ListView_IsOwnerData(plv))
    {
        LISTITEM litem;
        // moved here to reduce call backs in OWNERDATA case
        item.iItem = i;
        item.iSubItem = 0;
        item.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE;
        item.stateMask = LVIS_ALL;
        item.pszText = ach;
        item.cchTextMax = ARRAYSIZE(ach);
        ListView_OnGetItem(plv, &item);

        litem.pszText = item.pszText;
        ListView_GetRectsOwnerData(plv, i, &rcIcon, &rcLabel, &rcBounds, NULL, &litem);
        pitem = NULL;
    }
    else
    {
        pitem = ListView_GetItemPtr(plv, i);
        // NOTE this will do a GetItem LVIF_TEXT iff needed
        ListView_GetRects(plv, i, QUERY_DEFAULT, &rcIcon, &rcLabel, &rcBounds, NULL);
    }

    fUnfolded = FALSE;
    if ( (plvdi->flags & LVDI_UNFOLDED) || ListView_IsItemUnfolded(plv, i))
    {
        ListView_UnfoldRects(plv, i, &rcIcon, &rcLabel, &rcBounds, NULL );
        fUnfolded = TRUE;
    }


    rcBiasedBounds = rcBounds;
    if (ListView_IsBorderSelect(plv))
        InflateRect(&rcBiasedBounds, BORDERSELECT_THICKNESS, BORDERSELECT_THICKNESS);

    if (!plvdi->prcClip || IntersectRect(&rcT, &rcBiasedBounds, plvdi->prcClip))
    {
        RECT rcIconReal;
        UINT fText;
        COLORREF clrIconBk = plv->clrBk;
        if (!ListView_IsOwnerData(plv))
        {
            item.iItem = i;
            item.iSubItem = 0;
            item.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE;
            item.stateMask = LVIS_ALL;
            item.pszText = ach;
            item.cchTextMax = ARRAYSIZE(ach);
            ListView_OnGetItem(plv, &item);
            
            // Make sure the listview hasn't been altered during
            // the callback to get the item info

            if (pitem != ListView_GetItemPtr(plv, i))
                return FALSE;
        }

        if (plvdi->lpptOrg)
        {
            OffsetRect(&rcIcon, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
            OffsetRect(&rcLabel, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
            OffsetRect(&rcBounds, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
        }

        fText = ListView_GetTextSelectionFlags(plv, &item, plvdi->flags);

        if (ListView_IsIconView(plv))
        {
            rcIcon.left += ListView_GetIconBufferX(plv);
            rcIcon.top += ListView_GetIconBufferY(plv);

            fText = ListView_DrawImageEx(plv, &item, plvdi->nmcd.nmcd.hdc,
                                       rcIcon.left, rcIcon.top, clrIconBk, plvdi->flags, -1);

            SetRect(&rcIconReal, rcIcon.left, rcIcon.top, rcIcon.left + plv->cxIcon, rcIcon.top + plv->cyIcon);


            if (ListView_IsBorderSelect(plv))
            {
                int cp = 1;
                COLORREF clrOutline = plv->clrOutline;
                if (fText & SHDT_SELECTED || fText & SHDT_SELECTNOFOCUS)
                {
                    clrOutline = (fText & SHDT_SELECTED)?g_clrHighlight:g_clrBtnFace;
                    cp = BORDERSELECT_THICKNESS;
                    InflateRect(&rcIconReal, cp, cp);
                }
                SHOutlineRectThickness(plvdi->nmcd.nmcd.hdc, &rcIconReal, clrOutline, g_clrBtnFace, cp);
            }

            // If linebreaking needs to happen, then use SHDT_DRAWTEXT.
            // Otherwise, use our (hopefully faster) internal SHDT_ELLIPSES
            if (rcLabel.bottom - rcLabel.top > plv->cyLabelChar)
                fText |= SHDT_DRAWTEXT;
            else
                fText |= SHDT_ELLIPSES;

            // We only use DT_NOFULLWIDTHCHARBREAK on Korean(949) Memphis and NT5
            if (949 == g_uiACP)
                fText |= SHDT_NODBCSBREAK;

        }
        else
        {
            SetRect(&rcIconReal, rcIcon.left, rcIcon.top, rcIcon.left + plv->cxIcon, rcIcon.top + plv->cyIcon);
            fText = ListView_DrawImageEx(plv, &item, plvdi->nmcd.nmcd.hdc,
                                       rcIcon.left, rcIcon.top, clrIconBk, plvdi->flags, -1);
        }

        if (ListView_HideLabels(plv) && 
            (plvdi->flags & LVDI_FOCUS) && 
            (item.state & LVIS_FOCUSED) && 
            !(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS))
        {
            DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcIconReal);
        }

        // Don't draw label if it's being edited...
        // or if it is hidden due to the HideLabels style.
        //
        if ((plv->iEdit != i) && !ListView_HideLabels(plv))
        {
            HRESULT hr = E_FAIL;
            COLORREF clrTextBk = plvdi->nmcd.clrTextBk;
            // If multiline label, then we need to use DrawText
            if (rcLabel.bottom - rcLabel.top > plv->cyLabelChar)
            {
                fText |= SHDT_DRAWTEXT;

                // If the text is folded, we need to clip and add ellipses

                if (!fUnfolded)
                    fText |= SHDT_CLIPPED | SHDT_DTELLIPSIS;

                if ( ListView_IsOwnerData(plv) )
                {
                    // If owner data, we have no z-order and if long names they will over lap each
                    // other, better to truncate for now...
                    if (ListView_IsSmallView(plv))
                        fText |= SHDT_ELLIPSES;
                }

            }
            else
                fText |= SHDT_ELLIPSES;

            if (plvdi->flags & LVDI_TRANSTEXT)
                fText |= SHDT_TRANSPARENT;

            if ((fText & SHDT_SELECTED) && (plvdi->flags & LVDI_HOTSELECTED))
                fText |= SHDT_HOTSELECTED;

            if (item.pszText && (*item.pszText))
            {
                if (plv->pImgCtx || ListView_IsWatermarked(plv))
                    clrTextBk = CLR_NONE;

                if(plv->dwExStyle & WS_EX_RTLREADING)
                    fText |= SHDT_RTLREADING;

                if ((plv->clrBk == CLR_NONE) &&
                    !(fText & (SHDT_SELECTED | SHDT_HOTSELECTED | SHDT_SELECTNOFOCUS)) && // And we're not selected
                    !(plv->flags & LVF_DRAGIMAGE) &&                                      // And this is not during dragdrop.
                    !(plv->exStyle & LVS_EX_REGIONAL) &&                                  // No need for regional.    
                    plv->fListviewShadowText)                                             // and enabled
                {
                    fText |= SHDT_SHADOWTEXT;
                }

                SHDrawText(plvdi->nmcd.nmcd.hdc, item.pszText, &rcLabel, LVCFMT_LEFT, fText,
                           plv->cyLabelChar, plv->cxEllipses,
                           plvdi->nmcd.clrText, clrTextBk);

                if ((plvdi->flags & LVDI_FOCUS) && 
                    (item.state & LVIS_FOCUSED) && 
                    !(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS))
                {
                    rcLabel.top -= g_cyCompensateInternalLeading;
                    DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcLabel);
                }
            }
        }
    }
    return TRUE;
}

void ListView_RefoldLabelRect(LV* plv, RECT *prcLabel, LISTITEM *pitem)
{
    int bottom = pitem->cyUnfoldedLabel;
    bottom = min(bottom, pitem->cyFoldedLabel);
    bottom = min(bottom, CLIP_HEIGHT);
    prcLabel->bottom = prcLabel->top + bottom;
}


ULONGLONG _GetDistanceToRect(LV* plv, RECT *prcSlot, int x, int y)
{
    int xSlotCenter = prcSlot->left + RECTWIDTH(*prcSlot) / 2;
    int ySlotCenter = prcSlot->top + RECTHEIGHT(*prcSlot) / 2;
    LONGLONG dx = (LONGLONG)(x - xSlotCenter);
    LONGLONG dy = (LONGLONG)(y - ySlotCenter);

    return (ULONGLONG)(dx * dx) + (ULONGLONG)(dy * dy);
}


// prcSlot returned in Listview Coordinates
void ListView_CalcItemSlotAndRect(LV* plv, LISTITEM* pitem, int* piSlot, RECT* prcSlot)
{
    int cxScreen, cyScreen, cSlots, iHit;
    POINT pt;

    // Determine which slot this item is in by calculating the hit slot for the
    // item's x,y position.

    short iWorkArea = (plv->nWorkAreas > 0) ? pitem->iWorkArea : -1;

    cSlots = ListView_GetSlotCountEx(plv, TRUE, iWorkArea, &cxScreen, &cyScreen);

    // Adjust point by current workarea location.
    if (iWorkArea >= 0)
    {
        pt.x = pitem->pt.x - plv->prcWorkAreas[iWorkArea].left;
        pt.y = pitem->pt.y - plv->prcWorkAreas[iWorkArea].top;
    }
    else
    {
        pt = pitem->pt;
    }

    iHit = ListView_CalcHitSlot(plv, pt, cSlots, cxScreen, cyScreen);

    if (piSlot)
        *piSlot = iHit;

    if (prcSlot)
        ListView_CalcSlotRect(plv, pitem, iHit, cSlots, FALSE, cxScreen, cyScreen, prcSlot);
}

int ListView_FindItemInSlot(LV* plv, short iWorkArea, int iSlotToFind)
{
    int iItemFound = -1;
    int cItems;

    cItems = ListView_Count(plv);
  
    if (cItems == 0 || !ListView_IsRearrangeableView(plv) || plv->hdpaZOrder == NULL || ListView_IsOwnerData( plv ))
    {
        // nothing to check
    }
    else
    {
        int i;

        for (i = 0; i < cItems; i++)
        {
            LISTITEM* pitem = ListView_GetItemPtr(plv, i);
            // Only consider items in this workarea.
            if (pitem && ((iWorkArea == -1) || (pitem->iWorkArea == iWorkArea)))
            {
                int iSlot;
                ListView_CalcItemSlotAndRect(plv, pitem, &iSlot, NULL);

                if (iSlot == iSlotToFind)
                {
                    iItemFound = i;
                    break;
                }
            }
        }
    }

    return iItemFound;
}

BOOL ListView_OnInsertMarkHitTest(LV* plv, int x, int y, LPLVINSERTMARK plvim)
{
    POINT pt = {x + plv->ptOrigin.x, y + plv->ptOrigin.y};
    short iWorkArea = -1;
    int cItems;

    if (plvim->cbSize != sizeof(LVINSERTMARK))
        return FALSE;

    if (plv->nWorkAreas)
    {
        ListView_FindWorkArea(plv, pt, &iWorkArea);
    }

    cItems = ListView_Count(plv);
  
    if (cItems == 0 || !ListView_IsRearrangeableView(plv) || plv->hdpaZOrder == NULL || ListView_IsOwnerData( plv ))
    {
        plvim->dwFlags = 0;
        plvim->iItem = -1;
    }
    else
    {
        ULONGLONG uClosestDistance = (ULONGLONG)-1; // MAX INT
        LISTITEM* pClosestItem = NULL;
        int iClosestItem = -1;
        int iClosestSlot = -1;
        RECT rcClosestSlot;
        int i;

        for (i = 0; i < cItems; i++)
        {
            // Only consider items in this workarea.
            LISTITEM* pitem = ListView_GetItemPtr(plv, i);
            if (pitem && ((iWorkArea == -1) || (pitem->iWorkArea == iWorkArea)))
            {
                int  iSlot;
                RECT rcSlot;
                ListView_CalcItemSlotAndRect(plv, pitem, &iSlot, &rcSlot);

                if (PtInRect(&rcSlot, pt))
                {
                    // Hit it. This is as close as we can get.
                    pClosestItem = pitem;
                    iClosestItem = i;
                    iClosestSlot = iSlot;
                    rcClosestSlot = rcSlot;
                    break;
                }
                else
                {
                    // Keep track of closest item in this workarea, in case none are hit.
                    ULONGLONG uDistance = _GetDistanceToRect(plv, &rcSlot, pt.x, pt.y);
                    if (uDistance < uClosestDistance)
                    {
                        pClosestItem = pitem;
                        iClosestItem = i;
                        iClosestSlot = iSlot;
                        rcClosestSlot = rcSlot;
                        uClosestDistance = uDistance;
                    }
                }
            }
        }

        if (pClosestItem)
        {
            BOOL fVert = !((plv->ci.style & LVS_ALIGNMASK) == LVS_ALIGNTOP);    // what about lvs_alignbottom?
            int iDragSlot = -1;

            // For the drag source case, we need the drag slot to compare against
            if (-1 != plv->iDrag)
            {
                LISTITEM* pitemDrag =  ListView_GetItemPtr(plv, plv->iDrag);
                if (pitemDrag)
                    ListView_CalcItemSlotAndRect(plv, pitemDrag, &iDragSlot, NULL);
            }

            // Now that we have the item, calculate before/after
            if (fVert)
                plvim->dwFlags = (pt.y > (rcClosestSlot.top + (RECTHEIGHT(rcClosestSlot))/2)) ? LVIM_AFTER : 0;
            else
                plvim->dwFlags = (pt.x > (rcClosestSlot.left + (RECTWIDTH(rcClosestSlot))/2)) ? LVIM_AFTER : 0;

            plvim->iItem = iClosestItem;

            // If this is the drag source (or right next to it) then ignore the hit.
            if (-1 != iDragSlot &&
                ((iDragSlot==iClosestSlot) ||
                 (iDragSlot==(iClosestSlot-1) && !(plvim->dwFlags & LVIM_AFTER)) ||
                 (iDragSlot==(iClosestSlot+1) && (plvim->dwFlags & LVIM_AFTER))))
            {
                plvim->dwFlags = 0;
                plvim->iItem = -1;
            }
            else if ((plv->ci.style & LVS_AUTOARRANGE) && !(plv->exStyle & LVS_EX_SINGLEROW) && !fVert) // auto arrange needs to tweak some beginning/end-of-line cases
            {
                RECT rcViewWorkArea;
                if (-1 != iWorkArea)
                {
                    rcViewWorkArea = plv->prcWorkAreas[iWorkArea];
                }
                else
                {
                    if (plv->rcView.left == RECOMPUTE)
                        ListView_Recompute(plv);
                    rcViewWorkArea = plv->rcView;
                }

                if ((-1 != iDragSlot) && (iClosestSlot > iDragSlot) && !(plvim->dwFlags & LVIM_AFTER))
                {
                    // We're after our drag source, if we're at the beginning of a line
                    // then the insert mark is actually at the end of the previous line.
                    if (rcClosestSlot.left - RECTWIDTH(rcClosestSlot)/2 < rcViewWorkArea.left)
                    {
                        int iItemPrev = ListView_FindItemInSlot(plv, iWorkArea, iClosestSlot-1);
                        if (-1 != iItemPrev)
                        {
                            plvim->dwFlags = LVIM_AFTER;
                            plvim->iItem = iItemPrev;
                        }
                    }
                }
                else if (((-1 == iDragSlot) || (iClosestSlot < iDragSlot)) && (plvim->dwFlags & LVIM_AFTER))
                {
                    // We're before our drag source (or there is no drag source), if we're at end of a line
                    // then the insert mark is actually at the beginning of the next line.
                    if (rcClosestSlot.right + RECTWIDTH(rcClosestSlot)/2 > rcViewWorkArea.right)
                    {
                        int iItemNext = ListView_FindItemInSlot(plv, iWorkArea, iClosestSlot+1);
                        if (-1 != iItemNext)
                        {
                            plvim->dwFlags = 0;
                            plvim->iItem = iItemNext;
                        }
                    }
                }
            }
        }
        else
        {
            // No insert mark.
            plvim->dwFlags = 0;
            plvim->iItem = -1;
        }
    }
    return TRUE;
}


int ListView_IItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem)
{
    int iHit;
    UINT flags;
    POINT pt;
    RECT rcLabel = {0};
    RECT rcIcon = {0};
    RECT rcState = {0};
    
    if (piSubItem)
        *piSubItem = 0;

    // Map window-relative coordinates to view-relative coords...
    //
    pt.x = x + plv->ptOrigin.x;
    pt.y = y + plv->ptOrigin.y;

    // If there are any uncomputed items, recompute them now.
    //
    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    flags = 0;

    if (ListView_IsOwnerData( plv ))
    {
        int cSlots;
        POINT ptWnd;
        LISTITEM item;
        int iWidth = 0, iHeight = 0;

        cSlots = ListView_GetSlotCount( plv, TRUE, &iWidth, &iHeight );
        iHit = ListView_CalcHitSlot( plv, pt, cSlots, iWidth, iHeight );
        if (iHit < ListView_Count(plv))
        {
            ListView_IGetRectsOwnerData( plv, iHit, &rcIcon, &rcLabel, &item, FALSE );
            ptWnd.x = x;
            ptWnd.y = y;
            if (PtInRect(&rcIcon, ptWnd))
            {
                flags = LVHT_ONITEMICON;
            }
            else if (PtInRect(&rcLabel, ptWnd) && !ListView_HideLabels(plv))
            {
                flags = LVHT_ONITEMLABEL;
            }
        }
    }
    else
    {
        for (iHit = 0; (iHit < ListView_Count(plv)); iHit++)
        {
            LISTITEM* pitem = ListView_FastGetZItemPtr(plv, iHit);
            POINT ptItem;
            RECT rcBounds;  // Only used if ListView_IsBorderSelect

            ptItem.x = pitem->pt.x;
            ptItem.y = pitem->pt.y;

            rcIcon.top    = ptItem.y - g_cyIconMargin;

            rcLabel.top    = ptItem.y + plv->cyIcon + g_cyLabelSpace;
            rcLabel.bottom = rcLabel.top + pitem->cyUnfoldedLabel;


            if ( !ListView_IsItemUnfoldedPtr(plv, pitem) )
                ListView_RefoldLabelRect(plv, &rcLabel, pitem);

            // Quick, easy rejection test...
            //
            if (pt.y < rcIcon.top || pt.y >= rcLabel.bottom)
                continue;
 
            rcIcon.left   = ptItem.x - g_cxIconMargin;
            rcIcon.right  = ptItem.x + plv->cxIcon + g_cxIconMargin;
            // We need to make sure there is no gap between the icon and label
            rcIcon.bottom = rcLabel.top;

            if (ListView_IsSimpleSelect(plv) && 
                    (ListView_IsIconView(plv) || ListView_IsTileView(plv)))
            {
                rcState.top = rcIcon.top;
                rcState.right = rcIcon.right - ((RECTWIDTH(rcIcon) -plv->cxIcon) / 2);
                rcState.left = rcState.right - plv->cxState;
                rcState.bottom = rcState.top + plv->cyState;
            }
            else
            {
                rcState.bottom = ptItem.y + plv->cyIcon;
                rcState.right = ptItem.x;
                rcState.top = rcState.bottom - plv->cyState;
                rcState.left = rcState.right - plv->cxState;
            }

            if (ListView_HideLabels(plv))
            {
                CopyRect(&rcBounds, &rcIcon);
            }
            else
            {
                rcLabel.left   = ptItem.x  + (plv->cxIcon / 2) - (ICONCXLABEL(plv, pitem) / 2);
                rcLabel.right  = rcLabel.left + ICONCXLABEL(plv, pitem);
            }


            if (plv->cxState && PtInRect(&rcState, pt))
            {
                flags = LVHT_ONITEMSTATEICON;
            }
            else if (PtInRect(&rcIcon, pt))
            {
                flags = LVHT_ONITEMICON;

                if (pt.x < rcIcon.left + RECTWIDTH(rcIcon)/10)
                    flags |= LVHT_ONLEFTSIDEOFICON;
                else if (pt.x >= rcIcon.right - RECTWIDTH(rcIcon)/10)
                    flags |= LVHT_ONRIGHTSIDEOFICON;
            }
            else if (PtInRect(&rcLabel, pt))
            {
                flags = LVHT_ONITEMLABEL;
            }
            else if (ListView_IsBorderSelect(plv) &&
                (pitem->state & LVIS_SELECTED) &&
                PtInRect(&rcBounds, pt))
            {
                flags = LVHT_ONITEMICON;

                if (pt.x < rcBounds.left + RECTWIDTH(rcBounds)/10)
                    flags |= LVHT_ONLEFTSIDEOFICON;
                else if (pt.x >= rcBounds.right - RECTWIDTH(rcBounds)/10)
                    flags |= LVHT_ONRIGHTSIDEOFICON;
            }

            if (flags)
                break;
        }
    }

    if (flags == 0)
    {
        flags = LVHT_NOWHERE;
        iHit = -1;
    }
    else
    {
        if (!ListView_IsOwnerData( plv ))
        {
            iHit = DPA_GetPtrIndex(plv->hdpa, ListView_FastGetZItemPtr(plv, iHit));
        }
    }
 
    *pflags = flags;
    return iHit;
}

// REARCHITECT raymondc
// need to pass HDC here isnce it's sometimes called from the paint loop
// This returns rects in Window Coordinates
void ListView_IGetRectsOwnerData( LV* plv,
        int iItem,
        RECT* prcIcon,
        RECT* prcLabel,
        LISTITEM* pitem,
        BOOL fUsepitem )
{
   int itemIconXLabel;
   int cxIconMargin;
   int cSlots;

   // calculate x, y from iItem
   cSlots = ListView_GetSlotCount( plv, TRUE, NULL, NULL );
   pitem->iWorkArea = 0;               // OwnerData doesn't support workareas
   ListView_SetIconPos( plv, pitem, iItem, cSlots );

   // calculate lable sizes from iItem
   ListView_IRecomputeLabelSize( plv, pitem, iItem, NULL, fUsepitem);

   if (plv->ci.style & LVS_NOLABELWRAP)
   {
      // use single label
      itemIconXLabel = pitem->cxSingleLabel;
   }
   else
   {
      // use multilabel
      itemIconXLabel = pitem->cxMultiLabel;
   }

    cxIconMargin = ListView_GetIconBufferX(plv);

    prcIcon->left   = pitem->pt.x - cxIconMargin - plv->ptOrigin.x;
    prcIcon->right  = prcIcon->left + plv->cxIcon + 2 * cxIconMargin;
    prcIcon->top    = pitem->pt.y - g_cyIconMargin - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->cyIcon + 2 * g_cyIconMargin;

    prcLabel->left   = pitem->pt.x  + (plv->cxIcon / 2) - (itemIconXLabel / 2) - plv->ptOrigin.x;
    prcLabel->right  = prcLabel->left + itemIconXLabel;
    prcLabel->top    = pitem->pt.y  + plv->cyIcon + g_cyLabelSpace - plv->ptOrigin.y;
    prcLabel->bottom = prcLabel->top  + pitem->cyUnfoldedLabel;


    if ( !ListView_IsItemUnfolded(plv, iItem) )
        ListView_RefoldLabelRect(plv, prcLabel, pitem);
}


// out:
//      prcIcon         icon bounds including icon margin area
// This returns rects in Window Coordinates
void ListView_IGetRects(LV* plv, LISTITEM* pitem, UINT fQueryLabelRects, RECT* prcIcon, RECT* prcLabel, LPRECT prcBounds)
{
    int cxIconMargin;

    ASSERT( !ListView_IsOwnerData( plv ) );

    if (pitem->pt.x == RECOMPUTE) 
    {
        ListView_Recompute(plv);
    }

    if (pitem->pt.x == RECOMPUTE)
    {
        RECT rcZero = {0};
        *prcIcon = *prcLabel = rcZero;
        return;
    }

    cxIconMargin = ListView_GetIconBufferX(plv);

    prcIcon->left   = pitem->pt.x - cxIconMargin - plv->ptOrigin.x;
    prcIcon->right  = prcIcon->left + plv->cxIcon + 2 * cxIconMargin;
    prcIcon->top    = pitem->pt.y - g_cyIconMargin - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->cyIcon + 2 * g_cyIconMargin;

    prcLabel->left   = pitem->pt.x  + (plv->cxIcon / 2) - (ICONCXLABEL(plv, pitem) / 2) - plv->ptOrigin.x;
    prcLabel->right  = prcLabel->left + ICONCXLABEL(plv, pitem);
    prcLabel->top    = pitem->pt.y  + plv->cyIcon + g_cyLabelSpace - plv->ptOrigin.y;
    prcLabel->bottom = prcLabel->top  + pitem->cyUnfoldedLabel;

    if (IsQueryFolded(fQueryLabelRects) ||
        (!ListView_IsItemUnfoldedPtr(plv, pitem) && !IsQueryUnfolded(fQueryLabelRects)))
    {
        ListView_RefoldLabelRect(plv, prcLabel, pitem);
    }
}

// fWithoutScrollbars==FALSE means that we assume more items are on the screen than will fit, so we'll have a scrollbar.
int ListView_GetSlotCountEx(LV* plv, BOOL fWithoutScrollbars, int iWorkArea, int *piWidth, int *piHeight)
{
    int cxScreen;
    int cyScreen;
    int dxItem;
    int dyItem;
    int iSlots;
    int iSlotsX;
    int iSlotsY;

    // film strip mode
    if (ListView_SingleRow(plv))
    {
        if(piWidth)
            *piWidth = plv->sizeClient.cx;
        if(piHeight)
            *piHeight = plv->sizeClient.cy;
            
        return MAXINT;
    }

    // Always assume we have a scrollbar when in group view,
    // since our iTotalSlots calculation at the bottom will be wrong in this mode...
    if (plv->fGroupView)
        fWithoutScrollbars = FALSE;

    // Always use the current client window size to determine
    //
    if ((iWorkArea >= 0 ) && (plv->nWorkAreas > 0))
    {
        ASSERT(iWorkArea < plv->nWorkAreas);
        cxScreen = RECTWIDTH(plv->prcWorkAreas[iWorkArea]);
        cyScreen = RECTHEIGHT(plv->prcWorkAreas[iWorkArea]);
    }
    else
    {
        if (plv->fGroupView)
        {
            cxScreen = plv->sizeClient.cx - plv->rcBorder.left - plv->rcBorder.right - plv->paddingRight - plv->paddingLeft;
            cyScreen = plv->sizeClient.cy - plv->rcBorder.bottom - plv->rcBorder.top - plv->paddingBottom - plv->paddingTop;
        }
        else
        {
            RECT rcClientNoScrollBars;
            ListView_GetClientRect(plv, &rcClientNoScrollBars, FALSE, NULL);
            cxScreen = RECTWIDTH(rcClientNoScrollBars);
            cyScreen = RECTHEIGHT(rcClientNoScrollBars);

            if (ListView_IsIScrollView(plv) && !(plv->ci.style & LVS_NOSCROLL))
            {
                cxScreen = cxScreen - plv->rcViewMargin.left - plv->rcViewMargin.right;
                cyScreen = cyScreen - plv->rcViewMargin.top - plv->rcViewMargin.bottom;
            }
        }

        if (cxScreen < 0)
            cxScreen = 0;
        if (cyScreen < 0)
            cyScreen = 0;
    }

    // If we're assuming the scrollbars are there, shrink width/height as appropriate
    if (!fWithoutScrollbars && !(plv->ci.style & LVS_NOSCROLL))
    {
        switch (plv->ci.style & LVS_ALIGNMASK)
        {
        case LVS_ALIGNBOTTOM:
        case LVS_ALIGNTOP:
            cxScreen -= ListView_GetCxScrollbar(plv);
            break;

        case LVS_ALIGNRIGHT:
        default:
        case LVS_ALIGNLEFT:
            cyScreen -= ListView_GetCyScrollbar(plv);
            break;
        }
    }

    _GetCurrentItemSize(plv, &dxItem, &dyItem);

    if (!dxItem)
        dxItem = 1;
    if (!dyItem)
        dyItem = 1;

    iSlotsX = max(1, (cxScreen) / dxItem);
    iSlotsY = max(1, (cyScreen) / dyItem);

    // Lets see which direction the view states
    switch (plv->ci.style & LVS_ALIGNMASK)
    {
    case LVS_ALIGNBOTTOM:
        //The number of slots are the same as ALIGNTOP;
        //So, intentional fall through...
    case LVS_ALIGNTOP:
        iSlots = iSlotsX;
        break;

    case LVS_ALIGNRIGHT:
        // The number of slots are the same as ALIGNLEFT; 
        // So, intentional fall through...
    default:
    case LVS_ALIGNLEFT:
        iSlots = iSlotsY;
        break;
    }

    if(piWidth)
        *piWidth = cxScreen;
    if(piHeight)
        *piHeight = cyScreen;
        
    // if we don't have enough slots total on the screen, we're going to have
    // a scrollbar, so recompute with the scrollbars on
    if (fWithoutScrollbars) 
    {
        int iTotalSlots = (iSlotsX * iSlotsY);
        if (iTotalSlots < ListView_Count(plv)) 
        {
            iSlots = ListView_GetSlotCountEx(plv, FALSE, iWorkArea, piWidth, piHeight);
        }
    }

    return iSlots;
}

int ListView_GetSlotCount(LV* plv, BOOL fWithoutScrollbars, int *piWidth, int *piHeight)
{
    // Make sure this function does exactly the same thing as when
    // we had no workareas
    return ListView_GetSlotCountEx(plv, fWithoutScrollbars, -1, piWidth, piHeight);
}

// get the pixel row (or col in left align) of pitem
int LV_GetItemPixelRow(LV* plv, LISTITEM* pitem)
{
    DWORD dwAlignment = plv->ci.style & LVS_ALIGNMASK;

    if((dwAlignment == LVS_ALIGNLEFT) || (dwAlignment == LVS_ALIGNRIGHT))
        return pitem->pt.x;
    else
        return pitem->pt.y;
}

// get the pixel row (or col in left align) of the lowest item
int LV_GetMaxPlacedItem(LV* plv)
{
    int i;
    int iMaxPlacedItem = 0;
    
    for (i = 0; i < ListView_Count(plv); i++) 
    {
        LISTITEM* pitem = ListView_FastGetItemPtr(plv, i);
        if (pitem->pt.y != RECOMPUTE) 
        {
            int iRow = LV_GetItemPixelRow(plv, pitem);
            // if the current item is "below" (on right if it's left aligned)
            // the lowest placed item, we can start appending
            if (!i || iRow > iMaxPlacedItem)
                iMaxPlacedItem = iRow;
        }
    }
    
    return iMaxPlacedItem;;
}

// Get the buffer around an item for rcView calculations and slot offsets
int ListView_GetIconBufferX(LV* plv)
{
    if (ListView_IsIconView(plv))
    {
        return (plv->cxIconSpacing - plv->cxIcon) / 2;
    }
    else if (ListView_IsTileView(plv))
        return g_cxLabelMargin;
    else
        return 0;
}

int ListView_GetIconBufferY(LV* plv)
{
    if (ListView_IsIconView(plv))
        return g_cyIconOffset;
    else if (ListView_IsTileView(plv))
        return g_cyIconMargin;
    else
        return 0;
}


void ListView_AddViewRectBuffer(LV* plv, RECT* prcView)
{
    if (ListView_IsIconView(plv))
    {
        // we now grow the label size a bit, so we already have the g_cxEdge added/removed
    }
    else
    {
        prcView->right += g_cxEdge;
        prcView->bottom += g_cyEdge;
    }
}

// Calculate rcView, returned in Listview Coordinates
// Returns FALSE if rcView is not calculatable and fNoRecalc is specified
BOOL ListView_ICalcViewRect(LV* plv, BOOL fNoRecalc, RECT* prcView)
{
    int i;

    ASSERT(ListView_IsIScrollView(plv) && !ListView_IsOwnerData(plv) && !(plv->fGroupView && plv->hdpaGroups));

    SetRectEmpty(prcView);

    for (i = 0; i < ListView_Count(plv); i++)
    {
        RECT rcIcon;
        RECT rcLabel;
        RECT rcItem;

        if (fNoRecalc)
        {
            LISTITEM *pitem = ListView_FastGetItemPtr(plv, i);
            if (pitem->pt.x == RECOMPUTE)
            {
                return FALSE;
            }
        }

        ListView_GetRects(plv, i, QUERY_RCVIEW|QUERY_UNFOLDED, &rcIcon, &rcLabel, &rcItem, NULL);
        UnionRect(prcView, prcView, &rcItem);
    }

    if (!IsRectEmpty(prcView))
    {
        // Convert to listview coordinates
        OffsetRect(prcView, plv->ptOrigin.x, plv->ptOrigin.y);

        // Grow it a bit
        ListView_AddViewRectBuffer(plv, prcView);
    }

    return TRUE;
}

BOOL ListView_FixIScrollPositions(LV* plv, BOOL fNoScrollbarUpdate, RECT* prcClient)
{
    BOOL fRet = FALSE;

    // it's possible for the below ListView_GetClientRect() to force a recalc of rcView
    // which can come back to this function.  Nothing bad happens, but there's no
    // need to do fix the scroll positions until we unwind.
    if (!plv->fInFixIScrollPositions)
    {
        plv->fInFixIScrollPositions = TRUE;

        //   First, where rcClient is smaller than rcView:
        //      * rcView.left <= ptOrigin.x <= ptOrigin.x+rcClient.right <= rcView.right
        //   Second, where rcClient is larger than rcView (no scrollbars visible):
        //      * ptOrigin.x <= rcView.left <= rcView.right <= ptOrigin.x+rcClient.right
        if (!(plv->ci.style & LVS_NOSCROLL))
        {
            POINT pt = plv->ptOrigin;
            RECT rcClient;
            if (prcClient)
                rcClient = *prcClient; // can be passed in to avoid calling the below function a second time
            else
                ListView_GetClientRect(plv, &rcClient, TRUE, FALSE);

            ASSERT(plv->rcView.left != RECOMPUTE);

            if (RECTWIDTH(rcClient) < RECTWIDTH(plv->rcView))
            {
                if (plv->ptOrigin.x < plv->rcView.left)
                    plv->ptOrigin.x = plv->rcView.left;
                else if (plv->ptOrigin.x > plv->rcView.right - RECTWIDTH(rcClient))
                    plv->ptOrigin.x = plv->rcView.right - RECTWIDTH(rcClient);
            }
            else
            {
                if (plv->rcView.left < plv->ptOrigin.x)
                    plv->ptOrigin.x = plv->rcView.left;
                else if (plv->rcView.right - RECTWIDTH(rcClient) > plv->ptOrigin.x)
                    plv->ptOrigin.x = plv->rcView.right - RECTWIDTH(rcClient);
            }
            if (RECTHEIGHT(rcClient) < RECTHEIGHT(plv->rcView))
            {
                if (plv->ptOrigin.y < plv->rcView.top)
                    plv->ptOrigin.y = plv->rcView.top;
                else if (plv->ptOrigin.y > plv->rcView.bottom - RECTHEIGHT(rcClient))
                    plv->ptOrigin.y = plv->rcView.bottom - RECTHEIGHT(rcClient);
            }
            else
            {
                if (plv->rcView.top < plv->ptOrigin.y)
                    plv->ptOrigin.y = plv->rcView.top;
                else if (plv->rcView.bottom - RECTHEIGHT(rcClient) > plv->ptOrigin.y)
                    plv->ptOrigin.y = plv->rcView.bottom - RECTHEIGHT(rcClient);
            }

            fRet = (pt.x != plv->ptOrigin.x) || (pt.y != plv->ptOrigin.y);
        }

        plv->fInFixIScrollPositions = FALSE;

        if (fRet)
        {
            // Something moved, we need to invalidate
            ListView_InvalidateWindow(plv);
            if (!fNoScrollbarUpdate)
                ListView_UpdateScrollBars(plv);
        }
    }

    return fRet;
}


// Go through and recompute any icon positions and optionally
// icon label dimensions.
//
// This function also recomputes the view bounds rectangle.
//
// The algorithm is to simply search the list for any items needing
// recomputation.  For icon positions, we scan possible icon slots
// and check to see if any already-positioned icon intersects the slot.
// If not, the slot is free.  As an optimization, we start scanning
// icon slots from the previous slot we found.
//
BOOL ListView_IRecomputeEx(LV* plv, HDPA hdpaSort, int iFrom, BOOL fForce)
{
    int i;
    int cGroups = 0;
    int cWorkAreaSlots[LV_MAX_WORKAREAS];
    BOOL fUpdateSB;
    // if all the items are unplaced, we can just keep appending
    BOOL fAppendAtEnd = (((UINT)ListView_Count(plv)) == plv->uUnplaced);
    int iFree;
    int iWidestGroup = 0;
    BOOL fRet = FALSE;

    if (hdpaSort == NULL)
        hdpaSort = plv->hdpa;

    plv->uUnplaced = 0;

    if (!ListView_IsSlotView(plv))
        return FALSE;

    if (plv->flags & LVF_INRECOMPUTE)
    {
        return FALSE;
    }
    plv->flags |= LVF_INRECOMPUTE;

    plv->cSlots = ListView_GetSlotCount(plv, FALSE, NULL, NULL);

    if (plv->nWorkAreas > 0)
        for (i = 0; i < plv->nWorkAreas; i++)
            cWorkAreaSlots[i] = ListView_GetSlotCountEx(plv, FALSE, i, NULL, NULL);

    // Scan all items for RECOMPUTE, and recompute slot if needed.
    //
    fUpdateSB = (plv->rcView.left == RECOMPUTE);

    if (!ListView_IsOwnerData( plv ))
    {
        LVFAKEDRAW lvfd;                    // in case client uses customdraw
        LV_ITEM item;                       // in case client uses customdraw
        int iMaxPlacedItem = RECOMPUTE;

        item.mask = LVIF_PARAM;
        item.iSubItem = 0;

        ListView_BeginFakeCustomDraw(plv, &lvfd, &item);

        if (!fAppendAtEnd)
            iMaxPlacedItem = LV_GetMaxPlacedItem(plv);

        if (plv->fGroupView && plv->hdpaGroups)
        {
            int iAccumulatedHeight = 0;
            int cItems = ListView_Count(plv);
            int iGroupItem;
            LISTITEM* pitem;


            for (iGroupItem = 0; iGroupItem < cItems; iGroupItem++)
            {
                pitem = ListView_FastGetItemPtr(plv, iGroupItem);
                if (!pitem)
                    break;
                if (pitem->cyFoldedLabel == SRECOMPUTE || fForce)
                {
                    // Get the item lParam only if we need it for customdraw
                    item.iItem = iGroupItem;
                    item.lParam = pitem->lParam;

                    if (!LISTITEM_HASASKEDFORGROUP(pitem))
                    {
                        item.mask = LVIF_GROUPID;
                        ListView_OnGetItem(plv, &item);
                    }

                    _ListView_RecomputeLabelSize(plv, pitem, iGroupItem, NULL, FALSE);
                }
            }

            if (iFrom > 0)
            {
                LISTGROUP* pgrpPrev = DPA_FastGetPtr(plv->hdpaGroups, iFrom - 1);
                iAccumulatedHeight = pgrpPrev->rc.bottom + plv->paddingBottom;
            }

            cGroups = DPA_GetPtrCount(plv->hdpaGroups);
            for (i = iFrom; i < cGroups; i++)
            {
                LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, i);
                if (!pgrp)  // Huh?
                    break;

                cItems = DPA_GetPtrCount(pgrp->hdpa);

                if (cItems == 0)
                {
                    SetRect(&pgrp->rc, 0,  0,  0, 0);
                }
                else
                {
                    RECT rcBoundsPrev = {0};
                    iFree = 0;

                    if (pgrp->pszHeader && (pgrp->cyTitle == 0 || fForce))
                    {
                        RECT rc = {0, 0, 1000, 0};
                        HDC hdc = GetDC(plv->ci.hwnd);
                        HFONT hfontOld = SelectObject(hdc, plv->hfontGroup);

                        DrawText(hdc, pgrp->pszHeader, -1, &rc, DT_LV | DT_CALCRECT);

                        SelectObject(hdc, hfontOld);
                        ReleaseDC(plv->ci.hwnd, hdc);

                        pgrp->cyTitle = RECTHEIGHT(rc);
                    }

                    iAccumulatedHeight += LISTGROUP_HEIGHT(plv, pgrp);

                    SetRect(&pgrp->rc, plv->rcBorder.left + plv->paddingLeft,  iAccumulatedHeight,  
                        plv->sizeClient.cx - plv->rcBorder.right - plv->paddingRight, 0);

                    for (iGroupItem = 0; iGroupItem < cItems; iGroupItem++)
                    {
                        pitem = DPA_FastGetPtr(pgrp->hdpa, iGroupItem);
                        if (!pitem)
                            break;

                        if (iGroupItem > 0)
                        {
                            RECT rcBounds;
                            ListView_SetIconPos(plv, pitem, iFree, plv->cSlots);
                           _ListView_GetRectsFromItem(plv, ListView_IsSmallView(plv), pitem, QUERY_DEFAULT,
                               NULL, NULL, &rcBounds, NULL);

                           if (IntersectRect(&rcBounds, &rcBounds, &rcBoundsPrev))
                               iFree++;
                        }

                        if (ListView_SetIconPos(plv, pitem, iFree, plv->cSlots))
                            fRet = TRUE;

                        if (!fUpdateSB && LV_IsItemOnViewEdge(plv, pitem))
                            fUpdateSB = TRUE;
                    
                        if (iFree == 0)
                        {
                            int cx, cy;
                            _GetCurrentItemSize(plv, &cx, &cy);
                            iAccumulatedHeight += cy;
                            iWidestGroup = max(iWidestGroup, cx);
                        }
                        else if (iFree % plv->cSlots == 0)
                        {
                            int cx, cy;
                            _GetCurrentItemSize(plv, &cx, &cy);
                            iAccumulatedHeight += cy;
                            iWidestGroup = max(iWidestGroup, plv->cSlots * cx);
                        }

                       _ListView_GetRectsFromItem(plv, ListView_IsSmallView(plv), pitem, QUERY_DEFAULT,
                           NULL, NULL, &rcBoundsPrev, NULL);
                        iFree++;
                    }

                    pgrp->rc.bottom = iAccumulatedHeight;
                    iAccumulatedHeight += plv->rcBorder.bottom + plv->paddingBottom;
                }
            }

            // Now iterate through the items and Reset the position of items that aren't associated with a group
            for (i = 0; i < ListView_Count(plv); i++)
            {
                LISTITEM* pitem = ListView_FastGetItemPtr(plv, i);

                if (pitem->pGroup == NULL)
                {
                    pitem->pt.x = 0;
                    pitem->pt.y = 0;
                }
            }

        }
        else
        {
            // Must keep in local variable because ListView_SetIconPos will keep
            // invalidating the iFreeSlot cache while we're looping
            if (fForce)
                plv->iFreeSlot = -1;
            iFree = plv->iFreeSlot;
            for (i = 0; i < ListView_Count(plv); i++)
            {
                int cRealSlots;
                LISTITEM* pitem = ListView_FastGetItemPtr(plv, i);
                BOOL fRedraw = FALSE;

                cRealSlots = (plv->nWorkAreas > 0) ? cWorkAreaSlots[pitem->iWorkArea] : plv->cSlots;
                if (pitem->pt.y == RECOMPUTE || fForce)
                {
                    if (pitem->cyFoldedLabel == SRECOMPUTE || fForce)
                    {
                        // Get the item lParam only if we need it for customdraw
                        item.iItem = i;
                        item.lParam = pitem->lParam;

                        _ListView_RecomputeLabelSize(plv, pitem, i, NULL, FALSE);
                    }

                    if (i < ListView_Count(plv))    // Recompute could have nuked some items.
                    {
                        if (!fForce)
                        {
                            // (dli) This function gets a new icon postion and then goes 
                            // through the whole set of items to see if that position is occupied
                            // should let it know in the multi-workarea case, it only needs to go
                            // through those who are in the same workarea.
                            // This is okay for now because we cannot have too many items on the
                            // desktop. 
                            if (lvfd.nmcd.nmcd.hdc)
                            {
                                int iWidth = 0, iHeight = 0;
                                DWORD dwAlignment = (plv->ci.style & LVS_ALIGNMASK);

                                // If we are right or bottom aligned, then..
                                // ....we want to get the width and height to be passed to FindFreeSlot.
                                if ((dwAlignment == LVS_ALIGNRIGHT) || (dwAlignment == LVS_ALIGNBOTTOM))
                                    ListView_GetSlotCountEx(plv, FALSE, pitem->iWorkArea, &iWidth, &iHeight);

                                iFree = ListView_FindFreeSlot(plv, i, iFree + 1, cRealSlots, QUERY_FOLDED, &fUpdateSB, &fAppendAtEnd, lvfd.nmcd.nmcd.hdc, iWidth, iHeight);
                            }
                            ASSERT(iFree != -1);
                        }
                        else
                        {
                            iFree++;
                        }

                        // If this slot is frozen, then move this item to the next slot!
                        if ((plv->iFrozenSlot != -1) && (plv->iFrozenSlot == iFree))
                        {
                            iFree++;  // Skip the frozen slot!
                        }

                        if (ListView_SetIconPos(plv, pitem, iFree, cRealSlots))
                            fRet = TRUE;

                        if (!fAppendAtEnd)
                        {
                            //// optimization.  each time we calc a new free slot, we iterate through all the items to see
                            // if any of the freely placed items collide with this.
                            // fAppendAtEnd indicates that iFree is beyond any freely placed item
                            // 
                            // if the current item is "below" (on right if it's left aligned)
                            // the lowest placed item, we can start appending
                            if (LV_GetItemPixelRow(plv, pitem) > iMaxPlacedItem)
                                fAppendAtEnd = TRUE;
                        }
                
                        if (!fUpdateSB && LV_IsItemOnViewEdge(plv, pitem))
                            fUpdateSB = TRUE;

                        fRedraw = TRUE;
                    }
                }

                if (fRedraw)
                {
                    ListView_InvalidateItem(plv, i, FALSE, RDW_INVALIDATE | RDW_ERASE);
                }

                // If the item that we just positioned is marked a frozen item...
                if ((pitem == plv->pFrozenItem) && (iFree >= 0))
                {
                    //... then we need to ignore that in free slot calculations.
                    iFree--;
                }
            }
            plv->iFreeSlot = iFree;
        }
        ListView_EndFakeCustomDraw(&lvfd);

    }
    // If we changed something, recompute the view rectangle
    // and then update the scroll bars.
    //
    if (fUpdateSB || plv->rcView.left == RECOMPUTE || fForce)
    {
        // NOTE: No infinite recursion results because we're setting
        // plv->rcView.left != RECOMPUTE
        //
        SetRectEmpty(&plv->rcView);

        if (plv->fGroupView && plv->hdpaGroups && !ListView_IsOwnerData( plv ))
        {
            LISTGROUP* pgrp;
            int iGroup;
            // Find the first group with an item in it...
            for (iGroup = 0; iGroup < cGroups; iGroup++)
            {
                pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
                if (DPA_GetPtrCount(pgrp->hdpa) > 0)
                {
                    plv->rcView.top = pgrp->rc.top - max(plv->rcBorder.top, pgrp->cyTitle + 6) - plv->paddingTop;
                    plv->rcView.left = pgrp->rc.left - plv->rcBorder.left - plv->paddingLeft;
                    break;
                }
            }
            // ...and the last group with an item in it
            for (iGroup = cGroups - 1; iGroup >= 0; iGroup--)
            {
                pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
                if (DPA_GetPtrCount(pgrp->hdpa))
                {
                    plv->rcView.bottom = pgrp->rc.bottom + plv->rcBorder.bottom + plv->paddingBottom;
                    break;
                }
            }
            plv->rcView.right = iWidestGroup;
        }
        else
        {
            if (ListView_IsOwnerData( plv ))
            {
                TraceMsg(TF_GENERAL, "************ LV: Expensive update! ******* ");
                if (ListView_Count( plv ) > 0)
                {
                    RECT  rcLast;
                    RECT  rcItem;
                    int iSlots;
                    int   iItem = ListView_Count( plv ) - 1;

                    ListView_GetRects( plv, 0, QUERY_DEFAULT, NULL, NULL, &plv->rcView, NULL );
                    ListView_GetRects( plv, iItem, QUERY_DEFAULT, NULL, NULL, &rcLast, NULL );
                    plv->rcView.right = rcLast.right;
                    plv->rcView.bottom = rcLast.bottom;

                    //
                    // calc how far back in the list to check
                    //
                    iSlots = plv->cSlots + 2;

                    // REVIEW:  This cache hint notification causes a spurious
                    //  hint, since this happens often but is always the last items
                    //  available.  Should this hint be done at all and this information
                    //  be cached local to the control?
                    ListView_NotifyCacheHint( plv, max( 0, iItem - iSlots), iItem );

                    // move backwards from last item until either rc.right or
                    // rc.left is greater than the last, then use that value.
                    // Note: This code makes very little assumptions about the ordering
                    // done.  We should be careful as multiple line text fields could
                    // mess us up.
                    for( iItem--;
                       (iSlots > 0) && (iItem >= 0);
                        iSlots--, iItem--)
                    {
                        RECT rcIcon;
                        RECT rcLabel;

                        ListView_GetRects( plv, iItem, QUERY_RCVIEW|QUERY_UNFOLDED, &rcIcon, &rcLabel, &rcItem, NULL );
                        if (rcItem.right > rcLast.right)
                        {
                            plv->rcView.right =  rcItem.right;
                        }
                        if (rcItem.bottom > rcLast.bottom)
                        {
                            plv->rcView.bottom = rcItem.bottom;
                        }
                    }

                    // The above calculations were done in Window coordinates, convert to Listview coordinates
                    OffsetRect(&plv->rcView, plv->ptOrigin.x, plv->ptOrigin.y);
                }
            }
            else
            {
                ListView_ICalcViewRect(plv, FALSE, &plv->rcView);
            }
        }

        //TraceMsg(DM_TRACE, "RECOMPUTE: rcView %x %x %x %x", plv->rcView.left, plv->rcView.top, plv->rcView.right, plv->rcView.bottom);
        //TraceMsg(DM_TRACE, "Origin %x %x", plv->ptOrigin.x, plv->ptOrigin.y);

        ListView_UpdateScrollBars(plv);
    }
    
    ListView_RecalcRegion(plv, FALSE, TRUE);
    // Now state we are out of the recompute...
    plv->flags &= ~LVF_INRECOMPUTE;

    ASSERT(ListView_ValidatercView(plv, &plv->rcView, TRUE));
    ASSERT(ListView_ValidateScrollPositions(plv, NULL));

    return fRet;
}

//This function finds out the nearest work area where the given item must fall.
int  NearestWorkArea(LV *plv, int x, int y, int cxItem, int cyItem, int iCurrentWorkArea)
{
    int iIndex = 0;
    POINT ptItemCenter = {x + (cxItem/2), y + (cyItem/2)}; //Get the center of the item.
    
    if(plv->nWorkAreas <= 0)    //If this is a single monitor system...
        return -1;              //... then return -1 to indicate that.

    if(plv->nWorkAreas == 1)
        return 0;               //There is only one workarea; so, return it's index.

    //Find the work-area where the center of the icon falls.
    iIndex = iCurrentWorkArea; // This point is most likely to be in the current work area.

    do                           // So, start with that work area.
    {
        if(PtInRect(&plv->prcWorkAreas[iIndex], ptItemCenter))
            return iIndex;
            
        if(++iIndex == plv->nWorkAreas) //If we have reached the end,...
            iIndex = 0;                 // ...start from the begining.
            
         // If we have completed looking at all workareas...
         // ....quit the loop!
    } while (iIndex != iCurrentWorkArea);

    return iCurrentWorkArea; //If it does not fall into any of the work areas, then use the current one.
}

// This function modifies *px, *py to to be in slot-like position -- it doesn't actually gurantee it's in a real slot
// (NOTE: I tried to assert that this way of calculating slots matched with ListView_CalcSlotRect, but the latter
// function guarantee's it's in a real slot and this can not.  That assert flushed out real bugs in callers of listview,
// but it unfortunately hits valid cases as well.)
void NearestSlot(LV *plv, LISTITEM* pitem, int *px, int *py, int cxItem, int cyItem, LPRECT prcWork)
{
    DWORD dwAlignment = plv->ci.style & LVS_ALIGNMASK;
    int iWidth = 0;
    int iHeight = 0;
    int x = *px;
    int y = *py;
    
    if (prcWork != NULL)
    {
        x = x - prcWork->left;
        y = y - prcWork->top;
    }

    //Get the x with respect to the top right corner.
    if (dwAlignment == LVS_ALIGNRIGHT)
    {
        x = (iWidth = (prcWork? RECTWIDTH(*prcWork) : plv->sizeClient.cx)) - x - cxItem;
    }
    else if (dwAlignment == LVS_ALIGNBOTTOM) //Get y with respect to the bottom left corner.
    {
        y = (iHeight = (prcWork? RECTHEIGHT(*prcWork) : plv->sizeClient.cy)) - y - cyItem;
    }

#if 0
    // The above iWidth/iHeight calculations are incorrect in some cases, but I don't think that matters...
    // We might want to consider replacing the above code with ListView_GetSlotCountEx...
    if (TRUE)
    {
        int iWidth2, iHeight2;
        ListView_GetSlotCountEx(plv, TRUE, prcWork ? pitem->iWorkArea : -1,  &iWidth2, &iHeight2);
        if (dwAlignment == LVS_ALIGNRIGHT)
        {
            ASSERT(iWidth == iWidth2);
        }
        else if (dwAlignment == LVS_ALIGNBOTTOM)
        {
            ASSERT(iHeight == iHeight2);
        }
    }
#endif

    // Calculate the center point
    if (x < 0)
        x -= cxItem/2;
    else
        x += cxItem/2;

    if (y < 0)
        y -= cyItem/2;
    else
        y += cyItem/2;

    // Find the new x,y point
    x = x - (x % cxItem);
    y = y - (y % cyItem);

    // Get x and y with respect to the top left corner again.
    if (dwAlignment == LVS_ALIGNRIGHT)
        x = iWidth - x - cxItem;
    else if (dwAlignment == LVS_ALIGNBOTTOM)
        y = iHeight - y - cyItem;
            
    if (prcWork != NULL)
    {
        x = x + prcWork->left;
        y = y + prcWork->top;
    }

    *px = x;
    *py = y;
}


//-------------------------------------------------------------------
//
//-------------------------------------------------------------------

void ListView_CalcMinMaxIndex( LV* plv, PRECT prcBounding, int* iMin, int* iMax )
{
   POINT pt;
   int cSlots;
   int  iWidth = 0, iHeight = 0;

   cSlots = ListView_GetSlotCount( plv, TRUE, &iWidth, &iHeight );

   pt.x = prcBounding->left + plv->ptOrigin.x;
   pt.y = prcBounding->top + plv->ptOrigin.y;
   *iMin = ListView_CalcHitSlot( plv, pt, cSlots, iWidth, iHeight );

   pt.x = prcBounding->right + plv->ptOrigin.x;
   pt.y = prcBounding->bottom + plv->ptOrigin.y;
   *iMax = ListView_CalcHitSlot( plv, pt, cSlots, iWidth, iHeight ) + 1;
}
//-------------------------------------------------------------------
//
// Function: ListView_CalcHitSlot
//
// Summary: Given a point (relative to complete icon view), calculate
//    which slot that point is closest to.
//
// Arguments:
//    plv [in] - List view to work with
//    pt [in]  - location to check with
//    cslot [in]  - number of slots wide the current view is
//
// Notes: This does not guarentee that the point is hitting the item
//    located at that slot.  That should be checked by comparing rects.
//
// History:
//    Nov-1-1994  MikeMi   Added to improve Ownerdata hit testing
//    July-11-2000 Sankar  Added iWidth and iHeight parameters to support Right alignment.
//
//-------------------------------------------------------------------

int ListView_CalcHitSlot( LV* plv, POINT pt, int cSlot, int iWidth, int iHeight)
{
    int cxItem;
    int cyItem;
    int iSlot = 0;

    ASSERT(plv);

    if (cSlot < 1)
        cSlot = 1;

    _GetCurrentItemSize(plv, &cxItem, &cyItem);

    // Lets see which direction the view states
    switch (plv->ci.style & LVS_ALIGNMASK)
    {
    case LVS_ALIGNBOTTOM:
      iSlot = min (pt.x / cxItem, cSlot - 1) + ((iHeight - pt.y) / cyItem) * cSlot;
      break;

    case LVS_ALIGNTOP:
      iSlot = min (pt.x / cxItem, cSlot - 1) + (pt.y / cyItem) * cSlot;
      break;

    case LVS_ALIGNLEFT:
      iSlot = (pt.x / cxItem) * cSlot + min (pt.y / cyItem, cSlot - 1);
      break;

    case LVS_ALIGNRIGHT:
      iSlot = ((iWidth - pt.x) / cxItem) * cSlot + min (pt.y / cyItem, cSlot - 1);
      break;
    }

    return( iSlot );
}

DWORD ListView_IApproximateViewRect(LV* plv, int iCount, int iWidth, int iHeight)
{
    int cxSave = plv->sizeClient.cx;
    int cySave = plv->sizeClient.cy;
    int cxItem;
    int cyItem;
    int cCols;
    int cRows;

    plv->sizeClient.cx = iWidth;
    plv->sizeClient.cy = iHeight;
    cCols = ListView_GetSlotCount(plv, TRUE, NULL, NULL);

    plv->sizeClient.cx = cxSave;
    plv->sizeClient.cy = cySave;

    cCols = min(cCols, iCount);
    if (cCols == 0)
        cCols = 1;
    cRows = (iCount + cCols - 1) / cCols;

    if (plv->ci.style & (LVS_ALIGNLEFT | LVS_ALIGNRIGHT)) {
        int c;

        c = cCols;
        cCols = cRows;
        cRows = c;
    }

    _GetCurrentItemSize(plv, &cxItem, &cyItem);

    iWidth = cCols * cxItem;
    iHeight = cRows * cyItem;

    return MAKELONG(iWidth + g_cxEdge, iHeight + g_cyEdge);
}


// if fBias is specified, slot rect is returned in Window Coordinates 
// otherwise, slot rect is returned in Listview Coordinates
void ListView_CalcSlotRect(LV* plv, LISTITEM *pItem, int iSlot, int cSlot, BOOL fBias, int iWidth, int iHeight, LPRECT lprc)
{
    int cxItem, cyItem;

    ASSERT(plv);

    if (cSlot < 1)
        cSlot = 1;

    _GetCurrentItemSize(plv, &cxItem, &cyItem);

    // Lets see which direction the view states
    switch (plv->ci.style & LVS_ALIGNMASK)
    {
    case LVS_ALIGNBOTTOM:
        lprc->left = (iSlot % cSlot) * cxItem;
        lprc->top = iHeight - ((iSlot / cSlot)+1) * cyItem;
        break;

    case LVS_ALIGNTOP:
        lprc->left = (iSlot % cSlot) * cxItem;
        lprc->top = (iSlot / cSlot) * cyItem;
        break;

    case LVS_ALIGNRIGHT:
        lprc->top = (iSlot % cSlot) * cyItem;
        lprc->left = iWidth - (((iSlot / cSlot)+1) * cxItem);
        break;

    case LVS_ALIGNLEFT:
        lprc->top = (iSlot % cSlot) * cyItem;
        lprc->left = (iSlot / cSlot) * cxItem;
        break;

    }

    if (fBias)
    {
        lprc->left -= plv->ptOrigin.x;
        lprc->top -= plv->ptOrigin.y;
    }
    lprc->bottom = lprc->top + cyItem;
    lprc->right = lprc->left + cxItem;
    
    // Multi-Workarea case offset from the workarea coordinate to the whole
    // listview coordinate. 
    if (plv->nWorkAreas > 0)
    {
        ASSERT(pItem);
        ASSERT(pItem->iWorkArea < plv->nWorkAreas);
        OffsetRect(lprc, plv->prcWorkAreas[pItem->iWorkArea].left, plv->prcWorkAreas[pItem->iWorkArea].top);
    }

    if (plv->fGroupView)
    {
        if (pItem && 
            LISTITEM_HASGROUP(pItem))
        {
            OffsetRect(lprc, pItem->pGroup->rc.left, pItem->pGroup->rc.top);
        }
    }
}

// Intersect this rectangle with all items in this listview except myself,
// this will determine if this rectangle overlays any icons. 
BOOL ListView_IsCleanRect(LV * plv, RECT * prc, int iExcept, UINT fQueryLabelRects, BOOL * pfUpdate, HDC hdc)
{
    int j;
    RECT rc;
    int cItems = ListView_Count(plv);
    for (j = cItems; j-- > 0; )
    {
        if (j == iExcept)
            continue;
        else
        {
            LISTITEM* pitem = ListView_FastGetItemPtr(plv, j);
            if (pitem->pt.y != RECOMPUTE)
            {
                // If the dimensions aren't computed, then do it now.
                //
                if (pitem->cyFoldedLabel == SRECOMPUTE)
                {
                    _ListView_RecomputeLabelSize(plv, pitem, j, hdc, FALSE);
                    
                    // Ensure that the item gets redrawn...
                    //
                    ListView_InvalidateItem(plv, j, FALSE, RDW_INVALIDATE | RDW_ERASE);
                    
                    // Set flag indicating that scroll bars need to be
                    // adjusted.
                    //
                    if (LV_IsItemOnViewEdge(plv, pitem))
                        *pfUpdate = TRUE;
                }
                
                ListView_GetRects(plv, j, fQueryLabelRects, NULL, NULL, &rc, NULL);
                if (IntersectRect(&rc, &rc, prc))
                    return FALSE;
            }
        }
    }
    
    return TRUE;
}       

// Find an icon slot that doesn't intersect an icon.
// Start search for free slot from slot i.
//
int ListView_FindFreeSlot(LV* plv, int iItem, int i, int cSlot, UINT fQueryLabelRects, BOOL* pfUpdate,
        BOOL *pfAppend, HDC hdc, int iWidth, int iHeight)
{
    RECT rcSlot;
    RECT rcItem;
    RECT rc;
    LISTITEM * pItemLooking = ListView_FastGetItemPtr(plv, iItem);

    ASSERT(!ListView_IsOwnerData( plv ));

    // Horrible N-squared algorithm:
    // enumerate each slot and see if any items intersect it.
    //
    // REVIEW: This is really slow with long lists (e.g., 1000)
    //

    //
    // If the Append at end is set, we should be able to simply get the
    // rectangle of the i-1 element and check against it instead of
    // looking at every other item...
    //
    if (*pfAppend)
    {
        int iPrev = iItem - 1;
        
        // Be careful about going off the end of the list. (i is a slot
        // number not an item index).
        if (plv->nWorkAreas > 0)
        {
            while (iPrev >= 0)
            {
                LISTITEM * pPrev = ListView_FastGetItemPtr(plv, iPrev);
                if ((pPrev->iWorkArea == pItemLooking->iWorkArea) && (plv->pFrozenItem != pPrev))
                    break;  
                iPrev--;
            }
        }
        else
        {
            while (iPrev >= 0)
            {
                LISTITEM * pPrev = ListView_FastGetItemPtr(plv, iPrev);
                if (plv->pFrozenItem != pPrev)
                    break;  
                iPrev--;
            }
        }
        
        if (iPrev >= 0)
            ListView_GetRects(plv, iPrev, fQueryLabelRects, NULL, NULL, &rcItem, NULL);
        else
            SetRect(&rcItem, 0, 0, 0, 0);
    }

    for ( ; ; i++)
    {
        // Compute view-relative slot rectangle...
        //
        ListView_CalcSlotRect(plv, pItemLooking, i, cSlot, TRUE, iWidth, iHeight, &rcSlot);

        if (*pfAppend)
        {
            if (!IntersectRect(&rc, &rcItem, &rcSlot)) {
                return i;       // Found a free slot...
            }
        }
        
        if (ListView_IsCleanRect(plv, &rcSlot, iItem, fQueryLabelRects, pfUpdate, hdc))
            break;
    }

    return i;
}

// Recompute an item's label size (cxLabel/cyLabel).  For speed, this function
// is passed a DC to use for text measurement.
//
// If hdc is NULL, then this function will create and initialize a temporary
// DC, then destroy it.  If hdc is non-NULL, then it is assumed to have
// the correct font already selected into it.
//
// fUsepitem means not to use the text of the item.  Instead, use the text
// pointed to by the pitem structure.  This is used in two cases.
//
//  -   Ownerdata, because we don't have a real pitem.
//  -   Regulardata, where we already found the pitem text (as an optimizatin)
//
void ListView_IRecomputeLabelSize(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fUsepitem)
{
    TCHAR szLabel[CCHLABELMAX + 4];
    TCHAR szLabelFolded[ARRAYSIZE(szLabel) + CCHELLIPSES + CCHELLIPSES];
    int cchLabel;
    RECT rcSingle = {0};
    RECT rcFolded = {0};
    RECT rcUnfolded = {0};
    LVFAKEDRAW lvfd;
    LV_ITEM item;

    ASSERT(plv);

    // the following will use the passed in pitem text instead of calling
    // GetItem.  This would be two consecutive calls otherwise, in some cases.
    //
    if (fUsepitem && (pitem->pszText != LPSTR_TEXTCALLBACK))
    {
        Str_GetPtr0(pitem->pszText, szLabel, ARRAYSIZE(szLabel));
        item.lParam = pitem->lParam;
    }
    else
    {
        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = i;
        item.iSubItem = 0;
        item.pszText = szLabel;
        item.cchTextMax = ARRAYSIZE(szLabel);
        item.stateMask = 0;
        szLabel[0] = TEXT('\0');    // In case the OnGetItem fails
        ListView_OnGetItem(plv, &item);

        if (!item.pszText)
        {
            SetRectEmpty(&rcSingle);
            rcFolded = rcSingle;
            rcUnfolded = rcSingle;
            goto Exit;
        }

        if (item.pszText != szLabel)
            lstrcpyn(szLabel, item.pszText, ARRAYSIZE(szLabel));
    }

    cchLabel = lstrlen(szLabel);

    rcUnfolded.left = rcUnfolded.top = rcUnfolded.bottom = 0;
    rcUnfolded.right = plv->cxIconSpacing - g_cxLabelMargin * 2;
    rcSingle = rcUnfolded;
    rcFolded = rcUnfolded;

    if (cchLabel > 0)
    {
        UINT flags;

        lvfd.nmcd.nmcd.hdc = NULL;

        if (!hdc) 
        {                             // Set up fake customdraw
            ListView_BeginFakeCustomDraw(plv, &lvfd, &item);
            ListView_BeginFakeItemDraw(&lvfd);
        } 
        else
        {
            lvfd.nmcd.nmcd.hdc = hdc;           // Use the one the app gave us
        }

        if (lvfd.nmcd.nmcd.hdc != NULL)
        {
            int align;
            if (plv->dwExStyle & WS_EX_RTLREADING)
            {
                align = GetTextAlign(lvfd.nmcd.nmcd.hdc);
                SetTextAlign(lvfd.nmcd.nmcd.hdc, align | TA_RTLREADING);
            }

            DrawText(lvfd.nmcd.nmcd.hdc, szLabel, cchLabel, &rcSingle, (DT_LV | DT_CALCRECT));

            if (plv->ci.style & LVS_NOLABELWRAP) 
            {
                flags = DT_LV | DT_CALCRECT;
            } 
            else 
            {
                flags = DT_LVWRAP | DT_CALCRECT;
                // We only use DT_NOFULLWIDTHCHARBREAK on Korean(949) Memphis and NT5
                if (949 == g_uiACP)
                    flags |= DT_NOFULLWIDTHCHARBREAK;
            }

            DrawText(lvfd.nmcd.nmcd.hdc, szLabel, cchLabel, &rcUnfolded, flags);

            //
            //  DrawText with DT_MODIFYSTRING is quirky when you enable
            //  word ellipses.  Once it finds anything that requires ellipses,
            //  it stops and doesn't return anything else (even if those other
            //  things got displayed).
            //
            lstrcpy(szLabelFolded, szLabel);
            DrawText(lvfd.nmcd.nmcd.hdc, szLabelFolded, cchLabel, &rcFolded, flags | DT_WORD_ELLIPSIS | DT_MODIFYSTRING);

            //  If we had to ellipsify, but you can't tell from looking at the
            //  rcFolded.bottom and rcUnfolded.bottom, then tweak rcFolded.bottom
            //  so the unfoldifier knows that unfolding is worthwhile.
            if (rcFolded.bottom == rcUnfolded.bottom &&
                lstrcmp(szLabel, szLabelFolded))
            {
                // The actual value isn't important, as long as it's greater
                // than rcUnfolded.bottom and CLIP_HEIGHT.  We take advantage
                // of the fact that CLIP_HEIGHT is only two lines, so the only
                // problem case is where you have a two-line item and only the
                // first line is ellipsified.
                rcFolded.bottom++;
            }

            if (plv->dwExStyle & WS_EX_RTLREADING)
            {
                SetTextAlign(lvfd.nmcd.nmcd.hdc, align);
            }

            if (!hdc) 
            {   
                // Clean up fake customdraw
                ListView_EndFakeItemDraw(&lvfd);
                ListView_EndFakeCustomDraw(&lvfd);
            }

        }
    }
    else
    {
        rcFolded.bottom = rcUnfolded.bottom = rcUnfolded.top + plv->cyLabelChar;
    }

Exit:

    if (pitem) 
    {
        int cyEdge;
        pitem->cxSingleLabel = (short)((rcSingle.right - rcSingle.left) + 2 * g_cxLabelMargin);
        pitem->cxMultiLabel = (short)((rcUnfolded.right - rcUnfolded.left) + 2 * g_cxLabelMargin);

        cyEdge = (plv->ci.style & LVS_NOLABELWRAP) ? 0 : g_cyEdge;

        pitem->cyFoldedLabel = (short)((rcFolded.bottom - rcFolded.top) + cyEdge);
        pitem->cyUnfoldedLabel = (short)((rcUnfolded.bottom - rcUnfolded.top) + cyEdge);
    }

}


// Set up an icon slot position.  Returns FALSE if position didn't change.
//
BOOL ListView_SetIconPos(LV* plv, LISTITEM* pitem, int iSlot, int cSlot)
{
    RECT rc;
    int iWidth = 0, iHeight = 0;
    DWORD   dwAlignment;

    ASSERT(plv);

    // We need to compute iWidth and iHeight only if right or bottom aligned.
    dwAlignment = (plv->ci.style & LVS_ALIGNMASK);
    if ((dwAlignment == LVS_ALIGNRIGHT) || (dwAlignment == LVS_ALIGNBOTTOM))
        ListView_GetSlotCountEx(plv, FALSE, pitem->iWorkArea, &iWidth, &iHeight);

    ListView_CalcSlotRect(plv, pitem, iSlot, cSlot, FALSE, iWidth, iHeight, &rc);

    // Offset into the slot so the item will draw at the right place
    rc.left += ListView_GetIconBufferX(plv);
    rc.top += ListView_GetIconBufferY(plv);
   
    if (rc.left != pitem->pt.x || rc.top != pitem->pt.y)
    {
        LV_AdjustViewRectOnMove(plv, pitem, rc.left, rc.top);

        return TRUE;
    }
    return FALSE;
}

// returns rcView in window coordinates
void ListView_GetViewRect2(LV* plv, RECT* prcView, int cx, int cy)
{
    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    *prcView = plv->rcView;

    //
    // Offsets for scrolling.
    //
    if (ListView_IsReportView(plv))
    {
        OffsetRect(prcView, -plv->ptlRptOrigin.x, -plv->ptlRptOrigin.y);
    }
    else
    {
        OffsetRect(prcView, -plv->ptOrigin.x, -plv->ptOrigin.y);
    }

    // desktop's snaptogrid code and defview's "position in lower right corner"
    // assume rcView includes the entire rcClient...  The below violates the
    // scrolling rules, so only do this for noscroll listview.
    if (ListView_IsSlotView(plv) && (plv->ci.style & LVS_NOSCROLL))
    {
        RECT rc;

        rc.left = 0;
        rc.top = 0;
        rc.right = cx;
        rc.bottom = cy;
        UnionRect(prcView, prcView, &rc);
    }
}

BOOL ListView_OnGetViewRect(LV* plv, RECT* prcView)
{
    BOOL fRet = FALSE;

    if (prcView)
    {
        ListView_GetViewRect2(plv, prcView, plv->sizeClient.cx, plv->sizeClient.cy);
        fRet = TRUE;
    }

    return fRet;
}

// RECTs returned in window coordinates
DWORD ListView_GetStyleAndClientRectGivenViewRect(LV* plv, RECT *prcViewRect, RECT* prcClient)
{
    RECT rcClient;
    DWORD style;

    // do this instead of the #else below because
    // in new versus old apps, you may need to add in g_c?Border because of
    // the one pixel overlap...
    GetWindowRect(plv->ci.hwnd, &rcClient);
    if (GetWindowLong(plv->ci.hwnd, GWL_EXSTYLE) & (WS_EX_CLIENTEDGE | WS_EX_STATICEDGE | WS_EX_WINDOWEDGE)) 
    {
        rcClient.right -= 2 * g_cxEdge;
        rcClient.bottom -= 2 * g_cyEdge;
    }
    rcClient.right -= rcClient.left;
    rcClient.bottom -= rcClient.top;
    if (rcClient.right < 0)
        rcClient.right = 0;
    if (rcClient.bottom < 0)
        rcClient.bottom = 0;
    rcClient.top = rcClient.left = 0;

    style = 0L;
    if (prcViewRect)
    {
        ASSERT(!ListView_IsIScrollView(plv) || ListView_ValidatercView(plv, &plv->rcView, FALSE));

        if ((rcClient.left < rcClient.right) && (rcClient.top < rcClient.bottom))
        {
            RECT rcView = *prcViewRect;
            // IScrollViews ensure scrollpositions based on rectwidth/height,
            // so we can use this current-scroll-position-independant method:
            if (ListView_IsIScrollView(plv))
            {
                do
                {
                    if (!(style & WS_HSCROLL) &&
                        (RECTWIDTH(rcClient) < RECTWIDTH(rcView)))
                    {
                        style |= WS_HSCROLL;
                        rcClient.bottom -= ListView_GetCyScrollbar(plv);
                    }
                    if (!(style & WS_VSCROLL) &&
                        (RECTHEIGHT(rcClient) < RECTHEIGHT(rcView)))
                    {
                        style |= WS_VSCROLL;
                        rcClient.right -= ListView_GetCxScrollbar(plv);
                    }
                }
                while (!(style & WS_HSCROLL) && (RECTWIDTH(rcClient) < RECTWIDTH(rcView)));
            }
            else
            {
                do
                {
                    if (!(style & WS_HSCROLL) &&
                        (rcView.left < rcClient.left || rcView.right > rcClient.right))
                    {
                        style |= WS_HSCROLL;
                        rcClient.bottom -= ListView_GetCyScrollbar(plv);
                    }
                    if (!(style & WS_VSCROLL) &&
                        (rcView.top < rcClient.top || rcView.bottom > rcClient.bottom))
                    {
                        style |= WS_VSCROLL;
                        rcClient.right -= ListView_GetCxScrollbar(plv);
                    }
                }
                while (!(style & WS_HSCROLL) && rcView.right > rcClient.right);
            }
        }
    }

    *prcClient = rcClient;
    return style;
}

// prcViewRect used only if fSubScroll is TRUE
// RECTs returned in window coordinates
DWORD ListView_GetClientRect(LV* plv, RECT* prcClient, BOOL fSubScroll, RECT *prcViewRect)
{
    RECT rcView;

    if (fSubScroll)
    {
        ListView_GetViewRect2(plv, &rcView, 0, 0);

        if (prcViewRect)
            *prcViewRect = rcView;
        else
            prcViewRect = &rcView;
    }
    else
    {
        prcViewRect = NULL;
    }

    return ListView_GetStyleAndClientRectGivenViewRect(plv, prcViewRect, prcClient);
}

// Note: pitem->iWorkArea must be properly set when calling this.  It gets set
// in LV_AdjustViewRectOnMove().
int CALLBACK ArrangeIconCompare(LISTITEM* pitem1, LISTITEM* pitem2, LPARAM lParam)
{
    int v1, v2;
    int iDirection = 1; //Assume "normal" direction
    POINT pt1 = {pitem1->pt.x, pitem1->pt.y};
    POINT pt2 = {pitem2->pt.x, pitem2->pt.y};
    // REVIEW: lParam can be 0 and we fault ... bug in caller, but we might want to be robust here.
    LV* plv = (LV*)lParam;
    int cx, cy;

    // Are these guys in the same workarea? Normalize with respect to topleft of workarea
    if (plv->nWorkAreas)
    {
        if (pitem1->iWorkArea == pitem2->iWorkArea)
        {
            RECT *prcWorkArea = &plv->prcWorkAreas[pitem1->iWorkArea];
            pt1.x -= prcWorkArea->left;
            pt2.x -= prcWorkArea->left;
            pt1.y -= prcWorkArea->top;
            pt2.y -= prcWorkArea->top;
        }
    }

    _GetCurrentItemSize(plv, &cx, &cy);

    switch((WORD)(plv->ci.style & LVS_ALIGNMASK))
    {
        case LVS_ALIGNRIGHT:
            iDirection = -1; //Right alignment results in abonormal direction.
            //Intentional fall through....
        
        case LVS_ALIGNLEFT:
            // Vertical arrangement
            v1 = pt1.x / cx;
            v2 = pt2.x / cx;

            if (v1 > v2)
                return iDirection;
            else if (v1 < v2)
                return -iDirection;
            else
            {
                if (pt1.y > pt2.y)
                    return 1;
                else if (pt1.y < pt2.y)
                    return -1;
            }
            break;

        case LVS_ALIGNBOTTOM:
            iDirection = -1;  //Bottom alignment results in abnormal direction.
            //Intentional fall through....
            
        case LVS_ALIGNTOP:
            v1 = pt1.y / cy;
            v2 = pt2.y / cy;

            if (v1 > v2)
                return iDirection;
            else if (v1 < v2)
                return -iDirection;
            else
            {
                if (pt1.x > pt2.x)
                    return 1;
                else if (pt1.x < pt2.x)
                    return -1;
            }
            break;
    }
    return 0;
}

void ListView_CalcBounds(LV* plv, UINT fQueryLabelRects, RECT *prcIcon, RECT *prcLabel, RECT *prcBounds)
{
    if ( ListView_HideLabels(plv) )
    {
        *prcBounds = *prcIcon;
    }
    else
    {
        UnionRect(prcBounds, prcIcon, prcLabel);

        if (IsQueryrcView(fQueryLabelRects))
        {
            if (ListView_IsIScrollView(plv))
            {
                RECT rcLabel = *prcLabel;

                prcBounds->left -= plv->rcViewMargin.left;
                prcBounds->top -= plv->rcViewMargin.top;
                prcBounds->right += plv->rcViewMargin.right;
                prcBounds->bottom += plv->rcViewMargin.bottom;

                // If no rcViewMargin is set, then we should make sure the label text
                // doesn't actually hit the edge of the screen...
                InflateRect(&rcLabel, g_cxEdge, g_cyEdge);
                UnionRect(prcBounds, prcBounds, &rcLabel);
            }
        }
    }
}

// This returns rects in Window Coordinates
// fQueryLabelRects determins how prcBounds and prcLabel are returned
void _ListView_GetRectsFromItem(LV* plv, BOOL bSmallIconView,
                                            LISTITEM *pitem, UINT fQueryLabelRects,
                                            LPRECT prcIcon, LPRECT prcLabel, LPRECT prcBounds, LPRECT prcSelectBounds)
{
    RECT rcIcon;
    RECT rcLabel;

    if (!prcIcon)
        prcIcon = &rcIcon;
    if (!prcLabel)
        prcLabel = &rcLabel;

    // Test for NULL item passed in
    if (pitem)
    {
        // This routine is called during ListView_Recompute(), while
        // plv->rcView.left may still be == RECOMPUTE.  So, we can't
        // test that to see if recomputation is needed.
        //
        if (pitem->pt.y == RECOMPUTE || pitem->cyFoldedLabel == SRECOMPUTE)
        {
            ListView_Recompute(plv);
        }

        if (bSmallIconView)
        {
            ListView_SGetRects(plv, pitem, prcIcon, prcLabel, prcBounds);
        }
        else if (ListView_IsTileView(plv))
        {
            ListView_TGetRects(plv, pitem, prcIcon, prcLabel, prcBounds);
        }
        else
        {
            ListView_IGetRects(plv, pitem, fQueryLabelRects, prcIcon, prcLabel, prcBounds);
        }

        if (prcBounds)
        {
            ListView_CalcBounds(plv, fQueryLabelRects, prcIcon, prcLabel, prcBounds);

            if (!(ListView_IsSimpleSelect(plv) && (ListView_IsIconView(plv) || ListView_IsTileView(plv)))  && 
                        plv->himlState && (LV_StateImageValue(pitem)))
            {
                prcBounds->left -= plv->cxState + LV_ICONTOSTATECX;
            }
        }

    }
    else 
    {
        SetRectEmpty(prcIcon);
        *prcLabel = *prcIcon;
        if (prcBounds)
            *prcBounds = *prcIcon;
    }

    if (prcSelectBounds)
    {
        if ( ListView_HideLabels(plv) )
            *prcSelectBounds = *prcIcon;
        else
            UnionRect(prcSelectBounds, prcIcon, prcLabel);

        if (!(ListView_IsSimpleSelect(plv) && 
                (ListView_IsIconView(plv) || ListView_IsTileView(plv))) 
                        && plv->himlState && (LV_StateImageValue(pitem)))
        {
            prcSelectBounds->left -= plv->cxState + LV_ICONTOSTATECX;
        }
    }
}

void _ListView_InvalidateItemPtr(LV* plv, BOOL bSmallIcon, LISTITEM *pitem, UINT fRedraw)
{
    RECT rcBounds;

    ASSERT( !ListView_IsOwnerData( plv ));

    _ListView_GetRectsFromItem(plv, bSmallIcon, pitem, QUERY_DEFAULT, NULL, NULL, &rcBounds, NULL);
    ListView_DebugDrawInvalidRegion(plv, &rcBounds, NULL);
    RedrawWindow(plv->ci.hwnd, &rcBounds, NULL, fRedraw);
}

//
// return TRUE if things still overlap
// this only happens if we tried to unstack things, and there was NOSCROLL set and
// items tried to go off the deep end
//
// NOTE: This function is written such that the order of icons in hdpaSort is still valid 
// even after unstacking some icons. This is very important because this function gets
// called twice (one for each direction) and we need to make sure the sort order does not 
// change between those two calls.
//
BOOL ListView_IUnstackOverlaps(LV* plv, HDPA hdpaSort, int iDirection, int xMargin, int yMargin, BOOL *pfIconsUnstacked)
{
    int i;
    int iCount;
    BOOL bSmallIconView = ListView_IsSmallView(plv);
    RECT rcItem, rcItem2, rcTemp;
    int cxItem, cyItem;
    LISTITEM* pitem;
    LISTITEM* pitem2;
    int iStartIndex, iEndIndex;
    BOOL    fAdjustY;
    int     iNextPrevCol = 1;
    int     iNextPrevRow = 1;
    int     iSlots;
    int     iCurWorkArea;
    RECT    rcCurWorkArea;
    BOOL    fRet = FALSE;

    ASSERT( !ListView_IsOwnerData( plv ) );

    _GetCurrentItemSize(plv, &cxItem, &cyItem);
    
    iCount = ListView_Count(plv);

    //
    // Get the direction in which we need to move the icons.
    //
    if(iDirection == 1)
    {
        iStartIndex = 0;        //We are starting with icon "0"...
        iEndIndex = iCount - 1; //...and moving towards the last icon.
    }
    else
    {
        ASSERT(iDirection == -1);
        iStartIndex = iCount - 1;  //We are starting with the last icon...
        iEndIndex = 0;             //..and moving towards the "0"th icon.
    }

    //
    // Look at the alignment of the icons to decide if we need to move them up/down or
    // left/right.
    //
    switch (plv->ci.style & LVS_ALIGNMASK)
    {
        case LVS_ALIGNBOTTOM:
            iNextPrevRow = -1;
            //Intentional fall-through!
        case LVS_ALIGNTOP:
            fAdjustY = FALSE;
            break;

        case LVS_ALIGNRIGHT:
            iNextPrevCol = -1;
            //Intentional fall-through!
        case LVS_ALIGNLEFT:
        default:
            fAdjustY = TRUE;
            break;
    }

    *pfIconsUnstacked = FALSE;

    // Give an unusual value to iCurWorkArea so that we will be forced to compute the 
    // rcCurWorkArea when we go through the loop the first time.
    iCurWorkArea = -2;
    
    // finally, unstack any overlaps
    for (i = iStartIndex ; i != (iEndIndex + iDirection) ; i += iDirection) 
    {
        int j;
        pitem = DPA_GetPtr(hdpaSort, i);

        if (bSmallIconView)
        {
            _ListView_GetRectsFromItem(plv, bSmallIconView, pitem, QUERY_FOLDED, NULL, NULL, &rcItem, NULL);
        }

        // move all the items that overlap with pitem
        for (j = i+iDirection ; j != (iEndIndex + iDirection); j += iDirection) 
        {
            POINT ptOldPos;

            pitem2 = DPA_GetPtr(hdpaSort, j);
            ptOldPos = pitem2->pt;

            //If an item is being newly added, ignore that item from participating
            //in the Unstacking. Otherwise, it results in all items being shuffled
            //around un-necessarrily!
            if((pitem2->pt.x == RECOMPUTE) || (pitem2->pt.y == RECOMPUTE))
                break; //break out of the loop!
                
            //
            //Check if pitem and pitem2 overlap; If so, move pitem2 to the next position.
            //
            if (bSmallIconView) 
            {
                // for small icons, we need to do an intersect rect
                _ListView_GetRectsFromItem(plv, bSmallIconView, pitem2, QUERY_FOLDED, NULL, NULL, &rcItem2, NULL);

                if (IntersectRect(&rcTemp, &rcItem, &rcItem2)) 
                {
                    // yes, it intersects.  move it out
                    *pfIconsUnstacked = TRUE;
                    _ListView_InvalidateItemPtr(plv, bSmallIconView, pitem2, RDW_INVALIDATE| RDW_ERASE);
                    do 
                    {
                        if(fAdjustY)
                            pitem2->pt.y += (cyItem * iDirection);
                        else    
                            pitem2->pt.x += (cxItem * iDirection);
                    } while (PtInRect(&rcItem, pitem2->pt));
                } 
                else 
                {
                    // pitem and pitem2 do not overlap...!
                    break;  //...break out of the loop!
                }

            } 
            else 
            {
                // for large icons, just find the ones that share the x,y;
                if (pitem2->pt.x == pitem->pt.x && pitem2->pt.y == pitem->pt.y) 
                {
                    *pfIconsUnstacked = TRUE;
                    _ListView_InvalidateItemPtr(plv, bSmallIconView, pitem2, RDW_INVALIDATE| RDW_ERASE);
                    if(fAdjustY)
                        pitem2->pt.y += (cyItem * iDirection);
                    else
                        pitem2->pt.x += (cxItem * iDirection);
                } 
                else 
                {
                    // pitem and pitem2 do not overlap...!
                    break; //...break out of the loop!
                }
            }

            //
            // Now we know that pitem2 overlapped with pitem and therefore pitem2 had been
            // moved to the "next" possible slot!
            //
            // If scrolling is possible, then we don't have to do anything else. But, if
            // NOSCROLL style is there, we need to check if the icon falls outside the 
            // client area and if so move it within.
            //
            if (plv->ci.style & LVS_NOSCROLL) 
            {
                //Since our list of icons are sorted based on their positions, the work
                //area change occurs only infrequently.
                if(iCurWorkArea != pitem2->iWorkArea)
                {
                    iCurWorkArea = pitem2->iWorkArea;
                    if((iCurWorkArea == -1) || (plv->prcWorkAreas == NULL) || (plv->nWorkAreas < 1))
                    {
                        rcCurWorkArea.left = rcCurWorkArea.top = 0;
                        rcCurWorkArea.right = plv->sizeClient.cx;
                        rcCurWorkArea.bottom = plv->sizeClient.cy;
                    }
                    else
                    {
                        ASSERT(plv->nWorkAreas >= 1);
                        rcCurWorkArea = plv->prcWorkAreas[iCurWorkArea];
                    }
                    //Get the number of slots per row/column based on the alignment style!
                    iSlots = ListView_GetSlotCountEx(plv, TRUE, iCurWorkArea, NULL, NULL);                    
                }
                
                //No scrolling possible. So, check if the icon lies outside the client area.
                if(fAdjustY)
                {
                    if(iDirection == 1)
                    {
                        //Has it moved below the bottom edge?
                        if(pitem2->pt.y > (rcCurWorkArea.bottom - (cyItem/2)))
                        {
                            //Then, move the item to the next/prev column.
                            pitem2->pt.x += iNextPrevCol*cxItem;
                            pitem2->pt.y = rcCurWorkArea.top + yMargin;

                            *pfIconsUnstacked = TRUE; // while not "unstacked", they did move
                        }
                    }
                    else
                    {
                        ASSERT(iDirection == -1);
                        //Has it moved above the top edge?
                        if(pitem2->pt.y < rcCurWorkArea.top)
                        {
                            //Then, move it to the next/prev column.
                            pitem2->pt.x -= iNextPrevCol*cxItem;
                            pitem2->pt.y = rcCurWorkArea.top + yMargin + (iSlots - 1)*cyItem;

                            *pfIconsUnstacked = TRUE; // while not "unstacked", they did move
                        }
                    }
                }
                else
                {
                    if(iDirection == 1)
                    {
                        //Has it been moved to the right of the right-edge?
                        if(pitem2->pt.x > (rcCurWorkArea.right - (cxItem/2)))
                        {
                            //Then move the item to the next/prev row.
                            pitem2->pt.x = rcCurWorkArea.left + xMargin;
                            pitem2->pt.y += iNextPrevRow*cyItem;

                            *pfIconsUnstacked = TRUE; // while not "unstacked", they did move
                        }
                    }
                    else
                    {
                        ASSERT(iDirection == -1);
                        //Has is moved to the left of the left-edge?
                        if(pitem2->pt.x < rcCurWorkArea.left)
                        {
                            //Then move the item to the prev/next row.
                            pitem2->pt.x = rcCurWorkArea.left + xMargin + (iSlots - 1)*cxItem;
                            pitem2->pt.y -= iNextPrevRow*cyItem;

                            *pfIconsUnstacked = TRUE; // while not "unstacked", they did move
                        }
                    }
                }
                // Inspite of all the above adjustments, if it still falls outside the
                // client, then move it back to where it was!
                if (pitem2->pt.x < rcCurWorkArea.left || pitem2->pt.y < rcCurWorkArea.top ||
                    pitem2->pt.x > (rcCurWorkArea.right - (cxItem/2))||
                    pitem2->pt.y > (rcCurWorkArea.bottom - (cyItem/2))) 
                {
                    pitem2->pt = ptOldPos;
                    fRet = TRUE; // TRUE = >Icons are still overlapped at the corner.
                    
                    //When this happens, we have reached the top-left corner or 
                    //the bottom-right corner of one work area (depending on the direction 
                    //and alignment)
                    //Once we reach a corner, we can't return immediately because there  
                    //could be icons in other work-areas that need to be unstacked.
                    //So, return only if we are working with a single work area.
                    if(plv->nWorkAreas <= 1)
                    {
                        if (*pfIconsUnstacked)
                            plv->rcView.left = RECOMPUTE;

                        return(fRet);
                    }
                }
            }
            
            // invalidate the new position as well
            _ListView_InvalidateItemPtr(plv, bSmallIconView, pitem2, RDW_INVALIDATE| RDW_ERASE);
        }
    }

    // NOTE: the above code should call LV_AdjustViewRectOnMove instead
    // of modifying item's points directly, but this is the easier fix.  This is
    // also not a perf hit, since it's uncommon for items to be stacked.
    if (*pfIconsUnstacked)
        plv->rcView.left = RECOMPUTE;

    return fRet; 
}


BOOL ListView_SnapToGrid(LV* plv, HDPA hdpaSort)
{
    // this algorithm can't fit in the structure of the other
    // arrange loop without becoming n^2 or worse.
    // this algorithm is order n.

    // iterate through and snap to the nearest grid.
    // iterate through and push aside overlaps.

    int i;
    int iCount;
    int x,y;
    LISTITEM* pitem;
    int cxItem, cyItem;
    RECT    rcClient = {0, 0, plv->sizeClient.cx, plv->sizeClient.cy};
    int     xMargin;
    int     yMargin;
    BOOL    fIconsMoved = FALSE;            //Has any icon moved to goto the nearest slot?
    BOOL    fIconsUnstacked = FALSE;        //Did we unstack any icons?

    ASSERT( !ListView_IsOwnerData( plv ) );

    _GetCurrentItemSize(plv, &cxItem, &cyItem);

    xMargin = ListView_GetIconBufferX(plv);
    yMargin = ListView_GetIconBufferY(plv);

    iCount = ListView_Count(plv);

    // first snap to nearest grid
    for (i = 0; i < iCount; i++)
    {
        int iWorkArea = 0;
        LPRECT prcCurWorkArea;
        
        pitem = DPA_GetPtr(hdpaSort, i);

        x = pitem->pt.x;
        y = pitem->pt.y;

        //If an item is being newly added, ignore that item from participating
        //in the snap-to-grid. Otherwise, it results in all items being shuffled
        //around un-necessarrily!
        if ((x == RECOMPUTE) || (y == RECOMPUTE))
            continue;
            
        x -= xMargin;
        y -= yMargin;
        
        //Let's find the nearest work area (where this icon should fall)
        iWorkArea = NearestWorkArea(plv, x, y, cxItem, cyItem, pitem->iWorkArea);
        
        if(iWorkArea == -1)
        {
            prcCurWorkArea = &rcClient;
        }
        else
        {
            prcCurWorkArea = &plv->prcWorkAreas[iWorkArea];
            pitem->iWorkArea = (short)iWorkArea;
        }
        
        NearestSlot(plv, pitem, &x,&y, cxItem, cyItem, prcCurWorkArea);

        x += xMargin;
        y += yMargin;

        if (x != pitem->pt.x || y != pitem->pt.y)
        {
            fIconsMoved = TRUE;
            _ListView_InvalidateItemPtr(plv, ListView_IsSmallView(plv), pitem, RDW_INVALIDATE| RDW_ERASE);
            if (plv->ci.style & LVS_NOSCROLL)
            {
                // if it's marked noscroll, make sure it's still on the client region
                while (x > (prcCurWorkArea->right - cxItem + xMargin))
                    x -= cxItem;

                while (x < 0)
                    x += cxItem;

                while (y > (prcCurWorkArea->bottom - cyItem + yMargin))
                    y -= cyItem;

                while (y < 0)
                    y += cyItem;
            }

            LV_AdjustViewRectOnMove(plv, pitem, x, y);        

            _ListView_InvalidateItemPtr(plv, ListView_IsSmallView(plv), pitem, RDW_INVALIDATE| RDW_ERASE);
        }
    }

    // now resort the dpa
    if (!DPA_Sort(hdpaSort, ArrangeIconCompare, (LPARAM)plv))
        return FALSE;

    // go in one direction, if there are still overlaps, go in the other
    // direction as well
    if (ListView_IUnstackOverlaps(plv, hdpaSort, 1, xMargin, yMargin, &fIconsUnstacked))
    {
        //The sorting already done by DPA_Sort is still valid!
        BOOL fIconsUnstackedSecondTime = FALSE;
        ListView_IUnstackOverlaps(plv, hdpaSort, -1, xMargin, yMargin, &fIconsUnstackedSecondTime);
        fIconsUnstacked |= fIconsUnstackedSecondTime;
    }

    // If something moved, make sure the scrollbars are correct
    if ((fIconsMoved || fIconsUnstacked))
    {
        ListView_UpdateScrollBars(plv);
    }
    return FALSE;
}


BOOL ListView_OnArrange(LV* plv, UINT style)
{
    HDPA hdpaSort = NULL;

    if (!ListView_IsAutoArrangeView(plv)) 
    {
        return FALSE;
    }

    if (ListView_IsOwnerData( plv ))
    {
        if ( style & (LVA_SNAPTOGRID | LVA_SORTASCENDING | LVA_SORTDESCENDING) )
        {
            RIPMSG(0, "LVM_ARRANGE: Cannot combine LVA_SNAPTOGRID or LVA_SORTxxx with owner-data");
            return( FALSE );
        }
    }

    if (!ListView_IsOwnerData( plv ))
    {
        // we clone plv->hdpa so we don't blow away indices that
        // apps have saved away.
        // we sort here to make the nested for loop below more bearable.
        hdpaSort = DPA_Clone(plv->hdpa, NULL);

        if (!hdpaSort)
            return FALSE;
    }

    // Give every item a new position...
    if (ListView_IsOwnerData( plv ))
    {
        ListView_CommonArrange(plv, style, NULL);
    }
    else
    {
        if (!DPA_Sort(hdpaSort, ArrangeIconCompare, (LPARAM)plv))
            return FALSE;

        ListView_CommonArrange(plv, style, hdpaSort);

        DPA_Destroy(hdpaSort);
    }

    NotifyWinEvent(EVENT_OBJECT_REORDER, plv->ci.hwnd, OBJID_CLIENT, 0);

    return TRUE;
}

BOOL ListView_CommonArrangeGroup(LV* plv, int cSlots, HDPA hdpa, int iWorkArea, int cWorkAreaSlots[])
{
    int iItem;
    BOOL fItemMoved = FALSE;
    int iSlot = 0;

    // For each group, we start as slot zero. 
    for (iItem = 0; iItem < DPA_GetPtrCount(hdpa); iItem++)
    {
        int cRealSlots; 
        LISTITEM* pitem = DPA_GetPtr(hdpa, iItem);

        // In the multi-workarea case, if this item is not in our workarea, skip it. 
        if (pitem->iWorkArea != iWorkArea)
            continue;

        // Ignore frozen items.
        if (pitem == plv->pFrozenItem)
            continue;

        cRealSlots = (plv->nWorkAreas > 0) ? cWorkAreaSlots[pitem->iWorkArea] : cSlots;

        fItemMoved |= ListView_SetIconPos(plv, pitem, iSlot++, cRealSlots);
    }

    return fItemMoved;
}

void ListView_InvalidateWindow(LV* plv)
{
    if (ListView_RedrawEnabled(plv))
        RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
    else 
    {
        ListView_DeleteHrgnInval(plv);
        plv->hrgnInval = (HRGN)ENTIRE_REGION;
        plv->flags |= LVF_ERASE;
    }
}

// Arrange the icons given a sorted hdpa, and arrange them in the sub workareas
BOOL ListView_CommonArrangeEx(LV* plv, UINT style, HDPA hdpaSort, int iWorkArea)
{
    if (!ListView_IsOwnerData( plv ))
    {
        BOOL fItemMoved = FALSE;
        BOOL fScrolled = FALSE;

        // We're going to call FixIScrollPositions at the end of this, so turn off
        // scroll-validation while we re-arrange the world
        ASSERT(!plv->fInFixIScrollPositions);
        plv->fInFixIScrollPositions = TRUE;

        if (style == LVA_SNAPTOGRID && !plv->fGroupView) 
        {
            // ListView_SnapToGrid() has been made multi-mon aware. This needs to be called
            // just once and it snaps to grid all icons in ALL work areas. Since
            // ListView_CommonArrangeEx() gets called for every work area, we want to avoid
            // un-necessary calls to ListView_SnapToGrid(). So, we call it just once for
            // the first work area.
            if (iWorkArea < 1) // For iWorkArea = 0 or -1.
            {
                fItemMoved |= ListView_SnapToGrid(plv, hdpaSort);
            }
        }
        else
        {
            int cSlots;
            int cWorkAreaSlots[LV_MAX_WORKAREAS];

            if (plv->nWorkAreas > 0)
            {
                int i;
                for (i = 0; i < plv->nWorkAreas; i++)
                    cWorkAreaSlots[i] = ListView_GetSlotCountEx(plv, TRUE, i, NULL, NULL);
            }
            else
                cSlots = ListView_GetSlotCount(plv, TRUE, NULL, NULL);

            if (plv->fGroupView && plv->hdpaGroups)
            {
                int iGroup;
                int cGroups = DPA_GetPtrCount(plv->hdpaGroups);
                for (iGroup = 0; iGroup < cGroups; iGroup++)
                {
                    LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);

                    fItemMoved |= ListView_CommonArrangeGroup(plv, cSlots, pgrp->hdpa, iWorkArea, cWorkAreaSlots);
                }

                if (fItemMoved)
                {
                    ListView_IRecomputeEx(plv, NULL, 0, FALSE);
                }
            }
            else
            {
                fItemMoved |= ListView_CommonArrangeGroup(plv, cSlots, hdpaSort, iWorkArea, cWorkAreaSlots);
            }
        }

        plv->fInFixIScrollPositions = FALSE;

        // We might have to adjust the scroll positions to match the new rcView
        if (ListView_IsIScrollView(plv) && !(plv->ci.style & LVS_NOSCROLL))
        {
            RECT rcClient;
            POINT pt;

            fScrolled |= ListView_FixIScrollPositions(plv, FALSE, NULL);

            // Find the auto arrange origin
            ListView_GetClientRect(plv, &rcClient, TRUE, FALSE);
            if ((plv->ci.style & LVS_ALIGNMASK) == LVS_ALIGNRIGHT)
                pt.x = plv->rcView.right - RECTWIDTH(rcClient);
            else
                pt.x = plv->rcView.left;
            if ((plv->ci.style & LVS_ALIGNMASK) == LVS_ALIGNBOTTOM)
                pt.y = plv->rcView.bottom - RECTHEIGHT(rcClient);
            else
                pt.y = plv->rcView.top;

            // If rcView is smaller than rcClient, peg it to the correct side
            if (RECTWIDTH(rcClient) > RECTWIDTH(plv->rcView))
            {
                if (plv->ptOrigin.x != pt.x)
                {
                    plv->ptOrigin.x = pt.x;
                    fScrolled = TRUE;
                }
            }
            if (RECTHEIGHT(rcClient) > RECTHEIGHT(plv->rcView))
            {
                if (plv->ptOrigin.y != pt.y)
                {
                    plv->ptOrigin.y = pt.y;
                    fScrolled = TRUE;
                }
            }
            ASSERT(ListView_ValidateScrollPositions(plv, &rcClient));
        }

        if (fItemMoved || fScrolled)
        {
            int iItem;

            // We might as well invalidate the entire window to make sure...
            ListView_InvalidateWindow(plv);

            // ensure important items are visible
            iItem = (plv->iFocus >= 0) ? plv->iFocus : ListView_OnGetNextItem(plv, -1, LVNI_SELECTED);

            if (ListView_RedrawEnabled(plv))
                ListView_UpdateScrollBars(plv);

            if (iItem >= 0)
                ListView_OnEnsureVisible(plv, iItem, FALSE);
        }
    }

    return TRUE;
}


// this arranges the icon given a sorted hdpa.
// Arrange the workareas one by one in the multi-workarea case. 
BOOL ListView_CommonArrange(LV* plv, UINT style, HDPA hdpaSort)
{
    if (plv->nWorkAreas < 1)
    {
        if (plv->exStyle & LVS_EX_MULTIWORKAREAS)
            return TRUE;
        else
            return ListView_CommonArrangeEx(plv, style, hdpaSort, 0);
    }
    else
    {
        int i;
        for (i = 0; i < plv->nWorkAreas; i++)
            ListView_CommonArrangeEx(plv, style, hdpaSort, i);
        return TRUE;
    }
}

void ListView_IUpdateScrollBars(LV* plv)
{
    // nothing to update if we're in the middle of fixing them up...
    if (!plv->fInFixIScrollPositions)
    {
        RECT rcClient;
        RECT rcView;
        DWORD style;
        DWORD styleOld;
        SCROLLINFO si;

        styleOld = ListView_GetWindowStyle(plv);

        style = ListView_GetClientRect(plv, &rcClient, TRUE, &rcView);
        if (ListView_FixIScrollPositions(plv, TRUE,  &rcClient))
        {
            RECT rcClient2, rcView2;
            DWORD style2 = ListView_GetClientRect(plv, &rcClient2, TRUE, &rcView2);

#ifdef DEBUG
            // Now that ListView_GetClientRect is scroll-position-independent, fixing the scroll
            // positions should have no effect on the size of rcClient and it's style
            //
            ASSERT(style2 == style);
            ASSERT(RECTWIDTH(rcClient)==RECTWIDTH(rcClient2) && RECTHEIGHT(rcClient)==RECTHEIGHT(rcClient2));
            ASSERT(RECTWIDTH(rcView)==RECTWIDTH(rcView2) && RECTHEIGHT(rcView)==RECTHEIGHT(rcView2));
#endif

            rcClient = rcClient2;
            rcView = rcView2;
        }

        si.cbSize = sizeof(SCROLLINFO);

        if (style & WS_HSCROLL)
        {
            si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
            si.nMin = 0;
            si.nMax = rcView.right - rcView.left - 1;

            si.nPage = rcClient.right - rcClient.left;

            si.nPos = rcClient.left - rcView.left;

            // ListView_FixIScrollPositions() ensures that our scroll positions are correct:
            ASSERT(si.nMax >= (int)si.nPage); // otherwise why is WS_HSCROLL set?
            ASSERT(si.nPos >= 0); // rcClient.left isn't left of rcView.left
            ASSERT(si.nPos + (int)si.nPage <= si.nMax + 1); // rcClient.right isn't right of rcView.right

            ListView_SetScrollInfo(plv, SB_HORZ, &si, TRUE);
        }
        else if (styleOld & WS_HSCROLL)
        {
            ListView_SetScrollRange(plv, SB_HORZ, 0, 0, TRUE);
        }

        if (style & WS_VSCROLL)
        {
            si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
            si.nMin = 0;
            si.nMax = rcView.bottom - rcView.top - 1;

            si.nPage = rcClient.bottom - rcClient.top;

            si.nPos = rcClient.top - rcView.top;

            // ListView_FixIScrollPositions() ensures that our scroll positions are correct:
            ASSERT(si.nMax >= (int)si.nPage); // otherwise why is WS_VSCROLL set?
            ASSERT(si.nPos >= 0); // rcClient.top isn't above rcView.top
            ASSERT(si.nPos + (int)si.nPage <= si.nMax + 1); // rcClient.bottom isn't below of rcView.bottom

            ListView_SetScrollInfo(plv, SB_VERT, &si, TRUE);
        }
        else if (styleOld & WS_VSCROLL)
        {
            ListView_SetScrollRange(plv, SB_VERT, 0, 0, TRUE);
        }
    }
}

void ListView_ComOnScroll(LV* plv, UINT code, int posNew, int sb,
                                     int cLine, int cPage)
{
    int pos;
    SCROLLINFO si;
    BOOL fVert = (sb == SB_VERT);
    UINT uSmooth = SSW_EX_UPDATEATEACHSTEP;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;

    if (!ListView_GetScrollInfo(plv, sb, &si)) {
        return;
    }

    if (cPage != -1)
        si.nPage = cPage;

    if (si.nPage)
        si.nMax -= (si.nPage - 1);

    ASSERT(si.nMax >= si.nMin);
    if (si.nMax < si.nMin)
        si.nMax = si.nMin;

    pos = (int)si.nPos; // current position

    switch (code)
    {
    case SB_LEFT:
        si.nPos = si.nMin;
        break;
    case SB_RIGHT:
        si.nPos = si.nMax;
        break;
    case SB_PAGELEFT:
        si.nPos = max(si.nMin, si.nPos - (int)si.nPage);
        break;
    case SB_LINELEFT:
        si.nPos = max(si.nMin, si.nPos - cLine);
        break;
    case SB_PAGERIGHT:
        si.nPos = min(si.nMax, si.nPos + (int)si.nPage);
        break;
    case SB_LINERIGHT:
        si.nPos = min(si.nMax, si.nPos + cLine);
        break;

    case SB_THUMBTRACK:
        si.nPos = posNew;
        uSmooth = SSW_EX_IMMEDIATE;
        break;

    case SB_ENDSCROLL:
        // When scroll bar tracking is over, ensure scroll bars
        // are properly updated...
        //
        ListView_UpdateScrollBars(plv);
        return;

    default:
        return;
    }

    if (plv->iScrollCount >= SMOOTHSCROLLLIMIT)
        uSmooth = SSW_EX_IMMEDIATE;

    si.fMask = SIF_POS;
    si.nPos = ListView_SetScrollInfo(plv, sb, &si, TRUE);

    if (pos != si.nPos)
    {
        int delta = (int)si.nPos - pos;
        int dx = 0, dy = 0;
        if (fVert)
            dy = delta;
        else
            dx = delta;
        ListView_SendScrollNotify(plv, TRUE, dx, dy);
        _ListView_Scroll2(plv, dx, dy, uSmooth);
        ListView_SendScrollNotify(plv, FALSE, dx, dy);
        UpdateWindow(plv->ci.hwnd);
    }
}

//
//  We need a smoothscroll callback so our background image draws
//  at the correct origin.  If we don't have a background image,
//  then this work is superfluous but not harmful either.
//
int CALLBACK ListView_IScroll2_SmoothScroll(
    HWND hwnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip ,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags)
{
    LV* plv = ListView_GetPtr(hwnd);
    if (plv)
    {
        plv->ptOrigin.x -= dx;
        plv->ptOrigin.y -= dy;
    }

    // Now do what SmoothScrollWindow would've done if we weren't
    // a callback

    if (ListView_IsWatermarkedBackground(plv) || 
        ListView_IsWatermarked(plv))
    {
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        return TRUE;
    }
    else
        return ScrollWindowEx(hwnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
}



void ListView_IScroll2(LV* plv, int dx, int dy, UINT uSmooth)
{
    if (dx | dy)
    {
        if ((plv->clrBk == CLR_NONE) && (plv->pImgCtx == NULL))
        {
            plv->ptOrigin.x += dx;
            plv->ptOrigin.y += dy;
            LVSeeThruScroll(plv, NULL);
        }
        else
        {
            SMOOTHSCROLLINFO si;
            si.cbSize =  sizeof(si);
            si.fMask = SSIF_SCROLLPROC;
            si.hwnd = plv->ci.hwnd;
            si.dx = -dx;
            si.dy = -dy;
            si.lprcSrc = NULL;
            si.lprcClip = NULL;
            si.hrgnUpdate = NULL;
            si.lprcUpdate = NULL;
            si.fuScroll = uSmooth | SW_INVALIDATE | SW_ERASE | SSW_EX_UPDATEATEACHSTEP;
            si.pfnScrollProc = ListView_IScroll2_SmoothScroll;
            SmoothScrollWindow(&si);
        }
    }
}

void ListView_IOnScroll(LV* plv, UINT code, int posNew, UINT sb)
{
    int cLine;

    if (sb == SB_VERT)
    {
        cLine = plv->cyIconSpacing / 2;
    }
    else
    {
        cLine = plv->cxIconSpacing / 2;
    }

    ListView_ComOnScroll(plv, code,  posNew,  sb, cLine, -1);
}

int ListView_IGetScrollUnitsPerLine(LV* plv, UINT sb)
{
    int cLine;

    if (sb == SB_VERT)
    {
        cLine = plv->cyIconSpacing / 2;
    }
    else
    {
        cLine = plv->cxIconSpacing / 2;
    }

    return cLine;
}

// NOTE: there is very similar code in the treeview
//
// Totally disgusting hack in order to catch VK_RETURN
// before edit control gets it.
//
LRESULT CALLBACK ListView_EditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LV* plv = ListView_GetPtr(GetParent(hwnd));
    LRESULT lret;

    ASSERT(plv);

#if defined(FE_IME) || !defined(WINNT)
    if ( (g_fDBCSInputEnabled) && LOWORD(GetKeyboardLayout(0L)) == 0x0411 )
    {
        // The following code adds IME awareness to the
        // listview's label editing. Currently just for Japanese.
        //
        DWORD dwGcs;
    
        if (msg==WM_SIZE)
        {
            // If it's given the size, tell it to an IME.

             ListView_SizeIME(hwnd);
        }
        else if (msg == EM_SETLIMITTEXT )
        {
           if (wParam < 13)
               plv->flags |= LVF_DONTDRAWCOMP;
           else
               plv->flags &= ~LVF_DONTDRAWCOMP;
        }
        // Give up to draw IME composition by ourselves in case
        // we're working on SFN. Win95d-5709
        else if (!(plv->flags & LVF_DONTDRAWCOMP ))
        {
            switch (msg)
            {

             case WM_IME_STARTCOMPOSITION:
             case WM_IME_ENDCOMPOSITION:
                 return 0L;


             case WM_IME_COMPOSITION:

             // If lParam has no data available bit, it implies
             // canceling composition.
             // ListView_InsertComposition() tries to get composition
             // string w/ GCS_COMPSTR then remove it from edit control if
             // nothing is available.
             //
                 if ( !lParam )
                     dwGcs = GCS_COMPSTR;
                 else
                     dwGcs = (DWORD) lParam;

                 ListView_InsertComposition(hwnd, wParam, dwGcs, plv);
                 return 0L;
                 
             case WM_PAINT:
                 lret=CallWindowProc(plv->pfnEditWndProc, hwnd, msg, wParam, lParam);
                 ListView_PaintComposition(hwnd,plv);
                 return lret;
                 
             case WM_IME_SETCONTEXT:

             // We draw composition string.
             //
                 lParam &= ~ISC_SHOWUICOMPOSITIONWINDOW;
                 break;

             default:
                 // the other messages should simply be processed
                 // in this subclass procedure.
                 break;
            }
        }
    }
#endif FE_IME

    switch (msg)
    {
    case WM_SETTEXT:
        SetWindowID(hwnd, 1);
        break;

    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_RETURN:
            ListView_DismissEdit(plv, FALSE);
            return 0L;

        case VK_ESCAPE:
            ListView_DismissEdit(plv, TRUE);
            return 0L;
        }
        break;

    case WM_CHAR:
        switch (wParam)
        {
        case VK_RETURN:
            // Eat the character, so edit control wont beep!
            return 0L;
        }
                break;

        case WM_GETDLGCODE:
                return DLGC_WANTALLKEYS | DLGC_HASSETSEL;        /* editing name, no dialog handling right now */
    }

    return CallWindowProc(plv->pfnEditWndProc, hwnd, msg, wParam, lParam);
}

//  Helper routine for SetEditSize
void ListView_ChangeEditRectForRegion(LV* plv, LPRECT lprc)
{
    LISTITEM* pitem = ListView_GetItemPtr(plv, plv->iEdit);

    ASSERT(!ListView_IsOwnerData(plv));
    ASSERT(ListView_IsIconView(plv));

    if (!EqualRect((CONST RECT *)&pitem->rcTextRgn, (CONST RECT *)lprc)) 
    {
        // RecalcRegion knows to use rcTextRgn in the case where iEdit != -1,
        // so set it up before calling through.
        CopyRect(&pitem->rcTextRgn, (CONST RECT *)lprc);
        ListView_RecalcRegion(plv, TRUE, TRUE);

        // Invalidate the entire Edit and force a repaint from the listview
        // on down to make sure we don't leave turds...
        InvalidateRect(plv->hwndEdit, NULL, TRUE);
        UpdateWindow(plv->ci.hwnd);
    }
}

void ListView_SetEditSize(LV* plv)
{
    RECT rcLabel;
    UINT seips;

    if (!((plv->iEdit >= 0) && (plv->iEdit < ListView_Count(plv))))
    {
       ListView_DismissEdit(plv, TRUE);    // cancel edits
       return;
    }

    ListView_GetRects(plv, plv->iEdit, QUERY_DEFAULT, NULL, &rcLabel, NULL, NULL);

    // OffsetRect(&rc, rcLabel.left + g_cxLabelMargin + g_cxBorder,
    //         (rcLabel.bottom + rcLabel.top - rc.bottom) / 2 + g_cyBorder);
    // OffsetRect(&rc, rcLabel.left + g_cxLabelMargin , rcLabel.top);

    // get the text bounding rect

    if (ListView_IsIconView(plv))
    {
        // We should not adjust y-positoin in case of the icon view.
        InflateRect(&rcLabel, -g_cxLabelMargin, -g_cyBorder);
    }
    else
    {
        // Special case for single-line & centered
        InflateRect(&rcLabel, -g_cxLabelMargin - g_cxBorder, (-(rcLabel.bottom - rcLabel.top - plv->cyLabelChar) / 2) - g_cyBorder);
    }

    seips = 0;
    if (ListView_IsIconView(plv) && !(plv->ci.style & LVS_NOLABELWRAP))
        seips |= SEIPS_WRAP;
#ifdef DEBUG
    if (plv->ci.style & LVS_NOSCROLL)
        seips |= SEIPS_NOSCROLL;
#endif

    SetEditInPlaceSize(plv->hwndEdit, &rcLabel, plv->hfontLabel, seips);

    if (plv->exStyle & LVS_EX_REGIONAL)
        ListView_ChangeEditRectForRegion(plv, &rcLabel);
}

// to avoid eating too much stack
void ListView_DoOnEditLabel(LV *plv, int i, LPTSTR pszInitial)
{
    TCHAR szLabel[CCHLABELMAX];
    LV_ITEM item;

    item.mask = LVIF_TEXT;
    item.iItem = i;
    item.iSubItem = 0;
    item.pszText = szLabel;
    item.cchTextMax = ARRAYSIZE(szLabel);
    ListView_OnGetItem(plv, &item);

    if (!item.pszText)
        return;

    // Make sure the edited item has the focus.
    if (plv->iFocus != i)
        ListView_SetFocusSel(plv, i, TRUE, TRUE, FALSE);

    // Make sure the item is fully visible
    ListView_OnEnsureVisible(plv, i, FALSE);        // fPartialOK == FALSE

    // Must subtract one from ARRAYSIZE(szLabel) because Edit_LimitText doesn't include
    // the terminating NULL

    plv->hwndEdit = CreateEditInPlaceWindow(plv->ci.hwnd,
            pszInitial? pszInitial : item.pszText, ARRAYSIZE(szLabel) - 1,
        ListView_IsIconView(plv) ?
            (WS_BORDER | WS_CLIPSIBLINGS | WS_CHILD | ES_CENTER | ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL) :
            (WS_BORDER | WS_CLIPSIBLINGS | WS_CHILD | ES_LEFT | ES_AUTOHSCROLL), plv->hfontLabel);
    if (plv->hwndEdit)
    {
        LISTITEM* pitem;
        LV_DISPINFO nm;

        // We create the edit window but have not shown it.  Ask the owner
        // if they are interested or not.
        // If we passed in initial text set the ID to be dirty...
        if (pszInitial)
            SetWindowID(plv->hwndEdit, 1);

        nm.item.mask = LVIF_PARAM;
        nm.item.iItem = i;
        nm.item.iSubItem = 0;

        if (!ListView_IsOwnerData( plv ))
        {
            if (!(pitem = ListView_GetItemPtr(plv, i)))
            {
                DestroyWindow(plv->hwndEdit);
                plv->hwndEdit = NULL;
                return;
            }
            nm.item.lParam = pitem->lParam;
        }
        else
            nm.item.lParam = (LPARAM)0;


        plv->iEdit = i;

        // if they have LVS_EDITLABELS but return non-FALSE here, stop!
        if ((BOOL)CCSendNotify(&plv->ci, LVN_BEGINLABELEDIT, &nm.hdr))
        {
            plv->iEdit = -1;
            DestroyWindow(plv->hwndEdit);
            plv->hwndEdit = NULL;
        }
    }
}


void RescrollEditWindow(HWND hwndEdit)
{
    Edit_SetSel(hwndEdit, -1, -1);      // move to the end
    Edit_SetSel(hwndEdit, 0, -1);       // select all text
}

HWND ListView_OnEditLabel(LV* plv, int i, LPTSTR pszInitialText)
{

    // this eats stack
    ListView_DismissEdit(plv, FALSE);

    if (!(plv->ci.style & LVS_EDITLABELS) || (GetFocus() != plv->ci.hwnd) ||
        (i == -1))
        return(NULL);   // Does not support this.

    ListView_DoOnEditLabel(plv, i, pszInitialText);

    if (plv->hwndEdit) {

        plv->pfnEditWndProc = SubclassWindow(plv->hwndEdit, ListView_EditWndProc);

#if defined(FE_IME) || !defined(WINNT)
        if (g_fDBCSInputEnabled) {
            if (SendMessage(plv->hwndEdit, EM_GETLIMITTEXT, (WPARAM)0, (LPARAM)0)<13)
            {
                plv->flags |= LVF_DONTDRAWCOMP;
            }

        }
#endif

        ListView_SetEditSize(plv);

        // Show the window and set focus to it.  Do this after setting the
        // size so we don't get flicker.
        SetFocus(plv->hwndEdit);
        ShowWindow(plv->hwndEdit, SW_SHOW);
        ListView_InvalidateItem(plv, i, TRUE, RDW_INVALIDATE | RDW_ERASE);

        RescrollEditWindow(plv->hwndEdit);

        /* Due to a bizzare twist of fate, a certain mix of resolution / font size / icon
        /  spacing results in being able to see the previous label behind the edit control
        /  we have just created.  Therefore to overcome this problem we ensure that this
        /  label is erased.
        /
        /  As the label is not painted when we have an edit control we just invalidate the
        /  area and the background will be painted.  As the window is a child of the list view
        /  we should not see any flicker within it. */

        if ( ListView_IsIconView( plv ) && !ListView_HideLabels(plv))
        {
            RECT rcLabel;
            
            ListView_GetRects( plv, i, QUERY_UNFOLDED, NULL, &rcLabel, NULL, NULL );

            InvalidateRect( plv->ci.hwnd, &rcLabel, TRUE );
            UpdateWindow( plv->ci.hwnd );
        }
    }

    return plv->hwndEdit;
}


BOOL ListView_DismissEdit(LV* plv, BOOL fCancel)
{
    LISTITEM* pitem = NULL;
    BOOL fOkToContinue = TRUE;
    HWND hwndEdit = plv->hwndEdit;
    HWND hwnd = plv->ci.hwnd;
    int iEdit;
    LV_DISPINFO nm;
    TCHAR szLabel[CCHLABELMAX];
#if defined(FE_IME) || !defined(WINNT)
    HIMC himc;
#endif


    if (plv->fNoDismissEdit)
        return FALSE;

    if (!hwndEdit) {
        // Also make sure there are no pending edits...
        ListView_CancelPendingEdit(plv);
        return TRUE;    // It is OK to process as normal...
    }

    // If the window is not visible, we are probably in the process
    // of being destroyed, so assume that we are being destroyed
    if (!IsWindowVisible(plv->ci.hwnd))
        fCancel = TRUE;

    //
    // We are using the Window ID of the control as a BOOL to
    // state if it is dirty or not.
    switch (GetWindowID(hwndEdit)) {
    case 0:
        // The edit control is not dirty so act like cancel.
        fCancel = TRUE;
        // Fall through to set window so we will not recurse!
    case 1:
        // The edit control is dirty so continue.
        SetWindowID(hwndEdit, 2);    // Don't recurse
        break;
    case 2:
        // We are in the process of processing an update now, bail out
        return TRUE;
    }

    // Bug#94345: this will fail if the program deleted the items out
    // from underneath us (while we are waiting for the edit timer).
    // make delete item invalidate our edit item
    // We uncouple the edit control and hwnd out from under this as
    // to allow code that process the LVN_ENDLABELEDIT to reenter
    // editing mode if an error happens.
    iEdit = plv->iEdit;

    do
    {
        if (ListView_IsOwnerData( plv ))
        {
            if (!((iEdit >= 0) && (iEdit < plv->cTotalItems)))
            {
                break;
            }
            nm.item.lParam = 0;
        }
        else
        {

            pitem = ListView_GetItemPtr(plv, iEdit);
            ASSERT(pitem);
            if (pitem == NULL)
            {
                break;
            }
            nm.item.lParam = pitem->lParam;
        }

        nm.item.iItem = iEdit;
        nm.item.iSubItem = 0;
        nm.item.cchTextMax = 0;
        nm.item.mask = 0;

        if (fCancel)
            nm.item.pszText = NULL;
        else
        {
            Edit_GetText(hwndEdit, szLabel, ARRAYSIZE(szLabel));
            nm.item.pszText = szLabel;
            nm.item.mask |= LVIF_TEXT;
            nm.item.cchTextMax = ARRAYSIZE(szLabel);
        }

        //
        // Notify the parent that we the label editing has completed.
        // We will use the LV_DISPINFO structure to return the new
        // label in.  The parent still has the old text available by
        // calling the GetItemText function.
        //

        fOkToContinue = (BOOL)CCSendNotify(&plv->ci, LVN_ENDLABELEDIT, &nm.hdr);
        if (!IsWindow(hwnd)) {
            return FALSE;
        }
        if (fOkToContinue && !fCancel)
        {
            //
            // If the item has the text set as CALLBACK, we will let the
            // ower know that they are supposed to set the item text in
            // their own data structures.  Else we will simply update the
            // text in the actual view.
            //
            if (!ListView_IsOwnerData( plv ) &&
                (pitem->pszText != LPSTR_TEXTCALLBACK))
            {
                // Set the item text (everything's set up in nm.item)
                //
                nm.item.mask = LVIF_TEXT;
                ListView_OnSetItem(plv, &nm.item);
            }
            else
            {
                CCSendNotify(&plv->ci, LVN_SETDISPINFO, &nm.hdr);

                // Also we will assume that our cached size is invalid...
                plv->rcView.left = RECOMPUTE;
                if (!ListView_IsOwnerData( plv ))
                {
                    ListView_SetSRecompute(pitem);
                }
            }
        }

#if defined(FE_IME) || !defined(WINNT)
        if (g_fDBCSInputEnabled) {
            if (LOWORD(GetKeyboardLayout(0L)) == 0x0411 && (himc = ImmGetContext(hwndEdit)))
            {
                ImmNotifyIME(himc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0L);
                ImmReleaseContext(hwndEdit, himc);
            }
        }
#endif

        // redraw
        ListView_InvalidateItem(plv, iEdit, FALSE, RDW_INVALIDATE | RDW_ERASE);
    } while (FALSE);

    // If the hwnedit is still us clear out the variables
    if (hwndEdit == plv->hwndEdit)
    {
        plv->iEdit = -1;
        plv->hwndEdit = NULL;   // avoid being reentered
    }
    DestroyWindow(hwndEdit);

    // We've to recalc the region because the edit in place window has
    // added stuff to the region that we don't know how to remove
    // safely.
    ListView_RecalcRegion(plv, TRUE, TRUE);

    return fOkToContinue;
}

HWND CreateEditInPlaceWindow(HWND hwnd, LPCTSTR lpText, int cbText, LONG style, HFONT hFont)
{
    HWND hwndEdit;

    // Create the window with some nonzero size so margins work properly
    // The caller will do a SetEditInPlaceSize to set the real size
    // But make sure the width is huge so when an app calls SetWindowText,
    // USER won't try to scroll the window.
    hwndEdit = CreateWindowEx(GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_RTLREADING, 
                              TEXT("EDIT"), lpText, style,
            0, 0, 16384, 20, hwnd, NULL, HINST_THISDLL, NULL);

    if (hwndEdit) {

        Edit_LimitText(hwndEdit, cbText);

        Edit_SetSel(hwndEdit, 0, 0);    // move to the beginning

        FORWARD_WM_SETFONT(hwndEdit, hFont, FALSE, SendMessage);

    }

    return hwndEdit;
}


// in:
//      hwndEdit        edit control to position in client coords of parent window
//      prc             bonding rect of the text, used to position everthing
//      hFont           font being used
//      flags
//          SEIPS_WRAP      if this is a wrapped type (multiline) edit
//          SEIPS_NOSCROLL  if the parent control does not have scrollbars
//
//      The SEIPS_NOSCROLL flag is used only in DEBUG.  Normally, the item
//      being edited should have been scrolled into view, but if the parent
//      doesn't have scrollbars, then clearly that's not possible, so we
//      shouldn't ASSERT in that case.
//
// Notes:
//       The top-left corner of the bouding rectangle must be the position
//      the client uses to draw text. We adjust the edit field rectangle
//      appropriately.
//
void SetEditInPlaceSize(HWND hwndEdit, RECT *prc, HFONT hFont, UINT seips)
{
    RECT rc, rcClient, rcFormat;
    TCHAR szLabel[CCHLABELMAX + 1];
    int cchLabel, cxIconTextWidth;
    HDC hdc;
    HWND hwndParent = GetParent(hwndEdit);
    UINT flags;

    cchLabel = Edit_GetText(hwndEdit, szLabel, ARRAYSIZE(szLabel));
    if (szLabel[0] == 0)
    {
        lstrcpy(szLabel, c_szSpace);
        cchLabel = 1;
    }

    hdc = GetDC(hwndParent);

    SelectFont(hdc, hFont);

    cxIconTextWidth = g_cxIconSpacing - g_cxLabelMargin * 2;
    rc.left = rc.top = rc.bottom = 0;
    rc.right = cxIconTextWidth;      // for DT_LVWRAP

    // REVIEW: we might want to include DT_EDITCONTROL in our DT_LVWRAP

    if (seips & SEIPS_WRAP)
    {
        flags = DT_LVWRAP | DT_CALCRECT;
        // We only use DT_NOFULLWIDTHCHARBREAK on Korean(949) Memphis and NT5
        if (949 == g_uiACP)
            flags |= DT_NOFULLWIDTHCHARBREAK;
    }
    else
        flags = DT_LV | DT_CALCRECT;
    // If the string is NULL display a rectangle that is visible.
    DrawText(hdc, szLabel, cchLabel, &rc, flags);

    // Minimum text box size is 1/4 icon spacing size
    if (rc.right < g_cxIconSpacing / 4)
        rc.right = g_cxIconSpacing / 4;

    // position the text rect based on the text rect passed in
    // if wrapping, center the edit control around the text mid point

    OffsetRect(&rc,
        (seips & SEIPS_WRAP) ? prc->left + ((prc->right - prc->left) - (rc.right - rc.left)) / 2 : prc->left,
        (seips & SEIPS_WRAP) ? prc->top : prc->top +  ((prc->bottom - prc->top) - (rc.bottom - rc.top)) / 2 );

    // give a little space to ease the editing of this thing
    if (!(seips & SEIPS_WRAP))
        rc.right += g_cxLabelMargin * 4;
    rc.right += g_cyEdge;   // try to leave a little more for dual blanks

    ReleaseDC(hwndParent, hdc);

    GetClientRect(hwndParent, &rcClient);
    IntersectRect(&rc, &rc, &rcClient);

    //
    // Inflate it after the clipping, because it's ok to hide border.
    //
    // EM_GETRECT already takes EM_GETMARGINS into account, so don't use both.

    SendMessage(hwndEdit, EM_GETRECT, 0, (LPARAM)(LPRECT)&rcFormat);

    // Turn the margins inside-out so we can AdjustWindowRect on them.
    rcFormat.top = -rcFormat.top;
    rcFormat.left = -rcFormat.left;
    AdjustWindowRectEx(&rcFormat, GetWindowStyle(hwndEdit), FALSE,
                                  GetWindowExStyle(hwndEdit));

    InflateRect(&rc, -rcFormat.left, -rcFormat.top);

    HideCaret(hwndEdit);

    SetWindowPos(hwndEdit, NULL, rc.left, rc.top,
            rc.right - rc.left, rc.bottom - rc.top, SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS);

    CopyRect(prc, (CONST RECT *)&rc);

    InvalidateRect(hwndEdit, NULL, TRUE);

    ShowCaret(hwndEdit);
}

// draw three pixel wide border for border selection.
void ListView_DrawBorderSel(HIMAGELIST himl, HWND hwnd, HDC hdc, int x,int y, COLORREF clr)
{
    int dx, dy;
    RECT rc;
    COLORREF clrSave = SetBkColor(hdc, clr);

    ImageList_GetIconSize(himl, &dx, &dy);
    //left
    rc.left = x - 4;    // 1 pixel seperation + 3 pixel width.
    rc.top = y - 4;
    rc.right = x - 1;
    rc.bottom = y + dy + 4;
    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
    //top
    rc.left = rc.right;
    rc.right = rc.left + dx + 2;
    rc.bottom = rc.top + 3;
    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
    //right
    rc.left = rc.right;
    rc.right = rc.left + 3;
    rc.bottom = rc.top + dy + 8; // 2*3 pixel borders + 2*1 pixel seperation = 8
    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
    // bottom
    rc.top = rc.bottom - 3;
    rc.right = rc.left;
    rc.left = rc.right - dx - 2;
    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);

    SetBkColor(hdc, clrSave);
    return;
}

UINT ListView_GetTextSelectionFlags(LV* plv, LV_ITEM *pitem, UINT fDraw)
{
    UINT fText = SHDT_DESELECTED;
    // the item can have one of 4 states, for 3 looks:
    //    normal                    simple drawing
    //    selected, no focus        light image highlight, no text hi
    //    selected w/ focus         highlight image & text
    //    drop highlighting         highlight image & text

    if ((pitem->state & LVIS_DROPHILITED) || 
        (fDraw & LVDI_SELECTED && (pitem->state & LVIS_SELECTED)) )
    {
        fText = SHDT_SELECTED;
    }

    if (fDraw & LVDI_SELECTNOFOCUS && (pitem->state & LVIS_SELECTED)) 
    {
        fText = SHDT_SELECTNOFOCUS;
    }

    return fText;
}

//
//  If xMax >= 0, then the image will not be drawn past the x-coordinate
//  specified by xMax.  This is used only during report view drawing, where
//  we have to clip against our column width.
//
UINT ListView_DrawImageEx2(LV* plv, LV_ITEM* pitem, HDC hdc, int x, int y, COLORREF crBk, UINT fDraw, int xMax, int iIconEffect, int iFrame)
{
    BOOL fBorderSel = ListView_IsBorderSelect(plv);
    UINT fImage;
    COLORREF clr = 0;
    HIMAGELIST himl;
    int cxIcon;
    UINT fText = ListView_GetTextSelectionFlags(plv, pitem, fDraw);
    DWORD fState = iIconEffect;

    fImage = (pitem->state & LVIS_OVERLAYMASK);
    
    if (plv->flags & LVF_DRAGIMAGE)
    {
        fImage |= ILD_PRESERVEALPHA;
    }

    if (ListView_IsIconView(plv) || ListView_IsTileView(plv)) 
    {
        himl = plv->himl;
        cxIcon = plv->cxIcon;
    } 
    else 
    {
        himl = plv->himlSmall;
        cxIcon = plv->cxSmIcon;
    }

    if (!(plv->flags & LVF_DRAGIMAGE))
    {
        // the item can have one of 4 states, for 3 looks:
        //    normal                    simple drawing
        //    selected, no focus        light image highlight, no text hi
        //    selected w/ focus         highlight image & text
        //    drop highlighting         highlight image & text

        if ((pitem->state & LVIS_DROPHILITED) ||
            ((fDraw & LVDI_SELECTED) && (pitem->state & LVIS_SELECTED)))
        {
            fText = SHDT_SELECTED;
            if (!fBorderSel)    // do not effect color of icon on borderselect.
            {
                fImage |= ILD_BLEND50;
                clr = CLR_HILIGHT;
            }
        }

        if (pitem->state & LVIS_CUT)
        {
            fImage |= ILD_BLEND50;
            clr = plv->clrBk;
        }

        // Affects only allowed if double buffering
        if (ListView_IsDoubleBuffer(plv))
        {
            if ((pitem->state & LVIS_GLOW || (fDraw & LVDI_GLOW)) && !(fDraw & LVDI_NOEFFECTS))
            {
                crBk = CLR_NONE;
                fState |= ILS_GLOW;
            }

            if (fDraw & LVDI_SHADOW && !(fDraw & LVDI_NOEFFECTS))
            {
                crBk = CLR_NONE;
                fState |= ILS_SHADOW;
            }
        }
    }

    if (!(fDraw & LVDI_NOIMAGE))
    {
        if (himl) 
        {
            if (plv->pImgCtx || ListView_IsWatermarked(plv) || ((plv->exStyle & LVS_EX_REGIONAL) && !g_fSlowMachine))
            {
                crBk = CLR_NONE;
            }

            if (xMax >= 0)
                cxIcon = min(cxIcon, xMax - x);

            if (cxIcon > 0)
            {
                IMAGELISTDRAWPARAMS imldp;
                DWORD dwFrame = iFrame;

                imldp.cbSize = sizeof(imldp);
                imldp.himl   = himl;
                imldp.i      = pitem->iImage;
                imldp.hdcDst = hdc;
                imldp.x      = x;
                imldp.y      = y;
                imldp.cx     = CCIsHighDPI()?0:cxIcon;
                imldp.cy     = 0;
                imldp.xBitmap= 0;
                imldp.yBitmap= 0;
                imldp.rgbBk  = crBk;
                imldp.rgbFg  = clr;
                imldp.fStyle = fImage;
                imldp.fState = fState;
                imldp.Frame = dwFrame;

                if (ListView_IsDPIScaled(plv))
                    imldp.fStyle |= ILD_DPISCALE;



                ImageList_DrawIndirect(&imldp);
            }
        }

        if (plv->himlState) 
        {
            if (LV_StateImageValue(pitem) &&
                (pitem->iSubItem == 0 || plv->exStyle & LVS_EX_SUBITEMIMAGES)
                ) 
            {
                int iState = LV_StateImageIndex(pitem);
                int dyImage = 0;
                int xDraw = x - plv->cxState - LV_ICONTOSTATECX;

                // if we are not rendering checks boxes with toggle select
                // then lets render the state image the old way.

                if (ListView_IsSimpleSelect(plv) && 
                        (ListView_IsIconView(plv) || ListView_IsTileView(plv)))
                {
                    xDraw = x+cxIcon -plv->cxState; // align top right
                    dyImage = 0;
                }
                else
                {
                    if (himl)
                    {
                        if (ListView_IsIconView(plv))
                            dyImage = plv->cyIcon - plv->cyState;
                        else if (ListView_IsTileView(plv))
                            dyImage = (plv->sizeTile.cy - plv->cyState) / 2; //Center vertically
                        else // assume small icon
                            dyImage = plv->cySmIcon - plv->cyState;
                    }
                }

                cxIcon = plv->cxState;
                if (xMax >= 0)
                {
                    cxIcon = min(cxIcon, xMax - xDraw);
                }

                if (cxIcon > 0)
                {
                    IMAGELISTDRAWPARAMS imldp;

                    imldp.cbSize = sizeof(imldp);
                    imldp.himl   = plv->himlState;
                    imldp.i      = iState;
                    imldp.hdcDst = hdc;
                    imldp.x      = xDraw;
                    imldp.y      = y + dyImage;
                    imldp.cx     = CCIsHighDPI()?0:cxIcon;
                    imldp.cy     = 0;
                    imldp.xBitmap= 0;
                    imldp.yBitmap= 0;
                    imldp.rgbBk  = crBk;
                    imldp.rgbFg  = clr;
                    imldp.fStyle = fImage;
                    imldp.fState = fState;
                    imldp.Frame = 0;

                    if (ListView_IsDPIScaled(plv))
                        imldp.fStyle |= ILD_DPISCALE;

                    ImageList_DrawIndirect(&imldp);
                }
            }
        }
    }

    return fText;
}

UINT ListView_DrawImageEx(LV* plv, LV_ITEM* pitem, HDC hdc, int x, int y, COLORREF crBk, UINT fDraw, int xMax)
{
    return ListView_DrawImageEx2(plv, pitem, hdc, x, y, crBk, fDraw, xMax, ILD_NORMAL, 0);
}

#if defined(FE_IME) || !defined(WINNT)
void ListView_SizeIME(HWND hwnd)
{
    HIMC himc;
#ifdef _WIN32
    CANDIDATEFORM   candf;
#else
    CANDIDATEFORM16   candf;
#endif
    RECT rc;

    // If this subclass procedure is being called with WM_SIZE,
    // This routine sets the rectangle to an IME.

    GetClientRect(hwnd, &rc);


    // Candidate stuff
    candf.dwIndex = 0; // Bogus assumption for Japanese IME.
    candf.dwStyle = CFS_EXCLUDE;
    candf.ptCurrentPos.x = rc.left;
    candf.ptCurrentPos.y = rc.bottom;
    candf.rcArea = rc;

    if (himc=ImmGetContext(hwnd))
    {
        ImmSetCandidateWindow(himc, &candf);
        ImmReleaseContext(hwnd, himc);
    }
}

#ifndef UNICODE
LPSTR DoDBCSBoundary(LPTSTR lpsz, int *lpcchMax)
{
    int i = 0;

    while (i < *lpcchMax && *lpsz)
    {
        i++;

        if (IsDBCSLeadByte(*lpsz))
        {

            if (i >= *lpcchMax)
            {
                --i; // Wrap up without the last leadbyte.
                break;
            }

            i++;
            lpsz+= 2;
        }
        else
            lpsz++;
   }

   *lpcchMax = i;

   return lpsz;
}
#endif

void DrawCompositionLine(HWND hwnd, HDC hdc, HFONT hfont, LPTSTR lpszComp, LPBYTE lpszAttr, int ichCompStart, int ichCompEnd, int ichStart)
{
    PTSTR pszCompStr;
    int ichSt,ichEnd;
    DWORD dwPos;
    BYTE bAttr;
    HFONT hfontOld;

    int  fnPen;
    HPEN hPen;
    COLORREF crDrawText;
    COLORREF crDrawBack;
    COLORREF crOldText;
    COLORREF crOldBk;


    while (ichCompStart < ichCompEnd)
    {

        // Get the fragment to draw
        //
        // ichCompStart,ichCompEnd -- index at Edit Control
        // ichSt,ichEnd            -- index at lpszComp

        ichEnd = ichSt  = ichCompStart - ichStart;
        bAttr = lpszAttr[ichSt];

        while (ichEnd < ichCompEnd - ichStart)
        {
            if (bAttr == lpszAttr[ichEnd])
                ichEnd++;
            else
                break;
        }

        pszCompStr = (PTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(ichEnd - ichSt + 1 + 1) ); // 1 for NULL.

        if (pszCompStr)
        {
            lstrcpyn(pszCompStr, &lpszComp[ichSt], ichEnd-ichSt+1);
            pszCompStr[ichEnd-ichSt] = '\0';
        }


        // Attribute stuff
        switch (bAttr)
        {
            case ATTR_INPUT:
                fnPen = PS_DOT;
                crDrawText = g_clrWindowText;
                crDrawBack = g_clrWindow;
                break;
            case ATTR_TARGET_CONVERTED:
            case ATTR_TARGET_NOTCONVERTED:
                fnPen = PS_DOT;
                crDrawText = g_clrHighlightText;
                crDrawBack = g_clrHighlight;
                break;
            case ATTR_CONVERTED:
                fnPen = PS_SOLID;
                crDrawText = g_clrWindowText;
                crDrawBack = g_clrWindow;
                break;
        }
        crOldText = SetTextColor(hdc, crDrawText);
        crOldBk = SetBkColor(hdc, crDrawBack);

        hfontOld= SelectObject(hdc, hfont);

        // Get the start position of composition
        //
        dwPos = (DWORD) SendMessage(hwnd, EM_POSFROMCHAR, ichCompStart, 0);

        // Draw it.
        TextOut(hdc, GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos), pszCompStr, ichEnd-ichSt);
#ifndef DONT_UNDERLINE
        // Underline
        hPen = CreatePen(fnPen, 1, crDrawText);
        if( hPen ) {

            HPEN hpenOld = SelectObject( hdc, hPen );
            int iOldBk = SetBkMode( hdc, TRANSPARENT );
            SIZE size;

            GetTextExtentPoint(hdc, pszCompStr, ichEnd-ichSt, &size);

            MoveToEx( hdc, GET_X_LPARAM(dwPos), size.cy + GET_Y_LPARAM(dwPos)-1, NULL);

            LineTo( hdc, size.cx + GET_X_LPARAM(dwPos),  size.cy + GET_Y_LPARAM(dwPos)-1 );

            SetBkMode( hdc, iOldBk );

            if( hpenOld ) SelectObject( hdc, hpenOld );

            DeleteObject( hPen );
        }
#endif

        if (hfontOld)
            SelectObject(hdc, hfontOld);

        SetTextColor(hdc, crOldText);
        SetBkColor(hdc, crOldBk);

        LocalFree((HLOCAL)pszCompStr);

        //Next fragment
        //
        ichCompStart += ichEnd-ichSt;
    }
}

void ListView_InsertComposition(HWND hwnd, WPARAM wParam, LPARAM lParam, LV *plv)
{
    PSTR pszCompStr;

    int  cbComp = 0;
    int  cbCompNew;
    int  cchMax;
    int  cchText;
    DWORD dwSel;
    HIMC himc = (HIMC)0;


    // To prevent recursion..

    if (plv->flags & LVF_INSERTINGCOMP)
    {
        return;
    }
    plv->flags |= LVF_INSERTINGCOMP;

    // Don't want to redraw edit during inserting.
    //
    SendMessage(hwnd, WM_SETREDRAW, (WPARAM)FALSE, 0);

    // If we have RESULT STR, put it to EC first.

    if (himc = ImmGetContext(hwnd))
    {
#ifdef WIN32
        if (!(dwSel = PtrToUlong(GetProp(hwnd, szIMECompPos))))
            dwSel = Edit_GetSel(hwnd);

        // Becaues we don't setsel after inserting composition
        // in win32 case.
        Edit_SetSel(hwnd, GET_X_LPARAM(dwSel), GET_Y_LPARAM(dwSel));
#endif
        if (lParam&GCS_RESULTSTR)
        {
            // ImmGetCompositionString() returns length of buffer in bytes,
            // not in # of character
            cbComp = (int)ImmGetCompositionString(himc, GCS_RESULTSTR, NULL, 0);
            
            pszCompStr = (PSTR)LocalAlloc(LPTR, cbComp + sizeof(TCHAR));
            if (pszCompStr)
            {
                ImmGetCompositionString(himc, GCS_RESULTSTR, (PSTR)pszCompStr, cbComp+sizeof(TCHAR));
                
                // With ImmGetCompositionStringW, cbComp is # of bytes copied
                // character position must be calculated by cbComp / sizeof(TCHAR)
                //
                *(TCHAR *)(&pszCompStr[cbComp]) = TEXT('\0');
                Edit_ReplaceSel(hwnd, (LPTSTR)pszCompStr);
                LocalFree((HLOCAL)pszCompStr);
            }
#ifdef WIN32
            // There's no longer selection
            //
            RemoveProp(hwnd, szIMECompPos);

            // Get current cursor pos so that the subsequent composition
            // handling will do the right thing.
            //
            dwSel = Edit_GetSel(hwnd);
#endif
        }

        if (lParam & GCS_COMPSTR)
        {
            // ImmGetCompositionString() returns length of buffer in bytes,
            // not in # of character
            //
            cbComp = (int)ImmGetCompositionString(himc, GCS_COMPSTR, NULL, 0);
            pszCompStr = (PSTR)LocalAlloc(LPTR, cbComp + sizeof(TCHAR));
            if (pszCompStr)
            {
                ImmGetCompositionString(himc, GCS_COMPSTR, pszCompStr, cbComp+sizeof(TCHAR));

                // Get position of the current selection
                //
#ifndef WIN32
                dwSel  = Edit_GetSel(hwnd);
#endif
                cchMax = (int)SendMessage(hwnd, EM_GETLIMITTEXT, 0, 0);
                cchText = Edit_GetTextLength(hwnd);

                // Cut the composition string if it exceeds limit.
                //
                cbCompNew = min((UINT)cbComp,
                              sizeof(TCHAR)*(cchMax-(cchText-(HIWORD(dwSel)-LOWORD(dwSel)))));

                // wrap up the DBCS at the end of string
                //
                if (cbCompNew < cbComp)
                {
#ifndef UNICODE
                    DoDBCSBoundary((LPSTR)pszCompStr, (int *)&cbCompNew);
#endif

                    *(TCHAR *)(&pszCompStr[cbCompNew]) = TEXT('\0');

                    // Reset composition string if we cut it.
                    ImmSetCompositionString(himc, SCS_SETSTR, pszCompStr, cbCompNew, NULL, 0);
                    cbComp = cbCompNew;
                }
                
               *(TCHAR *)(&pszCompStr[cbComp]) = TEXT('\0');

               // Replace the current selection with composition string.
               //
               Edit_ReplaceSel(hwnd, (LPTSTR)pszCompStr);

               LocalFree((HLOCAL)pszCompStr);
           }

           // Mark the composition string so that we can replace it again
           // for the next time.
           //

#ifdef WIN32
           // Don't setsel to avoid flicking
           if (cbComp)
           {
               dwSel = MAKELONG(LOWORD(dwSel),LOWORD(dwSel)+cbComp/sizeof(TCHAR));
               SetProp(hwnd, szIMECompPos, IntToPtr(dwSel));
           }
           else
               RemoveProp(hwnd, szIMECompPos);
#else
           // Still use SETSEL for 16bit.
           if (cbComp)
               Edit_SetSel(hwnd, LOWORD(dwSel), LOWORD(dwSel)+cbComp);
#endif

        }

        ImmReleaseContext(hwnd, himc);
    }

    SendMessage(hwnd, WM_SETREDRAW, (WPARAM)TRUE, 0);
    //
    // We want to update the size of label edit just once at
    // each WM_IME_COMPOSITION processing. ReplaceSel causes several EN_UPDATE
    // and it causes ugly flicking too.
    //
    RedrawWindow(hwnd, NULL, NULL, RDW_INTERNALPAINT|RDW_INVALIDATE);
    SetWindowID(plv->hwndEdit, 1);
    ListView_SetEditSize(plv);

    plv->flags &= ~LVF_INSERTINGCOMP;
}

void ListView_PaintComposition(HWND hwnd, LV * plv)
{
    BYTE szCompStr[CCHLABELMAX + 1];
    BYTE szCompAttr[CCHLABELMAX + 1];

    int  cchLine, ichLineStart;
    int  cbComp = 0;
    int  cchComp;
    int  nLine;
    int  ichCompStart, ichCompEnd;
    DWORD dwSel;
    int  cchMax, cchText;
    HIMC himc = (HIMC)0;
    HDC  hdc;


    if (plv->flags & LVF_INSERTINGCOMP)
    {
        // This is the case that ImmSetCompositionString() generates
        // WM_IME_COMPOSITION. We're not ready to paint composition here.
        return;
    }

    if (himc = ImmGetContext(hwnd))
    {

        cbComp=(UINT)ImmGetCompositionString(himc, GCS_COMPSTR, szCompStr, sizeof(szCompStr));

        ImmGetCompositionString(himc, GCS_COMPATTR, szCompAttr, sizeof(szCompStr));
        ImmReleaseContext(hwnd, himc);
    }

    if (cbComp)
    {

        // Get the position of current selection
        //
#ifdef WIN32

        if (!(dwSel = PtrToUlong(GetProp(hwnd, szIMECompPos))))
            dwSel = 0L;
#else
        dwSel  = Edit_GetSel(hwnd);
#endif
        cchMax = (int)SendMessage(hwnd, EM_GETLIMITTEXT, 0, 0);
        cchText = Edit_GetTextLength(hwnd);
        cbComp = min((UINT)cbComp, sizeof(TCHAR)*(cchMax-(cchText-(HIWORD(dwSel)-LOWORD(dwSel)))));
#ifndef UNICODE
        DoDBCSBoundary((LPTSTR)szCompStr, (int *)&cbComp);
#endif
        *(TCHAR *)(&szCompStr[cbComp]) = TEXT('\0');



        /////////////////////////////////////////////////
        //                                             //
        // Draw composition string over the sel string.//
        //                                             //
        /////////////////////////////////////////////////


        hdc = GetDC(hwnd);


        ichCompStart = LOWORD(dwSel);

        cchComp = cbComp/sizeof(TCHAR);
        while (ichCompStart < (int)LOWORD(dwSel) + cchComp)
        {
            // Get line from each start pos.
            //
            nLine = Edit_LineFromChar(hwnd, ichCompStart);
            ichLineStart = Edit_LineIndex(hwnd, nLine);
            cchLine= Edit_LineLength(hwnd, ichLineStart);

            // See if composition string is longer than this line.
            //
            if(ichLineStart+cchLine > (int)LOWORD(dwSel)+cchComp)
                ichCompEnd = LOWORD(dwSel)+cchComp;
            else
            {
                // Yes, the composition string is longer.
                // Take the begining of the next line as next start.
                //
                if (ichLineStart+cchLine > ichCompStart)
                    ichCompEnd = ichLineStart+cchLine;
                else
                {
                    // If the starting position is not proceeding,
                    // let's get out of here.
                    break;
                }
            }

            // Draw the line
            //
            DrawCompositionLine(hwnd, hdc, plv->hfontLabel, (LPTSTR)szCompStr, szCompAttr, ichCompStart, ichCompEnd, LOWORD(dwSel));

            ichCompStart = ichCompEnd;
        }

        ReleaseDC(hwnd, hdc);
        // We don't want to repaint the window.
        ValidateRect(hwnd, NULL);
    }
}

#endif FE_IME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\lvsmall.c ===
// small icon view (positional view, not list)

#include "ctlspriv.h"
#include "listview.h"

int ListView_SItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem)
{

    int iHit;
    UINT flags;
    POINT pt;
    RECT rcState;
    RECT rcLabel;
    RECT rcIcon;

    if (piSubItem)
        *piSubItem = 0;

    // Map window-relative coordinates to view-relative coords...
    //
    pt.x = x + plv->ptOrigin.x;
    pt.y = y + plv->ptOrigin.y;

    // If we find an uncomputed item, recompute them all now...
    //
    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    flags = 0;

    if (ListView_IsOwnerData( plv ))
    {
        int cSlots;
        POINT ptWnd;
        LISTITEM item;
        int iWidth = 0, iHeight = 0;

        cSlots = ListView_GetSlotCount( plv, TRUE, &iWidth, &iHeight );
        iHit = ListView_CalcHitSlot( plv, pt, cSlots, iWidth, iHeight );
        ListView_SGetRectsOwnerData( plv, iHit, &rcIcon, &rcLabel, &item, FALSE );
        ptWnd.x = x;
        ptWnd.y = y;

        if (PtInRect(&rcIcon, ptWnd))
        {
            flags = LVHT_ONITEMICON;
        }
        else if (PtInRect(&rcLabel, ptWnd))
        {
            flags = LVHT_ONITEMLABEL;
        }
    }
    else
    {
        for (iHit = 0; iHit < ListView_Count(plv); iHit++)
        {
            LISTITEM* pitem = ListView_FastGetZItemPtr(plv, iHit);
            POINT ptItem;

            ptItem.x = pitem->pt.x;
            ptItem.y = pitem->pt.y;

            rcIcon.top    = ptItem.y;
            rcIcon.bottom = ptItem.y + plv->cyItem;

            rcLabel.top    = rcIcon.top;
            rcLabel.bottom = rcIcon.bottom;

            // Quick, easy rejection test...
            //
            if (pt.y < rcIcon.top || pt.y >= rcIcon.bottom)
                continue;

            rcIcon.left   = ptItem.x;
            rcIcon.right  = ptItem.x + plv->cxSmIcon;
            
            rcState.bottom = rcIcon.bottom;
            rcState.right = rcIcon.left;
            rcState.left = rcState.right - (plv->cxState + LV_ICONTOSTATEOFFSET(plv));
            rcState.top = rcState.bottom - plv->cyState;

            rcLabel.left   = rcIcon.right;
            rcLabel.right  = rcLabel.left + pitem->cxSingleLabel;

            if (PtInRect(&rcIcon, pt))
            {
                flags = LVHT_ONITEMICON;
            } else if (PtInRect(&rcLabel, pt))
            {
                flags = LVHT_ONITEMLABEL;
            } else if (PtInRect(&rcState, pt)) 
            {
                flags = LVHT_ONITEMSTATEICON;
            }
            
            if (flags)
                break;
        }
    }

    if (flags == 0)
    {
        flags = LVHT_NOWHERE;
        iHit = -1;
    }
    else
    {
      if (!ListView_IsOwnerData( plv ))
          iHit = DPA_GetPtrIndex(plv->hdpa, (void*)ListView_FastGetZItemPtr(plv, iHit));
    }

    *pflags = flags;
    return iHit;
}


void ListView_SGetRectsOwnerData( LV* plv,
        int iItem,
        RECT* prcIcon,
        RECT* prcLabel,
        LISTITEM* pitem,
        BOOL fUsepitem )
{
    RECT rcIcon;
    RECT rcLabel;
    int cSlots;

    // calculate itemx, itemy, itemsSingleLabel from iItem
    cSlots = ListView_GetSlotCount( plv, TRUE, NULL, NULL );
    pitem->iWorkArea = 0;               // OwnerData doesn't support workareas
    ListView_SetIconPos( plv, pitem, iItem, cSlots );

    // calculate lable sizes
    // Note the rect we return should be the min of the size returned and the slot size...
    ListView_IRecomputeLabelSize( plv, pitem, iItem, NULL, fUsepitem );

    rcIcon.left   = pitem->pt.x - plv->ptOrigin.x;
    rcIcon.right  = rcIcon.left + plv->cxSmIcon;
    rcIcon.top    = pitem->pt.y - plv->ptOrigin.y;
    rcIcon.bottom = rcIcon.top + plv->cyItem;
    *prcIcon = rcIcon;

    rcLabel.left   = rcIcon.right;
    if (pitem->cxSingleLabel < (plv->cxItem - plv->cxSmIcon))
        rcLabel.right  = rcLabel.left + pitem->cxSingleLabel;
    else
        rcLabel.right  = rcLabel.left + plv->cxItem - plv->cxSmIcon;
    rcLabel.top    = rcIcon.top;
    rcLabel.bottom = rcIcon.bottom;
    *prcLabel = rcLabel;
}


void ListView_SGetRects(LV* plv, LISTITEM* pitem, RECT* prcIcon, RECT* prcLabel, LPRECT prcBounds)
{

    ASSERT( !ListView_IsOwnerData( plv ));

    if (pitem->pt.x == RECOMPUTE) 
    {
        ListView_Recompute(plv);
    }

    prcIcon->left   = pitem->pt.x - plv->ptOrigin.x;
    prcIcon->right  = prcIcon->left + plv->cxSmIcon;
    prcIcon->top    = pitem->pt.y - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->cyItem;

    prcLabel->left   = prcIcon->right;
    prcLabel->right  = prcLabel->left + pitem->cxSingleLabel;
    prcLabel->top    = prcIcon->top;
    prcLabel->bottom = prcIcon->bottom;
}

// Return the index of the first item >= *pszLookup.
//
int ListView_DoLookupString(LV* plv, LPCTSTR pszLookup, UINT flags, int iStart, int j)
{
    int i;
    BOOL fExact;
    int k;
    LISTITEM* pitem;
    LISTITEM* pitemLast = NULL;

    ASSERT( !ListView_IsOwnerData( plv ));

    fExact = FALSE;
    i = iStart;
    while ((i >= iStart) && (i < j))
    {
        int result;
        k = (i + j) / 2;
        pitem = ListView_FastGetItemPtr(plv, k);
        
        if (pitem == pitemLast)
            break;
        pitemLast = pitem;
        
        result = ListView_CompareString(plv, 
                k, pszLookup, flags, 0);

#ifdef MAINWIN
        // IEUNIX - Mainwin's lstrcmp is not compatable with WIN32.
        if(result < 0)
            result = -1;
        else if(result > 0)
            result = 1;
#endif

        if (plv->ci.style & LVS_SORTDESCENDING)
            result = -result;

        switch (result)
        {
        case 0:
            fExact = TRUE;
            // fall through
        case 1:
            j = k;
            break;
        case -1:
            i = k + 1;
            break;
        }
    }
    // For substrings, return index only if exact match was found.
    //
    if (!(flags & (LVFI_SUBSTRING | LVFI_PARTIAL)) && 
        !fExact)
        return -1;

    if (i < 0)
        i = 0;
    
    if ((!(flags & LVFI_NEARESTXY)) &&
        ListView_CompareString(plv, i, pszLookup, flags, 1)) {
        i = -1;
    }
    return i;
}

int ListView_LookupString(LV* plv, LPCTSTR pszLookup, UINT flags, int iStart)
{
    int iret;
    
    if (!pszLookup)
        return 0;
    
    iret = ListView_DoLookupString(plv, pszLookup, flags, iStart, ListView_Count(plv));
    if (iret == -1 && (flags & LVFI_WRAP)) {
        iret = ListView_DoLookupString(plv, pszLookup, flags, 0, iStart);
    }
    
    return iret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\lvtile.c ===
// large icon view stuff

#include "ctlspriv.h"
#include "listview.h"
void ListView_TRecomputeLabelSizeInternal(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fUsepitem);
void ListView_TGetRectsInternal(LV* plv, LISTITEM* pitem, int i, RECT* prcIcon, RECT* prcLabel, LPRECT prcBounds);
void ListView_TGetRectsOwnerDataInternal( LV* plv, int iItem, RECT* prcIcon, RECT* prcLabel, LISTITEM* pitem, BOOL fUsepitem );
#define TILELABELRATIO 20

#define _GetStateCX(plv) \
            ((plv->himlState && !ListView_IsSimpleSelect(plv)) ? plv->cxState:0)

#define _GetStateCY(plv) \
            (plv->himlState ? plv->cyState:0)

int _CalcDesiredIconHeight(LV* plv)
{
    return max(plv->cyIcon, _GetStateCY(plv));
}

// Based on the icon height, and the number of columns showing
int _CalcDesiredTileHeight(LV* plv, LISTITEM* pitem)
{
    return 2 * g_cyIconMargin + max (_CalcDesiredIconHeight(plv), pitem->cyFoldedLabel);
}

#define    LIGHTENBYTE(percent, x) { x += (255 - x) * percent / 100;}
COLORREF GetBorderSelectColor(int iPercent, COLORREF clr)
{
    //BOOL fAllowDesaturation;
    BYTE r, g, b;

    // Doing this is less expensive than Luminance adjustment
    //fAllowDesaturation = FALSE;
    r = GetRValue(clr);
    g = GetGValue(clr);
    b = GetBValue(clr);
    // If all colors are above positive saturation, allow a desaturation
    /*if (r > 0xF0 && g > 0xF0 && b > 0xF0)
    {
        fAllowDesaturation = TRUE;
    }*/

    LIGHTENBYTE(iPercent, r);
    LIGHTENBYTE(iPercent, g);
    LIGHTENBYTE(iPercent, b);

    return RGB(r,g,b);
}

void _InitTileColumnsEnum(PLVTILECOLUMNSENUM plvtce, LV* plv, UINT cColumns, UINT *puColumns, BOOL fOneLessLine)
{
    int iSortedColumn = (plv->iLastColSort < plv->cCol) ? plv->iLastColSort : -1;

    if (cColumns == I_COLUMNSCALLBACK)
    {
        // We don't have column information yet.
        plvtce->iTotalSpecifiedColumns = 0;
        plvtce->iColumnsRemainingMax = 0;
    }
    else
    {
        int iSubtract = fOneLessLine ? 1 : 0;
        // The total number of columns that we can use in the puColumns array
        // (limited not just by cColumns, but also plv->cSubItems)
        plvtce->iTotalSpecifiedColumns = min(plv->cSubItems - iSubtract, (int)cColumns);
        // The total number of columns that we might use, including the sorted column,
        // which may or may not be included in puColumns. This is also limited
        // by plv->cSubItems
        plvtce->iColumnsRemainingMax = min(plv->cSubItems - iSubtract, (int)cColumns + ((iSortedColumn >= 0) ? 1 : 0));
    }
    plvtce->puSpecifiedColumns = puColumns;     // Array of specified columns
    plvtce->iCurrentSpecifiedColumn = 0;
    plvtce->iSortedColumn = iSortedColumn;  // Sorted column (-1 if none, 0 if name - in these cases we ignore)
    plvtce->bUsedSortedColumn = FALSE;
}

/*
 * This is just like Str_Set, but for tile columns instead of strings.
 * ppuColumns and pcColumns get set to puColumns and cColumns
 */
BOOL Tile_Set(UINT **ppuColumns, UINT *pcColumns, UINT *puColumns, UINT cColumns)
{
    if ((cColumns == I_COLUMNSCALLBACK) || (cColumns == 0) || (puColumns == NULL))
    {
        // We're setting the columns to zero, or callback
        // If there was already something there, free it.
        if ((*pcColumns != I_COLUMNSCALLBACK) && (*pcColumns != 0))
        {
            if (*ppuColumns)
                LocalFree(*ppuColumns);
        }

        *pcColumns = cColumns;
        *ppuColumns = NULL;
    }
    else
    {
        // We're providing a bunch of new columns
        UINT *puColumnsNew = *ppuColumns;

        if ((*pcColumns == I_COLUMNSCALLBACK) || (*pcColumns == 0))
            puColumnsNew = NULL; // There's nothing there to realloc.

        // Reallocate the block of columns
        puColumnsNew = CCLocalReAlloc(puColumnsNew, sizeof(UINT) * cColumns);
        if (!puColumnsNew)
            return FALSE;

        *pcColumns = cColumns;

        CopyMemory(puColumnsNew, puColumns, sizeof(UINT) * cColumns);
        *ppuColumns = puColumnsNew;
    }

    return TRUE;
}




BOOL ListView_TDrawItem(PLVDRAWITEM plvdi)
{
    RECT rcIcon;
    RECT rcLabel;
    RECT rcBounds;
    RECT rcT;
    RECT rcFocus={0};
    TCHAR ach[CCHLABELMAX];
    LV_ITEM item = {0};
    int i = (int) plvdi->nmcd.nmcd.dwItemSpec;
    int iStateImageOffset;
    LV* plv = plvdi->plv;
    LISTITEM* pitem;
    LISTITEM litem;
    UINT auColumns[CCMAX_TILE_COLUMNS];
    COLORREF clrTextBk = plvdi->nmcd.clrTextBk;

    if (ListView_IsOwnerData(plv))
    {
        // moved here to reduce call backs in OWNERDATA case
        item.iItem = i;
        item.iSubItem = 0;
        item.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE | LVIF_COLUMNS;
        item.stateMask = LVIS_ALL;
        item.pszText = ach;
        item.cchTextMax = ARRAYSIZE(ach);
        item.cColumns = ARRAYSIZE(auColumns);
        item.puColumns = auColumns;
        ListView_OnGetItem(plv, &item);

        litem.pszText = item.pszText;
        ListView_TGetRectsOwnerDataInternal(plv, i, &rcIcon, &rcLabel, &litem, TRUE);
        UnionRect(&rcBounds, &rcLabel, &rcIcon);
        pitem = NULL;
    }
    else
    {
        pitem = ListView_GetItemPtr(plv, i);
        if (pitem)
        {
            // NOTE this will do a GetItem LVIF_TEXT iff needed
            ListView_TGetRects(plv, pitem, &rcIcon, &rcLabel, &rcBounds);
        }
    }

    if (!plvdi->prcClip || IntersectRect(&rcT, &rcBounds, plvdi->prcClip))
    {
        UINT fText;

        if (!ListView_IsOwnerData(plv))
        {
            item.iItem = i;
            item.iSubItem = 0;
            item.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE | LVIF_COLUMNS;
            item.stateMask = LVIS_ALL;
            item.pszText = ach;
            item.cchTextMax = ARRAYSIZE(ach);
            item.cColumns = ARRAYSIZE(auColumns);
            item.puColumns = auColumns;
            ListView_OnGetItem(plv, &item);

            // Make sure the listview hasn't been altered during
            // the callback to get the item info

            if (pitem != ListView_GetItemPtr(plv, i))
            {
                return FALSE;
            }

            // Call this again.  The bounds may have changed - ListView_OnGetItem may have retrieved new
            // info via LVN_GETDISPINFO
            ListView_TGetRectsInternal(plv, pitem, i, &rcIcon, &rcLabel, &rcBounds);

        }

        if (plvdi->lpptOrg)
        {
            OffsetRect(&rcIcon, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
            OffsetRect(&rcLabel, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
            OffsetRect(&rcBounds, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
        }

        fText = ListView_GetTextSelectionFlags(plv, &item, plvdi->flags);

        
        plvdi->nmcd.iSubItem = 0;

        if (plv->pImgCtx || plv->hbmpWatermark)
        {
            clrTextBk = CLR_NONE;
        }
        else
        {
            if (CLR_NONE != plvdi->nmcd.clrFace)
                FillRectClr(plvdi->nmcd.nmcd.hdc, &rcBounds, plvdi->nmcd.clrFace);
        }

        iStateImageOffset = _GetStateCX(plv);

        ListView_DrawImageEx2(plv, &item, plvdi->nmcd.nmcd.hdc,
                              rcIcon.left + iStateImageOffset + g_cxLabelMargin,
                              rcIcon.top + (rcIcon.bottom - rcIcon.top - _CalcDesiredIconHeight(plv))/2,
                              plvdi->nmcd.clrFace,
                              plvdi->flags, rcLabel.right, plvdi->nmcd.iIconEffect, plvdi->nmcd.iIconPhase);

        // Don't draw label if it's being edited...
        //
        if (plv->iEdit != i)
        {
            RECT rcLine = rcLabel;
            RECT rcDummy;
            BOOL fLineWrap;
            LISTSUBITEM lsi;
            TCHAR szBuffer[CCHLABELMAX];
            rcFocus = rcLabel;

            // Apply any margins

            rcLine.left   += plv->rcTileLabelMargin.left;
            rcLine.top    += plv->rcTileLabelMargin.top;
            rcLine.right  -= plv->rcTileLabelMargin.right;
            rcLine.bottom -= plv->rcTileLabelMargin.bottom;

            // Center text lines vertically:
            rcLine.top += (rcLine.bottom - rcLine.top - (pitem ? pitem->cyFoldedLabel : litem.cyFoldedLabel))/2;
            rcFocus.top = rcLine.top;
                        
            // Make sure the text is in szBuffer
            if (szBuffer != item.pszText)
                lstrcpyn(szBuffer, item.pszText, ARRAYSIZE(szBuffer));

            // Now get the bounds of the thing.
            lsi.pszText = szBuffer;
            lsi.iImage = -1;
            lsi.state = 0;
            fLineWrap = TCalculateSubItemRect(plv, NULL, &lsi, i, 0, plvdi->nmcd.nmcd.hdc, &rcDummy, NULL);
            rcLine.bottom = rcLine.top + lsi.sizeText.cy;// + ((fLineWrap) ? lsi.sizeText.cy : 0);

            fText |= SHDT_LEFT | SHDT_CLIPPED | SHDT_NOMARGIN; // Need line wrapping, potentially, so SHDT_DRAWTEXT. Need left alignment. Need to clip to rect.

            if (plvdi->flags & LVDI_TRANSTEXT)
                fText |= SHDT_TRANSPARENT;

            if ((fText & SHDT_SELECTED) && (plvdi->flags & LVDI_HOTSELECTED))
                fText |= SHDT_HOTSELECTED;

            if (plvdi->dwCustom & LVCDRF_NOSELECT)
            {
                fText &= ~(SHDT_HOTSELECTED | SHDT_SELECTED);
            }

            if (item.pszText && (*item.pszText))
            {
                if(plv->dwExStyle & WS_EX_RTLREADING)
                    fText |= SHDT_RTLREADING;

                SHDrawText(plvdi->nmcd.nmcd.hdc, item.pszText, &rcLine, LVCFMT_LEFT, SHDT_DRAWTEXT | fText,
                           RECTHEIGHT(rcLine), plv->cxEllipses,
                           plvdi->nmcd.clrText, clrTextBk);
            }

            if (plv->cCol > 0)
            {
                int fItemText = fText;
                // Map CLR_DEFAULT to a real colorref before passing to GetSortColor.
                COLORREF clrSubItemText = GetSortColor(10,
                                              (plvdi->nmcd.clrText == CLR_DEFAULT) ? g_clrWindowText : plvdi->nmcd.clrText);
                int iSubItem;
                LVTILECOLUMNSENUM lvtce;

                
                _InitTileColumnsEnum(&lvtce, plv, item.cColumns, item.puColumns, fLineWrap);

                while (-1 != (iSubItem = _GetNextColumn(&lvtce)))
                {
                    LVITEM lvi;
                    lvi.mask = LVIF_TEXT;
                    lvi.iItem = i;
                    lvi.iSubItem = iSubItem;
                    lvi.pszText = szBuffer;
                    lvi.cchTextMax = ARRAYSIZE(szBuffer);

                    if (ListView_IsOwnerData( plv ))
                        lvi.lParam = 0L;
                    else
                        lvi.lParam = pitem->lParam;

                    if (ListView_OnGetItem(plv, &lvi))
                    {
                        if (lvi.pszText)
                        {
                            // Make sure the text is in szBuffer
                            if (szBuffer != lvi.pszText)
                                lstrcpyn(szBuffer, lvi.pszText, ARRAYSIZE(szBuffer));

                            // Now get the bounds of the thing.
                            lsi.pszText = szBuffer;
                            lsi.iImage = -1;
                            lsi.state = 0;

                            plvdi->nmcd.clrText = clrSubItemText;

                            TCalculateSubItemRect(plv, NULL, &lsi, i, iSubItem, plvdi->nmcd.nmcd.hdc, &rcDummy, NULL);

                            // Now we should have the size of the text.
                            plvdi->nmcd.iSubItem = iSubItem;

                            CICustomDrawNotify(&plvdi->plv->ci, CDDS_SUBITEM | CDDS_ITEMPREPAINT, &plvdi->nmcd.nmcd);

                            if (lsi.pszText != NULL && *lsi.pszText != 0)
                            {
                                rcLine.top = rcLine.bottom;
                                rcLine.bottom = rcLine.top + lsi.sizeText.cy;

                                SHDrawText(plvdi->nmcd.nmcd.hdc, lsi.pszText, &rcLine, LVCFMT_LEFT, fItemText | SHDT_ELLIPSES,
                                           RECTHEIGHT(rcLine), plv->cxEllipses,
                                           plvdi->nmcd.clrText, clrTextBk);
                            }
                        }
                    }
                }
            }

            rcFocus.bottom = rcLine.bottom;
        }

        if ((plvdi->flags & LVDI_FOCUS) &&
            (item.state & LVIS_FOCUSED) &&
            !(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS))
        {
            rcFocus.top -= g_cyCompensateInternalLeading;
            rcFocus.bottom += g_cyCompensateInternalLeading;
            DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcFocus);
        }
    }

    return TRUE;
}

int ListView_TItemHitTest(LV* plv, int x, int y, UINT* pflags, int *piSubItem)
{
    int iHit;
    UINT flags;
    POINT pt;
    RECT rcLabel;
    RECT rcIcon;
    int iStateImageOffset = 0;

    if (piSubItem)
        *piSubItem = 0;

    // Map window-relative coordinates to view-relative coords...
    //
    pt.x = x + plv->ptOrigin.x;
    pt.y = y + plv->ptOrigin.y;

    // If there are any uncomputed items, recompute them now.
    //
    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    flags = 0;

    if (ListView_IsOwnerData( plv ))
    {
        int cSlots;
        POINT ptWnd;
        LISTITEM item;
        int iWidth = 0, iHeight = 0;

        cSlots = ListView_GetSlotCount( plv, TRUE, &iWidth, &iHeight );
        iHit = ListView_CalcHitSlot( plv, pt, cSlots, iWidth, iHeight );
        if (iHit < ListView_Count(plv))
        {
            ListView_TGetRectsOwnerDataInternal( plv, iHit, &rcIcon, &rcLabel, &item, FALSE );
            ptWnd.x = x;
            ptWnd.y = y;
            if (PtInRect(&rcIcon, ptWnd))
            {
                flags = LVHT_ONITEMICON;
            }
            else if (PtInRect(&rcLabel, ptWnd))
            {
                flags = LVHT_ONITEMLABEL;
            }
        }
    }
    else
    {
        iStateImageOffset = _GetStateCX(plv);

        for (iHit = 0; (iHit < ListView_Count(plv)); iHit++)
        {
            LISTITEM* pitem = ListView_FastGetZItemPtr(plv, iHit);
            POINT ptItem;

            ptItem.x = pitem->pt.x;
            ptItem.y = pitem->pt.y;

            rcIcon.left   = ptItem.x;
            rcIcon.right  = rcIcon.left + plv->cxIcon + 3 * g_cxLabelMargin + iStateImageOffset;
            rcIcon.top    = pitem->pt.y;
            rcIcon.bottom = rcIcon.top + plv->sizeTile.cy - 2 * g_cyIconMargin;

            rcLabel.left   = rcIcon.right;
            if (pitem->cyUnfoldedLabel != SRECOMPUTE)
            {
                rcLabel.right = rcLabel.left + pitem->cxSingleLabel;
            }
            else
            {
                rcLabel.right  = rcLabel.left + plv->sizeTile.cx - RECTWIDTH(rcIcon) - 2 * g_cxLabelMargin;
            }
            rcLabel.top    = rcIcon.top;
            rcLabel.bottom = rcIcon.bottom;

            // Max out bottoms
            rcLabel.bottom = rcIcon.bottom = max(rcIcon.bottom, rcLabel.bottom);

            if (PtInRect(&rcIcon, pt))
            {
                flags = LVHT_ONITEMICON;
            }
            else if (PtInRect(&rcLabel, pt))
            {
                flags = LVHT_ONITEMLABEL;
            }
        
            if (flags)
                break;
        }
    }

    if (flags == 0)
    {
        flags = LVHT_NOWHERE;
        iHit = -1;
    }
    else
    {
        if (!ListView_IsOwnerData( plv ))
        {
            iHit = DPA_GetPtrIndex(plv->hdpa, ListView_FastGetZItemPtr(plv, iHit));
        }
    }

    *pflags = flags;
    return iHit;
}

// out:
//      prcIcon         icon bounds including icon margin area
void ListView_TGetRects(LV* plv, LISTITEM* pitem, RECT* prcIcon, RECT* prcLabel, LPRECT prcBounds)
{
    RECT rcIcon;
    RECT rcLabel;
    int iStateImageOffset = 0;

    if (!prcLabel)
        prcLabel = &rcLabel;

    if (!prcIcon)
        prcIcon = &rcIcon;

    if (pitem->pt.x == RECOMPUTE) 
    {
        ListView_Recompute(plv);
    }

    if (pitem->pt.x == RECOMPUTE)
    {
        RECT rcZero = {0};
        *prcIcon = *prcLabel = rcZero;
        return;
    }

    iStateImageOffset = _GetStateCX(plv);

    prcIcon->left = pitem->pt.x - plv->ptOrigin.x;
    prcIcon->right = prcIcon->left + plv->cxIcon + 3 * g_cxLabelMargin + iStateImageOffset;
    prcIcon->top = pitem->pt.y - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->sizeTile.cy - 2 * g_cyIconMargin;

    prcLabel->left = prcIcon->right;
    prcLabel->right = pitem->pt.x - plv->ptOrigin.x + plv->sizeTile.cx - 2 * g_cxLabelMargin; //2 in tile, 1 on right. pitem->pt.x takes care of left margin
    prcLabel->top = prcIcon->top;
    prcLabel->bottom = prcIcon->bottom;

    if (prcBounds)
    {
        UnionRect(prcBounds, prcLabel, prcIcon);
    }
}


void ListView_TGetRectsOwnerData( LV* plv,
        int iItem,
        RECT* prcIcon,
        RECT* prcLabel,
        LISTITEM* pitem,
        BOOL fUsepitem )
{
    int cSlots;
    RECT rcIcon;
    RECT rcLabel;
    int iStateImageOffset = 0;

    if (!prcLabel)
        prcLabel = &rcLabel;

    if (!prcIcon)
        prcIcon = &rcIcon;

    // calculate x, y from iItem
    cSlots = ListView_GetSlotCount( plv, TRUE, NULL, NULL );
    pitem->iWorkArea = 0;               // OwnerData doesn't support workareas
    ListView_SetIconPos( plv, pitem, iItem, cSlots );
    
    // What else can we do?
    pitem->cColumns = 0;
    pitem->puColumns = NULL;
    // End What else can we do?

    iStateImageOffset = _GetStateCX(plv);

    prcIcon->left   = pitem->pt.x - plv->ptOrigin.x;
    prcIcon->right  = prcIcon->left + plv->cxIcon + 3 * g_cxLabelMargin + iStateImageOffset;
    prcIcon->top    = pitem->pt.y - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->sizeTile.cy - 2 * g_cyIconMargin;

    prcLabel->left   = prcIcon->right;
    prcLabel->right  = pitem->pt.x - plv->ptOrigin.x + plv->sizeTile.cx - 2 * g_cxLabelMargin;
    prcLabel->top    = prcIcon->top;
    prcLabel->bottom = prcIcon->bottom;
}

// out:
//      prcIcon         icon bounds including icon margin area
void ListView_TGetRectsInternal(LV* plv, LISTITEM* pitem, int i, RECT* prcIcon, RECT* prcLabel, LPRECT prcBounds)
{
    RECT rcIcon;
    RECT rcLabel;
    int iStateImageOffset = 0;

    if (!prcLabel)
        prcLabel = &rcLabel;

    if (!prcIcon)
        prcIcon = &rcIcon;

    if (pitem->pt.x == RECOMPUTE) 
    {
        ListView_Recompute(plv);
    }

    if (pitem->pt.x == RECOMPUTE)
    {
        RECT rcZero = {0};
        *prcIcon = *prcLabel = rcZero;
        return;
    }

    if (pitem->cyUnfoldedLabel == SRECOMPUTE)
    {
        ListView_TRecomputeLabelSizeInternal(plv, pitem, i, NULL, FALSE);
    }

    iStateImageOffset = _GetStateCX(plv);

    prcIcon->left = pitem->pt.x - plv->ptOrigin.x;
    prcIcon->right = prcIcon->left + plv->cxIcon + 3 * g_cxLabelMargin + iStateImageOffset;
    prcIcon->top = pitem->pt.y - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->sizeTile.cy - 2 * g_cyIconMargin;

    prcLabel->left = prcIcon->right;

    if (ListView_FullRowSelect(plv)) // full-row-select means full-tile-select
    {
        prcLabel->right = pitem->pt.x - plv->ptOrigin.x + plv->sizeTile.cx - 2 * g_cxLabelMargin; //2 in tile, 1 on right. pitem->pt.x takes care of left margin
    }
    else
    {
        prcLabel->right = prcLabel->left + pitem->cxSingleLabel;
    }
    prcLabel->top = prcIcon->top;
    prcLabel->bottom = prcIcon->bottom;

    if (prcBounds)
    {
        UnionRect(prcBounds, prcLabel, prcIcon);
    }
}


void ListView_TGetRectsOwnerDataInternal( LV* plv,
        int iItem,
        RECT* prcIcon,
        RECT* prcLabel,
        LISTITEM* pitem,
        BOOL fUsepitem )
{
    int cSlots;
    RECT rcIcon;
    RECT rcLabel;
    int iStateImageOffset = 0;

    if (!prcLabel)
        prcLabel = &rcLabel;

    if (!prcIcon)
        prcIcon = &rcIcon;

    // calculate x, y from iItem
    cSlots = ListView_GetSlotCount( plv, TRUE, NULL, NULL );
    pitem->iWorkArea = 0;               // OwnerData doesn't support workareas
    ListView_SetIconPos( plv, pitem, iItem, cSlots );
    
    // What else can we do?
    pitem->cColumns = 0;
    pitem->puColumns = NULL;
    // End What else can we do?

    // calculate lable sizes from iItem
    ListView_TRecomputeLabelSizeInternal( plv, pitem, iItem, NULL, fUsepitem);

    iStateImageOffset = _GetStateCX(plv);

    prcIcon->left   = pitem->pt.x - plv->ptOrigin.x;
    prcIcon->right  = prcIcon->left + plv->cxIcon + 3 * g_cxLabelMargin + iStateImageOffset;
    prcIcon->top    = pitem->pt.y - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->sizeTile.cy - 2 * g_cyIconMargin;

    prcLabel->left   = prcIcon->right;
    prcLabel->right  = pitem->pt.x - plv->ptOrigin.x + plv->sizeTile.cx - 2 * g_cxLabelMargin;
    prcLabel->top    = prcIcon->top;
    prcLabel->bottom = prcIcon->bottom;
}

            // Note: still need to add rcTileLabelMargin to this diagram

            //g_cxLabelMargin                           g_cxLabelMargin                                     g_cxLabelMargin
            // __|__ __|___                               __|__ __|___                                         __|__ __|__
            //|     |      |                             |     |      |                                       |     |     |
            //      *************************************************************************************************
            //      *     *   ^                          *     *      *                                       *     *
            //      *     *   |-- cyIconMargin           *     *      *                                       *     *
            //      *     *   v                          *     *      *                                       *     *
            //      *     ********************************     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *           Icon               *     *      *                                       *     *
            //      *     *   Width: plv->cxIcon +       *     *      *                                       *     *
            //      *     *          plv->cxState        *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *   Height: max(plv->cyIcon,   *     *      *            Space left for label       *     *
            //      *     *               plv->cyState)  *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     *                              *     *      *                                       *     *
            //      *     ********************************     *      *                                       *     *
            //      *     *   ^                          *     *      *                                       *     *
            //      *     *   |-- cyIconMargin           *     *      *                                       *     *
            //      *     *   v                          *     *      *                                       *     *
            //      *************************************************************************************************
            //
            // The top and bottom margins of the tile are plv->cyIconMargin, the left and right are plv->cxLabelMargin
            // (as shown in the diagram)


// Returns TRUE when iSubItem == 0, and the text wraps to a second line. FALSE otherwise.
// When the return value is TRUE, the height returned in pitem->rcTxtRgn/plsi->sizeText is the height of two lines.
BOOL TCalculateSubItemRect(LV* plv, LISTITEM *pitem, LISTSUBITEM* plsi, int i, int iSubItem, HDC hdc, RECT* prc, BOOL *pbUnfolded)
{
    TCHAR szLabel[CCHLABELMAX + 4];
    RECT rcSubItem = {0};
    LVFAKEDRAW lvfd;
    LV_ITEM item;
    BOOL fLineWrap = FALSE;
    int cchLabel;

    if (pbUnfolded)
    {
        *pbUnfolded = TRUE;
    }

    // the following will use the passed in pitem text instead of calling
    // GetItem.  This would be two consecutive calls otherwise, in some cases.
    //
    if (pitem && (pitem->pszText != LPSTR_TEXTCALLBACK))
    {
        Str_GetPtr0(pitem->pszText, szLabel, ARRAYSIZE(szLabel));
        item.lParam = pitem->lParam;
    }
    else if (plsi && (plsi->pszText != LPSTR_TEXTCALLBACK))
    {
        Str_GetPtr0(plsi->pszText, szLabel, ARRAYSIZE(szLabel));
    }
    else
    {
        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = i;
        item.iSubItem = iSubItem;
        item.pszText = szLabel;
        item.cchTextMax = ARRAYSIZE(szLabel);
        item.stateMask = 0;
        szLabel[0] = TEXT('\0');    // In case the OnGetItem fails
        ListView_OnGetItem(plv, &item);

        if (!item.pszText)
        {
            SetRectEmpty(&rcSubItem);
            goto Exit;
        }

        if (item.pszText != szLabel)
            lstrcpyn(szLabel, item.pszText, ARRAYSIZE(szLabel));
    }

    cchLabel = lstrlen(szLabel);

    if (cchLabel > 0)
    {
        int cxRoomForLabel = plv->sizeTile.cx
                             - 5 * g_cxLabelMargin
                             - plv->cxIcon
                             - _GetStateCX(plv)
                             - plv->rcTileLabelMargin.left
                             - plv->rcTileLabelMargin.right;
        int align;
        if (hdc) 
        {
            lvfd.nmcd.nmcd.hdc = hdc;           // Use the one the app gave us
        }
        else
        {                             // Set up fake customdraw
            ListView_BeginFakeCustomDraw(plv, &lvfd, &item);
            lvfd.nmcd.nmcd.dwItemSpec = i;
            lvfd.nmcd.iSubItem = iSubItem;
            CIFakeCustomDrawNotify(&plv->ci, CDDS_ITEMPREPAINT | ((iSubItem != 0)?CDDS_SUBITEM:0), &lvfd.nmcd.nmcd);
        } 

        if (plv->dwExStyle & WS_EX_RTLREADING)
        {
            align = GetTextAlign(lvfd.nmcd.nmcd.hdc);
            SetTextAlign(lvfd.nmcd.nmcd.hdc, align | TA_RTLREADING);
        }

        DrawText(lvfd.nmcd.nmcd.hdc, szLabel, cchLabel, &rcSubItem, (DT_LV | DT_CALCRECT));

        if ((iSubItem == 0) && (plv->cSubItems > 0))
        {
            // Sub Item zero can wrap to two lines (but only if there is room for a second line, i.e. if
            // cSubItems > 0. We need to pass this information (that we wrapped to a second
            // line, in addition to passing the rect height back) to the caller. The way we determine if we have
            // wrapped to a second line, is to call DrawText a second time with word wrapping enabled, and see if the
            // RECTHEIGHT is bigger.

            RECT rcSubItemWrapped = {0};
            LONG lLineHeight = RECTHEIGHT(rcSubItem);

            rcSubItemWrapped.right = cxRoomForLabel;

            DrawText(lvfd.nmcd.nmcd.hdc, szLabel, cchLabel, &rcSubItemWrapped, (DT_LVTILEWRAP | DT_CALCRECT | DT_WORD_ELLIPSIS));

            if (RECTHEIGHT(rcSubItemWrapped) > RECTHEIGHT(rcSubItem))
            {
                // We wrapped to multiple lines.
                fLineWrap = TRUE;

                // Don't let us go past two lines.
                if (RECTHEIGHT(rcSubItemWrapped) > 2 * RECTHEIGHT(rcSubItem))
                    rcSubItemWrapped.bottom = rcSubItemWrapped.top + 2 * RECTHEIGHT(rcSubItem);

                rcSubItem = rcSubItemWrapped;
            }

            // Did we asked if we're folded?
            if (pbUnfolded)
            {
                // We need to call draw text again - this time without DT_WORD_ELLIPSES - 
                // to determine if anything was actually truncated.
                RECT rcSubItemWrappedNoEllipse = {0};
                int cLines = fLineWrap ? 2 : 1;
                rcSubItemWrappedNoEllipse.right = cxRoomForLabel;

                DrawText(lvfd.nmcd.nmcd.hdc, szLabel, cchLabel, &rcSubItemWrappedNoEllipse, (DT_LVTILEWRAP | DT_CALCRECT));

                if (RECTHEIGHT(rcSubItemWrappedNoEllipse) > (cLines * lLineHeight))
                {
                    *pbUnfolded = FALSE;  // We're going to draw truncated.
                }
            }
        }
        else if (pbUnfolded)
        {
            // Are we truncated?
            *pbUnfolded = (RECTWIDTH(rcSubItem) <= cxRoomForLabel);
        }

        if (plv->dwExStyle & WS_EX_RTLREADING)
        {
            SetTextAlign(lvfd.nmcd.nmcd.hdc, align);
        }


        // rcSubItem was calculated w/o margins. Now add in margins.
        rcSubItem.left -= plv->rcTileLabelMargin.left;
        rcSubItem.right += plv->rcTileLabelMargin.right;
        // Top and bottom margins are left for the whole label - don't need to be applied here.

        if (!hdc) 
        {                             // Clean up fake customdraw
            CIFakeCustomDrawNotify(&plv->ci, CDDS_ITEMPOSTPAINT | ((iSubItem != 0)?CDDS_SUBITEM:0), &lvfd.nmcd.nmcd);
            ListView_EndFakeCustomDraw(&lvfd);
        }

    }
    else
    {
        SetRectEmpty(&rcSubItem);
    }

Exit:


    if (pitem)
    {
        pitem->rcTextRgn = rcSubItem;
    }
    else if (plsi)
    {
        plsi->sizeText.cx = RECTWIDTH(rcSubItem);
        plsi->sizeText.cy = RECTHEIGHT(rcSubItem);
    }

    if (prc)
    {
        if (rcSubItem.left < prc->left)
            prc->left = rcSubItem.left;

        if (rcSubItem.right > prc->right)
            prc->right = rcSubItem.right;

        prc->bottom += RECTHEIGHT(rcSubItem);
    }

    return fLineWrap;
}


void ListView_TRecomputeLabelSize(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fUsepitem)
{
    if (pitem)
    {
        pitem->cxSingleLabel = 0;
        pitem->cxMultiLabel = 0;
        pitem->cyFoldedLabel = 0;
        pitem->cyUnfoldedLabel = SRECOMPUTE;
    }
}

void ListView_TRecomputeLabelSizeInternal(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fUsepitem)
{
    RECT rcTotal = {0};
    LONG iLastBottom;
    LONG iLastDifference = 0; // last line's height
    BOOL fLineWrap; // Does the first line of the label wrap to the second?
    int iLabelLines = plv->cSubItems; // listview-wide number of lines per tile.
    LV_ITEM item; // What to use if pitem is not to be used.
    UINT cColumns = 0;
    UINT rguColumns[CCMAX_TILE_COLUMNS] = {0};
    UINT *puColumns = rguColumns;

    // Determine the number of columns to show
    if (fUsepitem && (pitem->cColumns != I_COLUMNSCALLBACK))
    {
        cColumns = pitem->cColumns;
        puColumns = pitem->puColumns;
    }
    else
    {
        item.mask = LVIF_COLUMNS;
        item.iItem = i;
        item.iSubItem = 0;
        item.stateMask = 0;
        item.cColumns = ARRAYSIZE(rguColumns);
        item.puColumns = rguColumns;

        if (ListView_OnGetItem(plv, &item))
        {
            cColumns = item.cColumns;  // and puColumns = rguColumns
        }
    }

    iLastBottom = rcTotal.bottom;

    // The text of the item is determined in TCalculateSubItemRect.
    fLineWrap = TCalculateSubItemRect(plv, (fUsepitem ? pitem : NULL), NULL, i, 0, hdc, &rcTotal, NULL);
    iLastDifference = rcTotal.bottom - iLastBottom;
    if (fLineWrap)
    {
        iLabelLines--; // One less line for subitems.
        // iLastDifference should represent a single line... in this case, it represents two lines. Chop it in half.
        iLastDifference /= 2;
    }

    if (plv->cCol > 0)
    {
        int iSubItem;
        LVTILECOLUMNSENUM lvtce;
        _InitTileColumnsEnum(&lvtce, plv, cColumns, puColumns, fLineWrap);
        
        while (-1 != (iSubItem = _GetNextColumn(&lvtce)))
        {
            LISTSUBITEM* plsi;

            HDPA hdpa = ListView_IsOwnerData(plv) ? ListView_GetSubItemDPA(plv, iSubItem - 1) : NULL;
            
            if (hdpa) 
                plsi = DPA_GetPtr(hdpa, i);
            else
                plsi = NULL;

            iLastBottom = rcTotal.bottom;
            TCalculateSubItemRect(plv, NULL, plsi, i, iSubItem, hdc, &rcTotal, NULL);
            iLabelLines--;
        }
    }

    // Add the top and bottom margins to rcTotal.  Doesn't matter whether they're added to top or bottom,
    // since we only consider RECTHEIGHT
    rcTotal.bottom += (plv->rcTileLabelMargin.top + plv->rcTileLabelMargin.bottom);

    if (pitem) 
    {
        int iStateImageOffset = _GetStateCX(plv);
        int cx = (plv->sizeTile.cx - 5 * g_cxLabelMargin - iStateImageOffset - plv->cxIcon);
        if (ListView_FullRowSelect(plv)) // full-row-select means full-tile-select
        {
            pitem->cxSingleLabel = pitem->cxMultiLabel = (short) cx;
        }
        else
        {

            if (cx > RECTWIDTH(rcTotal))
                cx = RECTWIDTH(rcTotal);
                
            pitem->cxSingleLabel = pitem->cxMultiLabel = (short) cx;
        }
        pitem->cyFoldedLabel = pitem->cyUnfoldedLabel = (short)RECTHEIGHT(rcTotal);
    }
}



/**
 * This function calculates the tilesize for listview, based on the following:
 * 1) Leave room for margins and padding
 * 2) Take into account imagelist and stateimage list.
 * 3) For the label portion, take into account
 *    a) The number of tile columns (plv->cSubItems)
 *    b) The height and width of a typical letter (leave space for 20 m's?)
 */
void ListView_RecalcTileSize(LV* plv)
{
    RECT rcItem = {0};
    int cLines;

    LVFAKEDRAW lvfd;
    LV_ITEM lvitem;
    
    if (plv->dwTileFlags == (LVTVIF_FIXEDHEIGHT | LVTVIF_FIXEDWIDTH))
        return; // Nothing to do.

    ListView_BeginFakeCustomDraw(plv, &lvfd, &lvitem);

    DrawText(lvfd.nmcd.nmcd.hdc, TEXT("m"), 1, &rcItem, (DT_LV | DT_CALCRECT));

    // REVIEW: Custom draw functionality needs to be tested.
    ListView_EndFakeCustomDraw(&lvfd);

    cLines = plv->cSubItems + 1; // +1 because cSubItems doesn't include the main label.

    if (!(plv->dwTileFlags & LVTVIF_FIXEDWIDTH))
    {
        // Here, we are attempting to determine a valid width for the tile, by assuming a typical number
        // of chars... and the size is based on TILELABELRATIO * the width of the letter 'm' in the current font.
        // This sucks. Without a genuine layout engine though, it is a difficult task. Other options include basing
        // the tile width on:
        //  1) some fraction of the client width
        //  2) the longest label we've got (like the LIST view currently does - this sucks)
        //  3) the height (via some ratio)
        // After some experimentation, TILELABELRATIO seems to look alright. (Note that a client can always
        // set tiles to be an explicit size too.)
        plv->sizeTile.cx = 4 * g_cxLabelMargin +
                           _GetStateCX(plv) +
                           plv->cxIcon +
                           plv->rcTileLabelMargin.left +
                           RECTWIDTH(rcItem) * TILELABELRATIO +
                           plv->rcTileLabelMargin.right;
    }
    
    if (!(plv->dwTileFlags & LVTVIF_FIXEDHEIGHT))
    {
        int cyIcon = max(_GetStateCY(plv), plv->cyIcon);
        int cyText = plv->rcTileLabelMargin.top +
                     RECTHEIGHT(rcItem) * cLines +
                     plv->rcTileLabelMargin.bottom;
        plv->sizeTile.cy = 4 * g_cyIconMargin + max(cyIcon, cyText);
    }

}


/**
 * This gets the next tile column base on the LVTILECOLUMNSENUM struct.
 * We don't just directly use the column information in LVITEM/LISTITEM structs,
 * because we want to take the current sorted column into account. That column
 * automatically gets prepended to the columns that are displayed for each item.
 */
int _GetNextColumn(PLVTILECOLUMNSENUM plvtce)
{
    if (plvtce->iColumnsRemainingMax > 0)
    {
        plvtce->iColumnsRemainingMax--;
        if (plvtce->bUsedSortedColumn || (plvtce->iSortedColumn <= 0))
        {
            // We've already used the sorted column, or we've got no sorted column
            int iColumn;
            do
            {
                if (plvtce->iCurrentSpecifiedColumn >= plvtce->iTotalSpecifiedColumns)
                    return -1;

                iColumn = plvtce->puSpecifiedColumns[plvtce->iCurrentSpecifiedColumn];
                plvtce->iCurrentSpecifiedColumn++;
            } while (iColumn == plvtce->iSortedColumn);
            return iColumn;
        }
        else
        {
            // We have a sorted column, and it has not been used - return it!
            plvtce->bUsedSortedColumn = TRUE;
            return plvtce->iSortedColumn;
        }
    }    
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\listview.c ===
#include "ctlspriv.h"
#include "listview.h"
#include "image.h"
#include <mlang.h>
#include <inetreg.h>
#include "uxthemep.h"

#define __IOleControl_INTERFACE_DEFINED__       // There is a conflict with the IOleControl's def of CONTROLINFO
#include "shlobj.h"

#ifdef FULL_DEBUG
#define LISTVIEW_VFX_DEFAULT TRUE
#else
#define LISTVIEW_VFX_DEFAULT FALSE
#endif

int  LV_GetNewColWidth(LV* plv, int iFirst, int iLast);
void ListView_RecalcTileSize(LV* plv);
int  ListView_ComputeCXItemSize(LV* plv);

#define IE_SETTINGS          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")
#define USE_DBL_CLICK_TIMER  TEXT("UseDoubleClickTimer")

int g_bUseDblClickTimer;

#define LVMP_WINDOWPOSCHANGED (WM_USER + 1)
HRESULT WINAPI UninitializeFlatSB(HWND hwnd);

// the insert mark is 6 pixels wide
#define INSERTMARKSIZE      6
#define GROUPHEADER_PADDING 6
#define GRADIENT_WIDTH      300

#define COLORISLIGHT(clr) ((5*GetGValue((clr)) + 2*GetRValue((clr)) + GetBValue((clr))) > 8*128)

void ListView_HandleMouse(LV* plv, BOOL fDoubleClick, int x, int y, UINT keyFlags, BOOL bMouseWheel);

/// function table setup
const PFNLISTVIEW_DRAWITEM pfnListView_DrawItem[5] = 
{
    ListView_IDrawItem,
    ListView_RDrawItem,
    ListView_IDrawItem,
    ListView_LDrawItem,
    ListView_TDrawItem,
};

void ListView_HandleStateIconClick(LV* plv, int iItem);

DWORD ListView_IApproximateViewRect(LV* ,int, int, int);
DWORD ListView_RApproximateViewRect(LV* ,int, int, int);
DWORD ListView_LApproximateViewRect(LV* ,int, int, int);

const PFNLISTVIEW_APPROXIMATEVIEWRECT pfnListView_ApproximateViewRect[5] = 
{
    ListView_IApproximateViewRect,
    ListView_RApproximateViewRect,
    ListView_IApproximateViewRect,
    ListView_LApproximateViewRect,
    ListView_IApproximateViewRect,
};

const PFNLISTVIEW_UPDATESCROLLBARS pfnListView_UpdateScrollBars[5] = 
{
    ListView_IUpdateScrollBars,
    ListView_RUpdateScrollBars,
    ListView_IUpdateScrollBars,
    ListView_LUpdateScrollBars,
    ListView_IUpdateScrollBars,
};

const PFNLISTVIEW_ITEMHITTEST pfnListView_ItemHitTest[5] = 
{
    ListView_IItemHitTest,
    ListView_RItemHitTest,
    ListView_SItemHitTest,
    ListView_LItemHitTest,
    ListView_TItemHitTest,
};

const PFNLISTVIEW_ONSCROLL pfnListView_OnScroll[5] = 
{
    ListView_IOnScroll,
    ListView_ROnScroll,
    ListView_IOnScroll,
    ListView_LOnScroll,
    ListView_IOnScroll,
};

const PFNLISTVIEW_SCROLL2 pfnListView_Scroll2[5] = 
{
    ListView_IScroll2,
    ListView_RScroll2,
    ListView_IScroll2,
    ListView_LScroll2,
    ListView_IScroll2,
};

const PFNLISTVIEW_GETSCROLLUNITSPERLINE pfnListView_GetScrollUnitsPerLine[5] = 
{
    ListView_IGetScrollUnitsPerLine,
    ListView_RGetScrollUnitsPerLine,
    ListView_IGetScrollUnitsPerLine,
    ListView_LGetScrollUnitsPerLine,
    ListView_IGetScrollUnitsPerLine,
};

void ListView_NULLRecomputeLabelSize(LV* plv, LISTITEM* pitem, int i, HDC hdc, BOOL fusepitem)
{
    // Report and List view don't need a recompute
}

const PFNLISTVIEW_RECOMPUTELABELSIZE pfnListView_RecomputeLabelSize[5] = 
{
    ListView_IRecomputeLabelSize,
    ListView_IRecomputeLabelSize,
    ListView_IRecomputeLabelSize,
    ListView_IRecomputeLabelSize,
    ListView_TRecomputeLabelSize,
};

BOOL ListView_NULLRecomputeEx(LV* plv, HDPA hdpaSort, int iFrom, BOOL fForce)
{
    return FALSE;
}

const PFNLISTVIEW_RECOMPUTEEX pfnListView_RecomputeEx[5] = 
{
    ListView_IRecomputeEx,
    ListView_RRecomputeEx,
    ListView_IRecomputeEx,
    ListView_NULLRecomputeEx,
    ListView_IRecomputeEx,
};

#ifdef DEBUG_PAINT
void ListView_DebugDrawInvalidRegion(LV* plv, RECT* prc, HRGN hrgn)
{
    HDC hdc;
    HBRUSH hbrush;
    int bkMode;
    static int s_iclr;
    static COLORREF s_aclr[] =
    {
            RGB(255, 0, 0), RGB(0, 255, 0),
            RGB(255, 255, 0), RGB(0, 255, 255),
    };

    s_iclr = (s_iclr + 1) % ARRAYSIZE(s_aclr);
    hdc = GetDC(plv->ci.hwnd);
    hbrush = CreateHatchBrush(HS_DIAGCROSS, s_aclr[s_iclr]);
    bkMode = SetBkMode(hdc, TRANSPARENT);
    if (prc)
    {
        FillRect(hdc, prc, hbrush);
    }
    else if (hrgn)
    {
        FillRgn(hdc, hrgn, hbrush);
    }
    DeleteObject((HGDIOBJ)hbrush);
    SetBkMode(hdc, bkMode);
    ReleaseDC(plv->ci.hwnd, hdc);
    Sleep(120);
}

BOOL ListView_DebugDrawInvalidItem(LV* plv, int iItem)
{
    RECT rcLabel;
    RECT rcIcon;
    ListView_GetRects(plv, iItem, QUERY_DEFAULT,
        &rcIcon, &rcLabel, NULL, NULL);
    ListView_DebugDrawInvalidRegion(plv, &rcIcon, NULL);
    ListView_DebugDrawInvalidRegion(plv, &rcLabel, NULL);
    return TRUE;

}


void ListView_DebugDisplayClipRegion(LV* plv, RECT* prc, HRGN hrgn)
{
    HDC hdc = GetDC(plv->ci.hwnd);
    if (prc)
    {
        InvertRect(hdc, prc);
    }
    else if (hrgn)
    {
        InvertRgn(hdc, hrgn);
    }

    Sleep(120);

    if (prc)
    {
        InvertRect(hdc, prc);
    }
    else if (hrgn)
    {
        InvertRgn(hdc, hrgn);
    }

    ReleaseDC(plv->ci.hwnd, hdc);
}
#else
#define ListView_DebugDrawInvalidItem(plv, iItem) FALSE
#endif

// redefine to trace at most calls to ListView_SendChange
#define DM_LVSENDCHANGE 0


// penwin.h is messed up; define local stuff for now
#define HN_BEGINDIALOG        40    // Lens/EditText/garbage detection dialog is about
                                    // to come up on this hedit/bedit
#define HN_ENDDIALOG          41    // Lens/EditText/garbage detection dialog has
                                    // just been destroyed

//---------------------------------------------------------
// no way am I gonna make TWO function calls where I can do FOUR comparisons!
//
#define RECTS_IN_SIZE(sz, r2) (!RECTS_NOT_IN_SIZE(sz, r2))

#define RECTS_NOT_IN_SIZE(sz, r2) (\
   ((sz).cx <= (r2).left) ||\
   (0 >= (r2).right) ||\
   ((sz).cy <= (r2).top) ||\
   (0 >= (r2).bottom))

//---------------------------------------------------------


void ListView_OnUpdate(LV* plv, int i);
void ListView_OnDestroy(LV* plv);
BOOL ListView_ValidateScrollParams(LV* plv, int * dx, int *dy);
void ListView_ButtonSelect(LV* plv, int iItem, UINT keyFlags, BOOL bSelected);
void ListView_DeselectAll(LV* plv, int iDontDeselect);
void ListView_LRInvalidateBelow(LV* plv, int i, int fSmoothScroll);
void ListView_IInvalidateBelow(LV* plv, int i);
void ListView_InvalidateFoldedItem(LV* plv, int iItem, BOOL fSelectionOnly, UINT fRedraw);
void ListView_ReleaseBkImage(LV *plv);
void ListView_RecalcRegion(LV *plv, BOOL fForce, BOOL fRedraw);

BOOL g_fSlowMachine = -1;

BOOL ListView_Init(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = ListView_WndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = c_szListViewClass;
    wc.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1); // NULL;
    wc.style           = CS_DBLCLKS | CS_GLOBALCLASS;
    wc.cbWndExtra      = sizeof(LV*);
    wc.cbClsExtra      = 0;

    if (!RegisterClass(&wc) && !GetClassInfo(hinst, c_szListViewClass, &wc))
        return FALSE;

    return TRUE;
}

// Cancel tracking tooltips which are activated by item focus via keyboard
void ListView_CancelTipTrack(LV* plv)
{
    // Make sure in tracking mode
    if (plv->hwndToolTips)
    {
        // Cancel any pending timer
        KillTimer(plv->ci.hwnd, IDT_TRACKINGTIP);

        if (ListView_IsKbdTipTracking(plv))
        {
            TOOLINFO ti = {0};

            // Mark as tracking nothing
            plv->iTracking = LVKTT_NOTRACK;
     
            // Reset tooltip to non-tracking
            ti.cbSize = sizeof(TOOLINFO);
            ti.hwnd = plv->ci.hwnd;

            SendMessage(plv->hwndToolTips, TTM_GETTOOLINFO, 0, (LPARAM)&ti);

            SendMessage(plv->hwndToolTips, TTM_TRACKACTIVATE, FALSE, (LPARAM)&ti);

            // Switch tooltip window back to non-tracking (manual) mode
            ti.uFlags &= ~TTF_TRACK;
            SendMessage(plv->hwndToolTips, TTM_SETTOOLINFO, 0, (LPARAM)&ti);
        }
    }
}

BOOL ListView_GetRegIASetting(BOOL *pb)
{
    HKEY        hkey;
    BOOL        bRet = FALSE;
    BOOL        bValue = TRUE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, IE_SETTINGS, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD cbValue = sizeof(DWORD);

        if (RegQueryValueEx(hkey, (LPTSTR)USE_DBL_CLICK_TIMER, 0, &dwType, (LPBYTE)&dwValue, &cbValue) == ERROR_SUCCESS)
        {
            bValue = (BOOL)dwValue;
            bRet = TRUE;
        }
        RegCloseKey(hkey);
    }

    *pb = bValue;
    return bRet;
}


BOOL ListView_NotifyCacheHint(LV* plv, int iFrom, int iTo)
{
    NM_CACHEHINT nm;

    if (iFrom <= iTo)
    {
        nm.iFrom = iFrom;
        nm.iTo = iTo;
        return !(BOOL)CCSendNotify(&plv->ci, LVN_ODCACHEHINT, &nm.hdr);
    }
    return FALSE;
}

void ListView_LazyCreateObjects(LV *plv, int iMin, int iMax)
{
    for (; iMin < iMax; iMin++)
        NotifyWinEvent(EVENT_OBJECT_CREATE, plv->ci.hwnd, OBJID_CLIENT, 1 + iMin);
}

//
//  Owner-data causes MSAA lots of grief, because there is no way to tell
//  MSAA "I just created 25 million items".  You have to tell it one at a
//  time.  Instead of sending out 25 million "add item" notifications, we
//  just send them out as they scroll into view.
//
//  plv->iMSAAMin and plv->iMSAAMax are the range of items we most
//  recently told MSAA about.  MSAAMax is *exclusive*, just like RECTs.
//  It makes the math easier.
//
//  We use iMSAAMin and iMSAAMax to avoid sending blatantly redundant
//  notifications, which would other happen very frequently.
//
void ListView_LazyCreateWinEvents(LV *plv, int iFrom, int iTo)
{
    int iMin = iFrom;
    int iMax = iTo+1;           // Convert from [From,To] to [Min,Max)

    //
    //  If the incoming range is entirely contained within the existing
    //  range, then there is nothing to do.  This happens a lot.
    //
    if (iMin >= plv->iMSAAMin && iMax <= plv->iMSAAMax)
        return;

    //
    //  If the incoming range is adjacent to or overlaps the low end
    //  of the existing range...  (This happens when scrolling backwards.)
    //
    if (iMin <= plv->iMSAAMin && iMax >= plv->iMSAAMin)
    {
        // Notify the low end.
        ListView_LazyCreateObjects(plv, iMin, plv->iMSAAMin);

        // Extend the list of things we've notified.
        plv->iMSAAMin = iMin;

        // Remove it from the things left to be notified.
        iMin = plv->iMSAAMax;
    }

    //
    //  Now do the same thing to the top end.
    //  (This happens when scrolling forwards.)
    //
    if (iMax >= plv->iMSAAMax && iMin <= plv->iMSAAMax)
    {
        // Notify the top end.
        ListView_LazyCreateObjects(plv, plv->iMSAAMax, iMax);

        // Extend the list of things we've notified.
        plv->iMSAAMax = iMax;

        // Remove it from the things left to be notified.
        iMax = plv->iMSAAMin;
    }

    //
    //  If there are still things to be notified, then it means that the
    //  incoming range isn't contiguous with the previous range, so throw
    //  away the old range and just set it to the current range.
    //  (This happens when you grab the scrollbar and jump to a completely
    //  unrelated part of the listview.)
    //
    if (iMin < iMax)
    {
        plv->iMSAAMin = iMin;
        plv->iMSAAMax = iMax;
        ListView_LazyCreateObjects(plv, iMin, iMax);
    }

}

LRESULT ListView_RequestFindItem(LV* plv, CONST LV_FINDINFO* plvfi, int iStart)
{
    NM_FINDITEM nm;

    nm.lvfi = *plvfi;
    nm.iStart = iStart;
    return CCSendNotify(&plv->ci, LVN_ODFINDITEM, &nm.hdr);
}

BOOL ListView_SendChange(LV* plv, int i, int iSubItem, int code, UINT oldState, UINT newState,
                              UINT changed, LPARAM lParam)
{
    NM_LISTVIEW nm;

    nm.iItem = i;
    nm.iSubItem = iSubItem;
    nm.uNewState = newState;
    nm.uOldState = oldState;
    nm.uChanged = changed;
    nm.ptAction.x = 0;
    nm.ptAction.y = 0;
    nm.lParam = lParam;

    return !CCSendNotify(&plv->ci, code, &nm.hdr);
}

void ListView_SendODChangeAndInvalidate(LV* plv, int iFrom, int iTo, UINT oldState,
                                UINT newState)
{
    NM_ODSTATECHANGE nm;

    nm.iFrom = iFrom;
    nm.iTo = iTo;
    nm.uNewState = newState;
    nm.uOldState = oldState;

    CCSendNotify(&plv->ci, LVN_ODSTATECHANGED, &nm.hdr);

    // Tell accessibility, "Selection changed in a complex way"
    NotifyWinEvent(EVENT_OBJECT_SELECTIONWITHIN, plv->ci.hwnd, OBJID_CLIENT, CHILDID_SELF);

    // considerable speed increase less than 100 to do this method
    // while over 100, the other method works faster
    if ((iTo - iFrom) > 100)
    {
        InvalidateRect(plv->ci.hwnd, NULL, FALSE);
    }
    else
    {
        while (iFrom <= iTo)
        {
            ListView_InvalidateItem(plv, iFrom, TRUE, RDW_INVALIDATE);
            iFrom++;
        }
    }
}

//
//  This function autoarranges or snaps to grid based on the style and ExStyle
//
//  Note: AutoArrange overrides the snap-to-grid style.
//
void ListView_ArrangeOrSnapToGrid(LV *plv)
{
    if (plv->ci.style & LVS_AUTOARRANGE)
        ListView_OnArrange(plv, LVA_DEFAULT);
    else if (plv->exStyle & LVS_EX_SNAPTOGRID)
        ListView_OnArrange(plv, LVA_SNAPTOGRID);
}

BOOL ListView_Notify(LV* plv, int i, int iSubItem, int code)
{
    NM_LISTVIEW nm;
    nm.iItem = i;
    nm.iSubItem = iSubItem;
    nm.uNewState = nm.uOldState = 0;
    nm.uChanged = 0;
    nm.lParam = 0;
    
    if (!ListView_IsOwnerData(plv)) 
    {
        if (code == LVN_DELETEITEM) 
        {
            LISTITEM * pItem = ListView_GetItemPtr(plv, i);
            if (pItem) 
                nm.lParam = pItem->lParam;
        }
    }
    
    return (BOOL)CCSendNotify(&plv->ci, code, &nm.hdr);
}

BOOL ListView_GetEmptyText(LV* plv)
{
    NMLVDISPINFO nm;
    BOOL ret;
    TCHAR szText[80];

    if (plv->fNoEmptyText)
        return FALSE;

    if (plv->pszEmptyText)
        return TRUE;

    // For each listview control, we will only send this notify
    // once if necessary.

    memset(&nm, 0, sizeof(NMLVDISPINFO));
    nm.item.mask = LVIF_TEXT;
    nm.item.cchTextMax = ARRAYSIZE(szText);
    nm.item.pszText = szText;
    szText[0] = TEXT('\0');

    ret = (BOOL)CCSendNotify(&plv->ci, LVN_GETEMPTYTEXT, &nm.hdr);

    if (ret)
        // save the text so we don't notify again.
        Str_Set(&plv->pszEmptyText, szText);
    else
        // set a flag so we don't notify again.
        plv->fNoEmptyText = TRUE;

    return ret;
}

void ListView_NotifyFocusEvent(LV *plv)
{
    if (plv->iFocus != -1 && IsWindowVisible(plv->ci.hwnd) && GetFocus() == plv->ci.hwnd)
        NotifyWinEvent(EVENT_OBJECT_FOCUS, plv->ci.hwnd, OBJID_CLIENT,
                plv->iFocus+1);
}

//
//  Call this function when the listview has changed in a radical manner.
//  It notifies MSAA that "Whoa, things are completely different now."
//
void ListView_NotifyRecreate(LV *plv)
{
    NotifyWinEvent(EVENT_OBJECT_DESTROY, plv->ci.hwnd, OBJID_CLIENT, CHILDID_SELF);
    NotifyWinEvent(EVENT_OBJECT_CREATE, plv->ci.hwnd, OBJID_CLIENT, CHILDID_SELF);
    plv->iMSAAMin = plv->iMSAAMax = 0;
}

int ListView_OnSetItemCount(LV *plv, int iItems, DWORD dwFlags)
{
   BOOL frt = TRUE;

   // For compatability we assume 0 for flags implies old (Athena) type of functionality and
   // does a Invalidate all otherwise if low bit is set we try to be a bit smarter.  First pass
   // If the first added item is visible invalidate all.  Yes we can do better...
   if (ListView_IsOwnerData(plv))
   {
       int iItem;
       int cTotalItemsOld = plv->cTotalItems;
       BOOL fInvalidateAll = ((dwFlags & LVSICF_NOINVALIDATEALL) == 0);

       if ((iItems >= 0) && (iItems <= MAX_LISTVIEWITEMS))
       {
           plv->cTotalItems = iItems;

           // check focus
           if (plv->iFocus >= iItems)
              plv->iFocus = -1;
          if (plv->iDropHilite >= iItems)
              plv->iDropHilite = -1;

           // check mark
           if (plv->iMark >= iItems)
              plv->iMark = -1;

           // make sure no selections above number of items
           plv->plvrangeCut->lpVtbl->ExcludeRange(plv->plvrangeCut, iItems, SELRANGE_MAXVALUE);
           if (FAILED(plv->plvrangeSel->lpVtbl->ExcludeRange(plv->plvrangeSel, iItems, SELRANGE_MAXVALUE)))
           {
               SetLastError(ERROR_OUTOFMEMORY);
               return FALSE;
           }


           plv->rcView.left = RECOMPUTE;  // recompute view rect

           if (ListView_IsAutoArrangeView(plv)) 
           {
               // Call off to the arrange function.
               ListView_OnArrange(plv, LVA_DEFAULT);

               if (!fInvalidateAll)
               {
                   // Try to be smart and invalidate only what we need to.
                   // Add a little logic to erase any message like no items found when
                   // the view was previously empty...
                   if (cTotalItemsOld < iItems)
                       iItem = cTotalItemsOld;
                   else
                       iItem = iItems - 1;  // Get the index

                   if ((iItem >= 0) && (cTotalItemsOld > 0))
                       ListView_IInvalidateBelow(plv, iItem);
                   else
                       fInvalidateAll = TRUE;
               }

           } 
           else 
           {
               ListView_Recompute(plv);
               // if we have empty text and old count was zero... then we should redraw all
               if (plv->pszEmptyText && (cTotalItemsOld == 0) && (iItems > 0))
                   fInvalidateAll = TRUE;

               // Try to do smart invalidates...
               if (!fInvalidateAll)
               {
                   // Try to be smart and invalidate only what we need to.
                   if (cTotalItemsOld < iItems)
                       iItem = cTotalItemsOld;
                   else
                       iItem = iItems - 1;  // Get the index

                   if (iItem >= 0)
                       ListView_LRInvalidateBelow(plv, iItem, FALSE);
               }


               // We may try to resize the column
               ListView_MaybeResizeListColumns(plv, 0, ListView_Count(plv)-1);

               // For compatability we assume 0 for flags implies old type
               // of functionality and scrolls the important item into view.
               // If second bit is set, we leave the scroll position alone.
               if ((dwFlags & LVSICF_NOSCROLL) == 0)
               {
                   // what is the important item
                   iItem = (plv->iFocus >= 0) ?
                           plv->iFocus :
                           ListView_OnGetNextItem(plv, -1, LVNI_SELECTED);

                   iItem = max(0, iItem);

                   // make important item visable
                   ListView_OnEnsureVisible(plv, iItem, FALSE);
               }
           }


           if (fInvalidateAll)
               InvalidateRect(plv->ci.hwnd, NULL, TRUE);
           ListView_UpdateScrollBars(plv);

           ListView_NotifyRecreate(plv);
           ListView_NotifyFocusEvent(plv);

       } 
       else 
       {
           frt = FALSE;
       }

   }
   else 
   {
       if (plv->hdpaSubItems)
       {
           int iCol;
           for (iCol = plv->cCol - 1; iCol >= 0; iCol--)
           {
               HDPA hdpa = ListView_GetSubItemDPA(plv, iCol);
               if (hdpa)   // this is optional, call backs don't have them
                   DPA_Grow(hdpa, iItems);
           }
       }

       DPA_Grow(plv->hdpa, iItems);
       DPA_Grow(plv->hdpaZOrder, iItems);
    }

    return frt;
}

VOID ListView_InvalidateTTLastHit(LV* plv, int iNewHit)
{
    if (plv->iTTLastHit == iNewHit)
    {
        plv->iTTLastHit = -1;
        if (plv->pszTip && plv->pszTip != LPSTR_TEXTCALLBACK)
        {
            plv->pszTip[0] = 0;
        }
    }
}

typedef struct
{
    LV              *plv;
    BOOL            fSortIndices;
    PFNLVCOMPARE    pfnCompare;
    LPARAM          lParam;
    BOOL            bPassLP;
} LVSortInfo;

int CALLBACK ListView_SortCallback(void * dw1, void * dw2, LPARAM lParam)
{
    LISTITEM *pitem1;
    LISTITEM *pitem2;
    LVSortInfo *pSortInfo = (LVSortInfo *)lParam;

    ASSERT(!ListView_IsOwnerData(pSortInfo->plv));

    // determine whether  dw1 and dw2 are indices or the real items
    // and assign pitem? accordingly
    if (pSortInfo->fSortIndices) 
    {
        pitem1 = ListView_GetItemPtr(pSortInfo->plv, PtrToUlong(dw1));
        pitem2 = ListView_GetItemPtr(pSortInfo->plv, PtrToUlong(dw2));
    } 
    else 
    {
        pitem1 = (LISTITEM *)dw1;
        pitem2 = (LISTITEM *)dw2;
    }

    if (!pSortInfo->pfnCompare) 
    {
        // Treat NULL pszText like null string.
        LPCTSTR pszText1 = pitem1->pszText ? pitem1->pszText : c_szNULL;
        LPCTSTR pszText2 = pitem2->pszText ? pitem2->pszText : c_szNULL;

        // REARCHITECT: should allow callbacks in text
        if (pszText1 != LPSTR_TEXTCALLBACK &&
            pszText2 != LPSTR_TEXTCALLBACK)
        {
            return lstrcmpi(pitem1->pszText, pitem2->pszText);
        }
        RIPMSG(0, "LVM_SORTITEM(EX): Cannot combine NULL callback with LPSTR_TEXTCALLBACK");
        return -1;
    } 
    else
    {
        if (pSortInfo->bPassLP)
            return pSortInfo->pfnCompare(pitem1->lParam, pitem2->lParam, pSortInfo->lParam);
        else 
        {
            if (pSortInfo->fSortIndices)
                return pSortInfo->pfnCompare((LPARAM)dw1, (LPARAM)dw2, pSortInfo->lParam);
            else
            {
                // we want to sort by the indices, but all we've got are pointers to the items
                // and there is no way to get back from that pointer to an index
                RIPMSG(0, "LVM_SORTITEM(EX): Want to sort by indicies, but only have pointers");
                return -1;
            }
        }

    }
    RIPMSG(0, "LVM_SORTITEM(EX): Didn't seem to sort by anything");
    return -1;
}

LISTGROUP* ListView_FindGroupFromID(LV* plv, int iGroupId, int* piIndex)
{
    if (plv->hdpaGroups)
    {
        int cGroups = DPA_GetPtrCount(plv->hdpaGroups);
        int iGroup;
        for (iGroup = 0; iGroup < cGroups; iGroup++)
        {
            LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
            if (pgrp->iGroupId == iGroupId)
            {
                if (piIndex)
                    *piIndex = iGroup;
                return pgrp;
            }
        }
    }

    return NULL;

}

BOOL ListView_VerifyGroupIdIsUnique(LV* plv, int iGroupId)
{
    if (plv->hdpaGroups)
    {
        int cGroups = DPA_GetPtrCount(plv->hdpaGroups);
        int iGroup;
        for (iGroup = 0; iGroup < cGroups; iGroup++)
        {
            LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
            if (pgrp->iGroupId == iGroupId)
                return FALSE;
        }
    }

    return TRUE;
}

int ListView_GroupIndexFromItem(LV* plv, LISTITEM* pitem)
{
    if (LISTITEM_HASGROUP(pitem))
    {
        int cGroups = DPA_GetPtrCount(plv->hdpaGroups);
        int iGroup;
        for (iGroup = 0; iGroup < cGroups; iGroup++)
        {
            LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
            if (pgrp == pitem->pGroup)
            {
                return iGroup;
            }
        }

    }
    return -1;
}


BOOL ListView_RemoveItemFromItsGroup(LV* plv, LISTITEM* pitem)
{
    if (LISTITEM_HASGROUP(pitem))
    {
        LISTGROUP* pgrp = pitem->pGroup;
        int cItems = DPA_GetPtrCount(pgrp->hdpa);
        int iItem;
        for (iItem = 0; iItem < cItems; iItem++)
        {
            LISTITEM* pgitem = DPA_FastGetPtr(pgrp->hdpa, iItem);
            if (pgitem == pitem)
            {
                DPA_DeletePtr(pgrp->hdpa, iItem);
                return TRUE;
            }
        }

    }
    return FALSE;
}

BOOL ListView_FixupGroupsAfterSorting(LV *plv)
{
    BOOL fRet = FALSE;
    int cGroups = DPA_GetPtrCount(plv->hdpaGroups);

    int *rgiGroupIds = LocalAlloc(LPTR, sizeof(int) * cGroups);

    // rgi will be where we keep the index in each group as we add items to them
    int *rgi = LocalAlloc(LPTR, sizeof(int) * cGroups);

    if (rgiGroupIds && rgi)
    {
        int i;
        int iMax = DPA_GetPtrCount(plv->hdpa);

        // Save away the group IDs, and temporary replace them with straight indices
        for (i=0; i < cGroups; i++)
        {
            LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, i);
            rgiGroupIds[i] = pgrp->iGroupId;
            pgrp->iGroupId = i;
        }

        // Now all the items are sorted, and all we need to do it put them back in their
        // respective groups is sorted order
        for (i=0; i < iMax;i++)
        {
            LISTITEM *pitem = ListView_FastGetItemPtr(plv, i);
            LISTGROUP* pgrp = LISTITEM_GROUP(pitem);
            if (pgrp)
            {
                ASSERT(pgrp->hdpa);
                DPA_SetPtr(pgrp->hdpa, rgi[pgrp->iGroupId]++, pitem);
            }
        }

#if DEBUG
        // At this point, we should still have the proper number of items in each group!
        for (i=0; i < cGroups; i++)
        {
            LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, i);
            ASSERT(DPA_GetPtrCount(pgrp->hdpa) == rgi[i]);
        }
#endif

        // Restore the proper GroupIds now
        for (i=0; i < cGroups; i++)
        {
            LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, i);
            pgrp->iGroupId = rgiGroupIds[i];
        }

        fRet = TRUE;
    }
    LocalFree(rgiGroupIds);
    LocalFree(rgi);
    return fRet;
}

BOOL ListView_SortAllColumns(LV* plv, LVSortInfo * psi)
{
    BOOL fReturn;
    ASSERT(!ListView_IsOwnerData(plv));

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    // don't do this optimization if we will need the indices to sort by
    if (psi->bPassLP && 
        ((!plv->hdpaSubItems) || 
         !DPA_GetPtrCount(plv->hdpaSubItems))) 
    {
        psi->fSortIndices = FALSE;
        fReturn = DPA_Sort(plv->hdpa, ListView_SortCallback, (LPARAM)psi);
    } 
    else 
    {
        // if we need to sort several hdpa's, create one DPA of just indices
        // and sort that, then fix up all the dpa's

        // initialize the hdpa with indices
        HDPA hdpa = DPA_Clone(plv->hdpa, NULL);

        fReturn = FALSE;
        if (hdpa) 
        {
            int i, iMax;
            void **ph;
            void **pNewIndices;
            ASSERT(DPA_GetPtrCount(plv->hdpa) == DPA_GetPtrCount(hdpa));
            ph = pNewIndices = DPA_GetPtrPtr(hdpa);
            iMax = DPA_GetPtrCount(hdpa);
            for (i = 0; i < iMax; ph++, i++) 
            {
                *ph = IntToPtr(i);
            }

            psi->fSortIndices = TRUE;
            if (DPA_Sort(hdpa, ListView_SortCallback, (LPARAM)psi)) 
            {
                ph = LocalAlloc(LPTR, sizeof(void *) * iMax);
                if (ph) 
                {
                    int j;
                    void **pSubItems;
                    // we could get here because bPassLP is false, even if we don't have subitems
                    if (plv->hdpaSubItems && DPA_GetPtrCount(plv->hdpaSubItems))
                    {
                        for (i = DPA_GetPtrCount(plv->hdpaSubItems) - 1; i >= 0; i--) 
                        {
                            HDPA hdpaSubItem = ListView_GetSubItemDPA(plv, i);
                            if (hdpaSubItem) 
                            {
                                // make sure it's of the right size
                                while (DPA_GetPtrCount(hdpaSubItem) < iMax) 
                                {
                                    if (DPA_InsertPtr(hdpaSubItem, iMax, NULL) == -1)
                                        goto Bail;
                                }

                                // actually copy across the dpa with the new indices
                                pSubItems = DPA_GetPtrPtr(hdpaSubItem);
                                for (j = 0; j < iMax; j++) 
                                {
                                    ph[j] = pSubItems[PtrToUlong(pNewIndices[j])];
                                }

                                // finally, copy it all back to the pSubItems;
                                memcpy(pSubItems, ph, sizeof(void *) * iMax);
                            }
                        }
                    }

                    // now do the main hdpa
                    pSubItems = DPA_GetPtrPtr(plv->hdpa);
                    for (j = 0; j < iMax; j++) 
                    {
                        ph[j] = pSubItems[PtrToUlong(pNewIndices[j])];
                    }

                    // finally, copy it all back to the pSubItems;
                    memcpy(pSubItems, ph, sizeof(void *) * iMax);
                    fReturn = TRUE;
Bail:
                    LocalFree(ph);
                }
            }
            DPA_Destroy(hdpa);
        }
    }
    if (fReturn && plv->fGroupView && plv->hdpaGroups && DPA_GetPtrCount(plv->hdpaGroups) > 0 && ListView_IsGroupedView(plv))
    {
        fReturn = ListView_FixupGroupsAfterSorting(plv);
    }
    return fReturn;
}

DWORD ListView_OnApproximateViewRect(LV* plv, int iCount, int iWidth, int iHeight)
{
    if (iCount == -1)
        iCount = ListView_Count(plv);

    if (iWidth == -1)
        iWidth = plv->sizeClient.cx;

    if (iHeight == -1)
        iHeight = plv->sizeClient.cy;

    return _ListView_ApproximateViewRect(plv, iCount, iWidth, iHeight);
}

DWORD ListView_OnSetLVRangeObject(LV* plv, int iWhich, ILVRange *plvrange)
{
    ILVRange **pplvrange;
    switch (iWhich)
    {
    case LVSR_SELECTION:
        pplvrange = &plv->plvrangeSel;
        break;
    case LVSR_CUT:
        pplvrange = &plv->plvrangeCut;
        break;
    default:
        return FALSE;
    }
    if (*pplvrange)
    {
        // Release the old one
        (*pplvrange)->lpVtbl->Release(*pplvrange);
    }
    *pplvrange = plvrange;

    // Hold onto the pointer...
    if (plvrange)
        plvrange->lpVtbl->AddRef(plvrange);

    return TRUE;
}


BOOL ListView_OnSortItems(LV *plv, LPARAM lParam, PFNLVCOMPARE pfnCompare, BOOL bPassLP)
{
    LVSortInfo SortInfo;
    LISTITEM *pitemFocused;
    SortInfo.pfnCompare = pfnCompare;
    SortInfo.lParam     = lParam;
    SortInfo.plv = plv;
    SortInfo.bPassLP = bPassLP;

    if (ListView_IsOwnerData(plv)) 
    {
        RIPMSG(0, "LVM_SORTITEMS: Invalid for owner-data listview");
        return FALSE;
    }

    ListView_DismissEdit(plv, TRUE);    // cancel edits

    // we're going to mess with the indices, so stash away the pointer to the
    // focused item.
    if (plv->iFocus != -1) 
    {
        pitemFocused = ListView_GetItemPtr(plv, plv->iFocus);
    } 
    else
        pitemFocused = NULL;

    if (ListView_SortAllColumns(plv, &SortInfo)) 
    {
        // restore the focused item.
        if (pitemFocused) 
        {
            int i;
            for (i = ListView_Count(plv) - 1; i >= 0 ; i--) 
            {
                if (ListView_GetItemPtr(plv, i) == pitemFocused) 
                {
                    plv->iFocus = i;
                    plv->iMark = i;
                }
            }
        }

        if (ListView_IsAutoArrangeView(plv))
        {
            ListView_CommonArrange(plv, LVA_DEFAULT, plv->hdpa);
        }
        else
        {
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        }

        // The items in the view have moved around; let apps know
        NotifyWinEvent(EVENT_OBJECT_REORDER, plv->ci.hwnd, OBJID_CLIENT, 0);
        return TRUE;
    }
    return FALSE;
}


void ListView_EnableWindow(LV* plv, BOOL wParam)
{
    if (wParam) 
    {
        if (plv->ci.style & WS_DISABLED) 
        {
            plv->ci.style &= ~WS_DISABLED;      // enabled
            ListView_OnSetBkColor(plv, plv->clrBkSave);
        }
    } 
    else 
    {
        if (!(plv->ci.style & WS_DISABLED)) 
        {
            plv->clrBkSave = plv->clrBk;
            plv->ci.style |= WS_DISABLED;       // disabled
            ListView_OnSetBkColor(plv, g_clrBtnFace);
        }
    }
    RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
}


BOOL ListView_IsItemVisibleI(LV* plv, int i)
// Assumes parmss ok etc for speed. Called inside region calc code.
{
    RECT rcBounds;

    // get bounding rect of item
    ListView_GetRects(plv, i, QUERY_DEFAULT, NULL, NULL, &rcBounds, NULL);

    // Should perf this up for multimonitor case where there are dead zones in work area...
    return RECTS_IN_SIZE(plv->sizeClient, rcBounds);
}


// Helper for ListView_RecalcRegion
#define BitOn(lpbits, x, y, cx) (*((BYTE *)(lpbits + ((y * cx) + (x / 8)))) & (0x80 >> (x % 8)))

void ListView_RecalcRegion(LV* plv, BOOL fForce, BOOL fRedraw)
{
    HRGN hrgnUnion = NULL;
    HRGN hrgn = NULL;
    int i;
    HDC hdc = NULL;
    BYTE * lpBits = NULL;
    HBITMAP hbmp = NULL, hbmpOld = NULL;
    RECT rc, rcIcon = {0};
    LISTITEM * pitem;
    BITMAP bm;

    // Bail out if we don't need to do any work
    if (!(plv->exStyle & LVS_EX_REGIONAL) || !ListView_RedrawEnabled(plv) ||
        (plv->flags & LVF_INRECALCREGION))
        return;

    // To prevent recursion
    plv->flags |= LVF_INRECALCREGION;

    if ((ListView_Count(plv) > 0))
    {
        int cxIcon, cyIcon;
        int dxOffset, dyOffset;

        // Run through first to see if anything changed - bail if not!
        if (!fForce)
        {
            for (i = 0; i < ListView_Count(plv); i++)
            {
                pitem = ListView_FastGetItemPtr(plv, i);

                if (!ListView_IsItemVisibleI(plv, i))
                {
                    if (pitem->hrgnIcon == (HANDLE)-1 || !pitem->hrgnIcon)
                        // Item was invisible and still is. Nothing changed.
                        continue;

                    if (pitem->hrgnIcon)
                    {
                        // Item was visible and now is invisible... Something
                        // changed.
                        pitem->ptRgn.x = RECOMPUTE;
                        pitem->ptRgn.y = RECOMPUTE;
                        DeleteObject(pitem->hrgnIcon);
                        pitem->hrgnIcon = NULL;
                    }
                }

                ListView_GetRects(plv, i, QUERY_DEFAULT, NULL, &rc, NULL, NULL);

                // If the location of the icon or the text rectangle have
                // changed, then we need to continue so that we can recalculate
                // the region.
                if ((pitem->pt.x != pitem->ptRgn.x) ||
                    (pitem->pt.y != pitem->ptRgn.y) ||
                    (!pitem->hrgnIcon) ||
                    !EqualRect((CONST RECT *)&pitem->rcTextRgn, (CONST RECT *)&rc))
                    goto changed;

            }
            // If we go through all the items and nothing changed, then
            // we can return without doing any work!
            ASSERT(i == ListView_Count(plv));
            goto exit;
changed:;
        }

        // Figure out the dimensions of the Icon rectangle - assumes
        // each Icon rectangle is the same size.
        ListView_GetRects(plv, 0, QUERY_DEFAULT, &rcIcon, NULL, NULL, NULL);

        // Center the icon in the rectangle
        CCGetIconSize(&plv->ci, plv->himl, &cxIcon, &cyIcon);

        dxOffset = (rcIcon.right - rcIcon.left - cxIcon) / 2;
        dyOffset = (rcIcon.bottom - rcIcon.top - cyIcon) / 2;
        cxIcon = rcIcon.right - rcIcon.left;
        cyIcon = rcIcon.bottom - rcIcon.top;

        if (!(hdc = CreateCompatibleDC(NULL)) ||
            (!(hbmp = CreateBitmap(cxIcon, cyIcon, 1, 1, NULL)))) 
        {
            goto BailOut;
        }

        GetObject(hbmp, sizeof(bm), &bm);

        if (!(lpBits = (BYTE *)GlobalAlloc(GPTR, bm.bmWidthBytes * bm.bmHeight)))
            goto BailOut;

        hbmpOld = SelectObject(hdc, hbmp);
        PatBlt(hdc, 0, 0, cxIcon, cyIcon, WHITENESS);

        if (hrgnUnion = CreateRectRgn(0, 0, 0, 0)) 
        {
            for (i = 0; i < ListView_Count(plv); i++)
            {
                int x, y, iResult;
                BOOL fStarted = FALSE;
                LPRECT lprc;

                pitem = ListView_FastGetItemPtr(plv, i);

                if (pitem->pt.y == RECOMPUTE)
                    continue;

                if (!ListView_IsItemVisibleI(plv, i))
                {
                    // ignore invisible items
                    if (pitem->hrgnIcon && pitem->hrgnIcon!=(HANDLE)-1)
                    {
                        pitem->ptRgn.x = RECOMPUTE;
                        pitem->ptRgn.y = RECOMPUTE;
                        DeleteObject(pitem->hrgnIcon);
                        pitem->hrgnIcon = (HANDLE)-1;
                    }
                    continue;
                }

                // Add the region for the icon text first
                ListView_GetRects(plv, i, QUERY_DEFAULT, &rcIcon, &rc, NULL, NULL);

                // If we're in edit mode always use rcTextRgn
                if (i == plv->iEdit)
                    lprc = &pitem->rcTextRgn;
                else
                    lprc = &rc;

                if (!(hrgn = CreateRectRgnIndirect(lprc)))
                    goto Error;

                iResult = CombineRgn(hrgnUnion, hrgn, hrgnUnion, RGN_OR);

                DeleteObject(hrgn);

                if (iResult == ERROR)
                {
                    // Error case - out of memory.  Just select in a NULL region.
Error:
                    DeleteObject(hrgnUnion);
                    hrgnUnion = NULL;
                    break;
                }

                // Succeeded, copy the rectangle to rcTextRgn so we
                // can test against it in the future.  Don't copy over
                // it if we are in edit mode, the rectangle is used to
                // store the edit window in that case.
                if (plv->iEdit != i)
                    CopyRect(&pitem->rcTextRgn, (CONST RECT *)&rc);

                // Now create a region for the icon mask - or use the cached one
                if (!pitem->hrgnIcon || pitem->hrgnIcon == (HANDLE)-1)
                {
//                    (pitem->pt.x != pitem->ptRgn.x) ||
//                    (pitem->pt.y != pitem->ptRgn.y))
                    HRGN hrgnIcon = NULL;

                    // On slow machines, we'll just wrap the icon with a rectangle.  But on
                    // faster machines, we'll build a region that corresponds to the
                    // mask for the icon so it looks sweet.
                    if (g_fSlowMachine) 
                    {
                        // Modify the rectangle slightly so it looks better

                        // Glue the icon and text rectangles together
                        rcIcon.bottom = rc.top;
                        // Shrink the width of the rectangle so it's only as big as the icon itself
                        InflateRect(&rcIcon, -dxOffset, 0);
                        hrgnIcon = CreateRectRgnIndirect(&rcIcon);
                    }
                    else
                    {
                        // If the image isn't around, get it now.
                        if (pitem->iImage == I_IMAGECALLBACK)
                        {
                            LV_ITEM item;

                            item.iItem = i;
                            item.iSubItem = 0;
                            item.mask = LVIF_IMAGE;
                            item.stateMask = LVIS_ALL;
                            item.pszText = NULL;
                            item.cchTextMax = 0;
                            // BOGUS - do we need to worry about our state
                            // getting messed up during the callback?
                            ListView_OnGetItem(plv, &item);
                        }

                        ImageList_Draw(plv->himl, pitem->iImage, hdc, 0, 0, ILD_MASK | (pitem->state & LVIS_OVERLAYMASK));

                        GetBitmapBits(hbmp, bm.bmWidthBytes * bm.bmHeight, (void *)lpBits);

                        for (y = 0; y < cyIcon; y++)
                        {
                            for (x = 0; x < cxIcon; x++)
                            {
                                if (!fStarted && !BitOn(lpBits, x, y, bm.bmWidthBytes))
                                {
                                    rc.left = x;
                                    rc.top = y;
                                    rc.bottom = y + 1;
                                    fStarted = TRUE;
                                    if (x == (cxIcon - 1))
                                    {
                                        x++;
                                        goto AddIt;
                                    }
                                    else
                                    {
                                        continue;
                                    }
                                }

                                if (fStarted && BitOn(lpBits, x, y, bm.bmWidthBytes))
                                {
AddIt:
                                    rc.right = x;
                                    //
                                    // Mirror the region so that the icons get displayed ok. [samera]
                                    //
                                    if (plv->ci.dwExStyle & RTL_MIRRORED_WINDOW)
                                    {
                                        int iLeft = rc.left;
                                        rc.left = (cxIcon - (rc.right+1));
                                        rc.right = (cxIcon - (iLeft+1));
                                        OffsetRect(&rc, rcIcon.left - dxOffset, rcIcon.top + dyOffset);
                                    }
                                    else
                                        OffsetRect(&rc, rcIcon.left + dxOffset, rcIcon.top + dyOffset);


                                    if (hrgn = CreateRectRgnIndirect(&rc))
                                    {
                                        if (hrgnIcon || (hrgnIcon = CreateRectRgn(0, 0, 0, 0)))
                                            iResult = CombineRgn(hrgnIcon, hrgn, hrgnIcon, RGN_OR);
                                        else
                                            iResult = ERROR;

                                        DeleteObject(hrgn);
                                    }

                                    if (!hrgn || (iResult == ERROR))
                                    {
                                        if (hrgnIcon)
                                            DeleteObject(hrgnIcon);
                                        goto Error;
                                    }

                                    fStarted = FALSE;
                                }
                            }
                        }
                    }

                    if (hrgnIcon)
                    {
                        // Cache it since it takes a long time to build it
                        if (pitem->hrgnIcon && pitem->hrgnIcon != (HANDLE)-1)
                            DeleteObject(pitem->hrgnIcon);
                        pitem->hrgnIcon = hrgnIcon;
                        pitem->ptRgn = pitem->pt;

                        // Add it to the accumulated window region
                        if (ERROR == CombineRgn(hrgnUnion, hrgnIcon, hrgnUnion, RGN_OR))
                            goto Error;
                    }
                }
                else
                {
                    OffsetRgn(pitem->hrgnIcon, pitem->pt.x - pitem->ptRgn.x, pitem->pt.y - pitem->ptRgn.y);
                    pitem->ptRgn = pitem->pt;
                    if (ERROR == CombineRgn(hrgnUnion, pitem->hrgnIcon, hrgnUnion, RGN_OR))
                        goto Error;
                }
            }
        }
    }

BailOut:
    if (lpBits)
        GlobalFree((HGLOBAL)lpBits);
    if (hbmp)
    {
        SelectObject(hdc, hbmpOld);
        DeleteObject(hbmp);
    }
    if (hdc)
        DeleteDC(hdc);

    // Windows takes ownership of the region when we select it in to the window
    SetWindowRgn(plv->ci.hwnd, hrgnUnion, fRedraw);

exit:
    plv->flags &= ~LVF_INRECALCREGION;
}

HIMAGELIST CreateCheckBoxImagelist(HIMAGELIST himl, BOOL fTree, BOOL fUseColorKey, BOOL fMirror)
{
    int cxImage, cyImage;
    HBITMAP hbm;
    HBITMAP hbmTemp;
    COLORREF clrMask = CLR_DEFAULT;
    HDC hdcDesk = GetDC(NULL);
    HDC hdc;
    RECT rc;
    int nImages = fTree ? 3 : 2;
    HTHEME hTheme;
    DTBGOPTS dtbg = {sizeof(DTBGOPTS), DTBG_DRAWSOLID, 0,};   // tell drawthemebackground to preserve the alpha channel

    if (!hdcDesk)
        return NULL;

    hdc = CreateCompatibleDC(hdcDesk);
    ReleaseDC(NULL, hdcDesk);

    if (!hdc)
        return NULL;

    hTheme = OpenThemeData(NULL, L"Button");


    // Must protect against ImageList_GetIconSize failing in case app
    // gave us a bad himl
    if (himl && ImageList_GetIconSize(himl, &cxImage, &cyImage))
    {
        // cxImage and cyImage are okay
    }
    else
    {
        cxImage = g_cxSmIcon;
        cyImage = g_cySmIcon;
    }

    himl = ImageList_Create(cxImage, cyImage, ILC_MASK | ILC_COLOR32, 0, nImages);
    hbm = CreateColorBitmap(cxImage * nImages, cyImage);

    // fill
    hbmTemp = SelectObject(hdc, hbm);
    rc.left = rc.top = 0;
    rc.bottom = cyImage;
    rc.right = cxImage * nImages;

    if (!hTheme)
    {
        if (fUseColorKey)
        {
            clrMask = RGB(255,000,255); // magenta
            if (clrMask == g_clrWindow)
                clrMask = RGB(000,000,255); // blue
        }
        else
        {
            clrMask = g_clrWindow;
        }

        // Don't fill the image with the mask when themes are on. We want this to 
        // "Alpha blend to zero" or be clear. No transparent blt needed.
        FillRectClr(hdc, &rc, clrMask);
    }

    rc.right = cxImage;
    // now draw the real controls on
    InflateRect(&rc, -g_cxEdge, -g_cyEdge);
    rc.right++;
    rc.bottom++;

    if (fTree)
        OffsetRect(&rc, cxImage, 0);

    if (hTheme)
    {
        DrawThemeBackgroundEx(hTheme, hdc, BP_CHECKBOX, CBS_UNCHECKEDNORMAL, &rc, &dtbg);
    }
    else
    {
        DrawFrameControl(hdc, &rc, DFC_BUTTON, DFCS_BUTTONCHECK | DFCS_FLAT | 
            (fUseColorKey? 0 : DFCS_TRANSPARENT));
    }

    OffsetRect(&rc, cxImage, 0);
    // [msadek]; For the mirrored case, there is an off-by-one somewhere in MirrorIcon() or System API.
    // Since I will not be touching MirrorIcon() by any mean and no chance to fix a system API,
    // let's compensate for it here.
    if (fMirror)
    {
        OffsetRect(&rc, -1, 0);  
    }

    if (hTheme)
    {
        DrawThemeBackgroundEx(hTheme, hdc, BP_CHECKBOX, CBS_CHECKEDNORMAL, &rc, &dtbg);
    }
    else
    {
        DrawFrameControl(hdc, &rc, DFC_BUTTON, DFCS_BUTTONCHECK | DFCS_FLAT | DFCS_CHECKED | 
            (fUseColorKey? 0 : DFCS_TRANSPARENT));
    }

    SelectObject(hdc, hbmTemp);

    if (fUseColorKey)
    {
        ImageList_AddMasked(himl, hbm, clrMask);
    }
    else
    {
        ImageList_Add(himl, hbm, NULL);
    }

    if (fMirror)
    {
        HICON hIcon = ImageList_ExtractIcon(0, himl, nImages-1);
        MirrorIcon(&hIcon, NULL);
        ImageList_ReplaceIcon(himl, nImages-1, hIcon);
    }

    DeleteDC(hdc);
    DeleteObject(hbm);
    if (hTheme)
        CloseThemeData(hTheme);
    return himl;
}

void ListView_InitCheckBoxes(LV* plv, BOOL fInitializeState)
{
    HIMAGELIST himlCopy = (plv->himlSmall ? plv->himlSmall : plv->himl);
    HIMAGELIST himl;
    BOOL bMirror = FALSE;
    // [msadek], CheckBoxed need not to be mirrored.
    // mirroer it during imagelist creation time so that it displays correctly
    
    himl = CreateCheckBoxImagelist(himlCopy, FALSE, TRUE, IS_WINDOW_RTL_MIRRORED(plv->ci.hwnd));
    ImageList_SetBkColor(himl, IsUsingCleartype()? (plv->clrBk) : (CLR_NONE));
    ListView_OnSetImageList(plv, himl, LVSIL_STATE);

    if (fInitializeState)
        ListView_OnSetItemState(plv, -1, INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);
}

void ListView_PopBubble(LV *plv)
{
    if (plv->hwndToolTips)
        SendMessage(plv->hwndToolTips, TTM_POP, 0, 0);
}

DWORD ListView_ExtendedStyleChange(LV* plv, DWORD dwNewStyle, DWORD dwExMask)
{
    DWORD dwOldStyle = plv->exStyle;

    // this will change the listview report size and painting algorithm
    // because of the leading edge, so need to re-update scroll bars
    // and repaint everything
    if (ListView_IsReportView(plv))
    {
        ListView_RUpdateScrollBars(plv);
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    // Change of styles may also changes tooltip policy, so pop it
    ListView_PopBubble(plv);

    if (dwExMask)
        dwNewStyle = (plv->exStyle & ~ dwExMask) | (dwNewStyle & dwExMask);

    // Currently, LVS_EX_REGIONAL, LVS_EX_MULTIWORKAREAS, LVS_EX_HIDELABELS, and
    // LVS_EX_SINGLEROW are only supported for large icon view
    if (!ListView_IsIconView(plv)) 
    {
        dwNewStyle &= ~(LVS_EX_REGIONAL | LVS_EX_MULTIWORKAREAS | LVS_EX_HIDELABELS | LVS_EX_SINGLEROW);
    }

    // LVS_EX_REGIONAL and LVS_EX_SINGLEROW are not supported for ownerdata
    if (ListView_IsOwnerData(plv)) 
    {
        dwNewStyle &= ~(LVS_EX_REGIONAL | LVS_EX_SINGLEROW);
    }

    plv->exStyle = dwNewStyle;

    // do any invalidation or whatever is needed here.
    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_HIDELABELS)
    {
        plv->rcView.left = RECOMPUTE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_GRIDLINES) 
    {
        if (ListView_IsReportView(plv))
        {
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        }
    }

    if ((dwOldStyle ^ dwNewStyle) & (LVS_EX_UNDERLINEHOT | LVS_EX_UNDERLINECOLD |
                                     LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE |
                                     LVS_EX_SUBITEMIMAGES | LVS_EX_SNAPTOGRID)) 
    {
        plv->rcView.left = RECOMPUTE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_CHECKBOXES) 
    {
        if (dwNewStyle & LVS_EX_CHECKBOXES) 
        {
            ListView_InitCheckBoxes(plv, TRUE);
        } 
        else 
        {
            // destroy the check boxes!
            HIMAGELIST himl = ListView_OnSetImageList(plv, NULL, LVSIL_STATE);
            if (himl)
                ImageList_Destroy(himl);
        }
    }

    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_FLATSB) 
    {
        if (dwNewStyle & LVS_EX_FLATSB) 
        {
            InitializeFlatSB(plv->ci.hwnd);
            if (plv->hwndHdr)
            {
                SetWindowBits(plv->hwndHdr, GWL_STYLE, HDS_FLAT, HDS_FLAT);
            }
        } 
        else 
        {
            if (plv->hwndHdr)
            {
                SetWindowBits(plv->hwndHdr, GWL_STYLE, HDS_FLAT, 0);
            }
            UninitializeFlatSB(plv->ci.hwnd);
        }
    }

    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_REGIONAL) 
    {
        g_fSlowMachine = FALSE;

        if (dwNewStyle & LVS_EX_REGIONAL) 
        {
            ListView_RecalcRegion(plv, TRUE, TRUE);
        } 
        else 
        {
            int i;
            LISTITEM * pitem;

            // Delete all the cached regions, then NULL out our selected region.
            for (i = 0; i < ListView_Count(plv); i++) 
            {
                pitem = ListView_FastGetItemPtr(plv, i);
                if (pitem->hrgnIcon && pitem->hrgnIcon!=(HANDLE)-1) 
                {
                    DeleteObject(pitem->hrgnIcon);
                }
                pitem->hrgnIcon = NULL;
            }
            SetWindowRgn(plv->ci.hwnd, (HRGN)NULL, TRUE);
        }
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_SINGLEROW)
    {
        _ListView_RecomputeEx(plv, NULL, 0, TRUE);
    }

    if (ListView_IsDoubleBuffer(plv))
    {
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    return dwOldStyle;
}

// Bug#94368 raymondc v6.0:  Doesn't detect WM_WINDOWPOSCHANGING as a way
// of being shown.  NT5 defview has to hack around it pretty grossly.
// Fix for v6.0.

void LV_OnShowWindow(LV* plv, BOOL fShow)
{
    if (fShow)
    {
        if (!(plv->flags & LVF_VISIBLE))
        {
            plv->flags |= LVF_VISIBLE;
            if (plv->fGroupView)
                _ListView_RecomputeEx(plv, NULL, 0, FALSE);
            ListView_UpdateScrollBars(plv);
        }
    } 
    else
        plv->flags &= ~LVF_VISIBLE;

}

LRESULT ListView_OnHelp(LV* plv, LPHELPINFO lpHelpInfo)
{

    //  If we're seeing WM_HELP because of our child header control, then
    //  munge the HELPINFO structure to use the ListView's control id.
    //  win\core\user\combo.c has similiar code to handle the child edit
    //  control of a combo box.
    if ((lpHelpInfo != NULL) && (plv->wView == LV_VIEW_DETAILS) &&
        (lpHelpInfo->iCtrlId == LVID_HEADER)) 
    {

        lpHelpInfo->hItemHandle = plv->ci.hwnd;
        lpHelpInfo->iCtrlId = GetWindowID(plv->ci.hwnd);
        //  Shouldn't have to do this: USER would have filled in the appropriate
        //  context id by walking up the parent hwnd chain.
        //lpHelpInfo->dwContextId = GetContextHelpId(hwnd);

    }

    return DefWindowProc(plv->ci.hwnd, WM_HELP, 0, (LPARAM)lpHelpInfo);

}

DWORD ListView_OnSetIconSpacing(LV* plv, LPARAM lParam)
{
    DWORD dwOld = MAKELONG(plv->cxIconSpacing, plv->cyIconSpacing);

    int cxIconSpacing, cyIconSpacing;

    if (lParam == (LPARAM)-1) 
    {
        // go back to using defaults
        plv->flags &= ~LVF_ICONSPACESET;
        cxIconSpacing = (plv->cxIcon + (g_cxIconSpacing - g_cxIcon));
        cyIconSpacing = (plv->cyIcon + (g_cyIconSpacing - g_cyIcon));
    } 
    else 
    {
        if (LOWORD(lParam))
        {
            cxIconSpacing = LOWORD(lParam);
            if (ListView_IsDPIScaled(plv))
                CCDPIScaleX(&cxIconSpacing);
        }
        else
        {
            cxIconSpacing = plv->cxIconSpacing;
        }

        if (HIWORD(lParam))
        {
            cyIconSpacing = HIWORD(lParam);
            if (ListView_IsDPIScaled(plv))
                CCDPIScaleY(&cyIconSpacing);
        }
        else
        {
            cyIconSpacing = plv->cyIconSpacing;
        }

        plv->flags |= LVF_ICONSPACESET;
    }

    if ((cxIconSpacing != plv->cxIconSpacing) || 
        (cyIconSpacing != plv->cyIconSpacing))
    {
        plv->cxIconSpacing = cxIconSpacing;
        plv->cyIconSpacing = cyIconSpacing;

        plv->rcView.left = RECOMPUTE;

        // Recomputing is necessary except when snap-to-grid is toggled. Snap to grid assumes icon spacing
        // is the grid, however this is the only style that makes this assumption.
        if(!(plv->exStyle & LVS_EX_SNAPTOGRID))
            _ListView_RecomputeEx(plv, NULL, 0, TRUE);

        plv->iFreeSlot = -1;
    }

    return dwOld;
}

BOOL ListView_OnSetCursorMsg(LV* plv)
{
    if (plv->exStyle & (LVS_EX_ONECLICKACTIVATE|LVS_EX_TWOCLICKACTIVATE))
    {
        if (plv->iHot != -1)
        {
            if (((plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickOK)) ||
                ListView_OnGetItemState(plv, plv->iHot, LVIS_SELECTED))
            {
                if (!plv->hCurHot)
                {
                    plv->hCurHot = LoadCursor(NULL, IDC_HAND);
                }

                SetCursor(plv->hCurHot);

                return TRUE;
            }
        }
    }

    return FALSE;
}

void ListView_OnSetHotItem(LV* plv, int iItem)
{
    if (iItem != plv->iHot) 
    {
        if ((plv->exStyle & LVS_EX_ONECLICKACTIVATE) ||
            (plv->exStyle & LVS_EX_TWOCLICKACTIVATE)) // We only change visuals for hot with Underline
        {
            BOOL fSelectOnly;
            UINT uInvalidateFlags = RDW_INVALIDATE;
            BOOL fBlended = FALSE;
        
            // Check to see if the item we are making not is in a blended state
            if (iItem != -1)
            {
                // Cut is blended so we need to erase...
                fBlended = ListView_OnGetItemState(plv, iItem, LVIS_CUT);
                if (!fBlended)
                    fBlended = ListView_OnGetItemState(plv, iItem, LVIS_SELECTED);
            }

            // If we need to erase either one then we erase both. 
            if (plv->iHot != -1 && ListView_IsValidItemNumber(plv, plv->iHot) && !fBlended)
            {
                // Cut is blended so we need to erase...
                fBlended = ListView_OnGetItemState(plv, plv->iHot, LVIS_CUT);
                if (!fBlended)
                    fBlended = ListView_OnGetItemState(plv, plv->iHot, LVIS_SELECTED);
            }

            if (ImageList_GetFlags(plv->himl) & ILC_COLOR32)
                fBlended = TRUE;

            // Affects only apply if double buffering
            if (ListView_IsDoubleBuffer(plv) ||
                plv->fListviewShadowText ||
                fBlended)
            {
                uInvalidateFlags |= RDW_ERASE;
            }

            fSelectOnly = ListView_FullRowSelect(plv);

        
            ListView_InvalidateItemEx(plv, plv->iHot, fSelectOnly, uInvalidateFlags, LVIF_TEXT | LVIF_IMAGE);
            ListView_InvalidateItemEx(plv, iItem, fSelectOnly, uInvalidateFlags, LVIF_TEXT | LVIF_IMAGE);
        }
        plv->iHot = iItem;
    }
}


BOOL fShouldFirstClickActivate()
{
    static BOOL fInited = FALSE;
    static BOOL fActivate = TRUE;
    if (!fInited)
    {
        long cb = 0;
        if (RegQueryValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\NoFirstClickActivate"),
                      NULL, &cb) == ERROR_SUCCESS)
            fActivate = FALSE;
        fInited = TRUE;
    }
    return fActivate;
}

BOOL ChildOfDesktop(HWND hwnd)
{
    return IsChild(GetShellWindow(), hwnd);
}


void ListView_OnMouseMove(LV* plv, int x, int y, UINT uFlags)
{
    int iItem;
    LV_HITTESTINFO ht;
    NMLISTVIEW nm;

    ht.pt.x = x;
    ht.pt.y = y;
    iItem = ListView_OnSubItemHitTest(plv, &ht);
    if (ht.iSubItem != 0) 
    {
        // if we're not in full row select,
        // hitting on a subitem is like hitting on nowhere
        // also, in win95, ownerdraw fixed effectively had full row select
        if (!ListView_FullRowSelect(plv) &&
            !(plv->ci.style & LVS_OWNERDRAWFIXED)) 
        {
            iItem = -1;
            ht.flags = LVHT_NOWHERE;
        }
    }

    if (ht.flags & LVHT_NOWHERE ||
       ht.flags & LVHT_ONITEMSTATEICON) 
    {
        iItem = -1; // this is possible in the list mode (sigh)
    }

    nm.iItem = iItem;
    nm.iSubItem = ht.iSubItem;
    nm.uChanged = 0;
    nm.ptAction.x = x;
    nm.ptAction.y = y;

    if (!CCSendNotify(&plv->ci, LVN_HOTTRACK, &nm.hdr)) 
    {

#ifdef DEBUG
        if ((nm.iItem != -1) && nm.iSubItem != 0)
            nm.iItem = -1;
#endif

        ListView_OnSetHotItem(plv, nm.iItem);
        // Ensure our cursor is correct now since the WM_SETCURSOR
        // message was already generated for this mouse event.
        ListView_OnSetCursorMsg(plv);

        // this lets us know when we've left an item
        // and can then reselect/toggle it on hover events
        if (iItem != plv->iNoHover) 
        {
            plv->iNoHover = -1;
        }
    }
}

BOOL EditBoxHasFocus()
{
    HWND hwndFocus = GetFocus();
    if (hwndFocus)
    {
        if (SendMessage(hwndFocus, WM_GETDLGCODE, 0, 0) & DLGC_HASSETSEL)
            return TRUE;
    }

    return FALSE;
}

void ListView_OnMouseHover(LV* plv, int x, int y, UINT uFlags)
{
    int iItem;
    BOOL bSelected;
    LV_HITTESTINFO ht;
    BOOL fControl;
    BOOL fShift;
    BOOL fNotifyReturn = FALSE;

    if (GetCapture() || !ChildOfActiveWindow(plv->ci.hwnd) ||
       EditBoxHasFocus())
        return;  // ignore hover while editing or any captured (d/d) operation

    if (CCSendNotify(&plv->ci, NM_HOVER, NULL))
    {
        return;
    }

    // REVIEW: right button implies no shift or control stuff
    // Single selection style also implies no modifiers
    //if (RIGHTBUTTON(keyFlags) || (plv->ci.style & LVS_SINGLESEL))
    if ((plv->ci.style & LVS_SINGLESEL)) 
    {
        fControl = FALSE;
        fShift = FALSE;
    } 
    else 
    {
        fControl = GetAsyncKeyState(VK_CONTROL) < 0;
        fShift = GetAsyncKeyState(VK_SHIFT) < 0;
    }

    ht.pt.x = x;
    ht.pt.y = y;
    iItem = ListView_OnHitTest(plv, &ht);

    if (iItem == -1 ||
        iItem == plv->iNoHover)
        return;

    //before we hover select we launch any pending item
    //this prevents clicking on one item and hover selecting other before
    //the timer goes off which result in wrong item being launched
    if (plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickHappened && plv->fOneClickOK)
    {
        HWND hwnd = plv->ci.hwnd;

        KillTimer(plv->ci.hwnd, IDT_ONECLICKHAPPENED);
        plv->fOneClickHappened = FALSE;
        CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &(plv->nmOneClickHappened.hdr));
        if (!IsWindow(hwnd))
            return;
    }

    plv->iNoHover = iItem;
    bSelected = ListView_OnGetItemState(plv, iItem, LVIS_SELECTED);

    if (ht.flags & (LVHT_ONITEMLABEL | LVHT_ONITEMICON))
    {
        UINT keyFlags = 0;

        if (fShift)
            keyFlags |= MK_SHIFT;
        if (fControl)
            keyFlags |= MK_CONTROL;

        if (!bSelected) 
        {
            // if it wasn't selected, we're about to select it... play
            // a little ditty for us...
            CCPlaySound(c_szSelect);
        }

        ListView_ButtonSelect(plv, iItem, keyFlags, bSelected);

        if (fControl)
        {
            ListView_SetFocusSel(plv, iItem, !fShift, FALSE, !fShift);
        }

        if (!fShift)
            plv->iMark = iItem;

        ListView_OnSetCursorMsg(plv);

        SetFocus(plv->ci.hwnd);    // activate this window
    }
}

BOOL EqualRects(LPRECT prcNew, LPRECT prcOld, int nRects)
{
    int i;
    for (i = 0; i < nRects; i++)
        if (!EqualRect(&prcNew[i], &prcOld[i]))
            return FALSE;
    return TRUE;
}

BOOL ListView_FindWorkArea(LV * plv, POINT pt, short * piWorkArea)
{
    int iWork;
    for (iWork = 0; iWork < plv->nWorkAreas; iWork++)
    {
        if (PtInRect(&plv->prcWorkAreas[iWork], pt))
        {
            *piWorkArea = (short)iWork;
            return TRUE;
        }
    }

    // (dli) default case is the primary work area
    *piWorkArea = 0;
    return FALSE;
}

void ListView_BullyIconsOnWorkarea(LV * plv, HDPA hdpaLostItems)
{
    int ihdpa;
    int iFree = -1;  // the last free slot number
    LVFAKEDRAW lvfd;
    LV_ITEM item;

    // Caller should've filtered this case out
    ASSERT(DPA_GetPtrCount(hdpaLostItems) > 0);

    // Set up in case caller is customdraw
    ListView_BeginFakeCustomDraw(plv, &lvfd, &item);
    item.mask = LVIF_PARAM;
    item.iSubItem = 0;

    // Go through my hdpa list of lost icons and try to place them within bound
    for (ihdpa = 0; ihdpa < DPA_GetPtrCount(hdpaLostItems); ihdpa++)
    {
        POINT ptNew, pt;
        RECT rcBound = {0};
        int cxBound, cyBound;
        int iWidth, iHeight;
        int iItem;
        LISTITEM * pitem;

        iItem = PtrToUlong(DPA_GetPtr(hdpaLostItems, ihdpa));
        pitem = ListView_FastGetItemPtr(plv, iItem);
        pt = pitem->pt;

        iWidth  = RECTWIDTH(plv->prcWorkAreas[pitem->iWorkArea]);
        iHeight = RECTHEIGHT(plv->prcWorkAreas[pitem->iWorkArea]);

        ListView_GetRects(plv, iItem, QUERY_DEFAULT, NULL, NULL, &rcBound, NULL);
        cxBound = RECTWIDTH(rcBound);
        cyBound = RECTHEIGHT(rcBound);

        pt.x -= plv->prcWorkAreas[pitem->iWorkArea].left;
        pt.y -= plv->prcWorkAreas[pitem->iWorkArea].top;

        if (pt.x < (-cxBound / 2))
        {
            ptNew.x = 0;
        }
        else if (pt.x > (iWidth - (cxBound / 2))) 
        {
            ptNew.x = iWidth - cxBound;
        }
        else
            ptNew.x = pt.x;

        if (pt.y < (-cyBound/2))
        {
            ptNew.y = 0;
        }
        else if (pt.y > (iHeight - (cyBound / 2))) 
        {
            ptNew.y = iHeight - cyBound;
        }
        else
            ptNew.y = pt.y;

        if ((ptNew.x != pt.x) || (ptNew.y != pt.y))
        {
            BOOL fUpdate;
            RECT rcTest;
            ptNew.x += plv->prcWorkAreas[pitem->iWorkArea].left;
            ptNew.y += plv->prcWorkAreas[pitem->iWorkArea].top;

            // See if the potential rectangle intersects other items.
            rcTest.left = ptNew.x - plv->ptOrigin.x;
            rcTest.top = ptNew.y - plv->ptOrigin.y;
            rcTest.right = rcTest.left + cxBound;
            rcTest.bottom = rcTest.top + cyBound;

            item.iItem = iItem;
            item.lParam = pitem->lParam;
            ListView_BeginFakeItemDraw(&lvfd);

            if (!ListView_IsCleanRect(plv, &rcTest, iItem, QUERY_DEFAULT, &fUpdate, lvfd.nmcd.nmcd.hdc))
            {
                // doh! We hit another item, let's try to find an available location
                // for this item
                BOOL fUpdateSB;
                BOOL fAppendAtEnd = FALSE;
                int  iWidth, iHeight;
                int cSlots = ListView_GetSlotCountEx(plv, FALSE, pitem->iWorkArea, &iWidth, &iHeight);
                iFree = ListView_FindFreeSlot(plv, iItem, iFree + 1, cSlots, QUERY_DEFAULT, &fUpdateSB, &fAppendAtEnd, lvfd.nmcd.nmcd.hdc, iWidth, iHeight);
                if (iFree == -1)
                    goto SetFirstGuess;
                ListView_SetIconPos(plv, pitem, iFree, cSlots);
                ListView_EndFakeItemDraw(&lvfd);
                continue;
            }
SetFirstGuess:
            ListView_EndFakeItemDraw(&lvfd);
            ListView_OnSetItemPosition(plv, iItem, ptNew.x, ptNew.y);
        }
    }
    ListView_EndFakeCustomDraw(&lvfd);
}

#define DPA_LAST    0x7fffffff

//
// ListView_OnSetWorkAreas
//
// set the "work areas" for the list view.
// the "work areas" are a group of sub rectanges of the list view client rect
// where icons are aranged, and parked by default.
//
void ListView_OnSetWorkAreas(LV* plv, int nWorkAreas, LPRECT prc)
{
    int iWork;
    HDPA hdpaLostItems = NULL;
    RECT rcOldWorkAreas[LV_MAX_WORKAREAS];

    BOOL bAutoArrange = plv->ci.style & LVS_AUTOARRANGE;
    int nOldWorkAreas = plv->nWorkAreas;

    if (nOldWorkAreas > 0)
    {
        ASSERT(plv->prcWorkAreas != NULL);
        memcpy(&rcOldWorkAreas[0], &plv->prcWorkAreas[0], sizeof(RECT) * nOldWorkAreas);
    }
    // for the mirrored case, the coordinates are reversed. IsRectEmpty() will always succeed
    if (nWorkAreas == 0 || prc == NULL || ((IsRectEmpty(prc)) && !(plv->ci.dwExStyle & RTL_MIRRORED_WINDOW)))
        plv->nWorkAreas = 0;
    else
    {
        plv->nWorkAreas = min(nWorkAreas, LV_MAX_WORKAREAS);

        if (plv->prcWorkAreas == NULL)
            plv->prcWorkAreas = (LPRECT)LocalAlloc(LPTR, sizeof(RECT) * LV_MAX_WORKAREAS);

        if (plv->prcWorkAreas == NULL)
            return;

        //Should we check if they intersect? This problem is sort of
        // solved (or made more confusing) by ListView_GetFreeSlot since it checks all of the icons for
        // intersection instead of just the ones in the workarea.
        for (iWork = 0; iWork < plv->nWorkAreas; iWork++)
            CopyRect(&plv->prcWorkAreas[iWork], &prc[iWork]);
    }

    // We don't support workareas for owner-data because our icon placement
    // algorithm (ListView_IGetRectsOwnerData) completely ignores workareas
    // and just dumps the icons in a rectangular array starting at (0,0).
    if (!ListView_IsOwnerData(plv) &&
        plv->nWorkAreas > 0 &&
        ((plv->nWorkAreas  != nOldWorkAreas) ||
         (!EqualRects(&plv->prcWorkAreas[0], &rcOldWorkAreas[0], nOldWorkAreas))))
    {
        int iItem;
        LISTITEM * pitem;

        //
        //  Subtle - ListView_Recompute cleans up all the RECOMPUTE icons,
        //  but in order to do that, it needs to have valid work area
        //  rectangles. So the call must happen after the CopyRect but before
        //  the loop that checks the icon positions.
        //
        ListView_Recompute(plv);

        for (iItem = 0; iItem < ListView_Count(plv); iItem++)
        {
            pitem = ListView_FastGetItemPtr(plv, iItem);

            if (pitem->pt.x == RECOMPUTE || pitem->pt.y == RECOMPUTE)
            {
                // ListView_Recompute should've fixed these if we were in
                // an iconical view.
                ASSERT(!(ListView_IsIconView(plv) || ListView_IsSmallView(plv)));
                continue;
            }

            // Try to move me to the same location relative to the same workarea.
            // This will give the cool shift effect when tools bars take the border areas.
            // And we only want to do this for the workareas that changed

            // Don't bully the icons on the workareas, Autoarrange will do the work for us

            if (nOldWorkAreas > 0)
            {
                int iOldWorkArea;
                iOldWorkArea = pitem->iWorkArea;
                if (iOldWorkArea >= plv->nWorkAreas)
                {
                    // My workarea is gone, put me on the primary workarea i.e. #0
                    pitem->iWorkArea = 0;
                    if (!bAutoArrange)
                    {
                        // If this item point location is already in the new primary workarea,
                        // move it out, and let ListView_BullyIconsOnWorkarea arrange it to the
                        // right place. NOTE: this could happen in the case the old secondary monitor
                        // is to the left of the old primary monitor, and user kills the secondary monitor
                        if (PtInRect(&plv->prcWorkAreas[0], pitem->pt))
                        {
                            pitem->pt.x = plv->prcWorkAreas[0].right + 1;
                            plv->iFreeSlot = -1; // an item moved -- old slot info is invalid
                        }
                        goto  InsertLostItemsArray;
                    }
                }
                else if ((!bAutoArrange) && (!EqualRect(&plv->prcWorkAreas[iOldWorkArea], &rcOldWorkAreas[iOldWorkArea])))
                {
                    RECT rcBound = {0};
                    POINT ptCenter;
                    pitem->pt.x += plv->prcWorkAreas[iOldWorkArea].left - rcOldWorkAreas[iOldWorkArea].left;
                    pitem->pt.y += plv->prcWorkAreas[iOldWorkArea].top - rcOldWorkAreas[iOldWorkArea].top;

                    // Use the center of this icon to determine whether it's out of bound
                    ListView_GetRects(plv, iItem, QUERY_DEFAULT, NULL, NULL, &rcBound, NULL);
                    ptCenter.x = pitem->pt.x + RECTWIDTH(rcBound) / 2;
                    ptCenter.y = pitem->pt.y + RECTHEIGHT(rcBound) / 2;

                    // If this shifted me out of bounds, register to be bullied on the workarea
                    if (!PtInRect(&plv->prcWorkAreas[iOldWorkArea], ptCenter))
                    {
InsertLostItemsArray:
                        if (!hdpaLostItems)
                        {
                            hdpaLostItems = DPA_Create(4);
                        }

                        if (hdpaLostItems)
                            DPA_InsertPtr(hdpaLostItems, DPA_LAST, IntToPtr(iItem));
                    }
                }

            }
            else
            {
                // My first time in a multi-workarea system, so find out my workarea
                if (!ListView_FindWorkArea(plv, pitem->pt, &(pitem->iWorkArea)) && !bAutoArrange)
                    goto InsertLostItemsArray;
            }

            if ((plv->exStyle & LVS_EX_REGIONAL) && (pitem->hrgnIcon))
            {
                if (pitem->hrgnIcon != (HANDLE)-1)
                    DeleteObject(pitem->hrgnIcon);
                pitem->hrgnIcon = NULL;
            }
        }

        if (hdpaLostItems)
        {
            ASSERT(!bAutoArrange);
            if (DPA_GetPtrCount(hdpaLostItems) > 0)
                ListView_BullyIconsOnWorkarea(plv, hdpaLostItems);

            DPA_Destroy(hdpaLostItems);
        }

        if (plv->exStyle & LVS_EX_REGIONAL)
            ListView_RecalcRegion(plv, TRUE, TRUE);

        if (ListView_IsSmallView(plv) || ListView_IsIconView(plv))
            ListView_ArrangeOrSnapToGrid(plv);
    }

    RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
}

void ListView_OnGetNumberOfWorkAreas(LV* plv, int * pnWorkAreas)
{
    if (pnWorkAreas)
        *pnWorkAreas = plv->nWorkAreas;
}

void ListView_OnGetWorkAreas(LV* plv, int nWorkAreas, LPRECT prc)
{
    int i;

    if (prc == NULL)
        return;

    for (i = 0; i < min(plv->nWorkAreas, nWorkAreas); i++)
    {
        if (i < plv->nWorkAreas)
            CopyRect(&prc[i], &plv->prcWorkAreas[i]);
        else
            // Set the workareas to all zeros if we don't have it.
            ZeroMemory(&prc[i], sizeof(RECT));
    }
}

// test an item to see if it is unfolded (because it is focused)

BOOL ListView_IsItemUnfolded(LV *plv, int item)
{
    return plv && (item >= 0) && ListView_IsIconView(plv) &&
           (plv->flags & LVF_UNFOLDED) && (plv->iFocus == item);
}

BOOL ListView_IsItemUnfoldedPtr(LV *plv, LISTITEM *pitem)
{
    return plv && pitem && ListView_IsIconView(plv) &&
           (plv->flags & LVF_UNFOLDED) && (pitem->state & LVIS_FOCUSED);
}

// Returns TRUE if unfolding the item will be worthwhile
BOOL ListView_GetUnfoldedRect(LV* plv, int iItem, RECT *prc)
{
    ListView_GetRects(plv, iItem, QUERY_DEFAULT, NULL, prc, NULL, NULL);
    return ListView_UnfoldRects(plv, iItem, NULL, prc, NULL, NULL);
}

BOOL ListView_OnSetGroupInfoInternal(LV* plv, PLVGROUP plvgrp, LISTGROUP* pgrp)
{
    if (plvgrp == NULL ||
        plvgrp->cbSize < sizeof(LVGROUP))
    {
        return FALSE;
    }

    if (plvgrp->mask & LVGF_STATE)
    {
        if ((plvgrp->state & LVGS_MASK) != plvgrp->state)
            return FALSE;

        pgrp->state = plvgrp->state;
    }

    if (plvgrp->mask & LVGF_ALIGN)
    {
        if ((plvgrp->uAlign & LVGA_ALIGN_MASK) != plvgrp->uAlign)
            return FALSE;

        pgrp->uAlign = plvgrp->uAlign;
    }
    else
    {
        pgrp->uAlign = LVGA_HEADER_LEFT;

    }

    if (ListView_VerifyGroupIdIsUnique(plv, plvgrp->iGroupId))
    {
        pgrp->iGroupId = plvgrp->iGroupId;
    }
    else
    {
        return FALSE;
    }

    if (plvgrp->mask & LVGF_HEADER)
    {
        Str_SetPtr(&pgrp->pszHeader, plvgrp->pszHeader);
    }

    if (plvgrp->mask & LVGF_FOOTER)
    {
        Str_SetPtr(&pgrp->pszFooter, plvgrp->pszFooter);
    }

    // Update the group.
    InvalidateRect(plv->ci.hwnd, &pgrp->rc, TRUE);

    return TRUE;
}

int ListView_OnSetGroupInfo(LV* plv, int iGroupId, PLVGROUP plvgrp)
{
    LISTGROUP* pgrp = ListView_FindGroupFromID(plv, iGroupId, NULL);
    if (pgrp)
    {
        ListView_OnSetGroupInfoInternal(plv, plvgrp, pgrp);
        return iGroupId;
    }

    return -1;
}

int ListView_OnGetGroupInfo(LV* plv, int iGroupId, PLVGROUP plvgrp)
{
    LISTGROUP* pgrp = ListView_FindGroupFromID(plv, iGroupId, NULL);

    if (plvgrp != NULL &&
        plvgrp->cbSize >= sizeof(LVGROUP) &&
        pgrp)
    {
        if (plvgrp->mask & LVGF_HEADER)
        {
            plvgrp->pszHeader = pgrp->pszHeader;
        }

        if (plvgrp->mask & LVGF_FOOTER)
        {
            plvgrp->pszFooter = pgrp->pszFooter;
        }

        if (plvgrp->mask & LVGF_STATE)
        {
            plvgrp->state = pgrp->state & plvgrp->stateMask;
        }

        if (plvgrp->mask & LVGF_ALIGN)
        {
            plvgrp->uAlign = pgrp->uAlign;
        }

        if (plvgrp->mask & LVGF_GROUPID)
        {
            plvgrp->iGroupId = pgrp->iGroupId;
        }

        return iGroupId;
    }
    return -1;
}

LISTGROUP* ListView_CreateGroup(LV* plv, PLVGROUP plvgrp)
{
    LISTGROUP* pgrp;
    
    // Validate Group
    if (plvgrp == NULL ||
        plvgrp->cbSize < sizeof(LVGROUP))
    {
        return NULL;
    }

    if (!(plvgrp->mask & LVGF_GROUPID))
    {
        // Have to have a group id...
        return NULL;
    }

    pgrp = LocalAlloc(LPTR, sizeof(LISTGROUP));
    if (pgrp)
    {
        if (!ListView_OnSetGroupInfoInternal(plv, plvgrp, pgrp))
        {
            LocalFree(pgrp);
            return NULL;
        }

        pgrp->hdpa = DPA_Create(5);
        SetRect(&pgrp->rc, 0, 0, 0, 0);
    }
    return pgrp;
}

void ListView_FreeGroupItem(LISTGROUP* pgrp)
{
    DPA_Destroy(pgrp->hdpa);
    Str_SetPtr(&pgrp->pszFooter, NULL);
    Str_SetPtr(&pgrp->pszHeader, NULL);
    LocalFree(pgrp);
}

LISTGROUP* ListView_FindFirstVisibleGroup(LV* plv)
{
    LISTGROUP* pgrp = NULL;
    int iGroup;
    int cGroups = DPA_GetPtrCount(plv->hdpaGroups);

    // Find the first group with an item in it.
    for (iGroup = 0; iGroup < cGroups; iGroup++)
    {
        pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
        if (DPA_GetPtrCount(pgrp->hdpa) > 0)
            break;
    }

    return pgrp;
}


LRESULT ListView_OnInsertGroup(LV* plv, int iGroup, PLVGROUP plvgrp)
{
    int iInsert = -1;
    LISTGROUP* pgrp = ListView_CreateGroup(plv, plvgrp);

    if (!pgrp)
    {
        return -1;
    }

    if (iGroup == -1)
    {
        iGroup = DA_LAST;
    }

    if (plv->hdpaGroups == NULL)
        plv->hdpaGroups = DPA_Create(4);

    if (plv->hdpaGroups)
        iInsert = DPA_InsertPtr(plv->hdpaGroups, iGroup, pgrp);

    if (iInsert == -1)
    {
        ListView_FreeGroupItem(pgrp);
    }

    plv->rcView.left = RECOMPUTE;
    InvalidateRect(plv->ci.hwnd, NULL, TRUE);

    return iInsert;
}


LRESULT ListView_OnRemoveGroup(LV* plv, int iGroupId)
{
    int iIndex;
    LISTGROUP* pgrp = ListView_FindGroupFromID(plv, iGroupId, &iIndex);
    if (pgrp)
    {
        int cItems = DPA_GetPtrCount(pgrp->hdpa);
        int iItem;
        for (iItem = 0; iItem < cItems; iItem++)
        {
            LISTITEM* pitem = DPA_FastGetPtr(pgrp->hdpa, iItem);
            if (pitem)
            {
                LISTITEM_SETHASNOTASKEDFORGROUP(pitem);
            }
        }

        ListView_FreeGroupItem(pgrp);

        DPA_DeletePtr(plv->hdpaGroups, iIndex);
        plv->rcView.left = RECOMPUTE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);

        return iIndex;
    }

    return -1;
}

int CALLBACK DestroyGroups(void* pv, void* pvData)
{
    LISTGROUP* pgrp = (LISTGROUP*)pv;
    ListView_FreeGroupItem(pgrp);
    return 1;
}

LRESULT ListView_OnRemoveAllGroups(LV* plv)
{
    if (!ListView_IsOwnerData(plv) && plv->hdpaGroups)
    {
        int i;
        int cItems = ListView_Count(plv);

        plv->fGroupView = FALSE;

        for (i = 0; i < cItems; i++)
        {
            LISTITEM* pitem = DPA_FastGetPtr(plv->hdpa, i);
            if (pitem)
                LISTITEM_SETHASNOTASKEDFORGROUP(pitem);
        }


        DPA_DestroyCallback(plv->hdpaGroups, DestroyGroups, NULL);
        plv->hdpaGroups = NULL;

        plv->rcView.left = RECOMPUTE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    return 1;
}


LRESULT ListView_OnSetGroupMetrics(LV* plv, PLVGROUPMETRICS pgm)
{
    BOOL fRecompute = FALSE;

    if (pgm->mask & LVGMF_BORDERSIZE)
    {
        plv->rcBorder.left = pgm->Left;
        plv->rcBorder.top = pgm->Top;
        plv->rcBorder.right = pgm->Right;
        plv->rcBorder.bottom = pgm->Bottom;
        fRecompute = TRUE;
    }

    if (pgm->mask & LVGMF_BORDERCOLOR)
    {
        plv->crTop = pgm->crTop;
        plv->crLeft = pgm->crLeft;
        plv->crRight = pgm->crRight;
        plv->crBottom = pgm->crBottom;
    }

    if (pgm->mask & LVGMF_TEXTCOLOR)
    {
        plv->crHeader = pgm->crHeader;
        plv->crFooter = pgm->crFooter;
    }

    if (fRecompute)
    {
        plv->rcView.left = RECOMPUTE;
        ListView_Recompute(plv);
        ListView_UpdateScrollBars(plv);
    }
    InvalidateRect(plv->ci.hwnd, NULL, TRUE);

    return 1;
}

LRESULT ListView_OnGetGroupMetrics(LV* plv, PLVGROUPMETRICS pgm)
{
    if (pgm->mask & LVGMF_BORDERSIZE)
    {
        pgm->Left = plv->rcBorder.left;
        pgm->Top = plv->rcBorder.top;
        pgm->Right = plv->rcBorder.right;
        pgm->Bottom = plv->rcBorder.bottom;
    }

    if (pgm->mask & LVGMF_BORDERCOLOR)
    {
        pgm->crTop = plv->crTop;
        pgm->crLeft = plv->crLeft;
        pgm->crRight = plv->crRight;
        pgm->crBottom = plv->crBottom;
    }

    if (pgm->mask & LVGMF_TEXTCOLOR)
    {
        pgm->crHeader = plv->crHeader;
        pgm->crFooter= plv->crFooter;
    }

    return 1;
}

typedef struct
{
    PFNLVGROUPCOMPARE pfnCompare;
    void * pvData;
} SORTGROUPDATA;

int CALLBACK pfnGroupSort(LPARAM one, LPARAM two, LPARAM pvData)
{
    SORTGROUPDATA* psg  = (SORTGROUPDATA*)pvData;
    LISTGROUP* pgrp1 = (LISTGROUP*)one;
    LISTGROUP* pgrp2 = (LISTGROUP*)two;

    if (!one)
        return 1;

    if (!two)
        return -1;

    return psg->pfnCompare(pgrp1->iGroupId, pgrp2->iGroupId, psg->pvData);
}

LRESULT ListView_OnSortGroups(LV* plv, PFNLVGROUPCOMPARE pfnCompare, void * pvData)
{
    if (plv->hdpaGroups)
    {
        SORTGROUPDATA sg;
        sg.pfnCompare = pfnCompare;
        sg.pvData = pvData;
        DPA_Sort(plv->hdpaGroups, (PFNDPACOMPARE)pfnGroupSort, (LPARAM)&sg);

        plv->rcView.left = RECOMPUTE;
        ListView_Recompute(plv);
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        ListView_UpdateScrollBars(plv);

        return 1;
    }

    return 0;
}

LRESULT ListView_OnInsertGroupSorted(LV* plv, LVINSERTGROUPSORTED* pinsert)
{
    int iInsertIndex = -1;
    SORTGROUPDATA sg;
    LISTGROUP* pgrp = ListView_CreateGroup(plv, &pinsert->lvGroup);

    sg.pfnCompare = pinsert->pfnGroupCompare;
    sg.pvData = pinsert->pvData;

    if (pgrp)
    {
        if (plv->hdpaGroups == NULL)
            plv->hdpaGroups = DPA_Create(4);

        if (plv->hdpaGroups)
        {
            iInsertIndex = DPA_SortedInsertPtr(plv->hdpaGroups, pgrp, 0, (PFNDPACOMPARE)pfnGroupSort, 
                (LPARAM)&sg, DPAS_INSERTAFTER, pgrp);
        }
        if (iInsertIndex == -1)
            ListView_FreeGroupItem(pgrp);

        plv->rcView.left = RECOMPUTE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    return iInsertIndex;
}

BOOL ListView_OnSetTileViewInfo(LV* plv, PLVTILEVIEWINFO pTileViewInfo)
{
    BOOL bRecompute = FALSE;
    if (!pTileViewInfo || (pTileViewInfo->cbSize != sizeof(LVTILEVIEWINFO)))
        return FALSE;

    if (pTileViewInfo->dwMask & LVTVIM_COLUMNS)
    {
        if (plv->cSubItems != pTileViewInfo->cLines)
        {
            bRecompute = TRUE;
            plv->cSubItems = pTileViewInfo->cLines;
        }
    }

    if (pTileViewInfo->dwMask & LVTVIM_TILESIZE)
    {
        DWORD dwTileFlags = pTileViewInfo->dwFlags & (LVTVIF_FIXEDHEIGHT | LVTVIF_FIXEDWIDTH);

        if (plv->dwTileFlags != dwTileFlags)
        {
            plv->dwTileFlags = dwTileFlags;
            bRecompute = TRUE;
        }

        if (ListView_IsDPIScaled(plv))
        {
            CCDPIScaleX(&pTileViewInfo->sizeTile.cx);
            CCDPIScaleY(&pTileViewInfo->sizeTile.cy);
        }


        if ((plv->dwTileFlags & LVTVIF_FIXEDHEIGHT) &&
            plv->sizeTile.cy != pTileViewInfo->sizeTile.cy)
        {
            plv->sizeTile.cy = pTileViewInfo->sizeTile.cy;
            bRecompute = TRUE;
        }

        if ((plv->dwTileFlags & LVTVIF_FIXEDWIDTH) &&
            plv->sizeTile.cx != pTileViewInfo->sizeTile.cx)
        {
            plv->sizeTile.cx = pTileViewInfo->sizeTile.cx;
            bRecompute = TRUE;
        }

    }

    if ((pTileViewInfo->dwMask & LVTVIM_LABELMARGIN) &&
        !EqualRect(&plv->rcTileLabelMargin, &pTileViewInfo->rcLabelMargin))
    {
        plv->rcTileLabelMargin = pTileViewInfo->rcLabelMargin;
        bRecompute = TRUE;
    }

    if (bRecompute)
    {
        ListView_RecalcTileSize(plv);
        plv->rcView.left = RECOMPUTE;
        ListView_Recompute(plv);
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }
    return TRUE;
}

BOOL ListView_OnGetTileViewInfo(LV* plv, PLVTILEVIEWINFO pTileViewInfo)
{
    if (!pTileViewInfo || (pTileViewInfo->cbSize != sizeof(LVTILEVIEWINFO)))
        return FALSE;

    if (pTileViewInfo->dwMask & LVTVIM_COLUMNS)
    {
        pTileViewInfo->cLines = plv->cSubItems;
    }

    if (pTileViewInfo->dwMask & LVTVIM_TILESIZE)
    {
        pTileViewInfo->dwFlags = plv->dwTileFlags;
        pTileViewInfo->sizeTile = plv->sizeTile;
    }

    if (pTileViewInfo->dwMask & LVTVIM_LABELMARGIN)
    {
        pTileViewInfo->rcLabelMargin = plv->rcTileLabelMargin;
    }

    return TRUE;
}

BOOL ListView_OnSetTileInfo(LV* plv, PLVTILEINFO pTileInfo)
{
    LVITEM lvi;

    if (!pTileInfo || (pTileInfo->cbSize != sizeof(LVTILEINFO)))
        return FALSE;

    lvi.mask = LVIF_COLUMNS;
    lvi.cColumns = pTileInfo->cColumns;
    lvi.puColumns = pTileInfo->puColumns;
    lvi.iSubItem = 0;
    lvi.iItem = pTileInfo->iItem;

    return ListView_OnSetItem(plv, &lvi);
}

BOOL ListView_OnGetTileInfo(LV* plv, PLVTILEINFO pTileInfo)
{
    LVITEM lvi;

    if (!pTileInfo || (pTileInfo->cbSize != sizeof(LVTILEINFO)))
        return FALSE;

    lvi.mask = LVIF_COLUMNS;
    lvi.iSubItem = 0;
    lvi.iItem = pTileInfo->iItem;
    lvi.cColumns = pTileInfo->cColumns;
    lvi.puColumns = pTileInfo->puColumns;

    if (ListView_OnGetItem(plv, &lvi))
    {
        pTileInfo->cColumns = lvi.cColumns;
        return TRUE;
    }
    return FALSE;
}

LRESULT ListView_OnSetInsertMark(LV* plv, LPLVINSERTMARK plvim)
{
    if (plvim->cbSize != sizeof(LVINSERTMARK))
        return 0;

    if (plvim->iItem != plv->iInsertItem ||
        BOOLIFY(plv->fInsertAfter) != BOOLIFY(plvim->dwFlags & LVIM_AFTER))
    {
        if (plv->iInsertItem != -1)
            ListView_InvalidateMark(plv);

        plv->iInsertItem = plvim->iItem;
        plv->fInsertAfter = BOOLIFY(plvim->dwFlags & LVIM_AFTER);

        if (plv->iInsertItem != -1)
            ListView_InvalidateMark(plv);
    }

    return 1;
}

LRESULT ListView_OnSetInfoTip(LV *plv, PLVSETINFOTIP plvSetInfoTip)
{
    LPWSTR pszText = NULL;
    LPWSTR pszProduced = NULL;
    LRESULT lRet = 0;

    // Check size and flags. MBZ for now.
    if (plvSetInfoTip->cbSize == sizeof(LVSETINFOTIP) && 
        plvSetInfoTip->dwFlags == 0 &&
        plvSetInfoTip->pszText != NULL)
    {
        pszText = plvSetInfoTip->pszText;

        // If we are still looking at the same item, then set its text, and pop up the tip.
        if (plvSetInfoTip->iItem == plv->iTTLastHit && plvSetInfoTip->iSubItem == plv->iTTLastSubHit)
        {
            TCHAR szBuf[INFOTIPSIZE];
            BOOL bItemUnfolded;
            BOOL fInfoTip = FALSE;
            szBuf[0] = 0;

            // preload the default tip text for folded items.
            bItemUnfolded = ListView_IsItemUnfolded2(plv, plv->iTTLastHit, plv->iTTLastSubHit, szBuf, ARRAYSIZE(szBuf));

            if (ListView_IsInfoTip(plv) && plv->iTTLastSubHit == 0)
            {
                if (*pszText && lstrcmp(szBuf, pszText) != 0)
                {
                    // App changed something - there is a real infotip
                    fInfoTip = TRUE;
                }
            }
            else
            {
                pszText = szBuf;
            }
        
            //
            // Set the margins now before the TTN_SHOW because it will be too late then.
            //
            // We want fat margins if we're an infotip, thin margins if we're an
            // in-place tooltip.
            //
            if (fInfoTip)
            {
                static const RECT rcMargin = {4, 4, 4, 4};
                SendMessage(plv->hwndToolTips, TTM_SETMARGIN, 0, (LPARAM)&rcMargin);
                CCSetInfoTipWidth(plv->ci.hwnd, plv->hwndToolTips);
                plv->fPlaceTooltip = FALSE;     // Set it to TRUE only if Unfolding tip is set

            }
            else
            {
                static const RECT rcMargin = {0, 0, 0, 0};
                plv->fPlaceTooltip = TRUE;
                SendMessage(plv->hwndToolTips, TTM_SETMARGIN, 0, (LPARAM)&rcMargin);
                CCResetInfoTipWidth(plv->ci.hwnd, plv->hwndToolTips);
            }

            Str_Set(&plv->pszTip, pszText);

            // Re-display tooltip. If tracking, call tracking start code (same as timer code)
            if (!ListView_IsKbdTipTracking(plv))
                lRet = SendMessage(plv->hwndToolTips, TTM_POPUP, 0, 0);
            else
                ListView_OnTimer(plv, IDT_TRACKINGTIP);
        }

        if (pszProduced)
            FreeProducedString(pszProduced);
    }
    return lRet;
}

LRESULT ListView_OnNotify(LV* plv, WPARAM wParam, LPNMHDR pnmh)
{
    // we can't switch on the control ID because the tooltip is a WS_POPUP window
    // and does not have a control ID. (header and tooltip both have 0 as ID)

    if (plv->hwndHdr && (plv->hwndHdr == pnmh->hwndFrom))
    {
        // this is a notify for the header, deal with it as needed

        return ListView_HeaderNotify(plv, (HD_NOTIFY *)pnmh);
    }
    else if (plv->hwndToolTips && (plv->hwndToolTips == pnmh->hwndFrom))
    {
        // implement unfolding the text for items as well as info tip support

        switch (pnmh->code)
        {
        case TTN_NEEDTEXT:
        {
            POINT pt;
            UINT uFlags;
            int iNewHit;
            int iNewSubHit;
            NMTTDISPINFO *pttt = (NMTTDISPINFO *)pnmh;

            // If keyboard tracking, do not hit test based on last cursor position
            if (ListView_IsKbdTipTracking(plv))
            {
                RECT rcItem;
                ListView_GetItemRect(plv->ci.hwnd, plv->iTracking, &rcItem, LVIR_LABEL);

                pt.x = rcItem.left;
                pt.y = rcItem.top;
            }
            else
                GetMessagePosClient(plv->ci.hwnd, &pt);

            iNewHit = _ListView_ItemHitTest(plv, pt.x, pt.y, &uFlags, &iNewSubHit);

            if (iNewHit != plv->iTTLastHit || iNewSubHit != plv->iTTLastSubHit)
            {
                plv->fPlaceTooltip = FALSE;     // Set it to TRUE only if Unfolding tip is set
                Str_Set(&plv->pszTip, NULL);    // clear the old tip

                plv->iTTLastHit = iNewHit;
                plv->iTTLastSubHit = iNewSubHit;

                if ((iNewHit >= 0) && (plv->iEdit == -1))
                {
                    TCHAR szBuf[INFOTIPSIZE], szBuf2[INFOTIPSIZE];
                    BOOL bItemUnfolded;
                    BOOL fInfoTip = FALSE;
                    LPTSTR pszTip = szBuf;  // Use this one first

                    szBuf[0] = 0;
                    szBuf2[0] = 0;

                    // preload the tip text for folded items. this
                    // may be overridden by callback below
                    bItemUnfolded = ListView_IsItemUnfolded2(plv, plv->iTTLastHit, plv->iTTLastSubHit, szBuf, ARRAYSIZE(szBuf));
                    lstrcpyn(szBuf2, szBuf, ARRAYSIZE(szBuf2)); // Backup the unfolding text

                    if (ListView_IsInfoTip(plv) && iNewSubHit == 0)
                    {
                        NMLVGETINFOTIP git;

                        git.dwFlags = bItemUnfolded ? LVGIT_UNFOLDED : 0;
                        git.pszText = szBuf;
                        git.cchTextMax = ARRAYSIZE(szBuf);
                        git.iItem = plv->iTTLastHit;
                        git.iSubItem = 0;
                        git.lParam = 0;

                        // for folded items pszText is prepopulated with the
                        // item text, clients should append to this

                        CCSendNotify(&plv->ci, LVN_GETINFOTIP, &git.hdr);

                        if (*szBuf && lstrcmp(szBuf, szBuf2) != 0)
                        {
                            // App changed something - there is a real infotip
                            fInfoTip = TRUE;
                        }

                    }
                    
                    //
                    // Set the margins now before the TTN_SHOW because it will be too late then.
                    //
                    // We want fat margins if we're an infotip, thin margins if we're an
                    // in-place tooltip.
                    //
                    if (fInfoTip)
                    {
                        static const RECT rcMargin = {4, 4, 4, 4};
                        SendMessage(plv->hwndToolTips, TTM_SETMARGIN, 0, (LPARAM)&rcMargin);
                        CCSetInfoTipWidth(plv->ci.hwnd, plv->hwndToolTips);

                    }
                    else
                    {
                        static const RECT rcMargin = {0, 0, 0, 0};
                        plv->fPlaceTooltip = TRUE;
                        SendMessage(plv->hwndToolTips, TTM_SETMARGIN, 0, (LPARAM)&rcMargin);
                        CCResetInfoTipWidth(plv->ci.hwnd, plv->hwndToolTips);
                    }

                    Str_Set(&plv->pszTip, pszTip);
                }
            }

            pttt->lpszText = plv->pszTip;     // here it is...
        }
        break;

        // Handle custom draw as we want the tooltip painted as a multi-line that
        // matches the formatting used by the list view.

        case NM_CUSTOMDRAW:
        {
            LPNMTTCUSTOMDRAW pnm = (LPNMTTCUSTOMDRAW) pnmh;

            if (plv->fPlaceTooltip &&
                (pnm->nmcd.dwDrawStage == CDDS_PREPAINT ||
                 pnm->nmcd.dwDrawStage == CDDS_ITEMPREPAINT))
            {
                DWORD dwCustom = 0;

                //
                //  Set up the customdraw DC to match the font of the LV item.
                //
                if (plv->iTTLastHit != -1)
                {
                    LVFAKEDRAW lvfd;
                    LV_ITEM item;
                    ListView_BeginFakeCustomDraw(plv, &lvfd, &item);

                    item.iItem = plv->iTTLastHit;
                    item.iSubItem = plv->iTTLastSubHit;
                    item.mask = LVIF_PARAM;
                    ListView_OnGetItem(plv, &item);
                    dwCustom = ListView_BeginFakeItemDraw(&lvfd);

                    // If client changed the font, then transfer the font
                    // from our private hdc into the tooltip's HDC.  We use
                    // a private HDC because we only want to let the app change
                    // the font, not the colors or anything else.
                    if (dwCustom & CDRF_NEWFONT)
                    {
                        SelectObject(pnm->nmcd.hdc, GetCurrentObject(lvfd.nmcd.nmcd.hdc, OBJ_FONT));
                    }
                    ListView_EndFakeItemDraw(&lvfd);
                    ListView_EndFakeCustomDraw(&lvfd);

                }

                //
                //  The Large Icon tooltip needs to be drawn specially.
                //
                if (ListView_IsIconView(plv))
                {
                    pnm->uDrawFlags &= ~(DT_SINGLELINE|DT_LEFT);
                    pnm->uDrawFlags |= DT_CENTER|DT_LVWRAP;

                    if (pnm->uDrawFlags & DT_CALCRECT)
                    {
                        pnm->nmcd.rc.right = pnm->nmcd.rc.left + (plv->cxIconSpacing - g_cxLabelMargin * 2);
                        pnm->nmcd.rc.bottom = pnm->nmcd.rc.top + 0x10000;           // big number, no limit!
                    }
                }

                // Don't return other wacky flags to TT, since all we
                // did was change the font (if even that)
                return dwCustom & CDRF_NEWFONT;
            }
        }
        break;

        case TTN_SHOW:
            if (plv->iTTLastHit != -1)
            {
                if (plv->fPlaceTooltip)
                {
                    LPNMTTSHOWINFO psi = (LPNMTTSHOWINFO)pnmh;
                    RECT rcLabel;

                    // In case we're doing subitem hit-testing
                    rcLabel.top = plv->iTTLastSubHit;
                    rcLabel.left = LVIR_LABEL;

                    // reposition to allign with the text rect and
                    // set it to topmost
                    if (plv->iTTLastSubHit && ListView_OnGetSubItemRect(plv, plv->iTTLastHit, &rcLabel)) 
                    {
                        LV_ITEM item;

                        // we got the subitem rect. When we draw subitems, we give
                        // them SHDT_EXTRAMARGIN, so we have to also
                        rcLabel.left += g_cxLabelMargin * 3;
                        rcLabel.right -= g_cxLabelMargin * 3;

                        // And take the image into account, too.
                        // ListView_OnGetItem will worry about LVS_EX_SUBITEMIMAGES.
                        item.mask = LVIF_IMAGE;
                        item.iImage = -1;
                        item.iItem = plv->iTTLastHit;
                        item.iSubItem = plv->iTTLastSubHit;
                        ListView_OnGetItem(plv, &item);
                        if (item.iImage != -1)
                            rcLabel.left += plv->cxSmIcon;
                    } 
                    else
                    {                    // a tip from subitem zero
                        ListView_GetUnfoldedRect(plv, plv->iTTLastHit, &rcLabel);
                        // SHDrawText actually leaves a g_cxLabelMargin margin
                        rcLabel.left += g_cxLabelMargin;
                        rcLabel.right -= g_cxLabelMargin;
                    }

                    // In report and list views, SHDrawText does vertical
                    // centering (without consulting the custom-draw client,
                    // even, so it just centers by a random amount).
                    if (ListView_IsListView(plv) || ListView_IsReportView(plv))
                    {
                        rcLabel.top += (rcLabel.bottom - rcLabel.top - plv->cyLabelChar) / 2;
                    }

                    SendMessage(plv->hwndToolTips, TTM_ADJUSTRECT, TRUE, (LPARAM)&rcLabel);
                    MapWindowRect(plv->ci.hwnd, HWND_DESKTOP, &rcLabel);

                    if (!ListView_IsIconView(plv))
                    {
                        // In non-large-icon view, the label size may be greater than the rect returned by ListView_GetUnfoldedRect.
                        // So don't specify the size
                        SetWindowPos(plv->hwndToolTips, HWND_TOP,
                                 rcLabel.left, rcLabel.top,
                                 0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_HIDEWINDOW);
                    }
                    else
                    {
                        SetWindowPos(plv->hwndToolTips, HWND_TOP,
                                 rcLabel.left, rcLabel.top,
                                 (rcLabel.right - rcLabel.left), (rcLabel.bottom - rcLabel.top),
                                 SWP_NOACTIVATE | SWP_HIDEWINDOW);
                    }
                    // This is an inplace tooltip, so disable animation.
                    psi->dwStyle |= TTS_NOANIMATE;
                    return TRUE;
                }
                else if (ListView_IsKbdTipTracking(plv))  // Size tip when keyboard tracking
                {
                    RECT rc;
                    RECT rcTT;
                    RECT rcItem;
                    POINT ptTT;
                    POINT ptItem;

                    MONITORINFO mi = {0};
                    mi.cbSize = sizeof(MONITORINFO);

                    // Establish item screen position and size
                    ListView_GetItemRect(plv->ci.hwnd, plv->iTracking, &rcItem, LVIR_ICON);
                    ListView_GetItemRect(plv->ci.hwnd, plv->iTracking, &rc, LVIR_BOUNDS);
                    rcItem.top = rc.top;
                    rcItem.bottom = rc.bottom;
                    ptItem.x = rcItem.left;
                    ptItem.y = rcItem.top;
                    ClientToScreen(plv->ci.hwnd, &ptItem);

                    // Get tip rect
                    GetWindowRect(plv->hwndToolTips, &rcTT);

                    // Init tooltip position
                    ptTT.x = ptItem.x + RECTWIDTH(rcItem);
                    ptTT.y = ptItem.y + RECTHEIGHT(rcItem);

                    // Get screen info where tooltip is being displayed
                    GetMonitorInfo(MonitorFromPoint(ptTT, MONITOR_DEFAULTTONEAREST), &mi);

                    // Update tooltip position if it runs off the screen
                    if ((ptTT.x + RECTWIDTH(rcTT)) > mi.rcMonitor.right)
                        ptTT.x = (ptItem.x + g_cxIconMargin) - RECTWIDTH(rcTT);

                    if ((ptTT.y + RECTHEIGHT(rcTT)) > mi.rcMonitor.bottom)
                        ptTT.y = ptItem.y - RECTHEIGHT(rcTT);

                    SetWindowPos(plv->hwndToolTips, NULL, ptTT.x, ptTT.y, 0, 0, SWP_NOSIZE|SWP_NOACTIVATE);

                    return TRUE;
                }
            }
            break;

        }
    }

    return 0;
}

// Pass the focus to the given window, and then check to see if it exists.
// Passing focus can cause the window to be destroyed (by the Explorer
// when renaming).

BOOL ListView_SetFocus(HWND hwnd)
{
    SetFocus(hwnd);
    return IsWindow(hwnd);
}

void ListView_Realize(LV* plv, HDC hdcParam, BOOL fBackground, BOOL fForceRepaint)
{
    if (plv->hpalHalftone)
    {
        HDC hdc = hdcParam ? hdcParam : GetDC(plv->ci.hwnd);

        if (hdc)
        {
            BOOL fRepaint;

            SelectPalette(hdc, plv->hpalHalftone, fBackground);
            fRepaint = RealizePalette(hdc) || fForceRepaint;

            if (!hdcParam)
                ReleaseDC(plv->ci.hwnd, hdc);

            if (fRepaint)
            {
                InvalidateRect(plv->ci.hwnd, NULL, TRUE);
            }
        }
    }
}

BOOL RectInRect(const RECT* prcOuter, const RECT* prcInner)
{
    RECT rcDummy;
    return IntersectRect(&rcDummy, prcOuter, prcInner);
}


LRESULT LVGenerateDragImage(LV* plv, SHDRAGIMAGE* pshdi)
{
    LRESULT lRet = 0;
    int iNumSelected = plv->nSelected;
    int iIndex;
    int iSelectedItem;
    RECT rc = {0, 0, 0, 0};
    RECT rcVisRect;
    HBITMAP hbmpOld = NULL;
    HDC  hdcDragImage;
    BOOL fBorderSelect = (plv->exStyle & LVS_EX_BORDERSELECT);

    // First loop through can get the selection rect
    if (ListView_IsOwnerData(plv)) 
    {
        plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &iNumSelected);
    }

    if (iNumSelected == 0)
        return FALSE;

    plv->flags |= LVF_DRAGIMAGE;

    GetClientRect(plv->ci.hwnd, &rcVisRect);


    // Loop Through and calculate the enclosing rect.
    for (iIndex = iNumSelected - 1, iSelectedItem = -1; iIndex >= 0; iIndex--)
    {
        iSelectedItem = ListView_OnGetNextItem(plv, iSelectedItem, LVNI_SELECTED);
        if (iSelectedItem != -1)
        {
            RECT rcItemBounds;

            // Make sure this is in the visible region
            if (ListView_GetItemRect(plv->ci.hwnd, iSelectedItem, &rcItemBounds, LVIR_SELECTBOUNDS) &&
                RectInRect(&rcVisRect, &rcItemBounds))
            {
                UnionRect(&rc, &rc, &rcItemBounds);
            }
        }
    }

    hdcDragImage = CreateCompatibleDC(NULL);

    if (hdcDragImage)
    {
        RGBQUAD* prgbBits;
        BITMAPINFO bi;

        // Need to turn this off because it doesn't look good.
        plv->exStyle &= ~LVS_EX_BORDERSELECT;

        // After this rc contains the bounds of all the items in Client Coordinates.
        //
        // Mirror the the DC, if the listview is mirrored.
        //
        if (plv->ci.dwExStyle & RTL_MIRRORED_WINDOW)
        {
            SET_DC_RTL_MIRRORED(hdcDragImage);
        }

    #define MAX_DRAG_RECT_WIDTH 300
    #define MAX_DRAG_RECT_HEIGHT 300
        // If this rect is too big, fix it.
        if (RECTWIDTH(rc) > MAX_DRAG_RECT_WIDTH)
        {
            int iLeft = MAX_DRAG_RECT_WIDTH / 2;
            int iRight = MAX_DRAG_RECT_WIDTH /2;

            int iRectOriginalLeft = rc.left;
            // Is the left boundry outside the visible rect?
            if (rc.left < plv->ptCapture.x - iLeft)
            {
                // Yes, then we have to clip it.
                rc.left = plv->ptCapture.x - iLeft;
            }
            else
            {
                // No? Well then shift the visible rect to the right, so that we have
                // more room.
                iRight += rc.left - (plv->ptCapture.x - iLeft);
            }

            // Is the right boundry outside the visible rect?
            if (rc.right > plv->ptCapture.x + iRight)
            {
                // Yes, then we have to clip it.
                rc.right = plv->ptCapture.x + iRight;
            }
            else
            {
                // No? Then try and add it to the left
                if (rc.left > iRectOriginalLeft)
                {
                    rc.left -= iRight - (rc.right - plv->ptCapture.x);
                    if (rc.left < iRectOriginalLeft)
                        rc.left = iRectOriginalLeft;
                }
            }
        }

        if (RECTHEIGHT(rc) > MAX_DRAG_RECT_HEIGHT)
        {
            // same for top and bottom:
            // Is the top boundry outside the visible rect?
            int iTop = MAX_DRAG_RECT_HEIGHT / 2;
            int iBottom = MAX_DRAG_RECT_HEIGHT /2;
            int iRectOriginalTop = rc.top;
            if (rc.top < plv->ptCapture.y - iTop)
            {
                // Yes, then we have to clip it.
                rc.top = plv->ptCapture.y - iTop;
            }
            else
            {
                // No? Well then shift the visible rect to the right, so that we have
                // more room.
                iBottom += rc.top - (plv->ptCapture.y - iTop);
            }

            // Is the right boundry outside the visible rect?
            if (rc.bottom > plv->ptCapture.y + iBottom)
            {
                // Yes, then we have to clip it.
                rc.bottom = plv->ptCapture.y + iBottom;
            }
            else
            {
                // No? Then try and add it to the top
                if (rc.top > iRectOriginalTop)
                {
                    rc.top -= iBottom - (rc.bottom - plv->ptCapture.y);
                    if (rc.top < iRectOriginalTop)
                        rc.top = iRectOriginalTop;
                }
            }
        }

        pshdi->sizeDragImage.cx = RECTWIDTH(rc) + 1;
        pshdi->sizeDragImage.cy = RECTHEIGHT(rc) + 1;
        bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
        bi.bmiHeader.biWidth = pshdi->sizeDragImage.cx;
        bi.bmiHeader.biHeight = pshdi->sizeDragImage.cy;
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biBitCount = 32;
        bi.bmiHeader.biCompression = BI_RGB;
        pshdi->hbmpDragImage = CreateDIBSection(hdcDragImage, &bi, DIB_RGB_COLORS, &prgbBits, NULL, 0);

        if (pshdi->hbmpDragImage)
        {
            int iTotal = bi.bmiHeader.biWidth * bi.bmiHeader.biHeight;
            LVDRAWITEM lvdi;
            int cItem;

            RECT  rcImage = {0, 0, pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy};
            hbmpOld = SelectObject(hdcDragImage, pshdi->hbmpDragImage);

            ZeroMemory(prgbBits, pshdi->sizeDragImage.cx * pshdi->sizeDragImage.cy);
            pshdi->crColorKey = CLR_NONE;


            // Calculate the offset... The cursor should be in the bitmap rect.

            if (plv->ci.dwExStyle & RTL_MIRRORED_WINDOW)
                pshdi->ptOffset.x = rc.right - plv->ptCapture.x;
            else
                pshdi->ptOffset.x = plv->ptCapture.x - rc.left;
            pshdi->ptOffset.y = plv->ptCapture.y - rc.top;

            lvdi.prcClip = NULL;
            lvdi.plv = plv;
            lvdi.nmcd.nmcd.hdc = hdcDragImage;
            lvdi.pitem = NULL;
            cItem = ListView_Count(plv);

            // Now loop through again for the paint cycle
            for (iIndex = cItem - 1, iSelectedItem = -1; iIndex >= 0; iIndex--)
            {
                if (ListView_IsOwnerData(plv)) 
                {
                    iSelectedItem++;
                    plv->plvrangeSel->lpVtbl->NextSelected(plv->plvrangeSel, iSelectedItem, &iSelectedItem);
                }
                else
                {
                    LISTITEM* pitem;
                    iSelectedItem = (int)(UINT_PTR)DPA_FastGetPtr(plv->hdpaZOrder, iIndex);
                    pitem = ListView_FastGetItemPtr(plv, iSelectedItem);
                    if (!(pitem->state & LVIS_SELECTED))
                        iSelectedItem = -1;
                }

                if (iSelectedItem != -1)
                {
                    int     iOldItemDrawing;
                    COLORREF crSave;
                    POINT ptOrigin = {-rc.left, -rc.top};     //Offset the rects by...
                    RECT  rcItemBounds;
                    RECT rcTemp;

                    iOldItemDrawing = plv->iItemDrawing;
                    plv->iItemDrawing = iSelectedItem;
                    lvdi.nmcd.nmcd.dwItemSpec = iSelectedItem;
                    ListView_GetRects(plv, iSelectedItem, QUERY_DEFAULT, NULL, NULL, &rcItemBounds, NULL);

                    // Make sure this is in the visible region
                    if (IntersectRect(&rcTemp, &rcVisRect, &rcItemBounds))
                    {
                        ptOrigin.x += rcItemBounds.left;
                        ptOrigin.y += rcItemBounds.top;
                        // these may get changed
                        lvdi.lpptOrg = &ptOrigin;
                        lvdi.flags = LVDI_NOEFFECTS;
                        lvdi.nmcd.clrText = plv->clrText;
                        lvdi.nmcd.clrTextBk = plv->clrTextBk;
                        lvdi.nmcd.clrFace = plv->clrBk;
                        lvdi.nmcd.iIconEffect = ILD_NORMAL;
                        lvdi.nmcd.iIconPhase = 0;

                        // Save the Background color!
                        crSave = plv->clrBk;
                        plv->clrBk = CLR_NONE;  // None so that it "bleeds" into the alpha channel

                        ListView_DrawItem(&lvdi);

                        plv->clrBk = crSave;
                    }
                    plv->iItemDrawing = iOldItemDrawing;
                }
            }


            for (iIndex = 0; iIndex < iTotal; iIndex++)
            {
                RGBQUAD* prgb = &prgbBits[iIndex];
                if (prgb->rgbReserved == 0 && 
                    (prgb->rgbRed || prgb->rgbGreen || prgb->rgbBlue))    // Do we have color an no alpha?
                {
                    prgb->rgbReserved = 0xFF;
                }
            }

            SelectObject(hdcDragImage, hbmpOld);
            DeleteDC(hdcDragImage);

            // We're passing back the created HBMP.
            lRet = 1;
        }

        if (fBorderSelect)
            plv->exStyle |= LVS_EX_BORDERSELECT;
    }

    plv->flags &= ~LVF_DRAGIMAGE;


    return lRet;
}


LRESULT ListView_OnEnableGroupView(LV* plv, BOOL fEnable)
{
    if (plv->ci.style & LVS_OWNERDATA)  // Not supported in ownerdata case.
        return -1;

    if (fEnable ^ plv->fGroupView)
    {
        if (fEnable)
        {
            // Turning on groupview, so nuke insertmark, because that's not allowed
            // in group view
            LVINSERTMARK lvim = {0};
            lvim.cbSize = sizeof(LVINSERTMARK);
            lvim.iItem = -1;
            ListView_OnSetInsertMark(plv, &lvim);
        }

        plv->fGroupView = fEnable;

        if (fEnable)
        {
            if (plv->hdpaGroups == NULL)
                plv->hdpaGroups = DPA_Create(4);

            if (plv->hdpaGroups == NULL)
                return -1;
        }

        plv->rcView.left = RECOMPUTE;
        SetWindowLongPtr(plv->ci.hwnd, GWL_STYLE, GetWindowLongPtr(plv->ci.hwnd, GWL_STYLE) | LVS_AUTOARRANGE);
        _ListView_RecomputeEx(plv, NULL, 0, TRUE);
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        ListView_UpdateScrollBars(plv);

        return 1;
    }

    return 0;
}


LRESULT ListView_SetViewType(LV* plv, WORD wView)
{
    if (wView > LV_VIEW_MAX)
        return -1;
    else if (plv->wView != wView)
    {
        int i;
        WORD wViewOld = plv->wView;

        ListView_DismissEdit(plv, FALSE);

        // (dli) Setting the small icon width here and only in the case when we go
        // from large icon view to some other view because of three reasons:
        // 1. According to chee, we want to set this before we change the style bit in
        // plv or after we scale.
        // 2. We don't want to do it after we scale because we want to set the width to
        // the maximum value so that the items in this listview do not cover each other
        // 3. we do it from large icon view because large icon view has fixed width for
        // each item, small icon view width can be scaled.

        if (wViewOld == LV_VIEW_ICON)
            ListView_ISetColumnWidth(plv, 0, LV_GetNewColWidth(plv, 0, ListView_Count(plv)-1), FALSE);

        if (wView == LV_VIEW_TILE)
        {
            ListView_RecalcTileSize(plv);
        }

        plv->wView = wView;

        ListView_TypeChange(plv, wViewOld, BOOLIFY(plv->ci.style & LVS_OWNERDRAWFIXED));

        // Else we would like to make the most important item to still
        // be visible.  So first we will look for a cursorered item
        // if this fails, we will look for the first selected item,
        // else we will simply ask for the first item (assuming the
        // count > 0
        //
        // And make sure the scrollbars are up to date Note this
        // also updates some variables that some views need
        ListView_UpdateScrollBars(plv);

        i = (plv->iFocus >= 0) ? plv->iFocus : ListView_OnGetNextItem(plv, -1, LVNI_SELECTED);
        if ((i == -1) && (ListView_Count(plv) > 0))
            i = 0;

        if (i != -1)
            ListView_OnEnsureVisible(plv, i, TRUE);

        RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);

        // Change of styles also changes tooltip policy, so pop it
        ListView_PopBubble(plv);
    }
    return 1;
}

BOOL    ListView_OnGetFrozenSlot(LV* plv, LPRECT pSlotRect)
{
    int cSlots, iWidth = 0, iHeight = 0;
    LISTITEM *pItem;
    
    if((plv->iFrozenSlot == LV_NOFROZENSLOT) || !ListView_IsIconView(plv) || ListView_IsOwnerData(plv) || (pSlotRect == NULL)) //Supported only in Large Icon mode!
        return FALSE;
        
    cSlots = ListView_GetSlotCount(plv, TRUE, &iWidth, &iHeight);

    //We need to have a valid pItem to pass to ListView_CalcSlotRect() function.
    pItem = plv->pFrozenItem;   //Try to use a frozen item, if present.
    if(pItem == NULL)
        pItem = ListView_GetItemPtr(plv, 0); //Or else, use the first item.
        
    if(pItem == NULL)   //If we couldn't get any pItem, then we can't call CalcSlotRect().
        return FALSE;   //... Hence, we have to return failure.
    else
    {
        ListView_CalcSlotRect(plv, pItem, plv->iFrozenSlot, cSlots, FALSE,
                                      iWidth, iHeight,pSlotRect);
        return TRUE;
    }
}

BOOL    ListView_OnSetFrozenSlot(LV* plv, BOOL fFreeze, LPPOINT    pPt)
{
    if(!ListView_IsIconView(plv) || ListView_IsOwnerData(plv)) //Supported only in Large Icon mode!
        return FALSE;
        
    if(fFreeze)
    {
        //First, find the slot where the given point lies.
        int cSlots, iWidth = 0, iHeight = 0;
        cSlots = ListView_GetSlotCount(plv, TRUE, &iWidth, &iHeight);
        plv->iFrozenSlot = ListView_CalcHitSlot(plv, *pPt, cSlots, iWidth, iHeight);
    }
    else
    {
        //Unfreeze a frozen slot.
        plv->iFrozenSlot = LV_NOFROZENSLOT; //No slot is frozen.
    }

    return TRUE;
}

int     ListView_OnGetFrozenItem(LV* plv)
{
    int i;
    LISTITEM *pItem;
    
    if((plv->pFrozenItem == NULL) || !ListView_IsIconView(plv) || ListView_IsOwnerData(plv)) //Supported only in Large Icon mode!
        return LV_NOFROZENITEM;

    for(i = 0; i < ListView_Count(plv); i++)
    {
        pItem = ListView_GetItemPtr(plv, i);
        if((pItem != NULL) && (pItem == plv->pFrozenItem))
            return (i);
    }

    return  LV_NOFROZENITEM;
}

BOOL    ListView_OnSetFrozenItem(LV* plv, BOOL fFreeze, int iIndex)
{
    LISTITEM *pitem;
    
    if(!ListView_IsIconView(plv) || ListView_IsOwnerData(plv)) //Supported only in Large Icon mode!
        return FALSE;

    if(fFreeze)
    {
        //Freeze the given item.
        pitem = ListView_GetItemPtr(plv, iIndex);

        if(pitem == NULL)
            return FALSE;

        plv->pFrozenItem = pitem;
    }
    else
    {
        //Unfreeze the currently frozen item.
        plv->pFrozenItem = NULL;
    }

    return TRUE;
}

// Item focus changed via the keyboard, start tracking tooltip timeout for keyboard nav popups
//
BOOL ListView_OnKeyboardSelected(LV* plv, int iNewFocus)
{
    if (iNewFocus >= 0 && plv->hwndToolTips)
    {
        // Focus via the keyboard (already cancelled via entry into this function)
        plv->iTracking = iNewFocus;

        // Delay will be replaced with an SPI
        SetTimer(plv->ci.hwnd, IDT_TRACKINGTIP, GetDoubleClickTime() * 2, NULL);
    }
    return TRUE;
}

LRESULT ListView_OnMapIndexToID(LV* plv, UINT iItem)
{
    LISTITEM* pitem;
    if (!ListView_IsValidItemNumber(plv, iItem) || ListView_IsOwnerData(plv))
    {
        return -1;
    }

    pitem = ListView_FastGetItemPtr(plv, iItem);

    ASSERT (pitem);

    return (LRESULT)pitem->dwId;
}

#ifdef DEBUG
UINT uAverageSeekCount = 0;
UINT uTotalSeeks = 0;
UINT uPerSeekCount = 0;
#endif
LRESULT ListView_OnMapIdToIndex(LV* plv, UINT Id)
{
    DWORD dwRet = -1;
    UINT cCounter = 0;
    UINT cItems = ListView_Count(plv);
    UINT i;
    
    if (ListView_IsOwnerData(plv))
        return -1;

    if (plv->iLastId >= cItems)
        plv->iLastId = 0;

    DEBUG_CODE(uTotalSeeks++);

   
    for (i = plv->iLastId; cCounter < cItems; cCounter++) 
    {
        LISTITEM* pitem = ListView_FastGetItemPtr(plv, i);
        if (pitem->dwId == Id)
        {
            if (plv->iLastId > i)
                plv->iIncrement = -1;
            else
                plv->iIncrement = 1;

            plv->iLastId = dwRet = i;
            break;
        }

        DEBUG_CODE(uPerSeekCount++);

        i += (DWORD)plv->iIncrement;

        if (i == -1)        // Wrapped around to "Less than zero"?
            i = cItems - 1;
        if (i >= cItems)
            i = 0;
    }

    DEBUG_CODE(uAverageSeekCount = uPerSeekCount / uTotalSeeks);

    return (LRESULT)dwRet;
}

void ListView_OnSize(LV* plv)
{
    if (plv->hwndToolTips)
    {
        TOOLINFO ti;

        if (ListView_IsLabelTip(plv))
        {
            // A truncated label may have been exposed or vice versa.
            ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);
        }

        ti.cbSize = sizeof(ti);
        ti.hwnd = plv->ci.hwnd;
        ti.uId = 0;

        // Resize the tooltip control so that it covers the entire
        // area of the window when its parent gets resized.
        GetClientRect(plv->ci.hwnd, &ti.rect);
        SendMessage(plv->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM) &ti);
    }

    // if we're supposed to center the image,
    // we need to do a full redraw on each size
    if ((plv->ulBkImageFlags & LVBKIF_SOURCE_MASK) &&
        (plv->ulBkImageFlags & LVBKIF_STYLE_MASK) == LVBKIF_STYLE_NORMAL &&
        (plv->xOffsetPercent || plv->yOffsetPercent))
    {
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }
}

BOOL ListView_OnSetViewMargins(LV* plv, RECT *prc)
{
    if (!IsEqualRect(plv->rcViewMargin, *prc))
    {
        plv->rcViewMargin = *prc;
        plv->rcView.left = RECOMPUTE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }
    return TRUE;
}

BOOL ListView_OnGetViewMargins(LV* plv, RECT *prc)
{
    *prc = plv->rcViewMargin;
    return TRUE;
}

LRESULT CALLBACK ListView_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LV* plv = ListView_GetPtr(hwnd);

    if (plv == NULL)
    {
        if (uMsg == WM_NCCREATE)
        {
            plv = (LV*)LocalAlloc(LPTR, sizeof(LV));
            if (!plv)
            {
                TraceMsg(TF_ERROR, "ListView: Out of memory");
                return 0L;      // fail the window create
            }

            plv->ci.hwnd = hwnd;
            plv->flags = LVF_REDRAW;    // assume that redrawing enabled!
            plv->iFocus = -1;           // no focus
            plv->iMark = -1;
            plv->iSelCol = -1;
            plv->iDropHilite = -1;      // Assume no item has drop hilite...
            plv->cyItem = plv->cyItemSave = 1; // never let these be zero, not even for a moment
            plv->hTheme = OpenThemeData(hwnd, L"ListView");
            plv->iInsertItem = -1;          // No insert mark by default of course
            plv->clrim = CLR_DEFAULT;
            plv->iTracking = LVKTT_NOTRACK;
            plv->hheap = GetProcessHeap();
            plv->iFrozenSlot = LV_NOFROZENSLOT; //No slot is frozen to begin with!
            plv->iIncrement = -1;
            ListView_SetPtr(hwnd, plv);
        }
        goto DoDefault;
    }

    if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST)) 
    {
        if (plv->exStyle & (LVS_EX_TRACKSELECT|LVS_EX_ONECLICKACTIVATE|LVS_EX_TWOCLICKACTIVATE)) 
        {
            TRACKMOUSEEVENT tme;

            tme.cbSize = sizeof(tme);
            tme.hwndTrack = plv->ci.hwnd;
            tme.dwHoverTime = plv->dwHoverTime;
            tme.dwFlags = TME_LEAVE | TME_HOVER | TME_QUERY;

            // see what's set
            TrackMouseEvent(&tme);
            tme.dwFlags &= TME_HOVER | TME_LEAVE;

            // set these bits if they aren't already set
            tme.dwFlags ^= TME_LEAVE;
            if (plv->exStyle & LVS_EX_TRACKSELECT)
            {
                tme.dwFlags ^= TME_HOVER;
            }

            tme.cbSize = sizeof(tme);
            tme.hwndTrack = plv->ci.hwnd;
            tme.dwHoverTime = plv->dwHoverTime;
            // set it if there's anything to set
            if (tme.dwFlags & (TME_HOVER | TME_LEAVE)) 
            {
                TrackMouseEvent(&tme);
            }
        }
    }

    if (uMsg == g_uDragImages)
    {
        return LVGenerateDragImage(plv, (SHDRAGIMAGE*)lParam);
    }

    switch (uMsg)
    {
        HANDLE_MSG(plv, WM_CREATE, ListView_OnCreate);
        HANDLE_MSG(plv, WM_DESTROY, ListView_OnDestroy);
        HANDLE_MSG(plv, WM_ERASEBKGND, ListView_OnEraseBkgnd);
        HANDLE_MSG(plv, WM_COMMAND, ListView_OnCommand);
        HANDLE_MSG(plv, WM_SETFOCUS, ListView_OnSetFocus);
        HANDLE_MSG(plv, WM_KILLFOCUS, ListView_OnKillFocus);

        HANDLE_MSG(plv, WM_HSCROLL, ListView_OnHScroll);
        HANDLE_MSG(plv, WM_VSCROLL, ListView_OnVScroll);
        HANDLE_MSG(plv, WM_GETDLGCODE, ListView_OnGetDlgCode);
        HANDLE_MSG(plv, WM_SETFONT, ListView_OnSetFont);
        HANDLE_MSG(plv, WM_GETFONT, ListView_OnGetFont);
        HANDLE_MSG(plv, WM_TIMER, ListView_OnTimer);
        HANDLE_MSG(plv, WM_SETREDRAW, ListView_OnSetRedraw);
        HANDLE_MSG(plv, WM_NCDESTROY, ListView_OnNCDestroy);

    case WM_SETCURSOR:
        if (ListView_OnSetCursorMsg(plv))
            return TRUE;
        break;

    case WM_PALETTECHANGED:
        if ((HWND)wParam == hwnd)
            break;
    case WM_QUERYNEWPALETTE:
        // Want to pass FALSE if WM_QUERYNEWPALETTE...
        ListView_Realize(plv, NULL, uMsg == WM_PALETTECHANGED, uMsg == WM_PALETTECHANGED);
        return TRUE;

    case LVMP_WINDOWPOSCHANGED:
    case WM_WINDOWPOSCHANGED:
        HANDLE_WM_WINDOWPOSCHANGED(plv, wParam, lParam, ListView_OnWindowPosChanged);
        break;

    case WM_WINDOWPOSCHANGING:
        {
            WINDOWPOS* wp = (WINDOWPOS*)lParam;
            if ((wp->flags & SWP_SHOWWINDOW)||
                (wp->flags & SWP_HIDEWINDOW))
            {
                BOOL fShow = (wp->flags & SWP_SHOWWINDOW);
                LV_OnShowWindow(plv, fShow);
            }

            if (ListView_IsWatermarked(plv))
            {
                RECT rc = {wp->x, wp->y, wp->x + wp->cx, wp->y + wp->y};
                // Invalidate New.
                rc.left = rc.right - plv->szWatermark.cx;
                rc.top = rc.bottom - plv->szWatermark.cy;
                InvalidateRect(plv->ci.hwnd, &rc, TRUE);

                // and Old:
                GetClientRect(plv->ci.hwnd, &rc);
                rc.left = rc.right - plv->szWatermark.cx;
                rc.top = rc.bottom - plv->szWatermark.cy;
                InvalidateRect(plv->ci.hwnd, &rc, TRUE);
            }
        }
        break;

    case WM_MBUTTONDOWN:
        if (ListView_SetFocus(hwnd) && plv->hwndToolTips)
            RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);
        break;

    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
        // Cancel manual tip track on any mouse button down
        ListView_CancelTipTrack(plv);
        if (plv->hwndToolTips)
            RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);
        ListView_OnButtonDown(plv, TRUE, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        break;

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
        // Cancel manual tip track on any mouse button down
        ListView_CancelTipTrack(plv);
        if (plv->hwndToolTips)
            RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);
        ListView_OnButtonDown(plv, FALSE, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        break;

    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_NCMOUSEMOVE:
        if (plv->hwndToolTips)
            RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);
        break;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        ListView_OnPaint(plv, (HDC)wParam);
        return 0;

    case WM_NCPAINT:
        {
            if (plv->hTheme && plv->ci.dwExStyle & WS_EX_CLIENTEDGE)
            {
                HRGN hrgn = (wParam != 1) ? (HRGN)wParam : NULL;

                if (CCDrawNonClientTheme(plv->hTheme, hwnd, hrgn, plv->hbrBk, 0, 0))
                {
                    return 1;
                }
            }
        }
        break;

    case WM_SHOWWINDOW:
        LV_OnShowWindow(plv, BOOLFROMPTR(wParam));
        break;

    case WM_MOUSEHOVER:
        ListView_OnMouseHover(plv, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        break;

    case WM_MOUSELEAVE:
        ListView_OnSetHotItem(plv, -1);
        plv->iNoHover = -1;

        break;

    case WM_KEYUP:
        plv->iScrollCount = 0;
        break;

    case WM_KEYDOWN:
        HANDLE_WM_KEYDOWN(plv, wParam, lParam, ListView_OnKey);
        break;

    case WM_IME_COMPOSITION:
        // Now only Korean version is interested in incremental search with composition string.
        if (g_fDBCSInputEnabled)
        {
            if (((ULONG_PTR)GetKeyboardLayout(0L) & 0xF000FFFFL) == 0xE0000412L)
            {
                if (ListView_OnImeComposition(plv, wParam, lParam))
                {
                    lParam &= ~GCS_RESULTSTR;
                    break;
                }
                else
                    return 0;
            }
        }
        break;

    case WM_CHAR:
        if (plv->iPuntChar) 
        {
            plv->iPuntChar--;
            return TRUE;
        } 
        else 
        {
            return HANDLE_WM_CHAR(plv, wParam, lParam, ListView_OnChar);
        }

    case WM_WININICHANGE:
        ListView_OnWinIniChange(plv, wParam, lParam);
        break;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&plv->ci, lParam);

    case WM_ENABLE:
        // HACK: we don't get WM_STYLECHANGE on EnableWindow()
        ListView_EnableWindow(plv, BOOLFROMPTR(wParam));
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        if (plv->ci.style & WS_DISABLED)
        {
            if (!(plv->flags & LVF_USERBKCLR))
                plv->clrBkSave = g_clrWindow;
            ListView_OnSetBkColor(plv, g_clrBtnFace);
        }
        else if (!(plv->flags & LVF_USERBKCLR))
        {
            ListView_OnSetBkColor(plv, g_clrWindow);
        }

        if (plv->exStyle & LVS_EX_CHECKBOXES)
        {
            ListView_InitCheckBoxes(plv, FALSE);
        }

        plv->crHeader = GetSysColor(COLOR_WINDOWTEXT);
        plv->crTop = GetSysColor(COLOR_BTNFACE);
        plv->crLeft = GetSysColor(COLOR_BTNFACE);

//  98/11/19 #249967 vtan: Always invalidate the list view
//  rectangle so that the color change causes a refresh.

        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        break;

        // don't use HANDLE_MSG because this needs to go to the default handler
    case WM_SYSKEYDOWN:
        HANDLE_WM_SYSKEYDOWN(plv, wParam, lParam, ListView_OnKey);
        break;

    case WM_UPDATEUISTATE:
    {
        DWORD dwUIStateMask = MAKEWPARAM(0xFFFF, UISF_HIDEFOCUS);

        // we care only about focus not accel, and redraw only if changed
        if (CCOnUIState(&(plv->ci), WM_UPDATEUISTATE, wParam & dwUIStateMask, lParam))
        {
            if (plv->iFocus >= 0)
            {
                // an item has the focus, invalidate it
                ListView_InvalidateItem(plv, plv->iFocus, FALSE, RDW_INVALIDATE | RDW_ERASE);
            }
        }

        goto DoDefault;
    }

    case LVM_GETITEMA:
        return (LRESULT)ListView_OnGetItemA(plv, (LV_ITEMA *)lParam);

    case LVM_SETITEMA:
        return (LRESULT)ListView_OnSetItemA(plv, (LV_ITEMA *)lParam);

    case LVM_INSERTITEMA:
        return (LRESULT)ListView_OnInsertItemA(plv, (LV_ITEMA *)lParam);

    case LVM_FINDITEMA:
        return (LRESULT)ListView_OnFindItemA(plv, (int)wParam, (LV_FINDINFOA *)lParam);

    case LVM_GETSTRINGWIDTHA:
        return (LRESULT)ListView_OnGetStringWidthA(plv, (LPCSTR)lParam, NULL);

    case LVM_GETCOLUMNA:
        return (LRESULT)ListView_OnGetColumnA(plv, (int)wParam, (LV_COLUMNA *)lParam);

    case LVM_SETCOLUMNA:
        return (LRESULT)ListView_OnSetColumnA(plv, (int)wParam, (LV_COLUMNA *)lParam);

    case LVM_INSERTCOLUMNA:
        return (LRESULT)ListView_OnInsertColumnA(plv, (int)wParam, (LV_COLUMNA *)lParam);

    case LVM_GETITEMTEXTA:
        return (LRESULT)ListView_OnGetItemTextA(plv, (int)wParam, (LV_ITEMA *)lParam);

    case LVM_SETITEMTEXTA:
        if (!lParam)
            return FALSE;

        return (LRESULT)ListView_OnSetItemTextA(plv, (int)wParam,
                                                ((LV_ITEMA *)lParam)->iSubItem,
                                                (LPCSTR)((LV_ITEMA *)lParam)->pszText);

    case LVM_GETBKIMAGEA:
        return (LRESULT)ListView_OnGetBkImageA(plv, (LPLVBKIMAGEA)lParam);

    case LVM_SETBKIMAGEA:
        return (LRESULT)ListView_OnSetBkImageA(plv, (LPLVBKIMAGEA)lParam);

    case WM_STYLECHANGING:
        ListView_OnStyleChanging(plv, (UINT)wParam, (LPSTYLESTRUCT)lParam);
        return 0;

    case WM_STYLECHANGED:
        ListView_OnStyleChanged(plv, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        return 0L;

    case WM_HELP:
        return ListView_OnHelp(plv, (LPHELPINFO)lParam);


    case LVM_GETIMAGELIST:
        return (LRESULT)(UINT_PTR)(ListView_OnGetImageList(plv, (int)wParam));

    case LVM_SETIMAGELIST:
        return (LRESULT)(UINT_PTR)ListView_OnSetImageList(plv, (HIMAGELIST)lParam, (int)wParam);

    case LVM_GETBKCOLOR:
        return (LRESULT)(plv->ci.style & WS_DISABLED ? plv->clrBkSave : plv->clrBk);

    case LVM_SETBKCOLOR:
        plv->flags |= LVF_USERBKCLR;
        if (plv->ci.style & WS_DISABLED) 
        {
            plv->clrBkSave = (COLORREF)lParam;
            return TRUE;
        } 
        else 
        {
            return (LRESULT)ListView_OnSetBkColor(plv, (COLORREF)lParam);
        }

    case LVM_GETTEXTCOLOR:
        return (LRESULT)plv->clrText;
    case LVM_SETTEXTCOLOR:
        plv->clrText = (COLORREF)lParam;
        return TRUE;
    case LVM_GETTEXTBKCOLOR:
        return (LRESULT)plv->clrTextBk;
    case LVM_SETTEXTBKCOLOR:
        plv->clrTextBk = (COLORREF)lParam;
        return TRUE;
    case LVM_GETHOTLIGHTCOLOR:
        return (LRESULT)plv->clrHotlight;
    case LVM_SETHOTLIGHTCOLOR:
        plv->clrHotlight = (COLORREF)lParam;
        return TRUE;

    case LVM_GETITEMCOUNT:
        if (ListView_IsOwnerData(plv))
            return (LRESULT)plv->cTotalItems;
        else if (!plv->hdpa)
            return 0;
        else
            return (LRESULT)DPA_GetPtrCount(plv->hdpa);
        break;

    case LVM_GETITEM:
        return (LRESULT)ListView_OnGetItem(plv, (LV_ITEM*)lParam);

    case LVM_GETITEMSTATE:
        return (LRESULT)ListView_OnGetItemState(plv, (int)wParam, (UINT)lParam);

    case LVM_SETITEMSTATE:
        if (!lParam)
            return FALSE;

        return (LRESULT)ListView_OnSetItemState(plv, (int)wParam,
                                                ((LV_ITEM *)lParam)->state,
                                                ((LV_ITEM *)lParam)->stateMask);

    case LVM_SETITEMTEXT:
        if (!lParam)
            return FALSE;

        return (LRESULT)ListView_OnSetItemText(plv, (int)wParam,
                                                ((LV_ITEM *)lParam)->iSubItem,
                                                (LPCTSTR)((LV_ITEM *)lParam)->pszText);

    case LVM_GETITEMTEXT:
        return (LRESULT)ListView_OnGetItemText(plv, (int)wParam, (LV_ITEM *)lParam);

    case LVM_GETBKIMAGE:
        return (LRESULT)ListView_OnGetBkImage(plv, (LPLVBKIMAGE)lParam);

    case LVM_SETBKIMAGE:
        return (LRESULT)ListView_OnSetBkImage(plv, (LPLVBKIMAGE)lParam);

    case LVM_GETSELECTEDCOLUMN:
        return plv->iLastColSort;

    case LVM_SETSELECTEDCOLUMN:
        plv->iLastColSort = (int) wParam;

        if (ListView_IsTileView(plv))
        {
            // Tileview displays the selected column on the second line, if available. The second
            // line might be blank w/o it. So when this changes, we need to recompute each tile.
            if (!ListView_IsOwnerData(plv))
            {
                int i;
                for (i = 0; i < ListView_Count(plv); i++)
                {
                    LISTITEM *pitem = ListView_FastGetItemPtr(plv, i);
                    ListView_SetSRecompute(pitem);
                }
            }

            plv->rcView.left = RECOMPUTE;
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        }

        return 1;

    case LVM_SETVIEW:
        return ListView_SetViewType(plv, (WORD)wParam);

    case LVM_GETVIEW:
        return plv->wView;

    case LVM_SETITEM:
        return (LRESULT)ListView_OnSetItem(plv, (const LV_ITEM*)lParam);

    case LVM_INSERTITEM:
        return (LRESULT)ListView_OnInsertItem(plv, (const LV_ITEM*)lParam);

    case LVM_DELETEITEM:
        return (LRESULT)ListView_OnDeleteItem(plv, (int)wParam);

    case LVM_UPDATE:
        ListView_OnUpdate(plv, (int)wParam);
        UpdateWindow(plv->ci.hwnd);
        return TRUE;

    case LVM_DELETEALLITEMS:
        lParam = (LRESULT)ListView_OnDeleteAllItems(plv);
        // Optimization:  Instead of sending out a zillion EVENT_OBJECT_DESTROY's,
        // we send out a destroy of ourselves followed by a fresh create.
        // For compatibility with IE4, we still send out the REORDER notification.
        NotifyWinEvent(EVENT_OBJECT_REORDER, hwnd, OBJID_CLIENT, 0);
        ListView_NotifyRecreate(plv);
        return lParam;

    case LVM_GETITEMRECT:
        return (LRESULT)ListView_OnGetItemRect(plv, (int)wParam, (RECT*)lParam);

    case LVM_GETSUBITEMRECT:
        return (LRESULT)ListView_OnGetSubItemRect(plv, (int)wParam, (LPRECT)lParam);

    case LVM_SUBITEMHITTEST:
        return (LRESULT)ListView_OnSubItemHitTest(plv, (LPLVHITTESTINFO)lParam);

    case LVM_GETISEARCHSTRINGA:
        if (GetFocus() == plv->ci.hwnd)
            return (LRESULT)GetIncrementSearchStringA(&plv->is, plv->ci.uiCodePage, (LPSTR)lParam);
        else
            return 0;

    case LVM_GETISEARCHSTRING:
        if (GetFocus() == plv->ci.hwnd)
            return (LRESULT)GetIncrementSearchString(&plv->is, (LPTSTR)lParam);
        else
            return 0;

    case LVM_GETITEMSPACING:
        if (wParam)
            return MAKELONG(plv->cxItem, plv->cyItem);
        else
            return MAKELONG(plv->cxIconSpacing, plv->cyIconSpacing);

    case LVM_GETNEXTITEM:
        return (LRESULT)ListView_OnGetNextItem(plv, (int)wParam, (UINT)lParam);

    case LVM_FINDITEM:
        return (LRESULT)ListView_OnFindItem(plv, (int)wParam, (const LV_FINDINFO*)lParam);

    case LVM_SETSELECTIONMARK:
    {
        int iOldMark = plv->iMark;
        int iNewMark = (int)lParam;
        if (iNewMark == -1 || ListView_IsValidItemNumber(plv, iNewMark))
        {
            plv->iMark = iNewMark;
        }
        return iOldMark;
    }

    case LVM_GETSELECTIONMARK:
        return plv->iMark;

    case LVM_GETITEMPOSITION:
        return (LRESULT)ListView_OnGetItemPosition(plv, (int)wParam,
                (POINT*)lParam);

    case LVM_SETITEMPOSITION:
        return (LRESULT)ListView_OnSetItemPosition(plv, (int)wParam,
                GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

    case LVM_SETITEMPOSITION32:
        if (!lParam)
            return FALSE;

        return (LRESULT)ListView_OnSetItemPosition(plv, (int)wParam,
                ((LPPOINT)lParam)->x, ((LPPOINT)lParam)->y);

    case LVM_SCROLL:
    {
        int dx = (int)wParam;
        int dy = (int)lParam;
        return (LRESULT)(ListView_ValidateScrollParams(plv, &dx, &dy) &&
                         ListView_OnScroll(plv, dx, dy));
    }

    case LVM_ENSUREVISIBLE:
        return (LRESULT)ListView_OnEnsureVisible(plv, (int)wParam, BOOLFROMPTR(lParam));

    case LVM_REDRAWITEMS:
        return (LRESULT)ListView_OnRedrawItems(plv, (int)wParam, (int)lParam);

    case LVM_ARRANGE:
        return (LRESULT)ListView_OnArrange(plv, (UINT)wParam);

    case LVM_GETEDITCONTROL:
        return (LRESULT)(UINT_PTR)plv->hwndEdit;

    case LVM_EDITLABELA:
    {
        LPWSTR lpEditString = NULL;
        HWND   hRet;

        if (lParam) 
        {
            lpEditString = ProduceWFromA(plv->ci.uiCodePage, (LPSTR)lParam);
        }

        hRet = ListView_OnEditLabel(plv, (int)wParam, lpEditString);

        if (lpEditString) 
        {
            FreeProducedString(lpEditString);
        }

        return (LRESULT)hRet;
    }

    case LVM_EDITLABEL:
        return (LRESULT)(UINT_PTR)ListView_OnEditLabel(plv, (int)wParam, (LPTSTR)lParam);

    case LVM_HITTEST:
        return (LRESULT)ListView_OnHitTest(plv, (LV_HITTESTINFO*)lParam);

    case LVM_GETSTRINGWIDTH:
        return (LRESULT)ListView_OnGetStringWidth(plv, (LPCTSTR)lParam, NULL);

    case LVM_GETCOLUMN:
        return (LRESULT)ListView_OnGetColumn(plv, (int)wParam, (LV_COLUMN*)lParam);

    case LVM_SETCOLUMN:
        return (LRESULT)ListView_OnSetColumn(plv, (int)wParam, (const LV_COLUMN*)lParam);

    case LVM_SETCOLUMNORDERARRAY:
        return SendMessage(plv->hwndHdr, HDM_SETORDERARRAY, wParam, lParam);

    case LVM_GETCOLUMNORDERARRAY:
        return SendMessage(plv->hwndHdr, HDM_GETORDERARRAY, wParam, lParam);

    case LVM_GETHEADER:
    {
        HWND hwndOld = plv->hwndHdr;
        if (lParam && IsWindow((HWND)lParam))
        {
            plv->hwndHdr = (HWND)lParam;
        }
        return (LRESULT)hwndOld;
    }

    case LVM_INSERTCOLUMN:
        return (LRESULT)ListView_OnInsertColumn(plv, (int)wParam, (const LV_COLUMN*)lParam);

    case LVM_DELETECOLUMN:
        return (LRESULT)ListView_OnDeleteColumn(plv, (int)wParam);

    case LVM_CREATEDRAGIMAGE:
        return (LRESULT)(UINT_PTR)ListView_OnCreateDragImage(plv, (int)wParam, (LPPOINT)lParam);


    case LVMI_PLACEITEMS:
        if (plv->uUnplaced) 
        {
            ListView_Recompute(plv);
            ListView_UpdateScrollBars(plv);
        }
        return 0;

    case LVM_GETVIEWRECT:
        return (LPARAM)ListView_OnGetViewRect(plv, (RECT*)lParam);

    case LVM_GETCOLUMNWIDTH:
        return (LPARAM)ListView_OnGetColumnWidth(plv, (int)wParam);

    case LVM_SETCOLUMNWIDTH:
        return (LPARAM)ListView_ISetColumnWidth(plv, (int)wParam,
            GET_X_LPARAM(lParam), TRUE);

    case LVM_SETCALLBACKMASK:
        plv->stateCallbackMask = (UINT)wParam;
        return (LPARAM)TRUE;

    case LVM_GETCALLBACKMASK:
        return (LPARAM)(UINT)plv->stateCallbackMask;

    case LVM_GETTOPINDEX:
        return (LPARAM)ListView_OnGetTopIndex(plv);

    case LVM_GETCOUNTPERPAGE:
        return (LPARAM)ListView_OnGetCountPerPage(plv);

    case LVM_GETORIGIN:
        return (LPARAM)ListView_OnGetOrigin(plv, (POINT*)lParam);

    case LVM_SETITEMCOUNT:
        return ListView_OnSetItemCount(plv, (int)wParam, (DWORD)lParam);

    case LVM_GETSELECTEDCOUNT:
        if (ListView_IsOwnerData(plv)) 
        {
            plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &plv->nSelected);
        }

        return plv->nSelected;

    case LVM_SORTITEMS:
        return ListView_OnSortItems(plv, (LPARAM)wParam, (PFNLVCOMPARE)lParam, TRUE);

    case LVM_SORTITEMSEX:
        return ListView_OnSortItems(plv, (LPARAM)wParam, (PFNLVCOMPARE)lParam, FALSE);

    case LVM_SETEXTENDEDLISTVIEWSTYLE:
        return ListView_ExtendedStyleChange(plv, (DWORD) lParam, (DWORD) wParam);

    case LVM_GETEXTENDEDLISTVIEWSTYLE:
        return plv->exStyle;

    case LVM_GETHOVERTIME:
        return plv->dwHoverTime;

    case LVM_SETHOVERTIME:
    {
        DWORD dwRet = plv->dwHoverTime;
        plv->dwHoverTime = (DWORD)lParam;
        return dwRet;
    }

    case LVM_GETTOOLTIPS:
        return (LRESULT)plv->hwndToolTips;

    case LVM_SETTOOLTIPS:
    {
        HWND hwndToolTips = plv->hwndToolTips;
        plv->hwndToolTips = (HWND)wParam;
        return (LRESULT)hwndToolTips;
    }

    case LVM_SETICONSPACING:
    {
        DWORD dwRet = ListView_OnSetIconSpacing(plv, lParam);

        // rearrange as necessary
        if (ListView_RedrawEnabled(plv) &&
             (ListView_IsSmallView(plv) || ListView_IsIconView(plv)))
        {
            ListView_ArrangeOrSnapToGrid(plv);
        }
        return dwRet;
    }

    case LVM_SETHOTITEM:
    {
        int iOld = plv->iHot;
        int iNew = (int)wParam;
        if (iNew == -1 || ListView_IsValidItemNumber(plv, iNew)) 
        {
            ListView_OnSetHotItem(plv, (int)wParam);
        }
        return iOld;
    }

    case LVM_GETHOTITEM:
        return plv->iHot;

    // hCurHot is used iff LVS_EX_TRACKSELECT
    case LVM_SETHOTCURSOR:
    {
        HCURSOR hCurOld = plv->hCurHot;
        plv->hCurHot = (HCURSOR)lParam;
        return (LRESULT)hCurOld;
    }

    case LVM_GETHOTCURSOR:
        if (!plv->hCurHot)
        {
            plv->hCurHot = LoadCursor(NULL, IDC_HAND);
        }
        return (LRESULT)plv->hCurHot;

    case LVM_APPROXIMATEVIEWRECT:
        return ListView_OnApproximateViewRect(plv, (int)wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

    case LVM_SETLVRANGEOBJECT:
        return ListView_OnSetLVRangeObject(plv, (int)wParam, (ILVRange *)lParam);

    case LVM_SETWORKAREAS:
        ListView_OnSetWorkAreas(plv, (int)wParam, (RECT *)lParam);
        return 0;

    case LVM_GETWORKAREAS:
        ListView_OnGetWorkAreas(plv, (int)wParam, (RECT *)lParam);
        return 0;

    case LVM_GETNUMBEROFWORKAREAS:
        ListView_OnGetNumberOfWorkAreas(plv, (int *)lParam);
        return 0;

    case LVM_RESETEMPTYTEXT:
        plv->fNoEmptyText = FALSE;
        Str_Set(&plv->pszEmptyText, NULL);
        if (ListView_Count(plv) == 0)
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        return 1;

    case LVM_INSERTGROUPSORTED:
        return ListView_OnInsertGroupSorted(plv, (LVINSERTGROUPSORTED*) wParam);

    case LVM_SORTGROUPS:
        return ListView_OnSortGroups(plv, (PFNLVGROUPCOMPARE)wParam, (void *)lParam);

    case LVM_ENABLEGROUPVIEW:
        return ListView_OnEnableGroupView(plv, (BOOL)wParam);

    case LVM_ISGROUPVIEWENABLED:
        return plv->fGroupView;

    case LVM_INSERTGROUP:
        return ListView_OnInsertGroup(plv, (int) wParam, (PLVGROUP)lParam);

    case LVM_SETGROUPINFO:
        return ListView_OnSetGroupInfo(plv, (int) wParam, (PLVGROUP)lParam);

    case LVM_GETGROUPINFO:
        return ListView_OnGetGroupInfo(plv, (int) wParam, (PLVGROUP)lParam);

    case LVM_REMOVEGROUP:
        return ListView_OnRemoveGroup(plv, (int) wParam);

    case LVM_REMOVEALLGROUPS:
        return ListView_OnRemoveAllGroups(plv);

    case LVM_HASGROUP:
        {
            LISTGROUP* pgrp = ListView_FindGroupFromID(plv, (int)wParam, NULL);
            if (pgrp)
                return 1;
            else
                return 0;
        }
        break;

    case LVM_SETGROUPMETRICS:
        return ListView_OnSetGroupMetrics(plv, (PLVGROUPMETRICS)lParam);

    case LVM_GETGROUPMETRICS:
        return ListView_OnGetGroupMetrics(plv, (PLVGROUPMETRICS)lParam);

    case LVM_SETTILEVIEWINFO:
        return ListView_OnSetTileViewInfo(plv, (PLVTILEVIEWINFO)lParam);

    case LVM_GETTILEVIEWINFO:
        return ListView_OnGetTileViewInfo(plv, (PLVTILEVIEWINFO)lParam);

    case LVM_SETTILEINFO:
        return ListView_OnSetTileInfo(plv, (PLVTILEINFO)lParam);

    case LVM_GETTILEINFO:
        return ListView_OnGetTileInfo(plv, (PLVTILEINFO)lParam);

    case LVM_SETINSERTMARK:
        if (ListView_IsRearrangeableView(plv) && (plv->ci.style & LVS_AUTOARRANGE) && !plv->fGroupView)
            return ListView_OnSetInsertMark(plv, (LPLVINSERTMARK)lParam);
        else
            return FALSE;

    case LVM_GETINSERTMARK:
        {
            LPLVINSERTMARK plvim = (LPLVINSERTMARK)lParam;

            if (plvim->cbSize != sizeof(LVINSERTMARK))
                return FALSE;

            plvim->dwFlags = (plv->fInsertAfter ? LVIM_AFTER : 0) | LVIM_SETFROMINFO;
            plvim->iItem = plv->iInsertItem;
            return TRUE;
        }

    case LVM_GETINSERTMARKRECT:
        {
            return ListView_OnGetInsertMarkRect(plv, (LPRECT)lParam);
        }

    case LVM_SETINSERTMARKCOLOR:
        {
            LRESULT lres = (LRESULT)ListView_OnGetInsertMarkColor(plv);
            plv->clrim = (COLORREF) lParam;
            return lres;
        }

    case LVM_GETINSERTMARKCOLOR:
        return ListView_OnGetInsertMarkColor(plv);

    case LVM_INSERTMARKHITTEST:
        {
            LPPOINT ppt = (LPPOINT)wParam;
            return ListView_OnInsertMarkHitTest(plv, ppt->x, ppt->y, (LPLVINSERTMARK)lParam);
        }

    case LVM_SETINFOTIP:
        {
            return ListView_OnSetInfoTip(plv, (PLVSETINFOTIP)lParam);
        }

    case LVM_SETOUTLINECOLOR:
        {
            LRESULT lres = (LRESULT)plv->clrOutline;
            plv->clrOutline = (COLORREF) lParam;
            return lres;
        }

    case LVM_GETOUTLINECOLOR:
        return (LRESULT)plv->clrOutline;

    case LVM_SETFROZENITEM:
        return ListView_OnSetFrozenItem(plv, (BOOL) wParam, (int) lParam);

    case LVM_GETFROZENITEM:
        return ListView_OnGetFrozenItem(plv);

    case LVM_SETFROZENSLOT:
        return ListView_OnSetFrozenSlot(plv, (BOOL) wParam, (LPPOINT)lParam);

    case LVM_GETFROZENSLOT:
        return ListView_OnGetFrozenSlot(plv, (LPRECT)lParam);

    case LVM_SETVIEWMARGINS:
        return ListView_OnSetViewMargins(plv, (LPRECT)lParam);

    case LVM_GETVIEWMARGINS:
        return ListView_OnGetViewMargins(plv, (LPRECT)lParam);

    case LVM_KEYBOARDSELECTED:
        ListView_CancelTipTrack(plv);
        return lParam == 0 ? ListView_OnKeyboardSelected(plv, (int)wParam) : FALSE;

    case LVM_CANCELEDITLABEL: 
        ListView_DismissEdit(plv, FALSE);
        return 1;

    case LVM_MAPINDEXTOID:
        return ListView_OnMapIndexToID(plv, (UINT)wParam);
    case LVM_MAPIDTOINDEX:
        return ListView_OnMapIdToIndex(plv, (UINT)wParam);

    case LVM_ISITEMVISIBLE:
        if (ListView_IsValidItemNumber(plv, (UINT)wParam))
        {
            return ListView_IsItemVisibleI(plv, (UINT)wParam);
        }
        else
        {
            return FALSE;
        }

    case WM_SIZE:
        if (plv)
        {
            ListView_OnSize(plv);
        }
        break;

    case WM_NOTIFY:
        return ListView_OnNotify(plv, wParam, (LPNMHDR)lParam);


    case WM_MOUSEMOVE:
        // Cancel manual track if mouse moved
        if (plv->lLastMMove != lParam)
        {
            ListView_CancelTipTrack(plv);

            if (plv->hwndToolTips)
            {
                UINT uFlags;
                int iHit, iSubHit;

                RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);

                if (!ListView_IsKbdTipTracking(plv))
                {
                    // check that we are still on the hit item, pop it!
                    iHit = _ListView_ItemHitTest(plv, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), &uFlags, &iSubHit);

                    if (iHit != plv->iTTLastHit || iSubHit != plv->iTTLastSubHit)
                        ListView_PopBubble(plv);
                }
            }
        }

        plv->lLastMMove = lParam;
        ListView_OnMouseMove(plv, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        break;

    case WM_GETOBJECT:
        if (lParam == OBJID_QUERYCLASSNAMEIDX)
            return MSAA_CLASSNAMEIDX_LISTVIEW;
        break;

    case WM_THEMECHANGED:
        if (plv->hTheme)
            CloseThemeData(plv->hTheme);

        plv->hTheme = OpenThemeData(plv->ci.hwnd, L"ListView");

        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        break;

    default:
        {
            LRESULT lres;
            if (CCWndProc(&plv->ci, uMsg, wParam, lParam, &lres))
                return lres;
        }

        if (uMsg == g_msgMSWheel) 
        {
            DWORD           dwStyle;
            int             sb;
            SCROLLINFO      si;
            int             cScrollUnitsPerLine;
            int             cPage;
            int             cLinesPerDetant;
            int             cDetants;
            int             dPos;
            int             iWheelDelta = (int)(short)HIWORD(wParam);
            BOOL            fScroll = !(wParam & (MK_SHIFT | MK_CONTROL));
            BOOL            fDataZoom = (BOOL) (wParam & MK_SHIFT);

            // Update count of scroll amount
            gcWheelDelta -= iWheelDelta;
            cDetants = gcWheelDelta / WHEEL_DELTA;
            if (cDetants != 0)
            {
                gcWheelDelta %= WHEEL_DELTA;
            }

            if (fScroll) 
            {
                if (g_ucScrollLines > 0 &&
                    cDetants != 0 &&
                    ((WS_VSCROLL | WS_HSCROLL) & (dwStyle = ListView_GetWindowStyle(plv)))) 
                {
                    sb = (dwStyle & WS_VSCROLL) ? SB_VERT : SB_HORZ;

                    // Get the scroll amount of one line
                    cScrollUnitsPerLine = _ListView_GetScrollUnitsPerLine(plv, sb);
                    ASSERT(cScrollUnitsPerLine > 0);

                    si.cbSize = sizeof(SCROLLINFO);
                    si.fMask = SIF_PAGE | SIF_POS;
                    if (!ListView_GetScrollInfo(plv, sb, &si))
                        return 1;

                    // The size of a page is at least one line, and
                    // leaves one line of overlap
                    cPage = (max(cScrollUnitsPerLine, (int)si.nPage - cScrollUnitsPerLine)) / cScrollUnitsPerLine;

                    // Don't scroll more than one page per detant
                    cLinesPerDetant = (int) min((ULONG) cPage, (ULONG) g_ucScrollLines);

                    dPos = cLinesPerDetant * cDetants * cScrollUnitsPerLine;

                    ListView_DismissEdit(plv, FALSE);
                    ListView_ComOnScroll(plv, SB_THUMBTRACK, si.nPos + dPos, 
                                         sb, cScrollUnitsPerLine, - 1);
                    ListView_UpdateScrollBars(plv);

                    // After scrolling, the tooltip might need to change
                    // so send the tooltip a fake mousemove message to force
                    // a recompute.  We use WM_NCMOUSEMOVE since our lParam
                    // is in screen coordinates, not client coordinates.
                    ListView_PopBubble(plv);
                    RelayToToolTips(plv->hwndToolTips, plv->ci.hwnd,
                                    WM_NCMOUSEMOVE, HTCLIENT, lParam);
                }
                return 1;
            } 
            else if (fDataZoom) 
            {
                LV_HITTESTINFO ht;
                ht.pt.x = GET_X_LPARAM(lParam);
                ht.pt.y = GET_Y_LPARAM(lParam);
                ScreenToClient(hwnd, &(ht.pt));

                // If we are rolling forward and we hit an item then navigate
                // into that item (simulate dblclk which will open it).  Otherwise
                // just fall through so it isn't handled.  In that case if we
                // are being hosted in explorer it will do a backwards
                // history navigation.
                if ((iWheelDelta > 0) && (ListView_OnSubItemHitTest(plv, &ht) >= 0) &&
                    (ht.flags & LVHT_ONITEM) && cDetants != 0)
                {
                    BYTE aKeyState[256];
                    // This is a bit yucky but when ListView_HandleMouse sends the
                    // notification to the listview owner we need to make sure that
                    // it doesn't think the shift key is down.  Otherwise it may
                    // perform some "alternate" action but in this case we always
                    // want it to perform the default open action.
                    //
                    // Strip the high bit of VK_SHIFT so that the shift key is
                    // not down.
                    GetKeyboardState(aKeyState);
                    aKeyState[VK_SHIFT] &= 0x7f;
                    SetKeyboardState(aKeyState);
                    ListView_HandleMouse(plv, FALSE, ht.pt.x, ht.pt.y, 0, TRUE);
                    ListView_HandleMouse(plv, TRUE, ht.pt.x, ht.pt.y, 0, TRUE);
                    return 1;
                }
                // else fall through
            }
        }

        break;
    }

DoDefault:
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

BOOL Listview_UpdateViewEffects(LV* plv)
{
    BOOL fChanged = FALSE;
    UINT fScroll = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("ListviewScrollOver"),
                        FALSE, // Don't ignore HKCU
                        LISTVIEW_VFX_DEFAULT); // Assume a fast enough machine
    UINT fWatermark = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("ListviewWatermark"),
                        FALSE, // Don't ignore HKCU
                        LISTVIEW_VFX_DEFAULT); // Assume a fast enough machine
    UINT fAlphaSelect = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("ListviewAlphaSelect"),
                        FALSE, // Don't ignore HKCU
                        LISTVIEW_VFX_DEFAULT); // Assume a fast enough machine

    UINT fShadow = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("ListviewShadow"),
                        FALSE, // Don't ignore HKCU
                        LISTVIEW_VFX_DEFAULT); // Assume a fast enough machine

    if (plv->fListviewAlphaSelect != fAlphaSelect          ||
        plv->fListviewShadowText != fShadow                ||
        plv->fListviewWatermarkBackgroundImages != fScroll ||
        plv->fListviewEnableWatermark != fWatermark)
    {
        fChanged = TRUE;
    }

    plv->fListviewAlphaSelect = BOOLIFY(fAlphaSelect);
    plv->fListviewShadowText = BOOLIFY(fShadow);
    plv->fListviewWatermarkBackgroundImages = BOOLIFY(fScroll);
    plv->fListviewEnableWatermark = BOOLIFY(fWatermark);


    return fChanged;
}

void ListView_OnWinIniChange(LV* plv, WPARAM wParam, LPARAM lParam)
{
    // REARCHITECT:  will this also catch sysparametersinfo?
    // we need a general way of handling this, not
    // just relying on the listview.
    InitGlobalMetrics(wParam);

    if (Listview_UpdateViewEffects(plv))
    {
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    switch (wParam) 
    {
        case 0:
        case SPI_SETNONCLIENTMETRICS:
        case SPI_SETICONTITLELOGFONT:
        case SPI_SETICONMETRICS:
            // If wParam is 0, only reload settings if lParam is 0 too.  This catches the wild-card scenario
            // (like the old plus tab which does WM_WININICHANGE, 0, 0) but allows us to ignore wParam = 0
            // and lParam = lpszSectionName.  Reduces unecessary flashing.
            if (wParam || !lParam)
            {
                if (!(plv->flags & LVF_ICONSPACESET))
                    ListView_OnSetIconSpacing(plv, (LPARAM)-1);

                if (plv->flags & LVF_FONTCREATED)
                    ListView_OnSetFont(plv, NULL, TRUE);

                // Force a recalc of all the icon regions by stripping and
                // then adding back the LVS_EX_REGIONAL bit.
                if (plv->exStyle & LVS_EX_REGIONAL) 
                {
                    ListView_ExtendedStyleChange(plv, 0, LVS_EX_REGIONAL);
                    ListView_ExtendedStyleChange(plv, LVS_EX_REGIONAL, LVS_EX_REGIONAL);
                }
            }
            break;

        default:
            break;
    }

    // If we are in an Iconic view and the user is in autoarrange mode,
    // then we need to arrange the items.
    //
    if ((ListView_IsSmallView(plv) || ListView_IsIconView(plv)))
    {
        // Call off to the arrange function.
        if (ListView_IsOwnerData(plv))
            ListView_OnArrange(plv, LVA_DEFAULT);
        else 
            ListView_ArrangeOrSnapToGrid(plv);
    }
}

BOOL ListView_OnCreate(LV* plv, CREATESTRUCT* lpCreateStruct)
{
    Listview_UpdateViewEffects(plv);
    InitDitherBrush();

    CIInitialize(&plv->ci, plv->ci.hwnd, lpCreateStruct);

    plv->wView = (WORD)(plv->ci.style & LVS_TYPEMASK);

    plv->dwExStyle = lpCreateStruct->dwExStyle;

    if (plv->ci.style & WS_VISIBLE)
        plv->flags |= LVF_VISIBLE;

    ListView_GetRegIASetting(&g_bUseDblClickTimer);

    if (ListView_IsOwnerData(plv))
    {
        // ownerdata initialization
        plv->plvrangeSel = LVRange_Create();
        if (NULL == plv->plvrangeSel)
           goto error0;

       plv->plvrangeCut = LVRange_Create();
       if (NULL == plv->plvrangeCut)
          goto error0;
    }
    else
    {
        ASSERT(plv->plvrangeSel == NULL);
        ASSERT(plv->plvrangeCut == NULL);

        plv->hdpa = DPA_CreateEx(LV_HDPA_GROW, plv->hheap);
        if (!plv->hdpa)
            goto error0;

        plv->hdpaZOrder = DPA_CreateEx(LV_HDPA_GROW, plv->hheap);
        if (!plv->hdpaZOrder)
            goto error1;
    }

    ASSERT(plv->nWorkAreas == 0);
    ASSERT(plv->prcWorkAreas == NULL);
    ASSERT(plv->fIconsPositioned == FALSE);
    plv->iNoHover = -1;
    plv->dwHoverTime = HOVER_DEFAULT;
    plv->iHot = -1;
    plv->iEdit = -1;
    plv->iFocus = -1;
    plv->iDrag = -1;
    plv->iTTLastHit = -1;
    plv->iFreeSlot = -1;
    plv->rcView.left = RECOMPUTE;
    plv->iLastColSort = -1;
    ASSERT(plv->sizeTile.cx == 0);
    ASSERT(plv->sizeTile.cy == 0);
    ASSERT(plv->dwTileFlags == 0);
    plv->cSubItems = 1;
    SetRect(&plv->rcBorder, 0, 12, 0, 0);
    plv->crHeader = GetSysColor(COLOR_WINDOWTEXT);
    plv->crTop = GetSysColor(COLOR_BTNFACE);
    plv->crBottom = CLR_NONE;
    plv->crLeft = CLR_NONE;
    plv->crRight = CLR_NONE;
    plv->paddingLeft = 12;
    plv->paddingTop = 12;
    plv->paddingRight = 0;
    plv->paddingBottom = 12;
    plv->szWatermark.cx = 200;
    plv->szWatermark.cy = 200;


    ASSERT(plv->iMSAAMin == plv->iMSAAMax);

    plv->sizeClient.cx = lpCreateStruct->cx;
    plv->sizeClient.cy = lpCreateStruct->cy;

    // Setup flag to say if positions are in small or large view
    if (ListView_IsSmallView(plv))
        plv->flags |= LVF_ICONPOSSML;

    // force calculation of listview metrics
    ListView_OnSetFont(plv, NULL, FALSE);

    plv->cxItem = ListView_ComputeCXItemSize(plv);

    // if we're in ownerdraw report mode, the size got saved to cyItemSave
    // at creation time, both need to have this
    if ((plv->ci.style & LVS_OWNERDRAWFIXED) && ListView_IsReportView(plv))
        plv->cyItem = plv->cyItemSave;
    else
        plv->cyItemSave = plv->cyItem;

    ListView_OnSetIconSpacing(plv, (LPARAM)-1);

    ListView_UpdateScrollBars(plv);     // sets plv->cItemCol

    plv->clrBk = CLR_NONE;
    plv->clrText = CLR_DEFAULT;
    plv->clrTextBk = CLR_DEFAULT;
    plv->clrHotlight = CLR_DEFAULT;
    plv->clrOutline = CLR_DEFAULT;

    // create the bk brush, and set the imagelists colors if needed
    ListView_OnSetBkColor(plv, g_clrWindow);

    // Initialize report view fields
    plv->xTotalColumnWidth = RECOMPUTE;

    if (ListView_IsReportView(plv))
        ListView_RInitialize(plv, FALSE);

    if (plv->ci.style & WS_DISABLED) 
    {
        plv->ci.style &= ~WS_DISABLED;
        ListView_EnableWindow(plv, FALSE);
    }

    // tooltip for unfolding name lables

    plv->hwndToolTips = CreateWindowEx(WS_EX_TRANSPARENT, TOOLTIPS_CLASS, NULL,
                                     WS_POPUP|TTS_NOPREFIX, 0, 0, 0, 0,
                                     NULL, NULL, g_hinst, NULL);
    if (plv->hwndToolTips)
    {
        TOOLINFO ti;

        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_TRANSPARENT|TTF_ABSOLUTE;
        ti.hwnd = plv->ci.hwnd;
        ti.uId = 0;
        ti.hinst = NULL;
        ti.lpszText = LPSTR_TEXTCALLBACK;

        GetClientRect(plv->ci.hwnd, &ti.rect);
        SendMessage(plv->hwndToolTips, TTM_ADDTOOL, 0, (LPARAM) &ti);

        /* Ensure that the tooltips use the same font as the view */
        FORWARD_WM_SETFONT(plv->hwndToolTips, plv->hfontLabel, FALSE, SendMessage);
    }

    SetTimer(plv->ci.hwnd, IDT_ONECLICKOK, GetDoubleClickTime(), NULL);

    return TRUE;

error1:
    DPA_Destroy(plv->hdpa);
    plv->hdpa = NULL;

error0:
    if (plv->plvrangeSel)
    {
        plv->plvrangeSel->lpVtbl->Release(plv->plvrangeSel);
        plv->plvrangeSel = NULL;
    }
    if (plv->plvrangeCut)
    {
        plv->plvrangeCut->lpVtbl->Release(plv->plvrangeCut);
        plv->plvrangeCut = NULL;
    }

    return FALSE;
}

void ListView_DeleteHrgnInval(LV* plv)
{
    if (plv->hrgnInval && plv->hrgnInval != (HRGN)ENTIRE_REGION)
        DeleteObject(plv->hrgnInval);
    plv->hrgnInval = NULL;
}

void ListView_OnDestroy(LV* plv)
{
    //
    // The tooltip window may or may not exist at this point.  It
    // depends if the owning window of the tips is also being destroy.
    // If so, then the tips are gone already.
    //

    if (IsWindow(plv->hwndToolTips))
        DestroyWindow(plv->hwndToolTips);

    if (plv->hCurHot)
        DestroyCursor(plv->hCurHot);

    plv->hwndToolTips = NULL;

    Str_Set(&plv->pszTip, NULL);
    Str_Set(&plv->pszEmptyText, NULL);

    TerminateDitherBrush();

    if (!ListView_IsOwnerData(plv))
    {
       // Make sure to notify the app
       ListView_OnDeleteAllItems(plv);
    }

    if ((plv->flags & LVF_FONTCREATED) && plv->hfontLabel)
    {
        DeleteObject(plv->hfontLabel);
        // plv->flags &= ~LVF_FONTCREATED;
        // plv->hwfontLabel = NULL;
    }

    if (plv->hfontGroup)
    {
        DeleteObject(plv->hfontGroup);
    }

    if (plv->hFontHot)
    {
        DeleteObject(plv->hFontHot);
    }

    if (plv->hbmpWatermark)
    {
        DeleteObject(plv->hbmpWatermark);
    }

    ListView_DeleteHrgnInval(plv);

    if (plv->prcWorkAreas)
    {
        // This assert is bogus: If the app created work areas then deleted
        // them, nWorkAreas will be 0 but prcWorkAreas will be non-NULL.
        // ASSERT(plv->nWorkAreas > 0);
        LocalFree(plv->prcWorkAreas);
    }

    if (plv->hdpaGroups)
    {
        DPA_DestroyCallback(plv->hdpaGroups, DestroyGroups, NULL);
        plv->hdpaGroups = NULL;
    }
}

void ListView_OnNCDestroy(LV* plv)
{
    if ((!(plv->ci.style & LVS_SHAREIMAGELISTS)) || ListView_CheckBoxes(plv)) 
    {

        if (plv->himlState &&
            (plv->himlState != plv->himl) &&
            (plv->himlState != plv->himlSmall))
        {
            ImageList_Destroy(plv->himlState);
        }
    }

    if (!(plv->ci.style & LVS_SHAREIMAGELISTS))
    {
        if (plv->himl)
            ImageList_Destroy(plv->himl);
        if (plv->himlSmall)
            ImageList_Destroy(plv->himlSmall);
    }

    if (ListView_IsOwnerData(plv))
    {
        if (plv->plvrangeSel)
        {
            plv->plvrangeSel->lpVtbl->Release(plv->plvrangeSel);
            plv->plvrangeSel = NULL;
        }
        if (plv->plvrangeCut)
        {
            plv->plvrangeCut->lpVtbl->Release(plv->plvrangeCut);
            plv->plvrangeCut = NULL;
        }
        plv->cTotalItems = 0;
    }

    ListView_ReleaseBkImage(plv);

    if (plv->hbrBk)
        DeleteBrush(plv->hbrBk);

    if (plv->hdpa)
        DPA_Destroy(plv->hdpa);

    if (plv->hdpaZOrder)
        DPA_Destroy(plv->hdpaZOrder);

    ListView_RDestroy(plv);

    IncrementSearchFree(&plv->is);

    ListView_SetPtr(plv->ci.hwnd, NULL);
    if (plv->hTheme)
        CloseThemeData(plv->hTheme);
    NearFree(plv);
}


// sets the background color for the listview
//
// this creats the brush for drawing the background as well
// as sets the imagelists background color if needed

BOOL ListView_OnSetBkColor(LV* plv, COLORREF clrBk)
{
    if (plv->clrBk != clrBk)
    {
        if (plv->hbrBk)
        {
            DeleteBrush(plv->hbrBk);
            plv->hbrBk = NULL;
        }

        if (clrBk != CLR_NONE)
        {
            plv->hbrBk = CreateSolidBrush(clrBk);
            if (!plv->hbrBk)
                return FALSE;
        }

        // don't mess with the imagelist color if things are shared

        if (!(plv->ci.style & LVS_SHAREIMAGELISTS))
        {

            if (plv->himl)
                ImageList_SetBkColor(plv->himl, clrBk);

            if (plv->himlSmall)
                ImageList_SetBkColor(plv->himlSmall, clrBk);

            if (plv->himlState)
                ImageList_SetBkColor(plv->himlState, clrBk);
        }

        plv->clrBk = clrBk;
    }
    return TRUE;
}

void InitBrushOrg(LV* plv, HDC hdc)
{
    int x;

    if (ListView_IsSmallView(plv) || ListView_IsIconView(plv))
    {
        x = plv->ptOrigin.x;
    }
    else if (ListView_IsListView(plv))
    {
        x = plv->xOrigin;
    } 
    else 
    {
        x = (int)plv->ptlRptOrigin.x;
    }

    SetBrushOrgEx(hdc, -x, 0, NULL);
}

void ListView_InvalidateRegion(LV* plv, HRGN hrgn)
{
    if (hrgn) 
    {
        if (plv->hrgnInval == NULL) 
        {
            plv->hrgnInval = hrgn;
        } 
        else 
        {

            // union it in if the entire region isn't marked for invalidate
            if (plv->hrgnInval != (HRGN)ENTIRE_REGION) 
            {
                UnionRgn(plv->hrgnInval, plv->hrgnInval, hrgn);
            }
            DeleteObject(hrgn);
        }
    }
}

//
//  Used when a watermark is the listview's background (detected via clrTextBk
//  being CLR_NONE) to perform a flicker-free scroll of the client area, using
//  an offscreen bitmap
//
//  potential perf issue -- caching DC and/or bitmap instead of create/destroy
//                          on each call
//
//  jeffbog 2/29/96
//

void LVSeeThruScroll(LV *plv, LPRECT lprcUpdate)
{
    HDC     hdcOff;
    HBITMAP hbmpOff;
    int     x,y,cx,cy;
    HDC     hdc = GetDC(plv->ci.hwnd);

    if (!lprcUpdate)
    {
        x = y = 0;
        cx = plv->sizeClient.cx;
        cy = plv->sizeClient.cy;
    }
    else
    {
        x  = lprcUpdate->left;
        y  = lprcUpdate->top;
        cx = lprcUpdate->right - x;
        cy = lprcUpdate->bottom - y;
    }

    hdcOff  = CreateCompatibleDC(hdc);
    hbmpOff = CreateCompatibleBitmap(hdc, plv->sizeClient.cx, plv->sizeClient.cy);
    SelectObject(hdcOff, hbmpOff);

    SendMessage(plv->ci.hwnd, WM_PRINT, (WPARAM)hdcOff, PRF_CLIENT | PRF_ERASEBKGND);
    BitBlt(hdc, x, y, cx, cy, hdcOff, x, y, SRCCOPY);
    ReleaseDC(plv->ci.hwnd, hdc);
    DeleteDC(hdcOff);
    DeleteObject(hbmpOff);
}

void ListView_OnPaint(LV* plv, HDC hdc)
{
    PAINTSTRUCT ps;
    RECT rcUpdate;
    HDC hPaintDC = hdc;
    HDC hMemDC = NULL;
    HBITMAP hMemBm = NULL;
    HBITMAP hOldBm;
    BOOL fInternDC = FALSE;

    // Before handling WM_PAINT, go ensure everything's recomputed...
    //
    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    // If we're in report view, update the header window: it looks
    // better this way...
    //
    if (ListView_IsReportView(plv) && plv->hwndHdr)
        UpdateWindow(plv->hwndHdr);

    // If nothing to do (i.e., we recieved a WM_PAINT because
    // of an RDW_INTERNALPAINT, and we didn't invalidate anything)
    // don't bother with the Begin/EndPaint.
    //
    if (hdc || GetUpdateRect(plv->ci.hwnd, &rcUpdate, FALSE))
    {
        if (!(plv->flags & LVF_VISIBLE))
        {
            plv->flags |= LVF_VISIBLE;
            // We may try to resize the column
            ListView_MaybeResizeListColumns(plv, 0, ListView_Count(plv)-1);
            ListView_UpdateScrollBars(plv);
        }

        // this needs to be done before the beginpaint because it clears
        // out the update region
        if (!(plv->flags & LVF_REDRAW))
        {
            // add this region to our local invalidate region
            HRGN hrgn = CreateRectRgn(0, 0, 0,0);
            if (hrgn)
            {

                // ok if GetUpdateRgn fails... then hrgn will still be
                // and empty region..
                GetUpdateRgn(plv->ci.hwnd, hrgn, FALSE);
                ListView_InvalidateRegion(plv, hrgn);
            }
        }

        // Get device context
        if (!hdc)
        {
            hPaintDC = hdc = BeginPaint(plv->ci.hwnd, &ps);
            fInternDC = TRUE;
        }
        else
        {
            GetClipBox(hdc, &ps.rcPaint);
        }

        // Skip painting if redrawing is not enabled but complete cycle (EndPaint)
        if (ListView_RedrawEnabled(plv))
        {
            // Create memory surface and map rendering context if double buffering
            if (ListView_IsDoubleBuffer(plv))
            {
                // Only make large enough for clipping region
                hMemDC = CreateCompatibleDC(hdc);
                if (hMemDC)
                {
                    hMemBm = CreateCompatibleBitmap(hdc, RECTWIDTH(ps.rcPaint), RECTHEIGHT(ps.rcPaint));
                    if (hMemBm)
                    {
                        hOldBm = SelectObject(hMemDC, hMemBm);

                        // Offset painting to paint in region
                        OffsetWindowOrgEx(hMemDC, ps.rcPaint.left, ps.rcPaint.top, NULL);
                    }
                    else
                    {
                        DeleteDC(hMemDC);
                        hMemDC = NULL;
                    }
                }
            }
            
            if (hMemDC)
            {
                // Use memory DC if it was created
                hPaintDC = hMemDC;
            }

            if (hPaintDC)
            {
                // Setup brush offset for list view scrolling
                InitBrushOrg(plv, hPaintDC);

                ListView_DebugDisplayClipRegion(plv, &ps.rcPaint, NULL);

                // Draw backround in this pass if double buffering, otherwise, it was handled in WM_ERASEBKGND
                if (ListView_IsDoubleBuffer(plv))
                {
                    // Add on buffer offset to scrolling offset
                    POINT ptBrOrg;
                    GetBrushOrgEx(hPaintDC, &ptBrOrg);

                    SetBrushOrgEx(hPaintDC, ptBrOrg.x - ps.rcPaint.left, ptBrOrg.y - ps.rcPaint.top, NULL);

                    ListView_DrawBackground(plv, hPaintDC, &ps.rcPaint);
                }

                // Draw foreground
                ListView_Redraw(plv, hPaintDC, &ps.rcPaint);

                // Complete double buffering by blitting and freeing off-screen objects
                if (ListView_IsDoubleBuffer(plv) &&
                    hMemDC)
                {

                    if (plv->flags & LVF_MARQUEE)
                    {
                        HDC h = CreateCompatibleDC(hMemDC);
                        if (h)
                        {
                            HBITMAP hbmp, hbmpOld;
                            BLENDFUNCTION bf = {0};
                            RECT rcInvalid;
                            RECT rcMarquee = {0, 0, RECTWIDTH(plv->rcMarquee), RECTHEIGHT(plv->rcMarquee)};
                            IntersectRect(&rcInvalid, &ps.rcPaint, &plv->rcMarquee);
                            if (!IsRectEmpty(&rcInvalid))
                            {
                                hbmp = CreateCompatibleBitmap(hMemDC, RECTWIDTH(rcInvalid), RECTHEIGHT(rcInvalid));
                                if (hbmp)
                                {
                                    hbmpOld = SelectObject(h, hbmp);

                                    FillRectClr(h, &rcMarquee, g_clrMenuHilight);

                                    bf.BlendOp = AC_SRC_OVER;
                                    bf.SourceConstantAlpha = 70;

                                    GdiAlphaBlend(hMemDC, rcInvalid.left, rcInvalid.top, RECTWIDTH(rcInvalid), RECTHEIGHT(rcInvalid), 
                                        h, 0, 0, RECTWIDTH(rcInvalid), RECTHEIGHT(rcInvalid), bf);
                                    SelectObject(h, hbmpOld);
                                    DeleteObject(hbmp);
                                }

                                SHOutlineRect(hMemDC, &plv->rcMarquee, g_clrHighlight, g_clrHighlight);
                            }

                            DeleteDC(h);
                        }
                    }


                    BitBlt(hdc, ps.rcPaint.left, ps.rcPaint.top, RECTWIDTH(ps.rcPaint), RECTHEIGHT(ps.rcPaint), hMemDC, ps.rcPaint.left, ps.rcPaint.top, SRCCOPY);

                    SelectObject(hMemDC, hOldBm);

                    DeleteObject(hMemBm);
                    DeleteDC(hMemDC);
                }
            }
        }
        
        // Free DC if necessary
        if (fInternDC)
            EndPaint(plv->ci.hwnd, &ps);
    }
}

void ListView_DrawSimpleBackground(LV *plv, HDC hdc, POINT* ppt, RECT *prcClip)
{
    if (plv->clrBk != CLR_NONE)
    {
        //
        // We just have a simple background color.
        //
        FillRect(hdc, prcClip, plv->hbrBk);
    }
    else
    {
        //
        // Parent HWND draws the background for us.
        //
        POINT pt = {0,0}, ptOrig;
        MapWindowPoints(plv->ci.hwnd, plv->ci.hwndParent, &pt, 1); //Map it to parent's co-ordinates
        OffsetWindowOrgEx(hdc, pt.x, pt.y, &ptOrig);
        
        SendMessage(plv->ci.hwndParent, WM_ERASEBKGND, (WPARAM)hdc, (LPARAM)0); //Make the parent draw into child's DC
        SetWindowOrgEx(hdc, ptOrig.x, ptOrig.y, NULL);
    }
}

#define SATURATE(x, y) { int ___cTemp; ___cTemp = (x) + ((y + 1) * 100 * (x)) / 1000; if (___cTemp > 0xFF) ___cTemp = 0xFF; (x) = (BYTE)___cTemp; }
void SaturateDC(void * pvBitmapBits, int Amount, RECT* prcColumn, RECT* prcImage)
{
    long x, y;

    long uHeight = RECTHEIGHT(*prcImage);
    long uWidth =  RECTWIDTH(*prcImage);
    ULONG* pul = (ULONG*)pvBitmapBits;

    for (y = 0; y < uHeight ;y++)
    {
        for (x = 0; x < uWidth; x++)
        {
            if (x + prcImage->left >= prcColumn->left && x + prcImage->left <= prcColumn->right)
            {
                RGBQUAD* prgb = (RGBQUAD*)&pul[y * uWidth + x];

                SATURATE(prgb->rgbRed, Amount);
                SATURATE(prgb->rgbGreen, Amount);
                SATURATE(prgb->rgbBlue, Amount);
            }
        }
    }
}

void SaturateSortColumn(LV* plv, HDC hdc, void * pvBitmapBits, POINT* ppt, RECT* prcClip)
{
    RECT rc;
    RECT rcUpdate = *prcClip;
    Header_GetItemRect(plv->hwndHdr, plv->iLastColSort, &rc);

    OffsetRect(&rc, ppt->x, 0);

    if (rcUpdate.left < rc.left)
        rcUpdate.left = rc.left;
    if (rcUpdate.right > rc.right)
        rcUpdate.right = rc.right;

    if (rcUpdate.left < rcUpdate.right ||
        IntersectRect(&rc, &rcUpdate, prcClip))
    {
        SaturateDC(pvBitmapBits, 0, &rcUpdate, prcClip);
    }
}

HDC PrepBackgroundDIBSection(HDC hdcDest, RECT* prc, void ** ppvBitmap, HBITMAP* phbmpOld)
{
    HDC hdcRet = CreateCompatibleDC(hdcDest);
    if (hdcRet)
    {
        HBITMAP hbmp;
        BITMAPINFO bi = {0};
        bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
        bi.bmiHeader.biWidth = RECTWIDTH(*prc);
        bi.bmiHeader.biHeight = RECTHEIGHT(*prc);
        bi.bmiHeader.biPlanes = 1;
        bi.bmiHeader.biBitCount = 32;
        bi.bmiHeader.biCompression = BI_RGB;

        hbmp = CreateDIBSection(hdcRet, &bi, DIB_RGB_COLORS, ppvBitmap, NULL, 0);

        *phbmpOld = (HBITMAP)SelectObject(hdcRet, hbmp);

        SetViewportOrgEx(hdcRet, -prc->left, -prc->top, NULL);
    }
    return hdcRet;
}

void CleanupBackgroundDIBSection(HDC hdc, HBITMAP hbmpOld)
{
    if (hdc)
    {
        HBITMAP hbmp = SelectObject(hdc, hbmpOld);
        if (hbmp)
            DeleteObject(hbmp);
        DeleteDC(hdc);
    }
}

void ListView_DrawBackground(LV *plv, HDC hdc, RECT *prcClip)
{
    HRGN hrgnClipSave;
    RECT rcClip;
    POINT ptBackOrg = {0};

    //
    // Compute ptBackOrg (aka scrolling offset), based on view style.
    //
    switch (plv->wView)
    {
        case LV_VIEW_LIST:
            ptBackOrg.x = -plv->xOrigin;
            ptBackOrg.y = 0;
            break;

        case LV_VIEW_DETAILS:
            ptBackOrg.x = -plv->ptlRptOrigin.x;
            ptBackOrg.y = -plv->ptlRptOrigin.y + plv->yTop;
            break;

        default:
            ptBackOrg.x = -plv->ptOrigin.x;
            ptBackOrg.y = -plv->ptOrigin.y;
            break;
    }


    // Optimize the common/simple case
    if (!(plv->pImgCtx && plv->fImgCtxComplete))
    {

        ListView_DrawSimpleBackground(plv, hdc, &ptBackOrg, prcClip);

        if (ListView_IsWatermarked(plv))
        {
            HDC hdcMem = CreateCompatibleDC(hdc);
            if (hdcMem)
            {
                HBITMAP hbmp = (HBITMAP)SelectObject(hdcMem, plv->hbmpWatermark);
                RECT rcWatermark;
                GetClientRect(plv->ci.hwnd, &rcWatermark);
                rcWatermark.left = rcWatermark.right - plv->szWatermark.cx;
                rcWatermark.top = rcWatermark.bottom - plv->szWatermark.cy;
                BitBlt(hdc, rcWatermark.left, rcWatermark.top, plv->szWatermark.cx, plv->szWatermark.cy,
                    hdcMem, 0, 0, SRCCOPY);
                SelectObject(hdcMem, hbmp);
                DeleteDC(hdcMem);
            }
        }

        if (plv->wView == LV_VIEW_DETAILS &&
             plv->iLastColSort != -1 && !plv->fGroupView)
        {
            RECT rcUpdate = *prcClip;
            RECT rc;
            COLORREF cr;

            Header_GetItemRect(plv->hwndHdr, plv->iLastColSort, &rc);

            OffsetRect(&rc, ptBackOrg.x, 0);

            if (rcUpdate.left < rc.left)
                rcUpdate.left = rc.left;
            if (rcUpdate.right > rc.right)
                rcUpdate.right = rc.right;

            cr = GetSortColor(10, plv->clrBk);

            FillRectClr(hdc, &rcUpdate, cr);
        }


        return;
    }

    //
    // Save the old clipping region,
    // since we whack on it a lot.
    //
    hrgnClipSave = CreateRectRgnIndirect(prcClip);
    if (hrgnClipSave)
    {
        if (GetClipRgn(hdc, hrgnClipSave) <= 0)
        {
            DeleteObject(hrgnClipSave);
            hrgnClipSave = NULL;
        }
    }

    //
    // Clip the clipping region to the caller's rectangle,
    // and save the final clipping rectangle in rcClip.
    //
    if (prcClip != NULL)
    {
        IntersectClipRect(hdc, prcClip->left, prcClip->top,
                               prcClip->right, prcClip->bottom);
    }
    GetClipBox(hdc, &rcClip);

    if (plv->pImgCtx && plv->fImgCtxComplete)
    {
        RECT rcImage, rcClient;
        ULONG ulState;
        SIZE sizeImg;
        ListView_Realize(plv, hdc, TRUE, FALSE);

        switch (plv->ulBkImageFlags & LVBKIF_STYLE_MASK)
        {
        case LVBKIF_STYLE_TILE:
            {
                HDC hdcBackBuffer = hdc;
                HBITMAP hbmpOld;
                void * pvBits = NULL;
                POINT ptBackTile = {0};
                if (plv->wView == LV_VIEW_DETAILS && 
                    plv->iLastColSort != -1)
                {
                    hdcBackBuffer = PrepBackgroundDIBSection(hdc, prcClip, &pvBits, &hbmpOld);
                    if (hdcBackBuffer == NULL)
                        hdcBackBuffer = hdc;
                }

                if (!plv->fListviewWatermarkBackgroundImages)
                    ptBackTile = ptBackOrg;

                if (plv->ulBkImageFlags & LVBKIF_FLAG_TILEOFFSET)
                {
                    // These offsets are in pixels, not percent (sorry)
                    ptBackTile.x -= plv->xOffsetPercent;
                    ptBackTile.y -= plv->yOffsetPercent;
                }
                IImgCtx_Tile(plv->pImgCtx, hdcBackBuffer, &ptBackTile, prcClip, NULL);

                if (hdcBackBuffer != hdc)
                {
                    SaturateSortColumn(plv, hdcBackBuffer, pvBits, &ptBackOrg, prcClip);
                    BitBlt(hdc, prcClip->left, prcClip->top, RECTWIDTH(*prcClip), RECTHEIGHT(*prcClip), hdcBackBuffer, prcClip->left, prcClip->top, SRCCOPY);
                    CleanupBackgroundDIBSection(hdcBackBuffer, hbmpOld);
                }

            }
            ExcludeClipRect(hdc, prcClip->left, prcClip->top,
                                 prcClip->right, prcClip->bottom);
            break;

        case LVBKIF_STYLE_NORMAL:
            //
            // Start with the base image.
            //
            IImgCtx_GetStateInfo(plv->pImgCtx, &ulState, &sizeImg, FALSE);
            rcImage.left = 0;
            rcImage.top = 0;
            rcImage.right = sizeImg.cx;
            rcImage.bottom = sizeImg.cy;

            //
            // Adjust for caller offsets.
            //
            GetClientRect(plv->ci.hwnd, &rcClient);
            if (plv->xOffsetPercent)
            {
                LONG dx = plv->xOffsetPercent * (rcClient.right - sizeImg.cx) / 100;

                rcImage.left += dx;
                rcImage.right += dx;
            }
            if (plv->yOffsetPercent)
            {
                LONG dy = plv->yOffsetPercent * (rcClient.bottom - sizeImg.cy) / 100;

                rcImage.top += dy;
                rcImage.bottom += dy;
            }

            //
            // Adjust for ptBackOrg (scrolling offset).
            //
            rcImage.left += ptBackOrg.x;
            rcImage.top += ptBackOrg.y;
            rcImage.right += ptBackOrg.x;
            rcImage.bottom += ptBackOrg.y;

            //
            // Draw the image, if necessary.
            //
            if (RectVisible(hdc, &rcImage))
            {
                IImgCtx_Draw(plv->pImgCtx, hdc, &rcImage);
                ExcludeClipRect(hdc, rcImage.left, rcImage.top,
                                     rcImage.right, rcImage.bottom);
            }
            break;
        }
    }

    //
    // Now draw the rest of the background.
    //
    if (RectVisible(hdc, prcClip))
    {
        ListView_DrawSimpleBackground(plv, hdc, &ptBackOrg, prcClip);
    }

    //
    // Restore old clipping region.
    //
    SelectClipRgn(hdc, hrgnClipSave);
    if (hrgnClipSave)
    {
        DeleteObject(hrgnClipSave);
    }
}

BOOL ListView_OnEraseBkgnd(LV *plv, HDC hdc)
{
    // If redraw is turned off, still process erase bk
    if (ListView_IsDoubleBuffer(plv) && (plv->flags & LVF_REDRAW))
    {
        // No erase, will happen in WM_PAINT handler (ListView_OnPaint)
        return FALSE;
    }
    else
    {
        RECT rcClip;

        //
        // We draw our own background, erase with it.
        //
        GetClipBox(hdc, &rcClip);
        ListView_DrawBackground(plv, hdc, &rcClip);

        return TRUE;
    }
}

void ListView_OnCommand(LV* plv, int id, HWND hwndCtl, UINT codeNotify)
{
    if (hwndCtl == plv->hwndEdit)
    {
        switch (codeNotify)
        {
        case EN_UPDATE:
            // We don't want flicker during replacing current selection
            // as we use selection for IME composition.
            //
            if ((g_fDBCSInputEnabled) && (plv->flags & LVF_INSERTINGCOMP))
                break;
            // We will use the ID of the window as a Dirty flag...
            if (IsWindowVisible(plv->hwndEdit))
            {
                SetWindowID(plv->hwndEdit, 1);
                ListView_SetEditSize(plv);
            }
            break;

        case EN_KILLFOCUS:
            // We lost focus, so dismiss edit and save changes
            // (Note that the owner might reject the change and restart
            // edit mode, which traps the user.  Owners need to give the
            // user a way to get out.)
            //

            //
            //  Fix horrible undocumented hanging problem:  LVN_ENDLABELEDIT
            //  is sent in response to EN_KILLFOCUS, which is send in response
            //  to WM_KILLFOCUS, and it is undocumented that you cannot display
            //  UI during WM_KILLFOCUS when a journal record hook is active,
            //  because the presence of a hook forces serialization of activation,
            //  and so when you put up UI, you generate activation changes, which
            //  get stuck because you haven't finished responding to the previous
            //  WM_KILLFOCUS message yet.
            //
            //  See NT bug 414634.
            //
            if (InSendMessage())
                ReplyMessage(0);

            if (!ListView_DismissEdit(plv, FALSE))
                return;
             break;

         case HN_BEGINDIALOG:  // pen windows is bringing up a dialog
             ASSERT(GetSystemMetrics(SM_PENWINDOWS)); // only on a pen system
             plv->fNoDismissEdit = TRUE;
             break;

         case HN_ENDDIALOG: // pen windows has destroyed dialog
             ASSERT(GetSystemMetrics(SM_PENWINDOWS)); // only on a pen system
             plv->fNoDismissEdit = FALSE;
             break;
        }

        // Forward edit control notifications up to parent
        //
        if (IsWindow(hwndCtl))
            FORWARD_WM_COMMAND(plv->ci.hwndParent, id, hwndCtl, codeNotify, SendMessage);
    }
}

void ListView_OnWindowPosChanged(LV* plv, const WINDOWPOS* lpwpos)
{
    if (!lpwpos || !(lpwpos->flags & SWP_NOSIZE))
    {
        RECT rc;
        int iOldSlots;

        // Update scrollbars first, since ListView_OnEnsureVisible requires accurate scroll info
        ListView_UpdateScrollBars(plv);

        if (ListView_IsOwnerData(plv) &&
                ListView_IsSlotView(plv))
        {
            iOldSlots = ListView_GetSlotCount(plv, TRUE, NULL, NULL);
        }

        GetClientRect(plv->ci.hwnd, &rc);
        plv->sizeClient.cx = rc.right;
        plv->sizeClient.cy = rc.bottom;

        if (ListView_IsAutoArrangeView(plv))
        {
            // Call off to the arrange function.
            ListView_ArrangeOrSnapToGrid(plv);
        }

        if (ListView_IsOwnerData(plv))
        {
            plv->rcView.left = RECOMPUTE;
            ListView_Recompute(plv);

            ListView_DismissEdit(plv, FALSE);
            if (ListView_IsSlotView(plv))
            {
                // Uses the
                int iNewSlots = ListView_GetSlotCount(plv, TRUE, NULL, NULL);
                if ((iNewSlots != iOldSlots) && (ListView_Count(plv) > min(iNewSlots, iOldSlots)))
                    RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
            }
        }

        ListView_RInitialize(plv, TRUE);

        if (ListView_IsWatermarked(plv))
        {
            GetClientRect(plv->ci.hwnd, &rc);
            rc.left = rc.right - plv->szWatermark.cx;
            rc.top = rc.bottom - plv->szWatermark.cy;
            InvalidateRect(plv->ci.hwnd, &rc, TRUE);
        }
    }
}


void ListView_InvalidateSelectedOrCutOwnerData(LV* plv, ILVRange *plvrangeSel)
{
    UINT rdwFlags = RDW_INVALIDATE;
    int cItem = ListView_Count(plv);
    DWORD dwType = plv->wView;
    int i;
    RECT rcView;

    ASSERT(ListView_IsOwnerData(plv));
    ASSERT(plv);

    GetClientRect(plv->ci.hwnd, &rcView);

    if (plv->clrTextBk == CLR_NONE
        || (plv->himl && (plv->clrBk != ImageList_GetBkColor(plv->himl)))) 
    {
        // always do an erase, otherwise the text background won't paint right
        rdwFlags |= RDW_ERASE;
    }

    // calculate start of items and end of items visible on the view
    //
    switch (dwType)
    {
    case LV_VIEW_DETAILS:
        i = ListView_RYHitTest(plv, rcView.top);
        cItem = ListView_RYHitTest(plv, rcView.bottom) + 1;
        break;

    case LV_VIEW_LIST:
      i = ListView_LCalcViewItem(plv, rcView.left, rcView.top);
      cItem = ListView_LCalcViewItem(plv, rcView.right, rcView.bottom) + 1;
        break;

   default:
        ListView_CalcMinMaxIndex(plv, &rcView, &i, &cItem);
        break;
    }

    i = max(i, 0);

    cItem = min(ListView_Count(plv), cItem);
    if (cItem > i)
    {
        ListView_NotifyCacheHint(plv, i, cItem-1);
    }

    for (; i < cItem; i++)
    {
        if (plvrangeSel->lpVtbl->IsSelected(plvrangeSel, i) == S_OK)
        {
            ListView_InvalidateItem(plv, i, FALSE, rdwFlags);
        }
    }
}

void ListView_RedrawSelection(LV* plv)
{
    if (ListView_IsOwnerData(plv)) 
    {
        ListView_InvalidateSelectedOrCutOwnerData(plv, plv->plvrangeSel);
    }
    else 
    {

        int i = -1;

        while ((i = ListView_OnGetNextItem(plv, i, LVNI_SELECTED)) != -1)
        {
            ListView_InvalidateItem(plv, i, TRUE, RDW_INVALIDATE | RDW_ERASE);
        }


        if (ListView_IsReportView(plv)) 
        {
            int iEnd = ListView_RYHitTest(plv, plv->sizeClient.cy) + 1;

            iEnd = min(iEnd, ListView_Count(plv));

            // if we're in report mode, sub items may have selection focus
            for (i = ListView_RYHitTest(plv, 0); i < iEnd; i++) 
            {
                int iCol;

                for (iCol = 1; iCol < plv->cCol; iCol++) 
                {
                    LISTSUBITEM lsi;
                    ListView_GetSubItem(plv, i, iCol, &lsi);
                    if (lsi.state & LVIS_SELECTED) 
                    {
                        ListView_InvalidateItem(plv, i, FALSE, RDW_INVALIDATE | RDW_ERASE);
                    }
                    break;
                }
            }
        }
    }

    UpdateWindow(plv->ci.hwnd);
}

void ListView_OnSetFocus(LV* plv, HWND hwndOldFocus)
{
    ASSERT(gcWheelDelta == 0);

    // due to the way listview call SetFocus on themselves on buttondown,
    // the window can get a strange sequence of focus messages: first
    // set, then kill, and then set again.  since these are not really
    // focus changes, ignore them and only handle "real" cases.
    //
    // But still send out the accessibility notification because USER
    // has already pushed focus back to the listview instead of to the
    // focus item.

    if (hwndOldFocus == plv->ci.hwnd)
    {
        ListView_NotifyFocusEvent(plv);
        return;
    }

    plv->flags |= ListView_HideLabels(plv) ? LVF_FOCUSED : LVF_FOCUSED | LVF_UNFOLDED;
    if (IsWindowVisible(plv->ci.hwnd))
    {
        if (plv->iFocus != -1)
        {
            ListView_InvalidateItem(plv, plv->iFocus, TRUE, RDW_INVALIDATE | RDW_ERASE);
            ListView_NotifyFocusEvent(plv);
        }

        ListView_RedrawSelection(plv);
    }

    // Let the parent window know that we are getting the focus.
    CCSendNotify(&plv->ci, NM_SETFOCUS, NULL);
}

void ListView_OnKillFocus(LV* plv, HWND hwndNewFocus)
{
    // Reset wheel scroll amount
    gcWheelDelta = 0;

    // due to the way listview call SetFocus on themselves on buttondown,
    // the window can get a strange sequence of focus messages: first
    // set, then kill, and then set again.  since these are not really
    // focus changes, ignore them and only handle "real" cases.
    if (!plv || hwndNewFocus == plv->ci.hwnd)
        return;

    ListView_CancelTipTrack(plv);

    plv->flags &= ~(LVF_FOCUSED|LVF_UNFOLDED);

    // Blow this off if we are not currently visible (being destroyed!)
    if (IsWindowVisible(plv->ci.hwnd))
    {
        if (plv->iFocus != -1)
        {
            UINT fRedraw = RDW_INVALIDATE;
            if (plv->clrTextBk == CLR_NONE || plv->fListviewShadowText)
                fRedraw |= RDW_ERASE;
            ListView_InvalidateFoldedItem(plv, plv->iFocus, TRUE, fRedraw);
        }
        ListView_RedrawSelection(plv);
    }

    // Let the parent window know that we are losing the focus.
    CCSendNotify(&plv->ci, NM_KILLFOCUS, NULL);
    IncrementSearchString(&plv->is, 0, NULL);
}

void ListView_DeselectAll(LV* plv, int iDontDeselect)
{
    int i = -1;
    int nSkipped = 0;
    BOOL fWasSelected = FALSE;

    if (iDontDeselect != -1) 
    {
        if (ListView_OnGetItemState(plv, iDontDeselect, LVIS_SELECTED))
            fWasSelected = TRUE;
    }

    if (ListView_IsOwnerData(plv)) 
    {

        // if there's only one item selected, and that item is the iDontDeselect
        // then our work is done...
        plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &plv->nSelected);
        if (plv->nSelected == 1 && fWasSelected)
            return;

        ListView_InvalidateSelectedOrCutOwnerData(plv, plv->plvrangeSel);

        ListView_OnSetItemState(plv, -1, 0, LVIS_SELECTED);
        if (fWasSelected) 
        {
            ListView_OnSetItemState(plv, iDontDeselect, LVIS_SELECTED, LVIS_SELECTED);
            nSkipped = 1;
        }

    } 
    else
    {
       if (iDontDeselect != plv->iFocus)
       {
           ListView_OnSetItemState(plv, plv->iFocus, 0, LVIS_SELECTED);
       }

       while ((plv->nSelected - nSkipped) && (i = ListView_OnGetNextItem(plv, i, LVNI_SELECTED)) != -1) 
       {
           if (i != iDontDeselect)
           {
               ListView_OnSetItemState(plv, i, 0, LVIS_SELECTED);
           } 
           else
           {
               if (fWasSelected) 
               {
                   nSkipped++;
               }
           }
       }
    }

    RIPMSG((plv->nSelected - nSkipped) == 0, "ListView_DeselectAll: Do not refuse a deselect when telling listview to Deselect all.");
    plv->nSelected = nSkipped;
}

// toggle the selection state of an item

void ListView_ToggleSelection(LV* plv, int iItem)
{
    UINT cur_state;
    if (iItem != -1)
    {
        cur_state = ListView_OnGetItemState(plv, iItem, LVIS_SELECTED);
        ListView_OnSetItemState(plv, iItem, cur_state ^ LVIS_SELECTED, LVIS_SELECTED);
    }
}

// Selects (or toggles) a range of items in the list.
//      The curent iFocus is the starting location
//      iItem - is the ending item
//      fToggle - Well set all of the selection state of all of the items to
//          inverse the starting location
//
void ListView_SelectRangeTo(LV* plv, int iItem, BOOL fResetRest)
{
    int iMin, iMax;
    int i = -1;
    UINT uSelVal = LVIS_SELECTED;

    if (plv->iMark == -1)
    {
        ListView_SetFocusSel(plv, iItem, TRUE, TRUE, FALSE);
        return;
    }

    if (!fResetRest)
        uSelVal = ListView_OnGetItemState(plv, plv->iMark, LVIS_SELECTED);

    // If we are in report view or list view we simply walk through the
    // indexes to see which items to select or deselect. otherwise it
    // is is based off of the location of the objects being within the
    // rectangle that is defined by
    if (ListView_IsListView(plv) || (ListView_IsReportView(plv) && !plv->fGroupView))
    {
        iMin = min(iItem, plv->iMark);
        iMax = max(iItem, plv->iMark);

        if (ListView_IsOwnerData(plv)) 
        {
            if (fResetRest)
            {
                ListView_DeselectAll(plv, -1);
            }

            if (iMax > iMin)
            {
                if (LVIS_SELECTED & uSelVal)
                {
                    if (FAILED(plv->plvrangeSel->lpVtbl->IncludeRange(plv->plvrangeSel, iMin, iMax)))
                        return;
                }
                else
                {
                    if (FAILED(plv->plvrangeSel->lpVtbl->ExcludeRange(plv->plvrangeSel, iMin, iMax)))
                        return;
                }
                ListView_SendODChangeAndInvalidate(plv, iMin, iMax, uSelVal ^ LVIS_SELECTED, uSelVal);
            }
            else
            {
                ListView_OnSetItemState(plv, iMin, uSelVal, LVIS_SELECTED);
            }
        }
        else
        {
            if (fResetRest)
            {
                while ((i = ListView_OnGetNextItem(plv, i, LVNI_SELECTED)) != -1)
                {
                    if (i < iMin || i > iMax)
                        ListView_OnSetItemState(plv, i, 0, LVIS_SELECTED);
                }
            }

            while (iMin <= iMax)
            {
                ListView_OnSetItemState(plv, iMin, uSelVal, LVIS_SELECTED);
                iMin++;
            }
        }
    }
    else
    {
        RECT    rcTemp;
        RECT    rcTemp2;
        RECT    rcBounding;
        int iFirstItem = (plv->iMark < iItem)? plv->iMark: iItem;
        int iSecondItem = (plv->iMark > iItem)? plv->iMark: iItem;

        ListView_GetRects(plv, iFirstItem, QUERY_DEFAULT, NULL, NULL, NULL, &rcTemp);
        ListView_GetRects(plv, iSecondItem, QUERY_DEFAULT, NULL, NULL, NULL, &rcTemp2);
        UnionRect(&rcBounding, &rcTemp, &rcTemp2);
        ListView_CalcMinMaxIndex(plv, &rcBounding, &iMin, &iMax);

        if (ListView_IsOwnerData(plv) && (iMax > iMin))
        {
            if (fResetRest)
            {
                ListView_DeselectAll(plv, -1);
            }

            iMax = min(iMax, ListView_Count(plv));
            iMin = max(iMin, 0);

            if (LVIS_SELECTED & uSelVal)
            {
                if (FAILED(plv->plvrangeSel->lpVtbl->IncludeRange(plv->plvrangeSel, iMin, iMax - 1)))
                    return;
            }
            else
            {
                if (FAILED(plv->plvrangeSel->lpVtbl->ExcludeRange(plv->plvrangeSel, iMin, iMax - 1)))
                    return;
            }

            ListView_SendODChangeAndInvalidate(plv, iMin, iMax, uSelVal ^ LVIS_SELECTED, uSelVal);

        } 
        else 
        {
            int iZ;
            POINT pt;
            RECT rcItem;
    
            for (i = 0; i < ListView_Count(plv); i++)
            {
                ListView_GetRects(plv, i, QUERY_DEFAULT, NULL, NULL, NULL, &rcItem);
                pt.x = (rcItem.right + rcItem.left) / 2;  // center of item
                pt.y = (rcItem.bottom + rcItem.top) / 2;

                // Is the item within the y bound of the first and last item?
                if (pt.y > rcTemp.top &&
                    pt.y < rcTemp2.bottom)
                {
                    // Yes. Check to see if the item is in the first row.
                    if (pt.y < rcTemp.bottom)
                    {
                        // It is. Then check to see if it's before the first item in that row.
                        if (pt.x < rcTemp.left)
                        {
                            // It is. Then this item is not to be selected.
                            if (fResetRest)
                                ListView_OnSetItemState(plv, i, 0, LVIS_SELECTED);

                            // Continue to the next item
                            continue;
                        }

                    }

                    // Is the item in the last row?
                    if (pt.y > rcTemp2.top)
                    {
                        // Yes. Is it after the last item in the selection?
                        if (pt.x > rcTemp2.right)
                        {
                            // It is. Then this item is not to be selected.
                            if (fResetRest)
                                ListView_OnSetItemState(plv, i, 0, LVIS_SELECTED);

                            // Continue to the next item
                            continue;
                        }
                    }

                    // The item is in the selection range. Go ahead and select it

                    if (!ListView_IsOwnerData(plv))
                    {
                      iZ = ListView_ZOrderIndex(plv, i);

                      if (iZ > 0)
                          DPA_InsertPtr(plv->hdpaZOrder, 0, DPA_DeletePtr(plv->hdpaZOrder, iZ));
                    }

                    ListView_OnSetItemState(plv, i, uSelVal, LVIS_SELECTED);
                }
                else if (fResetRest)
                    ListView_OnSetItemState(plv, i, 0, LVIS_SELECTED);
            }
        }
    }
}

// makes an item the focused item and optionally selects it
//
// in:
//      iItem           item to get the focus
//      fSelectAlso     select this item as well as set it as the focus
//      fDeselectAll    deselect all items first
//      fToggleSel      toggle the selection state of the item
//
// returns:
//      index of focus item (if focus change was refused)

int ListView_SetFocusSel(LV* plv, int iItem, BOOL fSelectAlso, BOOL fDeselectAll, BOOL fToggleSel)
{
    int iFocus = plv->iFocus;
    
    // if we're single sel mode, don't bother with this because
    // the set item will do it for us
    if (!(plv->ci.style & LVS_SINGLESEL) && (fDeselectAll))
        ListView_DeselectAll(plv, -1);
    
    if (iItem != plv->iFocus)
    {
        // remove the old focus
        if (plv->iFocus != -1)
        {
            // If he refuses to give up the focus, bail out.
            if (!ListView_OnSetItemState(plv, plv->iFocus, 0, LVIS_FOCUSED))
                return plv->iFocus;
        }
    }
    
    if (!ListView_IsOwnerData(plv))
    {
        
        if (fSelectAlso)
        {
            if (ListView_IsIconView(plv) || ListView_IsSmallView(plv) || ListView_IsTileView(plv))
            {
                int iZ = ListView_ZOrderIndex(plv, iItem);
                
                if (iZ > 0)
                    DPA_InsertPtr(plv->hdpaZOrder, 0, DPA_DeletePtr(plv->hdpaZOrder, iZ));
            }
        }
    }
    
    /* Ensure that when moving focus that we refresh the previous focus
    owner properly. */
    
    if (iFocus != -1 && iFocus != plv->iFocus && (plv->flags & LVF_UNFOLDED))
        ListView_InvalidateFoldedItem(plv, iFocus, FALSE, RDW_INVALIDATE);
    
    if (plv->iMark == -1)
        plv->iMark = iItem;
    
    SetTimer(plv->ci.hwnd, IDT_SCROLLWAIT, GetDoubleClickTime(), NULL);
    plv->flags |= LVF_SCROLLWAIT;
    
    if (fToggleSel)
    {
        ListView_ToggleSelection(plv, iItem);
        ListView_OnSetItemState(plv, iItem, LVIS_FOCUSED, LVIS_FOCUSED);
    }
    else
    {
        UINT flags = ((fSelectAlso || plv->ci.style & LVS_SINGLESEL) ?
            (LVIS_SELECTED | LVIS_FOCUSED) : LVIS_FOCUSED);
        ListView_OnSetItemState(plv, iItem, flags, flags);
    }
    
    return iItem;
}

UINT GetLVKeyFlags()
{
    UINT uFlags = 0;

    if (GetKeyState(VK_MENU) < 0)
        uFlags |= LVKF_ALT;
    if (GetKeyState(VK_CONTROL) < 0)
        uFlags |= LVKF_CONTROL;
    if (GetKeyState(VK_SHIFT) < 0)
        uFlags |= LVKF_SHIFT;

    return uFlags;
}

void ListView_OnKey(LV* plv, UINT vk, BOOL fDown, int cRepeat, UINT flags)
{
    UINT lvni = 0;
    int iNewFocus;
    BOOL fCtlDown;
    BOOL fShiftDown;
    LV_KEYDOWN nm;
    HWND hwnd = plv->ci.hwnd;

    if (!fDown)
        return;

    // Cancel manual tip track if any key is pressed
    ListView_CancelTipTrack(plv);

    // Swap the left and right arrow key if the control is mirrored.
    vk = RTLSwapLeftRightArrows(&plv->ci, vk);

    //prevent any change in selected items before the dbl click timer goes off
    //so that we don't launch wrong item(s)
    if (plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickHappened && plv->fOneClickOK)
    {
        //if a key is pressed with a mouse click with one click activate and double click
        //timer, we end up setting up a timer and then processing the keydown
        //this causes an item to be launched right away (from this code) and in case
        //of return being pressed it causes double activation
        //prevent these cases:
        if (vk == VK_SHIFT || vk == VK_CONTROL || vk == VK_MENU || vk == VK_RETURN)
            return;
        KillTimer(plv->ci.hwnd, IDT_ONECLICKHAPPENED);
        plv->fOneClickHappened = FALSE;
        CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &(plv->nmOneClickHappened.hdr));
        if (!IsWindow(hwnd))
            return;
    }

    // Notify
    nm.wVKey = (WORD) vk;
    nm.flags = flags;
    if (CCSendNotify(&plv->ci, LVN_KEYDOWN, &nm.hdr))
    {
        plv->iPuntChar++;
        return;
    } 
    else if (plv->iPuntChar)
    {
        // this is tricky...  if we want to punt the char, just increment the
        // count.  if we do NOT, then we must clear the queue of WM_CHAR's
        // this is to preserve the iPuntChar to mean "punt the next n WM_CHAR messages
        MSG msg;
        while(plv->iPuntChar && PeekMessage(&msg, plv->ci.hwnd, WM_CHAR, WM_CHAR, PM_REMOVE))
        {
            plv->iPuntChar--;
        }
        ASSERT(!plv->iPuntChar);
    }

    if (ListView_Count(plv) == 0)   // don't blow up on empty list
        return;

    fCtlDown = GetKeyState(VK_CONTROL) < 0;
    fShiftDown = GetKeyState(VK_SHIFT) < 0;

    switch (vk)
    {
    case VK_SPACE:
        // If shift (extend) or control (disjoint) select,
        // then toggle selection state of focused item.
        if (fCtlDown)
        {
            plv->iMark = plv->iFocus;
            ListView_ToggleSelection(plv, plv->iFocus);
            plv->iPuntChar++;
        }

        if (fShiftDown) 
        {
            ListView_SelectRangeTo(plv, plv->iFocus, TRUE);
        }

        if (ListView_CheckBoxes(plv))
        {
            if (plv->iFocus != -1)
                ListView_HandleStateIconClick(plv, plv->iFocus);

            if (ListView_IsSimpleSelect(plv))
            {
                int iToggle = -1;
                while ((iToggle = ListView_OnGetNextItem(plv, iToggle, LVNI_SELECTED)) != -1)
                {
                    if (plv->iFocus != iToggle)
                    {
                        ListView_HandleStateIconClick(plv, iToggle);
                    }
                }
            }
        }
        //notify of navigation key usage
        CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
        return;

    case VK_RETURN:
        CCSendNotify(&plv->ci, NM_RETURN, NULL);

        /// some (comdlg32 for example) destroy on double click
        // we need to bail if that happens because plv is no longer valid
        if (!IsWindow(hwnd))
            return;

        {
            NMITEMACTIVATE nm;

            nm.iItem = plv->iFocus;
            nm.iSubItem = 0;
            nm.uChanged = 0;
            nm.ptAction.x = -1;
            nm.ptAction.y = -1;
            nm.uKeyFlags = GetLVKeyFlags();
            CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &nm.hdr);
            if (!IsWindow(hwnd))
                return;
        }
        //notify of navigation key usage
        CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
        return;

    case VK_ADD:
        if (ListView_IsReportView(plv) && (GetKeyState(VK_CONTROL) < 0))
        {
            HCURSOR hcurPrev;
            int i;

            hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));
            for (i=0; i < plv->cCol; i++)
            {
                ListView_RSetColumnWidth(plv, i, -1);
            }

            SetCursor(hcurPrev);
            //notify of navigation key usage
            CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
            return;
        }
    }

    if (GetKeyState(VK_MENU) < 0)
        return;

    // For a single selection listview, disable extending the selection
    // by turning off the keyboard modifiers.
    if (plv->ci.style & LVS_SINGLESEL)
    {
        fCtlDown = FALSE;
        fShiftDown = FALSE;
    }

    //
    // Let the Arrow function attempt to process the key.
    //
    iNewFocus = ListView_Arrow(plv, plv->iFocus, vk);

    // If control (disjoint) selection, don't change selection.
    // If shift (extend) or control selection, don't deselect all.
    //
    if (iNewFocus != -1)
    {
        if (fShiftDown)
        {
            ListView_SelectRangeTo(plv, iNewFocus, TRUE);
            ListView_SetFocusSel(plv, iNewFocus, FALSE, FALSE, FALSE);
        }
        else 
        {
            if (!fCtlDown)
                plv->iMark = iNewFocus;
            ListView_SetFocusSel(plv, iNewFocus, !fCtlDown, !fShiftDown && !fCtlDown, FALSE);
        }
        IncrementSearchString(&plv->is, 0, NULL);
        CCPlaySound(c_szSelect);

        ListView_OnKeyboardSelected(plv, iNewFocus);
    }

    // on keyboard movement, scroll immediately.
    if (ListView_CancelScrollWait(plv)) 
    {
        ListView_OnEnsureVisible(plv, plv->iFocus, FALSE);
        UpdateWindow(plv->ci.hwnd);
    }

    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
}

//
//  LVN_INCREMENTALSEARCH gives the app the opportunity to customize
//  incremental search.  For example, if the items are numeric,
//  the app can do numerical search instead of string search.
//
//  App sets pnmfi->lvfi.lParam to the result of the incremental search,
//  or to -2 to fai the search and just beep.
//
//  App can return 2 to indicate that all processing should stop, if
//  app wants to take over incremental search completely.
//
BOOL ListView_IncrementalSearch(LV *plv, int iStartFrom, LPNMLVFINDITEM pnmfi, int *pi)
{
    INT_PTR fRc;

    ASSERT(!(pnmfi->lvfi.flags & LVFI_PARAM));
    pnmfi->lvfi.lParam = -1;

    fRc = CCSendNotify(&plv->ci, LVN_INCREMENTALSEARCH, &pnmfi->hdr);
    *pi = (int)pnmfi->lvfi.lParam;

    // Cannot just return fRc because some apps return 1 to all WM_NOTIFY's
    return fRc == 2;
}

// Now only Korean version is interested in incremental search with composition string.
LPTSTR GET_COMP_STRING(HIMC hImc, DWORD dwFlags)
{
    LONG iNumComp;
    PTSTR pszCompStr;
    iNumComp = ImmGetCompositionString(hImc, dwFlags, NULL, 0);
    pszCompStr = (PTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(iNumComp+1));
    if (pszCompStr)
    {
        if (iNumComp)
            ImmGetCompositionString(hImc, dwFlags, pszCompStr, iNumComp+1);
        pszCompStr[iNumComp] = TEXT('\0');
    }
    return pszCompStr;
}

#define FREE_COMP_STRING(pszCompStr)    LocalFree((HLOCAL)(pszCompStr))

BOOL ListView_OnImeComposition(LV* plv, WPARAM wParam, LPARAM lParam)
{
    LPTSTR lpsz;
    NMLVFINDITEM nmfi;
    int i;
    int iStartFrom = -1;
    int iLen;
    int iCount;
    HIMC hImc;
    TCHAR *pszCompStr;
    BOOL fRet = TRUE;

    iCount = ListView_Count(plv);

    if (!iCount || plv->iFocus == -1)
        return fRet;

    if (hImc = ImmGetContext(plv->ci.hwnd))
    {
        if (lParam & GCS_RESULTSTR)
        {
            fRet = FALSE;
            pszCompStr = GET_COMP_STRING(hImc, GCS_RESULTSTR);
            if (pszCompStr)
            {
                IncrementSearchImeCompStr(&plv->is, FALSE, pszCompStr, &lpsz);
                FREE_COMP_STRING(pszCompStr);
            }
        }
        if (lParam & GCS_COMPSTR)
        {
            fRet = TRUE;
            pszCompStr = GET_COMP_STRING(hImc, GCS_COMPSTR);
            if (pszCompStr)
            {
                if (IncrementSearchImeCompStr(&plv->is, TRUE, pszCompStr, &lpsz))
                    iStartFrom = plv->iFocus;
                else
                    iStartFrom = ((plv->iFocus - 1) + iCount)% iCount;

                nmfi.lvfi.flags = LVFI_SUBSTRING | LVFI_STRING | LVFI_WRAP;
                nmfi.lvfi.psz = lpsz;
                iLen = lstrlen(lpsz);

                // special case space as the first character
                if ((iLen == 1) && (*lpsz == TEXT(' '))) 
                {
                    if (plv->iFocus != -1)
                    {
                        ListView_OnSetItemState(plv, plv->iFocus, LVIS_SELECTED, LVIS_SELECTED);
                        IncrementSearchString(&plv->is, 0, NULL);
                    }
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
                    return fRet;
                }

                // Give caller full string in case they want to do something custom
                if (ListView_IncrementalSearch(plv, iStartFrom, &nmfi, &i))
                    return fRet;

                if (iLen > 0 && SameChars(lpsz, lpsz[0])) 
                {
                    //  The user has been typing the same char over and over again.
                    //  Switch from incremental search to Windows 3.1 style search.
                    iStartFrom = plv->iFocus;
                    nmfi.lvfi.psz = lpsz + iLen - 1;
                }

                if (i == -1)
                    i = ListView_OnFindItem(plv, iStartFrom, &nmfi.lvfi);

                if (!ListView_IsValidItemNumber(plv, i))
                {
                    i = -1;
                }

                TraceMsg(TF_LISTVIEW, "CIme listsearch %d %s %d", (LPTSTR)lpsz, (LPTSTR)lpsz, i);

                if (i != -1)
                {
                    ListView_SetFocusSel(plv, i, TRUE, TRUE, FALSE);
                    plv->iMark = i;
                    if (ListView_CancelScrollWait(plv))
                            ListView_OnEnsureVisible(plv, i, FALSE);
                } 
                else 
                {
                    // Don't beep on spaces, we use it for selection.
                    IncrementSearchBeep(&plv->is);
                }

                //notify of navigation key usage
                CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
                FREE_COMP_STRING(pszCompStr);
            }
        }
        ImmReleaseContext(plv->ci.hwnd, hImc);
    }
    return fRet;
}

// REVIEW: We will want to reset ichCharBuf to 0 on certain conditions,
// such as: focus change, ENTER, arrow key, mouse click, etc.
//
void ListView_OnChar(LV* plv, UINT ch, int cRepeat)
{
    LPTSTR lpsz;
    NMLVFINDITEM nmfi;
    int i;
    int iStartFrom = -1;
    int iLen;
    int iCount;

    iCount = ListView_Count(plv);

    if (!iCount)
        return;

    // Don't search for chars that cannot be in a file name (like ENTER and TAB)
    // The Polish keyboard layout uses CTRL+ALT to
    // enter some normal letters, so don't punt if the CTRL key is down or
    // people in Poland are in trouble!  We need to fix this. NTRAID 5262.
    if (ch < TEXT(' '))// || GetKeyState(VK_CONTROL) < 0)
    {
        IncrementSearchString(&plv->is, 0, NULL);
        return;
    }

    if (IncrementSearchString(&plv->is, ch, &lpsz))
        iStartFrom = plv->iFocus;
    else
        iStartFrom = ((plv->iFocus - 1) + iCount)% iCount;

    nmfi.lvfi.flags = LVFI_SUBSTRING | LVFI_STRING | LVFI_WRAP;
    nmfi.lvfi.psz = lpsz;
    iLen = lstrlen(lpsz);

    // special case space as the first character
    if ((iLen == 1) && (*lpsz == ' ')) 
    {
        if (plv->iFocus != -1) 
        {
            ListView_OnSetItemState(plv, plv->iFocus, LVIS_SELECTED, LVIS_SELECTED);
            IncrementSearchString(&plv->is, 0, NULL);
        }
        //notify of navigation key usage
        CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
        return;
    }

    // Give caller full string in case they want to do something custom
    if (ListView_IncrementalSearch(plv, iStartFrom, &nmfi, &i))
        return;

    if (iLen > 0 && SameChars(lpsz, lpsz[0])) 
    {
        //
        //  The user has been typing the same char over and over again.
        //  Switch from incremental search to Windows 3.1 style search.
        //
        iStartFrom = plv->iFocus;
        nmfi.lvfi.psz = lpsz + iLen - 1;
    }

    if (i == -1)
        i = ListView_OnFindItem(plv, iStartFrom, &nmfi.lvfi);

    if (!ListView_IsValidItemNumber(plv, i)) 
    {
        i = -1;
    }

    TraceMsg(TF_LISTVIEW, "listsearch %d %s %d", (LPTSTR)lpsz, (LPTSTR)lpsz, i);

    if (i != -1) 
    {
        ListView_SetFocusSel(plv, i, TRUE, TRUE, FALSE);
        plv->iMark = i;
        if (ListView_CancelScrollWait(plv))
            ListView_OnEnsureVisible(plv, i, FALSE);
    } 
    else 
    {
        // Don't beep on spaces, we use it for selection.
        IncrementSearchBeep(&plv->is);
    }

    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
}

BOOL SameChars(LPTSTR lpsz, TCHAR c)
{
    while (*lpsz)
    {
        if (*lpsz++ != c)
            return FALSE;
    }
    return TRUE;
}

UINT ListView_OnGetDlgCode(LV* plv, MSG* lpmsg)
{
    return DLGC_WANTARROWS | DLGC_WANTCHARS;
}

int ListView_ComputeCXItemSize(LV* plv)
{
    int cxItem;

    cxItem = 16 * plv->cxLabelChar + plv->cxSmIcon;
    if (cxItem == 0)
    {
        cxItem = g_cxBorder;
    }

    ASSERT(cxItem != 0);
    return cxItem;
}

int ListView_ComputeCYItemSize(LV* plv)
{
    int cyItem;

    cyItem = max(plv->cyLabelChar, plv->cySmIcon);

    if (plv->himlState)
    {
        cyItem = max(cyItem, plv->cyState);
    }

    cyItem += g_cyBorder;

    ASSERT(cyItem != 0);
    return cyItem;
}

void ListView_InvalidateCachedLabelSizes(LV* plv)
{
    int i;

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    // Label wrapping has changed, so we need to invalidate the
    // size of the items, such that they will be recomputed.
    //
    if (!ListView_IsOwnerData(plv))
    {
        for (i = ListView_Count(plv) - 1; i >= 0; i--)
        {
            LISTITEM* pitem = ListView_FastGetItemPtr(plv, i);
            ListView_SetSRecompute(pitem);
        }
    }
    plv->rcView.left = RECOMPUTE;

    if ((plv->ci.style & LVS_OWNERDRAWFIXED) && ListView_IsReportView(plv))
        plv->cyItemSave = ListView_ComputeCYItemSize(plv);
    else
    {
        plv->cyItem = ListView_ComputeCYItemSize(plv);
    }
}


void ListView_OnStyleChanging(LV* plv, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE) 
    {
        // Don't allow LVS_OWNERDATA to change after creation
        DWORD stylePreserve = LVS_OWNERDATA;

        // Don't allow a LVS_EX_REGIONAL listview to change type, since
        // it must be LVS_ICON
        // Similarly, HideLabels only works in large icon mode so keep the type.
        if ((plv->exStyle & LVS_EX_REGIONAL) || ListView_HideLabels(plv))
            stylePreserve |= LVS_TYPEMASK;

        // Preserve the bits that must be preserved
        pinfo->styleNew ^= (pinfo->styleNew ^ pinfo->styleOld) & stylePreserve;

        // If we're in group view, then listview must be in autoarrange
        if (plv->fGroupView)
        {
            pinfo->styleNew |= LVS_AUTOARRANGE;
        }

    }
}

WORD MapViewStyle(DWORD style)
{
    if (style == LVS_LIST)
        return LV_VIEW_LIST;
    if (style == LVS_SMALLICON)
        return LV_VIEW_SMALLICON;
    if (style == LVS_REPORT)
        return LV_VIEW_DETAILS;

    return LV_VIEW_ICON;
}

void ListView_OnStyleChanged(LV* plv, UINT gwl, LPSTYLESTRUCT pinfo)
{
    // Style changed: redraw everything...
    //
    // try to do this smartly, avoiding unnecessary redraws
    if (gwl == GWL_STYLE)
    {
        BOOL fRedraw = FALSE, fShouldScroll = FALSE;
        DWORD changeFlags, styleOld;

        ListView_DismissEdit(plv, FALSE);

        changeFlags = plv->ci.style ^ pinfo->styleNew;
        styleOld = plv->ci.style;

        // (dli) Setting the small icon width here and only in the case when we go
        // from large icon view to some other view because of three reasons:
        // 1. According to chee, we want to set this before we change the style bit in
        // plv or after we scale.
        // 2. We don't want to do it after we scale because we want to set the width to
        // the maximum value so that the items in this listview do not cover each other
        // 3. we do it from large icon view because large icon view has fixed width for
        // each item, small icon view width can be scaled.
        //
        if ((changeFlags & LVS_TYPEMASK) && (plv->wView == LV_VIEW_ICON))
            ListView_ISetColumnWidth(plv, 0,
                                     LV_GetNewColWidth(plv, 0, ListView_Count(plv)-1), FALSE);

        plv->ci.style = pinfo->styleNew;        // change our version

        if (changeFlags & (WS_BORDER | WS_CAPTION | WS_THICKFRAME)) 
        {
            // the changing of these bits affect the size of the window
            // but not until after this message is handled
            // so post ourself a message.
            PostMessage(plv->ci.hwnd, LVMP_WINDOWPOSCHANGED, 0, 0);
        }

        if (changeFlags & LVS_NOCOLUMNHEADER)
        {
            if (plv->hwndHdr)
            {
                SetWindowBits(plv->hwndHdr, GWL_STYLE, HDS_HIDDEN,
                              (plv->ci.style & LVS_NOCOLUMNHEADER) ? HDS_HIDDEN : 0);

                fRedraw = TRUE;
                fShouldScroll = TRUE;
            }
        }

        if (changeFlags & LVS_NOLABELWRAP)
        {
            ListView_InvalidateCachedLabelSizes(plv);
            fShouldScroll = TRUE;
            fRedraw = TRUE;
        }

        if (changeFlags & LVS_TYPEMASK)
        {
            WORD wViewOld = plv->wView;
            plv->wView = MapViewStyle(plv->ci.style & LVS_TYPEMASK);
            ListView_TypeChange(plv, wViewOld, (BOOL)BOOLIFY(styleOld & LVS_OWNERDRAWFIXED));
            fShouldScroll = TRUE;
            fRedraw = TRUE;
        }

        if (changeFlags & LVS_AUTOARRANGE)
        {
            if (plv->ci.style & LVS_AUTOARRANGE)
            {
                // Turned on.
                ListView_OnArrange(plv, LVA_DEFAULT);
                fRedraw = TRUE;
            }
            else
            {
                // Turned off. Nuke insertmark, because that's not allowed when
                // auto-arrange is off.
                LVINSERTMARK lvim = {0};
                lvim.cbSize = sizeof(LVINSERTMARK);
                lvim.iItem = -1;
                ListView_OnSetInsertMark(plv, &lvim);
            }
        }

        // previously, this was the else to
        // (changeFlags & LVS_AUTOARRANGE && (plv->ci.style & LVS_AUTOARRANGE))
        // I'm not sure that was really the right thing..
        if (fShouldScroll)
        {
            // Else we would like to make the most important item to still
            // be visible.  So first we will look for a cursorered item
            // if this fails, we will look for the first selected item,
            // else we will simply ask for the first item (assuming the
            // count > 0
            //
            int i;

            // And make sure the scrollbars are up to date Note this
            // also updates some variables that some views need
            ListView_UpdateScrollBars(plv);

            i = (plv->iFocus >= 0) ? plv->iFocus : ListView_OnGetNextItem(plv, -1, LVNI_SELECTED);
            if ((i == -1)  && (ListView_Count(plv) > 0))
                i = 0;

            if (i != -1)
                ListView_OnEnsureVisible(plv, i, TRUE);
        }

        if (fRedraw)
            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
    }
    else if (gwl == GWL_EXSTYLE)
    {
        //
        // If the RTL_MIRROR extended style bit had changed, let's
        // repaint the control window.
        //
        if ((plv->ci.dwExStyle&RTL_MIRRORED_WINDOW) !=  (pinfo->styleNew&RTL_MIRRORED_WINDOW))
            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);

        // Save the new ex-style bits
        plv->ci.dwExStyle = pinfo->styleNew;
    }

    // Change of styles also changes tooltip policy, so pop it
    ListView_PopBubble(plv);
}

void ListView_TypeChange(LV* plv, WORD wViewOld, BOOL fOwnerDrawFixed)
{
    RECT rc;
    int i;
    //
    //  Invalidate all cached string metrics because customdraw clients
    //  may draw differently depending on the type.  This happens more
    //  often than you might think, not on purpose, but because apps are
    //  buggy.
    //
    if (!ListView_IsOwnerData(plv))
    {
        for (i = 0; i < ListView_Count(plv); i++)
        {
            LISTITEM *pitem = ListView_FastGetItemPtr(plv, i);
            ListView_SetSRecompute(pitem);
        }
    }

    switch (wViewOld)
    {
    case LV_VIEW_DETAILS:
        ShowWindow(plv->hwndHdr, SW_HIDE);
        if (fOwnerDrawFixed) 
        {
            // swap cyItem and cyFixed;
            int temp = plv->cyItem;
            plv->cyItem = plv->cyItemSave;
            plv->cyItemSave = temp;
        }
        break;

    default:
        break;
    }

    plv->ptOrigin.x = 0;
    plv->ptOrigin.y = 0;
    plv->ptlRptOrigin.x = 0;
    plv->ptlRptOrigin.y = 0;
    plv->rcView.left = RECOMPUTE;

    _ListView_RecomputeEx(plv, NULL, 0, TRUE);

    // Now handle any special setup needed for the new view
    switch (plv->wView)
    {
    case LV_VIEW_LIST:
        // We may need to resize the columns
        ListView_MaybeResizeListColumns(plv, 0, ListView_Count(plv)-1);
        break;

    case LV_VIEW_DETAILS:
        // if it's owner draw fixed, we may have to do funky stuff
        if (wViewOld != LV_VIEW_DETAILS) 
        {
            plv->cyItemSave = plv->cyItem;
        }
        ListView_RInitialize(plv, FALSE);
        break;

    default:
        break;
    }

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    GetClientRect(plv->ci.hwnd, &rc);
    plv->sizeClient.cx = rc.right;
    plv->sizeClient.cy = rc.bottom;
}

int ListView_OnHitTest(LV* plv, LV_HITTESTINFO* pinfo)
{
    UINT flags;
    int x, y;

    if (!pinfo) return -1;

    x = pinfo->pt.x;
    y = pinfo->pt.y;

    pinfo->iItem = -1;
    flags = 0;
    if (x < 0)
        flags |= LVHT_TOLEFT;
    else if (x >= plv->sizeClient.cx)
        flags |= LVHT_TORIGHT;
    if (y < 0)
        flags |= LVHT_ABOVE;
    else if (y >= plv->sizeClient.cy)
        flags |= LVHT_BELOW;

    if (flags == 0)
    {
        pinfo->iItem = _ListView_ItemHitTest(plv, x, y, &flags, NULL);
    }

    pinfo->flags = flags;

    if (pinfo->iItem >= ListView_Count(plv))
    {
        pinfo->iItem = -1;
        pinfo->flags = LVHT_NOWHERE;
    }
    return pinfo->iItem;
}

int ScrollAmount(int large, int iSmall, int unit)
{

    return (((large - iSmall) + (unit - 1)) / unit) * unit;
}

// NOTE: this is duplicated in shell32.dll
//
// checks to see if we are at the end position of a scroll bar
// to avoid scrolling when not needed (avoid flashing)
//
// in:
//      code        SB_VERT or SB_HORZ
//      bDown       FALSE is up or left
//                  TRUE  is down or right
BOOL CanScroll(LV* plv, int code, BOOL bDown)
{
    SCROLLINFO si;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_RANGE | SIF_PAGE | SIF_POS;

    if (ListView_GetScrollInfo(plv, code, &si))
    {
        if (bDown)
        {
            if (si.nPage)
                si.nMax -= (si.nPage - 1);
            return si.nPos < si.nMax;
        }
        else
        {
            return si.nPos > si.nMin;
        }
    }
    else
    {
        return FALSE;
    }
}

// detect if we should auto scroll the window
//
// in:
//      pt  cursor pos in hwnd's client coords
// out:
//      pdx, pdy ammount scrolled in x and y
//
// REVIEW, this should make sure a certain amount of time has passed
// before scrolling.

void ScrollDetect(LV* plv, POINT pt, int *pdx, int *pdy)
{
    int dx, dy;

    *pdx = *pdy = 0;

    if (!(plv->ci.style & (WS_HSCROLL | WS_VSCROLL)))
        return;

    dx = dy = plv->cyIcon / 16;
    if (ListView_IsReportView(plv)) 
    {
        if (!plv->fGroupView)       // Groupview is always in pixels
            dy = plv->cyItem;       // we scroll in units of items...

        if (!dx)
            dx = plv->cxSmIcon;
    }


    if (ListView_IsListView(plv))
        dx = plv->cxItem;

    if (!dx)
        dx = 1;

    if (!dy)
        dy = 1;

    // we need to check if we can scroll before acutally doing it
    // since the selection rect is adjusted based on how much
    // we scroll by

    if (plv->ci.style & WS_VSCROLL) // scroll vertically?
    { 

        if (pt.y >= plv->sizeClient.cy) 
        {
            if (CanScroll(plv, SB_VERT, TRUE))
                *pdy = ScrollAmount(pt.y, plv->sizeClient.cy, dy);   // down
        }
        else if (pt.y <= 0) 
        {
            if (CanScroll(plv, SB_VERT, FALSE))
                *pdy = -ScrollAmount(0, pt.y, dy);     // up
        }
    }

    if (plv->ci.style & WS_HSCROLL) // horizontally
    { 
        if (pt.x >= plv->sizeClient.cx) 
        {
            if (CanScroll(plv, SB_HORZ, TRUE))
                *pdx = ScrollAmount(pt.x, plv->sizeClient.cx, dx);    // right
        } 
        else if (pt.x <= 0) 
        {
            if (CanScroll(plv, SB_HORZ, FALSE))
                *pdx = -ScrollAmount(0, pt.x, dx);    // left
        }
    }

    // REARCHITECT: this will potentially scroll outside the bounds of the
    // listview.  we should bound the scroll amount in CanScroll()
    // or ScrollAmount().

    if (*pdx || *pdy)
    {
        ListView_ValidateScrollParams(plv, pdx, pdy);
    }
}

#define swap(pi1, pi2) {int i = *(pi1) ; *(pi1) = *(pi2) ; *(pi2) = i ;}

void OrderRect(RECT *prc)
{
    if (prc->left > prc->right)
        swap(&prc->left, &prc->right);

    if (prc->bottom < prc->top)
        swap(&prc->bottom, &prc->top);
}

// in:
//      x, y    starting point in client coords

#define SCROLL_FREQ     (GetDoubleClickTime()/2)     // 1/5 of a second between scrolls

BOOL ShouldScroll(LV* plv, LPPOINT ppt, LPRECT lprc)
{
    ASSERT(ppt);

    if (plv->ci.style & WS_VSCROLL)
    {
        if (ppt->y >= lprc->bottom)
        {
            if (CanScroll(plv, SB_VERT, TRUE))
                return TRUE;
        }
        else if (ppt->y <= lprc->top)
        {
            if (CanScroll(plv, SB_VERT, FALSE))
                return TRUE;
        }
    }

    if (plv->ci.style & WS_HSCROLL)
    {
        if (ppt->x >= lprc->right)
        {
            if (CanScroll(plv, SB_HORZ, TRUE))
                return TRUE;
        }
        else if (ppt->x <= lprc->left)
        {
            if (CanScroll(plv, SB_HORZ, FALSE))
                return TRUE;
        }
    }

    return FALSE;
}

BOOL DrawFocusRectClip(HDC hdc, CONST RECT * prc, CONST RECT * prcClip)
{
    RECT rc;

    IntersectRect(&rc, prc, prcClip);

    return DrawFocusRect(hdc, &rc);
}


// Listview is "Alpha Capable" if:
//      Colors >= 16bpp  (Needed for alpha)
//      The Listview is double buffered (Needed for flicker)
//      The use has "Show window contents while dragging"  (Needed to turn off on slow machines)
//          NOTE: g_fDragFullWindows is turned off in comctl32 when running a remote session
BOOL ListView_IsAlphaMarqueeCapable(LV* plv)
{
    BOOL fAlphaCapable = FALSE;
    if (ListView_IsDoubleBuffer(plv))
    {
        if (AreAllMonitorsAtLeast(16))
        {
            fAlphaCapable = plv->fListviewAlphaSelect;
        }
    }

    return fAlphaCapable;
}

void ListView_DragSelect(LV *plv, int x, int y)
{
    RECT rc, rcWindow, rcOld, rcUnion, rcTemp2, rcClip;
    POINT pt;
    MSG32 msg32;
    HDC hdc;
    HWND hwnd = plv->ci.hwnd;
    int i, iEnd, dx, dy;
    BOOL bInOld, bInNew = FALSE, bLocked = FALSE;
    DWORD dwTime, dwNewTime;
    HRGN hrgnUpdate = NULL, hrgnLV = NULL;
    BOOL fAlphaMarquee = ListView_IsAlphaMarqueeCapable(plv);

    rc.left = rc.right = x;
    rc.top = rc.bottom = y;

    rcOld = rc;

    UpdateWindow(plv->ci.hwnd);

    if (plv->exStyle & LVS_EX_REGIONAL)
    {
        if ((hrgnUpdate = CreateRectRgn(0,0,0,0)) &&
            (hrgnLV = CreateRectRgn(0,0,0,0)) &&
            (LockWindowUpdate(GetParent(hwnd))))
        {
            hdc = GetDCEx(hwnd, NULL, DCX_PARENTCLIP | DCX_LOCKWINDOWUPDATE);
            bLocked = TRUE;
        }
        else
        {
            goto BailOut;
        }
    }
    else
    {
        hdc = GetDC(hwnd);
    }

    SetCapture(hwnd);

    if (fAlphaMarquee)
    {
        plv->flags |= LVF_MARQUEE;
        plv->rcMarquee = rc;
        InvalidateRect(plv->ci.hwnd, &plv->rcMarquee, TRUE);
    }
    else
    {
        DrawFocusRect(hdc, &rc);
    }

    GetClientRect(hwnd, &rcClip);
    GetWindowRect(hwnd, &rcWindow);

    dwTime = GetTickCount();

    for (;;)
    {
        // WM_CANCELMODE messages will unset the capture, in that
        // case I want to exit this loop
        if (GetCapture() != hwnd)
        {
            break;
        }

        if (!PeekMessage32(&msg32, NULL, 0, 0, PM_REMOVE, TRUE)) 
        {
            // if the cursor is outside of the window rect
            // we need to generate messages to make autoscrolling
            // keep going

            if (!PtInRect(&rcWindow, msg32.pt) &&
                ShouldScroll(plv, &msg32.pt, &rcWindow))
            {
                SetCursorPos(msg32.pt.x, msg32.pt.y);
            }
            else
            {
                WaitMessage();
            }
            continue;
        }


        // See if the application wants to process the message...
        if (CallMsgFilter32(&msg32, MSGF_COMMCTRL_DRAGSELECT, TRUE) != 0)
            continue;

        switch (msg32.message)
        {

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_MBUTTONUP:
        case WM_RBUTTONDOWN:
            CCReleaseCapture(&plv->ci);
            goto EndOfLoop;


        case WM_TIMER:
            if (msg32.wParam != IDT_MARQUEE)
                goto DoDefault;
            // else fall through

        case WM_MOUSEMOVE:
        {
            int dMax = -1;
            pt = msg32.pt;
            ScreenToClient(hwnd, &pt);

            dwNewTime = GetTickCount();
//            if (1 || (dwNewTime - dwTime) > SCROLL_FREQ)
//          {
                dwTime = dwNewTime;     // reset scroll timer
                ScrollDetect(plv, pt, &dx, &dy);
//          }
//          else
//          {
//              dx = dy = 0;
//          }
            //SetTimer(plv->ci.hwnd, IDT_MARQUEE, SCROLL_FREQ, NULL);

            y -= dy;    // scroll up/down
            x -= dx;    // scroll left/right

            rc.left = x;
            rc.top = y;
            rc.right = pt.x;
            rc.bottom = pt.y;

            // clip drag rect to the window
            //
            if (rc.right > rcClip.right)
                rc.right = rcClip.right;
            if (rc.right < rcClip.left)
                rc.right = rcClip.left;
            if (rc.bottom > rcClip.bottom)
                rc.bottom = rcClip.bottom;
            if (rc.bottom < rcClip.top)
                rc.bottom = rcClip.top;

            OrderRect(&rc);

            if (EqualRect(&rc, &rcOld))
                break;

            // move the old rect
            if (!fAlphaMarquee)
            {
                DrawFocusRect(hdc, &rcOld); // erase old
            }

            if (dx || dy)
                ListView_OnScroll(plv, dx, dy);
            OffsetRect(&rcOld, -dx, -dy);

            //
            // For Report and List view, we can speed things up by
            // only searching through those items that are visible.  We
            // use the hittest to calculate the first item to paint.
            // REARCHITECT:: We are using state specific info here...
            //
            UnionRect(&rcUnion, &rc, &rcOld);

            if (ListView_IsReportView(plv) && !plv->fGroupView)
            {
                i = (int)((plv->ptlRptOrigin.y + rcUnion.top  - plv->yTop)
                        / plv->cyItem);
                iEnd = (int)((plv->ptlRptOrigin.y + rcUnion.bottom  - plv->yTop)
                        / plv->cyItem) + 1;
            }

            else if (ListView_IsListView(plv))
            {
                i = ((plv->xOrigin + rcUnion.left)/ plv->cxItem)
                        * plv->cItemCol + rcUnion.top / plv->cyItem;

                iEnd = ((plv->xOrigin + rcUnion.right)/ plv->cxItem)
                        * plv->cItemCol + rcUnion.bottom / plv->cyItem + 1;
            }

            else
            {
                if (ListView_IsOwnerData(plv))
                {
                    ListView_CalcMinMaxIndex(plv, &rcUnion, &i, &iEnd);
                }
                else
                {
                    i = 0;
                    iEnd = ListView_Count(plv);
                }
            }

            // make sure our endpoint is in range.
            if (iEnd > ListView_Count(plv))
                iEnd = ListView_Count(plv);

            if (i < 0)
                i = 0;

            if (ListView_IsOwnerData(plv) && (i < iEnd))
            {
                ListView_NotifyCacheHint(plv, i, iEnd-1);
            }

            if (bInNew && !(msg32.wParam & (MK_CONTROL | MK_SHIFT)))
            {
                plv->iMark = -1;
            }

            for (; i  < iEnd; i++)
            {
                RECT dummy;
                ListView_GetRects(plv, i, QUERY_DEFAULT, NULL, NULL, NULL, &rcTemp2);

                // don't do this infaltion if we're in report&full row mode
                // in that case, just touching is good enough
                if (!(ListView_IsReportView(plv) && ListView_FullRowSelect(plv))) 
                {
                    int cxInflate = (rcTemp2.right - rcTemp2.left) / 4;
                    if (ListView_IsListView(plv))
                    {
                        cxInflate = min(cxInflate, plv->cxSmIcon);
                    }
                    InflateRect(&rcTemp2, -cxInflate, -(rcTemp2.bottom - rcTemp2.top) / 4);
                }

                bInOld = (IntersectRect(&dummy, &rcOld, &rcTemp2) != 0);
                bInNew = (IntersectRect(&dummy, &rc, &rcTemp2) != 0);

                if (msg32.wParam & MK_CONTROL)
                {
                    if (bInOld != bInNew) 
                    {
                        ListView_ToggleSelection(plv, i);
                    }
                } 
                else
                {
                    // was there a change?
                    if (bInOld != bInNew)
                    {
                        ListView_OnSetItemState(plv, i, bInOld ? 0 : LVIS_SELECTED, LVIS_SELECTED);
                    }

                    // if no alternate keys are down.. set the mark to
                    // the item furthest from the cursor
                    if (bInNew && !(msg32.wParam & (MK_CONTROL | MK_SHIFT))) 
                    {
                        int dItem;
                        dItem = (rcTemp2.left - pt.x) * (rcTemp2.left - pt.x) +
                            (rcTemp2.top - pt.y) * (rcTemp2.top - pt.y);
                        // if it's further away, set this as the mark
                        //DebugMsg(TF_LISTVIEW, "dItem = %d, dMax = %d", dItem, dMax);
                        if (dItem > dMax) 
                        {
                            //DebugMsg(TF_LISTVIEW, "taking dItem .. iMark = %d", i);
                            dMax = dItem;
                            plv->iMark = i;
                        }
                    }
                }
            }

            if (fAlphaMarquee)
            {
                RECT rcInvalid;
                UnionRect(&rcInvalid, &rcOld, &rc);
                InflateRect(&rcInvalid, 1, 1);

                plv->flags |= LVF_MARQUEE;
                plv->rcMarquee = rc;

                InvalidateRect(plv->ci.hwnd, &rcInvalid, TRUE);
            }

            //DebugMsg(TF_LISTVIEW, "Final iMark = %d", plv->iMark);
            if (bLocked) 
            {
                if (GetUpdateRgn(plv->ci.hwnd, hrgnUpdate, FALSE) > NULLREGION)
                {
                    ValidateRect(plv->ci.hwnd, NULL);
                    GetWindowRgn(plv->ci.hwnd, hrgnLV);
                    CombineRgn(hrgnUpdate, hrgnUpdate, hrgnLV, RGN_AND);
                    SelectClipRgn(hdc, hrgnUpdate);
                    SendMessage(plv->ci.hwnd, WM_PRINTCLIENT, (WPARAM)hdc, 0);
                    SelectClipRgn(hdc, NULL);
                }
            } 
            else 
            {
                UpdateWindow(plv->ci.hwnd);    // make selection draw
            }


            if (!fAlphaMarquee)
            {
                DrawFocusRect(hdc, &rc);
            }
    
            rcOld = rc;
            break;
        }

        case WM_KEYDOWN:
            switch (msg32.wParam) 
            {
            case VK_ESCAPE:
                ListView_DeselectAll(plv, -1);
                goto EndOfLoop;
            }
        case WM_CHAR:
        case WM_KEYUP:
            // don't process thay keyboard stuff during marquee
            break;


        default:

            // don't process mouse wheel stuff
            if (msg32.message == g_msgMSWheel)
                break;

        DoDefault:
            TranslateMessage32(&msg32, TRUE);
            DispatchMessage32(&msg32, TRUE);
        }
    }

EndOfLoop:

    plv->flags &= ~LVF_MARQUEE;

    if (fAlphaMarquee)
    {
        InvalidateRect(plv->ci.hwnd, &rcOld, TRUE);
    }
    else
    {
        DrawFocusRect(hdc, &rcOld); // erase old
    }

    ReleaseDC(hwnd, hdc);

BailOut:
    if (hrgnUpdate)
        DeleteObject(hrgnUpdate);
    if (hrgnLV)
        DeleteObject(hrgnLV);
    if (bLocked)
        LockWindowUpdate(NULL);
}


#define SHIFT_DOWN(keyFlags)    (keyFlags & MK_SHIFT)
#define CONTROL_DOWN(keyFlags)  (keyFlags & MK_CONTROL)
#define RIGHTBUTTON(keyFlags)   (keyFlags & MK_RBUTTON)

void ListView_ButtonSelect(LV* plv, int iItem, UINT keyFlags, BOOL bSelected)
{
    if (SHIFT_DOWN(keyFlags))
    {
        ListView_SelectRangeTo(plv, iItem, !CONTROL_DOWN(keyFlags));
        ListView_SetFocusSel(plv, iItem, TRUE, FALSE, FALSE);
    }
    else if (!CONTROL_DOWN(keyFlags))
    {
        ListView_SetFocusSel(plv, iItem, TRUE, !bSelected, FALSE);
        if (!RIGHTBUTTON(keyFlags) && bSelected && ListView_IsSimpleSelect(plv))
        {
            ListView_HandleStateIconClick(plv, iItem);
        }
    }
}

void ListView_HandleStateIconClick(LV* plv, int iItem)
{
    int iState =
        ListView_OnGetItemState(plv, iItem, LVIS_STATEIMAGEMASK);

    iState = STATEIMAGEMASKTOINDEX(iState) -1;
    iState++;
    iState %= ImageList_GetImageCount(plv->himlState);
    iState++;
    ListView_OnSetItemState(plv, iItem, INDEXTOSTATEIMAGEMASK(iState), LVIS_STATEIMAGEMASK);
}

BOOL ListView_RBeginMarquee(LV* plv, int x, int y, LPLVHITTESTINFO plvhti)
{
    if (ListView_FullRowSelect(plv) &&
        ListView_IsReportView(plv) &&
        !(plv->ci.style & LVS_SINGLESEL) &&
        !ListView_OwnerDraw(plv) &&
        plvhti->iSubItem == 0) 
    {
        // can only begin marquee in column 0.
        if (plvhti->flags == LVHT_ONITEM)
        {
            return TRUE;
        }
    }

    return FALSE;
}

void ListView_HandleMouse(LV* plv, BOOL fDoubleClick, int x, int y, UINT keyFlags, BOOL bMouseWheel)
{
    LV_HITTESTINFO ht;
    NMITEMACTIVATE nm;
    int iItem, click, drag;
    BOOL bSelected, fHadFocus, fNotifyReturn = FALSE;
    BOOL fActive;
    HWND hwnd = plv->ci.hwnd;

    if (plv->fButtonDown)
        return;
    plv->fButtonDown = TRUE;


    if (plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickHappened && plv->fOneClickOK)
    {
        KillTimer(plv->ci.hwnd, IDT_ONECLICKHAPPENED);
        plv->fOneClickHappened = FALSE;
        CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &(plv->nmOneClickHappened.hdr));
        if (!IsWindow(hwnd))
            return;
    }

    fHadFocus = (GetFocus() == plv->ci.hwnd);
    click = RIGHTBUTTON(keyFlags) ? NM_RCLICK : NM_CLICK;
    drag  = RIGHTBUTTON(keyFlags) ? LVN_BEGINRDRAG : LVN_BEGINDRAG;

    fActive = ChildOfActiveWindow(plv->ci.hwnd) || fShouldFirstClickActivate() ||
              ChildOfDesktop(plv->ci.hwnd);

    TraceMsg(TF_LISTVIEW, "ListView_OnButtonDown %d", fDoubleClick);

    SetCapture(plv->ci.hwnd);

    plv->ptCapture.x = x;
    plv->ptCapture.y = y;

    if (!ListView_DismissEdit(plv, FALSE) && GetCapture() != plv->ci.hwnd)
        goto EndButtonDown;

    CCReleaseCapture(&plv->ci);

    // REVIEW: right button implies no shift or control stuff
    // Single selection style also implies no modifiers
    //if (RIGHTBUTTON(keyFlags) || (plv->ci.style & LVS_SINGLESEL))
    if ((plv->ci.style & LVS_SINGLESEL))
        keyFlags &= ~(MK_SHIFT | MK_CONTROL);

    ht.pt.x = x;
    ht.pt.y = y;
    iItem = ListView_OnSubItemHitTest(plv, &ht);
    if (ht.iSubItem != 0) 
    {
        // if we're not in full row select,
        // hitting on a subitem is like hitting on nowhere
        // also, in win95, ownerdraw fixed effectively had full row select
        if (!ListView_FullRowSelect(plv) &&
            !(plv->ci.style & LVS_OWNERDRAWFIXED)) 
        {
            iItem = -1;
            ht.flags = LVHT_NOWHERE;
        }
    }

    nm.iItem = iItem;
    nm.iSubItem = ht.iSubItem;
    nm.uChanged = 0;
    nm.ptAction.x = x;
    nm.ptAction.y = y;
    nm.uKeyFlags = GetLVKeyFlags();

    // FProt Profesional assumed that if the notification structure pointer + 14h bytes
    // had a value 2 that it was a displayinfo structure and they then used offset +2c as lparam...
    nm.uNewState = 0;

    plv->iNoHover = iItem;

    bSelected = (iItem >= 0) && ListView_OnGetItemState(plv, iItem, LVIS_SELECTED);

    if (fDoubleClick)
    {
        // Cancel any name editing that might happen.
        ListView_CancelPendingEdit(plv);
        KillTimer(plv->ci.hwnd, IDT_SCROLLWAIT);

        if (ht.flags & LVHT_NOWHERE) 
        {
            // this would have been done in the first click in win95 except
            // now we blow off the first click on focus change
            if (!SHIFT_DOWN(keyFlags) && !CONTROL_DOWN(keyFlags))
                ListView_DeselectAll(plv, -1);
        }

        click = RIGHTBUTTON(keyFlags) ? NM_RDBLCLK : NM_DBLCLK ;
        if (CCSendNotify(&plv->ci, click, &nm.hdr))
            goto EndButtonDown;

        /// some (comdlg32 for example) destroy on double click
        // we need to bail if that happens because plv is no longer valid
        if (!IsWindow(hwnd))
            return;

        if (click == NM_DBLCLK)
        {
            // these shift control flags are to mirror when we don't send out the activate on the single click,
            // but are in the oneclick activate mode  (see below)
            if (ht.flags & (LVHT_ONITEMLABEL | LVHT_ONITEMICON))
            {
                // possible scenarios below:
                // 1) we're using classic windows style so double click => launch
                // 2) we're using single click activate
                //    a) shift is down and item is selected => launch
                //       this implies that the first click selected it
                //    b) control is down => launch
                //       the first click toggled the selection so if the item was
                //       the only item selected and we double clicked on it
                //       the first click deselects it and no item is selected
                //       so nothing will be launched - this is win95 behavior
                if (!(plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickOK) ||
                    (plv->exStyle & LVS_EX_ONECLICKACTIVATE &&  plv->fOneClickOK &&
                     (SHIFT_DOWN(keyFlags) || CONTROL_DOWN(keyFlags))))
                {
                    CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &nm.hdr);
                }
            }
            // Double-click on checkbox state icon cycles it just like single click
            else if ((ht.flags & LVHT_ONITEMSTATEICON) && ListView_CheckBoxes(plv)) 
            {
                ListView_HandleStateIconClick(plv, iItem);
            }
        }

        if (!IsWindow(hwnd))
            return;
        goto EndButtonDown;
    }

    if (ht.flags & (LVHT_ONITEMLABEL | LVHT_ONITEMICON))
    {
        // if it wasn't selected, we're about to select it... play
        // a little ditty for us...
        CCPlaySound(c_szSelect);

        if (!RIGHTBUTTON(keyFlags) || (!CONTROL_DOWN(keyFlags) && !SHIFT_DOWN(keyFlags)))
            ListView_ButtonSelect(plv, iItem, keyFlags, bSelected);

        // handle full row select
        // If single-select listview, disable marquee selection.
        //
        // Careful - CheckForDragBegin yields and the app may have
        // destroyed the item we were thinking about dragging!
        //
        if (!bMouseWheel && CheckForDragBegin(plv->ci.hwnd, x, y))
        {
            // should we do a marquee?
            if (ListView_RBeginMarquee(plv, x, y, &ht) &&
                !CCSendNotify(&plv->ci, LVN_MARQUEEBEGIN, &nm.hdr))
            {
                ListView_DragSelect(plv, x, y);
                fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
            }
            else
            {
                // Before we start dragging, make it sure that it is
                // selected and has the focus.
                ListView_SetFocusSel(plv, iItem, TRUE, FALSE, FALSE);

                if (!SHIFT_DOWN(keyFlags))
                    plv->iMark = iItem;

                // Then, we need to update the window before start dragging
                // to show the selection chagne.
                UpdateWindow(plv->ci.hwnd);

                // Remember which item we're dragging, as it affects ListView_OnInsertMarkHitTest
                plv->iDrag = iItem;

                CCSendNotify(&plv->ci, drag, &nm.hdr);

                plv->iDrag = -1;

                goto EndButtonDown;
            }
        }

        // CheckForDragBegin yields, so revalidate before continuing
        else if (IsWindow(hwnd))
        {
            // button came up and we are not dragging

            if (!RIGHTBUTTON(keyFlags))
            {
                if (CONTROL_DOWN(keyFlags))
                {
                    // do this on the button up so that ctrl-dragging a range
                    // won't toggle the select.

                    if (SHIFT_DOWN(keyFlags))
                        ListView_SetFocusSel(plv, iItem, FALSE, FALSE, FALSE);
                    else
                    {
                        ListView_SetFocusSel(plv, iItem, TRUE, FALSE, TRUE);
                    }
                }
            }
            if (!SHIFT_DOWN(keyFlags))
                plv->iMark = iItem;

            if (!ListView_SetFocus(plv->ci.hwnd))    // activate this window
                return;

            // now do the deselect stuff
            if (!SHIFT_DOWN(keyFlags) && !CONTROL_DOWN(keyFlags) && !RIGHTBUTTON(keyFlags))
            {
                ListView_DeselectAll(plv, iItem);
                if ((ht.flags & LVHT_ONITEMLABEL) && bSelected &&
                    !(plv->exStyle & (LVS_EX_ONECLICKACTIVATE|LVS_EX_TWOCLICKACTIVATE)))
                {

                    // doing this check for ownerdrawfixed is for compatability.
                    // we don't want to go into edit mode if the user just happened to click
                    // to this window when a different one had focus,
                    // but ms hammer relied upon the notification being sent (and we
                    // don't go into edit mode anyways for ownerdraw)
                    if (fHadFocus ||
                        (plv->ci.style & LVS_OWNERDRAWFIXED))
                    {
                        // Click on item label.  It was selected and
                        // no modifier keys were pressed and no drag operation
                        // So setup for name edit mode.  Still need to wait
                        // to make sure user is not doing double click.
                        //
                        ListView_SetupPendingNameEdit(plv);
                    }
                }
            }

            fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
            if (!IsWindow(hwnd))
                return;

            if (plv->exStyle & (LVS_EX_ONECLICKACTIVATE|LVS_EX_TWOCLICKACTIVATE))
            {
                if (!RIGHTBUTTON(keyFlags))
                {
                    // We don't ItemActivate within one double-click time of creating
                    // this listview. This is a common occurence for people used to
                    // double-clicking. The first click pops up a new window which
                    // receives the second click and ItemActivates the item...
                    //
                    if ((plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickOK) || bSelected)
                    {
                        if (fActive)
                        {
                            // condition: if we're in a single click activate mode
                            // don't launch if control or shift keys are pressed
                            BOOL bCond = plv->exStyle & LVS_EX_ONECLICKACTIVATE && !CONTROL_DOWN(keyFlags) && !SHIFT_DOWN(keyFlags);

                            if ((bSelected && plv->exStyle & LVS_EX_TWOCLICKACTIVATE) ||
                                (bCond && !g_bUseDblClickTimer))
                            {
                                CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &nm.hdr);
                                if (!IsWindow(hwnd))
                                    return;
                            }
                            else if (bCond && g_bUseDblClickTimer)
                            {
                                plv->fOneClickHappened = TRUE;
                                plv->nmOneClickHappened = nm;
                                SetTimer(plv->ci.hwnd, IDT_ONECLICKHAPPENED, GetDoubleClickTime(), NULL);
                            }
                        }
                    }
                }
            }
        }
        else
        {
            // IsWindow() failed.  Bail.
            return;
        }
    }
    else if (ht.flags & LVHT_ONITEMSTATEICON)
    {
        // Should activate window and send notificiation to parent...
        if (!ListView_SetFocus(plv->ci.hwnd))   // activate this window
            return;
        fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
        if (fNotifyReturn && ListView_CheckBoxes(plv))
        {
            ListView_HandleStateIconClick(plv, iItem);
        }
    }
    else if (ht.flags & LVHT_NOWHERE)
    {
        if (!ListView_SetFocus(plv->ci.hwnd))   // activate this window
            return;

        // If single-select listview, disable marquee selection.
        if (!(plv->ci.style & LVS_SINGLESEL) && CheckForDragBegin(plv->ci.hwnd, x, y) &&
            !CCSendNotify(&plv->ci, LVN_MARQUEEBEGIN, &nm.hdr))
        {
            if (!SHIFT_DOWN(keyFlags) && !CONTROL_DOWN(keyFlags))
                ListView_DeselectAll(plv, -1);
            ListView_DragSelect(plv, x, y);
            fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
        }
        else if (IsWindow(hwnd))
        {
            // if we didn't have focus and aren't showing selection always,
            // make the first click just set focus
            BOOL fDoFirstClickSelection = (fHadFocus || plv->ci.style & LVS_SHOWSELALWAYS ||
                                           CONTROL_DOWN(keyFlags) || SHIFT_DOWN(keyFlags) ||
                                           RIGHTBUTTON(keyFlags));

            if (fDoFirstClickSelection && fActive)
            {

                if (!SHIFT_DOWN(keyFlags) && !CONTROL_DOWN(keyFlags))
                    ListView_DeselectAll(plv, -1);

                fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
            }
        }
        else
        {
            // IsWindow() failed.  Bail.
            return;
        }
    }

    // re-check the key state so we don't get confused by multiple clicks

    // this needs to check the GetKeyState stuff only when we've gone into
    // a modal loop waiting for the rbutton up.
    if (fNotifyReturn && (click == NM_RCLICK)) // && (GetKeyState(VK_RBUTTON)>=0))
    {
        POINT pt = { x, y };
        ClientToScreen(plv->ci.hwnd, &pt);
        FORWARD_WM_CONTEXTMENU(plv->ci.hwnd, plv->ci.hwnd, pt.x, pt.y, SendMessage);
    }

EndButtonDown:
    if (IsWindow(hwnd))
        plv->fButtonDown = FALSE;
}

void ListView_OnButtonDown(LV* plv, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    ListView_HandleMouse(plv, fDoubleClick, x, y, keyFlags, FALSE);
}

BOOL ListView_CancelPendingTimer(LV* plv, UINT fFlags, int idTimer)
{
    if (plv->flags & fFlags)
    {
        KillTimer(plv->ci.hwnd, idTimer);
        plv->flags &= ~fFlags;
        return TRUE;
    }
    return FALSE;
}

//
// ListView_OnTimer:
//     process the WM_TIMER message.  If the timer id is thta
//     of the name editing, we should then start the name editing mode.
//
void ListView_OnTimer(LV* plv, UINT id)
{
    KillTimer(plv->ci.hwnd, id);

    if (id == IDT_NAMEEDIT)
    {
        // Kill the timer as we wont need any more messages from it.

        if (ListView_CancelPendingEdit(plv)) 
        {
            // And start name editing mode.
            if (!ListView_OnEditLabel(plv, plv->iFocus, NULL))
            {
                ListView_DismissEdit(plv, FALSE);
                ListView_SetFocusSel(plv, plv->iFocus, TRUE, TRUE, FALSE);
            }
        }
    } 
    else if (id == IDT_SCROLLWAIT) 
    {
        if (ListView_CancelScrollWait(plv)) 
        {
            ListView_OnEnsureVisible(plv, plv->iFocus, TRUE);
        }
    } 
    else if (id == IDT_ONECLICKOK) 
    {
        plv->fOneClickOK = TRUE;
    } 
    else if (id == IDT_ONECLICKHAPPENED) 
    {
        //if (!g_bUseDblClickTimer)
        //{
        ////    EnableWindow(plv->ci.hwnd, TRUE);
        //    SetWindowBits(plv->ci.hwnd, GWL_STYLE, WS_DISABLED, 0);
        //    plv->fOneClickHappened = FALSE;
        //}
        // check the bit just in case they double-clicked
        //else
        if (plv->fOneClickHappened)
        {
            plv->fOneClickHappened = FALSE;
            CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &(plv->nmOneClickHappened.hdr));
        }
    }
    else if (id == IDT_TRACKINGTIP)
    {
        // Display keyboard nav tracking tooltip popups

        if (ListView_IsKbdTipTracking(plv))  // Item requires tracking popup
        {
            // Ensure index is still valid
            if (ListView_IsValidItemNumber(plv, plv->iTracking))
            {
                TOOLINFO ti = {0};

                ti.cbSize = sizeof(TOOLINFO);
                ti.hwnd = plv->ci.hwnd;

                // Cancel previous
                SendMessage(plv->hwndToolTips, TTM_TRACKACTIVATE, FALSE, (LPARAM)&ti);

                // Switch ListView's tooltip window to "tracking" (manual) mode
                SendMessage(plv->hwndToolTips, TTM_GETTOOLINFO, 0, (LPARAM)&ti);
                ti.uFlags |= TTF_TRACK;
                SendMessage(plv->hwndToolTips, TTM_SETTOOLINFO, 0, (LPARAM)&ti);

                // Activate and establish size
                SendMessage(plv->hwndToolTips, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti);
            }
            else
            {
                // Index was invalid (ListView set of items changed), tip track cancel, no popup
                plv->iTracking = LVKTT_NOTRACK;
            }
        }
    }
}

//
// ListView_SetupPendingNameEdit:
//      Sets up a timer to begin name editing at a delayed time.  This
//      will allow the user to double click on the already selected item
//      without going into name editing mode, which is especially important
//      in those views that only show a small icon.
//
void ListView_SetupPendingNameEdit(LV* plv)
{
    SetTimer(plv->ci.hwnd, IDT_NAMEEDIT, GetDoubleClickTime(), NULL);
    plv->flags |= LVF_NMEDITPEND;
}

void ListView_OnHVScroll(LV* plv, UINT code, int pos, int sb)
{
    int iScrollCount = 0;

    SCROLLINFO si;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_TRACKPOS;

    // if we're in 32bits, don't trust the pos since it's only 16bit's worth
    if (ListView_GetScrollInfo(plv, sb, &si))
        pos = (int)si.nTrackPos;

    ListView_DismissEdit(plv, FALSE);

    _ListView_OnScroll(plv, code, pos, sb);

    switch (code)
    {
    case SB_PAGELEFT:
    case SB_PAGERIGHT:
        if (plv->iScrollCount < SMOOTHSCROLLLIMIT)
            plv->iScrollCount += 3;
        break;

    case SB_LINELEFT:
    case SB_LINERIGHT:
        if (plv->iScrollCount < SMOOTHSCROLLLIMIT)
            plv->iScrollCount++;
        break;

    case SB_ENDSCROLL:
        plv->iScrollCount = 0;
        break;

    }
}

void ListView_OnVScroll(LV* plv, HWND hwndCtl, UINT code, int pos)
{
    ListView_OnHVScroll(plv, code, pos, SB_VERT);
}

void ListView_OnHScroll(LV* plv, HWND hwndCtl, UINT code, int pos)
{
    ListView_OnHVScroll(plv, code, pos, SB_HORZ);
}

int ListView_ValidateOneScrollParam(LV* plv, int iDirection, int dx)
{
    SCROLLINFO si;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;

    if (!ListView_GetScrollInfo(plv, iDirection, &si))
        return 0;

    if (si.nPage)
        si.nMax -= (si.nPage - 1);
    si.nPos += dx;
    if (si.nPos < si.nMin) 
    {
        dx += (int)(si.nMin - si.nPos);
    } 
    else if (si.nPos > si.nMax) 
    {
        dx -= (int)(si.nPos - si.nMax);
    }

    return dx;
}

BOOL ListView_ValidateScrollParams(LV* plv, int * pdx, int *pdy)
{
    int dx = *pdx;
    int dy = *pdy;

    if (plv->ci.style & LVS_NOSCROLL)
        return FALSE;

    if (ListView_IsListView(plv))
    {
        ListView_MaybeResizeListColumns(plv, 0, ListView_Count(plv)-1);
#ifdef COLUMN_VIEW
        if (dx < 0)
            dx = (dx - (plv->cxItem - 1)) / plv->cxItem;
        else
            dx = (dx + (plv->cxItem - 1)) / plv->cxItem;

        if (dy)
            return FALSE;
#else
        if (dy < 0)
            dy = (dy - (plv->cyItem - 1)) / plv->cyItem;
        else
            dy = (dy + (plv->cyItem - 1)) / plv->cyItem;

        if (dx)
            return FALSE;
#endif
    }
    else if (ListView_IsReportView(plv))
    {
        //
        // Note: This function expects that dy is in number of lines
        // and we are working with pixels so do a conversion use some
        // rounding up and down to make it right
        if (dy > 0)
            dy = (dy + plv->cyItem/2) / plv->cyItem;
        else
            dy = (dy - plv->cyItem/2) / plv->cyItem;
    }

    if (dy)
    {
        dy = ListView_ValidateOneScrollParam(plv, SB_VERT, dy);
        if (ListView_IsReportView(plv)
#ifndef COLUMN_VIEW
            || ListView_IsListView(plv)
#endif
           )
        {
           // convert back to pixels
           dy *= plv->cyItem;
        }
        *pdy = dy;
    }

    if (dx)
    {
        dx = ListView_ValidateOneScrollParam(plv, SB_HORZ, dx);
#ifdef COLUMN_VIEW
        if (ListView_IsListView(plv))
        {
            dx *= plv->cxItem;
        }
#endif
        *pdx = dx;
    }

    return TRUE;
}

BOOL ListView_SendScrollNotify(LV* plv, BOOL fBegin, int dx, int dy)
{
    NMLVSCROLL nm;

    nm.dx = dx;
    nm.dy = dy;

    return !CCSendNotify(&plv->ci, fBegin ? LVN_BEGINSCROLL : LVN_ENDSCROLL, &nm.hdr);
}


BOOL ListView_OnScrollSelectSmooth(LV* plv, int dx, int dy, UINT uSmooth)
{
    if (plv->ci.style & LVS_NOSCROLL)
        return FALSE;

#ifdef DEBUG
    // If we try and scroll an illegal amount then ListView_IScroll2_SmoothScroll
    // will offset ptOrigin incorrectly (it doesn't check min/max range) which then
    // mucks up hit testing and insert marks
    if (ListView_IsIScrollView(plv))
    {
        int dxTmp = dx;
        int dyTmp = dy;

        ASSERT(ListView_ValidateScrollParams(plv, &dxTmp, &dyTmp) &&
               dxTmp == dx && dyTmp == dy);
    }
#endif

    if (ListView_IsListView(plv))
    {
        // Scale pixel count to column count
        //
#ifdef COLUMN_VIEW
        if (dx < 0)
            dx -= plv->cxItem - 1;
        else
            dx += plv->cxItem - 1;

        dx = dx / plv->cxItem;

        if (dy)
            return FALSE;
#else
        if (dy < 0)
            dy -= plv->cyItem - 1;
        else
            dy += plv->cyItem - 1;

        dy = dy / plv->cyItem;

        if (dx)
            return FALSE;
#endif
    }
    else if (ListView_IsReportView(plv) && !plv->fGroupView)
    {
        //
        // Note: This function expects that dy is in number of lines
        // and we are working with pixels so do a conversion use some
        // rounding up and down to make it right
        if (dy > 0)
            dy = (dy + plv->cyItem/2) / plv->cyItem;
        else
            dy = (dy - plv->cyItem/2) / plv->cyItem;
    }
    
    ListView_SendScrollNotify(plv, TRUE, dx, dy);
    _ListView_Scroll2(plv, dx, dy, uSmooth);
    ListView_SendScrollNotify(plv, FALSE, dx, dy);
    ListView_UpdateScrollBars(plv);
    return TRUE;
}

BOOL ListView_OnScroll(LV* plv, int dx, int dy)
{
    return ListView_OnScrollSelectSmooth(plv, dx, dy, 0);
}

#ifdef DEBUG
BOOL ListView_ValidatercView(LV* plv, RECT* prcView, BOOL fRecalcDone)
{
    BOOL fRet = prcView->left != RECOMPUTE ? TRUE : !fRecalcDone;

    // hitting this assert is only valuable if there's a manual repro, which never happens in stress
#ifdef FULL_DEBUG 
    if (!ListView_IsOwnerData(plv) && ListView_IsIScrollView(plv) && !(plv->fGroupView && plv->hdpaGroups) && ListView_RedrawEnabled(plv))
    {
        RECT rcViewTmp;
        fRet = ListView_ICalcViewRect(plv, TRUE, &rcViewTmp);
        if (fRet)
        {
            ASSERT(prcView->left != RECOMPUTE);
            fRet = IsEqualRect(rcViewTmp, *prcView);
        }
        else
        {
            fRet = !fRecalcDone;
        }
    }
#endif
    
    return fRet;
}

BOOL ListView_ValidateScrollPositions(LV* plv, RECT* prcClient)
{
    BOOL fRet = TRUE;

    // hitting this assert is only valuable if there's a manual repro, which never happens in stress
#ifdef FULL_DEBUG 
    // if we're in ListView_FixIScrollPositions, then it will fix up the scroll positions when we unwind
    if (ListView_IsIScrollView(plv) && (!plv->fInFixIScrollPositions) && ListView_RedrawEnabled(plv))
    {
        if (!(plv->ci.style & LVS_NOSCROLL))
        {
            // if we don't have a client rect there's no way to validate anything, assume everything will be recomputed later
            RECT rcClient;
            if (!prcClient)
            {
                if (plv->rcView.left != RECOMPUTE)
                {
                    ListView_GetStyleAndClientRectGivenViewRect(plv, &plv->rcView, &rcClient);
                    prcClient = &rcClient;
                }
            }

            if (prcClient)
            {        
                if (fRet)
                {
                    if (RECTWIDTH(*prcClient) < RECTWIDTH(plv->rcView))
                    {
                        fRet = (plv->rcView.left <= plv->ptOrigin.x) && (plv->ptOrigin.x+RECTWIDTH(*prcClient) <= plv->rcView.right);
                    }
                    else
                    {
                        fRet = (plv->ptOrigin.x <= plv->rcView.left) && (plv->rcView.right <= plv->ptOrigin.x+RECTWIDTH(*prcClient));
                    }
                }

                if (fRet)
                {
                    if (RECTHEIGHT(*prcClient) < RECTHEIGHT(plv->rcView))
                    {
                        fRet = (plv->rcView.top <= plv->ptOrigin.y) && (plv->ptOrigin.y+RECTHEIGHT(*prcClient) <= plv->rcView.bottom);
                    }
                    else
                    {
                        fRet = (plv->ptOrigin.y <= plv->rcView.top) && (plv->rcView.bottom <= plv->ptOrigin.y+RECTHEIGHT(*prcClient));
                    }
                }
            }
        }
        else
        {
            fRet = (plv->ptOrigin.x == 0) && (plv->ptOrigin.y == 0);
        }
    }
#endif

    return fRet;
}
#endif

BOOL ListView_OnEnsureVisible(LV* plv, int i, BOOL fPartialOK)
{
    RECT rcBounds;
    RECT rc;
    RECT rcClient;
    int dx, dy;
    
    if (!ListView_IsValidItemNumber(plv, i) || plv->ci.style & LVS_NOSCROLL)
        return FALSE;
    
    // we need to do this again inside because some callers don't do it.
    // other callers that do this need to do it outside so that
    // they can know not to call us if there's not wait pending
    ListView_CancelScrollWait(plv);
    
    if (ListView_IsReportView(plv))
        return ListView_ROnEnsureVisible(plv, i, fPartialOK);

    ListView_GetRects(plv, i, QUERY_DEFAULT, &rc, NULL, &rcBounds, NULL);
    
    if (plv->fGroupView)
    {
        LISTITEM* pitem = ListView_GetItemPtr(plv, i);
        if (pitem)
        {
            LISTGROUP* pgrp = ListView_FindFirstVisibleGroup(plv);
            if (pitem->pGroup == pgrp && pgrp)
            {
                rcBounds.top -= LISTGROUP_HEIGHT(plv, pgrp);
            }
        }
    }
    
    if (!fPartialOK)
        rc = rcBounds;

    // Scrolling is done relative to this calculated rect, not the size of hwndListview (plv->sizeClient)
    ListView_GetClientRect(plv, &rcClient, TRUE, NULL);
    ASSERT(ListView_ValidateScrollPositions(plv, &rcClient));

    // If any part of rc is outside of rcClient, then
    // scroll so that all of rcBounds is visible.
    //
    dx = 0;
    if (rc.left < 0 || (rc.right >= rcClient.right && rcClient.right != 0))
    {
        dx = rcBounds.left - 0;
        if (dx >= 0)
        {
            dx = rcBounds.right - rcClient.right;
            if (dx <= 0)
                dx = 0;
            else if ((rcBounds.left - dx) < 0)
                dx = rcBounds.left - 0; // Not all fits...
        }
    }
    dy = 0;
    if (rc.top < 0 || (rc.bottom >= rcClient.bottom && rcClient.bottom != 0))
    {
        dy = rcBounds.top - 0;
        if (dy >= 0)
        {
            dy = rcBounds.bottom - rcClient.bottom;
            if (dy < 0)
                dy = 0;
        }
    }
    
    // if rcClient is 0 or 1 pixel in size, it is impossible to scroll it
    if (dx | dy)
        ListView_ValidateScrollParams(plv, &dx, &dy);

    if (dx | dy)
        return ListView_OnScrollSelectSmooth(plv, dx, dy, SSW_EX_IMMEDIATE);
    
    return TRUE;
}

void ListView_UpdateScrollBars(LV* plv)
{
    RECT rc;
    DWORD dwStyle;

    if ((plv->ci.style & LVS_NOSCROLL) ||
        (!(ListView_RedrawEnabled(plv))))
        return;

    _ListView_UpdateScrollBars(plv);

    GetClientRect(plv->ci.hwnd, &rc);
    plv->sizeClient.cx = rc.right;
    plv->sizeClient.cy = rc.bottom;

    dwStyle = ListView_GetWindowStyle(plv);
    plv->ci.style = (plv->ci.style & ~(WS_HSCROLL | WS_VSCROLL)) | (dwStyle & WS_HSCROLL | WS_VSCROLL);
}

#ifndef WINNT
#pragma optimize ("gle", off)
// Crappy hack for Sage, which passes unitialized memory to SetWindowPlacement.
// They used to get lucky and get zeros for the max position, but now they end
// up with non-zero stack trash that causes bad things to happen when sage is
// maximized.  Thus, zero a bunch of stack to save their tail...
void ZeroSomeStackForSage()
{
    BYTE aByte[1024];

    memset(aByte, 0, sizeof(aByte));

    aByte;
}
#pragma optimize ("", on)
#endif

void ListView_OnSetFont(LV* plv, HFONT hfont, BOOL fRedraw)
{
    HDC hdc;
    SIZE siz;
    LOGFONT lf;
    HFONT hfontPrev;
    TEXTMETRIC tm;

    if ((plv->flags & LVF_FONTCREATED) && plv->hfontLabel) 
    {
        DeleteObject(plv->hfontLabel);
        plv->flags &= ~LVF_FONTCREATED;
    }

    if (hfont == NULL) 
    {
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
        hfont = CreateFontIndirect(&lf);
        plv->flags |= LVF_FONTCREATED;
    }

    hdc = GetDC(HWND_DESKTOP);
    if (hdc)
    {
        hfontPrev = SelectFont(hdc, hfont);

        GetTextMetrics(hdc, &tm);
 
        plv->cyLabelChar = tm.tmHeight;
        plv->cxLabelChar = tm.tmAveCharWidth; // Maybe this should tm.tmMaxCharWidth

        GetTextExtentPoint(hdc, c_szEllipses, CCHELLIPSES, &siz);
        plv->cxEllipses = siz.cx;

        SelectFont(hdc, hfontPrev);
        ReleaseDC(HWND_DESKTOP, hdc);
    }

    plv->hfontLabel = hfont;

    if (plv->hfontLabel)
    {
        LOGFONT lf;
        if (GetObject(plv->hfontLabel, sizeof(LOGFONT), &lf))
        {
            if (plv->hfontGroup)
                DeleteObject(plv->hfontGroup);

            CCAdjustForBold(&lf);

            plv->hfontGroup = CreateFontIndirect(&lf);
        }
    }

    plv->ci.uiCodePage = GetCodePageForFont(hfont);

    ListView_InvalidateCachedLabelSizes(plv);

    /* Ensure that our tooltip control uses the same font as the list view is using, therefore
    /  avoiding any nasty formatting problems. */

    if (plv->hwndToolTips)
    {
        FORWARD_WM_SETFONT(plv->hwndToolTips, plv->hfontLabel, FALSE, SendMessage);
    }

    // If we have a header window, we need to forward this to it also
    // as we have destroyed the hfont that they are using...
    if (plv->hwndHdr)
    {
        FORWARD_WM_SETFONT(plv->hwndHdr, plv->hfontLabel, FALSE, SendMessage);
        ListView_UpdateScrollBars(plv);
    }

    if (plv->hFontHot)
    {
        DeleteObject(plv->hFontHot);
        plv->hFontHot = NULL;
    }

    CCGetHotFont(plv->hfontLabel, &plv->hFontHot);
    plv->iFreeSlot = -1;

    if (fRedraw)
        RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
#ifndef WINNT
    ZeroSomeStackForSage();
#endif
}

HFONT ListView_OnGetFont(LV* plv)
{
    return plv->hfontLabel;
}

// This function process the WM_SETREDRAW message by setting or clearing
// a bit in the listview structure, which several places in the code will
// check...
//
// REVIEW: Should probably forward to DefWindowProc()
//
void ListView_OnSetRedraw(LV* plv, BOOL fRedraw)
{
    if (fRedraw)
    {
        BOOL fChanges = FALSE;
        // Only do work if we're turning redraw back on...
        //
        if (!(plv->flags & LVF_REDRAW))
        {
            plv->flags |= LVF_REDRAW;

            // deal with any accumulated invalid regions
            if (plv->hrgnInval)
            {
                UINT fRedraw = (plv->flags & LVF_ERASE) ? RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW : RDW_UPDATENOW|RDW_INVALIDATE;
                if (plv->hrgnInval == (HRGN)ENTIRE_REGION)
                    plv->hrgnInval = NULL;

                RedrawWindow(plv->ci.hwnd, NULL, plv->hrgnInval, fRedraw);
                ListView_DeleteHrgnInval(plv);
                fChanges = TRUE;
            }
            plv->flags &= ~LVF_ERASE;


            // Turning redraw on recomputes listview.
            if (plv->fGroupView)
            {
                _ListView_RecomputeEx(plv, NULL, 0, TRUE);
            }

            if (plv->fGroupView || ListView_IsDoubleBuffer(plv))
                InvalidateRect(plv->ci.hwnd, NULL, TRUE);


            // now deal with the optimized stuff
            if (ListView_IsListView(plv) || 
                ListView_IsReportView(plv))
            {
                if (plv->iFirstChangedNoRedraw != -1)
                {
                    // We may try to resize the column
                    if (!ListView_MaybeResizeListColumns(plv, plv->iFirstChangedNoRedraw,
                            ListView_Count(plv)-1))
                        ListView_OnUpdate(plv, plv->iFirstChangedNoRedraw);
                }
                else
                    ListView_UpdateScrollBars(plv);
            } 
            else 
            {
                int iCount;

                if (plv->iFirstChangedNoRedraw != -1) 
                {
                    for (iCount = ListView_Count(plv) ; plv->iFirstChangedNoRedraw < iCount; plv->iFirstChangedNoRedraw++) 
                    {
                        ListView_InvalidateItem(plv, plv->iFirstChangedNoRedraw, FALSE, RDW_INVALIDATE);
                    }
                    
                    fChanges = TRUE;
                }

                if (fChanges)
                {
                    ListView_RecalcRegion(plv, TRUE, TRUE);
                }

                if (((plv->ci.style & LVS_AUTOARRANGE) ||(plv->exStyle & LVS_EX_SNAPTOGRID)) && fChanges) 
                {
                    ListView_OnUpdate(plv, plv->iFirstChangedNoRedraw);
                } 
                else 
                {
                    ListView_UpdateScrollBars(plv);
                }
            }
        }
    }
    else
    {
        plv->iFirstChangedNoRedraw = -1;
        plv->flags &= ~LVF_REDRAW;
    }
}

HIMAGELIST ListView_OnGetImageList(LV* plv, int iImageList)
{
    switch (iImageList)
    {
        case LVSIL_NORMAL:
            return plv->himl;

        case LVSIL_SMALL:
            return plv->himlSmall;

        case LVSIL_STATE:
            return plv->himlState;
    }
    RIPMSG(0, "ListView_GetImageList: Invalid Imagelist asked for");
    return NULL;
}

HIMAGELIST ListView_OnSetImageList(LV* plv, HIMAGELIST himl, int iImageList)
{
    HIMAGELIST hImageOld = NULL;
    BOOL fImageSizeChanged = FALSE; //Assume the size hasn't changed!
    
    switch (iImageList)
    {
        case LVSIL_NORMAL:
            hImageOld = plv->himl;
            plv->himl = himl;
            if (himl) 
            {
                int cxIconNew, cyIconNew;
                //Get the Icon sizes from the new image list.
                if (CCGetIconSize(&plv->ci, himl, &cxIconNew , &cyIconNew))
                {
                    //Check to see if the sizes have changed!
                    if((cxIconNew != plv->cxIcon) || (cyIconNew != plv->cyIcon))
                    {
                        fImageSizeChanged = TRUE;
                        plv->cxIcon = cxIconNew;
                        plv->cyIcon = cyIconNew;
                    }
                }
            
                if (fImageSizeChanged && (!(plv->flags & LVF_ICONSPACESET))) 
                {
                    ListView_OnSetIconSpacing(plv, (LPARAM)-1);
                }
            }
            break;

        case LVSIL_SMALL:
            hImageOld = plv->himlSmall;
            plv->himlSmall = himl;
            if (himl)
            {
                int cxSmIconNew, cySmIconNew;
                //Get the small icon sizes from the new image list.
                if(CCGetIconSize(&plv->ci, himl, &cxSmIconNew , &cySmIconNew))
                {
                    //Check to see if the sizes have changed!
                    if((cxSmIconNew != plv->cxSmIcon) || (cySmIconNew != plv->cySmIcon))
                    {
                        fImageSizeChanged = TRUE;
                        plv->cxSmIcon = cxSmIconNew;
                        plv->cySmIcon = cySmIconNew;
                    }
                }
            }

            if (fImageSizeChanged)
            {
                plv->cxItem = ListView_ComputeCXItemSize(plv);

                // After changing the imagelist, try to resize the columns, because we can't
                // guess what the new size is going to be. Discovered by Thumbview 
                ListView_MaybeResizeListColumns(plv, 0, ListView_Count(plv)-1);
                plv->cyItem = ListView_ComputeCYItemSize(plv);
            }

            if (plv->hwndHdr)
                SendMessage(plv->hwndHdr, HDM_SETIMAGELIST, 0, (LPARAM)himl);
            break;

        case LVSIL_STATE:
            fImageSizeChanged = TRUE;
            if (himl) 
            {
                CCGetIconSize(&plv->ci, himl, &plv->cxState , &plv->cyState);
            }
            else 
            {
                plv->cxState = 0;
            }
            hImageOld = plv->himlState;
            plv->himlState = himl;
            plv->cyItem = ListView_ComputeCYItemSize(plv);
            break;

        default:
            fImageSizeChanged = TRUE;
            TraceMsg(TF_LISTVIEW, "sh TR - LVM_SETIMAGELIST: unrecognized iImageList");
            break;
    }

    if (himl && !(plv->ci.style & LVS_SHAREIMAGELISTS))
        ImageList_SetBkColor(himl, plv->clrBk);

    // Imagelist size changed... if we're in tileview, we need to recalculate the tilesize.
    if (ListView_IsTileView(plv) && (iImageList == LVSIL_STATE || iImageList == LVSIL_NORMAL))
    {
        ListView_RecalcTileSize(plv);
    }

    if(fImageSizeChanged)
    {
        // Now, recompute!
        plv->rcView.left = RECOMPUTE; // invalidate this up front to avoid the asserts - it'll get recalculated anyway
        _ListView_RecomputeEx(plv, NULL, 0, TRUE);
    }

    if (ListView_Count(plv) > 0)
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);

    return hImageOld;
}

#ifdef UNICODE
BOOL ListView_OnGetItemA(LV* plv, LV_ITEMA *plvi) 
{
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that LV_ITEMA is exactly the same
    // as LV_ITEMW except for the pointer to the string.
    COMPILETIME_ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW))

    if (!plvi)
        return FALSE;

    if ((plvi->mask & LVIF_TEXT) && (plvi->pszText != NULL)) 
    {
        pszC = plvi->pszText;
        pszW = LocalAlloc(LMEM_FIXED, plvi->cchTextMax * sizeof(WCHAR));
        if (pszW == NULL)
            return FALSE;
        plvi->pszText = (LPSTR)pszW;
    }

    fRet = ListView_OnGetItem(plv, (LV_ITEM *) plvi);

    if (pszW)
    {
        if (plvi->pszText != LPSTR_TEXTCALLBACKA)
        {
            if (fRet && plvi->cchTextMax)
                ConvertWToAN(plv->ci.uiCodePage, pszC, plvi->cchTextMax, (LPWSTR)plvi->pszText, -1);
            plvi->pszText = pszC;
        }

        LocalFree(pszW);
    }

    return fRet;

}
#endif

BOOL ListView_OnGetItem(LV* plv, LV_ITEM* plvi)
{
    UINT mask;
    LISTITEM* pitem = NULL;
    LV_DISPINFO nm;

    if (!plvi)
    {
        RIPMSG(0, "LVM_GET(ITEM|ITEMTEXT): Invalid pitem = NULL");
        return FALSE;
    }

    if (!ListView_IsValidItemNumber(plv, plvi->iItem))
    {
#ifdef DEBUG
        // owner data views (e.g. docfind) may change the number of items in listview
        // while we are doing something, thus hitting this rip
        if (!ListView_IsOwnerData(plv))
            RIPMSG(0, "LVM_GET(ITEM|ITEMTEXT|ITEMSTATE): item=%d does not exist", plvi->iItem);
#endif
        return FALSE;
    }

    nm.item.mask = 0;
    mask = plvi->mask;

    if (!ListView_IsOwnerData(plv))
    {
        // Standard listviews
        pitem = ListView_FastGetItemPtr(plv, plvi->iItem);
        ASSERT(pitem);

        // Handle sub-item cases for report view
        //
        if (plvi->iSubItem != 0)
        {
            LISTSUBITEM lsi;

            ListView_GetSubItem(plv, plvi->iItem, plvi->iSubItem, &lsi);
            if (mask & LVIF_TEXT)
            {
                if (lsi.pszText != LPSTR_TEXTCALLBACK)
                {
                    Str_GetPtr0(lsi.pszText, plvi->pszText, plvi->cchTextMax);
                } 
                else 
                {
                    // if this is LVIF_NORECOMPUTE we will update pszText later
                    nm.item.mask |= LVIF_TEXT;
                }
            }

            if ((mask & LVIF_IMAGE) && (plv->exStyle & LVS_EX_SUBITEMIMAGES))
            {
                plvi->iImage = lsi.iImage;
                if (lsi.iImage == I_IMAGECALLBACK)
                    nm.item.mask |= LVIF_IMAGE;
            }

            if (mask & LVIF_STATE) 
            {

                if (ListView_FullRowSelect(plv)) 
                {
                    // if we're in full row select,
                    // the state bit for select and focus follows column 0.
                    lsi.state |= pitem->state & (LVIS_SELECTED | LVIS_FOCUSED | LVIS_DROPHILITED);
                }

                plvi->state = lsi.state & plvi->stateMask;


                if (plv->stateCallbackMask)
                {
                    nm.item.stateMask = (plvi->stateMask & plv->stateCallbackMask);
                    if (nm.item.stateMask)
                    {
                        nm.item.mask |= LVIF_STATE;
                        nm.item.state = 0;
                    }
                }
            }
        } 
        else 
        {
            if (mask & LVIF_TEXT)
            {
                if (pitem->pszText != LPSTR_TEXTCALLBACK)
                {
                    Str_GetPtr0(pitem->pszText, plvi->pszText, plvi->cchTextMax);
                } 
                else 
                {
                    // if this is LVIF_NORECOMPUTE we will update pszText later
                    nm.item.mask |= LVIF_TEXT;
                }
            }

            if (mask & LVIF_IMAGE)
            {
                plvi->iImage = pitem->iImage;
                if (pitem->iImage == I_IMAGECALLBACK)
                    nm.item.mask |= LVIF_IMAGE;
            }

            if (mask & LVIF_INDENT)
            {
                plvi->iIndent = pitem->iIndent;
                if (pitem->iIndent == I_INDENTCALLBACK)
                    nm.item.mask |= LVIF_INDENT;
            }

            if (mask & LVIF_STATE)
            {
                plvi->state = (pitem->state & plvi->stateMask);

                if (plv->stateCallbackMask)
                {
                    nm.item.stateMask = (plvi->stateMask & plv->stateCallbackMask);
                    if (nm.item.stateMask)
                    {
                        nm.item.mask |= LVIF_STATE;
                        nm.item.state = 0;
                    }
                }
            }

            if (mask & LVIF_GROUPID)
            {
                if (LISTITEM_HASGROUP(pitem))
                {
                    plvi->iGroupId = pitem->pGroup->iGroupId;
                }
                else
                {
                    nm.item.mask |= LVIF_GROUPID;
                }
            }

            if (mask & LVIF_COLUMNS)
            {
                if ((plvi->puColumns == NULL) || (plvi->cColumns > CCMAX_TILE_COLUMNS))
                {
                    return FALSE;
                }

                if (pitem->cColumns == I_COLUMNSCALLBACK)
                {
                    nm.item.mask |= LVIF_COLUMNS;
                }
                else
                {
                    plvi->cColumns = pitem->cColumns;
                    if (plvi->cColumns < pitem->cColumns)
                    {
                        // Not enough room to store the columns
                        return FALSE;
                    }

                    // Copy the array
                    if (plvi->puColumns && pitem->puColumns)
                    {
                        CopyMemory(plvi->puColumns, pitem->puColumns, plvi->cColumns * sizeof(UINT));
                    }
                }
            }

        }

        if (mask & LVIF_PARAM)
            plvi->lParam = pitem->lParam;
    }
    else
    {
        // Complete call back for info...

        // Handle sub-item cases for report view
        //
        if (plvi->iSubItem != 0)
        {
            // if there are no subitem images, don't query for them
            if (!(plv->exStyle & LVS_EX_SUBITEMIMAGES))
                mask &= ~LVIF_IMAGE;

            // don't allow indent on the non-0th column
            mask &= ~LVIF_INDENT;
        }

        if (mask & LVIF_PARAM)
            plvi->lParam = 0L;      // Dont have any to return now...

        if (mask & LVIF_STATE)
        {
            plvi->state = 0;

            if ((plvi->iSubItem == 0) || ListView_FullRowSelect(plv))
            {
                if (plvi->iItem == plv->iFocus)
                    plvi->state |= LVIS_FOCUSED;

                if (plv->plvrangeSel->lpVtbl->IsSelected(plv->plvrangeSel, plvi->iItem) == S_OK)
                    plvi->state |= LVIS_SELECTED;

                if (plv->plvrangeCut->lpVtbl->IsSelected(plv->plvrangeCut, plvi->iItem) == S_OK)
                    plvi->state |= LVIS_CUT;

                if (plvi->iItem == plv->iDropHilite)
                    plvi->state |= LVIS_DROPHILITED;

                plvi->state &= plvi->stateMask;
            }

            if (plv->stateCallbackMask)
            {
                nm.item.stateMask = (plvi->stateMask & plv->stateCallbackMask);
                if (nm.item.stateMask)
                {
                    nm.item.mask |= LVIF_STATE;
                    nm.item.state = 0;
                }
            }
        }

        if (mask & LVIF_COLUMNS)
        {
            nm.item.mask |= LVIF_COLUMNS;
        }

        nm.item.mask |= (mask & (LVIF_TEXT | LVIF_IMAGE | LVIF_INDENT));
    }

    if (mask & LVIF_NORECOMPUTE)
    {
        if (nm.item.mask & LVIF_TEXT)
            plvi->pszText = LPSTR_TEXTCALLBACK;

        if (nm.item.mask & LVIF_COLUMNS)
            plvi->cColumns = I_COLUMNSCALLBACK;
    }
    else if (nm.item.mask)
    {
        UINT rguColumns[CCMAX_TILE_COLUMNS];
        nm.item.iItem  = plvi->iItem;
        nm.item.iSubItem = plvi->iSubItem;
        if (ListView_IsOwnerData(plv))
            nm.item.lParam = 0L;
        else
            nm.item.lParam = pitem->lParam;

        // just in case LVIF_IMAGE is set and callback doesn't fill it in
        // ... we'd rather have a -1 than whatever garbage is on the stack
        nm.item.iImage = -1;
        nm.item.iIndent = 0;
        if (nm.item.mask & LVIF_TEXT)
        {
            RIPMSG(plvi->pszText != NULL, "LVM_GET(ITEM|ITEMTEXT) null string pointer");

            if (plvi->pszText)
            {
                nm.item.pszText = plvi->pszText;
                nm.item.cchTextMax = plvi->cchTextMax;

                // Make sure the buffer is zero terminated...
                if (nm.item.cchTextMax)
                    *nm.item.pszText = 0;
            }
            else
            {
                // Don't make caller smash null pointer
                nm.item.mask &= ~LVIF_TEXT;
            }
        }

        if (nm.item.mask & LVIF_COLUMNS)
        {
            nm.item.cColumns = plvi->cColumns;
            nm.item.puColumns = rguColumns;
            if (plvi->puColumns && plvi->cColumns && plvi->cColumns < ARRAYSIZE(rguColumns))
            {
                CopyMemory(rguColumns, plvi->puColumns, sizeof(UINT) * plvi->cColumns);
            }
        }

        CCSendNotify(&plv->ci, LVN_GETDISPINFO, &nm.hdr);

        // use nm.item.mask to give the app a chance to change values
        if (nm.item.mask & LVIF_INDENT)
            plvi->iIndent = nm.item.iIndent;
        if (nm.item.mask & LVIF_GROUPID)
        {
            if (pitem)
            {
                if (nm.item.iGroupId == I_GROUPIDNONE)
                {
                    ListView_RemoveItemFromItsGroup(plv, pitem);
                    LISTITEM_SETASKEDFORGROUP(pitem);
                }
                else
                {
                    LISTGROUP* pgrp = ListView_FindGroupFromID(plv, nm.item.iGroupId, NULL);

                    if (pgrp != pitem->pGroup)
                    {
                        ListView_RemoveItemFromItsGroup(plv, pitem);

                        pitem->pGroup = pgrp;
                        if (pgrp)
                        {
                            DPA_AppendPtr(pgrp->hdpa, pitem);
                        }
                    }
                }
            }
            plvi->iGroupId = nm.item.iGroupId;
        }

        if (nm.item.mask & LVIF_STATE)
            plvi->state ^= ((plvi->state ^ nm.item.state) & nm.item.stateMask);
        if (nm.item.mask & LVIF_IMAGE)
            plvi->iImage = nm.item.iImage;
        if (nm.item.mask & LVIF_TEXT)
            plvi->pszText = CCReturnDispInfoText(nm.item.pszText, plvi->pszText, plvi->cchTextMax);
        if (nm.item.mask & LVIF_COLUMNS)
        {
            // Put the # of columns back in the LV_ITEM struct.  Don't need to
            // do anything with puColumns.

            UINT cColumns = (nm.item.cColumns == I_COLUMNSCALLBACK) ? 0 : nm.item.cColumns;
            UINT cColumnsToCopy = min(cColumns, plvi->cColumns);
            // Copy rguColumns back into the thing we were passed.
            CopyMemory(plvi->puColumns, rguColumns, sizeof(UINT) * cColumnsToCopy);

            plvi->cColumns = cColumnsToCopy;
        }

        if (pitem && (nm.item.mask & LVIF_DI_SETITEM))
        {

            //
            // The SendNotify above can set about a terrible series of events
            // whereby asking for DISPINFO causes the shell to look around
            // (call peekmessage) to see if its got a new async icon for the
            // listview.  This lets other messages be delivered, such as an
            // UPDATEIMAGE of Index == -1 (if the user is changing icon sizing
            // at the same time).  This causes a re-enumeration of the desktop
            // and hence this very listview is torn down and rebuilt while
            // we're sitting here for the DISPINFO to finish.  Thus, as a cheap
            // and dirty solution, I check to see if the item I think I have
            // is the same one I had when I made the notify, and if not, I
            // bail.  Don't blame me, I'm just cleaning up the mess.

            if (pitem != ListView_GetItemPtr(plv, plvi->iItem))
            {
                return FALSE;
            }

            if (nm.item.iSubItem == 0)
            {
                //DebugMsg(TF_LISTVIEW, "SAVING ITEMS!");
                if (nm.item.mask & LVIF_IMAGE)
                    pitem->iImage = (short) nm.item.iImage;

                if (nm.item.mask & LVIF_INDENT)
                    pitem->iIndent = (short) nm.item.iIndent;

                if (nm.item.mask & LVIF_TEXT)
                    if (nm.item.pszText)
                    {
                        Str_Set(&pitem->pszText, nm.item.pszText);
                    }

                if (nm.item.mask & LVIF_STATE)
                    pitem->state ^= ((pitem->state ^ nm.item.state) & nm.item.stateMask);

                if (nm.item.mask & LVIF_COLUMNS)
                {
                    Tile_Set(&pitem->puColumns, &pitem->cColumns, nm.item.puColumns, nm.item.cColumns);

                    // Just did a Tile_Set - need to recompute.
                    ListView_SetSRecompute(pitem);
                }
            }
            else
            {
                ListView_SetSubItem(plv, &nm.item);
            }
        }
    }

    return TRUE;
}

BOOL ListView_OnSetItemA(LV* plv, LV_ITEMA* plvi) 
{
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    BOOL fRet;

    // Let ListView_OnSetItem() handle owner-data validation

    //HACK ALERT -- this code assumes that LV_ITEMA is exactly the same
    // as LV_ITEMW except for the pointer to the string.
    COMPILETIME_ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW));

    if (!plvi)
        return FALSE;

    if ((plvi->mask & LVIF_TEXT) && (plvi->pszText != NULL)) 
    {
        pszC = plvi->pszText;
        pszW = ProduceWFromA(plv->ci.uiCodePage, pszC);
        if (pszW == NULL)
            return FALSE;
        plvi->pszText = (LPSTR)pszW;
    }

    fRet = ListView_OnSetItem(plv, (const LV_ITEM*) plvi);

    if (pszW != NULL) 
    {
        plvi->pszText = pszC;

        FreeProducedString(pszW);
    }
    return fRet;
}

void ListView_OffsetRect(LV* plv, RECT* prc)
{
    if (ListView_IsReportView(plv))
    {
        OffsetRect(prc, -plv->ptlRptOrigin.x, -plv->ptlRptOrigin.y + plv->yTop);
    }
    else
    {
        OffsetRect(prc, -plv->ptOrigin.x, -plv->ptOrigin.y);
    }
}

BOOL ListView_OnSetItem(LV* plv, const LV_ITEM* plvi)
{
    LISTITEM* pitem = NULL;
    UINT mask;
    UINT maskChanged;
    UINT rdwFlags=RDW_INVALIDATE;
    int i;
    UINT stateOld, stateNew;
    BOOL fFocused = FALSE;
    BOOL fSelected = FALSE;
    BOOL fStateImageChanged = FALSE;
    
    if (ListView_IsOwnerData(plv)) 
    {
        RIPMSG(0, "LVM_SETITEM: Invalid for owner-data listview");
        return FALSE;
    }
    
    if (!plvi)
        return FALSE;
    
    RIPMSG(plvi->iSubItem >= 0, "ListView_OnSetItem: Invalid item index");
    
    if (plv->himl && (plv->clrBk != ImageList_GetBkColor(plv->himl)))
        rdwFlags |= RDW_ERASE;
    
    mask = plvi->mask;
    if (!mask)
        return TRUE;
    
    // If we're setting a subitem, handle it elsewhere...
    //
    if (plvi->iSubItem > 0)
        return ListView_SetSubItem(plv, plvi);
    
    i = plvi->iItem;
    
    pitem = ListView_GetItemPtr(plv, i);
    if (!pitem)
        return FALSE;
    
    //REVIEW: This is a BOGUS HACK, and should be fixed.
    //This incorrectly calculates the old state (since we may
    // have to send LVN_GETDISPINFO to get it).
    //
    stateOld = stateNew = 0;
    if (mask & LVIF_STATE)
    {
        stateOld = pitem->state & plvi->stateMask;
        stateNew = plvi->state & plvi->stateMask;
    }
    
    // Prevent multiple selections in a single-select listview.
    if ((plv->ci.style & LVS_SINGLESEL) && (mask & LVIF_STATE) && (stateNew & LVIS_SELECTED))
    {
        ListView_DeselectAll(plv, i);
        
        // Refresh the old state information
        stateOld = pitem->state & plvi->stateMask;
    }
    
    if (!ListView_SendChange(plv, i, 0, LVN_ITEMCHANGING, stateOld, stateNew, mask, pitem->lParam))
        return FALSE;
    
    maskChanged = 0;
    
    if (mask & LVIF_STATE)
    {
        UINT change = (pitem->state ^ plvi->state) & plvi->stateMask;
        
        if (change)
        {
            pitem->state ^= change;
            
            maskChanged |= LVIF_STATE;
            
            // the selection state has changed.. update selected count
            if (change & LVIS_SELECTED)
            {
                fSelected = TRUE;
                
                if (pitem->state & LVIS_SELECTED) 
                {
                    plv->nSelected++;
                } 
                else 
                {
                    if (plv->nSelected > 0)
                        plv->nSelected--;
                }
            }
            
            // For some bits we can only invert the label area...
            // fSelectOnlyChange = ((change & ~(LVIS_SELECTED | LVIS_FOCUSED | LVIS_DROPHILITED)) == 0);
            // fEraseItem = ((change & ~(LVIS_SELECTED | LVIS_DROPHILITED)) != 0);
            
            // try to steal focus from the previous guy.
            if (change & LVIS_FOCUSED)
            {
                BOOL fUnfolded = ListView_IsItemUnfolded(plv, plv->iFocus);
                int iOldFocus = plv->iFocus;
                RECT rcLabel;
                
                fFocused = TRUE;
                
                if (plv->iFocus != i) 
                {
                    if ((plv->iFocus == -1) || ListView_OnSetItemState(plv, plv->iFocus, 0, LVIS_FOCUSED)) 
                    {
                        ASSERT(pitem->state & LVIS_FOCUSED);
                        plv->iFocus = i;
                        if (plv->iMark == -1)
                            plv->iMark = i;
                    } 
                    else 
                    {
                        fFocused = FALSE;
                        pitem->state &= ~LVIS_FOCUSED;
                    }
                } 
                else
                {
                    ASSERT(!(pitem->state & LVIS_FOCUSED));
                    plv->iFocus = -1;
                }
                
                // If we were previously unfolded and we move the focus we must
                // attempt to refresh the previous focus owner to referect this change.
                
                if (fUnfolded && !ListView_IsItemUnfolded(plv, iOldFocus) && (plv->iItemDrawing != iOldFocus))
                {
                    ListView_GetUnfoldedRect(plv, iOldFocus, &rcLabel);
                    RedrawWindow(plv->ci.hwnd, &rcLabel, NULL, RDW_INVALIDATE|RDW_ERASE);
                }
                
                // Kill the tooltip if focus moves, it causes us headaches otherwise!
                ListView_PopBubble(plv);
            }
            
            if (change & LVIS_CUT ||
                plv->clrTextBk == CLR_NONE)
                rdwFlags |= RDW_ERASE;
            
            if (change & LVIS_OVERLAYMASK) 
            {
                // Overlay changed, so need to blow away icon region cache
                if (pitem->hrgnIcon)
                {
                    if (pitem->hrgnIcon != (HANDLE) -1)
                        DeleteObject(pitem->hrgnIcon);
                    pitem->hrgnIcon = NULL;
                }
            }
            
            fStateImageChanged = (change & LVIS_STATEIMAGEMASK);
            
        }
    }
    
    if (mask & LVIF_TEXT)
    {
        // need to do this now because we're changing the text
        // so we need to get the rect of the thing before the text changes
        // but don't redraw the item we are currently painting
        if (plv->iItemDrawing != i)
        {
            ListView_InvalidateItemEx(plv, i, FALSE,
                RDW_INVALIDATE | RDW_ERASE, LVIF_TEXT);
        }
        
        if (!Str_Set(&pitem->pszText, plvi->pszText))
            return FALSE;
        
        plv->rcView.left = RECOMPUTE;
        ListView_SetSRecompute(pitem);
        maskChanged |= LVIF_TEXT;
    }
    
    if (mask & LVIF_INDENT) 
    {
        if (pitem->iIndent != plvi->iIndent)
        {
            pitem->iIndent = (short) plvi->iIndent;
            maskChanged |= LVIF_INDENT;
            
            if (ListView_IsReportView(plv))
                rdwFlags |= RDW_ERASE;
        }
    }
    
    if (mask & LVIF_IMAGE)
    {
        if (pitem->iImage != plvi->iImage)
        {
            pitem->iImage = (short) plvi->iImage;
            maskChanged |= LVIF_IMAGE;
            
            if (pitem->hrgnIcon) 
            {
                if (pitem->hrgnIcon != (HANDLE) -1)
                    DeleteObject(pitem->hrgnIcon);
                pitem->hrgnIcon = NULL;
            }
            
            // erase if there was a set image
            if (pitem->iImage != I_IMAGECALLBACK)
                rdwFlags |= RDW_ERASE;
        }
    }
    
    if (mask & LVIF_PARAM)
    {
        if (pitem->lParam != plvi->lParam)
        {
            pitem->lParam = plvi->lParam;
            maskChanged |= LVIF_PARAM;
        }
    }
    
    if (mask & LVIF_GROUPID)
    {
        LISTGROUP* pgrp = ListView_FindGroupFromID(plv, plvi->iGroupId, NULL);
        if (pgrp)
        {
            if (pitem->pGroup != pgrp)
            {
                ListView_RemoveItemFromItsGroup(plv, pitem);
                pitem->pGroup = pgrp;
                DPA_AppendPtr(pgrp->hdpa, pitem);
                
                if (ListView_RedrawEnabled(plv))
                {
                    _ListView_RecomputeEx(plv, NULL, 0, FALSE);
                    InvalidateRect(plv->ci.hwnd, NULL, TRUE);
                }
                
                maskChanged |= LVIF_GROUPID;
            }
        }
    }
    
    if (mask & LVIF_COLUMNS)
    {
        UINT uNumColumns = (plvi->cColumns == I_COLUMNSCALLBACK) ? 0 : plvi->cColumns;
        
        if (((uNumColumns > 0) && (plvi->puColumns == NULL)) || // Didn't provide any columns
            (uNumColumns > CCMAX_TILE_COLUMNS))                   // Provided too many 
        {
            return FALSE; // See note below about premature return.
        }
        
        if (!Tile_Set(&pitem->puColumns, &pitem->cColumns, plvi->puColumns, plvi->cColumns))
            return FALSE;
        // Note: if we fail here, we may have still set the LVIF_TEXT above...
        // so the call partially succeeded. Oh well, no way to undo that.
        
        maskChanged |= LVIF_COLUMNS;
        
        // Columns changed - need to recompute this guy.
        ListView_SetSRecompute(pitem);
    }
    
    if (maskChanged)
    {
        // don't redraw the item we are currently painting
        if (plv->iItemDrawing != i)
            ListView_InvalidateItemEx(plv, i, FALSE, rdwFlags, maskChanged);
        
        TraceMsg(DM_LVSENDCHANGE, "LV - SendChange %d %d %d %d", i, stateOld, stateNew, maskChanged);
        ListView_SendChange(plv, i, 0, LVN_ITEMCHANGED, stateOld, stateNew, maskChanged, pitem->lParam);
        
        if (maskChanged & LVIF_TEXT)
            NotifyWinEvent(EVENT_OBJECT_NAMECHANGE, plv->ci.hwnd, OBJID_CLIENT, i+1);
        
        if (maskChanged & LVIF_STATE)
        {
            if (fFocused)
                ListView_NotifyFocusEvent(plv);
            
            if (fSelected)
            {
                if (stateNew & LVIS_SELECTED)
                {
                    NotifyWinEvent((plv->nSelected == 1) ? EVENT_OBJECT_SELECTION :
                EVENT_OBJECT_SELECTIONADD, plv->ci.hwnd, OBJID_CLIENT, i+1);
                }
                else
                {
                    NotifyWinEvent(EVENT_OBJECT_SELECTIONREMOVE, plv->ci.hwnd, OBJID_CLIENT, i+1);
                }
            }
            
            if (fStateImageChanged)
                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, plv->ci.hwnd, OBJID_CLIENT, i+1);
        }
    }
    
    return TRUE;
}

UINT ListView_OnGetItemState(LV* plv, int i, UINT mask)
{
    LV_ITEM lvi;

    lvi.mask = LVIF_STATE;
    lvi.stateMask = mask;
    lvi.iItem = i;
    lvi.iSubItem = 0;
    if (!ListView_OnGetItem(plv, &lvi))
        return 0;

    return lvi.state;
}


BOOL ListView_OnSetItemState(LV* plv, int i, UINT data, UINT mask)
{
    UINT rdwFlags = RDW_INVALIDATE;
    LV_ITEM lvi;

    lvi.mask    = LVIF_STATE;
    lvi.state   = data;
    lvi.stateMask = mask;
    lvi.iItem   = i;
    lvi.iSubItem = 0;

    // if the item is -1, we will do it for all items.  We special case
    // a few cases here as to speed it up.  For example if the mask is
    // LVIS_SELECTED and data is zero it implies that we will deselect
    // all items...
    //
    if (ListView_IsOwnerData(plv))
    {
        UINT uOldData = 0;

        // these are the only two we handled
        mask &= (LVIS_SELECTED | LVIS_FOCUSED | LVIS_CUT | LVIS_DROPHILITED);
        if (!mask)
            return TRUE;

        if (plv->clrTextBk == CLR_NONE || 
            (plv->himl && (plv->clrBk != ImageList_GetBkColor(plv->himl))))
        {
            rdwFlags |= RDW_ERASE;
        }

        if (i == -1)
        {
            // request selection state change for all
            if (mask & LVIS_SELECTED)
            {
                if (data & LVIS_SELECTED)
                {  // set selection
                    if ((plv->ci.style & LVS_SINGLESEL))
                    {   // cant make multiple selections in a single-select listview.
                        return FALSE;
                    }

                    if (plv->cTotalItems)
                    {
                        if (FAILED(plv->plvrangeSel->lpVtbl->IncludeRange(plv->plvrangeSel, 0, plv->cTotalItems - 1)))
                            return FALSE;
                    }

                    RedrawWindow(plv->ci.hwnd, NULL, NULL, rdwFlags);
                }
                else
                {  // clear selection
                    if (plv->nSelected > 0) 
                    {
                        ListView_InvalidateSelectedOrCutOwnerData(plv, plv->plvrangeSel);
                        if (FAILED(plv->plvrangeSel->lpVtbl->Clear(plv->plvrangeSel)))
                            return FALSE;
                    } 
                    else 
                    {
                        // if nothing was selected, then there's nothing to clear
                        // no change.
                        mask &= ~ LVIS_SELECTED;
                    }
                }
                uOldData |= (LVIS_SELECTED & (mask ^ data));

                // Update our internal count to what the list thinks is the number selected...
                plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &plv->nSelected);
            }

            // can maybe combine with above code...
            if (mask & LVIS_CUT)
            {
                if (data & LVIS_CUT)
                {  // set selection

                    if (plv->cTotalItems)
                        if (FAILED(plv->plvrangeCut->lpVtbl->IncludeRange(plv->plvrangeCut, 0, plv->cTotalItems - 1)))
                            return FALSE;

                    RedrawWindow(plv->ci.hwnd, NULL, NULL, rdwFlags);

                }
                else
                {  // clear selection
                    if (plv->plvrangeCut->lpVtbl->IsEmpty(plv->plvrangeCut) != S_OK) 
                    {
                        ListView_InvalidateSelectedOrCutOwnerData(plv, plv->plvrangeCut);
                        if (FAILED(plv->plvrangeCut->lpVtbl->Clear(plv->plvrangeCut)))
                            return FALSE;
                    }
                    else 
                    {
                        // if nothing was selected, then there's nothing to clear
                        // no change.
                        mask &= ~ LVIS_CUT;
                    }
                }
                uOldData |= (LVIS_CUT & (mask ^ data));
            }

            // request focus state change
            if (mask & LVIS_FOCUSED)
            {
                if (data & LVIS_FOCUSED)
                {  // cant set focus to all
                    return FALSE;
                }
                else if (plv->iFocus != -1)
                {
                    int iOldFocus = plv->iFocus;
                    // clear focus
                    uOldData |= (LVIS_FOCUSED & (mask ^ data));
                    plv->iFocus = -1;
                    // notify that the old focus is being lost
                    DebugMsg(DM_LVSENDCHANGE, TEXT("VLV: LVN_ITEMCHANGED: %d %d %d"), iOldFocus, LVIS_FOCUSED, 0);
                    ListView_SendChange(plv, iOldFocus, 0, LVN_ITEMCHANGED, LVIS_FOCUSED, 0, LVIF_STATE, 0);
                    ListView_InvalidateFoldedItem(plv, iOldFocus, TRUE, RDW_INVALIDATE |RDW_ERASE);
                }
            }

            if (mask & LVIS_DROPHILITED)
            {
                if (data & LVIS_DROPHILITED)
                {  // cant set focus to all
                    return FALSE;
                }
                else if (plv->iDropHilite != -1)
                {
                    int iOldDropHilite = plv->iDropHilite;
                    // clear focus
                    uOldData |= (LVIS_FOCUSED & (mask ^ data));
                    plv->iDropHilite = -1;
                    // notify that the old focus is being lost
                    ListView_SendChange(plv, iOldDropHilite, 0, LVN_ITEMCHANGED, LVIS_DROPHILITED, 0, LVIF_STATE, 0);
                    ListView_InvalidateFoldedItem(plv, iOldDropHilite, TRUE, RDW_INVALIDATE |RDW_ERASE);
                }
            }

            // invalidate and notify if there was a change
            if (uOldData ^ (data & mask)) 
            {
                DebugMsg(DM_LVSENDCHANGE, TEXT("VLV: LVN_ITEMCHANGED: %d %d %d"), i, uOldData, data);
                ListView_SendChange(plv, i, 0, LVN_ITEMCHANGED, uOldData, data, LVIF_STATE, 0);

                if (mask & LVIS_SELECTED)
                {
                    // Tell accessibility, "Selection changed in a complex way"
                    // (There is no "select all" or "select none" notification)
                    NotifyWinEvent(EVENT_OBJECT_SELECTIONWITHIN, plv->ci.hwnd, OBJID_CLIENT, CHILDID_SELF);
                }
            }
        }
        else
        {
            if (!ListView_IsValidItemNumber(plv, i))
                return FALSE;

            // request selection state change
            // and the selection state is new...
            if ((mask & LVIS_SELECTED)) 
            {
                if (((plv->plvrangeSel->lpVtbl->IsSelected(plv->plvrangeSel, i) == S_OK) ? LVIS_SELECTED : 0) ^ (data & LVIS_SELECTED))
                {
                    if (data & LVIS_SELECTED)
                    {  // set selection
                        if ((plv->ci.style & LVS_SINGLESEL))
                        {
                            // in single selection mode, we need to deselect everything else
                            if (!ListView_OnSetItemState(plv, -1, 0, LVIS_SELECTED))
                                return FALSE;
                        }

                        // now select the new item
                        if (FAILED(plv->plvrangeSel->lpVtbl->IncludeRange(plv->plvrangeSel, i, i)))
                            return FALSE;
                    }
                    else
                    {  // clear selection
                        if (FAILED(plv->plvrangeSel->lpVtbl->ExcludeRange(plv->plvrangeSel, i, i)))
                            return FALSE;
                    }

                    // something actually changed (or else we wouldn't be in this
                    // if block
                    uOldData |= (LVIS_SELECTED & (mask ^ data));
                }
                else
                {
                    // nothing changed... so make the uOldData be the same for this bit
                    // else make this the same as
                    uOldData |= (LVIS_SELECTED & (mask & data));
                }

                // Update our internal count to what the list thinks is the number selected...
                plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &plv->nSelected);
            }

            if ((mask & LVIS_CUT)) 
            {
                if (((plv->plvrangeCut->lpVtbl->IsSelected(plv->plvrangeCut, i) == S_OK) ? LVIS_CUT : 0) ^ (data & LVIS_CUT))
                {
                    if (data & LVIS_CUT)
                    {
                        // now select the new item
                        if (FAILED(plv->plvrangeCut->lpVtbl->IncludeRange(plv->plvrangeCut, i, i)))
                            return FALSE;
                    }
                    else
                    {  // clear selection
                        if (FAILED(plv->plvrangeCut->lpVtbl->ExcludeRange(plv->plvrangeCut, i, i)))
                            return FALSE;
                    }
                    // something actually changed (or else we wouldn't be in this
                    // if block
                    uOldData |= (LVIS_CUT & (mask ^ data));
                    rdwFlags |= RDW_ERASE;
                }
                else
                {
                    // nothing changed... so make the uOldData be the same for this bit
                    // else make this the same as
                    uOldData |= (LVIS_CUT & (mask & data));
                }
            }

            // request focus state change
            if (mask & LVIS_FOCUSED)
            {
                int iOldFocus = plv->iFocus;

                if (data & LVIS_FOCUSED)
                {  // set focus
                    if (i != plv->iFocus)
                    {
                        // we didn't have the focus before
                        plv->iFocus = i;
                        if (plv->iMark == -1)
                            plv->iMark = i;
                        if (iOldFocus != -1)
                        {

                            // we're stealing it from someone
                            // notify of the change
                            DebugMsg(DM_LVSENDCHANGE, TEXT("VLV: LVN_ITEMCHANGED: %d %d %d"), iOldFocus, LVIS_FOCUSED, 0);
                            ListView_SendChange(plv, iOldFocus, 0, LVN_ITEMCHANGED, LVIS_FOCUSED, 0, LVIF_STATE, 0);

                        }
                    }
                    else
                    {
                        // we DID have the focus before
                        uOldData |= LVIS_FOCUSED;
                    }
                }
                else
                {  // clear focus
                    if (i == plv->iFocus)
                    {
                        plv->iFocus = -1;
                        uOldData |= LVIS_FOCUSED;
                    }
                }
            }

            // request focus state change
            if (mask & LVIS_DROPHILITED)
            {
                int iOldDropHilite = plv->iDropHilite;

                if (data & LVIS_DROPHILITED)
                {  // set Drop Hilite
                    if (i != plv->iDropHilite)
                    {
                        // we didn't have the Drop Hilite before
                        plv->iDropHilite = i;
                        if (iOldDropHilite != -1) 
                        {
                            // we're stealing it from someone
                            // notify of the change
                            ListView_SendChange(plv, iOldDropHilite, 0, LVN_ITEMCHANGED, LVIS_DROPHILITED, 0, LVIF_STATE, 0);
                            ListView_InvalidateFoldedItem(plv, iOldDropHilite, TRUE, RDW_INVALIDATE |RDW_ERASE);

                        }
                    }
                    else
                    {
                        // we DID have the Drop Hilite before
                        uOldData |= LVIS_DROPHILITED;
                    }
                }
                else
                {  // clear Drop Hilite
                    if (i == plv->iDropHilite)
                    {
                        plv->iDropHilite = -1;
                        uOldData |= LVIS_DROPHILITED;
                    }
                }
            }

            // invalidate and notify if there was a change
            if (uOldData ^ (data & mask))
            {
                DebugMsg(DM_LVSENDCHANGE, TEXT("VLV: LVN_ITEMCHANGED: %d %d %d"), i, uOldData, data);
                ListView_SendChange(plv, i, 0, LVN_ITEMCHANGED, uOldData, data, LVIF_STATE, 0);
                ListView_InvalidateItem(plv, i, TRUE, rdwFlags);

                // Kill the tooltip if focus moves, it causes us headaches otherwise!
                if ((uOldData ^ (data & mask)) & LVIS_FOCUSED)
                {
                    ListView_PopBubble(plv);
                    ListView_NotifyFocusEvent(plv);
                }

                // Tell accessibility about the changes
                if (mask & LVIS_SELECTED) 
                {
                    UINT event;

                    if (data & LVIS_SELECTED)
                    {
                        if (plv->nSelected == 1)
                            event = EVENT_OBJECT_SELECTION; // this object is the entire selection
                        else
                            event = EVENT_OBJECT_SELECTIONADD; // this object is selected
                    }
                    else
                        event = EVENT_OBJECT_SELECTIONREMOVE; // this object is unselected
                    NotifyWinEvent(event, plv->ci.hwnd, OBJID_CLIENT, i + 1);
                }
            }
        }
    }
    else
    {
        if (i != -1)
        {
            return ListView_OnSetItem(plv, &lvi);
        }
        else
        {
            UINT flags = LVNI_ALL;

            if (data == 0)
            {
                switch (mask)
                {
                case LVIS_SELECTED:
                    flags = LVNI_SELECTED;
                    break;
                case LVIS_CUT:
                    flags = LVNI_CUT;
                    break;
                }
            }
            else if ((plv->ci.style & LVS_SINGLESEL) && (mask == LVIS_SELECTED))
                return FALSE;   /* can't select all in single-select listview */
            else if ((mask & data) & LVIS_FOCUSED) 
            {
                return FALSE; // can't set focus to everything
            }

            //
            // Now iterate over all of the items that match our criteria and
            // set their new value.
            //
            while ((lvi.iItem = ListView_OnGetNextItem(plv, lvi.iItem, flags)) != -1) 
            {
                ListView_OnSetItem(plv, &lvi);
            }
        }
    }
    return TRUE;
}

//
// Returns TRUE if the label of an item is not truncated (is unfolded) and FALSE
// otherwise. If FALSE is returned, it also fills the Unfolding text in pszText.
// If TRUE is returned, pszText is set to empty string.
//
BOOL ListView_IsItemUnfolded2(LV* plv, int iItem, int iSubItem, LPTSTR pszText, int cchTextMax)
{
    BOOL bItemUnfolded = ListView_IsItemUnfolded(plv, iItem);

    if (pszText && cchTextMax > 0)    // Sanity checks on input params.
    {
        pszText[0] = 0;

        if (!bItemUnfolded)
        {
            RECT rcLabel = {0};
            LV_ITEM item;

            item.iItem = iItem;
            item.iSubItem = iSubItem;
            item.mask = LVIF_TEXT | LVIF_PARAM;

            if (ListView_IsTileView(plv))
            {
                TCalculateSubItemRect(plv, NULL, NULL, iItem, iSubItem, NULL, NULL, &bItemUnfolded);
                if (!bItemUnfolded)
                {
                    // Need to supply text.
                    item.pszText = pszText;
                    item.cchTextMax = cchTextMax;
                    ListView_OnGetItem(plv, &item);
                }
            }
            else if (!ListView_IsIconView(plv))
            {
                if (ListView_IsLabelTip(plv) || ListView_IsInfoTip(plv))
                {
                    BOOL fSuccess;

                    rcLabel.left = LVIR_LABEL;

                    if (iSubItem) 
                    {
                        rcLabel.top = iSubItem;
                        fSuccess = ListView_OnGetSubItemRect(plv, iItem, &rcLabel);
                    }
                    else 
                    {
                        fSuccess = ListView_OnGetItemRect(plv, iItem, &rcLabel);
                    }

                    if (fSuccess)
                    {
                        TCHAR szText[INFOTIPSIZE];

                        item.pszText = szText;
                        item.cchTextMax = min(ARRAYSIZE(szText), cchTextMax);
                        if (ListView_OnGetItem(plv, &item) && item.pszText != LPSTR_TEXTCALLBACK)
                        {
                            SIZE siz;
                            LVFAKEDRAW lvfd;
                            int cx;
                            HRESULT hr = E_FAIL;

                            ListView_BeginFakeCustomDraw(plv, &lvfd, &item);
                            ListView_BeginFakeItemDraw(&lvfd);

                            //        ---------Label width----------- ---Client width---
                            cx = min(rcLabel.right - g_cxLabelMargin, plv->sizeClient.cx);

                            hr = GetTextExtentPoint32(lvfd.nmcd.nmcd.hdc, item.pszText, lstrlen(item.pszText), &siz) ? 
                                S_OK : E_FAIL;

                            if (SUCCEEDED(hr) &&
                                (rcLabel.left + g_cxLabelMargin + siz.cx) > cx)
                            {
                                lstrcpyn(pszText, item.pszText, item.cchTextMax);
                            }
                            else
                            {
                                // Not truncated after all
                                bItemUnfolded = TRUE;
                            }

                            ListView_EndFakeItemDraw(&lvfd);
                            ListView_EndFakeCustomDraw(&lvfd);
                        }
                    }
                }
            }
            else
            {
                // Large icon view is the only one that folds
                if (ListView_GetUnfoldedRect(plv, iItem, &rcLabel))
                {
                    item.pszText = pszText;
                    item.cchTextMax = cchTextMax;
                    ListView_OnGetItem(plv, &item);
                }
                else
                {
                    // Item was never folded
                    bItemUnfolded = TRUE;
                }
            }
        }
    }
    return bItemUnfolded;
}

#ifdef UNICODE

// Rather than thunking to ListView_OnGetItemText, we let ListView_GetItemA
// do the work.

int ListView_OnGetItemTextA(LV* plv, int i, LV_ITEMA *plvi)
{
    if (!plvi)
        return 0;

    RIPMSG(plvi->pszText != NULL, "LVM_GETITEMTEXT null string pointer");

    plvi->mask = LVIF_TEXT;
    plvi->iItem = i;
    if (!ListView_OnGetItemA(plv, plvi))
        return 0;

    return lstrlenA(plvi->pszText);
}
#endif

int ListView_OnGetItemText(LV* plv, int i, LV_ITEM *plvi)
{
    if (!plvi)
        return 0;

    RIPMSG(plvi->pszText != NULL, "LVM_GETITEMTEXT null string pointer");

    plvi->mask = LVIF_TEXT;
    plvi->iItem = i;
    if (!ListView_OnGetItem(plv, plvi))
        return 0;

    return lstrlen(plvi->pszText);
}


#ifdef UNICODE
BOOL WINAPI ListView_OnSetItemTextA(LV* plv, int i, int iSubItem, LPCSTR pszText)
{
    LPWSTR pszW = NULL;
    BOOL fRet;

    // Let ListView_OnSetItemText() handle owner-data validation

    if (pszText != NULL)
    {
        pszW = ProduceWFromA(plv->ci.uiCodePage, pszText);
        if (pszW == NULL)
        {
            return FALSE;
        }
    }

    fRet = ListView_OnSetItemText(plv, i, iSubItem, pszW);

    FreeProducedString(pszW);

    return fRet;
}
#endif

BOOL WINAPI ListView_OnSetItemText(LV* plv, int i, int iSubItem, LPCTSTR pszText)
{
    LV_ITEM lvi;

    if (ListView_IsOwnerData(plv))
    {
       RIPMSG(0, "LVM_SETITEMTEXT: Invalid for owner-data listview");
       return FALSE;
    }

    ListView_InvalidateTTLastHit(plv, i);

    lvi.mask = LVIF_TEXT;
    lvi.pszText = (LPTSTR)pszText;
    lvi.iItem = i;
    lvi.iSubItem = iSubItem;

    return ListView_OnSetItem(plv, &lvi);
}

VOID CALLBACK ImgCtxCallback(void * pvImgCtx, void * pvArg)
{
    LV *plv = (LV *)pvArg;
    ULONG ulState;
    SIZE sizeImg;
    IImgCtx *pImgCtx = plv->pImgCtx;

    IImgCtx_GetStateInfo(pImgCtx, &ulState, &sizeImg, TRUE);

    if (ulState & (IMGLOAD_STOPPED | IMGLOAD_ERROR))
    {
        TraceMsg(TF_BKIMAGE, "Listview ImageCallback: Error!");
        plv->fImgCtxComplete = FALSE;
    }

    else if (ulState & IMGCHG_COMPLETE)
    {
        TraceMsg(TF_BKIMAGE, "Listview ImageCallback: Complete!");
        plv->fImgCtxComplete = TRUE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }
}

void ListView_ReleaseBkImage(LV *plv)
{
    if (plv->pImgCtx)
    {
        IImgCtx_Release(plv->pImgCtx);
        plv->pImgCtx = NULL;

        if (plv->hpalHalftone)
        {
            // No need to delete the half tone palette since we really
            // share it with the image context and it will clean up.
            plv->hpalHalftone = NULL;
        }
    }

    if (plv->hbmBkImage)
    {
        DeleteObject(plv->hbmBkImage);
        plv->hbmBkImage = NULL;
    }

    if (plv->pszBkImage)
    {
        LocalFree(plv->pszBkImage);
        plv->pszBkImage = NULL;
    }
}

BOOL WINAPI ListView_OnSetBkImage(LV* plv, LPLVBKIMAGE pbi)
{
    BOOL fRet = FALSE;
    if (!pbi)
        return FALSE;
    
    if (pbi->ulFlags & LVBKIF_TYPE_WATERMARK)
    {
        BITMAP bm;
        if (pbi->ulFlags & ~LVBKIF_TYPE_WATERMARK)
            return FALSE;       // We don't support anything else with a watermark

        if (plv->hbmpWatermark)
        {
            DeleteObject(plv->hbmpWatermark);
            plv->hbmpWatermark = NULL;
        }

        if (pbi->hbm && GetObject(pbi->hbm, sizeof(bm), &bm))
        {
            plv->hbmpWatermark = pbi->hbm;
            plv->szWatermark.cx = bm.bmWidth;
            plv->szWatermark.cy = bm.bmHeight;
            fRet = TRUE;
        }
    }
    else
    {
        LPCTSTR pszImage = pbi->pszImage;
        long fl;
        switch (pbi->ulFlags & LVBKIF_SOURCE_MASK)
        {
        case LVBKIF_SOURCE_NONE:
            TraceMsg(TF_BKIMAGE, "LV SetBkImage to none");
            ListView_ReleaseBkImage(plv);
            break;

        case LVBKIF_SOURCE_HBITMAP:
            TraceMsg(TF_BKIMAGE, "LV SetBkImage to hBitmap %08lX", pbi->hbm);
            ListView_ReleaseBkImage(plv);
            if (pbi->hbm &&
                (plv->pImgCtx = CBitmapImgCtx_Create(pbi->hbm)) != NULL)
            {
                plv->hbmBkImage = pbi->hbm;
            }
            else
            {
                pbi->ulFlags &= ~LVBKIF_SOURCE_HBITMAP;
            }
            break;

        case LVBKIF_SOURCE_URL:
            TraceMsg(TF_BKIMAGE, "LV SetBkImage to URL");
            ListView_ReleaseBkImage(plv);
            if (pszImage && pszImage[0])
            {
                HRESULT (*pfnCoCreateInstance)(REFCLSID, IUnknown *, DWORD, REFIID, void * *);
                HRESULT hr;
                HMODULE hmodOLE;

                plv->pszBkImage = LocalAlloc(LPTR, (lstrlen(pszImage) + 1) * sizeof(TCHAR));
                if (plv->pszBkImage == NULL)
                {
                    TraceMsg(TF_BKIMAGE, "Wow, could not allocate memory for string!");
                    return FALSE;
                }
                lstrcpy(plv->pszBkImage, pszImage);

                if (((hmodOLE = GetModuleHandle(TEXT("OLE32"))) == NULL) ||
                    ((pfnCoCreateInstance = (HRESULT (*)(REFCLSID, IUnknown *, DWORD, REFIID, void * *))GetProcAddress(hmodOLE, "CoCreateInstance")) == NULL))
                {
                    TraceMsg(TF_BKIMAGE, "Could not find CoCreateInstance!");
                    TraceMsg(TF_BKIMAGE, "Did the caller remember to call CoInitialize?");
                    return FALSE;
                }

                hr = pfnCoCreateInstance(&CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                                         &IID_IImgCtx, (void * *)&plv->pImgCtx);

                if (FAILED(hr))
                {
                    TraceMsg(TF_BKIMAGE, "Could not create a pImgCtx!");
                    TraceMsg(TF_BKIMAGE, "Did you remember to register IEIMAGE.DLL?");
                    return FALSE;
                }
                //
                // Mirror the downloaded image if the listview window is RTL mirrored,
                // so that it would be displayed as is. [samera]
                //
                fl = ((IS_WINDOW_RTL_MIRRORED(plv->ci.hwnd)) ? DWN_MIRRORIMAGE : 0);

                hr = IImgCtx_Load(plv->pImgCtx, pszImage, fl);
                if (FAILED(hr))
                {
                    IImgCtx_Release(plv->pImgCtx);
                    plv->pImgCtx = NULL;
                    TraceMsg(TF_BKIMAGE, "Could not init a pImgCtx!");
                    return FALSE;
                }
            }
            else
            {
                pbi->ulFlags &= ~LVBKIF_SOURCE_URL;
            }
            break;

        default:
            RIPMSG(0, "LVM_SETBKIMAGE: Unsupported image type %d", pbi->ulFlags & LVBKIF_SOURCE_MASK);
            return FALSE;
        }

        plv->ulBkImageFlags = pbi->ulFlags;
        plv->xOffsetPercent = pbi->xOffsetPercent;
        plv->yOffsetPercent = pbi->yOffsetPercent;

        //
        // If we actually created a pImgCtx, initialize it here.
        //
        if (plv->pImgCtx)
        {
            if (plv->hpalHalftone == NULL)
            {
                IImgCtx_GetPalette(plv->pImgCtx, &plv->hpalHalftone);
            }

            plv->fImgCtxComplete = FALSE;
            IImgCtx_SetCallback(plv->pImgCtx, ImgCtxCallback, plv);
            IImgCtx_SelectChanges(plv->pImgCtx, IMGCHG_COMPLETE, 0, TRUE);

            TraceMsg(TF_BKIMAGE, "  SUCCESS!");
            fRet = TRUE;
        }
    }

    InvalidateRect(plv->ci.hwnd, NULL, TRUE);

    return fRet;
}

#ifdef UNICODE
BOOL WINAPI ListView_OnSetBkImageA(LV* plv, LPLVBKIMAGEA pbiA)
{
    BOOL fProducedString = FALSE;
    BOOL fRet;
    LVBKIMAGEW biW;

    CopyMemory(&biW, pbiA, sizeof(LVBKIMAGE));

    switch (biW.ulFlags & LVBKIF_SOURCE_MASK)
    {
    case LVBKIF_SOURCE_NONE:
    case LVBKIF_SOURCE_HBITMAP:
        break;

    case LVBKIF_SOURCE_URL:
        if (biW.pszImage != NULL)
        {
            biW.pszImage = ProduceWFromA(plv->ci.uiCodePage, (LPCSTR)biW.pszImage);
            if (biW.pszImage == (LPARAM)NULL)
            {
                return FALSE;
            }
            fProducedString = TRUE;
        }
        break;

    default:
        // Let ListView_OnSetBkImage() complain about the invalid parameter
        break;
    }

    fRet = ListView_OnSetBkImage(plv, &biW);

    if (fProducedString)
    {
        FreeProducedString((void *)biW.pszImage);
    }

    return fRet;
}
#endif

BOOL WINAPI ListView_OnGetBkImage(LV* plv, LPLVBKIMAGE pbi)
{
    BOOL fRet = FALSE;

    if (!IsBadWritePtr(pbi, sizeof(*pbi)))
    {
        if (pbi->ulFlags & LVBKIF_TYPE_WATERMARK)
        {
            pbi->hbm = plv->hbmpWatermark;
            fRet = TRUE;
        }
        else
        {
            pbi->ulFlags = plv->ulBkImageFlags;

            switch (plv->ulBkImageFlags & LVBKIF_SOURCE_MASK)
            {
            case LVBKIF_SOURCE_NONE:
                fRet = TRUE;
                break;

            case LVBKIF_SOURCE_HBITMAP:
                pbi->hbm = plv->hbmBkImage;
                fRet = TRUE;
                break;

            case LVBKIF_SOURCE_URL:
                if (!IsBadWritePtr(pbi->pszImage, pbi->cchImageMax * sizeof(TCHAR)))
                {
                    lstrcpyn(pbi->pszImage, plv->pszBkImage, pbi->cchImageMax);
                    fRet = TRUE;
                }
                break;

            default:
                RIPMSG(0, "ListView_OnGetBkImage: Invalid source");
                break;
            }

            pbi->xOffsetPercent = plv->xOffsetPercent;
            pbi->yOffsetPercent = plv->yOffsetPercent;
        }
    }

    return fRet;
}

#ifdef UNICODE
BOOL WINAPI ListView_OnGetBkImageA(LV* plv, LPLVBKIMAGEA pbiA)
{
    BOOL fRet = FALSE;

    if (!IsBadWritePtr(pbiA, sizeof(*pbiA)))
    {
        pbiA->ulFlags = plv->ulBkImageFlags;

        switch (plv->ulBkImageFlags & LVBKIF_SOURCE_MASK)
        {
        case LVBKIF_SOURCE_NONE:
            fRet = TRUE;
            break;

        case LVBKIF_SOURCE_HBITMAP:
            pbiA->hbm = plv->hbmBkImage;
            fRet = TRUE;
            break;

        case LVBKIF_SOURCE_URL:
            if (!IsBadWritePtr(pbiA->pszImage, pbiA->cchImageMax))
            {
                ConvertWToAN(plv->ci.uiCodePage, pbiA->pszImage,
                             pbiA->cchImageMax, plv->pszBkImage, -1);
                fRet = TRUE;
            }
            break;

        default:
            RIPMSG(0, "ListView_OnGetBkImage: Invalid source");
            break;
        }

        pbiA->xOffsetPercent = plv->xOffsetPercent;
        pbiA->yOffsetPercent = plv->yOffsetPercent;
    }

    return fRet;
}
#endif

void ListView_FreeSubItem(PLISTSUBITEM plsi)
{
    if (plsi)
    {
        Str_Set(&plsi->pszText, NULL);
        LocalFree(plsi);
    }
}

int ListView_GetCxScrollbar(LV* plv)
{
    int cx;

    if (((plv->exStyle & LVS_EX_FLATSB) == 0) ||
        !FlatSB_GetScrollProp(plv->ci.hwnd, WSB_PROP_CXVSCROLL, &cx))
    {
        cx = g_cxScrollbar;
    }

    return cx;
}

int ListView_GetCyScrollbar(LV* plv)
{
    int cy;

    if (((plv->exStyle & LVS_EX_FLATSB) == 0) ||
        !FlatSB_GetScrollProp(plv->ci.hwnd, WSB_PROP_CYHSCROLL, &cy))
    {
        cy = g_cyScrollbar;
    }

    return cy;
}

DWORD ListView_GetWindowStyle(LV* plv)
{
    DWORD dwStyle;

    if (((plv->exStyle & LVS_EX_FLATSB) == 0) ||
        !FlatSB_GetScrollProp(plv->ci.hwnd, WSB_PROP_WINSTYLE, (LPINT)&dwStyle))
    {
        dwStyle = GetWindowStyle(plv->ci.hwnd);
    }

    return dwStyle;
}

int ListView_SetScrollInfo(LV *plv, int fnBar, LPSCROLLINFO lpsi, BOOL fRedraw)
{
    int iRc;

    if (plv->exStyle & LVS_EX_FLATSB)
    {
        iRc = FlatSB_SetScrollInfo(plv->ci.hwnd, fnBar, lpsi, fRedraw);
    }
    else
    {
        iRc = SetScrollInfo(plv->ci.hwnd, fnBar, lpsi, fRedraw);
    }

    //
    //  You'd think we were finished, but in fact the game is only half over.
    //
    //  Some apps (e.g., Font Folder) will do
    //
    //      SetWindowLong(hwnd, GWL_STYLE, newStyle);
    //
    //  where newStyle toggles the WS_HSCROLL and/or WS_VSCROLL bits.
    //  This causes USER's internal bookkeeping to go completely out
    //  of whack:  The ScrollInfo says that there is a scrollbar, but
    //  the window style says there isn't, or vice versa.  The result
    //  is that we get a scrollbar when we shouldn't or vice versa.
    //
    //  So each time we tweak the scroll info in a manner that changes
    //  the range and page, we kick USER in the head to make sure USER's
    //  view of the world (via style bits) is the same as the scroll
    //  bar's view of the world (via SCROLLINFO).
    //

    //
    //  We should always change SIF_PAGE and SIF_RANGE at the same time.
    //
    ASSERT((lpsi->fMask & (SIF_PAGE | SIF_RANGE)) == 0 ||
           (lpsi->fMask & (SIF_PAGE | SIF_RANGE)) == (SIF_PAGE | SIF_RANGE));

    if ((lpsi->fMask & (SIF_PAGE | SIF_RANGE)) == (SIF_PAGE | SIF_RANGE))
    {
        BOOL fShow;
        fShow = lpsi->nMax && (int)lpsi->nPage <= lpsi->nMax;

#ifdef DEBUG
        {
            DWORD dwStyle, dwScroll, dwWant;
            dwScroll = (fnBar == SB_VERT) ? WS_VSCROLL : WS_HSCROLL;
            //
            //  We can short-circuit some logic with secret knowledge about how
            //  ListView uses SetScrollInfo.
            //
            ASSERT(lpsi->nMin == 0);

            dwWant = fShow ? dwScroll : 0;
            dwStyle = ListView_GetWindowStyle(plv);
            if ((dwStyle & dwScroll) != dwWant)
            {
                TraceMsg(TF_LISTVIEW, "ListView_SetScrollInfo: App twiddled WS_[VH]SCROLL");
            }
        }
#endif

        if (plv->exStyle & LVS_EX_FLATSB)
            FlatSB_ShowScrollBar(plv->ci.hwnd, fnBar, fShow);
        else
            ShowScrollBar(plv->ci.hwnd, fnBar, fShow);
    }

    return iRc;
}

// Add/remove/replace item

BOOL ListView_FreeItem(LV* plv, LISTITEM* pitem)
{
    ASSERT(!ListView_IsOwnerData(plv));

    if (pitem)
    {
        if ((pitem->puColumns) && (pitem->cColumns != I_COLUMNSCALLBACK))
            LocalFree(pitem->puColumns);

        Str_Set(&pitem->pszText, NULL);
        if (pitem->hrgnIcon && pitem->hrgnIcon!=(HANDLE)-1)
            DeleteObject(pitem->hrgnIcon);
        // NOTE: We never remove items from the image list; that's
        // the app's responsibility.
        // REVIEW: Should we do this?  Or should we just provide
        // a message that will adjust image indices for the guy
        // when one is removed?
        //
        ControlFree(plv->hheap, pitem);
    }
    return FALSE;
}

LISTITEM* ListView_CreateItem(LV* plv, const LV_ITEM* plvi)
{
    LISTITEM* pitem = ControlAlloc(plv->hheap, sizeof(LISTITEM));

    ASSERT(!ListView_IsOwnerData(plv));

    if (pitem)
    {
        if (plvi->mask & LVIF_STATE)
        {
            if (plvi->state & ~LVIS_ALL)
            {
                DebugMsg(DM_ERROR, TEXT("ListView: Invalid state: %04x"), plvi->state);
                return NULL;
            }

            // If adding a selected item to a single-select listview, deselect
            // any other items.
            if ((plv->ci.style & LVS_SINGLESEL) && (plvi->state & LVIS_SELECTED))
                ListView_DeselectAll(plv, -1);

            pitem->state  = (plvi->state & ~(LVIS_FOCUSED | LVIS_SELECTED));
        }

        if (plvi->mask & LVIF_PARAM)
            pitem->lParam = plvi->lParam;

        if (plvi->mask & LVIF_IMAGE)
            pitem->iImage = (short) plvi->iImage;

        if (plvi->mask & LVIF_INDENT)
            pitem->iIndent = (short) plvi->iIndent;

        pitem->pt.x = pitem->pt.y = RECOMPUTE;
        ListView_SetSRecompute(pitem);

        pitem->pszText = NULL;
        if (plvi->mask & LVIF_TEXT) 
        {
            if (!Str_Set(&pitem->pszText, plvi->pszText))
            {
                ListView_FreeItem(plv, pitem);
                return NULL;
            }
        }

        if ((plvi->mask & LVIF_COLUMNS) && plvi->cColumns)
        {
            pitem->cColumns = plvi->cColumns;
            if (plvi->cColumns != I_COLUMNSCALLBACK)
            {
                // Too many columns, or no column array? Then fail.
                if ((plvi->cColumns > CCMAX_TILE_COLUMNS) || (plvi->puColumns == NULL))
                {
                    ListView_FreeItem(plv, pitem);
                    return NULL;
                }

                pitem->puColumns = LocalAlloc(LPTR, sizeof(UINT) * pitem->cColumns);
                if (pitem->puColumns == NULL)
                {
                    ListView_FreeItem(plv, pitem);
                    return NULL;
                }

                CopyMemory(pitem->puColumns, plvi->puColumns, sizeof(UINT) * pitem->cColumns);
            }
        }
        else
        {
            pitem->cColumns = 0;
            pitem->puColumns = NULL;
        }

        pitem->dwId = plv->idNext++;        // This may overflow. How to deal?
    }
    return pitem;
}

// HACK ALERT!! -- fSmoothScroll is an added parameter!  It allows for smooth
// scrolling when deleting items.  ListView_LRInvalidateBelow is only currently
// called from ListView_OnUpdate and ListView_OnDeleteItem.  Both these calls
// have been modified to work correctly and be backwards compatible.
//
void ListView_LRInvalidateBelow(LV* plv, int i, int fSmoothScroll)
{
    if (ListView_IsListView(plv) || ListView_IsReportView(plv))
    {
        RECT rcItem;

        if (!ListView_RedrawEnabled(plv) ||
            (ListView_IsReportView(plv) && (plv->pImgCtx != NULL)))
            fSmoothScroll = FALSE;

        if (i >= 0)// && i < ListView_Count(plv))
        {
            ListView_GetRects(plv, i, QUERY_DEFAULT, NULL, NULL, &rcItem, NULL);
        }
        else
        {
            rcItem.left = rcItem.top = 0;
            rcItem.right = plv->sizeClient.cx;
            rcItem.bottom = plv->sizeClient.cy;
        }

        // Don't try to scroll over the header part
        if (ListView_IsReportView(plv) && rcItem.top < plv->yTop)
            rcItem.top = plv->yTop;

        // For both List and report view need to erase the item and
        // below.  Note: do simple test to see if there is anything
        // to redraw

        // we can't check for bottom/right > 0 because if we nuked something
        // above or to the left of the view, it may affect us all
        if ((rcItem.top <= plv->sizeClient.cy) &&
            (rcItem.left <= plv->sizeClient.cx))
        {
            rcItem.bottom = plv->sizeClient.cy;

            if (ListView_RedrawEnabled(plv))
            {
                if ((plv->clrBk == CLR_NONE) && (plv->pImgCtx == NULL))
                {
                    LVSeeThruScroll(plv, &rcItem);
                }
                else if (ListView_IsReportView(plv) && fSmoothScroll)
                {
#ifndef UNIX
                    SMOOTHSCROLLINFO si =
                    {
                        sizeof(si),
                        SSIF_MINSCROLL,
                        plv->ci.hwnd,
                        0,
                        -(plv->cyItem),
                        &rcItem,
                        &rcItem,
                        NULL,
                        NULL,
                        SW_INVALIDATE|SW_ERASE,
                        SSI_DEFAULT,
                        1,
                        1,
                    };
#else
                    SMOOTHSCROLLINFO si;
                    si.cbSize = sizeof(si);
                    si.fMask = SSIF_MINSCROLL;
                    si.hwnd = plv->ci.hwnd;
                    si.dx = 0;
                    si.dy = -(plv->cyItem);
                    si.lprcSrc = &rcItem;
                    si.lprcClip = &rcItem;
                    si.hrgnUpdate = NULL;
                    si.lprcUpdate = NULL;
                    si.fuScroll = SW_INVALIDATE|SW_ERASE;
                    si.uMaxScrollTime = SSI_DEFAULT;
                    si.cxMinScroll = 1;
                    si.cyMinScroll = 1;
                    si.pfnScrollProc = NULL;
#endif

                    SmoothScrollWindow(&si);
                }
                else
                {
                    RedrawWindow(plv->ci.hwnd, &rcItem, NULL, RDW_INVALIDATE | RDW_ERASE);
                }
            }
            else
            {
                RedrawWindow(plv->ci.hwnd, &rcItem, NULL, RDW_INVALIDATE | RDW_ERASE);
            }

            if (ListView_IsListView(plv))
            {
                RECT rcClient;
                // For Listview we need to erase the other columns...
                rcClient.left = rcItem.right;
                rcClient.top = 0;
                rcClient.bottom = plv->sizeClient.cy;
                rcClient.right = plv->sizeClient.cx;
                RedrawWindow(plv->ci.hwnd, &rcClient, NULL, RDW_INVALIDATE | RDW_ERASE);
            }
        }
    }
}

// Used in Ownerdata Icon views to try to not invalidate the whole world...
void ListView_IInvalidateBelow(LV* plv, int i)
{
    RECT rcItem;

    if (i >= 0)
    {
        ListView_GetRects(plv, i, QUERY_DEFAULT, NULL, NULL, &rcItem, NULL);
    }
    else
    {
        rcItem.left = rcItem.top = 0;
        rcItem.right = plv->sizeClient.cx;
        rcItem.bottom = plv->sizeClient.cy;
    }

    // For Iconviews we need to invalidate everything to the right of us in this
    // row and everything below the row...
    // below.  Note: do simple test to see if there is anything
    // to redraw

    if ((rcItem.top <= plv->sizeClient.cy) &&
        (rcItem.left <= plv->sizeClient.cx))
    {
        rcItem.right = plv->sizeClient.cx;
        RedrawWindow(plv->ci.hwnd, &rcItem, NULL, RDW_INVALIDATE | RDW_ERASE);

        // Now erase everything below...
        rcItem.top = rcItem.bottom;
        rcItem.bottom = plv->sizeClient.cy;
        rcItem.left = 0;
        RedrawWindow(plv->ci.hwnd, &rcItem, NULL, RDW_INVALIDATE | RDW_ERASE);
    }
}


void ListView_OnUpdate(LV* plv, int i)
{
    // If in icon/small view, don't call InvalidateItem, since that'll force
    // FindFreeSlot to get called, which is pig-like.  Instead, just
    // force a WM_PAINT message, which we'll catch and call Recompute with.
    //
    if (ListView_IsAutoArrangeView(plv))
    {
        ListView_ArrangeOrSnapToGrid(plv);
        if (!(plv->ci.style & LVS_AUTOARRANGE))
            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INTERNALPAINT | RDW_NOCHILDREN);
    }
    else
    {
        // HACK ALERT!! -- The third parameter is new.  It allows for
        // smooth scrolling when items are deleted in reportview.
        // Passing 0, tells it NOT to scroll.
        //
        ListView_LRInvalidateBelow(plv, i, 0);
    }
    ListView_UpdateScrollBars(plv);
}

#ifdef UNICODE
int ListView_OnInsertItemA(LV* plv, LV_ITEMA* plvi)
{
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    int iRet;

    //HACK ALERT -- this code assumes that LV_ITEMA is exactly the same
    // as LV_ITEMW except for the pointer to the string.
    COMPILETIME_ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW));

    if (!plvi)
    {
        return -1;
    }

    if ((plvi->mask & LVIF_TEXT) && (plvi->pszText != NULL))
    {
        pszC = plvi->pszText;
        pszW = ProduceWFromA(plv->ci.uiCodePage, pszC);
        if (pszW == NULL)
            return -1;
        plvi->pszText = (LPSTR)pszW;
    }

    iRet = ListView_OnInsertItem(plv, (const LV_ITEM*) plvi);

    if (pszW != NULL)
    {
        plvi->pszText = pszC;
        FreeProducedString(pszW);
    }

    return iRet;

}
#endif

int ListView_OnInsertItem(LV* plv, const LV_ITEM* plvi)
{
    int i;
    ListView_InsertItemInternal(plv, plvi, &i);
    return i;
}

LISTITEM* ListView_InsertItemInternal(LV* plv, const LV_ITEM* plvi, int* pi)
{
    int iItem;
    LISTITEM *pitem = NULL;

    *pi = -1;
    if (plvi == NULL)
    {
        RIPMSG(0, "ListView_InsertItem: Do not pass a NULL LV_ITEM.");
        return NULL;
    }

    if (plvi->iSubItem != 0)    // can only insert the 0th item
    {
        RIPMSG(0, "ListView_InsertItem: iSubItem must be 0 (app passed %d)", plvi->iSubItem);
        return NULL;
    }

    // If sorted, then insert sorted.
    //
    if (plv->ci.style & (LVS_SORTASCENDING | LVS_SORTDESCENDING)
        && !ListView_IsOwnerData(plv))
    {
        if (plvi->pszText == LPSTR_TEXTCALLBACK)
        {
            DebugMsg(DM_ERROR, TEXT("Don't use LPSTR_TEXTCALLBACK with LVS_SORTASCENDING or LVS_SORTDESCENDING"));
            return NULL;
        }
        iItem = ListView_LookupString(plv, plvi->pszText, LVFI_SUBSTRING | LVFI_NEARESTXY, 0);
    }
    else
        iItem = plvi->iItem;

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    if (!ListView_IsOwnerData(plv))
    {
        int iZ;
        static s_blah = 0;
        UINT uSelMask = plvi->mask & LVIF_STATE ?
                (plvi->state & (LVIS_FOCUSED | LVIS_SELECTED))
                : 0;
        UINT uSel = uSelMask;
        pitem = ListView_CreateItem(plv, plvi);

        if (!pitem)
            return NULL;

        iItem = DPA_InsertPtr(plv->hdpa, iItem, pitem);
        if (iItem == -1)
        {
            ListView_FreeItem(plv, pitem);
            return NULL;
        }

        plv->cTotalItems++;

        if (plv->hdpaSubItems)
        {
            int iCol;
            // slide all the colum DPAs down to match the location of the
            // inserted item
            //
            for (iCol = plv->cCol - 1; iCol >= 0; iCol--)
            {
                HDPA hdpa = ListView_GetSubItemDPA(plv, iCol);
                if (hdpa)       // this is optional, call backs don't have them
                {
                    // insert a blank item (REVIEW: should this be callback?)

                    // since this can be a tail sparce array,
                    // we need to make sure enough items are there.
                    if (iItem >= DPA_GetPtrCount(hdpa))
                        DPA_SetPtr(hdpa, iItem, NULL);
                    else if (DPA_InsertPtr(hdpa, iItem, NULL) != iItem)
                        goto Failure;
                    // Bad assert since hdpa can be tail sparse
                    // ASSERT(ListView_Count(plv) == DPA_GetPtrCount(hdpa));
                    ASSERT(ListView_Count(plv) >= DPA_GetPtrCount(hdpa));
                }
            }
        }

        // Add item to end of z order
        //
        iZ = DPA_InsertPtr(plv->hdpaZOrder, ListView_Count(plv), IntToPtr(iItem));

        if (iZ == -1)
        {
Failure:
            DebugMsg(TF_LISTVIEW, TEXT("ListView_OnInsertItem() failed"));
            if (DPA_DeletePtr(plv->hdpa, iItem))
                plv->cTotalItems--;
            ListView_FreeItem(plv, pitem);
            return NULL;
        }

        // if we inserted before the focus point, move the focus point up one
        if (iItem <= plv->iFocus)
            plv->iFocus++;
        // do the same thing for the mark
        if (iItem <= plv->iMark)
            plv->iMark++;

        // If the item was not added at the end of the list we need
        // to update the other indexes in the list
        if (iItem != ListView_Count(plv) - 1)
        {
            int i2;
            for (i2 = iZ - 1; i2 >= 0; i2--)
            {
                int iItemZ = (int)(UINT_PTR)DPA_FastGetPtr(plv->hdpaZOrder, i2);
                if (iItemZ >= iItem)
                    DPA_SetPtr(plv->hdpaZOrder, i2, (void *)(UINT_PTR)(iItemZ + 1));
            }
        }

        if (ListView_CheckBoxes(plv)) 
        {
            uSelMask |= LVIS_STATEIMAGEMASK;
            uSel |= INDEXTOSTATEIMAGEMASK(1);
        }

        if (uSelMask) 
        {
            // we masked off these in the createitem above.
            // because turning these on means more than setting the bits.
            ListView_OnSetItemState(plv, iItem, uSel, uSelMask);
        }

        if (plvi->mask & LVIF_GROUPID)
        {
            int iGroupId = plvi->iGroupId;
            if (iGroupId == I_GROUPIDNONE)
            {
                LISTITEM_SETASKEDFORGROUP(pitem);
            }
            else if (iGroupId != I_GROUPIDCALLBACK)
            {
                LISTGROUP* pgrp = ListView_FindGroupFromID(plv, iGroupId, NULL);
                if (!pgrp)
                {
                    ListView_FreeItem(plv, pitem);
                    return NULL;
                }

                pitem->pGroup = pgrp;
                DPA_AppendPtr(pgrp->hdpa, pitem);
            }
        }
        else
        {
            LISTITEM_SETHASNOTASKEDFORGROUP(pitem);
        }


        if (plv->fGroupView && (plv->flags & LVF_REDRAW))
        {
            _ListView_RecomputeEx(plv, NULL, 0, FALSE);
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        }
    }
    else
    {
        //
        // simply adjust selection and count
        //
        if ((iItem >= 0) && (iItem <= MAX_LISTVIEWITEMS))
        {
            if (FAILED(plv->plvrangeSel->lpVtbl->InsertItem(plv->plvrangeSel, iItem)))
            {
                return  NULL;
            }
            plv->cTotalItems++;
            plv->rcView.left = RECOMPUTE;
            ListView_Recompute(plv);
            if (!ListView_IsReportView(plv) && !ListView_IsListView(plv))
            {
                // We need to erase the background so that we don't leave
                // turds from wrapped labels in large icon mode.  This could
                // be optimized by only invalidating to the right of and
                // below the inserted item.
                InvalidateRect(plv->ci.hwnd, NULL, TRUE);
            }

            // if we inserted before the focus point, move the focus point up
            if (iItem <= plv->iFocus)
                plv->iFocus++;
            // do the same thing for the mark
            if (iItem <= plv->iMark)
                plv->iMark++;
        }
    }

    if (!ListView_IsOwnerData(plv))
    {
        ASSERT(ListView_Count(plv) == DPA_GetPtrCount(plv->hdpaZOrder));
    }

    if (ListView_RedrawEnabled(plv))
    {
        // Update region
        ListView_RecalcRegion(plv, TRUE, TRUE);

        // The Maybe resize colmns may resize things in which case the next call
        // to Update is not needed.
        if (!ListView_MaybeResizeListColumns(plv, iItem, iItem))
            ListView_OnUpdate(plv, iItem);

        // this trick makes inserting lots of items cheap
        // even if redraw is enabled.... don't calc or position items
        // until this postmessage comes around
        if (!plv->uUnplaced)
        {
            PostMessage(plv->ci.hwnd, LVMI_PLACEITEMS, 0, 0);
        }
        plv->uUnplaced++;
    }
    else
    {
        //
        // Special case code to make using SetRedraw work reasonably well
        // for adding items to a listview which is in a non layout mode...
        //
        if ((plv->iFirstChangedNoRedraw == -1) ||
                (iItem < plv->iFirstChangedNoRedraw))
            plv->iFirstChangedNoRedraw = iItem;

    }

    // Nuke insertmark... it may be invalid now that an item has been added.
    {
        LVINSERTMARK lvim = {0};
        lvim.cbSize = sizeof(LVINSERTMARK);
        lvim.iItem = -1;
        ListView_OnSetInsertMark(plv, (LPLVINSERTMARK)&lvim);
    }

    ListView_Notify(plv, iItem, 0, LVN_INSERTITEM);

    NotifyWinEvent(EVENT_OBJECT_CREATE, plv->ci.hwnd, OBJID_CLIENT, iItem+1);

    *pi = iItem;

    return pitem;
}

BOOL ListView_OnDeleteItem(LV* plv, int iItem)
{
    int iCount = ListView_Count(plv);

    if (!ListView_IsValidItemNumber(plv, iItem))
        return FALSE;   // out of range

    NotifyWinEvent(EVENT_OBJECT_DESTROY, plv->ci.hwnd, OBJID_CLIENT, iItem+1);

    ListView_DismissEdit(plv, TRUE);  // cancel edits

    ListView_OnSetItemState(plv, iItem, 0, LVIS_SELECTED);

    if (plv->iFocus == iItem)
        ListView_OnSetItemState(plv, (iItem == iCount - 1 ? iItem - 1 : iItem + 1), LVIS_FOCUSED, LVIS_FOCUSED);

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    if (!ListView_IsOwnerData(plv))
    {
        LISTITEM* pitem = ListView_FastGetItemPtr(plv, iItem);
        int iZ;

        if ((plv->rcView.left != RECOMPUTE) && ListView_IsSlotView(plv)) 
        {
            if (LV_IsItemOnViewEdge(plv, pitem)) 
            {
                plv->rcView.left = RECOMPUTE;
            }
        }

        ListView_RemoveItemFromItsGroup(plv, pitem);
    
        // We don't need to invalidate the item in report view because we
        // will be scrolling on top of it.
        //
        if (!ListView_IsReportView(plv))
            ListView_InvalidateItem(plv, iItem, FALSE, RDW_INVALIDATE | RDW_ERASE);

        // this notify must be done AFTER the Invalidate because some items need callbacks
        // to calculate the rect, but the notify might free it out
        ListView_Notify(plv, iItem, 0, LVN_DELETEITEM);

        // During the notify, the app might've done something to the listview
        // so revalidate the item number pointer so we don't fault
#ifdef DEBUG
        // Validate internally because DPA_DeletePtr will ASSERT if you ask it
        // to delete something that doesn't exist.
        if (!ListView_IsValidItemNumber(plv, iItem))
            pitem = NULL;
        else
#endif
            pitem = DPA_DeletePtr(plv->hdpa, iItem);

        if (!pitem)
        {
            RIPMSG(0, "Something strange happened during LVN_DELETEITEM; abandoning LVM_DELETEITEM");
            return FALSE;
        }

        plv->cTotalItems = DPA_GetPtrCount(plv->hdpa);

        // remove from the z-order, this is a lisearch to find this!

        DPA_DeletePtr(plv->hdpaZOrder, ListView_ZOrderIndex(plv, iItem));

        //
        // As the Z-order hdpa is a set of indexes we also need to decrement
        // all indexes that exceed the one we are deleting.
        //
        for (iZ = ListView_Count(plv) - 1; iZ >= 0; iZ--)
        {
            int iItemZ = (int)(UINT_PTR)DPA_FastGetPtr(plv->hdpaZOrder, iZ);
            if (iItemZ > iItem)
                DPA_SetPtr(plv->hdpaZOrder, iZ, IntToPtr(iItemZ - 1));
        }

        // remove from sub item DPAs if necessary

        if (plv->hdpaSubItems)
        {
            int iCol;
            for (iCol = plv->cCol - 1; iCol >= 0; iCol--)
            {
                HDPA hdpa = ListView_GetSubItemDPA(plv, iCol);
                if (hdpa) 
                {     // this is optional, call backs don't have them
                    PLISTSUBITEM plsi;

                    // These DPAs are tail sparse, so don't get upset if we
                    // try to delete something that's past the end of the list
#ifdef DEBUG
                    plsi = iItem < DPA_GetPtrCount(hdpa) ? DPA_DeletePtr(hdpa, iItem) : NULL;
#else
                    plsi = DPA_DeletePtr(hdpa, iItem);
#endif
                    ListView_FreeSubItem(plsi);
                }
            }
        }

        ListView_FreeItem(plv, pitem);  // ... finaly the item pointer

        if (plv->fGroupView && (plv->flags & LVF_REDRAW))
        {
            _ListView_RecomputeEx(plv, NULL, 0, TRUE);
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        }
    }
    else
    {
        //
        // simply notify and then fixup selection state and count
        //
        if ((iItem >= 0) && (iItem <= MAX_LISTVIEWITEMS))
        {
            ListView_Notify(plv, iItem, 0, LVN_DELETEITEM);

            if (FAILED(plv->plvrangeSel->lpVtbl->RemoveItem(plv->plvrangeSel, iItem)))
            {
                SetLastError(ERROR_OUTOFMEMORY);
                return FALSE;
            }
            plv->cTotalItems--;
            plv->rcView.left = RECOMPUTE;
            ListView_Recompute(plv);

            if (!ListView_IsReportView(plv) && !ListView_IsListView(plv))
            {
                // We need to erase the background so that the last item gets
                // erased in both icon modes and so that we don't leave turds
                // from wrapped labels in large icon mode.  This could be
                // optimized by only invalidating to the right of and below
                // the deleted item.
                InvalidateRect(plv->ci.hwnd, NULL, TRUE);
            }
        }
        else
        {
            return FALSE;
        }
    }

    iCount = ListView_Count(plv);       // regrab count incase someone updated item...

    if (!ListView_IsOwnerData(plv))
    {
        ASSERT(ListView_Count(plv) == DPA_GetPtrCount(plv->hdpaZOrder));
    }

    if (plv->iFocus == iItem) 
    {
        if (plv->iFocus >= iCount) 
        {
            plv->iFocus = iCount - 1;
        }
    } 
    
    if (plv->iFocus > iItem) 
    {
        plv->iFocus--;          // slide the focus index down
    }

    // same with the mark
    if (plv->iMark == iItem)  
    { 
        // deleted the mark item

        if (plv->iMark >= iCount) // did we nuke the last item?
            plv->iMark = iCount - 1;
    } 
    else if (plv->iMark > iItem)
        plv->iMark--;          // slide the mark index down

    // Free up the hot item
    if (plv->iHot == iItem)
        plv->iHot = -1;

    // Deleting an icon invalidates the icon positioning cache
    plv->iFreeSlot = -1;

    // HACK ALERT!! -- This construct with ReportView steals code from
    // ListView_OnUpdate.  Currently, it will work exactly the same as before,
    // EXCEPT, that it won't call ListView_OnUpdate.  This is to allow us to
    // send a flag to ListView_LRUpdateBelow to tell it we're scrolling up.
    //
    if (ListView_IsReportView(plv)) 
    {

        // if the new count is zero and we will be showing empty text, simply invalidate the
        // rect and redraw, else go through the invalidate below code...
        
        // we don't know if we are going to show empty text if pszEmptyText is NULL, or not
        // because we may get one through notify, so if iCount is 0 invalidate everything
        if (iCount == 0)
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        else
            ListView_LRInvalidateBelow(plv,iItem,1);



        if (ListView_RedrawEnabled(plv))
            ListView_UpdateScrollBars(plv);
        else {
            //
            // Special case code to make using SetRedraw work reasonably well
            // for adding items to a listview which is in a non layout mode...
            //
            if ((plv->iFirstChangedNoRedraw != -1) && (iItem < plv->iFirstChangedNoRedraw))
                plv->iFirstChangedNoRedraw--;
        }
    }
    else 
    {
        if (ListView_RedrawEnabled(plv))
            ListView_OnUpdate(plv, iItem);

        else
        {
            ListView_LRInvalidateBelow(plv, iItem, 0);
            //
            // Special case code to make using SetRedraw work reasonably well
            // for adding items to a listview which is in a non layout mode...
            //
            if ((plv->iFirstChangedNoRedraw != -1) && (iItem < plv->iFirstChangedNoRedraw))
                plv->iFirstChangedNoRedraw--;
        }
    }
    ListView_RecalcRegion(plv, TRUE, TRUE);

    return TRUE;
}

void ListView_DeleteAllGroupItems(LV* plv)
{
    if (plv->hdpaGroups)
    {
        int iGroup, cGroups = DPA_GetPtrCount(plv->hdpaGroups);
        for (iGroup = 0; iGroup < cGroups; iGroup++)
        {
            LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
            DPA_Destroy(pgrp->hdpa);
            pgrp->hdpa = DPA_Create(5);
        }
    }
}

BOOL ListView_OnDeleteAllItems(LV* plv)
{
    int i;
    BOOL bAlreadyNotified;
    BOOL fHasItemData = !ListView_IsOwnerData(plv);
    
    ListView_DismissEdit(plv, TRUE);    // cancel edits
    ListView_DeleteAllGroupItems(plv);
    
    // Must neutralize the focus because some apps will call
    // ListView_OnGetNextItem(LVNI_FOCUSED) during delete notifications,
    // so we need to make sure the focus is in a safe place.
    // May as well neutralize the mark, too.
    plv->iMark = plv->iFocus = -1;
    
    // Also nuke the icon positioning cache
    plv->iFreeSlot = -1;

    // Since we delete all items, There is no insertion slot!
    plv->iInsertItem = -1;
    
    bAlreadyNotified = (BOOL)ListView_Notify(plv, -1, 0, LVN_DELETEALLITEMS);
    
    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);
    
    if (fHasItemData || !bAlreadyNotified)
    {
        for (i = ListView_Count(plv) - 1; i >= 0; i--)
        {
            if (!bAlreadyNotified)
                ListView_Notify(plv, i, 0, LVN_DELETEITEM);
            
            if (fHasItemData)
            {
                ListView_FreeItem(plv, ListView_FastGetItemPtr(plv, i));
                //
                //  CAREFUL!  Applications such as NT Backup call back
                //  into ListView during the LVN_DELETEITEM notification,
                //  so we need to kill this item or we will fault at the
                //  next iteration because everybody relies on
                //  ListView_Count for validation.
                //
                DPA_FastDeleteLastPtr(plv->hdpa);
                plv->cTotalItems--;
            }
        }
    }
    
    if (ListView_IsOwnerData(plv))
    {
        if (FAILED(plv->plvrangeSel->lpVtbl->Clear(plv->plvrangeSel)))
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }
        plv->cTotalItems = 0;
    }
    else
    {
        DPA_DeleteAllPtrs(plv->hdpa);
        DPA_DeleteAllPtrs(plv->hdpaZOrder);
        plv->cTotalItems = 0;
        
        if (plv->hdpaSubItems)
        {
            int iCol;
            for (iCol = plv->cCol - 1; iCol >= 0; iCol--)
            {
                HDPA hdpa = ListView_GetSubItemDPA(plv, iCol);
                if (hdpa)
                {
                    DPA_EnumCallback(hdpa, ListView_FreeColumnData, 0);
                    DPA_DeleteAllPtrs(hdpa);
                }
            }
        }
    }
    
    plv->rcView.left = RECOMPUTE;
    plv->xOrigin = 0;
    plv->nSelected = 0;
    
    plv->ptlRptOrigin.x = 0;
    plv->ptlRptOrigin.y = 0;
    
    // reset the cxItem width
    if (!(plv->flags & LVF_COLSIZESET))
    {
        plv->cxItem = ListView_ComputeCXItemSize(plv);
    }
    
    RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
    ListView_UpdateScrollBars(plv);
    
    return TRUE;
}

int ListView_IFindNearestItem(LV* plv, int left, int top, UINT vk)
{
    int iMin = -1;
    
    if (ListView_IsOwnerData(plv))
    {
        POINT pt;
        int cSlots;
        int   iWidth = 0, iHeight = 0;
        
        ASSERT(!ListView_IsReportView(plv) && !ListView_IsListView(plv));
        
        pt.x = left + plv->ptOrigin.x;
        pt.y = top + plv->ptOrigin.y;
        
        cSlots = ListView_GetSlotCount(plv, TRUE, &iWidth, &iHeight);
        iMin = ListView_CalcHitSlot(plv, pt, cSlots, iWidth, iHeight);
        
        switch(vk)
        {
        case VK_HOME:
            iMin = 0;
            break;
            
        case VK_END:
            iMin = ListView_Count(plv) - 1;
            break;
            
        case VK_LEFT:
            if (iMin % cSlots)
                iMin -= 1;
            break;
            
        case VK_RIGHT:
            if ((iMin + 1) % cSlots)
                iMin += 1;
            break;
            
        case VK_UP:
            if (iMin >= cSlots)
                iMin -= cSlots;
            break;
            
        case VK_DOWN:
            if (iMin + cSlots < ListView_Count(plv))
                iMin += cSlots;
            break;
            
        default: ;
        }
        
        iMin = max(0, iMin);
        iMin = min(ListView_Count(plv) - 1, iMin);
        
    }
    else
    {
        ULONGLONG dMin = 0;
        int cyItem;
        int yEnd = 0, yLimit = 0, xEnd = 0;
        int iCount;
        int i;
        
        if (ListView_UseLargeIcons(plv)) 
        {
            cyItem = plv->cyIcon;
        } 
        else 
        {
            cyItem = plv->cyItem;
        }
        
        iCount = ListView_Count(plv);
        if (iCount == 1)
            return 0;
        
        if (vk == VK_HOME)
        {
            yEnd = yLimit = plv->rcView.bottom;
            xEnd = plv->rcView.right;
        }
        else if (vk == VK_END)
        {
            yEnd = yLimit = plv->rcView.top;
            xEnd = plv->rcView.left;
        }
        for (i = 0; i < iCount; i++)
        {
            RECT rc;
            int dx;
            ULONGLONG dxAbs, dyAbs, dOffset;
            int dy;
            
            ListView_GetRects(plv, i, QUERY_DEFAULT, &rc, NULL, NULL, NULL);
            
            dx = rc.left - left;
            dxAbs = (ULONGLONG)(dx < 0 ? -dx : dx);
            dy = rc.top - top;
            dyAbs = (ULONGLONG)(dy < 0 ? -dy : dy);
            
            if ((vk == VK_LEFT) && (dxAbs < dyAbs || dx >= 0))
                continue;
            else if ((vk == VK_RIGHT) && (dxAbs < dyAbs || dx <= 0))
                continue;
            else if ((vk == VK_UP) && (dxAbs > dyAbs || dy >= 0))
                continue;
            else if ((vk == VK_DOWN) && (dxAbs > dyAbs || dy <= 0))
                continue;
            
            if (vk == VK_HOME || vk == VK_END)
            {
                // home is not the nearest to the top corner, it's the leftmost of the top row.
                // ditto (reversed) for end.  thus we can't use the stuff below. bummer
                if (vk == VK_HOME)
                {
                    if ((rc.top + cyItem < yEnd) ||  // if it's fully above the highest line so, take it!
                        ((rc.top < yLimit) &&  // if it's on the same row as the top item to date
                        (rc.left < xEnd)))
                    {
                        iMin = i;
                        xEnd = rc.left;
                        yEnd = rc.top;
                        if (rc.top + cyItem < yLimit)
                            yLimit = rc.top + cyItem;
                    }
                }
                else
                {
                    if ((rc.top > yEnd) || //if it's full below the lowest row
                        ((rc.top + cyItem > yLimit) && // if it's on the same row
                        (rc.right > xEnd)))
                    {
                        iMin = i;
                        xEnd = rc.right;
                        yEnd = rc.top;
                        if (rc.top > yLimit)
                            yLimit = rc.top;
                    }
                }
            }
            else
            {
                dOffset = ((dxAbs * dxAbs) + (dyAbs * dyAbs));
                if (iMin == -1 || (dMin > dOffset))
                {
                    dMin = dOffset;
                    iMin = i;
                }
            }
        }
    }
    return iMin;
}

int ListView_Arrow(LV* plv, int iStart, UINT vk)
{
    RECT rcFocus;
    int i;
    int dx;
    int iCount;

    //
    // The algorithm to find which item depends if we are in a view
    // that is arrange(layout) oriented or a sorted (list) view.
    // For the sorted views we will use some optimizations to make
    // it faster
    //
    iCount = ListView_Count(plv);
    if ((ListView_IsReportView(plv) || ListView_IsListView(plv)) && !plv->fGroupView)
    {
        //
        // For up and down arrows, simply increment or decrement the
        // index.  Note: in listview this will cause it to wrap columns
        // which is fine as it is compatible with the file manager
        //
        // Assumes only one of these flags is set...

        switch (vk)
        {
        case VK_LEFT:
            if (ListView_IsReportView(plv))
            {
                ListView_ROnScroll(plv, (GetAsyncKeyState(VK_CONTROL) < 0) ? SB_PAGELEFT : SB_LINELEFT, 0, SB_HORZ);
            }
            else
                iStart -= plv->cItemCol;
            break;

        case VK_RIGHT:
            if (ListView_IsReportView(plv))
            {
                // Make this horizontally scroll the report view
                ListView_ROnScroll(plv, (GetAsyncKeyState(VK_CONTROL) < 0) ? SB_PAGERIGHT : SB_LINERIGHT, 0, SB_HORZ);
            }
            else
                iStart += plv->cItemCol;
            break;

        case VK_UP:
            iStart--;
            break;

        case VK_DOWN:
            iStart++;
            break;

        case VK_HOME:
            iStart = 0;
            break;

        case VK_END:
            iStart = iCount -1;
            break;

        case VK_NEXT:
            if (ListView_IsReportView(plv))
            {
                i = iStart; // save away to make sure we dont go wrong way!

                // First go to end of page...
                iStart = (int)(((LONG)(plv->sizeClient.cy - (plv->cyItem)
                        - plv->yTop) + plv->ptlRptOrigin.y) / plv->cyItem);

                // If Same item, increment by page size.
                if (iStart <= i)
                    iStart = i + max(
                            (plv->sizeClient.cy - plv->yTop)/ plv->cyItem - 1,
                            1);

                if (iStart >= iCount)
                    iStart = iCount - 1;
            }
            else
            {
                // multiply by 2/3 to give a good feel.. when the item is mostly shown
                // you want to go to the next column
                dx = (plv->sizeClient.cx + (plv->cxItem*2)/3) / plv->cxItem;
                if (!dx)
                    dx = 1;

                iStart += plv->cItemCol *  dx;
                if (plv->cItemCol)
                {
                    while (iStart >= iCount)
                        iStart -= plv->cItemCol;
                }
            }
            break;

        case VK_PRIOR:

            if (ListView_IsReportView(plv))
            {
                i = iStart; // save away to make sure we dont go wrong way!

                // First go to end of page...
                iStart = (int)(plv->ptlRptOrigin.y / plv->cyItem);

                // If Same item, increment by page size.
                if (iStart >= i)
                    iStart = i - max(
                            (plv->sizeClient.cy - plv->yTop)/ plv->cyItem - 1,
                            1);

                if (iStart < 0)
                    iStart = 0;
            }
            else
            {
                dx = (plv->sizeClient.cx + (plv->cxItem*2)/3) / plv->cxItem;
                if (!dx)
                    dx = 1;
                iStart -= plv->cItemCol * dx;
                if (plv->cItemCol)
                {
                    while (iStart < 0)
                        iStart += plv->cItemCol;
                }

            }
            break;

        default:
            return -1;      // Out of range
        }

        // Make sure it is in range!.
        if ((iStart >= 0) && (iStart < iCount))
            return iStart;
        else if (iCount == 1)
            return 0;
        else
            return -1;
    }

    else
    {
        //
        // Layout type view. we need to use the position of the items
        // to figure out the next item
        //

        if (ListView_IsOwnerData(plv))
        {
          iStart = max(0, iStart);

            // if it does not matches any of the entries in the case statement below
            // this is done to skip the call back by the GetRects
            //
            if (vk != VK_LEFT  &&
                    vk != VK_RIGHT &&
                    vk != VK_UP &&
                    vk != VK_DOWN &&
                    vk != VK_HOME &&
                    vk != VK_END &&
                    vk != VK_NEXT &&
                    vk != VK_PRIOR)
            {
                return -1;
            }
            ListView_GetRects(plv, iStart, QUERY_DEFAULT, &rcFocus, NULL, NULL, NULL);
        }
        else
        {
            if (iStart != -1)
            {
                ListView_GetRects(plv, iStart, QUERY_DEFAULT, &rcFocus, NULL, NULL, NULL);
            }
        }

        switch (vk)
        {
        // For standard arrow keys just fall out of here.
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            if (ListView_IsOwnerData(plv))
            {
                break;
            }
            else
            {
                if (iStart != -1)
                {
                    // all keys map to VK_HOME except VK_END
                    break;
                }

                // Fall through
                vk = VK_HOME;
            }

        case VK_HOME:
            rcFocus.left = - plv->ptOrigin.x;
            rcFocus.top = - plv->ptOrigin.y;
            break;

        case VK_END:
            rcFocus.left = plv->rcView.right;
            rcFocus.top = plv->rcView.bottom;
            break;

        case VK_NEXT:
            rcFocus.top += plv->sizeClient.cy;
            vk = VK_UP;
            break;

        case VK_PRIOR:
            vk = VK_DOWN;
            rcFocus.top -= plv->sizeClient.cy;
            break;
        default:
            return -1;      // Out of range
        }

        return ListView_IFindNearestItem(plv, rcFocus.left, rcFocus.top, vk);
    }
}

int ListView_OnGetNextItem(LV* plv, int i, UINT flags)
{
    int iStart = i;
    int cItemMax = ListView_Count(plv);

    // Note that -1 is a valid starting point
    if (i < -1 || i >= cItemMax)
        return -1;

    if (ListView_IsOwnerData(plv))
    {
        if (flags & (LVNI_CUT | LVNI_DROPHILITED | LVNI_PREVIOUS))
        {
            return -1;
        }
    }

    if (flags & LVNI_FOCUSED)
    {
        // we know which item is focused, jump right to it.
        // but we have to mimick the code below exactly for compat:
        //     if directional bits are set, they take precedence.
        if (!(flags & (LVNI_ABOVE | LVNI_BELOW | LVNI_TORIGHT | LVNI_TOLEFT)))
        {
            // there are no more focused items after iFocus
            if (i >= plv->iFocus)
                return -1;

            // subtract one here -- we increment it below
            i = plv->iFocus - 1;
        }
    }

    while (TRUE)
    {
        if (flags & (LVNI_ABOVE | LVNI_BELOW | LVNI_TORIGHT | LVNI_TOLEFT))
        {
            UINT vk;
            if (flags & LVNI_ABOVE)
                vk = VK_UP;
            else if (flags & LVNI_BELOW)
                vk = VK_DOWN;
            else if (flags & LVNI_TORIGHT)
                vk = VK_RIGHT;
            else
                vk = VK_LEFT;

            if (i != -1)
                i = ListView_Arrow(plv, i, vk);
            if (i == -1)
                return i;

        }
        else
        {
            i++;
            if (i == cItemMax)
                return -1;
        }

        // See if any other restrictions are set
        if (flags & ~(LVNI_ABOVE | LVNI_BELOW | LVNI_TORIGHT | LVNI_TOLEFT))
        {
            WORD wItemState;

            if (ListView_IsOwnerData(plv))
            {
                if (flags & LVNI_FOCUSED)
                {
                    // we check LVNI_FOCUSED before the loop, so i == iFocus
                    ASSERT(i == plv->iFocus && i != -1);
                    if (flags & LVNI_SELECTED)
                    {
                        if (plv->plvrangeSel->lpVtbl->IsSelected(plv->plvrangeSel, i) != S_OK)
                        {
                            i = -1;
                        }
                    }
                }
                else if (flags & LVNI_SELECTED)
                {
                    i = max(i, 0);
                    plv->plvrangeSel->lpVtbl->NextSelected(plv->plvrangeSel, i, &i);
                }
                else
                {
                    i = -1;
                }
            }
            else
            {
                {
                    LISTITEM* pitem = ListView_FastGetItemPtr(plv, i);
                    wItemState = pitem->state;
                }

                // for LVNI_FOCUSED, we start at the LVIS_FOCUSED element, if we're
                // not on that element, one of the below continues was hit, so
                // we'll never find the element. bail out early.
                if ((flags & LVNI_FOCUSED) && !(wItemState & LVIS_FOCUSED))
                {
                    ASSERT(i == plv->iFocus || i == plv->iFocus+1);
                    return -1;
                }

                if (((flags & LVNI_SELECTED) && !(wItemState & LVIS_SELECTED)) ||
                    ((flags & LVNI_CUT) && !(wItemState & LVIS_CUT)) ||
                    ((flags & LVNI_DROPHILITED) && !(wItemState & LVIS_DROPHILITED)))
                {
                    if (i != iStart)
                        continue;
                    else 
                    {
                        // we've looped and we can't find anything to fit this criteria
                        return -1;
                    }
                }
            }
        }
        return i;
    }
}

int ListView_CompareString(LV* plv, int i, LPCTSTR pszFind, UINT flags, int iLen)
{
    // REARCHITECT: non protected globals
    int cb;
    TCHAR ach[CCHLABELMAX];
    LV_ITEM item;

    ASSERT(!ListView_IsOwnerData(plv));
    ASSERT(pszFind);

    item.iItem = i;
    item.iSubItem = 0;
    item.mask = LVIF_TEXT;
    item.pszText = ach;
    item.cchTextMax = ARRAYSIZE(ach);
    ListView_OnGetItem(plv, &item);

    if (!(flags & (LVFI_PARTIAL | LVFI_SUBSTRING)))
        return lstrcmpi(item.pszText, pszFind);

    // FEATURE: LVFI_SUBSTRING is not really implemented yet.

    cb = lstrlen(pszFind);
    if (iLen && (cb > iLen))
    {
        cb = iLen;
    }

    //
    // If the sub strings not equal then return the ordering based
    // on the entire string.
    //
#ifndef UNIX
    return IntlStrEqNI(item.pszText, pszFind, cb) ? 0 : lstrcmp(item.pszText, pszFind);
#else
    return IntlStrEqNI(item.pszText, pszFind, cb) ? 0 : lstrcmpi(item.pszText, pszFind);
#endif

}

#ifdef UNICODE
int ListView_OnFindItemA(LV* plv, int iStart, LV_FINDINFOA * plvfi)
{
    LPWSTR pszW = NULL;
    LPCSTR pszC = NULL;
    int iRet;

    //HACK ALERT -- this code assumes that LV_FINDINFOA is exactly the same
    // as LV_FINDINFOW except for the pointer to the string.
    COMPILETIME_ASSERT(sizeof(LV_FINDINFOA) == sizeof(LV_FINDINFOW));

    if (!plvfi)
        return -1;

    if (!(plvfi->flags & LVFI_PARAM) && !(plvfi->flags & LVFI_NEARESTXY))
    {
        pszC = plvfi->psz;
        if ((pszW = ProduceWFromA(plv->ci.uiCodePage, pszC)) == NULL)
            return -1;
        plvfi->psz = (LPSTR)pszW;
    }

    iRet = ListView_OnFindItem(plv, iStart, (const LV_FINDINFO *)plvfi);

    if (pszW != NULL)
    {
        plvfi->psz = pszC;

        FreeProducedString(pszW);
    }

    return iRet;
}
#endif

int ListView_OnFindItem(LV* plv, int iStart, const LV_FINDINFO* plvfi)
{
    int i;
    int j;
    int cItem;
    UINT flags;

    if (!plvfi)
        return -1;

    if (plvfi->flags & LVFI_NEARESTXY) 
    {
        if (ListView_IsSlotView(plv)) 
        {
            return ListView_IFindNearestItem(plv, plvfi->pt.x, plvfi->pt.y, plvfi->vkDirection);
        } 
        else
            return -1;
    }

    // Note that -1 is a valid starting point
    if (iStart < -1 || iStart >= ListView_Count(plv))
        return -1;

    if (ListView_IsOwnerData(plv))
    {
        // call back to owner for search
        return (int) ListView_RequestFindItem(plv, plvfi, iStart + 1);
    }
    else
    {
        flags  = plvfi->flags;
        i = iStart;
        cItem = ListView_Count(plv);
        if (flags & LVFI_PARAM)
        {
            LPARAM lParam = plvfi->lParam;

            // Lisearch with wraparound...
            //
            for (j = cItem; j-- != 0;)
            {
                ++i;
                if (i == cItem)
                {
                    if (flags & LVFI_WRAP)
                        i = 0;
                    else
                        break;
                }

                if (ListView_FastGetItemPtr(plv, i)->lParam == lParam)
                    return i;
            }
        }
        else // if (flags & (LVFI_STRING | LVFI_SUBSTRING | LVFI_PARTIAL))
        {
            LPCTSTR pszFind = plvfi->psz;
            if (!pszFind)
                return -1;

            if (plv->ci.style & (LVS_SORTASCENDING | LVS_SORTDESCENDING))
                return ListView_LookupString(plv, pszFind, flags, i + 1);

            for (j = cItem; j-- != 0;)
            {
                ++i;
                if (i == cItem)
                {
                    if (flags & LVFI_WRAP)
                        i = 0;
                    else
                        break;
                }

                if (ListView_CompareString(plv,
                                           i,
                                           pszFind,
                                           (flags & (LVFI_PARTIAL | LVFI_SUBSTRING)), 0) == 0)
                {
                    return i;
                }
            }
        }
    }
    return -1;
}

BOOL ListView_OnGetItemRect(LV* plv, int i, RECT* prc)
{
    LPRECT pRects[LVIR_MAX];

    // validate parameters
    if (!ListView_IsValidItemNumber(plv, i))
    {
        RIPMSG(0, "LVM_GETITEMRECT: invalid index %d", i);
        return FALSE;
    }

    if (!prc || prc->left >= LVIR_MAX || prc->left < 0)
    {
        RIPMSG(0, "LVM_GETITEMRECT: invalid rect pointer");
        return FALSE;
    }

    pRects[0] = NULL;
    pRects[1] = NULL;
    pRects[2] = NULL;
    pRects[3] = NULL;

    pRects[prc->left] = prc;
    ListView_GetRects(plv, i, QUERY_DEFAULT, pRects[LVIR_ICON], pRects[LVIR_LABEL],
                      pRects[LVIR_BOUNDS], pRects[LVIR_SELECTBOUNDS]);
    return TRUE;
}

//
// in:
//      plv
//      iItem           MUST be a valid item index (in range)
// out:
//   prcIcon            icon bounding rect
//   prcLabel           label text bounding rect, for details this is the first column
//   prcBounds          entire item (all text and icon), including columns in details
//   prcSelectionBounds union of icon and label rects, does NOT include columns
//                      in details view

// REARCHITECT raymondc - Need to pass an HDC parameter for measurement
// since sometimes we do this while painting

// This returns rects in Window Coordinates
void ListView_GetRects(LV* plv, int iItem, UINT fQueryLabelRects, 
                       RECT* prcIcon, RECT* prcLabel, RECT* prcBounds,
                       RECT* prcSelectBounds)
{
    ASSERT(plv);
    
    if (ListView_IsReportView(plv))
    {
        ListView_RGetRects(plv, iItem, prcIcon, prcLabel, prcBounds, prcSelectBounds);
    }
    else if (ListView_IsListView(plv))
    {
        ListView_LGetRects(plv, iItem, prcIcon, prcLabel, prcBounds, prcSelectBounds);
    }
    else
    {
        if (ListView_IsOwnerData(plv))
        {
            RECT rcIcon;
            RECT rcTextBounds;
            LISTITEM item;
            
            if (ListView_IsIconView(plv))
                ListView_IGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, &item, FALSE);
            else if (ListView_IsSmallView(plv))
                ListView_SGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, &item, FALSE);
            else if (ListView_IsTileView(plv))
                ListView_TGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, &item, FALSE);
            
            if (prcIcon)
                *prcIcon = rcIcon;
            if (prcLabel)
                *prcLabel = rcTextBounds;
            
            if (prcBounds)
                UnionRect(prcBounds, &rcIcon, &rcTextBounds);
            
            if (prcSelectBounds)
                UnionRect(prcSelectBounds, &rcIcon, &rcTextBounds);
        }
        else
        {
            if (iItem >= ListView_Count(plv))
            {
                return;
            }
            else
            {
                LISTITEM *pitem = ListView_FastGetItemPtr(plv, iItem);
                
                if (pitem->cyFoldedLabel == SRECOMPUTE)
                {
                    _ListView_RecomputeLabelSize(plv, pitem, iItem, NULL, FALSE);
                }
                _ListView_GetRectsFromItem(plv, ListView_IsSmallView(plv), pitem, fQueryLabelRects,
                    prcIcon, prcLabel, prcBounds, prcSelectBounds);
            }
        }
    }
}

void ListView_GetRectsOwnerData(LV* plv, int iItem,
                                RECT* prcIcon, RECT* prcLabel, RECT* prcBounds,
                                RECT* prcSelectBounds, LISTITEM* pitem)
{
    ASSERT(plv);
    ASSERT(ListView_IsOwnerData(plv));
    
    if (ListView_IsReportView(plv))
    {
        ListView_RGetRects(plv, iItem, prcIcon, prcLabel, prcBounds,
            prcSelectBounds);
    }
    else if (ListView_IsListView(plv))
    {
        ListView_LGetRects(plv, iItem, prcIcon, prcLabel, prcBounds,
            prcSelectBounds);
    }
    else
    {
        RECT rcIcon;
        RECT rcTextBounds;
        
        if (ListView_IsIconView(plv))
            ListView_IGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, pitem, TRUE);
        else if (ListView_IsSmallView(plv))
            ListView_SGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, pitem, TRUE);
        else if (ListView_IsTileView(plv))
            ListView_TGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, pitem, TRUE);
        
        // Don't need to check for folding here, as will have been handled in user data
        // rectangle fetching functions.
        
        if (prcIcon)
            *prcIcon = rcIcon;
        if (prcLabel)
            *prcLabel = rcTextBounds;
        
        if (prcBounds)
            UnionRect(prcBounds, &rcIcon, &rcTextBounds);
        
        if (prcSelectBounds)
            UnionRect(prcSelectBounds, &rcIcon, &rcTextBounds);
    }
}


BOOL ListView_OnRedrawItems(LV* plv, int iFirst, int iLast)
{
    int iCount = ListView_Count(plv);

    if (iFirst < iCount)
    {
        if (iLast >= iCount)
            iLast = iCount - 1;

        while (iFirst <= iLast)
            ListView_InvalidateItem(plv, iFirst++, FALSE, RDW_INVALIDATE | RDW_ERASE);
    }
    return TRUE;
}

// fSelectionOnly       use the selection bounds only, ie. don't include
//                      columns in invalidation if in details view
//
void ListView_InvalidateItemEx(LV* plv, int iItem, BOOL fSelectionOnly,
    UINT fRedraw, UINT maskChanged)
{
    RECT rc;
    LPRECT prcIcon;
    LPRECT prcLabel;
    LPRECT prcBounds;
    LPRECT prcSelectBounds;
    LISTITEM* pitem = NULL;

    if (iItem == -1)
        return;

    // Ok if NULL
    if (plv->hdpa)
        pitem = ListView_GetItemPtr(plv, iItem);


    prcIcon = prcLabel = prcBounds = prcSelectBounds = NULL;

    // if we're in owner draw mode, and there's been a new font,
    // we don't really know what the selection bounds is, so always use the bounds
    // in that case... unless we're in fullrowselect mode
    if (ListView_IsOwnerData(plv) && plv->flags & LVF_CUSTOMFONT &&
       !ListView_FullRowSelect(plv)) 
    {
        fSelectionOnly = FALSE;
    }

    // if we're owner draw, there's no such thing as selection only
    if (plv->ci.style & LVS_OWNERDRAWFIXED)
        fSelectionOnly = FALSE;

    if (fSelectionOnly) 
    {
        // In report mode non-fullrowselect,
        // we have to use the full label rectangle rather
        // than just the selection bounds, since the stuff outside the
        // rectangle might need redrawing, too.

        if (ListView_IsReportView(plv) && !ListView_FullRowSelect(plv))
            prcLabel = &rc;
        else
            prcSelectBounds = &rc;
    } 
    else 
    {
        // if _only_the_text_ or _only_the_image_ changed then limit the redraw
        switch (maskChanged) 
        {

        case LVIF_IMAGE:
            prcIcon = &rc;
            break;

        case LVIF_TEXT:
            prcLabel = &rc;
            break;

        default:
            prcBounds = &rc;
            break;
        }
    }

    if (ListView_RedrawEnabled(plv)) 
    {
        ListView_GetRects(plv, iItem, QUERY_DEFAULT,
            prcIcon, prcLabel, prcBounds, prcSelectBounds);

        if (RECTS_IN_SIZE(plv->sizeClient, rc))
        {
            if (ListView_IsBorderSelect(plv))
            {
                InflateRect(&rc, 4 + g_cxIconMargin, 4 + g_cyIconMargin);     // account for selection border and seperation since drawing otside of icon
                fRedraw |= RDW_ERASE;
            }

            // Affects only allowed if dubble buffering
            if (ListView_IsDoubleBuffer(plv))
            {
                if ((pitem && (pitem->state & LVIS_GLOW)))
                {
                    InflateRect(&rc, GLOW_EXPAND, GLOW_EXPAND);
                    fRedraw |= RDW_ERASE;
                }
            }

            ListView_DebugDrawInvalidRegion(plv, &rc, NULL);
            RedrawWindow(plv->ci.hwnd, &rc, NULL, fRedraw);
        }
    } 
    else 
    {
        // if we're not visible, we'll get a full
        // erase bk when we do become visible, so only do this stuff when
        // we're on setredraw false
        if (!(plv->flags & LVF_REDRAW)) 
        {

            // if we're invalidating that's new (thus hasn't been painted yet)
            // blow it off
            if ((plv->iFirstChangedNoRedraw != -1) &&
                (iItem >= plv->iFirstChangedNoRedraw)) 
            {
                return;
            }

            ListView_GetRects(plv, iItem, QUERY_DEFAULT, 
                prcIcon, prcLabel, prcBounds, prcSelectBounds);

            // Affects only allowed if dubble buffering
            if (ListView_IsDoubleBuffer(plv))
            {
                if (pitem && (pitem->state & LVIS_GLOW))
                {
                    InflateRect(&rc, GLOW_EXPAND, GLOW_EXPAND);
                    fRedraw |= RDW_ERASE;
                }
            }

            if (ListView_IsBorderSelect(plv))
            {
                InflateRect(&rc, 4 + g_cxIconMargin, 4 + g_cyIconMargin);     // account for selection border and seperation since drawing otside of icon
                fRedraw |= RDW_ERASE;
            }

            // if it had the erase bit, add it to our region
            if (RECTS_IN_SIZE(plv->sizeClient, rc))
            {
                HRGN hrgn = CreateRectRgnIndirect(&rc);

                ListView_InvalidateRegion(plv, hrgn);

                if (fRedraw & RDW_ERASE)
                    plv->flags |= LVF_ERASE;
            }
        }
    }
}

// this returns BF_* flags to indicate which if any edge the item I is touching
// or crossing...
UINT LV_IsItemOnViewEdge(LV* plv, LISTITEM* pitem)
{
    RECT rcItem;
    UINT uRet = 0;

    // as far as rcView goes, unfolded label rects determine edge-ness
    _ListView_GetRectsFromItem(plv, ListView_IsSmallView(plv), pitem, QUERY_RCVIEW|QUERY_UNFOLDED,
                               NULL, NULL, &rcItem, NULL);
    // translate from window coordinates to listview coordinate
    OffsetRect(&rcItem, plv->ptOrigin.x, plv->ptOrigin.y);
    // include the rcView buffer
    ListView_AddViewRectBuffer(plv, &rcItem);

    if (rcItem.right >= plv->rcView.right)
        uRet |= BF_RIGHT;

    if (rcItem.left <= plv->rcView.left)
        uRet |= BF_LEFT;

    if (rcItem.top <= plv->rcView.top)
        uRet |= BF_TOP;

    if (rcItem.bottom >= plv->rcView.bottom)
        uRet |= BF_BOTTOM;

    return uRet;
}

// Move pitem to x,y
// Update rcView to accomodate this if we can, or mark rcView for recomputation
void LV_AdjustViewRectOnMove(LV* plv, LISTITEM *pitem, int x, int y)
{
    plv->iFreeSlot = -1; // The "free slot" cache is no good once an item moves

    // if we have to recompute anyways, don't bother
    if (!ListView_IsOwnerData(plv))
    {
        if ((plv->rcView.left != RECOMPUTE) &&
            x != RECOMPUTE && y != RECOMPUTE &&
            pitem->cyFoldedLabel != SRECOMPUTE) 
        {
            RECT rcClient, rcAfter;
            RECT rcView = plv->rcView;

            // Our optimized move-adjust-rcView must maintain this, make sure it's true before we even start:
            ASSERT(ListView_ValidatercView(plv, &plv->rcView, FALSE));

            ListView_GetClientRect(plv, &rcClient, TRUE, NULL);
            ASSERT(ListView_ValidateScrollPositions(plv, &rcClient));

            if (pitem->pt.x != RECOMPUTE) 
            {
                UINT uEdges;

                uEdges = LV_IsItemOnViewEdge(plv, pitem);

                pitem->pt.x = x;
                pitem->pt.y = y;

                // before and after the move, they need to be touching the
                // same edges or not at all
                if (uEdges != LV_IsItemOnViewEdge(plv, pitem)) 
                {
                    goto FullRecompute;
                }
            } 
            else 
            {
                // if the position wasn't set before
                // we just need to find out what it is afterwards and
                // enlarge the view... we don't need to shrink it
                pitem->pt.x = x;
                pitem->pt.y = y;
            }

            _ListView_GetRectsFromItem(plv, ListView_IsSmallView(plv), pitem, QUERY_RCVIEW|QUERY_UNFOLDED,
                                       NULL, NULL, &rcAfter, NULL);
            // translate from window coordinates to listview coordinates
            OffsetRect(&rcAfter, plv->ptOrigin.x, plv->ptOrigin.y);

            // include the rcView buffer
            ListView_AddViewRectBuffer(plv, &rcAfter);

            // if we make it here, we just have to make sure the new view rect
            // encompases this new item
            UnionRect(&rcView, &rcView, &rcAfter);

            DebugMsg(TF_LISTVIEW, TEXT("Score! (%d %d %d %d) was (%d %d %d %d)"),
                     rcView.left, rcView.top, rcView.right, rcView.bottom,
                     plv->rcView.left, plv->rcView.top, plv->rcView.right, plv->rcView.bottom);

            // Our optimized move-adjust-rcView must maintain this:
            ASSERT(ListView_ValidatercView(plv, &rcView, FALSE));
            plv->rcView = rcView;

            // make sure our scroll positions are correct
            if (ListView_IsIScrollView(plv))
                ListView_FixIScrollPositions(plv, FALSE, &rcClient);
            ASSERT(ListView_ValidateScrollPositions(plv, &rcClient));
        } 
        else 
        {
FullRecompute:
            plv->rcView.left = RECOMPUTE;
        }
    }

    DebugMsg(TF_LISTVIEW, TEXT("LV -- AdjustViewRect pitem %d -- (%x, %x)"),
             pitem,
             pitem->pt.x, pitem->pt.y);

    pitem->pt.x = x;
    pitem->pt.y = y;

    // Compute the workarea of this item if applicable
    ListView_FindWorkArea(plv, pitem->pt, &(pitem->iWorkArea));
}

BOOL ListView_OnSetItemPosition(LV* plv, int i, int x, int y)
{
    LISTITEM* pitem;

    if (plv->fGroupView)
        return FALSE;

    if (ListView_IsListView(plv))
        return FALSE;

    if (ListView_IsOwnerData(plv))
    {
       RIPMSG(0, "LVM_SETITEMPOSITION: Invalid for owner-data listview");
       return FALSE;
    }

    pitem = ListView_GetItemPtr(plv, i);
    if (!pitem)
        return FALSE;

    //
    // this is a hack to fix a bug in OLE drag/drop loop
    //
    if (x >= 0xF000 && x < 0x10000)
    {
        DebugMsg(TF_LISTVIEW, TEXT("LV -- On SetItemPosition fixing truncated negative number 0x%08X"), x);
        x = x - 0x10000;
    }

    if (y >= 0xF000 && y < 0x10000)
    {
        DebugMsg(TF_LISTVIEW, TEXT("LV -- On SetItemPosition fixing truncated negative number 0x%08X"), y);
        y = y - 0x10000;
    }

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    if (pitem->cyFoldedLabel == SRECOMPUTE)
    {
        _ListView_RecomputeLabelSize(plv, pitem, i, NULL, FALSE);
    }

    // erase old

    if (y != pitem->pt.y || x != pitem->pt.x) 
    {
        // Don't invalidate if it hasn't got a position yet
        if (pitem->pt.y != RECOMPUTE) 
        {
            ListView_InvalidateItem(plv, i, FALSE, RDW_INVALIDATE | RDW_ERASE);
        } 
        else if (plv->uUnplaced) 
        {
            // this means an unplaced item got placed
            plv->uUnplaced--;
            if (!plv->uUnplaced) 
            {
                MSG msg;
                // if this is now 0, pull out the postmessage
                PeekMessage(&msg, plv->ci.hwnd, LVMI_PLACEITEMS, LVMI_PLACEITEMS, PM_REMOVE);
            }
        }

        if (y == RECOMPUTE) 
        {
            // if they're setting the new position to be a "any open spot" post that we
            // need to calc this later
            if (!plv->uUnplaced) 
            {
                PostMessage(plv->ci.hwnd, LVMI_PLACEITEMS, 0, 0);
            }
            plv->uUnplaced++;
        }
    }

    DebugMsg(TF_LISTVIEW, TEXT("LV -- On SetItemPosition %d %d %d %d -- (%x, %x)"),
             plv->rcView.left, plv->rcView.top, plv->rcView.right, plv->rcView.bottom,
             pitem->pt.x, pitem->pt.y);


    LV_AdjustViewRectOnMove(plv, pitem, x, y);

    // and draw at new position
    ListView_RecalcRegion(plv, FALSE, TRUE);
    ListView_InvalidateItem(plv, i, FALSE, RDW_INVALIDATE);

    // If autoarrange is turned on, do it now...
    if (ListView_RedrawEnabled(plv)) 
    {
        ListView_ArrangeOrSnapToGrid(plv);
        if (!(plv->ci.style & LVS_AUTOARRANGE))
            ListView_UpdateScrollBars(plv);
    }

    if (!(plv->ci.style & LVS_AUTOARRANGE))
    {
        plv->fIconsPositioned = TRUE;
    }

    return TRUE;
}

BOOL ListView_OnGetItemPosition(LV* plv, int i, POINT* ppt)
{
    LISTITEM* pitem;

    //
    // This needs to handle all views as it is used to figure out
    // where the item is during drag and drop and the like
    //
    if (!ppt)
    {
        RIPMSG(0, "LVM_GETITEMPOSITION: Invalid ppt = NULL");
        return FALSE;
    }

    if (ListView_IsListView(plv) || ListView_IsReportView(plv)
        || ListView_IsOwnerData(plv))
    {
        RECT rcIcon;
        ListView_GetRects(plv, i, QUERY_DEFAULT, &rcIcon, NULL, NULL, NULL);
        ppt->x = rcIcon.left;
        ppt->y = rcIcon.top;

    } 
    else 
    {

        pitem = ListView_GetItemPtr(plv, i);
        if (!pitem)
            return FALSE;

        if (pitem->pt.x == RECOMPUTE)
            ListView_Recompute(plv);

        ppt->x = pitem->pt.x;
        ppt->y = pitem->pt.y;
    }
    return TRUE;
}

BOOL ListView_OnGetOrigin(LV* plv, POINT* ppt)
{
    if (!ppt)
    {
        DebugMsg(DM_ERROR, TEXT("ListView_OnGetOrigin: ppt is NULL"));
        return FALSE;
    }

    if (ListView_IsListView(plv) || ListView_IsReportView(plv))
        return FALSE;

    *ppt = plv->ptOrigin;
    return TRUE;
}

int ListView_OnGetStringWidthA(LV* plv, LPCSTR psz, HDC hdc)
{
    LPWSTR pszW = NULL;
    int iRet;

    if (!psz)
        return 0;

    if ((psz != NULL) && (pszW = ProduceWFromA(plv->ci.uiCodePage, psz)) == NULL)
        return 0;

    iRet = ListView_OnGetStringWidth(plv, pszW, hdc);

    FreeProducedString(pszW);

    return iRet;
}

int ListView_OnGetStringWidth(LV* plv, LPCTSTR psz, HDC hdc)
{
    SIZE siz;
    HDC hdcFree = NULL;
    HFONT hfontPrev;

    if (!psz || psz == LPSTR_TEXTCALLBACK)
        return 0;

    if (!hdc) 
    {
        hdcFree = hdc = GetDC(plv->ci.hwnd);
    }

    hfontPrev = SelectFont(hdc, plv->hfontLabel);
    GetTextExtentPoint(hdc, psz, lstrlen(psz), &siz);
    SelectFont(hdc, hfontPrev);

    if (hdcFree) 
    {
        ReleaseDC(plv->ci.hwnd, hdcFree);
    }

    return siz.cx;
}

int ListView_OnGetColumnWidth(LV* plv, int iCol)
{
    if (ListView_IsReportView(plv))
        return ListView_RGetColumnWidth(plv, iCol);
    else if (ListView_IsListView(plv))
        return plv->cxItem;
    
    return 0;
}

BOOL ListView_ISetColumnWidth(LV* plv, int iCol, int cx, BOOL fExplicit)
{

    if (ListView_IsListView(plv))
    {
        if (iCol != 0 || cx <= 0)
            return FALSE;

        // if it's different and this is an explicit set, or we've never set it explicitly
        if (plv->cxItem != cx && (fExplicit || !(plv->flags & LVF_COLSIZESET)))
        {
            // REVIEW: Should optimize what gets invalidated here...

            plv->cxItem = cx;
            if (fExplicit)
                plv->flags |= LVF_COLSIZESET;   // Set the fact that we explictly set size!.

            if (ListView_IsLabelTip(plv))
            {
                // A truncated label may have been exposed or vice versa.
                ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);
            }

            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
            ListView_UpdateScrollBars(plv);
        }
        return TRUE;
    }
    else if (ListView_IsReportView(plv))
    {
        if (ListView_IsLabelTip(plv))
        {
            // A truncated label may have been exposed or vice versa.
            ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);
        }
        return ListView_RSetColumnWidth(plv, iCol, cx);
    }
    else
    {
        if (cx && plv->cxItem != cx && (fExplicit || !(plv->flags & LVF_COLSIZESET)))
        {
            // REVIEW: Should optimize what gets invalidated here...
            plv->cxItem = cx;
            if (fExplicit)
                plv->flags |= LVF_COLSIZESET;   // Set the fact that we explictly set size!.

            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
            ListView_UpdateScrollBars(plv);
        }
        // BUG-FOR-BUG COMPATIBILITY:  IE4 accidentally returned FALSE here.
    }
    return FALSE;
}

void DrawGradiantLine(HDC hdc, RECT* prcText, RECT* prcGroup)
{
    COLORREF cr1 = GetSysColor(COLOR_GRADIENTACTIVECAPTION);
    COLORREF cr2 = GetSysColor(COLOR_WINDOW);
    TRIVERTEX pt[2];
    GRADIENT_RECT gr;

    RECT rc = {prcGroup->left, prcText->bottom-1, prcGroup->left + GRADIENT_WIDTH, prcText->bottom};

    pt[0].x = rc.left;
    pt[0].y = rc.top;
    pt[1].x = rc.right;
    pt[1].y = rc.bottom;

    pt[0].Red = GetRValue(cr1) << 8;
    pt[0].Green = GetGValue(cr1) << 8;
    pt[0].Blue = GetBValue(cr1) << 8;
    pt[0].Alpha = 0xFF00;
    pt[1].Red = GetRValue(cr2) << 8;
    pt[1].Green = GetGValue(cr2) << 8;
    pt[1].Blue = GetBValue(cr2) << 8;
    pt[1].Alpha = 0x0000;


    gr.UpperLeft = 0;
    gr.LowerRight = 1;

    GdiGradientFill(hdc, pt, 2, &gr, 1, GRADIENT_FILL_RECT_H);

}

void ListView_Redraw(LV* plv, HDC hdc, RECT* prcClip)
{
    int i = 0;
    int cItem = ListView_Count(plv);
    NMCUSTOMDRAW nmcd;
    LVDRAWITEM lvdi = {0};

    SetBkMode(hdc, TRANSPARENT);
    SelectFont(hdc, plv->hfontLabel);

    nmcd.hdc = hdc;

    nmcd.rc = *prcClip;

    plv->ci.dwCustom = CICustomDrawNotify(&plv->ci, CDDS_PREPAINT, &nmcd);
    if (!(plv->ci.dwCustom & CDRF_SKIPDEFAULT)) 
    {
        int cGroups;
        // Just before doing any painting, see if the region is up to date...
        ListView_RecalcRegion(plv, FALSE, TRUE);

        //
        // For list view and report view, we can save a lot of time
        // by calculating the index of the first item that may need
        // painting...
        //

        switch (plv->wView) 
        {
        case LV_VIEW_DETAILS:
            if (!plv->fGroupView)
            {
                i = ListView_RYHitTest(plv, prcClip->top);
                cItem = ListView_RYHitTest(plv, prcClip->bottom) + 1;
            }
            break;

        case LV_VIEW_LIST:
            i = ListView_LCalcViewItem(plv, prcClip->left, prcClip->top);
            cItem = ListView_LCalcViewItem(plv, prcClip->right, prcClip->bottom) + 1;
            break;

        default:
            if (ListView_IsOwnerData(plv))
            {
                ListView_CalcMinMaxIndex(plv, prcClip, &i, &cItem);
                break;
            }
        }

        if (i < 0)
            i = 0;

        cItem = min(ListView_Count(plv), cItem);
        if (ListView_IsOwnerData(plv) && (cItem > i))
        {
            ListView_NotifyCacheHint(plv, i, cItem-1);
            ListView_LazyCreateWinEvents(plv, i, cItem-1);
        }

        lvdi.plv = plv;
        lvdi.nmcd.nmcd.hdc = hdc;
        lvdi.prcClip = prcClip;
        lvdi.pitem = NULL;

        if (plv->hdpaGroups)
        {
            cGroups = DPA_GetPtrCount(plv->hdpaGroups);

            if (plv->fGroupView && cGroups > 0 && ListView_IsGroupedView(plv))
            {
                int iGroup;
                RECT rcClient;
                GetClientRect(plv->ci.hwnd, &rcClient);

                for (iGroup = 0; iGroup < cGroups; iGroup++)
                {
                    LISTGROUP* pgrp = DPA_FastGetPtr(plv->hdpaGroups, iGroup);
                    int cItems = DPA_GetPtrCount(pgrp->hdpa);

                    if (cItems > 0)
                    {
                        RECT rcT;
                        RECT rc;

                        SetRect(&rc, 0,
                                     pgrp->rc.top - LISTGROUP_HEIGHT(plv, pgrp),
                                     rcClient.right,
                                     pgrp->rc.bottom + plv->rcBorder.bottom + plv->paddingBottom);

                        if (ListView_IsReportView(plv))
                        {
                            OffsetRect(&rc, -plv->ptlRptOrigin.x, -plv->ptlRptOrigin.y + plv->yTop);
                        }
                        else
                        {
                            OffsetRect(&rc, -plv->ptOrigin.x, -plv->ptOrigin.y);
                        }


                        if (IntersectRect(&rcT, &rc, prcClip))
                        {
                            NMLVCUSTOMDRAW nmcdGroup = {0};
                            DWORD dwCust;
                            UINT uAlign = LVCFMT_LEFT;
                            HFONT hfontOld;
                            RECT rcBorder = plv->rcBorder;
                            rcBorder.top = max(pgrp->cyTitle + 6, plv->rcBorder.top);
                            nmcdGroup.nmcd.hdc = hdc;
                            nmcdGroup.nmcd.rc = rc;
                            nmcdGroup.nmcd.dwItemSpec = pgrp->iGroupId;
                            nmcdGroup.dwItemType = LVCDI_GROUP;

                            nmcdGroup.rcText.left = rc.left + plv->paddingLeft;
                            nmcdGroup.rcText.top = rc.top;
                            nmcdGroup.rcText.bottom = rc.top + max(pgrp->cyTitle + 6, plv->rcBorder.top);
                            nmcdGroup.rcText.right = rc.right;

                            nmcdGroup.uAlign = pgrp->uAlign;

                            nmcdGroup.clrText = plv->crHeader;

                            dwCust = CICustomDrawNotify(&plv->ci, CDDS_PREPAINT, &nmcdGroup.nmcd);

                            if (!(dwCust & CDRF_SKIPDEFAULT))
                            {
                                RECT rcHeader = {0};
                                if (!(LVCDRF_NOGROUPFRAME & dwCust))
                                {
                                    DrawGradiantLine(hdc, &nmcdGroup.rcText, &nmcdGroup.nmcd.rc);
                                }

                                if (!(dwCust & CDRF_NEWFONT))
                                {
                                    hfontOld = SelectObject(hdc, plv->hfontGroup);
                                }

                                if (nmcdGroup.uAlign & LVGA_HEADER_CENTER)
                                    uAlign = LVCFMT_CENTER;
                                else if (nmcdGroup.uAlign & LVGA_HEADER_RIGHT)
                                    uAlign = LVCFMT_RIGHT;

                                SHDrawText(hdc, pgrp->pszHeader,
                                    &nmcdGroup.rcText, uAlign, SHDT_VCENTER | SHDT_LEFT,
                                    plv->cyLabelChar, plv->cxEllipses,
                                    nmcdGroup.clrText, CLR_NONE);

                                // Need do do this before we unselect so that we get the right font...
                                DrawText(hdc, pgrp->pszHeader, -1, &rcHeader, DT_LV | DT_CALCRECT);

                                if (!(dwCust & CDRF_NEWFONT))
                                {
                                    SelectObject(hdc, hfontOld);
                                }
                            }

                            dwCust = CICustomDrawNotify(&plv->ci, CDDS_POSTPAINT, &nmcdGroup.nmcd);
                        }
                    }
                }
            }
        }

        cItem = min(ListView_Count(plv), cItem);

        for (; i < cItem; i++)
        {
            BOOL bSuccess;
            int i2;

            if (ListView_IsRearrangeableView(plv) && 
                !ListView_IsOwnerData(plv))
            {
                LISTITEM *pitem;

                // Icon views: Draw back-to-front mapped through
                // Z-order array for proper Z order appearance - If autoarrange
                // is on, we don't need to do this as our arrange code is setup
                // to not overlap items!
                //
                // For the cases where we might have overlap, we sped this up,
                // by converting the hdpaZorder into a list of indexes instead
                // of pointers.  This ovoids the costly convert pointer to
                // index call.
                //
                i2 = (int)(UINT_PTR)DPA_FastGetPtr(plv->hdpaZOrder, (cItem - 1) -i);

                //
                // do a fast clip check on the item so we dont even try to
                // draw it unless it is visible
                //
                // for small icon view we cant clip on the left without
                // getting the text
                //
                // for large icon view we cant clip on the top without
                // getting the text
                //
                // for large icon view in NOLABELWRAP mode, we can't clip
                // on the top without getting the text, nor can we clip to
                // the left or right in case the text is long.
                //
                // we can always clip to the bottom
                //
                pitem = ListView_FastGetItemPtr(plv, i2);

                if (pitem && pitem->pt.x != RECOMPUTE)
                {
                    int yBias = 0;
                    if (ListView_IsBorderSelect(plv))
                        yBias = BORDERSELECT_THICKNESS;

                    if (pitem->pt.y - yBias - plv->ptOrigin.y > prcClip->bottom)
                        continue;

                    if (plv->wView == LV_VIEW_SMALLICON)
                    {
                        if (pitem->pt.x - plv->ptOrigin.x - plv->cxState > prcClip->right)
                            continue;

                        if (pitem->pt.y + yBias + plv->cyItem - plv->ptOrigin.y < prcClip->top)
                            continue;
                    }
                    else if (!(plv->ci.style & LVS_NOLABELWRAP))
                    {
                        if (plv->wView == LV_VIEW_TILE)
                        {
                            if (pitem->pt.x - plv->sizeTile.cx - plv->ptOrigin.x > prcClip->right)
                                continue;

                            if (pitem->pt.x + yBias + plv->sizeTile.cx - plv->ptOrigin.x < prcClip->left)
                                continue;
                        }
                        else // LV_VIEW_ICON
                        {
                            if (pitem->pt.x - plv->cxIconSpacing - plv->ptOrigin.x > prcClip->right)
                                continue;

                            if (pitem->pt.x + yBias + plv->cxIconSpacing - plv->ptOrigin.x < prcClip->left)
                                continue;
                        }
                    }
                }
                
               