 pEapolPkt)) != NO_ERROR)
                        {
                            break;
                        }
                    }
                }

                break;

            case EAPOLSTATE_HELD:
                TRACE0 (EAPOL, "ProcessReceivedPacket: HELD state, Ignoring packet");
                if (ReqId)
                {
                    // Deactivate current timer
                    RESTART_TIMER (pPCB->hTimer,
                            INFINITE_SECONDS,
                            "PCB",
                            &dwRetCode);
                    if (dwRetCode != NO_ERROR)
                    {
                        break;
                    }
                    if ((dwRetCode = FSMAcquired (pPCB,
                                                pEapolPkt)) != NO_ERROR)
                    {
                        break;
                    }
                }
                break;

            case EAPOLSTATE_AUTHENTICATED:
                TRACE0 (EAPOL, "ProcessReceivedPacket: STATE_AUTHENTICATED");
                if (ReqId)
                {
                    if ((dwRetCode = FSMAcquired (pPCB,
                                                pEapolPkt)) != NO_ERROR)
                    {
                        break;
                    }

                }
                else
                if (RxKey)
                {
                    if ((dwRetCode = FSMRxKey (pPCB,
                                                pEapolPkt)) != NO_ERROR)
                    {
                        break;
                    }
                }
                break;

            default:
                TRACE0 (EAPOL, "ProcessReceivedPacket: Critical Error. Invalid state, Ignoring packet");
                break;
        }

        // Only packet passing through switch statement will be freed here
        FREE (pEapolBuffer);

        RELEASE_WRITE_LOCK (&(pPCB->rwLock));

    } while (FALSE);

    
    // Post a new read request, ignoring errors
            
    ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));
    if (!EAPOL_PORT_ACTIVE(pPCB))
    {
        TRACE1 (EAPOL, "ProcessReceivedPacket: Port %s not active, not reposting read request",
                pPCB->pszDeviceGUID);
        // Port is not active, release Context buffer
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));
    }
    else
    {
        TRACE1 (EAPOL, "ProcessReceivedPacket: Reposting buffer on port %s",
                pPCB->pszDeviceGUID);
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));
        
        // ElReadFromPort creates a new context buffer, adds a ref count,
        // and posts the read request
        if ((dwRetCode = ElReadFromPort (
                                        pPCB,
                                        NULL,
                                        0
                                        )) != NO_ERROR)
        {
            TRACE1 (EAPOL, "ProcessReceivedPacket: Critical error: ElReadFromPort error %d",
                    dwRetCode);
            // LOG
        }
    }
    
    // Dereference ref count held for the read that was just processed
    EAPOL_DEREFERENCE_PORT(pPCB);
    TRACE2 (EAPOL, "ProcessReceivedPacket: pPCB= %p, RefCnt = %ld", 
            pPCB, pPCB->dwRefCount);

    TRACE0 (EAPOL, "ProcessReceivedPacket exit");

    return;
}


// 
// FSMDisconnected
//
// Description:
//      Function called when media disconnect occurs
//
// Arguments:
//      pPCB - Pointer to PCB for the port on which media disconnect occurs
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
FSMDisconnected (
        IN  EAPOL_PCB   *pPCB
        )
{
    DWORD           dwRetCode   = NO_ERROR;

    TRACE1 (EAPOL, "FSMDisconnected entered for port %s", pPCB->pszFriendlyName);

    do 
    {

    } while (FALSE);

    TRACE1 (EAPOL, "Setting state DISCONNECTED for port %s", pPCB->pszFriendlyName);

    pPCB->State = EAPOLSTATE_DISCONNECTED;

    // Free Identity buffer

    if (pPCB->pszIdentity != NULL)
    {
        FREE (pPCB->pszIdentity);
        pPCB->pszIdentity = NULL;
    }

    // Free Password buffer

    if (pPCB->pszPassword != NULL)
    {
        FREE (pPCB->pszPassword);
        pPCB->pszPassword = NULL;
    }

    // Free user-specific data in the PCB

    if (pPCB->pCustomAuthUserData != NULL)
    {
        FREE (pPCB->pCustomAuthUserData);
        pPCB->pCustomAuthUserData = NULL;
    }

    // Free connection data, though it is common to all users

    if (pPCB->pCustomAuthConnData != NULL)
    {
        FREE (pPCB->pCustomAuthConnData);
        pPCB->pCustomAuthConnData = NULL;
    }

    // Free SSID

    if (pPCB->pszSSID != NULL)
    {
        FREE (pPCB->pszSSID);
        pPCB->pszSSID = NULL;
    }

    pPCB->fGotUserIdentity = FALSE;

    TRACE1 (EAPOL, "FSMDisconnected completed for port %s", pPCB->pszFriendlyName);

    return dwRetCode;
}


// 
// FSMLogoff
//
// Description:
//      Function called to send out EAPOL_Logoff packet. Usually triggered by
//      user logging off.
//
// Arguments:
//      pPCB - Pointer to PCB for the port on which logoff packet is to be
//              sent out
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
FSMLogoff (
        IN  EAPOL_PCB   *pPCB
        )
{
    EAPOL_PACKET    *pEapolPkt  = NULL;
    DWORD           dwRetCode   = NO_ERROR;

    TRACE1 (EAPOL, "FSMLogoff entered for port %s", pPCB->pszFriendlyName);

    do 
    {
        // Allocate new buffer
        pEapolPkt = (EAPOL_PACKET *) MALLOC (sizeof (EAPOL_PACKET));
        if (pEapolPkt == NULL)
        {
            TRACE0 (EAPOL, "FSMLogoff: Error in allocating memory for EAPOL packet");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Fill in fields

        memcpy ((BYTE *)pEapolPkt->EthernetType, 
                (BYTE *)pPCB->bEtherType, 
                SIZE_ETHERNET_TYPE);
        pEapolPkt->ProtocolVersion = pPCB->bProtocolVersion;
        pEapolPkt->PacketType = EAPOL_Logoff;
        HostToWireFormat16 ((WORD)0, (BYTE *)pEapolPkt->PacketBodyLength);

        // Send packet out on the port
        dwRetCode = ElWriteToPort (pPCB,
                                    (CHAR *)pEapolPkt,
                                    sizeof (EAPOL_PACKET));
        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAPOL, "FSMLogoff: Error in writing Logoff pkt to port %ld",
                    dwRetCode);

            break;
        }

        // Mark that EAPOL_Logoff was sent out on the port
        pPCB->dwLogoffSent = 1;

    } while (FALSE);

    TRACE1 (EAPOL, "Setting state LOGOFF for port %s", pPCB->pszFriendlyName);

    pPCB->State = EAPOLSTATE_LOGOFF;

    // Free Identity buffer

    if (pPCB->pszIdentity != NULL)
    {
        FREE (pPCB->pszIdentity);
        pPCB->pszIdentity = NULL;
    }

    // Free Password buffer

    if (pPCB->pszPassword != NULL)
    {
        FREE (pPCB->pszPassword);
        pPCB->pszPassword = NULL;
    }

    // Free user-specific data in the PCB

    if (pPCB->pCustomAuthUserData != NULL)
    {
        FREE (pPCB->pCustomAuthUserData);
        pPCB->pCustomAuthUserData = NULL;
    }

    // Free connection data, though it is common to all users

    if (pPCB->pCustomAuthConnData != NULL)
    {
        FREE (pPCB->pCustomAuthConnData);
        pPCB->pCustomAuthConnData = NULL;
    }

    // Free SSID

    if (pPCB->pszSSID != NULL)
    {
        FREE (pPCB->pszSSID);
        pPCB->pszSSID = NULL;
    }

    pPCB->fGotUserIdentity = FALSE;

    if (pEapolPkt != NULL)
    {
        FREE (pEapolPkt);
        pEapolPkt = NULL;
    }

    TRACE1 (EAPOL, "FSMLogoff completed for port %s", pPCB->pszFriendlyName);

    return dwRetCode;
}


//
// FSMConnecting
//
// Description:
//
// Funtion called to send out EAPOL_Start packet. If MaxStart EAPOL_Start 
// packets have been sent out, State Machine moves to Authenticated state
//
// Arguments:
//      pPCB - Pointer to the PCB for the port on which Start packet is 
//      to be sent out
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
FSMConnecting (
        IN  EAPOL_PCB   *pPCB
        )
{
    EAPOL_PACKET    *pEapolPkt = NULL;
    DWORD           dwStartInterval = 0;               
    GUID            DeviceGuid;
    DWORD           dwRetCode = NO_ERROR;

    TRACE1 (EAPOL, "FSMConnecting entered for port %s", pPCB->pszFriendlyName);

#ifndef EAPOL_SERVICE

    ElStringToGuid (pPCB->pszDeviceGUID, &DeviceGuid);
    (VOID)EAPOLMANAuthenticationStarted (&DeviceGuid);

#endif

    do 
    {
        if (pPCB->State == EAPOLSTATE_CONNECTING)
        {
            // If PCB->State was Connecting earlier, increment ulStartCount 
            // else set ulStartCount to zero
    
            // Did not receive Req/Id
            if ((++(pPCB->ulStartCount)) > pPCB->EapolConfig.dwmaxStart)
            {
                // Deactivate start timer
                RESTART_TIMER (pPCB->hTimer,
                        INFINITE_SECONDS,
                        "PCB",
                        &dwRetCode);
                if (dwRetCode != NO_ERROR)
                {
                    break;
                }

                TRACE0 (EAPOL, "FSMConnecting: Sent out maxStart with no response, Setting AUTHENTICATED state");

                // Sent out enough EAPOL_Starts
                // Go into authenticated state
                if ((dwRetCode = FSMAuthenticated (pPCB,
                                            pEapolPkt)) != NO_ERROR)
                {
                    TRACE1 (EAPOL, "FSMConnecting: Error in FSMAuthenticated %ld",
                            dwRetCode);
                    break;
                }

#ifndef EAPOL_SERVICE

                // Display change of status using sys tray balloon
                // on interface icon
                ElStringToGuid (pPCB->pszDeviceGUID, &DeviceGuid);
                (VOID)EAPOLMANAuthenticationSucceeded (&DeviceGuid);

#endif

                // No need to send out more EAPOL_Start packets

                // Reset start packet count
                pPCB->ulStartCount = 0;
                pPCB->fIsRemoteEndEAPOLAware = FALSE;
                break;
            }
        }
        else
        {
            pPCB->ulStartCount++;
        }
            
        // If user is not logged in, send out EAPOL_Start packets
        // at intervals of 1 second each. This is used to detect if the
        // interface is on a secure network or not. 
        // If user is logged in, use the configured value for the 
        // StartPeriod as the interval
        //if (!pPCB->fUserLoggedIn)

        if (!g_fUserLoggedOn)
        {
            dwStartInterval = EAPOL_INIT_START_PERIOD; // 1 second
        }
        else
        {
            dwStartInterval = pPCB->EapolConfig.dwstartPeriod;
        }

        // Restart timer with startPeriod
        // Even if error occurs, timeout will happen
        // Else, we won't be able to get out of connecting state
        RESTART_TIMER (pPCB->hTimer,
                dwStartInterval,
                "PCB",
                &dwRetCode);
            
        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAPOL, "FSMConnecting: Error in RESTART_TIMER %ld",
                    dwRetCode);
            break;
        }

        // Send out EAPOL_Start
        // Allocate new buffer
        pEapolPkt = (EAPOL_PACKET *) MALLOC (sizeof(EAPOL_PACKET));
        if (pEapolPkt == NULL)
        {
            TRACE0 (EAPOL, "FSMConnecting: Error in allocating memory for EAPOL packet");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // ISSUE:
        // Does Authenticator side also ignore data beyond PacketType
        // as the supplicant side does?

        memcpy ((BYTE *)pEapolPkt->EthernetType, 
                (BYTE *)pPCB->bEtherType, 
                SIZE_ETHERNET_TYPE);
        pEapolPkt->ProtocolVersion = pPCB->bProtocolVersion;
        pEapolPkt->PacketType = EAPOL_Start;
        HostToWireFormat16 ((WORD)0, (BYTE *)pEapolPkt->PacketBodyLength);

        // Send packet out on the port
        dwRetCode = ElWriteToPort (pPCB,
                                    (CHAR *)pEapolPkt,
                                    sizeof (EAPOL_PACKET));
        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAPOL, "FSMConnecting: Error in writing Start Pkt to port %ld",
                    dwRetCode);
            break;
        }

        TRACE1 (EAPOL, "Setting state CONNECTING for port %s", pPCB->pszFriendlyName);

        pPCB->State = EAPOLSTATE_CONNECTING;
        SET_EAPOL_START_TIMER(pPCB);

    } while (FALSE);

    if (pEapolPkt != NULL)
    {
        FREE (pEapolPkt);
    }

    TRACE1 (EAPOL, "FSMConnecting completed for port %s", pPCB->pszFriendlyName);
    return dwRetCode;
}


//
// FSMAcquired
//
// Description:
//      Function called when the port receives a EAP-Request/Identity packet.
//      EAP processing of the packet occurs and a EAP-Response/Identity may
//      be sent out by EAP if required.
//      
//
// Arguments:
//      pPCB - Pointer to the PCB for the port on which data is being
//      processed
//      pEapolPkt - Pointer to EAPOL packet that was received
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
FSMAcquired (
        IN  EAPOL_PCB       *pPCB,
        IN  EAPOL_PACKET    *pEapolPkt
        )
{
    DWORD       dwComputerNameLen = 0;
    GUID        DeviceGuid;
    DWORD       dwRetCode= NO_ERROR;

    TRACE1 (EAPOL, "FSMAcquired entered for port %s", pPCB->pszFriendlyName);

#ifndef EAPOL_SERVICE

    ElStringToGuid (pPCB->pszDeviceGUID, &DeviceGuid);
    (VOID)EAPOLMANAuthenticationStarted (&DeviceGuid);

#endif

    do
    {

        // Indicate to EAP=Dll to cleanup any leftovers from earlier
        // authentication. This is to take care of cases where errors
        // occured in the earlier authentication and cleanup wasn't done
        if ((dwRetCode = ElEapEnd (pPCB)) != NO_ERROR)
        {
            TRACE1 (EAPOL, "FSMAcquired: Error in ElEapEnd = %ld",
                    dwRetCode);
            break;
        }

        // Restart timer with authPeriod
        // Even if there is error in ElEapWork, the authtimer timeout
        // should happen
        RESTART_TIMER (pPCB->hTimer,
                pPCB->EapolConfig.dwauthPeriod,
                "PCB",
                &dwRetCode);
        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAPOL, "FSMAcquired: Error in RESTART_TIMER %ld",
                    dwRetCode);
            break;
        }

        // Since an EAP Req-ID was received, reset EAPOL_Start count
        pPCB->ulStartCount = 0;


        // If current received EAP Id is the same the previous EAP Id
        // send the last EAPOL packet again

        if (((PPP_EAP_PACKET *)pEapolPkt->PacketBody)->Id == 
            pPCB->dwPreviousId)
        {
                
            TRACE0 (EAPOL, "FSMAcquired: Re-xmitting EAP_Packet to port");

            dwRetCode = ElWriteToPort (pPCB,
                            (CHAR *)pPCB->pbPreviousEAPOLPkt,
                            pPCB->dwSizeOfPreviousEAPOLPkt);
            if (dwRetCode != NO_ERROR)
            {
                TRACE1 (EAPOL, "FSMAcquired: Error in writing re-xmitted EAP_Packet to port %ld",
                        dwRetCode);
                break;
            }
        }
        else
        {

            // Process the EAP packet
            // ElEapWork will send out response if required
            if (( dwRetCode = ElEapWork (
                            pPCB,
                            (PPP_EAP_PACKET *)pEapolPkt->PacketBody
                            )) != NO_ERROR)
            {
                TRACE1 (EAPOL, "FSMAcquired: Error in ElEapWork %ld",
                        dwRetCode);
                break;
            }
        }

        TRACE1 (EAPOL, "Setting state ACQUIRED for port %s", pPCB->pszFriendlyName);

        SET_EAPOL_AUTH_TIMER(pPCB);
        pPCB->State = EAPOLSTATE_ACQUIRED;

    } while (FALSE);

    TRACE1 (EAPOL, "FSMAcquired completed for port %s", pPCB->pszFriendlyName);

    return dwRetCode;
}


//
// FSMAuthenticating
//
// Description:
//
// Function called when an non EAP-Request/Identity packet is received on the
// port. EAP processing of the data occurs.
//
// Arguments:
//      pPCB - Pointer to the PCB for the port on which data is being
//      processed
//      pEapolPkt - Pointer to EAPOL packet that was received
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
FSMAuthenticating (
        IN  EAPOL_PCB       *pPCB,
        IN  EAPOL_PACKET    *pEapolPkt
        )
{
    GUID            DeviceGuid;
    DWORD           dwRetCode = NO_ERROR;

    TRACE1 (EAPOL, "FSMAuthenticating entered for port %s", pPCB->pszFriendlyName);

#ifndef EAPOL_SERVICE

    ElStringToGuid (pPCB->pszDeviceGUID, &DeviceGuid);
    (VOID)EAPOLMANAuthenticationStarted (&DeviceGuid);

#endif

    do
    {

        // Restart timer with authPeriod
        // Even if there is error in ElEapWork, the authtimer timeout
        // should happen
        RESTART_TIMER (pPCB->hTimer,
                pPCB->EapolConfig.dwauthPeriod,
                "PCB",
                &dwRetCode);
        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAPOL, "FSMAuthenticating: Error in RESTART_TIMER %ld",
                    dwRetCode);
            break;
        }

        // If current received EAP Id is the same the previous EAP Id
        // send the last EAPOL packet again
	    // For EAPCODE_Success and EAPCODE_Failure, the value of id field
	    // will not be increment, Refer to EAP RFC 

        if ((((PPP_EAP_PACKET *)pEapolPkt->PacketBody)->Id 
                    == pPCB->dwPreviousId) &&
                (((PPP_EAP_PACKET *)pEapolPkt->PacketBody)->Code 
                    !=  EAPCODE_Success) &&
                (((PPP_EAP_PACKET *)pEapolPkt->PacketBody)->Code 
                    !=  EAPCODE_Failure))
        {

            TRACE0 (EAPOL, "FSMAcquired: Re-xmitting EAP_Packet to port");

            dwRetCode = ElWriteToPort (pPCB,
                            (CHAR *)pPCB->pbPreviousEAPOLPkt,
                            pPCB->dwSizeOfPreviousEAPOLPkt);
            if (dwRetCode != NO_ERROR)
            {
                TRACE1 (EAPOL, "FSMAcquired: Error in writing re-xmitted EAP_Packet to port = %ld",
                        dwRetCode);
                break;
            }
        }
        else
        {
            // Process the EAP packet
            // ElEapWork will send out response if required
            if (( dwRetCode = ElEapWork (
                            pPCB,
                            (PPP_EAP_PACKET *)pEapolPkt->PacketBody
                            )) != NO_ERROR)
            {
                TRACE1 (EAPOL, "FSMAuthenticating: Error in ElEapWork %ld",
                        dwRetCode);
                break;
            }
        }


        TRACE1 (EAPOL, "Setting state AUTHENTICATING for port %s", pPCB->pszFriendlyName);

        SET_EAPOL_AUTH_TIMER(pPCB);
        pPCB->State = EAPOLSTATE_AUTHENTICATING;

    } while (FALSE);

    TRACE1 (EAPOL, "FSMAuthenticating completed for port %s", pPCB->pszFriendlyName);

    return dwRetCode;
}


//
// FSMHeld
//
// Description:
//      Function called when a EAP-Failure packet is received in the
//      Authenticating state. State machine is held for heldPeriod before
//      re-authentication can occur.
//
// Arguments:
//      pPCB - Pointer to the PCB for the port on which data is being
//      processed
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
FSMHeld (
        IN  EAPOL_PCB   *pPCB
        )
{
    DWORD       dwRetCode = NO_ERROR;

    TRACE1 (EAPOL, "FSMHeld entered for port %s", pPCB->pszFriendlyName);

    do 
    {
#ifdef DRAFT7
        if (g_dwMachineAuthEnabled)
        {
#endif

        pPCB->dwAuthFailCount++;

        if (pPCB->dwAuthFailCount <= EAPOL_MAX_AUTH_FAIL_COUNT)
        {
            TRACE1 (EAPOL, "Restarting Held timer with time value = %ld",
                    pPCB->EapolConfig.dwheldPeriod);

            // Restart timer with heldPeriod
            RESTART_TIMER (pPCB->hTimer,
                    pPCB->EapolConfig.dwheldPeriod,
                    "PCB",
                    &dwRetCode);
        }
        else
        {
            TRACE1 (EAPOL, "Restarting Held timer with extended time value = %ld",
                    (pPCB->dwAuthFailCount * (pPCB->EapolConfig.dwheldPeriod)));

            // Restart timer with heldPeriod times pPCB->dwAuthFailCount
            RESTART_TIMER (pPCB->hTimer,
                    ((pPCB->dwAuthFailCount) * (pPCB->EapolConfig.dwheldPeriod)),
                    "PCB",
                    &dwRetCode);
        }

#ifdef DRAFT7
        }
        else
        {

        TRACE1 (EAPOL, "Restarting Held timer with time value = %ld",
                pPCB->EapolConfig.dwheldPeriod);

        // Restart timer with heldPeriod
        RESTART_TIMER (pPCB->hTimer,
                pPCB->EapolConfig.dwheldPeriod,
                "PCB",
                &dwRetCode);

        } // g_dwMachineAuthEnabled
#endif
            
        if (dwRetCode != NO_ERROR)
        {
            TRACE1 (EAPOL, "FSMHeld: Error in RESTART_TIMER %ld",
                    dwRetCode);

            break;
        }

        // Free Identity buffer

        if (pPCB->pszIdentity != NULL)
        {
            FREE (pPCB->pszIdentity);
            pPCB->pszIdentity = NULL;
        }
    
        // Free Password buffer
    
        if (pPCB->pszPassword != NULL)
        {
            FREE (pPCB->pszPassword);
            pPCB->pszPassword = NULL;
        }
    
        // Free user-specific data in the PCB
    
        if (pPCB->pCustomAuthUserData != NULL)
        {
            FREE (pPCB->pCustomAuthUserData);
            pPCB->pCustomAuthUserData = NULL;
        }
    
        // Free connection data
    
        if (pPCB->pCustomAuthConnData != NULL)
        {
            FREE (pPCB->pCustomAuthConnData);
            pPCB->pCustomAuthConnData = NULL;
        }
    
        // Since there has been an error in credentials, start afresh
        // the authentication. Credentials may have changed e.g. certs 
        // may be renewed, MD5 credentials corrected etc.

        pPCB->fGotUserIdentity = FALSE;
    
        TRACE1 (EAPOL, "Setting state HELD for port %s", pPCB->pszFriendlyName);

        pPCB->State = EAPOLSTATE_HELD;
        SET_EAPOL_HELD_TIMER(pPCB);

        TRACE1 (EAPOL, "FSMHeld: Port %s set to HELD state",
                pPCB->pszDeviceGUID);

    } while (FALSE);
    
    TRACE1 (EAPOL, "FSMHeld completed for port %s", pPCB->pszFriendlyName);

    return dwRetCode;
}


//
// FSMAuthenticated
//
// Description:
//
// Function called when a EAP-Success packet is received or MaxStart 
// EAPOL_Startpackets have been sent out, but no EAP-Request/Identity 
// packets were received. If EAP-Success packet is request, DHCP client 
// is restarted to get a new IP address.
//
// Arguments:
//      pPCB - Pointer to the PCB for the port on which data is being
//      processed
//      pEapolPkt - Pointer to EAPOL packet that was received
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
FSMAuthenticated (
        IN  EAPOL_PCB       *pPCB,
        IN  EAPOL_PACKET   *pEapolPkt
        )
{
    DHCP_PNP_CHANGE     DhcpPnpChange;
    DWORD               dwRetCode = NO_ERROR;

    TRACE1 (EAPOL, "FSMAuthenticated entered for port %s", 
            pPCB->pszFriendlyName);

    do
    {
        // Shutdown earlier EAP session
        ElEapEnd (pPCB);

        // Call DHCP only if state machine went through authentication
        // If FSM is getting AUTHENTICATED by default, don't call DHCP

        // if (pPCB->ulStartCount < pPCB->EapolConfig.dwmaxStart)
        {
            // Call DHCP to do PnP
            ZeroMemory(&DhcpPnpChange, sizeof(DHCP_PNP_CHANGE));
            DhcpPnpChange.Version = DHCP_PNP_CHANGE_VERSION_0;
            if ((dwRetCode = DhcpHandlePnPEvent(0, 
                        DHCP_CALLER_TCPUI, 
                        NULL,
                        //pPCB->pszDeviceGUID,
                        &DhcpPnpChange, 
                        NULL)) != NO_ERROR)
            {
                TRACE1 (EAPOL, "FSMAuthenticated: DHCPHandlePnPEvent returned error %ld",
                        dwRetCode);
                break;
            }
            TRACE0 (EAPOL, "FSMAuthenticated: DHCPHandlePnPEvent successful");
        }
            
        TRACE1 (EAPOL, "Setting state AUTHENTICATED for port %s", pPCB->pszFriendlyName);

        pPCB->State = EAPOLSTATE_AUTHENTICATED;

    } while (FALSE);

    TRACE1 (EAPOL, "FSMAuthenticated completed for port %s", pPCB->pszFriendlyName);

    return dwRetCode;
}


//
// FSMRxKey
//
// Description:
//      Function called when an EAPOL-Key packet is received in the 
//      Authenticated state. The WEP key is decrypted and
//      plumbed down to the NIC driver.
//
// Arguments:
//      pPCB - Pointer to the PCB for the port on which data is being
//      processed
//      pEapolPkt - Pointer to EAPOL packet that was received
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
FSMRxKey (
        IN  EAPOL_PCB       *pPCB,
        IN  EAPOL_PACKET   *pEapolPkt
        )
{
    EAPOL_KEY_DESC      *pKeyDesc = NULL;
    EAPOL_KEY_DESC_D8   *pKeyDesc_D8 = NULL;
    EAPOL_PACKET_D8     EapolPktD8;
    EAPOL_PACKET_D8     *pEapolPktD8 = NULL;
    ULONGLONG           ullReplayCheck = 0; 
    BYTE                bReplayCheck[8];
    BYTE                *pbMD5EapolPkt = NULL;
    DWORD               dwMD5EapolPktLen = 0;
    MD5_CTX             MD5Context;
    DWORD               dwEapPktLen = 0;
    DWORD               dwIndex = 0;
    BYTE                bHMACMD5HashBuffer[MD5DIGESTLEN];
    RC4_KEYSTRUCT       rc4key;
    BYTE                bKeyBuffer[48];
    BYTE                *pbKeyToBePlumbed = NULL;
    DWORD               dwKeyLength = 0;
    NDIS_802_11_WEP     *pNdisWEPKey = NULL;

    DWORD               dwRetCode = NO_ERROR;

    TRACE1 (EAPOL, "FSMRxKey entered for port %s", pPCB->pszFriendlyName);

    do
    {
        if (!pPCB->fRemoteEnd8021XD8)
        {
        // DRAFT 7

        pKeyDesc = (EAPOL_KEY_DESC *)pEapolPkt->PacketBody;

        dwKeyLength = WireToHostFormat16 (pKeyDesc->KeyLength);

        TRACE4 (EAPOL, "Signature Type = %ld, \n Encrypt Type = %ld, \n KeyLength = %ld, \n KeyIndex = %ld",
                pKeyDesc->SignatureType,
                pKeyDesc->EncryptType,
                dwKeyLength,
                pKeyDesc->KeyIndex
                );

        // For Draft 8, do not check for non-existing fields

        if (pKeyDesc->SignatureType != 1)
        {
            TRACE1 (EAPOL, "FSMRxKey: Invalid signature type = %ld",
                    pKeyDesc->SignatureType);
            // log
            break;
        }

        if (pKeyDesc->EncryptType != 1)
        {
            TRACE1 (EAPOL, "FSMRxKey: Invalid encryption type = %ld",
                    pKeyDesc->EncryptType);
            // log
            break;
        }

        memcpy ((BYTE *)bReplayCheck, 
                (BYTE *)pKeyDesc->ReplayCounter, 
                8*sizeof(BYTE));

        ullReplayCheck = ((*((PBYTE)(bReplayCheck)+0) << 56) +
                         (*((PBYTE)(bReplayCheck)+1) << 48) +
                         (*((PBYTE)(bReplayCheck)+2) << 40) +
                         (*((PBYTE)(bReplayCheck)+3) << 32) +
                         (*((PBYTE)(bReplayCheck)+4) << 24) +
                         (*((PBYTE)(bReplayCheck)+5) << 16) +
                         (*((PBYTE)(bReplayCheck)+6) << 8) +
                         (*((PBYTE)(bReplayCheck)+7)));

        //
        // Check validity of Key message using the ReplayCounter field
        // Verify if it is in sync with the last ReplayCounter value 
        // received
        //
        
        TRACE0 (EAPOL, "Incoming Replay counter ======= ");
        EAPOL_DUMPBA ((BYTE *)&ullReplayCheck, 8);
        TRACE0 (EAPOL, "Last Replay counter ======= ");
                EAPOL_DUMPBA ((BYTE *)&(pPCB->ullLastReplayCounter), 8);

        if (ullReplayCheck <= pPCB->ullLastReplayCounter)
        {
            TRACE0 (EAPOL, "FSMRxKey: Replay counter is not in sync, something is wrong");
            // log
            break;
        }
        
        // If valid ReplayCounter, save it in the PCB for future check
        pPCB->ullLastReplayCounter = ullReplayCheck;


        TRACE0 (EAPOL, "Replay counter in desc ======");
        EAPOL_DUMPBA (pKeyDesc->ReplayCounter, 8);

        //
        // Verify if the MD5 hash generated on the EAPOL packet,
        // with Signature nulled out, is the same as the signature
        // Use the MPPERecv key as the secret
        //

        dwEapPktLen = WireToHostFormat16 (pEapolPkt->PacketBodyLength);
        dwMD5EapolPktLen = sizeof (EAPOL_PACKET) - sizeof(pEapolPkt->EthernetType) - 1 + dwEapPktLen;
        if ((pbMD5EapolPkt = (BYTE *) MALLOC (dwMD5EapolPktLen)) == NULL)
        {
            TRACE0 (EAPOL, "FSMRxKey: Error in MALLOC for pbMD5EapolPkt");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        memcpy ((BYTE *)pbMD5EapolPkt, (BYTE *)pEapolPkt+sizeof(pEapolPkt->EthernetType), dwMD5EapolPktLen);

        //
        // Null out the signature in the key descriptor copy, to calculate
        // the hash on the supplicant side
        //

        ZeroMemory ((BYTE *)(pbMD5EapolPkt
                            - sizeof(pEapolPkt->EthernetType) +
                            sizeof(EAPOL_PACKET) - 1 + // pEapolPkt->Body
                            sizeof(EAPOL_KEY_DESC)- // End of EAPOL_KEY_DESC
                            MD5DIGESTLEN-1), // Signature field
                            MD5DIGESTLEN);

        (VOID) ElGetHMACMD5Digest (
            pbMD5EapolPkt,
            dwMD5EapolPktLen,
            pPCB->pbMPPERecvKey,
            pPCB->dwMPPERecvKeyLength,
            bHMACMD5HashBuffer
            );

        TRACE0 (EAPOL, "FSMRxKey: MD5 Hash body ==");
        EAPOL_DUMPBA (pbMD5EapolPkt, dwMD5EapolPktLen);

        TRACE0 (EAPOL, "FSMRxKey: MD5 Hash secret ==");
        EAPOL_DUMPBA (pPCB->pbMPPERecvKey, pPCB->dwMPPERecvKeyLength);

        TRACE0 (EAPOL, "FSMRxKey: MD5 Hash generated by Supplicant");
        EAPOL_DUMPBA (bHMACMD5HashBuffer, MD5DIGESTLEN);

        TRACE0 (EAPOL, "FSMRxKey: Signature sent in EAPOL_KEY_DESC");
        EAPOL_DUMPBA (pKeyDesc->KeySignature, MD5DIGESTLEN);

        //
        // Check if HMAC-MD5 hash in received packet is what is expected
        //
        if (memcmp (bHMACMD5HashBuffer, pKeyDesc->KeySignature, MD5DIGESTLEN) != 0)
        {
            TRACE0 (EAPOL, "FSMRxKey: Signature in Key Desc does not match, potential security attack");
            // log
            break;
        }
            
        //
        // Decrypt the multicast WEP key if it has been provided
        //

        // Check if there is Key Material (5/16 bytes) at the end of 
        // the Key Descriptor

        if (WireToHostFormat16 (pEapolPkt->PacketBodyLength) > sizeof (EAPOL_KEY_DESC))

        {
            memcpy ((BYTE *)bKeyBuffer, (BYTE *)pKeyDesc->Key_IV, 16);
            memcpy ((BYTE *)&bKeyBuffer[16], (BYTE *)pPCB->pbMPPESendKey, 32);

            rc4_key (&rc4key, 48, bKeyBuffer);
            rc4 (&rc4key, dwKeyLength, pKeyDesc->Key);

            TRACE0 (EAPOL, " ========= The multicast key is ============= ");
            EAPOL_DUMPBA (pKeyDesc->Key, dwKeyLength);


            // Use the unencrypted key in the Key Desc as the encryption key

            pbKeyToBePlumbed = pKeyDesc->Key;
            
        }
        else
        {
            // Use the MPPESend key as the encryption key

            pbKeyToBePlumbed = (BYTE *)pPCB->pbMPPESendKey;
        }

        if ((pNdisWEPKey = MALLOC ( sizeof(NDIS_802_11_WEP)-1+dwKeyLength )) 
                == NULL)
        {
            TRACE0 (EAPOL, "FSMRxKey: MALLOC failed for pNdisWEPKey");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pNdisWEPKey->Length = sizeof(NDIS_802_11_WEP) - 1 + dwKeyLength;
        memcpy ((BYTE *)pNdisWEPKey->KeyMaterial, (BYTE *)pbKeyToBePlumbed,
                dwKeyLength);
        pNdisWEPKey->KeyLength = dwKeyLength;


        // Create the long index out of the byte index got from AP
        // If MSB in byte is set, set MSB in ulong format

        if (pKeyDesc->KeyIndex & 0x80)
        {
            pNdisWEPKey->KeyIndex = 0x80000000;
        }
        else
        {
            pNdisWEPKey->KeyIndex = 0x00000000;
        }

        pNdisWEPKey->KeyIndex |= (pKeyDesc->KeyIndex & 0x03);

        TRACE1 (ANY, "FSMRxKey: Key Index is %x", pNdisWEPKey->KeyIndex);


        // Use NDISUIO to plumb the key to the driver

        if ((dwRetCode = ElNdisuioSetOIDValue (
                                    pPCB->hPort,
                                    OID_802_11_ADD_WEP,
                                    (BYTE *)pNdisWEPKey,
                                    pNdisWEPKey->Length)) != NO_ERROR)
        {
            TRACE1 (PORT, "FSMRxKey: ElNdisuioSetOIDValue failed with error %ld",
                    dwRetCode);
        }

        }
        else
        {
        // DRAFT 8

        // Point beyond Signature Type for structure alignment
        pKeyDesc_D8 = (EAPOL_KEY_DESC_D8 *)(pEapolPkt->PacketBody);

        dwKeyLength = WireToHostFormat16 (pKeyDesc_D8->KeyLength);

        TRACE3 (EAPOL, "Descriptor type = %ld, \n KeyLength = %ld, \n KeyIndex = %ld",
                pKeyDesc_D8->DescriptorType,
                dwKeyLength,
                pKeyDesc_D8->KeyIndex
                );

        memcpy ((BYTE *)bReplayCheck, 
                (BYTE *)pKeyDesc_D8->ReplayCounter, 
                8*sizeof(BYTE));

        ullReplayCheck = ((*((PBYTE)(bReplayCheck)+0) << 56) +
                         (*((PBYTE)(bReplayCheck)+1) << 48) +
                         (*((PBYTE)(bReplayCheck)+2) << 40) +
                         (*((PBYTE)(bReplayCheck)+3) << 32) +
                         (*((PBYTE)(bReplayCheck)+4) << 24) +
                         (*((PBYTE)(bReplayCheck)+5) << 16) +
                         (*((PBYTE)(bReplayCheck)+6) << 8) +
                         (*((PBYTE)(bReplayCheck)+7)));

        //
        // Check validity of Key message using the ReplayCounter field
        // Verify if it is in sync with the last ReplayCounter value 
        // received
        //
        
        TRACE0 (EAPOL, "Incoming Replay counter ======= ");
        EAPOL_DUMPBA ((BYTE *)&ullReplayCheck, 8);
        TRACE0 (EAPOL, "Last Replay counter ======= ");
                EAPOL_DUMPBA ((BYTE *)&(pPCB->ullLastReplayCounter), 8);

        if (ullReplayCheck < pPCB->ullLastReplayCounter)
        {
            TRACE0 (EAPOL, "FSMRxKey: Replay counter is not in sync, something is wrong");
            // log
            break;
        }
        
        // If valid ReplayCounter, save it in the PCB for future check
        pPCB->ullLastReplayCounter = ullReplayCheck;

        TRACE1 (EAPOL, "Replay counter ======= %lx", ullReplayCheck);

        TRACE0 (EAPOL, "Replay counter in desc ======");
        EAPOL_DUMPBA (pKeyDesc_D8->ReplayCounter, 8);

        //
        // Verify if the MD5 hash generated on the EAPOL packet,
        // with Signature nulled out, is the same as the signature
        // Use the MPPERecv key as the secret
        //

        {
            ZeroMemory (&EapolPktD8, sizeof (EAPOL_PACKET_D8));

            memcpy (EapolPktD8.EthernetType, pEapolPkt->EthernetType, 2);
            EapolPktD8.ProtocolVersion = pEapolPkt->ProtocolVersion;
            EapolPktD8.PacketType = pEapolPkt->PacketType;
            memcpy (EapolPktD8.PacketBodyLength, pEapolPkt->PacketBodyLength, 
                    2);
            memcpy ((BYTE *)&(EapolPktD8.AuthResultCode), (BYTE *)pEapolPkt - 2, 2);

            memcpy ((BYTE *)pEapolPkt - 2, (BYTE *)&EapolPktD8,
                    sizeof(EAPOL_PACKET_D8)-1);

            pEapolPktD8 = (EAPOL_PACKET_D8 *)((BYTE *)pEapolPkt - 2);
        }

        dwEapPktLen = WireToHostFormat16 (pEapolPktD8->PacketBodyLength);
        dwMD5EapolPktLen = sizeof (EAPOL_PACKET_D8) - sizeof(pEapolPktD8->EthernetType) - 1 + dwEapPktLen;
        if ((pbMD5EapolPkt = (BYTE *) MALLOC (dwMD5EapolPktLen)) == NULL)
        {
            TRACE0 (EAPOL, "FSMRxKey: Error in MALLOC for pbMD5EapolPkt");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        memcpy ((BYTE *)pbMD5EapolPkt, (BYTE *)pEapolPktD8+sizeof(pEapolPktD8->EthernetType), dwMD5EapolPktLen);

        //
        // Null out the signature in the key descriptor copy, to calculate
        // the hash on the supplicant side
        //

        // Draft 8 has different KEY_DESC size
        ZeroMemory ((BYTE *)(pbMD5EapolPkt
                            - sizeof(pEapolPktD8->EthernetType) +
                            sizeof(EAPOL_PACKET_D8) - 1 + // pEapolPktD8->Body
                            sizeof(EAPOL_KEY_DESC_D8) - // End of EAPOL_KEY_DESC
                            MD5DIGESTLEN-1), // Signature field
                            MD5DIGESTLEN);

        (VOID) ElGetHMACMD5Digest (
            pbMD5EapolPkt,
            dwMD5EapolPktLen,
            pPCB->pbMPPERecvKey,
            pPCB->dwMPPERecvKeyLength,
            bHMACMD5HashBuffer
            );

        TRACE0 (EAPOL, "FSMRxKey: MD5 Hash body ==");
        EAPOL_DUMPBA (pbMD5EapolPkt, dwMD5EapolPktLen);

        TRACE0 (EAPOL, "FSMRxKey: MD5 Hash secret ==");
        EAPOL_DUMPBA (pPCB->pbMPPERecvKey, pPCB->dwMPPERecvKeyLength);

        TRACE0 (EAPOL, "FSMRxKey: MD5 Hash generated by Supplicant");
        EAPOL_DUMPBA (bHMACMD5HashBuffer, MD5DIGESTLEN);

        TRACE0 (EAPOL, "FSMRxKey: Signature sent in EAPOL_KEY_DESC");
        EAPOL_DUMPBA (pKeyDesc_D8->KeySignature, MD5DIGESTLEN);

        //
        // Check if HMAC-MD5 hash in received packet is what is expected
        //
        if (memcmp (bHMACMD5HashBuffer, pKeyDesc_D8->KeySignature, MD5DIGESTLEN) != 0)
        {
            TRACE0 (EAPOL, "FSMRxKey: Signature in Key Desc does not match, potential security attack");
            // log
            break;
        }
            
        //
        // Decrypt the multicast WEP key if it has been provided
        //

        // Check if there is Key Material (5/16 bytes) at the end of 
        // the Key Descriptor

        if (WireToHostFormat16 (pEapolPktD8->PacketBodyLength) > sizeof (EAPOL_KEY_DESC))

        {
            memcpy ((BYTE *)bKeyBuffer, (BYTE *)pKeyDesc_D8->Key_IV, 16);
            memcpy ((BYTE *)&bKeyBuffer[16], (BYTE *)pPCB->pbMPPESendKey, 32);

            rc4_key (&rc4key, 48, bKeyBuffer);
            rc4 (&rc4key, dwKeyLength, pKeyDesc_D8->Key);

            TRACE0 (EAPOL, " ========= The multicast key is ============= ");
            EAPOL_DUMPBA (pKeyDesc_D8->Key, dwKeyLength);


            // Use the unencrypted key in the Key Desc as the encryption key

            pbKeyToBePlumbed = pKeyDesc_D8->Key;
            
        }
        else
        {
            // Use the MPPESend key as the encryption key

            pbKeyToBePlumbed = (BYTE *)pPCB->pbMPPESendKey;
        }

        if ((pNdisWEPKey = MALLOC ( sizeof(NDIS_802_11_WEP)-1+dwKeyLength )) 
                == NULL)
        {
            TRACE0 (EAPOL, "FSMRxKey: MALLOC failed for pNdisWEPKey");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pNdisWEPKey->Length = sizeof(NDIS_802_11_WEP) - 1 + dwKeyLength;
        memcpy ((BYTE *)pNdisWEPKey->KeyMaterial, (BYTE *)pbKeyToBePlumbed,
                dwKeyLength);
        pNdisWEPKey->KeyLength = dwKeyLength;


        // Create the long index out of the byte index got from AP
        // If MSB in byte is set, set MSB in ulong format

        if (pKeyDesc_D8->KeyIndex & 0x80)
        {
            pNdisWEPKey->KeyIndex = 0x80000000;
        }
        else
        {
            pNdisWEPKey->KeyIndex = 0x00000000;
        }

        pNdisWEPKey->KeyIndex |= (pKeyDesc_D8->KeyIndex & 0x03);

        TRACE1 (ANY, "FSMRxKey: Key Index is %x", pNdisWEPKey->KeyIndex);


        // Use NDISUIO to plumb the key to the driver

        if ((dwRetCode = ElNdisuioSetOIDValue (
                                    pPCB->hPort,
                                    OID_802_11_ADD_WEP,
                                    (BYTE *)pNdisWEPKey,
                                    pNdisWEPKey->Length)) != NO_ERROR)
        {
            TRACE1 (PORT, "FSMRxKey: ElNdisuioSetOIDValue failed with error %ld",
                    dwRetCode);
        }

        }
    } while (FALSE);

    if (pbMD5EapolPkt != NULL)
    {
        FREE (pbMD5EapolPkt);
        pbMD5EapolPkt = NULL;
    }

    if (pNdisWEPKey != NULL)
    {
        FREE (pNdisWEPKey);
        pNdisWEPKey = NULL;
    }

    TRACE1 (EAPOL, "FSMRxKey completed for port %s", pPCB->pszFriendlyName);

    return dwRetCode;
}


//
// ElTimeoutCallbackRoutine
//
// Description:
//
// Function called when any timer work item queued on the global timer 
// queue expires. Depending on the state in which the port is when the timer
// expires, the port moves to the next state.
//
// Arguments:
//      pvContext - Pointer to context. In this case, it is pointer to a PCB 
//      fTimerOfWaitFired - Unused
//
// Return values:
//

VOID 
ElTimeoutCallbackRoutine (
        IN  PVOID       pvContext,
        IN  BOOLEAN     fTimerOfWaitFired
        )
{
    EAPOL_PCB       *pPCB;

    TRACE0 (EAPOL, "ElTimeoutCallbackRoutine entered");
    
    do 
    {
        // Context should not be NULL
        if (pvContext == NULL)
        {
            TRACE0 (EAPOL, "ElTimeoutCallbackRoutine: pvContext is NULL. Invalid timeout callback");
            break;
        }

        // PCB is guaranteed to exist until all timers are fired
            
        // Verify if Port is still active
        pPCB = (EAPOL_PCB *)pvContext;
        ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

        if (!EAPOL_PORT_ACTIVE(pPCB))
        {
            // Port is not active
            RELEASE_WRITE_LOCK (&(pPCB->rwLock));
            TRACE1 (PORT, "ElTimeoutCallbackRoutine: Port %s is inactive",
                    pPCB->pszDeviceGUID);
            break;
        }

        // Check the timer has been changed
        // If the current time is less than the programmed timeout on
        // the PCB, either timer component has shot off timer earlier
        // or the timer fired but someone changed it in the meanwhile
        if (pPCB->ulTimeout > GetTickCount())
        {
            TRACE0 (EAPOL, "ElTimeoutCallbackRoutine: Timeout value has been changed or Timer fired earlier than required");
            break;
        }
    
        // Check the current state of the state machine 
        // We can do additional checks such as flagging which timer was fired
        // and in the timeout checking if the PCB state has remained the same
        // Else bail out
    
        switch (pPCB->State)
        {
            case EAPOLSTATE_CONNECTING:
                if (!EAPOL_START_TIMER_SET(pPCB))
                {
                    TRACE1 (EAPOL, "ElTimeoutCallbackRoutine: Wrong timeout %ld in Connecting state", CHECK_EAPOL_TIMER(pPCB));
                    break;
                }
                FSMConnecting(pPCB);
                break;
    
            case EAPOLSTATE_ACQUIRED:
                if (!EAPOL_AUTH_TIMER_SET(pPCB))
                {
                    TRACE1 (EAPOL, "ElTimeoutCallbackRoutine: Wrong timeout %ld in Acquired state", CHECK_EAPOL_TIMER(pPCB));
                    break;
                }
                FSMConnecting(pPCB);
                break;
                
            case EAPOLSTATE_AUTHENTICATING:
                if (!EAPOL_AUTH_TIMER_SET(pPCB))
                {
                    TRACE1 (EAPOL, "ElTimeoutCallbackRoutine: Wrong timeout %ld in Authenticating state", CHECK_EAPOL_TIMER(pPCB));
                    break;
                }
                FSMConnecting(pPCB);
                break;
                
            case EAPOLSTATE_HELD:
                if (!EAPOL_HELD_TIMER_SET(pPCB))
                {
                    TRACE1 (EAPOL, "ElTimeoutCallbackRoutine: Wrong timeout %ld in Held state", CHECK_EAPOL_TIMER(pPCB));
                    break;
                }
                FSMConnecting(pPCB);
                break;

            case EAPOLSTATE_DISCONNECTED:
                TRACE0 (EAPOL, "ElTimeoutCallbackRoutine: No action in Disconnected state");
                break;
                
            case EAPOLSTATE_LOGOFF:
                TRACE0 (EAPOL, "ElTimeoutCallbackRoutine: No action in Logoff state");
                break;
                
            default:
                TRACE0 (EAPOL, "ElTimeoutCallbackRoutine: Critical Error. Invalid state after timer expires ");
                break;
        }
    
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));

    } while (FALSE);
            
    TRACE0 (EAPOL, "ElTimeoutCallbackRoutine completed");

    return;
}


//
// ElEapWork
//
// Description:
//
// Function called when an EAPOL packet of type EAP_Packet is received 
// The EAP packet is passed to the EAP module for processing.
// Depending on the result of the processing, a EAP Response packet
// is sent or the incoming packet is ignored.
//
// Input arguments:
//  pPCB - Pointer to PCB for the port on which data is being processed
//  pRecvPkt - Pointer to EAP packet in the data received from the remote end
//              
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

//
// ISSUE: Rewrite with do {} while(FALSE)
//

DWORD
ElEapWork (
    IN EAPOL_PCB        *pPCB,
    IN PPP_EAP_PACKET   *pRecvPkt
    )
{
    DWORD           dwLength = 0;
    ELEAP_RESULT    EapResult;
    PPP_EAP_PACKET  *pSendPkt;
    EAPOL_PACKET    *pEapolPkt;
    GUID            DeviceGuid;
    WCHAR           awszNotificationMsg[MAX_NOTIFICATION_MSG_SIZE];
    DWORD           dwReceivedId = 0;
    DWORD           dwDraft8HdrIncr = 0;
    DWORD           dwRetCode = NO_ERROR;

    //
    // If the protocol has not been started yet, call ElEapBegin
    //

    if (!(pPCB->fEapInitialized))
    {
        if (ElEapBegin (pPCB) != NO_ERROR)
        {
            TRACE1 (EAPOL, "ElEapWork: Error in ElEapBegin = %ld", dwRetCode);
            return dwRetCode;
        }
    }

    ZeroMemory(&EapResult, sizeof(EapResult));
    
    // Create buffer for EAPOL + EAP and pass pointer to EAP header

    pEapolPkt = (EAPOL_PACKET *) MALLOC (MAX_EAPOL_BUFFER_SIZE); 

    TRACE1 (EAPOL, "ElEapWork: EapolPkt created at %p", pEapolPkt);

    if (pEapolPkt == NULL)
    {
        TRACE0 (EAPOL, "ElEapWork: Error allocating EAP buffer");
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        return dwRetCode;
    }

    // Point to EAP header
    pSendPkt = (PPP_EAP_PACKET *)((PBYTE)pEapolPkt + sizeof (EAPOL_PACKET) - 1);

    if (pRecvPkt != NULL)
    {
        dwReceivedId = pRecvPkt->Id;
    }

    if (pPCB->fRemoteEnd8021XD8)
    {
        // Account for 2 bytes of AuthResultCode
        dwDraft8HdrIncr = 2;
    }

    dwRetCode = ElEapMakeMessage (pPCB,
                                pRecvPkt,
                                pSendPkt,
                                MAX_EAPOL_BUFFER_SIZE 
                                - sizeof(EAPOL_PACKET) - 1 - dwDraft8HdrIncr,
                                &EapResult
                                );

    // Notification message for the user

    if (NULL != EapResult.pszReplyMessage)
    {
        // Free earlier notication with the PCB
        if (pPCB->pszEapReplyMessage != NULL)
        {
            FREE (pPCB->pszEapReplyMessage);
            pPCB->pszEapReplyMessage = NULL;
        }

        pPCB->pszEapReplyMessage = EapResult.pszReplyMessage;

        // Notify user of message

#ifndef EAPOL_SERVICE

        ZeroMemory (awszNotificationMsg, MAX_NOTIFICATION_MSG_SIZE);
        if (0 == MultiByteToWideChar (
                    CP_ACP,
                    0,
                    pPCB->pszEapReplyMessage,
                    -1,
                    awszNotificationMsg, 
                    MAX_NOTIFICATION_MSG_SIZE))
        {
            dwRetCode = GetLastError();
    
            TRACE2 (EAPOL,"MultiByteToWideChar(%s) failed: %d",
                                        pPCB->pszEapReplyMessage,
                                        dwRetCode);
            FREE (pEapolPkt);
            pEapolPkt = NULL;
                
            return dwRetCode;
            
        }

        // Display notification message using sys tray balloon
        // on interface icon
        ElStringToGuid (pPCB->pszDeviceGUID, &DeviceGuid);
        (VOID)EAPOLMANNotification (&DeviceGuid,
                                    awszNotificationMsg,
                                    0);

#endif

        TRACE1 (EAPOL, "ElEapWork: Notified user of EAP data = %s",
              pPCB->pszEapReplyMessage);
    }

    if (dwRetCode != NO_ERROR)
    {
        switch (dwRetCode)
        {
            case ERROR_PPP_INVALID_PACKET:

                TRACE0 (EAPOL, "ElEapWork: Silently discarding invalid auth packet");
                break;
    
            default:

                TRACE1 (EAPOL, "ElEapWork: ElEapMakeMessage returned error %ld",
                                                                dwRetCode);

                // NotifyCallerOfFailure (pPCB, dwRetCode);

                break;
        }

        // Free up memory reserved for packet
        FREE (pEapolPkt);
        pEapolPkt = NULL;

        return dwRetCode;
    }

    //
    // Check to see if we have to save any user data
    //

    if (EapResult.fSaveUserData) 
    {
        if ((dwRetCode = ElSetEapUserInfo (
                        pPCB->hUserToken,
                        pPCB->pszDeviceGUID,
                        pPCB->dwEapTypeToBeUsed,
                        pPCB->pszSSID,
                        EapResult.pUserData,
                        EapResult.dwSizeOfUserData)) != NO_ERROR)
        {
            TRACE1 (EAPOL, "ElEapWork: ElSetEapUserInfo failed with error = %d",
                    dwRetCode);
            if (pEapolPkt != NULL)
            {
                FREE (pEapolPkt);
                pEapolPkt = NULL;
            }
            return dwRetCode;
        }

        TRACE1 (EAPOL, "ElEapWork: Saved EAP data for user, dwRetCode = %d", 
                dwRetCode);
    }

    //
    // Check to see if we have to save any connection data
    //

    if ((EapResult.fSaveConnectionData ) &&
         ( 0 != EapResult.SetCustomAuthData.dwSizeOfConnectionData ) )
    {
           
        if ((dwRetCode = ElSetCustomAuthData (
                        pPCB->pszDeviceGUID,
                        pPCB->dwEapTypeToBeUsed,
                        pPCB->pszSSID,
                        EapResult.SetCustomAuthData.pConnectionData,
                        EapResult.SetCustomAuthData.dwSizeOfConnectionData
                        )) != NO_ERROR)
        {
            TRACE1 ( EAPOL, "ElEapWork: ElSetCustomAuthData failed with error = %d",
                    dwRetCode);
            FREE (pEapolPkt);
            pEapolPkt = NULL;
            return dwRetCode;
        }

        TRACE0 ( EAPOL, "ElEapWork: Saved EAP data for connection" );
    }

    switch( EapResult.Action )
    {

        case ELEAP_Send:
        case ELEAP_SendAndDone:

            // Send out EAPOL packet

            memcpy ((BYTE *)pEapolPkt->EthernetType, 
                    (BYTE *)pPCB->bEtherType, 
                    SIZE_ETHERNET_TYPE);
            pEapolPkt->ProtocolVersion = pPCB->bProtocolVersion;
            pEapolPkt->PacketType = EAP_Packet;

            // The EAP packet length is in the packet returned back by 
            // the Dll MakeMessage
            // In case of Notification and Identity Response, it is in
            // EapResult.wSizeOfEapPkt

            if (EapResult.wSizeOfEapPkt == 0)
            {
                EapResult.wSizeOfEapPkt = 
                    WireToHostFormat16 (pSendPkt->Length);
            }
            HostToWireFormat16 ((WORD) EapResult.wSizeOfEapPkt,
                    (BYTE *)pEapolPkt->PacketBodyLength);


            // Make a copy of the EAPOL packet in the PCB
            // Will be used during retransmission

            if (pPCB->pbPreviousEAPOLPkt != NULL)
            {
                FREE (pPCB->pbPreviousEAPOLPkt);
            }
            pPCB->pbPreviousEAPOLPkt = 
                MALLOC (sizeof (EAPOL_PACKET)+EapResult.wSizeOfEapPkt-1);

            if (pPCB->pbPreviousEAPOLPkt == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (EAPOL, "ElEapWork: MALLOC failed for pbPreviousEAPOLPkt");
                if (pEapolPkt != NULL)
                {
                    FREE (pEapolPkt);
                    pEapolPkt = NULL;
                }
                return dwRetCode;
            }

            memcpy (pPCB->pbPreviousEAPOLPkt, pEapolPkt, 
                    sizeof (EAPOL_PACKET)+EapResult.wSizeOfEapPkt-1);

            pPCB->dwSizeOfPreviousEAPOLPkt = 
                sizeof (EAPOL_PACKET)+EapResult.wSizeOfEapPkt-1;

            pPCB->dwPreviousId = dwReceivedId;


            // Send packet out on the port
            dwRetCode = ElWriteToPort (pPCB,
                            (CHAR *)pEapolPkt,
                            sizeof (EAPOL_PACKET)+EapResult.wSizeOfEapPkt-1);
            if (dwRetCode != NO_ERROR)
            {
                TRACE1 (EAPOL, "ElEapWork: Error in writing EAP_Packet to port %ld",
                        dwRetCode);
                if (pEapolPkt != NULL)
                {
                    FREE (pEapolPkt);
                    pEapolPkt = NULL;
                }
                return dwRetCode;
            }

            if (pEapolPkt != NULL)
            {
                FREE (pEapolPkt);
                pEapolPkt = NULL;
            }

            // More processing to be done?
            // Supplicant side should not ever receive ELEAP_SendAndDone
            // result code

            if (EapResult.Action != ELEAP_SendAndDone)
            {
                break;
            }
            else
            {
                TRACE0 (EAPOL, "ElEapWork: ELEAP_SendAndDone wrong result received");
                ASSERT(0);
            }
    
        case ELEAP_Done:
    
            // Retrieve MPPE keys from the attributes information
            // returned by EAP-TLS

            switch (EapResult.dwError)
            {
            case NO_ERROR:
    
                TRACE0 (EAPOL, "ElEapWork: Authentication was successful");

                //
                // If authentication was successful
                //
    
                dwRetCode = ElExtractMPPESendRecvKeys (
                                            pPCB, 
                                            EapResult.pUserAttributes,
                                            (BYTE*)&(EapResult.abChallenge),
                                            (BYTE*)&(EapResult.abResponse));
    
                if (dwRetCode != NO_ERROR)
                {
                    FREE (pEapolPkt);
                    //NotifyCallerOfFailure (pPcb, dwRetCode);

                    return dwRetCode;
                }
    
                // ISSUE:
                // Do we want to retain UserAttributes
                // pPCB->pAuthProtocolAttributes = EapResult.pUserAttributes;
    
                break;
    

            default:
                if (pEapolPkt != NULL)
                {
                    FREE (pEapolPkt);
                    pEapolPkt = NULL;
                }
                TRACE0 (EAPOL, "ElEapWork: Authentication FAILED");
                break;
            }

            // Free memory allocated for the packet, since no response
            // is going to be sent out
            if (pEapolPkt != NULL)
            {
                FREE (pEapolPkt);
                pEapolPkt = NULL;
            }

            break;
    
        case ELEAP_NoAction:
            // Free memory allocated for the packet, since nothing
            // is being done with it
            if (pEapolPkt != NULL)
            {
                FREE (pEapolPkt);
                pEapolPkt = NULL;
            }

            break;
    
        default:
    
            break;
    }
    
    if (pEapolPkt != NULL)
    {
        FREE (pEapolPkt);
        pEapolPkt = NULL;
    }

    //
    // Check to see if we have to bring up the InteractiveUI for EAP
    // i.e. Server cert confirmation etc.
    //
    
    if (EapResult.fInvokeEapUI)
    {
        ElInvokeInteractiveUI (pPCB, &(EapResult.InvokeEapUIData));
    }

    return dwRetCode;
}


//
//
// ElExtractMPPESendRecvKeys
//
// Description:
//      Function called if authentication was successful. The MPPE Send &
//      Recv keys are extracted from the RAS_AUTH_ATTRIBUTE passed from
//      the EAP DLL and stored in the PCB. The keys are used to decrypt
//      the multicast WEP key and also are used for media-based encrypting.
//
// Return values
// 
//      NO_ERROR - Success
//      Non-zero - Failure
//

DWORD
ElExtractMPPESendRecvKeys (
    IN  EAPOL_PCB               *pPCB, 
    IN  RAS_AUTH_ATTRIBUTE *    pUserAttributes,
    IN  BYTE *                  pChallenge,
    IN  BYTE *                  pResponse
)
{
    RAS_AUTH_ATTRIBUTE *    pAttribute;
    RAS_AUTH_ATTRIBUTE *    pAttributeSendKey;
    RAS_AUTH_ATTRIBUTE *    pAttributeRecvKey;
    DWORD                   dwRetCode = NO_ERROR;
    DWORD                   dwEncryptionPolicy  = 0;
    DWORD                   dwEncryptionTypes   = 0;


    //
    // Every time we get encryption keys, plumb them to the driver
    //

    do
    {
        pAttribute = ElAuthAttributeGetVendorSpecific (
                                311, 12, pUserAttributes);


        pAttributeSendKey = ElAuthAttributeGetVendorSpecific ( 311, 16,
                                pUserAttributes);
        pAttributeRecvKey = ElAuthAttributeGetVendorSpecific ( 311, 17,
                                pUserAttributes);

        if ((pAttributeSendKey != NULL) 
            && (pAttributeRecvKey != NULL))
        {
            //
            // Set the MS-MPPE-Send-Key and MS-MPPE-Recv-Key with 
            // the ethernet driver
            //

            ULONG ulSendKeyLength = 0;
            ULONG ulRecvKeyLength = 0;

            // Based on PPP code
            ulSendKeyLength = *(((BYTE*)(pAttributeSendKey->Value))+8);
            ulRecvKeyLength = *(((BYTE*)(pAttributeRecvKey->Value))+8);
            TRACE0 (EAPOL, "Send key = ");
            EAPOL_DUMPBA (((BYTE*)(pAttributeSendKey->Value))+9,
                    ulSendKeyLength);

            TRACE0 (EAPOL, "Recv key = ");
            EAPOL_DUMPBA (((BYTE*)(pAttributeRecvKey->Value))+9,
                    ulRecvKeyLength);

            pPCB->dwMPPESendKeyLength = ulSendKeyLength;
            pPCB->dwMPPERecvKeyLength = ulRecvKeyLength;

            //
            // Copy MPPE Send and Receive Keys into the PCB for later usage
            // These keys will be used to decrypt the global multicast key
            // (if any).
            //

            if (pPCB->dwMPPESendKeyLength != 0)
            {
                if (pPCB->pbMPPESendKey != NULL)
                {
                    FREE (pPCB->pbMPPESendKey);
                    pPCB->pbMPPESendKey = NULL;
                }

                if ((pPCB->pbMPPESendKey = MALLOC (pPCB->dwMPPESendKeyLength))
                        == NULL)
                {
                    TRACE0 (EAPOL, "ElExtractMPPESendRecvKeys: Error in Malloc for SendKey");
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                memcpy (pPCB->pbMPPESendKey, 
                        ((BYTE*)(pAttributeSendKey->Value))+9, 
                        pPCB->dwMPPESendKeyLength);
            }

            if (pPCB->dwMPPERecvKeyLength != 0)
            {
                if (pPCB->pbMPPERecvKey != NULL)
                {
                    FREE (pPCB->pbMPPERecvKey);
                    pPCB->pbMPPERecvKey = NULL;
                }

                if ((pPCB->pbMPPERecvKey = MALLOC (pPCB->dwMPPERecvKeyLength))
                        == NULL)
                {
                    TRACE0 (EAPOL, "ElExtractMPPESendRecvKeys: Error in Malloc for RecvKey");
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                memcpy (pPCB->pbMPPERecvKey, 
                        ((BYTE*)(pAttributeRecvKey->Value))+9, 
                        pPCB->dwMPPERecvKeyLength);
            }

            TRACE0 (EAPOL,"MPPE-Send/Recv-Keys set");

        }
        else
        {
            TRACE0 (EAPOL, "ElExtractMPPESendRecvKeys: pAttributeSendKey or pAttributeRecvKey == NULL");
        }

    } while (FALSE);

    if (dwRetCode != NO_ERROR)
    {
        if (pPCB->pbMPPESendKey != NULL)
        {
            FREE (pPCB->pbMPPESendKey);
            pPCB->pbMPPESendKey = NULL;
        }

        if (pPCB->pbMPPERecvKey != NULL)
        {
            FREE (pPCB->pbMPPERecvKey);
            pPCB->pbMPPERecvKey = NULL;
        }
    }

    return( dwRetCode );

}


//
// ElProcessEapSuccess
//
// Description:
//
// Function called when an EAP_Success is received in any state
//
// Input arguments:
//  pPCB - Pointer to PCB for the port on which data is being processed
//  pEapolPkt - Pointer to EAPOL packet that was received
//              
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElProcessEapSuccess (
    IN EAPOL_PCB        *pPCB,
    IN EAPOL_PACKET     *pEapolPkt
    )
{
    GUID                    DeviceGuid;
    BOOLEAN                 fAuthenticateAndAuthorized = TRUE;
    EAPOL_PACKET_D8_D7      *pDummyHeader;
    DWORD                   dwRetCode = NO_ERROR;

    TRACE0 (EAPOL, "ElProcessEapSuccess: Got EAPCODE_Success");

    do
    {

        // Indicate to EAP=Dll to cleanup completed session
        if ((dwRetCode = ElEapEnd (pPCB)) != NO_ERROR)
        {
            TRACE1 (EAPOL, "ProcessReceivedPacket: EapSuccess: Error in ElEapEnd = %ld",
                    dwRetCode);
            break;
        }

        if (pPCB->fRemoteEnd8021XD8)
        {
            fAuthenticateAndAuthorized = FALSE;

            pDummyHeader = (EAPOL_PACKET_D8_D7 *)((BYTE *)pEapolPkt - 2);

            switch (WireToHostFormat16(pDummyHeader->AuthResultCode))
            {
                case AUTH_Authorized:
                    fAuthenticateAndAuthorized = TRUE;
                    break;
                case AUTH_Unauthorized:
                    fAuthenticateAndAuthorized = FALSE;
                    break;
                default:
                    fAuthenticateAndAuthorized = FALSE;
                    break;
            }
        }

        if (fAuthenticateAndAuthorized)
        {
            TRACE0 (EAPOL, "ElProcessEapSuccess: Autho and Authen successful");

            // Complete remaining processing i.e. DHCP
            if ((dwRetCode = FSMAuthenticated (pPCB,
                                        pEapolPkt)) != NO_ERROR)
            {
                break;
            }

#ifndef EAPOL_SERVICE

            // Display change of status using sys tray balloon
            // on interface icon
            ElStringToGuid (pPCB->pszDeviceGUID, &DeviceGuid);
            (VOID)EAPOLMANAuthenticationSucceeded (&DeviceGuid);

#endif
        }
        else
        {
            TRACE0 (EAPOL, "ElProcessEapSuccess: Autho and Authen failed");

            if ((dwRetCode = FSMHeld (pPCB)) != NO_ERROR)
            {
                break;
            }

#ifndef EAPOL_SERVICE

            // Display change of status using sys tray balloon
            // on interface icon
            ElStringToGuid (pPCB->pszDeviceGUID, &DeviceGuid);
            (VOID)EAPOLMANAuthenticationFailed (&DeviceGuid, 0);
    
#endif
        }

    } 
    while (FALSE);

    return dwRetCode;
}


//
// ElProcessEapFail
//
// Description:
//
// Function called when an EAP_Fail is received in any state
//
// Input arguments:
//  pPCB - Pointer to PCB for the port on which data is being processed
//  pEapolPkt - Pointer to EAPOL packet that was received
//              
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElProcessEapFail (
    IN EAPOL_PCB        *pPCB,
    IN EAPOL_PACKET     *pEapolPkt
    )
{
    GUID        DeviceGuid;
    DWORD       dwRetCode = NO_ERROR;

    TRACE0 (EAPOL, "ElProcessEapFail: Got EAPCODE_Failure");

    do
    {
        // Indicate to EAP=Dll to cleanup completed session
        if ((dwRetCode = ElEapEnd (pPCB)) != NO_ERROR)
        {
            TRACE1 (EAPOL, "ElProcessEapFail: EapFail: Error in ElEapEnd = %ld",
                    dwRetCode);
            break;
        }

        if ((dwRetCode = FSMHeld (pPCB)) != NO_ERROR)
        {
            break;
        }

#ifndef EAPOL_SERVICE

        // Display change of status using sys tray balloon
        // on interface icon
        ElStringToGuid (pPCB->pszDeviceGUID, &DeviceGuid);
        (VOID)EAPOLMANAuthenticationFailed (&DeviceGuid, 0);

#endif

    } 
    while (FALSE);

    return dwRetCode;
}

#undef EAPOL_SERVICE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\elsync.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:


Abstract:

    The file contains the READ_WRITE_LOCK definition which allows
    multiple-reader/single-writer.  This implementation DOES NOT
    starve a thread trying to acquire write accesss if there are
    a large number of threads interested in acquiring read access.

Revision History:

    mohitt, sachins, Apr 23 2000, Created

--*/

#include "pcheapol.h"
#pragma hdrstop

//----------------------------------------------------------------------------
// Function: CreateReadWriteLock
//
// Initializes a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

DWORD
CreateReadWriteLock(
    PREAD_WRITE_LOCK    pRWL,
    PCHAR               szName
    ) 
{

    sprintf(pRWL->RWL_Name, "%.3s", szName);
    
    pRWL->RWL_ReaderCount = 0;

    __try {
        InitializeCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        return GetLastError();
    }

    pRWL->RWL_ReaderDoneEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (pRWL->RWL_ReaderDoneEvent != NULL) {
        return GetLastError();
    }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DeleteReadWriteLock
//
// Frees resources used by a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

VOID
DeleteReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) 
{

    CloseHandle(pRWL->RWL_ReaderDoneEvent);
    pRWL->RWL_ReaderDoneEvent = NULL;
    DeleteCriticalSection(&pRWL->RWL_ReadWriteBlock);
    pRWL->RWL_ReaderCount = 0;
}



//----------------------------------------------------------------------------
// Function:    AcquireReadLock
//
// Secures shared ownership of the lock object for the caller.
//
// readers enter the read-write critical section, increment the count,
// and leave the critical section
//----------------------------------------------------------------------------

VOID
AcquireReadLock(
    PREAD_WRITE_LOCK pRWL
    ) 
{

    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock); 
    InterlockedIncrement(&pRWL->RWL_ReaderCount);
    LeaveCriticalSection(&pRWL->RWL_ReadWriteBlock);
}



//----------------------------------------------------------------------------
// Function:    ReleaseReadLock
//
// Relinquishes shared ownership of the lock object.
//
// the last reader sets the event to wake any waiting writers
//----------------------------------------------------------------------------

VOID
ReleaseReadLock(
    PREAD_WRITE_LOCK pRWL
    ) 
{

    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) < 0) {
        SetEvent(pRWL->RWL_ReaderDoneEvent); 
    }
}



//----------------------------------------------------------------------------
// Function:    AcquireWriteLock
//
// Secures exclusive ownership of the lock object.
//
// the writer blocks other threads by entering the ReadWriteBlock section,
// and then waits for any thread(s) owning the lock to finish
//----------------------------------------------------------------------------

VOID
AcquireWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) 
{

    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock);
    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) >= 0) { 
        WaitForSingleObject(pRWL->RWL_ReaderDoneEvent, INFINITE);
    }
}



//----------------------------------------------------------------------------
// Function:    ReleaseWriteLock
//
// Relinquishes exclusive ownership of the lock object.
//
// the writer releases the lock by setting the count to zero
// and then leaving the ReadWriteBlock critical section
//----------------------------------------------------------------------------

VOID
ReleaseWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) 
{

    InterlockedIncrement(&pRWL->RWL_ReaderCount);
    LeaveCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
}

#if 0

//----------------------------------------------------------------------------
// InitializeDynamicLocksStore
//
// Initialize the structure from which dynamic readwrite locks are allocated.
//----------------------------------------------------------------------------

DWORD
InitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE    pStore,
    HANDLE                  hHeap,
    PCHAR                   szName
    ) 
{

    sprintf(pStore->szName, "%.3s", szName);
    
    // initialize the heap from where dynamic locks are allocated
    pStore->hHeap = hHeap;
    
    INITIALIZE_LOCKED_LIST(&pStore->llFreeLocksList, szName);
    if (!LOCKED_LIST_INITIALIZED(&pStore->llFreeLocksList))
        return GetLastError();

    // initialize the count of the number of free and allocated locks
    pStore->ulCountAllocated = pStore->ulCountFree = 0;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// DeInitializeDynamicLocksStore
//
// Fail if any allocated locks have not been freed.
// Delete the free locks and the FreeLocksList.
//----------------------------------------------------------------------------

DWORD
DeInitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE    pStore
    ) 
{
    
    PDYNAMIC_READWRITE_LOCK pLock;
    PLIST_ENTRY             pleHead, ple;

    // can't complete if any locks are still allocated!!!
    if (pStore->ulCountAllocated)
        return ERROR_CAN_NOT_COMPLETE;

    // deinitialize the count of the number of free and allocated locks
    pStore->ulCountAllocated = pStore->ulCountFree = 0;

    // deinitialize the FreeLocksList
    pStore->llFreeLocksList.created = 0;

    // delete all dynamic readwrite locks and free the memory.
    pleHead = &(pStore->llFreeLocksList.head);
    for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
    {
        pLock = CONTAINING_RECORD(ple, DYNAMIC_READWRITE_LOCK, leLink);
        DELETE_READ_WRITE_LOCK(&pLock->rwlLock);
        HeapFree(pStore->hHeap, 0, pLock);
    }

    DeleteCriticalSection(&(pStore->llFreeLocksList.lock));

    // deinitialize the heap from where dynamic locks are allocated
    pStore->hHeap = NULL;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// GetDynamicReadwriteLock
//
// Return a free dynamic readwrite lock, if one is available.
// Else allocate a new dynamic readwrite lock.
// Assumes pStore->llFreeLocksList is locked.
//----------------------------------------------------------------------------

PDYNAMIC_READWRITE_LOCK
GetDynamicReadwriteLock (
    PDYNAMIC_LOCKS_STORE    pStore
    ) 
{

    PDYNAMIC_READWRITE_LOCK pLock;
    PLIST_ENTRY             pleHead, ple;

    do                          // breakout loop
    {
        // a free dynamic lock is available. Return it
        pleHead = &(pStore->llFreeLocksList.head);
        if (!IsListEmpty(pleHead))
        {
            pStore->ulCountFree--;
            ple = RemoveHeadList(pleHead);
            pLock = CONTAINING_RECORD(ple, DYNAMIC_READWRITE_LOCK, leLink);
            break;
        }
    
        // allocate memory for a new dynamic lock
        pLock = HeapAlloc(pStore->hHeap, 0, sizeof(DYNAMIC_READWRITE_LOCK));
        if (pLock ==  NULL)
            break;

        // initialize the fields
        CREATE_READ_WRITE_LOCK(&(pLock->rwlLock), pStore->szName);
        if (!READ_WRITE_LOCK_CREATED(&(pLock->rwlLock)))
        {
            HeapFree(pStore->hHeap, 0, pLock);
            pLock = NULL;
            break;
        }
    } while (FALSE);

    if (pLock != NULL)
    {
        pStore->ulCountAllocated++;
        pLock->ulCount = 0;
    }

    return pLock;
}
    

    
//----------------------------------------------------------------------------
// FreeDynamicReadwriteLock
//
// Accepts a released dynamic readwrite lock.
// Frees it if there are too many dynamic readwrite locks.
// Assumes pStore->llFreeLocksList is locked.
//----------------------------------------------------------------------------

VOID
FreeDynamicReadwriteLock (
    PDYNAMIC_READWRITE_LOCK pLock,
    PDYNAMIC_LOCKS_STORE    pStore
    ) 
{

    PLIST_ENTRY             pleHead;


    // decrement count of allocated locks
    pStore->ulCountAllocated--;

    // if there are too many dynamic readwrite locks, then free this lock
    if ((pStore->ulCountAllocated + pStore->ulCountFree + 1) >
        DYNAMIC_LOCKS_HIGH_THRESHOLD)
    {
        DELETE_READ_WRITE_LOCK(&pLock->rwlLock);
        HeapFree(pStore->hHeap, 0, pLock);    
    }
    else                        // insert into the list of free locks
    {
        pleHead = &(pStore->llFreeLocksList.head);
        InsertHeadList(pleHead, &pLock->leLink);
        pStore->ulCountFree++;
    }

    return;
}



//----------------------------------------------------------------------------
// AcquireDynamicLock
//
// Locks the FreeLocksList.
// Allocates a new dynamic lock if required.
// Increments the count.
// Unlocks the FreeLocksList.
// Acquires the dynamic lock.
//----------------------------------------------------------------------------

DWORD
AcquireDynamicReadwriteLock (
    PDYNAMIC_READWRITE_LOCK *ppLock,
    LOCK_MODE               lmMode,
    PDYNAMIC_LOCKS_STORE    pStore
    ) 
{

    // acquire the lock for the free locks list
    AcquireListLock(&pStore->llFreeLocksList);
    
    // if it does not already exist, allocate a new dynamic lock
    if (*ppLock == NULL)
    {
        *ppLock = GetDynamicReadwriteLock(pStore);

        // if could not get a lock we are in serious trouble
        if (*ppLock == NULL)
        {
            ReleaseListLock(&pStore->llFreeLocksList);
            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    // increment count in the dynamic lock
    (*ppLock)->ulCount++;

    // release the lock for the free locks list
    ReleaseListLock(&pStore->llFreeLocksList);    

    // acquire dynamic lock
    if (lmMode == READ_MODE)
        AcquireReadLock(&(*ppLock)->rwlLock);
    else
        AcquireWriteLock(&(*ppLock)->rwlLock);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// ReleaseDynamicReadwriteLock
//
// Locks the FreeLocksList.
// Releases the dynamic lock.
// Decrements the count.
// Free the dynamic lock if count becomes 0.
// Unlocks the FreeLocksList.
//----------------------------------------------------------------------------

VOID
ReleaseDynamicReadwriteLock (
    PDYNAMIC_READWRITE_LOCK *ppLock,
    LOCK_MODE               lmMode,
    PDYNAMIC_LOCKS_STORE    pStore
    ) 
{

    // acquire the lock for the free locks list
    AcquireListLock(&pStore->llFreeLocksList);

    // release the dynamic readwrite lock
    if (lmMode == READ_MODE)
        ReleaseReadLock(&(*ppLock)->rwlLock);
    else 
        ReleaseWriteLock(&(*ppLock)->rwlLock);

    // decrement count in the dynamic lock, free it if count becomes 0
    (*ppLock)->ulCount--;
    if ((*ppLock)->ulCount is 0)
    {
        FreeDynamicReadwriteLock(*ppLock, pStore);
        *ppLock = NULL;         // so it is known that it doesn't exist 
    }

    // release the lock for the free locks list
    ReleaseListLock(&pStore->llFreeLocksList);    

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\makefile.inc ===
eapolmsg.mc: eapollog.h
    mapmsg EAPOL EAPOL_LOG_BASE eapollog.h > eapolmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\eluser.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    
    eluser.h

Abstract:

    The module deals with declarations related to user interaction, user logon


Revision History:

    sachins, Apr 23 2000, Created

--*/

#ifndef _EAPOL_USER_H_
#define _EAPOL_USER_H_

//
// Dialer dialogs argument block.  
//
typedef struct
_USERDLGARGS
{
    EAPOL_PCB       *pPCB;
} USERDLGARGS;

//
// Dialer dialogs context block. 
//
typedef struct
USERDLGINFO
{
    // Common dial context information including the RAS API arguments.
    //
    USERDLGARGS* pArgs;

    // Handle of the dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndEbUser;
    HWND hwndEbPw;
    HWND hwndEbDomain;
    HWND hwndCbSavePw;
    HWND hwndClbNumbers;
    HWND hwndStLocations;
    HWND hwndLbLocations;
    HWND hwndPbRules;
    HWND hwndPbProperties;

    // Window handles and original window procedure of the subclassed
    // 'hwndClbNumbers' control's edit-box and list-box child windows.
    //
    HWND hwndClbNumbersEb;
    HWND hwndClbNumbersLb;
    WNDPROC wndprocClbNumbersEb;
    WNDPROC wndprocClbNumbersLb;

    // Set if COM has been initialized (necessary for calls to netshell).
    //
    BOOL fComInitialized;
} USERDLGINFO;

DWORD
ElGetUserIdentity (
        IN  EAPOL_PCB       *pPCB
        );

DWORD
ElGetUserNamePassword (
        IN  EAPOL_PCB       *pPCB
        );

VOID
ElUserLogonCallback (
        IN  PVOID           pvContext,
        IN  BOOLEAN         fTimerOfWaitFired
        );

VOID
ElUserLogoffCallback (
        IN  PVOID           pvContext,
        IN  BOOLEAN         fTimerOfWaitFired
        );

DWORD
ElInvokeInteractiveUI (
        IN  EAPOL_PCB               *pPCB,
        IN  ELEAP_INVOKE_EAP_UI     *pInvokeEapUIIn
        );

VOID
ElUserDlgSave (
        IN  USERDLGINFO      *pInfo
        );
BOOL
ElUserDlgCommand (
        IN  USERDLGINFO      *pInfo,
        IN  WORD        wNotification,
        IN  WORD        wId,
        IN  HWND        hwndCtrl
        );
DWORD
ElUserDlg (
        IN  HWND        hwndOwner,
        IN  EAPOL_PCB   *pPCB
        );

BOOL
ElUserDlgInit (
        IN  HWND    hwndDlg,
        IN  USERDLGARGS  *pArgs
        );

VOID
ElUserDlgTerm (
        IN  HWND    hwndDlg,
        IN  USERDLGINFO      *pInfo
        );

INT_PTR
ElUserDlgProc (
        IN HWND hwnd,
        IN UINT unMsg,
        IN WPARAM wparam,
        IN LPARAM lparam );

#endif // _EAPOL_USER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\cmevent.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       C M E V E N T  . H
//
//  Contents:   Connection manager Event type declarations
//
//  Notes:
//
//  Author:     ckotze   1 Mar 2001
//
//----------------------------------------------------------------------------
#pragma once
#include "nmbase.h"
#include "nmres.h"
#include <rasapip.h>

enum CONMAN_MANAGER
{
    INVALID_MANAGER = 0,
    CONMAN_INCOMING,
    CONMAN_LAN,
    CONMAN_RAS,
};

struct CONMAN_EVENT
{
    CONMAN_EVENTTYPE    Type;
    CONMAN_MANAGER      ConnectionManager;

    union
    {
    // CONNECTION_ADDED
    // CONNECTION_MODIFIED
        RASENUMENTRYDETAILS Details;
        struct
        {
            NETCON_PROPERTIES*   pProps;         // ConnectionManager = CONMAN_RAS and CONMAN_LAN
            BYTE*                pbPersistData;  // ConnectionManager = CONMAN_RAS and EVENTTYPE = CONNECTION_ADDED
            ULONG                cbPersistData;  // ConnectionManager = CONMAN_RAS and EVENTTYPE = CONNECTION_ADDED
        };

        NETCON_PROPERTIES_EX*   pPropsEx;
    
    // CONNECTION_DELETED
        GUID                guidId;
        
    // INCOMING_CONNECTED
    // INCOMING_DISCONNECTED
        struct
        {
            GUID                guidId;         // ConnectionManager = CONMAN_INCOMING and type = INCOMING_CONNECTED/DISCONNECTED
            HANDLE              hConnection;    // ConnectionManager = CONMAN_INCOMING and EVENTYPE = CONNECTION_ADDED
            DWORD               dwConnectionType;
        };

    // CONNECTION_RENAMED
        struct
        {
            GUID            guidId;
            WCHAR           szNewName [RASAPIP_MAX_ENTRY_NAME + 1];
        };

    // CONNECTION_STATUS_CHANGE
        struct
        {
            GUID            guidId;
            NETCON_STATUS   Status;
        };

    // CONNECTION_BALLOON_POPUP
        struct
        {
            GUID            guidId;
            BSTR            szCookie;
            BSTR            szBalloonText;
        };

	// DISABLE_EVENTS
        struct
        {
            BOOL            fDisable;
            ULONG           ulDisableTimeout;
        };
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\eluser.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:
    
    eluser.c


Abstract:

    The module deals with functions related to user interaction, user logon


Revision History:

    sachins, Apr 23 2000, Created

--*/


#include "pcheapol.h"
#pragma hdrstop

//
// Test code declarations for EAP-MD5CHAP
//



// This function is not defined in any header file. Located in
// $(SDK_LIB_PATH)\irnotif.lib

extern HANDLE
GetCurrentUserTokenW (
        WCHAR       Winsta[],
        DWORD       DesiredAccess
        );

extern BOOL
GetWinStationUserToken(ULONG, PHANDLE);

extern ULONG
GetClientLogonId ();

#define cszEapKeyRas   TEXT("Software\\Microsoft\\RAS EAP\\UserEapInfo")

#define cszEapValue TEXT("EapInfo")

#ifndef EAPOL_SERVICE
#define cszModuleName TEXT("netman.dll")
#else
#define cszModuleName TEXT("eapol.exe")
#endif


//
// ElGetUserIdentity
//
// Description:
//
// Function called to initiate and get user identity on a particular 
// interface. The RasEapGetIdentity in the appropriate DLL is called
// with the necessary arguments.
// 
// Arguments:
//  pPCB - Pointer to PCB for the specific port/interface
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElGetUserIdentity (
        IN  EAPOL_PCB       *pPCB
        )
{
    HANDLE              hUserToken;
    HANDLE              hLib = NULL;
    EAPOLEAPFREE        pFreeFunc = NULL;
    EAPOLEAPGETIDENTITY pIdenFunc = NULL;
    DWORD               dwIndex = -1;
    DWORD               cbData = 0;
    PBYTE               pbAuthData = NULL;
    PBYTE               pbUserIn = NULL;
    DWORD               dwInSize = 0;
    BYTE                *pUserDataOut;
    DWORD               dwSizeOfUserDataOut;
    LPWSTR              lpwszIdentity = NULL;
    HWND                hwndOwner = NULL;
    HWINSTA             hwinstaSave;
    HDESK               hdeskSave;
    HWINSTA             hwinstaUser;
    HDESK               hdeskUser;
    DWORD               dwThreadId;
    UNICODE_STRING      IdentityUnicodeString;
    ANSI_STRING         IdentityAnsiString;
    CHAR                Buffer[256];
    WCHAR               wszFriendlyName[256]; // Friendly name max 255 char
    CHAR                *pszUserName = NULL;
    DWORD               dwFlags = 0;
    DWORD               dwRetCode = NO_ERROR;

    do 
    {
        // If machine auth not enabled


        TRACE0 (USER, "ElGetUserIdentity entered");

        //
        // NOTE:
        // Optimize pPCB->rwLock lock holding time
        //
        
        ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

        if (pPCB->PreviousAuthenticationType != EAPOL_MACHINE_AUTHENTICATION)
        {

        if (!EAPOL_PORT_ACTIVE(pPCB))
        {
            TRACE1 (PORT, "ElGetUserIdentity: Port %s not active",
                    pPCB->pszDeviceGUID);

            // Port is not active, cannot do further processing on this port
            
            break;
        }

        //
        // Get Access Token for user logged on interactively
        //
        
        // Call Terminal Services API

        if (GetWinStationUserToken (GetClientLogonId(), &hUserToken) 
                != NO_ERROR)
        {
            TRACE0 (USER, "ElGetUserIdentity: Terminal Services API GetWinStationUserToken failed !!! ");

            // Call private API

            hUserToken = GetCurrentUserTokenW (L"WinSta0",
                                        TOKEN_QUERY |
                                        TOKEN_DUPLICATE |
                                        TOKEN_ASSIGN_PRIMARY);
            if (hUserToken == NULL)
            {
                dwRetCode = GetLastError ();
                TRACE1 (USER, "ElGetUserIdentity: Error in GetCurrentUserTokenW = %ld",
                    dwRetCode);
                dwRetCode = ERROR_NO_TOKEN;
                break;
            }
        }
                                        
        if (hUserToken == NULL)
        {
            dwRetCode = GetLastError ();
            TRACE0 (USER, "ElGetUserIdentity: Error in getting current user token");
            dwRetCode = ERROR_NO_TOKEN;
            break;
        }

        pPCB->hUserToken = hUserToken;

        // Get the size of the user blob
        if ((dwRetCode = ElGetEapUserInfo (
                        pPCB->hUserToken,
                        pPCB->pszDeviceGUID,
                        pPCB->dwEapTypeToBeUsed,
                        pPCB->pszSSID,
                        NULL,
                        &dwInSize
                        )) != NO_ERROR)
        {
            if (dwRetCode == ERROR_BUFFER_TOO_SMALL)
            {
                if (dwInSize <= 0)
                {
                    // No blob stored in the registry
                    // Continue processing
                    TRACE0 (USER, "ElGetUserIdentity: NULL sized user data");
                    pbUserIn = NULL;
                }
                else
                {
                    // Allocate memory to hold the blob
                    pbUserIn = MALLOC (dwInSize);
                    if (pbUserIn == NULL)
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        TRACE0 (USER, "ElGetUserIdentity: Error in memory allocation for User data");
                        break;
                    }
                    if ((dwRetCode = ElGetEapUserInfo (
                                pPCB->hUserToken,
                                pPCB->pszDeviceGUID,
                                pPCB->dwEapTypeToBeUsed,
                                pPCB->pszSSID,
                                pbUserIn,
                                &dwInSize
                                )) != NO_ERROR)
                    {
                        TRACE1 (USER, "ElGetUserIdentity: ElGetEapUserInfo failed with %ld",
                                dwRetCode);
                        break;
                    }
                }
            }
            else
            {
                // User info may not have been created till now
                // which is valid condition to proceed
                if (dwRetCode != ERROR_FILE_NOT_FOUND)
                {
                    TRACE1 (USER, "ElGetUserIdentity: ElGetEapUserInfo size estimation failed with error %ld",
                            dwRetCode);
                    break;
                }
            }
        }

        // The EAP dll will have already been loaded by the state machine
        // Retrieve the handle to the dll from the global EAP table

        if ((dwIndex = ElGetEapTypeIndex (pPCB->dwEapTypeToBeUsed)) == -1)
        {
            TRACE1 (USER, "ElGetUserIdentity: ElGetEapTypeIndex finds no dll for EAP index %ld",
                    pPCB->dwEapTypeToBeUsed);
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        hLib = g_pEapTable[dwIndex].hInstance;

        pIdenFunc = (EAPOLEAPGETIDENTITY)GetProcAddress(hLib, 
                                                    "RasEapGetIdentity");
        pFreeFunc = (EAPOLEAPFREE)GetProcAddress(hLib, "RasEapFreeMemory");

        if ((pFreeFunc == NULL) || (pIdenFunc == NULL))
        {
            TRACE0 (USER, "ElGetUserIdentity: pIdenFunc or pFreeFunc does not exist in the EAP implementation");
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Get the size of the EAP blob
        if ((dwRetCode = ElGetCustomAuthData (
                        pPCB->pszDeviceGUID,
                        pPCB->dwEapTypeToBeUsed,
                        pPCB->pszSSID,
                        NULL,
                        &cbData
                        )) != NO_ERROR)
        {
            if (dwRetCode == ERROR_BUFFER_TOO_SMALL)
            {
                if (cbData <= 0)
                {
                    // No EAP blob stored in the registry
                    TRACE0 (USER, "ElGetUserIdentity: NULL sized EAP blob, cannot continue");
                    pbAuthData = NULL;
                    // Every port should have connection data !!!
                    dwRetCode = ERROR_CAN_NOT_COMPLETE;
                    break;
                }
                else
                {
                    // Allocate memory to hold the blob
                    pbAuthData = MALLOC (cbData);
                    if (pbAuthData == NULL)
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        TRACE0 (USER, "ElGetUserIdentity: Error in memory allocation for EAP blob");
                        break;
                    }
                    if ((dwRetCode = ElGetCustomAuthData (
                                pPCB->pszDeviceGUID,
                                pPCB->dwEapTypeToBeUsed,
                                pPCB->pszSSID,
                                pbAuthData,
                                &cbData
                                )) != NO_ERROR)
                    {
                        TRACE1 (USER, "ElGetUserIdentity: ElGetCustomAuthData failed with %ld",
                                dwRetCode);
                        break;
                    }
                }
            }
            else
            {
                // CustomAuthData for "Default" is always created for an
                // interface when EAPOL starts up
                TRACE1 (USER, "ElGetUserIdentity: ElGetCustomAuthData size estimation failed with error %ld",
                        dwRetCode);
                break;
            }
        }

        // Save handles to service window

        hwinstaSave = GetProcessWindowStation();
        if (hwinstaSave == NULL)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "OpenWindowStation: GetProcessWindowStation failed with error %ld",
                    dwRetCode);
            break;
        }

        dwThreadId = GetCurrentThreadId ();

        hdeskSave = GetThreadDesktop (dwThreadId);
        if (hdeskSave == NULL)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "OpenWindowStation: GetThreadDesktop failed with error %ld",
                    dwRetCode);
            break;
        }


        if (!ImpersonateLoggedOnUser (pPCB->hUserToken))
        {
            dwRetCode = GetLastError();
            TRACE1 (USER, "ElGetUserIdentity: ImpersonateLoggedOnUse failed with error %ld",
                    dwRetCode);
            break;
        }

        // Impersonate the client and connect to the User's window station
        // and desktop. This will be the interactively logged-on user

        hwinstaUser = OpenWindowStation (L"WinSta0", FALSE, MAXIMUM_ALLOWED);
        if (hwinstaUser == NULL)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "OpenWindowStation: OpenWindowStation failed with error %ld",
                    dwRetCode);
            break;
        }

        if (!SetProcessWindowStation(hwinstaUser))
            TRACE1 (USER, "ElGetUserIdentity: SetProcessWindowStation failed with error = %ld",
                    (dwRetCode = GetLastError()));
        hdeskUser = OpenDesktop (L"Default", 0, FALSE, MAXIMUM_ALLOWED);
        if (hdeskUser == NULL)
        {
            if (!SetProcessWindowStation (hwinstaSave))
                TRACE1 (USER, "ElGetUserIdentity: SetProcessWindowStation failed with error = %ld",
                        (dwRetCode = GetLastError()));
            if (!CloseWindowStation (hwinstaUser))
                TRACE1 (USER, "ElGetUserIdentity: CloseWindowStation failed with error = %ld",
                    (dwRetCode = GetLastError()));
            dwRetCode = ERROR_INVALID_WORKSTATION;
            break;
        }

        if (!SetThreadDesktop (hdeskUser))
            TRACE1 (USER, "ElGetUserIdentity: SetThreadDesktop failed with error = %ld",
                    (dwRetCode = GetLastError()));

        // Get handle to desktop window

        hwndOwner = GetDesktopWindow ();

        ZeroMemory (wszFriendlyName, 256*sizeof(WCHAR));

        // Convert the friendly name of the adapter to a display ready
        // form
        if (pPCB->pszFriendlyName)
        {
            if (0 == MultiByteToWideChar(
                        CP_ACP,
                        0,
                        pPCB->pszFriendlyName,
                        -1,
                        wszFriendlyName,
                        256 ) )
            {
                dwRetCode = GetLastError();

                TRACE2 (USER, "ElGetUserIdentity: MultiByteToWideChar(%s) failed: %d",
                        pPCB->pszFriendlyName,
                        dwRetCode);
                break;
            }
        }

        if (pIdenFunc)
        if ((dwRetCode = (*(pIdenFunc))(
                        pPCB->dwEapTypeToBeUsed,
                        hwndOwner, // hwndOwner
                        0, // dwFlags
                        NULL, // lpszPhonebook
                        wszFriendlyName, // lpszEntry
                        pbAuthData, // Connection data
                        cbData, // Count of pbAuthData
                        pbUserIn, // User data for port
                        dwInSize, // Size of user data
                        &pUserDataOut,
                        &dwSizeOfUserDataOut,
                        &lpwszIdentity
                        )) != NO_ERROR)
        {
            TRACE1 (USER, "ElGetUserIdentity: Error in calling GetIdentity = %ld",
                    dwRetCode);
            // Revert impersonation
            if (!RevertToSelf())
            {
                dwRetCode = GetLastError();
                TRACE1 (USER, "ElGetUserIdentity: Error in RevertToSelf = %ld",
                    dwRetCode);
            }

            // Restore window station and desktop
            if (!SetThreadDesktop (hdeskSave))
                TRACE1 (USER, "ElGetUserIdentity: SetThreadDesktop failed with error = %ld",
                        (dwRetCode = GetLastError()));
            if (!SetProcessWindowStation (hwinstaSave))
                TRACE1 (USER, "ElGetUserIdentity: SetProcessWindowStation failed with error = %ld",
                        (dwRetCode = GetLastError()));
            if (!CloseDesktop(hdeskUser))
                TRACE1 (USER, "ElGetUserIdentity: CloseDesktop failed with error = %ld",
                        (dwRetCode = GetLastError()));
            if (!CloseWindowStation(hwinstaUser))
                TRACE1 (USER, "ElGetUserIdentity: CloseWindowStation failed with error = %ld",
                        (dwRetCode = GetLastError()));

            break;
        }

        // Revert impersonation
        if (!RevertToSelf())
        {
            dwRetCode = GetLastError();
            TRACE1 (USER, "ElGetUserIdentity: Error in RevertToSelf = %ld",
                    dwRetCode);
            // Restore window station and desktop
            if (!SetThreadDesktop (hdeskSave))
                TRACE1 (USER, "ElGetUserIdentity: SetThreadDesktop failed with error = %ld",
                        (dwRetCode = GetLastError()));
            if (!SetProcessWindowStation (hwinstaSave))
                TRACE1 (USER, "ElGetUserIdentity: SetProcessWindowStation failed with error = %ld",
                        (dwRetCode = GetLastError()));
            if (!CloseDesktop(hdeskUser))
                TRACE1 (USER, "ElGetUserIdentity: CloseDesktop failed with error = %ld",
                        (dwRetCode = GetLastError()));
            if (!CloseWindowStation(hwinstaUser))
                TRACE1 (USER, "ElGetUserIdentity: CloseWindowStation failed with error = %ld",
                        (dwRetCode = GetLastError()));
            break;
        }

        // Restore window station and desktop settings
        if (!SetThreadDesktop (hdeskSave))
            TRACE1 (USER, "ElGetUserIdentity: SetThreadDesktop failed with error = %ld",
                    (dwRetCode = GetLastError()));
        if (!SetProcessWindowStation (hwinstaSave))
            TRACE1 (USER, "ElGetUserIdentity: SetProcessWindowStation failed with error = %ld",
                    (dwRetCode = GetLastError()));
        if (!CloseDesktop(hdeskUser))
            TRACE1 (USER, "ElGetUserIdentity: CloseDesktop failed with error = %ld",
                    (dwRetCode = GetLastError()));
        if (!CloseWindowStation(hwinstaUser))
            TRACE1 (USER, "ElGetUserIdentity: CloseWindowStation failed with error = %ld",
                    (dwRetCode = GetLastError()));
       
        
        // Fill in the returned information into the PCB fields for 
        // later authentication

        if (pPCB->pCustomAuthUserData != NULL)
        {
            FREE (pPCB->pCustomAuthUserData);
            pPCB->pCustomAuthUserData = NULL;
        }

        pPCB->pCustomAuthUserData = MALLOC (dwSizeOfUserDataOut + sizeof (DWORD));
        if (pPCB->pCustomAuthUserData == NULL)
        {
            TRACE1 (USER, "ElGetUserIdentity: Error in allocating memory for UserInfo = %ld",
                    dwRetCode);
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pPCB->pCustomAuthUserData->dwSizeOfCustomAuthData = dwSizeOfUserDataOut;

        if ((dwSizeOfUserDataOut != 0) && (pUserDataOut != NULL))
        {
            memcpy ((BYTE *)pPCB->pCustomAuthUserData->pbCustomAuthData, 
                (BYTE *)pUserDataOut, 
                dwSizeOfUserDataOut);
        }

        if (lpwszIdentity != NULL)
        {
            // NOTE:
            // Assuming 256 character identity maximum

            // Convert wchar Identity to char string
            RtlInitUnicodeString (&IdentityUnicodeString, lpwszIdentity);
            IdentityAnsiString.MaximumLength = sizeof(Buffer);
            IdentityAnsiString.Buffer = Buffer;
            IdentityAnsiString.Length = 0;
            if ((dwRetCode = RtlUnicodeStringToAnsiString (
                    &IdentityAnsiString,
                    &IdentityUnicodeString,
                    FALSE)) != NO_ERROR)
            {
                TRACE1 (USER, "ElGetUserIdentity: Error in RtlConvertUnicodeStringToAnsiString = %ld",
                        dwRetCode);
                break;
            }

            pszUserName = MALLOC (IdentityAnsiString.Length + 1);
            if (pszUserName == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (USER, "ElGetUserIdentity: MALLOC failed for pszUserName");
                break;
            }

            memcpy (pszUserName, 
                    IdentityAnsiString.Buffer, 
                    IdentityAnsiString.Length);
            pszUserName[IdentityAnsiString.Length] = '\0';

            if (pPCB->pszIdentity != NULL)
            {
                FREE (pPCB->pszIdentity);
                pPCB->pszIdentity = NULL;
            }

            pPCB->pszIdentity = MALLOC (IdentityAnsiString.Length + 1);
            if (pPCB->pszIdentity == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (USER, "ElGetUserIdentity: MALLOC failed for pPCB->pszIdentity");
                break;
            }

            memcpy (pPCB->pszIdentity, 
                    IdentityAnsiString.Buffer, 
                    IdentityAnsiString.Length);
            pPCB->pszIdentity[IdentityAnsiString.Length] = '\0';

            TRACE1 (USER, "ElGetUserIdentity: Got username = %s",
                    pszUserName);
        }

        if (pPCB->pCustomAuthConnData != NULL)
        {
            FREE (pPCB->pCustomAuthConnData);
            pPCB->pCustomAuthConnData = NULL;
        }

        // Memory for pCustomAuthConnData and pCustomAuthUserData
        // is released from the PCB when user logs off and during
        // port deletion 

        pPCB->pCustomAuthConnData = MALLOC (cbData + sizeof (DWORD));
        if (pPCB->pCustomAuthConnData == NULL)
        {
            TRACE1 (USER, "ElGetUserIdentity: Error in allocating memory for AuthInfo = %ld",
                    dwRetCode);
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pPCB->pCustomAuthConnData->dwSizeOfCustomAuthData = cbData;

        if ((cbData != 0) && (pbAuthData != NULL))
        {
            memcpy ((BYTE *)pPCB->pCustomAuthConnData->pbCustomAuthData, 
                (BYTE *)pbAuthData, 
                cbData);
        }

        // Mark the identity has been obtained for this PCB
        pPCB->fGotUserIdentity = TRUE;


        }
        else // MACHINE_AUTHENTICATION
        {


        TRACE0 (USER, "ElGetUserIdentity entered");

        
        if (!EAPOL_PORT_ACTIVE(pPCB))
        {
            TRACE1 (PORT, "ElGetUserIdentity: Port %s not active",
                    pPCB->pszDeviceGUID);

            // Port is not active, cannot do further processing on this port
            
            break;
        }


        // The EAP dll will have already been loaded by the state machine
        // Retrieve the handle to the dll from the global EAP table

        if ((dwIndex = ElGetEapTypeIndex (pPCB->dwEapTypeToBeUsed)) == -1)
        {
            TRACE1 (USER, "ElGetUserIdentity: ElGetEapTypeIndex finds no dll for EAP index %ld",
                    pPCB->dwEapTypeToBeUsed);
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        hLib = g_pEapTable[dwIndex].hInstance;

        pIdenFunc = (EAPOLEAPGETIDENTITY)GetProcAddress(hLib, 
                                                    "RasEapGetIdentity");
        pFreeFunc = (EAPOLEAPFREE)GetProcAddress(hLib, "RasEapFreeMemory");

        if ((pFreeFunc == NULL) || (pIdenFunc == NULL))
        {
            TRACE0 (USER, "ElGetUserIdentity: pIdenFunc or pFreeFunc does not exist in the EAP implementation");
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Get the size of the EAP blob
        if ((dwRetCode = ElGetCustomAuthData (
                        pPCB->pszDeviceGUID,
                        pPCB->dwEapTypeToBeUsed,
                        pPCB->pszSSID,
                        NULL,
                        &cbData
                        )) != NO_ERROR)
        {
            if (dwRetCode == ERROR_BUFFER_TOO_SMALL)
            {
                if (cbData <= 0)
                {
                    // No EAP blob stored in the registry
                    TRACE0 (USER, "ElGetUserIdentity: NULL sized EAP blob, cannot continue");
                    pbAuthData = NULL;
                    // Every port should have connection data !!!
                    dwRetCode = ERROR_CAN_NOT_COMPLETE;
                    break;
                }
                else
                {
                    // Allocate memory to hold the blob
                    pbAuthData = MALLOC (cbData);
                    if (pbAuthData == NULL)
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        TRACE0 (USER, "ElGetUserIdentity: Error in memory allocation for EAP blob");
                        break;
                    }
                    if ((dwRetCode = ElGetCustomAuthData (
                                pPCB->pszDeviceGUID,
                                pPCB->dwEapTypeToBeUsed,
                                pPCB->pszSSID,
                                pbAuthData,
                                &cbData
                                )) != NO_ERROR)
                    {
                        TRACE1 (USER, "ElGetUserIdentity: ElGetCustomAuthData failed with %ld",
                                dwRetCode);
                        break;
                    }
                }
            }
            else
            {
                // CustomAuthData for "Default" is always created for an
                // interface when EAPOL starts up
                TRACE1 (USER, "ElGetUserIdentity: ElGetCustomAuthData size estimation failed with error %ld",
                        dwRetCode);
                break;
            }
        }


        if (pIdenFunc)
        if ((dwRetCode = (*(pIdenFunc))(
                        pPCB->dwEapTypeToBeUsed,
                        hwndOwner, // hwndOwner
                        RAS_EAP_FLAG_MACHINE_AUTH, // dwFlags
                        NULL, // lpszPhonebook
                        wszFriendlyName, // lpszEntry
                        pbAuthData, // Connection data
                        cbData, // Count of pbAuthData
                        pbUserIn, // User data for port
                        dwInSize, // Size of user data
                        &pUserDataOut,
                        &dwSizeOfUserDataOut,
                        &lpwszIdentity
                        )) != NO_ERROR)
        {
            TRACE1 (USER, "ElGetUserIdentity: Error in calling GetIdentity = %ld",
                    dwRetCode);
            break;
        }

        // Fill in the returned information into the PCB fields for 
        // later authentication

        if (pPCB->pCustomAuthUserData != NULL)
        {
            FREE (pPCB->pCustomAuthUserData);
            pPCB->pCustomAuthUserData = NULL;
        }

        pPCB->pCustomAuthUserData = MALLOC (dwSizeOfUserDataOut + sizeof (DWORD));
        if (pPCB->pCustomAuthUserData == NULL)
        {
            TRACE1 (USER, "ElGetUserIdentity: Error in allocating memory for UserInfo = %ld",
                    dwRetCode);
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pPCB->pCustomAuthUserData->dwSizeOfCustomAuthData = dwSizeOfUserDataOut;

        if ((dwSizeOfUserDataOut != 0) && (pUserDataOut != NULL))
        {
            memcpy ((BYTE *)pPCB->pCustomAuthUserData->pbCustomAuthData, 
                (BYTE *)pUserDataOut, 
                dwSizeOfUserDataOut);
        }

        if (lpwszIdentity != NULL)
        {
            // NOTE:
            // Assuming 256 character identity maximum

            // Convert wchar Identity to char string
            RtlInitUnicodeString (&IdentityUnicodeString, lpwszIdentity);
            IdentityAnsiString.MaximumLength = sizeof(Buffer);
            IdentityAnsiString.Buffer = Buffer;
            IdentityAnsiString.Length = 0;
            if ((dwRetCode = RtlUnicodeStringToAnsiString (
                    &IdentityAnsiString,
                    &IdentityUnicodeString,
                    FALSE)) != NO_ERROR)
            {
                TRACE1 (USER, "ElGetUserIdentity: Error in RtlConvertUnicodeStringToAnsiString = %ld",
                        dwRetCode);
                break;
            }

            TRACE1 (USER, "lpwszIdentity = %ws", lpwszIdentity);

            pszUserName = MALLOC (IdentityAnsiString.Length + 1);
            if (pszUserName == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (USER, "ElGetUserIdentity: MALLOC failed for pszUserName");
                break;
            }

            memcpy (pszUserName, 
                    IdentityAnsiString.Buffer, 
                    IdentityAnsiString.Length);
            pszUserName[IdentityAnsiString.Length] = '\0';

            TRACE1 (USER, "pszUserName = %s", pszUserName);

            if (pPCB->pszIdentity != NULL)
            {
                FREE (pPCB->pszIdentity);
                pPCB->pszIdentity = NULL;
            }

            pPCB->pszIdentity = MALLOC (IdentityAnsiString.Length + 1);
            if (pPCB->pszIdentity == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (USER, "ElGetUserIdentity: MALLOC failed for pPCB->pszIdentity");
                break;
            }

            memcpy (pPCB->pszIdentity, 
                    IdentityAnsiString.Buffer, 
                    IdentityAnsiString.Length);
            pPCB->pszIdentity[IdentityAnsiString.Length] = '\0';

            TRACE1 (USER, "ElGetUserIdentity: Got username = %s",
                    pszUserName);
        }

        if (pPCB->pCustomAuthConnData != NULL)
        {
            FREE (pPCB->pCustomAuthConnData);
            pPCB->pCustomAuthConnData = NULL;
        }

        // Memory for pCustomAuthConnData and pCustomAuthUserData
        // is released from the PCB when user logs off and during
        // port deletion 

        pPCB->pCustomAuthConnData = MALLOC (cbData + sizeof (DWORD));
        if (pPCB->pCustomAuthConnData == NULL)
        {
            TRACE1 (USER, "ElGetUserIdentity: Error in allocating memory for AuthInfo = %ld",
                    dwRetCode);
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pPCB->pCustomAuthConnData->dwSizeOfCustomAuthData = cbData;

        if ((cbData != 0) && (pbAuthData != NULL))
        {
            memcpy ((BYTE *)pPCB->pCustomAuthConnData->pbCustomAuthData, 
                (BYTE *)pbAuthData, 
                cbData);
        }

        // Mark the identity has been obtained for this PCB
        pPCB->fGotUserIdentity = TRUE;

        }

        // Release the per-interface lock
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));


    } while (FALSE);

    // Cleanup
    if (dwRetCode != NO_ERROR)
    {
        // Release the per-interface lock
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));

        if (pPCB->pCustomAuthUserData != NULL)
        {
            FREE (pPCB->pCustomAuthUserData);
            pPCB->pCustomAuthUserData = NULL;
        }

        if (pPCB->pCustomAuthConnData != NULL)
        {
            FREE (pPCB->pCustomAuthConnData);
            pPCB->pCustomAuthConnData = NULL;
        }

        if (pPCB->pszIdentity != NULL)
        {
            FREE (pPCB->pszIdentity);
            pPCB->pszIdentity = NULL;
        }

    }

    if (pbUserIn != NULL)
    {
        FREE (pbUserIn);
    }

    if (pbAuthData != NULL)
    {
        FREE (pbAuthData);
    }

    if (pszUserName != NULL)
    {
        FREE (pszUserName);
    }

    if (pFreeFunc != NULL)
    {
        if (lpwszIdentity != NULL)
        {
            if (( dwRetCode = (*(pFreeFunc)) ((BYTE *)lpwszIdentity)) != NO_ERROR)
            {
                TRACE1 (USER, "ElGetUserIdentity: Error in pFreeFunc = %ld",
                        dwRetCode);
            }
        }
        if (pUserDataOut != NULL)
        {
            if (( dwRetCode = (*(pFreeFunc)) ((BYTE *)pUserDataOut)) != NO_ERROR)
            {
                TRACE1 (USER, "ElGetUserIdentity: Error in pFreeFunc = %ld",
                        dwRetCode);
            }
        }
    }

    TRACE1 (USER, "ElGetUserIdentity completed with error %ld", dwRetCode);

    return dwRetCode;

}


//
// ElUserLogonCallback
//
// Description:
//
// Callback function invoked whenever a user logs in
// Will initiate authentication process on all ports of LAN class
// Credentials for the user in case of EAP-TLS can be obtained by 
// acquiring user token
// For EAP-CHAP, WinLogon cerdentials will need to be supplied
//
// Arguments:
//  None. 
//

VOID
ElUserLogonCallback (
        PVOID       pvContext,
        BOOLEAN     fTimerOfWaitFired
        )
{

    DWORD       dwIndex = 0;
    EAPOL_PCB   *pPCB = NULL;
    BOOL        fSetCONNECTINGState = FALSE;
    DWORD       dwRetCode = NO_ERROR;           

    // Set global flag to indicate the user logged on

    TRACE1 (USER, "ElUserLogonCallback: UserloggedOn = %ld",
            g_fUserLoggedOn);

    g_fUserLoggedOn = InterlockedIncrement (&(g_fUserLoggedOn));

    do 
    {
    
        ACQUIRE_WRITE_LOCK (&(g_PCBLock));

        for (dwIndex = 0; dwIndex < PORT_TABLE_BUCKETS; dwIndex++)
        {
            for (pPCB = g_PCBTable.pPCBBuckets[dwIndex].pPorts;
                    pPCB != NULL;
                    pPCB = pPCB->pNext)
            {

#ifdef DRAFT7
                if (g_dwMachineAuthEnabled)
                {
#endif

                fSetCONNECTINGState = FALSE;

                ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

                switch (pPCB->State)
                {
                    case EAPOLSTATE_CONNECTING:
                    case EAPOLSTATE_ACQUIRED:
                    case EAPOLSTATE_AUTHENTICATING:

                        // Reset AuthFailCount conditionally
                        pPCB->dwAuthFailCount = 0;
                        
                        // fall through

                    case EAPOLSTATE_HELD:

                        // End EAP session 
                        (VOID) ElEapEnd (pPCB);

                        fSetCONNECTINGState = TRUE;

                        break;

                    case EAPOLSTATE_AUTHENTICATED:
                        if (pPCB->PreviousAuthenticationType ==
                                EAPOL_UNAUTHENTICATED_ACCESS)
                        {
                            // Reset AuthFailCount 
                            pPCB->dwAuthFailCount = 0;
                            fSetCONNECTINGState = TRUE;
                        }

                        break;

                    default:
                        break;

                }

                if (!EAPOL_PORT_ACTIVE(pPCB))
                {
                    TRACE1 (USER, "ElUserLogonCallback: Port %s not active",
                                            pPCB->pszDeviceGUID);
                    fSetCONNECTINGState = FALSE;
                }

                // Set port to EAPOLSTATE_CONNECTING
            
                if (fSetCONNECTINGState)
                {
                    pPCB->dwAuthFailCount = 0;

                    // With unauthenticated access flag set, port will always
                    // reauthenticate for logged on user

                    pPCB->PreviousAuthenticationType = 
                                EAPOL_UNAUTHENTICATED_ACCESS;
                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));

                    // Restart authentication on the port
                    if ((dwRetCode = ElReStartPort (pPCB)) != NO_ERROR)
                    {
                        TRACE1 (USER, "ElUserLogonCallback: MachineAuth: Error in ElReStartPort = %ld",
                                dwRetCode);
                        continue;
                    }
                }
                else
                {
                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));
                    continue;
                }


#ifdef DRAFT7
                }
                else
                {
    
                ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

                // If the port is already authenticated due to non-secure
                // LAN, authentication can be skipped for this port
                if (pPCB->State == EAPOLSTATE_AUTHENTICATED)
                {
                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));
                    TRACE0 (USER, "ElUserLogonCallback: Port already authenticated, continuing with next port");
                    continue;
                }
    
                RELEASE_WRITE_LOCK (&(pPCB->rwLock));
    
                // Restart authentication on the port
                if ((dwRetCode = ElReStartPort (pPCB)) != NO_ERROR)
                {
                    TRACE1 (USER, "ElUserLogonCallback: Error in ElReStartPort = %ld",
                            dwRetCode);
                    break;
                }
        
                TRACE1 (USER, "ElUserLogonCallback: = Authentication restarted on port %p",
                        pPCB);


                } // g_dwMachineAuthEnabled
#endif
        
            }
        }
    
        RELEASE_WRITE_LOCK (&(g_PCBLock));
    
        if (dwRetCode != NO_ERROR)
        {
            break;
        }
    
    } while (FALSE);
    
        
    TRACE1 (USER, "ElUserLogonCallback: completed with error %ld", dwRetCode);
    
    return;

}


//
// ElUserLogoffCallback
//
// Description:
//
// Callback function invoked whenever a user logs off 
// Will logoff from all ports which have authentication enabled
//
// Arguments:
//  None. 
//

VOID
ElUserLogoffCallback (
        PVOID       pvContext,
        BOOLEAN     fTimerOfWaitFired
        )
{
    DWORD           dwIndex = 0;
    EAPOL_PCB       *pPCB = NULL; 
    BOOL            fSetCONNECTINGState = FALSE;
    DWORD           dwRetCode = NO_ERROR;

    // Reset global flag to indicate the user logged on

    g_fUserLoggedOn = 0;

    TRACE1 (USER, "ElUserLogoffCallback: UserloggedOff = %ld",
            g_fUserLoggedOn);
    

    ACQUIRE_WRITE_LOCK (&(g_PCBLock));

    for (dwIndex = 0; dwIndex < PORT_TABLE_BUCKETS; dwIndex++)
    {
        for (pPCB = g_PCBTable.pPCBBuckets[dwIndex].pPorts;
                pPCB != NULL;
                pPCB = pPCB->pNext)
        {

#ifdef DRAFT7
            if (g_dwMachineAuthEnabled)
            {
#endif

                fSetCONNECTINGState = FALSE;

                ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

                switch (pPCB->State)
                {
                    case EAPOLSTATE_CONNECTING:
                    case EAPOLSTATE_ACQUIRED:
                    case EAPOLSTATE_AUTHENTICATING:
                        
                        // Reset AuthFailCount conditionally
                        pPCB->dwAuthFailCount = 0;

                        // fall through

                    case EAPOLSTATE_HELD:

                        // End EAP session 
                        (VOID) ElEapEnd (pPCB);

                        fSetCONNECTINGState = TRUE;

                        break;

                    case EAPOLSTATE_AUTHENTICATED:
                        if (pPCB->PreviousAuthenticationType ==
                                EAPOL_USER_AUTHENTICATION)
                        {
                            // Reset AuthFailCount 
                            pPCB->dwAuthFailCount = 0;
                            fSetCONNECTINGState = TRUE;
                        }
                        break;

                    default:
                        break;

                }


                // Set port to EAPOLSTATE_CONNECTING
            
                if (fSetCONNECTINGState)
                {
                    pPCB->dwAuthFailCount = 0;

                    // With Unauthenticated_access, port will always
                    // reauthenticate 

                    pPCB->PreviousAuthenticationType = 
                                EAPOL_UNAUTHENTICATED_ACCESS;
                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));

                    // Restart authentication on the port
                    if ((dwRetCode = ElReStartPort (pPCB)) != NO_ERROR)
                    {
                        TRACE1 (USER, "ElUserLogoffCallback: MachineAuth: Error in ElReStartPort = %ld",
                                dwRetCode);
                        continue;
                    }
                    
                }
                else
                {
                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));
                    continue;
                }

#ifdef DRAFT7
            } 
            else
            {

            ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

            // If remote end has sent responses earlier and if EAPOL_Logoff
            // was not sent out on this port, send out EAPOL_Logoff

            if ((pPCB->fIsRemoteEndEAPOLAware) && (!(pPCB->dwLogoffSent)))
            {

                // End EAP session 
                // Will always return NO_ERROR, so no check on return value
                (VOID) ElEapEnd (pPCB);

                // Send out EAPOL_Logoff on the port
                if ((dwRetCode = FSMLogoff (pPCB)) != NO_ERROR)
                {
                    RELEASE_WRITE_LOCK (&(pPCB->rwLock));
                    TRACE1 (USER, "ElUserLogoffCallback: Error in FSMLogoff = %ld",
                            dwRetCode);
                    continue;
                }

            }

            RELEASE_WRITE_LOCK (&(pPCB->rwLock));
    
            TRACE1 (USER, "ElUserLogoffCallback: = Logoff sent out on port %p",
                    pPCB);

            } //  g_dwMachineAuthEnabled
#endif

        }
    }

    RELEASE_WRITE_LOCK (&(g_PCBLock));

    TRACE0 (USER, "ElUserLogonCallback: completed");

    return;
}


//
// ElGetUserNamePassword
//
// Description:
//
// Function called to get username, domain (if any) and password using
// an interactive dialog. Called if EAP-type is MD5
//
// Arguments:
//      pPCB - Pointer to PCB for the port/interface on which credentials 
//      are to be obtained
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

//
// NOTE: Could be done in a better way. Require EAP config structures
// as in ..\ras\ui\rasdlg\dial.c
//

DWORD
ElGetUserNamePassword (
        IN  EAPOL_PCB       *pPCB
        )
{
    HANDLE              hUserToken;
    DWORD               dwIndex = -1;
    DWORD               dwInSize = 0;
    HWND                hwndOwner = NULL;
    HWINSTA             hwinstaSave;
    HDESK               hdeskSave;
    HWINSTA             hwinstaUser;
    HDESK               hdeskUser;
    DWORD               dwThreadId;
    DWORD               dwRetCode = NO_ERROR;

    do 
    {
        TRACE0 (USER, "ElGetUserNamePassword entered");

        //
        // NOTE:
        // Optimize pPCB->rwLock lock holding time
        //
        
        ACQUIRE_WRITE_LOCK (&(pPCB->rwLock));

        if (!EAPOL_PORT_ACTIVE(pPCB))
        {
            TRACE1 (PORT, "ElGetUserNamePassword: Port %s not active",
                    pPCB->pszDeviceGUID);
            // Port is not active, cannot do further processing on this port
            break;
        }

        //
        // Get Access Token for user logged on interactively
        //
        
        // Call Terminal Services API

        if (GetWinStationUserToken (GetClientLogonId(), &hUserToken) 
                != NO_ERROR)
        {
            TRACE0 (USER, "ElGetUserNamePassword: Terminal Services API GetWinStationUserToken failed !!! ");
            
            // Call private API

            hUserToken = GetCurrentUserTokenW (L"WinSta0",
                                        TOKEN_QUERY |
                                        TOKEN_DUPLICATE |
                                        TOKEN_ASSIGN_PRIMARY);
            if (hUserToken == NULL)
            {
                dwRetCode = GetLastError ();
                TRACE1 (USER, "ElGetUserNamePassword: Error in GetCurrentUserTokenW = %ld",
                        
                        dwRetCode);
                dwRetCode = ERROR_NO_TOKEN;
                break;
            }
        }
                                        
        if (hUserToken == NULL)
        {
            dwRetCode = GetLastError ();
            TRACE0 (USER, "ElGetUserNamePassword: Error in getting current user token");
            dwRetCode = ERROR_NO_TOKEN;
            break;
        }

        pPCB->hUserToken = hUserToken;


        // The EAP dll will have already been loaded by the state machine
        // Retrieve the handle to the dll from the global EAP table

        if ((dwIndex = ElGetEapTypeIndex (pPCB->dwEapTypeToBeUsed)) == -1)
        {
            TRACE1 (USER, "ElGetUserNamePassword: ElGetEapTypeIndex finds no dll for EAP index %ld",
                    pPCB->dwEapTypeToBeUsed);
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Save handles to service window

        hwinstaSave = GetProcessWindowStation();
        if (hwinstaSave == NULL)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "ElGetUserNamePassword: GetProcessWindowStation failed with error %ld",
                    dwRetCode);
            break;
        }

        dwThreadId = GetCurrentThreadId ();

        hdeskSave = GetThreadDesktop (dwThreadId);
        if (hdeskSave == NULL)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "ElGetUserNamePassword: GetThreadDesktop failed with error %ld",
                    dwRetCode);
            break;
        }


        if (!ImpersonateLoggedOnUser (pPCB->hUserToken))
        {
            dwRetCode = GetLastError();
            TRACE1 (USER, "ElGetUserNamePassword: ImpersonateLoggedOnUse failed with error %ld",
                    dwRetCode);
            break;
        }

        // Impersonate the client and connect to the User's window station
        // and desktop. This will be the interactively logged-on user

        hwinstaUser = OpenWindowStation (L"WinSta0", FALSE, MAXIMUM_ALLOWED);
        if (hwinstaUser == NULL)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "ElGetUserNamePassword: OpenWindowStation failed with error %ld",
                    dwRetCode);
            break;
        }

        SetProcessWindowStation(hwinstaUser);
        hdeskUser = OpenDesktop (L"Default", 0, FALSE, MAXIMUM_ALLOWED);
        if (hdeskUser == NULL)
        {
            SetProcessWindowStation (hwinstaSave);
            CloseWindowStation (hwinstaUser);
            dwRetCode = ERROR_INVALID_WORKSTATION;
            break;
        }

        SetThreadDesktop (hdeskUser);

        // Get handle to desktop window

        hwndOwner = GetDesktopWindow ();


        //
        // Call the user dialog for obtaining the username and password
        //

        if ((dwRetCode = ElUserDlg (hwndOwner, pPCB)) != NO_ERROR)
        {
            TRACE0 (USER, "ElGetUserNamePassword: ElUserDlg failed");

            RevertToSelf();

            // Restore window station and desktop
            SetThreadDesktop (hdeskSave);
            SetProcessWindowStation (hwinstaSave);
            CloseDesktop(hdeskUser);
            CloseWindowStation(hwinstaUser);
            break;
        }


        // Revert impersonation
        if (!RevertToSelf())
        {
            dwRetCode = GetLastError();
            TRACE1 (USER, "ElGetUserNamePassword: Error in RevertToSelf = %ld",
                    dwRetCode);
            // Restore window station and desktop
            SetThreadDesktop (hdeskSave);
            SetProcessWindowStation (hwinstaSave);
            CloseDesktop(hdeskUser);
            CloseWindowStation(hwinstaUser);
            break;
        }

        // Restore window station and desktop settings
        SetThreadDesktop (hdeskSave);
        SetProcessWindowStation (hwinstaSave);
        CloseDesktop(hdeskUser);
        CloseWindowStation(hwinstaUser);

       
        // Mark the identity has been obtained for this PCB
        pPCB->fGotUserIdentity = TRUE;

        // Release the per-interface lock
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));

    } while (FALSE);

    // Cleanup
    if (dwRetCode != NO_ERROR)
    {
        // Release the per-interface lock
        RELEASE_WRITE_LOCK (&(pPCB->rwLock));

        if (pPCB->pCustomAuthUserData != NULL)
        {
            FREE (pPCB->pCustomAuthUserData);
        }

        if (pPCB->pCustomAuthConnData != NULL)
        {
            FREE (pPCB->pCustomAuthConnData);
        }

    }

    TRACE1 (USER, "ElGetUserNamePassword completed with error %ld", dwRetCode);

    return dwRetCode;
}


//
// ElUserDlg
//
// Description:
//
// Function called to pop dialog box to user to enter username, password,
// domainname etc.
//
// Arguments:
//      hwndOwner - handle to user desktop
//      pPCB - Pointer to PCB for the port/interface on which credentials 
//      are to be obtained
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

DWORD
ElUserDlg (
        IN  HWND        hwndOwner,
        IN  EAPOL_PCB   *pPCB
        )
{
    USERDLGARGS     args;
    DWORD           dwRetCode = NO_ERROR;     


    TRACE0 (USER, "ElUserDlg: Entered");

    args.pPCB = pPCB;

    if ( DialogBoxParam (
                    GetModuleHandle(cszModuleName),
                    MAKEINTRESOURCE (DID_DR_DialerUD),
                    hwndOwner,
                    ElUserDlgProc,
                    (LPARAM)&args ) == -1)
    {
        dwRetCode = GetLastError ();
        TRACE1 (USER, "ElUserDlg: DialogBoxParam failed with error %ld",
                dwRetCode);
    }

    return dwRetCode;
}


//
// ElUserDlgProc
//
// Description:
//
// Function handling all events for username/password/... dialog box
//
// Arguments:
//      hwnd -
//      unMsg -
//      wparam -
//      lparam -
//
// Return values:
//      NO_ERROR - success
//      non-zero - error
//

INT_PTR
ElUserDlgProc (
        IN HWND hwnd,
        IN UINT unMsg,
        IN WPARAM wparam,
        IN LPARAM lparam )
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            {
                return ElUserDlgInit( hwnd, (USERDLGARGS* )lparam );
                break;
            }
        case WM_HELP:
        case WM_CONTEXTMENU:
            {
                break;
            }
        case WM_COMMAND:
            {
                USERDLGINFO* pInfo = (USERDLGINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ASSERT( pInfo );
                return ElUserDlgCommand (
                        pInfo, HIWORD(wparam), LOWORD(wparam), (HWND)lparam );

                break;
            }
        case WM_DESTROY:
            {
                USERDLGINFO* pInfo = (USERDLGINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ElUserDlgTerm (hwnd, pInfo);
                break;
            }
    }

    return FALSE;
}


BOOL
ElUserDlgInit (
        IN  HWND    hwndDlg,
        IN  USERDLGARGS  *pArgs
        )
{
    USERDLGINFO     *pInfo = NULL;
    WCHAR           wszFriendlyName[256];
    DWORD           dwRetCode = NO_ERROR;

    TRACE0 (USER, "ElUserDlgInit entered");

    do
    {
        pInfo = MALLOC (sizeof (USERDLGINFO));
        if (pInfo == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (USER, "ElUserDlgInit: MALLOC failed for pInfo");
            break;
        }
     
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;
    
        SetWindowLongPtr (hwndDlg, DWLP_USER, (ULONG_PTR)pInfo);
#if 0
        if (!SetWindowLongPtr (hwndDlg, DWLP_USER, (ULONG_PTR)pInfo))
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "ElUserDlgInit: SetWindowLongPtr failed with error %ld",
                    dwRetCode);
            break;
        }
#endif
        TRACE0 (USER, "ElUserDlgInit: Context Set");
    
        // 
        // Set the title
        //
    
        ZeroMemory (wszFriendlyName, 256*sizeof(WCHAR));
    
        // Convert the friendly name of the adapter to a display ready
        // form
        if (pArgs->pPCB->pszFriendlyName)
        {
            if (0 == MultiByteToWideChar(
                        CP_ACP,
                        0,
                        pArgs->pPCB->pszFriendlyName,
                        -1,
                        wszFriendlyName,
                        256 ) )
            {
                dwRetCode = GetLastError();
    
                TRACE2 (USER, "ElUserDlgInit: MultiByteToWideChar(%s) failed: %d",
                        pArgs->pPCB->pszFriendlyName,
                        dwRetCode);
    
            }
            if (!SetWindowText (hwndDlg, wszFriendlyName))
            {
                dwRetCode = GetLastError ();
                TRACE1 (USER, "ElUserDlgInit: SetWindowText failed with error %ld",
                        dwRetCode);
                break;
            }
        }
        else
        {
            if (!SetWindowText (hwndDlg, NULL))
            {
                dwRetCode = GetLastError ();
                TRACE1 (USER, "ElUserDlgInit: SetWindowText - NULL failed with error %ld",
                        dwRetCode);
                break;
            }
        }
    
        pInfo->hwndEbUser = GetDlgItem( hwndDlg, CID_DR_EB_User );
        ASSERT (pInfo->hwndEbUser);
        pInfo->hwndEbPw = GetDlgItem( hwndDlg, CID_DR_EB_Password );
        ASSERT (pInfo->hwndEbPw);
        pInfo->hwndEbDomain = GetDlgItem( hwndDlg, CID_DR_EB_Domain );
        ASSERT (pInfo->hwndEbDomain);
    
    }
    while (FALSE);

    if (dwRetCode != NO_ERROR)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


//
// ElUserDlgCommand
//
// Description:
//
// Function called on WM_COMMAND
// domainname etc.
//
// Arguments:
//      PInfo - dialog context
//      WNotification - notification code of the command 
//      wId - control/menu identifier of the command  
//      HwndCtrl - control window handle the command.
//
// Return values:
//      TRUE - success
//      FALSE - error
//

BOOL
ElUserDlgCommand (
        IN  USERDLGINFO      *pInfo,
        IN  WORD        wNotification,
        IN  WORD        wId,
        IN  HWND        hwndCtrl
        )
{
    TRACE3 (USER, "ElUserDlgCommand: n=%d, i=%d, c=%x",
            (DWORD)wNotification, (DWORD)wId, (ULONG_PTR)hwndCtrl);

    switch (wId)
    {
        case IDOK:
        case CID_DR_PB_DialConnect:
            {
                ElUserDlgSave (pInfo);
                EndDialog (pInfo->hwndDlg, TRUE);
                return TRUE;
            }
        case IDCANCEL:
        case CID_DR_PB_Cancel:
            {
                EndDialog (pInfo->hwndDlg, TRUE);
                return TRUE;
            }
        default:
            {
                TRACE0 (USER, "ElUserDlgCommand: Got something we are not interested in");
                break;
            }
    }

    return FALSE;
    
}

VOID
ElUserDlgSave (
        IN  USERDLGINFO      *pInfo
        )
{
    EAPOL_PCB       *pPCB = NULL;
    int             iError;
    CHAR            szUserName[UNLEN + 1];
    CHAR            szDomain[DNLEN + 1];
    CHAR            szPassword[DNLEN + 1];
    DWORD           dwRetCode = NO_ERROR;

    pPCB = (EAPOL_PCB *)pInfo->pArgs->pPCB;

    do 
    {

        // Username

        if ((iError = 
                    GetWindowTextA( 
                        pInfo->hwndEbUser, 
                        &(szUserName[0]), 
                        UNLEN + 1 )) == 0)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "ElUserDlgSave: GetWindowText - Username failed with error %ld",
                    dwRetCode);
        }
        szUserName[iError] = '\0';
    
        TRACE1 (USER, "ElUserDlgSave: Get Username %s", szUserName);
    
        // Password

        if ((iError = 
                    GetWindowTextA( 
                        pInfo->hwndEbPw, 
                        &(szPassword[0]), 
                        PWLEN + 1 )) == 0)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "ElUserDlgSave: GetWindowText - Password failed with error %ld",
                    dwRetCode);
        }
        szPassword[iError] = '\0';
    
        if (pPCB->pszPassword != NULL)
        {
            FREE (pPCB->pszPassword);
            pPCB->pszPassword = NULL;
        }

        pPCB->pszPassword = MALLOC (strlen(szPassword) + 1);
        
        if (pPCB->pszPassword == NULL)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0 (USER, "ElUserDlgSave: MALLOC failed for pPCB->pszPassword");
            break;
        }

        memcpy (pPCB->pszPassword, szPassword, strlen(szPassword) + 1);

        // Uncomment only if absolutely required
        // Security issue, since we are writing trace to file

        // TRACE1 (USER, "ElUserDlgSave: Got Password %s", pPCB->pszPassword);
    
        // Domain
    
        if ((iError = 
                    GetWindowTextA( 
                        pInfo->hwndEbDomain, 
                        &(szDomain[0]), 
                        DNLEN + 1 )) == 0)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "ElUserDlgSave: GetWindowText - Domain failed with error %ld",
                    dwRetCode);
        }
        szDomain[iError] = '\0';
    
        TRACE1 (USER, "ElUserDlgSave: Got Domain %s", szDomain);
    
        if (pPCB->pszIdentity != NULL)
        {
            FREE (pPCB->pszIdentity);
            pPCB->pszIdentity = NULL;
        }

        if ((szDomain != NULL) &&
                (szDomain[0] != (CHAR)NULL))
        {
            pPCB->pszIdentity = 
                MALLOC (strlen(szDomain)+strlen(szUserName)+2);
            if (pPCB->pszIdentity == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (USER, "ElUserDlgSave: MALLOC failed for pPCB->pszIdentity 1");
                break;
            }

            strcpy (pPCB->pszIdentity, szDomain);
            strcat( pPCB->pszIdentity, "\\" );
            strcat (pPCB->pszIdentity, szUserName);
        }
        else
        {
            pPCB->pszIdentity = 
                MALLOC (strlen(szUserName)+1);
            if (pPCB->pszIdentity == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (USER, "ElUserDlgSave: MALLOC failed for pPCB->pszIdentity 2");
                break;
            }

            strcpy (pPCB->pszIdentity, szUserName);
        }

        TRACE1 (USER, "ElUserDlgSave: Got identity %s", pPCB->pszIdentity);
    
        TRACE1 (USER, "ElUserDlgSave: PCB->GUID = %s", pPCB->pszDeviceGUID);

        // Hash-up password while storing locally

        ElEncodePw (pPCB->pszPassword);

    }
    while (FALSE);

    if (dwRetCode != NO_ERROR)
    {
        if (pPCB->pszIdentity != NULL)
        {
            FREE (pPCB->pszIdentity);
            pPCB->pszIdentity = NULL;
        }
        
        if (pPCB->pszPassword != NULL)
        {
            FREE (pPCB->pszPassword);
            pPCB->pszPassword = NULL;
        }
    }

    return;

}

VOID
ElUserDlgTerm (
        IN  HWND        hwndDlg,
        IN  USERDLGINFO      *pInfo
        )
{
    EndDialog (hwndDlg, TRUE);
    FREE (pInfo);
}


//
// ElInvokeInteractiveUI
//
// Description:
//
// Function called to invoke RasEapInvokeInteractiveUI for an EAP on a 
// particular interface
// 
// Arguments:
//  pPCB - Pointer to PCB for the specific interface
//  pInvokeEapUIIn - Data to be supplied to the InvokeInteractiveUI entrypoint
//      provided by the EAP dll through PPP_EAP_OUTPUT structure
//

DWORD
ElInvokeInteractiveUI (
        IN  EAPOL_PCB               *pPCB,
        IN  ELEAP_INVOKE_EAP_UI     *pInvokeEapUIIn
        )
{
    HANDLE              hUserToken = NULL;
    HANDLE              hLib = NULL;
    EAPOLEAPFREE        pFreeFunc = NULL;
    EAPOLEAPINVOKEINTERACTIVEUI     pEapInvokeUI = NULL;
    DWORD               dwIndex = -1;
    BYTE                *pUIDataOut = NULL;
    DWORD               dwSizeOfUIDataOut;
    HWND                hwndOwner = NULL;
    HWINSTA             hwinstaSave = NULL;
    HDESK               hdeskSave = NULL;
    HWINSTA             hwinstaUser = NULL;
    HDESK               hdeskUser = NULL;
    DWORD               dwThreadId = 0;
    DWORD               dwRetCode = NO_ERROR;

    do 
    {
        TRACE0 (USER, "ElInvokeInteractiveUI entered");

        // The EAP dll will have already been loaded by the state machine
        // Retrieve the handle to the dll from the global EAP table

        if ((dwIndex = ElGetEapTypeIndex (pPCB->dwEapTypeToBeUsed)) == -1)
        {
            TRACE1 (USER, "ElInvokeInteractiveUI: ElGetEapTypeIndex finds no dll for EAP index %ld",
                    pPCB->dwEapTypeToBeUsed);
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        hLib = g_pEapTable[dwIndex].hInstance;

        pEapInvokeUI = (EAPOLEAPINVOKEINTERACTIVEUI) GetProcAddress 
                                        (hLib, "RasEapInvokeInteractiveUI");
        pFreeFunc = (EAPOLEAPFREE) GetProcAddress (hLib, "RasEapFreeMemory");

        if ((pFreeFunc == NULL) || (pEapInvokeUI == NULL))
        {
            TRACE0 (USER, "ElInvokeInteractiveUI: pEapInvokeUI or pFreeFunc does not exist in the EAP implementation");
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Get Access Token for user logged on interactively

        // Call Terminal Services API

        if (GetWinStationUserToken (GetClientLogonId(), &hUserToken) 
                != NO_ERROR)
        {
            TRACE0 (USER, "ElInvokeInteractiveUI: Terminal Services API GetWinStationUserToken failed !!! ");

            // Call private API

            hUserToken = GetCurrentUserTokenW (L"WinSta0",
                                        TOKEN_QUERY |
                                        TOKEN_DUPLICATE |
                                        TOKEN_ASSIGN_PRIMARY);
            if (hUserToken == NULL)
            {
                dwRetCode = GetLastError ();
                TRACE1 (USER, "ElInvokeInteractiveUI: Error in GetCurrentUserTokenW = %ld",
                    dwRetCode);
                dwRetCode = ERROR_NO_TOKEN;
                break;
            }
        }
                                        
        if (hUserToken == NULL)
        {
            dwRetCode = GetLastError ();
            TRACE0 (USER, "ElInvokeInteractiveUI: Error in getting current user token");
            dwRetCode = ERROR_NO_TOKEN;
            break;
        }


        pPCB->hUserToken = hUserToken;


        // Save handles to service window

        hwinstaSave = GetProcessWindowStation();
        if (hwinstaSave == NULL)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "ElInvokeInteractiveUI: GetProcessWindowStation failed with error %ld",
                    dwRetCode);
            break;
        }

        dwThreadId = GetCurrentThreadId ();

        hdeskSave = GetThreadDesktop (dwThreadId);
        if (hdeskSave == NULL)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "ElInvokeInteractiveUI: GetThreadDesktop failed with error %ld",
                    dwRetCode);
            break;
        }


        if (!ImpersonateLoggedOnUser (pPCB->hUserToken))
        {
            dwRetCode = GetLastError();
            TRACE1 (USER, "ElInvokeInteractiveUI: ImpersonateLoggedOnUse failed with error %ld",
                    dwRetCode);
            break;
        }

        // Impersonate the client and connect to the User's window station
        // and desktop. This will be the interactively logged-on user

        hwinstaUser = OpenWindowStation (L"WinSta0", FALSE, MAXIMUM_ALLOWED);
        if (hwinstaUser == NULL)
        {
            dwRetCode = GetLastError ();
            TRACE1 (USER, "OpenWindowStation: OpenWindowStation failed with error %ld",
                    dwRetCode);
            break;
        }

        SetProcessWindowStation(hwinstaUser);
        hdeskUser = OpenDesktop (L"Default", 0, FALSE, MAXIMUM_ALLOWED);
        if (hdeskUser == NULL)
        {
            SetProcessWindowStation (hwinstaSave);
            CloseWindowStation (hwinstaUser);
            dwRetCode = ERROR_INVALID_WORKSTATION;
            break;
        }

        SetThreadDesktop (hdeskUser);

        // Get handle to desktop window

        hwndOwner = GetDesktopWindow ();

        if ((dwRetCode = (*(pEapInvokeUI))(
                        pPCB->dwEapTypeToBeUsed,
                        hwndOwner, // hwndOwner
                        // Context data from EAP 
                        pInvokeEapUIIn->pbUIContextData, 
                        // Size of context data 
                        pInvokeEapUIIn->dwSizeOfUIContextData, 
                        &pUIDataOut,
                        &dwSizeOfUIDataOut
                        )) != NO_ERROR)
        {
            TRACE1 (USER, "ElInvokeInteractiveUI: Error in calling InvokeInteractiveUI = %ld",
                    dwRetCode);
            // Revert impersonation
            if (!RevertToSelf())
            {
                dwRetCode = GetLastError();
                TRACE1 (USER, "ElInvokeInteractiveUI: Error in RevertToSelf = %ld",
                    dwRetCode);
            }

            // Restore window station and desktop
            SetThreadDesktop (hdeskSave);
            SetProcessWindowStation (hwinstaSave);
            CloseDesktop(hdeskUser);
            CloseWindowStation(hwinstaUser);

            break;
        }

        // Revert impersonation
        if (!RevertToSelf())
        {
            dwRetCode = GetLastError();
            TRACE1 (USER, "ElInvokeInteractiveUI: Error in RevertToSelf = %ld",
                    dwRetCode);
            // Restore window station and desktop
            SetThreadDesktop (hdeskSave);
            SetProcessWindowStation (hwinstaSave);
            CloseDesktop(hdeskUser);
            CloseWindowStation(hwinstaUser);
            break;
        }

        // Restore window station and desktop settings
        SetThreadDesktop (hdeskSave);
        SetProcessWindowStation (hwinstaSave);
        CloseDesktop(hdeskUser);
        CloseWindowStation(hwinstaUser);
       
        // Free the context we passed to the dll
        if (pInvokeEapUIIn->pbUIContextData != NULL)
        {
            FREE (pInvokeEapUIIn->pbUIContextData);
            pInvokeEapUIIn->pbUIContextData = NULL;
            pInvokeEapUIIn->dwSizeOfUIContextData = 0;
        }
        
        // Fill in the returned information into the PCB fields for 
        // later authentication

        if (pPCB->EapUIData.pEapUIData != NULL)
        {
            FREE (pPCB->EapUIData.pEapUIData);
            pPCB->EapUIData.pEapUIData = NULL;
            pPCB->EapUIData.dwSizeOfEapUIData = 0;
        }

        pPCB->EapUIData.pEapUIData = MALLOC (dwSizeOfUIDataOut + sizeof (DWORD));
        if (pPCB->EapUIData.pEapUIData == NULL)
        {
            TRACE1 (USER, "ElInvokeInteractiveUI: Error in allocating memory for UIData = %ld",
                    dwRetCode);
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pPCB->EapUIData.dwSizeOfEapUIData = dwSizeOfUIDataOut;

        if ((dwSizeOfUIDataOut != 0) && (pUIDataOut != NULL))
        {
            memcpy ((BYTE *)pPCB->EapUIData.pEapUIData,
                (BYTE *)pUIDataOut, 
                dwSizeOfUIDataOut);
        }

        pPCB->fEapUIDataReceived = TRUE;

        TRACE0 (USER, "ElInvokeInteractiveUI: Calling ElEapWork");

        // Provide UI data to EAP Dll for processing
        // EAP will send out response if required

        if ((dwRetCode = ElEapWork (
                                pPCB,
                                NULL)) != NO_ERROR)
        {
            TRACE1 (USER, "ElInvokeInteractiveUI: ElEapWork failed with error = %ld",
                    dwRetCode);
            break;
        }
                
        TRACE0 (USER, "ElInvokeInteractiveUI: ElEapWork completed successfully");

    } while (FALSE);

    // Cleanup
    if (dwRetCode != NO_ERROR)
    {
        if (pPCB->EapUIData.pEapUIData != NULL)
        {
            FREE (pPCB->EapUIData.pEapUIData);
            pPCB->EapUIData.pEapUIData = NULL;
            pPCB->EapUIData.dwSizeOfEapUIData = 0;
        }

    }

    if (pInvokeEapUIIn->pbUIContextData != NULL)
    {
        FREE (pInvokeEapUIIn->pbUIContextData);
        pInvokeEapUIIn->pbUIContextData = NULL;
        pInvokeEapUIIn->dwSizeOfUIContextData = 0;
    }

    if (pFreeFunc != NULL)
    {
        if (pUIDataOut != NULL)
        {
            if (( dwRetCode = (*(pFreeFunc)) ((BYTE *)pUIDataOut)) != NO_ERROR)
            {
                TRACE1 (USER, "ElInvokeInteractiveUI: Error in pFreeFunc = %ld",
                        dwRetCode);
            }
        }
    }

    TRACE1 (USER, "ElInvokeInteractiveUI completed with error %ld", dwRetCode);

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\pcheapol.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This module contains the header files that needed to included across 
    various source files


Revision History:

    sachins, Apr 23 2000, Created
   
Notes:

    Maintain the order of the include files, at the top being vanilla
    definitions files, bottom being dependent definitions

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <rtutils.h>
#include <locale.h>
#include <lmcons.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <winsvc.h>
#include <winuser.h>
#include <wmistr.h>
#include <wmium.h>
#include <wchar.h>
#include <zwapi.h>
#include <dbt.h>
#include <rpc.h>
#include <raseapif.h>
#include <raserror.h>
#include <ntddndis.h>
#include <ndisguid.h>
#include <ndispnp.h>
#include <dhcpcapi.h>
#include <winsock2.h>
#include <mswsock.h>
#include <ws2spi.h>
#include <md5.h>
#include <rc4.h>
#include <objbase.h>
#include <security.h>
#include <secext.h>
#include <nuiouser.h>       // NDISUIO driver definitions
#include <nlasvc.h>

#include "winsta.h"

#include "eldefs.h"
#include "elsync.h"
#include "eapol.h"
#include "elport.h"
#include "eleap.h"
#include "eldeviceio.h"
#include "elprotocol.h"
#include "eluser.h"
#include "eapolutil.h"
#include "eapollog.h"       // Message file
#include "eapoldlgrc.h"
#include "mprerror.h"       // Extended errors provided by mpr
#include "elglobals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\cobase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O B A S E . H
//
//  Contents:   Connection Objects Shared code
//
//  Notes:
//
//  Author:     ckotze   16 Mar 2001
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"

HRESULT 
HrBuildPropertiesExFromProperties(
    IN NETCON_PROPERTIES* pProps, 
    OUT NETCON_PROPERTIES_EX* pPropsEx, 
    IN IPersistNetConnection* pPersistNetConnection);

HRESULT 
HrGetPropertiesExFromINetConnection(
    IN INetConnection* pConn, 
    OUT NETCON_PROPERTIES_EX** ppPropsEx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\eapol\service\svcmain.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    svcmain.c

Abstract:

    This module contains code for starting off, shutting down and 
    handling device addition/removal request for the EAPOL module. 


Revision History:

    sachins, Apr 25 2000, Created

Notes:
    EAPOL_SERVICE if defined, on compilation, a .exe version is created.
    If not defined, on compilation, a .lib is created, with entry 
    points defined, which netman calls into.

--*/

#include "pcheapol.h"
#pragma hdrstop

#define NDISUIO_SERVICE_NAME    L"NDISUIO"
#define NETMAN_SERVICE_NAME     L"NETMAN"


extern
VOID
EAPOLServiceMain (
    IN DWORD        argc,
    IN LPWSTR       *lpwsServiceArgs
    );

VOID
EAPOLServiceMainWorker (
        IN  PVOID       pvContext
        );

#ifdef EAPOL_SERVICE

//
// main
//
// Description: Will simply register the entry point of the EAPOL 
//		service with the service controller. The service controller
//		will capture this thread. It will be freed only when
//		the service is shutdown. At that point we will simply exit
//		the process.
//
// Return values:	none
//

void
_cdecl
main ( int argc, unsigned char * argv[] )
{
    SERVICE_TABLE_ENTRY	EapolServiceDispatchTable[2];

    UNREFERENCED_PARAMETER( argc );
    UNREFERENCED_PARAMETER( argv );

    EapolServiceDispatchTable[0].lpServiceName = EAPOL_SERVICE_NAME;
    EapolServiceDispatchTable[0].lpServiceProc = EAPOLServiceMain;
    EapolServiceDispatchTable[1].lpServiceName = NULL;
    EapolServiceDispatchTable[1].lpServiceProc = NULL;

    if ( !StartServiceCtrlDispatcher( EapolServiceDispatchTable ) )
    {
	ASSERT (0);
    }

    ExitProcess(0);
}

//
// EAPOLAnnounceServiceStatus
//
// Description: Will simly call SetServiceStatus to inform the service
//      control manager of this service's current status.
//
// Return values: none
//

VOID
EAPOLAnnounceServiceStatus (
    VOID
    )
{
    BOOL dwRetCode;

    ASSERT (g_hServiceStatus);

    //
    // Increment the checkpoint in a pending state:
    //

    switch( g_ServiceStatus.dwCurrentState )
    {
    case SERVICE_START_PENDING:
    case SERVICE_STOP_PENDING:

        g_ServiceStatus.dwCheckPoint++;

        break;

    default:
        break;
    }

    dwRetCode = SetServiceStatus( g_hServiceStatus,
                                  &g_ServiceStatus );

    if ( dwRetCode == FALSE )
    {
	TRACE1 (INIT, "Error: SetServiceStatus returned %d\n", 
		GetLastError() );
    }
}

#endif


//
// EAPOLCleanUp
//
// Description: Will free any allocated memory, deinitialize RPC, deinitialize
//              the kernel-mode server and unload it if it was loaded.
//              This could have been called due to an error on SERVICE_START
//              or normal termination.
//
// Return values: none
//

VOID
EAPOLCleanUp (
    IN DWORD    dwError
    )
{
    DWORD   dwIndex;
    DWORD   dwEventStatus = 0;
    SERVICE_STATUS  ServiceStatus;
    DWORD   dwRetCode = NO_ERROR;

    if (g_hEventTerminateEAPOL == NULL)
    {
        return;
    }

    // 
    // Check if have already gone through EAPOLCleanUp before
    // Return if so
    //

    if (( dwEventStatus = WaitForSingleObject (
                g_hEventTerminateEAPOL,
                0)) == WAIT_FAILED)
    {
        dwRetCode = GetLastError ();
        if ( g_dwTraceId != INVALID_TRACEID )
	{
            TRACE1 (INIT, "EAPOLCleanUp: WaitForSingleObject failed with error %ld, Terminating cleanup",
                dwRetCode);
	}

        // log

        return;
    }

    if (dwEventStatus == WAIT_OBJECT_0)
    {
        if ( g_dwTraceId != INVALID_TRACEID )
	{
            TRACE0 (INIT, "EAPOLCleanUp: g_hEventTerminateEAPOL already signaled, returning");
	}
        return;
    }

#ifdef EAPOL_SERVICE

    //
    // Announce that we are stopping
    //

    g_ServiceStatus.dwCurrentState     = SERVICE_STOP_PENDING;
    g_ServiceStatus.dwControlsAccepted = 0;
    g_ServiceStatus.dwCheckPoint       = 1;
    g_ServiceStatus.dwWaitHint         = 200000;

    EAPOLAnnounceServiceStatus();

#endif

    //
    // Tear down and free everything
    //

    //
    // Set event to indicate to waiting threads to terminate
    //

    if ( !SetEvent (g_hEventTerminateEAPOL) )
    {
        dwRetCode = GetLastError();
        if ( g_dwTraceId != INVALID_TRACEID )
	{
            TRACE1 (INIT, "EAPOLCleanUp: SetEvent for g_hEventTerminateEAPOL failed with error %ld",
                dwRetCode);
	}

        // log
    }

    //
    // Shutdown device related stuff
    // Close handles to NDISUIO
    // Shutdown EAPOL State machine
    //
    if ( ( dwRetCode = ElMediaDeInit()) != NO_ERROR )
    {
        if ( g_dwTraceId != INVALID_TRACEID )
        {
            TRACE1 (INIT, "Media DeInit failed with dwRetCode = %ld\n", 
                    dwRetCode );
        }

        dwRetCode = NO_ERROR;
    }
	else
	{
            if ( g_dwTraceId != INVALID_TRACEID )
	    {
        	TRACE1 (INIT, "Media DeInit succeeded with dwRetCode = %ld\n", 
                   dwRetCode );
	    }
	}

#ifdef EAPOL_SERVICE

    if ( dwError == NO_ERROR )
    {
        g_ServiceStatus.dwWin32ExitCode = NO_ERROR;
    }
    else
    {
        g_ServiceStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
    }

    g_ServiceStatus.dwCurrentState       = SERVICE_STOPPED;
    g_ServiceStatus.dwControlsAccepted   = 0;
    g_ServiceStatus.dwCheckPoint         = 0;
    g_ServiceStatus.dwWaitHint           = 0;
    g_ServiceStatus.dwServiceSpecificExitCode = dwError;

    EAPOLAnnounceServiceStatus();

#endif

    if (!CloseHandle(g_hStopService))
    {
        if ( g_dwTraceId != INVALID_TRACEID )
        {
            TRACE1 (INIT, "EAPOLCleanup: CloseHandle failed with error %ld",
                GetLastError());
        }
    }

    //
    // Shut down NDISUIO service
    //

    if ( g_hNDISUIOService != NULL )
    {
        if (!ControlService ( g_hNDISUIOService, SERVICE_CONTROL_STOP, &ServiceStatus ))
        {
            if ( g_dwTraceId != INVALID_TRACEID )
            {
                TRACE1 (INIT, "EAPOLCleanup: ControlService failed with error %ld",
                    GetLastError());
            }
        }

        if (!CloseServiceHandle ( g_hNDISUIOService ))
        {
            if ( g_dwTraceId != INVALID_TRACEID )
            {
                TRACE1 (INIT, "EAPOLCleanup: CloseServiceHandle failed with error %ld",
                        GetLastError());
            }
        }

        g_hNDISUIOService = NULL;
    }

    if ( g_hServiceCM != NULL )
    {
        if (!CloseServiceHandle ( g_hServiceCM ))
        {
            if ( g_dwTraceId != INVALID_TRACEID )
            {
                TRACE1 (INIT, "EAPOLCleanup: CloseServiceHandle for SCM failed with error %ld",
                        GetLastError());
            }
        }

        g_hServiceCM = NULL;
    }


    if ( g_dwTraceId != INVALID_TRACEID )
    {
        TRACE1 (INIT, "EAPOLCleanup completed with error %d\n", dwError );
        TraceDeregisterA( g_dwTraceId );
        g_dwTraceId = INVALID_TRACEID;
    }


    EapolLogInformation (EAPOL_LOG_SERVICE_RUNNING, 0, NULL);

    if ( g_hLogEvents != NULL)
    {
        EapolLogInformation (EAPOL_LOG_SERVICE_STOPPED, 0, NULL);
        RouterLogDeregisterW( g_hLogEvents );
        g_hLogEvents = NULL;
    }

    return;
}


#ifdef EAPOL_SERVICE

//
// ServiceHandlerEx
//
// Description: Will respond to control requests from the service controller.
//
// Return values:     none
//
//

DWORD
ServiceHandlerEx (
    IN DWORD        dwControlCode,
    IN DWORD        dwEventType,
    IN LPVOID       lpEventData,
    IN LPVOID       lpContext
    )
{
    DWORD dwRetCode = NO_ERROR;

    switch( dwControlCode )
    {
    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        if ( ( g_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
            ||
            ( g_ServiceStatus.dwCurrentState == SERVICE_STOPPED ))
        {
            break;
        }

        TRACE0 (INIT, "ServiceHandlerEx: SERVICE_CONTROL_ STOP or SHUTDOWN event called");

        //
        // Announce that we are stopping
        //

        g_ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        g_ServiceStatus.dwControlsAccepted = 0;
        g_ServiceStatus.dwCheckPoint       = 1;
        g_ServiceStatus.dwWaitHint         = 200000;

        EAPOLAnnounceServiceStatus();

        SetEvent( g_hStopService );

        return( NO_ERROR );

        break;

    case SERVICE_CONTROL_DEVICEEVENT:
        if ( ( g_ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
            ||
            ( g_ServiceStatus.dwCurrentState == SERVICE_STOPPED ))
        {
            break;
        }

        TRACE0 (INIT, "ServiceHandlerEx: SERVICE_CONTROL_DEVICEEVENT event called");
        // Received notification that some LAN interface was added or deleted

        if (lpEventData != NULL)
        {
            // Call device notification handler

            if ((dwRetCode = ElDeviceNotificationHandler (
                            lpEventData, dwEventType)) != NO_ERROR)
            {
        
                TRACE1 (INIT, "ServiceHandlerEx: ElDeviceNotificationHandler faield with error %ld",
                        dwRetCode);
                break;
            }
        }

    default:

        return( ERROR_CALL_NOT_IMPLEMENTED );

        break;
    }

    return( dwRetCode );
}

#endif


//
// EAPOLServiceMain
//
// Description: This is the main procedure for the EAPOL Server Service. It
//              will be called when the service is supposed to start itself.
//              It will do all service wide initialization.
//
// Return values:     none
//

VOID
WINAPI
EAPOLServiceMain (
    IN DWORD    argc,   // Command line arguments. Will be ignored.
    IN LPWSTR * lpwsServiceArgs
    )
{
    DWORD   dwRetCode = NO_ERROR;

    UNREFERENCED_PARAMETER( argc );
    UNREFERENCED_PARAMETER( lpwsServiceArgs );

    g_hEventTerminateEAPOL = NULL;

    // Queue a worker item to do the heavy-duty work during initialization
    // This will not hold up the main worker thread

    if (!QueueUserWorkItem(
        (LPTHREAD_START_ROUTINE)EAPOLServiceMainWorker,
        NULL,
        WT_EXECUTELONGFUNCTION))
    {
        dwRetCode = GetLastError();
	    ASSERT (0);
    }

}


VOID
EAPOLServiceMainWorker (
        IN  PVOID       pvContext
        )
{

    DWORD       dwIndex = 0;
    SC_HANDLE   hServiceCM;
    SC_HANDLE   hNDISUIOService;
    SC_HANDLE   hNetManService;
    LPQUERY_SERVICE_CONFIG pNetmanServiceConfig = NULL;
    DWORD       dwBufSize = 0, dwBytesNeeded = 0;
    DWORD       dwRetCode = NO_ERROR;

    //
    // Initialize globals
    //

    g_hLogEvents  = NULL;
    g_dwTraceId = INVALID_TRACEID;
    g_hServiceCM = NULL;
    g_hNDISUIOService = NULL;
    g_hStopService = NULL;
    g_dwModulesStarted = 0;
    g_dwMachineAuthEnabled = 0;
    g_hNLA_LPC_Port = NULL;


    //
    // Create event that will be used to indicate EAPOL shutdown 
    //

    g_hEventTerminateEAPOL = CreateEvent( NULL, TRUE, FALSE, NULL );

    if ( g_hEventTerminateEAPOL == (HANDLE)NULL )
    {
	dwRetCode = GetLastError ();
	ASSERT (0);
        EAPOLCleanUp ( dwRetCode );
        return;
    }


    //
    // Register for debug tracing via rtutils.dll
    //

    g_dwTraceId = TraceRegister (L"EAPOL");

    if ( g_dwTraceId == INVALID_TRACEID )
    {
	dwRetCode = GetLastError ();
        ASSERT (0);
        EAPOLCleanUp ( dwRetCode );
        return;
    }

    //
    // Register for event logging via rtutils.dll
    //

    g_hLogEvents = RouterLogRegisterW(L"EAPOL");

    if ( g_hLogEvents == NULL )
    {
	dwRetCode = GetLastError ();
        TRACE1 (INIT, "EAPOLServiceMainWorker: RouterLogRegisterW failed with error %ld",
               dwRetCode); 
        EAPOLCleanUp ( dwRetCode );
        return;
    }


#ifdef EAPOL_SERVICE

    g_hServiceStatus = RegisterServiceCtrlHandlerEx(
                                            TEXT("EAPOL"),
                                            ServiceHandlerEx,
                                            NULL );

    if ( !g_hServiceStatus )
    {
        return;
    }

    g_ServiceStatus.dwServiceType  = SERVICE_WIN32_SHARE_PROCESS;
    g_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;

    EAPOLAnnounceServiceStatus();

#endif

    //
    // Start NDISUIO driver
    //

    if ((g_hServiceCM = OpenSCManager ( NULL, NULL, SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE )) 
            == NULL)
    {
        dwRetCode = GetLastError ();
        TRACE1 (INIT, "EAPOLServiceMainWorker: OpenSCManager failed with error %ld",
               dwRetCode); 
        EAPOLCleanUp ( dwRetCode );
        return;
    }

    if ((g_hNDISUIOService = 
                OpenService ( g_hServiceCM, 
                    NDISUIO_SERVICE_NAME, 
                    SERVICE_START | SERVICE_STOP )) 
            == NULL)
    {
        dwRetCode = GetLastError ();
        TRACE1 (INIT, "EAPOLServiceMainWorker: OpenService NdisUIO failed with error %ld",
                dwRetCode);
        EAPOLCleanUp ( dwRetCode );
        return;
    }

    if (!StartService( g_hNDISUIOService, 0, NULL ))
    {
        dwRetCode = GetLastError ();
        TRACE1 (INIT, "EAPOLServiceMainWorker: StartService failed with error %ld",
                dwRetCode);
        if (dwRetCode != ERROR_SERVICE_ALREADY_RUNNING)
        {
            EAPOLCleanUp ( dwRetCode );
            return;
        }
    }

    //
    // Register for event logging via rtutils.dll
    //

    g_hLogEvents = RouterLogRegisterW(L"EAPOL");

    if ( g_hLogEvents == NULL )
    {
	dwRetCode = GetLastError ();
        TRACE1 (INIT, "EAPOLServiceMainWorker: RouterLogRegisterW failed with error %ld",
                dwRetCode);
        EAPOLCleanUp ( dwRetCode );
        return;
    }

#ifdef EAPOL_SERVICE

    //
    // Announce that we have successfully started.
    //

    g_ServiceStatus.dwCurrentState      = SERVICE_RUNNING;
    g_ServiceStatus.dwCheckPoint        = 0;
    g_ServiceStatus.dwWaitHint          = 0;
    g_ServiceStatus.dwControlsAccepted  = SERVICE_ACCEPT_STOP;

    EAPOLAnnounceServiceStatus();


    //
    // Create event that will be used to shutdown the EAPOL service
    //

    g_hStopService = CreateEvent ( NULL, TRUE, FALSE, NULL );

    if ( g_hStopService == (HANDLE)NULL )
    {
	dwRetCode = GetLastError ();
        TRACE1 (INIT, "EAPOLServiceMainWorker: CreateEvent failed with error %ld",
                dwRetCode);
        EAPOLCleanUp ( dwRetCode );
        return;
    }

#endif

    //
    // Set User logged indication
    //

    g_fUserLoggedOn = 0;

    //
    // Used for detetcing MACHINE_AUTH
    // Verify if netman is SERVICE_AUTO_START and set flag if machine auth
    // is enabled to indicate machine authentication
    //

    if ((hNetManService = 
                OpenService ( g_hServiceCM, 
                    NETMAN_SERVICE_NAME, 
                    SERVICE_QUERY_CONFIG )) 
            == NULL)
    {
        dwRetCode = GetLastError ();
        TRACE1 (INIT, "EAPOLServiceMainWorker: OpenService Netman failed with error %ld",
                dwRetCode);
        EAPOLCleanUp ( dwRetCode );
        return;
    }

    dwBufSize = 0;
    if (!QueryServiceConfig (
                hNetManService,
                NULL,
                dwBufSize,
                &dwBytesNeeded
                ))
    {
        if ((dwRetCode = GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
        {
            pNetmanServiceConfig = (LPQUERY_SERVICE_CONFIG) MALLOC (dwBytesNeeded);
            if (pNetmanServiceConfig == NULL)
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                TRACE0 (INIT, "EAPOLServiceMainWorker: MALLOC failed for pNetmanServiceConfig");
                if (!CloseServiceHandle (hNetManService))
                {
                    dwRetCode = GetLastError ();
                    TRACE1 (INIT, "EAPOLServiceMainWorker: CloseServiceHandle Netman failed with error %ld",
                            dwRetCode);
                }
                EAPOLCleanUp ( dwRetCode );
                return;
            }
            else
            {
                dwBufSize = dwBytesNeeded;
                if (!QueryServiceConfig (
                            hNetManService,
                            pNetmanServiceConfig,
                            dwBufSize,
                            &dwBytesNeeded
                            ))
                {
                    dwRetCode = GetLastError ();
                    TRACE0 (INIT, "EAPOLServiceMainWorker: QueryServiceConfig failed for pNetmanServiceConfig");
                    if (!CloseServiceHandle (hNetManService))
                    {
                        dwRetCode = GetLastError ();
                        TRACE1 (INIT, "EAPOLServiceMainWorker: CloseServiceHandle Netman failed with error %ld",
                                dwRetCode);
                    }
                    EAPOLCleanUp ( dwRetCode );
                    return;
                }
                else
                {
                    if (pNetmanServiceConfig->dwStartType == SERVICE_AUTO_START)
                    {
                        TRACE0 (INIT, "EAPOLServiceMainWorker: Machine auth enabled");
                        g_dwMachineAuthEnabled = 1;
                    }
                    else
                    {
                        TRACE0 (INIT, "EAPOLServiceMainWorker: Machine auth disabled");
                    }
                }
            }
        }
        else
        {
            TRACE1 (INIT, "EAPOLServiceMainWorker: QueryServiceConfig failed with error %ld",
                        dwRetCode);
            if (!CloseServiceHandle (hNetManService))
            {
                dwRetCode = GetLastError ();
                TRACE1 (INIT, "EAPOLServiceMainWorker: CloseServiceHandle Netman failed with error %ld",
                        dwRetCode);
            }
                
            EAPOLCleanUp ( dwRetCode );
            return;
        }
    }

    if (!CloseServiceHandle (hNetManService))
    {
        dwRetCode = GetLastError ();
        TRACE1 (INIT, "EAPOLServiceMainWorker: CloseServiceHandle Netman failed with error %ld",
                dwRetCode);
        EAPOLCleanUp ( dwRetCode );
        return;
    }
                

    //
    // Initialize media related stuff
    // Interfaces will be enumerated, handles to NDISUIO driver will be opened,
    // EAPOL will be initialized
    //

    if ( ( dwRetCode = ElMediaInit()) != NO_ERROR )
    {
        TRACE1 (INIT, "Media Init failed with dwRetCode = %d\n", 
                   dwRetCode );
        EAPOLCleanUp ( dwRetCode );
        return;
    }
	else
	{
        TRACE1 (INIT, "Media Init succeeded with dwRetCode = %d\n", 
                   dwRetCode );
	}

    TRACE0 (INIT, "EAPOL started successfully\n" );


    EapolLogInformation (EAPOL_LOG_SERVICE_STARTED, 0, NULL);

#ifdef EAPOL_SERVICE

    //
    // Just wait here for EAPOL service to terminate.
    //

    dwRetCode = WaitForSingleObject( g_hStopService, INFINITE );

    if ( dwRetCode == WAIT_FAILED )
    {
        dwRetCode = GetLastError();
    }
    else
    {
        dwRetCode = NO_ERROR;
    }

    TRACE0 (INIT, "Stopping EAPOL gracefully\n" );

    EAPOLCleanUp ( dwRetCode );

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\eapolfunc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E A P O L F U N C . H
//
//  Contents:   EAPOL Notification Functions
//
//  Notes:
//
//  Author:     sachins   26 Jul 2000
//
//----------------------------------------------------------------------------

#pragma once

extern "C" 
{

HRESULT EAPOLMANAuthenticationStarted(REFGUID InterfaceId);

HRESULT EAPOLMANAuthenticationSucceeded(REFGUID InterfaceId);

HRESULT EAPOLMANAuthenticationFailed(
        REFGUID InterfaceId,
        DWORD dwType);

HRESULT EAPOLMANNotification(
        REFGUID InterfaceId,
        LPWSTR szwNotificationMessage,
        DWORD dwType);

extern 
VOID 
EAPOLServiceMain (
        IN DWORD        argc,
        IN LPWSTR       *lpwsServiceArgs
        );

extern
VOID
EAPOLCleanUp (
        IN DWORD    dwError
        );

extern
DWORD
ElDeviceNotificationHandler (
        IN  VOID        *lpEventData,
        IN  DWORD       dwEventType
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\dialup.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D I A L U P . H
//
//  Contents:   Dial-up Connection UI object.
//
//  Notes:
//
//  Author:     shaunco   15 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"
#include "rasconob.h"
#include <rasapip.h>

class ATL_NO_VTABLE CDialupConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CDialupConnection,
                        &CLSID_DialupConnection>,
    public CRasConnectionBase,
    public INetConnection,
    public INetRasConnection,
    public IPersistNetConnection,
    public INetConnectionBrandingInfo,
    public INetDefaultConnection,
    public INetConnection2
{
public:
    CDialupConnection () : CRasConnectionBase ()
    {
        m_fCmPathsLoaded = FALSE;
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_DIALUP_CONNECTION)

    BEGIN_COM_MAP(CDialupConnection)
        COM_INTERFACE_ENTRY(INetConnection)
        COM_INTERFACE_ENTRY(INetConnection2)
        COM_INTERFACE_ENTRY(INetRasConnection)
        COM_INTERFACE_ENTRY(INetDefaultConnection)
        COM_INTERFACE_ENTRY(IPersistNetConnection)
        COM_INTERFACE_ENTRY(INetConnectionBrandingInfo)
    END_COM_MAP()

    // INetConnection
    STDMETHOD (Connect) ();

    STDMETHOD (Disconnect) ();

    STDMETHOD (Delete) ();

    STDMETHOD (Duplicate) (
        PCWSTR             pszDuplicateName,
        INetConnection**    ppCon);

    STDMETHOD (GetProperties) (
        NETCON_PROPERTIES** ppProps);

    STDMETHOD (GetUiObjectClassId) (
        CLSID*  pclsid);

    STDMETHOD (Rename) (
        PCWSTR pszNewName);

    // INetRasConnection
    STDMETHOD (GetRasConnectionInfo) (
        RASCON_INFO* pRasConInfo);

    STDMETHOD (SetRasConnectionInfo) (
        const RASCON_INFO* pRasConInfo);

    STDMETHOD (GetRasConnectionHandle) (
        ULONG_PTR*  phRasConn);

    // IPersistNetConnection
    STDMETHOD (GetClassID) (
        CLSID* pclsid);

    STDMETHOD (GetSizeMax) (
        ULONG* pcbSize);

    STDMETHOD (Load) (
        const BYTE* pbBuf,
        ULONG       cbSize);

    STDMETHOD (Save) (
        BYTE*  pbBuf,
        ULONG  cbSize);

    // INetConnectionBrandingInfo
    STDMETHOD (GetBrandingIconPaths) (CON_BRANDING_INFO  ** ppConBrandInfo);
    STDMETHOD (GetTrayMenuEntries)(CON_TRAY_MENU_DATA ** ppMenuData);

    // INetDefaultConnection
    STDMETHOD (SetDefault (BOOL  bDefault));
    STDMETHOD (GetDefault (BOOL* pbDefault));
    
    // INetConnection2
    STDMETHOD (GetPropertiesEx)(OUT NETCON_PROPERTIES_EX** ppConnectionPropertiesEx);

private:

    //  Private Vars to hold the paths to the CM file and keep track if they have been loaded or not.
    //
    tstring m_strCmsFile;
    tstring m_strProfileDir;
    tstring m_strShortServiceName;
    tstring m_strCmDir;
    BOOL    m_fCmPathsLoaded;

    //  Private Accessor functions for the above strings
    //
    PCWSTR
    PszwCmsFile ()
    {
        AssertH (!m_strCmsFile.empty());
        return m_strCmsFile.c_str();
    }
    PCWSTR
    PszwProfileDir ()
    {
        AssertH (!m_strProfileDir.empty());
        return m_strProfileDir.c_str();
    }
    PCWSTR
    PszwCmDir ()
    {
        AssertH (!m_strCmDir.empty());
        return m_strCmDir.c_str();
    }
    PCWSTR
    PszwShortServiceName ()
    {
        AssertH (!m_strShortServiceName.empty());
        return m_strShortServiceName.c_str();
    }

    //  Private methods for handling of type NCT_Internet
    HRESULT HrGetCmpFileLocation(PCWSTR pszPhonebook, PCWSTR pszEntryName, PWSTR pszCmpFilePath);
    HRESULT HrEnsureCmStringsLoaded();
    HRESULT HrGetPrivateProfileSectionWithAlloc(WCHAR** pszwSection, int* nSize);
    HRESULT HrGetMenuNameAndCmdLine(PWSTR pszString, PWSTR pszName, PWSTR pszProgram, PWSTR pszParams);
    HRESULT HrFillInConTrayMenuEntry(PCWSTR pszName, PCWSTR pszCmdLine, PCWSTR pszParams, CON_TRAY_MENU_ENTRY* pMenuEntry);
public:
    static HRESULT
    CreateInstanceUninitialized (
        REFIID              riid,
        VOID**              ppv,
        CDialupConnection** ppObj);

    static HRESULT
    CreateInstanceFromDetails (
        const RASENUMENTRYDETAILS*  pEntryDetails,
        REFIID                      riid,
        VOID**                      ppv);

    static HRESULT
    CreateInstanceFromPbkFileAndEntryName (
        PCWSTR pszwPbkFile,
        PCWSTR pszwEntryName,
        REFIID  riid,
        VOID**  ppv);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\gpnla.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       G P N L A . H
//
//  Contents:   Class for Handling NLA Changes that affect Group Policies
//
//  Notes:
//
//  Author:     sjkhan   20 Feb 2001
//
//----------------------------------------------------------------------------
#pragma once
#include "nmbase.h"
#include <winsock2.h>
#include "ncstl.h"
#include "ncstlstr.h"
#include "netcon.h"
#include "gpbase.h"
#include "cmevent.h"

typedef struct tagGPNLAINFORMATION
{
    tstring         strNetworkName;
    NETCON_STATUS   ncsStatus;
} GPNLAINFORMATION;

typedef pair<GUID, GPNLAINFORMATION> GPNLAPAIR;

typedef list<GPNLAPAIR> GPNLALIST;
typedef GPNLALIST::iterator GPNLAITER;

class CGroupPolicyNetworkLocationAwareness : public CGroupPolicyBase
{
public:
    CGroupPolicyNetworkLocationAwareness();
    ~CGroupPolicyNetworkLocationAwareness();

    HRESULT Initialize();
    HRESULT Uninitialize();
    virtual BOOL IsSameNetworkAsGroupPolicies();

    static VOID NTAPI EventHandler(IN LPVOID pContext, IN BOOLEAN TimerOrWaitFired);
    static VOID NTAPI GroupPolicyChange(IN LPVOID pContext, IN BOOLEAN TimerOrWaitFired);
    static DWORD WINAPI ShutdownNlaHandler(PVOID pThis);

protected:
    HRESULT LookupServiceBegin(DWORD dwControlFlags);
    HRESULT LookupServiceNext(DWORD dwControlFlags, LPDWORD lpdwBufferLength, LPWSAQUERYSET lpqsResults);
    HRESULT LookupServiceEnd();
    HRESULT QueueEvent(CONMAN_EVENTTYPE cmEventType, LPGUID pguidAdapter, NETCON_STATUS ncsStatus);
    HRESULT RegisterWait();
    HRESULT DeregisterWait();
    HRESULT EnumChanges();

    LONG Reference();
    LONG Unreference();

    BOOL IsJoinedToDomain();

    static HRESULT ReconfigureHomeNet(IN BOOL fWaitUntilRunningOrStopped = FALSE);

protected:
    WSADATA             m_wsaData;
    WSACOMPLETION       m_wsaCompletion;
    WSAOVERLAPPED       m_wsaOverlapped;
    HANDLE              m_hQuery;
    WSAQUERYSET         m_wqsRestrictions;
    BOOL                m_fSameNetwork;
    HANDLE              m_hEventNLA;
    HANDLE              m_hNLAWait;
    HANDLE              m_hEventGP;
    HANDLE              m_hGPWait;
    GPNLALIST           m_listAdapters;
    CRITICAL_SECTION    m_csList;
    LONG                m_lRefCount;
    HANDLE              m_hEventExit;
    BOOL                m_fShutdown;
    BOOL                m_fErrorShutdown;
    static LONG         m_lBusyWithReconfigure;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\cmutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C M U T I L . H
//
//  Contents:   Connection manager.
//
//  Notes:
//
//  Author:     omiller   1 Jun 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include <rasapip.h>
#include <stlmap.h>


struct CMEntry
{

    CMEntry() {}
    CMEntry(const CMEntry & ref) 
    {
        Set(ref.m_guid,ref.m_szEntryName,ref.m_ncs);
    }

    CMEntry(const GUID & guid,const WCHAR * szEntryName, const NETCON_STATUS ncs) 
    {
        Set(guid,szEntryName,ncs);
    }

    CMEntry & operator=(const CMEntry & ref)
    {
        if(&ref != this)
        {
            Set(ref.m_guid, ref.m_szEntryName, ref.m_ncs);
        }
        return *this;
    }

    CMEntry & operator=(const CMEntry * ref)
    {
        if(ref != this)
        {
            Set(ref->m_guid, ref->m_szEntryName, ref->m_ncs);
        }
        return *this;
    }

    void Set(const GUID & guid, const WCHAR * sz, const NETCON_STATUS ncs)
    {
        ZeroMemory(m_szEntryName, sizeof(m_szEntryName)); 
        lstrcpyn(m_szEntryName, sz, RASAPIP_MAX_ENTRY_NAME);
        m_guid = guid;
        m_ncs = ncs;
    }

    WCHAR         m_szEntryName[RASAPIP_MAX_ENTRY_NAME + 1];
    GUID          m_guid;
    NETCON_STATUS m_ncs;
};

class CCMUtil
{
public:
    ~CCMUtil();

    static CCMUtil & Instance() { return s_instance; }
    HRESULT HrGetEntry(const GUID & guid, CMEntry & cm);
    HRESULT HrGetEntry(const WCHAR * szEntryName, CMEntry & cm);
    void SetEntry(const GUID & guid, const WCHAR * szEntryName, const NETCON_STATUS ncs);
    void RemoveEntry(const GUID & guid);

private:
    static CCMUtil s_instance;
    
    CRITICAL_SECTION m_CriticalSection;
    
    typedef vector<CMEntry> CMEntryTable;

    CMEntryTable m_Table;

    CMEntryTable::iterator GetIteratorFromGuid(const GUID & guid);

    
    CCMUtil();
    CCMUtil(const CCMUtil &);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\eventq.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E V E N T Q  . H
//
//  Contents:   Event Queue for managing synchonization of external events.
//
//  Notes:      
//
//  Author:     ckotze   29 Nov 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include <ncstl.h>
#include <stlqueue.h>

using namespace std;

class CEvent 
{
public:
    CEvent(HANDLE hEvent);
    ~CEvent();

    HRESULT SetEvent();
    HRESULT ResetEvent();

private:
    HANDLE  m_hEvent;
    BOOL    m_bSignaled;
};

enum EVENT_MANAGER;

typedef struct tagUSERWORKITEM
{
    LPTHREAD_START_ROUTINE Function;
    PVOID Event;
    EVENT_MANAGER EventMgr;
} USERWORKITEM;

typedef list<USERWORKITEM> EVENTQUEUE;
typedef EVENTQUEUE::iterator EVENTQUEUEITER;

class CEventQueue
{
public:
    CEventQueue(HANDLE hServiceShutdown);
    ~CEventQueue();

    HRESULT EnqueueEvent(IN LPTHREAD_START_ROUTINE Function, IN PVOID pEvent, IN const EVENT_MANAGER EventMgr);
    HRESULT DequeueEvent(OUT LPTHREAD_START_ROUTINE& Function, OUT PVOID& pEvent, OUT EVENT_MANAGER& EventMgr);
    BOOL    AtomCheckSizeAndResetEvent(const BOOL fDispatchEvents);
    DWORD   WaitForExit();
    size_t size();

private:
    EVENTQUEUE          m_eqWorkItems;
    CRITICAL_SECTION    m_csQueue;
    CEvent*             m_pFireEvents;
    HANDLE              m_hServiceShutdown;
    HANDLE              m_hWait;
    BOOL                m_fRefreshAllInQueue;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\ncqueue.h ===
#pragma once
#include "nmbase.h"
#include "nmres.h"

//
//  The queue item structure.  The device instance id of the queue item
//  will follow the actual structure (i.e. string start =
//  beginning of structure + size of structure.)
//
struct NCQUEUE_ITEM
{
    DWORD           cbSize;
    NC_INSTALL_TYPE eType;
    GUID            ClassGuid;
    GUID            InstanceGuid;
    DWORD           dwCharacter;
    DWORD           dwDeipFlags;
    union
    {
        DWORD  cchPnpId;
        PWSTR  pszPnpId;
    };
    union
    {
        DWORD  cchInfId;
        PWSTR  pszInfId;
    };

};

class ATL_NO_VTABLE CInstallQueue :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CInstallQueue, &CLSID_InstallQueue>,
    public INetInstallQueue
{
public:
    CInstallQueue();
    VOID FinalRelease ();

    DECLARE_CLASSFACTORY_DEFERRED_SINGLETON(CInstallQueue)
    DECLARE_REGISTRY_RESOURCEID(IDR_INSTALLQUEUE)

    BEGIN_COM_MAP(CInstallQueue)
        COM_INTERFACE_ENTRY(INetInstallQueue)
    END_COM_MAP()

    // INetInstallQueue
    STDMETHOD (AddItem) (
        IN const NIQ_INFO* pInfo);

    STDMETHOD (ProcessItems) ()
    {
        return HrQueueWorkItem();
    };

    VOID            Close();
    HRESULT         HrOpen();
    HRESULT         HrGetNextItem(NCQUEUE_ITEM** ppncqi);
    HRESULT         HrRefresh();
    VOID            MarkCurrentItemForDeletion();

protected:
    CRITICAL_SECTION    m_csReadLock;
    CRITICAL_SECTION    m_csWriteLock;
    DWORD               m_dwNextAvailableIndex;
    HKEY                m_hkey;
    INT                 m_nCurrentIndex;
    DWORD               m_cItems;
    PWSTR*             m_aszItems;
    DWORD               m_cItemsToDelete;
    PWSTR*             m_aszItemsToDelete;
    BOOL                m_fQueueIsOpen;

    DWORD           DwSizeOfItem(NCQUEUE_ITEM* pncqi);
    VOID            DeleteMarkedItems();
    BOOL            FIsQueueIndexInRange();
    VOID            FreeAszItems();
    HRESULT         HrAddItem(
                        const NIQ_INFO* pInfo);

    NCQUEUE_ITEM*   PncqiCreateItem(
                        const NIQ_INFO* pInfo);

    VOID            SetNextAvailableIndex();
    VOID            SetItemStringPtrs(NCQUEUE_ITEM* pncqi);
    HRESULT         HrQueueWorkItem();
};

//+---------------------------------------------------------------------------
//
//  Function:   DwSizeOfItem
//
//  Purpose:    Determines the size (in bytes) of the entire NCQUEUE_ITEM
//              structure.  This includes the string (and the NULL terminator)
//              appended to the end of the structure.
//
//  Arguments:
//      ncqi [in] The queue item.
//
//  Returns:    DWORD. The size in bytes.
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
inline DWORD
CInstallQueue::DwSizeOfItem (NCQUEUE_ITEM* pncqi)
{
    AssertH(pncqi);
    PWSTR pszDeviceInstanceId = (PWSTR)((BYTE*)pncqi + pncqi->cbSize);

    DWORD cbDeviceInstanceId = CbOfSzAndTerm (pszDeviceInstanceId);

    PWSTR pszInfId = (PWSTR)((BYTE*)pszDeviceInstanceId + cbDeviceInstanceId);

    return pncqi->cbSize + cbDeviceInstanceId + CbOfSzAndTerm (pszInfId);
};

//+---------------------------------------------------------------------------
//
//  Function:   SetItemStringPtrs
//
//  Purpose:    Sets the pszwDeviceInstanceId member of the NCQUEUE_ITEM
//              structure to the correct location of the device id string.
//
//  Arguments:
//      pncqi [inout] The queue item.
//
//  Returns:    nothing
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
inline VOID
CInstallQueue::SetItemStringPtrs (
    NCQUEUE_ITEM* pncqi)
{
    AssertH(pncqi);

    pncqi->pszPnpId = (PWSTR)((BYTE*)pncqi + pncqi->cbSize);

    DWORD cbPnpId = CbOfSzAndTerm (pncqi->pszPnpId);
    pncqi->pszInfId = (PWSTR)((BYTE*)pncqi->pszPnpId + cbPnpId);
};

inline BOOL
CInstallQueue::FIsQueueIndexInRange()
{
    return (m_nCurrentIndex >= 0) && (m_nCurrentIndex < (INT)m_cItems);
}

inline void
CInstallQueue::FreeAszItems()
{
    for (DWORD dw = 0; dw < m_cItems; ++dw)
    {
        MemFree(m_aszItems[dw]);
    }
    MemFree(m_aszItems);
    m_aszItems = NULL;
    m_cItems = 0;
}


VOID
WaitForInstallQueueToExit();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\inbound.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I N B O U N D . H
//
//  Contents:   Inbound Connection object.
//
//  Notes:
//
//  Author:     shaunco   23 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"
#include <rasuip.h>


class ATL_NO_VTABLE CInboundConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CInboundConnection,
                        &CLSID_InboundConnection>,
    public INetConnection,
    public INetInboundConnection,
    public IPersistNetConnection,
    public INetConnectionSysTray
{
private:
    // This member will be TRUE if this connection object represents
    // the disconnected object used to configure inbound connections.
    // Only one of these objects exists and is created by the enumerator
    // only when no connected inbound objects exist.
    //
    BOOL                m_fIsConfigConnection;

    // For connected inbound objects, this member is the handle to the
    // connection.
    //
    HRASSRVCONN         m_hRasSrvConn;

    // This is the name of the connection object as shown in the shell.
    // This should never be empty.
    //
    tstring             m_strName;

    // This is the name of the device associated with the connection.
    // This will be empty when m_fIsConfigConnection is TRUE.
    //
    tstring             m_strDeviceName;

    // This is the media type of the connection.
    //
    NETCON_MEDIATYPE    m_MediaType;

    // This is the id of the connection.
    //
    GUID                m_guidId;

    // This member is TRUE only when we are fully initialized.
    //
    BOOL                m_fInitialized;

private:
    PCWSTR
    PszwName ()
    {
        //AssertH (!m_strName.empty());
        return m_strName.c_str();
    }

    PCWSTR
    PszwDeviceName ()
    {
        AssertH (FIff(m_strDeviceName.empty(), m_fIsConfigConnection));
        return (!m_strDeviceName.empty()) ? m_strDeviceName.c_str()
                                          : NULL;
    }

    VOID
    SetName (
            PCWSTR pszwName)
    {
        AssertH (pszwName);
        m_strName = pszwName;
        //AssertH (!m_strName.empty());
    }

    VOID
    SetDeviceName (
            PCWSTR pszwDeviceName)
    {
        if (pszwDeviceName && *pszwDeviceName)
        {
            AssertH (!m_fIsConfigConnection);
            m_strDeviceName = pszwDeviceName;
        }
        else
        {
            AssertH (m_fIsConfigConnection);
            m_strDeviceName.erase();
        }
    }

    HRESULT
    GetCharacteristics (
        DWORD*    pdwFlags);

    HRESULT
    GetStatus (
        NETCON_STATUS*  pStatus);

public:
    CInboundConnection();
    ~CInboundConnection();

    DECLARE_REGISTRY_RESOURCEID(IDR_INBOUND_CONNECTION)

    BEGIN_COM_MAP(CInboundConnection)
        COM_INTERFACE_ENTRY(INetConnection)
        COM_INTERFACE_ENTRY(INetInboundConnection)
        COM_INTERFACE_ENTRY(IPersistNetConnection)
        COM_INTERFACE_ENTRY(INetConnectionSysTray)
    END_COM_MAP()

    // INetConnection
    STDMETHOD (Connect) ();

    STDMETHOD (Disconnect) ();

    STDMETHOD (Delete) ();

    STDMETHOD (Duplicate) (
        PCWSTR             pszwDuplicateName,
        INetConnection**    ppCon);

    STDMETHOD (GetProperties) (
        NETCON_PROPERTIES** ppProps);

    STDMETHOD (GetUiObjectClassId) (
        CLSID*  pclsid);

    STDMETHOD (Rename) (
        PCWSTR pszwNewName);

    // INetInboundConnection
    STDMETHOD (GetServerConnectionHandle) (
        ULONG_PTR*  phRasSrvConn);

    STDMETHOD (InitializeAsConfigConnection) (
        BOOL fStartRemoteAccess);

    // IPersistNetConnection
    STDMETHOD (GetClassID) (
        CLSID* pclsid);

    STDMETHOD (GetSizeMax) (
        ULONG* pcbSize);

    STDMETHOD (Load) (
        const BYTE* pbBuf,
        ULONG       cbSize);

    STDMETHOD (Save) (
        BYTE*  pbBuf,
        ULONG  cbSize);

    // INetConnectionSysTray
    STDMETHOD (ShowIcon) (
        const BOOL bShowIcon)
    {
        return E_NOTIMPL;
    }

    STDMETHOD (IconStateChanged) ();

public:
    static HRESULT CreateInstance (
        BOOL        fIsConfigConnection,
        HRASSRVCONN hRasSrvConn,
        PCWSTR     pszwName,
        PCWSTR     pszwDeviceName,
        DWORD       dwType,
        const GUID* pguidId,
        REFIID      riid,
        VOID**      ppv);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\lan.h ===
#pragma once
#include "nmbase.h"
#include "nmres.h"
#include "nmhnet.h"


extern LONG g_CountLanConnectionObjects;


class ATL_NO_VTABLE CLanConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CLanConnection, &CLSID_LanConnection>,
    public INetConnection,
    public IPersistNetConnection,
    public INetLanConnection,
    public INetConnectionSysTray,
    public INetConnection2
{
private:
    HKEY                    m_hkeyConn;         // hkey for connection root
    BOOL                    m_fInitialized;
    HDEVINFO                m_hdi;
    SP_DEVINFO_DATA         m_deid;
    
    // This is required for checking permission on Firewall etc.
    CComPtr<INetMachinePolicies>    m_pNetMachinePolicies;

    // Home networking support. m_fHNetPropertiesCached is set to TRUE
    // after the first successful call to HrEnsureHNetPropertiesCached.
    //
    BOOL                    m_fHNetPropertiesCached;
    LONG                    m_lHNetModifiedEra;
    LONG                    m_lUpdatingHNetProperties;
    HNET_CONN_PROPERTIES    *m_pHNetProperties;
    

public:
    CLanConnection()
    {
        m_hkeyConn = NULL;
        m_fInitialized = FALSE;
        m_hdi = NULL;
        m_fHNetPropertiesCached = FALSE;
        m_lHNetModifiedEra = 0;
        m_pHNetProperties = NULL;
        m_lUpdatingHNetProperties = 0;
        m_pNetMachinePolicies = NULL;
        InterlockedIncrement(&g_CountLanConnectionObjects);
    }
    ~CLanConnection();

    DECLARE_REGISTRY_RESOURCEID(IDR_LAN_CONNECTION)

    BEGIN_COM_MAP(CLanConnection)
        COM_INTERFACE_ENTRY(INetConnection)
        COM_INTERFACE_ENTRY(IPersistNetConnection)
        COM_INTERFACE_ENTRY(INetLanConnection)
        COM_INTERFACE_ENTRY(INetConnectionSysTray)
        COM_INTERFACE_ENTRY(INetConnection2)
    END_COM_MAP()

    // INetConnection
    HRESULT GetDeviceName(PWSTR* ppszwDeviceName);
    HRESULT GetStatus(NETCON_STATUS*  pStatus);
    HRESULT GetCharacteristics(NETCON_MEDIATYPE ncm, DWORD* pdwFlags);

    STDMETHOD(Connect)();
    STDMETHOD(Disconnect)();
    STDMETHOD(Delete)();
    STDMETHOD(Duplicate) (PCWSTR pszwDuplicateName, INetConnection** ppCon);
    STDMETHOD(GetProperties) (NETCON_PROPERTIES** ppProps);
    STDMETHOD(GetUiObjectClassId)(CLSID *pclsid);
    STDMETHOD(Rename)(PCWSTR pszwNewName);

    //
    // INetLanConnection
    //

    STDMETHOD(GetInfo)(DWORD dwMask, LANCON_INFO* pLanConInfo);
    STDMETHOD(SetInfo)(DWORD dwMask, const LANCON_INFO* pLanConInfo);
    STDMETHOD(GetDeviceGuid)(GUID *pguid);

    //
    // IPersistNetConnection
    //

    STDMETHOD(GetClassID)(CLSID *pclsid);
    STDMETHOD(GetSizeMax)(ULONG *pcbSize);
    STDMETHOD(Load)(const BYTE *pbBuf, ULONG cbSize);
    STDMETHOD(Save)(BYTE *pbBuf, ULONG cbSize);

    // INetConnectionSysTray
    STDMETHOD (ShowIcon) (const BOOL bShowIcon);

    // INetConnectionSysTray
    STDMETHOD (IconStateChanged) ();

    // INetConnection2
    STDMETHOD (GetPropertiesEx)(OUT NETCON_PROPERTIES_EX** ppConnectionPropertiesEx);
    
    //
    // Overrides
    //
    static HRESULT CreateInstance(HDEVINFO hdi, const SP_DEVINFO_DATA &deid,
                                  PCWSTR pszPnpId,
                                  REFIID riid, LPVOID *ppv);

private:
    HRESULT HrIsConnectionActive(VOID);
    HRESULT HrPutName(PCWSTR szwName);
    HRESULT HrInitialize(PCWSTR pszPnpId);
    HRESULT HrLoad(const GUID &guid);
    HRESULT HrOpenRegistryKeys(const GUID &guid);
    HRESULT HrConnectOrDisconnect(BOOL fConnect);
    HRESULT HrCallSens(BOOL fConnect);
    HRESULT HrLoadDevInfoFromGuid(const GUID &guid);
    HRESULT HrIsAtmAdapterFromHkey(HKEY hkey);
    HRESULT HrIsAtmElanFromHkey(HKEY hkey);
    BOOL FIsMediaPresent(VOID);
    HRESULT HrIsConnectionBridged(BOOL* pfBridged);
    HRESULT HrIsConnectionFirewalled(BOOL* pfFirewalled);
    HRESULT HrIsConnectionNetworkBridge(BOOL* pfBridged);
    HRESULT HrIsConnectionIcsPublic(BOOL* pfIcsPublic);
    HRESULT HrEnsureHNetPropertiesCached(VOID);
    HRESULT HrGetIHNetConnection(IHNetConnection **ppHNetConnection);
    HRESULT HrEnsureValidNlaPolicyEngine();
};

//
// Globals
//

HRESULT HrGetInstanceGuid(HDEVINFO hdi, const SP_DEVINFO_DATA &deid,
                          LPGUID pguid);
VOID EnsureUniqueConnectionName(PCWSTR pszPotentialName, PWSTR pszNewName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\nminit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N M I N I T . H
//
//  Contents:   Initialization routines for netman.
//
//  Notes:
//
//  Author:     shaunco   27 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once

HRESULT
HrNmCreateClassObjectRegistrationEvent (
    HANDLE* phEvent);

HRESULT
HrNmWaitForClassObjectsToBeRegistered ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\nmbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N M B A S E . H
//
//  Contents:   Base include file for netman.exe.  Defines globals.
//
//  Notes:
//
//  Author:     shaunco   15 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "netcon.h"
#include "netconp.h"
#include <atlbase.h>
#include "ncstl.h"
#include "stlmap.h"

enum EVENT_MANAGER
{
    INVALID_EVENTMGR = 0,
    EVENTMGR_CONMAN
};

#define PersistDataLead 0x14
#define PersistDataTrail 0x05

typedef struct tagRegEntry
{
    LPWSTR      strKeyName;
    LPWSTR      strValueName;
    DWORD       dwType;
    DWORD       dwValue;
    LPWSTR      strValue;
    BYTE*       pbValue;
    DWORD       dwBinLen;
    BOOL        fMoreOnKey;
} REGENTRY;

typedef map<GUID, INetConnectionManager*> CLASSMANAGERMAP;
bool operator < (const GUID& rguid1, const GUID& rguid2);

enum RASREFTYPE
{
    REF_INITIALIZE,
    REF_REFERENCE,
    REF_UNREFERENCE,
};

class CServiceModule : public CComModule
{
public:
    VOID    DllProcessAttach (HINSTANCE hinst);
    VOID    DllProcessDetach (VOID);

    VOID    ServiceMain (DWORD argc, PWSTR argv[]);
    DWORD   DwHandler (DWORD dwControl, DWORD dwEventType,
                       PVOID pEventData, PVOID pContext);
    VOID    Run ();
    VOID    SetServiceStatus (DWORD dwState);
    VOID    UpdateServiceStatus (BOOL fUpdateCheckpoint = TRUE);
    DWORD   DwServiceStatus () { return m_status.dwCurrentState; }

    VOID    ReferenceRasman (RASREFTYPE RefType);

private:
    static
    DWORD
    WINAPI
    _DwHandler (
        DWORD dwControl,
        DWORD dwEventType,
        PVOID pEventData,
        PVOID pContext);

public:
    HRESULT ServiceShutdown();
    HRESULT ServiceStartup();
    DWORD                   m_dwThreadID;
    SERVICE_STATUS_HANDLE   m_hStatus;
    SERVICE_STATUS          m_status;
    BOOL                    m_fRasmanReferenced;
};


extern CServiceModule _Module;
#include <atlcom.h>

#include "ncatl.h"
#include "ncstring.h"
#include "nmclsid.h"


enum CONMAN_EVENTTYPE
{
    INVALID_TYPE = 0,
    CONNECTION_ADDED,
    CONNECTION_BANDWIDTH_CHANGE,
    CONNECTION_DELETED,
    CONNECTION_MODIFIED,
    CONNECTION_RENAMED,
    CONNECTION_STATUS_CHANGE,
    REFRESH_ALL,
    CONNECTION_ADDRESS_CHANGE,
    CONNECTION_BALLOON_POPUP,
    DISABLE_EVENTS
};

BOOL IsValidEventType(EVENT_MANAGER EventMgr, int EventType);

// This LONG is incremented every time we get a notification that
// a RAS phonebook entry has been modified.  It is reset to zero
// when the service is started.  Wrap-around does not matter.  It's
// purpose is to let a RAS connection object know if it's cache should
// be re-populated with current information.
//
extern LONG g_lRasEntryModifiedVersionEra;

VOID
LanEventNotify (
    CONMAN_EVENTTYPE    EventType,
    INetConnection*     pConn,
    PCWSTR             szwNewName,
    const GUID *        pguidConn);

VOID
IncomingEventNotify (
    CONMAN_EVENTTYPE    EventType,
    INetConnection*     pConn,
    PCWSTR             szwNewName,
    const GUID *        pguidConn);

STDAPI
RegisterSvrHelper();

STDAPI
CreateEAPOLKeys();

STDAPI
SetKeySecurity(
    DWORD dwKeyIndex,
    PSID psidUserOrGroup,
    ACCESS_MASK dwAccessMask);

VOID
NTAPI
DispatchEvents(
    IN LPVOID pContext,
    IN BOOLEAN TimerOrWaitFired);

HRESULT
HrEnsureEventHandlerInitialized();

HRESULT
UninitializeEventHandler();

BOOL
QueueUserWorkItemInThread(
    IN LPTHREAD_START_ROUTINE Function,
    IN PVOID Context,
    IN EVENT_MANAGER EventMgr);

DWORD
WINAPI
GroupPolicyNLAEvents(
    IN LPVOID pContext,
    IN BOOLEAN TimerOrWaitFired);

DWORD
WINAPI
ConmanEventWorkItem(PVOID);

DWORD
WINAPI
RasEventWorkItem(PVOID);

DWORD
WINAPI
LanEventWorkItem(PVOID);

HRESULT
WINAPI
HrEnsureRegisteredWithNla();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\nmhnet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       N M H N E T. H
//
//  Contents:   Globals and routines used of hnetworking support
//
//  Notes:
//
//  Author:     jonburs     15 August 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "nmres.h"
#include "netconp.h"
#include "hnetcfg.h"

//
// Cached IHNetCfgMgr pointer. This pointer is obtained the
// first time someone calls HrGetHNetCfgMgr, and is released
// when CleanupHNetSupport is called.
//

extern IHNetCfgMgr *g_pHNetCfgMgr;

//
// This value is incremented every time INetConnectionHNetUtil::NotifyUpdate()
// is called, and is used by connection objects to make sure that their
// cached homenet properties (sharing, bridging, firewall, etc.) are
// up to date. Rollover does not matter. This value is set to 0 when
// InitializeHNetSupport is called.
//

extern LONG g_lHNetModifiedEra;

VOID
InitializeHNetSupport(
    VOID
    );

VOID
CleanupHNetSupport(
    VOID
    );

HRESULT
HrGetHNetCfgMgr(
    IHNetCfgMgr **ppHNetCfgMgr
    );

class ATL_NO_VTABLE CNetConnectionHNetUtil :
    public CComObjectRootEx <CComMultiThreadModelNoCS>,
    public CComCoClass <CNetConnectionHNetUtil, &CLSID_NetConnectionHNetUtil>,
    public INetConnectionHNetUtil
{

public:

    BEGIN_COM_MAP(CNetConnectionHNetUtil)
        COM_INTERFACE_ENTRY(INetConnectionHNetUtil)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()
    DECLARE_REGISTRY_RESOURCEID(IDR_HN_CONNECTION_UTIL)

    CNetConnectionHNetUtil()
    {
    }
    
    ~CNetConnectionHNetUtil()
    {
    }

    //
    // INetConnectionHNetUtil
    //

    STDMETHODIMP
    NotifyUpdate(
        VOID
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\nmclsid.h ===
#include <guiddef.h>

// Reserved GUIDS for our use
//
// BA126AD1-2166-11D1-B1D0-00805FC1270E     CLSID_ConnectionManager
// BA126AD2-2166-11D1-B1D0-00805FC1270E     CLSID_ConnectionManagerEnumConnection
// BA126AD3-2166-11D1-B1D0-00805FC1270E     CLSID_LanConnectionManager
// BA126AD4-2166-11D1-B1D0-00805FC1270E     CLSID_LanConnectionManagerEnumConnection
// BA126AD5-2166-11D1-B1D0-00805FC1270E     CLSID_WanConnectionManager
// BA126AD6-2166-11D1-B1D0-00805FC1270E     CLSID_WanConnectionManagerEnumConnection
// BA126AD7-2166-11D1-B1D0-00805FC1270E     CLSID_DialUpConnection
// BA126AD8-2166-11D1-B1D0-00805FC1270E     CLSID_NetGroupPolicies
// BA126AD9-2166-11D1-B1D0-00805FC1270E     CLSID_InboundConnection
// BA126ADA-2166-11D1-B1D0-00805FC1270E     (free) CLSID_InternetConnection
// BA126ADB-2166-11D1-B1D0-00805FC1270E     CLSID_LanConnection
// BA126ADC-2166-11D1-B1D0-00805FC1270E     (free) CLSID_VpnConnection
// BA126ADD-2166-11D1-B1D0-00805FC1270E     CLSID_InboundConnectionManager
// BA126ADE-2166-11D1-B1D0-00805FC1270E     CLSID_InboundConnectionManagerEnumConnection
// BA126ADF-2166-11D1-B1D0-00805FC1270E     CLSID_InstallQueue
// BA126AE0-2166-11D1-B1D0-00805FC1270E     CLSID_SharedAccessConnectionManager
// BA126AE1-2166-11D1-B1D0-00805FC1270E     CLSID_SharedAccessConnectionManagerEnumConnection
// BA126AE2-2166-11D1-B1D0-00805FC1270E     CLSID_SharedAccessConnection
// BA126AE3-2166-11D1-B1D0-00805FC1270E     CLSID_NetConnectionHNetUtil
// BA126AE4-2166-11D1-B1D0-00805FC1270E     CLSID_EAPOLManager
// BA126AE5-2166-11D1-B1D0-00805FC1270E     CLSID_ConnectionManager2
// ...
// BA126B1D-2166-11D1-B1D0-00805FC1270E
// BA126B1E-2166-11D1-B1D0-00805FC1270E
// BA126B1F-2166-11D1-B1D0-00805FC1270E

// The following CLSIDs are defined in uuid.lib because the public uses them.
//
EXTERN_C const CLSID CLSID_ConnectionManager;
EXTERN_C const CLSID CLSID_LanConnectionManager;
EXTERN_C const CLSID CLSID_NetConnectionHNetUtil;
EXTERN_C const CLSID CLSID_EAPOLManager;

DEFINE_GUID(CLSID_ConnectionManagerEnumConnection,          0xBA126AD2,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_LanConnectionManagerEnumConnection,       0xBA126AD4,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_WanConnectionManager,                     0xBA126AD5,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_WanConnectionManagerEnumConnection,       0xBA126AD6,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_DialupConnection,                         0xBA126AD7,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_NetGroupPolicies,                         0xBA126AD8,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_InboundConnection,                        0xBA126AD9,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_LanConnection,                            0xBA126ADB,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_InboundConnectionManager,                 0xBA126ADD,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_InboundConnectionManagerEnumConnection,   0xBA126ADE,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_SharedAccessConnectionManager,            0xBA126AE0,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_SharedAccessConnectionManagerEnumConnection, 0xBA126AE1,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_SharedAccessConnection,                   0xBA126AE2,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);

DEFINE_GUID(CLSID_InstallQueue,                             0xBA126ADF,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\nmpolicy.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       N M P O L I C Y  . H
//
//  Contents:   Interface for verifying NLA policy settings.
//
//  Notes:      
//
//  Author:     ckotze   12 Dec 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"
#include "gpnla.h"

class ATL_NO_VTABLE CNetMachinePolicies : 
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CNetMachinePolicies,
                        &CLSID_NetGroupPolicies>,
    public INetMachinePolicies

{
public:
    CNetMachinePolicies();
    ~CNetMachinePolicies();
    
    DECLARE_REGISTRY_RESOURCEID(IDR_NET_GROUP_POLICIES)

    BEGIN_COM_MAP(CNetMachinePolicies)
        COM_INTERFACE_ENTRY(INetMachinePolicies)
    END_COM_MAP()

    HRESULT STDMETHODCALLTYPE VerifyPermission(IN const DWORD ulPerm, OUT BOOL* pfPermission);

protected:
    CGroupPolicyNetworkLocationAwareness* m_pGroupPolicyNLA;
private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOGDI
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <setupapi.h>

#include <stdio.h>
#include <wchar.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\nmres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N M R E S . H
//
//  Contents:   Master resource header for netman.exe
//
//  Notes:
//
//  Author:     shaunco   15 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once

//+---------------------------------------------------------------------------
// Strings resources
//
#define IDS_INBOUND_CONFIG_CONNECTION_NAME  100
#define IDS_LAN_DEFAULT_CONN_NAME           101
#define IDS_INSTALLQUEUE_CAPTION            102
#define IDS_INSTALLQUEUE_REBOOT_REQUIRED    103
#define IDS_ELAN_DEFAULT_CONN_NAME          104
#define IDS_ATM_DEFAULT_CONN_NAME           105
#define IDS_SHAREDACCESS_DEFAULT_CONN_NAME  106
#define IDS_SHAREDACCESS_CONN_NAME          107
#define IDS_BRIDGE_DEFAULT_CONN_NAME        108

//+---------------------------------------------------------------------------
// Reigstry resources
//

// Netman application
//
#define IDR_NETMAN                  100

// Connection Manager
//
#define IDR_CONMAN                  101
#define IDR_CONMAN_ENUM             102

// Connection Class Managers
//
#define IDR_INBOUND_CONMAN          103
#define IDR_INBOUND_CONMAN_ENUM     104
#define IDR_LAN_CONMAN              105
#define IDR_LAN_CONMAN_ENUM         106
#define IDR_WAN_CONMAN              107
#define IDR_WAN_CONMAN_ENUM         108

// Connection Objects
//
#define IDR_DIALUP_CONNECTION       109
#define IDR_DIRECT_CONNECTION       110
#define IDR_INBOUND_CONNECTION      111
#define IDR_INTERNET_CONNECTION     112
#define IDR_LAN_CONNECTION          113
#define IDR_VPN_CONNECTION          114

// Install queue
//
#define IDR_INSTALLQUEUE            115

// Connection Manager 2
//
#define IDR_CONMAN2                 122


// Shared Access Connection Class Manager

#define IDR_SA_CONMAN                120
#define IDR_SA_CONMAN_ENUM           117
#define IDR_SA_CONNECTION            118

// Home networking util

#define IDR_HN_CONNECTION_UTIL       119

// EAPOL Manager
//

#define IDR_EAPOLMAN                116

// NetGroupPolicies

#define IDR_NET_GROUP_POLICIES      121
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\test\main.cpp ===
#include "pch.h"
#pragma hdrstop
#include <netcon.h>
#include <netconp.h>
#include <tchar.h>

EXTERN_C
VOID
__cdecl
wmain ()
/*
VOID
wmainCRTStartup (
    VOID
    )
*/
{
    HRESULT                 hr;
    INetConnectionManager * pconMan;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_ConnectionManager, NULL,
                              CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                              IID_INetConnectionManager,
                              (LPVOID *)&pconMan);
        if (SUCCEEDED(hr))
        {
            IEnumNetConnection* pEnum;
            hr = pconMan->EnumConnections(NCME_DEFAULT, &pEnum);

            if (SUCCEEDED(hr))
            {
                INetConnection* aNetCon [512];
                ULONG           cNetCon;

                hr = pEnum->Next (celems(aNetCon), aNetCon, &cNetCon);

                _tprintf(L"Number of connections: %d\r\n", cNetCon);

                if (SUCCEEDED(hr))
                {
                    for (ULONG i = 0; i < cNetCon; i++)
                    {
                        INetConnection* pNetCon = aNetCon[i];

                        NETCON_PROPERTIES* pProps;
                        hr = pNetCon->GetProperties (&pProps);
                        if (SUCCEEDED(hr))
                        {
                            _tprintf(L"Connection name: %s Type: %d\r\n", pProps->pszwName, pProps->MediaType);
                            
                            if (pProps->MediaType == NCT_LAN && pProps->Status == NCS_MEDIA_DISCONNECTED)
                            {
                                _tprintf(L"Connection %s (%s) is currently Disconnected", pProps->pszwName, pProps->pszwDeviceName);
                            }
                            if (pProps->dwCharacter & NCCF_INCOMING_ONLY)
                            {
                                _tprintf(L"Inbound Connection\r\n");
                                INetConnectionSysTray* pTray;
                                hr = pNetCon->QueryInterface(IID_INetConnectionSysTray, reinterpret_cast<void **>(&pTray));
                                _tprintf(L"QI returned: %x", hr);
                                if (SUCCEEDED(hr))
                                {
                                    pTray->IconStateChanged();
                                }
                            }

                            CoTaskMemFree(pProps);
                        }

                        ReleaseObj (pNetCon);
                    }
                }
                pEnum->Release();
            }

            pconMan->Release();
        }
        CoUninitialize();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\test\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Connections Manager Test App"
#define VER_INTERNALNAME_STR            "tnetman.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\saconob.h ===
#pragma once
#include "hnetbcon.h"
#include "nmbase.h"
#include "nmres.h"
#include "HNetCfg.h"



extern LONG g_CountSharedAccessConnectionObjects;

HRESULT InvokeVoidAction(IUPnPService * pService, LPTSTR pszCommand, VARIANT* pOutParams);

class ATL_NO_VTABLE CSharedAccessConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CSharedAccessConnection, &CLSID_SharedAccessConnection>,
    public INetConnection,
    public INetSharedAccessConnection,
    public IPersistNetConnection
{

public:
    DECLARE_REGISTRY_RESOURCEID(IDR_SA_CONNECTION)

    BEGIN_COM_MAP(CSharedAccessConnection)
        COM_INTERFACE_ENTRY(INetConnection)
        COM_INTERFACE_ENTRY(INetSharedAccessConnection)
        COM_INTERFACE_ENTRY(IPersistNetConnection)
    END_COM_MAP()

    CSharedAccessConnection();
    
    HRESULT GetStatus(NETCON_STATUS*  pStatus);
    HRESULT GetCharacteristics(DWORD* pdwFlags);
    
    //
    // INetConnection
    //
    STDMETHOD(Connect)();
    STDMETHOD(Disconnect)();
    STDMETHOD(Delete)();
    STDMETHOD(Duplicate) (PCWSTR pszwDuplicateName, INetConnection** ppCon);
    STDMETHOD(GetProperties) (NETCON_PROPERTIES** ppProps);
    STDMETHOD(GetUiObjectClassId)(CLSID *pclsid);
    STDMETHOD(Rename)(PCWSTR pszwNewName);

    //
    // INetSharedAccessConnection
    //
    
    STDMETHOD(GetInfo)(DWORD dwMask, SHAREDACCESSCON_INFO* pConInfo);
    STDMETHOD(SetInfo)(DWORD dwMask, const SHAREDACCESSCON_INFO* pConInfo);
    STDMETHODIMP GetLocalAdapterGUID(GUID* pGuid);
    STDMETHODIMP GetService(SAHOST_SERVICES ulService, IUPnPService** ppService);


    //
    // IPersistNetConnection
    //

    STDMETHOD(GetClassID)(CLSID *pclsid);
    STDMETHOD(GetSizeMax)(ULONG *pcbSize);
    STDMETHOD(Load)(const BYTE *pbBuf, ULONG cbSize);
    STDMETHOD(Save)(BYTE *pbBuf, ULONG cbSize);

    //
    // Overrides
    //

    HRESULT FinalConstruct(void);
    HRESULT FinalRelease(void);

private:
    HRESULT GetConnectionName(LPWSTR* pName);
    HRESULT GetStringStateVariable(IUPnPService* pService, LPWSTR pszVariableName, BSTR* pString);

    ISharedAccessBeacon* m_pSharedAccessBeacon;
    IUPnPService* m_pWANConnectionService;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\inc\rasconob.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S C O N O B . H
//
//  Contents:   Declares the base class used to implement the Dialup, Direct,
//              and Vpn connection objects.  Also includes RAS-related
//              utility functions used only within netman.exe.
//
//  Notes:
//
//  Author:     shaunco   23 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "netconp.h"
#include "nmhnet.h"
#include <ras.h>
#include <rasapip.h>


class CRasConnectionBase
{
protected:
    BOOL                m_fInitialized;

    // These are the 'primary id' for the connection.  Every property of
    // a connection can be obtained using these two pieces of information.
    //
    tstring             m_strPbkFile;
    GUID                m_guidId;

    // m_fEntryPropertiesCached is set to TRUE after the first call
    // to HrEnsureEntryPropertiesCached.  The following members are cached
    // as a result of this.
    //
    BOOL                m_fEntryPropertiesCached;
    LONG                m_lRasEntryModifiedVersionEra;
    tstring             m_strEntryName;
    tstring             m_strDeviceName;
    BOOL                m_fBranded;
    BOOL                m_fForAllUsers;
    BOOL                m_fShowMonitorIconInTaskBar;
    NETCON_MEDIATYPE    m_MediaType;
    DWORD               m_dwFlagsPriv;
    tstring             m_strPhoneNumber;


    // This is required for checking permission on Firewall etc.
    CComPtr<INetMachinePolicies>    m_pNetMachinePolicies;
    
    // Home networking support. m_fHNetPropertiesCached is set to TRUE
    // after the first successful call to HrEnsureHNetPropertiesCached.
    //
    BOOL                m_fHNetPropertiesCached;
    LONG                m_lHNetModifiedEra;
    LONG                m_lUpdatingHNetProperties;
    HNET_CONN_PROPERTIES    m_HNetProperties;

protected:
    CRasConnectionBase ()
    {
        // Warning: this class should never have any virtual methods
        // or derive from a class with virtual methods.  If it does,
        // you'll have to remove the ZeroMemory and replace it with
        // induhvidual moves.  (Did you catch the Dilbert reference?)
        //
        ZeroMemory (this, sizeof(CRasConnectionBase));
    }

    BOOL FAllowRemoval (
        HRESULT* phReason);

    BOOL
    FIsBranded ()
    {
        AssertH (m_fEntryPropertiesCached);
        return m_fBranded;
    }

    BOOL
    FShowIcon ()
    {
        AssertH (m_fEntryPropertiesCached);
        return m_fShowMonitorIconInTaskBar;
    }

    GUID
    GuidId ()
    {
        AssertH (m_fEntryPropertiesCached);
        AssertH (m_guidId != GUID_NULL);
        return m_guidId;
    }

    PCWSTR
    PszwPbkFile ()
    {
        AssertH (!m_strPbkFile.empty());
        return m_strPbkFile.c_str();
    }

    PCWSTR
    PszwEntryName ()
    {
        AssertH (!m_strEntryName.empty());
        return m_strEntryName.c_str();
    }

    VOID
    SetPbkFile (
            PCWSTR pszwPbkFile)
    {
        AssertH (pszwPbkFile);
        m_strPbkFile = pszwPbkFile;
        AssertH (!m_strPbkFile.empty());
    }

    VOID
    SetEntryName (
            PCWSTR pszwEntryName)
    {
        AssertH (pszwEntryName);
        m_strEntryName = pszwEntryName;
        AssertH (!m_strEntryName.empty());
    }

    PCWSTR
    PszwDeviceName ()
    {
        AssertH (m_fEntryPropertiesCached);
        return (!m_strDeviceName.empty()) ? m_strDeviceName.c_str()
                                          : NULL;
    }

    NETCON_MEDIATYPE
    MediaType ()
    {
        AssertH (m_fEntryPropertiesCached);
        return m_MediaType;
    }


    VOID
    CacheProperties (
        const RASENUMENTRYDETAILS*  pDetails);

    HRESULT
    HrEnsureEntryPropertiesCached ();

    HRESULT
    HrFindRasConn (
        OUT HRASCONN* phRasConn,
        OUT RASCONN* pRasConn OPTIONAL);

    HRESULT HrGetCharacteristics (
        DWORD*    pFlags);

    HRESULT HrGetStatus (
        NETCON_STATUS*  pStatus);

    HRESULT
    HrLockAndRenameEntry (
        PCWSTR                                     pszwNewName,
        CComObjectRootEx <CComMultiThreadModel>*    pObj);

    HRESULT
    HrGetRasConnectionInfo (
        RASCON_INFO* pRasConInfo);

    HRESULT
    HrSetRasConnectionInfo (
        const RASCON_INFO* pRasConInfo);

    HRESULT
    HrGetRasConnectionHandle (
            HRASCONN* phRasConn);

    HRESULT
    HrPersistGetSizeMax (
        ULONG*  pcbSize);

    HRESULT
    HrPersistLoad (
        const BYTE* pbBuf,
        ULONG       cbSize);

    HRESULT
    HrPersistSave (
        BYTE*   pbBuf,
        ULONG   cbSize);

    HRESULT
    HrEnsureHNetPropertiesCached ();

    HRESULT
    HrGetIHNetConnection (
        IHNetConnection **ppHNetConnection);

    HRESULT
    HrIsConnectionFirewalled(
        BOOL* pfFirewalled);

    HRESULT 
    HrEnsureValidNlaPolicyEngine();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netman\ncqueue\ncqueue.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       N C Q U E U E . C P P
//
//  Contents:   NetCfg queued installer actions
//
//  Notes:
//
//  Author:     billbe   19 Aug 1998
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "nceh.h"
#include "ncmisc.h"
#include "ncnetcfg.h"
#include "ncqueue.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncui.h"
#include "wizentry.h"


const WCHAR c_szRegKeyNcQueue[] = L"SYSTEM\\CurrentControlSet\\Control\\Network\\NcQueue";
const DWORD c_cchQueueValueNameLen = 9;
const DWORD c_cbQueueValueNameLen = c_cchQueueValueNameLen * sizeof(WCHAR);

enum RO_ACTION
{
    RO_ADD,
    RO_CLEAR,
};

extern const WCHAR c_szRegValueNetCfgInstanceId[];

CRITICAL_SECTION    g_csRefCount;
DWORD               g_dwRefCount = 0;
HANDLE              g_hLastThreadExitEvent;

DWORD WINAPI
InstallQueueWorkItem(PVOID pvContext);


inline VOID
IncrementRefCount()
{
    EnterCriticalSection(&g_csRefCount);

    // If 0 is the current count and we have an event to reset...
    if (!g_dwRefCount && g_hLastThreadExitEvent)
    {
        ResetEvent(g_hLastThreadExitEvent);
    }
    ++g_dwRefCount;

    LeaveCriticalSection(&g_csRefCount);
}

inline VOID
DecrementRefCount()
{
    EnterCriticalSection(&g_csRefCount);

    --g_dwRefCount;

    // If the count is 0 and we have an event to signal...
    if (!g_dwRefCount && g_hLastThreadExitEvent)
    {
        SetEvent(g_hLastThreadExitEvent);
    }

    LeaveCriticalSection(&g_csRefCount);
}

//+---------------------------------------------------------------------------
//
//  Function:   WaitForInstallQueueToExit
//
//  Purpose:    This function waits until the last thread Called to continue processing the queue after processing was
//              stopped due to a shutdown (of teh Netman service or system)
//
//  Arguments:
//      none
//
//  Returns:    nothing
//
//  Author:     billbe   8 Sep 1998
//
//  Notes:
//
VOID
WaitForInstallQueueToExit()
{
    // Wait on the event if it was successfully created.
    if (g_hLastThreadExitEvent)
    {
        TraceTag(ttidInstallQueue, "Waiting on LastThreadExitEvent");
        (VOID) WaitForSingleObject(g_hLastThreadExitEvent, INFINITE);
        TraceTag(ttidInstallQueue, "Event signaled");
    }
    else
    {
        // If the event was not created, fall back to simply looping
        // on the ref count
        while (g_dwRefCount);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ProcessQueue
//
//  Purpose:    Called to continue processing the queue after processing was
//              stopped due to a shutdown (of the Netman service or system)
//
//  Arguments:
//      none
//
//  Returns:    nothing
//
//  Author:     billbe   8 Sep 1998
//
//  Notes:
//
EXTERN_C VOID WINAPI
ProcessQueue()
{
    HRESULT                 hr;
    INetInstallQueue*       pniq;
    BOOL                    fInitCom = TRUE;

    TraceTag(ttidInstallQueue, "ProcessQueue called");
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
        fInitCom = FALSE;
    }

    if (SUCCEEDED(hr))
    {
        // Create the install queue object and get the install queue interface
        hr = CoCreateInstance(CLSID_InstallQueue, NULL,
                              CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                              IID_INetInstallQueue,
                              reinterpret_cast<LPVOID *>(&pniq));
        if (S_OK == hr)
        {
            // Process whatever was left in the queue
            //
            pniq->ProcessItems();
            pniq->Release();
        }

        if (fInitCom)
        {
            CoUninitialize();
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   RunOnceAddOrClearItem
//
//  Purpose:    Adds or clears an entry to/from the RunOnce registry key.
//
//  Arguments:
//      pszValueName [in] The value name of the run once item
//      pszItemToRun [in] The actual command to "Run Once"
//      eAction      [in] RO_ADD to add the item, RO_CLEAR to clear the item.
//
//  Returns:    nothing
//
//  Author:     billbe   8 Sep 1998
//
//  Notes:
//
VOID
RunOnceAddOrClearItem (
    IN PCWSTR pszValueName,
    IN PCWSTR pszItemToRun,
    IN RO_ACTION eAction)
{
    static const WCHAR c_szRegKeyRunOnce[] = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce";
    HRESULT hr;
    HKEY    hkey;

    // Open the RunOnce key
    hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE, c_szRegKeyRunOnce,
            KEY_WRITE, &hkey);

    if (S_OK == hr)
    {
        if (RO_ADD == eAction)
        {
            // Set the command line to run when the user logs in next.
            (VOID) HrRegSetSz (hkey, pszValueName, pszItemToRun);
            TraceTag(ttidInstallQueue, "Added %S RunOnce entry", pszValueName);
        }
        else if (RO_CLEAR == eAction)
        {
            // Remove the command line.
            (VOID) HrRegDeleteValue (hkey, pszValueName);
            TraceTag(ttidInstallQueue, "Cleared %S RunOnce entry", pszValueName);
        }

        RegCloseKey(hkey);
    }

}



//+---------------------------------------------------------------------------
//
//  Member:     CInstallQueue::CInstallQueue
//
//  Purpose:    CInstall queue constructor
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     BillBe   10 Sep 1998
//
//  Notes:
//
CInstallQueue::CInstallQueue() :
    m_dwNextAvailableIndex(0),
    m_hkey(NULL),
    m_nCurrentIndex(-1),
    m_cItems(0),
    m_aszItems(NULL),
    m_cItemsToDelete(0),
    m_aszItemsToDelete(NULL),
    m_fQueueIsOpen(FALSE)
{
    TraceTag(ttidInstallQueue, "Installer queue processor being created");

    InitializeCriticalSection (&m_csReadLock);
    InitializeCriticalSection (&m_csWriteLock);
    InitializeCriticalSection (&g_csRefCount);

    // Create an event that we will use to signal to interested parties
    // that we are done.  This is used by netman to wait for our threads
    // to exit before destroying this object
    g_hLastThreadExitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    // If the event could not be created, we can still go on, we just won't
    // use the event to signal our exit.
    if (!g_hLastThreadExitEvent)
    {
        TraceTag(ttidInstallQueue, "Error creating last thread exit "
                "event %d", GetLastError());
    }

    // Set the next available queue index so insertions won't overlap
    SetNextAvailableIndex();
}

//+---------------------------------------------------------------------------
//
//  Member:     CInstallQueue::FinalRelease
//
//  Purpose:    COM destructor
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     BillBe   10 Sep 1998
//
//  Notes:
//
VOID
CInstallQueue::FinalRelease ()
{
    DeleteCriticalSection (&m_csWriteLock);
    DeleteCriticalSection (&m_csReadLock);
    DeleteCriticalSection (&g_csRefCount);
}

// INetInstallQueue

//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::AddItem
//
//  Purpose:    Add item to the queue
//
//  Arguments:
//      pGuid                [in] The class guid of the device that was
//                                modified (installed. updated, or removed)
//      pszDeviceInstanceId  [in] The instance id of the device
//      pszInfId             [in] The inf id of the device
//      dwCharacter          [in] The device's characteristics
//      eType                [in] The install type (event) - indicates
//                                whether the device was installed, updated,
//                                or removed
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise.
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:  If the device was removed, the device instance id will be the
//          instance guid of the device.  If the device was installed
//          or updated then the id will be the PnP instance id
//
STDMETHODIMP
CInstallQueue::AddItem (
    const NIQ_INFO* pInfo)
{
    Assert(pInfo);
    Assert(pInfo->pszPnpId);
    Assert(pInfo->pszInfId);

    if (!pInfo)
    {
        return E_POINTER;
    }

    if (!pInfo->pszPnpId)
    {
        return E_POINTER;
    }

    if (!pInfo->pszInfId)
    {
        return E_POINTER;
    }

    // Increment our refcount since we will be queueing a thread
    IncrementRefCount();

    // Add the item to the queue
    HRESULT hr = HrAddItem (pInfo);

    if (S_OK == hr)
    {
        // Start processing the queue on another thread
        hr = HrQueueWorkItem();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CInstallQueue::AddItem");
    return hr;
}


// CInstallQueue
//

//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::HrQueueWorkItem
//
//  Purpose:    Start processing the queue on another thread
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise.
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
HRESULT
CInstallQueue::HrQueueWorkItem()
{
    HRESULT hr = S_OK;

    // Add ref our object since we will need it independent of whoever
    // called us
    AddRef();

    // Queue a work item thread
    if (!QueueUserWorkItem(InstallQueueWorkItem, this, WT_EXECUTEDEFAULT))
    {
        hr = HrFromLastWin32Error();
        Release();

        // The thread wasn't queued so reduce the ref count
        DecrementRefCount();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::SetNextAvailableIndex
//
//  Purpose:    Sets the member variable m_dwNextAvailableIndex to the next
//              available queue position (registry valuename)
//
//  Arguments:
//      none
//
//  Returns:    nothing
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
VOID
CInstallQueue::SetNextAvailableIndex()
{
    TraceTag(ttidInstallQueue, "Setting Next Available index");

    EnterCriticalSection(&m_csWriteLock);

    DWORD dwTempCount;

    HKEY hkey;
    // Open the NcQueue registry key
    HRESULT hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyNcQueue,
            KEY_QUERY_VALUE, &hkey);

    if (S_OK == hr)
    {
        WCHAR  szValueName[c_cchQueueValueNameLen];
        DWORD  cbValueName;
        PWSTR pszStopString;
        DWORD  dwIndex = 0;
        DWORD  dwType;

        do
        {
            cbValueName = c_cbQueueValueNameLen;

            // Enumerate each value name
            hr = HrRegEnumValue(hkey, dwIndex, szValueName, &cbValueName,
                    &dwType, NULL, NULL);

            if (S_OK == hr)
            {
                // Convert the value name to a number
                dwTempCount = wcstoul(szValueName, &pszStopString, c_nBase16);

                // If the number is greater than our current count
                // adjust the current count
                if (dwTempCount >= m_dwNextAvailableIndex)
                {
                    m_dwNextAvailableIndex = dwTempCount + 1;
                }
            }
            ++dwIndex;
        } while (S_OK == hr);

        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }

        RegCloseKey(hkey);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        hr = S_OK;
    }

    TraceTag(ttidInstallQueue, "Next Available index set %d", m_dwNextAvailableIndex);
    LeaveCriticalSection(&m_csWriteLock);
}


// Compare strings given pointers to PCWSTRs
inline int __cdecl
iCompare(const void* ppszArg1, const void* ppszArg2)
{

    return lstrcmpW(*((PCWSTR*)(void*)ppszArg1), *((PCWSTR*)(void*)ppszArg2));
}


//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::PncqiCreateItem
//
//  Purpose:    Creates a queue item
//
//  Arguments:
//      pguidClass           [in] The class guid of a device.
//      pszDeviceInstanceId  [in] The device id of the device.
//                                a pnp instance id if the device is being
//                                added or updated, a netcfg instance guid
//                                if it is being removed.
//      pszInfId             [in] The device's inf id.
//      dwCharacter          [in] The device's characteristics.
//      eType                [in] The notification for the item. Whether
//                                the device was installed, removed,
//                                or reinstalled.
//
//  Returns:    NCQUEUE_ITEM.  The newly created item.
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
NCQUEUE_ITEM*
CInstallQueue::PncqiCreateItem(
    const NIQ_INFO* pInfo)
{
    Assert(pInfo);
    Assert(pInfo->pszPnpId);
    Assert(pInfo->pszInfId);

    // The size of the item is the size of the structure plus the size of
    // the device id we are appending to the structure
    DWORD cbPnpId = CbOfSzAndTerm (pInfo->pszPnpId);
    DWORD cbInfId = CbOfSzAndTerm (pInfo->pszInfId);
    DWORD cbSize = sizeof(NCQUEUE_ITEM) + cbPnpId + cbInfId;

    NCQUEUE_ITEM* pncqi = (NCQUEUE_ITEM*)MemAlloc(cbSize);

    if (pncqi)
    {
        pncqi->cbSize = sizeof(NCQUEUE_ITEM);
        pncqi->eType = pInfo->eType;
        pncqi->dwCharacter = pInfo->dwCharacter;
        pncqi->dwDeipFlags = pInfo->dwDeipFlags;
        pncqi->cchPnpId = wcslen(pInfo->pszPnpId);
        pncqi->cchInfId = wcslen(pInfo->pszInfId);
        pncqi->ClassGuid = pInfo->ClassGuid;
        pncqi->InstanceGuid = pInfo->InstanceGuid;
        CopyMemory((BYTE*)pncqi + pncqi->cbSize, pInfo->pszPnpId, cbPnpId);
        CopyMemory((BYTE*)pncqi + pncqi->cbSize + cbPnpId,
                   pInfo->pszInfId, cbInfId);
    }

    return pncqi;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrAddItem
//
//  Purpose:    Worker function that adds an item to the queue
//
//  Arguments:
//      pguidClass [in] The class guid of a device
//      pszwDeviceInstanceId [in] The device id of the device
//                                a pnp instance id if the device is being
//                                added or updated, a netcfg instance guid
//                                if it is being removed
//      eType [in] The notification for the item. Whether the device
//                   was installed, removed, or reinstalled.
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise.
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
HRESULT
CInstallQueue::HrAddItem(
    const NIQ_INFO* pInfo)
{
    Assert(pInfo->pszPnpId);
    Assert(pInfo->pszInfId);

    EnterCriticalSection(&m_csWriteLock);

    // Create the structure to be stored in the registry
    NCQUEUE_ITEM* pncqi = PncqiCreateItem(pInfo);

    // Open the NcQueue registry key
    //
    HKEY hkey;
    HRESULT hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyNcQueue,
            0, KEY_READ_WRITE, NULL, &hkey, NULL);

    if (S_OK == hr && pncqi)
    {
        // Store the queue item under the next available valuename
        //
        WCHAR szValue[c_cchQueueValueNameLen];
        wsprintfW(szValue, L"%.8X", m_dwNextAvailableIndex);

        hr = HrRegSetValueEx(hkey, szValue, REG_BINARY, (BYTE*)pncqi,
                DwSizeOfItem(pncqi));

        if (S_OK == hr)
        {
            // Update the global count string
            ++m_dwNextAvailableIndex;
        }
        RegCloseKey(hkey);
    }

    MemFree(pncqi);

    LeaveCriticalSection(&m_csWriteLock);

    TraceError("CInstallQueue::HrAddItem", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::DeleteMarkedItems
//
//  Purpose:    Deletes, from the registry, any values that have been
//              marked for delete.
//
//  Arguments:
//      none
//
//  Returns:    nothing
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
VOID
CInstallQueue::DeleteMarkedItems()
{
    Assert(m_hkey);

    // If we have items to delete...
    if (m_cItemsToDelete)
    {
        Assert(m_aszItemsToDelete);

        // Remove each one from the registry
        //
        for (DWORD dw = 0; dw < m_cItemsToDelete; ++dw)
        {
            RegDeleteValue(m_hkey, m_aszItemsToDelete[dw]);
        }
    }

    // Free the array and reset the pointer and counter
    //
    MemFree(m_aszItemsToDelete);
    m_aszItemsToDelete = NULL;
    m_cItemsToDelete = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::HrRefresh
//
//  Purpose:    Refreshs our snapshot of the queue.
//
//  Arguments:
//      none
//
//  Returns:    HRESULT. S_OK if successful and the queue has items,
//                       S_FALSE if the queue is empty,
//                       an error code otherwise.
///
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
HRESULT
CInstallQueue::HrRefresh()
{
    Assert(m_hkey);

    // We don't want items being added to the queue while we are
    // refreshing our snapshot, so we use a critical section to keep
    // things
    //
    EnterCriticalSection(&m_csWriteLock);

    // Do some housecleaning before the refresh
    //
    DeleteMarkedItems();
    FreeAszItems();

    // Retrieve the number of items in the queue
    HRESULT hr = HrRegQueryInfoKey(m_hkey, NULL, NULL, NULL, NULL,
            NULL, &m_cItems, NULL, NULL, NULL, NULL);

    if (S_OK == hr)
    {
        Assert(0 <= (INT) m_cItems);

        // If the queue is not empty...
        if (0 < m_cItems)
        {
            DWORD cbValueLen;

            // Allocate the array of pointers to strings for the items.
            // Also, allocate the same quantity of pointers to hold
            // items we will delete from the queue
            DWORD cbArraySize = m_cItems * sizeof(PWSTR*);
            m_aszItems =
                    reinterpret_cast<PWSTR*>(MemAlloc(cbArraySize));

            if (m_aszItems)
            {
                m_aszItemsToDelete =
                        reinterpret_cast<PWSTR*>(MemAlloc(cbArraySize));

                if (m_aszItemsToDelete)
                {

                    // Store all the value names
                    // We will need to sort them so we can process each device in the
                    // correct order
                    //
                    DWORD dwType;
                    for (DWORD dw = 0; dw < m_cItems; ++dw)
                    {
                        m_aszItems[dw] =
                                reinterpret_cast<PWSTR>(MemAlloc(c_cbQueueValueNameLen));
                        if (m_aszItems[dw])
                        {
                            cbValueLen = c_cbQueueValueNameLen;
                            (void) HrRegEnumValue(m_hkey, dw,
                                    m_aszItems[dw], &cbValueLen,
                                    &dwType, NULL, NULL);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    // Sort the value names in ascending order.  The value names
                    // are string versions of numbers padded to the left with zeroes
                    // e.g. 00000001
                    qsort(m_aszItems, m_cItems, sizeof(PWSTR), iCompare);
                }
                else
                {
                    MemFree(m_aszItems);
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            // no items in the queue
            hr = S_FALSE;

            // The next items entered should start with valuename 00000000
            m_dwNextAvailableIndex = 0;
        }
    }
    else
    {
        // Refresh not possible so invalidate the key
        RegCloseKey(m_hkey);
        m_hkey = NULL;
    }

    // Reset Queue Index to just before the first element since
    // retrieval is always done on the next element
    m_nCurrentIndex = -1;

    // Items can now be added to the queue
    LeaveCriticalSection(&m_csWriteLock);

    TraceError("CInstallQueue::HrRefresh",
            (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::HrOpen
//
//  Purpose:    Opens the netcfg installer queue
//
//  Arguments:
//      None
//
//  Returns:    HRESULT. S_OK if successful and the queue has items,
//                       S_FALSE if the queue is empty,
//                       an error code otherwise.
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:  When the queue is opened, it is a snapshot of the current queue
//          state.  i.e. items could be added after the fact.  To refresh the
//          snapshot, use RefreshQueue.
//
HRESULT
CInstallQueue::HrOpen()
{
    HRESULT hr = S_OK;

    // We don't want any other thread to process the queue since we will
    // continue to retrieve new items that are added while we are
    // processing the initial set
    EnterCriticalSection(&m_csReadLock);

    AssertSz(!m_hkey, "Reopening NcQueue without closing first!");

    // We might have been waiting for a bit.  Make sure the system
    // is not shutting down before continuing
    //
    if (SERVICE_RUNNING == _Module.DwServiceStatus ())
    {
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyNcQueue,
                KEY_ALL_ACCESS, &m_hkey);

        if (S_OK == hr)
        {
            // Get a current snapshot of what's in the queue
            // by refreshing
            hr = HrRefresh();

            if (SUCCEEDED(hr))
            {
                // The queue is officially open
                m_fQueueIsOpen = TRUE;
            }
        }
    }
    else
    {
        TraceTag(ttidInstallQueue, "HrOpen::System is shutting down");
        hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    TraceError("CInstallQueue::HrOpen",
               ((S_FALSE == hr) ||
                (HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS)) == hr) ?
               S_OK : hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::Close
//
//  Purpose:    Closes the netcfg installer queue
//
//  Arguments:
//      None
//
//  Returns:    nothing
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
VOID
CInstallQueue::Close()
{
    if (m_fQueueIsOpen)
    {
        // Housecleaning
        //

        // Delete anything so marked
        DeleteMarkedItems();

        // Free up the list of value names (aka queue items)
        FreeAszItems();

        RegSafeCloseKey(m_hkey);
        m_hkey = NULL;

        // Queue is now closed
        m_fQueueIsOpen = FALSE;
    }

    // Other threads may have a chance at the queue now
    LeaveCriticalSection(&m_csReadLock);
}

//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::MarkCurrentItemForDeletion
//
//  Purpose:    Marks the current item for deletion from the registry
//              when the queue is refreshed or closed
//
//  Arguments:
//      None
//
//  Returns:    nothing
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
VOID
CInstallQueue::MarkCurrentItemForDeletion()
{
    AssertSz(FIsQueueIndexInRange(), "Queue index out of range");

    if (FIsQueueIndexInRange())
    {
        // The number of items to delete should never exceed the number
        // of queue items in our snapshot
        if (m_cItemsToDelete < m_cItems)
        {
            // Just store a pointer, in m_aszItemsToDelete, to the value name
            // pointed to by m_aszItems
            //
            m_aszItemsToDelete[m_cItemsToDelete] = m_aszItems[m_nCurrentIndex];
            ++m_cItemsToDelete;
        }
        else
        {
            TraceTag(ttidError, "Too many items marked for deletion");
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::HrGetNextItem
//
//  Purpose:    Get's the next item in the queue
//
//  Arguments:
//      None
//
//  Returns:    HRESULT. S_OK is successful,
//              ERROR_NO_MORE_ITEMS (hresult version), if there are no
//              more items in the queue.  An error code otherwise.
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
HRESULT
CInstallQueue::HrGetNextItem(NCQUEUE_ITEM** ppncqi)
{
    Assert(ppncqi);

    HRESULT hr;

    // Increment index to the next value
    ++m_nCurrentIndex;

    // If we haven't gone past the end of the queue...
    if (FIsQueueIndexInRange())
    {
        // assign convenience pointer
        PCWSTR pszItem = m_aszItems[m_nCurrentIndex];

        DWORD cbData;

        // Get the next queue item from the registry
        //
        hr = HrRegQueryValueEx(m_hkey, pszItem, NULL, NULL, &cbData);

        if (S_OK == hr)
        {
            *ppncqi = (NCQUEUE_ITEM*)MemAlloc(cbData);
            
            if( *ppncqi )
            {
                DWORD dwType;
                hr = HrRegQueryValueEx(m_hkey, pszItem, &dwType,
                    (BYTE*)(*ppncqi), &cbData);

                if (S_OK == hr)
                {
                    Assert(REG_BINARY == dwType);
                    Assert((*ppncqi)->cchPnpId == (DWORD)
                           (wcslen((PWSTR)((BYTE*)(*ppncqi) +
                           (*ppncqi)->cbSize))));
                    Assert((*ppncqi)->cchInfId == (DWORD)
                           (wcslen((PWSTR)((BYTE*)(*ppncqi) +
                           (*ppncqi)->cbSize +
                          ((*ppncqi)->cchPnpId + 1) * sizeof(WCHAR)))));

                    // change union variable from the count of characters
                    // to the actual string pointer
                    SetItemStringPtrs(*ppncqi);
                }
                else
                {
                    MemFree(*ppncqi);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
    }

    TraceError("CInstallQueue::HrGetNextItem",
            (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   EnumerateQueueItemsAndDoNotifications
//
//  Purpose:    Enumerates each item in the queue and notifies INetCfg
//              of the modification (event)
//
//  Arguments:
//      pINetCfg                 [in]  INetCfg interface
//      pinq                     [in]  The INetInstallQueue interface
//      hdi                      [in]  See Device Installer Api for more info
//      pfReboot                 [out] TRUE if INetCfg requested a reboot,
//                                     FALSE otherwise
//
//  Returns:    HRESULT. S_OK is successful, an error code otherwise
//
//  Author:     billbe   8 Sep 1998
//
//  Notes:
//
BOOL
EnumerateQueueItemsAndDoNotifications(
    INetCfg* pINetCfg,
    INetCfgInternalSetup* pInternalSetup,
    CInstallQueue* pniq,
    HDEVINFO hdi,
    BOOL* pfReboot)
{
    Assert(pINetCfg);
    Assert(pniq);
    Assert(IsValidHandle(hdi));
    Assert(pfReboot);

    NCQUEUE_ITEM*   pncqi;
    SP_DEVINFO_DATA deid;
    HRESULT         hr;
    BOOL            fStatusOk = TRUE;

    // Go through each item in the queue and add to INetCfg
    //
    while (S_OK == (hr = pniq->HrGetNextItem(&pncqi)))
    {
        // If we are not shutting down...
        if (SERVICE_RUNNING == _Module.DwServiceStatus ())
        {
            if (NCI_INSTALL == pncqi->eType)
            {
                NIQ_INFO Info;
                ZeroMemory(&Info, sizeof(Info));
                Info.ClassGuid = pncqi->ClassGuid;
                Info.InstanceGuid = pncqi->InstanceGuid;
                Info.dwCharacter = pncqi->dwCharacter;
                Info.dwDeipFlags = pncqi->dwDeipFlags;
                Info.pszPnpId = pncqi->pszPnpId;
                Info.pszInfId = pncqi->pszInfId;

                NC_TRY
                {
                    // Notify INetCfg
                    hr = HrDiAddComponentToINetCfg(
                            pINetCfg, pInternalSetup, &Info);
                }
                NC_CATCH_ALL
                {
                    hr = E_UNEXPECTED;
                }
            }
            else if (NCI_UPDATE == pncqi->eType)
            {
                pInternalSetup->EnumeratedComponentUpdated(pncqi->pszPnpId);
            }
            else if (NCI_REMOVE == pncqi->eType)
            {
                hr = pInternalSetup->EnumeratedComponentRemoved (
                        pncqi->pszPnpId);
            }

            if (SUCCEEDED(hr))
            {
                // Store the reboot result
                if (NETCFG_S_REBOOT == hr)
                {
                    *pfReboot = TRUE;
                }
                TraceTag(ttidInstallQueue, "Deleting item");
                pniq->MarkCurrentItemForDeletion();
            }
            else
            {
                if (NETCFG_E_NEED_REBOOT == hr)
                {
                    // Stop processing the queue since INetCfg will
                    // refuse updates.
                    hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
                    fStatusOk = FALSE;
                }
                else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    // INetCfg couldn't find the adapter.  Maybe someone
                    // removed it before we could notify INetCfg.
                    //
                    if (NCI_REMOVE != pncqi->eType)
                    {
                        HDEVINFO hdi;
                        SP_DEVINFO_DATA deid;

                        // Double check if the device is there.
                        // If it is, we need to remove it since INetCfg
                        // refuses to acknowledge its presence.
                        //
                        hr = HrSetupDiCreateDeviceInfoList (&pncqi->ClassGuid,
                                NULL, &hdi);

                        if (S_OK == hr)
                        {
                            hr = HrSetupDiOpenDeviceInfo (hdi,
                                    pncqi->pszPnpId, NULL, 0, &deid);

                            if (S_OK == hr)
                            {
                                (VOID) HrSetupDiRemoveDevice (hdi, &deid);
                            }

                            SetupDiDestroyDeviceInfoList (hdi);
                        }

                        // Stop trying to notify INetCfg.
                        //
                        pniq->MarkCurrentItemForDeletion();
                    }
                }
                else
                {
                    // Display message on error??
                    TraceHr (ttidError, FAL, hr, FALSE,
                            "EnumerateQueueItemsAndDoNotifications");
                }
            }
        }
        else
        {
            TraceTag(ttidInstallQueue, "System is shutting down during processing");
            hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
        }
        MemFree(pncqi);

        if (HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS) == hr)
        {
            break;
        }
    }

    // This error is expected when enumeration is complete
    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }

    TraceError("EnumerateQueueItemsAndDoNotifications", hr);
    return fStatusOk;
}

//+---------------------------------------------------------------------------
//
//  Function:   InstallerQueueWorkItem
//
//  Purpose:    The LPTHREAD_START_ROUTINE passed to QueueUserWorkItem to
//              handle the work of notifying INetCfg and the Connections
//              wizard of an installation event.
//
//  Arguments:
//      pvContext [in] A pointer to a CInstallQueue class.
//
//  Returns:    NOERROR
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:      The CInstallQueue was AddRef'd to insure its existence
//              while we use it.  This function must release it before
//              exiting.
//
DWORD WINAPI
InstallQueueWorkItem(PVOID pvContext)
{
    const WCHAR c_szInstallQueue[] = L"Install Queue";
    const WCHAR c_szProcessQueue[] = L"rundll32 netman.dll,ProcessQueue";
    const WCHAR c_szRegValueNcInstallQueue[] = L"NCInstallQueue";

    CInstallQueue* pniq = reinterpret_cast<CInstallQueue*>(pvContext);
    Assert(pniq);

    BOOL fReboot = FALSE;
    BOOL fInitCom = TRUE;

    // We need to continue processing when the system is rebooted.
    RunOnceAddOrClearItem (c_szRegValueNcInstallQueue,
            c_szProcessQueue, RO_ADD);

    HRESULT hr = CoInitializeEx (NULL,
                    COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);

    if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
        fInitCom = FALSE;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "InstallQueueWorkItem: "
            "CoInitializeEx failed");

    if (SUCCEEDED(hr))
    {
        // Open the queue, this will give us a snapshot of what is in the queue
        // at this time
        hr = pniq->HrOpen();

        if (S_OK == hr)
        {
            // Create an HDEVINFO
            HDEVINFO hdi;
            hr = HrSetupDiCreateDeviceInfoList(NULL, NULL, &hdi);

            if (S_OK == hr)
            {
                INetCfg* pINetCfg;
                INetCfgInternalSetup* pInternalSetup;
                DWORD cmsTimeout = 500;

                // As long as we are not shutting down. keep trying to get a
                // writable INetCfg.
                do
                {
                    // Increase the time we wait each iteration.
                    cmsTimeout = cmsTimeout >= 512000 ? 512000 : cmsTimeout * 2;

                    // If we are not in the process of shutting down...
                    if (SERVICE_RUNNING == _Module.DwServiceStatus())
                    {
                        // Try to get a writable INetCfg
                        hr = HrCreateAndInitializeINetCfg(NULL, &pINetCfg,
                                TRUE, cmsTimeout, c_szInstallQueue, NULL);
                        if (NETCFG_E_NEED_REBOOT == hr)
                        {
                            hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
                            break;
                        }
                    }
                    else
                    {
                        // Times up! Pencils down!  Netman is shutting down
                        // we need to stop processing
                        hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
                        break;
                    }

                } while (FAILED(hr));

                if (S_OK == hr)
                {
                    hr = pINetCfg->QueryInterface (IID_INetCfgInternalSetup,
                            (void**)&pInternalSetup);
                    if (S_OK == hr)
                    {
                        // Go through the queue notifying interested modules
                        do
                        {
                            if (!EnumerateQueueItemsAndDoNotifications(pINetCfg,
                                    pInternalSetup, pniq, hdi, &fReboot))
                            {
                                hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
                                continue;
                            }

                            if (SERVICE_RUNNING == _Module.DwServiceStatus ())
                            {
                                TraceTag(ttidInstallQueue, "Refreshing queue");
                                // Check to see if any items were added to the queue
                                // after we started processing it
                                hr = pniq->HrRefresh();

                                if (S_FALSE == hr)
                                {
                                    // We are finished so we can remove
                                    // the entry in runonce that would
                                    // start the queue processing on login.
                                    RunOnceAddOrClearItem (
                                            c_szRegValueNcInstallQueue,
                                            c_szProcessQueue, RO_CLEAR);
                                }
                            }
                            else
                            {
                                hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
                            }
                        } while (S_OK == hr);

                        ReleaseObj (pInternalSetup);
                    }

                    (VOID) HrUninitializeAndReleaseINetCfg(FALSE, pINetCfg,
                            TRUE);

                }
                SetupDiDestroyDeviceInfoList(hdi);
            }
        }

        // Close the queue
        pniq->Close();

        DecrementRefCount();

        if (fInitCom)
        {
            CoUninitialize();
        }
    }

    if (FAILED(hr))
    {
        // Display error.
    }

    // If a reboot is required and we are not in setup or already shutting
    // down prompt the user.
    //
    if (fReboot && (SERVICE_RUNNING == _Module.DwServiceStatus()) &&
            !FInSystemSetup())
    {
        // Handle reboot prompt
        DWORD dwFlags = QUFR_REBOOT | QUFR_PROMPT;

        (VOID) HrNcQueryUserForReboot(_Module.GetResourceInstance(),
                                      NULL, IDS_INSTALLQUEUE_CAPTION,
                                      IDS_INSTALLQUEUE_REBOOT_REQUIRED,
                                      dwFlags);
    }

    TraceTag(ttidInstallQueue, "User Work Item Completed");

    TraceError("InstallQueueWorkItem", (S_FALSE == hr) ? S_OK : hr);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L L M A I N . C P P
//
//  Contents:   Networking Optional component DLL
//
//  Notes:
//
//  Author:     danielwe   18 Dec 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include <ncreg.h>

// Optional component setup
#include "netoc.h"
#include "netocp.h"


BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

// Global
CComModule _Module;


EXTERN_C
BOOL
WINAPI
DllMain (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /*lpReserved*/)
{
    if (DLL_PROCESS_ATTACH == dwReason)
    {
        InitializeDebugging();

        _Module.Init (ObjectMap, hInstance);
        DisableThreadLibraryCalls (hInstance);
    }
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        _Module.Term ();
        UnInitializeDebugging();
    }
    return TRUE;    // ok
}

//+---------------------------------------------------------------------------
//
//  Function:   NetOcSetupProc
//
//  Purpose:
//
//  Arguments:
//      pvComponentId    []
//      pvSubcomponentId []
//      uFunction        []
//      uParam1          []
//      pvParam2         []
//
//  Returns:
//
//  Author:     danielwe   12 Dec 1997
//
//  Notes:
//
EXTERN_C
DWORD
WINAPI
NetOcSetupProc (
    LPCVOID pvComponentId,
    LPCVOID pvSubcomponentId,
    UINT uFunction,
    UINT uParam1,
    LPVOID pvParam2)
{
    return NetOcSetupProcHelper(pvComponentId, pvSubcomponentId, uFunction,
                                uParam1, pvParam2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\implinc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       I M P L I N C . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     shaunco   25 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncxbase.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

// Include ATL's implementation.  Substitute _ASSERTE with our Assert.
//
#ifdef _ASSERTE
#undef _ASSERTE
#define _ASSERTE Assert
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\ncacs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       N C A C S . H
//
//  Contents:   Installation support for Admission Control Service
//
//  Notes:
//
//  Author:     RameshPa     02/12/98
//
//----------------------------------------------------------------------------

#ifndef _NCACS_H_
#define _NCACS_H_

#pragma once
#include "netoc.h"
#include "lmaccess.h"
#include "lmjoin.h"
#include "lmerr.h"
#include "lmapibuf.h"

HRESULT HrOcAcsOnInstall(PNETOCDATA pnocd);
HRESULT HrOcExtACS(PNETOCDATA pnocd, UINT uMsg,
                   WPARAM wParam, LPARAM lParam);
HRESULT HrOcAcsOnQueryChangeSelState(PNETOCDATA pnocd, BOOL fShowUi);

#endif // _NCACS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\ncacs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       N C A C S . C P P
//
//  Contents:   Installation support for ACS service
//
//  Notes:
//
//  Author:     RameshPa    02/12/98
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncxbase.h"
#include "ncerror.h"
#include "ncreg.h"
#include "ncacs.h"
#include "ncsvc.h"
#include "netoc.h"
#include "ncnetcfg.h"
#include "resource.h"
#include <iphlpapi.h>
#include <winsock2.h>
#include <ntsecapi.h>

extern const WCHAR c_szSvcRsvp[];

static const WCHAR      c_szTcpIp[]             = L"TcpIp";
static const WCHAR      c_szAfd[]               = L"Afd";
static const WCHAR      c_szAcsService[]        = L"AcsService";
static const WCHAR      c_szRegKeyRsvpParams[]  = L"System\\CurrentControlSet\\Services\\RSVP\\Parameters\\";
static const WCHAR      c_szRegKeyRsvpSubnet1[] = L"System\\CurrentControlSet\\Services\\RSVP\\Parameters\\Subnet\\Subnet1\\";
static const WCHAR      c_szRegKeyRsvpSubnet[] = L"System\\CurrentControlSet\\Services\\RSVP\\Parameters\\Subnet\\";
static const WCHAR      c_szRegKeyRsvpAdapters[]= L"System\\CurrentControlSet\\Services\\RSVP\\Parameters\\Adapters\\";
static const WCHAR      c_szRegKeyRsvpPcmConfig[]= L"System\\CurrentControlSet\\Services\\RSVP\\PCM Config\\";
static const WCHAR      c_szRegKeyRsvpMsidlpm[]  = L"System\\CurrentControlSet\\Services\\RSVP\\MSIDLPM\\";


//$ REVIEW : RameshPa : 02/13/98 : Is this defined anywhere?
const DWORD             dwKilo                  = 1024;
const DWORD             dwMega                  = (1024 * dwKilo);
const DWORD             dwGiga                  = (1024 * dwMega);

static const WCHAR      c_szIpHlpApiDllName[]   = L"IpHlpApi";
static const CHAR       c_szaGetIpAddrTable[]   = "GetIpAddrTable";

typedef DWORD (*GETIPADDRTABLE)(
    OUT    PMIB_IPADDRTABLE pIpAddrTable,
    IN OUT PDWORD           pdwSize,
    IN     BOOL             bOrder);

struct ACS_SUBNET_REG_DATA
{
    DWORD       dwSubnetIpAddress;  // This is in host order
    DWORD       dwDSBMPriority;
    DWORD       dwMaxRSVPBandwidth;
    DWORD       dwMaxTotalPeakRate;
    DWORD       dwMaxTokenBucketRatePerFlow;
    DWORD       dwMaxPeakRatePerFlow;
    DWORD       dwIAmDsbmRefreshInterval;
    DWORD       dwDSBMDeadInterval;
    BOOL        fRunAsDSBM;
};

// Subnet registry keys
//
static const WCHAR      c_szRunAsDSBM[]         = L"Run as DSBM";
static const WCHAR      c_szSubnetIPAddress[]   = L"Subnet IP Address";
static const WCHAR      c_szMaxPeakRate[]       = L"Maximum peak rate per flow";
static const WCHAR      c_szMaxRSVPBandwidth[]  = L"Maximum RSVP bandwidth";
static const WCHAR      c_szMaxTokenBucket[]    = L"Maximum token bucket rate per flow";
static const WCHAR      c_szMaxTotalPeakRate[]  = L"Maximum total peak rate";
static const WCHAR      c_szIAmDsbmRefresh[]    = L"I_AM_DSBM Refresh Interval";
static const WCHAR      c_szDSBMDeadInterval[]  = L"DSBM Dead Interval";
static const WCHAR      c_szDSBMPriority[]      = L"DSBM Priority";

// Default general property sheet values
//
const BOOL          c_fRunAsDSBMDef             = TRUE;

// Default subnet values
//
const DWORD             c_dwIpAddressDef        = 0;
static const WCHAR      c_szIpAddressDef[]      = L"0.0.0.0";
const DWORD             c_dwMaxPeakRateDef      = 0xFFFFFFFF;
const DWORD             c_dwMaxRSVPBandwidthDef = 0;
const DWORD             c_dwMaxTokenBucketDef   = 0xFFFFFFFF;
const DWORD             c_dwMaxTotalPeakRateDef = 0xFFFFFFFF;
const DWORD             c_dwIAmDsbmRefreshDef   = 5;
const DWORD             c_dwDSBMDeadIntervalDef = 15;
const DWORD             c_dwDSBMPriorityDef     = 4;

// General values

// 127.0.0.0, host order
//
const DWORD             c_dwLocalSubnet         = 0x7f000000;
const DWORD             c_dwNullSubnet          = 0x00000000;

static const VALUETABLE c_avtAcsSubnet[] =
{
    {c_szSubnetIPAddress,   REG_IP,     offsetof(ACS_SUBNET_REG_DATA, dwSubnetIpAddress),
            (BYTE*)(&c_szIpAddressDef)},
    {c_szMaxPeakRate,       REG_DWORD,  offsetof(ACS_SUBNET_REG_DATA, dwMaxPeakRatePerFlow),
            (BYTE*)(&c_dwMaxPeakRateDef)},
    {c_szMaxRSVPBandwidth,  REG_DWORD,  offsetof(ACS_SUBNET_REG_DATA, dwMaxRSVPBandwidth),
            (BYTE*)(&c_dwMaxRSVPBandwidthDef)},
    {c_szMaxTokenBucket,    REG_DWORD,  offsetof(ACS_SUBNET_REG_DATA, dwMaxTokenBucketRatePerFlow),
            (BYTE*)(&c_dwMaxTokenBucketDef)},
    {c_szMaxTotalPeakRate,  REG_DWORD,  offsetof(ACS_SUBNET_REG_DATA, dwMaxTotalPeakRate),
            (BYTE*)(&c_dwMaxTotalPeakRateDef)},
    {c_szIAmDsbmRefresh,    REG_DWORD,  offsetof(ACS_SUBNET_REG_DATA, dwIAmDsbmRefreshInterval),
            (BYTE*)(&c_dwIAmDsbmRefreshDef)},
    {c_szDSBMDeadInterval,  REG_DWORD,  offsetof(ACS_SUBNET_REG_DATA, dwDSBMDeadInterval),
            (BYTE*)(&c_dwDSBMDeadIntervalDef)},
    {c_szDSBMPriority,      REG_DWORD,  offsetof(ACS_SUBNET_REG_DATA, dwDSBMPriority),
            (BYTE*)(&c_dwDSBMPriorityDef)},
    {c_szRunAsDSBM,         REG_BOOL,   offsetof(ACS_SUBNET_REG_DATA, fRunAsDSBM),
            (BYTE*) &c_fRunAsDSBMDef},
};


//+---------------------------------------------------------------------------
//
//  Function:   OpenPolicy
//
//  Purpose:    This routine opens the policy object on the local computer
//
//  Arguments:  PolicyHandle - Pointer to the opended handle
//
//  Returns:    ERROR_SUCCESS if successful, Win32 error otherwise.
//
//  Notes:      The retruned PolicyHandle must be closed by the caller
//
DWORD
OpenPolicy( PLSA_HANDLE PolicyHandle )
{
    NTSTATUS            Status;
    DWORD               Error;

    LSA_OBJECT_ATTRIBUTES       ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;

    QualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    QualityOfService.ImpersonationLevel = SecurityImpersonation;
    QualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QualityOfService.EffectiveOnly = FALSE;

    //
    // The two fields that must be set are length and the quality of service.
    //

    ObjectAttributes.Length = sizeof(LSA_OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = 0;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = &QualityOfService;

    //
    // Attempt to open the policy for all access on the local machine
    //

    Status = LsaOpenPolicy(
                NULL,
                &ObjectAttributes,
                POLICY_ALL_ACCESS,
                PolicyHandle );

    Error = LsaNtStatusToWinError(Status);

    return(Error);
}


//+---------------------------------------------------------------------------
//
//  Function:   InitLsaString
//
//  Purpose:    This routine intializes LSA_UNICODE_STRING given an UNICODE string0
//
//  Arguments:  LsaString
//              String
//
//  Returns:
//
//  Notes:
//
void
InitLsaString(
        PLSA_UNICODE_STRING LsaString,
        PWSTR              String  )
{
    DWORD StringLength;
    if (String == NULL)
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength = (USHORT) (StringLength + 1) * sizeof(WCHAR);
}

//+---------------------------------------------------------------------------
//
//  Function:   InitLsaString
//
//  Purpose:    This routine intializes LSA_UNICODE_STRING given an UNICODE string0
//
//  Arguments:  LsaString
//              String
//
//  Returns:
//
//  Notes:
//
PSID
GetAccountSid(
    LSA_HANDLE  PolicyHandle,
    PWSTR      AccountName
    )
{
    DWORD       NewSidLength;
    DWORD       SubAuthorityCount;
    PSID        Sid;
    PSID        DomainSid;
    NTSTATUS    Status;

    PLSA_TRANSLATED_SID TranslatedSid;
    PLSA_REFERENCED_DOMAIN_LIST Domains;
    LSA_UNICODE_STRING AccountString;

    //
    // Convert the string to a LSA_UNICODE_STRING
    //

    InitLsaString(
        &AccountString,
        AccountName
        );

    //
    // Call the LSA to lookup the name
    //

    Status = LsaLookupNames(
                PolicyHandle,
                1,
                &AccountString,
                &Domains,
                &TranslatedSid
                );

    if (!SUCCEEDED(Status))
        return(NULL);

    //
    // Build a SID from the Domain SID and account RID
    //

    DomainSid = Domains->Domains[TranslatedSid->DomainIndex].Sid;
    //
    // Compute the length of the new SID.  This is the length required for the
    // number of subauthorities in the domain sid plus one for the user RID.
    //

    SubAuthorityCount = *GetSidSubAuthorityCount(DomainSid);
    NewSidLength = GetSidLengthRequired( (UCHAR) (SubAuthorityCount + 1) );

    Sid = LocalAlloc(0,NewSidLength);

    if (Sid == NULL)
    {
        LsaFreeMemory(Domains);
        LsaFreeMemory(TranslatedSid);
        return(NULL);
    }

    //
    // Build the SID by copying the domain SID and, increasing the sub-
    // authority count in the new sid by one, and setting the last
    // subauthority to be the relative id of the user.
    //

    CopySid(
        NewSidLength,
        Sid,
        DomainSid
        );


    *GetSidSubAuthorityCount(Sid) = (UCHAR) SubAuthorityCount + 1;
    *GetSidSubAuthority(Sid, SubAuthorityCount) = TranslatedSid->RelativeId;
    LsaFreeMemory(Domains);
    LsaFreeMemory(TranslatedSid);

    return(Sid);

}

//+---------------------------------------------------------------------------
//
//  Function:   AddUserRightToAccount
//
//  Purpose:    This routine grants the SE_TCB_NAME right to the specified user
//              account on the local machine
//
//  Arguments:  PolicyHandle
//              AccountName
//
//  Returns:    ERROR_SUCCESS   if the right was granted successfully
//              Win32 error otherwise
//
//  Notes:
//
DWORD
AddUserRightToAccount(
    PWSTR      AccountName )
{
    DWORD       Error;
    NTSTATUS    Status;
    PSID        AccountSid = NULL;
    LSA_HANDLE  PolicyHandle;
    LSA_UNICODE_STRING UserRightString;

    // Get a LSA policy handle to manipulate user rights
    Error = OpenPolicy ( &PolicyHandle );
    if ( Error )
        return Error;

    // Get the SID for the account
    AccountSid = GetAccountSid(
                        PolicyHandle,
                        AccountName );
    if (AccountSid == NULL)
    {
        LsaClose ( &PolicyHandle );

        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Create a LSA_UNICODE_STRING for the right name
    //
    InitLsaString(
                &UserRightString,
                SE_TCB_NAME );

    // Grant the right
    Status = LsaAddAccountRights(
                PolicyHandle,
                AccountSid,
                &UserRightString,
                1 );

    Error = LsaNtStatusToWinError(Status);

    LocalFree( AccountSid );

    LsaClose ( &PolicyHandle );

    return(Error);
}

//+---------------------------------------------------------------------------
//
//  Function:   AddUserRightToAccount
//
//  Purpose:    This routine removes the SE_TCB_NAME right to the specified user
//              account on the local machine
//
//  Arguments:  PolicyHandle
//              AccountName
//
//  Returns:    ERROR_SUCCESS   if the right was rmoved successfully
//              Win32 error otherwise
//
//  Notes:
//
DWORD
RemoveUserRightFromAccount(
        PWSTR AccountName )
{
    NTSTATUS    Status;
    DWORD       Error;
    PSID        AccountSid;
    LSA_HANDLE  PolicyHandle;

    LSA_UNICODE_STRING UserRightString;

    // Get a LSA policy handle to manipulate user rights
    Error = OpenPolicy ( &PolicyHandle );
    if ( Error )
        return Error;

    AccountSid = GetAccountSid(
            PolicyHandle,
            AccountName );
    if (AccountSid == NULL)
    {
        LsaClose ( &PolicyHandle );
        
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Create a LSA_UNICODE_STRING for the right name
    //

    InitLsaString(
                &UserRightString,
                SE_TCB_NAME );

    Status = LsaRemoveAccountRights(
                PolicyHandle,
                AccountSid,
                FALSE,      // don't remove all rights
                &UserRightString,
                1 );

    Error = LsaNtStatusToWinError(Status);

    LocalFree(AccountSid);

    LsaClose ( &PolicyHandle );

    return(Error);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetAcsServiceAccountName
//
//  Purpose:    This routine returns the AcsService account name in the
//              DomainName\UserName format. DomainName is obtained from
//              the current logon domain.
//
//  Arguments:  lpwNtAccountName - Buffer to return the account name.
//
//  Returns:    S_OK    If the account name was generated
//              Win32 error otherwise
//
//  Notes:
//
HRESULT HrGetAcsServiceAccountName (
            PWSTR      lpwNtAccountName )
{
    DWORD       dwErr;
    HRESULT     hr;
    PWSTR      lpwDomain       = NULL;
    PWSTR      lpwDcName       = NULL;
    LPBYTE      lpbUserInfo     = NULL;

    NETSETUP_JOIN_STATUS    js;

    lpwNtAccountName[0] = 0;

    // Get the name of the DC for the logged on domain
    dwErr = NetGetDCName (
                    NULL,
                    NULL,
                    (LPBYTE *) &lpwDcName );
    if ( dwErr ) {

        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    // Next get user info to verify that there is a user
    // account for AcsService
    dwErr = NetUserGetInfo (
                    lpwDcName,
                    c_szAcsService,
                    2,
                    &lpbUserInfo );
    if ( dwErr ) {

        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    // Find out the name of the domain into which this compter
    // is currently logged on to
    dwErr = NetGetJoinInformation (
                        NULL,
                        &lpwDomain,
                        &js );
    if ( dwErr ) {

        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    if ( js != NetSetupDomainName ) {

        hr = NETCFG_E_NOT_JOINED;
        goto Exit;
    }

    // Generate the account name by concatenating domain name and "AcsService"
    wcscpy ( lpwNtAccountName, lpwDomain );
    wcscat ( lpwNtAccountName, L"\\" );
    wcscat ( lpwNtAccountName, c_szAcsService );

    hr = S_OK;

Exit:

    if ( lpwDcName )
        NetApiBufferFree ( lpwDcName );

    if ( lpbUserInfo )
        NetApiBufferFree ( lpbUserInfo );

    if ( lpwDomain )
        NetApiBufferFree ( lpwDomain );

    TraceError("HrGetAcsServiceAccountName", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrSetAcsServiceRights
//
//  Purpose:    This routine adds the AcsService account to the administrators group
//              on the local computer and grants SE_TCB_NAME right also
//
//  Arguments:
//
//  Returns:    S_OK    Success
//              Win32 error otherwise
//
//  Notes:
//
HRESULT HrSetAcsServiceRights( )
{
    DWORD       dwErr;
    HRESULT     hr;
    WCHAR       szAcsUserName[UNLEN+GNLEN+2];
    PWSTR       lpwAcsUserName;

    LOCALGROUP_MEMBERS_INFO_3   localgroup_members;

    // First get the user name of AcsService in the format
    // DomainName\UserName
    hr = ::HrGetAcsServiceAccountName ( szAcsUserName );
    if ( hr ) {

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_ACCOUNT_NAME);
        goto Exit;
    }

    if ( !szAcsUserName[0] ) {

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_ACCOUNT_NAME);
        goto Exit;
    }

    // Add AcsService account to be a local administrator
    localgroup_members.lgrmi3_domainandname = szAcsUserName;
    dwErr = NetLocalGroupAddMembers(
                NULL,                           // PDC name
                L"Administrators",              // group name
                3,                              // passing in name
                (LPBYTE)&localgroup_members,    // Buffer
                1 );                            // count passed in

    if ( dwErr ) {

        if ( dwErr == ERROR_MEMBER_IN_ALIAS ) {
            hr = S_OK;
            dwErr = 0;
        }
        else {
            hr = HRESULT_FROM_WIN32(dwErr);
            goto Exit;
        }
    }

    // Grant SE_TCB_NAME "Act as part of Operating system" right to AcsService
    dwErr = AddUserRightToAccount(
                    szAcsUserName );
    if ( dwErr ) {

        hr = HRESULT_FROM_WIN32( dwErr );
        goto Exit;
    }

    hr = S_OK;

Exit:
    TraceError ( "HrSetAcsServiceRights", hr );

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveAcsServiceRights
//
//  Purpose:    This routine removes the AcsService account from the administrators group
//              on the local computer and removes SE_TCB_NAME right.
//
//  Arguments:
//
//  Returns:    S_OK    Success
//              Win32 error otherwise
//
//  Notes:
//
HRESULT HrRemoveAcsServiceRights( )
{
    DWORD       dwErr;
    HRESULT     hr;
    WCHAR       szAcsUserName[UNLEN+GNLEN+2];

    LOCALGROUP_MEMBERS_INFO_3   localgroup_members;

    // First get the user name of AcsService in the format
    // DomainName\UserName
    hr = ::HrGetAcsServiceAccountName ( szAcsUserName );
    if ( hr ) {

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_ACCOUNT_NAME);
        goto Exit;
    }

    if ( !szAcsUserName[0] ) {

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_ACCOUNT_NAME);
        goto Exit;
    }

    // Remove AcsService account to be a local administrator
    localgroup_members.lgrmi3_domainandname = szAcsUserName;
    dwErr = NetLocalGroupDelMembers(
                NULL,                           // PDC name
                L"Administrators",              // group name
                3,                              // passing in name
                (LPBYTE)&localgroup_members,    // Buffer
                1 );                            // count passed in

    if ( dwErr ) {

        if ( dwErr == ERROR_MEMBER_NOT_IN_ALIAS ) {
            hr = S_OK;
            dwErr = 0;
        }
        else {
            hr = HRESULT_FROM_WIN32(dwErr);
            goto Exit;
        }
    }

    // Grant "Act as part of Operating system" right to AcsService
    dwErr = RemoveUserRightFromAccount(
                    szAcsUserName );
    if ( dwErr ) {

        hr = HRESULT_FROM_WIN32( dwErr );
        goto Exit;
    }

    hr = S_OK;

Exit:
    TraceError ( "HrRemoveAcsServiceRights", hr );
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetIpAddrTable
//
//  Purpose:    Gets the address table of the subnets that machine can see
//
//  Arguments:  ppmiat -    Where to return the allocated address table
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Notes:      The result must be freed by the caller
//
HRESULT HrGetIpAddrTable(MIB_IPADDRTABLE** ppmiat)
{
    HRESULT         hr                  = S_OK;
    DWORD           dwErr               = NO_ERROR;
    HMODULE         hIpHelpApi          = NULL;
    GETIPADDRTABLE  pfnGetIpAddrTable   = NULL;

    AssertSz(ppmiat , "HrGetIpAddrTable doesn't have a ppmiat");

    // Make sure we have our function loaded
    //
    hr = ::HrLoadLibAndGetProc(
            c_szIpHlpApiDllName,
            c_szaGetIpAddrTable,
            &hIpHelpApi,
            (FARPROC*)&pfnGetIpAddrTable);
    if (SUCCEEDED(hr))
    {
        DWORD           dwAddrCount     = 0;

        AssertSz(pfnGetIpAddrTable, "We should have a pfnGetIpAddrTable");

        // Find out how big a buffer we need.
        //
        dwErr = pfnGetIpAddrTable(*ppmiat, &dwAddrCount, FALSE);
        hr = HRESULT_FROM_WIN32(dwErr);

        // Allocate the buffer of the correct size
        //
        if ((NO_ERROR == dwErr)
            || (ERROR_INSUFFICIENT_BUFFER == dwErr))
        {
            UINT    cbTable =   0;

            // Create the buffer
            //
            cbTable = (sizeof(MIB_IPADDRTABLE)
                    + (sizeof(MIB_IPADDRROW) * (dwAddrCount)));

            *ppmiat = reinterpret_cast<MIB_IPADDRTABLE*>(new BYTE [cbTable]);

            // Try a second time with the correct buffer
            //
            dwErr = pfnGetIpAddrTable(*ppmiat, &dwAddrCount, FALSE);
            hr = HRESULT_FROM_WIN32(dwErr);
        }

        // Unload the DLL
        //
        (VOID)::FreeLibrary(hIpHelpApi);

    }

    TraceErrorOptional("HrGetIpAddrTable", hr,
        (HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) == hr));
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrFindFirstSubnet
//
//  Purpose:    Finds the first available subnet on the system to be used as
//              the default entry in the registry.  If a subnet cannot be found
//              000.000.000.000 is used.
//
//  Arguments:  pdwSubnet - Where to return the subnet
//
//  Returns:    Error code
//
//  Notes:
//
HRESULT HrFindFirstSubnet(DWORD* pdwSubnet)
{
    HRESULT                 hr              = S_OK;
    MIB_IPADDRTABLE*        ppmiat          = NULL;

    // Get our list of address entries
    //
    hr = HrGetIpAddrTable(&ppmiat);
    if (SUCCEEDED(hr))
    {
        MIB_IPADDRROW*          pmiarTemp       = ppmiat->table;
        DWORD                   dwIpAddrCount   = ppmiat->dwNumEntries;
        DWORD                   dwSubnet        = 0x0;

        while (dwIpAddrCount--)
        {
            // Find out what the sub net is
            //
            dwSubnet = (pmiarTemp->dwAddr & pmiarTemp->dwMask);

            // The APIs return the value in network order, and we want to
            // store the data in host order, so we have to convert the
            // address
            //
            dwSubnet = ntohl(dwSubnet);

            // Don't add invalid subnets to the list
            //
            if ((c_dwLocalSubnet != dwSubnet)
                && (c_dwNullSubnet != dwSubnet))
            {
                // We found one!!
                //
                *pdwSubnet = dwSubnet;

                break;
            }

            // Look at the next entry
            //
            pmiarTemp++;
        }

        // Free the allocated memory
        //
        delete ppmiat;
    }

    TraceError("HrFindFirstSubnet", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrWriteAcsSubnetDataToReg
//
//  Purpose:    Writes out the subnet information to the registry
//
//  Arguments:  pasrdSubnet -   The data that has to be written
//
//  Returns:    Error code
//
//  Notes:
//
HRESULT HrWriteAcsSubnetDataToReg(ACS_SUBNET_REG_DATA* pasrdSubnet)
{
    HRESULT     hr              = S_OK;
    HKEY        hkeySubnet      = NULL;
    DWORD       dwDisposition   = 0x0;

    hr = ::HrRegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            c_szRegKeyRsvpSubnet,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hkeySubnet,
            &dwDisposition);
    if (SUCCEEDED(hr))
    {
        // Write out the parameters
        //
        hr = ::HrRegWriteValueTable(
                hkeySubnet,
                celems(c_avtAcsSubnet),
                c_avtAcsSubnet,
                reinterpret_cast<BYTE*>(pasrdSubnet),
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS);

        ::RegSafeCloseKey(hkeySubnet);
    }

    TraceError("HrWriteAcsSubnetDataToReg", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrWriteAcsRegistryData
//
//  Purpose:    Writes to the registry all of ACS's default parameters
//
//  Arguments:  pnocd -         The option component information that is
//                      needed to get an INetCfg instance
//              pasrdSubnet -   The subnet information
//              palrdLog -      The logging information
//
//  Returns:    Error code
//
//  Notes:
//
HRESULT HrWriteAcsRegistryData(
        PNETOCDATA pnocd )
{
    HRESULT     hr  = S_OK;
    ACS_SUBNET_REG_DATA     asrdSubnet  = { 0 };

    // See if we can find a subnet
    //
    hr = ::HrFindFirstSubnet(&(asrdSubnet.dwSubnetIpAddress));
    if (SUCCEEDED(hr))
    {
        // Default subnet values
        //
        asrdSubnet.dwDSBMPriority               = c_dwDSBMPriorityDef;
        asrdSubnet.dwMaxPeakRatePerFlow         = c_dwMaxPeakRateDef;
        asrdSubnet.dwMaxRSVPBandwidth           = c_dwMaxRSVPBandwidthDef;
        asrdSubnet.dwMaxTokenBucketRatePerFlow  = c_dwMaxTokenBucketDef;
        asrdSubnet.dwMaxTotalPeakRate           = c_dwMaxTotalPeakRateDef;
        asrdSubnet.dwIAmDsbmRefreshInterval     = c_dwIAmDsbmRefreshDef;
        asrdSubnet.dwDSBMDeadInterval           = c_dwDSBMDeadIntervalDef;
        asrdSubnet.fRunAsDSBM                   = c_fRunAsDSBMDef;

        hr = ::HrWriteAcsSubnetDataToReg(&asrdSubnet);
        if (SUCCEEDED(hr))
        {
            ::HrWriteAcsRegistryData(pnocd);
        }
    }

    TraceError("HrWriteAcsRegistryData", hr);

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrChangeRsvpService
//
//  Purpose:    Change some RSVP service parameters
//
//  Arguments:  szDisplayName - The new display name
//              dwStartType -   The new start type
//              fStartService - If the service should be started
//
//  Returns:    Error code
//
//  Notes:
//
HRESULT HrChangeRsvpService(
        const WCHAR* szDisplayName,
        DWORD dwStartType,
        BOOL fStartService)
{
    HRESULT             hr          = S_OK;
    CServiceManager     scm;
    CService            svc;

    // Open the RSVP service with a lock on the service controller.
    //
    hr = scm.HrOpenService(&svc, c_szSvcRsvp, NO_LOCK);
    if (SUCCEEDED(hr))
    {
        hr = scm.HrAddServiceDependency ( c_szSvcRsvp, c_szTcpIp );
        if (SUCCEEDED(hr))
        {
            hr = scm.HrAddServiceDependency ( c_szSvcRsvp, c_szAfd );
            if (SUCCEEDED(hr))
            {
                // Set the new start type
                //
                hr = svc.HrSetStartType(dwStartType);
                if (SUCCEEDED(hr))
                {
                    // Change the display name
                    //
                    hr = svc.HrSetDisplayName(szDisplayName);
                    if (SUCCEEDED(hr) && fStartService)
                    {
                        // Unlock the Service Control Manager so that we can
                        // start the service.
                        //
//                        scm.Unlock();

                        // Start up the service
                        //
                        hr = scm.HrStartServiceNoWait(c_szSvcRsvp);
                    }
                }
            }
        }
    }

    TraceError("HrChangeRsvpService", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrInstallACS
//
//  Purpose:    Called when ACS service is being installed. Handles all of the
//              additional installation for ACS beyond that of the INF file.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Notes:
//
HRESULT HrInstallACS(PNETOCDATA pnocd)
{
    HRESULT                 hr          = S_OK;

#ifdef NEVER

    // For NT 5.0 beta 2, setting rights for AcsService user name will not be done as this
    // is introducing significant delay.

    // Make AcsService to be local admin and grant SE_TCB_NAME right
    hr = ::HrSetAcsServiceRights();
    if (SUCCEEDED(hr)) {

        // Display a message box asking the user to change the logon name
        NcMsgBox(   g_ocmData.hwnd,
                    IDS_OC_CAPTION,
                    IDS_OC_ACS_CHG_LOGON,
                    MB_ICONSTOP | MB_OK);
    }

#endif // NEVER

    // Ignoring any error from changing rights and continue with the
    // setup so that ACS will run in Resouce only mode.
    // Change the RSVP service parameters
    hr = ::HrChangeRsvpService(
                ::SzLoadIds(IDS_OC_ACS_SERVICE_NAME),
                SERVICE_AUTO_START,
                TRUE);

    TraceError("HrInstallACS", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveACS
//
//  Purpose:    Handles additional removal requirements for ACS Service
//              component.
//
//      hwnd [in]   Parent window for displaying UI.
//      poc  [in]   Pointer to optional component being installed.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Notes:
//
HRESULT HrRemoveACS(PNETOCDATA pnocd)
{
    HRESULT         hr = S_OK;


#ifdef NEVER

    // For NT 5.0 beta 2, Removing AcsService user right will not be done as this
    // is introducing significant delay.

    // Drop the membership from local admins and remove SE_TCB_NAME right
    (VOID)::HrRemoveAcsServiceRights ();

#endif  // NEVER

    //
    // Clean out the adapters and subnet reg keys (if present)
    //
    (VOID)::HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, c_szRegKeyRsvpAdapters);
    (VOID)::HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, c_szRegKeyRsvpSubnet1);
    (VOID)::HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, c_szRegKeyRsvpSubnet);

    // Put the name back the way it should be
    //
    (VOID)::HrChangeRsvpService(
            ::SzLoadIds(IDS_OC_RSVP_SERVICE_NAME),
            SERVICE_DEMAND_START,
            FALSE);

    TraceError("HrRemoveACS", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtACS
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     danielwe   17 Sep 1998
//
//  Notes:
//
HRESULT HrOcExtACS(PNETOCDATA pnocd, UINT uMsg,
                   WPARAM wParam, LPARAM lParam)
{
    HRESULT     hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_POST_INSTALL:
        hr = HrOcAcsOnInstall(pnocd);
        break;

    case NETOCM_QUERY_CHANGE_SEL_STATE:
        hr = HrOcAcsOnQueryChangeSelState(pnocd, static_cast<BOOL>(wParam));
        break;
    }

    TraceError("HrOcExtACS", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcAcsOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for ACS Server
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Notes:
//
HRESULT HrOcAcsOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;

    if (IT_INSTALL == pnocd->eit)
    {
        hr = HrInstallACS(pnocd);
    }
    else if (IT_REMOVE == pnocd->eit)
    {
        hr = HrRemoveACS(pnocd);
    }

    TraceError("HrOcAcsOnInstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcAcsOnQueryChangeSelState
//
//  Purpose:    Handles the request of the OC framework of whether or not
//              the user should be allowed to install ACS on this host.
//
//  Arguments:
//      pnocd   [in]  NetOC Data
//      fShowUi [in]  TRUE if UI should be shown, FALSE if not
//
//  Returns:    S_OK if install is allowed, S_FALSE if not, Win32 error
//              otherwise
//
//  Author:     rameshpa   23 April 1998
//
//  Notes:
//
HRESULT HrOcAcsOnQueryChangeSelState(PNETOCDATA pnocd, BOOL fShowUi)
{
    HRESULT     hr = S_OK;

#ifdef NEVER

    // For NT 5.0 beta 2, checking for user name will not be done as this
    // is introducing significant delay.

    WCHAR       szAcsUserName[UNLEN+GNLEN+2];

    Assert(pnocd);
    Assert(g_ocmData.hwnd);

    // See if AcsService account exists in this domain or not
    hr = HrGetAcsServiceAccountName(szAcsUserName);
    if (    FAILED(hr)
        ||  !szAcsUserName[0] )
    {
        if (fShowUi)
        {
            NcMsgBox(   g_ocmData.hwnd,
                        IDS_OC_CAPTION,
                        IDS_OC_NO_ACS_USER_ACCOUNT,
                        MB_ICONSTOP | MB_OK);
        }

        // Allow ACS setup to continue, as ACS will default to
        // Resource only
        hr = S_FALSE;
    }

    TraceError("HrOcAcsOnQueryChangeSelState", hr);

#endif  // NEVER

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\ncbeac.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation
//
//  File:       N C B E A C . H
//
//  Contents:   Installation support for Beacon Client
//
//  Notes:      
//
//  Author:     roelfc     2 April 2002
//
//----------------------------------------------------------------------------

#ifndef _NCBEAC_H
#define _NCBEAC_H

#pragma once
#include "netoc.h"

HRESULT HrOcExtBEACON(PNETOCDATA pnocd, UINT uMsg,
                      WPARAM wParam, LPARAM lParam);

#endif //!_NCBEAC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\nccm.cpp ===
//+---------------------------------------------------------------------------
//
// File:     NCCM.CPP
//
// Module:   NetOC.DLL
//
// Synopsis: Implements the dll entry points required to integrate into
//           NetOC.DLL the installation of the following components.
//
//              CMAK, PBS, PBA
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:  quintinb   15 Dec 1998
//
//+---------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "nccm.h"


//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtCM
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     danielwe   17 Sep 1998
//
//  Notes:
//
HRESULT HrOcExtCM(PNETOCDATA pnocd, UINT uMsg,
                    WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_QUEUE_FILES:

        hr = HrOcCmakPreQueueFiles(pnocd);
        TraceError("HrOcExtCM -- HrOcCmakPreQueueFiles Failed", hr);

//  PBA is in value add, but check add back the start menu link if an upgrade
        hr = HrOcCpaPreQueueFiles(pnocd);
        TraceError("HrOcExtCM -- HrOcCpaPreQueueFiles Failed", hr);

        hr = HrOcCpsPreQueueFiles(pnocd);
        TraceError("HrOcExtCM -- HrOcCpsPreQueueFiles Failed", hr);

        break;

    case NETOCM_POST_INSTALL:

        hr = HrOcCmakPostInstall(pnocd);
        TraceError("HrOcExtCM -- HrOcCmakPostInstall Failed", hr);

//  PBA now in Value Add
//        hr = HrOcCpaOnInstall(pnocd);
//        TraceError("HrOcExtCM -- HrOcCpaOnInstall Failed", hr);

        hr = HrOcCpsOnInstall(pnocd);
        TraceError("HrOcExtCM -- HrOcCpsOnInstall Failed", hr);

        break;
    }

    TraceError("HrOcExtCM", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\ncbeac.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation
//
//  File:       N C B E A C . C P P
//
//  Contents:   Installation support for Beacon Client
//
//  Notes:
//
//  Author:     roelfc     2 April 2002
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "netoc.h"
#include "ncbeac.h"


//+---------------------------------------------------------------------------
//
//  Function:   HrOcBeaconOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for Beacon Client.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     roelfc   2 April 2002
//
//  Notes:
//
HRESULT HrOcBeaconOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;

    if (pnocd->eit == IT_REMOVE)
    {
        // When we uninstall Beacon Client, we need a reboot
        // in order to stop the SSDP service. (RAID #592673) 
        hr = NETCFG_S_REBOOT;
    }

    TraceError("HrOcBeaconOnInstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtBEACON
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     roelfc   2 April 2002
//
//  Notes:
//
HRESULT HrOcExtBEACON(PNETOCDATA pnocd, UINT uMsg,
                      WPARAM wParam, LPARAM lParam)
{
    HRESULT     hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_POST_INSTALL:
        hr = HrOcBeaconOnInstall(pnocd);
        break;
    }

    TraceError("HrOcExtBEACON", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\nccm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       NCCM.H
//
//  Contents:   Installation support for Connection Manager Administration kit
//  Contents:   Installation support for Connection Point Services -- Phonebook Admin
//  Contents:   Installation support for Connection Point Services -- Phonebook Server
//
//  Notes:
//
//  Author:     quintinb 26 Jan 1999
//
//----------------------------------------------------------------------------

#ifndef _NCCM_H_
#define _NCCM_H_

#pragma once

#include <aclapi.h>

#include "netoc.h"
#include "netocp.h"
#include "ncreg.h"

//  Types
//
enum e_rootType {www, ftp};

//  Function Headers
//

// Shared Extension Proc
HRESULT HrOcExtCM(PNETOCDATA pnocd, UINT uMsg, WPARAM wParam, LPARAM lParam);

//CMAK
HRESULT HrOcCmakPreQueueFiles(PNETOCDATA pnocd);
HRESULT HrOcCmakPostInstall(PNETOCDATA pnocd);
BOOL migrateProfiles(PCTSTR pszSource, PCWSTR pszDestination);
BOOL RenameProfiles32(PCTSTR pszCMAKpath, PCWSTR pszProfilesDir);
void DeleteOldCmakSubDirs(PCWSTR pszCmakPath);
void DeleteIeakCmakLinks();
void DeleteProgramGroupWithLinks(PCWSTR pszGroupPath);
void DeleteOldNtopLinks();

//PBA
HRESULT HrOcCpaPreQueueFiles(PNETOCDATA pnocd);
//HRESULT HrOcCpaOnInstall(PNETOCDATA pnocd);
//HRESULT RefCountPbaSharedDlls(BOOL bIncrement);
//HRESULT UnregisterAndDeleteDll(PCWSTR pszFile);
//HRESULT HrGetDaoInstallPath(PWSTR pszDaoPath, DWORD dwNumChars);
//HRESULT HrGetPbaInstallPath(PWSTR pszCpaPath, DWORD dwNumChars);
//HRESULT RegisterDll(PCWSTR pszFile);

//PBS
HRESULT HrOcCpsOnInstall(PNETOCDATA pnocd);
HRESULT HrOcCpsPreQueueFiles(PNETOCDATA pnocd);
BOOL RegisterPBServerDataSource();
BOOL CreateCPSVRoots();
BOOL RemoveCPSVRoots();
BOOL LoadPerfmonCounters();
HRESULT SetVirtualRootAccessPermissions(PWSTR pszVirtDir, DWORD dwAccessPermisions );
HRESULT AddNewVirtualRoot(e_rootType rootType, PWSTR pszDir, PWSTR pszPath);
HRESULT DeleteVirtualRoot(e_rootType rootType, PWSTR pszPath);
HRESULT SetDirectoryAccessPermissions(PCWSTR pszFile, ACCESS_RIGHTS AccessRightsToModify, ULONG fAccessFlags, PSID pSid);
void SetCpsDirPermissions();
DWORD AddToRegKeySD(PCWSTR pszRegKeyName, PSID pGroupSID, DWORD dwAccessMask);
HRESULT HrMoveOldCpsInstall(PCWSTR pszProgramFiles);
HRESULT HrGetWwwRootDir(PWSTR pszWwwRoot, UINT uWwwRootCount);

#endif // _NCCM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\nccmak.cpp ===
//+---------------------------------------------------------------------------
//
// File:     NCCMAK.CPP
//
// Module:   NetOC.DLL
//
// Synopsis: Implements the dll entry points required to integrate into
//           NetOC.DLL the installation of the following components.
//
//              NETCMAK
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:   a-anasj 9 Mar 1998
//           quintinb   18 Sep 1998 --  rewrote
//
//+---------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "ncatl.h"

#include "resource.h"

#include "nccm.h"

//
//  Define Globals
//
WCHAR g_szCmakPath[MAX_PATH+1];

//
//  Define Strings Chars
//
static const WCHAR c_szCmakRegPath[] = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMAK.EXE";
static const WCHAR c_szPathValue[] = L"Path";
static const WCHAR c_szProfiles32Fmt[] = L"%s\\Profiles-32";
static const WCHAR c_szCm32Fmt[] = L"%s\\cm32";
static const WCHAR c_szProfilesFmt[] = L"%s\\Profiles";
static const WCHAR c_szSupportFmt[] = L"%s\\Support";
static const WCHAR c_szCmHelpFmt[] = L"%s\\Support\\CmHelp";
static const WCHAR c_szCmakGroup[] = L"Connection Manager Administration Kit";

const DWORD c_dwCmakDirID = 123174; // just must be larger than DIRID_USER = 0x8000;


//+---------------------------------------------------------------------------
//
//  Function:   HrOcCmakPreQueueFiles
//
//  Purpose:    Called by optional components installer code before any files
//              are copied to handle any additional installation processing
//              for the Connection Manager Administration Kit.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 18 Sep 1998
//
//  Notes:
//
HRESULT HrOcCmakPreQueueFiles(PNETOCDATA pnocd)
{
    HRESULT hr = S_OK;

    if ((IT_INSTALL == pnocd->eit) || (IT_UPGRADE == pnocd->eit) || (IT_REMOVE == pnocd->eit))
    {
        //  Figure out if CMAK is already installed
        //      if so, save where it is located

        HKEY hKey;
        ZeroMemory(g_szCmakPath, sizeof(g_szCmakPath));

        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szCmakRegPath, KEY_READ, &hKey);

        if (SUCCEEDED(hr))
        {
            DWORD dwSize = sizeof(g_szCmakPath);

            if (ERROR_SUCCESS != RegQueryValueExW(hKey, c_szPathValue, NULL, NULL,
                (LPBYTE)g_szCmakPath, &dwSize))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            RegCloseKey(hKey);
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            //  This is  a fresh install of CMAK, don't return an error
            //
            hr = SHGetSpecialFolderPath(NULL, g_szCmakPath, CSIDL_PROGRAM_FILES, FALSE);
            if (SUCCEEDED(hr))
            {
                lstrcatW(g_szCmakPath, L"\\Cmak");
            }
        }

        if (SUCCEEDED(hr))
        {
            //  Next Create the CMAK Dir ID
            //
            hr = HrEnsureInfFileIsOpen(pnocd->pszComponentId, *pnocd);
            if (SUCCEEDED(hr))
            {
                if(!SetupSetDirectoryId(pnocd->hinfFile, c_dwCmakDirID, g_szCmakPath))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
    }

    TraceError("HrOcCmakPreQueueFiles", hr);
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcCmakPostInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for Connection Manager Administration Kit.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     a-anasj 9 Mar 1998
//
//  Notes:
//
HRESULT HrOcCmakPostInstall(PNETOCDATA pnocd)
{
    HRESULT hr = S_OK;
    WCHAR szTempDest[MAX_PATH+1];

    if ((IT_INSTALL == pnocd->eit) || (IT_UPGRADE == pnocd->eit))
    {
        //
        //  Then we need to migrate profiles and potentially delete old directories
        //

        if (L'\0' != g_szCmakPath[0])
        {
            wsprintfW(szTempDest, c_szProfilesFmt, g_szCmakPath);

            //
            //  Rename Profiles-32 to Profiles
            //

            BOOL bFail = !RenameProfiles32(g_szCmakPath, szTempDest);
            hr = bFail ? E_UNEXPECTED: S_OK;

            //
            //  Migrate 1.0 Profiles
            //
            bFail = !migrateProfiles(g_szCmakPath, szTempDest);
            hr = bFail ? E_UNEXPECTED: S_OK;

            //
            //  Delete the old directories (cm32 and its sub-dirs)
            //

            DeleteOldCmakSubDirs(g_szCmakPath);
        DeleteOldNtopLinks();
            DeleteIeakCmakLinks();
        }
    }
    else if (IT_REMOVE == pnocd->eit)
    {
        //
        //  We use the g_szCmakPath string to hold where CMAK was installed.
        //  To Properly delete the CMAK directory, we must delete the following
        //  directories CMAK\Support\CMHelp, CMAK\Support, CMAK\Profiles, and CMAK.
        //  We should only delete these directories if they are empty of both files
        //  and sub-dirs.
        //
        wsprintfW(szTempDest, c_szCmHelpFmt, g_szCmakPath);
        if (!RemoveDirectory(szTempDest))
        {
            TraceError("HrOcCmakPostInstall -- Removing CMHelp Dir",
                HRESULT_FROM_WIN32(GetLastError()));
        }

        wsprintfW(szTempDest, c_szSupportFmt, g_szCmakPath);
        if (!RemoveDirectory(szTempDest))
        {
            TraceError("HrOcCmakPostInstall -- Removing Support Dir",
                HRESULT_FROM_WIN32(GetLastError()));
        }

        wsprintfW(szTempDest, c_szProfilesFmt, g_szCmakPath);
        if (!RemoveDirectory(szTempDest))
        {
            TraceError("HrOcCmakPostInstall -- Removing Profiles Dir",
                HRESULT_FROM_WIN32(GetLastError()));
        }

        if (!RemoveDirectory(g_szCmakPath))
        {
            TraceError("HrOcCmakPostInstall -- Removing CMAK Dir",
                HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    TraceError("HrOcCmakPostInstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   migrateProfiles
//
//  Purpose:    This is the function that migrates the profiles.  It takes the current
//              CMAK dir as its first input and the new CMAK dir as its second input..
//
//  Arguments:  PCWSTR pszSource - root of source CMAK dir
//              PCWSTR pszDestination - root of destination CMAK dir
//
//  Returns:    BOOL - Returns TRUE if it was able to migrate the profiles.
//
//  Author:     a-anasj   9 Mar 1998
//
//  Notes:
// History:   quintinb Created    12/9/97
//
BOOL migrateProfiles(PCWSTR pszSource, PCWSTR pszDestination)
{
    WCHAR szSourceProfileSearchString[MAX_PATH+1];
    WCHAR szFile[MAX_PATH+1];
    HANDLE hFileSearch;
    WIN32_FIND_DATA wfdFindData;
    BOOL bReturn = TRUE;
    SHFILEOPSTRUCT fOpStruct;

    //
    //  Initialize the searchstring and the destination dir
    //

    wsprintfW(szSourceProfileSearchString, L"%s\\*.*", pszSource);

    //
    //  Create the destination directory
    //

    CreateDirectory(pszDestination, NULL); //lint !e534 this might fail if it already exists

    hFileSearch = FindFirstFile(szSourceProfileSearchString, &wfdFindData);

    while (INVALID_HANDLE_VALUE != hFileSearch)
    {

        if((wfdFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            (0 != _wcsicmp(wfdFindData.cFileName, L"cm32")) && // 1.1/1.2 Legacy
            (0 != _wcsicmp(wfdFindData.cFileName, L"cm16")) && // 1.1/1.2 Legacy
            (0 != _wcsicmp(wfdFindData.cFileName, L"Docs")) &&
            (0 != _wcsicmp(wfdFindData.cFileName, L"Profiles-32")) && // 1.1/1.2 Legacy
            (0 != _wcsicmp(wfdFindData.cFileName, L"Profiles-16")) && // 1.1/1.2 Legacy
            (0 != _wcsicmp(wfdFindData.cFileName, L"Support")) &&
            (0 != _wcsicmp(wfdFindData.cFileName, L"Profiles")) &&
            (0 != _wcsicmp(wfdFindData.cFileName, L".")) &&
            (0 != _wcsicmp(wfdFindData.cFileName, L"..")))
        {
            //
            //  Then I have a profile directory
            //

            ZeroMemory(&fOpStruct, sizeof(fOpStruct));
            ZeroMemory(szFile, sizeof(szFile));
            wsprintfW(szFile, L"%s\\%s", pszSource, wfdFindData.cFileName);

            fOpStruct.hwnd = NULL;
            fOpStruct.wFunc = FO_MOVE;
            fOpStruct.pTo = pszDestination;
            fOpStruct.pFrom = szFile;
            fOpStruct.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;

            bReturn &= (0== SHFileOperation(&fOpStruct));   //lint !e514, intended use of boolean, quintinb
        }

        //
        //  Check to see if we have any more Files
        //
        if (!FindNextFile(hFileSearch, &wfdFindData))
        {
            if (ERROR_NO_MORE_FILES != GetLastError())
            {
                //
                //  We had some unexpected error, report unsuccessful completion
                //
                bReturn = FALSE;
            }

            //
            //  Exit the loop
            //
            break;
        }
    }

    if (INVALID_HANDLE_VALUE != hFileSearch)
    {
        FindClose(hFileSearch);
    }

    return bReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   RenameProfiles32
//
//  Purpose:    Takes the inputted CMAK path, appends Profiles-32 to it, and then
//              renames the resulting dir to the path inputted as pszProfilesDir.
//              Note this dir must exist for it to be renamed.
//
//  Arguments:  PCWSTR pszCMAKpath - current cmak path
//              PCWSTR pszProfilesDir - new profiles directory path
//
//  Returns:    BOOL - Returns TRUE if succeeded
//
//  Author:     quintinb   13 Aug 1998
//
//  Notes:
BOOL RenameProfiles32(PCWSTR pszCMAKpath, PCWSTR pszProfilesDir)
{
    SHFILEOPSTRUCT fOpStruct;
    WCHAR szTemp[MAX_PATH+1];

    ZeroMemory(&fOpStruct, sizeof(fOpStruct));
    ZeroMemory(szTemp, sizeof(szTemp));

    wsprintfW(szTemp, c_szProfiles32Fmt, pszCMAKpath);

    if (SetFileAttributes(szTemp, FILE_ATTRIBUTE_NORMAL))
    {
        fOpStruct.hwnd = NULL;
        fOpStruct.wFunc = FO_MOVE;
        fOpStruct.pTo = pszProfilesDir;
        fOpStruct.pFrom = szTemp;
        fOpStruct.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;

        return (0== SHFileOperation(&fOpStruct));   //lint !e514, intended use of boolean, quintinb
    }
    else
    {
        return TRUE;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteOldCmakSubDirs
//
//  Purpose:    Deletes the old Cmak sub directories.  Uses FindFirstFile becuase
//              we don't want to delete any customized doc files that the user may
//              have customized.  Thus anything in the CMHelp directory except the
//              original help files is deleted.
//
//  Arguments:  PCWSTR pszCMAKpath - current cmak path
//
//  Returns:    Nothing
//
//  Author:     quintinb   6 Nov 1998
//
//  Notes:
void DeleteOldCmakSubDirs(PCWSTR pszCmakPath)
{
    WCHAR szCm32path[MAX_PATH+1];
    WCHAR szCm32SearchString[MAX_PATH+1];
    WCHAR szTemp[MAX_PATH+1];
    HANDLE hCm32FileSearch;
    WIN32_FIND_DATA wfdCm32;

    //
    // Delete the old IEAK Docs Dir
    //
    wsprintfW(szTemp, L"%s\\%s", pszCmakPath, SzLoadIds(IDS_OC_OLD_IEAK_DOCDIR));
    RemoveDirectory(szTemp);

    wsprintfW(szCm32path, c_szCm32Fmt, pszCmakPath);

    //
    //  First look in the Cm32 directory itself.  Delete all files found, continue down
    //  into subdirs.
    //

    wsprintfW(szCm32SearchString, L"%s\\*.*", szCm32path);

    hCm32FileSearch = FindFirstFile(szCm32SearchString, &wfdCm32);

    while (INVALID_HANDLE_VALUE != hCm32FileSearch)
    {

        if (wfdCm32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            if ((0 != lstrcmpiW(wfdCm32.cFileName, L".")) &&
               (0 != lstrcmpiW(wfdCm32.cFileName, L"..")))
            {
                //
                //  Then we want to delete all the files in this lang sub dir and we
                //  we want to delete the four help files from the CM help dir.  If all the
                //  files are deleted from a dir then we should remove the directory.
                //
                WCHAR szLangDirSearchString[MAX_PATH+1];
                HANDLE hLangDirFileSearch;
                WIN32_FIND_DATA wfdLangDir;

                wsprintfW(szLangDirSearchString, L"%s\\%s\\*.*", szCm32path,
                    wfdCm32.cFileName);

                hLangDirFileSearch = FindFirstFile(szLangDirSearchString, &wfdLangDir);

                while (INVALID_HANDLE_VALUE != hLangDirFileSearch)
                {
                    if (wfdLangDir.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        if ((0 != lstrcmpiW(wfdLangDir.cFileName, L".")) &&
                           (0 != lstrcmpiW(wfdLangDir.cFileName, L"..")))
                        {
                            //
                            //  We only want to delete help files from our help source dirs
                            //
                            if (0 == _wcsnicmp(wfdLangDir.cFileName, L"CM", 2))
                            {
                                //
                                //  Delete the four help files only.
                                //
                                wsprintfW(szTemp, L"%s\\%s\\%s\\cmctx32.rtf", szCm32path,
                                    wfdCm32.cFileName, wfdLangDir.cFileName);
                                DeleteFile(szTemp);

                                wsprintfW(szTemp, L"%s\\%s\\%s\\cmmgr32.h", szCm32path,
                                    wfdCm32.cFileName, wfdLangDir.cFileName);
                                DeleteFile(szTemp);

                                wsprintfW(szTemp, L"%s\\%s\\%s\\cmmgr32.hpj", szCm32path,
                                    wfdCm32.cFileName, wfdLangDir.cFileName);
                                DeleteFile(szTemp);

                                wsprintfW(szTemp, L"%s\\%s\\%s\\cmtrb32.rtf", szCm32path,
                                    wfdCm32.cFileName, wfdLangDir.cFileName);
                                DeleteFile(szTemp);

                                //
                                //  Now try to remove the directory
                                //
                                wsprintfW(szTemp, L"%s\\%s\\%s", szCm32path,
                                    wfdCm32.cFileName, wfdLangDir.cFileName);
                                RemoveDirectory(szTemp);
                            }
                        }
                    }
                    else
                    {
                        wsprintfW(szTemp, L"%s\\%s\\%s", szCm32path, wfdCm32.cFileName,
                            wfdLangDir.cFileName);

                        DeleteFile(szTemp);
                    }

                    //
                    //  Check to see if we have any more Files
                    //
                    if (!FindNextFile(hLangDirFileSearch, &wfdLangDir))
                    {
                        //
                        //  Exit the loop
                        //
                        break;
                    }
                }

                if (INVALID_HANDLE_VALUE != hLangDirFileSearch)
                {
                    FindClose(hLangDirFileSearch);

                    //
                    //  Now try to remove the lang dir directory
                    //
                    wsprintfW(szTemp, L"%s\\%s", szCm32path, wfdCm32.cFileName);
                    RemoveDirectory(szTemp);
                }
            }
        }
        else
        {
            wsprintfW(szTemp, L"%s\\%s", szCm32path, wfdCm32.cFileName);

            DeleteFile(szTemp);
        }

        //
        //  Check to see if we have any more Files
        //
        if (!FindNextFile(hCm32FileSearch, &wfdCm32))
        {
            if (INVALID_HANDLE_VALUE != hCm32FileSearch)
            {
                FindClose(hCm32FileSearch);
            }

            //
            //  Now try to remove the cm32 directory
            //
            RemoveDirectory(szCm32path);

            //
            //  Exit the loop
            //
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteProgramGroupWithLinks
//
//  Purpose:    Utility function to delete a given program group and its links.
//              Thus if you pass in the full path to a program group to delete,
//              the function does a findfirstfile to find and delete any links.
//              The function ignores sub-dirs.
//
//
//  Arguments:  PCWSTR pszGroupPath - Full path to the program group to delete.
//
//  Returns:    Nothing
//
//  Author:     quintinb   6 Nov 1998
//
//  Notes:
void DeleteProgramGroupWithLinks(PCWSTR pszGroupPath)
{
    HANDLE hLinkSearch;
    WIN32_FIND_DATA wfdLinks;
    WCHAR szLinkSearchString[MAX_PATH+1];
    WCHAR szTemp[MAX_PATH+1];

    wsprintfW(szLinkSearchString, L"%s\\*.*", pszGroupPath);

    hLinkSearch = FindFirstFile(szLinkSearchString, &wfdLinks);

    while (INVALID_HANDLE_VALUE != hLinkSearch)
    {
        if (!(wfdLinks.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            wsprintfW(szTemp, L"%s\\%s", pszGroupPath, wfdLinks.cFileName);

            DeleteFile(szTemp);
        }

        //
        //  Check to see if we have any more Files
        //
        if (!FindNextFile(hLinkSearch, &wfdLinks))
        {
            FindClose(hLinkSearch);

            //
            //  Now try to remove the directory
            //
            RemoveDirectory(pszGroupPath);

            //
            //  Exit the loop
            //
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteOldNtopLinks
//
//  Purpose:    Deletes the old links from the NT 4.0 Option Pack
//
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Author:     quintinb   6 Nov 1998
//
//  Notes:
void DeleteOldNtopLinks()
{
    HRESULT hr;

    //
    //  First Delete the old NTOP4 Path
    //
    WCHAR szGroup[MAX_PATH+1];
    WCHAR szTemp[MAX_PATH+1];

    //
    //  Get the CSIDL_COMMON_PROGRAMS value
    //
    hr = SHGetSpecialFolderPath(NULL, szTemp, CSIDL_COMMON_PROGRAMS, FALSE);
    if (SUCCEEDED(hr))
    {
        wsprintfW(szGroup, L"%s\\%s\\%s", szTemp,
            (PWSTR)SzLoadIds(IDS_OC_NTOP4_GROUPNAME),
            (PWSTR)SzLoadIds(IDS_OC_ICS_GROUPNAME));

        DeleteProgramGroupWithLinks(szGroup);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteIeakCmakLinks
//
//  Purpose:    Deletes the old links from the IEAK4 CMAK
//
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Author:     quintinb   6 Nov 1998
//
//  Notes:
void DeleteIeakCmakLinks()
{
    WCHAR szUserDirRoot[MAX_PATH+1];
    WCHAR szGroup[MAX_PATH+1];
    WCHAR szTemp[MAX_PATH+1];
    WCHAR szEnd[MAX_PATH+1];


    //
    //  Next Delete the old IEAK CMAK links
    //
    //
    //  Get the Desktop directory and then remove the desktop part.  This will give us the
    //  root of the user directories.
    //
    HRESULT hr = SHGetSpecialFolderPath(NULL, szUserDirRoot, CSIDL_DESKTOPDIRECTORY, FALSE);
    if (SUCCEEDED(hr))
    {

        //
        //  Remove \\Desktop
        //
        WCHAR* pszTemp = wcsrchr(szUserDirRoot, L'\\');
        if (NULL == pszTemp)
        {
            return;
        }
        else
        {
            *pszTemp = L'\0';
        }

        HRESULT hr = SHGetSpecialFolderPath(NULL, szTemp, CSIDL_PROGRAMS, FALSE);

        if (SUCCEEDED(hr))
        {
            if (0 == _wcsnicmp(szUserDirRoot, szTemp, wcslen(szUserDirRoot)))
            {
                lstrcpyW(szEnd, &(szTemp[wcslen(szUserDirRoot)]));
            }
        }

        //
        //  Remove \\<User Name>>
        //
        pszTemp = wcsrchr(szUserDirRoot, L'\\');
        if (NULL == pszTemp)
        {
            return;
        }
        else
        {
            *pszTemp = L'\0';
        }

        //
        //  Now start searching for user dirs to delete the CMAK group from
        //
        WCHAR szUserDirSearchString[MAX_PATH+1];
        HANDLE hUserDirSearch;
        WIN32_FIND_DATA wfdUserDirs;

        wsprintfW(szUserDirSearchString, L"%s\\*.*", szUserDirRoot);
        hUserDirSearch = FindFirstFile(szUserDirSearchString, &wfdUserDirs);

        while (INVALID_HANDLE_VALUE != hUserDirSearch)
        {
            if ((wfdUserDirs.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                (0 != _wcsicmp(wfdUserDirs.cFileName, L".")) &&
                (0 != _wcsicmp(wfdUserDirs.cFileName, L"..")))
            {
                wsprintfW(szGroup, L"%s\\%s%s\\%s", szUserDirRoot, wfdUserDirs.cFileName,
                    szEnd, c_szCmakGroup);
                DeleteProgramGroupWithLinks(szGroup);

            }

            if (!FindNextFile(hUserDirSearch, &wfdUserDirs))
            {
                FindClose(hUserDirSearch);

                //
                //  Exit the loop
                //
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\ncdhcps.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C D H C P S . H
//
//  Contents:   Installation support for DHCP Server
//
//  Notes:      B sharp
//
//  Author:     jeffspr   13 May 1997
//
//----------------------------------------------------------------------------

#ifndef _NCDHCPS_H_
#define _NCDHCPS_H_

#pragma once
#include "netoc.h"

HRESULT HrOcDhcpOnInstall(PNETOCDATA pnocd);
HRESULT HrOcExtDHCPServer(PNETOCDATA pnocd, UINT uMsg,
                          WPARAM wParam, LPARAM lParam);
HRESULT HrSetServiceRecoveryOption(PNETOCDATA pnocd);

#endif // _NCDHCPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\nccpa.cpp ===
//+---------------------------------------------------------------------------
//
// File:     NCNetCPA.CPP
//
// Module:   NetOC.DLL
//
// Synopsis: Implements the dll entry points required to integrate into
//           NetOC.DLL the installation of the following components.
//
//              NETCPS
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:   Anas Jarrah (a-anasj) Created    3/9/98
//
//+---------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "ncatl.h"

#include "resource.h"

#include "nccm.h"

//
//  Define Globals
//
WCHAR g_szCpaPath[MAX_PATH+1];
WCHAR g_szDaoPath[MAX_PATH+1];

//
//  Define Constants
//
const DWORD c_dwCpaDirID = 123176;  // just must be larger than DIRID_USER = 0x8000;
const DWORD c_dwDaoDirID = 123177;  // just must be larger than DIRID_USER = 0x8000;

const WCHAR* const c_szDaoClientsPath = L"SOFTWARE\\Microsoft\\Shared Tools\\DAO\\Clients";
const WCHAR* const c_szCommonFilesPath = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion";
const WCHAR* const c_szCommonFilesDirValue = L"CommonFilesDir";

HRESULT HrGetPBAPathIfInstalled(PWSTR pszCpaPath, DWORD dwNumChars)
{
    HRESULT hr;
    HKEY hKey;
    BOOL bFound = FALSE;

    //  We need to see if PBA is installed or not.  If it is then we want to 
    //  add back the PBA start menu link.  If it isn't, then we want to do nothing
    //  with PBA.
    //

    ZeroMemory(pszCpaPath, sizeof(WCHAR)*dwNumChars);
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szDaoClientsPath, KEY_READ, &hKey);

    if (SUCCEEDED(hr))
    {
        WCHAR szCurrentValue[MAX_PATH+1];
        WCHAR szCurrentData[MAX_PATH+1];
        DWORD dwValueSize = MAX_PATH;
        DWORD dwDataSize = MAX_PATH;
        DWORD dwType;
        DWORD dwIndex = 0;

        while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szCurrentValue, &dwValueSize, NULL, &dwType,
               (LPBYTE)szCurrentData, &dwDataSize))
        {
            _wcslwr(szCurrentValue);
            if (NULL != wcsstr(szCurrentValue, L"pbadmin.exe"))
            {
                //
                //  Then we have found the PBA path
                //

                WCHAR* pszTemp = wcsrchr(szCurrentValue, L'\\');
                if (NULL != pszTemp)
                {
                    *pszTemp = L'\0';
                    lstrcpyW(pszCpaPath, szCurrentValue);
                    bFound = TRUE;
                    break;
                }
            }
            dwValueSize = MAX_PATH;
            dwDataSize = MAX_PATH;
            dwIndex++;
        }

        RegCloseKey(hKey);
    }

    if (!bFound)
    {
        //  We didn't find PBA, so lets return S_FALSE
        //
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

BOOL GetAdminToolsFolder(PWSTR pszAdminTools)
{
    BOOL bReturn = FALSE;

    if (pszAdminTools)
    {
        bReturn = SHGetSpecialFolderPath(NULL, pszAdminTools, CSIDL_COMMON_PROGRAMS, TRUE);

        if (bReturn)
        {
            //  Now Append Administrative Tools
            //
            lstrcat(pszAdminTools, SzLoadIds(IDS_OC_ADMIN_TOOLS));            
        }
    }

    return bReturn;
}

HRESULT HrCreatePbaShortcut(PWSTR pszCpaPath)
{
    HRESULT hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        IShellLink *psl = NULL;

        hr = CoCreateInstance(CLSID_ShellLink, NULL,
                CLSCTX_INPROC_SERVER, //CLSCTX_LOCAL_SERVER,
                IID_IShellLink,
                (LPVOID*)&psl);
        
        if (SUCCEEDED(hr))
        {
            IPersistFile *ppf = NULL;

            // Set up the properties of the Shortcut
            //
            static const WCHAR c_szPbAdmin[] = L"\\pbadmin.exe";

            WCHAR szPathToPbadmin[MAX_PATH+1] = {0};
            DWORD dwLen = lstrlen(c_szPbAdmin) + lstrlen(pszCpaPath) + 1;

            if (MAX_PATH >= dwLen)
            {
                //  Set the Path to pbadmin.exe
                //
                lstrcpy(szPathToPbadmin, pszCpaPath);
                lstrcat(szPathToPbadmin, c_szPbAdmin);
            
                hr = psl->SetPath(szPathToPbadmin);
            
                if (SUCCEEDED(hr))
                {
                    //  Set the Description to Phone Book Administrator
                    //
                    hr = psl->SetDescription(SzLoadIds(IDS_OC_PBA_DESC));

                    if (SUCCEEDED(hr))
                    {
                        hr = psl->QueryInterface(IID_IPersistFile,
                                                 (LPVOID *)&ppf);
                        if (SUCCEEDED(hr))
                        {
                            WCHAR szAdminTools[MAX_PATH+1] = {0};                            
                            if (GetAdminToolsFolder(szAdminTools))
                            {
                                // Create the link file.
                                //
                                hr = ppf->Save(szAdminTools, TRUE);
                            }

                            ReleaseObj(ppf);
                        }                    
                    }
                }
            }

            ReleaseObj(psl);
        }

        CoUninitialize();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcCpaPreQueueFiles
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for PhoneBook Server.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 18 Sep 1998
//
//  Notes:
//
HRESULT HrOcCpaPreQueueFiles(PNETOCDATA pnocd)
{
    HRESULT hr = S_OK;

    switch ( pnocd->eit )
    {
    case IT_UPGRADE:

        WCHAR szPbaInstallPath[MAX_PATH+1];

        hr = HrGetPBAPathIfInstalled(szPbaInstallPath, MAX_PATH);

        if (S_OK == hr)
        {
            HrCreatePbaShortcut(szPbaInstallPath);
        }

	break;

    case IT_INSTALL:
    case IT_REMOVE:

        break;
    }

    TraceError("HrOcCpaPreQueueFiles", hr);
    return hr;
}


/*
//+---------------------------------------------------------------------------
//
//  Function:   HrOcCpaPreQueueFiles
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for PhoneBook Server.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 18 Sep 1998
//
//  Notes:
//
HRESULT HrOcCpaPreQueueFiles(PNETOCDATA pnocd)
{
    HRESULT hr = S_OK;

    switch ( pnocd->eit )
    {
    case IT_UPGRADE:
    case IT_INSTALL:
    case IT_REMOVE:

        //
        //  Get the PBA install Dir.
        //
        hr = HrGetPbaInstallPath(g_szCpaPath, celems(g_szCpaPath));

        if (SUCCEEDED(hr))
        {
            //  Next Create the CPA Dir ID
            //
            hr = HrEnsureInfFileIsOpen(pnocd->pszComponentId, *pnocd);
            if (SUCCEEDED(hr))
            {
                if(!SetupSetDirectoryId(pnocd->hinfFile, c_dwCpaDirID, g_szCpaPath))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }

        //
        //  Now query the system for the DAO350 install path
        //

        if (SUCCEEDED (hr))
        {
            hr = HrGetDaoInstallPath(g_szDaoPath, celems(g_szDaoPath));
            if (SUCCEEDED(hr))
            {
                //  Next Create the DAO Dir ID
                //
                hr = HrEnsureInfFileIsOpen(pnocd->pszComponentId, *pnocd);
                if (SUCCEEDED(hr))
                {
                    if(!SetupSetDirectoryId(pnocd->hinfFile, c_dwDaoDirID, g_szDaoPath))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
            }
        }

        break;
    }

    TraceError("HrOcCpaPreQueueFiles", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcCpaOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for PhoneBook Server.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 18 Sep 1998
//
//  Notes:
//
HRESULT HrOcCpaOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr      = S_OK;
    switch ( pnocd->eit )
    {
    case IT_INSTALL:
        hr = RefCountPbaSharedDlls(TRUE); // bIncrement = TRUE
        break;

    case IT_REMOVE:
        hr = RefCountPbaSharedDlls(FALSE); // bIncrement = FALSE
        break;

    case IT_UPGRADE:
        DeleteOldNtopLinks();
        break;

    case IT_UNKNOWN:
    case IT_NO_CHANGE:
        break;
    }

    TraceError("HrOcCpaOnInstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RefCountPbaSharedDlls
//
//  Purpose:    Reference count and register/unregister all of the PBAdmin
//              shared components.
//
//  Arguments:  BOOL bIncrement -- if TRUE, then increment the ref count,
//                                 else decrement it
//
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 9 OCT 1998
//
//  Notes:
//
HRESULT RefCountPbaSharedDlls(BOOL bIncrement)
{
    HRESULT hr = S_OK;
    HKEY hKey;
    WCHAR szSystemDir[MAX_PATH+1];
    DWORD dwSize;
    DWORD dwCount;
    LONG lResult;
    const UINT uNumDlls = 6;
    const UINT uStringLen = 12 + 1;
    const WCHAR* const c_szSsFmt = L"%s\\%s";
    const WCHAR* const c_szSharedDllsPath = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDlls";
    WCHAR mszDlls[uNumDlls][uStringLen] = {  L"comctl32.ocx",
                                                 L"comdlg32.ocx",
                                                 L"msinet.ocx",
                                                 L"tabctl32.ocx",
                                                 L"dbgrid32.ocx",
                                                 L"dao350.dll"
    };

    WCHAR mszDllPaths[uNumDlls][MAX_PATH];


    //
    //  All of the Dlls that we ref count are in the system directory, except for Dao350.dll.
    //  Thus we want to append the system directory path to our filenames and handle dao last.
    //

    if (0 == GetSystemDirectory(szSystemDir, MAX_PATH))
    {
        return E_UNEXPECTED;
    }

    for (int i = 0; i < (uNumDlls - 1); i++)
    {
        wsprintfW(mszDllPaths[i], c_szSsFmt, szSystemDir, mszDlls[i]);
    }

    //
    //  Now write out the dao350.dll path.
    //
    wsprintfW(mszDllPaths[i], c_szSsFmt, g_szDaoPath, mszDlls[i]);

    //
    //  Open the shared DLL key and start enumerating our multi-sz with all of our dll's
    //  to add.
    //
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szSharedDllsPath,
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwSize)) // using dwSize as a temp to hold the disposition value
    {
        for (int i=0; i < uNumDlls; i++)
        {
            dwSize = sizeof(DWORD);

            lResult = RegQueryValueExW(hKey, mszDllPaths[i], NULL, NULL, (LPBYTE)&dwCount, &dwSize);

            if (ERROR_SUCCESS == lResult)
            {
                //
                //  Increment or decrement as appropriate.  Make sure not to decrement 0
                //

                if (0 != dwCount || bIncrement)
                {
                    dwCount = dwCount + (bIncrement ? 1 : -1);
                }
            }
            else if (ERROR_FILE_NOT_FOUND == lResult)
            {
                if (bIncrement)
                {
                    //
                    //  The the value doesn't yet exist.  Set the count to 1.
                    //
                    dwCount = 1;
                }
                else
                {
                    //
                    //  We are decrementing and we couldn't find the DLL, nothing to
                    //  change for the count but we should still delete the dll.
                    //
                    dwCount = 0;
                }
            }
            else
            {
                hr = S_FALSE;
                continue;
            }

            //
            //  Not that we have determined the ref count, do something about it.
            //
            if (dwCount == 0)
            {
                //
                //  We don't want to delete dao350.dll, but otherwise we need to delete
                //  the file if it has a zero refcount.
                //
                if (0 != lstrcmpiW(mszDlls[i], L"dao350.dll"))
                {
                    hr = UnregisterAndDeleteDll(mszDllPaths[i]);
                    if (FAILED(hr))
                    {
                        //
                        //  Don't fail the setup over a file that we couldn't unregister or
                        //  couldn't delete
                        //
                        hr = S_FALSE;
                    }
                }
                RegDeleteValue(hKey, mszDllPaths[i]);
            }
            else
            {
                //
                //  Set the value to its new count.
                //
                if (ERROR_SUCCESS != RegSetValueEx(hKey, mszDllPaths[i], 0, REG_DWORD,
                    (LPBYTE)&dwCount, sizeof(DWORD)))
                {
                    hr = S_FALSE;
                }

                //
                //  If we are incrementing the count then we should register the dll.
                //
                if (bIncrement)
                {
                    hr = RegisterDll(mszDllPaths[i]);
                }
            }
        }

        RegCloseKey(hKey);
    }

    TraceError("RefCountPbaSharedDlls", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   UnregisterAndDeleteDll
//
//  Purpose:    Unregister and delete the given COM component
//
//  Arguments:  pszFile -- The full path to the file to unregister and delete
//
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 9 OCT 1998
//
//  Notes:
//

HRESULT UnregisterAndDeleteDll(PCWSTR pszFile)
{
    HINSTANCE hLib = NULL;
    FARPROC pfncUnRegister;
    HRESULT hr = S_OK;

    if ((NULL == pszFile) || (L'\0' == pszFile[0]))
    {
        return E_INVALIDARG;
    }

    hLib = LoadLibrary(pszFile);
    if (NULL != hLib)
    {
        pfncUnRegister = GetProcAddress(hLib, "DllUnregisterServer");
        if (NULL != pfncUnRegister)
        {
            hr = (pfncUnRegister)();
            if (SUCCEEDED(hr))
            {
                FreeLibrary(hLib);
                hLib = NULL;
//  This was removed because PBA setup is moving to Value Add and because of bug 323231
//                if (!DeleteFile(pszFile))
//                {
//                    hr = S_FALSE;
//                }
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    if (NULL != hLib)
    {
        FreeLibrary(hLib);
    }


    TraceError("UnregisterAndDeleteDll", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterDll
//
//  Purpose:    Register the given COM component
//
//  Arguments:  pszFile -- The full path to the file to register
//
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 9 OCT 1998
//
//  Notes:
//

HRESULT RegisterDll(PCWSTR pszFile)
{
    HINSTANCE hLib = NULL;
    FARPROC pfncRegister;
    HRESULT hr = S_OK;

    if ((NULL == pszFile) || (L'\0' == pszFile[0]))
    {
        return E_INVALIDARG;
    }

    hLib = LoadLibrary(pszFile);
    if (NULL != hLib)
    {
        pfncRegister = GetProcAddress(hLib, "DllRegisterServer");
        if (NULL != pfncRegister)
        {
            hr = (pfncRegister)();
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    if (NULL != hLib)
    {
        FreeLibrary(hLib);
    }


    TraceError("RegisterDll", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetPbaInstallPath
//
//  Purpose:    Get the install path for pbadmin.exe.
//
//  Arguments:  pszCpaPath -- buffer to hold the install path of PBA.
//              dwNumChars -- the number of characters that the buffer can hold.
//
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 19 OCT 1998
//
//  Notes:
//

HRESULT HrGetPbaInstallPath(PWSTR pszCpaPath, DWORD dwNumChars)
{
    HRESULT hr;
    HKEY hKey;
    BOOL bFound = FALSE;

    //  We need to setup the custom DIRID so that CPA will install
    //  to the correct location.  First get the path from the system.
    //

    ZeroMemory(pszCpaPath, sizeof(WCHAR)*dwNumChars);
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szDaoClientsPath, KEY_READ, &hKey);

    if (SUCCEEDED(hr))
    {
        WCHAR szCurrentValue[MAX_PATH+1];
        WCHAR szCurrentData[MAX_PATH+1];
        DWORD dwValueSize = MAX_PATH;
        DWORD dwDataSize = MAX_PATH;
        DWORD dwType;
        DWORD dwIndex = 0;

        while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szCurrentValue, &dwValueSize, NULL, &dwType,
               (LPBYTE)szCurrentData, &dwDataSize))
        {
            _wcslwr(szCurrentValue);
            if (NULL != wcsstr(szCurrentValue, L"pbadmin.exe"))
            {
                //
                //  Then we have found the PBA path
                //

                WCHAR* pszTemp = wcsrchr(szCurrentValue, L'\\');
                if (NULL != pszTemp)
                {
                    *pszTemp = L'\0';
                    lstrcpyW(pszCpaPath, szCurrentValue);
                    bFound = TRUE;
                    break;
                }
            }
            dwValueSize = MAX_PATH;
            dwDataSize = MAX_PATH;
            dwIndex++;
        }

        RegCloseKey(hKey);
    }

    if (!bFound)
    {
        //  This is  a fresh install of CPA, don't return an error
        //
        hr = SHGetSpecialFolderPath(NULL, pszCpaPath, CSIDL_PROGRAM_FILES, FALSE);

        if (SUCCEEDED(hr))
        {
            lstrcatW(pszCpaPath, L"\\PBA");
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetDaoInstallPath
//
//  Purpose:    Get the install path for pbadmin.exe.
//
//  Arguments:  pszCpaPath -- buffer to hold the install path of PBA.
//              dwNumChars -- the number of characters that the buffer can hold.
//
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 19 OCT 1998
//
//  Notes:
//

HRESULT HrGetDaoInstallPath(PWSTR pszDaoPath, DWORD dwNumChars)
{
    HRESULT hr;
    HKEY hKey;

    //  We need to setup the custom DIRID so that CPA will install
    //  to the correct location.  First get the path from the system.
    //

    ZeroMemory(pszDaoPath, sizeof(WCHAR)*dwNumChars);
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szCommonFilesPath, KEY_ALL_ACCESS, &hKey);

    if (SUCCEEDED(hr))
    {
        DWORD dwSize = sizeof(WCHAR)*dwNumChars;

        //
        //  Try to get the CommonFilesDir value from the registry, but if it doesn't exist
        //  then create it.
        //
        if (ERROR_SUCCESS != RegQueryValueExW(hKey, c_szCommonFilesDirValue, NULL, NULL,
            (LPBYTE)pszDaoPath, &dwSize))
        {
            hr = SHGetSpecialFolderPath(NULL, pszDaoPath, CSIDL_PROGRAM_FILES, FALSE);

            if (SUCCEEDED(hr))
            {
                //
                //  QBBUG -- Common files is localizable.  Make a string resource.
                //
                lstrcatW(pszDaoPath, (PWSTR)SzLoadIds(IDS_OC_COMMON_FILES));

                //
                //  Now set the regvalue
                //
                hr = HrRegSetValueEx(hKey, c_szCommonFilesDirValue, REG_SZ,
                     (const BYTE*)pszDaoPath, sizeof(WCHAR)*dwNumChars);
            }

        }
        RegCloseKey(hKey);
    }

    if (SUCCEEDED(hr))
    {
        //
        //  QBBUG -- should Microsoft shared be a string resource?
        //
        lstrcatW(g_szDaoPath, (PWSTR)SzLoadIds(IDS_OC_MS_SHARED_DAO));
    }

    return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\nccps.cpp ===
//+---------------------------------------------------------------------------
//
// File:     NcCPS.CPP
//
// Module:   NetOC.DLL
//
// Synopsis: Implements the dll entry points required to integrate into
//           NetOC.DLL the installation of the following components.
//
//              NETCPS
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:   a-anasj 9 Mar 1998
//
//+---------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include <iadmw.h>      // Interface header
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines
#include <LOADPERF.H>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "ncatl.h"
#include "resource.h"

#include "nccm.h"

//
//  Define Globals
//
WCHAR g_szProgramFiles[MAX_PATH+1];

//
//  Define Constants
//
static const WCHAR c_szInetRegPath[] = L"Software\\Microsoft\\InetStp";
static const WCHAR c_szWWWRootValue[] = L"PathWWWRoot";
static const WCHAR c_szSSFmt[] = L"%s%s";
static const WCHAR c_szMsAccess[] = L"Microsoft Access";
static const WCHAR c_szOdbcDataSourcesPath[] = L"SOFTWARE\\ODBC\\ODBC.INI\\ODBC Data Sources";
static const WCHAR c_szPbServer[] = L"PBServer";
static const WCHAR c_szOdbcInstKey[] = L"SOFTWARE\\ODBC\\ODBCINST.INI";
static const WCHAR c_szWwwRootPath[] = L"\\Inetpub\\wwwroot";
static const WCHAR c_szWwwRoot[] = L"\\wwwroot";
static const WCHAR c_szPbsRootPath[] = L"\\Phone Book Service";
static const WCHAR c_szPbsBinPath[] = L"\\Phone Book Service\\Bin";
static const WCHAR c_szPbsDataPath[] = L"\\Phone Book Service\\Data";
static const WCHAR c_szOdbcPbserver[] = L"Software\\ODBC\\odbc.ini\\pbserver";
const DWORD c_dwCpsDirID = 123175;  // just must be larger than DIRID_USER = 0x8000;

//+---------------------------------------------------------------------------
//
//  Function:   HrOcCpsPreQueueFiles
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for PhoneBook Server.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 18 Sep 1998
//
//  Notes:
//
HRESULT HrOcCpsPreQueueFiles(PNETOCDATA pnocd)
{
    HRESULT hr = S_OK;

    switch ( pnocd->eit )
    {
    case IT_UPGRADE:
    case IT_INSTALL:
    case IT_REMOVE:

        //  We need to setup the custom DIRID so that CPS will install
        //  to the correct location.  First get the path from the system.
        //
        ZeroMemory(g_szProgramFiles, sizeof(g_szProgramFiles));

        //  This is  a fresh install of CMAK, don't return an error
        //
        hr = SHGetSpecialFolderPath(NULL, g_szProgramFiles, CSIDL_PROGRAM_FILES, FALSE);

        if (SUCCEEDED(hr))
        {
            if (IT_UPGRADE == pnocd->eit)
            {
                hr = HrMoveOldCpsInstall(g_szProgramFiles);
            }

            //  Next Create the CPS Dir ID
            //
            if (SUCCEEDED(hr))
            {
                hr = HrEnsureInfFileIsOpen(pnocd->pszComponentId, *pnocd);
                if (SUCCEEDED(hr))
                {
                    if(!SetupSetDirectoryId(pnocd->hinfFile, c_dwCpsDirID, g_szProgramFiles))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
            }
        }
        break;
    }

    TraceError("HrOcCpsPreQueueFiles", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrMoveOldCpsInstall
//
//  Purpose:    This function moves the old cps directory to the new cps directory
//              location.  Because of the problems with Front Page Extensions and
//              directory permissions we moved our install directory out from under
//              wwwroot to Program Files instead.
//
//  Arguments:
//      pszprogramFiles        [in]
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 26 Jan 1999
//
//  Notes:
//
HRESULT HrMoveOldCpsInstall(PCWSTR pszProgramFiles)
{
    WCHAR szOldCpsLocation[MAX_PATH+1];
    WCHAR szNewCpsLocation[MAX_PATH+1];
    WCHAR szTemp[MAX_PATH+1];
    SHFILEOPSTRUCT fOpStruct;
    HRESULT hr = S_OK;

    if ((NULL == pszProgramFiles) || (L'\0' == pszProgramFiles[0]))
    {
        return E_INVALIDARG;
    }

    //
    //  First, lets build the old CPS location
    //
    hr = HrGetWwwRootDir(szTemp, celems(szTemp));

    if (SUCCEEDED(hr))
    {
        //
        //  Zero the string buffers
        //
        ZeroMemory(szOldCpsLocation, celems(szOldCpsLocation));
        ZeroMemory(szNewCpsLocation, celems(szNewCpsLocation));

        wsprintfW(szOldCpsLocation, c_szSSFmt, szTemp, c_szPbsRootPath);

        //
        //  Now check to see if the old cps location exists
        //
        DWORD dwDirectoryAttributes = GetFileAttributes(szOldCpsLocation);

        //
        //  If we didn't get back -1 (error return code for GetFileAttributes), check to
        //  see if we have a directory.  If so, go ahead and copy the data over.
        //
        if ((-1 != dwDirectoryAttributes) && (dwDirectoryAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            //
            //  Now build the new cps location
            //
            wsprintfW(szNewCpsLocation, c_szSSFmt, pszProgramFiles, c_szPbsRootPath);

            //
            //  Now copy the old files to the new location
            //
            ZeroMemory(&fOpStruct, sizeof(fOpStruct));

            fOpStruct.hwnd = NULL;
            fOpStruct.wFunc = FO_COPY;
            fOpStruct.pTo = szNewCpsLocation;
            fOpStruct.pFrom = szOldCpsLocation;
            fOpStruct.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;

            if (0== SHFileOperation(&fOpStruct))
            {
                //
                //  Now delete the original directory
                //
                fOpStruct.pTo = NULL;
                fOpStruct.wFunc = FO_DELETE;
                if (0 != SHFileOperation(&fOpStruct))
                {
                    hr = S_FALSE;
                }
            }
            else
            {
                //
                //  Note, SHFileOperation isn't guarenteed to return anything sensible here.  We might
                //  get back ERROR_NO_TOKEN or ERROR_INVALID_HANDLE, etc when the directory is just missing.
                //  The following check probably isn't useful anymore because of this but I will leave it just
                //  in case.  Hopefully the file check above will make sure we don't hit this but ...
                //
                DWORD dwError = GetLastError();

                if ((ERROR_FILE_NOT_FOUND == dwError) || (ERROR_PATH_NOT_FOUND == dwError))
                {
                    //
                    //  Then we couldn't find the old dir to move it.  Not fatal.
                    //
                    hr = S_FALSE;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(dwError);
                }
            }
        }
        else
        {
            //
            //  Then we couldn't find the old dir to move it.  Not fatal.
            //
            hr = S_FALSE;        
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetWwwRootDir
//
//  Purpose:    This function retrieves the location of the InetPub\wwwroot dir from the
//              WwwRootDir registry key.
//
//  Arguments:
//      szInetPub               [out]   String Buffer to hold the InetPub dir path
//      uInetPubCount           [in]    number of chars in the output buffer
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 26 Jan 1999
//
//  Notes:
//
HRESULT HrGetWwwRootDir(PWSTR szWwwRoot, UINT uWwwRootCount)
{
    HKEY hKey;
    HRESULT hr = S_OK;

    //
    //  Check input params
    //
    if ((NULL == szWwwRoot) || (0 == uWwwRootCount))
    {
        return E_INVALIDARG;
    }

    //
    //  Set the strings to empty
    //
    szWwwRoot[0] = L'\0';

    //
    //  First try to open the InetStp key and get the wwwroot value.
    //
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szInetRegPath, KEY_READ, &hKey);

    if (SUCCEEDED(hr))
    {
        DWORD dwSize = uWwwRootCount * sizeof(WCHAR);

        RegQueryValueExW(hKey, c_szWWWRootValue, NULL, NULL, (LPBYTE)szWwwRoot, &dwSize);
        RegCloseKey(hKey);
        hr = S_OK;
    }


    if (L'\0' == szWwwRoot[0])
    {
        //  Well, we didn't get anything from the registry, lets try building the default.
        //
        WCHAR szTemp[MAX_PATH+1];
        if (GetWindowsDirectory(szTemp, MAX_PATH))
        {
            //  Get the drive that the windows dir is on using _tsplitpath
            //
            WCHAR szDrive[_MAX_DRIVE+1];
            _wsplitpath(szTemp, szDrive, NULL, NULL, NULL);

            if (uWwwRootCount > (UINT)(lstrlenW(szDrive) + lstrlenW (c_szWwwRootPath) + 1))
            {
                wsprintfW(szWwwRoot, c_szSSFmt, szDrive, c_szWwwRootPath);
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcCpsOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for PhoneBook Server.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     a-anasj 9 Mar 1998
//
//  Notes:
//
HRESULT HrOcCpsOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr      = S_OK;
    DWORD       dwRet   = 0;
    BOOL        bRet    = FALSE;

    switch (pnocd->eit)
    {
    case IT_INSTALL:
    case IT_UPGRADE:
        {

        // Register MS_Access data source
        //
        dwRet = RegisterPBServerDataSource();
        if ( NULL == dwRet)
        {
            hr = S_FALSE;
        }

        // Load Perfomance Monitor Counters
        //
        bRet = LoadPerfmonCounters();
        if (FALSE == bRet)
        {
            hr = S_FALSE;
        }

        // Create Virtual WWW and FTP roots
        //
        if (IT_UPGRADE == pnocd->eit)
        {
            //
            //  If this is an upgrade, we must first delete the old Virtual Roots
            //  before we can create new ones.
            //
            RemoveCPSVRoots();
        }

        dwRet = CreateCPSVRoots();
        if (NULL == dwRet)
        {
            hr = S_FALSE;
        }

        SetCpsDirPermissions();

        //
        // set additional security permssion to the reg key for ODBC
        //

        PSID pAuthenticatedUsersSid;
        SID_IDENTIFIER_AUTHORITY NTSidAuthority = SECURITY_NT_AUTHORITY;

        AllocateAndInitializeSid (&NTSidAuthority, 1, SECURITY_AUTHENTICATED_USER_RID, 
                                  0, 0, 0, 0, 0, 0, 0, &pAuthenticatedUsersSid);

        //
        //  This function will handle pAuthenticatedUsersSid == NULL
        //
        AddToRegKeySD(c_szOdbcPbserver, 
                      pAuthenticatedUsersSid, 
                      KEY_QUERY_VALUE          |
                        KEY_SET_VALUE          |
                        KEY_CREATE_SUB_KEY     |
                        KEY_ENUMERATE_SUB_KEYS |
                        KEY_NOTIFY             |
                        DELETE                 |
                        READ_CONTROL);

        if (pAuthenticatedUsersSid)
        {
            FreeSid(pAuthenticatedUsersSid);
        }

        }

        break;
    case IT_REMOVE:

        //  Remove the Virtual Directories, so access to the service is stopped.
        //
        RemoveCPSVRoots();
        break;
    }

    TraceError("HrOcCpsOnInstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadPerfmonCounters
//
//  Purpose:    Do whatever is neccessary to make the performance monitor Display the PBServerMonitor counters
//
//  Arguments:
//
//  Returns:    BOOL TRUE if successfull, Not TRUE otherwise.
//
//  Author:     a-anasj Mar 9/1998
//
//  Notes: One of the installation requirements for PhoneBook Server.
//          is to load the perfomance monitor counters that allow PBServerMonitor
//          to report to the user on PhoneBook Server performance.
//          In this function we add the services registry entry first then we
//          call into LoadPerf.Dll to load the counters for us. The order is imperative.
//          I then add other registry entries related to PBServerMonitor.
//

BOOL LoadPerfmonCounters()
{
    WinExec("lodctr.exe CPSSym.ini", SW_HIDE);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterPBServerDataSource
//
//  Purpose:    Registers PBServer.
//
//  Arguments:  None
//
//  Returns:    Win32 error code
//
//  Author:     a-anasj   9 Mar 1998
//
//  Notes:
//  History:    7-9-97 a-frankh Created
//              10/4/97 mmaguire RAID #19906 - Totally restructured to include error handling
//              5-14-98 quintinb removed unnecessary comments and cleaned up the function.
//
BOOL RegisterPBServerDataSource()
{
    DWORD dwRet = 0;

    HKEY hkODBCInst = NULL;
    HKEY hkODBCDataSources = NULL;

    DWORD dwIndex;
    WCHAR szName[MAX_PATH+1];

    __try
    {
        // Open the hkODBCInst RegKey
        //
        dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, c_szOdbcInstKey, &hkODBCInst);
        if((ERROR_SUCCESS != dwRet) || (NULL == hkODBCInst))
        {
            __leave;
        }

        // Look to see the the "Microsoft Access" RegKey is defined
        //  If it is, then set the value of the ODBC Data Sources RegKey below
        //
        dwIndex = 0;
        do
        {
            dwRet = RegEnumKey(hkODBCInst,dwIndex,szName,celems(szName));
            dwIndex++;
        } while ((ERROR_SUCCESS == dwRet) && (NULL == wcsstr(szName, c_szMsAccess)));

        if ( ERROR_SUCCESS != dwRet )
        {
            // We need the Microsoft Access *.mdb driver to work
            // and we could not find it
            //
            __leave;
        }

        // Open the hkODBCDataSources RegKey
        //
        dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, c_szOdbcDataSourcesPath,
            &hkODBCDataSources);

        if( ERROR_SUCCESS != dwRet )
        {
            __leave;
        }

        //
        //  Use the name from the resource for registration purposes.
        //
        //  NOTE: this string is from HKLM\Software\ODBC\ODBCINST.INI\*
        //
        lstrcpy(szName, SzLoadIds(IDS_OC_PB_DSN_NAME));

        // Set values in the hkODBCDataSources key
        //
        dwRet = RegSetValueEx(hkODBCDataSources, c_szPbServer, 0, REG_SZ,
            (LPBYTE)szName, (lstrlenW(szName)+1)*sizeof(WCHAR));

        if( ERROR_SUCCESS != dwRet )
        {
            __leave;
        }

    } // end __try



    __finally
    {
        if (hkODBCInst)
        {
            RegCloseKey (hkODBCInst);
        }

        if (hkODBCDataSources)
        {
            RegCloseKey (hkODBCDataSources);
        }
    }

    return (ERROR_SUCCESS == dwRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateCPSVRoots
//
//  Purpose:    Creates the Virtual Directories required for Phone Book Service.
//
//  Arguments:  None
//
//  Returns:    TRUE if successfull, FALSE otherwise.
//
//  Author:     a-anasj Mar 9/1998
//
//  Notes:
//
BOOL CreateCPSVRoots()
{
    //  QBBUG - Should we make sure the physical paths exist before pointing a virtual root to them?

    WCHAR   szPath[MAX_PATH+1];
    HRESULT hr;

    if (L'\0' == g_szProgramFiles[0])
    {
        return FALSE;
    }

    //  Create the Bindir virtual root
    //
    wsprintfW(szPath, c_szSSFmt, g_szProgramFiles, c_szPbsBinPath);

    hr = AddNewVirtualRoot(www, L"PBServer", szPath);
    if (S_OK != hr)
    {
        return FALSE;
    }

    //  Now we set the Execute access permissions on the PBServer Virtual Root
    //
    PWSTR szVirtDir;
    szVirtDir = L"/LM/W3svc/1/ROOT/PBServer";
    SetVirtualRootAccessPermissions( szVirtDir, MD_ACCESS_EXECUTE | MD_ACCESS_READ );

    //  Create the Data dir virtual roots
    //
    wsprintfW(szPath, c_szSSFmt, g_szProgramFiles, c_szPbsDataPath);
    hr = AddNewVirtualRoot(www, L"PBSData", szPath);
    if (S_OK != hr)
    {
        return FALSE;
    }

    hr = AddNewVirtualRoot(ftp, L"PBSData", szPath);
    if (S_OK != hr)
    {
        return FALSE;
    }

    //  Now we set the Execute access permissions on the PBServer Virtual Root
    //
    szVirtDir = L"/LM/MSFTPSVC/1/ROOT/PBSData";
    SetVirtualRootAccessPermissions(szVirtDir, MD_ACCESS_READ);
    return 1;
}


//+---------------------------------------------------------------------------
//
//  The following are neccessary defines, define guids and typedefs enums
//  they are created for the benefit of AddNewVirtualRoot()
//+---------------------------------------------------------------------------

#define error_leave(x)  goto leave_routine;

#define MY_DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }


MY_DEFINE_GUID(CLSID_MSAdminBase, 0xa9e69610, 0xb80d, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);
MY_DEFINE_GUID(IID_IMSAdminBase, 0x70b51430, 0xb6ca, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);


//+---------------------------------------------------------------------------
//
//  Function:   AddNewVirtualRoot
//
//  Purpose:    Helps create Virtual Roots in the WWW and FTP services.
//
//  Arguments:
//      PWSTR szDirW : Alias of new Virtual Root
//      PWSTR szPathW: Physical Path to wich the new Virtual Root will point
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     a-anasj Mar 9/1998
//
//  Notes:
//
HRESULT AddNewVirtualRoot(e_rootType rootType, PWSTR szDirW, PWSTR szPathW)
{

    HRESULT hr = S_OK;
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    PWSTR szMBPathW;

    if (www == rootType)
    {
        szMBPathW = L"/LM/W3svc/1/ROOT";
    }
    else if (ftp == rootType)
    {
        szMBPathW = L"/LM/MSFTPSVC/1/ROOT";
    }
    else
    {
        //  Unknown root type
        //
        ASSERT(FALSE);
        return S_FALSE;
    }

    if (FAILED(CoInitialize(NULL)))
    {
        return S_FALSE;
    }

    // Create an instance of the metabase object
    hr=::CoCreateInstance(CLSID_MSAdminBase,//CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMeta);
    if (FAILED(hr))
    {
        error_leave("CoCreateInstance");
    }

    // open key to ROOT on website #1 (where all the VDirs live)
    hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         szMBPathW,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         1000,
                         &hMeta);
    if (FAILED(hr))
    {
        error_leave("OpenKey");
    }

    // Add new VDir called szDirW

    hr=pIMeta->AddKey(hMeta, szDirW);

    if (FAILED(hr))
    {
        error_leave("Addkey");
    }

    // Set the physical path for this VDir
    METADATA_RECORD mr;
    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = METADATA_INHERIT ;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;

    mr.dwMDDataLen    = (wcslen(szPathW) + 1) * sizeof(WCHAR);
    mr.pbMDData       = (unsigned char*)(szPathW);

    hr=pIMeta->SetData(hMeta,szDirW,&mr);

    if (FAILED(hr))
    {
        error_leave("SetData");
    }

    //
    // we also need to set the keytype
    //
    ZeroMemory((PVOID)&mr, sizeof(METADATA_RECORD));
    mr.dwMDIdentifier = MD_KEY_TYPE;
    mr.dwMDAttributes = METADATA_INHERIT ;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.pbMDData       = (unsigned char*)(www == rootType? L"IIsWebVirtualDir" : L"IIsFtpVirtualDir");
    mr.dwMDDataLen    = (lstrlenW((PWSTR)mr.pbMDData) + 1) * sizeof(WCHAR);

    hr=pIMeta->SetData(hMeta,szDirW,&mr);

    if (FAILED(hr))
    {
        error_leave("SetData");
    }


    // Call CloseKey() prior to calling SaveData
    pIMeta->CloseKey(hMeta);
    hMeta = NULL;
    // Flush out the changes and close
    hr=pIMeta->SaveData();
    if (FAILED(hr))
    {
        error_leave("SaveData");
    }

leave_routine:
    if (pIMeta)
    {
        if(hMeta)
            pIMeta->CloseKey(hMeta);
        pIMeta->Release();
    }
    CoUninitialize();
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   SetVirtualRootAccessPermissions
//
//  Purpose :   Sets Access Permissions to a Virtual Roots in the WWW service.
//
//  Arguments:
//      PWSTR szVirtDir : Alias of new Virtual Root
//      DWORD   dwAccessPermisions can be any combination of the following
//                   or others defined in iiscnfg.h
//                  MD_ACCESS_EXECUTE | MD_ACCESS_WRITE | MD_ACCESS_READ;
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     a-anasj Mar 18/1998
//
//  Notes:
//
HRESULT SetVirtualRootAccessPermissions(PWSTR szVirtDir, DWORD  dwAccessPermisions)
{

    HRESULT hr = S_OK;                  // com error status
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMeta = NULL;       // handle to metabase

    if (FAILED(CoInitialize(NULL)))
    {
        return S_FALSE;
    }

    // Create an instance of the metabase object
    hr=::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMeta);
    if (FAILED(hr))
    {
        error_leave("CoCreateInstance");
    }

    // open key to ROOT on website #1 (where all the VDirs live)
    hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         szVirtDir,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         1000,
                         &hMeta);
    if (FAILED(hr))
    {
        error_leave("OpenKey");
    }


    // Set the physical path for this VDir
    METADATA_RECORD mr;
    mr.dwMDIdentifier = MD_ACCESS_PERM;
    mr.dwMDAttributes = METADATA_INHERIT ;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = DWORD_METADATA; // this used to be STRING_METADATA, but that was
                                        // the incorrect type and was causing vdir access
                                        // problems.

    // Now, create the access perm
    mr.pbMDData = (PBYTE) &dwAccessPermisions;
    mr.dwMDDataLen = sizeof (DWORD);
    mr.dwMDDataTag = 0;  // datatag is a reserved field.


    hr=pIMeta->SetData(hMeta,
        TEXT ("/"),             // The root of the Virtual Dir we opened above
        &mr);

    if (FAILED(hr))
    {
        error_leave("SetData");
    }

    // Call CloseKey() prior to calling SaveData
    pIMeta->CloseKey(hMeta);
    hMeta = NULL;
    // Flush out the changes and close
    hr=pIMeta->SaveData();
    if (FAILED(hr))
    {
        error_leave("SaveData");
    }

leave_routine:
    if (pIMeta)
    {
        if(hMeta)
            pIMeta->CloseKey(hMeta);
        pIMeta->Release();
    }
    CoUninitialize();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   RemoveCPSVRoots
//
//  Purpose:    Deletes the Virtual Directories required for Phone Book Service.
//
//  Arguments:  None
//
//  Returns:    TRUE if successfull, FALSE otherwise.
//
//  Author:     a-anasj Mar 9/1998
//              quintinb Jan 10/1999  added error checking and replaced asserts with traces
//
//  Notes:
//
BOOL RemoveCPSVRoots()
{
    HRESULT hr;
    HKEY hKey;

    hr = DeleteVirtualRoot(www, L"PBServer");
    if (SUCCEEDED(hr))
    {
        //
        //  Now delete the associated reg key
        //
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters\\Virtual Roots",
            KEY_ALL_ACCESS, &hKey);

        if (SUCCEEDED(hr))
        {
            if (ERROR_SUCCESS == RegDeleteValue(hKey, L"/PBServer"))
            {
                hr = S_OK;
            }
            else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_FALSE;
            }

            RegCloseKey(hKey);
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_FALSE;
        }
    }
    TraceError("RemoveCPSVRoots -- Deleting PBServer Www Vroot", hr);

    hr = DeleteVirtualRoot(www, L"PBSData");
    if (SUCCEEDED(hr))
    {
        //
        //  Now delete the associated reg key
        //
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters\\Virtual Roots",
            KEY_ALL_ACCESS, &hKey);

        if (SUCCEEDED(hr))
        {
            if (ERROR_SUCCESS == RegDeleteValue(hKey, L"/PBSData"))
            {
                hr = S_OK;
            }
            else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_FALSE;
            }

            RegCloseKey(hKey);
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_FALSE;
        }
    }
    TraceError("RemoveCPSVRoots -- Deleting PBSData WWW Vroot", hr);

    hr = DeleteVirtualRoot(ftp, L"PBSData");
    if (SUCCEEDED(hr))
    {
        //
        //  Now delete the associated reg key
        //
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters\\Virtual Roots",
            KEY_ALL_ACCESS, &hKey);

        if (SUCCEEDED(hr))
        {
            if (ERROR_SUCCESS == RegDeleteValue(hKey, L"/PBSData"))
            {
                hr = S_OK;
            }
            else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_FALSE;
            }

            RegCloseKey(hKey);
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_FALSE;
        }
    }
    TraceError("RemoveCPSVRoots -- Deleting PBSData FTP Vroot", hr);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteVirtualRoot
//
//  Purpose:    Deletes a Virtual Root in the WWW or FTP services.
//
//  Arguments:
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     a-anasj Mar 9/1998
//
//  Notes:
//
HRESULT DeleteVirtualRoot(e_rootType rootType, PWSTR szPathW)
{

    HRESULT hr = S_OK;                  // com error status
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    PWSTR szMBPathW;

    if (www == rootType)
    {
        szMBPathW = L"/LM/W3svc/1/ROOT";
    }
    else if (ftp == rootType)
    {
        szMBPathW = L"/LM/MSFTPSVC/1/ROOT";
    }
    else
    {
        //  Unknown root type
        //
        ASSERT(FALSE);
        return S_FALSE;
    }


    if (FAILED(CoInitialize(NULL)))
    {
        return S_FALSE;
        //error_leave("CoInitialize");
    }

    // Create an instance of the metabase object
    hr=::CoCreateInstance(CLSID_MSAdminBase,//CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMeta);
    if (FAILED(hr))
    {
        error_leave("CoCreateInstance");
    }

    // open key to ROOT on website #1 (where all the VDirs live)
    hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         szMBPathW,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         1000,
                         &hMeta);
    if (FAILED(hr))
    {
        error_leave("OpenKey");
    }

    // Add new VDir called szDirW

    hr=pIMeta->DeleteKey(hMeta, szPathW);

    if (FAILED(hr))
    {
        error_leave("DeleteKey");
    }

    // Call CloseKey() prior to calling SaveData
    pIMeta->CloseKey(hMeta);
    hMeta = NULL;
    // Flush out the changes and close
    hr=pIMeta->SaveData();
    if (FAILED(hr))
    {
        error_leave("SaveData");
    }

leave_routine:
    if (pIMeta)
    {
        if(hMeta)
            pIMeta->CloseKey(hMeta);
        pIMeta->Release();
    }
    CoUninitialize();
    return hr;
}

HRESULT SetDirectoryAccessPermissions(PWSTR pszFile, ACCESS_MASK AccessRightsToModify,
                                      ACCESS_MODE fAccessFlags, PSID pSid)
{
    if (!pszFile && !pSid)
    {
        return E_INVALIDARG;
    }

    EXPLICIT_ACCESS         AccessEntry = {0};
    PSECURITY_DESCRIPTOR    pSecurityDescriptor = NULL;
    PACL                    pOldAccessList = NULL;
    PACL                    pNewAccessList = NULL;
    DWORD                   dwRes;

    // Get the current DACL information from the object.

    dwRes = GetNamedSecurityInfo(pszFile,                        // name of the object
                                 SE_FILE_OBJECT,                 // type of object
                                 DACL_SECURITY_INFORMATION,      // type of information to set
                                 NULL,                           // provider is Windows NT
                                 NULL,                           // name or GUID of property or property set
                                 &pOldAccessList,                // receives existing DACL information
                                 NULL,                           // receives existing SACL information
                                 &pSecurityDescriptor);          // receives a pointer to the security descriptor

    if (ERROR_SUCCESS == dwRes)
    {
        //
        // Initialize the access list entry.
        //
        BuildTrusteeWithSid(&(AccessEntry.Trustee), pSid);
        
        AccessEntry.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        AccessEntry.grfAccessMode = fAccessFlags;   

        //
        // Set provider-independent standard rights.
        //
        AccessEntry.grfAccessPermissions = AccessRightsToModify;

        //
        // Build an access list from the access list entry.
        //

        dwRes = SetEntriesInAcl(1, &AccessEntry, pOldAccessList, &pNewAccessList);

        if (ERROR_SUCCESS == dwRes)
        {
            //
            // Set the access-control information in the object's DACL.
            //
            dwRes = SetNamedSecurityInfo(pszFile,                     // name of the object
                                         SE_FILE_OBJECT,              // type of object
                                         DACL_SECURITY_INFORMATION,   // type of information to set
                                         NULL,                        // pointer to the new owner SID
                                         NULL,                        // pointer to the new primary group SID
                                         pNewAccessList,              // pointer to new DACL
                                         NULL);                       // pointer to new SACL
        }
    }

    //
    // Free the returned buffers.
    //
    if (pNewAccessList)
    {
        LocalFree(pNewAccessList);
    }

    if (pSecurityDescriptor)
    {
        LocalFree(pSecurityDescriptor);
    }

    //
    //  If the system is using FAT instead of NTFS, then we will get the Invalid Acl error.
    //
    if (ERROR_INVALID_ACL == dwRes)
    {
        return S_FALSE;
    }
    else
    {
        return HRESULT_FROM_WIN32(dwRes);
    }
}

void SetCpsDirPermissions()
{
    WCHAR szPath[MAX_PATH+1];
    HRESULT hr;

    //
    //  Create the SID for the Everyone Account (World account)
    //

    PSID pWorldSid;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;

    BOOL bRet = AllocateAndInitializeSid (&WorldSidAuthority, 1, SECURITY_WORLD_RID, 
                              0, 0, 0, 0, 0, 0, 0, &pWorldSid);

    if (bRet && pWorldSid )
    {
        const ACCESS_MASK c_Write = FILE_WRITE_ATTRIBUTES | FILE_WRITE_DATA | FILE_WRITE_EA | 
                                     FILE_ADD_SUBDIRECTORY | FILE_ADD_FILE | 
                                     FILE_DELETE_CHILD | FILE_APPEND_DATA;

        const ACCESS_MASK c_Read = FILE_READ_ATTRIBUTES | FILE_READ_DATA | FILE_READ_EA |
                                    FILE_LIST_DIRECTORY | SYNCHRONIZE | READ_CONTROL;

        const ACCESS_MASK c_Execute = FILE_EXECUTE | FILE_TRAVERSE;

        ACCESS_MASK arCpsRoot= c_Read;
                                  
        ACCESS_MASK arCpsBin=  c_Read | c_Execute;

        ACCESS_MASK arCpsData= c_Read | c_Write;
                                    
        ACCESS_MODE fAccessFlags = GRANT_ACCESS;

        //
        //  Set the Data Dir access permissions
        //
        wsprintf(szPath, c_szSSFmt, g_szProgramFiles, c_szPbsDataPath);
        hr = SetDirectoryAccessPermissions(szPath, arCpsData, fAccessFlags, pWorldSid);
        TraceError("SetCpsDirPermissions -- Data dir", hr);

        //
        //  Set the Bin Dir access permissions
        //
        wsprintf(szPath, c_szSSFmt, g_szProgramFiles, c_szPbsBinPath);
        hr = SetDirectoryAccessPermissions(szPath, arCpsBin, fAccessFlags, pWorldSid);
        TraceError("SetCpsDirPermissions -- Bin dir", hr);

        //
        //  Set the Root Dir access permissions
        //
        wsprintf(szPath, c_szSSFmt, g_szProgramFiles, c_szPbsRootPath);
        hr = SetDirectoryAccessPermissions(szPath, arCpsRoot, fAccessFlags, pWorldSid);
        TraceError("SetCpsDirPermissions -- Root dir", hr);

        FreeSid(pWorldSid);
    }
}

DWORD AddToRegKeySD(PCWSTR pszRegKeyName, PSID pGroupSID, DWORD dwAccessMask)
{
#define MAX_DOMAIN_LEN  80

    PSECURITY_DESCRIPTOR pRelSD = NULL;
    PSECURITY_DESCRIPTOR pAbsSD = NULL;
    DWORD   cbSID;
    SID_NAME_USE snuGroup;
    DWORD   dwDomainSize;
    WCHAR   szDomainName[MAX_DOMAIN_LEN];

    PACL  pDACL;

    DWORD  dwSDLength = 0;
    DWORD  dwSDRevision;
    DWORD  dwDACLLength = 0;

    SECURITY_DESCRIPTOR_CONTROL sdcSDControl;

    PACL  pNewDACL  = NULL;
    DWORD  dwAddDACLLength = 0;

    BOOL  fHasDACL  = FALSE;
    BOOL  fDACLDefaulted = FALSE;

    ACCESS_ALLOWED_ACE  *pDACLAce;

    DWORD  dwError = 0;

    DWORD  i;


    DWORD dwcSDLength;    // Security descriptor length

    if (!pszRegKeyName || !pGroupSID)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // handle for security registry key
    HKEY  hSecurityRegKey = NULL;

    // now open reg key to set security
    dwError = RegOpenKeyEx (HKEY_LOCAL_MACHINE, pszRegKeyName, 0, KEY_ALL_ACCESS, &hSecurityRegKey);

    if (dwError)
    {
        goto ErrorExit;
    }

    // get length of security descriptor
    dwError = RegQueryInfoKey (hSecurityRegKey, NULL, NULL, NULL, NULL, 
                               NULL, NULL, NULL, NULL, NULL, &dwcSDLength, NULL);
    if (dwError)
    {
        goto ErrorExit;
    }

    // get SD memory
    pRelSD = (PSECURITY_DESCRIPTOR) LocalAlloc (LPTR, (UINT)dwcSDLength);

    // first get the self-relative SD

    dwError = RegGetKeySecurity (hSecurityRegKey, 
                                 (SECURITY_INFORMATION)(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION), 
                                 pRelSD, &dwcSDLength);
    if (dwError)
    {
        goto ErrorExit;
    }

    // check if SD is good

    if (!pRelSD || !IsValidSecurityDescriptor (pRelSD))
    {
        dwError = GetLastError();
        goto ErrorExit;
    }

    // get SD control bits
    if (!GetSecurityDescriptorControl (pRelSD, (PSECURITY_DESCRIPTOR_CONTROL)&sdcSDControl,
                                       (LPDWORD) &dwSDRevision))
    {
        dwError = GetLastError();
        goto ErrorExit;
    }

    // check if DACL is present
    if (SE_DACL_PRESENT & sdcSDControl)
    {
        // get dacl

        if (!GetSecurityDescriptorDacl (pRelSD, (LPBOOL)&fHasDACL, (PACL *) &pDACL, 
                                        (LPBOOL) &fDACLDefaulted))
        {
            dwError = GetLastError();
            goto ErrorExit;
        }

        // get dacl length
        dwDACLLength = pDACL->AclSize;

        // get length of new DACL

        dwAddDACLLength = sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD) + GetLengthSid (pGroupSID);
    }
    else
    {
        // get length of new DACL

        dwAddDACLLength = sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) - 
                          sizeof (DWORD) + GetLengthSid (pGroupSID);
    }

    // get memory needed for new DACL

    pNewDACL = ( PACL) LocalAlloc (LPTR, dwDACLLength + dwAddDACLLength);
    if (!pNewDACL)
    {
        dwError = GetLastError();
        goto ErrorExit;
    }

    // get the sd length
    dwSDLength = GetSecurityDescriptorLength (pRelSD);

    // get memory for new SD

    pAbsSD = ( PSECURITY_DESCRIPTOR)LocalAlloc ( LPTR, dwSDLength + dwAddDACLLength);
    if (!pAbsSD)
    {
        dwError = GetLastError();
        goto ErrorExit;
    }

    // change self-relative SD to absolute by making new SD

    if (!InitializeSecurityDescriptor (pAbsSD, SECURITY_DESCRIPTOR_REVISION))
    {
        dwError = GetLastError();
        goto ErrorExit;
    }

    // init new DACL

    if (!InitializeAcl (pNewDACL, dwDACLLength + dwAddDACLLength, ACL_REVISION))
    {
        dwError = GetLastError();
        goto ErrorExit;
    }

    // now add in all of the ACEs into the new DACL (if org DACL is there)
    if (SE_DACL_PRESENT & sdcSDControl)
    {
        for (i = 0; i < pDACL->AceCount; i++)
        {
            // get ace from original dacl
            if (!GetAce (pDACL, i, (LPVOID *) &pDACLAce))
            {
                dwError = GetLastError();
                goto ErrorExit;
            }

            // check if group sid is already there.  If so, skip it(don't copy)
            if (EqualSid ((PSID)&(pDACLAce->SidStart), pGroupSID))
            {
                continue;
            }

            // now add ace to new dacl

            if (!AddAccessAllowedAce (pNewDACL, ACL_REVISION, pDACLAce->Mask, 
                                      (PSID)&(pDACLAce->SidStart)))
            {
                dwError = GetLastError();
                goto ErrorExit;
            }
        }
    }

    // now add new ACE to new DACL
    if (!AddAccessAllowedAce (pNewDACL, ACL_REVISION, dwAccessMask, pGroupSID))
    {
        dwError = GetLastError();
        goto ErrorExit;
    }

    // check if everything went ok
    if (!IsValidAcl (pNewDACL))
    {
        dwError = GetLastError();
        goto ErrorExit;
    }

    // now set security descriptor DACL

    if (!SetSecurityDescriptorDacl (pAbsSD, TRUE, pNewDACL, fDACLDefaulted))
    {
        dwError = GetLastError();
        goto ErrorExit;
    }

    // check if everything went ok
    if (!IsValidSecurityDescriptor (pAbsSD))
    {
        dwError = GetLastError();
        goto ErrorExit;
    }

    // now set the reg key security (this will overwrite any existing security)

    dwError = RegSetKeySecurity (hSecurityRegKey, 
                                 (SECURITY_INFORMATION)(DACL_SECURITY_INFORMATION), pAbsSD);
    
ErrorExit:

    if (hSecurityRegKey)
    {
        RegCloseKey (hSecurityRegKey);
    }

    if (pRelSD)
    {
        LocalFree(pRelSD);
    }
    
    if (pAbsSD)
    {
        LocalFree (pAbsSD);
    }
    
    if (pNewDACL)
    {
        LocalFree (pNewDACL);
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\ncdhcps.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C D H C P S . C P P
//
//  Contents:   Installation support for DHCP Server
//
//  Notes:
//
//  Author:     jeffspr     13 May 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncdhcps.h"
#include "ncreg.h"
#include "ncsvc.h"
#include "netoc.h"
#include "ncnetcfg.h"
#include "netcfgp.h"
#include "ncmisc.h"
#include "netcfgn.h"

extern const WCHAR c_szInfId_MS_DHCPServer[];

static const WCHAR c_szDHCPServerParamPath[]    = L"System\\CurrentControlSet\\Services\\DHCPServer\\Parameters";

//$ REVIEW (jeffspr) 13 May 1997: These obviously need to be localized.
static const WCHAR      c_szDisplayName[]   = L"DHCP Server";
static const WCHAR      c_szManufacturer[]  = L"Microsoft";
static const WCHAR      c_szProduct[]       = L"DHCPServer";

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallDHCPServerNotifyObject
//
//  Purpose:    Handles the installation of DHCP Server on behalf of the DHCP
//              Server optional component. Calls into the INetCfg interface
//              to do the install.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     jeffspr   13 May 1997
//
//  Notes:
//
HRESULT HrInstallDHCPServerNotifyObject(PNETOCDATA pnocd)
{
    HRESULT                 hr          = S_OK;
    INetCfg *               pnc         = NULL;
    INetCfgComponent*       pncc        = NULL;
    INetCfgComponentSetup*  pnccSetup   = NULL;

    hr = HrOcGetINetCfg(pnocd, TRUE, &pnc);
    if (SUCCEEDED(hr))
    {
        NETWORK_INSTALL_PARAMS  nip = {0};

        nip.dwSetupFlags = FInSystemSetup() ? NSF_PRIMARYINSTALL :
                                              NSF_POSTSYSINSTALL;
        Assert(pnocd);

        TraceTag(ttidNetOc, "Installing DHCP Server notify object");
        hr = HrInstallComponentOboUser(
            pnc,
            &nip,
            GUID_DEVCLASS_NETSERVICE,
            c_szInfId_MS_DHCPServer,
            &pncc);
        if (SUCCEEDED(hr))
        {
            TraceTag(ttidNetOc, "QI'ing INetCfgComponentPrivate from DHCP pncc");

            // Need to query for the private component interface which
            // gives us access to the notify object.
            //
            INetCfgComponentPrivate* pnccPrivate = NULL;
            hr = pncc->QueryInterface(
                    IID_INetCfgComponentPrivate,
                    reinterpret_cast<void**>(&pnccPrivate));
            if (S_OK == hr)
            {
                TraceTag(ttidNetOc, "Getting notify object INetCfgComponentSetup from pnccSetup");

                // Query the notify object for its setup interface.
                // If it doesn't support it, that's okay, we can continue.
                //
                hr = pnccPrivate->QueryNotifyObject(
                        IID_INetCfgComponentSetup,
                        (void**) &pnccSetup);
                if (S_OK == hr)
                {
                    TraceTag(ttidNetOc, "Calling pnccSetup->ReadAnswerFile()");

                    (VOID) pnccSetup->ReadAnswerFile(g_ocmData.sic.SetupData.UnattendFile, pnocd->pszSection);

                    hr = pnc->Apply();

                    ReleaseObj(pnccSetup);
                }

                ReleaseObj(pnccPrivate);
            }

            ReleaseObj(pncc);
        }

        (VOID) HrUninitializeAndReleaseINetCfg(TRUE, pnc, TRUE);
    }

    TraceError("HrInstallDHCPServerNotifyObject", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveDHCPServerNotifyObject
//
//  Purpose:    Handles the removal of the DHCP Server on behalf of the DHCP
//              Server optional component. Calls into the INetCfg interface
//              to do the actual removal.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     jeffspr   13 Jun 1997
//
//  Notes:
//
HRESULT HrRemoveDHCPServerNotifyObject(PNETOCDATA pnocd)
{
    HRESULT     hr  = S_OK;
    INetCfg *   pnc = NULL;

    hr = HrOcGetINetCfg(pnocd, TRUE, &pnc);
    if (SUCCEEDED(hr))
    {
        // Ignore the return from this. This is purely to remove the
        // spurious user refcount from NT4 to NT5 upgrade. This will
        // likely fail when removing a fresh install of DHCP Server.
        //
        hr = HrRemoveComponentOboUser(
            pnc,
            GUID_DEVCLASS_NETSERVICE,
            c_szInfId_MS_DHCPServer);

        if (SUCCEEDED(hr))
        {
            hr = pnc->Apply();
        }

        (VOID) HrUninitializeAndReleaseINetCfg(TRUE, pnc, TRUE);
    }

    TraceError("HrRemoveDHCPServerNotifyObject", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetDhcpServiceRecoveryOption
//
//  Purpose:    Sets the recovery options for the DHCPServer service
//
//  Arguments:
//      pnocd [in]  Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     danielwe   26 May 1999
//
//  Notes:
//
HRESULT HrSetDhcpServiceRecoveryOption(PNETOCDATA pnocd)
{
    CServiceManager     sm;
    CService            service;
    HRESULT             hr = S_OK;

    SC_ACTION   sra [4] =
    {
        { SC_ACTION_RESTART, 15*1000 }, // restart after 15 seconds
        { SC_ACTION_RESTART, 15*1000 }, // restart after 15 seconds
        { SC_ACTION_RESTART, 15*1000 }, // restart after 15 seconds
        { SC_ACTION_NONE,    30*1000 },
    };

    SERVICE_FAILURE_ACTIONS sfa =
    {
        60 * 60,        // dwResetPeriod is 1 hr
        L"",            // no reboot message
        L"",            // no command to execute
        4,              // 3 attempts to restart the server and stop after that
        sra
    };

    hr = sm.HrOpenService(&service, L"DHCPServer");
    if (S_OK == hr)
    {
        hr = service.HrSetServiceRestartRecoveryOption(&sfa);
    }

    TraceError("HrSetDhcpServiceRecoveryOption", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallDHCPServer
//
//  Purpose:    Called when DHCP Server is being installed. Handles all of the
//              additional installation for DHCPS beyond that of the INF file.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     jeffspr     13 May 1997
//
//  Notes:
//
HRESULT HrInstallDHCPServer(PNETOCDATA pnocd)
{
    HRESULT         hr = S_OK;
    CServiceManager sm;
    CService        srv;

    Assert(pnocd);

    hr = HrHandleStaticIpDependency(pnocd);
    if (SUCCEEDED(hr))
    {
        hr = HrInstallDHCPServerNotifyObject(pnocd);
        if (SUCCEEDED(hr))
        {
            hr = HrSetDhcpServiceRecoveryOption(pnocd);
        }
    }

    TraceError("HrInstallDHCPServer", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveDHCPServer
//
//  Purpose:    Handles additional removal requirements for DHCP Server
//              component.
//
//      hwnd [in]   Parent window for displaying UI.
//      poc  [in]   Pointer to optional component being installed.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     jeffspr     13 May 1997
//
//  Notes:
//
HRESULT HrRemoveDHCPServer(PNETOCDATA pnocd)
{
    Assert(pnocd);

    // Get the path to the database files from the regsitry.
    // Important to do this before removing the component because
    // the registry locations get removed when removing the component.
    //
    tstring strDatabasePath;
    tstring strBackupDatabasePath;

    HKEY hkeyParams;
    HRESULT hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        c_szDHCPServerParamPath,
                        KEY_READ,
                        &hkeyParams);
    if (SUCCEEDED(hr))
    {
        (VOID) HrRegQueryExpandString (
                    hkeyParams,
                    L"DatabasePath",
                    &strDatabasePath);

        (VOID) HrRegQueryExpandString (
                    hkeyParams,
                    L"BackupDatabasePath",
                    &strBackupDatabasePath);

        RegCloseKey (hkeyParams);
    }

    // Remove DHCP server.
    //
    hr = HrRemoveDHCPServerNotifyObject(pnocd);

    if (SUCCEEDED(hr) &&
        !(strDatabasePath.empty() && strBackupDatabasePath.empty()))
    {
        (VOID) HrDeleteFileSpecification (
                    L"*.mdb",
                    strDatabasePath.c_str());

        (VOID) HrDeleteFileSpecification (
                    L"*.log",
                    strDatabasePath.c_str());

        (VOID) HrDeleteFileSpecification (
                    L"*.mdb",
                    strBackupDatabasePath.c_str());

        (VOID) HrDeleteFileSpecification (
                    L"*.log",
                    strBackupDatabasePath.c_str());
    }

    TraceError("HrRemoveDHCPServer", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtDHCPServer
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     danielwe   17 Sep 1998
//
//  Notes:
//
HRESULT HrOcExtDHCPServer(PNETOCDATA pnocd, UINT uMsg,
                          WPARAM wParam, LPARAM lParam)
{
    HRESULT     hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_POST_INSTALL:
        hr = HrOcDhcpOnInstall(pnocd);
        break;
    }

    TraceError("HrOcExtDHCPServer", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcDhcpOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for DHCP Server
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     jeffspr     13 May 1997
//
//  Notes:
//
HRESULT HrOcDhcpOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;

    switch(pnocd->eit)
    {
        // Install DHCP
        case IT_INSTALL:
            hr = HrInstallDHCPServer(pnocd);
            break;

        // Remove DHCP
        case IT_REMOVE:
            hr = HrRemoveDHCPServer(pnocd);
            break;

        case IT_UPGRADE:
            hr = HrSetDhcpServiceRecoveryOption(pnocd);
            break;
    }

    TraceError("HrOcDhcpOnInstall", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\ncias.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       N C I A S . H
//
//  Contents:   Installation support for IAS service
//
//  Notes:
//
//  Author:     tperraut    02/22/1999
//
//----------------------------------------------------------------------------

#ifndef _NCIAS_H_
#define _NCIAS_H_

#pragma once
#include "netoc.h"

HRESULT HrOcExtIAS(
                   PNETOCDATA pnocd, 
                   UINT uMsg,
                   WPARAM wParam, 
                   LPARAM lParam
                  );

HRESULT HrOcIASUpgrade(const PNETOCDATA pnocd);

HRESULT HrOcIASDelete(const PNETOCDATA pnocd);

HRESULT HrOcIASInstallCleanRegistry(const PNETOCDATA pnocd);

HRESULT HrOcIASBackupMdb(const PNETOCDATA pnocd);

HRESULT HrOcIASPreInf(const PNETOCDATA pnocd);

HRESULT HrOcIASPostInstall(const PNETOCDATA pnocd);

HRESULT HrOcIASRetrieveMDBNames(
                                    tstring* pstrOriginalName, 
                                    tstring* pstrBackupName
                               );

#endif // _NCIAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\ncsfm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S F M . H
//
//  Contents:   Installation support for Services for Macintosh.
//
//  Notes:
//
//  Author:     danielwe   5 May 1997
//
//----------------------------------------------------------------------------

#pragma once

#include "netoc.h"

BOOL FContainsUAMVolume(WCHAR chDrive);
HRESULT HrGetFirstPossibleUAMDrive(WCHAR *pchDriveLetter);
HRESULT HrInstallSFM(PNETOCDATA pnocd);
HRESULT HrCreateDirectory(PCWSTR pszDir);
HRESULT HrSetupUAM(PWSTR pszPath);
HRESULT HrRemoveSFM(PNETOCDATA pnocd);
HRESULT HrOcSfmOnQueryChangeSelState(PNETOCDATA pnocd, BOOL fShowUi);
HRESULT HrOcSfmOnInstall(PNETOCDATA pnocd);
HRESULT HrOcExtSFM(PNETOCDATA pnocd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT HrDeleteOldFolders(PCWSTR pszUamPath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\ncias.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       N C I A S . C P P
//
//  Contents:   Installation support for IAS service
//
//  Notes:
//
//  Author:     tperraut    02/22/1999
// 
//  Revision:  tperraut   01/19/2000 bugs 444353, 444354, 444355
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "netoc.h"
#include "ncreg.h"

#include "ncias.h"
#include "ncstring.h"

#include "userenv.h"

static const char   c_szIASRegisterFunctionName[]   = "IASDirectoryRegisterService";
static const char   c_szIASUnRegisterFunctionName[] = "IASDirectoryUnregisterService";
static const WCHAR  c_szIASDllName[]                = L"ias.dll";



//+---------------------------------------------------------------------------
//
//  Function:   HrOcIASRegisterActiveDirectory
//
//  Purpose:   Try to register IAS in the Active Directory 
//             if the computer is part of a Win2k domain... 
//
//  Arguments:
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Notes:
//
//  Author: Thierry Perraut (tperraut)
//
HRESULT HrOcIASUnRegisterActiveDirectory()
{
    typedef INT_PTR (WINAPI *UNREGISTER_IAS_ACTIVE_DIRECTORY)();

    UNREGISTER_IAS_ACTIVE_DIRECTORY   pfnUnRegisterIASActiveDirectory;
    
    ///////////////////
    // Load ias.dll
    ///////////////////
    HMODULE         hmod;
    HRESULT         hr = HrLoadLibAndGetProc (      
                                c_szIASDllName,
                                c_szIASUnRegisterFunctionName,
                                &hmod,
                                &pfnUnRegisterIASActiveDirectory
                             );
    if (S_OK == hr)
    {
        // fix bug 444354
        // pfnUnRegisterIASActiveDirectory not NULL here
        if (!FAILED (CoInitialize(NULL)))
        {
            LONG lresult = pfnUnRegisterIASActiveDirectory();

            if (ERROR_SUCCESS != lresult)
            {
                hr = S_OK; //not a fatal error, should be ignored
            }
            CoUninitialize();
        }

        FreeLibrary(hmod);
    }

    // Errors ignored
    hr = S_OK;
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOcIASUnRegisterActiveDirectory
//
//  Purpose:   Try to remove IAS from the Active Directory 
//             if the computer is part of a Win2k domain... 
//
//  Arguments:
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Notes:
//
//  Author: Thierry Perraut (tperraut)
//
HRESULT HrOcIASRegisterActiveDirectory()
{
    typedef INT_PTR (WINAPI *REGISTER_IAS_ACTIVE_DIRECTORY)();

    REGISTER_IAS_ACTIVE_DIRECTORY   pfnRegisterIASActiveDirectory;
    
    ///////////////////
    // Load ias.dll
    ///////////////////
    HMODULE         hmod;
    HRESULT         hr = HrLoadLibAndGetProc (      
                                c_szIASDllName,
                                c_szIASRegisterFunctionName,
                                &hmod,
                                &pfnRegisterIASActiveDirectory
                             );
    if (S_OK == hr)
    {
        // Fix bug 444353
        // pfnRegisterIASActiveDirectory not NULL here
        if (!FAILED (CoInitialize(NULL)))
        {

            LONG lresult = pfnRegisterIASActiveDirectory();

            if (ERROR_SUCCESS != lresult)
            {
                hr = S_OK; //not a fatal error, should be ignored
            }  
            CoUninitialize();
        }

        FreeLibrary(hmod);
    }

    // Errors ignored
    hr = S_OK;
    return hr;
}


HRESULT HrOcIASDisableLMAuthentication()
{
   static const WCHAR IASLMAuthKey[] = L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Policy";
   static const WCHAR IASLMAuthValue[] = L"Allow LM Authentication";

   HKEY key = NULL;

   HRESULT hr = HrRegOpenKeyEx(
                   HKEY_LOCAL_MACHINE,
                   IASLMAuthKey,
                   KEY_SET_VALUE | KEY_EXECUTE | KEY_QUERY_VALUE,
                   &key
                   );
   if (SUCCEEDED(hr))
   {
      hr = HrRegQueryValueEx (
              key,
              IASLMAuthValue,
              NULL,
              NULL,
              NULL
              );

      if (FAILED(hr))
      {
         DWORD value = 0;

         // No such value: create it
         hr = HrRegSetValueEx(
                 key,
                 IASLMAuthValue,
                 REG_DWORD,
                 reinterpret_cast<BYTE*>(&value),
                 sizeof(value)
                 );
      }

      RegSafeCloseKey(key);
   }

   hr = S_OK;
   return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOcIASPreInf
//
//  Purpose:    Called when IAS service is being installed/upgraded/removed.
//              Called before the processing of the INF file
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Notes:
//
//  Author: Thierry Perraut (tperraut)
//
HRESULT HrOcIASPreInf(const PNETOCDATA pnocd)
{ 
    HRESULT         hr;
    
    switch(pnocd->eit)
    {
    case IT_INSTALL:
        {
            // Place holder 
            hr = S_OK;
            break;
        }
    case IT_REMOVE:
        {
            // Place holder 
            hr = S_OK;
            break;
        }
    case IT_UPGRADE:
        {
            // Place holder 
            hr = S_OK;
            break;
        }
    default:
        {
            hr = S_OK; //  some new messages should not be seen as errors 
        }
    }

    TraceError("HrOcIASPreInf", hr); 
    return      hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOcIASPostInstall
//
//  Purpose:    Called when IAS service is being installed/upgraded/removed.
//              Called after the processing of the INF file
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Notes:
//
//  Author: Thierry Perraut (tperraut)
//
HRESULT HrOcIASPostInstall(const PNETOCDATA pnocd)
{ 
    HRESULT             hr;
    
    switch(pnocd->eit)
    {
    case IT_INSTALL:
        {
            // Disable LM AUthentication on clean installs
            hr = HrOcIASDisableLMAuthentication();
            // ignore the result

            // call the Active Directory registration code here
            hr = HrOcIASRegisterActiveDirectory();
            break;
        }
    case IT_REMOVE:
        {
            // call the Active Directory clean code here
            hr = HrOcIASUnRegisterActiveDirectory();
            break;
        }
    case IT_UPGRADE:
        {
            hr = S_OK;
            break;
        }
    default:
        {
            hr = S_OK; //  some new messages should not be seen as errors 
        }
    }

    TraceError("HrOcIASPostInstall", hr); 
    return      hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtIAS
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     tperraut    02/22/1999
//
//  Notes:
//
HRESULT HrOcExtIAS(PNETOCDATA pnocd, UINT uMsg,
                   WPARAM wParam, LPARAM lParam)
{
    HRESULT         hr;
    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_PRE_INF:
        {
            hr = HrOcIASPreInf(pnocd);
            break;
        }
    case NETOCM_POST_INSTALL:
        {
            hr = HrOcIASPostInstall(pnocd);
            break;
        }
    default:
        {
            hr = S_OK; //  some new messages should not be seen as errors 
        }
    }

    TraceError("HrOcExtIAS", hr);
    return      hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\ncsfm.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S F M . C P P
//
//  Contents:   Installation support for Services for Macintosh.
//
//  Notes:
//
//  Author:     danielwe   5 May 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "ncatlui.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncsfm.h"
#include "ncui.h"
#include "netoc.h"
#include "resource.h"
#include "sfmsec.h"
#include "macfile.h"

extern const WCHAR      c_szBackslash[];

static const WCHAR      c_szNTFS[]          = L"NTFS";
static const WCHAR      c_szColonBackslash[]= L":\\";

// These will have %windir%\system32\ prepended to them
static const WCHAR      c_szSrcRSCFile[]    = L"SFMUAM.RSC";
static const WCHAR      c_szSrcRSCFile5[]   = L"SFMUAM5.RSC";
static const WCHAR      c_szSrcIFOFile[]    = L"SFMUAM.IFO";
static const WCHAR      c_szSrcIFOFile5[]   = L"SFMUAM5.IFO";
static const WCHAR      c_szSrcTXTFile[]    = L"SFMUAM.TXT";
static const WCHAR      c_szSrcRSCUamInst[] = L"UAMINST.RSC";
static const WCHAR      c_szSrcIFOUamInst[] = L"UAMINST.IFO";

// These will have UAM path prepended to them
static const WCHAR      c_szDstRSCFile[]    = L"\\%s\\MS UAM:Afp_Resource";
static const WCHAR      c_szDstRSCFile5[]   = L"\\%s\\MS UAM 5.0:Afp_Resource";
static const WCHAR      c_szDstIFOFile[]    = L"\\%s\\MS UAM:Afp_AfpInfo";
static const WCHAR      c_szDstIFOFile5[]   = L"\\%s\\MS UAM 5.0:Afp_AfpInfo";
static const WCHAR      c_szDstTXTFile[]    = L"\\ReadMe.UAM";
static const WCHAR      c_szDstRSCUamInst[] = L"\\%s:Afp_Resource";
static const WCHAR      c_szDstIFOUamInst[] = L"\\%s:Afp_AfpInfo";

// registry constants
static const WCHAR      c_szRegKeyVols[]    = L"System\\CurrentControlSet\\Services\\MacFile\\Parameters\\Volumes";
static const WCHAR      c_szRegKeyParams[]  = L"System\\CurrentControlSet\\Services\\MacFile\\Parameters";
static const WCHAR      c_szPath[]          = L"PATH=";
static const WCHAR      c_szRegValServerOptions[] = L"ServerOptions";

//+---------------------------------------------------------------------------
//
//  Function:   FContainsUAMVolume
//
//  Purpose:    Determines whether the given drive letter contains a UAM
//              volume.
//
//  Arguments:
//      chDrive [in]    Drive letter to search.
//
//  Returns:    TRUE if drive contains a UAM volume, FALSE if not.
//
//  Author:     danielwe   22 May 1997
//
//  Notes:
//
BOOL FContainsUAMVolume(WCHAR chDrive)
{
    tstring         strUAMPath;
    WIN32_FIND_DATA w32Data;
    BOOL            frt = FALSE;
    HANDLE          hfind;

    strUAMPath = chDrive;
    strUAMPath += c_szColonBackslash;
    strUAMPath += SzLoadIds(IDS_OC_SFM_VOLNAME);

    hfind = FindFirstFile(strUAMPath.c_str(), &w32Data);
    if (hfind != INVALID_HANDLE_VALUE)
    {
        // Found a volume!
        frt = TRUE;
        FindClose(hfind);
    }

    return frt;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetFirstPossibleUAMDrive
//
//  Purpose:    Obtains the first fixed or removable drive's drive letter
//              that has the NTFS file system installed on it and/or already
//              has a UAM volume on it.
//
//  Arguments:
//      pchDriveLetter [out]    Drive letter returned. If no drive is found,
//                              this is the NUL character.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT HrGetFirstPossibleUAMDrive(WCHAR *pchDriveLetter)
{
    HRESULT     hr = S_OK;
    WCHAR       mszDrives[1024];

    Assert(pchDriveLetter);

    *pchDriveLetter = 0;

    if (GetLogicalDriveStrings(celems(mszDrives), mszDrives))
    {
        PCWSTR      pchDrive;
        WCHAR       szFileSystem[64];
        DWORD       dwType;

        pchDrive = mszDrives;
        while (*pchDrive)
        {
            // pchDrive is something like "C:\" at this point
            dwType = GetDriveType(pchDrive);

            if ((dwType == DRIVE_REMOVABLE) || (dwType == DRIVE_FIXED))
            {
                // Only look at removable or fixed drives.
                if (GetVolumeInformation(pchDrive, NULL, 0, NULL, NULL, NULL,
                                         szFileSystem, celems(szFileSystem)))
                {
                    if (!lstrcmpiW(szFileSystem, c_szNTFS))
                    {
                        // Drive letter gets first char of drive root path
                        if (!*pchDriveLetter)
                        {
                            // If no drive was found yet, this becomes the
                            // first
                            *pchDriveLetter = *pchDrive;
                        }

                        // Found NTFS drive. Continue looking, though
                        // in case there exists an NTFS drive that already has
                        // a UAM volume on it.
                        if (FContainsUAMVolume(*pchDrive))
                        {
                            // Override first drive letter and use this one
                            // and break because it already has a UAM volume
                            // on it.
                            *pchDriveLetter = *pchDrive;
                            break;
                        }
                    }
                }
            }
            pchDrive += lstrlenW(pchDrive) + 1;
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrGetFirstPossibleUAMDrive", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDeleteOldFolders
//
//  Purpose:    Removes the old AppleShare Folder directory from an NT4 to
//              NT5 upgrade.
//
//  Arguments:
//      pszUamPath [in]  Path to UAM volume.
//
//  Returns:    S_OK if success, WIN32 error otherwise
//
//  Author:     danielwe   15 Dec 1998
//
//  Notes:
//
HRESULT HrDeleteOldFolders(PCWSTR pszUamPath)
{
    HRESULT     hr = S_OK;

    WCHAR   szOldFolder[MAX_PATH];

    lstrcpyW(szOldFolder, pszUamPath);
    lstrcatW(szOldFolder, c_szBackslash);
    lstrcatW(szOldFolder, SzLoadIds(IDS_OC_SFM_APPLESHARE_FOLDER));

    hr = HrDeleteDirectory(szOldFolder, TRUE);
    if ((HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ||
        (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr))
    {
        // ok if old directory was not there
        hr = S_OK;
    }

    TraceError("HrDeleteOldFolders", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallSFM
//
//  Purpose:    Called when SFM is being installed. Handles all of the
//              additional installation for SFM beyond that of the INF file.
//
//  Arguments:
//      pnocd   [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT HrInstallSFM(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;
    WCHAR       chNTFSDrive;

    hr = HrGetFirstPossibleUAMDrive(&chNTFSDrive);
    if (SUCCEEDED(hr))
    {
        if (chNTFSDrive != 0)
        {
            WCHAR   szUAMPath[MAX_PATH];

            szUAMPath[0] = chNTFSDrive;
            szUAMPath[1] = 0;
            lstrcatW(szUAMPath, c_szColonBackslash);
            lstrcatW(szUAMPath, SzLoadIds(IDS_OC_SFM_VOLNAME));

            // UAM Path is now something like "D:\Microsoft UAM Volume".

            hr = HrDeleteOldFolders(szUAMPath);
            if (SUCCEEDED(hr))
            {
                hr = HrSetupUAM(szUAMPath);
                if (SUCCEEDED(hr))
                {
                    WCHAR       szValue[MAX_PATH];

                    lstrcpyW(szValue, c_szPath);
                    lstrcatW(szValue, szUAMPath);

                    // Add the final multi_sz value to the registry
                    hr = HrRegAddStringToMultiSz(szValue,
                                                 HKEY_LOCAL_MACHINE,
                                                 c_szRegKeyVols,
                                                 SzLoadIds(IDS_OC_SFM_VOLNAME),
                                                 STRING_FLAG_ENSURE_AT_END,
                                                 0);
                }
            }
        }
        else
        {
            // No NTFS drives present.
            //$ REVIEW (danielwe) 6 May 1997: For now we will fail,
            // but how can we do this in the future?
            // Not the best error code, but hopefully it's close to
            // what we want.
            hr = HRESULT_FROM_WIN32(ERROR_UNRECOGNIZED_MEDIA);
        }
    }

    TraceError("HrInstallSFM", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveSFM
//
//  Purpose:    Handles additional removal requirements for SFM component.
//
//      pnocd   [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT HrRemoveSFM(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;

    static const WCHAR c_szRegKeyLsa[] = L"System\\CurrentControlSet\\Control\\Lsa";
    static const WCHAR c_szRegValueNotif[] = L"Notification Packages";
    static const WCHAR c_szRasSfm[] = L"RASSFM";

    hr = HrRegRemoveStringFromMultiSz(c_szRasSfm, HKEY_LOCAL_MACHINE,
                                      c_szRegKeyLsa, c_szRegValueNotif,
                                      STRING_FLAG_REMOVE_ALL);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        // benign error
        hr = S_OK;
    }

    TraceError("HrRemoveSFM", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtSFM
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     danielwe   17 Sep 1998
//
//  Notes:
//
HRESULT HrOcExtSFM(PNETOCDATA pnocd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT     hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_POST_INSTALL:
        hr = HrOcSfmOnInstall(pnocd);
        break;

    case NETOCM_QUERY_CHANGE_SEL_STATE:
        hr = HrOcSfmOnQueryChangeSelState(pnocd, static_cast<BOOL>(wParam));
        break;
    }

    TraceError("HrOcExtSFM", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSfmOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for SFM.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT HrOcSfmOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;

    Assert(pnocd);

    if (pnocd->eit == IT_INSTALL || pnocd->eit == IT_UPGRADE)
    {
        hr = HrInstallSFM(pnocd);
        if (HRESULT_FROM_WIN32(ERROR_UNRECOGNIZED_MEDIA) == hr)
        {
            // This error code means no NTFS drives were present
            NcMsgBox(g_ocmData.hwnd, IDS_OC_CAPTION, IDS_OC_SFM_NO_NTFS,
                     MB_ICONSTOP | MB_OK);
            g_ocmData.fErrorReported = TRUE;
        }
        else
        {
            if (SUCCEEDED(hr) && pnocd->eit == IT_UPGRADE)
            {
                HKEY    hkeyParams;

                TraceTag(ttidNetOc, "Upgrading MacFile server options...");

                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyParams,
                                    KEY_ALL_ACCESS, &hkeyParams);
                if (S_OK == hr)
                {
                    DWORD       dwOptions;

                    hr = HrRegQueryDword(hkeyParams, c_szRegValServerOptions,
                                         &dwOptions);
                    if (S_OK == hr)
                    {
                        // 'or' in the UAM option
                        //
                        hr = HrRegSetDword(hkeyParams, c_szRegValServerOptions,
                                           dwOptions | AFP_SRVROPT_MICROSOFT_UAM);
                    }

                    RegCloseKey (hkeyParams);
                }
            }
        }
    }
    else
    {
        // Do not call HrRemoveSFM anymore.
        // It removes an entry in the notification packages list for LSA.
        // RASSFM entry should never be removed if LSA/SAM is to notify
        // SFM/IAS about changes in password/guest account changes etc.
        //hr = HrRemoveSFM(pnocd);
    }

    TraceError("HrOcSfmOnInstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSfmOnQueryChangeSelState
//
//  Purpose:    Handles the request of the OC framework of whether or not
//              the user should be allowed to install this component.
//
//  Arguments:
//      pnocd   [in]  NetOC Data
//      fShowUi [in]  TRUE if UI should be shown, FALSE if not
//
//  Returns:    S_OK if install is allowed, S_FALSE if not, Win32 error
//              otherwise
//
//  Author:     danielwe   6 Feb 1998
//
//  Notes:
//
HRESULT HrOcSfmOnQueryChangeSelState(PNETOCDATA pnocd, BOOL fShowUi)
{
    HRESULT     hr = S_OK;
    WCHAR       chNTFSDrive;

    Assert(pnocd);
    Assert(g_ocmData.hwnd);

    // See if an NTFS volume exists
    hr = HrGetFirstPossibleUAMDrive(&chNTFSDrive);
    if (SUCCEEDED(hr))
    {
        if (chNTFSDrive == 0)
        {
            if (fShowUi)
            {
                NcMsgBox(g_ocmData.hwnd, IDS_OC_CAPTION, IDS_OC_SFM_NO_NTFS,
                         MB_ICONSTOP | MB_OK);
            }

            hr = S_FALSE;
        }
    }

    TraceError("HrOcSfmOnQueryChangeSelState", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateDirectory
//
//  Purpose:    Creates the given directory. If the directory already exists,
//              no error is returned.
//
//  Arguments:
//      pszDir [in]  Path to directory to create.
//
//  Returns:    S_OK if success, Win32 error otherwise.
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT HrCreateDirectory(PCWSTR pszDir)
{
    HRESULT     hr = S_OK;

    if (!CreateDirectory(pszDir, NULL))
    {
        // Don't complain if directory already exists.
        if (GetLastError() != ERROR_ALREADY_EXISTS)
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceError("HrCreateDirectory" ,hr);
    return hr;
}

struct FOLDER
{
    UINT                idsFoldName;
    PCWSTR              aszSrcFiles[2];
    PCWSTR              aszDstFiles[2];
};

static const FOLDER     c_afold[] =
{
    {
        IDS_OC_SFM_FOLDNAMENT4,
        {
            c_szSrcRSCFile,
            c_szSrcIFOFile
        },
        {
            c_szDstRSCFile,
            c_szDstIFOFile,
        }
    },
    {
        IDS_OC_SFM_FOLDNAMENT5,
        {
            c_szSrcRSCFile5,
            c_szSrcIFOFile5
        },
        {
            c_szDstRSCFile5,
            c_szDstIFOFile5
        }
    }
};

static const INT c_cfold = celems(c_afold);

static const PCWSTR c_aszRootFilesSrc[] =
{
    c_szSrcTXTFile,
    c_szSrcIFOUamInst,
    c_szSrcRSCUamInst,
};

static const PCWSTR c_aszRootFilesDst[] =
{
    c_szDstTXTFile,
    c_szDstIFOUamInst,
    c_szDstRSCUamInst,
};

static const INT c_cszFilesRoot = celems(c_aszRootFilesDst);

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupUAM
//
//  Purpose:    Copies the UAM files to the proper UAM path.
//
//  Arguments:
//      pszPath [in]     Path to UAM volume.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT HrSetupUAM(PWSTR pszPath)
{
    HRESULT     hr = S_OK;
    WCHAR       szWinDir[MAX_PATH];
    INT         isz;

    // Create dir: "X:\Microsoft UAM Volume"
    hr = HrCreateDirectory(pszPath);
    if (SUCCEEDED(hr))
    {
        hr = HrSecureSfmDirectory(pszPath);
        if (SUCCEEDED(hr))
        {
            INT     ifold;

            for (ifold = 0; ifold < c_cfold; ifold++)
            {
                WCHAR   szNewDir[MAX_PATH];

                lstrcpyW(szNewDir, pszPath);
                lstrcatW(szNewDir, c_szBackslash);
                lstrcatW(szNewDir, SzLoadIds(c_afold[ifold].idsFoldName));
                lstrcatW(szNewDir, c_szBackslash);
                lstrcatW(szNewDir, SzLoadIds(IDS_OC_SFM_APPLESHARE_FOLDER));
                lstrcatW(szNewDir, c_szBackslash);

                // Create dir: "X:\Microsoft UAM Volume\<folder>\AppleShare Folder"
                hr = HrCreateDirectoryTree(szNewDir, NULL);
                if (SUCCEEDED(hr))
                {
                    if (GetSystemDirectory(szWinDir, celems(szWinDir)))
                    {
                        WCHAR   szSrcFile[MAX_PATH];
                        WCHAR   szDstFile[MAX_PATH];
                        WCHAR   szDstFilePath[MAX_PATH];
                        INT     isz;

                        for (isz = 0; isz < celems(c_afold[ifold].aszSrcFiles);
                             isz++)
                        {
                            lstrcpyW(szSrcFile, szWinDir);
                            lstrcatW(szSrcFile, c_szBackslash);
                            lstrcatW(szSrcFile, c_afold[ifold].aszSrcFiles[isz]);

                            lstrcpyW(szDstFile, pszPath);
                            lstrcatW(szDstFile, c_szBackslash);
                            lstrcatW(szDstFile, SzLoadIds(c_afold[ifold].idsFoldName));

                            wsprintf(szDstFilePath,
                                     c_afold[ifold].aszDstFiles[isz],
                                     SzLoadIds(IDS_OC_SFM_APPLESHARE_FOLDER));

                            lstrcatW(szDstFile, szDstFilePath);

                            TraceTag(ttidNetOc, "MacFile: Copying %S to %S...",
                                     szSrcFile, szDstFile);

                            if (!CopyFile(szSrcFile, szDstFile, FALSE))
                            {
                                hr = HrFromLastWin32Error();
                                goto err;
                            }
                        }
                    }
                    else
                    {
                        hr = HrFromLastWin32Error();
                    }
                }
            }
        }
    }

    // Copy files to the root
    //
    if (SUCCEEDED(hr))
    {
        for (isz = 0; isz < c_cszFilesRoot; isz++)
        {
            WCHAR   szSrcFile[MAX_PATH];
            WCHAR   szDstFile[MAX_PATH];

            lstrcpyW(szSrcFile, szWinDir);
            lstrcatW(szSrcFile, c_szBackslash);
            lstrcatW(szSrcFile, c_aszRootFilesSrc[isz]);

            if ((c_aszRootFilesDst[isz] == c_szDstIFOUamInst) ||
                (c_aszRootFilesDst[isz] == c_szDstRSCUamInst))
            {
                WCHAR   szTemp[MAX_PATH];

                lstrcpyW(szTemp, pszPath);
                lstrcatW(szTemp, c_aszRootFilesDst[isz]);
                wsprintfW(szDstFile, szTemp,
                         SzLoadIds(IDS_OC_SFM_UAM_INSTALLER));
            }
            else
            {
                lstrcpyW(szDstFile, pszPath);
                lstrcatW(szDstFile, c_aszRootFilesDst[isz]);
            }

            TraceTag(ttidNetOc, "MacFile: Copying %S to %S", szSrcFile,
                     szDstFile);

            if (!CopyFile(szSrcFile, szDstFile, FALSE))
            {
                hr = HrFromLastWin32Error();
                goto err;
            }
        }
    }

err:
    TraceError("HrSetupUAM", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>
#include <oleauto.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <infstr.h>
#include <setupapi.h>
#include <shellapi.h>
#include <shlobj.h>
#include <stdio.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\netocp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T O C P . H
//
//  Contents:   Private definitions for NETOC
//
//  Notes:
//
//  Author:     danielwe   17 Sep 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NETOCP_H
#define _NETOCP_H

#ifndef _OCMANAGE_H
#define _OCMANAGE_H
#include <ocmanage.h>   // OC Manager header
#endif //!_OCMANAGE_H

#include "netoc.h"
#include "netcon.h"
#include "ncstring.h"
#include "netcfgx.h"

//---[ Prototypes ]-----------------------------------------------------------

DWORD NetOcSetupProcHelper(LPCVOID pvComponentId, LPCVOID pvSubcomponentId,
                           UINT uFunction, UINT uParam1, LPVOID pvParam2);
HRESULT HrOnInitComponent(PSETUP_INIT_COMPONENT psic);
VOID OnWizardCreated(HWND hwnd);
HRESULT HrOnCalcDiskSpace(PCWSTR szwSubComponentId, BOOL fAdd,
                          HDSKSPC hdskspc);
DWORD DwOnQueryState(PCWSTR szwSubComponentId, BOOL fFinal);
HRESULT HrEnsureInfFileIsOpen(PCWSTR szwSubComponentId, NETOCDATA &nocd);
HRESULT HrOnPreCommitFileQueue(PCWSTR szwSubComponentId);
HRESULT HrOnQueueFileOps(PCWSTR szwSubComponentId, HSPFILEQ hfq);
HRESULT HrOnCompleteInstallation(PCWSTR szwComponentId,
                                 PCWSTR szwSubComponentId);
HRESULT HrOnQueryChangeSelState(PCWSTR szwSubComponentId, BOOL fSelected,
                                UINT uiFlags);
BOOL FOnQuerySkipPage(OcManagerPage ocmPage);
VOID OnCleanup(VOID);
HRESULT HrGetSelectionState(PCWSTR szwSubComponentId, UINT uStateType);
HRESULT HrGetInstallType(PCWSTR szwSubComponentId, NETOCDATA &nocd,
                         EINSTALL_TYPE *peit);
HRESULT HrInstallNetCfgComponent(PCWSTR szComponentId,
                                 PCWSTR szManufacturer,
                                 PCWSTR szProduct,
                                 PCWSTR szDisplayName,
                                 const GUID& rguid);
HRESULT HrRemoveNetCfgComponent(PCWSTR szComponentId,
                                 PCWSTR szManufacturer,
                                 PCWSTR szProduct,
                                 PCWSTR szDisplayName,
                                 const GUID& rguid);
HRESULT HrCallExternalProc(PNETOCDATA pnocd, UINT uMsg, WPARAM wParam,
                           LPARAM lParam);
HRESULT HrRunInfSection(HINF hinf, PNETOCDATA pnocd,
                        PCWSTR szInstallSection, DWORD dwFlags);
HRESULT HrInstallOrRemoveServices(HINF hinf, PCWSTR szSectionName);
HRESULT HrHandleOCExtensions(HINF hinfFile, PCWSTR szInstallSection);
HRESULT HrOCInstallOrUninstallFromINF(PNETOCDATA pnocd);
HRESULT HrDoOCInstallOrUninstall(PNETOCDATA pnocd);
UINT UiOcErrorFromHr(HRESULT hr);
VOID ReportErrorHr(HRESULT hr, INT ids, HWND hwnd, PCWSTR szDesc);

HRESULT HrInstallOrRemoveNetCfgComponent(PNETOCDATA pnocd,
                                         PCWSTR szComponentId,
                                         PCWSTR szManufacturer,
                                         PCWSTR szProduct,
                                         PCWSTR szDisplayName,
                                         const GUID& rguid);
HRESULT HrDoActualInstallOrUninstall(HINF hinf, PNETOCDATA pnocd,
                                     PCWSTR szInstallSection);
HRESULT HrVerifyStaticIPPresent(INetCfg *pnc);

NETOCDATA *PnocdFindComponent(PCWSTR szwComponent);
VOID DeleteAllComponents(VOID);
VOID AddComponent(PCWSTR szwComponent, NETOCDATA *pnocd);
HRESULT HrCountConnections(INetConnection **ppconn);
HRESULT HrStartOrStopAnyServices(HINF hinf, PCWSTR szSection, BOOL fStart);
DWORD DwOnQueryStepCount(PCWSTR pvSubcomponentId);
HRESULT HrSetNextButton(PCWSTR pszSubComponentId);
#endif //!_NETOCP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\netocx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T O C X . H
//
//  Contents:   Custom installation functions for the various optional
//              components.
//
//  Notes:
//
//  Author:     danielwe   19 Jun 1997
//
//----------------------------------------------------------------------------

#ifndef _NETOCX_H
#define _NETOCX_H
#pragma once

HRESULT HrOcWinsOnInstall(PNETOCDATA pnocd);
HRESULT HrOcExtWINS(PNETOCDATA pnocd, UINT uMsg,
                    WPARAM wParam, LPARAM lParam);
HRESULT HrOcDnsOnInstall(PNETOCDATA pnocd);
HRESULT HrOcExtDNS(PNETOCDATA pnocd, UINT uMsg,
                    WPARAM wParam, LPARAM lParam);
HRESULT HrOcSnmpOnInstall(PNETOCDATA pnocd);
HRESULT HrOcExtSNMP(PNETOCDATA pnocd, UINT uMsg,
                    WPARAM wParam, LPARAM lParam);
HRESULT HrSetWinsServiceRecoveryOption(PNETOCDATA pnocd);

#endif //!_NETOCX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\netocx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T O C X . C P P
//
//  Contents:   Custom installation functions for various optional
//              components.
//
//  Notes:
//
//  Author:     danielwe   19 Jun 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "netoc.h"
#include "netocx.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"
#include "snmpocx.h"

static const WCHAR c_szFileSpec[] = L"*.*";
static const WCHAR c_szWinsPath[] = L"\\wins";
static const WCHAR c_szRegKeyWinsParams[] = L"System\\CurrentControlSet\\Services\\WINS\\Parameters";
static const WCHAR c_szRegValWinsBackupDir[] = L"BackupDirPath";

//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtWINS
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     danielwe   17 Sep 1998
//
//  Notes:
//
HRESULT HrOcExtWINS(PNETOCDATA pnocd, UINT uMsg,
                    WPARAM wParam, LPARAM lParam)
{
    HRESULT     hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_POST_INSTALL:
        hr = HrOcWinsOnInstall(pnocd);
        break;
    }

    TraceError("HrOcExtWINS", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtDNS
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     danielwe   17 Sep 1998
//
//  Notes:
//
HRESULT HrOcExtDNS(PNETOCDATA pnocd, UINT uMsg,
                   WPARAM wParam, LPARAM lParam)
{
    HRESULT     hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_POST_INSTALL:
        hr = HrOcDnsOnInstall(pnocd);
        break;
    }

    TraceError("HrOcExtDNS", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtSNMP
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     danielwe   17 Sep 1998
//
//  Notes:
//
HRESULT HrOcExtSNMP(PNETOCDATA pnocd, UINT uMsg,
                    WPARAM wParam, LPARAM lParam)
{
    HRESULT     hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_POST_INSTALL:
        hr = HrOcSnmpOnInstall(pnocd);
        break;
    }

    TraceError("HrOcExtSNMP", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetWinsServiceRecoveryOption
//
//  Purpose:    Sets the recovery options for the WINS service
//
//  Arguments:
//      pnocd [in]  Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     danielwe   26 May 1999
//
//  Notes:
//
HRESULT HrSetWinsServiceRecoveryOption(PNETOCDATA pnocd)
{
    CServiceManager     sm;
    CService            service;
    HRESULT             hr = S_OK;

    SC_ACTION   sra [4] =
    {
        { SC_ACTION_RESTART, 15*1000 }, // restart after 15 seconds
        { SC_ACTION_RESTART, 15*1000 }, // restart after 15 seconds
        { SC_ACTION_RESTART, 15*1000 }, // restart after 15 seconds
        { SC_ACTION_NONE,    30*1000 },
    };

    SERVICE_FAILURE_ACTIONS sfa =
    {
        60 * 60,        // dwResetPeriod is 1 hr
        L"",            // no reboot message
        L"",            // no command to execute
        4,              // 3 attempts to restart the server and stop after that
        sra
    };

    hr = sm.HrOpenService(&service, L"WINS");
    if (S_OK == hr)
    {
        hr = service.HrSetServiceRestartRecoveryOption(&sfa);
    }

    TraceError("HrSetWinsServiceRecoveryOption", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcWinsOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for WINS Server.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     danielwe   19 Jun 1997
//
//  Notes:
//
HRESULT HrOcWinsOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;

    if (pnocd->eit == IT_INSTALL)
    {
        hr = HrHandleStaticIpDependency(pnocd);
        if (SUCCEEDED(hr))
        {
            hr = HrSetWinsServiceRecoveryOption(pnocd);
        }
    }
    else if (pnocd->eit == IT_UPGRADE)
    {
        HKEY    hkey;

        // Upgrade the BackupDirPath value from whatever it was to
        // REG_EXPAND_SZ
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyWinsParams,
                            KEY_ALL_ACCESS, &hkey);
        if (SUCCEEDED(hr))
        {
            DWORD   dwType;
            LPBYTE  pbData = NULL;
            DWORD   cbData;

            hr = HrRegQueryValueWithAlloc(hkey, c_szRegValWinsBackupDir,
                                          &dwType, &pbData, &cbData);
            if (SUCCEEDED(hr))
            {
                switch (dwType)
                {
                case REG_MULTI_SZ:
                case REG_SZ:
                    PWSTR  pszNew;

                    // This cast will give us the first string of the MULTI_SZ
                    pszNew = reinterpret_cast<PWSTR>(pbData);

                    TraceTag(ttidNetOc, "Resetting %S to %S",
                             c_szRegValWinsBackupDir, pszNew);

                    hr = HrRegSetSz(hkey, c_szRegValWinsBackupDir, pszNew);
                    break;
                }

                MemFree(pbData);
            }

            RegCloseKey(hkey);
        }

        // This process is non-fatal

        TraceError("HrOcWinsOnInstall - Failed to upgrade BackupDirPath - "
                   "non-fatal", hr);

        // overwrite hr on purpose
        hr = HrSetWinsServiceRecoveryOption(pnocd);
    }
    else if (pnocd->eit == IT_REMOVE)
    {
        WCHAR   szWinDir[MAX_PATH];

        if (GetSystemDirectory(szWinDir, celems(szWinDir)))
        {
            lstrcatW(szWinDir, c_szWinsPath);

            // szWinDir should now be something like c:\winnt\system32\wins
            hr = HrDeleteFileSpecification(c_szFileSpec, szWinDir);
        }
        else
        {
            hr = HrFromLastWin32Error();
        }

        if (FAILED(hr))
        {
            TraceError("HrOcWinsOnInstall: failed to delete files, continuing...",
                       hr);
            hr = S_OK;
        }
    }

    TraceError("HrOcWinsOnInstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcDnsOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for DNS Server.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     danielwe   19 Jun 1997
//
//  Notes:
//
HRESULT HrOcDnsOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;

    if (pnocd->eit == IT_INSTALL)
    {
        hr = HrHandleStaticIpDependency(pnocd);
    }

    TraceError("HrOcDnsOnInstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSnmpAgent
//
//  Purpose:    Installs the SNMP agent parameters
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     FlorinT 10/05/1998
//
//  Notes:
//
HRESULT HrOcSnmpAgent(PNETOCDATA pnocd)
{
    tstring tstrVariable;
    PWSTR  pTstrArray = NULL;
    HRESULT hr;

    // Read SNMP answer file params and save them to the registry

    //-------- read the 'Contact Name' parameter
    hr = HrSetupGetFirstString(g_ocmData.hinfAnswerFile,
                               AF_SECTION,
                               AF_SYSNAME,
                               &tstrVariable);
    if (hr == S_OK)
    {
        hr = SnmpRegWriteTstring(REG_KEY_AGENT,
                                 SNMP_CONTACT,
                                 tstrVariable);
    }

    if (hr == S_OK || hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
    {
        //-------- read the 'Location' parameter
        hr = HrSetupGetFirstString(g_ocmData.hinfAnswerFile,
                                   AF_SECTION,
                                   AF_SYSLOCATION,
                                   &tstrVariable);
    }

    if (hr == S_OK)
    {
        hr = SnmpRegWriteTstring(REG_KEY_AGENT,
                                 SNMP_LOCATION,
                                 tstrVariable);
    }

    if (hr == S_OK || hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
    {
        //-------- read the 'Service' parameter
        hr = HrSetupGetFirstMultiSzFieldWithAlloc(g_ocmData.hinfAnswerFile,
                                                  AF_SECTION,
                                                  AF_SYSSERVICES,
                                                  &pTstrArray);
    }

    if (hr == S_OK)
    {
        DWORD dwServices = SnmpStrArrayToServices(pTstrArray);
        delete pTstrArray;
        hr = SnmpRegWriteDword(REG_KEY_AGENT,
                               SNMP_SERVICES,
                               dwServices);
    }

    return  (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND)) ? S_OK : hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSnmpTraps
//
//  Purpose:    Installs the traps SNMP parameters defined in the answer file
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     FlorinT 10/05/1998
//
//  Notes:
//
HRESULT HrOcSnmpTraps(PNETOCDATA pnocd)
{
    tstring tstrVariable;
    PWSTR  pTstrArray = NULL;
    HRESULT hr;

    // Read SNMP answer file params and save them to the registry

    //-------- read the 'Trap community' parameter
    hr = HrSetupGetFirstString(g_ocmData.hinfAnswerFile,
                               AF_SECTION,
                               AF_TRAPCOMMUNITY,
                               &tstrVariable);

    if (hr == S_OK)
    {
        //-------- read the 'Trap destinations' parameter
        HrSetupGetFirstMultiSzFieldWithAlloc(g_ocmData.hinfAnswerFile,
                                             AF_SECTION,
                                             AF_TRAPDEST,
                                             &pTstrArray);

        hr = SnmpRegWriteTraps(tstrVariable, pTstrArray);
        delete pTstrArray;
    }

    return  (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND)) ? S_OK : hr;
}

// bitmask values for 'pFlag' parameter for HrOcSnmpSecurity()
// they indicate which of the SNMP SECuritySETtings were defined through
// the answerfile.
#define SNMP_SECSET_COMMUNITIES     0x00000001
#define SNMP_SECSET_AUTHFLAG        0x00000002
#define SNMP_SECSET_PERMMGR         0x00000004

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSnmpSecurituy
//
//  Purpose:    Installs the security SNMP parameters defined in the answer file
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     FlorinT 10/05/1998
//
//  Notes:
//
HRESULT HrOcSnmpSecurity(PNETOCDATA pnocd, DWORD *pFlags)
{
    BOOL    bVariable = FALSE;
    PWSTR  pTstrArray = NULL;
    HRESULT hr;

    // Read SNMP answer file params and save them to the registry

    //-------- read the 'Accepted communities' parameter
    hr = HrSetupGetFirstMultiSzFieldWithAlloc(g_ocmData.hinfAnswerFile,
                                 AF_SECTION,
                                 AF_ACCEPTCOMMNAME,
                                 &pTstrArray);

    if (hr == S_OK)
    {
        if (pFlags)
            (*pFlags) |= SNMP_SECSET_COMMUNITIES;
        hr = SnmpRegWriteCommunities(pTstrArray);
        delete pTstrArray;
    }

    if (hr == S_OK || hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
    {
        //-------- read the 'EnableAuthenticationTraps' parameter
        hr = HrSetupGetFirstStringAsBool(g_ocmData.hinfAnswerFile,
                                         AF_SECTION,
                                         AF_SENDAUTH,
                                         &bVariable);
        if (hr == S_OK)
        {
            if (pFlags)
                (*pFlags) |= SNMP_SECSET_AUTHFLAG;

            hr = SnmpRegWriteDword(REG_KEY_SNMP_PARAMETERS,
                                   REG_VALUE_AUTHENTICATION_TRAPS,
                                   bVariable);
        }
    }

    if (hr == S_OK || hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
    {
        //-------- read the 'Permitted Managers' parameter
        hr = HrSetupGetFirstStringAsBool(g_ocmData.hinfAnswerFile,
                                         AF_SECTION,
                                         AF_ANYHOST,
                                         &bVariable);
    }

    if (hr == S_OK)
    {
        pTstrArray = NULL;

        // if not 'any host', get the list of hosts from the inf file
        if (bVariable == FALSE)
        {
            hr = HrSetupGetFirstMultiSzFieldWithAlloc(g_ocmData.hinfAnswerFile,
                                                      AF_SECTION,
                                                      AF_LIMITHOST,
                                                      &pTstrArray);
        }

        // at least clear up the 'permitted managers' list (bVariable = TRUE)
        // at most, write the allowed managers to the registry
        if (hr == S_OK)
        {
            if (pFlags)
                (*pFlags) |= SNMP_SECSET_PERMMGR;

            hr = SnmpRegWritePermittedMgrs(bVariable, pTstrArray);
        }

        if (pTstrArray != NULL)
            delete pTstrArray;
    }

    return  (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND)) ? S_OK : hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSnmpDefCommunity
//
//  Purpose:    Installs the default SNMP community.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     FlorinT 10/05/1998
//
//  Notes:
//
HRESULT HrOcSnmpDefCommunity(PNETOCDATA pnocd)
{
    HRESULT hr = S_OK;

    hr = SnmpRegWriteDefCommunity();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSnmpUpgParams
//
//  Purpose:    makes all the registry changes needed when upgrading to Win2K
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     FlorinT 10/05/1998
//
//  Notes:
//
HRESULT HrOcSnmpUpgParams(PNETOCDATA pnocd)
{
    HRESULT hr = S_OK;

    hr = SnmpRegUpgEnableAuthTraps();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSnmpOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for SNMP.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     danielwe   15 Sep 1998
//
//  Notes:
//
HRESULT HrOcSnmpOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;
    DWORD       secFlags = 0;

    if ((pnocd->eit == IT_INSTALL) | (pnocd->eit == IT_UPGRADE))
    {
        // --ft:10/14/98-- bug #237203 - success if there is no answer file!
        if (g_ocmData.hinfAnswerFile != NULL)
        {
            hr = HrOcSnmpSecurity(pnocd, &secFlags);
            if (hr == S_OK)
                hr = HrOcSnmpTraps(pnocd);
            if (hr == S_OK)
                hr = HrOcSnmpAgent(pnocd);
        }
    }

    // configure the 'public' community as a read-only community only if:
    // fresh installing and (there is no answer_file or there is an answer_file but it doesn't
    // configure any community)
    if (hr == S_OK && pnocd->eit == IT_INSTALL && !(secFlags & SNMP_SECSET_COMMUNITIES))
    {
       hr = HrOcSnmpDefCommunity(pnocd);
    }

    // on upgrade only look at the old EnableAuthTraps value and copy it to the new location
    if (hr == S_OK && pnocd->eit == IT_UPGRADE)
    {
        // don't care here about the return code. The upgrade from W2K to W2K fail here and we
        // don't need to fail in this case. Any failure in upgrading the setting from NT4 to W2K
        // will result in having the default parameter.
        HrOcSnmpUpgParams(pnocd);
    }

    if (hr == S_OK && (pnocd->eit == IT_INSTALL || pnocd->eit == IT_UPGRADE) )
    {
        // set admin dacl to ValidCommunities subkey
        hr = SnmpAddAdminAclToKey(REG_KEY_VALID_COMMUNITIES);
        if (hr == S_OK)
        {
            // set admin dacl to PermittedManagers subkey
            hr = SnmpAddAdminAclToKey(REG_KEY_PERMITTED_MANAGERS);
        }   
    }

    TraceError("HrOcSnmpOnInstall", hr);
    return (hr == HRESULT_FROM_SETUPAPI(ERROR_SECTION_NOT_FOUND)) ? S_OK : hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\netoc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T O C . H
//
//  Contents:   Functions for handling installation and removal of optional
//              networking components.
//
//  Notes:
//
//  Author:     danielwe   28 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NETOC_H
#define _NETOC_H

#ifndef _OCMANAGE_H
#define _OCMANAGE_H
#include <ocmanage.h>   // OC Manager header
#endif //!_OCMANAGE_H

#include "netcon.h"
#include "ncstring.h"
#include "netcfgx.h"

enum EINSTALL_TYPE
{
    IT_UNKNOWN          =   0x0,
    IT_INSTALL          =   0x1,
    IT_UPGRADE          =   0x2,
    IT_REMOVE           =   0x3,
    IT_NO_CHANGE        =   0x4,
};

struct OCM_DATA
{
    INetCfg *               pnc;    // Uh, I assume we all know what this is.
    HWND                    hwnd;   // hwnd of parent window for any UI
    SETUP_INIT_COMPONENT    sic;    // initialization data
    HINF                    hinfAnswerFile;
    BOOL                    fErrorReported;
    BOOL                    fNoDepends;

    OCM_DATA()
    {
        hwnd = NULL;
        hinfAnswerFile = NULL;
        pnc = NULL;
        fErrorReported = FALSE;
        fNoDepends = FALSE;
    }
};

//+---------------------------------------------------------------------------
//
//  NetOCData - Combines all of the standard parameters that we were
//              previously passing all over the place. This will keep
//              us from having to continually change all of our prototypes
//              when we need other info in ALL functions, and will prevent
//              us from instantiating objects such as INetCfg in multiple
//              places
//
//  Notes:      Some members of this structure will not be initialized right away,
//              but will be filled in when first needed.
//
//  Author:     jeffspr   24 Jul 1997
//
struct NetOCData
{
    PCWSTR                  pszSection;
    PWSTR                   pszComponentId;
    tstring                 strDesc;
    EINSTALL_TYPE           eit;
    BOOL                    fCleanup;
    BOOL                    fFailedToInstall;
    HINF                    hinfFile;

    NetOCData()
    {
        eit = IT_UNKNOWN;
        pszSection = NULL;
        fCleanup = FALSE;
        fFailedToInstall = FALSE;
        hinfFile = NULL;
        pszComponentId = NULL;
    }

    ~NetOCData()
    {
        delete [] pszComponentId;
    }
};

typedef struct NetOCData    NETOCDATA;
typedef struct NetOCData *  PNETOCDATA;

// Extension proc prototype
//
typedef HRESULT (*PFNOCEXTPROC) (PNETOCDATA pnocd, UINT uMsg, WPARAM wParam,
                                 LPARAM lParam);

struct OCEXTPROCS
{
    PCWSTR          pszComponentName;
    PFNOCEXTPROC    pfnHrOcExtProc;
};

// Message handler constants
//
const UINT NETOCM_QUERY_CHANGE_SEL_STATE    = 1000;
const UINT NETOCM_POST_INSTALL              = 1001;
const UINT NETOCM_PRE_INF                   = 1002;
const UINT NETOCM_QUEUE_FILES               = 1003;

extern OCM_DATA g_ocmData;

//
// Public functions
//

HRESULT HrHandleStaticIpDependency(PNETOCDATA pnocd);
HRESULT HrOcGetINetCfg(PNETOCDATA pnocd, BOOL fWriteLock, INetCfg **ppnc);

#endif //!_NETOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\netoc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T O C . C P P
//
//  Contents:   Functions for handling installation and removal of optional
//              networking components.
//
//  Notes:
//
//  Author:     danielwe   28 Apr 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "lancmn.h"
#include "ncacs.h"
#include "ncatlui.h"
#include "ncbeac.h"
#include "nccm.h"
#include "ncdhcps.h"
#include "ncias.h"
#include "ncmisc.h"
#include "ncmsz.h"
#include "ncnetcfg.h"
#include "ncnetcon.h"
#include "ncoc.h"
#include "ncperms.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsfm.h"
#include "ncstring.h"
#include "ncsvc.h"
#include "ncxbase.h"
#include "netcfgn.h"
#include "netcon.h"
#include "netoc.h"
#include "netocp.h"
#include "netocx.h"
#include "resource.h"


//
// External component install functions.
// Add an entry in this table for each component that requires additional,
// non-common installation support.
//
// NOTE: The component name should match the section name in the INF.
//
#pragma BEGIN_CONST_SECTION
static const OCEXTPROCS c_aocepMap[] =
{
    { L"MacSrv",       HrOcExtSFM          },
    { L"DHCPServer",   HrOcExtDHCPServer   },
    { L"NetCM",        HrOcExtCM           },
    { L"WINS",         HrOcExtWINS         },
    { L"DNS",          HrOcExtDNS          },
    { L"ACS",          HrOcExtACS          },
    { L"SNMP",         HrOcExtSNMP         },
    { L"IAS",          HrOcExtIAS          },
    { L"BEACON",       HrOcExtBEACON       },
};
#pragma END_CONST_SECTION

static const INT c_cocepMap = celems(c_aocepMap);

// generic strings
static const WCHAR  c_szUninstall[]         = L"Uninstall";
static const WCHAR  c_szServices[]          = L"StartServices";
static const WCHAR  c_szDependOnComp[]      = L"DependOnComponents";
static const WCHAR  c_szVersionSection[]    = L"Version";
static const WCHAR  c_szProvider[]          = L"Provider";
static const WCHAR  c_szDefManu[]           = L"Unknown";
static const WCHAR  c_szInfRef[]            = L"SubCompInf";
static const WCHAR  c_szDesc[]              = L"OptionDesc";
static const WCHAR  c_szNoDepends[]         = L"NoDepends";

// static-IP verification
static const WCHAR  c_szTcpipInterfacesPath[]   =

L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces";
static const WCHAR  c_szEnableDHCP[]            = L"EnableDHCP";

extern const WCHAR  c_szOcMainSection[];

static const DWORD  c_dwUpgradeMask         = SETUPOP_WIN31UPGRADE |
                                              SETUPOP_WIN95UPGRADE |
                                              SETUPOP_NTUPGRADE;

OCM_DATA g_ocmData;

typedef list<NETOCDATA*> ListOcData;
ListOcData g_listOcData;

//+---------------------------------------------------------------------------
//
//  Function:   PnocdFindComponent
//
//  Purpose:    Looks for the given component name in the list of known
//              components.
//
//  Arguments:
//      pszComponent [in]   Name of component to lookup.
//
//  Returns:    Pointer to component's data.
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
NETOCDATA *PnocdFindComponent(PCWSTR pszComponent)
{
    ListOcData::iterator    iterList;

    for (iterList = g_listOcData.begin();
         iterList != g_listOcData.end();
         iterList++)
    {
        NETOCDATA * pnocd;

        pnocd = *iterList;
        if (!lstrcmpiW(pnocd->pszComponentId, pszComponent))
        {
            return pnocd;
        }
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteAllComponents
//
//  Purpose:    Removes all components from our list and frees all associated
//              data.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
VOID DeleteAllComponents()
{
    ListOcData::iterator    iterList;

    for (iterList = g_listOcData.begin();
         iterList != g_listOcData.end();
         iterList++)
    {
        NETOCDATA * pnocd;

        pnocd = (*iterList);

        if (pnocd->hinfFile)
        {
            SetupCloseInfFile(pnocd->hinfFile);
        }

        delete pnocd;
    }

    g_listOcData.erase(g_listOcData.begin(), g_listOcData.end());
}

//+---------------------------------------------------------------------------
//
//  Function:   AddComponent
//
//  Purpose:    Adds a component to our list.
//
//  Arguments:
//      pszComponent [in]   Name of component to add.
//      pnocd        [in]   Data to associate with component.
//
//  Returns:    Nothing.
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
VOID AddComponent(PCWSTR pszComponent, NETOCDATA *pnocd)
{
    Assert(pszComponent);
    Assert(pnocd);

    pnocd->pszComponentId = SzDupSz(pszComponent);
    g_listOcData.push_back(pnocd);
}

//+---------------------------------------------------------------------------
//
//  Function:   NetOcSetupProcHelper
//
//  Purpose:    Main entry point for optional component installs
//
//  Arguments:
//      pvComponentId    [in]       Component Id (string)
//      pvSubcomponentId [in]       Sub component Id (string)
//      uFunction        [in]       Function being performed
//      uParam1          [in]       First param to function
//      pvParam2         [in, out]  Second param to function
//
//  Returns:    Win32 error if failure
//
//  Author:     danielwe   17 Dec 1997
//
//  Notes:
//
DWORD NetOcSetupProcHelper(LPCVOID pvComponentId, LPCVOID pvSubcomponentId,
                           UINT uFunction, UINT uParam1, LPVOID pvParam2)
{
    TraceFileFunc(ttidNetOc);
    HRESULT     hr = S_OK;

    switch (uFunction)
    {
    case OC_PREINITIALIZE:
        return OCFLAG_UNICODE;

    case OC_QUERY_CHANGE_SEL_STATE:

        TraceTag(ttidNetOc, "OC_QUERY_CHANGE_SEL_STATE: %S, %ld, 0x%08X.",
                 pvSubcomponentId ? pvSubcomponentId : L"null", uParam1,
                 pvParam2);

        if (FHasPermission(NCPERM_AddRemoveComponents))
        {
            hr = HrOnQueryChangeSelState(reinterpret_cast<PCWSTR>(pvSubcomponentId),
                                         uParam1, reinterpret_cast<UINT_PTR>(pvParam2));

            if (S_OK == hr)
            {
                return TRUE;
            }

        }
        else
        {
            NcMsgBox(g_ocmData.hwnd, IDS_OC_CAPTION, IDS_OC_NO_PERMS,
                     MB_ICONSTOP | MB_OK);
        }
        return FALSE;

    case OC_QUERY_SKIP_PAGE:
        TraceTag(ttidNetOc, "OC_QUERY_SKIP_PAGE: %ld", uParam1);
        return FOnQuerySkipPage(static_cast<OcManagerPage>(uParam1));

    case OC_WIZARD_CREATED:
        TraceTag(ttidNetOc, "OC_WIZARD_CREATED: 0x%08X", pvParam2);
        OnWizardCreated(reinterpret_cast<HWND>(pvParam2));
        break;

    case OC_INIT_COMPONENT:
        TraceTag(ttidNetOc, "OC_INIT_COMPONENT: %S", pvSubcomponentId ?
                 pvSubcomponentId : L"null");
        hr = HrOnInitComponent(reinterpret_cast<PSETUP_INIT_COMPONENT>(pvParam2));
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        TraceTag(ttidNetOc, "OC_ABOUT_TO_COMMIT_QUEUE: %S", pvSubcomponentId ?
                 pvSubcomponentId : L"null");
        hr = HrOnPreCommitFileQueue(reinterpret_cast<PCWSTR>(pvSubcomponentId));
        break;

    case OC_CALC_DISK_SPACE:
        // Ignore return value for now. This is not fatal anyway.
        (VOID) HrOnCalcDiskSpace(reinterpret_cast<PCWSTR>(pvSubcomponentId),
                               uParam1, reinterpret_cast<HDSKSPC>(pvParam2));
        break;

    case OC_QUERY_STATE:
        return DwOnQueryState(reinterpret_cast<PCWSTR>(pvSubcomponentId),
                              uParam1 == OCSELSTATETYPE_FINAL);

    case OC_QUEUE_FILE_OPS:
        TraceTag(ttidNetOc, "OC_QUEUE_FILE_OPS: %S, 0x%08X", pvSubcomponentId ?
                 pvSubcomponentId : L"null",
                 pvParam2);
        hr = HrOnQueueFileOps(reinterpret_cast<PCWSTR>(pvSubcomponentId),
                              reinterpret_cast<HSPFILEQ>(pvParam2));
        break;

    case OC_COMPLETE_INSTALLATION:
        TraceTag(ttidNetOc, "OC_COMPLETE_INSTALLATION: %S, %S", pvComponentId ?
                 pvComponentId : L"null",
                 pvSubcomponentId ? pvSubcomponentId : L"null");
        hr = HrOnCompleteInstallation(reinterpret_cast<PCWSTR>(pvComponentId),
                                      reinterpret_cast<PCWSTR>(pvSubcomponentId));
        break;

    case OC_QUERY_STEP_COUNT:
        return DwOnQueryStepCount(reinterpret_cast<PCWSTR>(pvSubcomponentId));

    case OC_CLEANUP:
        OnCleanup();
        break;

    default:
        break;
    }

    if (g_ocmData.sic.HelperRoutines.SetReboot && (NETCFG_S_REBOOT == hr))
    {
        // Request a reboot. Note we don't return the warning as the OCM call
        // below handles it. Fall through and return NO_ERROR.
        //
        g_ocmData.sic.HelperRoutines.SetReboot(
                    g_ocmData.sic.HelperRoutines.OcManagerContext,
                    FALSE);
    }
    else if (FAILED(hr))
    {
        if (!g_ocmData.fErrorReported)
        {
            PCWSTR pszSubComponentId = reinterpret_cast<PCWSTR>(pvSubcomponentId);

            TraceError("NetOcSetupProcHelper", hr);

            if (pszSubComponentId)
            {
                NETOCDATA * pnocd;

                pnocd = PnocdFindComponent(pszSubComponentId);

                Assert(pnocd);

                if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
                {
                    ReportErrorHr(hr, UiOcErrorFromHr(hr), g_ocmData.hwnd,
                                  pnocd->strDesc.c_str());
                }
            }
        }

        TraceError("NetOcSetupProcHelper", hr);
        return DwWin32ErrorFromHr(hr);
    }

    return NO_ERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnInitComponent
//
//  Purpose:    Handles the OC_INIT_COMPONENT function message.
//
//  Arguments:
//      psic              [in]  Setup data. (see OCManager spec)
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
HRESULT HrOnInitComponent (PSETUP_INIT_COMPONENT psic)
{
    HRESULT     hr = S_OK;

    if (OCMANAGER_VERSION <= psic->OCManagerVersion)
    {
        psic->ComponentVersion = OCMANAGER_VERSION;
        CopyMemory(&g_ocmData.sic, (LPVOID)psic, sizeof(SETUP_INIT_COMPONENT));
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnWizardCreated
//
//  Purpose:    Handles the OC_WIZARD_CREATED function message.
//
//  Arguments:
//      hwnd [in]   HWND of wizard (may not be NULL)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
VOID OnWizardCreated(HWND hwnd)
{
    g_ocmData.hwnd = hwnd;
    AssertSz(g_ocmData.hwnd, "Parent HWND is NULL!");
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCalcDiskSpace
//
//  Purpose:    Handles the OC_CALC_DISK_SPACE function message.
//
//  Arguments:
//      pszSubComponentId [in]  Name of component.
//      fAdd              [in]  TRUE if disk space should be added to total
//                              FALSE if removed from total.
//      hdskspc           [in]  Handle to diskspace struct.
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
HRESULT HrOnCalcDiskSpace(PCWSTR pszSubComponentId, BOOL fAdd,
                          HDSKSPC hdskspc)
{
    HRESULT     hr = S_OK;
    DWORD       dwErr;
    NETOCDATA * pnocd;

    pnocd = PnocdFindComponent(pszSubComponentId);

    Assert(pnocd);

    TraceTag(ttidNetOc, "Calculating disk space for %S...",
             pszSubComponentId);

    hr = HrEnsureInfFileIsOpen(pszSubComponentId, *pnocd);
    if (SUCCEEDED(hr))
    {
        if (fAdd)
        {
            dwErr = SetupAddInstallSectionToDiskSpaceList(hdskspc,
                                                          pnocd->hinfFile,
                                                          NULL,
                                                          pszSubComponentId,
                                                          0, 0);
        }
        else
        {
            dwErr = SetupRemoveInstallSectionFromDiskSpaceList(hdskspc,
                                                               pnocd->hinfFile,
                                                               NULL,
                                                               pszSubComponentId,
                                                               0, 0);
        }

        if (!dwErr)
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceError("HrOnCalcDiskSpace", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwOnQueryState
//
//  Purpose:    Handles the OC_QUERY_STATE function message.
//
//  Arguments:
//      pszSubComponentId [in]  Name of component.
//      fFinal            [in]  TRUE if this is the final state query, FALSE
//                              if not
//
//  Returns:    SubcompOn - component should be checked "on"
//              SubcompUseOcManagerDefault - use whatever OCManage thinks is
//              the default
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
DWORD DwOnQueryState(PCWSTR pszSubComponentId, BOOL fFinal)
{
    HRESULT     hr = S_OK;

    if (pszSubComponentId)
    {
        NETOCDATA *     pnocd;
        EINSTALL_TYPE   eit;

        pnocd = PnocdFindComponent(pszSubComponentId);
        if (!pnocd)
        {
            pnocd = new NETOCDATA;
            if(pnocd)
            {
                AddComponent(pszSubComponentId, pnocd);
            }
        }

        if(pnocd)
        {
            if (fFinal)
            {
                if (pnocd->fFailedToInstall)
                {
                    TraceTag(ttidNetOc, "OC_QUERY_STATE: %S failed to install so "
                             "we are turning it off", pszSubComponentId);
                    return SubcompOff;
                }
            }
            else
            {
                hr = HrGetInstallType(pszSubComponentId, *pnocd, &eit);
                if (SUCCEEDED(hr))
                {
                    pnocd->eit = eit;

                    if ((eit == IT_INSTALL) || (eit == IT_UPGRADE))
                    {
                        TraceTag(ttidNetOc, "OC_QUERY_STATE: %S is ON",
                                 pszSubComponentId);
                        return SubcompOn;
                    }
                    else if (eit == IT_REMOVE)
                    {
                        TraceTag(ttidNetOc, "OC_QUERY_STATE: %S is OFF",
                                 pszSubComponentId);
                        return SubcompOff;
                    }
                }
            }
        }
    }

    TraceTag(ttidNetOc, "OC_QUERY_STATE: %S is using default",
             pszSubComponentId);

    return SubcompUseOcManagerDefault;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrEnsureInfFileIsOpen
//
//  Purpose:    Ensures that the INF file for the given component is open.
//
//  Arguments:
//      pszSubComponentId [in]      Name of component.
//      nocd              [in, ref] Data associated with component.
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
HRESULT HrEnsureInfFileIsOpen(PCWSTR pszSubComponentId, NETOCDATA &nocd)
{
    HRESULT     hr = S_OK;
    tstring     strInf;

    if (!nocd.hinfFile)
    {
        // Get component INF file name
        hr = HrSetupGetFirstString(g_ocmData.sic.ComponentInfHandle,
                                   pszSubComponentId, c_szInfRef,
                                   &strInf);
        if (SUCCEEDED(hr))
        {
            TraceTag(ttidNetOc, "Opening INF file %S...", strInf.c_str());

            hr = HrSetupOpenInfFile(strInf.c_str(), NULL,
                                    INF_STYLE_WIN4, NULL, &nocd.hinfFile);
            if (SUCCEEDED(hr))
            {
                // Append in the layout.inf file
                (VOID) SetupOpenAppendInfFile(NULL, nocd.hinfFile, NULL);
            }
        }

        // This is a good time to cache away the component description as
        // well.
        (VOID) HrSetupGetFirstString(g_ocmData.sic.ComponentInfHandle,
                                     pszSubComponentId, c_szDesc,
                                     &nocd.strDesc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnPreCommitFileQueue
//
//  Purpose:    Handles the OC_ABOUT_TO_COMMIT_QUEUE function message.
//
//  Arguments:
//      pszSubComponentId [in]  Name of component.
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   9 Dec 1998
//
//  Notes:
//
HRESULT HrOnPreCommitFileQueue(PCWSTR pszSubComponentId)
{
    HRESULT     hr = S_OK;
    NETOCDATA * pnocd;

    if (pszSubComponentId)
    {
        EINSTALL_TYPE   eit;

        pnocd = PnocdFindComponent(pszSubComponentId);

        hr = HrGetInstallType(pszSubComponentId, *pnocd, &eit);
        if (SUCCEEDED(hr))
        {
            pnocd->eit = eit;

            if (pnocd->eit == IT_REMOVE)
            {
                // Always use main install section
                hr = HrStartOrStopAnyServices(pnocd->hinfFile,
                                              pszSubComponentId, FALSE);
                if (FAILED(hr))
                {
                    // Don't report errors for non-existent services
                    if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) != hr)
                    {
                        // Don't bail removal if services couldn't be stopped.
                        if (!g_ocmData.fErrorReported)
                        {
                            // Report an error and continue the removal.
                            ReportErrorHr(hr,
                                          IDS_OC_STOP_SERVICE_FAILURE,
                                          g_ocmData.hwnd,
                                          pnocd->strDesc.c_str());
                        }
                    }

                    hr = S_OK;
                }

                // We need to unregister DLLs before they get commited to the
                // queue, otherwise we try to unregister a non-existent DLL.
                if (SUCCEEDED(hr))
                {
                    tstring     strUninstall;

                    // Get the name of the uninstall section first
                    hr = HrSetupGetFirstString(pnocd->hinfFile,
                                               pszSubComponentId,
                                               c_szUninstall, &strUninstall);
                    if (SUCCEEDED(hr))
                    {
                        PCWSTR   pszInstallSection;

                        pszInstallSection = strUninstall.c_str();

                        // Run the INF but only call the unregister function
                        //
                        hr = HrSetupInstallFromInfSection(g_ocmData.hwnd,
                                                          pnocd->hinfFile,
                                                          pszInstallSection,
                                                          SPINST_UNREGSVR,
                                                          NULL, NULL, 0, NULL,
                                                          NULL, NULL, NULL);
                    }
                    else
                    {
                        // Uninstall may not be present
                        hr = S_OK;
                    }
                }
            }
        }
    }

    TraceError("HrOnPreCommitFileQueue", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnQueueFileOps
//
//  Purpose:    Handles the OC_QUEUE_FILE_OPS function message.
//
//  Arguments:
//      pszSubComponentId [in]  Name of component.
//      hfq               [in]  Handle to file queue struct.
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
HRESULT HrOnQueueFileOps(PCWSTR pszSubComponentId, HSPFILEQ hfq)
{
    HRESULT     hr = S_OK;
    NETOCDATA * pnocd;

    if (pszSubComponentId)
    {
        EINSTALL_TYPE   eit;

        pnocd = PnocdFindComponent(pszSubComponentId);

        hr = HrGetInstallType(pszSubComponentId, *pnocd, &eit);
        if (SUCCEEDED(hr))
        {
            pnocd->eit = eit;

            if ((pnocd->eit == IT_INSTALL) || (pnocd->eit == IT_UPGRADE) ||
                (pnocd->eit == IT_REMOVE))
            {
                BOOL    fSuccess = TRUE;
                PCWSTR pszInstallSection;
                tstring strUninstall;

                AssertSz(hfq, "No file queue?");

                hr = HrEnsureInfFileIsOpen(pszSubComponentId, *pnocd);
                if (SUCCEEDED(hr))
                {
                    if (pnocd->eit == IT_REMOVE)
                    {
                        // Get the name of the uninstall section first
                        hr = HrSetupGetFirstString(pnocd->hinfFile,
                                                   pszSubComponentId,
                                                   c_szUninstall,
                                                   &strUninstall);
                        if (SUCCEEDED(hr))
                        {
                            pszInstallSection = strUninstall.c_str();
                        }
                        else
                        {
                            if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
                            {
                                // Uninstall section is not required.
                                hr = S_OK;
                                fSuccess = FALSE;
                            }
                        }
                    }
                    else
                    {
                        pszInstallSection = pszSubComponentId;
                    }
                }

                if (SUCCEEDED(hr) && fSuccess)
                {
                    hr = HrCallExternalProc(pnocd, NETOCM_QUEUE_FILES,
                                            (WPARAM)hfq, 0);
                }

                if (SUCCEEDED(hr))
                {
                    TraceTag(ttidNetOc, "Queueing files for %S...",
                             pszSubComponentId);

                    hr = HrSetupInstallFilesFromInfSection(pnocd->hinfFile,
                                                           NULL, hfq,
                                                           pszInstallSection,
                                                           NULL, 0);
                }
            }
        }
    }

    TraceError("HrOnQueueFileOps", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCompleteInstallation
//
//  Purpose:    Handles the OC_COMPLETE_INSTALLATION function message.
//
//  Arguments:
//      pszComponentId    [in]  Top-level component name (will always be
//                              "NetOC" or NULL.
//      pszSubComponentId [in]  Name of component.
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   23 Feb 1998
//              omiller    28 March 2000 Added code to move the progress
//                                       bar one tick for every component
//                                       installed or removed.
//
//  Notes:
//
HRESULT HrOnCompleteInstallation(PCWSTR pszComponentId,
                                 PCWSTR pszSubComponentId)
{
    HRESULT     hr = S_OK;

    // Make sure they're different. If not, it's the top level item and
    // we don't want to do anything
    if (pszSubComponentId && lstrcmpiW(pszSubComponentId, pszComponentId))
    {
        NETOCDATA * pnocd;

        pnocd = PnocdFindComponent(pszSubComponentId);

        Assert(pnocd);

        pnocd->fCleanup = FALSE;

        if (pnocd->eit == IT_INSTALL || pnocd->eit == IT_REMOVE ||
            pnocd->eit == IT_UPGRADE)
        {
            pnocd->pszSection = pszSubComponentId;

            // Get component description

#if DBG
            if (pnocd->eit == IT_INSTALL)
            {
                TraceTag(ttidNetOc, "Installing network OC %S...",
                         pszSubComponentId);
            }
            else if (pnocd->eit == IT_UPGRADE)
            {
                TraceTag(ttidNetOc, "Upgrading network OC %S...",
                         pszSubComponentId);
            }
            else if (pnocd->eit == IT_REMOVE)
            {
                TraceTag(ttidNetOc, "Removing network OC %S...",
                         pszSubComponentId);
            }
#endif

            hr = HrDoOCInstallOrUninstall(pnocd);
            if (FAILED(hr) && pnocd->eit == IT_INSTALL)
            {
                // A failure during install means we have to clean up by doing
                // an uninstall now. Report the appropriate error and do the
                // remove. Note - Don't report the error if it's ERROR_CANCELLED,
                // because they KNOW that they cancelled, and it's not really
                // an error.
                //
                if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
                {
                    // Don't report the error a second time if the component
                    // has already put up error UI (and set this flag)
                    //
                    if (!g_ocmData.fErrorReported)
                    {
                        ReportErrorHr(hr, UiOcErrorFromHr(hr),
                                      g_ocmData.hwnd,
                                      pnocd->strDesc.c_str());
                    }
                }
                g_ocmData.fErrorReported = TRUE;


                // Now we're removing
                pnocd->eit = IT_REMOVE;
                pnocd->fCleanup = TRUE;
                pnocd->fFailedToInstall = TRUE;

                // eat the error. Haven't we troubled them enough? :(
                (VOID) HrDoOCInstallOrUninstall(pnocd);
            }
            else
            {
                // Every time a component is installed,upgraded or removed, the progress
                // bar is advanced by one tick. For every component that is being
                // installed/removed/upgraded the OC manager asked netoc for how many ticks
                // that component counts (OC_QUERY_STEP_COUNT). From this information
                // the OC manger knows the relationship between tick and progress bar
                // advancement.
                g_ocmData.sic.HelperRoutines.TickGauge(g_ocmData.sic.HelperRoutines.OcManagerContext);
            }
        }
    }


    TraceError("HrOnCompleteInstallation", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   DwOnQueryStepCount
//
//  Purpose:    Handles the OC_QUERY_STEP_COUNT message.
//              The OC manager is asking us how many ticks a component is worth.
//              The number of ticks determines the distance the progress bar gets
//              moved. For netoc all components installed/removed are one tick and
//              all components that are unchanged are 0 ticks.
//
//  Arguments:
//      pszSubComponentId [in]  Name of component.
//
//  Returns:    Number of ticks for progress bar to move
//
//  Author:     omiller    28 March 2000
//
//
DWORD DwOnQueryStepCount(PCWSTR pvSubcomponentId)
{
    NETOCDATA * pnocd;

    // Get the component
    pnocd = PnocdFindComponent(reinterpret_cast<PCWSTR>(pvSubcomponentId));
    if( pnocd )
    {
        // Check if the status of the component has changed.
        if (pnocd->eit == IT_INSTALL || pnocd->eit == IT_REMOVE ||
            pnocd->eit == IT_UPGRADE)
        {
            // Status of component has changed. For this component the OC manager
            // will move the status bar by one tick.
            return 1;
        }
    }

    // The component has not changed. The progress bar will not move for this component.
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnQueryChangeSelState
//
//  Purpose:    Handles the OC_QUERY_CHANGE_SEL_STATE function message.
//              Enables and disables the next button. If no changes has
//              been made to the selections the next button is disabled.
//
//  Arguments:
//      pszSubComponentId [in]  Name of component.
//      fSelected         [in]  TRUE if component was checked "on", FALSE if
//                              checked "off"
//      uiFlags           [in]  Flags defined in ocmgr.doc
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   23 Feb   1998
//
//  Notes:
//
HRESULT HrOnQueryChangeSelState(PCWSTR pszSubComponentId, BOOL fSelected,
                                UINT uiFlags)
{
    HRESULT       hr = S_OK;
    static int    nItemsChanged=0;
    NETOCDATA *   pnocd;

    if (fSelected && pszSubComponentId)
    {
        pnocd = PnocdFindComponent(pszSubComponentId);
        if (pnocd)
        {
            // "NetOc" may be a subcomponent and we don't want to call this
            // for it.
            hr = HrCallExternalProc(pnocd, NETOCM_QUERY_CHANGE_SEL_STATE,
                                    (WPARAM)(!!(uiFlags & OCQ_ACTUAL_SELECTION)),
                                    0);
        }
    }

    TraceError("HrOnQueryChangeSelState", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   FOnQuerySkipPage
//
//  Purpose:    Handles the OC_QUERY_SKIP_PAGE function message.
//
//  Arguments:
//      ocmPage [in]    Which page we are asked to possibly skip.
//
//  Returns:    TRUE if component list page should be skipped, FALSE if not.
//
//  Author:     danielwe   23 Feb   1998
//
//  Notes:
//
BOOL FOnQuerySkipPage(OcManagerPage ocmPage)
{
    BOOL    fUnattended;
    BOOL    fGuiSetup;
    BOOL    fWorkstation;

    fUnattended = !!(g_ocmData.sic.SetupData.OperationFlags & SETUPOP_BATCH);
    fGuiSetup = !(g_ocmData.sic.SetupData.OperationFlags & SETUPOP_STANDALONE);
    fWorkstation = g_ocmData.sic.SetupData.ProductType == PRODUCT_WORKSTATION;

    if ((fUnattended || fWorkstation) && fGuiSetup)
    {
        // We're in GUI mode setup and... we're unattended -OR- this is
        // a workstation install
        if (ocmPage == OcPageComponentHierarchy)
        {
            TraceTag(ttidNetOc, "NETOC: Skipping component list page "
                     "during GUI mode setup...");
            TraceTag(ttidNetOc, "fUnattended = %s, fGuiSetup = %s, "
                     "fWorkstation = %s",
                     fUnattended ? "yes" : "no",
                     fGuiSetup ? "yes" : "no",
                     fWorkstation ? "yes" : "no");

            // Make sure we never show the component list page during setup
            return TRUE;
        }
    }

    TraceTag(ttidNetOc, "Using component list page.");
    TraceTag(ttidNetOc, "fUnattended = %s, fGuiSetup = %s, "
             "fWorkstation = %s",
             fUnattended ? "yes" : "no",
             fGuiSetup ? "yes" : "no",
             fWorkstation ? "yes" : "no");

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnCleanup
//
//  Purpose:    Handles the OC_CLEANUP function message.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
VOID OnCleanup()
{
    TraceTag(ttidNetOc, "Cleaning up");

    if (g_ocmData.hinfAnswerFile)
    {
        SetupCloseInfFile(g_ocmData.hinfAnswerFile);
        TraceTag(ttidNetOc, "Closed answer file");
    }

    DeleteAllComponents();
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetSelectionState
//
//  Purpose:
//
//  Arguments:
//      pszSubComponentId [in]  Name of subcomponent
//      uStateType        [in]  In OCManager doc.
//
//  Returns:    S_OK if component is selected, S_FALSE if not, or Win32 error
//              otheriwse
//
//  Author:     danielwe   17 Dec 1997
//
//  Notes:
//
HRESULT HrGetSelectionState(PCWSTR pszSubComponentId, UINT uStateType)
{
    HRESULT     hr = S_OK;
    BOOL        fInstall;

    fInstall = g_ocmData.sic.HelperRoutines.
        QuerySelectionState(g_ocmData.sic.HelperRoutines.OcManagerContext,
                            pszSubComponentId, uStateType);
    if (!fInstall)
    {
        // Still not sure of the state
        hr = HrFromLastWin32Error();
        if (SUCCEEDED(hr))
        {
            // Ok now we know
            hr = S_FALSE;
        }
    }
    else
    {
        hr = S_OK;
    }

    TraceError("HrGetSelectionState", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetInstallType
//
//  Purpose:    Determines whether the given component is being installed or
//              removed and stores the result in the given structure.
//
//  Arguments:
//      pszSubComponentId [in]  Component being queried
//      nocd              [in, ref] Net OC Data.
//      peit              [out] Returns the install type
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   16 Dec 1997
//
//  Notes:      If the function fails, the eit member is unreliable
//
HRESULT HrGetInstallType(PCWSTR pszSubComponentId, NETOCDATA &nocd,
                         EINSTALL_TYPE *peit)
{
    HRESULT     hr = S_OK;

    Assert(peit);
    Assert(pszSubComponentId);

    *peit = IT_UNKNOWN;

    if (g_ocmData.sic.SetupData.OperationFlags & SETUPOP_BATCH)
    {
        // In batch mode (upgrade or unattended install), install flag is
        // determined from answer file not from selection state.

        // assume no change
        *peit = IT_NO_CHANGE;

        if (!g_ocmData.hinfAnswerFile)
        {
            // Open the answer file
            hr = HrSetupOpenInfFile(g_ocmData.sic.SetupData.UnattendFile, NULL,
                                    INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL,
                                    &g_ocmData.hinfAnswerFile);
        }

        if (SUCCEEDED(hr))
        {
            DWORD   dwValue = 0;

            // First query for a special value called "NoDepends" which, if
            // present, means that the DependOnComponents line will be IGNORED
            // for ALL network optional components for this install. This is
            // because NetCfg may invoke the OC Manager to install an optional
            // component and if that component has DependOnComponents, it will
            // turn around and try to instantiate another INetCfg and that
            // will fail because one instance is already running. This case
            // is rare, though.
            //
            hr = HrSetupGetFirstDword(g_ocmData.hinfAnswerFile,
                                        c_szOcMainSection, c_szNoDepends,
                                        &dwValue);
            if (SUCCEEDED(hr) && dwValue)
            {
                TraceTag(ttidNetOc, "Found the special 'NoDepends'"
                         " keyword in the answer file. DependOnComponents "
                         "will be ignored from now on");
                g_ocmData.fNoDepends = TRUE;
            }
            else
            {
                TraceTag(ttidNetOc, "Didn't find the special 'NoDepends'"
                         " keyword in the answer file");
                hr = S_OK;
            }

            hr = HrSetupGetFirstDword(g_ocmData.hinfAnswerFile,
                                      c_szOcMainSection, pszSubComponentId,
                                      &dwValue);
            if (SUCCEEDED(hr))
            {
                // This component was installed before, so we should
                // return that this component should be checked on

                if (dwValue)
                {
                    TraceTag(ttidNetOc, "Optional component %S was "
                             "previously installed or is being added thru"
                             " unattended install.", pszSubComponentId);

                    if (g_ocmData.sic.SetupData.OperationFlags & SETUPOP_NTUPGRADE)
                    {
                        // If we're upgrading NT, then this optional component
                        // does exist but it needs to be upgraded
                        *peit = IT_UPGRADE;
                    }
                    else
                    {
                        // Otherwise (even if Win3.1 or Win95 upgrade) it's like
                        // we're fresh installing the optional component
                        *peit = IT_INSTALL;
                    }
                }
                else
                {
                    // Answer file contains something like WINS=0
                    hr = HrGetSelectionState(pszSubComponentId,
                                             OCSELSTATETYPE_ORIGINAL);
                    if (S_OK == hr)
                    {
                        // Only set state to remove if the component was
                        // previously installed.
                        //
                        *peit = IT_REMOVE;
                    }
                }
            }
        }

        hr = S_OK;

        // If the answer file was opened successfully and if the
        // a section was found for the pszSubComponentId, *peit
        // will be either IT_INSTALL, IT_UPGRADE or IT_REMOVE.
        // Nothing needs to be done for any of these *peit values.
        // However, if the answerfile could not be opened or if
        // no section existed in the answer file for the pszSubComponentId
        // *peit will have the value IT_NO_CHANGE. For this scenario,
        // if the corresponding subComponent is currently installed,
        // we should upgrade it. The following if addresses this scenario.

        if (*peit == IT_NO_CHANGE)
        {
            // Still not going to install, because this is an upgrade
            hr = HrGetSelectionState(pszSubComponentId,
                                     OCSELSTATETYPE_ORIGINAL);
            if (S_OK == hr)
            {
                // If originally selected and not in answer file, this is an
                // upgrade of this component
                *peit = IT_UPGRADE;
            }
        }
    }
    else    // This is standalone (post-setup) mode
    {
        hr = HrGetSelectionState(pszSubComponentId, OCSELSTATETYPE_ORIGINAL);
        if (SUCCEEDED(hr))
        {
            HRESULT     hrT;

            hrT = HrGetSelectionState(pszSubComponentId,
                                      OCSELSTATETYPE_CURRENT);
            if (SUCCEEDED(hrT))
            {
                if (hrT != hr)
                {
                    // wasn't originally installed so...
                    *peit = (hrT == S_OK) ? IT_INSTALL : IT_REMOVE;
                }
                else
                {
                    // was originally checked
                    *peit = IT_NO_CHANGE;
                }
            }
            else
            {
                hr = hrT;
            }
        }
    }

    AssertSz(FImplies(SUCCEEDED(hr), *peit != IT_UNKNOWN), "Succeeded "
             "but we never found out the install type!");

    if (SUCCEEDED(hr))
    {
        hr = S_OK;

#if DBG
        const CHAR *szInstallType;

        switch (*peit)
        {
        case IT_NO_CHANGE:
            szInstallType = "no change";
            break;
        case IT_INSTALL:
            szInstallType = "install";
            break;
        case IT_UPGRADE:
            szInstallType = "upgrade";
            break;
        case IT_REMOVE:
            szInstallType = "remove";
            break;
        default:
            AssertSz(FALSE, "Unknown install type!");
            break;
        }

        TraceTag(ttidNetOc, "Install type of %S is %s.", pszSubComponentId,
                 szInstallType);
#endif

    }

    TraceError("HrGetInstallType", hr);
    return hr;
}

#if DBG
PCWSTR SzFromOcUmsg(UINT uMsg)
{
    switch (uMsg)
    {
    case NETOCM_PRE_INF:
        return L"NETOCM_PRE_INF";

    case NETOCM_POST_INSTALL:
        return L"NETOCM_POST_INSTALL";

    case NETOCM_QUERY_CHANGE_SEL_STATE:
        return L"NETOCM_QUERY_CHANGE_SEL_STATE";

    case NETOCM_QUEUE_FILES:
        return L"NETOCM_QUEUE_FILES";

    default:
        return L"**unknown**";
    }
}
#else
#define SzFromOcUmsg(x)     (VOID)0
#endif

//+---------------------------------------------------------------------------
//
//  Function:   HrCallExternalProc
//
//  Purpose:    Calls a component's external function as defined by
//              the table at the top of this file. This enables a component
//              to perform additional installation tasks that are not common
//              to other components.
//
//  Arguments:
//      pnocd   [in]   Pointer to Net OC Data
//
//  Returns:    S_OK if successful, Win32 error code otherwise.
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT HrCallExternalProc(PNETOCDATA pnocd, UINT uMsg, WPARAM wParam,
                           LPARAM lParam)
{
    HRESULT     hr = S_OK;
    INT         iaocep;

    AssertSz(pnocd, "Bad pnocd in HrCallExternalProc");

    for (iaocep = 0; iaocep < c_cocepMap; iaocep++)
    {
        if (!lstrcmpiW(c_aocepMap[iaocep].pszComponentName,
                      pnocd->pszComponentId))
        {
            TraceTag(ttidNetOc, "Calling external procedure for %S. uMsg = %S"
                     " wParam = %08X,"
                     " lParam = %08X", c_aocepMap[iaocep].pszComponentName,
                     SzFromOcUmsg(uMsg), wParam, lParam);

            // This component has an external proc. Call it now.
            hr = c_aocepMap[iaocep].pfnHrOcExtProc(pnocd, uMsg,
                                                   wParam, lParam);

            // Don't try to call any other functions
            break;
        }
    }

    TraceError("HrCallExternalProc", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallOrRemoveNetCfgComponent
//
//  Purpose:    Utility function for use by optional components that wish to
//              install a NetCfg component from within their own install.
//
//  Arguments:
//      pnocd          [in]     Pointer to NETOC data
//      pszComponentId  [in]     Component ID of NetCfg component to install.
//                              This can be found in the netinfid.cpp file.
//      pszManufacturer [in]     Manufacturer name of component doing the
//                              installing (*this* component). Should always
//                              be "Microsoft".
//      pszProduct      [in]     Short name of product for this component.
//                              Should be something like "MacSrv".
//      pszDisplayName  [in]     Display name of this product. Should be
//                              something like "Services For Macintosh".
//      rguid          [in]     class GUID of the component being installed
//
//  Returns:    S_OK if successful, Win32 error code otherwise.
//
//  Author:     danielwe   6 May 1997
//
//  Notes:
//
HRESULT HrInstallOrRemoveNetCfgComponent(PNETOCDATA pnocd,
                                         PCWSTR pszComponentId,
                                         PCWSTR pszManufacturer,
                                         PCWSTR pszProduct,
                                         PCWSTR pszDisplayName,
                                         const GUID& rguid)
{
    HRESULT                 hr = S_OK;
    INetCfg *               pnc;
    NETWORK_INSTALL_PARAMS  nip = {0};
    BOOL                    fReboot = FALSE;

    nip.dwSetupFlags = FInSystemSetup() ? NSF_PRIMARYINSTALL :
                                          NSF_POSTSYSINSTALL;

    hr = HrOcGetINetCfg(pnocd, TRUE, &pnc);
    if (SUCCEEDED(hr))
    {
        if (pnocd->eit == IT_INSTALL || pnocd->eit == IT_UPGRADE)
        {
            if (*pszComponentId == L'*')
            {
                // Advance past the *
                pszComponentId++;

                // Install OBO user instead
                TraceTag(ttidNetOc, "Installing %S on behalf of the user",
                         pszComponentId);

                hr = HrInstallComponentOboUser(pnc, &nip, rguid,
                                               pszComponentId, NULL);
            }
            else
            {
                TraceTag(ttidNetOc, "Installing %S on behalf of %S",
                         pszComponentId, pnocd->pszSection);

                hr = HrInstallComponentOboSoftware(pnc, &nip,
                                                   rguid,
                                                   pszComponentId,
                                                   pszManufacturer,
                                                   pszProduct,
                                                   pszDisplayName,
                                                   NULL);
            }
        }
        else
        {
            AssertSz(pnocd->eit == IT_REMOVE, "Invalid install action!");

            TraceTag(ttidNetOc, "Removing %S on behalf of %S",
                     pszComponentId, pnocd->pszSection);

            hr = HrRemoveComponentOboSoftware(pnc,
                                              rguid,
                                              pszComponentId,
                                              pszManufacturer,
                                              pszProduct,
                                              pszDisplayName);
            if (NETCFG_S_REBOOT == hr)
            {
                // Save off the fact that we need to reboot
                fReboot = TRUE;
            }
            // Don't care about the return value here. If we can't remove a
            // dependent component, we can't do anything about it so we should
            // still continue the removal of the OC.
            //
            else if (FAILED(hr))
            {
                TraceTag(ttidError, "Failed to remove %S on behalf of %S!! "
                         "Error is 0x%08X",
                         pszComponentId, pnocd->pszSection, hr);
                hr = S_OK;
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = pnc->Apply();
        }

        (VOID) HrUninitializeAndReleaseINetCfg(TRUE, pnc, TRUE);
    }

    if (SUCCEEDED(hr) && fReboot)
    {
        // If all went well and we needed to reboot, set hr back.
        hr = NETCFG_S_REBOOT;
    }

    TraceError("HrInstallOrRemoveNetCfgComponent", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallOrRemoveServices
//
//  Purpose:    Given an install section, installs (or removes) NT services
//              from the section.
//
//  Arguments:
//      hinf          [in]  Handle to INF file.
//      pszSectionName [in]  Name of section to use.
//
//  Returns:    S_OK if successful, WIN32 HRESULT if not.
//
//  Author:     danielwe   23 Apr 1997
//
//  Notes:
//
HRESULT HrInstallOrRemoveServices(HINF hinf, PCWSTR pszSectionName)
{
    static const WCHAR c_szDotServices[] = L"."INFSTR_SUBKEY_SERVICES;

    HRESULT     hr = S_OK;
    PWSTR       pszServicesSection;
    const DWORD c_cchServices = celems(c_szDotServices);
    DWORD       cchName;

    // Look for <szSectionName>.Services to install any NT
    // services if they exist.

    cchName = c_cchServices + lstrlenW(pszSectionName);

    pszServicesSection = new WCHAR [cchName];

    if(pszServicesSection)
    {
        lstrcpyW(pszServicesSection, pszSectionName);
        lstrcatW(pszServicesSection, c_szDotServices);

        if (!SetupInstallServicesFromInfSection(hinf, pszServicesSection, 0))
        {
            hr = HrFromLastWin32Error();
            if (hr == HRESULT_FROM_SETUPAPI(ERROR_SECTION_NOT_FOUND))
            {
                // No problem if section was not found
                hr = S_OK;
            }
        }

        delete [] pszServicesSection;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceError("HrInstallOrRemoveServices", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrHandleOCExtensions
//
//  Purpose:    Handles support for all optional component extensions to the
//              INF file format.
//
//  Arguments:
//      hinfFile         [in]   handle to INF to process
//      pszInstallSection [in]   Install section to process
//
//  Returns:    S_OK if success, setup API HRESULT otherwise
//
//  Author:     danielwe   28 Apr 1997
//
//  Notes:
//
HRESULT HrHandleOCExtensions(HINF hinfFile, PCWSTR pszInstallSection)
{
    HRESULT     hr  = S_OK;

    // There's now common code to do this, so simply make a call to that code.
    //
    hr = HrProcessAllINFExtensions(hinfFile, pszInstallSection);

    TraceError("HrHandleOCExtensions", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallOrRemoveDependOnComponents
//
//  Purpose:    Handles installation or removal of any NetCfg components that
//              the optional component being installed is dependent upon.
//
//  Arguments:
//      pnocd            [in]   Pointer to NETOC data
//      hinf             [in]   Handle to INF file to process.
//      pszInstallSection [in]   Section name to install from.
//      pszDisplayName    [in]   Display name of component being installed.
//
//  Returns:    S_OK if success, setup API HRESULT otherwise
//
//  Author:     danielwe   17 Jun 1997
//
//  Notes:
//
HRESULT HrInstallOrRemoveDependOnComponents(PNETOCDATA pnocd,
                                            HINF hinf,
                                            PCWSTR pszInstallSection,
                                            PCWSTR pszDisplayName)
{
    HRESULT     hr = S_OK;
    PWSTR       mszDepends;
    tstring     strManufacturer;
    PCWSTR      pszManufacturer;

    Assert(pnocd);

    hr = HrSetupGetFirstString(hinf, c_szVersionSection, c_szProvider,
                               &strManufacturer);
    if (S_OK == hr)
    {
        pszManufacturer = strManufacturer.c_str();
    }
    else
    {
        // No provider found, use default
        hr = S_OK;
        pszManufacturer = c_szDefManu;
    }

    hr = HrSetupGetFirstMultiSzFieldWithAlloc(hinf, pszInstallSection,
                                              c_szDependOnComp,
                                              &mszDepends);
    if (S_OK == hr)
    {
        PCWSTR     pszComponent;

        pszComponent = mszDepends;
        while (SUCCEEDED(hr) && *pszComponent)
        {
            const GUID *    pguidClass;
            PCWSTR         pszComponentActual = pszComponent;

            if (*pszComponent == L'*')
            {
                pszComponentActual = pszComponent + 1;
            }

            if (FClassGuidFromComponentId(pszComponentActual, &pguidClass))
            {
                hr = HrInstallOrRemoveNetCfgComponent(pnocd,
                                                      pszComponent,
                                                      pszManufacturer,
                                                      pszInstallSection,
                                                      pszDisplayName,
                                                      *pguidClass);
            }
#ifdef DBG
            else
            {
                TraceTag(ttidNetOc, "Error in INF, Component %S not found!",
                         pszComponent);
            }
#endif
            pszComponent += lstrlenW(pszComponent) + 1;
        }
        delete mszDepends;
    }
    else if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
    {
        // Section is not required.
        hr = S_OK;
    }

    TraceError("HrInstallOrRemoveDependOnComponents", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRunInfSection
//
//  Purpose:    Runs the given INF section, but doesn't copy files
//
//  Arguments:
//      hinf              [in]   Handle to INF to run
//      pnocd             [in]   NetOC Data
//      pszInstallSection [in]   Install section to run
//      dwFlags           [in]   Install flags (SPINST_*)
//
//  Returns:    S_OK if success, SetupAPI or Win32 error otherwise
//
//  Author:     danielwe   16 Dec 1997
//
//  Notes:
//
HRESULT HrRunInfSection(HINF hinf, PNETOCDATA pnocd,
                        PCWSTR pszInstallSection, DWORD dwFlags)
{
    HRESULT     hr;

    // Now we run all sections but CopyFiles and UnregisterDlls because we
    // did that earlier
    //
    hr = HrSetupInstallFromInfSection(g_ocmData.hwnd, hinf,
                                      pszInstallSection,
                                      dwFlags & ~SPINST_FILES & ~SPINST_UNREGSVR,
                                      NULL, NULL, 0, NULL,
                                      NULL, NULL, NULL);

    TraceError("HrRunInfSection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrStartOrStopAnyServices
//
//  Purpose:    Starts or stops any services the INF has requested via the
//              Services value in the main install section.
//
//  Arguments:
//      hinf      [in] handle to INF to process
//      pszSection [in] Install section to process
//      fStart    [in] TRUE to start, FALSE to stop.
//
//  Returns:    S_OK or Win32 error code.
//
//  Author:     danielwe   17 Jun 1997
//
//  Notes:      Services are stopped in the same order they are started.
//
HRESULT HrStartOrStopAnyServices(HINF hinf, PCWSTR pszSection, BOOL fStart)
{
    HRESULT     hr;
    PWSTR      mszServices;

    hr = HrSetupGetFirstMultiSzFieldWithAlloc(hinf, pszSection,
                                              c_szServices, &mszServices);
    if (SUCCEEDED(hr))
    {
        // Build an array of pointers to strings that point at the
        // strings of the multi-sz.  This is needed because the API to
        // stop and start services takes an array of pointers to strings.
        //
        UINT     cServices;
        PCWSTR* apszServices;

        hr = HrCreateArrayOfStringPointersIntoMultiSz(
                mszServices,
                &cServices,
                &apszServices);

        if (SUCCEEDED(hr))
        {
            CServiceManager scm;

            if (fStart)
            {
                hr = scm.HrStartServicesAndWait(cServices, apszServices);
            }
            else
            {
                hr = scm.HrStopServicesAndWait(cServices, apszServices);
            }

            MemFree (apszServices);
        }

        delete mszServices;
    }
    else if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
    {
        // this is a totally optional thing
        hr = S_OK;
    }

    TraceError("HrStartOrStopAnyServices", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDoActualInstallOrUninstall
//
//  Purpose:    Handles main portion of install or uninstall for an optional
//              network component.
//
//  Arguments:
//      hinf             [in]   handle to INF to process
//      pnocd            [in]   Pointer to NETOC data (hwnd, poc)
//      pszInstallSection [in]   Install section to process
//
//  Returns:    S_OK if success, setup API HRESULT otherwise
//
//  Author:     danielwe   17 Jun 1997
//
//  Notes:
//
HRESULT HrDoActualInstallOrUninstall(HINF hinf,
                                     PNETOCDATA pnocd,
                                     PCWSTR pszInstallSection)
{
    HRESULT     hr = S_OK;
    BOOL        fReboot = FALSE;

    AssertSz(pszInstallSection, "Install section is NULL!");
    AssertSz(pnocd, "Bad pnocd in HrDoActualInstallOrUninstall");
    //AssertSz(g_ocmData.hwnd, "Bad g_ocmData.hwnd in HrDoActualInstallOrUninstall");

    if (pnocd->eit == IT_REMOVE)
    {
        hr = HrCallExternalProc(pnocd, NETOCM_PRE_INF, 0, 0);
        if (SUCCEEDED(hr))
        {
            // Now process the component's INF file
            //

            TraceTag(ttidNetOc, "Running INF section %S", pszInstallSection);

            hr = HrRunInfSection(hinf, pnocd, pszInstallSection, SPINST_ALL);
        }
    }
    else
    {
        hr = HrCallExternalProc(pnocd, NETOCM_PRE_INF, 0, 0);
        if (SUCCEEDED(hr))
        {
            // Process the component's INF file
            //

            TraceTag(ttidNetOc, "Running INF section %S", pszInstallSection);

            hr = HrRunInfSection(hinf, pnocd, pszInstallSection,
                                 SPINST_ALL & ~SPINST_REGSVR);
        }
    }

    if (SUCCEEDED(hr))
    {
        // Must install or remove services first
        TraceTag(ttidNetOc, "Running HrInstallOrRemoveServices for %S",
                 pszInstallSection);
        hr = HrInstallOrRemoveServices(hinf, pszInstallSection);
        if (SUCCEEDED(hr))
        {
            // Bug #383239: Wait till services are installed before
            // running the RegisterDlls section
            //
            hr = HrRunInfSection(hinf, pnocd, pszInstallSection,
                                 SPINST_REGSVR);
        }

        if (SUCCEEDED(hr))
        {
            TraceTag(ttidNetOc, "Running HrHandleOCExtensions for %S",
                     pszInstallSection);
            hr = HrHandleOCExtensions(hinf, pszInstallSection);
            if (SUCCEEDED(hr))
            {
                if (!g_ocmData.fNoDepends)
                {
                    // Now install or remove any NetCfg components that this
                    // component requires
                    TraceTag(ttidNetOc, "Running "
                             "HrInstallOrRemoveDependOnComponents for %S",
                             pnocd->pszSection);
                    hr = HrInstallOrRemoveDependOnComponents(pnocd,
                                                             hinf,
                                                             pnocd->pszSection,
                                                             pnocd->strDesc.c_str());
                    if (NETCFG_S_REBOOT == hr)
                    {
                        fReboot = TRUE;
                    }
                }
                else
                {
                    AssertSz(g_ocmData.sic.SetupData.OperationFlags &
                             SETUPOP_BATCH, "How can NoDepends be set??");

                    TraceTag(ttidNetOc, "NOT Running "
                             "HrInstallOrRemoveDependOnComponents for %S "
                             "because NoDepends was set in the answer file.",
                             pnocd->pszSection);
                }

                if (SUCCEEDED(hr))
                {
                    // Now call any external installation support...
                    hr = HrCallExternalProc(pnocd, NETOCM_POST_INSTALL,
                                            0, 0);
                    if (SUCCEEDED(hr))
                    {
                        if (pnocd->eit == IT_INSTALL && !FInSystemSetup())
                        {
                            // ... and finally, start any services they've
                            // requested
                            hr = HrStartOrStopAnyServices(hinf,
                                    pszInstallSection, TRUE);
                            {
                                if (FAILED(hr))
                                {
                                    UINT    ids = IDS_OC_START_SERVICE_FAILURE;

                                    if (HRESULT_FROM_WIN32(ERROR_TIMEOUT) == hr)
                                    {
                                        ids = IDS_OC_START_TOOK_TOO_LONG;
                                    }

                                    // Don't bail installation if service
                                    // couldn't be started. Report an error
                                    // and continue the install.
                                    ReportErrorHr(hr, ids, g_ocmData.hwnd,
                                                  pnocd->strDesc.c_str());
                                    hr = S_OK;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if ((S_OK == hr) && (fReboot))
    {
        hr = NETCFG_S_REBOOT;
    }

    TraceError("HrDoActualInstallOrUninstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOCInstallOrUninstallFromINF
//
//  Purpose:    Handles installation of an Optional Component from its INF
//              file.
//
//  Arguments:
//      pnocd          [in]     Pointer to NETOC data.
//
//  Returns:    S_OK if success, setup API HRESULT otherwise
//
//  Author:     danielwe   6 May 1997
//
//  Notes:
//
HRESULT HrOCInstallOrUninstallFromINF(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;
    tstring     strUninstall;
    PCWSTR      pszInstallSection = NULL;
    BOOL        fSuccess = TRUE;

    Assert(pnocd);

    if (pnocd->eit == IT_REMOVE)
    {
        // Get the name of the uninstall section first
        hr = HrSetupGetFirstString(pnocd->hinfFile, pnocd->pszSection,
                                    c_szUninstall, &strUninstall);
        if (SUCCEEDED(hr))
        {
            pszInstallSection = strUninstall.c_str();
        }
        else
        {
            if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
            {
                // Uninstall section is not required.
                hr = S_OK;
                fSuccess = FALSE;
            }
        }
    }
    else
    {
        pszInstallSection = pnocd->pszSection;
    }

    if (fSuccess)
    {
        hr = HrDoActualInstallOrUninstall(pnocd->hinfFile,
                                          pnocd,
                                          pszInstallSection);
    }

    TraceError("HrOCInstallOrUninstallFromINF", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDoOCInstallOrUninstall
//
//  Purpose:    Installs or removes an optional networking component.
//
//  Arguments:
//      pnocd          [in]   Pointer to NETOC data
//
//  Returns:    S_OK for success, SetupAPI HRESULT error code otherwise.
//
//  Author:     danielwe   6 May 1997
//
//  Notes:
//
HRESULT HrDoOCInstallOrUninstall(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;

    hr = HrOCInstallOrUninstallFromINF(pnocd);

    TraceError("HrDoOCInstallOrUninstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   UiOcErrorFromHr
//
//  Purpose:    Maps a Win32 error code into an understandable error string.
//
//  Arguments:
//      hr [in]     HRESULT to convert
//
//  Returns:    The resource ID of the string.
//
//  Author:     danielwe   9 Feb 1998
//
//  Notes:
//
UINT UiOcErrorFromHr(HRESULT hr)
{
    UINT    uid;

    AssertSz(FAILED(hr), "Don't call UiOcErrorFromHr if Hr didn't fail!");

    switch (hr)
    {
    case HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND):
    case HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND):
        uid = IDS_OC_REGISTER_PROBLEM;
        break;
    case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
        uid = IDS_OC_FILE_PROBLEM;
        break;
    case NETCFG_E_NEED_REBOOT:
    case HRESULT_FROM_WIN32(ERROR_SERVICE_MARKED_FOR_DELETE):
        uid = IDS_OC_NEEDS_REBOOT;
        break;
    case HRESULT_FROM_WIN32(ERROR_CANCELLED):
        uid = IDS_OC_USER_CANCELLED;
        break;
    case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
        uid = IDS_OC_NO_PERMISSION;
        break;
    default:
        uid = IDS_OC_ERROR;
        break;
    }

    return uid;
}

//+---------------------------------------------------------------------------
//
//  Function:   SzErrorToString
//
//  Purpose:    Converts an HRESULT into a displayable string.
//
//  Arguments:
//      hr      [in]    HRESULT value to convert.
//
//  Returns:    LPWSTR a dynamically allocated string to be freed with LocalFree
//
//  Author:     mbend    3 Apr 2000
//
//  Notes:      Attempts to use FormatMessage to convert the HRESULT to a string.
//              If that fails, just convert the HRESULT to a hex string.
//
LPWSTR SzErrorToString(HRESULT hr)
{
    LPWSTR pszErrorText = NULL;
    FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                   FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL, hr,
                   MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                   (WCHAR*)&pszErrorText, 0, NULL);

    if (pszErrorText)
    {
        // Strip off newline characters.
        //
        LPWSTR pchText = pszErrorText;
        while (*pchText && (*pchText != L'\r') && (*pchText != L'\n'))
        {
            pchText++;
        }
        *pchText = 0;

        return pszErrorText;
    }
    // We did't find anything so format the hex value
    WCHAR szBuf[128];
    wsprintfW(szBuf, L"0x%08x", hr);
    WCHAR * szRet = reinterpret_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, lstrlenW(szBuf) * sizeof(WCHAR)));
    if(szRet)
    {
        lstrcpyW(szRet, szBuf);
    }
    return szRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReportErrorHr
//
//  Purpose:    Pops up a message box related to error passed in.
//
//  Arguments:
//      hr      [in]    HRESULT value to report.
//      ids     [in]    Resource ID of string to display.
//      hwnd    [in]    HWND of parent window.
//      pszDesc  [in]    Description of component involved.
//
//  Returns:    Nothing.
//
//  Author:     danielwe   28 Apr 1997
//
//  Notes:      The string resource in ids must contain a %1 and %2 where %1
//              is the name of the component, and %2 is the error code.
//
VOID ReportErrorHr(HRESULT hr, INT ids, HWND hwnd, PCWSTR pszDesc)
{
    BOOL bCleanup = TRUE;
    WCHAR * szText = SzErrorToString(hr);
    if(!szText)
    {
        szText = L"Out of memory!";
        bCleanup = FALSE;
    }
    NcMsgBox(hwnd, IDS_OC_CAPTION, ids, MB_ICONSTOP | MB_OK, pszDesc, szText);
    if(bCleanup)
    {
        LocalFree(szText);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrVerifyStaticIPPresent
//
//  Purpose:    Verify that at least one adapter has a static IP address.
//              Both DHCP Server and WINS need to know this, as they need
//              to bring up UI if this isn't the case. This function is, of
//              course, a complete hack until we can get a properties
//              interface hanging off of the components.
//
//  Arguments:
//      pnc     [in] INetCfg interface to use
//
//  Returns:    S_OK, or valid Win32 error code.
//
//  Author:     jeffspr   19 Jun 1997
//
//  Notes:
//
HRESULT HrVerifyStaticIPPresent(INetCfg *pnc)
{
    HRESULT             hr                  = S_OK;
    HKEY                hkeyInterfaces      = NULL;
    HKEY                hkeyEnum            = NULL;
    INetCfgComponent*   pncc                = NULL;
    HKEY                hkeyTcpipAdapter    = NULL;
    PWSTR               pszBindName        = NULL;

    Assert(pnc);

    // Iterate the adapters in the system looking for non-virtual adapters
    //
    CIterNetCfgComponent nccIter(pnc, &GUID_DEVCLASS_NET);
    while (S_OK == (hr = nccIter.HrNext(&pncc)))
    {
        DWORD   dwFlags = 0;

        // Get the adapter characteristics
        //
        hr = pncc->GetCharacteristics(&dwFlags);
        if (SUCCEEDED(hr))
        {
            DWORD       dwEnableValue   = 0;

            // If we're NOT a virtual adapter, THEN test for
            // tcp/ip static IP
            if (!(dwFlags & NCF_VIRTUAL))
            {
                WCHAR   szRegPath[MAX_PATH+1];

                // Get the component bind name
                //
                hr = pncc->GetBindName(&pszBindName);
                if (FAILED(hr))
                {
                    TraceTag(ttidError,
                            "Error getting bind name from component "
                            "in HrVerifyStaticIPPresent()");
                    goto Exit;
                }

                // Build the path to the TCP/IP instance key for his adapter
                //
                wsprintfW(szRegPath, L"%s\\%s",
                        c_szTcpipInterfacesPath, pszBindName);

                // Open the key for this adapter.
                //
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        szRegPath,
                        KEY_READ, &hkeyTcpipAdapter);
                if (SUCCEEDED(hr))
                {
                    // Read the EnableDHCP value.
                    //
                    hr = HrRegQueryDword(hkeyTcpipAdapter, c_szEnableDHCP,
                            &dwEnableValue);
                    if (FAILED(hr))
                    {
                        TraceTag(ttidError,
                                "Error reading the EnableDHCP value from "
                                "the enumerated key in "
                                "HrVerifyStaticIPPresent()");
                        goto Exit;
                    }

                    // If we've found a non-DHCP-enabled adapter.
                    //
                    if (0 == dwEnableValue)
                    {
                        // We have our man. Take a hike, and return S_OK,
                        // meaning that we had at least one good adapter.
                        // The enumerated key will get cleaned up at exit.
                        hr = S_OK;
                        goto Exit;
                    }

                    RegSafeCloseKey(hkeyTcpipAdapter);
                    hkeyTcpipAdapter = NULL;
                }
                else
                {
                    // If the key wasn't found, we just don't have a
                    // binding to TCP/IP. This is fine, but we don't need
                    // to continue plodding down this path.
                    //
                    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        TraceTag(ttidError,
                                "Error opening adapter key in "
                                "HrVerifyStaticIPPresent()");
                        goto Exit;
                    }
                }
            }
        }

        if (pszBindName)
        {
            CoTaskMemFree(pszBindName);
            pszBindName = NULL;
        }

        ReleaseObj (pncc);
        pncc = NULL;
    }

    // If we haven't found an adapter, we'll have an S_FALSE returned from
    // the HrNext. This is fine, because if we haven't found an adapter
    // with a static IP address, this is exactly what we want to return.
    // If we'd found one, we'd have set hr = S_OK, and dropped out of the
    // loop.

Exit:
    RegSafeCloseKey(hkeyTcpipAdapter);

    if (pszBindName)
    {
        CoTaskMemFree(pszBindName);
        pszBindName = NULL;
    }

    ReleaseObj(pncc);

    TraceError("HrVerifyStaticIPPresent()", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCountConnections
//
//  Purpose:    Determines the number of LAN connections present and returns
//              a pointer to an INetConnection object if only one connection
//              is present.
//
//  Arguments:
//      ppconn [out]    If only one connection is present, this returns it
//
//  Returns:    S_OK if no errors were found and at least one connection
//              exists, S_FALSE if no connections exist, or a Win32 or OLE
//              error code otherwise
//
//  Author:     danielwe   28 Jul 1998
//
//  Notes:
//
HRESULT HrCountConnections(INetConnection **ppconn)
{
    HRESULT                 hr = S_OK;
    INetConnectionManager * pconMan;

    Assert(ppconn);

    *ppconn = NULL;

    // Iterate all LAN connections
    //
    hr = HrCreateInstance(
        CLSID_LanConnectionManager,
        CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        &pconMan);

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

    if (SUCCEEDED(hr))
    {
        CIterNetCon         ncIter(pconMan, NCME_DEFAULT);
        INetConnection *    pconn = NULL;
        INetConnection *    pconnCur = NULL;
        INT                 cconn = 0;

        while (SUCCEEDED(hr) && (S_OK == (ncIter.HrNext(&pconn))))
        {
            ReleaseObj(pconnCur);
            cconn++;
            AddRefObj(pconnCur = pconn);
            ReleaseObj(pconn);
        }

        if (cconn > 1)
        {
            // if more than one connection found, release last one we had
            ReleaseObj(pconnCur);
            hr = S_OK;
        }
        else if (cconn == 0)
        {
            ReleaseObj(pconnCur);
            hr = S_FALSE;
        }
        else    // conn == 1
        {
            *ppconn = pconnCur;
            hr = S_OK;
        }

        ReleaseObj(pconMan);
    }

    TraceError("HrCountConnections", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrHandleStaticIpDependency
//
//  Purpose:    Handles the need that some components have that requires
//              at least one adapter using a static IP address before they
//              can be installed properly.
//
//  Arguments:
//      pnocd   [in]    Pointer to NETOC data
//
//  Returns:    S_OK if success, Win32 HRESULT error code otherwise.
//
//  Author:     danielwe   19 Jun 1997
//
//  Notes:
//

HRESULT HrHandleStaticIpDependency(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;
    static BOOL fFirstInvocation = TRUE;

    // bug 25841. This function is called during installation of DNS, DHCP,
    // and WINS. If all three are being installed togetther then this ends
    // up showing the same error message thrice when one would suffice.

    if( fFirstInvocation )
    {
        fFirstInvocation = FALSE;
    }
    else
    {
        return hr;
    }

    // Can't do anything about this if not in "attended" setup mode
    if (!(g_ocmData.sic.SetupData.OperationFlags & SETUPOP_BATCH))
    {
        BOOL        fChangesApplied = FALSE;
        INetCfg *   pnc = NULL;

        Assert(pnocd);
        //Assert(g_ocmData.hwnd);

        hr = HrOcGetINetCfg(pnocd, FALSE, &pnc);
        if (SUCCEEDED(hr))
        {
            hr = HrVerifyStaticIPPresent(pnc);
            if (hr == S_FALSE)
            {
                INetConnectionCommonUi *    pcommUi;
                INetConnection *            pconn = NULL;

                hr = HrCountConnections(&pconn);
                if (S_OK == hr)
                {
                    // One or more connections found

                    // Display message to user indicating that she has to
                    // configure at least one adapter with a static IP address
                    // before we can continue.
                    NcMsgBox(g_ocmData.hwnd, IDS_OC_CAPTION,
                             IDS_OC_NEED_STATIC_IP,
                             MB_ICONINFORMATION | MB_OK,
                             pnocd->strDesc.c_str());

                    hr = CoCreateInstance(CLSID_ConnectionCommonUi, NULL,
                                          CLSCTX_INPROC | CLSCTX_NO_CODE_DOWNLOAD,
                                          IID_INetConnectionCommonUi,
                                          reinterpret_cast<LPVOID *>(&pcommUi));

                    TraceHr(ttidError, FAL, hr, FALSE, "CoCreateInstance");

                    if (SUCCEEDED(hr))
                    {
                        if (pconn)
                        {
                            // Exactly one connection found
                            hr = pcommUi->ShowConnectionProperties(g_ocmData.hwnd,
                                                                   pconn);
                            if (S_OK == hr)
                            {
                                fChangesApplied = TRUE;
                            }
                            else if (FAILED(hr))
                            {
                                // Eat the error since we can't do anything about it
                                // anyway.
                                TraceError("HrHandleStaticIpDependency - "
                                           "ShowConnectionProperties", hr);
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            // More than one connection found
                            if (SUCCEEDED(hr))
                            {
                                NETCON_CHOOSECONN   chooseCon = {0};

                                chooseCon.lStructSize = sizeof(NETCON_CHOOSECONN);
                                chooseCon.hwndParent = g_ocmData.hwnd;
                                chooseCon.dwTypeMask = NCCHT_LAN;
                                chooseCon.dwFlags    = NCCHF_DISABLENEW;

                                hr = pcommUi->ChooseConnection(&chooseCon, NULL);
                                if (SUCCEEDED(hr))
                                {
                                    fChangesApplied = TRUE;
                                }
                                else
                                {
                                    // Eat the error since we can't do anything about it
                                    // anyway.
                                    TraceError("HrHandleStaticIpDependency - "
                                               "ChooseConnection", hr);
                                    hr = S_OK;
                                }
                            }
                        }

                        ReleaseObj(pcommUi);
                    }

                    ReleaseObj(pconn);

                    if (SUCCEEDED(hr))
                    {
                        // Don't bother checking again if they never
                        // made any changes

                        if (!fChangesApplied ||
                            (S_FALSE == (hr = HrVerifyStaticIPPresent(pnc))))
                        {
                            // Geez, still no static IP address available.
                            // Put up another message box scolding the user for
                            // not following directions.
                            NcMsgBox(g_ocmData.hwnd, IDS_OC_CAPTION,
                                     IDS_OC_STILL_NO_STATIC_IP,
                                     MB_ICONSTOP | MB_OK,
                                     pnocd->strDesc.c_str());
                            hr = S_OK;
                        }
                    }
                }
            }

            hr = HrUninitializeAndReleaseINetCfg(TRUE, pnc, FALSE);
        }
    }
    else
    {
        TraceTag(ttidNetOc, "Not handling static IP dependency for %S "
                 "because we're in unattended mode", pnocd->strDesc.c_str());
    }

    TraceError("HrHandleStaticIpDependency", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcGetINetCfg
//
//  Purpose:    Obtains an INetCfg to work with
//
//  Arguments:
//      pnocd      [in]     OC Data
//      fWriteLock [in]     TRUE if write lock should be acquired, FALSE if
//                          not.
//      ppnc       [out]    Returns INetCfg pointer
//
//  Returns:    S_OK if success, OLE or Win32 error if failed. ERROR_CANCELLED
//              is returned if INetCfg is locked and the users cancels.
//
//  Author:     danielwe   18 Dec 1997
//
//  Notes:
//
HRESULT HrOcGetINetCfg(PNETOCDATA pnocd, BOOL fWriteLock, INetCfg **ppnc)
{
    HRESULT     hr = S_OK;
    PWSTR      pszDesc;
    BOOL        fInitCom = TRUE;

    Assert(ppnc);
    *ppnc = NULL;

top:

    AssertSz(!*ppnc, "Can't have valid INetCfg here!");

    hr = HrCreateAndInitializeINetCfg(&fInitCom, ppnc, fWriteLock, 0,
                                      SzLoadIds(IDS_OC_CAPTION), &pszDesc);
    if ((hr == NETCFG_E_NO_WRITE_LOCK) && !pnocd->fCleanup)
    {
        int     nRet;

        nRet = NcMsgBox(g_ocmData.hwnd, IDS_OC_CAPTION, IDS_OC_CANT_GET_LOCK,
                        MB_RETRYCANCEL | MB_DEFBUTTON1 | MB_ICONWARNING,
                        pnocd->strDesc.c_str(),
                        pszDesc ? pszDesc : SzLoadIds(IDS_OC_GENERIC_COMP));

        CoTaskMemFree(pszDesc);

        if (IDRETRY == nRet)
        {
            goto top;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
    }

    TraceError("HrOcGetINetCfg", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\resource.h ===
#define IDS_OC_STRINGBASE                       500

#define IDS_OC_CAPTION                          IDS_OC_STRINGBASE +  18
#define IDS_OC_ERROR                            IDS_OC_STRINGBASE +  19
#define IDS_OC_START_SERVICE_FAILURE            IDS_OC_STRINGBASE +  20
#define IDS_OC_STOP_SERVICE_FAILURE             IDS_OC_STRINGBASE +  21
#define IDS_OC_NEED_STATIC_IP                   IDS_OC_STRINGBASE +  22
#define IDS_OC_STILL_NO_STATIC_IP               IDS_OC_STRINGBASE +  23
#define IDS_OC_SFM_NO_NTFS                      IDS_OC_STRINGBASE +  25
#define UNUSED_XX1                      IDS_OC_STRINGBASE +  26
#define UNUSED_XX2                      IDS_OC_STRINGBASE +  27
#define IDS_OC_CANT_GET_LOCK                    IDS_OC_STRINGBASE +  28
#define IDS_OC_GENERIC_COMP                     IDS_OC_STRINGBASE +  29
#define IDS_OC_REGISTER_PROBLEM                 IDS_OC_STRINGBASE +  30
#define IDS_OC_FILE_PROBLEM                     IDS_OC_STRINGBASE +  31
#define IDS_OC_NEEDS_REBOOT                     IDS_OC_STRINGBASE +  32
#define IDS_OC_RSVP_SERVICE_NAME                IDS_OC_STRINGBASE +  33
#define IDS_OC_ACS_SERVICE_NAME                 IDS_OC_STRINGBASE +  34

#define IDS_OC_CMAK_STPTITLE                    IDS_OC_STRINGBASE +  35
#define IDS_OC_CMAKPROGGROUP                    IDS_OC_STRINGBASE +  36
#define IDS_OC_CMAKLINK                         IDS_OC_STRINGBASE +  37
#define IDS_OC_NO_ACS_USER_ACCOUNT              IDS_OC_STRINGBASE +  38
#define IDS_OC_ACS_CHG_LOGON                    IDS_OC_STRINGBASE +  39
#define UNUSED_XX3                    IDS_OC_STRINGBASE +  40

#define IDS_OC_SFM_FOLDNAMENT4                  IDS_OC_STRINGBASE +  41
#define IDS_OC_SFM_FOLDNAMENT5                  IDS_OC_STRINGBASE +  42
#define IDS_OC_SFM_VOLNAME                      IDS_OC_STRINGBASE +  43
#define IDS_OC_SFM_UAM_INSTALLER                IDS_OC_STRINGBASE +  44
#define IDS_OC_START_TOOK_TOO_LONG              IDS_OC_STRINGBASE +  45
#define IDS_OC_COMMON_FILES                     IDS_OC_STRINGBASE +  46
#define IDS_OC_MS_SHARED_DAO                    IDS_OC_STRINGBASE +  47
#define IDS_OC_NTOP4_GROUPNAME                  IDS_OC_STRINGBASE +  48
#define IDS_OC_ICS_GROUPNAME                    IDS_OC_STRINGBASE +  49
#define IDS_OC_OLD_IEAK_DOCDIR                  IDS_OC_STRINGBASE +  50

#define IDS_OC_USER_CANCELLED                   IDS_OC_STRINGBASE +  51
#define IDS_OC_SFM_APPLESHARE_FOLDER            IDS_OC_STRINGBASE +  52

#define IDS_OC_NO_PERMS                         IDS_OC_STRINGBASE +  53
#define IDS_OC_ADMIN_TOOLS                      IDS_OC_STRINGBASE +  54
#define IDS_OC_PBA_DESC                         IDS_OC_STRINGBASE +  55
#define IDS_OC_NO_PERMISSION                    IDS_OC_STRINGBASE +  56
#define IDS_OC_PB_DSN_NAME                      IDS_OC_STRINGBASE +  57

#define IDI_PNPU_CMAK    99
#define IDI_PNPU_PBA    98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\sfmsec.h ===
#ifndef _SFMSEC_H
#define _SFMSEC_H

#pragma once

HRESULT HrSecureSfmDirectory(PCWSTR wszPath);

#endif //!_SFMSEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\snmpocx.h ===
#ifndef _SNMPOCX_H
#define _SNMPOCX_H

//---------------- general defines ---------------------
#define MAX_AF_STRING_LEN           1024
#define MAX_REG_STRING_LEN          256

// the section name expected to be found in the answer file
#define AF_SECTION                      L"SNMP"
// registry key
#define REG_KEY_SNMP_PARAMETERS         L"SYSTEM\\CurrentControlSet\\Services\\SNMP\\Parameters"

//---------------- the "Security" Panel ----------------
// answer file keys
#define AF_ACCEPTCOMMNAME               L"Accept_CommunityName"
#define AF_SENDAUTH                     L"Send_Authentication"
#define AF_ANYHOST                      L"Any_Host"
#define AF_LIMITHOST                    L"Limit_Host"
// registry keys
#define REG_KEY_VALID_COMMUNITIES       REG_KEY_SNMP_PARAMETERS L"\\ValidCommunities"
#define REG_KEY_AUTHENTICATION_TRAPS    REG_KEY_SNMP_PARAMETERS L"\\EnableAuthenticationTraps"
#define REG_VALUE_SWITCH                L"switch"
#define REG_VALUE_AUTHENTICATION_TRAPS  L"EnableAuthenticationTraps"
#define REG_NAME_RESOLUTION_RETRIES     L"NameResolutionRetries"
#define REG_KEY_PERMITTED_MANAGERS      REG_KEY_SNMP_PARAMETERS L"\\PermittedManagers"
// security defines
#define SEC_NONE_NAME                   L"NONE"
#define SEC_NONE_VALUE                  0x00000001
#define SEC_NOTIFY_NAME                 L"NOTIFY"
#define SEC_NOTIFY_VALUE                0x00000002
#define SEC_READ_ONLY_NAME              L"READ_ONLY"
#define SEC_READ_ONLY_VALUE             0x00000004
#define SEC_READ_WRITE_NAME             L"READ_WRITE"
#define SEC_READ_WRITE_VALUE            0x00000008
#define SEC_READ_CREATE_NAME            L"READ_CREATE"
#define SEC_READ_CREATE_VALUE           0x00000010
// default community name
#define SEC_DEF_COMM_NAME               L"public"
#define SEC_DEF_COMM_VALUE              SEC_READ_ONLY_VALUE

//----------------- the "Traps" Panel ------------------
// answer file keys
#define AF_TRAPCOMMUNITY                L"Community_Name"
#define AF_TRAPDEST                     L"Traps"
// registry keys
#define REG_KEY_TRAP_DESTINATIONS       REG_KEY_SNMP_PARAMETERS L"\\TrapConfiguration"

//----------------- the "Agent" Panel ------------------
// answer file keys
#define AF_SYSNAME                      L"Contact_Name"
#define AF_SYSLOCATION                  L"Location"
#define AF_SYSSERVICES                  L"Service"
// registry keys
#define REG_KEY_AGENT                   REG_KEY_SNMP_PARAMETERS L"\\RFC1156Agent"
#define SNMP_CONTACT                    L"sysContact"
#define SNMP_LOCATION                   L"sysLocation"
#define SNMP_SERVICES                   L"sysServices"
#define SRV_AGNT_PHYSICAL_NAME          L"Physical"
#define SRV_AGNT_PHYSICAL_VALUE         0x00000001
#define SRV_AGNT_DATALINK_NAME          L"Datalink"
#define SRV_AGNT_DATALINK_VALUE         0x00000002
#define SRV_AGNT_INTERNET_NAME          L"Internet"
#define SRV_AGNT_INTERNET_VALUE         0x00000004
#define SRV_AGNT_ENDTOEND_NAME          L"End-to-End"
#define SRV_AGNT_ENDTOEND_VALUE         0x00000008
#define SRV_AGNT_APPLICATIONS_NAME      L"Applications"
#define SRV_AGNT_APPLICATIONS_VALUE     0x00000040

//~~~~~~~~~~~~~~~~~ registry setting functions ~~~~~~~~~
HRESULT
SnmpRegWriteDword(PWSTR pRegKey,
                  PWSTR pValueName,
                  DWORD dwValueData);

HRESULT
SnmpRegUpgEnableAuthTraps();

HRESULT
SnmpRegWriteCommunities(PWSTR pCommArray);

HRESULT
SnmpRegWriteDefCommunity();

HRESULT
SnmpRegWritePermittedMgrs(BOOL bAnyHost,
                          PWSTR pMgrsList);

HRESULT
SnmpRegWriteTraps(tstring tstrVariable,
                  PWSTR  pTstrArray);

HRESULT
SnmpRegWriteTstring(PWSTR pRegKey,
                    PWSTR pValueName,
                    tstring tstrValueData);

DWORD
SnmpStrArrayToServices(PWSTR pSrvArray);

//~~~~~~~~~~~~~~~adding admin ACL to registry subkey~~~~~
HRESULT SnmpAddAdminAclToKey(PWSTR pwszKey);


#endif // _SNMPOCX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\sfmsec.cpp ===
#include "pch.h"
#pragma hdrstop

#include "sfmsec.h"

#define AFP_MIN_ACCESS          (FILE_READ_ATTRIBUTES | READ_CONTROL)

#define AFP_READ_ACCESS         (READ_CONTROL           |      \
                                                        FILE_READ_ATTRIBUTES |  \
                                                        FILE_TRAVERSE            |      \
                                                        FILE_LIST_DIRECTORY      |      \
                                                        FILE_READ_EA)

#define AFP_WRITE_ACCESS        (FILE_ADD_FILE           |      \
                                                        FILE_ADD_SUBDIRECTORY|  \
                                                        FILE_WRITE_ATTRIBUTES|  \
                                                        FILE_WRITE_EA            |      \
                                                        DELETE)

#define AFP_OWNER_ACCESS        (WRITE_DAC                        | \
                                                         WRITE_OWNER)



SID     AfpSidWorld     = { 1, 1, SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID };
SID     AfpSidNull      = { 1, 1, SECURITY_NULL_SID_AUTHORITY, SECURITY_NULL_RID };
SID     AfpSidSystem    = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };
SID     AfpSidCrtrOwner = { 1, 1, SECURITY_CREATOR_SID_AUTHORITY, SECURITY_CREATOR_OWNER_RID };
SID     AfpSidCrtrGroup = { 1, 1, SECURITY_CREATOR_SID_AUTHORITY, SECURITY_CREATOR_GROUP_RID };

/***    afpAddAceToAcl
 *
 *      Build an Ace corres. to the Sid(s) and mask and add these to the Acl. It is
 *      assumed that the Acl has space for the Aces. If the Mask is 0 (i.e. no access)
 *      the Ace added is a DENY Ace, else a ALLOWED ACE is added.
 */
PACCESS_ALLOWED_ACE
afpAddAceToAcl(
        IN  PACL                                pAcl,
        IN  PACCESS_ALLOWED_ACE pAce,
        IN  ACCESS_MASK                 Mask,
        IN  PSID                                pSid,
        IN  PSID                                pSidInherit OPTIONAL
)
{
        // Add a vanilla ace
        pAcl->AceCount ++;
        pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
        pAce->Header.AceFlags = 0;
        pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
        pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +
                                                        RtlLengthSid(pSid));
        RtlCopySid(RtlLengthSid(pSid), (PSID)(&pAce->SidStart), pSid);

        // Now add an inherit ace
        //

        pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
        pAcl->AceCount ++;
        pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
        pAce->Header.AceFlags = CONTAINER_INHERIT_ACE |
                                                        OBJECT_INHERIT_ACE |
                                                        INHERIT_ONLY_ACE;
        pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
        pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +
                                                        RtlLengthSid(pSid));
        RtlCopySid(RtlLengthSid(pSid), (PSID)(&pAce->SidStart), pSid);

        // Now add an inherit ace for the CreatorOwner/CreatorGroup
        if (ARGUMENT_PRESENT(pSidInherit))
        {
                pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
                pAcl->AceCount ++;
                pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
                pAce->Header.AceFlags = CONTAINER_INHERIT_ACE |
                                                                OBJECT_INHERIT_ACE |
                                                                INHERIT_ONLY_ACE;
                pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
                pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +
                                                                RtlLengthSid(pSidInherit));
                RtlCopySid(RtlLengthSid(pSidInherit), (PSID)(&pAce->SidStart), pSidInherit);
        }

        return ((PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize));
}

/***    afpMoveAces
 *
 *      Move a bunch of aces from the old security descriptor to the new security
 *      descriptor.
 */
PACCESS_ALLOWED_ACE
afpMoveAces(
        IN      PACL                            pOldDacl,
        IN      PACCESS_ALLOWED_ACE     pAceStart,
        IN      PSID                            pSidOldOwner,
        IN      PSID                            pSidNewOwner,
        IN      PSID                            pSidOldGroup,
        IN      PSID                            pSidNewGroup,
        IN      BOOLEAN                         DenyAces,
        IN      OUT PACL                        pNewDacl
)
{
        USHORT                          i;
        PACCESS_ALLOWED_ACE     pAceOld;
        PSID                            pSidAce;

        for (i = 0, pAceOld = (PACCESS_ALLOWED_ACE)((PBYTE)pOldDacl + sizeof(ACL));
                 i < pOldDacl->AceCount;
                 i++, pAceOld = (PACCESS_ALLOWED_ACE)((PBYTE)pAceOld + pAceOld->Header.AceSize))
        {
                // Note: All deny aces are ahead of the grant aces.
                if (DenyAces && (pAceOld->Header.AceType != ACCESS_DENIED_ACE_TYPE))
                        break;

                if (!DenyAces && (pAceOld->Header.AceType == ACCESS_DENIED_ACE_TYPE))
                        continue;

                pSidAce = (PSID)(&pAceOld->SidStart);
                if (!(RtlEqualSid(pSidAce, &AfpSidWorld)                ||
                          RtlEqualSid(pSidAce, pSidOldOwner)            ||
                          RtlEqualSid(pSidAce, pSidNewOwner)            ||
                          RtlEqualSid(pSidAce, &AfpSidCrtrOwner)        ||
                          RtlEqualSid(pSidAce, pSidOldGroup)            ||
                          RtlEqualSid(pSidAce, pSidNewGroup)            ||
                          RtlEqualSid(pSidAce, &AfpSidCrtrGroup)))
                {
                        RtlCopyMemory(pAceStart, pAceOld, pAceOld->Header.AceSize);
                        pAceStart = (PACCESS_ALLOWED_ACE)((PBYTE)pAceStart +
                                     pAceStart->Header.AceSize);
                        pNewDacl->AceCount ++;
                }
        }
        return (pAceStart);
}


/***    FSfmSetUamSecurity
 *
 *      Set the permissions on this directory. Also optionally set the owner and
 *      group ids. For setting the owner and group ids verify if the user has the
 *      needed access. This access is however not good enough. We check for this
 *      access but do the actual setting of the permissions in the special server
 *      context (RESTORE privilege is needed).
 */
HRESULT HrSecureSfmDirectory(PCWSTR wszPath)
{
    HRESULT                 hr = S_OK;
    NTSTATUS                Status;
    DWORD                   SizeNeeded;
    PBYTE                   pBuffer = NULL;
    PBYTE                   pAbsSecDesc = NULL;
    PISECURITY_DESCRIPTOR   pSecDesc;
    SECURITY_INFORMATION    SecInfo = DACL_SECURITY_INFORMATION;
    PACL                    pDaclNew = NULL;
    PACCESS_ALLOWED_ACE     pAce;
    LONG                    SizeNewDacl;
    HANDLE                  DirHandle;
    PWSTR                  pDirPath = NULL;
    UNICODE_STRING          DirectoryName;
    IO_STATUS_BLOCK         IoStatusBlock;
    DWORD                   cbDirPath;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    UINT                    Size;

    //
    // Convert the DIR Path to UNICODE
    //

   pDirPath =  (PWSTR)LocalAlloc(LPTR, (wcslen(wszPath) +
                                  wcslen(L"\\DOSDEVICES\\")+1) *
                                  sizeof(WCHAR));

    if (pDirPath == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto err;
    }

   wcscpy(pDirPath, L"\\DOSDEVICES\\");
   wcscat(pDirPath, wszPath);

   RtlInitUnicodeString(&DirectoryName, pDirPath);

   InitializeObjectAttributes(&ObjectAttributes,
                              &DirectoryName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL);

   Status = NtOpenFile(&DirHandle,
                       WRITE_DAC | READ_CONTROL | SYNCHRONIZE,
                       &ObjectAttributes,
                       &IoStatusBlock,
                       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE ,
                       FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

   LocalFree(pDirPath);

    if (!NT_SUCCESS(Status))
    {
        goto err;
    }

    do
    {
        //
        // Read the security descriptor for this directory
        //

        SizeNeeded = 256;

        do
        {
            if (pBuffer != NULL)
                LocalFree(pBuffer);

            if ((pBuffer = (PBYTE)LocalAlloc(LPTR,SizeNewDacl = SizeNeeded)) == NULL)
            {

                Status = STATUS_NO_MEMORY;
                break;
            }

            Status = NtQuerySecurityObject(DirHandle,
                                           OWNER_SECURITY_INFORMATION |
                                           GROUP_SECURITY_INFORMATION |
                                           DACL_SECURITY_INFORMATION,
                                           (PSECURITY_DESCRIPTOR)pBuffer,
                                           SizeNeeded, &SizeNeeded);

        } while ((Status != STATUS_SUCCESS) &&
                 ((Status == STATUS_BUFFER_TOO_SMALL)   ||
                  (Status == STATUS_BUFFER_OVERFLOW)    ||
                  (Status == STATUS_MORE_ENTRIES)));

        if (!NT_SUCCESS(Status))
        {
            hr = E_FAIL;
            break;
        }

        pSecDesc = (PISECURITY_DESCRIPTOR)pBuffer;

        // If the security descriptor is in self-relative form, convert to absolute
        if (pSecDesc->Control & SE_SELF_RELATIVE)
        {
            DWORD AbsoluteSizeNeeded;

            //
            // An absolute SD is not necessarily the same size as a relative
            // SD, so an in-place conversion may not be possible.
            //

            AbsoluteSizeNeeded = SizeNeeded;
            Status = RtlSelfRelativeToAbsoluteSD2(pSecDesc, &AbsoluteSizeNeeded);
            if (Status == STATUS_BUFFER_TOO_SMALL) {

                //
                // Allocate a new buffer in which to store the absolute
                // security descriptor, copy the contents of the relative
                // descriptor in, and try again.
                // 

                pAbsSecDesc = (PBYTE)LocalAlloc(LPTR,AbsoluteSizeNeeded);
                if (pAbsSecDesc == NULL) {
                    Status = STATUS_NO_MEMORY;
                    break;
                }

                RtlCopyMemory(pAbsSecDesc,pSecDesc,SizeNeeded);
                Status = RtlSelfRelativeToAbsoluteSD2(pAbsSecDesc,
                                                      &AbsoluteSizeNeeded );
                if (NT_SUCCESS(Status)) {
                    pSecDesc = (PISECURITY_DESCRIPTOR)pAbsSecDesc;
                }
            }
        }

        if (!NT_SUCCESS(Status))
        {
            break;
        }

        // Construct the new Dacl. This consists of Aces for World, Owner and Group
        // followed by Old Aces for everybody else, but with Aces for World, OldOwner
        // and OldGroup stripped out. First determine space for the new Dacl and
        // allocated space for the new Dacl. Lets be exteremely conservative. We
        // have two aces each for owner/group/world.

        SizeNewDacl +=
        (RtlLengthSid(pSecDesc->Owner) + sizeof(ACCESS_ALLOWED_ACE) +
         RtlLengthSid(pSecDesc->Group) + sizeof(ACCESS_ALLOWED_ACE) +
         RtlLengthSid(&AfpSidSystem) + sizeof(ACCESS_ALLOWED_ACE) +
         RtlLengthSid(&AfpSidWorld) + sizeof(ACCESS_ALLOWED_ACE)) * 3;

        if ((pDaclNew = (PACL)LocalAlloc(LPTR,SizeNewDacl)) == NULL)
        {

            Status = STATUS_NO_MEMORY;
            hr = E_OUTOFMEMORY;
            break;
        }

        RtlCreateAcl(pDaclNew, SizeNewDacl, ACL_REVISION);
        pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pDaclNew + sizeof(ACL));

        // At this time the Acl list is empty, i.e. no access for anybody
        // Start off by copying the Deny Aces from the original Dacl list
        // weeding out the Aces for World, old and new owner, new and old
        // group, creator owner and creator group
        if (pSecDesc->Dacl != NULL)
        {
            pAce = afpMoveAces(pSecDesc->Dacl, pAce, pSecDesc->Owner,
                               pSecDesc->Owner, pSecDesc->Group, pSecDesc->Group,
                               TRUE, pDaclNew);

        }

        // Now add Aces for System, World, Group & Owner - in that order
        pAce = afpAddAceToAcl(pDaclNew,
                              pAce,
                              AFP_READ_ACCESS,
                              &AfpSidSystem,
                              &AfpSidSystem);

        pAce = afpAddAceToAcl(pDaclNew,
                              pAce,
                              AFP_READ_ACCESS,
                              &AfpSidWorld,
                              NULL);

        pAce = afpAddAceToAcl(pDaclNew,
                              pAce,
                              AFP_READ_ACCESS ,
                              pSecDesc->Group,
                              &AfpSidCrtrGroup);

        pAce = afpAddAceToAcl(pDaclNew,
                              pAce,
                              AFP_READ_ACCESS |  AFP_WRITE_ACCESS,
                              pSecDesc->Owner,
                              &AfpSidCrtrOwner);


        // Now add in the Grant Aces from the original Dacl list weeding out
        // the Aces for World, old and new owner, new and old group, creator
        // owner and creator group
        if (pSecDesc->Dacl != NULL)
        {
            pAce = afpMoveAces(pSecDesc->Dacl, pAce, pSecDesc->Owner,
                               pSecDesc->Owner, pSecDesc->Group, pSecDesc->Group,
                               FALSE, pDaclNew);

        }

        // Now set the new security descriptor
        pSecDesc->Dacl = pDaclNew;

        Status = NtSetSecurityObject(DirHandle, SecInfo, pSecDesc);


    } while (FALSE);

    // Free the allocated buffers before we return
    if (pBuffer != NULL)
        LocalFree(pBuffer);
    if (pDaclNew != NULL)
        LocalFree(pDaclNew);
    if (pAbsSecDesc != NULL)
        LocalFree(pAbsSecDesc);

    if (!NT_SUCCESS(Status))
    {
        hr = E_FAIL;
    }

err:
    TraceError("HrSfmSetUamSecurity", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\svcstart.h ===
#ifndef _SVCSTART_H
#define _SVCSTART_H

int StopServiceAndDependencies(LPCTSTR ServiceName, int AddToRestartList);
int ServicesRestartList_RestartServices(void);

#endif //!_SVCSTART_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\svcstart.cpp ===
#include "pch.h"
#pragma hdrstop
#include <winsvc.h>
#include <winsock.h>
#include <nspapi.h>
#include <tchar.h>

#define PROCESS_SIZE    16

INT InetStartService( LPCTSTR lpServiceName );

TCHAR gServicesWhichMustBeRestarted[20][PROCESS_SIZE];
int gServicesWhichMustBeRestarted_nextuse;
int gServicesWhichMustBeRestarted_total;

int ServicesRestartList_EntryExists(LPCTSTR szServiceName)
{
    int iFoundMatch = FALSE;

    // loop thru the whole list
    for(int i=0; i < gServicesWhichMustBeRestarted_total;i++)
    {
        if (_tcsicmp(gServicesWhichMustBeRestarted[i], szServiceName) == 0)
        {
            iFoundMatch = TRUE;
            break;
        }
    }

    return iFoundMatch;
}


int ServicesRestartList_Add(LPCTSTR szServiceName)
{
    DbgPrint(("ServicesRestartList_Add() on Service %S"), szServiceName);

    // check if this value already exists in the globalarary
    if (ServicesRestartList_EntryExists(szServiceName)) {return FALSE;}
    
    // move info into global array
    if (gServicesWhichMustBeRestarted_nextuse <= 20)
    {
        _tcscpy(gServicesWhichMustBeRestarted[gServicesWhichMustBeRestarted_nextuse],szServiceName);
        // increment counter to array
        // increment next use space
        ++gServicesWhichMustBeRestarted_total;
        ++gServicesWhichMustBeRestarted_nextuse;
    }
    return TRUE;
}

int ServicesRestartList_RestartServices(void)
{
    int iReturn = FALSE;
    INT err = 0;


    // loop thru the whole list and restart the services in reverse
    // order from how they were entered?
    if (gServicesWhichMustBeRestarted_total >= 1)
    {
        DbgPrint(("RestartServices() Start."));
        for(int i=0; i < gServicesWhichMustBeRestarted_total;i++)
        {
            err = InetStartService(gServicesWhichMustBeRestarted[i]);
            DbgPrint(("Start service %S. err=%x"), gServicesWhichMustBeRestarted[i], err);
        }
        DbgPrint(("RestartServices()  End."));
    }

    return iReturn;
}



INT InetStartService( LPCTSTR lpServiceName )
{
    INT err = 0;
    const DWORD dwSvcSleepInterval = 500 ;
    const DWORD dwSvcMaxSleep = 180000 ;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    DbgPrint(("Starting %S service..."), lpServiceName);

    do {
        // set up the service first
        if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        SERVICE_STATUS svcStatus;
        if ( !QueryServiceStatus( hService, &svcStatus ))
        {
            err = ::GetLastError();
            break;
        }

        if ( svcStatus.dwCurrentState == SERVICE_RUNNING )
            break; // service already started and running

        if ( !::StartService( hService, 0, NULL ))
        {
            err = ::GetLastError();
            break;
        }

        //  Wait for the service to attain "running" status; but
        //  wait no more than 3 minute.
        DWORD dwSleepTotal;
        for ( dwSleepTotal = 0 ; dwSleepTotal < dwSvcMaxSleep
            && (QueryServiceStatus( hService, &svcStatus ))
            //&& svcStatus.dwCurrentState == SERVICE_START_PENDING ;
            && svcStatus.dwCurrentState != SERVICE_RUNNING ;
            dwSleepTotal += dwSvcSleepInterval )
        {
            ::Sleep( dwSvcSleepInterval ) ;
        }

        if ( svcStatus.dwCurrentState != SERVICE_RUNNING )
        {
            err = dwSleepTotal > dwSvcMaxSleep ?
                ERROR_SERVICE_REQUEST_TIMEOUT :
                svcStatus.dwWin32ExitCode;
            break;
        }

    } while ( FALSE );

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);
    
    DbgPrint(("Service started with 0x%x"), err);

    return(err);
}


//
//Routine Description:
//    Stop the named service and all those services which depend upon it.
//    And if the service is hung and can't be stopped, then kill the darn thing.
//
//Arguments:
//    ServiceName (Name of service to stop)
//
//Return Status:
//    TRUE - Indicates service successfully stopped
//    FALSE - Timeout occurred.
//
int StopServiceAndDependencies(LPCTSTR ServiceName, int AddToRestartList)
{
    DbgPrint(("StopServiceAndDependencies():%S Service"), ServiceName);

    int Err = 0;
    int iBeforeServiceStatus = 0;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    DWORD Timeout;
    DWORD TimeoutMaxSecs = 60 * 10; //10mins -- iisadmin may take a long time
    int iReturn = FALSE;

    //
    // Open a handle to the Service.
    //
    ScManagerHandle = OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT );
    if (ScManagerHandle == NULL) 
        {
        Err = GetLastError();
                DbgPrint(("StopServiceAndDependencies():OpenSCManager: Err on Service %S Err=0x%x FAILED"), ServiceName, Err);
        goto Cleanup;
    }

    ServiceHandle = OpenService(ScManagerHandle,ServiceName,SERVICE_QUERY_STATUS | SERVICE_INTERROGATE | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_STOP | SERVICE_QUERY_CONFIG );
    if ( ServiceHandle == NULL ) 
        {
        Err = GetLastError();
        if (Err == ERROR_SERVICE_DOES_NOT_EXIST)
        {
             iReturn = TRUE;
             DbgPrint(("StopServiceAndDependencies():%S Service does not exist."), ServiceName);
        }
        else
        {
             DbgPrint(("StopServiceAndDependencies():OpenService: Err on Service %S Err=0x%x FAILED"), ServiceName, Err);
        }
        goto Cleanup;
    }

    // Get the before service status.
    if (QueryServiceStatus(ServiceHandle, &ServiceStatus)) 
    {
        iBeforeServiceStatus = ServiceStatus.dwCurrentState;
    }

    //
    // Ask the service to stop.
    //
    if ( !ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus) ) 
        {
        Err = GetLastError();
        // If there are dependent services running,
        //  determine their names and stop them.
        if ( Err == ERROR_DEPENDENT_SERVICES_RUNNING ) 
                {
            BYTE ConfigBuffer[4096];
            LPENUM_SERVICE_STATUS ServiceConfig = (LPENUM_SERVICE_STATUS) &ConfigBuffer;
            DWORD BytesNeeded;
            DWORD ServiceCount;
            DWORD ServiceIndex;

            //
            // Get the names of the dependent services.
            //
            if ( !EnumDependentServices( ServiceHandle,SERVICE_ACTIVE,ServiceConfig,sizeof(ConfigBuffer),&BytesNeeded,&ServiceCount ) ) 
                        {
                Err = GetLastError();
                DbgPrint(("StopServiceAndDependencies():EnumDependentServices: Err on Service %S Err=0x%x FAILED"), ServiceName, Err);
                goto Cleanup;
            }

            //
            // Stop those services.
            //
            for ( ServiceIndex=0; ServiceIndex<ServiceCount; ServiceIndex++ ) 
                        {
                StopServiceAndDependencies( ServiceConfig[ServiceIndex].lpServiceName, AddToRestartList);
            }

            //
            // Ask the original service to stop.
            //
            if ( !ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus) ) 
                        {
                Err = GetLastError();

                                // check if the service is already stopped..
                                if ( Err == ERROR_SERVICE_CANNOT_ACCEPT_CTRL || Err == ERROR_SERVICE_NOT_ACTIVE) 
                                {
                                        // check if the service is alread stopped.
                                        if (QueryServiceStatus( ServiceHandle, &ServiceStatus )) 
                                        {
                                                if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED || ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) 
                                                        {
                            iReturn = TRUE;
                            goto Cleanup;
                            }
                                        }
                                }
                                else
                                {
                    // The service must be in a hung mode.  Let's kill it.
                    // Todo: NYI
                    DbgPrint(("StopServiceAndDependencies():'%S' Service must be in a hung mode. unable to stop it."), ServiceName);
                    //KillService(ServiceHandle);
                    //goto WaitLoop;
                                }
                        
                goto Cleanup;
            }

        }
                else 
                {
                        // check if the service is already stopped..
                        if ( Err == ERROR_SERVICE_CANNOT_ACCEPT_CTRL || Err == ERROR_SERVICE_NOT_ACTIVE) 
                        {
                                // check if the service is alread stopped.
                                if (QueryServiceStatus( ServiceHandle, &ServiceStatus )) 
                                {
                                        if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED || ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) 
                                                {
                        Err = ServiceStatus.dwCurrentState;
                        iReturn = TRUE;
                        goto Cleanup;
                        }
                                }
                        }
                        else
                        {
                                        // The service must be in a hung mode.  Let's kill it.
                                        DbgPrint(("StopServiceAndDependencies():'%S' Service must be in a hung mode."), ServiceName);
                                        //KillService(ServiceHandle);
                                        //goto WaitLoop;
                        }
                
            goto Cleanup;
        }
    }
    else
    {
        // We successfully asked the service to stop...
    }


    // Loop waiting for the service to stop.
    for ( Timeout=0; Timeout<TimeoutMaxSecs; Timeout++ ) 
    {
        // Return or continue waiting depending on the state of the service.
        if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED ) 
                {
                        // The service successfully stopped.
            DbgPrint(("StopServiceAndDependencies(): %S Service stopped."), ServiceName);
                        iReturn = TRUE;
            goto Cleanup;
        }

        // Wait a second for the service to finish stopping.
        Sleep( 1000 );

        // Query the status of the service again.
        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus ))
                {
            Err = GetLastError();
                        DbgPrint(("StopServiceAndDependencies():QueryServiceStatus: Err on Service %S Err=0x%x FAILED"), ServiceName, Err);
            goto Cleanup;
        }

#if 0
        // if the service we are trying to stop is a driver,
        // then heck we should just get out of here..
        if (TRUE == IsThisServiceADriver(ServiceName))
        {
            DbgPrint(("StopServiceAndDependencies(): %S service is a driver, and can only be removed upon reboot."), ServiceName);
            goto Cleanup;
        }
#endif
    }

    // if we get here then the service failed to stop.
    DbgPrint(("StopServiceAndDependencies(): failed to stop %S service."), ServiceName);

Cleanup:
    if ( ScManagerHandle != NULL )  {(VOID) CloseServiceHandle(ScManagerHandle);}
        if ( ServiceHandle != NULL ) {(VOID) CloseServiceHandle(ServiceHandle);}

    // if we successfully stopped this service, then
    // add it to the restart service list
    if (iReturn == TRUE)
    {
        if (iBeforeServiceStatus == SERVICE_RUNNING)
        {
            if (AddToRestartList) {ServicesRestartList_Add(ServiceName);}
        }
    }
    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\snmpocx.cpp ===
#include "pch.h"
#pragma hdrstop
#include <aclapi.h>
#include "netoc.h"
#include "ncreg.h"
#include "snmpocx.h"

// Allocates an admin ACL to be used with security descriptor
PACL AllocACL()
{
    PACL                        pAcl = NULL;
    PSID                        pSidAdmins = NULL;
    SID_IDENTIFIER_AUTHORITY    Authority = SECURITY_NT_AUTHORITY;

    EXPLICIT_ACCESS ea[1];

    // Create a SID for the BUILTIN\Administrators group.
    if ( !AllocateAndInitializeSid( &Authority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &pSidAdmins ))
    {
        return NULL;
    }


    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    ZeroMemory(&ea, 1 * sizeof(EXPLICIT_ACCESS));
    
    // The ACE will allow the Administrators group full access to the key.
    ea[0].grfAccessPermissions = KEY_ALL_ACCESS;
    ea[0].grfAccessMode = SET_ACCESS;
    ea[0].grfInheritance= NO_INHERITANCE;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[0].Trustee.ptstrName  = (LPTSTR) pSidAdmins;

    // Create a new ACL that contains the new ACEs.
    if (SetEntriesInAcl(1, ea, NULL, &pAcl) != ERROR_SUCCESS) 
    {
        TraceError( "SetEntriesInAcl Error", GetLastError() );
        FreeSid(pSidAdmins);
        return NULL;
    }

    FreeSid(pSidAdmins);

    return pAcl;
}
// frees a ACL
void FreeACL( PACL pAcl)
{
    if (pAcl != NULL)
        LocalFree(pAcl);
}

HRESULT SnmpAddAdminAclToKey(PWSTR pwszKey)
{
    HKEY    hKey = NULL;
    HRESULT hr;
    PACL    pAcl = NULL;
    SECURITY_DESCRIPTOR S_Desc;

    if (pwszKey == NULL)
        return S_FALSE;
    
    // open registy key
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                        pwszKey,         // subkey name
                        KEY_ALL_ACCESS,  // want WRITE_DAC,
                        &hKey            // handle to open key
                          );
    if (hr != S_OK)
    {
        TraceError("SnmpAddAdminDaclToKey::HrRegOpenKeyEx", hr);
        return hr;
    }
    
    // Initialize a security descriptor.  
    if (InitializeSecurityDescriptor (&S_Desc, SECURITY_DESCRIPTOR_REVISION) == 0)
    {
        RegSafeCloseKey(hKey);
        TraceError("SnmpAddAdminDaclToKey::InitializeSecurityDescriptor", GetLastError());
        return S_FALSE;
    }

    // get the ACL and put it into the security descriptor
    if ( (pAcl = AllocACL()) != NULL )
    {
        if (!SetSecurityDescriptorDacl (&S_Desc, TRUE, pAcl, FALSE))
        {
            FreeACL(pAcl);
            RegSafeCloseKey(hKey);
            TraceError("SnmpAddAdminDaclToKey::SetSecurityDescriptorDacl Failed.", GetLastError());
            return S_FALSE;
        }
    }
    else
    {
        RegSafeCloseKey(hKey);
        TraceError("SnmpAddAdminAclToKey::AllocACL Failed.", GetLastError());
        return S_FALSE;
    }


    if (RegSetKeySecurity (hKey, DACL_SECURITY_INFORMATION, &S_Desc)  != ERROR_SUCCESS)
    {
        FreeACL(pAcl);
        RegSafeCloseKey(hKey);
        TraceError("SnmpAddAdminDaclToKey::RegSetKeySecurity", GetLastError());
        return S_FALSE;
    }

    FreeACL(pAcl);
    RegSafeCloseKey(hKey);
    
    return S_OK;
}

HRESULT
SnmpRegWriteDword(PWSTR pszRegKey,
                  PWSTR pszValueName,
                  DWORD dwValueData)
{
    HRESULT hr;
    HKEY    hKey;

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          pszRegKey,
                          0,
                          KEY_QUERY_VALUE | KEY_SET_VALUE,
                          NULL,
                          &hKey,
                          NULL);
    if (hr != S_OK)
    {
        return hr;
    }

    hr = HrRegSetDword(hKey, pszValueName, dwValueData);

    RegSafeCloseKey(hKey);

    return hr;
}

HRESULT
SnmpRegUpgEnableAuthTraps()
{
    HRESULT hr = S_OK;
    HKEY    hKey;

    // open the ..SNMP\Parameters registry key
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        REG_KEY_AUTHENTICATION_TRAPS,
                        KEY_QUERY_VALUE,
                        &hKey);

    // if successful, look for EnableAuthenticationTrap switch
    // in the old registry location
    if (hr == S_OK)
    {
        DWORD dwAuthTrap;

        // get the value of the old 'switch' parameter
        hr = HrRegQueryDword(hKey,
                             REG_VALUE_SWITCH,
                             &dwAuthTrap);

        // if successful transfer the value to the new location
        // if this fails, it means the SNMP service worked with the default value
        // which is already installed through the inf file.
        if (hr == S_OK)
        {
            hr = SnmpRegWriteDword(REG_KEY_SNMP_PARAMETERS,
                                   REG_VALUE_AUTHENTICATION_TRAPS,
                                   dwAuthTrap);
        }

        // close and delete the old registry key as it is obsolete
        RegSafeCloseKey(hKey);
        HrRegDeleteKey (HKEY_LOCAL_MACHINE,
                        REG_KEY_AUTHENTICATION_TRAPS);
    }

    return hr;

}

HRESULT
SnmpRegWriteCommunities(PWSTR pszCommArray)
{
    HRESULT hr;
    HKEY    hKey;
    PWSTR  pszComm, pszAccess;
    DWORD   dwAccess;

    hr = HrRegDeleteKey(HKEY_LOCAL_MACHINE,
                        REG_KEY_VALID_COMMUNITIES);

    if (hr != S_OK)
    {
        return hr;
    }


    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          REG_KEY_VALID_COMMUNITIES,
                          0,
                          KEY_QUERY_VALUE | KEY_SET_VALUE,
                          NULL,
                          &hKey,
                          NULL);

    if (hr != S_OK)
    {
        return hr;
    }
    

    pszComm = pszCommArray;
    while (*pszComm != L'\0')
    {
        dwAccess = SEC_READ_ONLY_VALUE;
        pszAccess = wcschr(pszComm, L':');
        if (pszAccess != NULL)
        {
            *pszAccess = L'\0';
            pszAccess++;

            if (_wcsicmp(pszAccess, SEC_NONE_NAME)==0)
            {
                dwAccess = SEC_NONE_VALUE;
            }
            if (_wcsicmp(pszAccess, SEC_NOTIFY_NAME)==0)
            {
                dwAccess = SEC_NOTIFY_VALUE;
            }
            if (_wcsicmp(pszAccess, SEC_READ_ONLY_NAME)==0)
            {
                dwAccess = SEC_READ_ONLY_VALUE;
            }
            if (_wcsicmp(pszAccess, SEC_READ_WRITE_NAME)==0)
            {
                dwAccess = SEC_READ_WRITE_VALUE;
            }
            if (_wcsicmp(pszAccess, SEC_READ_CREATE_NAME)==0)
            {
                dwAccess = SEC_READ_CREATE_VALUE;
            }
        }

        hr = HrRegSetDword(hKey, pszComm, dwAccess);
        if (hr != S_OK)
        {
            break;
        }
        if (pszAccess != NULL)
        {
            pszComm = pszAccess;
        }
        pszComm += (wcslen(pszComm) + 1);
    }

    RegSafeCloseKey(hKey);
    
    return hr;
}

HRESULT SnmpRegWriteDefCommunity()
{
    HRESULT hr;
    HKEY    hKey;

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          REG_KEY_VALID_COMMUNITIES,
                          0,
                          KEY_QUERY_VALUE | KEY_SET_VALUE,
                          NULL,
                          &hKey,
                          NULL);
    if (hr != S_OK)
    {
        return hr;
    }

    hr = HrRegSetDword(hKey, SEC_DEF_COMM_NAME, SEC_DEF_COMM_VALUE);

    RegSafeCloseKey(hKey);

    return hr;
}

HRESULT SnmpRegWritePermittedMgrs(BOOL bAnyHost,
                                  PWSTR pMgrsList)
{
    HRESULT hr;
    HKEY    hKey;
    UINT    nMgr = 1;
    WCHAR   szMgr[16];

    hr = HrRegDeleteKey(HKEY_LOCAL_MACHINE,
                        REG_KEY_PERMITTED_MANAGERS);

    if (hr != S_OK)
    {
        return hr;
    }

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          REG_KEY_PERMITTED_MANAGERS,
                          0,
                          KEY_QUERY_VALUE | KEY_SET_VALUE,
                          NULL,
                          &hKey,
                          NULL);

    if (hr != S_OK || bAnyHost)
    {
        return hr;
    }

    while(*pMgrsList != L'\0')
    {
        swprintf(szMgr, L"%d", nMgr++);
        hr = HrRegSetSz(hKey, szMgr, pMgrsList);
        if (hr != S_OK)
            break;
        pMgrsList += wcslen(pMgrsList) + 1;
    }

    RegSafeCloseKey(hKey);

    return hr;
}

HRESULT
SnmpRegWriteTraps(tstring tstrVariable,
                  PWSTR  pTstrArray)
{
    HKEY hKey, hKeyTrap;
    HRESULT hr = S_OK;
    UINT    nTrap = 1;
    WCHAR   szTrap[16];

    hr = HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE,
                            REG_KEY_TRAP_DESTINATIONS);

    if (hr != S_OK)
        return hr;

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                      REG_KEY_TRAP_DESTINATIONS,
                      0,
                      KEY_QUERY_VALUE | KEY_SET_VALUE,
                      NULL,
                      &hKey,
                      NULL);

    if (hr != S_OK)
        return hr;

    hr = HrRegCreateKeyEx(hKey,
                       tstrVariable.c_str(),
                       0,
                       KEY_QUERY_VALUE | KEY_SET_VALUE,
                       NULL,
                       &hKeyTrap,
                       NULL);
    if (hr == S_OK)
    {
        // it might just happen that you want to create a
        // community but you don't have the trap destination
        // addresses yet. We should let this happen.
        if (pTstrArray != NULL)
        {
            while(*pTstrArray != L'\0')
            {
                swprintf(szTrap, L"%d", nTrap++);
                hr = HrRegSetSz(hKeyTrap, szTrap, pTstrArray);
                if (hr != S_OK)
                    break;
                pTstrArray += wcslen(pTstrArray) + 1;
            }
        }

        RegSafeCloseKey(hKeyTrap);
    }

    RegSafeCloseKey(hKey);

    return hr;
}

HRESULT
SnmpRegWriteTstring(PWSTR pRegKey,
                    PWSTR pValueName,
                    tstring tstrValueData)
{
    HRESULT hr = S_OK;
    HKEY    hKey;

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          pRegKey,
                          0,
                          KEY_QUERY_VALUE | KEY_SET_VALUE,
                          NULL,
                          &hKey,
                          NULL);
    if (hr != S_OK)
        return hr;

    hr = HrRegSetString(hKey, pValueName, tstrValueData);

    RegSafeCloseKey(hKey);

    return hr;
}

DWORD
SnmpStrArrayToServices(PWSTR pSrvArray)
{
    DWORD dwServices = 0;

    while(*pSrvArray)
    {
        if(_wcsicmp(pSrvArray, SRV_AGNT_PHYSICAL_NAME)==0)
            dwServices |= SRV_AGNT_PHYSICAL_VALUE;
        if(_wcsicmp(pSrvArray, SRV_AGNT_DATALINK_NAME)==0)
            dwServices |= SRV_AGNT_DATALINK_VALUE;
        if(_wcsicmp(pSrvArray, SRV_AGNT_ENDTOEND_NAME)==0)
            dwServices |= SRV_AGNT_ENDTOEND_VALUE;
        if(_wcsicmp(pSrvArray, SRV_AGNT_INTERNET_NAME)==0)
            dwServices |= SRV_AGNT_INTERNET_VALUE;
        if(_wcsicmp(pSrvArray, SRV_AGNT_APPLICATIONS_NAME)==0)
            dwServices |= SRV_AGNT_APPLICATIONS_VALUE;

        pSrvArray += wcslen(pSrvArray) + 1;
    }
    return dwServices;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netoc\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Optional Component Installer"
#define VER_INTERNALNAME_STR            "netoc.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\bindview\binding.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       B I N D I N G . C P P
//
//  Contents:   Functions to illustrate
//              o How to enumerate binding paths.
//              o How to enumerate binding interfaces.
//              o How to enable/disable bindings.
//
//  Notes:      
//
//  Author:     Alok Sinha    15-May-01
//
//----------------------------------------------------------------------------

#include "bindview.h"

//
// Function:  WriteBindings
//
// Purpose:   Write bindings to specified file.
//
// Arguments:
//    fp  [in]  File handle.
//
// Returns:   None.
//
// Notes:
//

VOID WriteBindings (FILE *fp)
{
    INetCfg              *pnc;
    IEnumNetCfgComponent *pencc;
    INetCfgComponent     *pncc;
    LPWSTR               lpszApp;
    HRESULT              hr;
    UINT                 i;


    hr = HrGetINetCfg( FALSE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    if ( hr == S_OK ) {

        for (i=CLIENTS_SELECTED; i <= PROTOCOLS_SELECTED; ++i) {

            fwprintf( fp, L"--- Bindings of %s ---\n", lpszNetClass[i] );

            //
            // Get Component Enumerator Interface.
            //

            hr = HrGetComponentEnum( pnc,
                                     pguidNetClass[i],
                                     &pencc );
            if ( hr == S_OK ) {

                hr = HrGetFirstComponent( pencc, &pncc );

                while( hr == S_OK ) {

                    //
                    // Write bindings of the component.
                    //

                    WriteBindingPath( fp,
                                      pncc );
                    ReleaseRef( pncc );

                    fwprintf( fp, L"\n" );

                    hr = HrGetNextComponent( pencc, &pncc );
                }

                fwprintf( fp, L"\n" );

                //
                // S_FALSE merely indicates that there are no more components.
                //

                if ( hr == S_FALSE ) {
                    hr = S_OK;
                }

                ReleaseRef( pencc );
            }
            else {
                ErrMsg( hr,
                        L"Couldn't get the component enumerator interface." );
            }
        }

        HrReleaseINetCfg( pnc, FALSE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the notify object interface." );
        }
    }

    return;
}

//
// Function:  WriteBindingPath
//
// Purpose:   Write binding paths of a component.
//
// Arguments:
//    fp    [in]  File handle.
//    pncc  [in]  Network component.
//
// Returns:   None.
//
// Notes:
//

VOID WriteBindingPath (FILE *fp,
                       INetCfgComponent *pncc)
{
    IEnumNetCfgBindingPath  *pencbp;
    INetCfgBindingPath      *pncbp;
    LPWSTR                  lpszName;
    HRESULT                 hr;

    //
    // Write the first component's name.
    //

    hr = pncc->GetDisplayName( &lpszName );

    if ( hr == S_OK ) {
        fwprintf( fp, L"\n%s", lpszName );
    }
    else {
        ErrMsg( hr,
                L"Unable to get the display name of a component, "
                L" some binding paths will not be written." );

       return;
    }

    //
    // Get binding path enumerator.
    //

    hr = HrGetBindingPathEnum( pncc,
                               EBP_BELOW,
                               &pencbp );
    if ( hr == S_OK ) {

        hr = HrGetFirstBindingPath( pencbp,
                                    &pncbp );

        while( hr == S_OK ) {

            //
            // Write interfaces of the binding path.
            //

            WriteInterfaces( fp,
                             pncbp );

            ReleaseRef( pncbp );

            hr = HrGetNextBindingPath( pencbp,
                                       &pncbp );
            if ( hr == S_OK ) {
                fwprintf( fp, L"\n%s", lpszName );
            }
        }
  
        ReleaseRef( pencbp );
    }
    else {
        ErrMsg( hr,
                L"Couldn't get the binding path enumerator of %s. "
                L"Its binding paths will not be written.",
                lpszName );
    }

    CoTaskMemFree( lpszName );
    return;
}

//
// Function:  WriteInterfaces
//
// Purpose:   Write bindings to specified file.
//
// Arguments:
//    fp     [in]  File handle.
//    pncbp  [in]  Binding path.
//
// Returns:   None.
//
// Notes:
//

VOID WriteInterfaces (FILE *fp,
                      INetCfgBindingPath *pncbp)
{
    IEnumNetCfgBindingInterface *pencbi;
    INetCfgBindingInterface     *pncbi;
    INetCfgComponent            *pnccLower;
    LPWSTR                      lpszName;
    HRESULT                     hr;

    hr = HrGetBindingInterfaceEnum( pncbp,
                                    &pencbi );

    if ( hr == S_OK ) {

        hr = HrGetFirstBindingInterface( pencbi,
                                         &pncbi );

        //
        // Write lower component of each interface.
        //

        while( hr == S_OK ) {

            hr = pncbi->GetLowerComponent ( &pnccLower );

            if ( hr == S_OK ) {

                hr = pnccLower->GetDisplayName( &lpszName );
                if ( hr == S_OK ) {
                    fwprintf( fp, L"-->%s", lpszName );
                    CoTaskMemFree( lpszName );
                }
            }

            ReleaseRef( pnccLower );
            ReleaseRef( pncbi );

            hr = HrGetNextBindingInterface( pencbi,
                                            &pncbi );
        }

        ReleaseRef( pencbi );
    }
    else {
        ErrMsg( hr,
                L"Couldn't get the binding interface enumerator."
                L"The binding interfaces will not be shown." );
    }

    return;
}

//
// Function:  EnumNetBindings
//
// Purpose:   Enumerate components and their bindings.
//
// Arguments:
//    hwndTree        [in]  Tree handle.
//    uiTypeSelected  [in]  Type of network component selected.
//
// Returns:   TRUE on success.
//
// Notes:
//

BOOL EnumNetBindings (HWND hwndTree,
                      UINT uiTypeSelected)
{
    INetCfg              *pnc;
    IEnumNetCfgComponent *pencc;
    INetCfgComponent     *pncc;
    LPWSTR               lpszApp;
    HTREEITEM            hTreeItem;
    HRESULT              hr;


    hr = HrGetINetCfg( FALSE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    if ( hr == S_OK ) {

        //
        // Get Component Enumerator Interface.
        //

        hr = HrGetComponentEnum( pnc,
                                 pguidNetClass[uiTypeSelected],
                                 &pencc );
        if ( hr == S_OK ) {

            hr = HrGetFirstComponent( pencc, &pncc );

            while( hr == S_OK ) {

                //
                // Add the component's name to the tree.
                //

                hTreeItem = AddToTree( hwndTree,
                                       TVI_ROOT,
                                       pncc );
                if ( hTreeItem ) {

                    //
                    // Enumerate bindings.
                    //

                    ListBindings( pncc,
                                  hwndTree,
                                  hTreeItem );
                }

                ReleaseRef( pncc );

                hr = HrGetNextComponent( pencc, &pncc );
            }

            //
            // S_FALSE merely indicates that there are no more components.
            //

            if ( hr == S_FALSE ) {
                hr = S_OK;
            }

            ReleaseRef( pencc );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the component enumerator interface." );
        }

        HrReleaseINetCfg( pnc, FALSE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the notify object interface." );
        }
    }

    return hr == S_OK;
}

//
// Function:  ListBindings
//
// Purpose:   Enumerate bindings of network components.
//
// Arguments:
//    pncc          [in]  Network component.
//    hwndTree      [in]  Tree handle.
//    hTreeItemRoot [in]   Parent item.
//
// Returns:   None.
//
// Notes:
//

VOID ListBindings (INetCfgComponent *pncc,
                   HWND hwndTree,
                   HTREEITEM hTreeItemRoot)
{
    IEnumNetCfgBindingPath      *pencbp;
    INetCfgBindingPath          *pncbp;
    HTREEITEM                   hTreeItem;
    ULONG                       ulIndex;
    HRESULT                     hr;
  
    hr = HrGetBindingPathEnum( pncc,
                               EBP_BELOW,
                               &pencbp );
    if ( hr == S_OK ) {

        hr = HrGetFirstBindingPath( pencbp,
                                    &pncbp );

        ulIndex = 1;

        while( hr == S_OK ) {

            //
            // Add an item for the binding path.
            //

            hTreeItem = AddBindNameToTree( pncbp,
                                           hwndTree,
                                           hTreeItemRoot,
                                           ulIndex );

            if ( hTreeItem ) {

                //
                // Enumerate interfaces.
                //

                ListInterfaces( pncbp,
                                hwndTree,
                                hTreeItem );
            }

            ReleaseRef( pncbp );

            hr = HrGetNextBindingPath( pencbp,
                                       &pncbp );

            ulIndex++;
        }
  
        ReleaseRef( pencbp );
    }
    else {
       LPWSTR  lpszName;

       if ( pncc->GetDisplayName(&lpszName) == S_OK ) {

          ErrMsg( hr,
                  L"Couldn't get the binding path enumerator of %s. "
                  L"Its binding paths will not be shown.",
                  lpszName );

          CoTaskMemFree( lpszName );
       }
       else {
          ErrMsg( hr,
                  L"Couldn't get the binding path enumerator of a "
                  L"network component. The binding paths will not "
                  L"be shown." );
       }
    }

    return;
}

//
// Function:  ListInterfaces
//
// Purpose:   Enumerate interfaces of a binding path.
//
// Arguments:
//    pncbp         [in]  Binding path.
//    hwndTree      [in]  Tree handle.
//    hTreeItemRoot [in]  Parent item.
//
// Returns:   None.
//
// Notes:
//

VOID ListInterfaces (INetCfgBindingPath *pncbp,
                     HWND hwndTree,
                     HTREEITEM hTreeItemRoot)
{
    IEnumNetCfgBindingInterface *pencbi;
    INetCfgBindingInterface     *pncbi;
    INetCfgComponent            *pnccBound;
    HTREEITEM                   hTreeItem;
    HRESULT                     hr;

    hr = HrGetBindingInterfaceEnum( pncbp,
                                    &pencbi );

    if ( hr == S_OK ) {

        hr = HrGetFirstBindingInterface( pencbi,
                                         &pncbi );
        hTreeItem = hTreeItemRoot;

        while( (hr == S_OK) && hTreeItem ) {

            //
            // Add lower component of every interface to the tree.
            //

            hr = pncbi->GetLowerComponent( &pnccBound );

            hTreeItem = AddToTree( hwndTree,
                                   hTreeItem,
                                   pnccBound );

            ReleaseRef( pnccBound );
            ReleaseRef( pncbi );

            hr = HrGetNextBindingInterface( pencbi,
                                            &pncbi );
        }

        //
        // If hr is S_OK then, the loop terminated due to error in adding
        // the binding path to the tree and pncbi has a reference to an
        // interface.
        //

        if ( hr == S_OK ) {

            ReleaseRef( pncbi );
        }

        ReleaseRef( pencbi );
    }
    else {
        ErrMsg( hr,
                L"Couldn't get the binding interface enumerator."
                L"The binding interfaces will not be shown." );
    }

    return;
}

//
// Function:  HandleBindingPathOperation
//
// Purpose:   
//
// Arguments:
//    hwndOwner    [in]  Owner window.
//    ulSelection  [in]  Option selected.
//    hItem        [in]  Item selected.
//    lParam       [in]  lParam of the item.
//
// Returns:   None.
//
// Notes:
//

VOID HandleBindingPathOperation (HWND hwndOwner,
                                 ULONG ulSelection,
                                 HTREEITEM hItem,
                                 LPARAM lParam)
{
    switch( ulSelection ) {

        case IDI_ENABLE:
        case IDI_DISABLE:

            //
            // Enable/disable binding path.
            //

            EnableBindingPath( hwndOwner,
                               hItem,
                               (LPWSTR)lParam,
                               ulSelection == IDI_ENABLE );
    }

    return;
}

//
// Function:  EnableBindingPath
//
// Purpose:   Enable/disable binding path.
//
// Arguments:
//    hwndOwner      [in]  Owner window.
//    hItem          [in]  Item handle of the binding path.
//    lpszPathToken  [in]  Path token of the binding path.
//    fEnable        [in]  if TRUE, enable, otherwise disable.
//
// Returns:   None.
//
// Notes:
//

VOID EnableBindingPath (HWND hwndOwner,
                        HTREEITEM hItem,
                        LPWSTR lpszPathToken,
                        BOOL fEnable)
{
    INetCfg              *pnc;
    INetCfgBindingPath   *pncbp;
    LPWSTR               lpszInfId;
    LPWSTR               lpszApp;
    HRESULT              hr;

    //
    // Get PnpID of the owner component.
    //

    lpszInfId = GetComponentId( hwndOwner,
                                hItem );

    if ( lpszInfId ) {

        hr = HrGetINetCfg( TRUE,
                           APP_NAME,
                           &pnc,
                           &lpszApp );

        if ( hr == S_OK ) {

            //
            // Find the binding path reference.
            //

            pncbp = FindBindingPath( pnc,
                                     lpszInfId,
                                     lpszPathToken );

            if ( pncbp ) {

                //
                // Enable/disable.
                //

                hr = pncbp->Enable( fEnable );

                if ( hr == S_OK ) {
                    hr = pnc->Apply();

                    if ( hr == S_OK ) {

                        //
                        // Refreshe the state of the item representing the
                        // binding path.
                        //

                        RefreshItemState( hwndOwner,
                                          hItem,
                                          fEnable );
                    }
                    else {
                        ErrMsg( hr,
                                L"Failed to apply changes to the binding path." );
                    }
                }
                else {
                    if ( fEnable ) {
                        ErrMsg( hr,
                                L"Failed to enable the binding path." );
                    }
                    else {
                        ErrMsg( hr,
                                L"Failed to disable the binding path." );
                    }
                }

                ReleaseRef( pncbp );
            }

            HrReleaseINetCfg( pnc,
                             TRUE );
        }
        else {
            if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
               ErrMsg( hr,
                       L"%s currently holds the lock, try later.",
                       lpszApp );

               CoTaskMemFree( lpszApp );
            }
            else {
               ErrMsg( hr,
                       L"Couldn't get the notify object interface." );
            }
        }
    }
    else {
          ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                  L"Couldn't determine the owner of the binding path." );
    }

    return;
}

//
// Function:  GetComponentId
//
// Purpose:   Find the PnpID of a network component.
//
// Arguments:
//    hwndTree  [in]  Tree handle.
//    hItem     [in]  Item handle of the binding path.
//
// Returns:   PnpID of the network component.
//
// Notes:
//

LPWSTR GetComponentId (HWND hwndTree,
                       HTREEITEM hItem)
{
    LPWSTR       lpszInfId;
    HTREEITEM    hTreeItemParent;
    TVITEMW      tvItem;

    lpszInfId = NULL;

    //
    // Get the item handle of the owner component.
    //

    hTreeItemParent = TreeView_GetParent( hwndTree,
                                          hItem );
    if ( hTreeItemParent ) {

        //
        // Get lParam of the owner component. lParam is the PnpID.
        //

        ZeroMemory( &tvItem,
                    sizeof(TVITEMW) );

        tvItem.hItem = hTreeItemParent;
        tvItem.mask = TVIF_PARAM;

        if ( TreeView_GetItem(hwndTree,
                              &tvItem) ) {

            lpszInfId = (LPWSTR)tvItem.lParam;
        }
    }

    return lpszInfId;
}

//
// Function:  WriteBindings
//
// Purpose:   Find the binding path with a give path token.
//
// Arguments:
//    pnc                    [in]  INetCfg reference.
//    lpszInfId              [in]  PnpID of the network component.
//    lpszPathTokenSelected  [in]  Path token of the binding path to search.
//
// Returns:   Reference to the binding path on success, otherwise NULL.
//
// Notes:
//

INetCfgBindingPath *FindBindingPath (INetCfg *pnc,
                                     LPWSTR lpszInfId,
                                     LPWSTR lpszPathTokenSelected)
{
    INetCfgComponent       *pncc;
    IEnumNetCfgBindingPath *pencbp;
    INetCfgBindingPath     *pncbp;
    LPWSTR                 lpszPathToken;
    HRESULT                hr;
    BOOL                   fFound;


    fFound = FALSE;

    //
    // Get the component reference.
    //

    hr = pnc->FindComponent( lpszInfId,
                             &pncc );

    if ( hr == S_OK ) {
     
        hr = HrGetBindingPathEnum( pncc,
                                   EBP_BELOW,
                                   &pencbp );
        if ( hr == S_OK ) {

            hr = HrGetFirstBindingPath( pencbp,
                                        &pncbp );

            // Enumerate each binding path and find the one
            // whose path token matches the specified one.
            //

            while ( !fFound && (hr == S_OK) ) {

                hr = pncbp->GetPathToken( &lpszPathToken );

                if ( hr == S_OK ) {
                    fFound = !wcscmp( lpszPathToken,
                                       lpszPathTokenSelected );

                    CoTaskMemFree( lpszPathToken );
                }

                if ( !fFound ) {
                    ReleaseRef( pncbp );

                    hr = HrGetNextBindingPath( pencbp,
                                               &pncbp );
                }
            }

            ReleaseRef( pencbp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the binding path enumerator interface." );
        }
    }
    else {
        ErrMsg( hr,
                L"Couldn't get an interface pointer to %s.",
                lpszInfId );
    }

    return (fFound) ? pncbp : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\bindview\bindview.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       B I N D V I E W . H
//
//  Contents:   Function Prototypes
//
//  Notes:      
//
//  Author:     Alok Sinha    15-May-01
//
//----------------------------------------------------------------------------

#ifndef _BINDVIEW_H_INCLUDED

#define _BINDVIEW_H_INCLUDED

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <windowsx.h>
#include <wchar.h>
#include <commctrl.h>        // For common controls, e.g. Tree
#include <commdlg.h>
#include <setupapi.h>
#include <devguid.h>

#include "NetCfgAPI.h"
#include "resource.h"

#define ID_STATUS           100
#define APP_NAME            L"BindView"

#define CLIENTS_SELECTED    0
#define SERVICES_SELECTED   1
#define PROTOCOLS_SELECTED  2
#define ADAPTERS_SELECTED   3

#define ITEM_NET_COMPONENTS 1
#define ITEM_NET_BINDINGS   2
#define ITEM_NET_ADAPTERS   4

#define DEFAULT_COMPONENT_SELECTED  CLIENTS_SELECTED

#define WM_NO_COMPONENTS    WM_USER+1

#define MENUITEM_ENABLE     L"Enable"
#define MENUITEM_DISABLE    L"Disable"

extern HINSTANCE    hInstance;
extern const GUID   *pguidNetClass [];
extern LPWSTR       lpszNetClass [];

typedef struct _BIND_UNBIND_INFO {
  LPWSTR lpszInfId;
  BOOL   fBindTo;
} BIND_UNBIND_INFO, *LPBIND_UNBIND_INFO;

//
// Functions defined in bindview.cpp
//

INT_PTR CALLBACK MainDlgProc (HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

INT_PTR CALLBACK BindComponentDlg (HWND hwndDlg,
                                   UINT uMsg,
                                   WPARAM wParam,
                                   LPARAM lParam);

INT_PTR CALLBACK InstallDlg (HWND hwndDlg,
                                      UINT uMsg,
                                      WPARAM wParam,
                                      LPARAM lParam);

INT_PTR CALLBACK UninstallDlg (HWND hwndDlg,
                               UINT uMsg,
                               WPARAM wParam,
                               LPARAM lParam);

VOID DumpBindings (LPWSTR lpszFile);

VOID InstallSelectedComponentType (HWND   hwndDlg,
                                   LPWSTR lpszInfFile);

HRESULT GetPnpID (LPWSTR lpszInfFile,
                  LPWSTR *lppszPnpID);

HRESULT GetKeyValue (HINF hInf,
                     LPCWSTR lpszSection,
                     LPCWSTR lpszKey,
                     DWORD  dwIndex,
                     LPWSTR *lppszValue);

VOID UninstallSelectedComponent (HWND hwndDlg);

VOID ExpandCollapseAll (HWND hwndTree,
                        HTREEITEM hTreeItem,
                        UINT uiFlag);

BOOL GetFileName (HWND hwndDlg,
                  LPWSTR lpszFilter,
                  LPWSTR lpszTitle,
                  DWORD dwFlags,
                  LPWSTR  lpszFile);

VOID ProcessRightClick (LPNMHDR lpnm);

VOID ShowComponentMenu (HWND hwndOwner,
                        HTREEITEM hItem,
                        LPARAM lParam);

VOID ShowBindingPathMenu (HWND hwndOwner,
                          HTREEITEM hItem,
                          LPARAM lParam,
                          BOOL fEnabled);

BOOL GetItemInfo (HWND hwndTree,
                  HTREEITEM hItem,
                  LPARAM *lParam,
                  LPDWORD  lpdwItemType,
                  BOOL *fEnabled);

HTREEITEM AddBindNameToTree (INetCfgBindingPath *pncbp,
                             HWND hwndTree,
                             HTREEITEM hParent,
                             ULONG  ulIndex);

HTREEITEM AddToTree (HWND hwndTree,
                     HTREEITEM hParent,
                     INetCfgComponent *pncc);

VOID RefreshAll (HWND hwndDlg);

VOID RefreshItemState (HWND hwndTree,
                       HTREEITEM hItem,
                       BOOL fEnable);

VOID RefreshBindings (HWND hwndTree,
                      LPWSTR lpszInfId);

VOID ReleaseMemory (HWND hwndTree,
                    HTREEITEM hTreeItem);


VOID DeleteChildren (HWND hwndTree,
                     HTREEITEM hTreeItem);

HTREEITEM InsertItem (HWND hwndTree,
                      UINT uiType);

BOOL UpdateComponentTypeList (HWND hwndTypeList);


VOID ErrMsg (HRESULT hr,
             LPCWSTR  lpFmt,
             ...);

//
// Functions defined in component.cpp
//

VOID HandleComponentOperation (HWND hwndOwner,
                               ULONG ulSelection,
                               HTREEITEM hItem,
                               LPARAM lParam);

VOID BindUnbindComponents( HWND hwndOwner,
                           HTREEITEM hItem,
                           LPWSTR lpszInfId,
                           BOOL fBindTo);

HRESULT InstallComponent (HWND hwndDlg,
                          const GUID *pguidClass);

HRESULT InstallSpecifiedComponent (LPWSTR lpszInfFile,
                                   LPWSTR lpszPnpID,
                                   const GUID *pguidClass);

DWORD ListCompToBindUnbind (LPWSTR lpszInfId,
                            UINT uiType,
                            HWND hwndTree,
                            BOOL fBound);

BOOL BindUnbind (LPWSTR lpszInfId,
                 HWND hwndTree,
                 BOOL fBind);

VOID ListInstalledComponents (HWND hwndTree,
                              const GUID *pguidClass);

HRESULT UninstallComponent (LPWSTR lpszInfId);

//
// Functions defined in binding.cpp
//

VOID WriteBindings (FILE *fp);

VOID WriteBindingPath (FILE *fp,
                       INetCfgComponent *pncc);

VOID WriteInterfaces (FILE *fp,
                      INetCfgBindingPath *pncbp);

BOOL EnumNetBindings (HWND hwndTree,
                      UINT uiTypeSelected);

VOID ListBindings (INetCfgComponent *pncc,
                   HWND hwndTree,
                   HTREEITEM hTreeItemRoot);

VOID ListInterfaces (INetCfgBindingPath *pncbp,
                     HWND hwndTree,
                     HTREEITEM hTreeItemRoot);

VOID HandleBindingPathOperation (HWND hwndOwner,
                                 ULONG ulSelection,
                                 HTREEITEM hItem,
                                 LPARAM lParam);

VOID EnableBindingPath (HWND hwndOwner,
                        HTREEITEM hItem,
                        LPWSTR lpszTokenPath,
                        BOOL fEnable);

LPWSTR GetComponentId (HWND hwndTree,
                       HTREEITEM hItem);

INetCfgBindingPath *FindBindingPath (INetCfg *pnc,
                                     LPWSTR lpszInfId,
                                     LPWSTR lpszPathTokenSelected);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\bindview\netcfgapi.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       N E T C F G A P I . C P P
//
//  Contents:   Functions to illustrate INetCfg API
//
//  Notes:      
//
//  Author:     Alok Sinha    15-May-01
//
//----------------------------------------------------------------------------

#include "NetCfgAPI.h"

//
// Function:  HrGetINetCfg
//
// Purpose:   Get a reference to INetCfg.
//
// Arguments:
//    fGetWriteLock  [in]  If TRUE, Write lock.requested.
//    lpszAppName    [in]  Application name requesting the reference.
//    ppnc           [out] Reference to INetCfg.
//    lpszLockedBy   [in]  Optional. Application who holds the write lock.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrGetINetCfg (IN BOOL fGetWriteLock,
                      IN LPCWSTR lpszAppName,
                      OUT INetCfg** ppnc,
                      OUT LPWSTR *lpszLockedBy)
{
    INetCfg      *pnc = NULL;
    INetCfgLock  *pncLock = NULL;
    HRESULT      hr = S_OK;

    //
    // Initialize the output parameters.
    //

    *ppnc = NULL;

    if ( lpszLockedBy )
    {
        *lpszLockedBy = NULL;
    }
    //
    // Initialize COM
    //

    hr = CoInitialize( NULL );

    if ( hr == S_OK ) {

        //
        // Create the object implementing INetCfg.
        //

        hr = CoCreateInstance( CLSID_CNetCfg,
                               NULL, CLSCTX_INPROC_SERVER,
                               IID_INetCfg,
                               (void**)&pnc );
        if ( hr == S_OK ) {

            if ( fGetWriteLock ) {

                //
                // Get the locking reference
                //

                hr = pnc->QueryInterface( IID_INetCfgLock,
                                          (LPVOID *)&pncLock );
                if ( hr == S_OK ) {

                    //
                    // Attempt to lock the INetCfg for read/write
                    //

                    hr = pncLock->AcquireWriteLock( LOCK_TIME_OUT,
                                                    lpszAppName,
                                                    lpszLockedBy);
                    if (hr == S_FALSE ) {
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }

            if ( hr == S_OK ) {

                //
                // Initialize the INetCfg object.
                //

                hr = pnc->Initialize( NULL );

                if ( hr == S_OK ) {
                    *ppnc = pnc;
                    pnc->AddRef();
                }
                else {

                    //
                    // Initialize failed, if obtained lock, release it
                    //

                    if ( pncLock ) {
                        pncLock->ReleaseWriteLock();
                    }
                }
            }

            ReleaseRef( pncLock );
            ReleaseRef( pnc );
        }

        //
        // In case of error, uninitialize COM.
        //

        if ( hr != S_OK ) {
            CoUninitialize();
        }
    }

    return hr;
}

//
// Function:  HrReleaseINetCfg
//
// Purpose:   Get a reference to INetCfg.
//
// Arguments:
//    pnc           [in] Reference to INetCfg to release.
//    fHasWriteLock [in] If TRUE, reference was held with write lock.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrReleaseINetCfg (IN INetCfg* pnc,
                          IN BOOL fHasWriteLock)
{
    INetCfgLock    *pncLock = NULL;
    HRESULT        hr = S_OK;

    //
    // Uninitialize INetCfg
    //

    hr = pnc->Uninitialize();

    //
    // If write lock is present, unlock it
    //

    if ( hr == S_OK && fHasWriteLock ) {

        //
        // Get the locking reference
        //

        hr = pnc->QueryInterface( IID_INetCfgLock,
                                  (LPVOID *)&pncLock);
        if ( hr == S_OK ) {
           hr = pncLock->ReleaseWriteLock();
           ReleaseRef( pncLock );
        }
    }

    ReleaseRef( pnc );

    //
    // Uninitialize COM.
    //

    CoUninitialize();

    return hr;
}

//
// Function:  HrInstallNetComponent
//
// Purpose:   Install a network component(protocols, clients and services)
//            given its INF file.
//
// Arguments:
//    pnc              [in] Reference to INetCfg.
//    lpszComponentId  [in] PnpID of the network component.
//    pguidClass       [in] Class GUID of the network component.
//    lpszInfFullPath  [in] INF file to install from.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrInstallNetComponent (IN INetCfg *pnc,
                               IN LPCWSTR lpszComponentId,
                               IN const GUID    *pguidClass,
                               IN LPCWSTR lpszInfFullPath)
{
    DWORD     dwError;
    HRESULT   hr = S_OK;
    WCHAR     Drive[_MAX_DRIVE];
    WCHAR     Dir[_MAX_DIR];
    WCHAR     DirWithDrive[_MAX_DRIVE+_MAX_DIR];

    //
    // If full path to INF has been specified, the INF
    // needs to be copied using Setup API to ensure that any other files
    // that the primary INF copies will be correctly found by Setup API
    //

    if ( lpszInfFullPath ) {

        //
        // Get the path where the INF file is.
        //

        _wsplitpath( lpszInfFullPath, Drive, Dir, NULL, NULL );

        wcscpy( DirWithDrive, Drive );
        wcscat( DirWithDrive, Dir );

        //
        // Copy the INF file and other files referenced in the INF file.
        //

        if ( !SetupCopyOEMInfW(lpszInfFullPath,
                               DirWithDrive,  // Other files are in the
                                              // same dir. as primary INF
                               SPOST_PATH,    // First param is path to INF
                               0,             // Default copy style
                               NULL,          // Name of the INF after
                                              // it's copied to %windir%\inf
                               0,             // Max buf. size for the above
                               NULL,          // Required size if non-null
                               NULL) ) {      // Optionally get the filename
                                              // part of Inf name after it is copied.
            dwError = GetLastError();

            hr = HRESULT_FROM_WIN32( dwError );
        }
    }

    if ( S_OK == hr ) {

        //
        // Install the network component.
        //

        hr = HrInstallComponent( pnc,
                                 lpszComponentId,
                                 pguidClass );
        if ( hr == S_OK ) {

            //
            // On success, apply the changes
            //

            hr = pnc->Apply();
        }
    }

    return hr;
}

//
// Function:  HrInstallComponent
//
// Purpose:   Install a network component(protocols, clients and services)
//            given its INF file.
// Arguments:
//    pnc              [in] Reference to INetCfg.
//    lpszComponentId  [in] PnpID of the network component.
//    pguidClass       [in] Class GUID of the network component.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrInstallComponent(IN INetCfg* pnc,
                           IN LPCWSTR szComponentId,
                           IN const GUID* pguidClass)
{
    INetCfgClassSetup   *pncClassSetup = NULL;
    INetCfgComponent    *pncc = NULL;
    OBO_TOKEN           OboToken;
    HRESULT             hr = S_OK;

    //
    // OBO_TOKEN specifies on whose behalf this
    // component is being installed.
    // Set it to OBO_USER so that szComponentId will be installed
    // on behalf of the user.
    //

    ZeroMemory( &OboToken,
                sizeof(OboToken) );
    OboToken.Type = OBO_USER;

    //
    // Get component's setup class reference.
    //

    hr = pnc->QueryNetCfgClass ( pguidClass,
                                 IID_INetCfgClassSetup,
                                 (void**)&pncClassSetup );
    if ( hr == S_OK ) {

        hr = pncClassSetup->Install( szComponentId,
                                     &OboToken,
                                     0,
                                     0,       // Upgrade from build number.
                                     NULL,    // Answerfile name
                                     NULL,    // Answerfile section name
                                     &pncc ); // Reference after the component
        if ( S_OK == hr ) {                   // is installed.

            //
            // we don't need to use pncc (INetCfgComponent), release it
            //

            ReleaseRef( pncc );
        }

        ReleaseRef( pncClassSetup );
    }

    return hr;
}

//
// Function:  HrUninstallNetComponent
//
// Purpose:   Uninstall a network component(protocols, clients and services).
//
// Arguments:
//    pnc           [in] Reference to INetCfg.
//    szComponentId [in] PnpID of the network component to uninstall.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrUninstallNetComponent(IN INetCfg* pnc,
                                IN LPCWSTR szComponentId)
{
    INetCfgComponent    *pncc = NULL;
    INetCfgClass        *pncClass = NULL;
    INetCfgClassSetup   *pncClassSetup = NULL;
    OBO_TOKEN           OboToken;
    GUID                guidClass;
    HRESULT             hr = S_OK;

    //
    // OBO_TOKEN specifies on whose behalf this
    // component is being installed.
    // Set it to OBO_USER so that szComponentId will be installed
    // on behalf of the user.
    //

    ZeroMemory( &OboToken,
                sizeof(OboToken) );
    OboToken.Type = OBO_USER;

    //
    // Get the component's reference.
    //

    hr = pnc->FindComponent( szComponentId,
                             &pncc );

    if (S_OK == hr) {

        //
        // Get the component's class GUID.
        //

        hr = pncc->GetClassGuid( &guidClass );

        if ( hr == S_OK ) {

            //
            // Get component's class reference.
            //

            hr = pnc->QueryNetCfgClass( &guidClass,
                                        IID_INetCfgClass,
                                        (void**)&pncClass );
            if ( hr == S_OK ) {

                //
                // Get Setup reference.
                //

                hr = pncClass->QueryInterface( IID_INetCfgClassSetup,
                                               (void**)&pncClassSetup );
                    if ( hr == S_OK ) {

                         hr = pncClassSetup->DeInstall( pncc,
                                                        &OboToken,
                                                        NULL);
                         if ( hr == S_OK ) {

                             //
                             // Apply the changes
                             //

                             hr = pnc->Apply();
                         }

                         ReleaseRef( pncClassSetup );
                    }

                ReleaseRef( pncClass );
            }
        }

        ReleaseRef( pncc );
    }

    return hr;
}

//
// Function:  HrGetComponentEnum
//
// Purpose:   Get network component enumerator reference.
//
// Arguments:
//    pnc         [in]  Reference to INetCfg.
//    pguidClass  [in]  Class GUID of the network component.
//    ppencc      [out] Enumerator reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrGetComponentEnum (INetCfg* pnc,
                            IN const GUID* pguidClass,
                            OUT IEnumNetCfgComponent **ppencc)
{
    INetCfgClass  *pncclass;
    HRESULT       hr;

    *ppencc = NULL;

    //
    // Get the class reference.
    //

    hr = pnc->QueryNetCfgClass( pguidClass,
                                IID_INetCfgClass,
                                (PVOID *)&pncclass );

    if ( hr == S_OK ) {

        //
        // Get the enumerator reference.
        //

        hr = pncclass->EnumComponents( ppencc );

        //
        // We don't need the class reference any more.
        //

        ReleaseRef( pncclass );
    }

    return hr;
}

//
// Function:  HrGetFirstComponent
//
// Purpose:   Enumerates the first network component.
//
// Arguments:
//    pencc      [in]  Component enumerator reference.
//    ppncc      [out] Network component reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrGetFirstComponent (IN IEnumNetCfgComponent* pencc,
                             OUT INetCfgComponent **ppncc)
{
    HRESULT  hr;
    ULONG    ulCount;

    *ppncc = NULL;

    pencc->Reset();

    hr = pencc->Next( 1,
                      ppncc,
                      &ulCount );
    return hr;
}

//
// Function:  HrGetNextComponent
//
// Purpose:   Enumerate the next network component.
//
// Arguments:
//    pencc      [in]  Component enumerator reference.
//    ppncc      [out] Network component reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:     The function behaves just like HrGetFirstComponent if
//            it is called right after HrGetComponentEnum.
//
//

HRESULT HrGetNextComponent (IN IEnumNetCfgComponent* pencc,
                            OUT INetCfgComponent **ppncc)
{
    HRESULT  hr;
    ULONG    ulCount;

    *ppncc = NULL;

    hr = pencc->Next( 1,
                      ppncc,
                      &ulCount );
    return hr;
}

//
// Function:  HrGetBindingPathEnum
//
// Purpose:   Get network component's binding path enumerator reference.
//
// Arguments:
//    pncc           [in]  Network component reference.
//    dwBindingType  [in]  EBP_ABOVE or EBP_BELOW.
//    ppencbp        [out] Enumerator reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrGetBindingPathEnum (IN INetCfgComponent *pncc,
                              IN DWORD dwBindingType,
                              OUT IEnumNetCfgBindingPath **ppencbp)
{
    INetCfgComponentBindings *pnccb = NULL;
    HRESULT                  hr;

    *ppencbp = NULL;

    //
    // Get component's binding.
    //

    hr = pncc->QueryInterface( IID_INetCfgComponentBindings,
                               (PVOID *)&pnccb );

    if ( hr == S_OK ) {

        //
        // Get binding path enumerator reference.
        //

        hr = pnccb->EnumBindingPaths( dwBindingType,
                                      ppencbp );

        ReleaseRef( pnccb );
    }

    return hr;
}

//
// Function:  HrGetFirstBindingPath
//
// Purpose:   Enumerates the first binding path.
//
// Arguments:
//    pencc      [in]  Binding path enumerator reference.
//    ppncc      [out] Binding path reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrGetFirstBindingPath (IN IEnumNetCfgBindingPath *pencbp,
                               OUT INetCfgBindingPath **ppncbp)
{
    ULONG   ulCount;
    HRESULT hr;

    *ppncbp = NULL;

    pencbp->Reset();

    hr = pencbp->Next( 1,
                       ppncbp,
                       &ulCount );

    return hr;
}

//
// Function:  HrGetNextBindingPath
//
// Purpose:   Enumerate the next binding path.
//
// Arguments:
//    pencbp      [in]  Binding path enumerator reference.
//    ppncbp      [out] Binding path reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:     The function behaves just like HrGetFirstBindingPath if
//            it is called right after HrGetBindingPathEnum.
//
//

HRESULT HrGetNextBindingPath (IN IEnumNetCfgBindingPath *pencbp,
                              OUT INetCfgBindingPath **ppncbp)
{
    ULONG   ulCount;
    HRESULT hr;

    *ppncbp = NULL;

    hr = pencbp->Next( 1,
                       ppncbp,
                       &ulCount );

    return hr;
}

//
// Function:  HrGetBindingInterfaceEnum
//
// Purpose:   Get binding interface enumerator reference.
//
// Arguments:
//    pncbp          [in]  Binding path reference.
//    ppencbp        [out] Enumerator reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrGetBindingInterfaceEnum (IN INetCfgBindingPath *pncbp,
                                   OUT IEnumNetCfgBindingInterface **ppencbi)
{
    HRESULT hr;

    *ppencbi = NULL;

    hr = pncbp->EnumBindingInterfaces( ppencbi );

    return hr;
}

//
// Function:  HrGetFirstBindingInterface
//
// Purpose:   Enumerates the first binding interface.
//
// Arguments:
//    pencbi      [in]  Binding interface enumerator reference.
//    ppncbi      [out] Binding interface reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrGetFirstBindingInterface (IN IEnumNetCfgBindingInterface *pencbi,
                                    OUT INetCfgBindingInterface **ppncbi)
{
    ULONG   ulCount;
    HRESULT hr;

    *ppncbi = NULL;

    pencbi->Reset();

    hr = pencbi->Next( 1,
                       ppncbi,
                       &ulCount );

    return hr;
}

//
// Function:  HrGetNextBindingInterface
//
// Purpose:   Enumerate the next binding interface.
//
// Arguments:
//    pencbi      [in]  Binding interface enumerator reference.
//    ppncbi      [out] Binding interface reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:     The function behaves just like HrGetFirstBindingInterface if
//            it is called right after HrGetBindingInterfaceEnum.
//
//

HRESULT HrGetNextBindingInterface (IN IEnumNetCfgBindingInterface *pencbi,
                                   OUT INetCfgBindingInterface **ppncbi)
{
    ULONG   ulCount;
    HRESULT hr;

    *ppncbi = NULL;

    hr = pencbi->Next( 1,
                       ppncbi,
                       &ulCount );

    return hr;
}

//
// Function:  ReleaseRef
//
// Purpose:   Release reference.
//
// Arguments:
//    punk     [in]  IUnknown reference to release.
//
// Returns:   Reference count.
//
// Notes:
//

VOID ReleaseRef (IN IUnknown* punk)
{
    if ( punk ) {
        punk->Release();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\bindview\component.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       C O M P O N E N T . C P P
//
//  Contents:   Functions to illustrate
//              o How to enumerate network components.
//              o How to install protocols, clients and services.
//              o How to uninstall protocols, clients and services.
//              o How to bind/unbind network components.
//
//  Notes:      
//
//  Author:     Alok Sinha    15-May-01
//
//----------------------------------------------------------------------------

#include "bindview.h"

//
// Function:  HandleComponentOperation
//
// Purpose:   Do component specific functions.
//
// Arguments:
//    hwndOwner    [in]  Owner window.
//    ulSelection  [in]  Option selected.
//    hItem        [in]  Item selected.
//    lParam       [in]  lParam of the item.
//
// Returns:   None.
//
// Notes:
//

VOID HandleComponentOperation (HWND hwndOwner,
                               ULONG ulSelection,
                               HTREEITEM hItem,
                               LPARAM lParam)
{
    switch( ulSelection ) {

        case IDI_BIND_TO:
        case IDI_UNBIND_FROM:

            //
            // Bind/unbind components.
            //

            BindUnbindComponents( hwndOwner,
                                  hItem,
                                  (LPWSTR)lParam,
                                  ulSelection == IDI_BIND_TO );
    }

    return;
}

//
// Function:  BindUnbindComponents
//
// Purpose:   Bind/unbind a network component.
//
// Arguments:
//    hwndOwner  [in]  Owner window.
//    hItem      [in]  Item handle of the network component.
//    lpszInfId  [in]  PnpID of the network component.
//    fBindTo    [in]  if TRUE, bind, otherwise unbind.
//
// Returns:   None.
//
// Notes:
//

VOID BindUnbindComponents( HWND hwndOwner,
                           HTREEITEM hItem,
                           LPWSTR lpszInfId,
                           BOOL fBindTo)
{
    BIND_UNBIND_INFO  BindUnbind;

    BindUnbind.lpszInfId = lpszInfId;
    BindUnbind.fBindTo = fBindTo;

    DialogBoxParam( hInstance,
                    MAKEINTRESOURCE(IDD_BIND_UNBIND),
                    hwndOwner,
                    BindComponentDlg,
                    (LPARAM)&BindUnbind ); 

    return;
}

//
// Function:  InstallComponent
//
// Purpose:   Install a network component.
//
// Arguments:
//    hwndDlg     [in]  Owner window.
//    pguidClass  [in]  Class GUID of type of network component to install.
//
// Returns:   S_OK on success, otherwise and error code.
//
// Notes:
//

HRESULT InstallComponent (HWND hwndDlg,
                          const GUID *pguidClass)
{
    INetCfg              *pnc;
    INetCfgClass         *pncClass;
    INetCfgClassSetup    *pncClassSetup;
    LPWSTR               lpszApp;
    OBO_TOKEN            obo;
    HRESULT              hr;

    //
    // Get INetCfg reference.
    //

    hr = HrGetINetCfg( TRUE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    if ( hr == S_OK ) {

        //
        // Get network component's class reference.
        //

        hr = pnc->QueryNetCfgClass( pguidClass,
                                    IID_INetCfgClass,
                                    (PVOID *)&pncClass );

        if ( hr == S_OK ) {

            //
            // Get Setup class reference.
            //

            hr = pncClass->QueryInterface( IID_INetCfgClassSetup,
                                           (LPVOID *)&pncClassSetup );

            if ( hr == S_OK ) {

                ZeroMemory( &obo,
                            sizeof(OBO_TOKEN) );

                obo.Type = OBO_USER;

                //
                // Let the network class installer prompt the user to select
                // a network component to install.
                //

                hr = pncClassSetup->SelectAndInstall( hwndDlg,
                                                      &obo,
                                                      NULL );

                if ( (hr == S_OK) || (hr == NETCFG_S_REBOOT) ) {

                    hr = pnc->Apply();
                }
                else {
                    if ( hr != HRESULT_FROM_WIN32(ERROR_CANCELLED) ) {
                        ErrMsg( hr,
                                L"Couldn't install the network component." );
                    }
                }

                ReleaseRef( pncClassSetup );
            }
            else {
                ErrMsg( hr,
                        L"Couldn't get an interface to setup class." );
            }

            ReleaseRef( pncClass );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get a pointer to class interface." );
        }

        HrReleaseINetCfg( pnc,
                          TRUE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't the get notify object interface." );
        }
    }
 
    return hr;
}

//
// Function:  InstallSpecifiedComponent
//
// Purpose:   Install a network component from an INF file.
//
// Arguments:
//    lpszInfFile [in]  INF file.
//    lpszPnpID   [in]  PnpID of the network component to install.
//    pguidClass  [in]  Class GUID of the network component.
//
// Returns:   None.
//
// Notes:
//

HRESULT InstallSpecifiedComponent (LPWSTR lpszInfFile,
                                   LPWSTR lpszPnpID,
                                   const GUID *pguidClass)
{
    INetCfg    *pnc;
    LPWSTR     lpszApp;
    HRESULT    hr;

    hr = HrGetINetCfg( TRUE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    if ( hr == S_OK ) {

        //
        // Install the network component.
        //

        hr = HrInstallNetComponent( pnc,
                                    lpszPnpID,
                                    pguidClass,
                                    lpszInfFile );
        if ( (hr == S_OK) || (hr == NETCFG_S_REBOOT) ) {

            hr = pnc->Apply();
        }
        else {
            if ( hr != HRESULT_FROM_WIN32(ERROR_CANCELLED) ) {
                ErrMsg( hr,
                        L"Couldn't install the network component." );
            }
        }

        HrReleaseINetCfg( pnc,
                          TRUE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't the get notify object interface." );
        }
    }

    return hr;
}

//
// Function:  ListCompToBindUnbind
//
// Purpose:   List all the components that are bound or bindable.
//
// Arguments:
//    lpszInfId [in]  PnpID of the network component.
//    uiType    [in]  Type of network component.
//    hwndTree  [in]  Tree handle in which to list.
//    fBound    [in]  if TRUE, list components that are bound.
//
// Returns:   Number of components listed.
//
// Notes:
//

DWORD ListCompToBindUnbind (LPWSTR lpszInfId,
                            UINT uiType,
                            HWND hwndTree,
                            BOOL fBound)
{
    INetCfg                   *pnc;
    INetCfgComponent          *pncc;
    IEnumNetCfgComponent      *pencc;
    INetCfgComponentBindings  *pnccb;
    INetCfgComponent          *pnccToBindUnbind;
    LPWSTR                    lpszApp;
    DWORD                     dwCount;
    HRESULT                   hr;


    dwCount = 0;
    hr = HrGetINetCfg( TRUE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    if ( hr == S_OK ) {

        //
        // Get a reference to the network component selected.
        //

        hr = pnc->FindComponent( lpszInfId,
                                 &pncc );

        if ( hr == S_OK ) {

            //
            // Get Component Enumerator Interface.
            //

            hr = HrGetComponentEnum( pnc,
                                     pguidNetClass[uiType],
                                     &pencc );
            if ( hr == S_OK ) {

                hr = pncc->QueryInterface( IID_INetCfgComponentBindings,
                                          (PVOID *)&pnccb );
                if ( hr == S_OK ) {

                    hr = HrGetFirstComponent( pencc, &pnccToBindUnbind );

                    while( hr == S_OK ) {

                        hr = pnccb->IsBoundTo( pnccToBindUnbind );

                        //
                        // fBound = TRUE ==> Want to list components that are
                        // bound.
                        //

                        if ( fBound ) {
                  
                            if ( hr == S_OK ) {
                                AddToTree( hwndTree,
                                           TVI_ROOT,
                                           pnccToBindUnbind );
                                dwCount++;
                            }
                        }
                        else {

                            //
                            // fBound = FALSE ==> Want to list components that 
                            // are not bound but are bindable.
                            //

                            if ( hr == S_FALSE ) {

                                hr = pnccb->IsBindableTo( pnccToBindUnbind );

                                if ( hr == S_OK ) {
                                    AddToTree( hwndTree,
                                               TVI_ROOT,
                                               pnccToBindUnbind );
                                    dwCount++;
                                }
                            }
                        }

                        ReleaseRef( pnccToBindUnbind );

                        hr = HrGetNextComponent( pencc, &pnccToBindUnbind );
                    }

                    ReleaseRef( pnccb );
                }
                else {
                    ErrMsg( hr,
                            L"Couldn't get the component binding interface "
                            L"of %s.",
                            lpszInfId );
                }

                ReleaseRef( pencc );
            }
            else {
                ErrMsg( hr,
                        L"Couldn't get the network component enumerator "
                        L"interface." );
            }
  
            ReleaseRef( pncc );

        }
        else {
            ErrMsg( hr,
                    L"Couldn't get an interface pointer to %s.",
                    lpszInfId );
        }

        HrReleaseINetCfg( pnc,
                          TRUE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the notify object interface." );
        }
    }

    return dwCount;
}

//
// Function:  BindUnbind
//
// Purpose:   Bind/unbind a network component.
//
// Arguments:
//    lpszInfId  [in]  PnpID of the network component to bind/unbind.
//    hwndTree   [in]  Tree handle.
//    fBind      [in]  if TRUE, bind, otherwise unbind.
//
// Returns:   TRUE on success.
//                       
// Notes:
//

BOOL BindUnbind (LPWSTR lpszInfId,
                 HWND hwndTree,
                 BOOL fBind)
{
    INetCfg                   *pnc;
    INetCfgComponent          *pncc;
    INetCfgComponentBindings  *pnccb;
    INetCfgComponent          *pnccToBindUnbind;
    LPWSTR                    lpszApp;
    HTREEITEM                 hTreeItem;
    TVITEMW                   tvItem;
    HRESULT                   hr;
    BOOL                      fChange;


    hr = HrGetINetCfg( TRUE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    fChange = FALSE;

    if ( hr == S_OK ) {

        //
        // Get a reference to the network component.
        //

        hr = pnc->FindComponent( lpszInfId,
                                 &pncc );
        if ( hr == S_OK ) {

            //
            // Get a reference to the component's binding.
            //

            hr = pncc->QueryInterface( IID_INetCfgComponentBindings,
                                         (PVOID *)&pnccb );
            if ( hr == S_OK ) {

                //
                // Start with the root item.
                //

                hTreeItem = TreeView_GetRoot( hwndTree );

                //
                // Bind/unbind the network component with every component
                // that is checked.
                //

                while ( hTreeItem ) {

                    ZeroMemory( &tvItem,
                                sizeof(TVITEMW) );

                    tvItem.hItem = hTreeItem;
                    tvItem.mask = TVIF_PARAM | TVIF_STATE;
                    tvItem.stateMask = TVIS_STATEIMAGEMASK;

                    if ( TreeView_GetItem(hwndTree,
                                          &tvItem) ) {

                        //
                        // Is the network component selected?
                        //

                        if ( (tvItem.state >> 12) == 2 ) {

                            //
                            // Get a reference to the selected component.
                            //

                            hr = pnc->FindComponent( (LPWSTR)tvItem.lParam,
                                                     &pnccToBindUnbind );
                            if ( hr == S_OK ) {

                                if ( fBind ) {

                                    //
                                    // Bind the component to the selected component.
                                    //

                                    hr = pnccb->BindTo( pnccToBindUnbind );

                                    if ( !fChange ) {
                                        fChange = hr == S_OK;
                                    }

                                    if ( hr != S_OK ) {
                                        ErrMsg( hr,
                                                L"%s couldn't be bound to %s.",
                                                     lpszInfId, (LPWSTR)tvItem.lParam );
                                    }
                                }
                                else {
                                    //
                                    // Unbind the component from the selected component.
                                    //

                                    hr = pnccb->UnbindFrom( pnccToBindUnbind );

                                    if ( !fChange ) {
                                        fChange = hr == S_OK;
                                    }

                                    if ( hr != S_OK ) {
                                        ErrMsg( hr,
                                                L"%s couldn't be unbound from %s.",
                                                     lpszInfId, (LPWSTR)tvItem.lParam );
                                    }
                                }

                                ReleaseRef( pnccToBindUnbind );
                            }
                            else {
                                ErrMsg( hr,
                                        L"Couldn't get an interface pointer to %s. "
                                        L"%s will not be bound to it.",
                                        (LPWSTR)tvItem.lParam,
                                        lpszInfId );
                            }
                        }
                    }

                    //
                    // Get the next item.
                    //

                    hTreeItem = TreeView_GetNextSibling( hwndTree,
                                                         hTreeItem );
                }

                ReleaseRef( pnccb );
            }
            else {
                ErrMsg( hr,
                        L"Couldn't get a binding interface of %s.",
                        lpszInfId );
            }

            ReleaseRef( pncc );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get an interface pointer to %s.",
                    lpszInfId );
        }

        //
        // If one or more network components have been bound/unbound,
        // apply the changes.
        //

        if ( fChange ) {
            hr = pnc->Apply();

            fChange = hr == S_OK;
        }

        HrReleaseINetCfg( pnc,
                          TRUE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the notify object interface." );
        }
    }

    return fChange;
}

//
// Function:  ListInstalledComponents
//
// Purpose:   List installed network components of specific class.
//
// Arguments:
//    hwndTree      [in]  Tree handle in which to list.
//    pguidClass    [in]  Class GUID of the network compoent class.
//
// Returns:   None.
//
// Notes:
//

VOID ListInstalledComponents (HWND hwndTree,
                              const GUID *pguidClass)
{
    INetCfg              *pnc;
    IEnumNetCfgComponent *pencc;
    INetCfgComponent     *pncc;
    LPWSTR               lpszApp;
    HTREEITEM            hTreeItem;
    HRESULT              hr;


    hr = HrGetINetCfg( FALSE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    if ( hr == S_OK ) {

        //
        // Get Component Enumerator Interface.
        //

        hr = HrGetComponentEnum( pnc,
                                 pguidClass,
                                 &pencc );
        if ( hr == S_OK ) {

            hr = HrGetFirstComponent( pencc, &pncc );

            while( hr == S_OK ) {

                //
                // Add an item to the tree for the network component.
                //

                hTreeItem = AddToTree( hwndTree,
                                       TVI_ROOT,
                                       pncc );

                ReleaseRef( pncc );

                hr = HrGetNextComponent( pencc, &pncc );
            }

            ReleaseRef( pencc );
        }
        else {
            ErrMsg( hr,
                    L"Failed to get the network component enumerator." );
        }

        HrReleaseINetCfg( pnc, FALSE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the notify object interface." );
        }
    }

    return;
}

//
// Function:  UninstallComponent
//
// Purpose:   Uninstall a network component.
//
// Arguments:
//    lpszInfId  [in]  PnpID of the network component to uninstall.
//
// Returns:   S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT UninstallComponent (LPWSTR lpszInfId)
{
    INetCfg              *pnc;
    INetCfgComponent     *pncc;
    INetCfgClass         *pncClass;
    INetCfgClassSetup    *pncClassSetup;
    LPWSTR               lpszApp;
    GUID                 guidClass;
    OBO_TOKEN            obo;
    HRESULT              hr;

    hr = HrGetINetCfg( TRUE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    if ( hr == S_OK ) {

        //
        // Get a reference to the network component to uninstall.
        //

        hr = pnc->FindComponent( lpszInfId,
                                 &pncc );

        if ( hr == S_OK ) {

            //
            // Get the class GUID.
            //

            hr = pncc->GetClassGuid( &guidClass );

            if ( hr == S_OK ) {

                //
                // Get a reference to component's class.
                //

                hr = pnc->QueryNetCfgClass( &guidClass,
                                            IID_INetCfgClass,
                                            (PVOID *)&pncClass );
                if ( hr == S_OK ) {

                    //
                    // Get the setup interface.
                    //

                    hr = pncClass->QueryInterface( IID_INetCfgClassSetup,
                                                   (LPVOID *)&pncClassSetup );

                    if ( hr == S_OK ) {

                        //
                        // Uninstall the component.
                        //

                        ZeroMemory( &obo,
                                    sizeof(OBO_TOKEN) );

                        obo.Type = OBO_USER;

                        hr = pncClassSetup->DeInstall( pncc,
                                                       &obo,
                                                       NULL );
                        if ( (hr == S_OK) || (hr == NETCFG_S_REBOOT) ) {

                            hr = pnc->Apply();

                            if ( (hr != S_OK) && (hr != NETCFG_S_REBOOT) ) {
                                ErrMsg( hr,
                                        L"Couldn't apply the changes after"
                                        L" uninstalling %s.",
                                        lpszInfId );
                            }
                        }
                        else {
                            ErrMsg( hr,
                                    L"Failed to uninstall %s.",
                                    lpszInfId );
                        }

                        ReleaseRef( pncClassSetup );
                    }
                    else {
                        ErrMsg( hr,
                                L"Couldn't get an interface to setup class." );
                    }

                    ReleaseRef( pncClass );
                }
                else {
                    ErrMsg( hr,
                            L"Couldn't get a pointer to class interface "
                            L"of %s.",
                            lpszInfId );
                }
            }
            else {
                ErrMsg( hr,
                        L"Couldn't get the class guid of %s.",
                        lpszInfId );
            }

            ReleaseRef( pncc );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get an interface pointer to %s.",
                    lpszInfId );
        }

        HrReleaseINetCfg( pnc,
                          TRUE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the notify object interface." );
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\bindview\netcfgapi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       N E T C F G A P I . H
//
//  Contents:   Functions Prototypes
//
//  Notes:      
//
//  Author:     Alok Sinha    15-May-01
//
//----------------------------------------------------------------------------

#ifndef _NETCFGAPI_H_INCLUDED

#define _NETCFGAPI_H_INCLUDED


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wchar.h>
#include <netcfgx.h>
#include <netcfgn.h>
#include <setupapi.h>
#include <devguid.h>
#include <objbase.h>

#define LOCK_TIME_OUT     5000

HRESULT HrGetINetCfg (IN BOOL fGetWriteLock,
                      IN LPCWSTR lpszAppName,
                      OUT INetCfg** ppnc,
                      OUT LPWSTR *lpszLockedBy);

HRESULT HrReleaseINetCfg (INetCfg* pnc,
                          BOOL fHasWriteLock);

HRESULT HrInstallNetComponent (IN INetCfg *pnc,
                               IN LPCWSTR szComponentId,
                               IN const GUID    *pguildClass,
                               IN LPCWSTR lpszInfFullPath);

HRESULT HrInstallComponent(IN INetCfg* pnc,
                           IN LPCWSTR szComponentId,
                           IN const GUID* pguidClass);

HRESULT HrUninstallNetComponent(IN INetCfg* pnc,
                                IN LPCWSTR szComponentId);

HRESULT HrGetComponentEnum (INetCfg* pnc,
                            IN const GUID* pguidClass,
                            IEnumNetCfgComponent **ppencc);

HRESULT HrGetFirstComponent (IEnumNetCfgComponent* pencc,
                             INetCfgComponent **ppncc);

HRESULT HrGetNextComponent (IEnumNetCfgComponent* pencc,
                            INetCfgComponent **ppncc);

HRESULT HrGetBindingPathEnum (INetCfgComponent *pncc,
                              DWORD dwBindingType,
                              IEnumNetCfgBindingPath **ppencbp);

HRESULT HrGetFirstBindingPath (IEnumNetCfgBindingPath *pencbp,
                               INetCfgBindingPath **ppncbp);

HRESULT HrGetNextBindingPath (IEnumNetCfgBindingPath *pencbp,
                               INetCfgBindingPath **ppncbp);

HRESULT HrGetBindingInterfaceEnum (INetCfgBindingPath *pncbp,
                                   IEnumNetCfgBindingInterface **ppencbi);

HRESULT HrGetFirstBindingInterface (IEnumNetCfgBindingInterface *pencbi,
                                    INetCfgBindingInterface **ppncbi);

HRESULT HrGetNextBindingInterface (IEnumNetCfgBindingInterface *pencbi,
                                   INetCfgBindingInterface **ppncbi);

VOID ReleaseRef (IUnknown* punk);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\bindview\bindview.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       B I N D V I E W . C P P
//
//  Contents:  
//
//  Notes:      
//
//  Author:     Alok Sinha    15-Amy-01
//
//----------------------------------------------------------------------------


#include "BindView.h"

//----------------------------------------------------------------------------
// Globals
//

//
// Image list for devices of various setup class.
//

SP_CLASSIMAGELIST_DATA ClassImageListData;

HINSTANCE              hInstance;
HMENU                  hMainMenu;
HMENU                  hComponentSubMenu;
HMENU                  hBindingPathSubMenu;

//
// Network components whose bindings are enumerated.
//

LPWSTR   lpszNetClass[] = {
                    L"All Clients",
                    L"All Services",
                    L"All Protocols"
         };

//
// GUIDs of network components.
//

const GUID     *pguidNetClass [] = {
                     &GUID_DEVCLASS_NETCLIENT,
                     &GUID_DEVCLASS_NETSERVICE,
                     &GUID_DEVCLASS_NETTRANS,
                     &GUID_DEVCLASS_NET
         };

//
// Program entry point.
//

int APIENTRY WinMain (HINSTANCE hInst,
                      HINSTANCE hPrevInstance, 
                      LPSTR lpCmdLine,         
                      int nCmdShow )           
{
    //
    // Make sure common control DLL is loaded.
    //

    hInstance = hInst;

    InitCommonControls();

    if ( DialogBoxW(hInst,
                    MAKEINTRESOURCEW(IDD_MAIN), 
                    NULL,
                    MainDlgProc) == -1 ) {

        ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                L"Failed to create the main dialog box, exiting..." );
    }

    return 0;
}

//
// WndProc for the main dialog box.
//

INT_PTR CALLBACK MainDlgProc (HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam)
{
    HWND   hwndBindingTree;
    HICON  hIcon;

    switch (uMsg) {

        case WM_INITDIALOG:

            hIcon = LoadIcon( hInstance,
                              MAKEINTRESOURCE(IDI_BINDVIEW) );

            if ( !hIcon ) {
                ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                        L"Couldn't load the program icon, exiting..." );

                return FALSE;
            }

            SetClassLongPtr( hwndDlg,
                              GCLP_HICON,
                              (LONG_PTR)hIcon );

            hMainMenu = LoadMenu( hInstance,
                                  MAKEINTRESOURCE(IDM_OPTIONS) );

            if ( !hMainMenu ) {

                ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                        L"Couldn't load the program menu, exiting..." );

                return FALSE;
            }

            hComponentSubMenu = GetSubMenu( hMainMenu,
                                            0 );

            hBindingPathSubMenu = GetSubMenu( hMainMenu,
                                              1 );

            if ( !hComponentSubMenu || !hBindingPathSubMenu ) {

                ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                        L"Couldn't load the program menu, exiting..." );

                DestroyMenu( hMainMenu );
                return FALSE;
            }

            //
            // Add the network components types whose bindings are shown.
            //

            UpdateComponentTypeList( GetDlgItem(hwndDlg,
                                                IDL_COMPONENT_TYPES) );

            //
            // Load and associate the image list of all device classes with
            // tree.
            //

            hwndBindingTree = GetDlgItem( hwndDlg,
                                          IDT_BINDINGS );

            ZeroMemory( &ClassImageListData, sizeof(SP_CLASSIMAGELIST_DATA) );
            ClassImageListData.cbSize = sizeof(SP_CLASSIMAGELIST_DATA);

            if ( SetupDiGetClassImageList(&ClassImageListData) == TRUE ) {

                TreeView_SetImageList( hwndBindingTree,
                                       ClassImageListData.ImageList,
                                       LVSIL_NORMAL );
            }
            else {

                //
                // In case, we failed to load the image list, abort.
                //

                ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                        L"Couldn't load the image list of "
                        L"device classes, exiting..." );

                DestroyMenu( hMainMenu );
                return FALSE;
            }

            //
            // Enumerate  the bindings of the network component selected by default.
            //

            EnumNetBindings( hwndBindingTree,
                             DEFAULT_COMPONENT_SELECTED );

            return TRUE; // Tell Windows to continue creating the dialog box.

        case WM_COMMAND:

            switch( LOWORD(wParam) ) {

                case IDL_COMPONENT_TYPES:

                    if ( HIWORD(wParam) == CBN_SELCHANGE ) {

                        //
                        // User has selected a new network component type.
                        //

                        RefreshAll( hwndDlg );
                    }

                    break;

                case IDB_EXPAND_ALL:
                case IDB_COLLAPSE_ALL:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        HTREEITEM hItem;
                        //
                        // Expand/Collapse the entire tree.
                        //

                        hwndBindingTree = GetDlgItem( hwndDlg,
                                                      IDT_BINDINGS );

                        hItem = TreeView_GetSelection( hwndBindingTree );

                        ExpandCollapseAll( hwndBindingTree,
                                           TVI_ROOT,
                                           (LOWORD(wParam) == IDB_EXPAND_ALL) ?
                                           TVE_EXPAND : TVE_COLLAPSE );

                        TreeView_SelectSetFirstVisible( hwndBindingTree,
                                                        hItem );
                    }
                    
                    break;

                case IDB_SAVE:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        //
                        // Save the binding information to a file.
                        //

                        WCHAR lpszFile[MAX_PATH+1];

                        if ( GetFileName(hwndDlg,
                                         NULL,
                                         L"Select a file name",
                                         OFN_DONTADDTORECENT | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT,
                                         lpszFile) ) {

                            DumpBindings( lpszFile );
                        }
                    }

                    break;

                case IDB_INSTALL:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        // 
                        // Install a network component.
                        //

                        if ( (BOOL)DialogBoxW(hInstance,
                                    MAKEINTRESOURCEW(IDD_INSTALL),
                                    hwndDlg,
                                    InstallDlg) == TRUE ) {

                            RefreshAll( hwndDlg );
                        }
                    }

                    break;

                case IDB_UNINSTALL:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        // 
                        // Uninstall a network component.
                        //

                        if ( (BOOL)DialogBoxW(hInstance,
                                    MAKEINTRESOURCEW(IDD_UNINSTALL),
                                    hwndDlg,
                                    UninstallDlg) == TRUE ) {

                            RefreshAll( hwndDlg );
                        }
                    }
            }

            break;

        case WM_NOTIFY:
            {
                LPNMHDR       lpnm;

                lpnm = (LPNMHDR)lParam;

                if ( (lpnm->idFrom == IDT_BINDINGS) &&
                      (lpnm->code == NM_RCLICK) ) {
      
                    //
                    // A network component or a binding path is selected
                    // with a righ-click.
                    //

                    ProcessRightClick( lpnm );

                    //
                    // Tell Windows that the righ-click has been handled
                    // us.
                    //

                    return TRUE;
                }
            }
            break;

        case WM_SYSCOMMAND:

            if ( (0xFFF0 & wParam) == SC_CLOSE ) {

                //
                // Before exiting, make sure to delete the image list
                // and the buffers associated with each item in the tree.
                //

                SetupDiDestroyClassImageList( &ClassImageListData );

                ReleaseMemory( GetDlgItem(hwndDlg, IDT_BINDINGS),
                               TVI_ROOT );

                DestroyMenu( hMainMenu );
                EndDialog( hwndDlg, 0 );
            }
    }

    return FALSE;
}

//
// WndProc of the dialog box for binding/unbinding compoents.
//

INT_PTR CALLBACK BindComponentDlg (HWND hwndDlg,
                                   UINT uMsg,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    LPBIND_UNBIND_INFO lpBindUnbind;

    switch (uMsg) {

        case WM_INITDIALOG:
            {
                DWORD dwCount;

                //
                // Save the lParam which is an index to the selected network
                // component.
                //

                SetWindowLongPtr( hwndDlg,
                                  DWLP_USER,
                                  (LONG_PTR)lParam );

                lpBindUnbind = (LPBIND_UNBIND_INFO)lParam;

                //
                // fBindTo is TRUE when the user wants to bind the selected
                // component to other components. So, we list the components
                // that are not bound and can bind.
                //
                //
                // fBindTo is FALSE when the user wants to unbind the selected
                // component from other components. So, we list the components
                // that are bound to it.
                //
                //
                // ListCompToBindUnbind returns number of components added to
                // the list. Keep track of it. If it zero then, we don't want to
                // show this dialog box.
                //

                dwCount = ListCompToBindUnbind(
                                      lpBindUnbind->lpszInfId,
                                      ADAPTERS_SELECTED,
                                      GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                                      lpBindUnbind->fBindTo == FALSE );

                dwCount += ListCompToBindUnbind(
                                      lpBindUnbind->lpszInfId,
                                      CLIENTS_SELECTED,
                                      GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                                      lpBindUnbind->fBindTo == FALSE );

                dwCount += ListCompToBindUnbind(
                                      lpBindUnbind->lpszInfId,
                                      SERVICES_SELECTED,
                                      GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                                      lpBindUnbind->fBindTo == FALSE );

                dwCount += ListCompToBindUnbind(
                                      lpBindUnbind->lpszInfId,
                                      PROTOCOLS_SELECTED,
                                      GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                                      lpBindUnbind->fBindTo == FALSE );

                if ( dwCount > 0 ) {

                    //
                    // Since the same dialog box is used for unbind opration,
                    // we need to update the text on the button to reflect that
                    // it is a bind operation.
                    //

                    if ( lpBindUnbind->fBindTo == FALSE ) {

                        SetWindowTextW( hwndDlg,
                                       L"Unbind From Network Components" );

                        SetWindowTextW( GetDlgItem(hwndDlg, IDB_BIND_UNBIND),
                                        L"Unbind" );

                        SetWindowTextW( GetDlgItem(hwndDlg, IDG_COMPONENT_LIST),
                                        L"Select components to unbind from" );
                    }
                }
                else {
                    if ( lpBindUnbind->fBindTo == TRUE ) {
                      ErrMsg( 0,
                                L"There no network components that can "
                                L"bind to the selected component." );
                    }
                    else {
                      ErrMsg( 0,
                                L"There no network components that are "
                                L"bound to the selected component." );
                    }

                    PostMessage( hwndDlg, WM_NO_COMPONENTS, 0, 0 );
                }

                return TRUE;
            }

        case WM_NO_COMPONENTS:
            EndDialog( hwndDlg, 0 );
            break;

        case WM_COMMAND:

            if ( (LOWORD(wParam) == IDB_CLOSE) &&
                 (HIWORD(wParam) == BN_CLICKED) ) {

                //
                // Before deleting the list in the tree, free the buffer
                // associated with each item. The buffer holds the
                // INF Id of network components.
                //
   
                ReleaseMemory( GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                               TVI_ROOT );

                EndDialog( hwndDlg, 0 );
            }
            else {

                //
                // User wants to bind/unbind.
                //

                if ( (LOWORD(wParam) == IDB_BIND_UNBIND) &&
                     (HIWORD(wParam) == BN_CLICKED) ) {

           

                    lpBindUnbind = (LPBIND_UNBIND_INFO)GetWindowLongPtr( hwndDlg,
                                                                         DWLP_USER );

                    if ( BindUnbind(lpBindUnbind->lpszInfId,
                                    GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                                    lpBindUnbind->fBindTo) ) {

                        RefreshBindings( hwndDlg,
                                         lpBindUnbind->lpszInfId );
                    }

                    ReleaseMemory( GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                                   TVI_ROOT );
                    EndDialog( hwndDlg, 0 );
                }
            }
            break;
             
        case WM_SYSCOMMAND:

            if ( (0xFFF0 & wParam) == SC_CLOSE ) {

                //
                // Before deleting the list in the tree, free the buffer
                // associated with each item. The buffer holds the
                // INF Id of network components.
                //
  
                ReleaseMemory( GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                               TVI_ROOT );

                EndDialog( hwndDlg, 0 );
            }
    }

    return FALSE;
}

//
//WndProc of the dialog box for installing network components.
//

INT_PTR CALLBACK InstallDlg (HWND hwndDlg,
                             UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam)
{
    switch (uMsg) {

        case WM_INITDIALOG:
            {
                HWND     hwndTree;

                //
                // List types of network components e.g. client,
                // protocol and service.
                //

                hwndTree = GetDlgItem( hwndDlg,
                                       IDT_COMPONENT_LIST );

                TreeView_SetImageList( hwndTree,
                                       ClassImageListData.ImageList,
                                       LVSIL_NORMAL );

                //
                // Insert and select client by default.
                //

                TreeView_Select( hwndTree,
                                 InsertItem(hwndTree,
                                            CLIENTS_SELECTED),
                                 TVGN_CARET );

                InsertItem( hwndTree,
                            SERVICES_SELECTED );

                InsertItem( hwndTree,
                            PROTOCOLS_SELECTED );

                //
                // Initialize it to FALSE. It will be set to TRUE when
                // at least one component is installed.
                //

                SetWindowLongPtr( hwndDlg,
                                  DWLP_USER,
                                  (LONG_PTR)FALSE );
                return TRUE;
            }

        case WM_COMMAND:

            switch( LOWORD(wParam) ) {

                case IDB_INSTALL:

                    //
                    // Install from Windows system directory.
                    //

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        InstallSelectedComponentType( hwndDlg, NULL );
                    }
                    break;

                case IDB_BROWSE:

                    //
                    // User wants to specify an INF file for the network
                    // to install.
                    //
                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        WCHAR lpszInfFile[MAX_PATH+1];

                        if ( GetFileName(hwndDlg,
                                         L"INF files (*.inf)\0*.inf\0",
                                         L"Select the INF file of the network component to install",
                                         OFN_DONTADDTORECENT | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,
                                         lpszInfFile) ) {

                            InstallSelectedComponentType( hwndDlg,
                                                          lpszInfFile );
                        }
                    }
                    break;

                case IDB_CLOSE:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        //
                        // Return the value of DWLP_USER to indicate whether one or
                        // more components have been installed. Accordingly, the 
                        // the list will be refreshed.
                        //

                        EndDialog( hwndDlg,
                                   GetWindowLongPtr(hwndDlg, DWLP_USER) );
                    }
            } 
            break;

        case WM_NOTIFY:
            {
                LPNMHDR       lpnm;

                lpnm = (LPNMHDR)lParam;

                if ( (lpnm->idFrom == IDT_COMPONENT_LIST) &&
                    (lpnm->code == NM_DBLCLK) ) {

                    //
                    // On double-click, install from Windows system directory.
                    //

                    InstallSelectedComponentType( hwndDlg, NULL );
                    
                }
             }
             break;

        case WM_SYSCOMMAND:

            if ( (0xFFF0 & wParam) == SC_CLOSE ) {
 
                //
                // Return the value of DWLP_USER to indicate whether one or
                // more components have been installed. Accordingly, the 
                // the list will be refreshed.
                //

                EndDialog( hwndDlg,
                           GetWindowLongPtr(hwndDlg, DWLP_USER) );
            }
    }

    return FALSE;
}

//
// WndProc of the dialog box for uninstalling a network component.
//

INT_PTR CALLBACK UninstallDlg (HWND hwndDlg,
                               UINT uMsg,
                               WPARAM wParam,
                               LPARAM lParam)
{
    HWND     hwndTree;

    switch (uMsg) {

        case WM_INITDIALOG:

            hwndTree = GetDlgItem( hwndDlg,
                                   IDT_COMPONENT_LIST );
            TreeView_SetImageList( hwndTree,
                                   ClassImageListData.ImageList,
                                   LVSIL_NORMAL );

            //
            // List all the compoents currently installed.
            //

            ListInstalledComponents( hwndTree,
                                     &GUID_DEVCLASS_NETCLIENT);
            ListInstalledComponents( hwndTree,
                                     &GUID_DEVCLASS_NETSERVICE );
            ListInstalledComponents( hwndTree,
                                     &GUID_DEVCLASS_NETTRANS );

            //
            // Initialize it to FALSE. It will be set to TRUE when
            // at least one component is installed.
            //

            SetWindowLongPtr( hwndDlg,
                              DWLP_USER,
                              (LONG_PTR)FALSE );
            return TRUE;

        case WM_COMMAND:

            switch( LOWORD(wParam) ) {

                case IDB_REMOVE:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        //
                        // Uninstall the selected component.
                        //

                        UninstallSelectedComponent( hwndDlg );

                    }
                    break;

                case IDB_CLOSE:

                    if ( HIWORD(wParam) == BN_CLICKED ) {
  
                        hwndTree = GetDlgItem( hwndDlg,
                                               IDT_COMPONENT_LIST );
                        ReleaseMemory( hwndTree,
                                       TVI_ROOT );

                        //
                        // Return the value of DWLP_USER to indicate whether one or
                        // more components have been installed. Accordingly, the 
                        // the list will be refreshed.
                        //

                        EndDialog( hwndDlg,
                                   GetWindowLongPtr(hwndDlg, DWLP_USER) );
                    }
            } 

            break;

        case WM_NOTIFY:
            {
                LPNMHDR       lpnm;

                lpnm = (LPNMHDR)lParam;

                if ( (lpnm->idFrom == IDT_COMPONENT_LIST) &&
                    (lpnm->code == NM_DBLCLK) ) {

                    UninstallSelectedComponent( hwndDlg );
                    
                }
             }
             break;

        case WM_SYSCOMMAND:

            if ( (0xFFF0 & wParam) == SC_CLOSE ) {

                hwndTree = GetDlgItem( hwndDlg,
                                       IDT_COMPONENT_LIST );
                ReleaseMemory( hwndTree,
                               TVI_ROOT );

                //
                // Return the value of DWLP_USER to indicate whether one or
                // more components have been installed. Accordingly, the 
                // the list will be refreshed.
                //

                EndDialog( hwndDlg,
                           GetWindowLongPtr(hwndDlg, DWLP_USER) );
            }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// Function:  DumpBindings
//
// Purpose:   Write the binding information.
//
// Arguments:
//    lpszFile [in]  Name of the file in which to write.
//
// Returns:   None
//
// Notes:
//

VOID DumpBindings (LPWSTR lpszFile)
{
    FILE *fp;

    fp = _wfopen( lpszFile,
                  L"w" );

    if ( fp == NULL ) {

        ErrMsg( 0,
                L"Unable to open %s.",
                lpszFile );
    }
    else {
        WriteBindings( fp );

        fclose( fp );
    }

    return;
}

//
// Function:  InstallSelectedComponentType
//
// Purpose:   Install a network component.
//
// Arguments:
//    hwndDlg     [in]  Handle to Install dialog box.
//    lpszInfFile [in]  Inf file of the network component.
//
// Returns:   None
//
// Notes:
//       If lpszInfFile is NULL, network components are installed from the
//       system directory.
//       

VOID InstallSelectedComponentType (HWND hwndDlg,
                                   LPWSTR lpszInfFile)
{
    HWND      hwndTree;
    HTREEITEM hItem;
    LPARAM    lParam;
    HCURSOR   hPrevCursor;
    HCURSOR   hWaitCursor;
    HWND      hwndFocus;
    DWORD     dwType;
    BOOL      fEnable;
    HRESULT   hr;

    hwndTree = GetDlgItem( hwndDlg,
                           IDT_COMPONENT_LIST );

    //
    // Find out the type of component selected.
    //

    hItem = TreeView_GetSelection( hwndTree );

    if ( hItem ) {
        if ( GetItemInfo( hwndTree,
                          hItem,
                          &lParam,
                          &dwType,
                          &fEnable) ) {

            //
            // Disable the install dialog controls.
            //

            hwndFocus = GetFocus();

            EnableWindow( hwndTree, FALSE );
            EnableWindow( GetDlgItem(hwndDlg,IDB_OK),
                          FALSE );
            EnableWindow( GetDlgItem(hwndDlg,IDB_CLOSE),
                          FALSE );
            hWaitCursor = LoadCursor( NULL,
                                      IDC_WAIT );
            if ( hWaitCursor ) {
                hPrevCursor = SetCursor( hWaitCursor );
            }

            if ( lpszInfFile ) {

                LPWSTR  lpszPnpID;

                //
                // Inf file name specified, install the network component
                // from this file.
                //

                hr = GetPnpID( lpszInfFile, &lpszPnpID );

                if ( hr == S_OK ) {

                    hr = InstallSpecifiedComponent( lpszInfFile,
                                                    lpszPnpID,
                                                    pguidNetClass[(UINT)lParam] );

                    CoTaskMemFree( lpszPnpID );
                }
                else {
                    ErrMsg( hr,
                            L"Error reading the INF file %s.",
                            lpszInfFile );
                }
            }
            else {

                //
                // Install from system directory.
                //

                hr = InstallComponent( hwndTree,
                                       pguidNetClass[(UINT)lParam] );
            }

            if ( hWaitCursor ) {
                SetCursor( hPrevCursor );
            }

            switch( hr ) {

                case S_OK:
                    MessageBoxW(
                           hwndTree,
                           L"Component installed successfully.",
                           L"Network Component Installation",
                           MB_OK | MB_ICONINFORMATION );
                           SetWindowLongPtr( hwndDlg,
                                             DWLP_USER,
                                             (LONG_PTR)TRUE );
                           break;

                case NETCFG_S_REBOOT:
                    MessageBoxW(
                          hwndTree,
                          L"Component installed successfully: "
                          L"Reboot required.",
                          L"Network Component Installation",
                          MB_OK | MB_ICONINFORMATION );
                          SetWindowLongPtr( hwndDlg,
                                            DWLP_USER,
                                            (LONG_PTR)TRUE );

            }

            //
            // Enable the install dialog controls.
            //

            EnableWindow( hwndTree, TRUE );
            EnableWindow( GetDlgItem(hwndDlg,IDB_OK),
                          TRUE );
            EnableWindow( GetDlgItem(hwndDlg,IDB_CLOSE),
                          TRUE );

            SetFocus( hwndFocus );
        }
    }

    return;
}

//
// Function:  GetPnpID
//
// Purpose:   Retrieve PnpID from an inf file.
//
// Arguments:
//    lpszInfFile [in]  Inf file to search.
//    lppszPnpID  [out] PnpID found.
//
// Returns:   TRUE on success.
//
// Notes:
//       

HRESULT GetPnpID (LPWSTR lpszInfFile,
                  LPWSTR *lppszPnpID)
{
    HINF    hInf;
    LPWSTR  lpszModelSection;
    HRESULT hr;

    *lppszPnpID = NULL;

    hInf = SetupOpenInfFileW( lpszInfFile,
                              NULL,
                              INF_STYLE_WIN4,
                              NULL );

    if ( hInf == INVALID_HANDLE_VALUE )
    {

        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Read the Model section name from Manufacturer section.
    //

    hr = GetKeyValue( hInf,
                      L"Manufacturer",
                      NULL,
                      1,
                      &lpszModelSection );

    if ( hr == S_OK )
    {

        //
        // Read PnpID from the Model section.
        //

        hr = GetKeyValue( hInf,
                          lpszModelSection,
                          NULL,
                          2,
                          lppszPnpID );

        CoTaskMemFree( lpszModelSection );
    }

    SetupCloseInfFile( hInf );

    return hr;
}

//
// Function:  GetKeyValue
//
// Purpose:   Retrieve the value of a key from the inf file.
//
// Arguments:
//    hInf        [in]  Inf file handle.
//    lpszSection [in]  Section name.
//    lpszKey     [in]  Key name.
//    dwIndex     [in]  Key index.
//    lppszValue  [out] Key value.
//
// Returns:   S_OK on success, otherwise and error code.
//
// Notes:
//       

HRESULT GetKeyValue (HINF hInf,
                     LPCWSTR lpszSection,
                     LPCWSTR lpszKey,
                     DWORD  dwIndex,
                     LPWSTR *lppszValue)
{
    INFCONTEXT  infCtx;
    DWORD       dwSizeNeeded;
    HRESULT     hr;

    *lppszValue = NULL;

    if ( SetupFindFirstLineW(hInf,
                             lpszSection,
                             lpszKey,
                             &infCtx) == FALSE )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    SetupGetStringFieldW( &infCtx,
                          dwIndex,
                          NULL,
                          0,
                          &dwSizeNeeded );

    *lppszValue = (LPWSTR)CoTaskMemAlloc( sizeof(WCHAR) * dwSizeNeeded );

    if ( !*lppszValue  )
    {
       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if ( SetupGetStringFieldW(&infCtx,
                              dwIndex,
                              *lppszValue,
                              dwSizeNeeded,
                              NULL) == FALSE )
    {

        hr = HRESULT_FROM_WIN32(GetLastError());

        CoTaskMemFree( *lppszValue );
        *lppszValue = NULL;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

//
// Function:  UninstallSelectedComponent
//
// Purpose:   Uninstall the selected network component.
//
// Arguments:
//    hwndDlg     [in]  Window handle of the uninstall dialog box.
//
// Returns:   TRUE on success.
//
// Notes:
//       

VOID UninstallSelectedComponent (HWND hwndDlg)
{
    HWND      hwndTree;
    HTREEITEM hItem;
    LPARAM    lParam;
    HCURSOR   hPrevCursor;
    HCURSOR   hWaitCursor;
    DWORD     dwType;
    BOOL      fEnable;
    HRESULT   hr;

    hwndTree = GetDlgItem( hwndDlg,
                           IDT_COMPONENT_LIST );

    //
    // Get the selected item to get its lParam which is the
    // PnpID of the network component.
    //

    hItem = TreeView_GetSelection( hwndTree );

    if ( hItem ) {
        if ( GetItemInfo( hwndTree,
                          hItem,
                          &lParam,
                          &dwType,
                          &fEnable) ) {

            hWaitCursor = LoadCursor( NULL,
                                      IDC_WAIT );
            if ( hWaitCursor ) {
                hPrevCursor = SetCursor( hWaitCursor );
            }

            //
            // Uninstall the selected component.
            //

            hr = UninstallComponent( (LPWSTR)lParam );


            if ( hWaitCursor ) {
                SetCursor( hPrevCursor );
            }

            switch( hr ) {

                case S_OK:
                    MessageBoxW(
                           hwndTree,
                           L"Uninstallation successful.",
                           L"Network Component Uninstallation",
                           MB_OK | MB_ICONINFORMATION );

                    CoTaskMemFree( (LPVOID)lParam );
                    TreeView_DeleteItem( hwndTree,
                                         hItem );

                    SetWindowLongPtr( hwndDlg,
                                      DWLP_USER,
                                      (LONG_PTR)TRUE );
                    break;

                case NETCFG_S_REBOOT:
                    MessageBoxW(
                          hwndTree,
                          L"Uninstallation successful: "
                          L"Reboot required.",
                          L"Network Component Uninstallation",
                          MB_OK | MB_ICONINFORMATION );

                    CoTaskMemFree( (LPVOID)lParam );
                    TreeView_DeleteItem( hwndTree,
                                         hItem );

                    SetWindowLongPtr( hwndDlg,
                                      DWLP_USER,
                                      (LONG_PTR)TRUE );
            }
        }
    }

    return;
}

//
// Function:  ExpandCollapseAll
//
// Purpose:   Expand or collapse a tree.
//
// Arguments:
//    hwndTree   [in]  Window handle of the tree.
//    hTreeItem  [in]  Handle of root item.
//    uiFlag     [in]  Flag indicating whether to expand or collapse.
//
// Returns:   None.
//
// Notes:
//       

VOID ExpandCollapseAll (HWND hwndTree,
                        HTREEITEM hTreeItem,
                        UINT uiFlag)
{
    HTREEITEM  hItemChild;

    hItemChild = TreeView_GetChild( hwndTree,
                                    hTreeItem );

    if ( hItemChild ) {

        //
        // If the root has one or more children, expand/collapse the root.
        //

        TreeView_Expand( hwndTree,
                         hTreeItem,
                         uiFlag );
    }

    while ( hItemChild ) {

        //
        // Expand/collapse all the children.
        //

        ExpandCollapseAll( hwndTree,
                           hItemChild,
                           uiFlag );

        //
        // Expand/collapse all the siblings.
        //

        hItemChild = TreeView_GetNextSibling( hwndTree,
                                              hItemChild );
    }

    return;
}

//
// Function:  GetFileName
//
// Purpose:   Prompt for a filename.
//
// Arguments:
//    hwndDlg    [in]  Window handle of the parent.
//    lpszFilter [in]  See documentation for GetOpenFileName.
//    lpszTitle  [in]  See documentation for GetOpenFileName.
//    dwFlags    [in]  See documentation for GetOpenFileName.
//    lpszFile   [in]  See documentation for GetOpenFileName.
//
// Returns:   See documentation for GetOpenFileName.
//
// Notes:
//       

BOOL GetFileName (HWND hwndDlg,
                  LPWSTR lpszFilter,
                  LPWSTR lpszTitle,
                  DWORD dwFlags,
                  LPWSTR lpszFile)
{
    OPENFILENAMEW ofn;
               
    lpszFile[0] = NULL;

    ZeroMemory( &ofn, sizeof(OPENFILENAMEW) );
    ofn.lStructSize = sizeof(OPENFILENAMEW);
    ofn.hwndOwner = hwndDlg;
    ofn.lpstrFilter = lpszFilter;
    ofn.lpstrFile = lpszFile;
    ofn.nMaxFile = MAX_PATH+1;
    ofn.lpstrTitle = lpszTitle;
    ofn.Flags = dwFlags;

    return GetOpenFileName( &ofn );
}

//
// Function:  ProcessRightClick
//
// Purpose:   Handle righ mouse button click.
//
// Arguments:
//    lpnm    [in]  LPNMHDR info
//
// Returns:   None.
//
// Notes:
//       

VOID ProcessRightClick (LPNMHDR lpnm)
{
    HTREEITEM hItemSelected;
    LPARAM    lParam;
    DWORD     dwItemType;
    BOOL      fEnabled;

    //
    // Determine the item on which user clicked the right mouse button.
    //

    hItemSelected = TreeView_GetDropHilight( lpnm->hwndFrom );

    if ( !hItemSelected ) {
        hItemSelected = TreeView_GetSelection( lpnm->hwndFrom );
    }
    else {

        //
        // User has right-clicked an unselected item, make that a selected
        // item.
        //

        TreeView_Select( lpnm->hwndFrom,
                         hItemSelected,
                         TVGN_CARET );
    }

    if ( hItemSelected ) {

        //
        // Get the lParam of the selected node in the tree which points to inf id or
        // pathtoken name depending on if the node represents a network component or
        // a binding path.
        //

        if ( GetItemInfo(lpnm->hwndFrom,
                         hItemSelected,
                         &lParam,
                         &dwItemType,
                         &fEnabled) ) {

            if ( dwItemType & ITEM_NET_COMPONENTS ) {

                //
                // Show the shortcut menu of operations for a network component.
                //

                ShowComponentMenu( lpnm->hwndFrom,
                                   hItemSelected,
                                   lParam);
            }
            else {
                if ( dwItemType & ITEM_NET_BINDINGS ) {

                    //
                    // Show the shortcut menu of operations for a binding path.
                    //

                    ShowBindingPathMenu( lpnm->hwndFrom,
                                         hItemSelected,
                                         lParam,
                                         fEnabled );
                }
            }
        }
    }

    return;
}

//
// Function:  ShowComponentMenu
//
// Purpose:   Show shortcut menu of options for a network component.
//
// Arguments:
//    hwndOwner  [in]  Owner window.
//    hItem      [in]  Selected item representing a network component.
//    lParam     [in]  PnpID of the network component.
//
// Returns:   None.
//
// Notes:
//       

VOID ShowComponentMenu (HWND hwndOwner,
                        HTREEITEM hItem,
                        LPARAM lParam)
{
    ULONG   ulSelection;
    POINT   pt;

    GetCursorPos( &pt );
    ulSelection = (ULONG)TrackPopupMenu( hComponentSubMenu,
                                         TPM_RIGHTALIGN | TPM_BOTTOMALIGN |
                                         TPM_NONOTIFY | TPM_RETURNCMD |
                                         TPM_RIGHTBUTTON,
                                         pt.x,
                                         pt.y,
                                         0,
                                         hwndOwner,
                                         NULL );

    if ( ulSelection ) {

        //
        // Do the selected action.
        //

        HandleComponentOperation( hwndOwner,
                                  ulSelection,
                                  hItem,
                                  lParam );
    }

    return;
}

//
// Function:  ShowBindingPathMenu
//
// Purpose:   Show shortcut menu of options for a network component.
//
// Arguments:
//    hwndOwner  [in]  Owner window.
//    hItem      [in]  Selected item representing a binding path.
//    lParam     [in]  PnpID of the network component.
//    fEnabled   [in]  TRUE when the path is enabled.
//
// Returns:   None.
//
// Notes:
//       


VOID ShowBindingPathMenu (HWND hwndOwner,
                          HTREEITEM hItem,
                          LPARAM lParam,
                          BOOL fEnabled)
{
    MENUITEMINFOW  menuItemInfo;
    ULONG   ulSelection;
    POINT   pt;

    //
    // Build the shortcut menu depending on whether path is
    // disabled or enabled.
    //

    ZeroMemory( &menuItemInfo,
                sizeof(MENUITEMINFOW) );

    menuItemInfo.cbSize = sizeof( MENUITEMINFOW );
    menuItemInfo.fMask = MIIM_TYPE | MIIM_ID;
    menuItemInfo.fType = MFT_STRING;
    menuItemInfo.fState = MFS_ENABLED;

    if ( fEnabled ) {
        menuItemInfo.dwTypeData = MENUITEM_DISABLE;
        menuItemInfo.wID = IDI_DISABLE;
    }
    else {
        menuItemInfo.dwTypeData = MENUITEM_ENABLE;
        menuItemInfo.wID = IDI_ENABLE;
    }

    SetMenuItemInfoW( hBindingPathSubMenu,
                     0,
                     TRUE,
                     &menuItemInfo );  

    GetCursorPos( &pt );
    ulSelection = (ULONG)TrackPopupMenu( hBindingPathSubMenu,
                                         TPM_RIGHTALIGN | TPM_BOTTOMALIGN |
                                         TPM_NONOTIFY | TPM_RETURNCMD |
                                         TPM_RIGHTBUTTON,
                                         pt.x,
                                         pt.y,
                                         0,
                                         hwndOwner,
                                         NULL );

    if ( ulSelection ) {

        //
        // Do the selected action.
        //

        HandleBindingPathOperation( hwndOwner,
                                    ulSelection,
                                    hItem,
                                    lParam );
    }

    return;
}

//
// Function:  GetItemInfo
//
// Purpose:   Returns information about an item.
//
// Arguments:
//    hwndTree     [in]  Window handle of the tree.
//    hItem        [in]  Item handle.
//    lParam       [out] lParam
//    lpdwItemType [out] Type, binding path or network component.
//    fEnabled     [out] TRUE if the binding path or component is enabled.
//
// Returns:   TRUE on sucess.
//
// Notes:
//       

BOOL GetItemInfo (HWND hwndTree,
                  HTREEITEM hItem,
                  LPARAM *lParam,
                  LPDWORD lpdwItemType,
                  BOOL *fEnabled)
{
    TVITEMW   tvItem;
    int       iImage;
    BOOL      fSuccess;


    fSuccess = FALSE;

    //
    // Get item's information.
    //

    ZeroMemory( &tvItem,
                sizeof(TVITEMW) );
    tvItem.hItem = hItem;
    tvItem.mask = TVIF_PARAM | TVIF_IMAGE | TVIF_STATE;
    tvItem.stateMask = TVIS_OVERLAYMASK ;

    if ( TreeView_GetItem(hwndTree,
                          &tvItem) ) {

        *lParam = tvItem.lParam;

        if ( SetupDiGetClassImageIndex(&ClassImageListData,
                                       &GUID_DEVCLASS_SYSTEM,
                                       &iImage) ) {
  
            //
            // Is it a binding path?
            //

            if ( tvItem.iImage == iImage ) {
                *lpdwItemType = ITEM_NET_BINDINGS;

                *fEnabled = !(TVIS_OVERLAYMASK & tvItem.state); 

                fSuccess = TRUE;
            }
            else {

                //
                // Item is a network component.
                //

                if ( SetupDiGetClassImageIndex(&ClassImageListData,
                                               &GUID_DEVCLASS_NET,
                                               &iImage) ) {

                    if ( tvItem.iImage == iImage ) {
                        *lpdwItemType = ITEM_NET_ADAPTERS;
                    }
                    else {
                        *lpdwItemType = ITEM_NET_COMPONENTS;
                    }

                    *fEnabled = !(TVIS_OVERLAYMASK & tvItem.state); 

                    fSuccess = TRUE;
                }
                else {
                    ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                            L"Couldn't load the images of network adapters." );
                }
            }
        }
        else {
            ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                    L"Couldn't load the images of system devices." );
        }
    }

    return fSuccess;
}

//
// Function:  AddBindNameToTree
//
// Purpose:   Adds an item representing the binding path.
//
// Arguments:
//    pncbp     [in]  Binding path to add.
//    hwndTree  [in]  Tree handle.
//    hParent   [in]  Parent item.
//    ulIndex   [in]  Index of the binding path.
//
// Returns:   Handle of the item added on success, otherwise NULL.
//
// Notes:
//       

HTREEITEM AddBindNameToTree (INetCfgBindingPath *pncbp,
                             HWND hwndTree,
                             HTREEITEM hParent,
                             ULONG  ulIndex)
{
    WCHAR            lpszBindName[40];
    LPWSTR           lpszPathToken;
    HTREEITEM        hTreeItem;
    TV_INSERTSTRUCTW tvInsertStruc;
    HRESULT          hr;

    hTreeItem = NULL;

    //
    // Store the path token as lParam.
    //

    hr = pncbp->GetPathToken( &lpszPathToken );

    if ( hr == S_OK ) {

        swprintf( lpszBindName, L"Binding Path %d", ulIndex );

        ZeroMemory(
              &tvInsertStruc,
              sizeof(TV_INSERTSTRUCTW) );

        tvInsertStruc.hParent = hParent;

        tvInsertStruc.hInsertAfter = TVI_LAST;

        tvInsertStruc.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE |
                                  TVIF_SELECTEDIMAGE | TVIF_STATE;

        tvInsertStruc.item.pszText = lpszBindName;

        tvInsertStruc.item.cchTextMax = wcslen( lpszBindName ) + sizeof(WCHAR);

        SetupDiGetClassImageIndex( &ClassImageListData,
                                   &GUID_DEVCLASS_SYSTEM,
                                   &tvInsertStruc.item.iImage );

        tvInsertStruc.item.iSelectedImage = tvInsertStruc.item.iImage;

        tvInsertStruc.item.stateMask = TVIS_OVERLAYMASK;

        if (  pncbp->IsEnabled() == S_FALSE ) {
            tvInsertStruc.item.state = INDEXTOOVERLAYMASK(
                                   IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
        }

        tvInsertStruc.item.lParam = (LPARAM)lpszPathToken;

        hTreeItem = TreeView_InsertItem( hwndTree,
                                         &tvInsertStruc );

        if ( !hTreeItem ) {
            ErrMsg( hr,
                    L"Couldn't add the binding path %d to the list."
                    L" The binding path will not be shown.", ulIndex );

            CoTaskMemFree( lpszPathToken );
        }
    }
    else {
        ErrMsg( hr,
                L"Couldn't get the PathToken of the binding path %d."
                L" The binding path will not be shown.", ulIndex );
    }

    return hTreeItem;
}

//
// Function:  AddToTree
//
// Purpose:   Adds an item representing the network component.
//
// Arguments:
//    hwndTree  [in]  Tree handle.
//    hParent   [in]  Parent item.
//    pncc      [in]  Network component.
//
// Returns:   Handle of the item added on success, otherwise NULL.
//
// Notes:
//       

HTREEITEM AddToTree (HWND hwndTree,
                     HTREEITEM hParent,
                     INetCfgComponent *pncc)
{
    LPWSTR           lpszItemName;
    LPWSTR           lpszId;
    GUID             guidClass;
    BOOL             fEnabled;
    ULONG            ulStatus;
    HTREEITEM        hTreeItem;
    TV_INSERTSTRUCTW tvInsertStruc;
    HRESULT          hr;

    hTreeItem = NULL;

    hr = pncc->GetDisplayName( &lpszItemName );

    if ( hr == S_OK ) {

        //
        // Get the inf id of the network component. We store it at lParam
        // and use it later to retrieve its interface pointer.
        //

        hr = pncc->GetId( &lpszId );

        if ( hr == S_OK ) {

            //
            // If it is a network adapter then, find out if it enabled/disabled.
            //

            hr = pncc->GetClassGuid( &guidClass );

            if ( hr == S_OK ) {
                if ( IsEqualGUID(guidClass, GUID_DEVCLASS_NET) ) {
                    hr = pncc->GetDeviceStatus( &ulStatus );
                    fEnabled = ulStatus == 0;
                }
                else {
                    fEnabled = TRUE;
                }
            }
            else {

                //
                // We can't get the status, so assume that it is disabled.
                //

                fEnabled = FALSE;
            }

            ZeroMemory(
                  &tvInsertStruc,
                  sizeof(TV_INSERTSTRUCTW) );

            tvInsertStruc.hParent = hParent;

            tvInsertStruc.hInsertAfter = TVI_LAST;

            tvInsertStruc.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE |
                                      TVIF_SELECTEDIMAGE | TVIF_STATE;

            tvInsertStruc.item.pszText = lpszItemName;

            tvInsertStruc.item.cchTextMax = wcslen( lpszItemName ) + sizeof(WCHAR);

            SetupDiGetClassImageIndex( &ClassImageListData,
                                       &guidClass,
                                       &tvInsertStruc.item.iImage );

            tvInsertStruc.item.iSelectedImage = tvInsertStruc.item.iImage;

            tvInsertStruc.item.stateMask = TVIS_OVERLAYMASK;

            if ( fEnabled == FALSE ) {
                tvInsertStruc.item.state = INDEXTOOVERLAYMASK(
                                       IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
            }

            tvInsertStruc.item.lParam = (LPARAM)lpszId;

            hTreeItem = TreeView_InsertItem( hwndTree,
                                             &tvInsertStruc );
            if ( !hTreeItem ) {
                ErrMsg( hr,
                        L"Failed to add %s to the list.",
                        lpszItemName );

                CoTaskMemFree( lpszId );
            }
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the inf id of %s."
                    L" It will not be added to the list.",
                    lpszItemName );
        }

        CoTaskMemFree( lpszItemName );
    }
    else {
        ErrMsg( hr,
                L"Couldn't get the display name of a network component."
                L" It will not be added to the list." );
    }

    return hTreeItem;
}

//
// Function:  RefreshAll
//
// Purpose:   Refreshes the main dialog box.
//
// Arguments:
//    hwndDlg  [in]  Dialog box handle.
//
// Returns:   None.
//
// Notes:
//       

VOID RefreshAll (HWND hwndDlg)
{
    HWND hwndTypeList;
    INT  iSelected;

    //
    // Find the selected network component type.
    //

    hwndTypeList = GetDlgItem( hwndDlg,
                              IDL_COMPONENT_TYPES );

    iSelected = (int)SendMessage( hwndTypeList,
                                  CB_GETCURSEL,
                                  0,
                                  0 );

    if ( iSelected != CB_ERR ) {

        //
        // Before deleting the list in the tree, free the buffer
        // associated with each item. The buffer holds either the
        // INF Id or the pathtoken depending on whether it is a
        // network component or a binding path.
        //

        ReleaseMemory( GetDlgItem(hwndDlg, IDT_BINDINGS),
                       TVI_ROOT );

        TreeView_DeleteItem (
                    GetDlgItem(hwndDlg, IDT_BINDINGS),
                    TVI_ROOT );

        //
        // Repopulate the tree with the selected network compnent
        // type.
        //

        EnumNetBindings( GetDlgItem(hwndDlg, IDT_BINDINGS),
                         (UINT)iSelected );

    }

    return;
}

//
// Function:  RefreshItemState
//
// Purpose:   Refreshes the specified item.
//
// Arguments:
//    hwndTree  [in]  Dialog box handle.
//    hItem     [in]  Item to refresh.
//    fEnable   [in]  TRUE if component is enabled.
//
// Returns:   None.
//
// Notes:
//       

VOID RefreshItemState (HWND hwndTree,
                       HTREEITEM hItem,
                       BOOL fEnable)
{
    TVITEMW       tvItem;

    ZeroMemory( &tvItem,
                sizeof(TVITEMW) );

    tvItem.hItem = hItem;
    tvItem.mask = TVIF_STATE;
    tvItem.stateMask = TVIS_OVERLAYMASK;

    if ( fEnable )
        tvItem.state = INDEXTOOVERLAYMASK( 0 );
    else
        tvItem.state = INDEXTOOVERLAYMASK(
                             IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
    TreeView_SetItem( hwndTree,
                      &tvItem );
    return;
}

//
// Function:  RefreshBindings
//
// Purpose:   Refreshes bindings of a specific component.
//
// Arguments:
//    hwndBindUnBindDlg  [in]  Dialog box handle.
//    lpszInfId          [in]  PnpID of the component whose bindings changed.
//
// Returns:   None.
//
// Notes:
//       

VOID RefreshBindings (HWND hwndBindUnBindDlg,
                      LPWSTR lpszInfId)
{
    INetCfg              *pnc;
    INetCfgComponent     *pncc;
    HWND                 hwndParent;
    HWND                 hwndTree;
    HTREEITEM            hItem;
    HRESULT              hr;


    hwndParent = GetParent( hwndBindUnBindDlg );
    hwndTree = GetDlgItem( hwndParent,
                           IDT_BINDINGS );

    hItem = TreeView_GetSelection( hwndTree );

    hr = HrGetINetCfg( FALSE,
                       APP_NAME,
                       &pnc,
                       NULL );

    if ( hr == S_OK ) {

        hr = pnc->FindComponent( lpszInfId,
                                 &pncc );

        if ( hr == S_OK ) {

            //
            // Delete all the children.
            //

            ReleaseMemory( hwndTree,
                           hItem );

            DeleteChildren( hwndTree,
                            hItem );

            ListBindings( pncc,
                          hwndTree,
                          hItem );

            ReleaseRef( pncc );
        }

        HrReleaseINetCfg( pnc,
                          FALSE );
    }

    return;
}

//
// Function:  ReleaseMemory
//
// Purpose:   Free memory associated with each item in the tree.
//
// Arguments:
//    hwndTree  [in]  Tree handle.
//    hTreeItem [in]  Root item.
//
// Returns:   None.
//
// Notes:
//
// Each node of the tree represents a network component or a binding path.
// At each node, lParam points to an allocated buffer wherein we store the
// inf id if it is a network component or pathtoken name if it is a binding
// path.
// 
//

VOID ReleaseMemory (HWND hwndTree,
                    HTREEITEM hTreeItem)
{
    HTREEITEM  hItemChild;
    TVITEMW    tvItem;

    hItemChild = TreeView_GetChild( hwndTree,
                                    hTreeItem );

    while ( hItemChild ) {

        ZeroMemory(
              &tvItem,
              sizeof(TVITEMW) );

        tvItem.hItem = hItemChild;
        tvItem.mask = TVIF_PARAM;

        TreeView_GetItem( hwndTree,
                          &tvItem );

        //
        // It should never be NULL but just in case...
        //

        if ( tvItem.lParam ) {
            CoTaskMemFree( (LPVOID)tvItem.lParam );

        }

        ReleaseMemory( hwndTree, hItemChild );

        hItemChild = TreeView_GetNextSibling( hwndTree,
                                              hItemChild );
    }

    return;
}

//
// Function:  DeleteChildren
//
// Purpose:   Delete childen of a specific item.
//
// Arguments:
//    hwndTree  [in]  Tree handle.
//    hTreeItem [in]  Parent item.
//
// Returns:   None.
//
// Notes:
//

VOID DeleteChildren (HWND hwndTree,
                     HTREEITEM hTreeItem)
{
    HTREEITEM  hItemChild;
    HTREEITEM  hItemSibling;

    hItemChild = TreeView_GetChild( hwndTree,
                                    hTreeItem );

    while ( hItemChild ) {

        DeleteChildren( hwndTree,
                        hItemChild );

        hItemSibling = TreeView_GetNextSibling( hwndTree,
                                                hItemChild );
        TreeView_DeleteItem( hwndTree,
                             hItemChild );

        hItemChild = hItemSibling;
    }

    return;
}

//
// Function:  InsertItem
//
// Purpose:   Insert text for each network component type.
//
// Arguments:
//    hwndTree  [in]  Tree handle.
//    uiType    [in]  Item type, protocol, client, service.
//
// Returns:   Item handle on success, otherwise NULL.
//
// Notes:
//

HTREEITEM InsertItem (HWND hwndTree,
                      UINT uiType)
{
    TV_INSERTSTRUCTW tvInsertStruc;

    ZeroMemory(
          &tvInsertStruc,
          sizeof(TV_INSERTSTRUCTW) );

    tvInsertStruc.hParent = TVI_ROOT;

    tvInsertStruc.hInsertAfter = TVI_LAST;

    tvInsertStruc.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE |
                              TVIF_SELECTEDIMAGE;


    switch( uiType ) {

        case CLIENTS_SELECTED:
            tvInsertStruc.item.pszText = L"Client";
            break;

        case SERVICES_SELECTED:
            tvInsertStruc.item.pszText = L"Service";
            break;

        default:
            tvInsertStruc.item.pszText = L"Protocol";
            break;
    }

    tvInsertStruc.item.cchTextMax = wcslen( tvInsertStruc.item.pszText ) +
                                    sizeof(WCHAR);

    SetupDiGetClassImageIndex( &ClassImageListData,
                               pguidNetClass[uiType],
                               &tvInsertStruc.item.iImage );

    tvInsertStruc.item.iSelectedImage = tvInsertStruc.item.iImage;

    tvInsertStruc.item.lParam = (LPARAM)uiType;

    return TreeView_InsertItem( hwndTree,
                                &tvInsertStruc );

}

//
// Function:  UpdateComponentTypeList
//
// Purpose:   Insert text for each network component type.
//
// Arguments:
//    hwndTypeList  [in]  ListView handle.
//
// Returns:   TRUE on success.
//
// Notes:
//

BOOL UpdateComponentTypeList (HWND hwndTypeList)
{
    UINT i;

    for (i=0; i < 3; ++i) {
        SendMessage( hwndTypeList,
                     CB_ADDSTRING,
                     (WPARAM)0,
                     (LPARAM)lpszNetClass[i] );
    }

    SendMessage( hwndTypeList,
                 CB_SETCURSEL,
                 (WPARAM)DEFAULT_COMPONENT_SELECTED,
                 (LPARAM)0 );
    return TRUE;
}

//
// Function:  ErrMsg
//
// Purpose:   Insert text for each network component type.
//
// Arguments:
//    hr  [in]  Error code.
//
// Returns:   None.
//
// Notes:
//

VOID ErrMsg (HRESULT hr,
             LPCWSTR  lpFmt,
             ...)
{

    LPWSTR   lpSysMsg;
    WCHAR    buf[400];
    ULONG    offset;
    va_list  vArgList; 


    if ( hr != 0 ) {
        swprintf( buf,
                  L"Error %#lx: ",
                  hr );
    }
    else {
        buf[0] = 0;
    }

    offset = wcslen( buf );
  
    va_start( vArgList,
              lpFmt );
    vswprintf( buf+offset,
                lpFmt,
                vArgList );

    va_end( vArgList );

    if ( hr != 0 ) {
        FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                       FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_IGNORE_INSERTS,
                       NULL,
                       hr,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       (LPWSTR)&lpSysMsg,
                       0,
                       NULL );
        if ( lpSysMsg ) {

            offset = wcslen( buf );

            swprintf( buf+offset,
                      L"\n\nPossible cause:\n\n" );

            offset = wcslen( buf );

            wcscat( buf+offset,
                     lpSysMsg );

            LocalFree( (HLOCAL)lpSysMsg );
        }

        MessageBoxW( NULL,
                    buf,
                    L"Error",
                    MB_ICONERROR | MB_OK );
    }
    else {
        MessageBoxW( NULL,
                    buf,
                    L"BindView",
                    MB_ICONINFORMATION | MB_OK );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\filter\dllmain.cpp ===
#include "pch.h"
#pragma hdrstop
#include "passthru.h"
#include "initguid.h"
#include "passthrn_i.c"

// Global
//#include "sfnetcfg_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CPassthru, CPassthru)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\bindview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BindView.rc
//
#define IDD_MAIN                        101
#define IDM_OPTIONS                     101
#define IDI_BINDVIEW                    105
#define IDD_BIND_UNBIND                 106
#define IDD_INSTALL                     107
#define IDD_UNINSTALL                   108
#define IDT_BINDINGS                    1000
#define IDB_INSTALL                     1001
#define IDB_UNINSTALL                   1002
#define IDS_COMPONENT                   1003
#define IDL_COMPONENT_TYPES             1004
#define IDB_EXPAND_ALL                  1005
#define IDB_COLLAPSE_ALL                1006
#define IDB_BROWSE                      1007
#define IDB_OK                          1011
#define IDS_ENABLE                      1012
#define IDE_OWNER                       1013
#define IDE_DEPTH                       1014
#define IDB_BIND_UNBIND                 1016
#define IDG_COMPONENT_LIST              1018
#define IDB_CLOSE                       1021
#define IDB_REMOVE                      1022
#define IDT_COMPONENT_LIST              1024
#define IDB_SAVE                        1025
#define IDI_ENABLE                      40001
#define IDI_UNBIND_FROM                 40004
#define IDI_BIND_TO                     40005
#define IDI_CANCEL                      40006
#define IDI_DISABLE                     40007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40008
#define _APS_NEXT_CONTROL_VALUE         1028
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\filter\implinc.cpp ===
#include "pch.h"
#pragma hdrstop

#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>

#include <initguid.h>
#include <devguid.h>

//EXTERN_C const IID IID_INetLanConnectionUiInfo = {0xC08956A6,0x1CD3,0x11D1,{0xB1,0xC5,0x00,0x80,0x5F,0xC1,0x27,0x0E}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\filter\pch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P C H . H
//
//  Contents:   Pre-compiled header file for the passthru notify object
//
//  Notes:
//
//----------------------------------------------------------------------------

#pragma once

// Turns off "string too long - truncated to 255 characters in the debug
// information, debugger cannot evaluate symbol."
//
#pragma warning (disable: 4786)

#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>

#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\filter\passthru.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P A S S T H R U . C P P
//
//  Contents:   Notify object code for the Passthru driver.
//
//  Notes:
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "passthru.h"

// =================================================================
// Forward declarations

LRESULT CALLBACK PassthruDialogProc(HWND hWnd, UINT uMsg,
                                        WPARAM wParam, LPARAM lParam);
UINT CALLBACK PassthruPropSheetPageProc(HWND hWnd, UINT uMsg,
                                            LPPROPSHEETPAGE ppsp);
HRESULT HrOpenAdapterParamsKey(GUID* pguidAdapter,
                               HKEY* phkeyAdapter);
HRESULT HrCopyMiniportInf (VOID);

inline ULONG ReleaseObj(IUnknown* punk)
{
    return (punk) ? punk->Release () : 0;
}

// =================================================================


//+---------------------------------------------------------------------------
//
// Function:  CPassthruParams::CPassthruParams
//
// Purpose:   constructor for class CPassthruParams
//
// Arguments: None
//
// Returns:
//
// Notes:
//
CPassthruParams::CPassthruParams(VOID)
{
    m_szParam1[0]      = '\0';
    m_szParam2[0]    = '\0';
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::CPassthru
//
// Purpose:   constructor for class CPassthru
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
CPassthru::CPassthru(VOID) :
        m_pncc(NULL),
        m_pnc(NULL),
        m_eApplyAction(eActUnknown),
        m_pUnkContext(NULL)
{
    TraceMsg(L"--> CPassthru::CPassthru\n");

    m_cAdaptersAdded   = 0;
    m_cAdaptersRemoved = 0;
    m_fConfigRead      = FALSE;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::~CPassthru
//
// Purpose:   destructor for class CPassthru
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
CPassthru::~CPassthru(VOID)
{
    TraceMsg(L"--> CPassthru::~CPassthru\n");

    // release interfaces if acquired

    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);
    ReleaseObj(m_pUnkContext);
}

// =================================================================
// INetCfgNotify
//
// The following functions provide the INetCfgNotify interface
// =================================================================


// ----------------------------------------------------------------------
//
// Function:  CPassthru::Initialize
//
// Purpose:   Initialize the notify object
//
// Arguments:
//    pnccItem    [in]  pointer to INetCfgComponent object
//    pnc         [in]  pointer to INetCfg object
//    fInstalling [in]  TRUE if we are being installed
//
// Returns:
//
// Notes:
//
STDMETHODIMP CPassthru::Initialize(INetCfgComponent* pnccItem,
        INetCfg* pnc, BOOL fInstalling)
{
    TraceMsg(L"--> CPassthru::Initialize\n");

    // save INetCfg & INetCfgComponent and add refcount

    m_pncc = pnccItem;
    m_pnc = pnc;

    if (m_pncc)
    {
        m_pncc->AddRef();
    }
    if (m_pnc)
    {
        m_pnc->AddRef();
    }

    if ( fInstalling )
    {
        OSVERSIONINFO osvi;

        ZeroMemory( &osvi,
                    sizeof(OSVERSIONINFO) );
        
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if ( GetVersionEx(&osvi) ) 
        {
            if ( (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && 
                 (osvi.dwMajorVersion == 5) &&
                 (osvi.dwMinorVersion == 0) )
            {
                // On Windows 2000, copy the miniport inf file to %windir%\inf.

                TraceMsg(L"    CPassthru::Initialize: Copying miniport inf to system inf directory...\n");
                HrCopyMiniportInf();
            }
            else
            {
                TraceMsg(L"    CPassthru::Initialize: Skipping copying miniport inf to system inf directory...\n");
            }
        }
    }

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::ReadAnswerFile
//
// Purpose:   Read settings from answerfile and configure Passthru
//
// Arguments:
//    pszAnswerFile    [in]  name of AnswerFile
//    pszAnswerSection [in]  name of parameters section
//
// Returns:
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
STDMETHODIMP CPassthru::ReadAnswerFile(PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection)
{
    TraceMsg(L"--> CPassthru::ReadAnswerFile\n");

    PCWSTR pszParamReadFromAnswerFile = L"ParamFromAnswerFile";

    // We will pretend here that szParamReadFromAnswerFile was actually
    // read from the AnswerFile using the following steps
    //
    //   - Open file pszAnswerFile using SetupAPI
    //   - locate section pszAnswerSection
    //   - locate the required key and get its value
    //   - store its value in pszParamReadFromAnswerFile
    //   - close HINF for pszAnswerFile

    // Now that we have read pszParamReadFromAnswerFile from the
    // AnswerFile, store it in our memory structure.
    // Remember we should not be writing it to the registry till
    // our Apply is called!!
    //
    wcscpy(m_sfParams.m_szParam1, pszParamReadFromAnswerFile);

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::Install
//
// Purpose:   Do operations necessary for install.
//
// Arguments:
//    dwSetupFlags [in]  Setup flags
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
STDMETHODIMP CPassthru::Install(DWORD dw)
{
    TraceMsg(L"--> CPassthru::Install\n");

    // Start up the install process
    HRESULT hr = S_OK;

    m_eApplyAction = eActInstall;

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::Removing
//
// Purpose:   Do necessary cleanup when being removed
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the removal is actually complete only when Apply is called!
//
STDMETHODIMP CPassthru::Removing(VOID)
{
    TraceMsg(L"--> CPassthru::Removing\n");

    HRESULT     hr = S_OK;

    m_eApplyAction = eActRemove;

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::Cancel
//
// Purpose:   Cancel any changes made to internal data
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CPassthru::CancelChanges(VOID)
{
    TraceMsg(L"--> CPassthru::CancelChanges\n");

    m_sfParams.m_szParam1[0] = '\0';

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::ApplyRegistryChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     We can make changes to registry etc. here.
//
STDMETHODIMP CPassthru::ApplyRegistryChanges(VOID)
{
    TraceMsg(L"--> CPassthru::ApplyRegistryChanges\n");

    HRESULT hr=S_OK;
    HKEY hkeyParams=NULL;
    HKEY hkeyAdapter;

    //
    // set default Param2 for newly added adapters
    //
    for (UINT cAdapter=0; cAdapter < m_cAdaptersAdded; cAdapter++)
    {
        hr = HrOpenAdapterParamsKey(&m_guidAdaptersAdded[cAdapter],
                                    &hkeyAdapter);
        if (S_OK == hr)
        {
            RegSetValueEx(
                    hkeyAdapter,
                    c_szParam2,
                    NULL, REG_SZ,
                    (LPBYTE) c_szParam2Default,
                    wcslen(c_szParam2Default)
                    *sizeof(WCHAR));

            RegCloseKey(hkeyAdapter);
        }
    }

    //
    // delete parameters of adapters that are unbound/removed
    //
    for (cAdapter=0; cAdapter < m_cAdaptersRemoved; cAdapter++)
    {
        //$ REVIEW  kumarp 23-November-98
        //
        // code to remove passthru\Parameters\Adapters\{guid} key
    }

    // do things that are specific to a config action

    switch (m_eApplyAction)
    {
    case eActPropertyUI:
        // A possible improvement might be to write the reg. only
        // if Param1 is modified.

        hr = m_pncc->OpenParamKey(&hkeyParams);
        if (S_OK == hr)
        {
            RegSetValueEx(hkeyParams, c_szParam1, NULL, REG_SZ,
                          (LPBYTE) m_sfParams.m_szParam1,
                          wcslen(m_sfParams.m_szParam1)*sizeof(WCHAR));

            RegCloseKey(hkeyParams);
        }

        HKEY hkeyAdapter;
        hr = HrOpenAdapterParamsKey(&m_guidAdapter, &hkeyAdapter);
        if (S_OK == hr)
        {
            RegSetValueEx(hkeyAdapter, c_szParam2, NULL, REG_SZ,
                          (LPBYTE) m_sfParams.m_szParam2,
                          wcslen(m_sfParams.m_szParam2)*sizeof(WCHAR));
            RegCloseKey(hkeyAdapter);
        }
        break;


    case eActInstall:
    case eActRemove:
        break;
    }

    return hr;
}

STDMETHODIMP
CPassthru::ApplyPnpChanges(
    IN INetCfgPnpReconfigCallback* pICallback)
{
    WCHAR szDeviceName[64];

    StringFromGUID2(
        m_guidAdapter,
        szDeviceName,
        (sizeof(szDeviceName) / sizeof(szDeviceName[0])));

    pICallback->SendPnpReconfig (
        NCRL_NDIS,
        c_szPassthruNdisName,
        szDeviceName,
        m_sfParams.m_szParam2,
        (wcslen(m_sfParams.m_szParam2) + 1) * sizeof(WCHAR));

    return S_OK;
}

// =================================================================
// INetCfgSystemNotify
// =================================================================

// ----------------------------------------------------------------------
//
// Function:  CPassthru::GetSupportedNotifications
//
// Purpose:   Tell the system which notifications we are interested in
//
// Arguments:
//    pdwNotificationFlag [out]  pointer to NotificationFlag
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CPassthru::GetSupportedNotifications(
        OUT DWORD* pdwNotificationFlag)
{
    TraceMsg(L"--> CPassthru::GetSupportedNotifications\n");

    *pdwNotificationFlag = NCN_NET | NCN_NETTRANS | NCN_ADD | NCN_REMOVE;

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::SysQueryBindingPath
//
// Purpose:   Allow or veto formation of a binding path
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbp        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CPassthru::SysQueryBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbp)
{
    TraceMsg(L"--> CPassthru::SysQueryBindingPath\n");

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::SysNotifyBindingPath
//
// Purpose:   System tells us by calling this function which
//            binding path has just been formed.
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbpItem    [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CPassthru::SysNotifyBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbpItem)
{
    TraceMsg(L"--> CPassthru::SysNotifyBindingPath\n");

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::SysNotifyComponent
//
// Purpose:   System tells us by calling this function which
//            component has undergone a change (installed/removed)
//
// Arguments:
//    dwChangeFlag [in]  type of system change
//    pncc         [in]  pointer to INetCfgComponent object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CPassthru::SysNotifyComponent(DWORD dwChangeFlag,
        INetCfgComponent* pncc)
{
    TraceMsg(L"--> CPassthru::SysNotifyComponent\n");

    return S_OK;
}

// =================================================================
// INetCfgProperties
// =================================================================


STDMETHODIMP CPassthru::SetContext(
        IUnknown * pUnk)
{
    TraceMsg(L"--> CPassthru::SetContext\n");

    HRESULT hr = S_OK;

    // release previous context, if any
    ReleaseObj(m_pUnkContext);
    m_pUnkContext = NULL;

    if (pUnk) // set the new context
    {
        m_pUnkContext = pUnk;
        m_pUnkContext->AddRef();
        ZeroMemory(&m_guidAdapter, sizeof(m_guidAdapter));

        // here we assume that we are going to be called only for
        // a LAN connection since the sample IM works only with
        // LAN devices
        INetLanConnectionUiInfo * pLanConnUiInfo;
        hr = m_pUnkContext->QueryInterface(
                IID_INetLanConnectionUiInfo,
                reinterpret_cast<PVOID *>(&pLanConnUiInfo));
        if (S_OK == hr)
        {
            hr = pLanConnUiInfo->GetDeviceGuid(&m_guidAdapter);
            ReleaseObj(pLanConnUiInfo);
        }
    }

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::MergePropPages
//
// Purpose:   Supply our property page to system
//
// Arguments:
//    pdwDefPages   [out]  pointer to num default pages
//    pahpspPrivate [out]  pointer to array of pages
//    pcPages       [out]  pointer to num pages
//    hwndParent    [in]   handle of parent window
//    szStartPage   [in]   pointer to
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CPassthru::MergePropPages(
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* szStartPage)
{
    TraceMsg(L"--> CPassthru::MergePropPages\n");

    HRESULT             hr      = S_OK;
    HPROPSHEETPAGE*     ahpsp   = NULL;

    m_eApplyAction = eActPropertyUI;

    // We don't want any default pages to be shown
    *pdwDefPages = 0;
    *pcPages = 0;
    *pahpspPrivate = NULL;

    ahpsp = (HPROPSHEETPAGE*)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE));
    if (ahpsp)
    {
        PROPSHEETPAGE   psp = {0};

        psp.dwSize            = sizeof(PROPSHEETPAGE);
        psp.dwFlags           = PSP_DEFAULT;
        psp.hInstance         = _Module.GetModuleInstance();
        psp.pszTemplate       = MAKEINTRESOURCE(IDD_PASSTHRU_GENERAL);
        psp.pfnDlgProc        = (DLGPROC) PassthruDialogProc;
        psp.pfnCallback       = (LPFNPSPCALLBACK) PassthruPropSheetPageProc;
        // for Win64, use LONG_PTR instead of LPARAM
        psp.lParam            = (LPARAM) this;
        psp.pszHeaderTitle    = NULL;
        psp.pszHeaderSubTitle = NULL;

        ahpsp[0] = ::CreatePropertySheetPage(&psp);
        *pcPages = 1;
        *pahpspPrivate = (LPBYTE) ahpsp;
    }

    return hr;
}


// ----------------------------------------------------------------------
//
// Function:  CPassthru::ValidateProperties
//
// Purpose:   Validate changes to property page
//
// Arguments:
//    hwndSheet [in]  window handle of property sheet
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CPassthru::ValidateProperties(HWND hwndSheet)
{
    TraceMsg(L"--> CPassthru::ValidateProperties\n");

    // Accept any change to Param1

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::CancelProperties
//
// Purpose:   Cancel changes to property page
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CPassthru::CancelProperties(VOID)
{
    TraceMsg(L"--> CPassthru::CancelProperties\n");

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::ApplyProperties
//
// Purpose:   Apply value of controls on property page
//            to internal memory structure
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     We do this work in OnOk so no need to do it here again.
//
STDMETHODIMP CPassthru::ApplyProperties(VOID)
{
    TraceMsg(L"--> CPassthru::ApplyProperties\n");

    return S_OK;
}


// =================================================================
// INetCfgBindNotify
// =================================================================

// ----------------------------------------------------------------------
//
// Function:  CPassthru::QueryBindingPath
//
// Purpose:   Allow or veto a binding path involving us
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbi        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CPassthru::QueryBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbp)
{
    TraceMsg(L"--> CPassthru::QueryBindingPath\n");

    // we do not want to veto any binding path

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::NotifyBindingPath
//
// Purpose:   System tells us by calling this function which
//            binding path involving us has just been formed.
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbp        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CPassthru::NotifyBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbp)
{
    TraceMsg(L"--> CPassthru::NotifyBindingPath\n");

    return S_OK;
}

// ------------ END OF NOTIFY OBJECT FUNCTIONS --------------------



// -----------------------------------------------------------------
// Property Sheet related functions
//

// ----------------------------------------------------------------------
//
// Function:  CPassthru::OnInitDialog
//
// Purpose:   Initialize controls
//
// Arguments:
//    hWnd [in]  window handle
//
// Returns:
//
// Notes:
//
LRESULT CPassthru::OnInitDialog(IN HWND hWnd)
{
    HKEY hkeyParams;
    HRESULT hr;
    DWORD dwSize;
    DWORD dwError;

    // read in Param1 & Param2 if not already read
    if (!m_fConfigRead)
    {
        m_fConfigRead = TRUE;
        hr = m_pncc->OpenParamKey(&hkeyParams);
        if (S_OK == hr)
        {
            // if this fails, we will show an empty edit box for Param1
            dwSize = MAX_PATH;
            RegQueryValueExW(hkeyParams, c_szParam1, NULL, NULL,
                            (LPBYTE) m_sfParams.m_szParam1, &dwSize);
            RegCloseKey(hkeyParams);
        }

        HKEY hkeyAdapter;
        hr = HrOpenAdapterParamsKey(&m_guidAdapter, &hkeyAdapter);
        if (S_OK == hr)
        {
            dwSize = MAX_PATH;
            dwError = RegQueryValueExW(hkeyAdapter, c_szParam2, NULL, NULL,
                                      (LPBYTE) m_sfParams.m_szParam2, &dwSize);
            RegCloseKey(hkeyAdapter);
        }
    }

    // Param1 edit box
    ::SendMessage(GetDlgItem(hWnd, IDC_PARAM1), EM_SETLIMITTEXT, MAX_PATH-1, 0);
    ::SetWindowText(GetDlgItem(hWnd, IDC_PARAM1), m_sfParams.m_szParam1);

    // Param2 edit box
    ::SendMessage(GetDlgItem(hWnd, IDC_PARAM2), EM_SETLIMITTEXT, MAX_PATH-1, 0);
    ::SetWindowText(GetDlgItem(hWnd, IDC_PARAM2), m_sfParams.m_szParam2);

    return PSNRET_NOERROR;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::OnOk
//
// Purpose:   Do actions when OK is pressed
//
// Arguments:
//    hWnd [in]  window handle
//
// Returns:
//
// Notes:
//
LRESULT CPassthru::OnOk(IN HWND hWnd)
{
    TraceMsg(L"--> CPassthru::OnOk\n");

    ::GetWindowText(GetDlgItem(hWnd, IDC_PARAM1),
                    m_sfParams.m_szParam1, MAX_PATH);
    ::GetWindowText(GetDlgItem(hWnd, IDC_PARAM2),
                    m_sfParams.m_szParam2, MAX_PATH);

    return PSNRET_NOERROR;
}

// ----------------------------------------------------------------------
//
// Function:  CPassthru::OnCancel
//
// Purpose:   Do actions when CANCEL is pressed
//
// Arguments:
//    hWnd [in]  window handle
//
// Returns:
//
// Notes:
//
LRESULT CPassthru::OnCancel(IN HWND hWnd)
{
    TraceMsg(L"--> CPassthru::OnCancel\n");

    return FALSE;
}

// ----------------------------------------------------------------------
//
// Function:  PassthruDialogProc
//
// Purpose:   Dialog proc
//
// Arguments:
//    hWnd   [in]  see win32 documentation
//    uMsg   [in]  see win32 documentation
//    wParam [in]  see win32 documentation
//    lParam [in]  see win32 documentation
//
// Returns:
//
// Notes:
//
LRESULT
CALLBACK
PassthruDialogProc (
    HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PROPSHEETPAGE*  ppsp;
    LRESULT         lRes = 0;

    static PROPSHEETPAGE* psp = NULL;
    CPassthru* psf;

    if (uMsg == WM_INITDIALOG)
    {
        ppsp = (PROPSHEETPAGE *)lParam;
        psf = (CPassthru *)ppsp->lParam;
        SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR)psf);

        lRes = psf->OnInitDialog(hWnd);
        return lRes;
    }
    else
    {
        psf = (CPassthru *)::GetWindowLongPtr(hWnd, DWLP_USER);

        // Until we get WM_INITDIALOG, just return FALSE
        if (!psf)
        {
            return FALSE;
        }
    }

    if (WM_COMMAND == uMsg)
    {
        if (EN_CHANGE == HIWORD(wParam))
        {
            // Set the property sheet changed flag if any of our controls
            // get changed.  This is important so that we get called to
            // apply our property changes.
            //
            PropSheet_Changed(GetParent(hWnd), hWnd);
        }
    }
    else if (WM_NOTIFY == uMsg)
    {
        LPNMHDR pnmh = (LPNMHDR)lParam;

        switch (pnmh->code)
        {
        case PSN_SETACTIVE:
            lRes = 0;        // accept activation
            break;

        case PSN_KILLACTIVE:
            // ok to loose being active
            SetWindowLongPtr(hWnd, DWLP_MSGRESULT, FALSE);
            lRes = TRUE;
            break;

        case PSN_APPLY:
            lRes = psf->OnOk(hWnd);
            break;

        case PSN_RESET:
            lRes = psf->OnCancel(hWnd);
            break;

        default:
            lRes = FALSE;
            break;
        }
    }

    return lRes;
}

// ----------------------------------------------------------------------
//
// Function:  PassthruPropSheetPageProc
//
// Purpose:   Prop sheet proc
//
// Arguments:
//    hWnd [in]  see win32 documentation
//    uMsg [in]  see win32 documentation
//    ppsp [in]  see win32 documentation
//
// Returns:
//
// Notes:
//
UINT CALLBACK PassthruPropSheetPageProc(HWND hWnd, UINT uMsg,
                                            LPPROPSHEETPAGE ppsp)
{
    UINT uRet = TRUE;


    return uRet;
}


// -----------------------------------------------------------------
//
//  Utility Functions
//

HRESULT HrGetBindingInterfaceComponents (
    INetCfgBindingInterface*    pncbi,
    INetCfgComponent**          ppnccUpper,
    INetCfgComponent**          ppnccLower)
{
    HRESULT hr=S_OK;

    // Initialize output parameters
    *ppnccUpper = NULL;
    *ppnccLower = NULL;

    INetCfgComponent* pnccUpper;
    INetCfgComponent* pnccLower;

    hr = pncbi->GetUpperComponent(&pnccUpper);
    if (SUCCEEDED(hr))
    {
        hr = pncbi->GetLowerComponent(&pnccLower);
        if (SUCCEEDED(hr))
        {
            *ppnccUpper = pnccUpper;
            *ppnccLower = pnccLower;
        }
        else
        {
            ReleaseObj(pnccUpper);
        }
    }

    return hr;
}

HRESULT HrOpenAdapterParamsKey(GUID* pguidAdapter,
                               HKEY* phkeyAdapter)
{
    HRESULT hr=S_OK;

    HKEY hkeyServiceParams;
    WCHAR szGuid[48];
    WCHAR szAdapterSubkey[128];
    DWORD dwError;

    if (ERROR_SUCCESS ==
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szPassthruParams,
                     0, KEY_ALL_ACCESS, &hkeyServiceParams))
    {
        StringFromGUID2(*pguidAdapter, szGuid, 47);
        _stprintf(szAdapterSubkey, L"Adapters\\%s", szGuid);
        if (ERROR_SUCCESS !=
            (dwError = RegOpenKeyEx(hkeyServiceParams,
                                    szAdapterSubkey, 0,
                                    KEY_ALL_ACCESS, phkeyAdapter)))
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }
        RegCloseKey(hkeyServiceParams);
    }

    return hr;
}


#if DBG
void TraceMsg(PCWSTR szFormat, ...)
{
    static WCHAR szTempBuf[4096];

    va_list arglist;

    va_start(arglist, szFormat);

    _vstprintf(szTempBuf, szFormat, arglist);
    OutputDebugString(szTempBuf);

    va_end(arglist);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\filter\passthru.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       P A S S T H R U . H
//
//  Contents:   Notify object code for the Passthru driver.
//
//  Notes:
//
//  Author:     kumarp 26-March-98
//
//----------------------------------------------------------------------------

#pragma once
#include "passthrn.h"
#include "resource.h"

// =================================================================
// string constants
//
const WCHAR c_szParam1[]                = L"Param1";
const WCHAR c_szParam2[]                = L"Param2";
const WCHAR c_szParam2Default[]         = L"<no-value>";
const WCHAR c_szPassthruParams[]        = L"System\\CurrentControlSet\\Services\\Passthru\\Parameters";
const WCHAR c_szPassthruId[]            = L"MS_Passthru";
const WCHAR c_szPassthruNdisName[]      = L"Passthru";

#if DBG
void TraceMsg(PCWSTR szFormat, ...);
#else
#define TraceMsg
#endif

// What type of config change the user/system is performing
enum ConfigAction {eActUnknown, eActInstall, eActRemove, eActPropertyUI};

#define MAX_ADAPTERS 64         // max no. of physical adapters in a machine

class CPassthruParams
{
public:
    WCHAR m_szParam1[MAX_PATH];
    WCHAR m_szParam2[MAX_PATH];

    CPassthruParams();
};

class CPassthru :
    public CComObjectRoot,
    public CComCoClass<CPassthru, &CLSID_CPassthru>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentPropertyUi,
    public INetCfgComponentNotifyBinding,
    public INetCfgComponentNotifyGlobal
{
public:
    CPassthru(VOID);
    ~CPassthru(VOID);

    BEGIN_COM_MAP(CPassthru)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
    END_COM_MAP()

    // DECLARE_NOT_AGGREGATABLE(CPassthru)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_PASSTHRU)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback);
    STDMETHOD (CancelChanges) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR szAnswerFile,
                                     PCWSTR szAnswerSections);
    STDMETHOD (Upgrade)             (DWORD, DWORD) {return S_OK;}
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Removing)            ();

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

// INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

// INetCfgNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);

private:
    INetCfgComponent*   m_pncc;
    INetCfg*            m_pnc;
    ConfigAction        m_eApplyAction;
    CPassthruParams m_sfParams;
    IUnknown*           m_pUnkContext;
    GUID                m_guidAdapter;
    GUID                m_guidAdaptersAdded[MAX_ADAPTERS];
    UINT                m_cAdaptersAdded;
    GUID                m_guidAdaptersRemoved[MAX_ADAPTERS];
    UINT                m_cAdaptersRemoved;
    BOOL                m_fConfigRead;

// Utility functions
public:
    LRESULT OnInitDialog(IN HWND hWnd);
    LRESULT OnOk(IN HWND hWnd);
    LRESULT OnCancel(IN HWND hWnd);

private:

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\filter\resource.h ===
//#include <ncres.h>

#pragma once

#define IDR_REG_PASSTHRU 40001

#define IDD_PASSTHRU_GENERAL      1850
#define IDC_PARAM1                1851
#define IDC_PARAM2                1852
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\filter\setupdi.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S E T U P D I . C P P
//
//  Contents:   Code to copy Net class inf file
//
//  Notes:
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "passthru.h"
#include <setupapi.h>

// =================================================================
// Forward declarations

HRESULT HrCopyMiniportInf (VOID);
HRESULT HrGetProtocolInf (LPWSTR lpszWindowsDir,
                          LPWSTR *lppszProtocolInf);
HRESULT HrGetMediaRootDir (LPWSTR lpszInfFile,
                           LPWSTR *lppszMediaRoot);
HRESULT HrGetPnpID (LPWSTR lpszInfFile,
                    LPWSTR *lppszPnpID);
HRESULT HrGetKeyValue (HINF hInf,
                       LPCWSTR lpszSection,
                       LPCWSTR lpszKey,
                       DWORD  dwIndex,
                       LPWSTR *lppszValue);



const WCHAR c_szInfPath[]               = L"Inf\\";
const WCHAR c_szMiniportInf[]           = L"netsf_m.inf";
const WCHAR c_szInfSourcePathInfo[]     = L"InfSourcePathInfo";
const WCHAR c_szOriginalInfSourcePath[] = L"OriginalInfSourcePath";

HRESULT HrCopyMiniportInf (VOID)
{
    LPWSTR  lpszWindowsDir;
    LPWSTR  lpszProtocolInf;
    LPWSTR  lpszMediaRoot;
    LPWSTR  lpszMiniportInf;
    DWORD   dwLen;
    HRESULT hr;

    //
    // Get %windir% directory.
    //

    dwLen = GetSystemWindowsDirectoryW( NULL, 0 );

    if ( dwLen == 0 )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Add 1 for NULL and 1 for "\" in case it is needed.

    dwLen += wcslen(c_szInfPath) + 2;

    lpszWindowsDir = (LPWSTR)CoTaskMemAlloc( dwLen * sizeof(WCHAR) );

    if ( !lpszWindowsDir )
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if ( GetSystemWindowsDirectoryW(lpszWindowsDir, dwLen) == 0 )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }
    else
    {
        // Append "inf\" to %windir%.

        dwLen = wcslen( lpszWindowsDir );

        if ( lpszWindowsDir[dwLen-1] == L'\\' )
        {
            wcscat( lpszWindowsDir, c_szInfPath );
        }
        else
        {
            wcscat( lpszWindowsDir, L"\\" );
            wcscat( lpszWindowsDir, c_szInfPath );
        }

        //
        // Find the protocol inf name. Originally, it was netsf.inf but has
        // been renamed to oem?.inf by SetupCopyOEMInf.
        //

        hr = HrGetProtocolInf( lpszWindowsDir, &lpszProtocolInf );

        if ( hr == S_OK )
        {
            //
            // Get the directory from where protocol was installed.

            hr = HrGetMediaRootDir( lpszProtocolInf, &lpszMediaRoot );

            if ( hr == S_OK )
            {

                TraceMsg(L"Media root directory is %s.\n", lpszMediaRoot);

                // Add 1 for NULL and 1 for "\" in case it is needed.

                lpszMiniportInf = (LPWSTR)CoTaskMemAlloc( (wcslen(lpszMediaRoot) +
                                                          wcslen(c_szMiniportInf) + 2) *
                                                          sizeof(WCHAR) );
                if ( lpszMiniportInf == NULL )
                {
                    hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    //
                    // We know the full path from where the protocol is being installed. Our
                    // miniport inf is in the same location. Copy the miniport inf to
                    // %windir%\inf so that when we install the virtual miniport, Setup
                    // will find the miniport inf.
                    //

                    wcscpy( lpszMiniportInf, lpszMediaRoot );

                    dwLen = wcslen( lpszMiniportInf );
                    if ( lpszMiniportInf[dwLen-1] != L'\\' )
                    {
                        wcscat( lpszMiniportInf, L"\\" );
                    }

                    wcscat( lpszMiniportInf, c_szMiniportInf );

                    TraceMsg(L"Calling SetupCopyOEMInf for %s.\n", lpszMiniportInf);

                    if ( !SetupCopyOEMInf(lpszMiniportInf,
                                          lpszMediaRoot,
                                          SPOST_PATH,
                                          0,
                                          NULL,
                                          0,
                                          NULL,
                                          NULL) )
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }

                    CoTaskMemFree( lpszMiniportInf );
                }

                CoTaskMemFree( lpszMediaRoot );
            }

            CoTaskMemFree( lpszProtocolInf );
        }
    }

    CoTaskMemFree( lpszWindowsDir );

    return hr;
}


//
// The function searches through all the inf files in %windir%\inf and
// returns the name of the protocol's inf.
//

HRESULT HrGetProtocolInf (LPWSTR lpszWindowsDir,
                          LPWSTR *lppszProtocolInf)
{
    LPWSTR  lpszFileList;
    LPWSTR  lpszFile;
    LPWSTR  lpszFileWithPath;
    LPWSTR  lpszPnpID;
    DWORD   dwSizeNeeded;
    BOOL    fTrailingSlash;
    DWORD   dwLen;
    BYTE    found;
    HRESULT hr;

    *lppszProtocolInf = NULL;
    dwLen = wcslen( lpszWindowsDir );
    fTrailingSlash = lpszWindowsDir[dwLen-1] == L'\\';

    if ( SetupGetInfFileListW(lpszWindowsDir,
                              INF_STYLE_WIN4,
                              NULL,
                              0,
                              &dwSizeNeeded) == 0 )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    lpszFileList = (LPWSTR)CoTaskMemAlloc( sizeof(WCHAR) * dwSizeNeeded );

    if ( !lpszFileList )
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if ( SetupGetInfFileListW( lpszWindowsDir,
                               INF_STYLE_WIN4,
                               lpszFileList,
                               dwSizeNeeded,
                               NULL) == 0 )

    {
        CoTaskMemFree( lpszFileList );
        return HRESULT_FROM_WIN32(GetLastError());
    }

    lpszFile = lpszFileList;
    found = 0;
    hr = S_OK;
    while( (hr == S_OK) && !found && *lpszFile )
    {
        lpszFileWithPath = (LPWSTR)CoTaskMemAlloc( sizeof(WCHAR) *
                                                  (wcslen(lpszFile) +
                                                  dwLen + 1 +
                                                  ((fTrailingSlash) ? 0 : 1)) );
        if ( !lpszFileWithPath )
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        else
        {
            if ( fTrailingSlash )
            {
             swprintf( lpszFileWithPath, L"%s%s",
                       lpszWindowsDir,
                       lpszFile );
            }
            else
            {
                swprintf( lpszFileWithPath, L"%s\\%s",
                          lpszWindowsDir,
                          lpszFile );
            }

            hr = HrGetPnpID( lpszFileWithPath, &lpszPnpID );

            // If the inf file installs a driver then, it will have a Model
            // section with the hwid/PnpID of the driver that is installed.
            //
            // In case, there is an error getting the hwid, we simply ignore
            // the inf file and continue with the next one.

            if ( hr == S_OK )
            {
                if (_wcsicmp(lpszPnpID, c_szPassthruId) == 0 )
                {
                    found = 1;
                }

                CoTaskMemFree( lpszPnpID );
            }

            if ( !found )
            {
                hr = S_OK;
                CoTaskMemFree( lpszFileWithPath );
                lpszFile += wcslen(lpszFile) + 1;
            }
        }
    }

    if ( found )
    {
        *lppszProtocolInf = lpszFileWithPath;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    CoTaskMemFree( lpszFileList );

    return hr;
}

HRESULT HrGetPnpID (LPWSTR lpszInfFile,
                    LPWSTR *lppszPnpID)
{
    HINF    hInf;
    LPWSTR  lpszModelSection;
    HRESULT hr;

    *lppszPnpID = NULL;

    hInf = SetupOpenInfFileW( lpszInfFile,
                              NULL,
                              INF_STYLE_WIN4,
                              NULL );

    if ( hInf == INVALID_HANDLE_VALUE )
    {

        return HRESULT_FROM_WIN32(GetLastError());
    }

    hr = HrGetKeyValue( hInf,
                        L"Manufacturer",
                        NULL,
                        1,
                        &lpszModelSection );

    if ( hr == S_OK )
    {
        hr = HrGetKeyValue( hInf,
                            lpszModelSection,
                            NULL,
                            2,
                            lppszPnpID );

        CoTaskMemFree( lpszModelSection );
    }

    SetupCloseInfFile( hInf );

    return hr;
}

HRESULT HrGetMediaRootDir (LPWSTR lpszInfFile,
                           LPWSTR *lppszMediaRoot)
{
    HINF    hInf;
    HRESULT hr;

    *lppszMediaRoot = NULL;

    hInf = SetupOpenInfFileW( lpszInfFile,
                              NULL,
                              INF_STYLE_WIN4,
                              NULL );

    if ( hInf == INVALID_HANDLE_VALUE )
    {

        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Contained within the protocol INF should be a [InfSourcePathInfo]
    // section with the following entry:
    //
    //     OriginalInfSourcePath = %1%
    //
    // If we retrieve the value (i.e., field 1) of this line, we'll get the
    // full path where the INF originally came from.
    //

    hr = HrGetKeyValue( hInf,
                        c_szInfSourcePathInfo,
                        c_szOriginalInfSourcePath,
                        1,
                        lppszMediaRoot );

    SetupCloseInfFile( hInf );

    return hr;
}

HRESULT HrGetKeyValue (HINF hInf,
                       LPCWSTR lpszSection,
                       LPCWSTR lpszKey,
                       DWORD  dwIndex,
                       LPWSTR *lppszValue)
{
    INFCONTEXT  infCtx;
    DWORD       dwSizeNeeded;
    HRESULT     hr;

    *lppszValue = NULL;

    if ( SetupFindFirstLineW(hInf,
                             lpszSection,
                             lpszKey,
                             &infCtx) == FALSE )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    SetupGetStringFieldW( &infCtx,
                          dwIndex,
                          NULL,
                          0,
                          &dwSizeNeeded );

    *lppszValue = (LPWSTR)CoTaskMemAlloc( sizeof(WCHAR) * dwSizeNeeded );

    if ( !*lppszValue  )
    {
       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if ( SetupGetStringFieldW(&infCtx,
                              dwIndex,
                              *lppszValue,
                              dwSizeNeeded,
                              NULL) == FALSE )
    {

        hr = HRESULT_FROM_WIN32(GetLastError());

        CoTaskMemFree( *lppszValue );
        *lppszValue = NULL;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\muxim\adapter.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       A D A P T E R . C P P
//
//  Contents:   Physical adapter class definition.
//
//  Notes:
//
//  Author:     Alok Sinha
//
//----------------------------------------------------------------------------

#include "adapter.h"
#include "common.h"

#ifdef  CUSTOM_EVENTS
#include "public.h"
#endif

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::CMuxPhysicalAdapter
//
// Purpose:   Constructor for class CMuxPhysicalAdapter
//
// Arguments: None
//
// Returns:
//
// Notes:
//

CMuxPhysicalAdapter::CMuxPhysicalAdapter (INetCfg *pnc,
                                          GUID *pguidAdapter)
{

    TraceMsg( L"-->CMuxPhysicalAdapter::CMuxPhysicalAdapter(Constructor).\n" );

    m_pnc = pnc;
    m_pnc->AddRef();

    CopyMemory( &m_guidAdapter,
                pguidAdapter,
                sizeof(GUID) );

    TraceMsg( L"<--CMuxPhysicalAdapter::CMuxPhysicalAdapter(Constructor).\n" );
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::~CMuxPhysicalAdapter
//
// Purpose:   Destructor for class CMuxPhysicalAdapter
//
// Arguments: None
//
// Returns:
//
// Notes:
//

CMuxPhysicalAdapter::~CMuxPhysicalAdapter (VOID)
{
    CMuxVirtualMiniport  *pMiniport;
    DWORD                dwMiniportCount;
    DWORD                i;


    TraceMsg( L"-->CMuxPhysicalAdapter::~CMuxPhysicalAdapter(Destructor).\n" );

    //
    // Delete all the instances representing the virtual miniports.
    // We are only deleting the class instances, not uninstalling the
    // the virtual miniports.
    //

    dwMiniportCount = m_MiniportList.ListCount();

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportList.Remove( &pMiniport );
        delete pMiniport;
    }

    dwMiniportCount = m_MiniportsToAdd.ListCount();

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportsToAdd.Remove( &pMiniport );
        delete pMiniport;
    }

    dwMiniportCount = m_MiniportsToRemove.ListCount();

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportsToRemove.Remove( &pMiniport );
        delete pMiniport;
    }

    ReleaseObj( m_pnc );

    TraceMsg( L"<--CMuxPhysicalAdapter::~CMuxPhysicalAdapter(Destructor).\n" );

}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::LoadConfiguration
//
// Purpose:   Read the registry to get the device IDs of the 
//            virtual miniports installed on the adapter and
//            crate an instance to represent each virtual miniport.
//
// Arguments: None
//
// Returns: S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxPhysicalAdapter::LoadConfiguration (VOID)
{
    HKEY                    hkeyAdapterGuid;
    WCHAR                   szAdapterGuidKey[MAX_PATH+1];
    WCHAR                   szAdapterGuid[MAX_PATH+1];
    LPWSTR                  lpMiniportList;
    LPWSTR                  lpMiniport;
    LPWSTR                  lpMiniportGuid;
    DWORD                   dwDisp;
    CMuxVirtualMiniport     *pMiniport;
    GUID                    guidMiniport;
    DWORD                   dwBytes;
    LONG                    lResult;

    TraceMsg( L"-->CMuxPhysicalAdapter::LoadConfiguration.\n" );

    //
    // Build the registry key using the adapter guid under which 
    // device IDs of the virtual miniports are stored.
    //

    StringFromGUID2( m_guidAdapter,
                    szAdapterGuid,
                    MAX_PATH+1 );

    swprintf( szAdapterGuidKey,
              L"%s\\%s",
              c_szAdapterList,
              szAdapterGuid );

    lResult = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
                                szAdapterGuidKey,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hkeyAdapterGuid,
                                &dwDisp);

    if ( lResult == ERROR_SUCCESS ) {

        //
        // If dwDisp indicates that a new key is created then, we know there
        // is no virtual miniport currently listed underneath and we simply
        // return.
        //

        if ( dwDisp != REG_CREATED_NEW_KEY ) {

            dwBytes = 0;
            lResult =  RegQueryValueExW(
                                        hkeyAdapterGuid,
                                        c_szUpperBindings,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &dwBytes );

            lpMiniportList = (LPWSTR)calloc( dwBytes, 1 );

            if ( lpMiniportList ) {

                lResult =  RegQueryValueExW(
                                    hkeyAdapterGuid,
                                    c_szUpperBindings,
                                    NULL,
                                    NULL,
                                    (LPBYTE)lpMiniportList,
                                    &dwBytes );

                if ( lResult == ERROR_SUCCESS ) {

                    lpMiniport = lpMiniportList;

#ifndef PASSTHRU_NOTIFY

                    //
                    // In case of mux, c_szUpperBindings is a multi_sz string.
                    //

                    while ( wcslen(lpMiniport) ) {

                        lpMiniportGuid = RemoveDevicePrefix( lpMiniport );

                        TraceMsg( L"   Loading configuration for miniport %s...\n",
                        lpMiniportGuid );

                        if ( lpMiniportGuid ) {

                            CLSIDFromString( lpMiniportGuid,
                                             &guidMiniport );
         
                            //
                            // Create an instance representing the virtual miniport.
                            //

                            pMiniport = new CMuxVirtualMiniport( m_pnc,
                                                                 &guidMiniport,
                                                                 &m_guidAdapter );

                            if ( pMiniport ) {

                                //
                                // Load any miniport specific configuration.
                                //

                                pMiniport->LoadConfiguration();

                                //
                                // Save the miniport instance in a list.
                                //

                                m_MiniportList.Insert( pMiniport,
                                                       guidMiniport );

                            }

                            free( lpMiniportGuid );
                        }

                        //
                        // Get next miniport guid.
                        //

                        lpMiniport += wcslen(lpMiniport) + 1;
                    }

#else

                    //
                    // In case of the passthru driver, c_szUpperBindings is
                    // a reg_sz string.
                    //

                    lpMiniportGuid = RemoveDevicePrefix( lpMiniport );

                    TraceMsg( L"   Loading configuration for miniport %s...\n",
                              lpMiniportGuid );

                    if ( lpMiniportGuid ) {

                        CLSIDFromString( lpMiniportGuid,
                                         &guidMiniport );

                        //
                        // Create an instance representing the virtual miniport.
                        //

                        pMiniport = new CMuxVirtualMiniport( m_pnc,
                                                             &guidMiniport,
                                                             &m_guidAdapter );

                        if ( pMiniport ) {

                            //
                            // Load any miniport specific configuration.
                            //

                            pMiniport->LoadConfiguration();

                            //
                            // Save the miniport instance in a list.
                            //

                            m_MiniportList.Insert( pMiniport,
                                                   guidMiniport );
                        }

                        free( lpMiniportGuid );
                    }
#endif
                }
                else {
                    TraceMsg( L"   Failed to read the registry value: %s.\n",
                              c_szUpperBindings );
                }

                free( lpMiniportList );
            }
            else {
                lResult = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        RegCloseKey( hkeyAdapterGuid );
    }
    else {

        TraceMsg( L"   Failed to open the registry key: %s.\n",
                  szAdapterGuidKey );
    }

    TraceMsg( L"<--CMuxPhysicalAdapter::LoadConfiguration(HRESULT = %x).\n",
              HRESULT_FROM_WIN32(lResult) );

    return HRESULT_FROM_WIN32(lResult);
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::GetAdapterGUID
//
// Purpose:   Returns the adapter GUID.
//
// Arguments:
//          OUT pguidAdapter:  GUID of the adapter returned.
//
// Returns: None.
//
// Notes:
//

VOID CMuxPhysicalAdapter::GetAdapterGUID (GUID *pguidAdapter)
{
    TraceMsg( L"-->CMuxPhysicalAdapter::GetAdapterGUID.\n" );

    CopyMemory( pguidAdapter,
                &m_guidAdapter,
                sizeof(GUID) );

    TraceMsg( L"<--CMuxPhysicalAdapter::GetAdapterGUID.\n" );
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::AddMiniport
//
// Purpose:   Puts the miniport instance into the list of newly added miniports.
//
// Arguments:
//          IN pMiniport:  A newly create miniport instance.
//
// Returns: S_OK on success, otherwize and error code.
//
// Notes:
//

HRESULT CMuxPhysicalAdapter::AddMiniport (CMuxVirtualMiniport *pMiniport)
{
    GUID    guidMiniport;
    HRESULT hr;

    TraceMsg( L"-->CMuxPhysicalAdapter::AddMiniport.\n" );

    pMiniport->GetMiniportGUID( &guidMiniport );

    hr = m_MiniportsToAdd.Insert( pMiniport,
                                  guidMiniport );

    TraceMsg( L"<--CMuxPhysicalAdapter::AddMiniport(HRESULT = %x).\n",
              hr );

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::RemoveMiniport
//
// Purpose:   Remove a specified miniport instance from the list and
//            uninstalls the corresponding virtual miniport.
//
// Arguments:
//          IN pguidMiniportToRemove: GUID of the miniport to be removed
//                                    and uninstalled. If it is NULL then,
//                                    the first miniport instance is removed.
//
// Returns: S_OK on success, otherwize and error code.
//
// Notes:
//

HRESULT CMuxPhysicalAdapter::RemoveMiniport (GUID *pguidMiniportToRemove)
{
    CMuxVirtualMiniport  *pMiniport;
    GUID                 guidMiniport;
    HRESULT              hr;

    TraceMsg( L"-->CMuxPhysicalAdapter::RemoveMiniport.\n" );

    //
    // If miniport GUID specified then, delete that one.
    //

    if ( pguidMiniportToRemove ) {

        hr = m_MiniportList.RemoveByKey( *pguidMiniportToRemove,
                                      &pMiniport );
    }
    else {

        //
        // No GUID specified, so we just delete the first one.
        //

        hr = m_MiniportList.Remove( &pMiniport );
    }

    if ( hr == S_OK ) {

        pMiniport->GetMiniportGUID( &guidMiniport );

        m_MiniportsToRemove.Insert( pMiniport,
                                    guidMiniport );
        pMiniport->DeInstall();
    }

    TraceMsg( L"<--CMuxPhysicalAdapter::RemoveMiniport(HRESULT = %x).\n",
              hr );

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::Remove
//
// Purpose:   Uninstall all the instances of virtual miniports.
//
// Arguments: None
//
// Returns: S_OK.
//
// Notes:
//

HRESULT CMuxPhysicalAdapter::Remove (VOID)
{
    CMuxVirtualMiniport  *pMiniport;
    GUID                    guidMiniport;
    DWORD                   dwMiniportCount;
    DWORD                   i;

    TraceMsg( L"-->CMuxPhysicalAdapter::Remove.\n" );

    dwMiniportCount = m_MiniportList.ListCount();

    TraceMsg ( L"   Removing %d miniports.\n",
               dwMiniportCount );

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportList.Remove( &pMiniport );
        pMiniport->GetMiniportGUID( &guidMiniport );
        m_MiniportsToRemove.Insert( pMiniport,
                                    guidMiniport );
        pMiniport->DeInstall();
    }

    TraceMsg( L"<--CMuxPhysicalAdapter::Remove(HRESULT = %x).\n",
              S_OK );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::ApplyRegistryChanges
//
// Purpose:   Update the registry depending on the actions performed.
//
// Arguments:
//          IN eApplyAction:  Action that was last performed.
//                            
//
// Returns: S_OK.
//
// Notes:
//        More than one action could have been performed by the user
//        but this function is called only once at the end. So, the argument
//        only denotes the very last action performed. For example, if the 
//        user deletes one miniport and adds two miniports then, the argument
//        will denote an add action.
//

HRESULT CMuxPhysicalAdapter::ApplyRegistryChanges (ConfigAction eApplyAction)
{
    HKEY                    hkeyAdapterList;
    HKEY                    hkeyAdapterGuid;
    WCHAR                   szAdapterGuid[MAX_PATH+1];
    CMuxVirtualMiniport     *pMiniport = NULL;
    DWORD                   dwMiniportCount;
    DWORD                   dwDisp;
    DWORD                   i;
    LONG                    lResult;
    HRESULT                 hr;


    TraceMsg( L"-->CMuxPhysicalAdapter::ApplyRegistryChanges.\n" );

    //
    // Open/create and then close the registry key to ensure that it does exist.
    //

    StringFromGUID2( m_guidAdapter,
                     szAdapterGuid,
                     MAX_PATH+1 );

    lResult = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
                               c_szAdapterList,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hkeyAdapterList,
                               &dwDisp);


    if ( lResult == ERROR_SUCCESS ) {

        lResult = RegCreateKeyExW( hkeyAdapterList,
                                   szAdapterGuid,
                                   0,
                                   NULL,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hkeyAdapterGuid,
                                   &dwDisp);

        if ( lResult == ERROR_SUCCESS ) {

            RegCloseKey( hkeyAdapterGuid );
        }
        else {
            TraceMsg( L"   Failed to create/open the registry key: %s\\%s.\n",
                      c_szAdapterList, szAdapterGuid );
        }

        RegCloseKey( hkeyAdapterList );
    }
    else {

        TraceMsg( L"   Failed to open the registry key: %s.\n",
                  c_szAdapterList );
    }

    //
    // Update the registry in case there were new miniports installed.
    //

    hr = HRESULT_FROM_WIN32( lResult );

    dwMiniportCount = m_MiniportsToAdd.ListCount();

    TraceMsg( L"   Applying registry changes when %d miniports added.\n",
              dwMiniportCount );

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportsToAdd.Find( i,
                               &pMiniport );

        //
        // Do virtual miniport specific registry changes.
        //
        // We need to tell the miniport instance explicitly what the action
        // is.
        //

        hr = pMiniport->ApplyRegistryChanges( eActAdd );

        if ( hr != S_OK ) {

            TraceMsg( L"   Failed to apply registry changes to miniport(%d).\n",
                      i );

        }
    }



    //
    // Update the registry in case one or more miniports were uninstalled.
    //

    dwMiniportCount = m_MiniportsToRemove.ListCount();

    TraceMsg( L"   Applying registry changes when %d miniports removed.\n",
              dwMiniportCount );

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportsToRemove.Find( i,
                                  &pMiniport );

        //
        // Do virtual miniport specific registry changes.
        //
        // We need to tell the miniport instance explicitly what the action
        // is.
        //

        hr = pMiniport->ApplyRegistryChanges( eActRemove );

        if ( hr != S_OK ) {

            TraceMsg( L"   Failed to apply registry changes to miniport(%d).\n",
                      i );

        }
    }

    //
    // If the adapter is being removed or the protocol is being uninstalled,
    // delete the adatper registry key.
    //

    if ( eApplyAction == eActRemove ) {

        //
        // Delete the adapter key.
        //

        lResult = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
                                   c_szAdapterList,
                                   0,
                                   NULL,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hkeyAdapterList,
                                   &dwDisp);

        if ( lResult == ERROR_SUCCESS ) {

            TraceMsg( L"   Deleting the registry key: %s.\n", szAdapterGuid );

            RegDeleteKeyW( hkeyAdapterList,
                           szAdapterGuid );
        }
    }

    TraceMsg( L"<--CMuxPhysicalAdapter::ApplyRegistryChanges(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::ApplyPnpChanges
//
// Purpose:   Apply the PnP changes depending on the actions performed.
//
// Arguments:
//          IN pfCallback  :  SendPnpConfig Callback interface.
//          IN eApplyAction:  Action that was last performed.
//                            
//
// Returns: S_OK.
//
// Notes:
//        More than one action could have been performed by the user
//        but this function is called only once at the end. So, the argument
//        only denotes the very last action performed. For example, if the 
//        user deletes one miniport and adds two miniports then, the argument
//        will denote an add action.
//

HRESULT CMuxPhysicalAdapter::ApplyPnpChanges(
                    INetCfgPnpReconfigCallback *pfCallback,
                    ConfigAction eApplyAction)
{
    CMuxVirtualMiniport     *pMiniport;
    GUID                    guidMiniport;
    WCHAR                   szMiniportGuid[MAX_PATH+1];
    LPWSTR                  lpDevice;
    DWORD                   dwMiniportCount;
    DWORD                   i;
    DWORD                   dwBytes;
    INetCfgComponent        *pncc;
    HRESULT                 hr;

#ifdef CUSTOM_EVENTS    
    LPWSTR                  lpszBindName;
    PNOTIFY_CUSTOM_EVENT       lppnpEvent;
#endif

    TraceMsg( L"-->CMuxPhysicalAdapter::ApplyPnpChanges.\n" );

#ifdef CUSTOM_EVENTS    

    //
    // Find the instance of the adapter to get its bindname.
    //

    hr = HrFindInstance( m_pnc,
                         m_guidAdapter,
                         &pncc );

    if ( hr == S_OK ) {

        hr = pncc->GetBindName( &lpszBindName );

        if ( hr != S_OK ) {
            TraceMsg( L"  GetBindName failed.(HRESULT = %x). PnP changes will not "
                      L"be applied and the driver will not be notified.\n",
                      hr );
        }

        ReleaseObj( pncc );
    }
    else {
        TraceMsg( L"  PnP changes will not "
               L"be applied and the driver will not be notified.\n",
               hr );
    }

#endif    

    dwMiniportCount = m_MiniportsToAdd.ListCount();

    TraceMsg( L"   Applying PnP changes to %d new miniports.\n",
            dwMiniportCount );

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportsToAdd.Remove( &pMiniport );

        pMiniport->GetMiniportGUID( &guidMiniport );

        m_MiniportList.Insert( pMiniport,
                               guidMiniport );

        //
        // Do miniport specific Pnp Changes when they are added.
        //

        hr = pMiniport->ApplyPnpChanges( pfCallback,
                                         eActAdd );

#ifdef CUSTOM_EVENTS


        //
        // Notify the driver that one or more virtual miniports have been added.
        //

        StringFromGUID2( guidMiniport,
                         szMiniportGuid,
                         MAX_PATH+1 );
        lpDevice = AddDevicePrefix( szMiniportGuid );

        if ( lpDevice ) {

            dwBytes = sizeof(NOTIFY_CUSTOM_EVENT) +
                      ((wcslen(lpDevice) + 1) * sizeof(WCHAR));

            lppnpEvent = (PNOTIFY_CUSTOM_EVENT)malloc( dwBytes );

            if ( lppnpEvent ) {

                lppnpEvent->uSignature = NOTIFY_SIGNATURE;
                lppnpEvent->uEvent = MUX_CUSTOM_EVENT;
                wcscpy( lppnpEvent->szMiniport,
                       lpDevice );

                hr = pfCallback->SendPnpReconfig( NCRL_NDIS,
                                                 c_szMuxService,
                                                 lpszBindName,
                                                 (PVOID)lppnpEvent,
                                                 dwBytes );

                TraceMsg( L"   INetCfgPnpReconfigCallback->SendPnpReconfig returned "
                         L"%#x.\n",
                         hr );

                if ( hr != S_OK ) {

                  TraceMsg( L"   Failed to apply Pnp changes, miniport(%d).\n",
                            i );

                }

                free( lppnpEvent );
            }
            free( lpDevice );
        }
#endif        
    }

    dwMiniportCount = m_MiniportsToRemove.ListCount();

    TraceMsg( L"   Applying PnP changes to %d removed miniports.\n",
            dwMiniportCount );

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportsToRemove.Remove( &pMiniport );

        pMiniport->GetMiniportGUID( &guidMiniport );

        //
        // Do miniport specific Pnp Changes when they are uninstalled.
        //

        hr = pMiniport->ApplyPnpChanges( pfCallback,
                                         eActRemove );

        delete pMiniport;

#ifdef CUSTOM_EVENTS

        //
        // Notify the driver that one or more virtual miniports have been
        // uninstalled.
        //
        // We can't notify the driver in case the adapter or the protocol is
        // being uninstalled because the binding handle doesn't exist.
        //

        if ( eApplyAction != eActRemove ) {

            StringFromGUID2( guidMiniport,
                             szMiniportGuid,
                             MAX_PATH+1 );
            lpDevice = AddDevicePrefix( szMiniportGuid );

            if ( lpDevice ) {

                dwBytes = sizeof(NOTIFY_CUSTOM_EVENT) +
                         ((wcslen(lpDevice) + 1) * sizeof(WCHAR));

                lppnpEvent = (PNOTIFY_CUSTOM_EVENT)malloc( dwBytes );

                if ( lppnpEvent ) {

                    lppnpEvent->uSignature = NOTIFY_SIGNATURE;
                    lppnpEvent->uEvent = MUX_CUSTOM_EVENT;
                    wcscpy( lppnpEvent->szMiniport,
                          lpDevice );

                    hr = pfCallback->SendPnpReconfig( NCRL_NDIS,
                                                    c_szMuxService,
                                                    lpszBindName,
                                                    (PVOID)lppnpEvent,
                                                    dwBytes );
                    TraceMsg( L"   INetCfgPnpReconfigCallback->SendPnpReconfig returned "
                            L"%#x.\n",
                            hr );

                    if ( hr != S_OK ) {

                        TraceMsg( L"   Failed to apply Pnp changes, miniport(%d).\n",
                               i );

                    }

                    free( lppnpEvent );
                }

                free( lpDevice );
            }
        }
#endif         

    }

#ifdef CUSTOM_EVENTS    
    CoTaskMemFree( lpszBindName );
#endif

    TraceMsg( L"<--CMuxPhysicalAdapter::ApplyPnpChanges(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::CancelChanges
//
// Purpose:   Cancel any changes made.
//
// Arguments: None
//                            
//
// Returns: S_OK.
//
// Notes:
//

HRESULT CMuxPhysicalAdapter::CancelChanges (VOID)
{
    TraceMsg( L"-->CMuxPhysicalAdapter::CancelChanges.\n" );

    TraceMsg( L"<--CMuxPhysicalAdapter::CancelChanges(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::AllMiniportsRemoved
//
// Purpose:   Find out if there is no miniport installed on the adapter.
//
// Arguments: None
//                            
//
// Returns: TRUE if all the miniports associated with this adapter have been
//          uninstalled and there is none pending to be added, otherwise FALSE.
//
// Notes:
//

BOOL  CMuxPhysicalAdapter::AllMiniportsRemoved (VOID)
{
  return (m_MiniportList.ListCount() + m_MiniportsToAdd.ListCount()) == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\muxim\adapter.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       A D A P T E R . H
//
//  Contents:   Header file for physical adapter class.
//
//  Notes:
//
//  Author:     Alok Sinha 31-Oct-2000
//
//----------------------------------------------------------------------------

#ifndef ADAPTER_H_INCLUDED

#define ADAPTER_H_INCLUDED

#include <windows.h>
#include <netcfgn.h>

#include "common.h"
#include "virtual.h"
#include "list.h"

//
// Class to represent a physical adapter.
//

class CMuxPhysicalAdapter
{
    //
    // Private member variables.
    //

    GUID    m_guidAdapter;

    INetCfg *m_pnc;

    //
    // List of virtual miniports associated with the adapter.
    //

    List<CMuxVirtualMiniport *, GUID> m_MiniportList;

    //
    // List of virtual miniports to be added.
    //

    List<CMuxVirtualMiniport *, GUID> m_MiniportsToAdd;

    //
    // List of virtual miniports to be removed.
    //

    List<CMuxVirtualMiniport *, GUID> m_MiniportsToRemove;

    //
    // Private member functions.
    //

  public:

    //
    // Public member functions
    //

    CMuxPhysicalAdapter (INetCfg *pnc,
                         GUID *guidAdapter);

    virtual ~CMuxPhysicalAdapter (VOID);

    HRESULT LoadConfiguration (VOID);

    VOID    GetAdapterGUID (GUID *guidAdapter);

    HRESULT AddMiniport (CMuxVirtualMiniport *pNewMiniport);

    HRESULT RemoveMiniport (GUID *pguidMiniport);

    HRESULT Remove (VOID);

    HRESULT ApplyRegistryChanges (ConfigAction eApplyAction);

    HRESULT ApplyPnpChanges (INetCfgPnpReconfigCallback *pfCallback,
                             ConfigAction eApplyAction);

    HRESULT CancelChanges (VOID);

    DWORD MiniportCount (VOID) { return m_MiniportList.ListCount(); }

    BOOL  AllMiniportsRemoved (VOID);
};


#endif // ADAPTER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\muxim\common.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       COMMON.CPP
//
//  Contents:   Debug & Utility functions
//
//  Notes:
//
//  Author:     Alok Sinha
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <netcfgn.h>
#include "common.h"

#ifdef DBG

void TraceMsg (LPWSTR szFormat, ...)
{
    static WCHAR szTempBuf[4096];

    va_list arglist;

    va_start(arglist, szFormat);

    vswprintf( szTempBuf, szFormat, arglist );

    OutputDebugStringW( szTempBuf );

    va_end(arglist);
}

void DumpChangeFlag (DWORD dwChangeFlag)
{
    TraceMsg( L"   ChangeFlag:" );

    if ( dwChangeFlag & NCN_ADD ) {
        TraceMsg( L" NCN_ADD" );
    }

    if ( dwChangeFlag & NCN_REMOVE ) {
        TraceMsg( L" NCN_REMOVE" );
    }

    if ( dwChangeFlag & NCN_UPDATE ) {
        TraceMsg( L" NCN_UPDATE" );
    }

    if ( dwChangeFlag & NCN_ENABLE ) {
        TraceMsg( L" NCN_ENABLE" );
    }

    if ( dwChangeFlag & NCN_DISABLE ) {
        TraceMsg( L" NCN_DISABLE" );
    }

    if ( dwChangeFlag & NCN_BINDING_PATH ) {
        TraceMsg( L" NCN_BINDING_PATH" );
    }

    if ( dwChangeFlag & NCN_PROPERTYCHANGE ) {
        TraceMsg( L" NCN_PROPERTYCHANGE" );
    }

    if ( dwChangeFlag & NCN_NET ) {
        TraceMsg( L" NCN_NET" );
    }

    if ( dwChangeFlag & NCN_NETTRANS ) {
        TraceMsg( L" NCN_NETTRANS" );
    }

    if ( dwChangeFlag & NCN_NETCLIENT ) {
        TraceMsg( L" NCN_NETCLIENT" );
    }

    if ( dwChangeFlag & NCN_NETSERVICE ) {
        TraceMsg( L" NCN_NETSERVICE" );
    }

    TraceMsg( L"\n" );
    return;
}

void DumpBindingPath (INetCfgBindingPath *pncbp)
{
    INetCfgComponent             *pncc;
    IEnumNetCfgBindingInterface  *pencbi;
    INetCfgBindingInterface      *pncbi;
    LPWSTR                       lpsz;
    DWORD                        dwIndex;
    ULONG                        ulCount;
    HRESULT                      hr;

    hr = pncbp->GetPathToken( &lpsz );

    if ( hr == S_OK ) {

        TraceMsg( L"   BindingPath: %s\n",
               lpsz );

        CoTaskMemFree( lpsz );
    }
    else {

    TraceMsg( L"   BindingPath: GetPathToken failed(HRESULT %x).\n",
           hr );
    }

#ifdef VERBOSE_TRACE

    hr = pncbp->EnumBindingInterfaces( &pencbi );

    if ( hr == S_OK ) {

        hr = pencbi ->Next( 1, &pncbi, &ulCount );

        for (dwIndex=0; hr == S_OK; dwIndex++ ) {

            hr = pncbi->GetName( &lpsz );

            if ( hr == S_OK ) {

               TraceMsg( L"   BindingInterface(%d): %s\n",
                         dwIndex, lpsz );

               CoTaskMemFree( lpsz );
            }
            else {

               TraceMsg( L"   BindingInterface(%d): GetName failed(HRESULT %x).\n",
                         dwIndex, hr );
            }

            hr = pncbi->GetUpperComponent( &pncc );

            if ( hr == S_OK ) {

                TraceMsg( L"   \tUpperComponent of the interface(%d)...\n",
                         dwIndex );

                DumpComponent( pncc );

                ReleaseObj( pncc );
            }
            else {

                TraceMsg( L"   UpperComponent: GetUpperComponent failed(HRESULT = %x).\n",
                         hr );
            }
            hr = pncbi->GetLowerComponent( &pncc );

            if ( hr == S_OK ) {

                TraceMsg( L"   \tLowerComponent of the interface(%d)...\n",
                         dwIndex );
                DumpComponent( pncc );

                ReleaseObj( pncc );
            }
            else {

                TraceMsg( L"   LowerComponent: GetLowerComponent failed(HRESULT = %x).\n",
                         hr );
            }

            ReleaseObj( pncbi );

            hr = pencbi ->Next( 1,
                                     &pncbi,
                                     &ulCount );
        }

        ReleaseObj( pencbi );
    }
    else {

        TraceMsg( L"   EnumBindingInterfaces failed, (HRESULT = %x)\n",
                  hr ); 
    }
#endif 
    return;
}

void DumpComponent (INetCfgComponent *pncc)
{
    LPWSTR  lpsz;
    DWORD   dwChars;
    ULONG   ulStatus;
    HRESULT hr;

    hr = pncc->GetDisplayName( &lpsz );

    if ( hr == S_OK ) {

        TraceMsg( L"   \t\tComponent: %s\n",
               lpsz );

        CoTaskMemFree( lpsz );
    }
    else {

        TraceMsg( L"   GetDisplay failed(HRESULT %x).\n",
               hr );
    }

    hr = pncc->GetCharacteristics( &dwChars );

    if ( hr == S_OK ) {

        TraceMsg( L"   \t\tCharacteristics:" );

        if ( dwChars & NCF_HIDDEN ) {
           TraceMsg( L" NCF_HIDDEN" );
        }

        if ( dwChars & NCF_NO_SERVICE ) {
           TraceMsg( L" NCF_NO_SERVICE" );
        }

        if ( dwChars & NCF_VIRTUAL ) {
           TraceMsg( L" NCF_VIRTUAL" );
        }

        if ( dwChars & NCF_PHYSICAL ) {
           TraceMsg( L" NCF_PHYSICAL" );
        }

        if ( dwChars & NCF_FILTER ) {
           TraceMsg( L" NCF_FILTER" );
        }

        if ( dwChars & NCF_NOT_USER_REMOVABLE ) {
           TraceMsg( L" NCF_NOT_USER_REMOVABLE" );
        }

        if ( dwChars & NCF_HAS_UI ) {
           TraceMsg( L" NCF_HAS_UI" );
        }

        if ( dwChars & NCF_SOFTWARE_ENUMERATED ) {
           TraceMsg( L" NCF_SOFTWARE_ENUMERATED" );
        }

        if ( dwChars & NCF_MULTIPORT_INSTANCED_ADAPTER ) {
           TraceMsg( L" NCF_MULTIPORT_INSTANCED_ADAPTER" );
        }

        TraceMsg( L"\n" );
    }
    else {

        TraceMsg( L"   GetCharacteristics failed(HRESULT %x).\n",
               hr );
    }

    hr = pncc->GetId( &lpsz );

    if ( hr == S_OK ) {

        TraceMsg( L"   \t\tHardware Id: %s\n",
               lpsz );

        CoTaskMemFree( lpsz );
    }
    else {

        TraceMsg( L"   GetId failed(HRESULT %x).\n",
               hr );
    }

    hr = pncc->GetBindName( &lpsz );

    if ( hr == S_OK ) {

        TraceMsg( L"   \t\tBindName: %s\n",
               lpsz );

        CoTaskMemFree( lpsz );
    }
    else {

        TraceMsg( L"   GetBindName failed(HRESULT %x).\n",
               hr );
    }

    if ( dwChars & NCF_PHYSICAL ) {
        hr = pncc->GetDeviceStatus( &ulStatus );

        if ( hr == S_OK ) {

            TraceMsg( L"   \t\tDeviceStatus: %#x\n",
                      ulStatus );
        }
        else {

            TraceMsg( L"   GetDeviceStatus failed(HRESULT %x).\n",
                      hr );
        }
    }

  return;
}

#endif

HRESULT HrFindInstance (INetCfg *pnc,
                        GUID &guidInstance,
                        INetCfgComponent **ppnccMiniport)
{
    IEnumNetCfgComponent  *pencc;
    INetCfgComponent      *pncc;
    GUID                  guid;
    WCHAR                 szGuid[MAX_PATH+1];
    ULONG                 ulCount;
    BOOL                  found;
    HRESULT               hr;

    TraceMsg( L"-->HrFindInstance.\n" );

    hr = pnc->EnumComponents( &GUID_DEVCLASS_NET,
                            &pencc );

    if ( hr == S_OK ) {

        StringFromGUID2( guidInstance,
                      szGuid,
                      MAX_PATH+1 );

        TraceMsg( L"  Looking for component with InstanceGuid %s\n",
               szGuid );

        hr = pencc->Next( 1,
                          &pncc,
                          &ulCount );

        for ( found=FALSE; (hr == S_OK) && (found == FALSE); ) {

            hr = pncc->GetInstanceGuid( &guid );

            if ( hr == S_OK ) {

                StringFromGUID2( guid,
                                szGuid,
                                MAX_PATH+1 );

                TraceMsg( L"  Found component with InstanceGuid %s\n",
                         szGuid );

                found = IsEqualGUID( guid,
                                    guidInstance );

                if ( found == FALSE ) {

                    ReleaseObj( pncc );

                    hr = pencc->Next( 1,
                                    &pncc,
                                    &ulCount );
                }
                else {
                    *ppnccMiniport = pncc;
                }
            }
        }   

        ReleaseObj( pencc );
    }
    else {

     TraceMsg( L"   EnumComponents failed(HRESULT = %x).\n",
               hr );
    }

    TraceMsg( L"<--HrFindInstance(HRESULT = %x).\n",
            hr );

    return hr;
}

LONG AddToMultiSzValue( HKEY hkeyAdapterGuid,
                        LPWSTR szMiniportGuid)
{
    LPWSTR lpCurrentValue=NULL;
    LPWSTR lpNewValue=NULL;
    DWORD  dwLen;
    DWORD  dwNewLen;
    LONG   lResult;

    dwLen = 0;
    lResult =  RegQueryValueExW(
                        hkeyAdapterGuid,
                        c_szUpperBindings,
                        NULL,
                        NULL,
                        NULL,
                        &dwLen );

    if ( dwLen != 0 ) {
        lpCurrentValue = (LPWSTR)calloc( dwLen, 1 );

        if ( lpCurrentValue ) {

        lResult =  RegQueryValueExW( hkeyAdapterGuid,
                                     c_szUpperBindings,
                                     NULL,
                                     NULL,
                                     (LPBYTE)lpCurrentValue,
                                     &dwLen );

        }
        else {

            lResult = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else {
        dwLen = sizeof(WCHAR);
        lpCurrentValue = (LPWSTR)calloc( dwLen, 1 );

        if ( !lpCurrentValue ) {
            lResult = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            lResult = ERROR_SUCCESS;
        }
    }

    if ( lResult == ERROR_SUCCESS ) {

        dwNewLen = dwLen + ((wcslen(szMiniportGuid) + 1) * sizeof(WCHAR));

        lpNewValue = (LPWSTR)malloc( dwNewLen );

        if ( lpNewValue ) {

            wcscpy( lpNewValue, szMiniportGuid );

            CopyMemory( lpNewValue+wcslen(szMiniportGuid)+1,
                        lpCurrentValue,
                        dwLen );

            lResult = RegSetValueExW( hkeyAdapterGuid,
                                    c_szUpperBindings,
                                    0,
                                    REG_MULTI_SZ,
                                    (LPBYTE)lpNewValue,
                                    dwNewLen );
        }
        else {
            lResult = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( lpCurrentValue ) {
        free( lpCurrentValue );
    }

    if ( lpNewValue ) {
        free( lpNewValue );
    }

    return lResult;
}

LONG DeleteFromMultiSzValue( HKEY hkeyAdapterGuid,
                             LPWSTR szMiniportGuid)
{
    LPWSTR lpCurrentValue=NULL;
    LPWSTR lpNewValue=NULL;
    LPWSTR lpCurrentValueTemp;
    LPWSTR lpNewValueTemp;
    DWORD  dwLen;
    DWORD  dwNewLen;
    LONG   lResult;

    dwLen = 0;
    lResult =  RegQueryValueExW(
                        hkeyAdapterGuid,
                        c_szUpperBindings,
                        NULL,
                        NULL,
                        NULL,
                        &dwLen );

    if ( lResult == ERROR_SUCCESS ) {
        lpCurrentValue = (LPWSTR)calloc( dwLen, 1 );
        lpNewValue = (LPWSTR)calloc( dwLen, 1 );

        if ( lpCurrentValue && lpNewValue ) {

            lResult =  RegQueryValueExW(
                              hkeyAdapterGuid,
                              c_szUpperBindings,
                              NULL,
                              NULL,
                              (LPBYTE)lpCurrentValue,
                              &dwLen );

            if ( lResult == ERROR_SUCCESS ) {

                lpCurrentValueTemp = lpCurrentValue;
                lpNewValueTemp = lpNewValue;

                while( wcslen(lpCurrentValueTemp) ) {

                    if ( _wcsicmp(lpCurrentValueTemp, szMiniportGuid) ) {
                        wcscpy( lpNewValueTemp, lpCurrentValueTemp );
                        lpNewValueTemp += wcslen(lpNewValueTemp) + 1;
                    }

                    lpCurrentValueTemp += wcslen(lpCurrentValueTemp) + 1;
                } //end of while

                dwNewLen = dwLen - ((wcslen(szMiniportGuid) + 1) * sizeof(WCHAR));

                if ( dwNewLen > 2 ) {
                    lResult = RegSetValueExW( hkeyAdapterGuid,
                                          c_szUpperBindings,
                                          0,
                                          REG_MULTI_SZ,
                                          (LPBYTE)lpNewValue,
                                          dwNewLen );
                }
                else {
                    lResult = RegDeleteValueW( hkeyAdapterGuid,
                                               c_szUpperBindings );
                }
            }
        }
        else {
            lResult = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( lpCurrentValue ) {
        free( lpCurrentValue );
    }

    if ( lpNewValue ) {
        free( lpNewValue );
    }

    return lResult;
}

LPWSTR AddDevicePrefix (LPWSTR lpStr)
{
    LPWSTR lpNewStr;

    lpNewStr = (LPWSTR)malloc( (wcslen(lpStr) +
                              wcslen(c_szDevicePrefix) + 1) *
                                           sizeof(WCHAR) );
    if ( lpNewStr ) {

        wcscpy( lpNewStr, c_szDevicePrefix );
        wcscat( lpNewStr, lpStr );
    }

    return lpNewStr;
}

LPWSTR RemoveDevicePrefix (LPWSTR lpStr)
{
    int i;
    LPWSTR lpNewStr;
    LPWSTR lpTemp;

    lpTemp = wcsrchr( lpStr, '\\' );

    if ( lpTemp ) {

        lpNewStr = _wcsdup( lpTemp+1 );
    }
    else {
        lpNewStr = NULL;
    }

    return lpNewStr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\muxim\implinc.cpp ===
#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>

#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#include <initguid.h>
#include <devguid.h>

#ifdef SubclassWindow

#undef SubclassWindow

#endif

#include <atlwin.h>

#ifdef _ATL_STATIC_REGISTRY

#include <statreg.h>
#include <statreg.cpp>

#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>


//EXTERN_C const IID IID_INetLanConnectionUiInfo = {0xC08956A6,0x1CD3,0x11D1,{0xB1,0xC5,0x00,0x80,0x5F,0xC1,0x27,0x0E}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\muxim\common.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       C O M M O N. H
//
//  Contents:   Common macros and declarations for the sample notify object.
//
//  Notes:
//
//  Author:     Alok Sinha
//
//----------------------------------------------------------------------------


#ifndef COMMON_H_INCLUDED

#define COMMON_H_INCLUDED

#include <devguid.h>

enum ConfigAction {

    eActUnknown, 
    eActInstall, 
    eActAdd, 
    eActRemove,
    eActUpdate,
    eActPropertyUIAdd,
    eActPropertyUIRemove
};       

//
// PnP ID, also referred to as Hardware ID, of the protocol interface.
//

const WCHAR c_szMuxProtocol[] = L"ms_muxp";

//
// PnP ID, also referred to as Hardware ID, of the Miniport interface.
//

const WCHAR c_szMuxMiniport[] = L"ms_muxmp";

//
// Name of the service as specified in the inf file in AddService directive.
//

const WCHAR c_szMuxService[] = L"muxp";

//
// Path to the config string where the virtual miniport instance names
// are stored.
//

const WCHAR c_szAdapterList[] =
                  L"System\\CurrentControlSet\\Services\\muxp\\Parameters\\Adapters";

//
// Value name in the registry where miniport device id is stored.
//

const WCHAR c_szUpperBindings[] = L"UpperBindings";


const WCHAR c_szDevicePrefix[] = L"\\Device\\";

#define ReleaseObj( x )  if ( x ) \
                            ((IUnknown*)(x))->Release();


#if DBG
void TraceMsg (LPWSTR szFormat, ...);
void DumpChangeFlag (DWORD dwChangeFlag);
void DumpBindingPath (INetCfgBindingPath* pncbp);
void DumpComponent (INetCfgComponent *pncc);
#else
#define TraceMsg
#define DumpChangeFlag( x )
#define DumpBindingPath( x )
#define DumpComponent( x )
#endif

HRESULT HrFindInstance (INetCfg *pnc,
                        GUID &guidInstance,
                        INetCfgComponent **ppnccMiniport);

LONG AddToMultiSzValue( HKEY hkeyAdapterGuid,
                        LPWSTR szMiniportGuid);

LONG DeleteFromMultiSzValue( HKEY hkeyAdapterGuid,
                             LPWSTR szMiniportGuid);

LPWSTR AddDevicePrefix (LPWSTR lpStr);
LPWSTR RemoveDevicePrefix (LPWSTR lpStr);

#endif // COMMON_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\muxim\list.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       LIST . H
//
//  Contents:   
//
//  Notes: List manipulation functions.
//
//----------------------------------------------------------------------------

#ifndef LIST_H_INCLUDED

#define LIST_H_INCLUDED

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>


template<class X, class Y> class List { 
     struct Node {
        X    item;
        Y    key;
        Node *next;
     };

     Node  *m_head;
     DWORD m_dwNodeCount;

  public:

              List ();

      virtual ~List();

     HRESULT  Insert (X item,
                      Y key);

     HRESULT  Remove (X *item);

     HRESULT  RemoveThis (X item);

     HRESULT  RemoveByKey (Y key,
                           X *item);

     VOID     RemoveAll(VOID);

     HRESULT  Find (DWORD dwIndex,
                    X *item);

     HRESULT  FindByKey (Y key,
                         X *item);

     DWORD    ListCount (VOID);
};

template<class X, class Y> List<X, Y>::List ()
{
  m_head = NULL;
  m_dwNodeCount = 0;
}

template<class X, class Y> List<X, Y>::~List ()
{
  RemoveAll();
}

template<class X, class Y> HRESULT List<X, Y>::Insert (X item,
                                                       Y key)
{
  Node *pNewNode;

  pNewNode = new Node;

  if ( pNewNode ) {
     pNewNode->item = item;
     pNewNode->key = key;
     pNewNode->next = NULL;

     if ( m_dwNodeCount ) {
        pNewNode->next = m_head;
     }

     m_head = pNewNode;
     m_dwNodeCount++;
  }

  return ( pNewNode ) ? S_OK : HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
}

template<class X, class Y> HRESULT List<X, Y>::Remove (X *item)
{
  Node *temp;

  if ( m_dwNodeCount == 0 ) {
     return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
  }

  *item = m_head->item;
  temp = m_head;
  m_head = m_head->next;
  delete temp;
  m_dwNodeCount--;

  return S_OK;
}
  
template<class X, class Y> HRESULT List<X, Y>::RemoveThis (X item)
{
  Node *temp;
  Node *nodeToFind;

  if ( m_dwNodeCount == 0 ) {
     return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
  }

  if ( m_head->item == item ) {

     nodeToFind = m_head;
     m_head = m_head->next;
  }
  else {
     for (temp = m_head; temp->next && (temp->next->item != item); ) {
        temp = temp->next;
     }

     if ( temp->next ) {
        nodeToFind = temp->next;
        temp->next = temp->next->next;
     }
     else
        nodeToFind = NULL;
  }

  if ( nodeToFind ) {
     delete nodeToFind;
     m_dwNodeCount--;
     return S_OK;
  }
  else
     return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}

template<class X, class Y> HRESULT List<X, Y>::RemoveByKey (Y key,
                                                            X *item)
{
  Node *temp;
  Node *nodeToFind;

  if ( m_dwNodeCount == 0 ) {
     return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
  }

  if ( m_head->key == key ) {

     nodeToFind = m_head;
     m_head = m_head->next;
  }
  else {
     for (temp = m_head; temp->next && (temp->next->key != key); ) {
        temp = temp->next;
     }

     if ( temp->next ) {
        nodeToFind = temp->next;
        temp->next = temp->next->next;
     }
     else
        nodeToFind = NULL;
  }

  if ( nodeToFind ) {
     *item = nodeToFind->item;

     delete nodeToFind;
     m_dwNodeCount--;

     return S_OK;
  }
  else
     return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}

template<class X, class Y> VOID List<X, Y>::RemoveAll (VOID)
{
  Node *temp;

  for (; m_dwNodeCount; --m_dwNodeCount) {
     temp = m_head;
     m_head = m_head->next;
     delete temp;
  }

  return;
}

template<class X, class Y> HRESULT List<X, Y>::Find (DWORD dwIndex,
                                                     X *item)
{
  Node  *temp;
  DWORD i;

  if ( (m_dwNodeCount == 0) || (dwIndex > m_dwNodeCount) ) {

     return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
  }

  for (i=0, temp = m_head; i < dwIndex; ++i) {
     temp = temp->next;
  }

  *item = temp->item;
  return S_OK;
}

template<class X, class Y> HRESULT List<X, Y>::FindByKey (Y key,
                                                          X *item)
{
  Node *temp;

  for (temp = m_head; temp && (temp->key != key); )
     temp = temp->next;

  if ( temp ) {
     *item = temp->item;
     return S_OK;
  }
  else {
     return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
  }
}

template<class X, class Y> DWORD List<X, Y>::ListCount (VOID)
{
  return m_dwNodeCount;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\muxim\notify.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       N O T I F Y . H
//
//  Contents:   Header file for sample notify object.
//
//  Notes:
//
//  Author:     Alok Sinha
//
//----------------------------------------------------------------------------

#ifndef NOTIFY_H_INCLUDE

#define NOTIFY_H_INCLUDE

#include <windows.h>

#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#include <devguid.h>
#include <setupapi.h>

#include <notifyn.h>
#include "list.h"
#include "adapter.h"
#include "resource.h"
#include "common.h"


//
// CMuxNotify Object - Base class for the entire notify object
//


class CMuxNotify :

               //
               // Must inherit from CComObjectRoot(Ex) for reference count
               // management and default threading model.
               //
 
               public CComObjectRoot,

               //
               // Define the default class factory and aggregation model.
               //

               public CComCoClass<CMuxNotify, &CLSID_CMuxNotify>,

               //
               // Notify Object's interfaces.
               //

               public INetCfgComponentControl,
               public INetCfgComponentSetup,
               public INetCfgComponentPropertyUi,
               public INetCfgComponentNotifyBinding,
               public INetCfgComponentNotifyGlobal
{

   //
   // Public members.
   //

   public:

      //
      // Constructor
      //

      CMuxNotify(VOID);

      //
      // Destructors.
      //

      ~CMuxNotify(VOID);

      //
      // Notify Object's interfaces.
      //

      BEGIN_COM_MAP(CMuxNotify)
         COM_INTERFACE_ENTRY(INetCfgComponentControl)
         COM_INTERFACE_ENTRY(INetCfgComponentSetup)
         COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
         COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
         COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
      END_COM_MAP()

      //
      // Uncomment the the line below if you don't want your object to
      // support aggregation. The default is to support it
      //
      // DECLARE_NOT_AGGREGATABLE(CMuxNotify)
      //

      DECLARE_REGISTRY_RESOURCEID(IDR_REG_SAMPLE_NOTIFY)

      //
      // INetCfgComponentControl
      //

      STDMETHOD (Initialize) (
                   IN INetCfgComponent  *pIComp,
                   IN INetCfg           *pINetCfg,
                   IN BOOL              fInstalling);

      STDMETHOD (CancelChanges) ();

      STDMETHOD (ApplyRegistryChanges) ();

      STDMETHOD (ApplyPnpChanges) (
                   IN INetCfgPnpReconfigCallback* pICallback);

      //
      // INetCfgComponentSetup
      //

      STDMETHOD (Install) (
                   IN DWORD dwSetupFlags);

      STDMETHOD (Upgrade) (
                   IN DWORD dwSetupFlags,
                   IN DWORD dwUpgradeFromBuildNo);

      STDMETHOD (ReadAnswerFile) (
                   IN PCWSTR szAnswerFile,
                   IN PCWSTR szAnswerSections);

      STDMETHOD (Removing) ();

      //
      // INetCfgComponentPropertyUi
      //

        STDMETHOD (QueryPropertyUi) (
                   IN IUnknown* pUnk);

        STDMETHOD (SetContext) (
                   IN IUnknown* pUnk);

        STDMETHOD (MergePropPages) (
                   IN OUT DWORD* pdwDefPages,
                   OUT LPBYTE* pahpspPrivate,
                   OUT UINT* pcPrivate,
                   IN HWND hwndParent,
                   OUT PCWSTR* pszStartPage);

        STDMETHOD (ValidateProperties) (
                   HWND hwndSheet);

        STDMETHOD (CancelProperties) ();

        STDMETHOD (ApplyProperties) ();

      //
      // INetCfgNotifyBinding
      //

      STDMETHOD (QueryBindingPath) (
                   IN DWORD dwChangeFlag,
                   IN INetCfgBindingPath* pncbp);

      STDMETHOD (NotifyBindingPath) (
                   IN DWORD dwChangeFlag,
                   IN INetCfgBindingPath* pncbp);

      //
      // INetCfgNotifyGlobal
      //

      STDMETHOD (GetSupportedNotifications) (
                   OUT DWORD* pdwNotificationFlag );

      STDMETHOD (SysQueryBindingPath) (
                   IN DWORD dwChangeFlag,
                   IN INetCfgBindingPath* pncbp);

      STDMETHOD (SysNotifyBindingPath) (
                   IN DWORD dwChangeFlag,
                   IN INetCfgBindingPath* pncbp);
            
      STDMETHOD (SysNotifyComponent) (
                   IN DWORD dwChangeFlag,
                   IN INetCfgComponent* pncc);

  //
  // Private members.
  //

  private:

     //
     // Private member variables.
     //

     INetCfgComponent  *m_pncc;  // Protocol's Net Config component
     INetCfg           *m_pnc;
     ConfigAction      m_eApplyAction;
     IUnknown*         m_pUnkContext;

     //
     // List of physical adapters currently installed.
     //

     List<CMuxPhysicalAdapter *, GUID> m_AdaptersList;

     //
     // List of physical adapters to be removed.
     //

     List<CMuxPhysicalAdapter *, GUID> m_AdaptersToRemove;

     //
     // List of physical adapters to be added.
     //

     List<CMuxPhysicalAdapter *, GUID> m_AdaptersToAdd;

     //
     // Private member functions.
     //

     HRESULT HrLoadAdapterConfiguration (VOID);

     HRESULT HrGetUpperAndLower (INetCfgBindingPath* pncbp,
                                 INetCfgComponent **ppnccUpper,
                                 INetCfgComponent **ppnccLower);

     HRESULT HrAddAdapter (INetCfgComponent *pnccAdapter);

     HRESULT HrRemoveAdapter (INetCfgComponent *pnccAdapter);

     HRESULT HrAddMiniport (CMuxPhysicalAdapter *pAdapter,
                            GUID *guidAdapter);

     HRESULT HrRemoveMiniport (CMuxPhysicalAdapter *pAdapter,
                            GUID *guidAdapter);

#ifdef DISABLE_PROTOCOLS_TO_PHYSICAL

    VOID EnableBindings (INetCfgComponent *pnccAdapter,
                         BOOL bEnable);

    BOOL IfExistMux (INetCfgBindingPath *pncbp);

    HRESULT HrGetBindingPathEnum (INetCfgComponent *pnccAdapter,
                                  DWORD dwBindingType,
                                  IEnumNetCfgBindingPath **ppencbp);

    HRESULT HrGetBindingPath (IEnumNetCfgBindingPath *pencbp,
                              INetCfgBindingPath **ppncbp);

    HRESULT HrGetBindingInterfaceEnum (INetCfgBindingPath *pncbp,
                                       IEnumNetCfgBindingInterface **ppencbi);

    HRESULT HrGetBindingInterface (IEnumNetCfgBindingInterface *pencbi,
                                   INetCfgBindingInterface **ppncbi);
#endif

  public:

     LRESULT OnInitDialog (IN HWND hWnd);
     LRESULT OnOk (IN HWND hWnd);
     LRESULT OnCancel (IN HWND hWnd);
};


LRESULT CALLBACK NotifyDialogProc (HWND hWnd,
                                   UINT uMsg,
                                   WPARAM wParam,
                                   LPARAM lParam);
UINT CALLBACK NotifyPropSheetPageProc (HWND hWnd,
                                       UINT uMsg,
                                       LPPROPSHEETPAGE ppsp);
#endif // NOTIFY_H_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\muxim\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       DLLMAIN . C P P
//
//  Contents:   Main entry points into the DLL
//
//  Notes:
//
//----------------------------------------------------------------------------


#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>

#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#include <devguid.h>

#include "notify.h"
#include "notifyn_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CMuxNotify, CMuxNotify)
END_OBJECT_MAP()





/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain (HINSTANCE hInstance,
                     DWORD dwReason,
                     LPVOID /*lpReserved*/)
{
	TraceMsg( L"-->DllMain.\n");

	if (dwReason == DLL_PROCESS_ATTACH) {

		TraceMsg( L"   Reason: Attach.\n");

		_Module.Init(ObjectMap, hInstance);

		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {

		TraceMsg( L"   Reason: Detach.\n");

		   _Module.Term();
	}

	TraceMsg( L"<--DllMain.\n");

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	HRESULT hr;

	TraceMsg( L"-->DllCanUnloadNow.\n");

	hr = (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;

	TraceMsg( L"-->DllCanUnloadNow(HRESULT = %x).\n",
	        hr );

	return hr;  
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	TraceMsg( L"-->DllGetClassObject.\n");

	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// Registers object, typelib and all interfaces in typelib

	TraceMsg( L"-->DllRegisterServer.\n");

	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	TraceMsg( L"-->DllUnregisterServer.\n");

	_Module.UnregisterServer();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\muxim\notify.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       N O T I F Y . C P P
//
//  Contents:   Sample notify object code
//  
//  Notes:
//
//  Author:     Alok Sinha

//----------------------------------------------------------------------------

#include "notify.h"

HRESULT HrCopyMiniportInf (VOID);

//----------------------------------------------------------------------------
//
// Function:  CMuxNotify::CMuxNotify
//
// Purpose:   Constructor for CMuxNotify
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//

CMuxNotify::CMuxNotify (VOID) : m_pncc (NULL),
                                m_pnc(NULL),
                                m_eApplyAction(eActUnknown),
                                m_pUnkContext(NULL)
{
    TraceMsg( L"-->CMuxNotify::CMuxNotify(Constructor).\n" );

    TraceMsg( L"<--CMuxNotify::CMuxNotify(Constructor).\n" );
}


// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::~CMuxNotify
//
// Purpose:   Destructor for class CMuxNotify
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
CMuxNotify::~CMuxNotify (VOID)
{
    CMuxPhysicalAdapter *pAdapter;
    DWORD dwAdapterCount;
    DWORD i;

    TraceMsg( L"-->CMuxNotify::~CMuxNotify(Destructor).\n" );

    // release interfaces if acquired

    ReleaseObj( m_pncc );
    ReleaseObj( m_pnc );
    ReleaseObj( m_pUnkContext );

    dwAdapterCount = m_AdaptersList.ListCount();

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersList.Remove( &pAdapter );

        delete pAdapter;
    }

    dwAdapterCount = m_AdaptersToRemove.ListCount();

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersToRemove.Remove( &pAdapter );

        delete pAdapter;
    }

    dwAdapterCount = m_AdaptersToAdd.ListCount();

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersToAdd.Remove( &pAdapter );

        delete pAdapter;
    }

    TraceMsg( L"<--CMuxNotify::~CMuxNotify(Destructor).\n" );
}

//
//---------------------- NOTIFY OBJECT FUNCTIONS -----------------------------
//

//----------------------------------------------------------------------------
// INetCfgComponentControl                                           
//                                                                       
// The following functions provide the INetCfgComponentControl interface.
//                                                                       
//----------------------------------------------------------------------------

//
// Function:  CMuxNotify::Initialize
//
// Purpose:   Initialize the notify object
//
// Arguments:
//           IN pnccItem   :  Pointer to INetCfgComponent object
//           IN pnc        :  Pointer to INetCfg object
//           IN fInstalling:  TRUE if we are being installed
//
// Returns:
//
// Notes:
//

STDMETHODIMP CMuxNotify::Initialize (INetCfgComponent* pncc,
                                     INetCfg* pnc, 
                                     BOOL fInstalling)
{
    HRESULT hr = S_OK;

    TraceMsg( L"-->CMuxNotify INetCfgControl::Initialize.\n" );


    // Save INetCfg & INetCfgComponent and add a refcount

    m_pncc = pncc;
    m_pnc = pnc;

    if (m_pncc) {

        m_pncc->AddRef();
    }

    if (m_pnc) {

        m_pnc->AddRef();
    }


    //
    // If this not an installation, then we need to 
    // initialize all of our data and classes
    //

    if ( !fInstalling ) {

        hr = HrLoadAdapterConfiguration();
    }else  {
        OSVERSIONINFO osvi;

        ZeroMemory( &osvi,
                    sizeof(OSVERSIONINFO) );
        
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if ( GetVersionEx(&osvi) ) 
        {
            if ( (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && 
                 (osvi.dwMajorVersion == 5) &&
                 (osvi.dwMinorVersion == 0) )
            {
                // On Windows 2000, copy the miniport inf file to %windir%\inf.

                TraceMsg(L"    Copying miniport inf to system inf directory...\n");
                HrCopyMiniportInf();
            }
            else
            {
                TraceMsg(L"    Skipping copying miniport inf to system inf directory...\n");
            }
        }
    }	
    TraceMsg( L"<--CMuxNotify INetCfgControl::Initialize(HRESULT = %x).\n",
           hr );

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::CancelChanges
//
// Purpose:   Cancel any changes made to internal data
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//

STDMETHODIMP CMuxNotify::CancelChanges (VOID)
{
    TraceMsg( L"-->CMuxNotify INetCfgControl::CancelChanges.\n" );


    TraceMsg( L"<--CMuxNotify INetCfgControl::CancelChanges(HRESULT = %x).\n",
              S_OK );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::ApplyRegistryChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK.
//
// Notes:     We can make changes to registry etc. here.

STDMETHODIMP CMuxNotify::ApplyRegistryChanges(VOID)
{
    CMuxPhysicalAdapter *pAdapter = NULL;
    GUID                   guidAdapter;
    DWORD                  dwAdapterCount;
    DWORD                  i;

    TraceMsg( L"-->CMuxNotify INetCfgControl::ApplyRegistryChanges.\n" );

    //
    // Make registry changes for the adapters added.
    //

    dwAdapterCount = m_AdaptersToAdd.ListCount();

    TraceMsg( L"   Adding %d new adapters.\n",
              dwAdapterCount );

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersToAdd.Find( i,
                              &pAdapter );
   
        pAdapter->ApplyRegistryChanges( eActAdd );

    }

    //
    // Make registry changes for the adapters uninstalled.
    //

    dwAdapterCount = m_AdaptersToRemove.ListCount();

    TraceMsg( L"   Removing %d adapters.\n",
              dwAdapterCount );

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersToRemove.Find( i,
                                 &pAdapter );
           
        pAdapter->ApplyRegistryChanges( eActRemove );
    }

    //
    // Make registry changes for the miniports added/removed
    // through the property pages.
    //

    dwAdapterCount = m_AdaptersList.ListCount();

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersList.Find( i,
                             &pAdapter );

        pAdapter->ApplyRegistryChanges( eActUpdate );
    }

    TraceMsg( L"<--CMuxNotify INetCfgControl::ApplyRegistryChanges(HRESULT = %x).\n",
              S_OK );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::ApplyPnpChanges
//
// Purpose:   Apply changes.
//
// Arguments:
//            IN pfCallback: PnPConfigCallback interface.
//
// Returns:   S_OK.
//
// Notes:     

STDMETHODIMP CMuxNotify::ApplyPnpChanges (
                                       INetCfgPnpReconfigCallback* pfCallback)
{
    CMuxPhysicalAdapter *pAdapter = NULL;
    GUID                   guidAdapter;
    DWORD                  dwAdapterCount;
    DWORD                  i;

    TraceMsg( L"-->CMuxNotify INetCfgControl::ApplyPnpChanges.\n" );

    //
    // Apply PnP changes for the adapters added.
    //

    dwAdapterCount = m_AdaptersToAdd.ListCount();

    TraceMsg( L"   Applying PnP changes when %d adapters added.\n",
            dwAdapterCount );

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersToAdd.Remove( &pAdapter );

        pAdapter->ApplyPnpChanges( pfCallback,
                                eActAdd );

        pAdapter->GetAdapterGUID( &guidAdapter );

        m_AdaptersList.Insert( pAdapter,
                            guidAdapter );
    }

    //
    // Apply PnP changes for the adapters uninstalled.
    //

    dwAdapterCount = m_AdaptersToRemove.ListCount();

    TraceMsg( L"   Applying PnP changes when %d adapters removed.\n",
            dwAdapterCount );

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersToRemove.Remove( &pAdapter );

        pAdapter->ApplyPnpChanges( pfCallback,
                            eActRemove );

        delete pAdapter;
    }

    //
    // Apply PnP changes for the miniports added/removed through
    // the property pages.
    //

    dwAdapterCount = m_AdaptersList.ListCount();

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersList.Find( i,
                          &pAdapter );

        pAdapter->ApplyPnpChanges( pfCallback,
                                eActUpdate );
    }

    TraceMsg( L"<--CMuxNotify INetCfgControl::ApplyPnpChanges(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}


//----------------------------------------------------------------------------
// INetCfgComponentSetup                                           
//                                                                       
// The following functions provide the INetCfgComponentSetup interface.
//                                                                       
//----------------------------------------------------------------------------

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::Install
//
// Purpose:   Do operations necessary during the installation.
//
// Arguments:
//            IN dwSetupFlags:  Setup flags
//
// Returns:   S_OK
//
// Notes:     Don't do anything irreversible (like modifying registry) yet
//            since the config. actually completes only when Apply is called!
//

STDMETHODIMP CMuxNotify::Install (DWORD dwSetupFlags)
{

    TraceMsg( L"-->CMuxNotify INetCfgSetup::Install.\n" );

    // Start up the install process

    m_eApplyAction = eActInstall;

    TraceMsg( L"<--CMuxNotify INetCfgSetup::Install(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::Upgrade
//
// Purpose:   Do operations necessary during the upgrade.
//
// Arguments:
//            IN dwSetupFlags: Setup flags
//
// Returns:   S_OK
//
// Notes:     Don't do anything irreversible (like modifying registry) yet
//            since the config. actually completes only when Apply is called!
//

STDMETHODIMP CMuxNotify::Upgrade (IN DWORD dwSetupFlags,
                                  IN DWORD dwUpgradeFromBuildNo)
{

    TraceMsg( L"-->CMuxNotify INetCfgSetup::Upgrade.\n" );

    TraceMsg( L"   DwSetupFlags = %x, dwUpgradeFromBuildNo = %x\n",
              dwSetupFlags,
              dwUpgradeFromBuildNo );

    TraceMsg( L"<--CMuxNotify INetCfgSetup::Upgrade(HRESULT = %x).\n",
              S_OK );

    return S_OK;
}


// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::ReadAnswerFile
//
// Purpose:   Read settings from answerfile and configure CMuxNotify
//
// Arguments:
//            IN pszAnswerFile   : Name of AnswerFile
//            IN pszAnswerSection: Name of parameters section
//
// Returns:
//
// Notes:     Don't do anything irreversible (like modifying registry) yet
//            since the config. actually completes only when Apply is called!
//

STDMETHODIMP CMuxNotify::ReadAnswerFile (PCWSTR pszAnswerFile,
                                         PCWSTR pszAnswerSection)
{
    PCWSTR pszParamReadFromAnswerFile = L"ParamFromAnswerFile";

    TraceMsg( L"-->CMuxNotify INetCfgSetup::ReadAnswerFile.\n" );

    // We will pretend here that szParamReadFromAnswerFile was actually
    // read from the AnswerFile using the following steps
    //
    //   - Open file pszAnswerFile using SetupAPI
    //   - locate section pszAnswerSection
    //   - locate the required key and get its value
    //   - store its value in pszParamReadFromAnswerFile
    //   - close HINF for pszAnswerFile

    // Now that we have read pszParamReadFromAnswerFile from the
    // AnswerFile, store it in our memory structure.
    // Remember we should not be writing it to the registry till
    // our Apply is called!!
    //

    TraceMsg( L"<--CMuxNotify INetCfgSetup::ReadAnswerFile(HRESULT = %x).\n",
              S_OK );

    return S_OK;
}


// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::Removing
//
// Purpose:   Do necessary cleanup when being removed
//
// Arguments: None
//
// Returns:   S_OK
//
// Notes:     Don't do anything irreversible (like modifying registry) yet
//            since the removal is actually complete only when Apply is called!
//

STDMETHODIMP CMuxNotify::Removing (VOID)
{

    TraceMsg( L"-->CMuxNotify INetCfgSetup::Removing.\n" );

    TraceMsg( L"<--CMuxNotify INetCfgSetup::Removing(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}



//----------------------------------------------------------------------------
// INetCfgComponentNotifyBinding                                          
//                                                                       
// The following functions provide the INetCfgComponentNotifyBinding interface.
//                                                                       
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// Function:  CMuxNotify::QueryBindingPath
//
// Purpose:  This is specific to the component being installed. This will 
//           ask us if we want to bind to the Item being passed into
//           this routine. We can disable the binding by returning
//           NETCFG_S_DISABLE_QUERY 
//
//
// Arguments:
//           IN dwChangeFlag: Type of binding change
//           IN pncbpItem   : Pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code.
//
// Notes:
//
STDMETHODIMP CMuxNotify::QueryBindingPath (IN DWORD dwChangeFlag,  
                                           IN INetCfgBindingPath *pncbp)
{
    TraceMsg( L"-->CMuxNotify INetCfgNotifyBinding::QueryBindingPath.\n" );

    DumpChangeFlag( dwChangeFlag );
    DumpBindingPath( pncbp );

    TraceMsg( L"<--CMuxNotify INetCfgNotifyBinding::QueryBindingPath(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::NotifyBindingPath
//
// Purpose:  We are now being told to bind to the component passed to us. 
//
//
// Arguments:
//           IN dwChangeFlag: Type of system change
//           IN pncc        : Pointer to INetCfgComponent object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//



STDMETHODIMP CMuxNotify::NotifyBindingPath (IN DWORD dwChangeFlag,  
                                            IN INetCfgBindingPath *pncbp)
{
    INetCfgComponent     *pnccLower;
    INetCfgComponent     *pnccUpper;
    LPWSTR               pszwInfIdLower;
    LPWSTR               pszwInfIdUpper;
    DWORD                dwCharcteristics;
    HRESULT              hr = S_OK;

    TraceMsg( L"-->CMuxNotify INetCfgNotifyBinding::NotifyBindingPath.\n" );

    DumpChangeFlag( dwChangeFlag );
    DumpBindingPath( pncbp );

     //
     // We are only interested to know 1) when a component is installed
     // and we are binding to it i.e. dwChangeFlag = NCN_ADD | NCN_ENABLE
     // and 2) when a component is removed to which we are bound i.e.
     // dwChangeFlag = NCN_REMOVE | NCN_ENABLE. dwChangeFlag is never
     // set to NCN_ADD or NCN_REMOVE only. So, checking for NCN_ENABLE
     // covers the case of NCN_ADD | NCN_ENABLE and checking for NCN_REMOVE
     // covers the case of NCN_REMOVE | NCN_ENABLE. We don't care about
     // NCN_ADD | NCN_DISABLE (case 1) and NCN_REMOVE | NCN_DISABLE (case 2).
     //

     if ( dwChangeFlag & (NCN_ENABLE | NCN_REMOVE) ) {

        //
        // Get the upper and lower components.
        //

        hr = HrGetUpperAndLower( pncbp,
                                 &pnccUpper,
                                 &pnccLower );

        if ( hr == S_OK ) {

            hr = pnccLower->GetCharacteristics( &dwCharcteristics );

            if ( hr == S_OK ) {

                hr = pnccLower->GetId( &pszwInfIdLower );

                if ( hr == S_OK ) {

                    hr = pnccUpper->GetId( &pszwInfIdUpper );

                    if ( hr == S_OK ) {

                        //
                        // We are interested only in binding to a
                        // physical ethernet adapters.
                        // 

                        if ( dwCharcteristics & NCF_PHYSICAL ) {

                            if ( !_wcsicmp( pszwInfIdUpper, c_szMuxProtocol ) ) {

                                if ( dwChangeFlag & NCN_ADD ) {

                                    hr = HrAddAdapter( pnccLower );
                                    m_eApplyAction = eActAdd;

                                } else if ( dwChangeFlag & NCN_REMOVE ) {

                                    hr = HrRemoveAdapter( pnccLower );
                                    m_eApplyAction = eActRemove;
                                }
                            }
                        } // Physical Adapters. 
                        else if (dwCharcteristics & NCF_VIRTUAL) {

                        }

                        CoTaskMemFree( pszwInfIdUpper );

                    } // Got the upper component id.

                    CoTaskMemFree( pszwInfIdLower );

                } // Got the lower component id.

            } // Got NIC's characteristics

            ReleaseObj(pnccLower);
            ReleaseObj(pnccUpper);

        } // Got the upper and lower components.

    } 

    TraceMsg( L"<--CMuxNotify INetCfgNotifyBinding::NotifyBindingPath(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}




//----------------------------------------------------------------------------
// INetCfgComponentNotifyGlobal
//                                                                       
// The following functions provide the INetCfgComponentNotifyGlobal interface.
//                                                                       
//----------------------------------------------------------------------------

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::GetSupportedNotifications
//
// Purpose:   Tell the system which notifications we are interested in
//
// Arguments:
//            OUT pdwNotificationFlag: Pointer to NotificationFlag
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CMuxNotify::GetSupportedNotifications (
                                             OUT DWORD* pdwNotificationFlag)
{
    TraceMsg( L"-->CMuxNotify INetCfgNotifyGlobal::GetSupportedNotifications.\n" );

    *pdwNotificationFlag = NCN_NET | NCN_NETTRANS | NCN_ADD | NCN_REMOVE |
                           NCN_BINDING_PATH | NCN_ENABLE | NCN_DISABLE;

    TraceMsg( L"<--CMuxNotify INetCfgNotifyGlobal::GetSupportedNotifications(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::SysQueryBindingPath
//
// Purpose:   Enable or Disable a binding path.
//
// Arguments:
//            IN dwChangeFlag: Type of binding change
//            IN pncbp       : Pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//

STDMETHODIMP CMuxNotify::SysQueryBindingPath (DWORD dwChangeFlag,
                                              INetCfgBindingPath* pncbp)
{
    INetCfgComponent     *pnccLower;
    INetCfgComponent     *pnccUpper;
    LPWSTR               pszwInfIdLower;
    LPWSTR               pszwInfIdUpper;
    DWORD                dwCharcteristics;
    HRESULT              hr = S_OK;


    TraceMsg( L"-->CMuxNotify INetCfgNotifyGlobal::SysQueryBindingPath.\n" );

    DumpChangeFlag( dwChangeFlag );
    DumpBindingPath( pncbp );

    if ( dwChangeFlag & NCN_ENABLE ) {

        //
        // Get the upper and lower components.
        //

        hr = HrGetUpperAndLower( pncbp,
                                 &pnccUpper,
                                 &pnccLower );

        if ( hr == S_OK ) {
            hr = pnccLower->GetCharacteristics( &dwCharcteristics );

            if ( hr == S_OK ) {

                hr = pnccLower->GetId( &pszwInfIdLower );

                if ( hr == S_OK ) {

                    hr = pnccUpper->GetId( &pszwInfIdUpper );

                    if ( hr == S_OK ) {

                        //
                        // We are interested only in bindings to physical 
                        // ethernet adapters.
                        // 

                        if ( dwCharcteristics & NCF_PHYSICAL ) {

#ifdef DISABLE_PROTOCOLS_TO_PHYSICAL

                            //
                            // If it not our protocol binding to the
                            // physical adapter then, disable the
                            // binding.
                            //

                            if (_wcsicmp( pszwInfIdUpper, c_szMuxProtocol ) ) {

                                TraceMsg( L"   Disabling the binding between %s "
                                          L"and %s.\n",
                                          pszwInfIdUpper,
                                          pszwInfIdLower );

                                hr = NETCFG_S_DISABLE_QUERY;
                            }
#endif

                        } // Physical Adapters. 
                        else {
                            if (dwCharcteristics & NCF_VIRTUAL) {

                                // If the lower component is our miniport
                                // and the upper component is our protocol
                                // then also, disable the binding.

                                if ( !_wcsicmp(pszwInfIdLower, c_szMuxMiniport) &&
                                     !_wcsicmp(pszwInfIdUpper, c_szMuxProtocol) ) {
                                  
                                    TraceMsg( L"   Disabling the binding between %s "
                                              L"and %s.\n",
                                              pszwInfIdUpper,
                                              pszwInfIdLower );

                                    hr = NETCFG_S_DISABLE_QUERY;
                                }

                            } // Virtual Adapters

                        }

                        CoTaskMemFree( pszwInfIdUpper );

                    } // Got the upper component id.

                    CoTaskMemFree( pszwInfIdLower );

                } // Got the lower component id.

            } // Got NIC's characteristics

            ReleaseObj(pnccLower);
            ReleaseObj(pnccUpper);

        }

    }

    TraceMsg( L"<--CMuxNotify INetCfgNotifyGlobal::SysQueryBindingPath(HRESULT = %x).\n",
            hr );

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::SysNotifyBindingPath
//
// Purpose:   System tells us by calling this function which
//            binding path has just been formed.
//
// Arguments:
//            IN dwChangeFlag: Type of binding change
//            IN pncbpItem   : Pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CMuxNotify::SysNotifyBindingPath (DWORD dwChangeFlag,
                                               INetCfgBindingPath* pncbp)
{
    TraceMsg( L"-->CMuxNotify INetCfgNotifyGlobal::SysNotifyBindingPath.\n" );

    DumpChangeFlag( dwChangeFlag );
    DumpBindingPath( pncbp );

    TraceMsg( L"<--CMuxNotify INetCfgNotifyGlobal::SysNotifyBindingPath(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::SysNotifyComponent
//
// Purpose:   System tells us by calling this function which
//            component has undergone a change (installed/removed)
//
// Arguments:
//            IN dwChangeFlag: Type of system change
//            IN pncc        : Pointer to INetCfgComponent object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CMuxNotify::SysNotifyComponent (DWORD dwChangeFlag,
                                                INetCfgComponent* pncc)
{
    TraceMsg( L"-->CMuxNotify INetCfgNotifyGlobal::SysNotifyComponent.\n" );

    DumpChangeFlag( dwChangeFlag );
    DumpComponent( pncc );

    TraceMsg( L"<--CMuxNotify INetCfgNotifyGlobal::SysNotifyComponent(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}


//----------------------------------------------------------------------------
// INetCfgComponentPropertyUi                                          
//                                                                       
// The following functions provide the INetCfgComponentPropertyUi interface.
//                                                                       
//----------------------------------------------------------------------------

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::MergePropPages
//
// Purpose:   Supply our property page to system.
//
// Arguments:
//            OUT pdwDefPages  : Pointer to num default pages
//            OUT pahpspPrivate: Pointer to array of pages
//            OUT pcPages      : Pointer to num pages
//            IN  hwndParent   : Handle of parent window
//            IN  szStartPage  : Pointer to
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CMuxNotify::MergePropPages (IN OUT DWORD* pdwDefPages,
                                         OUT LPBYTE* pahpspPrivate,
                                         OUT UINT* pcPages,
                                         IN HWND hwndParent,
                                         OUT PCWSTR* szStartPage)
{
    HRESULT                 hr = S_OK;
    HPROPSHEETPAGE          *ahpsp;;
    INetLanConnectionUiInfo *pLanConnUiInfo;

    TraceMsg(L"-->CMuxNotify INetCfgPropertyUi::MergePropPages\n");

    //
    // We don't want any default pages to be shown
    //

    *pdwDefPages = 0;
    *pcPages = 0;
    *pahpspPrivate = NULL;

    if ( !m_pUnkContext ) {
        return E_UNEXPECTED;
    }

    hr = m_pUnkContext->QueryInterface(
          IID_INetLanConnectionUiInfo,
          reinterpret_cast<PVOID *>(&pLanConnUiInfo));

    if ( hr == S_OK ) {

        ReleaseObj( pLanConnUiInfo );

        ahpsp = (HPROPSHEETPAGE*)CoTaskMemAlloc( sizeof(HPROPSHEETPAGE) );

        if (ahpsp) {

            PROPSHEETPAGE   psp = {0};

            psp.dwSize            = sizeof(PROPSHEETPAGE);
            psp.dwFlags           = PSP_DEFAULT;
            psp.hInstance         = _Module.GetModuleInstance();
            psp.pszTemplate       = MAKEINTRESOURCE(IDD_NOTIFY_GENERAL);
            psp.pfnDlgProc        = (DLGPROC)NotifyDialogProc;
            psp.pfnCallback       = NULL; (LPFNPSPCALLBACK)NotifyPropSheetPageProc;
            psp.lParam            = (LPARAM) this;
            psp.pszHeaderTitle    = NULL;
            psp.pszHeaderSubTitle = NULL;

            ahpsp[0] = ::CreatePropertySheetPage(&psp);
            *pcPages = 1;
            *pahpspPrivate = (LPBYTE)ahpsp;
        }
        else {
            hr = E_OUTOFMEMORY;
        }
    }
    TraceMsg(L"<--CMuxNotify INetCfgPropertyUi::MergePropPages(HRESULT = %x).\n",
           hr );

    return hr;
}


// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::ValidateProperties
//
// Purpose:   Validate changes to property page.
//
// Arguments:
//            IN hwndSheet: Window handle of property sheet
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//

STDMETHODIMP CMuxNotify::ValidateProperties (HWND hwndSheet)
{

    TraceMsg( L"-->CMuxNotify INetCfgPropertyUi::ValidateProperties\n" );

    TraceMsg(L"<--CMuxNotify INetCfgPropertyUi::ValidateProperties(HRESULT = %x).\n",
           S_OK );
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::CancelProperties
//
// Purpose:   Cancel changes to property page
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CMuxNotify::CancelProperties (VOID)
{
    TraceMsg(L"-->CMuxNotify INetCfgPropertyUi::CancelProperties\n");

    TraceMsg(L"<--CMuxNotify INetCfgPropertyUi::CancelProperties(HRESULT = %x).\n",
           S_OK );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::ApplyProperties
//
// Purpose:   Apply value of controls on property page
//            to internal memory structure
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     
//
STDMETHODIMP CMuxNotify::ApplyProperties (VOID)
{
    INetLanConnectionUiInfo *pLanConnUiInfo;
    CMuxPhysicalAdapter     *pAdapter;
    GUID                    guidAdapter;
    INetCfgComponent        *pncc;
    HRESULT                 hr = S_OK;

    TraceMsg(L"-->CMuxNotify INetCfgPropertyUi::ApplyProperties\n");

    if ( m_pUnkContext ) {

        hr = m_pUnkContext->QueryInterface(
                                  IID_INetLanConnectionUiInfo,
                                  reinterpret_cast<PVOID *>(&pLanConnUiInfo));

        if ( hr == S_OK ) {

            hr = pLanConnUiInfo->GetDeviceGuid( &guidAdapter );

            if ( hr == S_OK ) {

                hr = m_AdaptersList.FindByKey( guidAdapter,
                                               &pAdapter );
                if ( hr == S_OK ) {

                    switch( m_eApplyAction ) {

                        case eActPropertyUIAdd:

                              hr = HrAddMiniport( pAdapter,
                                                  &guidAdapter );
                        break;

                        case eActPropertyUIRemove:

                              hr = HrRemoveMiniport( pAdapter,
                                                     &guidAdapter );
                        break;
                    }
                }
            }

            ReleaseObj( pLanConnUiInfo );
        }
    }

    TraceMsg(L"<--CMuxNotify INetCfgPropertyUi::ApplyProperties(HRESULT = %x).\n",
           hr );
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::QueryPropertyUi
//
// Purpose:   System is asking if we support property pages.
//
// Arguments:
//            IN pUnk: Pointer to IUnknown.
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     We display property pages only in the context of
//            a LAN connection.
//

STDMETHODIMP CMuxNotify::QueryPropertyUi (IUnknown * pUnk)
{
    INetLanConnectionUiInfo *pLanConnUiInfo;
    HRESULT                 hr=S_FALSE;

    TraceMsg(L"-->CMuxNotify INetCfgPropertyUi::QueryPropertyUi\n");

#ifndef PASSTHRU_NOTIFY

    if ( pUnk ) {

        hr = pUnk->QueryInterface(
                              IID_INetLanConnectionUiInfo,
                              reinterpret_cast<PVOID *>(&pLanConnUiInfo));

        ReleaseObj( pLanConnUiInfo );
    } 
#endif

    TraceMsg(L"<--CMuxNotify INetCfgPropertyUi::QueryPropertyUi(HRESULT = %x).\n",
           hr );

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::SetContext
//
// Purpose:   Save the LAN connection context.
//
// Arguments: 
//            IN pUnk: Pointer to IUnknown.
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     It is also called to release the current LAN connection context.
//

STDMETHODIMP CMuxNotify::SetContext (IUnknown * pUnk)
{
    TraceMsg(L"-->CMuxNotify INetCfgPropertyUi::SetContext\n");

    //
    // Release previous context, if any
    //

    ReleaseObj( m_pUnkContext );

    m_pUnkContext = NULL;

    if ( pUnk ) {

        m_pUnkContext = pUnk;
        m_pUnkContext->AddRef();
    }

    TraceMsg(L"<--CMuxNotify INetCfgPropertyUi::SetContext(HRESULT = %x).\n",
           S_OK );

    return S_OK;
}

//----------------------------------------------------------------------------
//
//  Function:   CMuxNotify::HrLoadAdapterConfiguration
//
//  Purpose:    This loads the Miniport and adapters that have already been 
//              installed into our own data structures
//
//  Arguments:  None.
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//


HRESULT CMuxNotify::HrLoadAdapterConfiguration (VOID)
{
    HKEY                 hkeyAdapterList;
    WCHAR                szAdapterGuid[MAX_PATH+1];
    DWORD                dwDisp;
    CMuxPhysicalAdapter  *pAdapter;
    GUID                 guidAdapter;
    DWORD                dwIndex;
    LONG                 lResult;

    TraceMsg( L"-->CMuxNotify::HrLoadAdapterConfiguration.\n" );

    lResult = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
                               c_szAdapterList,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hkeyAdapterList,
                               &dwDisp);


    if ( lResult == ERROR_SUCCESS ) {

        //
        // If dwDisp indicates that a new key is created then, we know there
        // is no adapter currently listed underneath and we simply
        // return, otherwise, we enumerate the subkeys, each one representing an 
        // adapter.
        //

        if ( dwDisp != REG_CREATED_NEW_KEY ) {

            lResult = RegEnumKeyW( hkeyAdapterList,
                                   0,
                                   szAdapterGuid,
                                   MAX_PATH+1 );

            for (dwIndex=1; lResult == ERROR_SUCCESS; ++dwIndex) {

                TraceMsg( L"   Loading configuration for adapter %s...\n",
                         szAdapterGuid );

                //
                // Subkeys are actually a guid/bindname of the adapters.
                //

                CLSIDFromString( szAdapterGuid,
                                 &guidAdapter );

                //
                // Create an instance representing the adapter.
                //

                pAdapter = new CMuxPhysicalAdapter( m_pnc,
                                                    &guidAdapter );

                if ( pAdapter ) {

                  //
                  // Load any adapter specific configuration.
                  //

                  pAdapter->LoadConfiguration();

                  //
                  // Save the adapter instance in a list.
                  //

                  m_AdaptersList.Insert( pAdapter,
                                         guidAdapter );

                  //
                  // Get next subkey.
                  //

                  lResult = RegEnumKeyW( hkeyAdapterList,
                                         dwIndex,
                                         szAdapterGuid,
                                         MAX_PATH+1 );
                }
                else {

                 lResult = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            //
            // RegEnumKeyW may have returned error when there are no more
            // subkeys to read.
            //

            lResult = ERROR_SUCCESS;
        }

        RegCloseKey( hkeyAdapterList );
    }

    TraceMsg( L"<--CMuxNotify::HrLoadAdapterConfiguration(HRESULT = %x).\n",
              HRESULT_FROM_WIN32(lResult) );

    return HRESULT_FROM_WIN32(lResult);
}

//----------------------------------------------------------------------------
//
//  Function:   CMuxNotify::HrGetUpperAndLower
//
//  Purpose:    Get the upper and lower component of the first interface
//              of a binding path.
//
//  Arguments:  
//              IN  pncbp     : Binding path.
//              OUT ppnccUpper: Upper component.
//              OUT ppnccLower: Lower component.
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//

HRESULT CMuxNotify::HrGetUpperAndLower (INetCfgBindingPath* pncbp,
                                        INetCfgComponent **ppnccUpper,
                                        INetCfgComponent **ppnccLower)
{
    IEnumNetCfgBindingInterface*    pencbi;
    INetCfgBindingInterface*        pncbi;
    ULONG                           ulCount;
    HRESULT                         hr;

    TraceMsg( L"-->CMuxNotify::HrGetUpperAndLowerComponent.\n" );

    *ppnccUpper = NULL;
    *ppnccLower = NULL;

    hr = pncbp->EnumBindingInterfaces(&pencbi);

    if (S_OK == hr) {
     
        //
        // get the first binding interface
        //

        hr = pencbi->Next(1, &pncbi, &ulCount);

        if ( hr == S_OK ) {

            hr = pncbi->GetUpperComponent( ppnccUpper );

            if ( hr == S_OK ) {

                hr = pncbi->GetLowerComponent ( ppnccLower );
            }
            else {
                ReleaseObj( *ppnccUpper );
            }

            ReleaseObj( pncbi );
        }

        ReleaseObj( pencbi );
    }

    TraceMsg( L"<--CMuxNotify::HrGetUpperAndLowerComponent(HRESULT = %x).\n",
            hr );

    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   CMuxNotify::HrAddAdapter
//
//  Purpose:    Create an instance representing the physical adapter and install
//              a virtual miniport.
//
//  Arguments:  
//              IN pnccAdapter: Pointer to the physical adapter.
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//

HRESULT CMuxNotify::HrAddAdapter (INetCfgComponent *pnccAdapter)
{
    GUID                     guidAdapter;
    CMuxPhysicalAdapter      *pAdapter;
    HRESULT                  hr;

    TraceMsg( L"-->CMuxNotify::HrAddAdapter.\n" );

    hr = pnccAdapter->GetInstanceGuid( &guidAdapter );

    if ( hr == S_OK ) {

        pAdapter = new CMuxPhysicalAdapter( m_pnc,
                                            &guidAdapter );

        if ( pAdapter ) {

            hr = HrAddMiniport( pAdapter,
                                &guidAdapter );

            if ( hr == S_OK ) {

               m_AdaptersToAdd.Insert( pAdapter,
                                       guidAdapter );
            }
            else {

               delete pAdapter;
            }
        }
        else {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
    } 

    TraceMsg( L"<--CMuxNotify::HrAddAdapter(HRESULT = %x).\n",
            hr );

    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   CMuxNotify::HrRemoveAdapter
//
//  Purpose:    Deletes the instance representing the physical adapter
//              and uninstalls all the virtual miniports.
//
//  Arguments:  
//              IN pnccAdapter: Pointer to the physical adapter.
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:      This function is called when the adapter or the protocol
//              is being uninstalled.
//

HRESULT CMuxNotify::HrRemoveAdapter (INetCfgComponent *pnccAdapter)
{
    GUID                  guidAdapter;
    CMuxPhysicalAdapter   *pAdapter;
    HRESULT               hr;

    TraceMsg( L"-->CMuxNotify::HrRemoveAdapter.\n" );

    hr = pnccAdapter->GetInstanceGuid( &guidAdapter );

    if ( hr == S_OK ) {

        hr = m_AdaptersList.RemoveByKey( guidAdapter,
                                      &pAdapter );

         if ( hr == S_OK ) {

            m_AdaptersToRemove.Insert( pAdapter,  
                                       guidAdapter );
            hr = pAdapter->Remove();

#ifdef DISABLE_PROTOCOLS_TO_PHYSICAL

            //
            // Restore the bindings of other protocols to the physical
            // adapter.
            //
 
            EnableBindings( pnccAdapter,
                            TRUE );
#endif
         }
    }

    TraceMsg( L"<--CMuxNotify::HrRemoveAdapter(HRESULT = %x).\n",
            hr );

    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   CMuxNotify::HrAddMiniport
//
//  Purpose:    Installs a virtual miniport.
//
//  Arguments:  
//              IN pAdapter    : Pointer to the physical adapter class instance.
//              IN pguidAdapter: Pointer to the GUID of the adapter.
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:      
//

HRESULT CMuxNotify::HrAddMiniport (CMuxPhysicalAdapter *pAdapter,
                                   GUID *pguidAdapter)
{
    CMuxVirtualMiniport   *pMiniport;
    INetCfgComponent      *pnccAdapter;
    HRESULT               hr;

    TraceMsg( L"-->CMuxNotify::HrAddMiniport.\n" );

    pMiniport = new CMuxVirtualMiniport( m_pnc,
                                         NULL,
                                         pguidAdapter );
    if ( pMiniport ) {

        hr = pMiniport->Install();

        if ( hr == S_OK ) {

            hr = pAdapter->AddMiniport( pMiniport );

            if ( hr != S_OK ) {

                pMiniport->DeInstall();

                delete pMiniport;
            }
        }
    }
    else {

        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

#ifdef DISABLE_PROTOCOLS_TO_PHYSICAL

    if ( hr == S_OK ) {

        //
        // If this is the first virtual miniport then, disable the bindings
        // of other protocols to the physical adapter.
        //

        if ( pAdapter->MiniportCount() == 0 ) {

            hr = HrFindInstance( m_pnc,
                                 *pguidAdapter,
                                 &pnccAdapter );

            if ( hr == S_OK ) {
                EnableBindings( pnccAdapter,
                                FALSE );

                ReleaseObj( pnccAdapter );
            }
        }
    }
#endif

    TraceMsg( L"<--CMuxNotify::HrAddMiniport(HRESULT = %x).\n",
            hr );
    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   CMuxNotify::HrRemoveMiniport
//
//  Purpose:    Uninstalls a virtual miniport.
//
//  Arguments:  
//              IN pAdapter    : Pointer to the physical adapter class instance.
//              IN pguidAdapter: Pointer to the GUID of the adapter.
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:      
//

HRESULT CMuxNotify::HrRemoveMiniport (CMuxPhysicalAdapter *pAdapter,
                                      GUID *pguidAdapter)
{
    INetCfgComponent      *pnccAdapter;
    HRESULT                hr;

    TraceMsg( L"-->CMuxNotify::HrRemoveMiniport.\n" );

    hr = pAdapter->RemoveMiniport( NULL );

#ifdef DISABLE_PROTOCOLS_TO_PHYSICAL

    if ( hr == S_OK ) {

        //
        // If this was the last miniport that was removed then, restore the
        // bindings of other protocols to the physical adapter.
        //

        if ( pAdapter->AllMiniportsRemoved() ) {

            hr = HrFindInstance( m_pnc,
                                 *pguidAdapter,
                                 &pnccAdapter );

            if ( hr == S_OK ) {
                EnableBindings( pnccAdapter,
                                TRUE );

                ReleaseObj( pnccAdapter );
            }
        }
    }
#endif

    TraceMsg( L"<--CMuxNotify::HrRemoveMiniport(HRESULT = %x).\n",
            hr );

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::OnInitDialog
//
// Purpose:   Initialize controls
//
// Arguments:
//            IN hWnd: Window handle to the property page.
//
// Returns: TRUE.
//
// Notes:
//

LRESULT CMuxNotify::OnInitDialog (IN HWND hWndPage)
{
    m_eApplyAction = eActUnknown;

    ::SendMessage(GetDlgItem(hWndPage, IDC_ADD), BM_SETCHECK, BST_CHECKED, 0);
    ::SendMessage(GetDlgItem(hWndPage, IDC_REMOVE), BM_SETCHECK, BST_UNCHECKED, 0);

    return TRUE;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::OnOk
//
// Purpose:   Do actions when OK is pressed
//
// Arguments:
//            IN hWnd: Window handle to the property page.
//
// Returns:   PSNRET_NOERROR
//
// Notes:
//

LRESULT CMuxNotify::OnOk (IN HWND hWndPage)
{
    TraceMsg(L"-->CMuxNotify::OnOk\n");

    if ( ::SendMessage(GetDlgItem(hWndPage, IDC_ADD),
                       BM_GETCHECK, 0, 0) == BST_CHECKED ) {
     
        m_eApplyAction = eActPropertyUIAdd;
    }
    else {
        m_eApplyAction = eActPropertyUIRemove;
    }

    //
    // Set the property sheet changed flag if any of our controls
    // get changed.  This is important so that we get called to
    // apply our property changes.
    //

    PropSheet_Changed( GetParent(hWndPage), hWndPage);

    TraceMsg(L"<--CMuxNotify::OnOk(Action = %s).\n",
           (m_eApplyAction == eActPropertyUIAdd) ? L"Add" : L"Remove" );

    return PSNRET_NOERROR;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::OnCancel
//
// Purpose:   Do actions when CANCEL is pressed
//
// Arguments:
//            IN hWnd: Window handle to the property page.
//
// Returns:   FALSE
//
// Notes:
//
LRESULT CMuxNotify::OnCancel (IN HWND hWndPage)
{
    TraceMsg(L"-->CMuxNotify::OnCancel\n");

    m_eApplyAction = eActUnknown;

    TraceMsg(L"<--CMuxNotify::OnCancel\n");

    return FALSE;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotifyDialogProc
//
// Purpose:   Dialog proc
//
// Arguments:
//            IN hWnd  : See win32 documentation.
//            IN uMsg  : See win32 documentation.
//            IN wParam: See win32 documentation.
//            IN lParam: See win32 documentation.
//
// Returns:   See win32 documentation.
//
// Notes:
//
LRESULT CALLBACK NotifyDialogProc (HWND hWnd,
                                   UINT uMsg,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    CMuxNotify     *psf;
    LRESULT        lRes=FALSE;

    if ( uMsg != WM_INITDIALOG ) {

        psf = (CMuxNotify *)::GetWindowLongPtr( hWnd,
                                                DWLP_USER );

        // Until we get WM_INITDIALOG, just return FALSE

        if ( !psf ) {

            return lRes;
        }
    }

    switch( uMsg ) {

        case WM_INITDIALOG:
        {
            PROPSHEETPAGE* ppsp;
            ppsp = (PROPSHEETPAGE *)lParam;

            psf = (CMuxNotify *)ppsp->lParam;

            SetWindowLongPtr( hWnd,
                          DWLP_USER,
                          (LONG_PTR)psf);

            lRes = psf->OnInitDialog( hWnd );
        }
        break;

        case WM_COMMAND:

        break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code) {
        
            case PSN_KILLACTIVE:

                //
                // ok to loose focus.
                //

                SetWindowLongPtr( hWnd, DWLP_MSGRESULT, FALSE);

                lRes = TRUE;
                break;

            case PSN_APPLY:

                psf = (CMuxNotify *)::GetWindowLongPtr( hWnd, DWLP_USER);
                lRes = psf->OnOk( hWnd );

                SetWindowLongPtr( hWnd, DWLP_MSGRESULT, lRes);
                lRes = TRUE;
                break;

            case PSN_RESET:

                psf = (CMuxNotify *)::GetWindowLongPtr( hWnd, DWLP_USER);
                psf->OnCancel( hWnd );
        }
     }
  }

  return lRes;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotifyPropSheetPageProc
//
// Purpose:   Prop sheet proc
//
// Arguments:
//            IN hWnd: See win32 documentation
//            IN uMsg: See win32 documentation
//            IN ppsp: See win32 documentation
//
// Returns:   See win32 documentation
//
// Notes:
//

UINT CALLBACK NotifyPropSheetPageProc(HWND hWnd,
                                      UINT uMsg,
                                      LPPROPSHEETPAGE ppsp)
{
    return TRUE;
}


#ifdef DISABLE_PROTOCOLS_TO_PHYSICAL

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::EnableBindings
//
// Purpose:   Enable/Disable the bindings of other protocols to 
//            the physical adapter.
//
// Arguments:
//            IN pnccAdapter: Pointer to the physical adapter.
//            IN bEnable: TRUE/FALSE to enable/disable respectively.
//
// Returns:   None.
//
// Notes:
//

VOID CMuxNotify::EnableBindings (INetCfgComponent *pnccAdapter,
                                 BOOL bEnable)
{
    IEnumNetCfgBindingPath      *pencbp;
    INetCfgBindingPath          *pncbp;
    HRESULT                     hr;
  
    TraceMsg( L"-->CMuxNotify::EnableBindings.\n" );


    //
    // Get the binding path enumerator.
    //

    hr = HrGetBindingPathEnum( pnccAdapter,
                               EBP_ABOVE,
                               &pencbp );
    if ( hr == S_OK ) {

        hr = HrGetBindingPath( pencbp,
                               &pncbp );

        //
        // Traverse each binding path.
        //

        while( hr == S_OK ) {

            //
            // If our protocol does exist in the binding path then,
            // disable it.
            //

            if ( !IfExistMux(pncbp) ) {

                pncbp->Enable( bEnable );
            }

            ReleaseObj( pncbp );

            hr = HrGetBindingPath( pencbp,
                                   &pncbp );
        }

        ReleaseObj( pencbp );
    }
    else {
        TraceMsg( L"   Couldn't get the binding path enumerator, "
                  L"bindings will not be %s.\n",
                  bEnable ? L"enabled" : L"disabled" );
    }

    TraceMsg( L"<--CMuxNotify::EnableBindings.\n" );

    return;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::IfExistMux
//
// Purpose:   Determine if a given binding path contains our protocol.
//
// Arguments:
//            IN pncbp: Pointer to the binding path.
//
// Returns:   TRUE if our protocol exists, otherwise FALSE.
//
// Notes:
//

BOOL CMuxNotify::IfExistMux (INetCfgBindingPath *pncbp)
{
    IEnumNetCfgBindingInterface *pencbi;
    INetCfgBindingInterface     *pncbi;
    INetCfgComponent            *pnccUpper;
    LPWSTR                      lpszIdUpper;
    HRESULT                     hr;
    BOOL                        bExist = FALSE;

    TraceMsg( L"-->CMuxNotify::IfExistMux.\n" );

    //
    // Get the binding interface enumerator.
    //

    hr = HrGetBindingInterfaceEnum( pncbp,
                                  &pencbi );

    if ( hr == S_OK ) {

        //
        // Traverse each binding interface.
        //

        hr = HrGetBindingInterface( pencbi,
                                    &pncbi );

        while( !bExist && (hr == S_OK) ) {

            //
            // Is the upper component our protocol?
            //

            hr = pncbi->GetUpperComponent( &pnccUpper );

            if ( hr == S_OK ) {

                hr = pnccUpper->GetId( &lpszIdUpper );

                if ( hr == S_OK ) {

                    bExist = !_wcsicmp( lpszIdUpper, c_szMuxProtocol );

                    CoTaskMemFree( lpszIdUpper );
                }
                else {
                    TraceMsg( L"   Failed to get the upper component of the interface.\n" );
                }

                ReleaseObj( pnccUpper );
            }
            else {
                TraceMsg( L"   Failed to get the upper component of the interface.\n" );
            }

            ReleaseObj( pncbi );

            if ( !bExist ) {
                hr = HrGetBindingInterface( pencbi,
                                            &pncbi );
            }
        }

        ReleaseObj( pencbi );
    }
    else {
        TraceMsg( L"   Couldn't get the binding interface enumerator.\n" );
    }

    TraceMsg( L"<--CMuxNotify::IfExistMux(BOOL = %x).\n",
            bExist );

    return bExist;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::HrGetBindingPathEnum
//
// Purpose:   Returns the binding path enumerator.
//
// Arguments:
//            IN  pnccAdapter  : Pointer to the physical adapter.
//            IN  dwBindingType: Type of binding path enumerator.
//            OUT ppencbp      : Pointer to the binding path enumerator.
//
// Returns:   S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxNotify::HrGetBindingPathEnum (
                                     INetCfgComponent *pnccAdapter,
                                     DWORD dwBindingType,
                                     IEnumNetCfgBindingPath **ppencbp)
{
    INetCfgComponentBindings *pnccb = NULL;
    HRESULT                  hr;

    *ppencbp = NULL;

    hr = pnccAdapter->QueryInterface( IID_INetCfgComponentBindings,
                               (PVOID *)&pnccb );

    if ( hr == S_OK ) {
        hr = pnccb->EnumBindingPaths( dwBindingType,
                                      ppencbp );

        ReleaseObj( pnccb );
    }

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::HrGetBindingPath
//
// Purpose:   Returns a binding path.
//
// Arguments:
//            IN  pencbp  : Pointer to the binding path enumerator.
//            OUT ppncbp  : Pointer to the binding path.
//
// Returns:   S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxNotify::HrGetBindingPath (IEnumNetCfgBindingPath *pencbp,
                                      INetCfgBindingPath **ppncbp)
{
    ULONG   ulCount;
    HRESULT hr;

    *ppncbp = NULL;

    hr = pencbp->Next( 1,
                       ppncbp,
                       &ulCount );

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::HrGetBindingInterfaceEnum
//
// Purpose:   Returns the binding interface enumerator.
//
// Arguments:
//            IN  pncbp  : Pointer to the binding path.
//            OUT ppencbi: Pointer to the binding path enumerator.
//
// Returns:   S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxNotify::HrGetBindingInterfaceEnum (
                                     INetCfgBindingPath *pncbp,
                                     IEnumNetCfgBindingInterface **ppencbi)
{
    HRESULT hr;

    *ppencbi = NULL;

    hr = pncbp->EnumBindingInterfaces( ppencbi );

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::HrGetBindingInterface
//
// Purpose:   Returns a binding interface.
//
// Arguments:
//            IN  pencbi  : Pointer to the binding interface enumerator.
//            OUT ppncbi  : Pointer to the binding interface.
//
// Returns:   S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxNotify::HrGetBindingInterface (
                                     IEnumNetCfgBindingInterface *pencbi,
                                     INetCfgBindingInterface **ppncbi)
{
    ULONG   ulCount;
    HRESULT hr;

    *ppncbi = NULL;

    hr = pencbi->Next( 1,
                       ppncbi,
                       &ulCount );

    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\muxim\public.h ===
/*++
Copyright (c) 1990-2000    Microsoft Corporation All Rights Reserved

Module Name:

    public.h

Abstract:

    This module contains the common declarations shared by driver
    and user applications.

Author:

     
Environment:

    user and kernel
Notes:


Revision History:


--*/
#ifndef __PUBLIC_H
#define __PUBLIC_H

//
// To support ioctls from user-mode:
//

#define LINKNAME_STRING     L"\\DosDevices\\Mux"
#define NTDEVICE_STRING     L"\\Device\\Mux"

#define  MUX_CUSTOM_EVENT      1

#define NOTIFY_SIGNATURE       0xAFCDABAB

typedef struct _NOTIFY_CUSTOM_EVENT {
  ULONG           uSignature;
  ULONG           uEvent;
  WCHAR           szMiniport[1];
} NOTIFY_CUSTOM_EVENT, *PNOTIFY_CUSTOM_EVENT;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\muxim\resource.h ===
#ifndef RESOURCE_H_INCLUDE

#define RESOURCE_H_INCLUDE

#define IDR_REG_SAMPLE_NOTIFY     40001

#define IDD_NOTIFY_GENERAL        1850
#define IDC_STATIC                -1
#define IDC_ADD                   100
#define IDC_REMOVE                200

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\muxim\setupdi.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S E T U P D I . C P P
//
//  Contents:   Code to copy Net class inf file
//
//  Notes:
//
//----------------------------------------------------------------------------

#include "notify.h"

// =================================================================
// Forward declarations

HRESULT HrCopyMiniportInf (VOID);
HRESULT HrGetProtocolInf (LPWSTR lpszWindowsDir,
                          LPWSTR *lppszProtocolInf);
HRESULT HrGetMediaRootDir (LPWSTR lpszInfFile,
                           LPWSTR *lppszMediaRoot);
HRESULT HrGetPnpID (LPWSTR lpszInfFile,
                    LPWSTR *lppszPnpID);
HRESULT HrGetKeyValue (HINF hInf,
                       LPCWSTR lpszSection,
                       LPCWSTR lpszKey,
                       DWORD  dwIndex,
                       LPWSTR *lppszValue);



const WCHAR c_szInfPath[]               = L"Inf\\";
const WCHAR c_szMiniportInf[]           = L"mux_mp.inf";
const WCHAR c_szInfSourcePathInfo[]     = L"InfSourcePathInfo";
const WCHAR c_szOriginalInfSourcePath[] = L"OriginalInfSourcePath";

HRESULT HrCopyMiniportInf (VOID)
{
    LPWSTR  lpszWindowsDir;
    LPWSTR  lpszProtocolInf;
    LPWSTR  lpszMediaRoot;
    LPWSTR  lpszMiniportInf;
    DWORD   dwLen;
    HRESULT hr;

    //
    // Get %windir% directory.
    //

    dwLen = GetSystemWindowsDirectoryW( NULL, 0 );

    if ( dwLen == 0 )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Add 1 for NULL and 1 for "\" in case it is needed.

    dwLen += wcslen(c_szInfPath) + 2;

    lpszWindowsDir = (LPWSTR)CoTaskMemAlloc( dwLen * sizeof(WCHAR) );

    if ( !lpszWindowsDir )
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if ( GetSystemWindowsDirectoryW(lpszWindowsDir, dwLen) == 0 )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }
    else
    {
        // Append "inf\" to %windir%.

        dwLen = wcslen( lpszWindowsDir );

        if ( lpszWindowsDir[dwLen-1] == L'\\' )
        {
            wcscat( lpszWindowsDir, c_szInfPath );
        }
        else
        {
            wcscat( lpszWindowsDir, L"\\" );
            wcscat( lpszWindowsDir, c_szInfPath );
        }

        //
        // Find the protocol inf name. Originally, it was netsf.inf but has
        // been renamed to oem?.inf by SetupCopyOEMInf.
        //

        hr = HrGetProtocolInf( lpszWindowsDir, &lpszProtocolInf );

        if ( hr == S_OK )
        {
            //
            // Get the directory from where protocol was installed.

            hr = HrGetMediaRootDir( lpszProtocolInf, &lpszMediaRoot );

            if ( hr == S_OK )
            {

                TraceMsg(L"Media root directory is %s.\n", lpszMediaRoot);

                // Add 1 for NULL and 1 for "\" in case it is needed.

                lpszMiniportInf = (LPWSTR)CoTaskMemAlloc( (wcslen(lpszMediaRoot) +
                                                          wcslen(c_szMiniportInf) + 2) *
                                                          sizeof(WCHAR) );
                if ( lpszMiniportInf == NULL )
                {
                    hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                {
                    //
                    // We know the full path from where the protocol is being installed. Our
                    // miniport inf is in the same location. Copy the miniport inf to
                    // %windir%\inf so that when we install the virtual miniport, Setup
                    // will find the miniport inf.
                    //

                    wcscpy( lpszMiniportInf, lpszMediaRoot );

                    dwLen = wcslen( lpszMiniportInf );
                    if ( lpszMiniportInf[dwLen-1] != L'\\' )
                    {
                        wcscat( lpszMiniportInf, L"\\" );
                    }

                    wcscat( lpszMiniportInf, c_szMiniportInf );

                    TraceMsg(L"Calling SetupCopyOEMInf for %s.\n", lpszMiniportInf);

                    if ( !SetupCopyOEMInfW(lpszMiniportInf,
                                          lpszMediaRoot,
                                          SPOST_PATH,
                                          0,
                                          NULL,
                                          0,
                                          NULL,
                                          NULL) )
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }

                    CoTaskMemFree( lpszMiniportInf );
                }

                CoTaskMemFree( lpszMediaRoot );
            }

            CoTaskMemFree( lpszProtocolInf );
        }
    }

    CoTaskMemFree( lpszWindowsDir );

    return hr;
}


//
// The function searches through all the inf files in %windir%\inf and
// returns the name of the protocol's inf.
//

HRESULT HrGetProtocolInf (LPWSTR lpszWindowsDir,
                          LPWSTR *lppszProtocolInf)
{
    LPWSTR  lpszFileList;
    LPWSTR  lpszFile;
    LPWSTR  lpszFileWithPath;
    LPWSTR  lpszPnpID;
    DWORD   dwSizeNeeded;
    BOOL    fTrailingSlash;
    DWORD   dwLen;
    BYTE    found;
    HRESULT hr;

    *lppszProtocolInf = NULL;
    dwLen = wcslen( lpszWindowsDir );
    fTrailingSlash = lpszWindowsDir[dwLen-1] == L'\\';

    if ( SetupGetInfFileListW(lpszWindowsDir,
                              INF_STYLE_WIN4,
                              NULL,
                              0,
                              &dwSizeNeeded) == 0 )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    lpszFileList = (LPWSTR)CoTaskMemAlloc( sizeof(WCHAR) * dwSizeNeeded );

    if ( !lpszFileList )
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if ( SetupGetInfFileListW( lpszWindowsDir,
                               INF_STYLE_WIN4,
                               lpszFileList,
                               dwSizeNeeded,
                               NULL) == 0 )

    {
        CoTaskMemFree( lpszFileList );
        return HRESULT_FROM_WIN32(GetLastError());
    }

    lpszFile = lpszFileList;
    found = 0;
    hr = S_OK;
    while( (hr == S_OK) && !found && *lpszFile )
    {
        lpszFileWithPath = (LPWSTR)CoTaskMemAlloc( sizeof(WCHAR) *
                                                  (wcslen(lpszFile) +
                                                  dwLen + 1 +
                                                  ((fTrailingSlash) ? 0 : 1)) );
        if ( !lpszFileWithPath )
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        else
        {
            if ( fTrailingSlash )
            {
             swprintf( lpszFileWithPath, L"%s%s",
                       lpszWindowsDir,
                       lpszFile );
            }
            else
            {
                swprintf( lpszFileWithPath, L"%s\\%s",
                          lpszWindowsDir,
                          lpszFile );
            }

            hr = HrGetPnpID( lpszFileWithPath, &lpszPnpID );

            // If the inf file installs a driver then, it will have a Model
            // section with the hwid/PnpID of the driver that is installed.
            //
            // In case, there is an error getting the hwid, we simply ignore
            // the inf file and continue with the next one.

            if ( hr == S_OK )
            {
                if (_wcsicmp(lpszPnpID, c_szMuxProtocol) == 0 )
                {
                    found = 1;
                }

                CoTaskMemFree( lpszPnpID );
            }

            if ( !found )
            {
                hr = S_OK;
                CoTaskMemFree( lpszFileWithPath );
                lpszFile += wcslen(lpszFile) + 1;
            }
        }
    }

    if ( found )
    {
        *lppszProtocolInf = lpszFileWithPath;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    CoTaskMemFree( lpszFileList );

    return hr;
}

HRESULT HrGetPnpID (LPWSTR lpszInfFile,
                    LPWSTR *lppszPnpID)
{
    HINF    hInf;
    LPWSTR  lpszModelSection;
    HRESULT hr;

    *lppszPnpID = NULL;

    hInf = SetupOpenInfFileW( lpszInfFile,
                              NULL,
                              INF_STYLE_WIN4,
                              NULL );

    if ( hInf == INVALID_HANDLE_VALUE )
    {

        return HRESULT_FROM_WIN32(GetLastError());
    }

    hr = HrGetKeyValue( hInf,
                        L"Manufacturer",
                        NULL,
                        1,
                        &lpszModelSection );

    if ( hr == S_OK )
    {
        hr = HrGetKeyValue( hInf,
                            lpszModelSection,
                            NULL,
                            2,
                            lppszPnpID );

        CoTaskMemFree( lpszModelSection );
    }

    SetupCloseInfFile( hInf );

    return hr;
}

HRESULT HrGetMediaRootDir (LPWSTR lpszInfFile,
                           LPWSTR *lppszMediaRoot)
{
    HINF    hInf;
    HRESULT hr;

    *lppszMediaRoot = NULL;

    hInf = SetupOpenInfFileW( lpszInfFile,
                              NULL,
                              INF_STYLE_WIN4,
                              NULL );

    if ( hInf == INVALID_HANDLE_VALUE )
    {

        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Contained within the protocol INF should be a [InfSourcePathInfo]
    // section with the following entry:
    //
    //     OriginalInfSourcePath = %1%
    //
    // If we retrieve the value (i.e., field 1) of this line, we'll get the
    // full path where the INF originally came from.
    //

    hr = HrGetKeyValue( hInf,
                        c_szInfSourcePathInfo,
                        c_szOriginalInfSourcePath,
                        1,
                        lppszMediaRoot );

    SetupCloseInfFile( hInf );

    return hr;
}

HRESULT HrGetKeyValue (HINF hInf,
                       LPCWSTR lpszSection,
                       LPCWSTR lpszKey,
                       DWORD  dwIndex,
                       LPWSTR *lppszValue)
{
    INFCONTEXT  infCtx;
    DWORD       dwSizeNeeded;
    HRESULT     hr;

    *lppszValue = NULL;

    if ( SetupFindFirstLineW(hInf,
                             lpszSection,
                             lpszKey,
                             &infCtx) == FALSE )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    SetupGetStringFieldW( &infCtx,
                          dwIndex,
                          NULL,
                          0,
                          &dwSizeNeeded );

    *lppszValue = (LPWSTR)CoTaskMemAlloc( sizeof(WCHAR) * dwSizeNeeded );

    if ( !*lppszValue  )
    {
       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if ( SetupGetStringFieldW(&infCtx,
                              dwIndex,
                              *lppszValue,
                              dwSizeNeeded,
                              NULL) == FALSE )
    {

        hr = HRESULT_FROM_WIN32(GetLastError());

        CoTaskMemFree( *lppszValue );
        *lppszValue = NULL;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\muxim\virtual.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       V I R T U A L . C P P
//
//  Contents:   Virtual miniport class definition.
//
//  Notes:
//
//  Author:     Alok Sinha
//----------------------------------------------------------------------------

#include "virtual.h"
#include "common.h"

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::CMuxVirtualMiniport
//
// Purpose:   Constructor for class CMuxVirtualMiniport
//
// Arguments: None
//
// Returns:
//
// Notes:
//

CMuxVirtualMiniport::CMuxVirtualMiniport(INetCfg *pnc,
                                         GUID    *pguidMiniport,
                                         GUID    *pguidAdapter)
{
    TraceMsg( L"-->CMuxVirtualMiniport::CMuxVirtualMiniport(Constructor).\n" );

    m_pnc = pnc;
    m_pnc->AddRef();

    CopyMemory( &m_guidAdapter,
                pguidAdapter,
                sizeof(GUID) );

    if ( pguidMiniport ) {

        CopyMemory( &m_guidMiniport,
                    pguidMiniport,
                    sizeof(GUID) );

    }
    else {

        ZeroMemory( &m_guidMiniport,
                    sizeof(GUID) );
    }

    TraceMsg( L"<--CMuxVirtualMiniport::CMuxVirtualMiniport(Constructor).\n" );
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::~CMuxVirtualMiniport
//
// Purpose:   Destructor for class CMuxVirtualMiniport
//
// Arguments: None
//
// Returns:
//
// Notes:
//

CMuxVirtualMiniport::~CMuxVirtualMiniport(VOID)
{
    TraceMsg( L"-->CMuxVirtualMiniport::~CMuxVirtualMiniport(Destructor).\n" );

    ReleaseObj( m_pnc );

    TraceMsg( L"<--CMuxVirtualMiniport::~CMuxVirtualMiniport(Destructor).\n" );

}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::LoadConfiguration
//
// Purpose:   Load miniport configuration from the registry.
//
// Arguments: None
//
// Returns: S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxVirtualMiniport::LoadConfiguration(VOID)
{
    TraceMsg( L"-->CMuxVirtualMiniport::LoadConfiguration.\n" );

    TraceMsg( L"<--CMuxVirtualMiniport::LoadConfiguration(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::GetAdapterGUID
//
// Purpose:   Returns the adapter GUID.
//
// Arguments:
//          OUT pguidAdapter: GUID of the adapter returned.
//
// Returns: None.
//
// Notes:
//

VOID CMuxVirtualMiniport::GetAdapterGUID (GUID *pguidAdapter)
{
    TraceMsg( L"-->CMuxVirtualMiniport::GetAdapterGUID.\n" );

    CopyMemory( pguidAdapter,
                &m_guidAdapter,
                sizeof(GUID) );

    TraceMsg( L"<--CMuxVirtualMiniport::GetAdapterGUID.\n" );
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::GetMiniportGUID
//
// Purpose:   Returns the miniport GUID.
//
// Arguments:
//          OUT pguidMiniport: GUID of the miniport returned.
//
// Returns: None.
//
// Notes:
//

VOID CMuxVirtualMiniport::GetMiniportGUID (GUID *pguidMiniport)
{
    TraceMsg( L"-->CMuxVirtualMiniport::GetMiniportGUID.\n" );

    CopyMemory( pguidMiniport,
              &m_guidMiniport,
              sizeof(GUID) );

    TraceMsg( L"<--CMuxVirtualMiniport::GetMiniportGUID.\n" );
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::Install
//
// Purpose:   Installs a virtual miniport.
//
// Arguments: None
//
// Returns: S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxVirtualMiniport::Install (VOID)
{
    INetCfgClass       *pncClass;
    INetCfgClassSetup  *pncClassSetup;
    INetCfgComponent   *pnccMiniport;
    HRESULT            hr;

    TraceMsg( L"-->CMuxVirtualMiniport::Install.\n" );

    hr = m_pnc->QueryNetCfgClass( &GUID_DEVCLASS_NET,
                                  IID_INetCfgClass,
                                  (void **)&pncClass );
    if ( hr == S_OK ) {

        hr = pncClass->QueryInterface( IID_INetCfgClassSetup,
                                       (void **)&pncClassSetup );
        if ( hr == S_OK ) {

            hr = pncClassSetup->Install( c_szMuxMiniport,
                                         NULL,
                                         0,
                                         0,
                                         NULL,
                                         NULL,
                                         &pnccMiniport );
            if ( hr == S_OK ) {

                hr = pnccMiniport->GetInstanceGuid( &m_guidMiniport );

                if ( hr != S_OK ) {

                    TraceMsg( L"   Failed to get the instance guid, uninstalling "
                              L" the miniport.\n" );

                    pncClassSetup->DeInstall( pnccMiniport,
                                              NULL,
                                              NULL );
                }

                ReleaseObj( pnccMiniport );
            }
            else {

                TraceMsg( L"   Failed to install the miniport.\n" );
            }

            ReleaseObj( pncClassSetup );
        }
        else {

            TraceMsg( L"   QueryInterface failed.\n" );
        }

        ReleaseObj( pncClass );
    }
    else {

     TraceMsg( L"   QueryNetCfgClass failed.\n" );
    }

    TraceMsg( L"<--CMuxVirtualMiniport::Install(HRESULT = %x).\n",
            hr );

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::DeInstall
//
// Purpose:   Uninstalls the virtual miniport.
//
// Arguments: None
//
// Returns: S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxVirtualMiniport::DeInstall (VOID)
{
    INetCfgClass       *pncClass;
    INetCfgClassSetup  *pncClassSetup;
    INetCfgComponent   *pnccMiniport;
    HRESULT            hr;

    TraceMsg( L"-->CMuxVirtualMiniport::DeInstall.\n" );

    hr = m_pnc->QueryNetCfgClass( &GUID_DEVCLASS_NET,
                                  IID_INetCfgClass,
                                  (void **)&pncClass );
    if ( hr == S_OK ) {

        hr = pncClass->QueryInterface( IID_INetCfgClassSetup,
                                       (void **)&pncClassSetup );
        if ( hr == S_OK ) {

            hr = HrFindInstance( m_pnc,
                                 m_guidMiniport,
                                 &pnccMiniport );

            if ( hr == S_OK ) {

                TraceMsg( L"   Found the miniport instance to uninstall.\n" );

                hr = pncClassSetup->DeInstall( pnccMiniport,
                                               NULL,
                                               NULL );
                ReleaseObj( pnccMiniport );
            }
            else {
                TraceMsg( L"   Didn't find the miniport instance to uninstall.\n" );
            }

            ReleaseObj( pncClassSetup );
        }
        else {

            TraceMsg( L"   QueryInterface failed.\n" );
        }

        ReleaseObj( pncClass );
    }
    else {

        TraceMsg( L"   QueryNetCfgClass failed.\n" );
    }

    TraceMsg( L"<--CMuxVirtualMiniport::DeInstall(HRESULT = %x).\n",
              hr );

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::ApplyRegistryChanges
//
// Purpose:   Store the changes in the registry.
//
// Arguments:
//            IN eApplyAction: Action performed.
//
// Returns: S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxVirtualMiniport::ApplyRegistryChanges(ConfigAction eApplyAction)
{
    HKEY                    hkeyAdapterGuid;
    WCHAR                   szAdapterGuid[MAX_PATH+1];
    WCHAR                   szAdapterGuidKey[MAX_PATH+1];
    WCHAR                   szMiniportGuid[MAX_PATH+1];
    LPWSTR                  lpDevice;
    LONG                    lResult = 0;

    TraceMsg( L"-->CMuxVirtualMiniport::ApplyRegistryChanges.\n" );

    switch( eApplyAction ) {

        case eActAdd:         // Virtual miniport added.

            StringFromGUID2( m_guidAdapter,
                             szAdapterGuid,
                             MAX_PATH+1 );

            swprintf( szAdapterGuidKey,
                      L"%s\\%s",
                      c_szAdapterList,
                      szAdapterGuid );

            lResult = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
                                       szAdapterGuidKey,
                                       0,
                                       NULL,
                                       REG_OPTION_NON_VOLATILE,
                                       KEY_ALL_ACCESS,
                                       NULL,
                                       &hkeyAdapterGuid,
                                       NULL);


            if ( lResult == ERROR_SUCCESS ) {

                StringFromGUID2( m_guidMiniport,
                                 szMiniportGuid,
                                 MAX_PATH+1 );

                lpDevice = AddDevicePrefix( szMiniportGuid );

                if ( lpDevice ) {

#ifndef PASSTHRU_NOTIFY

                    lResult = AddToMultiSzValue( hkeyAdapterGuid,
                                                 lpDevice );
#else

                    lResult = RegSetValueExW( hkeyAdapterGuid,
                                              c_szUpperBindings,
                                              0,
                                              REG_SZ,
                                              (LPBYTE)lpDevice,
                                              (wcslen(lpDevice) + 1) *
                                              sizeof(WCHAR) );


#endif

                    if ( lResult != ERROR_SUCCESS ) {

                        TraceMsg( L"   Failed to save %s at %s\\%s.\n",
                                  lpDevice,
                                  szAdapterGuidKey,
                                  c_szUpperBindings );

                    }

                    free( lpDevice );
                }
                else {
                    lResult = ERROR_NOT_ENOUGH_MEMORY;
                }

                RegCloseKey( hkeyAdapterGuid );
            }
            else {
                TraceMsg( L"   Failed to open the registry key: %s.\n",
                          szAdapterGuidKey );
            }
            break;

        case eActRemove:                  // Virtual miniport removed.

            StringFromGUID2( m_guidAdapter,
                             szAdapterGuid,
                             MAX_PATH+1 );

            swprintf( szAdapterGuidKey,
                      L"%s\\%s",
                      c_szAdapterList,
                      szAdapterGuid );

            lResult = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
                                        szAdapterGuidKey,
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hkeyAdapterGuid,
                                        NULL);


            if ( lResult == ERROR_SUCCESS ) {

                StringFromGUID2( m_guidMiniport,
                                 szMiniportGuid,
                                 MAX_PATH+1 );

                lpDevice = AddDevicePrefix( szMiniportGuid );
                TraceMsg( L"   Deleting %s at %s.\n",
                          lpDevice,
                          szAdapterGuidKey );

                if ( lpDevice ) {

#ifndef PASSTHRU_NOTIFY

                    lResult = DeleteFromMultiSzValue( hkeyAdapterGuid,
                                                      lpDevice );
#else

                    lResult = RegDeleteValueW( hkeyAdapterGuid,
                                               c_szUpperBindings );
#endif

                    if ( lResult != ERROR_SUCCESS ) {

                        TraceMsg( L"   Failed to delete %s at %s\\%s.\n",
                                  lpDevice,
                                  szAdapterGuidKey,
                                  c_szUpperBindings );

                    }

                    free( lpDevice );
                }

                RegCloseKey( hkeyAdapterGuid );
            }
            else {
                TraceMsg( L"   Failed to open the registry key: %s.\n",
                          szAdapterGuidKey );
            }
    }

    TraceMsg( L"<--CMuxVirtualMiniport::ApplyRegistryChanges(HRESULT = %x).\n",
              HRESULT_FROM_WIN32(lResult) );

    return HRESULT_FROM_WIN32(lResult);
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::ApplyPnpChanges
//
// Purpose:   
//
// Arguments:
//            IN eApplyAction: Action performed.
//
// Returns: S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxVirtualMiniport::ApplyPnpChanges
                                 (INetCfgPnpReconfigCallback *pfCallback,
                                  ConfigAction eApplyAction)
{
    TraceMsg( L"-->CMuxVirtualMiniport::ApplyPnpChanges.\n" );

    TraceMsg( L"<--CMuxVirtualMiniport::ApplyPnpChanges(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\netcfg\implinc.cpp ===
#include "pch.h"
#pragma hdrstop
#include "idls_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\muxim\virtual.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       V I R T U A L . H
//
//  Contents:   Header file for virtual miniport class.
//
//  Notes:
//
//  Author:     Alok Sinha
//
//----------------------------------------------------------------------------

#ifndef VIRTUAL_H_INCLUDED

#define VIRTUAL_H_INCLUDE

#include <windows.h>
#include <stdio.h>
#include "netcfgn.h"

#include "common.h"

//
// Class to represent a virtual miniport created by IM driver.
//

class CMuxVirtualMiniport
{
    //
    // Private member variables.
    //

    INetCfg   *m_pnc;
    GUID      m_guidAdapter;
    GUID      m_guidMiniport;

    //
    // Public members.
    //

    public:

    CMuxVirtualMiniport(INetCfg *m_pnc,
                        GUID    *pguidMiniport,
                        GUID    *guidAdapter);

    virtual ~CMuxVirtualMiniport(VOID);
                                 
    HRESULT LoadConfiguration(VOID);

    VOID    GetAdapterGUID (GUID *);

    VOID    GetMiniportGUID (GUID *);

    HRESULT Install (VOID);

    HRESULT DeInstall (VOID);

    HRESULT ApplyRegistryChanges (ConfigAction eApplyAction);

    HRESULT ApplyPnpChanges (INetCfgPnpReconfigCallback *pfCallback,
                             ConfigAction eApplyAction);
};

#endif // VIRTUAL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\netcfg\snetcfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S N E T C F G . H
//
//  Contents:   Sample code that demonstrates how to:
//              - find out if a component is installed
//              - install a net component
//              - install an OEM net component
//              - uninstall a net component
//              - enumerate net components
//              - enumerate net adapters using Setup API
//              - enumerate binding paths of a component
//
//  Notes:
//
//  Author:     kumarp 26-March-98
//
//----------------------------------------------------------------------------

#pragma once

enum NetClass
{
    NC_NetAdapter=0,
    NC_NetProtocol,
    NC_NetService,
    NC_NetClient,
    NC_Unknown
};

void FindIfComponentInstalled(IN PCWSTR szComponentId);

HRESULT HrInstallNetComponent(IN PCWSTR szComponentId,
                              IN enum NetClass nc,
                              IN PCWSTR szSrcDir);

HRESULT HrUninstallNetComponent(IN PCWSTR szComponentId);


HRESULT HrShowNetAdapters();
HRESULT HrShowNetComponents();
HRESULT HrShowBindingPathsOfComponent(IN PCWSTR szComponentId);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\netcfg\pch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P C H . H
//
//  Contents:   Pre-compiled header file
//
//  Notes:
//
//  Author:     kumarp 28-September-98
//
//----------------------------------------------------------------------------

#pragma once

// Turns off "string too long - truncated to 255 characters in the debug
// information, debugger cannot evaluate symbol."
//
#pragma warning (disable: 4786)

#include <windows.h>
#include <netcfgx.h>
#include <netcfgn.h>

#include <setupapi.h>
#include <devguid.h>
#include <tchar.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\oemupg\pch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT5.0
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P C H . H
//
//  Contents:   Pre-compiled header file for sample OEM DLL code
//
//  Notes:
//
//  Author:     kumarp    16-October-97
//
//----------------------------------------------------------------------------

#pragma once

// Turns off "string too long - truncated to 255 characters in the debug
// information, debugger cannot evaluate symbol."
//
#pragma warning (disable: 4786)

#include <windows.h>
#include <setupapi.h>
#include <stdio.h>
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\netcfg\main.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M A I N . C P P
//
//  Contents:   Code to provide a simple cmdline interface to
//              the sample code functions
//
//  Notes:      The code in this file is not required to access any
//              netcfg functionality. It merely provides a simple cmdline
//              interface to the sample code functions provided in
//              file snetcfg.cpp.
//
//  Author:     kumarp    28-September-98
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "snetcfg.h"

// ----------------------------------------------------------------------
// Global vars
//
BOOL g_fVerbose=FALSE;
static WCHAR* optarg;

// ----------------------------------------------------------------------
void ShowUsage();
WCHAR getopt(ULONG Argc, WCHAR* Argv[], WCHAR* Opts);
enum NetClass MapToNetClass(WCHAR ch);


// ----------------------------------------------------------------------
//
// Function:  wmain
//
// Purpose:   The main function
//
// Arguments: standard main args
//
// Returns:   0 on success, non-zero otherwise
//
// Author:    kumarp 25-December-97
//
// Notes:
//
EXTERN_C int __cdecl wmain(int argc, WCHAR* argv[])
{
    HRESULT hr=S_OK;
    WCHAR ch;
    enum NetClass nc=NC_Unknown;

    // use simple cmd line parsing to get parameters for actions
    // we want to perform. the order of parameters supplied is significant.

    static const WCHAR c_szValidOptions[] =
        L"hH?c:C:l:L:i:I:u:U:vVp:P:s:S:b:B:q:Q:";
    WCHAR szFileFullPath[MAX_PATH+1];
    PWSTR szFileComponent;

    while (_istprint(ch = getopt(argc, argv, (WCHAR*) c_szValidOptions)))
    {
        switch (tolower(ch))
        {
        case 'q':
            FindIfComponentInstalled(optarg);
            break;

        case 'b':
            hr = HrShowBindingPathsOfComponent(optarg);
            break;

        case 'c':
            nc = MapToNetClass(optarg[0]);
            break;

        case 'l':
            wcscpy(szFileFullPath, optarg);
            break;

        case 'i':
            if (nc != NC_Unknown)
            {
                hr = HrInstallNetComponent(optarg, nc, szFileFullPath);
            }
            else
            {
                ShowUsage();
                exit(-1);
            }
            break;

        case 'u':
            hr = HrUninstallNetComponent(optarg);
            break;

        case 's':
            switch(tolower(optarg[0]))
            {
            case 'a':
                hr = HrShowNetAdapters();
                break;

            case 'n':
                hr = HrShowNetComponents();
                break;

            default:
                ShowUsage();
                exit(-1);
                break;
            }
            break;

        case 'v':
            g_fVerbose = TRUE;
            break;

        case EOF:
            break;

        default:
        case 'h':
        case '?':
            ShowUsage();
            exit(0);
            break;
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  MapToNetClass
//
// Purpose:   Map a character to the corresponding net class enum
//
// Arguments:
//    ch [in]  char to map
//
// Returns:   enum for net class
//
// Author:    kumarp 06-October-98
//
// Notes:
//
enum NetClass MapToNetClass(WCHAR ch)
{
    switch(tolower(ch))
    {
    case 'a':
        return NC_NetAdapter;

    case 'p':
        return NC_NetProtocol;

    case 's':
        return NC_NetService;

    case 'c':
        return NC_NetClient;

    default:
        return NC_Unknown;
    }
}
// ----------------------------------------------------------------------
//
// Function:  ShowUsage
//
// Purpose:   Display program usage help
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 24-December-97
//
// Notes:
//
void ShowUsage()
{
static const WCHAR c_szUsage[] =
    L"snetcfg [-v] [-l <full-path-to-component-INF>] -c <p|s|c> -i <comp-id>\n"
    L"    where,\n"
    L"    -l\tprovides the location of INF\n"
    L"    -c\tprovides the class of the component to be installed\n"
    L"      \tp == Protocol, s == Service, c == Client\n"
    L"    -i\tprovides the component ID\n\n"
    L"    The arguments must be passed in the order shown.\n\n"
    L"    Examples:\n"
    L"    snetcfg -l c:\\oemdir\\foo.inf -c p -i foo\n"
    L"    ...installs protocol 'foo' using c:\\oemdir\\foo.inf\n\n"
    L"    snetcfg -c s -i MS_Server\n"
    L"    ...installs service 'MS_Server'\n"

    L"\nOR\n\n"

    L"snetcfg [-v] -q <comp-id>\n"
    L"    Example:\n"
    L"    snetcfg -q MS_IPX\n"
    L"    ...displays if component 'MS_IPX' is installed\n"

    L"\nOR\n\n"

    L"snetcfg [-v] -u <comp-id>\n"
    L"    Example:\n"
    L"    snetcfg -u MS_IPX\n"
    L"    ...uninstalls component 'MS_IPX'\n"

    L"\nOR\n\n"

    L"snetcfg [-v] -s <a|n>\n"
    L"    where,\n"
    L"    -s\tprovides the type of components to show\n"
    L"      \ta == adapters, n == net components\n"
    L"    Examples:\n"
    L"    snetcfg -s n\n"
    L"    ...shows all installed net components\n\n"
    L"\n"

    L"\nOR\n\n"

    L"snetcfg [-v] -b <comp-id>\n"
    L"    Examples:\n"
    L"    snetcfg -b ms_tcpip\n"
    L"    ...shows binding paths containing 'ms_tcpip'\n\n"
    L"\n"

    L"General Notes:\n"
    L"  -v\t  turns on the verbose mode\n"
    L"  -?\t  Displays this help\n"
    L"\n";

    _tprintf(c_szUsage);
}



//+---------------------------------------------------------------------------
//
// Function:  getopt
//
// Purpose:   Parse cmdline and return one argument each time
//            this function is called.
//
// Arguments:
//    Argc [in]  standard main argc
//    Argv [in]  standard main argv
//    Opts [in]  valid options
//
// Returns:
//
// Author:    kumarp 06-October-98
//
// Notes:
//
WCHAR getopt (ULONG Argc, WCHAR* Argv[], WCHAR* Opts)
{
    static ULONG  optind=1;
    static ULONG  optcharind;
    static ULONG  hyphen=0;

    WCHAR  ch;
    WCHAR* indx;

    do {
        if (optind >= Argc) {
            return EOF;
        }

        ch = Argv[optind][optcharind++];
        if (ch == '\0') {
            optind++; optcharind=0;
            hyphen = 0;
            continue;
        }

        if ( hyphen || (ch == '-') || (ch == '/')) {
            if (!hyphen) {
                ch = Argv[optind][optcharind++];
                if (ch == '\0') {
                    optind++;
                    return EOF;
                }
            } else if (ch == '\0') {
                optind++;
                optcharind = 0;
                continue;
            }
            indx = wcschr(Opts, ch);
            if (indx == NULL) {
                continue;
            }
            if (*(indx+1) == ':') {
                if (Argv[optind][optcharind] != '\0'){
                    optarg = &Argv[optind][optcharind];
                } else {
                    if ((optind + 1) >= Argc ||
                        (Argv[optind+1][0] == '-' ||
                         Argv[optind+1][0] == '/' )) {
                        return 0;
                    }
                    optarg = Argv[++optind];
                }
                optind++;
                hyphen = optcharind = 0;
                return ch;
            }
            hyphen = 1;
            return ch;
        } else {
            return EOF;
        }
    } while (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\advcfg\acbind.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A C B I N D . C P P
//
//  Contents:   Advanced configuration bindings dialog implementation
//
//  Notes:
//
//  Author:     danielwe   18 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "acbind.h"
#include "achelp.h"
#include "acsheet.h"
#include "connutil.h"
#include "lancmn.h"
#include "ncnetcfg.h"
#include "ncsetup.h"
#include "ncui.h"
#include "netconp.h"
#include "order.h"


const DWORD g_aHelpIDs_IDD_ADVCFG_Bindings[]=
{
    LVW_Adapters, IDH_Adapters,
    PSB_Adapter_Up, IDH_Adapter_Up,
    PSB_Adapter_Down, IDH_Adapter_Down,
    TVW_Bindings, IDH_Bindings,
    PSB_Binding_Up, IDH_Binding_Up,
    IDH_Binding_Down, PSB_Binding_Down,
    0,0
};

extern const WCHAR c_szNetCfgHelpFile[];

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::~CBindingsDlg
//
//  Purpose:    Destructor for the Advanced configuration dialog
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
CBindingsDlg::~CBindingsDlg()
{
    if (m_hiconUpArrow)
    {
        DeleteObject(m_hiconUpArrow);
    }
    if (m_hiconDownArrow)
    {
        DeleteObject(m_hiconDownArrow);
    }

    if (m_hilItemIcons)
    {
        ImageList_Destroy(m_hilItemIcons);
    }

    if (m_hilCheckIcons)
    {
        ImageList_Destroy(m_hilCheckIcons);
    }

    ReleaseObj(m_pnc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnInitDialog
//
//  Purpose:    Called when the WM_INITDIALOG is received
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   19 Nov 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& bHandled)
{
    HRESULT                 hr = S_OK;
    INT                     iaci;
    RECT                    rc;
    LV_COLUMN               lvc = {0};
    SP_CLASSIMAGELIST_DATA  cid;

    m_hwndLV = GetDlgItem(LVW_Adapters);
    m_hwndTV = GetDlgItem(TVW_Bindings);

    // Make this initially invisible in case we don't have any adapters
    ::ShowWindow(GetDlgItem(IDH_TXT_ADVGFG_BINDINGS), SW_HIDE);

    hr = HrSetupDiGetClassImageList(&cid);
    if (SUCCEEDED(hr))
    {
        // Create small image lists
        m_hilItemIcons = ImageList_Duplicate(cid.ImageList);

        // Add the LAN connection icon to the image list
        HICON hIcon = LoadIcon(_Module.GetResourceInstance(),
                               MAKEINTRESOURCE(IDI_LB_GEN_S_16));
        Assert(hIcon);

        // Add the icon
        m_nIndexLan = ImageList_AddIcon(m_hilItemIcons, hIcon);

        ListView_SetImageList(m_hwndLV, m_hilItemIcons, LVSIL_SMALL);
        TreeView_SetImageList(m_hwndTV, m_hilItemIcons, TVSIL_NORMAL);

        (void) HrSetupDiDestroyClassImageList(&cid);
    }

    ::GetClientRect(m_hwndLV, &rc);
    lvc.mask = LVCF_FMT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn(m_hwndLV, 0, &lvc);

    if (!m_hiconUpArrow && !m_hiconDownArrow)
    {
        m_hiconUpArrow = (HICON)LoadImage(_Module.GetResourceInstance(),
                                          MAKEINTRESOURCE(IDI_UP_ARROW),
                                          IMAGE_ICON, 16, 16, 0);
        m_hiconDownArrow = (HICON)LoadImage(_Module.GetResourceInstance(),
                                            MAKEINTRESOURCE(IDI_DOWN_ARROW),
                                            IMAGE_ICON, 16, 16, 0);
    }

    SendDlgItemMessage(PSB_Adapter_Up, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(m_hiconUpArrow));
    SendDlgItemMessage(PSB_Adapter_Down, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(m_hiconDownArrow));
    SendDlgItemMessage(PSB_Binding_Up, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(m_hiconUpArrow));
    SendDlgItemMessage(PSB_Binding_Down, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(m_hiconDownArrow));

    if (SUCCEEDED(hr))
    {
        hr = HrBuildAdapterList();
    }

    // Create state image lists
    m_hilCheckIcons = ImageList_LoadBitmapAndMirror(
                                    _Module.GetResourceInstance(),
                                    MAKEINTRESOURCE(IDB_CHECKSTATE),
                                    16,
                                    0,
                                    PALETTEINDEX(6));
    TreeView_SetImageList(m_hwndTV, m_hilCheckIcons, TVSIL_STATE);

    if (FAILED(hr))
    {
        SetWindowLong(DWLP_MSGRESULT, PSNRET_INVALID);
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnContextMenu
//
//  Purpose:    Called in response to the WM_CONTEXTMENU message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    0 always
//
//  Author:     danielwe   22 Jan 1998
//
//  Notes:
//
LRESULT CBindingsDlg::OnContextMenu(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    ::WinHelp(m_hWnd,
            c_szNetCfgHelpFile,
            HELP_CONTEXTMENU,
            reinterpret_cast<ULONG_PTR>(g_aHelpIDs_IDD_ADVCFG_Bindings));
    
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnHelp
//
//  Purpose:    Called in response to the WM_HELP message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     danielwe   19 Mar 1998
//
//  Notes:
//
LRESULT CBindingsDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                           BOOL& bHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  reinterpret_cast<ULONG_PTR>(g_aHelpIDs_IDD_ADVCFG_Bindings));
    }

    return TRUE;  
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnOk
//
//  Purpose:    Called when the OK button is pressed
//
//  Arguments:
//
//  Returns:
//
//  Author:     danielwe   19 Nov 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    CWaitCursor wc;

    HRESULT hr = m_pnc->Apply();

    if (NETCFG_S_REBOOT == hr)
    {
        // On a reboot, uninitialize NetCfg since we won't be leaving
        // this function.
        //
        (VOID) m_pnc->Uninitialize();

        (VOID) HrNcQueryUserForReboot(_Module.GetResourceInstance(),
                                      m_hWnd,
                                      IDS_ADVCFG_CAPTION,
                                      IDS_REBOOT_REQUIRED,
                                      QUFR_PROMPT | QUFR_REBOOT);
    }

    // Normalize result
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceError("CBindingsDlg::OnOk", hr);
    return LresFromHr(hr);
}

//
// Binding list implementation
//

//+---------------------------------------------------------------------------
//
//  Member:     CSortableBindPath::operator <
//
//  Purpose:    Provides comparison operator for binding path depth
//
//  Arguments:
//      refsbp [in] Reference to bind path to compare with
//
//  Returns:    TRUE if given bind path depth is greater than this one
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:      The comparison is backwards on purpose so that sorting is
//              done is descending order.
//
bool CSortableBindPath::operator<(const CSortableBindPath &refsbp) const
{
    DWORD   dwLen1;
    DWORD   dwLen2;

    GetDepth(&dwLen1);
    refsbp.GetDepth(&dwLen2);

    // yes this is greater than because we want to sort in descending order
    return dwLen1 > dwLen2;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsHidden
//
//  Purpose:    Returns TRUE if the given component has the NCF_HIDDEN
//              characterstic.
//
//  Arguments:
//      pncc [in]   Component to be checked
//
//  Returns:    TRUE if component is hidden, FALSE if not
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
BOOL FIsHidden(INetCfgComponent *pncc)
{
    DWORD   dwFlags;

    return (SUCCEEDED(pncc->GetCharacteristics(&dwFlags)) &&
            ((dwFlags & NCF_HIDE_BINDING) || (dwFlags & NCF_HIDDEN)));
}

//+---------------------------------------------------------------------------
//
//  Function:   FDontExposeLower
//
//  Purpose:    Returns TRUE if the given component has the NCF_DONTEXPOSELOWER
//              characterstic.
//
//  Arguments:
//      pncc [in]   Component to be checked
//
//  Returns:    TRUE if component has DONTEXPOSELOWER, FALSE if not
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
BOOL FDontExposeLower(INetCfgComponent *pncc)
{
    DWORD   dwFlags;

    return (SUCCEEDED(pncc->GetCharacteristics(&dwFlags)) &&
            (dwFlags & NCF_DONTEXPOSELOWER));
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCountDontExposeLower
//
//  Purpose:    Counts the number of components in the given binding path
//              that have the NCF_DONTEXPOSELOWER characterstic.
//
//  Arguments:
//      pncbp  [in]  Binding path to count
//      pcItems[out] Number of components in the binding path that have the
//                   NCF_DONTEXPOSELOWER characterstic.
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
HRESULT HrCountDontExposeLower(INetCfgBindingPath *pncbp, DWORD *pcItems)
{
    HRESULT                     hr = S_OK;
    CIterNetCfgBindingInterface ncbiIter(pncbp);
    INetCfgBindingInterface *   pncbi;
    DWORD                       cItems = 0;
    DWORD                       cIter = 0;

    Assert(pcItems);

    *pcItems = 0;

    while (SUCCEEDED(hr) && S_OK == (hr = ncbiIter.HrNext(&pncbi)))
    {
        INetCfgComponent *  pncc;

        if (!cIter)
        {
            // First iteration. Get upper component first.
            hr = pncbi->GetUpperComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                if (FDontExposeLower(pncc))
                {
                    cItems++;
                }

                ReleaseObj(pncc);
            }
        }

        hr = pncbi->GetLowerComponent(&pncc);
        if (SUCCEEDED(hr))
        {
            if (FDontExposeLower(pncc))
            {
                cItems++;
            }

            ReleaseObj(pncc);
        }

        ReleaseObj(pncbi);
    }

    if (SUCCEEDED(hr))
    {
        *pcItems = cItems;
        hr = S_OK;
    }

    TraceError("HrCountDontExposeLower", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FEqualComponents
//
//  Purpose:    Compares the given 2 components to see if they are the same
//
//  Arguments:
//      pnccA [in]  First component to compare
//      pnccB [in]  Second component to compare
//
//  Returns:    TRUE if components are the same, FALSE if not
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
BOOL FEqualComponents(INetCfgComponent *pnccA, INetCfgComponent *pnccB)
{
    GUID    guidA;
    GUID    guidB;

    if (SUCCEEDED(pnccA->GetInstanceGuid(&guidA)) &&
        SUCCEEDED(pnccB->GetInstanceGuid(&guidB)))
    {
        return (guidA == guidB);
    }

    return FALSE;
}

//
// Debug functions
//

#ifdef ENABLETRACE
//+---------------------------------------------------------------------------
//
//  Function:   DbgDumpBindPath
//
//  Purpose:    Dumps the given binding path in an easy to read format
//
//  Arguments:
//      pncbp [in]  Bind path to dump
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
VOID DbgDumpBindPath(INetCfgBindingPath *pncbp)
{
    HRESULT                     hr = S_OK;
    tstring                     strPath;
    INetCfgBindingInterface *   pncbi;
    INetCfgComponent *          pncc = NULL;
    PWSTR pszwCompId;

    if ((!pncbp) || IsBadReadPtr((CONST VOID *)pncbp,
                                 sizeof(INetCfgBindingPath *)))
    {
        TraceTag(ttidAdvCfg, "Bind path is invalid!");
        return;
    }

    CIterNetCfgBindingInterface ncbiIter(pncbp);

    while (SUCCEEDED(hr) && S_OK == (hr = ncbiIter.HrNext(&pncbi)))
    {
        if (strPath.empty())
        {
            hr = pncbi->GetUpperComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                hr = pncc->GetId(&pszwCompId);
                if (SUCCEEDED(hr))
                {
                    strPath = pszwCompId;
                    CoTaskMemFree(pszwCompId);
                }
                ReleaseObj(pncc);
                pncc = NULL;
            }
        }
        hr = pncbi->GetLowerComponent(&pncc);
        if (SUCCEEDED(hr))
        {
            hr = pncc->GetId(&pszwCompId);
            if (SUCCEEDED(hr))
            {
                strPath += L" -> ";
                strPath += pszwCompId;

                CoTaskMemFree(pszwCompId);
            }
            ReleaseObj(pncc);
        }
        ReleaseObj(pncbi);
    }

    if (SUCCEEDED(hr))
    {
        TraceTag(ttidAdvCfg, "Address = 0x%08lx, Path is '%S'",
                 pncbp, strPath.c_str());
    }
    else
    {
        TraceTag(ttidAdvCfg, "Error dumping binding path.");
    }

}

VOID DbgDumpTreeViewItem(HWND hwndTV, HTREEITEM hti)
{
    WCHAR       szText[256];
    TV_ITEM     tvi;

    if (hti)
    {
        tvi.hItem = hti;
        tvi.pszText = szText;
        tvi.cchTextMax = celems(szText);
        tvi.mask = TVIF_TEXT;
        TreeView_GetItem(hwndTV, &tvi);

        TraceTag(ttidAdvCfg, "TreeView item is %S.", szText);
    }
    else
    {
        TraceTag(ttidAdvCfg, "TreeView item is NULL");
    }
}

#endif //ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\netcfg\snetcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S N E T C F G . C P P
//
//  Contents:   Sample code that demonstrates how to:
//              - find out if a component is installed
//              - install a net component
//              - install an OEM net component
//              - uninstall a net component
//              - enumerate net components
//              - enumerate net adapters using Setup API
//              - enumerate binding paths of a component
//
//  Notes:
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "snetcfg.h"


//----------------------------------------------------------------------------
// Globals
//
static const GUID* c_aguidClass[] =
{
    &GUID_DEVCLASS_NET,
    &GUID_DEVCLASS_NETTRANS,
    &GUID_DEVCLASS_NETSERVICE,
    &GUID_DEVCLASS_NETCLIENT
};

//----------------------------------------------------------------------------
// Prototypes of helper functions
//
HRESULT HrInstallNetComponent(IN INetCfg* pnc, IN PCWSTR szComponentId,
                              IN const GUID* pguidClass);
HRESULT HrUninstallNetComponent(IN INetCfg* pnc, IN PCWSTR szComponentId);
HRESULT HrGetINetCfg(IN BOOL fGetWriteLock, INetCfg** ppnc);
HRESULT HrReleaseINetCfg(BOOL fHasWriteLock, INetCfg* pnc);
void ShowMessage(IN PCWSTR szMsg, ...);
void ShowHrMessage(IN HRESULT hr);
inline ULONG ReleaseObj(IUnknown* punk)
{
    return (punk) ? punk->Release () : 0;
}


//+---------------------------------------------------------------------------
//
// Function:  HrIsComponentInstalled
//
// Purpose:   Find out if a component is installed
//
// Arguments:
//    szComponentId [in]  id of component to search
//
// Returns:   S_OK    if installed,
//            S_FALSE if not installed,
//            otherwise an error code
//
// Author:    kumarp 11-February-99
//
// Notes:
//
HRESULT HrIsComponentInstalled(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    INetCfg* pnc;
    INetCfgComponent* pncc;

    hr = HrGetINetCfg(FALSE, &pnc);
    if (S_OK == hr)
    {
        hr = pnc->FindComponent(szComponentId, &pncc);
        if (S_OK == hr)
        {
            ReleaseObj(pncc);
        }
        (void) HrReleaseINetCfg(FALSE, pnc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  FindIfComponentInstalled
//
// Purpose:   Find out if a component is installed
//
// Arguments:
//    szComponentId [in]  id of component to locate
//
// Returns:   None
//
// Author:    kumarp 11-February-99
//
// Notes:
//
void FindIfComponentInstalled(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;

    hr = HrIsComponentInstalled(szComponentId);
    if (S_OK == hr)
    {
        _tprintf(L"'%s' is installed\n", szComponentId);
    }
    else if (S_FALSE == hr)
    {
        _tprintf(L"'%s' is not installed\n", szComponentId);
    }
    else
    {
        _tprintf(L"Could not find if '%s' is installed. error code: 0x%x\n",
                 szComponentId, hr);
    }
}

//+---------------------------------------------------------------------------
//
// Function:  HrInstallNetComponent
//
// Purpose:   Install the specified net component
//
// Arguments:
//    szComponentId [in]  component to install
//    nc            [in]  class of the component
//    szInfFullPath [in]  full path to primary INF file
//                        required if the primary INF and other
//                        associated files are not pre-copied to
//                        the right destination dirs.
//                        Not required when installing MS components
//                        since the files are pre-copied by
//                        Windows NT Setup.
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrInstallNetComponent(IN PCWSTR szComponentId,
                              IN enum NetClass nc,
                              IN PCWSTR szInfFullPath)
{
    HRESULT hr=S_OK;
    INetCfg* pnc;

    // cannot install net adapters this way. they have to be
    // enumerated/detected and installed by PnP

    if ((nc == NC_NetProtocol) ||
        (nc == NC_NetService) ||
        (nc == NC_NetClient))
    {
        ShowMessage(L"Trying to install '%s'...", szComponentId);

        // if full path to INF has been specified, the INF
        // needs to be copied using Setup API to ensure that any other files
        // that the primary INF copies will be correctly found by Setup API
        //
        if (szInfFullPath && wcslen(szInfFullPath))
        {
            WCHAR szInfNameAfterCopy[MAX_PATH+1];
            if (SetupCopyOEMInf(
                    szInfFullPath,
                    NULL,               // other files are in the
                                        // same dir. as primary INF
                    SPOST_PATH,         // first param. contains path to INF
                    0,                  // default copy style
                    szInfNameAfterCopy, // receives the name of the INF
                                        // after it is copied to %windir%\inf
                    MAX_PATH,           // max buf. size for the above
                    NULL,               // receives required size if non-null
                    NULL))              // optionally retrieves filename
                                        // component of szInfNameAfterCopy
            {
                ShowMessage(L"...%s was copied to %s",
                            szInfFullPath,
                            szInfNameAfterCopy);
            }
            else
            {
                DWORD dwError = GetLastError();
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }

        if (S_OK == hr)
        {
            // get INetCfg interface
            hr = HrGetINetCfg(TRUE, &pnc);

            if (SUCCEEDED(hr))
            {
                // install szComponentId
                hr = HrInstallNetComponent(pnc, szComponentId,
                                           c_aguidClass[nc]);
                if (SUCCEEDED(hr))
                {
                    // Apply the changes
                    hr = pnc->Apply();
                }

                // release INetCfg
                (void) HrReleaseINetCfg(TRUE, pnc);
            }
        }
        // show success/failure message
        ShowHrMessage(hr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrInstallNetComponent
//
// Purpose:   Install the specified net component
//
// Arguments:
//    pnc           [in]  pointer to INetCfg object
//    szComponentId [in]  component to install
//    pguidClass    [in]  class guid of the component
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrInstallNetComponent(IN INetCfg* pnc,
                              IN PCWSTR szComponentId,
                              IN const GUID* pguidClass)
{
    HRESULT hr=S_OK;
    OBO_TOKEN OboToken;
    INetCfgClassSetup* pncClassSetup;
    INetCfgComponent* pncc;

    // OBO_TOKEN specifies the entity on whose behalf this
    // component is being installed

    // set it to OBO_USER so that szComponentId will be installed
    // On-Behalf-Of "user"
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    hr = pnc->QueryNetCfgClass (pguidClass, IID_INetCfgClassSetup,
                                (void**)&pncClassSetup);
    if (SUCCEEDED(hr))
    {
        hr = pncClassSetup->Install(szComponentId,
                                    &OboToken,
                                    NSF_POSTSYSINSTALL,
                                    0,       // <upgrade-from-build-num>
                                    NULL,    // answerfile name
                                    NULL,    // answerfile section name
                                    &pncc);
        if (S_OK == hr)
        {
            // we dont want to use pncc (INetCfgComponent), release it
            ReleaseObj(pncc);
        }

        ReleaseObj(pncClassSetup);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrUninstallNetComponent
//
// Purpose:   Initialize INetCfg and uninstall a component
//
// Arguments:
//    szComponentId [in]  InfId of component to uninstall (e.g. MS_TCPIP)
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrUninstallNetComponent(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    INetCfg* pnc;

    ShowMessage(L"Trying to uninstall '%s'...", szComponentId);

    // get INetCfg interface
    hr = HrGetINetCfg(TRUE, &pnc);

    if (SUCCEEDED(hr))
    {
        // uninstall szComponentId
        hr = HrUninstallNetComponent(pnc, szComponentId);

        if (S_OK == hr)
        {
            // Apply the changes
            hr = pnc->Apply();
        }
        else if (S_FALSE == hr)
        {
            ShowMessage(L"...'%s' is not installed", szComponentId);
        }

        // release INetCfg
        (void) HrReleaseINetCfg(TRUE, pnc);
    }

    // show success/failure message
    ShowHrMessage(hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrUninstallNetComponent
//
// Purpose:   Uninstall the specified component.
//
// Arguments:
//    pnc           [in]  pointer to INetCfg object
//    szComponentId [in]  component to uninstall
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrUninstallNetComponent(IN INetCfg* pnc, IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    OBO_TOKEN OboToken;
    INetCfgComponent* pncc;
    GUID guidClass;
    INetCfgClass* pncClass;
    INetCfgClassSetup* pncClassSetup;

    // OBO_TOKEN specifies the entity on whose behalf this
    // component is being uninstalld

    // set it to OBO_USER so that szComponentId will be uninstalld
    // On-Behalf-Of "user"
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    // see if the component is really installed
    hr = pnc->FindComponent(szComponentId, &pncc);

    if (S_OK == hr)
    {
        // yes, it is installed. obtain INetCfgClassSetup and DeInstall

        hr = pncc->GetClassGuid(&guidClass);

        if (S_OK == hr)
        {
            hr = pnc->QueryNetCfgClass(&guidClass, IID_INetCfgClass,
                                       (void**)&pncClass);
            if (SUCCEEDED(hr))
            {
                hr = pncClass->QueryInterface(IID_INetCfgClassSetup,
                                              (void**)&pncClassSetup);
                    if (SUCCEEDED(hr))
                    {
                        hr = pncClassSetup->DeInstall (pncc, &OboToken, NULL);

                        ReleaseObj (pncClassSetup);
                    }
                ReleaseObj(pncClass);
            }
        }
        ReleaseObj(pncc);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  HrShowNetAdapters
//
// Purpose:   Display all installed net class devices using Setup API
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowNetAdapters()
{
#define MAX_COMP_INSTID 4096
#define MAX_COMP_DESC   4096

    HRESULT hr=S_OK;
    HDEVINFO hdi;
    DWORD dwIndex=0;
    SP_DEVINFO_DATA deid;
    BOOL fSuccess=FALSE;
    DWORD   cchRequiredSize;
    WCHAR szCompInstanceId[MAX_COMP_INSTID];
    WCHAR szCompDescription[MAX_COMP_DESC];
    DWORD dwRegType;
    BOOL fFound=FALSE;

    // get a list of all devices of class 'GUID_DEVCLASS_NET'
    hdi = SetupDiGetClassDevs(&GUID_DEVCLASS_NET, NULL, NULL, DIGCF_PRESENT);

    if (INVALID_HANDLE_VALUE != hdi)
    {
        // enumerate over each device
        while (deid.cbSize = sizeof(SP_DEVINFO_DATA),
               SetupDiEnumDeviceInfo(hdi, dwIndex, &deid))
        {
            dwIndex++;

            // the right thing to do here would be to call this function
            // to get the size required to hold the instance ID and then
            // to call it second time with a buffer large enough for that size.
            // However, that would tend to obscure the control flow in
            // the sample code. Lets keep things simple by keeping the
            // buffer large enough.

            // get the device instance ID
            fSuccess = SetupDiGetDeviceInstanceId(hdi, &deid,
                                                  szCompInstanceId,
                                                  MAX_COMP_INSTID, NULL);
            if (fSuccess)
            {
                // get the description for this instance
                fSuccess =
                    SetupDiGetDeviceRegistryProperty(hdi, &deid,
                                                     SPDRP_DEVICEDESC,
                                                     &dwRegType,
                                                     (BYTE*) szCompDescription,
                                                     MAX_COMP_DESC,
                                                     NULL);
                if (fSuccess)
                {
                    if (!fFound)
                    {
                        fFound = TRUE;
                        _tprintf(L"Instance ID\tDescription\n");
                        _tprintf(L"-----------\t-----------\n");
                    }
                    _tprintf(L"%s\t%s\n",
                             szCompInstanceId, szCompDescription);
                }
            }
        }

        // release the device info list
        SetupDiDestroyDeviceInfoList(hdi);
    }

    if (!fSuccess)
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrShowNetComponents
//
// Purpose:   Display the list of installed components of the
//            specified class.
//
// Arguments:
//    pnc        [in]  pointer to INetCfg object
//    pguidClass [in]  pointer to class GUID
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowNetComponents(IN INetCfg* pnc,
                            IN const GUID* pguidClass)
{
    HRESULT hr=S_OK;
    PWSTR szInfId;
    PWSTR szDisplayName;
    DWORD dwcc;
    INetCfgComponent* pncc;
    INetCfgClass* pncclass;
    IEnumNetCfgComponent* pencc;
    ULONG celtFetched;

    hr = pnc->QueryNetCfgClass(pguidClass, IID_INetCfgClass,
                               (void**)&pncclass);
    if (SUCCEEDED(hr))
    {
        // get IEnumNetCfgComponent so that we can enumerate
        hr = pncclass->EnumComponents(&pencc);

        ReleaseObj(pncclass);

        while (SUCCEEDED(hr) &&
               (S_OK == (hr = pencc->Next(1, &pncc, &celtFetched))))
        {
            if (pguidClass == &GUID_DEVCLASS_NET)
            {
                // we are interested only in physical netcards
                //
                hr = pncc->GetCharacteristics(&dwcc);

                if (FAILED(hr) || !(dwcc & NCF_PHYSICAL))
                {
                    hr = S_OK;
                    ReleaseObj(pncc);
                    continue;
                }
            }

            hr = pncc->GetId(&szInfId);

            if (S_OK == hr)
            {
                hr = pncc->GetDisplayName(&szDisplayName);
                if (SUCCEEDED(hr))
                {
                    _tprintf(L"%-26s %s\n", szInfId, szDisplayName);

                    CoTaskMemFree(szDisplayName);
                }
                CoTaskMemFree(szInfId);
            }
            // we dont want to stop enumeration just because 1 component
            // failed either GetId or GetDisplayName, therefore reset hr to S_OK
            hr = S_OK;

            ReleaseObj(pncc);
        }
        ReleaseObj(pencc);
    }


    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  HrShowNetComponents
//
// Purpose:   Display installed net components.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowNetComponents()
{
    HRESULT hr=S_OK;
    PCWSTR szClassName;

    static const PCWSTR c_aszClassNames[] =
    {
        L"Network Adapters",
        L"Network Protocols",
        L"Network Services",
        L"Network Clients"
    };

    INetCfg* pnc;

    // get INetCfg interface
    hr = HrGetINetCfg(FALSE, &pnc);

    if (SUCCEEDED(hr))
    {
        for (int i=0; i<4; i++)
        {
            _tprintf(L"\n%s\n-----------------\n", c_aszClassNames[i]);

            (void) HrShowNetComponents(pnc, c_aguidClass[i]);
        }

        // release INetCfg
        hr = HrReleaseINetCfg(FALSE, pnc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetNextBindingInterface
//
// Purpose:   Enumerate over binding interfaces that constitute
//            the given binding path
//
// Arguments:
//    pncbp  [in]  pointer to INetCfgBindingPath object
//    ppncbi [out] pointer to pointer to INetCfgBindingInterface object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrGetNextBindingInterface(IN  INetCfgBindingPath* pncbp,
                                  OUT INetCfgBindingInterface** ppncbi)
{
    HRESULT hr=S_OK;
    INetCfgBindingInterface* pncbi=NULL;

    static IEnumNetCfgBindingInterface* pencbi=NULL;

    *ppncbi = NULL;

    // if this is the first call in the enumeration, obtain
    // the IEnumNetCfgBindingInterface interface
    //
    if (!pencbi)
    {
        hr = pncbp->EnumBindingInterfaces(&pencbi);
    }

    if (S_OK == hr)
    {
        ULONG celtFetched;

        // get next binding interface
        hr = pencbi->Next(1, &pncbi, &celtFetched);
    }

    // on the last call (hr == S_FALSE) or on error, release resources

    if (S_OK == hr)
    {
        *ppncbi = pncbi;
    }
    else
    {
        ReleaseObj(pencbi);
        pencbi = NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetNextBindingPath
//
// Purpose:   Enumerate over binding paths that start with
//            the specified component
//
// Arguments:
//    pncc              [in]  pointer to INetCfgComponent object
//    dwBindingPathType [in]  type of binding path to retrieve
//    ppncbp            [out] pointer to INetCfgBindingPath interface
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrGetNextBindingPath(IN  INetCfgComponent* pncc,
                             IN  DWORD  dwBindingPathType,
                             OUT INetCfgBindingPath** ppncbp)
{
    HRESULT hr=S_OK;
    INetCfgBindingPath* pncbp=NULL;

    static IEnumNetCfgBindingPath* pebp=NULL;

    *ppncbp = NULL;

    // if this is the first call in the enumeration, obtain
    // the IEnumNetCfgBindingPath interface
    if (!pebp)
    {
        INetCfgComponentBindings* pnccb=NULL;

        hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                                  (void**) &pnccb);
        if (S_OK == hr)
        {
            hr = pnccb->EnumBindingPaths(dwBindingPathType, &pebp);
            ReleaseObj(pnccb);
        }
    }

    if (S_OK == hr)
    {
        ULONG celtFetched;

        // get next binding path
        hr = pebp->Next(1, &pncbp, &celtFetched);
    }

    // on the last call (hr == S_FALSE) or on error, release resources

    if (S_OK == hr)
    {
        *ppncbp = pncbp;
    }
    else
    {
        ReleaseObj(pebp);
        pebp = NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrShowBindingPath
//
// Purpose:   Display components of a binding path in the format:
//            foo -> bar -> adapter
//
// Arguments:
//    pncbp [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowBindingPath(IN INetCfgBindingPath* pncbp)
{
    HRESULT hr=S_OK;
    INetCfgBindingInterface* pncbi;
    INetCfgComponent* pncc = NULL;
    BOOL fFirstInterface=TRUE;
    PWSTR szComponentId;

    while (SUCCEEDED(hr) &&
           (S_OK == (hr = HrGetNextBindingInterface(pncbp, &pncbi))))
    {
        // for the first (top) interface we need to get the upper as well as
        // the lower component. for other interfaces we need to get
        // only the lower component.

        if (fFirstInterface)
        {
            fFirstInterface = FALSE;
            hr = pncbi->GetUpperComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                // get id so that we can display it
                //
                // for readability of the output, we have used the GetId
                // function. For non net class components, this
                // does not pose a problem. In case of net class components,
                // there may be more than one net adapters of the same type
                // in which case, GetId will return the same string. This will
                // make it impossible to distinguish between two binding
                // paths that end in two distinct identical cards. In such case,
                // it may be better to use the GetInstanceGuid function because
                // it will return unique GUID for each instance of an adapter.
                //
                hr = pncc->GetId(&szComponentId);
                ReleaseObj(pncc);
                if (SUCCEEDED(hr))
                {
                    _tprintf(szComponentId);
                    CoTaskMemFree(szComponentId);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pncbi->GetLowerComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                hr = pncc->GetId(&szComponentId);
                if (SUCCEEDED(hr))
                {
                    _tprintf(L" -> %s", szComponentId);
                    CoTaskMemFree(szComponentId);
                }
                ReleaseObj(pncc);
            }
        }
        ReleaseObj(pncbi);
    }

    _tprintf(L"\n");

    if (hr == S_FALSE)
    {
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrShowBindingPathsBelowComponent
//
// Purpose:   Display all binding paths that start with
//            the specified component
//
// Arguments:
//    szComponentId [in]  id of given component (e.g. MS_TCPIP)
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowBindingPathsOfComponent(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    INetCfg* pnc=NULL;
    INetCfgComponent* pncc=NULL;
    INetCfgBindingPath* pncbp=NULL;

    // get INetCfg interface
    hr = HrGetINetCfg(FALSE, &pnc);

    if (SUCCEEDED(hr))
    {
        // get INetCfgComponent for szComponentId
        hr = pnc->FindComponent(szComponentId, &pncc);
        if (S_OK == hr)
        {
            _tprintf(L"Binding paths starting with '%s'\n\n",
                     szComponentId);

            while (S_OK == (hr = HrGetNextBindingPath(pncc, EBP_BELOW,
                                                      &pncbp)))
            {
                // display the binding path
                hr = HrShowBindingPath(pncbp);
                ReleaseObj(pncbp);
            }

            _tprintf(L"Binding paths ending with '%s'\n\n",
                     szComponentId);

            while (S_OK == (hr = HrGetNextBindingPath(pncc, EBP_ABOVE,
                                                      &pncbp)))
            {
                // display the binding path
                hr = HrShowBindingPath(pncbp);
                ReleaseObj(pncbp);
            }

            ReleaseObj(pncc);
        }
        // release INetCfg
        hr = HrReleaseINetCfg(FALSE, pnc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetINetCfg
//
// Purpose:   Initialize COM, create and initialize INetCfg.
//            Obtain write lock if indicated.
//
// Arguments:
//    fGetWriteLock [in]  whether to get write lock
//    ppnc          [in]  pointer to pointer to INetCfg object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrGetINetCfg(IN BOOL fGetWriteLock,
                     INetCfg** ppnc)
{
    HRESULT hr=S_OK;

    // Initialize the output parameters.
    *ppnc = NULL;

    // initialize COM
    hr = CoInitializeEx(NULL,
                        COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );

    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                              IID_INetCfg, (void**)&pnc);
        if (SUCCEEDED(hr))
        {
            INetCfgLock * pncLock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->QueryInterface(IID_INetCfgLock,
                                         (LPVOID *)&pncLock);
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    static const ULONG c_cmsTimeout = 15000;
                    static const WCHAR c_szSampleNetcfgApp[] =
                        L"Sample Netcfg Application (netcfg.exe)";
                    PWSTR szLockedBy;

                    hr = pncLock->AcquireWriteLock(c_cmsTimeout,
                                                   c_szSampleNetcfgApp,
                                                   &szLockedBy);
                    if (S_FALSE == hr)
                    {
                        hr = NETCFG_E_NO_WRITE_LOCK;
                        _tprintf(L"Could not lock INetcfg, it is already locked by '%s'", szLockedBy);
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->Initialize(NULL);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    pnc->AddRef();
                }
                else
                {
                    // initialize failed, if obtained lock, release it
                    if (pncLock)
                    {
                        pncLock->ReleaseWriteLock();
                    }
                }
            }
            ReleaseObj(pncLock);
            ReleaseObj(pnc);
        }

        if (FAILED(hr))
        {
            CoUninitialize();
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrReleaseINetCfg
//
// Purpose:   Uninitialize INetCfg, release write lock (if present)
//            and uninitialize COM.
//
// Arguments:
//    fHasWriteLock [in]  whether write lock needs to be released.
//    pnc           [in]  pointer to INetCfg object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrReleaseINetCfg(BOOL fHasWriteLock, INetCfg* pnc)
{
    HRESULT hr = S_OK;

    // uninitialize INetCfg
    hr = pnc->Uninitialize();

    // if write lock is present, unlock it
    if (SUCCEEDED(hr) && fHasWriteLock)
    {
        INetCfgLock* pncLock;

        // Get the locking interface
        hr = pnc->QueryInterface(IID_INetCfgLock,
                                 (LPVOID *)&pncLock);
        if (SUCCEEDED(hr))
        {
            hr = pncLock->ReleaseWriteLock();
            ReleaseObj(pncLock);
        }
    }

    ReleaseObj(pnc);

    CoUninitialize();

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  ShowMessage
//
// Purpose:   Helper function to display a message in verbose mode.
//            If not in verbose mode, do nothing.
//
// Arguments:
//    szMsg [in]  message to display
//
// Returns:   None
//
// Notes:
//
void ShowMessage(IN PCWSTR szMsg, ...)
{
    extern BOOL g_fVerbose;

    if (g_fVerbose)
    {
        va_list arglist;

        va_start(arglist, szMsg);
        _vtprintf(szMsg, arglist);
        _tprintf(L"\n");
        fflush(stdout);
        va_end(arglist);
    }
}

//+---------------------------------------------------------------------------
//
// Function:  ShowHrMessage
//
// Purpose:   Helper function to display the status of the last action
//            as indicated by the given HRESULT
//
// Arguments:
//    hr [in]  status code
//
// Returns:   None
//
// Notes:
//
void ShowHrMessage(IN HRESULT hr)
{
    if (SUCCEEDED(hr))
    {
        ShowMessage(L"...done");
        if (NETCFG_S_REBOOT == hr)
        {
            ShowMessage(L"*** You need to reboot your computer for this change to take effect ***");
        }
    }
    else
    {
        ShowMessage(L"..failed. Error code: 0x%lx", hr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\advcfg\acbind.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A D V C F G P . H
//
//  Contents:   Private header for Advanced Configuration dialog
//
//  Notes:
//
//  Author:     danielwe   20 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nsbase.h"

#include "ncatlps.h"
#include "netcfgx.h"
#include "resource.h"

//
// image state entries
//

enum SELS_MASKS
{
    SELS_CHECKED         = 0x1,
    SELS_UNCHECKED       = 0x2,
    SELS_FIXEDBINDING_DISABLED = 0x3,
    SELS_FIXEDBINDING_ENABLED  = 0x4,
};

enum MAB_DIRECTION
{
    MAB_UP      =   1,
    MAB_DOWN    =   2,
};

class CSortableBindPath;

typedef list<CSortableBindPath>     SBP_LIST;

enum ASSOCIATE_FLAGS
{
    ASSCF_ON_ENABLE     = 0x1,
    ASSCF_ON_DISABLE    = 0x2,
    ASSCF_ANCESTORS     = 0x8,
};

struct BIND_PATH_INFO
{
    INetCfgBindingPath *    pncbp;
    DWORD                   dwLength;
};

typedef list<BIND_PATH_INFO *>      BPIP_LIST;
typedef list<INetCfgComponent *>    NCC_LIST;
typedef list<INetCfgBindingPath *>  NCBP_LIST;

struct TREE_ITEM_DATA
{
    INetCfgComponent *  pncc;
    BPIP_LIST           listbpipOnEnable;
    BPIP_LIST           listbpipOnDisable;
    BOOL                fOrdered;
};

struct HTREEITEMP
{
    HTREEITEM   hti;
};

typedef list<HTREEITEMP>     HTI_LIST;

//
// CBindingsDlg
//

class CBindingsDlg: public CPropSheetPage
{
    BEGIN_MSG_MAP(CBindingsDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
        COMMAND_ID_HANDLER(PSB_Adapter_Up, OnAdapterUp)
        COMMAND_ID_HANDLER(PSB_Adapter_Down, OnAdapterDown)
        COMMAND_ID_HANDLER(PSB_Binding_Up, OnBindingUp)
        COMMAND_ID_HANDLER(PSB_Binding_Down, OnBindingDown)
        NOTIFY_CODE_HANDLER(TVN_DELETEITEM, OnTreeDeleteItem)
        NOTIFY_CODE_HANDLER(TVN_KEYDOWN, OnTreeKeyDown)
        NOTIFY_CODE_HANDLER(TVN_ITEMEXPANDING, OnTreeItemExpanding)
        NOTIFY_CODE_HANDLER(TVN_SELCHANGED, OnTreeItemChanged)
        NOTIFY_CODE_HANDLER(LVN_DELETEITEM, OnListDeleteItem)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnListItemChanged)
        NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDoubleClick)
        NOTIFY_CODE_HANDLER(NM_CLICK, OnClick)
    END_MSG_MAP()

    enum {IDD = IDD_Advanced_Config};

    CBindingsDlg(INetCfg *pnc)
    {
        AddRefObj(m_pnc = pnc);

        m_hiconUpArrow = NULL;
        m_hiconDownArrow = NULL;
        m_iItemSel = -1;
        m_hilItemIcons = NULL;
        m_hilCheckIcons = NULL;
        m_fWanBindingsFirst = FALSE;
    }

    ~CBindingsDlg();

    BOOL FShowPage()
    {
        return TRUE;
    }

private:
    INetCfg *       m_pnc;
    HWND            m_hwndLV;
    HWND            m_hwndTV;
    HICON           m_hiconUpArrow;
    HICON           m_hiconDownArrow;
    HIMAGELIST      m_hilItemIcons;
    HIMAGELIST      m_hilCheckIcons;
    INT             m_iItemSel;
    BOOL            m_fWanBindingsFirst;
    INT             m_nIndexLan;

    //
    // Message handlers
    //
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnAdapterUp(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnAdapterDown(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                          BOOL& bHandled);
    LRESULT OnBindingUp(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnBindingDown(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                          BOOL& bHandled);
    VOID OnAdapterUpDown(BOOL fUp);
    LRESULT OnListItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnTreeItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnTreeDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnListDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnTreeItemExpanding(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnTreeKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnDoubleClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    //
    // Adapter list functions
    //
    VOID OnAdapterChange(INT iItem);
    HRESULT HrBuildAdapterList(VOID);
    HRESULT HrGetAdapters(INetCfgComponent *pncc, NCC_LIST *plistNcc);
    VOID SetAdapterButtons();
    VOID AddListViewItem(INetCfgComponent *pncc, INT ipos, INT nIndex,
                         PCWSTR pszConnName);
    BOOL FIsWanBinding(INT iItem);
    VOID GetWanOrdering(VOID);
    VOID SetWanOrdering(VOID);

    //
    // Bindings tree functions
    //

    VOID SetCheckboxStates(VOID);
    VOID ToggleCheckbox(HTREEITEM hti);
    VOID OnBindingUpDown(BOOL fUp);
    HRESULT HrOrderSubItems(VOID);
    HRESULT HrOrderDisableLists(VOID);
    HRESULT HrOrderDisableList(TREE_ITEM_DATA *ptid);
    HTREEITEM HtiMoveTreeItemAfter(HTREEITEM htiParent, HTREEITEM htiDest,
                                   HTREEITEM htiSrc);
    VOID BuildBindingsList(INetCfgComponent *pncc);

    HRESULT HrHandleSubpath(SBP_LIST &listsbp, INetCfgBindingPath *pncbpSub);
    HRESULT HrHandleSubItem(INetCfgBindingPath *pncbpThis,
                            INetCfgBindingPath *pncbpMatch,
                            TREE_ITEM_DATA *ptid,
                            HTREEITEM htiMatchItem);
    HRESULT HrHandleValidSubItem(INetCfgBindingPath *pncbpThis,
                                 INetCfgBindingPath *pncbpMatch,
                                 INetCfgComponent *pnccThisOwner,
                                 HTREEITEM htiMatchItem,
                                 TREE_ITEM_DATA *ptid);
    HRESULT HrHandleTopLevel(INetCfgBindingPath *pncbpSub);
    HRESULT HrComponentIsHidden(INetCfgBindingPath *pncbp, DWORD iComp);
    HTREEITEM HtiAddTreeViewItem(INetCfgComponent * pnccOwner,
                                 HTREEITEM htiParent);
    VOID AssociateBinding(INetCfgBindingPath *pncbpThis, HTREEITEM hti,
                          DWORD dwFlags);
    HTREEITEM HtiIsSubItem(INetCfgComponent *pncc, HTREEITEM hti);
    VOID MoveAdapterBindings(INetCfgComponent *pnccSrc,
                             INetCfgComponent *pnccDst,
                             MAB_DIRECTION mabDir);
    LRESULT OnClickOrDoubleClick(int idCtrl, LPNMHDR pnmh, BOOL fDoubleClick);
};

DWORD
GetDepthSpecialCase (
    INetCfgBindingPath* pPath);

class CSortableBindPath
{
public:
    CSortableBindPath()
    {
        AssertSzH(FALSE,"Don't use this constructor!");
    }

    CSortableBindPath(INetCfgBindingPath *pncbp)
    {
        m_pncbp = pncbp;
    }

    bool operator<(const CSortableBindPath &refsbp) const;

    VOID GetDepth(DWORD *pdwDepth) const
    {
        *pdwDepth = GetDepthSpecialCase (m_pncbp);
    }

    INetCfgBindingPath *GetPath() const
    {
        return m_pncbp;
    }

private:
    INetCfgBindingPath *    m_pncbp;
};

class CIterTreeView
{
public:
    CIterTreeView(HWND hwndTV)
    {
        m_hwndTV = hwndTV;
        Reset();
    }

    HTREEITEM HtiNext();
    VOID Reset()
    {
        HTREEITEM   hti;

        EraseAndDeleteAll();
        hti = TreeView_GetRoot(m_hwndTV);
        if (hti)
        {
            HTREEITEMP  htip = {hti};
            m_stackHti.push_front(htip);
        }
    }

    HTREEITEM Front()
    {
        HTREEITEMP htip;

        if (m_stackHti.empty())
        {
            return NULL;
        }

        htip = m_stackHti.front();
        return htip.hti;
    }

    VOID PopAndDelete()
    {
        m_stackHti.pop_front();
    }

    VOID PushAndAlloc(HTREEITEM hti)
    {
        AssertSzH(hti, "Pushing NULL? Shame on you!");

        HTREEITEMP htip = {hti};
        m_stackHti.push_front(htip);
    }

    VOID EraseAndDeleteAll()
    {
        while (!m_stackHti.empty())
        {
            PopAndDelete();
        }
    }

private:
    HWND        m_hwndTV;
    HTI_LIST    m_stackHti;
};

BOOL FIsHidden(INetCfgComponent *pncc);
BOOL FDontExposeLower(INetCfgComponent *pncc);
VOID AddToListIfNotAlreadyAdded(BPIP_LIST &bpipList, BIND_PATH_INFO *pbpi);
VOID FreeBindPathInfoList(BPIP_LIST &listbpip);
HRESULT HrCountDontExposeLower(INetCfgBindingPath *pncbp, DWORD *pcItems);
BOOL FEqualComponents(INetCfgComponent *pnccA, INetCfgComponent *pnccB);
VOID ChangeTreeItemParam(HWND hwndTV,  HTREEITEM hitem, LPARAM lparam);
BIND_PATH_INFO *BpiFindBindPathInList(INetCfgBindingPath *pncbp,
                                      BPIP_LIST &listBpip);
VOID ChangeListItemParam(HWND hwndLV, INT iItem, LPARAM lParam);

#ifdef ENABLETRACE
VOID DbgDumpBindPath(INetCfgBindingPath *pncbp);
VOID DbgDumpTreeViewItem(HWND hwndTV, HTREEITEM hti);
#else
#define DbgDumpBindPath(x)
#define DbgDumpTreeViewItem(x,y)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\oemupg\oemupg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT5.0
//  Copyright (C) Microsoft Corporation, 1997, 1998.
//
//  File:       O E M U P G . C P P
//
//  Contents:   Sample code for OEM network component upgrade DLL
//
//  Notes:
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

// oemupgex.h is a part of the DDK
#include "oemupgex.h"

HMODULE g_hNetupgrdDll;
NetUpgradeAddSectionPrototype       g_pfnNuAddSection;
NetUpgradeAddLineToSectionPrototype g_pfnNuAddLineToSection;

VENDORINFO g_viOem =
{
    L"Foo Inc.",
    L"(123) 456 7890",
    L"http://www.foo.com",
    L"Please visit our website for further information"
};

EXTERN_C LONG  __stdcall
PreUpgradeInitialize(IN  PCWSTR         szWorkingDir,
                     IN  NetUpgradeInfo* pNetUpgradeInfo,
                     OUT VENDORINFO*     pviVendorInfo,
                     OUT DWORD*          pdwFlags,
                     OUT NetUpgradeData* pNetUpgradeData)
{
    DWORD dwError=ERROR_SUCCESS;

    // get function address of the two exported functions
    // for writing into the answerfile
    //
    g_hNetupgrdDll = GetModuleHandle(L"netupgrd.dll");

    if (g_hNetupgrdDll)
    {
        g_pfnNuAddSection =
            (NetUpgradeAddSectionPrototype)
            GetProcAddress(g_hNetupgrdDll, c_szNetUpgradeAddSection);

        g_pfnNuAddLineToSection =
            (NetUpgradeAddLineToSectionPrototype)
            GetProcAddress(g_hNetupgrdDll, c_szNetUpgradeAddLineToSection);

        if (!g_pfnNuAddSection || !g_pfnNuAddLineToSection)
        {
            // this should never occur
            //
            dwError = ERROR_CALL_NOT_IMPLEMENTED;
        }
    }

    return dwError;
}

EXTERN_C LONG  __stdcall
DoPreUpgradeProcessing(IN   HWND    hParentWindow,
                       IN   HKEY    hkeyParams,
                       IN   PCWSTR szPreNT5InfId,
                       IN   PCWSTR szPreNT5Instance,
                       IN   PCWSTR szNT5InfId,
                       IN   PCWSTR szSectionName,
                       OUT  VENDORINFO* pviVendorInfo,
                       OUT  DWORD*  pdwFlags,
                       IN   LPVOID  pvReserved)
{
    DWORD dwError=ERROR_SUCCESS;
    WCHAR szTempSection[256];
    WCHAR szTempLine[256];

    // set the flag so that we will get loaded during GUI setup
    *pdwFlags |= NUA_LOAD_POST_UPGRADE;

    if (g_pfnNuAddSection && g_pfnNuAddLineToSection)
    {
        // add the top level section
        //
        g_pfnNuAddSection(szSectionName);

        // add the mandatory key InfToRunBeforeInstall
        //
        // note: here it is assumed that the OEM also supplies a file foocopy.inf
        //       and that it has a section named foo.CopyFiles
        //
        swprintf(szTempLine, L"%s=foocopy.inf,foo.CopyFiles",
                  c_szInfToRunBeforeInstall);
        g_pfnNuAddLineToSection(szSectionName, szTempLine);

        // add the optional key InfToRunAfterInstall
        //
        swprintf(szTempLine, L"%s=,%s.SectionToRun",
                  c_szInfToRunAfterInstall, szSectionName);
        g_pfnNuAddLineToSection(szSectionName, szTempLine);

        // now add the section that should be run
        //
        swprintf(szTempSection, L"%s.SectionToRun", szSectionName);
        g_pfnNuAddSection(szTempSection);

        // add the AddReg key
        //
        swprintf(szTempLine, L"AddReg=%s.AddReg", szTempSection);
        g_pfnNuAddLineToSection(szTempSection, szTempLine);

        // now add the AddReg section
        //
        swprintf(szTempSection, L"%s.SectionToRun.AddReg",
                  szSectionName);
        g_pfnNuAddSection(szTempSection);

        // finally add registry operations to this section
        //
        swprintf(szTempLine, L"HKR,0\\0,IsdnPhoneNumber,0,\"%s\"",
                  L"111-2222");
        g_pfnNuAddLineToSection(szTempSection, szTempLine);

        swprintf(szTempLine, L"HKR,0\\0,IsdnPhoneNumber,0,\"%s\"",
                  L"333-4444");
        g_pfnNuAddLineToSection(szTempSection, szTempLine);
    }

    return dwError;
}

EXTERN_C LONG  __stdcall
PostUpgradeInitialize(IN PCWSTR          szWorkingDir,
                      IN  NetUpgradeInfo* pNetUpgradeInfo,
                      OUT VENDORINFO*     pviVendorInfo,
                      OUT LPVOID          pvReserved)
{
    return ERROR_SUCCESS;
}


EXTERN_C LONG  __stdcall
DoPostUpgradeProcessing(IN  HWND    hParentWindow,
                        IN  HKEY    hkeyParams,
                        IN  PCWSTR  szPreNT5Instance,
                        IN  PCWSTR  szNT5InfId,
                        IN  HINF    hinfAnswerFile,
                        IN  PCWSTR  szSectionName,
                        OUT VENDORINFO* pviVendorInfo,
                        IN  LPVOID  pvReserved)
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\advcfg\achelp.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Generated by Dan Weisman
// Used by advcfg.rc
//

#define IDH_Edit_NetBios                214
#define IDH_Lana                        218
#define IDH_Adapters                    25000
#define IDH_Adapter_Up                  25001
#define IDH_Adapter_Down                25002
#define IDH_Bindings                    25003
#define IDH_Binding_Up                  25004
#define IDH_Binding_Down                25005
#define IDH_Provider_Order              25006
#define IDH_TREEVIEW                    25011
#define IDH_MOVEUP                      25012
#define IDH_MOVEDOWN                    25013
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\advcfg\acsheet.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:
//
//  Contents:   A C S H E E T . C P P
//
//  Notes:      Advanced Configuration property sheet code
//
//  Author:     danielwe   14 Jul 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "acsheet.h"
#include "acbind.h"
#include "netcfgx.h"
#include "order.h"


const INT c_cmaxPages = 3;

//+---------------------------------------------------------------------------
//
//  Member:     HrGetINetCfg
//
//  Purpose:    Obtains the INetCfg with lock
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
HRESULT HrGetINetCfg(HWND hwndParent, INetCfg **ppnc, INetCfgLock **ppnclock)
{
    HRESULT         hr = S_OK;
    INetCfg *       pnc = NULL;
    INetCfgLock *   pnclock = NULL;

    Assert(ppnc);
    Assert(ppnclock);

    *ppnc = NULL;
    *ppnclock = NULL;

    hr = CoCreateInstance(CLSID_CNetCfg, NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            IID_INetCfg, reinterpret_cast<void**>(&pnc));

    if (SUCCEEDED(hr))
    {
        hr = pnc->QueryInterface(IID_INetCfgLock,
                                 reinterpret_cast<LPVOID *>(&pnclock));
        if (SUCCEEDED(hr))
        {
            PWSTR pszwLockHolder;

            hr = pnclock->AcquireWriteLock(0,
                    SzLoadIds(IDS_ADVCFG_LOCK_DESC), &pszwLockHolder);
            if (S_OK == hr)
            {
                Assert(!pszwLockHolder);
                hr = pnc->Initialize(NULL);
            }
            else if (S_FALSE == hr)
            {
                // Couldn't lock INetCfg
                NcMsgBox(hwndParent,
                    IDS_ADVCFG_CAPTION, IDS_ADVCFG_CANT_LOCK,
                    MB_ICONSTOP | MB_OK,
                    (pszwLockHolder)
                        ? pszwLockHolder
                        : SzLoadIds(IDS_ADVCFG_GENERIC_COMP));

                CoTaskMemFree(pszwLockHolder);

                // Don't need this anymore
                ReleaseObj(pnclock);
                pnclock = NULL;

                hr = E_FAIL;
            }
            else if (NETCFG_E_NEED_REBOOT == hr)
            {
                // Can't make any changes because we are pending a reboot.
                NcMsgBox(hwndParent,
                    IDS_ADVCFG_CAPTION, IDS_ADVCFG_NEED_REBOOT,
                    MB_ICONSTOP | MB_OK);

                // Don't need this anymore
                ReleaseObj(pnclock);
                pnclock = NULL;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        *ppnc = pnc;
        *ppnclock = pnclock;
    }

    TraceError("HrGetINetCfg", hr);
    return hr;
}

HRESULT HrDoAdvCfgDlg(HWND hwndParent)
{
    PROPSHEETHEADER     psh = {0};
    HPROPSHEETPAGE      ahpsp[c_cmaxPages];
    INetCfg *           pnc = NULL;
    INetCfgLock *       pnclock = NULL;
    HRESULT             hr;

    hr = HrGetINetCfg(hwndParent, &pnc, &pnclock);
    if (SUCCEEDED(hr))
    {
        CBindingsDlg        dlgBindings(pnc);
        CProviderOrderDlg   dlgProviderOrder;
        DWORD               cPages = 0;

        if (dlgBindings.FShowPage())
        {
            ahpsp[cPages++] = dlgBindings.CreatePage(IDD_ADVCFG_Bindings, 0);
        }

        if (dlgProviderOrder.FShowPage())
        {
            ahpsp[cPages++] = dlgProviderOrder.CreatePage(IDD_ADVCFG_Provider, 0);
        }

        psh.dwSize      = sizeof(PROPSHEETHEADER);
        psh.dwFlags     = PSH_NOAPPLYNOW;
        psh.hwndParent  = hwndParent;
        psh.hInstance   = _Module.GetResourceInstance();
        psh.pszCaption  = SzLoadIds(IDS_ADVCFG_PROPSHEET_TITLE);
        psh.nPages      = cPages;
        psh.phpage      = ahpsp;

        int nRet = PropertySheet(&psh);

        hr = pnc->Uninitialize();
        if (SUCCEEDED(hr))
        {
            if (pnclock)
            {
                // Don't unlock unless we previously successfully acquired the
                // write lock
                hr = pnclock->ReleaseWriteLock();
                ReleaseObj(pnclock);
            }
        }

        if (SUCCEEDED(hr))
        {
            ReleaseObj(pnc);
        }
    }

    TraceError("HrDoAdvCfgDlg", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\advcfg\aclist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A C L I S T . C P P
//
//  Contents:   Functions related to listview control in adavnced
//              configuration dialog.
//
//  Notes:
//
//  Author:     danielwe   3 Dec 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "acbind.h"
#include "acsheet.h"
#include "lancmn.h"
#include "ncnetcfg.h"
#include "ncnetcon.h"
#include "ncsetup.h"
#include "foldinc.h"

extern const WCHAR c_szInfId_MS_TCPIP[];


HRESULT CBindingsDlg::HrGetAdapters(INetCfgComponent *pncc,
                                    NCC_LIST *plistNcc)
{
    Assert(pncc);

    HRESULT                 hr = S_OK;

    CIterNetCfgBindingPath  ncbpIter(pncc);
    INetCfgBindingPath *    pncbp;
    NCC_LIST                listncc;
    INetCfgComponent *      pnccLast;

    while (SUCCEEDED(hr) && S_OK == (hr = ncbpIter.HrNext(&pncbp)))
    {
        hr = HrGetLastComponentAndInterface(pncbp, &pnccLast, NULL);
        if (SUCCEEDED(hr))
        {
            hr = HrIsConnection(pnccLast);
            if (S_OK == hr)
            {
                plistNcc->push_back(pnccLast);
            }
            else
            {
                // Don't need it anymore so release it
                ReleaseObj(pnccLast);
            }
        }

        ReleaseObj(pncbp);
    }

    if (SUCCEEDED(hr))
    {
        if (plistNcc->empty())
        {
            hr = S_FALSE;
        }
        else
        {
            plistNcc->unique();
            hr = S_OK;
        }
    }

    TraceError("CBindingsDlg::HrGetAdapters", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrBuildAdapterList
//
//  Purpose:    Builds the list of adapters displayed in the listview control
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if succeeded, OLE or Win32 error otherwise
//
//  Author:     danielwe   19 Nov 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrBuildAdapterList()
{
    HRESULT                 hr = S_OK;
    INetCfgComponent *      pncc = NULL;
    SP_CLASSIMAGELIST_DATA  cid;
    INT                     nIndexWan;
    INT                     ipos = 0;
    NCC_LIST                listncc;

    Assert(m_pnc);

    // Get the class image list structure
    hr = HrSetupDiGetClassImageList(&cid);
    if (SUCCEEDED(hr))
    {
        // Get the modem class image list index
        hr = HrSetupDiGetClassImageIndex(&cid,
                                         const_cast<LPGUID>(&GUID_DEVCLASS_MODEM),
                                         &nIndexWan);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pnc->FindComponent(c_szInfId_MS_TCPIP, &pncc);
        if (S_FALSE == hr)
        {
            // Hmm, TCP/IP is not installed. Better look for a protocol that
            // has bindings to an adapter.
            //
            CIterNetCfgComponent    nccIter(m_pnc, &GUID_DEVCLASS_NETTRANS);

            while (SUCCEEDED(hr) && S_OK == (hr = nccIter.HrNext(&pncc)))
            {
                hr = HrGetAdapters(pncc, &listncc);
                ReleaseObj(pncc);
                if (S_OK == hr)
                {
                    // We found one! Yay.
                    break;
                }
            }
        }
        else if (S_OK == hr)
        {
            hr = HrGetAdapters(pncc, &listncc);
            ReleaseObj(pncc);
        }
    }

    if (S_OK == hr)
    {
        // Iterate all LAN connections
        //
        INetConnectionManager * pconMan;

        HRESULT hr = HrCreateInstance(
            CLSID_LanConnectionManager,
            CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            &pconMan);

        TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

        if (SUCCEEDED(hr))
        {
            NCC_LIST::iterator      iterlist;
            INetCfgComponent *      pnccToAdd;

            for (iterlist = listncc.begin();
                 iterlist != listncc.end();
                 iterlist++)
            {
                CIterNetCon         ncIter(pconMan, NCME_DEFAULT);
                INetConnection *    pconn;
                GUID                guidAdd;
                BOOL                fAdded = FALSE;

                pnccToAdd = *iterlist;
                (VOID) pnccToAdd->GetInstanceGuid(&guidAdd);

                while (SUCCEEDED(hr) && !fAdded &&
                       (S_OK == (ncIter.HrNext(&pconn))))
                {
                    // Compare guid of connection's adapter to this
                    // one. If we have a match, add it to the listview
                    if (FPconnEqualGuid(pconn, guidAdd))
                    {
                        NETCON_PROPERTIES* pProps;
                        hr = pconn->GetProperties(&pProps);
                        if (SUCCEEDED(hr))
                        {
                            AddListViewItem(pnccToAdd, ipos, m_nIndexLan,
                                            pProps->pszwName);
                            fAdded = TRUE;
                            ipos++;

                            FreeNetconProperties(pProps);
                        }
                    }

                    ReleaseObj(pconn);
                }

#if DBG
                if (!fAdded)
                {
                    WCHAR   szwGuid[64];

                    StringFromGUID2(guidAdd, szwGuid, sizeof(szwGuid));
                    TraceTag(ttidAdvCfg, "Never added item %S for this "
                             "connection!", szwGuid);
                }
#endif

                // Balance AddRef from HrGetLastComponentAndInterface()
                ReleaseObj(pnccToAdd);
            }

            ReleaseObj(pconMan);
        }

        listncc.erase(listncc.begin(), listncc.end());
    }

    // Display WAN Adapter Bindings
    if (SUCCEEDED(hr))
    {
        GetWanOrdering();
        AddListViewItem(NULL, m_fWanBindingsFirst ? 0 : ipos, nIndexWan,
                        SzLoadIds(IDS_ADVCFG_WAN_ADAPTERS));
    }

    (void) HrSetupDiDestroyClassImageList(&cid);

    if (SUCCEEDED(hr))
    {
        SetAdapterButtons();
        ListView_SetColumnWidth(m_hwndLV, 0, LVSCW_AUTOSIZE);
        hr = S_OK;
    }

    // Select first item
    ListView_SetItemState(m_hwndLV, 0, LVIS_FOCUSED | LVIS_SELECTED,
                          LVIS_FOCUSED | LVIS_SELECTED);

    TraceError("CBindingsDlg::HrBuildAdapterList", hr);
    return hr;
}

VOID CBindingsDlg::GetWanOrdering()
{
    INetCfgSpecialCase * pncsc = NULL;

    if (SUCCEEDED(m_pnc->QueryInterface(IID_INetCfgSpecialCase,
                                        reinterpret_cast<LPVOID*>(&pncsc))))
    {
        (VOID) pncsc->GetWanAdaptersFirst(&m_fWanBindingsFirst);
        ReleaseObj(pncsc);
    }
}

VOID CBindingsDlg::SetWanOrdering()
{
    INetCfgSpecialCase * pncsc = NULL;

    if (SUCCEEDED(m_pnc->QueryInterface(IID_INetCfgSpecialCase,
                                        reinterpret_cast<LPVOID*>(&pncsc))))
    {
        (VOID) pncsc->SetWanAdaptersFirst(m_fWanBindingsFirst);
        ReleaseObj(pncsc);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::AddListViewItem
//
//  Purpose:    Adds the given component to the listview
//
//  Arguments:
//      pncc        [in] Component to be added. If NULL, then this is the
//                       special WAN adapter component.
//      ipos        [in] Position at which to add
//      nIndex      [in] Index of icon into system image list
//      pszConnName [in] Connection name
//
//  Returns:    Nothing
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
VOID CBindingsDlg::AddListViewItem(INetCfgComponent *pncc, INT ipos,
                                   INT nIndex, PCWSTR pszConnName)
{
    LV_ITEM     lvi = {0};

    lvi.mask = LVIF_TEXT | LVIF_IMAGE |
               LVIF_STATE | LVIF_PARAM;

    lvi.iImage = nIndex;

    lvi.iItem = ipos;
    AddRefObj(pncc);
    lvi.lParam = reinterpret_cast<LPARAM>(pncc);
    lvi.pszText = const_cast<PWSTR>(pszConnName);

    ListView_InsertItem(m_hwndLV, &lvi);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnListItemChanged
//
//  Purpose:    Called when the LVN_ITEMCHANGED message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   19 Nov 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnListItemChanged(int idCtrl, LPNMHDR pnmh,
                                      BOOL& bHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);

    Assert(pnmlv);

    // Check if selection changed
    if ((pnmlv->uNewState & LVIS_SELECTED) &&
        (!(pnmlv->uOldState & LVIS_SELECTED)))
    {
        if (pnmlv->iItem != m_iItemSel)
        {
            // Selection changed to different item
            OnAdapterChange(pnmlv->iItem);
            m_iItemSel = pnmlv->iItem;
        }
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnListDeleteItem
//
//  Purpose:    Called when the LVN_DELETEITEM message is received.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   4 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnListDeleteItem(int idCtrl, LPNMHDR pnmh,
                                     BOOL& bHandled)
{
    LV_ITEM             lvi = {0};
    INetCfgComponent *  pncc;
    NM_LISTVIEW *       pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);

    Assert(pnmlv);

    lvi.mask = LVIF_PARAM;
    lvi.iItem = pnmlv->iItem;

    ListView_GetItem(m_hwndLV, &lvi);
    pncc = reinterpret_cast<INetCfgComponent *>(lvi.lParam);
    ReleaseObj(pncc);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnAdapterChange
//
//  Purpose:    Handles the selection of a different adapter from the listview
//
//  Arguments:
//      iItem [in]  Item in list that was selected
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   19 Nov 1997
//
//  Notes:
//
VOID CBindingsDlg::OnAdapterChange(INT iItem)
{
    LV_ITEM             lvi = {0};
    INetCfgComponent *  pncc;
    PWSTR              szwText;
    WCHAR               szBuffer[256];

    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.pszText = szBuffer;
    lvi.cchTextMax = celems(szBuffer);
    lvi.iItem = iItem;

    ListView_GetItem(m_hwndLV, &lvi);
    TreeView_DeleteAllItems(m_hwndTV);

    pncc = reinterpret_cast<INetCfgComponent *>(lvi.lParam);
    if (pncc)
    {
        BuildBindingsList(pncc);
        SetCheckboxStates();
    }

    SetAdapterButtons();

    DwFormatStringWithLocalAlloc(SzLoadIds(IDS_BINDINGS_FOR), &szwText,
                                 lvi.pszText);

    BOOL bShouldEnable = TRUE;

    if (!pncc) 
    {
        // If the WAN bindings item is selected, hide and disable the treeview
        bShouldEnable = FALSE;
    }
    else
    {
        // if a LAN item is selected, make sure the treeview is enabled
        GUID guid;
        HRESULT hr = pncc->GetInstanceGuid(&guid);
        if (SUCCEEDED(hr))
        {
            ConnListEntry cle;
            hr = g_ccl.HrFindConnectionByGuid(&guid, cle);
            if (S_FALSE == hr)
            {
                hr = g_ccl.HrRefreshConManEntries();
                if (SUCCEEDED(hr))
                {
                    hr = g_ccl.HrFindConnectionByGuid(&guid, cle);
                }
            }
            
            if (S_OK == hr)
            {
                if ( (NCM_LAN == cle.ccfe.GetNetConMediaType()) &&
                     (cle.ccfe.GetCharacteristics() & NCCF_BRIDGED) )
                {
                    bShouldEnable = FALSE;
                }
            }
        }
    }

    if (bShouldEnable)
    {
        ::ShowWindow(GetDlgItem(IDH_TXT_ADVGFG_BINDINGS), SW_SHOW);
        ::EnableWindow(GetDlgItem(IDH_TXT_ADVGFG_BINDINGS), TRUE);
        ::EnableWindow(GetDlgItem(TVW_Bindings), TRUE);
    }
    else
    {
        
        ::ShowWindow(GetDlgItem(IDH_TXT_ADVGFG_BINDINGS), SW_HIDE);
        ::EnableWindow(GetDlgItem(IDH_TXT_ADVGFG_BINDINGS), FALSE);
        ::EnableWindow(GetDlgItem(TVW_Bindings), FALSE);
    }

    SetDlgItemText(IDH_TXT_ADVGFG_BINDINGS, szwText);
    LocalFree(szwText);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnAdapterUpDown
//
//  Purpose:    Helper function that performs most of the work to move
//              adapter bindings
//
//  Arguments:
//      fUp [in]    TRUE if moving up, FALSE if down
//
//  Returns:    Nothing
//
//  Author:     danielwe   2 Dec 1997
//
//  Notes:
//
VOID CBindingsDlg::OnAdapterUpDown(BOOL fUp)
{
    INetCfgComponent *  pnccSrc;
    INetCfgComponent *  pnccDst;
    INT                 iSel;
    INT                 iDst;
    LV_ITEM             lvi = {0};
    WCHAR               szBuffer[256];

    iSel = ListView_GetNextItem(m_hwndLV, -1, LVNI_SELECTED);

    AssertSz(iSel != -1, "No Selection?!?!?");

    lvi.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
    lvi.pszText = szBuffer;
    lvi.cchTextMax = celems(szBuffer);
    lvi.iItem = iSel;

    ListView_GetItem(m_hwndLV, &lvi);
    pnccSrc = reinterpret_cast<INetCfgComponent *>(lvi.lParam);

    if (pnccSrc)
    {
        // Normal LAN adapter
        iDst = ListView_GetNextItem(m_hwndLV, iSel,
                                    fUp ? LVNI_ABOVE : LVNI_BELOW);

        AssertSz(iDst != -1, "No item above or below!");
    }
    else
    {
        m_fWanBindingsFirst = fUp;

        // WAN binding item
        iDst = fUp ? 0 : ListView_GetItemCount(m_hwndLV) - 1;
    }

    lvi.iItem = iDst;

    ListView_GetItem(m_hwndLV, &lvi);
    pnccDst = reinterpret_cast<INetCfgComponent *>(lvi.lParam);
    AssertSz(pnccDst, "Dest Component is NULL!?!?");

    if (pnccSrc)
    {
        MoveAdapterBindings(pnccSrc, pnccDst, fUp ? MAB_UP : MAB_DOWN);
    }
    else
    {
        SetWanOrdering();
    }

    // Delete source item and move to where dest item is

    // Note: (danielwe) 2 Dec 1997: For LVN_DELETEITEM handler, make sure
    // refcount remains the same

    // Get item we are moving
    lvi.iItem = iSel;
    ListView_GetItem(m_hwndLV, &lvi);

    // Make the lParam of the item NULL so we don't release it
    ChangeListItemParam(m_hwndLV, iSel, NULL);
    ListView_DeleteItem(m_hwndLV, iSel);

    // Change its index
    lvi.iItem = iDst;
    lvi.state = lvi.stateMask = 0;

    // And insert in new location
    int iItem = ListView_InsertItem(m_hwndLV, &lvi);

    if (-1 != iItem)
    {
        ListView_SetItemState(m_hwndLV, iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
    
    // Reset cached selection
    m_iItemSel = iDst;

    SetAdapterButtons();
    ::SetFocus(m_hwndLV);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnAdapterUp
//
//  Purpose:    Called when the adapter UP arrow button is pressed
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   2 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnAdapterUp(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                BOOL& bHandled)
{
    OnAdapterUpDown(TRUE);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnAdapterDown
//
//  Purpose:    Called when the adapter DOWN button is pressed
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   2 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnAdapterDown(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                  BOOL& bHandled)
{
    OnAdapterUpDown(FALSE);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::FIsWanBinding
//
//  Purpose:    Determines if the given list view item is the special WAN
//              adapter ordering item.
//
//  Arguments:
//      iItem [in]  List view item to test
//
//  Returns:    TRUE if this is the WAN adapter ordering item or FALSE if not
//
//  Author:     danielwe   21 Jul 1998
//
//  Notes:
//
BOOL CBindingsDlg::FIsWanBinding(INT iItem)
{
    if (iItem != -1)
    {
        LV_ITEM     lvi = {0};

        lvi.mask = LVIF_PARAM;
        lvi.iItem = iItem;

        ListView_GetItem(m_hwndLV, &lvi);

        return !lvi.lParam;
    }
    else
    {
        // Invalid item can't be the WAN binding
        return FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::SetAdapterButtons
//
//  Purpose:    Sets the state of the up and down arrow buttons for the
//              adapters listview
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   19 Nov 1997
//
//  Notes:
//
VOID CBindingsDlg::SetAdapterButtons()
{
    INT iItemAbove = -1;
    INT iItemBelow = -1;
    INT iItem;

    iItem = ListView_GetNextItem(m_hwndLV, -1, LVNI_SELECTED);

    if (ListView_GetItemCount(m_hwndLV) > 1)
    {
        iItemAbove = ListView_GetNextItem(m_hwndLV, iItem, LVNI_ABOVE);
        iItemBelow = ListView_GetNextItem(m_hwndLV, iItem, LVNI_BELOW);
        if (FIsWanBinding(iItemAbove))
        {
            iItemAbove = -1;
            AssertSz(ListView_GetNextItem(m_hwndLV, iItemAbove, LVNI_ABOVE) == -1,
                     "Item above the WAN binding??");
        }
        else if (FIsWanBinding(iItemBelow))
        {
            iItemBelow = -1;
            AssertSz(ListView_GetNextItem(m_hwndLV, iItemBelow, LVNI_BELOW) == -1,
                     "Item below the WAN binding??");
        }
    }

    ::EnableWindow(GetDlgItem(PSB_Adapter_Up), (iItemAbove != -1));
    ::EnableWindow(GetDlgItem(PSB_Adapter_Down), (iItemBelow != -1));
}

static const GUID * c_aguidClass[] =
{
    &GUID_DEVCLASS_NETTRANS,
    &GUID_DEVCLASS_NETSERVICE,
    &GUID_DEVCLASS_NETCLIENT,
};
static const DWORD c_cguidClass = celems(c_aguidClass);

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::MoveAdapterBindings
//
//  Purpose:    Moves all bindings for the given source and destination
//              adapters in the given direction
//
//  Arguments:
//      pnccSrc [in]    Adapter for which bindings are being moved
//      pnccDst [in]    Adapter to which bindings are being moved before or
//                      after
//      mabDir  [in]    Direction to move. Either MAB_UP or MAB_DOWN
//
//  Returns:    Nothing
//
//  Author:     danielwe   2 Dec 1997
//
//  Notes:
//
VOID CBindingsDlg::MoveAdapterBindings(INetCfgComponent *pnccSrc,
                                     INetCfgComponent *pnccDst,
                                     MAB_DIRECTION mabDir)
{
    HRESULT     hr = S_OK;
    DWORD       iguid;

    AssertSz(pnccDst, "Destination component cannot be NULL!");

    for (iguid = 0; iguid < c_cguidClass; iguid++)
    {
        CIterNetCfgComponent    nccIter(m_pnc, c_aguidClass[iguid]);
        INetCfgComponent *      pncc;

        while (SUCCEEDED(hr) && S_OK == (hr = nccIter.HrNext(&pncc)))
        {
            CIterNetCfgBindingPath  ncbpIter(pncc);
            INetCfgBindingPath *    pncbp;
            INetCfgBindingPath *    pncbpTarget = NULL;
            BOOL                    fAssign = TRUE;
            NCBP_LIST               listbp;
            INetCfgComponent *      pnccLast;

            while (SUCCEEDED(hr) && S_OK == (hr = ncbpIter.HrNext(&pncbp)))
            {
                hr = HrGetLastComponentAndInterface(pncbp, &pnccLast, NULL);
                if (SUCCEEDED(hr))
                {
                    if (pnccLast == pnccDst)
                    {
                        if ((mabDir == MAB_UP) && fAssign)
                        {
                            AddRefObj(pncbpTarget = pncbp);
                            fAssign = FALSE;
                        }
                        else if (mabDir == MAB_DOWN)
                        {
                            ReleaseObj(pncbpTarget);
                            AddRefObj(pncbpTarget = pncbp);
                        }
                    }
                    else if (pnccLast == pnccSrc)
                    {
                        AddRefObj(pncbp);
                        listbp.push_back(pncbp);
                    }

                    ReleaseObj(pnccLast);
                }

                ReleaseObj(pncbp);
            }

            if (SUCCEEDED(hr))
            {
                NCBP_LIST::iterator         iterbp;
                INetCfgComponentBindings *  pnccb;

                hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                                          reinterpret_cast<LPVOID *>(&pnccb));
                if (SUCCEEDED(hr))
                {
                    for (iterbp = listbp.begin();
                         (iterbp != listbp.end()) && SUCCEEDED(hr);
                         iterbp++)
                    {
                        if (mabDir == MAB_UP)
                        {
                            TraceTag(ttidAdvCfg, "Moving...");
                            DbgDumpBindPath(*iterbp);
                            // Move this binding path before the tagret
                            hr = pnccb->MoveBefore(*iterbp, pncbpTarget);
                            TraceTag(ttidAdvCfg, "before...");
                            DbgDumpBindPath(pncbpTarget);
                        }
                        else
                        {
                            TraceTag(ttidAdvCfg, "Moving...");
                            DbgDumpBindPath(*iterbp);
                            // Move this binding path after the tagret
                            hr = pnccb->MoveAfter(*iterbp, pncbpTarget);
                            TraceTag(ttidAdvCfg, "after...");
                            DbgDumpBindPath(pncbpTarget);
                        }

                        if (mabDir == MAB_DOWN)
                        {
                            // In the down direction ONLY, from now on, the
                            // target becomes the last binding we moved. This
                            // keeps the binding order intact because moving
                            // several bindings after the same target
                            // effectively reverses their order.
                            //

                            // Release old target
                            ReleaseObj(pncbpTarget);

                            // AddRef new target
                            AddRefObj(pncbpTarget = *iterbp);
                        }

                        ReleaseObj(*iterbp);
                    }

                    ReleaseObj(pnccb);
                }

                listbp.erase(listbp.begin(), listbp.end());
            }

            ReleaseObj(pncbpTarget);
            ReleaseObj(pncc);
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    TraceError("CBindingsDlg::MoveAdapterBindings", hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChangeListItemParam
//
//  Purpose:    Changes the lParam member of the given item to the given
//              value.
//
//  Arguments:
//      hwndLV [in]     HWND of list view
//      iItem  [in]     Item to modify
//      lParam [in]     New lParam for item
//
//  Returns:    Nothing
//
//  Author:     danielwe   4 Dec 1997
//
//  Notes:
//
VOID ChangeListItemParam(HWND hwndLV, INT iItem, LPARAM lParam)
{
    LV_ITEM     lvi = {0};

    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.lParam = lParam;

    ListView_SetItem(hwndLV, &lvi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\advcfg\acsheet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A C S H E E T . H
//
//  Contents:   Definitions for the Advanced Configuration property sheet
//
//  Notes:
//
//  Author:     danielwe   14 Jul 1997
//
//----------------------------------------------------------------------------

#ifndef _ACSHEET_H
#define _ACSHEET_H

#pragma once
#include "nsbase.h"
#include "ncatlps.h"
#include "ncatlui.h"
#include "resource.h"

#endif //!_ACSHEET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\advcfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by advcfg.rc
//
#define IDCUR_AFTER                     3101
#define IDS_NCPA_NETWORK                5251
#define IDS_NCPA_PRINT                  5252
#define IDC_STATIC_LINE                 7000
#define LVW_Adapters                    25000
#define PSB_Adapter_Up                  25001
#define PSB_Adapter_Down                25002
#define TVW_Bindings                    25003
#define PSB_Binding_Up                  25004
#define PSB_Binding_Down                25005
#define PSB_Provider_Order              25006
#define IDD_Advanced_Config             25009
#define IDD_ADVCFG_Bindings             25009
#define IDD_PROVIDER                    25010
#define IDD_ADVCFG_Provider             25010
#define IDC_TREEVIEW                    25011
#define IDC_MOVEUP                      25012
#define IDC_MOVEDOWN                    25013
#define IDS_ADVCFG_LOCK_DESC            25100
#define IDS_BINDINGS_FOR                25101
#define IDS_ADVCFG_CAPTION              25102
#define IDS_ADVCFG_CANT_LOCK            25103
#define IDS_ADVCFG_GENERIC_COMP         25104
#define IDS_ADVCFG_PROPSHEET_TITLE      25108
#define IDS_ADVCFG_WAN_ADAPTERS         25109
#define IDS_ADVCFG_NEED_REBOOT          25110
#define TXT_Bindings_For                25111
#define IDH_TXT_AdvCfg_Network          25112
#define IDH_TXT_Advcfg_Connections      25113
#define IDH_TXT_ADVGFG_BINDINGS         25114
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\advcfg\actree.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A C T R E E . C P P
//
//  Contents:   Functions related to the Advanced Configuration dialog
//              tree view control
//
//  Notes:
//
//  Author:     danielwe   3 Dec 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "netcon.h"
#include "netconp.h"
#include "acsheet.h"
#include "acbind.h"
#include "ncnetcfg.h"
#include "lancmn.h"
#include "ncui.h"
#include "ncsetup.h"
#include "ncperms.h"

DWORD
GetDepthSpecialCase (
    INetCfgBindingPath* pPath)
{
    HRESULT hr;
    DWORD dwDepth;

    hr = pPath->GetDepth (&dwDepth);

    if (SUCCEEDED(hr))
    {
        INetCfgComponent* pLast;

        hr = HrGetLastComponentAndInterface (
                pPath, &pLast, NULL);

        if (SUCCEEDED(hr))
        {
            DWORD dwCharacteristics;

            // If the last component in the bindpath is one which
            // doesn't expose its lower bindings, then compsensate by
            // returning a depth that thinks it does.  This special case
            // is only for this code which was written for the origianl
            // binding engine but needed to be quickly adapted to the new
            // binding engine which doesn't return 'fake' bindpaths.
            //

            hr = pLast->GetCharacteristics (&dwCharacteristics);
            if (SUCCEEDED(hr) && (dwCharacteristics & NCF_DONTEXPOSELOWER))
            {
                PWSTR pszInfId;

                hr = pLast->GetId (&pszInfId);
                if (S_OK == hr)
                {
                    if (0 == lstrcmpW (pszInfId, L"ms_nwnb"))
                    {
                        dwDepth += 2;
                    }
                    else if (0 == lstrcmpW (pszInfId, L"ms_nwipx"))
                    {
                        dwDepth += 1;
                    }

                    CoTaskMemFree (pszInfId);
                }
            }

            ReleaseObj (pLast);
        }
    }

    return dwDepth;
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeBindPathInfoList
//
//  Purpose:    Frees the given list of BIND_PATH_INFO structures
//
//  Arguments:
//      listbpip [in, ref]  Reference to list to be freed
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
VOID FreeBindPathInfoList(BPIP_LIST &listbpip)
{
    BPIP_LIST::iterator     iterBpip;

    for (iterBpip = listbpip.begin();
         iterBpip != listbpip.end();
         iterBpip++)
    {
        BIND_PATH_INFO *    pbpi = *iterBpip;

        ReleaseObj(pbpi->pncbp);
        delete pbpi;
    }

    listbpip.erase(listbpip.begin(), listbpip.end());
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnTreeItemChanged
//
//  Purpose:    Called in response to the TVN_SELCHANGED message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnTreeItemChanged(int idCtrl, LPNMHDR pnmh,
                                      BOOL& bHandled)
{
    NM_TREEVIEW *   pnmtv = reinterpret_cast<NM_TREEVIEW *>(pnmh);

    Assert(pnmtv);

#ifdef ENABLETRACE
    WCHAR   szBuffer[265];

    pnmtv->itemNew.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_TEXT;
    pnmtv->itemNew.pszText = szBuffer;
    pnmtv->itemNew.cchTextMax = celems(szBuffer);

    TreeView_GetItem(m_hwndTV, &pnmtv->itemNew);

    TREE_ITEM_DATA *    ptid;

    ptid = reinterpret_cast<TREE_ITEM_DATA *>(pnmtv->itemNew.lParam);

    Assert(ptid);

    TraceTag(ttidAdvCfg, "*-------------------------------------------------"
             "------------------------------*");
    TraceTag(ttidAdvCfg, "Tree item %S selected", szBuffer);
    TraceTag(ttidAdvCfg, "-----------------------------------------");
    TraceTag(ttidAdvCfg, "OnEnable list:");
    TraceTag(ttidAdvCfg, "--------------");

    BPIP_LIST::iterator     iterBpip;

    for (iterBpip = ptid->listbpipOnEnable.begin();
         iterBpip != ptid->listbpipOnEnable.end();
         iterBpip++)
    {
        BIND_PATH_INFO *    pbpi = *iterBpip;

        DbgDumpBindPath(pbpi->pncbp);
    }

    TraceTag(ttidAdvCfg, "-----------------------------------");
    TraceTag(ttidAdvCfg, "OnDisable list:");
    TraceTag(ttidAdvCfg, "--------------");

    for (iterBpip = ptid->listbpipOnDisable.begin();
         iterBpip != ptid->listbpipOnDisable.end();
         iterBpip++)
    {
        BIND_PATH_INFO *    pbpi = *iterBpip;

        DbgDumpBindPath(pbpi->pncbp);
    }

    TraceTag(ttidAdvCfg, "*-------------------------------------------------"
             "------------------------------*");

#endif

    // Assume both buttons are greyed initially
    ::EnableWindow(GetDlgItem(PSB_Binding_Up), FALSE);
    ::EnableWindow(GetDlgItem(PSB_Binding_Down), FALSE);

    if (TreeView_GetParent(m_hwndTV, pnmtv->itemNew.hItem))
    {
        if (TreeView_GetNextSibling(m_hwndTV, pnmtv->itemNew.hItem))
        {
            ::EnableWindow(GetDlgItem(PSB_Binding_Down), TRUE);
        }

        if (TreeView_GetPrevSibling(m_hwndTV, pnmtv->itemNew.hItem))
        {
            ::EnableWindow(GetDlgItem(PSB_Binding_Up), TRUE);
        }
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnTreeDeleteItem
//
//  Purpose:    Called in response to the TVN_DELETEITEM message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:    Nothing useful
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnTreeDeleteItem(int idCtrl, LPNMHDR pnmh,
                                     BOOL& bHandled)
{
    NM_TREEVIEW *       pnmtv = reinterpret_cast<NM_TREEVIEW *>(pnmh);
    TREE_ITEM_DATA *    ptid;

    Assert(pnmtv);

    ptid = reinterpret_cast<TREE_ITEM_DATA *>(pnmtv->itemOld.lParam);

    // May be NULL if moving items around
    if (ptid)
    {
        ReleaseObj(ptid->pncc);
        FreeBindPathInfoList(ptid->listbpipOnEnable);
        FreeBindPathInfoList(ptid->listbpipOnDisable);

        delete ptid;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnTreeItemExpanding
//
//  Purpose:    Called when the TVN_ITEMEXPANDING message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnTreeItemExpanding(int idCtrl, LPNMHDR pnmh,
                                          BOOL& bHandled)
{
    // This prevents all tree items from collapsing
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnTreeKeyDown
//
//  Purpose:    Called when the TVN_KEYDOWN message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   22 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnTreeKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    TV_KEYDOWN *    ptvkd = (TV_KEYDOWN*)pnmh;
    HTREEITEM       hti = NULL;

    if (VK_SPACE == ptvkd->wVKey)
    {
        hti = TreeView_GetSelection(m_hwndTV);
        // if there is a selection
        if (hti)
        {
            ToggleCheckbox(hti);
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::ToggleCheckbox
//
//  Purpose:    Called when the user toggles a checbox in the treeview
//              control.
//
//  Arguments:
//      hti [in]    HTREEITEM of item that was toggled
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
VOID CBindingsDlg::ToggleCheckbox(HTREEITEM hti)
{
    if (!FHasPermission(NCPERM_ChangeBindState))
    {
        // do nothing
        return;
    }

    TV_ITEM             tvi = {0};
    TREE_ITEM_DATA *    ptid;
    BOOL                fEnable;

    tvi.mask = TVIF_PARAM | TVIF_HANDLE | TVIF_STATE;
    tvi.stateMask = TVIS_STATEIMAGEMASK;
    tvi.hItem = hti;
    TreeView_GetItem(m_hwndTV, &tvi);

    ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
    AssertSz(ptid, "No tree item data??");

    BPIP_LIST::iterator     iterBpip;
    BPIP_LIST *             plist;

    if (tvi.state & INDEXTOSTATEIMAGEMASK(SELS_CHECKED))
    {
        // unchecking the box
        plist = &ptid->listbpipOnDisable;
        fEnable = FALSE;
    }
    else
    {
        // checking the box
        plist = &ptid->listbpipOnEnable;
        fEnable = TRUE;
    }

    TraceTag(ttidAdvCfg, "ToggleChecbox: %s the following binding path(s)",
             fEnable ? "Enabling" : "Disabling");

    // Enable or disable each binding path in the appropriate list
    for (iterBpip = plist->begin();
         iterBpip != plist->end();
         iterBpip++)
    {
        BIND_PATH_INFO *    pbpi = *iterBpip;

        (VOID)pbpi->pncbp->Enable(fEnable);
        DbgDumpBindPath(pbpi->pncbp);
    }

    SetCheckboxStates();

    TraceTag(ttidAdvCfg, "Done!");
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnClick
//
//  Purpose:    Called in response to the NM_CLICK message.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return OnClickOrDoubleClick(idCtrl, pnmh, FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnDoubleClick
//
//  Purpose:    Called in response to the NM_DBLCLK message.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   16 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnDoubleClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return OnClickOrDoubleClick(idCtrl, pnmh, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnClickOrDoubleClick
//
//  Purpose:    Handles clicks or double clicks in the treeview control
//
//  Arguments:
//      idCtrl       [in]   ID of control
//      pnmh         [in]   Notification header
//      fDoubleClick [in]   TRUE if double click, FALSE if single click
//
//  Returns:
//
//  Author:     danielwe   16 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnClickOrDoubleClick(int idCtrl, LPNMHDR pnmh,
                                         BOOL fDoubleClick)
{
    if (idCtrl == TVW_Bindings)
    {
        DWORD           dwpts;
        RECT            rc;
        TV_HITTESTINFO  tvhti = {0};
        HTREEITEM       hti;

        // we have the location
        dwpts = GetMessagePos();

        // translate it relative to the tree view
        ::GetWindowRect(m_hwndTV, &rc);

        tvhti.pt.x = LOWORD(dwpts) - rc.left;
        tvhti.pt.y = HIWORD(dwpts) - rc.top;

        // get currently selected item
        hti = TreeView_HitTest(m_hwndTV, &tvhti);
        if (hti)
        {
            if (tvhti.flags & TVHT_ONITEMSTATEICON)
            {
                ToggleCheckbox(hti);
            }
            else if ((tvhti.flags & TVHT_ONITEM) && fDoubleClick)
            {
                ToggleCheckbox(hti);
            }
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnBindingUpDown
//
//  Purpose:    Handles the user moving a binding in the treeview up or down
//
//  Arguments:
//      fUp [in]    TRUE if moving up, FALSE if down
//
//  Returns:    Nothing
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
VOID CBindingsDlg::OnBindingUpDown(BOOL fUp)
{
    HRESULT                     hr = S_OK;
    TV_ITEM                     tvi = {0};
    HTREEITEM                   htiSel;
    HTREEITEM                   htiDst;
    TREE_ITEM_DATA *            ptidSel;
    TREE_ITEM_DATA *            ptidDst;
    INetCfgComponentBindings *  pnccb;

    htiSel = TreeView_GetSelection(m_hwndTV);

    AssertSz(htiSel, "No selection?");

    if (fUp)
    {
        htiDst = TreeView_GetPrevSibling(m_hwndTV, htiSel);
    }
    else
    {
        htiDst = TreeView_GetNextSibling(m_hwndTV, htiSel);
    }

    AssertSz(htiDst, "No next item?!");

    tvi.mask = TVIF_PARAM;
    tvi.hItem = htiSel;

    TreeView_GetItem(m_hwndTV, &tvi);

    ptidSel = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);

    tvi.hItem = htiDst;

    TreeView_GetItem(m_hwndTV, &tvi);

    ptidDst = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);

    BPIP_LIST::iterator         iterlist;
    INetCfgBindingPath *        pncbpDst;
    BIND_PATH_INFO *            pbpiDst = NULL;
    BPIP_LIST::iterator         posDst;
    BPIP_LIST::reverse_iterator posDstRev;
    INetCfgComponent *          pnccDstOwner;

    if (fUp)
    {
        posDst = ptidDst->listbpipOnDisable.begin();
        pbpiDst = *posDst;
    }
    else
    {
        posDstRev = ptidDst->listbpipOnDisable.rbegin();
        pbpiDst = *posDstRev;
    }

    AssertSz(pbpiDst, "We never found a path to move before or after!");

    pncbpDst = pbpiDst->pncbp;

    Assert(pncbpDst);

    hr = pncbpDst->GetOwner(&pnccDstOwner);
    if (SUCCEEDED(hr))
    {
        hr = pnccDstOwner->QueryInterface(IID_INetCfgComponentBindings,
                                          reinterpret_cast<LPVOID *>(&pnccb));
        if (SUCCEEDED(hr))
        {
            for (iterlist = ptidSel->listbpipOnDisable.begin();
                 iterlist != ptidSel->listbpipOnDisable.end() &&
                 SUCCEEDED(hr);
                 iterlist++)
            {
                // loop thru each item in the OnDisable list
                INetCfgBindingPath *    pncbp;
                BIND_PATH_INFO *        pbpi;

                pbpi = *iterlist;
                pncbp = pbpi->pncbp;

#if DBG
                INetCfgComponent *  pnccSrcOwner;

                if (SUCCEEDED(pncbp->GetOwner(&pnccSrcOwner)))
                {
                    AssertSz(pnccSrcOwner == pnccDstOwner, "Source and "
                             "dst path owners are not the same!?!");
                    ReleaseObj(pnccSrcOwner);
                }
#endif
                if (fUp)
                {
                    TraceTag(ttidAdvCfg, "Treeview: Moving...");
                    DbgDumpBindPath(pncbp);
                    // Move this binding path before the tagret
                    hr = pnccb->MoveBefore(pncbp, pncbpDst);
                    TraceTag(ttidAdvCfg, "Treeview: before...");
                    DbgDumpBindPath(pncbpDst);
                }
                else
                {
                    TraceTag(ttidAdvCfg, "Treeview: Moving...");
                    DbgDumpBindPath(pncbp);
                    // Move this binding path after the tagret
                    hr = pnccb->MoveAfter(pncbp, pncbpDst);
                    TraceTag(ttidAdvCfg, "Treeview: after...");
                    DbgDumpBindPath(pncbpDst);
                }
            }

            ReleaseObj(pnccb);
        }

        ReleaseObj(pnccDstOwner);
    }

    if (SUCCEEDED(hr))
    {
        HTREEITEM   htiParent;

        htiParent = TreeView_GetParent(m_hwndTV, htiSel);

        // Now that the binding has been moved, move the tree view item to the
        // proper place. If moving

        if (fUp)
        {
            // If moving up, the "move after" item should be the previous
            // sibling's previous sibling. If that doesn't exist, use the
            // previous sibling's parent. That had better exist!
            htiDst = TreeView_GetPrevSibling(m_hwndTV, htiDst);
            if (!htiDst)
            {
                htiDst = htiParent;
            }
        }

        AssertSz(htiDst, "No destination to move after!");

        SendDlgItemMessage(TVW_Bindings, WM_SETREDRAW, FALSE, 0);
        htiSel = HtiMoveTreeItemAfter(htiParent, htiDst, htiSel);
        TreeView_SelectItem(m_hwndTV, htiSel);
        SendDlgItemMessage(TVW_Bindings, WM_SETREDRAW, TRUE, 0);

        ::SetFocus(m_hwndTV);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnBindingUp
//
//  Purpose:    Called when the PSB_Binding_Up button is pressed
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnBindingUp(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                BOOL& bHandled)
{
    OnBindingUpDown(TRUE);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnBindingDown
//
//  Purpose:    Called when the PSB_Binding_Down button is pressed
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnBindingDown(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                  BOOL& bHandled)
{
    OnBindingUpDown(FALSE);

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::SetCheckboxStates
//
//  Purpose:    Sets the state of all checkboxes in the treeview.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
VOID CBindingsDlg::SetCheckboxStates()
{
    HRESULT         hr = S_OK;
    CIterTreeView   iterTV(m_hwndTV);
    HTREEITEM       hti;
    TV_ITEM         tvi = {0};
#ifdef ENABLETRACE
    WCHAR           szBuffer[256];
#endif

    BOOL fHasPermission = FHasPermission(NCPERM_ChangeBindState);

    while ((hti = iterTV.HtiNext()) && SUCCEEDED(hr))
    {
        TREE_ITEM_DATA *    ptid;

#ifdef ENABLETRACE
        tvi.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_TEXT;
        tvi.pszText = szBuffer;
        tvi.cchTextMax = celems(szBuffer);
#else
        tvi.mask = TVIF_HANDLE | TVIF_PARAM;
#endif
        tvi.hItem = hti;
        TreeView_GetItem(m_hwndTV, &tvi);

        ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
        AssertSz(ptid, "No tree item data??");

#ifdef ENABLETRACE
        TraceTag(ttidAdvCfg, "Setting checkbox state for item %S.", szBuffer);
#endif

        BPIP_LIST::iterator     iterBpip;
        DWORD                   cEnabled = 0;

        for (iterBpip = ptid->listbpipOnDisable.begin();
             iterBpip != ptid->listbpipOnDisable.end();
             iterBpip++)
        {
            BIND_PATH_INFO *    pbpi = *iterBpip;

            if (S_OK == pbpi->pncbp->IsEnabled())
            {
                cEnabled++;
            }
        }

        tvi.mask = TVIF_STATE;
        tvi.stateMask = TVIS_STATEIMAGEMASK;

        UINT iState;

        if (!fHasPermission)
        {
            iState = cEnabled ? SELS_FIXEDBINDING_ENABLED : SELS_FIXEDBINDING_DISABLED;
        }
        else
        {
            iState = cEnabled ? SELS_CHECKED : SELS_UNCHECKED;
        }
        tvi.state =  INDEXTOSTATEIMAGEMASK(iState);

        TreeView_SetItem(m_hwndTV, &tvi);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::BuildBindingsList
//
//  Purpose:    Builds the contents of the Bindings treeview control
//
//  Arguments:
//      pncc [in]   INetCfgComponent of adapter upon which this list is based
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
VOID CBindingsDlg::BuildBindingsList(INetCfgComponent *pncc)
{
    HRESULT     hr = S_OK;

    Assert(pncc);

    SBP_LIST                    listsbp;
    CIterNetCfgUpperBindingPath ncupbIter(pncc);
    INetCfgBindingPath *        pncbp;

    CWaitCursor wc;

    SendDlgItemMessage(TVW_Bindings, WM_SETREDRAW, FALSE, 0);

    while (SUCCEEDED(hr) && S_OK == (hr = ncupbIter.HrNext(&pncbp)))
    {
        listsbp.push_back(CSortableBindPath(pncbp));
    }

    if (SUCCEEDED(hr))
    {
        SBP_LIST::iterator  iterlist;

        // This sorts the list descending by depth
        listsbp.sort();

        for (iterlist = listsbp.begin();
             iterlist != listsbp.end() && SUCCEEDED(hr);
             iterlist++)
        {
            INetCfgBindingPath *    pncbp;

            pncbp = (*iterlist).GetPath();
            Assert(pncbp);

            hr = HrHandleSubpath(listsbp, pncbp);
            if (S_FALSE == hr)
            {
                hr = HrHandleTopLevel(pncbp);
            }
        }
    }

#ifdef ENABLETRACE
    if (FALSE)
    {
        SBP_LIST::iterator  iterlist;
        for (iterlist = listsbp.begin(); iterlist != listsbp.end(); iterlist++)
        {
            INetCfgBindingPath *    pncbp;

            pncbp = (*iterlist).GetPath();

            DWORD dwLen = GetDepthSpecialCase(pncbp);

            TraceTag(ttidAdvCfg, "Length is %ld.", dwLen);
        }
    }
#endif

    if (SUCCEEDED(hr))
    {
        hr = HrOrderDisableLists();
        if (SUCCEEDED(hr))
        {
            hr = HrOrderSubItems();
        }
    }

    SendDlgItemMessage(TVW_Bindings, WM_SETREDRAW, TRUE, 0);

    // Select first item in the tree
    TreeView_SelectItem(m_hwndTV, TreeView_GetRoot(m_hwndTV));

    {
        SBP_LIST::iterator  iterlist;

        for (iterlist = listsbp.begin();
             iterlist != listsbp.end() && SUCCEEDED(hr);
             iterlist++)
        {
            INetCfgBindingPath *    pncbp;

            pncbp = (*iterlist).GetPath();
            ReleaseObj(pncbp);
        }
    }

    TraceError("CBindingsDlg::BuildBindingsList", hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   BpiFindBindPathInList
//
//  Purpose:    Given a bind path and a list, finds the BIND_PATH_INFO item
//              that contains the given bind path.
//
//  Arguments:
//      pncbp    [in]       Bind path to look for
//      listBpip [in, ref]  List to search
//
//  Returns:    BIND_PATH_INFO of corresponding binding path, NULL if not
//              found
//
//  Author:     danielwe   4 Dec 1997
//
//  Notes:
//
BIND_PATH_INFO *BpiFindBindPathInList(INetCfgBindingPath *pncbp,
                                      BPIP_LIST &listBpip)
{
    BPIP_LIST::iterator     iterlist;

    for (iterlist = listBpip.begin(); iterlist != listBpip.end(); iterlist++)
    {
        BIND_PATH_INFO *    pbpi;

        pbpi = *iterlist;

        if (S_OK == pncbp->IsSamePathAs(pbpi->pncbp))
        {
            // Found the target path
            return pbpi;
        }
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrOrderDisableList
//
//  Purpose:    Given a component's item data, orders the OnDisable list
//              based on the true binding order for the owning component
//
//  Arguments:
//      ptid [in]   Item data containing list
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   4 Dec 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrOrderDisableList(TREE_ITEM_DATA *ptid)
{
    HRESULT             hr = S_OK;
    INetCfgComponent *  pnccOwner;
    BIND_PATH_INFO *    pbpi;

#if DBG
    size_t              cItems = ptid->listbpipOnDisable.size();
#endif

    // Get the owning component of the first binding path in the list
    pbpi = *(ptid->listbpipOnDisable.begin());
    hr = pbpi->pncbp->GetOwner(&pnccOwner);
    if (SUCCEEDED(hr))
    {
        CIterNetCfgBindingPath  ncbpIter(pnccOwner);
        INetCfgBindingPath *    pncbp;
        BPIP_LIST::iterator     posPncbp;
        BPIP_LIST::iterator     posInsertAfter;

        // Start this at beginning
        posInsertAfter = ptid->listbpipOnDisable.begin();

        while (SUCCEEDED(hr) && S_OK == (hr = ncbpIter.HrNext(&pncbp)))
        {
            pbpi = BpiFindBindPathInList(pncbp, ptid->listbpipOnDisable);
            if (pbpi)
            {
                BPIP_LIST::iterator     posErase;

                posErase = find(ptid->listbpipOnDisable.begin(),
                                ptid->listbpipOnDisable.end(), pbpi);

                AssertSz(posErase != ptid->listbpipOnDisable.end(), "It HAS"
                         " to be in the list!");

                // Found bind path in list
                // Remove it from present location and insert after next item
                ptid->listbpipOnDisable.splice(posInsertAfter,
                                               ptid->listbpipOnDisable,
                                               posErase);
                posInsertAfter++;
            }

            ReleaseObj(pncbp);
        }

        ReleaseObj(pnccOwner);
    }

    if (SUCCEEDED(hr))
    {
        AssertSz(ptid->listbpipOnDisable.size() == cItems, "How come we don't"
                 " have the same number of items in the list anymore??");
        hr = S_OK;
    }

    TraceError("CBindingsDlg::HrOrderDisableList", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrOrderDisableLists
//
//  Purpose:    Orders the OnDisable lists of all tree view items according
//              to the true binding order
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   4 Dec 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrOrderDisableLists()
{
    HRESULT         hr = S_OK;
    CIterTreeView   iterHti(m_hwndTV);
    HTREEITEM       hti;
    TV_ITEM         tvi = {0};

    // Loop thru each tree item, ordering the OnDisable lists to match the
    // owning component's true binding order

    while ((hti = iterHti.HtiNext()) && SUCCEEDED(hr))
    {
        TREE_ITEM_DATA *    ptid;

        tvi.mask = TVIF_PARAM;
        tvi.hItem = hti;
        TreeView_GetItem(m_hwndTV, &tvi);

        ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
        AssertSz(ptid, "No item data?!");

        hr = HrOrderDisableList(ptid);
    }

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    TraceError("CBindingsDlg::HrOrderDisableLists", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrOrderSubItems
//
//  Purpose:    Orders the sub items of the tree view to reflect the bind
//              order of the system
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrOrderSubItems()
{
    HRESULT     hr = S_OK;
    HTREEITEM   htiTopLevel;

    htiTopLevel = TreeView_GetRoot(m_hwndTV);
    while (htiTopLevel)
    {
        HTREEITEM           htiChild;
        TREE_ITEM_DATA *    ptid;
        TV_ITEM             tvi = {0};

        tvi.mask = TVIF_PARAM;
        tvi.hItem = htiTopLevel;
        TreeView_GetItem(m_hwndTV, &tvi);

        ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
        AssertSz(ptid, "No tree item data??");

        CIterNetCfgBindingPath      ncbpIter(ptid->pncc);
        INetCfgBindingPath *        pncbp;
        HTREEITEM                   htiInsertAfter = NULL;

        while (SUCCEEDED(hr) && S_OK == (hr = ncbpIter.HrNext(&pncbp)))
        {
            BOOL    fFound = FALSE;

            htiChild = TreeView_GetChild(m_hwndTV, htiTopLevel);

            while (htiChild && !fFound)
            {
                TREE_ITEM_DATA *    ptidChild;

                tvi.mask = TVIF_PARAM;
                tvi.hItem = htiChild;
                TreeView_GetItem(m_hwndTV, &tvi);

                ptidChild = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
                AssertSz(ptidChild, "No tree item data??");

                if (!ptidChild->fOrdered)
                {
                    BIND_PATH_INFO *        pbpi;

                    pbpi = BpiFindBindPathInList(pncbp,
                                                 ptidChild->listbpipOnDisable);
                    if (pbpi)
                    {
                        htiInsertAfter = HtiMoveTreeItemAfter(htiTopLevel,
                                                              htiInsertAfter,
                                                              htiChild);
                        ptidChild->fOrdered = TRUE;

                        fFound = TRUE;
                        // Go to next bind path
                        break;
                    }
                }

                htiChild = TreeView_GetNextSibling(m_hwndTV, htiChild);
            }

            ReleaseObj(pncbp);
        }

        htiTopLevel = TreeView_GetNextSibling(m_hwndTV, htiTopLevel);
    }

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    TraceError("CBindingsDlg::HrOrderSubItems", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HtiAddTreeViewItem
//
//  Purpose:    Addes a new tree item according to provided information
//
//  Arguments:
//      pnccOwner [in]  INetCfgComponent owner of component being added
//      htiParent [in]  HTREEITEM of parent (NULL if top-level item)
//
//  Returns:    HTREEITEM of newly added item
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
HTREEITEM CBindingsDlg::HtiAddTreeViewItem(INetCfgComponent * pnccOwner,
                                         HTREEITEM htiParent)
{
    HRESULT                 hr = S_OK;
    HTREEITEM               hti = NULL;
    SP_CLASSIMAGELIST_DATA  cid;

    Assert(pnccOwner);

    // Get the class image list structure
    hr = HrSetupDiGetClassImageList(&cid);
    if (SUCCEEDED(hr))
    {
        BSTR    pszwName;

        hr = pnccOwner->GetDisplayName(&pszwName);
        if (SUCCEEDED(hr))
        {
            GUID    guidClass;

            hr = pnccOwner->GetClassGuid(&guidClass);
            if (SUCCEEDED(hr))
            {
                INT     nIndex;

                // Get the component's class image list index
                hr = HrSetupDiGetClassImageIndex(&cid, &guidClass,
                                                 &nIndex);
                if (SUCCEEDED(hr))
                {
                    TV_INSERTSTRUCT     tvis = {0};
                    TREE_ITEM_DATA *    ptid;

                    ptid = new TREE_ITEM_DATA;
                    if (ptid)
                    {
                        AddRefObj(ptid->pncc = pnccOwner);
                        ptid->fOrdered = FALSE;

                        tvis.item.mask = TVIF_PARAM | TVIF_TEXT |
                                         TVIF_STATE | TVIF_IMAGE |
                                         TVIF_SELECTEDIMAGE;
                        tvis.item.iImage = nIndex;
                        tvis.item.iSelectedImage = nIndex;
                        tvis.item.stateMask = TVIS_STATEIMAGEMASK | TVIS_EXPANDED;
                        tvis.item.state = TVIS_EXPANDED |
                                          INDEXTOSTATEIMAGEMASK(SELS_CHECKED);
                        tvis.item.pszText = pszwName;
                        tvis.item.lParam = reinterpret_cast<LPARAM>(ptid);
                        tvis.hParent = htiParent;
                        tvis.hInsertAfter = TVI_LAST;

                        hti = TreeView_InsertItem(m_hwndTV, &tvis);

                        TraceTag(ttidAdvCfg, "Adding%s treeview item: %S",
                                 htiParent ? " child" : "", tvis.item.pszText);

                        CoTaskMemFree(pszwName);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }

        (void) HrSetupDiDestroyClassImageList(&cid);
    }

    return hti;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddToListIfNotAlreadyAdded
//
//  Purpose:    Addes the given bind path info structure to the given list
//
//  Arguments:
//      bpipList [in, ref]  List to be added to
//      pbpi     [in]       BIND_PATH_INFO structure to add
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:      If the item is not added to the list, it is deleted
//
VOID AddToListIfNotAlreadyAdded(BPIP_LIST &bpipList, BIND_PATH_INFO *pbpi)
{
    BPIP_LIST::iterator     iterBpip;
    BOOL                    fAlreadyInList = FALSE;

    for (iterBpip = bpipList.begin();
         iterBpip != bpipList.end();
         iterBpip++)
    {
        BIND_PATH_INFO *    pbpiList = *iterBpip;

        if (S_OK == pbpiList->pncbp->IsSamePathAs(pbpi->pncbp))
        {
            fAlreadyInList = TRUE;
            break;
        }
    }

    if (!fAlreadyInList)
    {
        bpipList.push_back(pbpi);
    }
    else
    {
        ReleaseObj(pbpi->pncbp);
        delete pbpi;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::AssociateBinding
//
//  Purpose:    Associates the given binding path with the given tree item
//
//  Arguments:
//      pncbpThis [in]  Bind path to associate
//      hti       [in]  HTREEITEM of item to associate the binding with
//      dwFlags   [in]  One or combination of:
//                          ASSCF_ON_ENABLE - associate with OnEnable list
//                          ASSCF_ON_DISABLE - associate with OnDisable list
//                          ASSCF_ANCESTORS - associate this binding with all
//                                            ancestors of the given item as
//                                            well
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:      If binding is already present in the given list, it is not
//              added again.
//
VOID CBindingsDlg::AssociateBinding(INetCfgBindingPath *pncbpThis,
                                  HTREEITEM hti, DWORD dwFlags)
{
    TV_ITEM             tvi = {0};
    TREE_ITEM_DATA *    ptid;

#ifdef ENABLETRACE
    WCHAR               szBuffer[256];
#endif

    //$ TODO (danielwe) 26 Nov 1997: Include ALL ancestors as well!

    AssertSz(dwFlags, "NO flags!");

#ifdef ENABLETRACE
    tvi.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_TEXT;
    tvi.pszText = szBuffer;
    tvi.cchTextMax = celems(szBuffer);
#else
    tvi.mask = TVIF_HANDLE | TVIF_PARAM;
#endif

    tvi.hItem = hti;

    SideAssert(TreeView_GetItem(m_hwndTV, &tvi));

    ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
    AssertSz(ptid, "No tree item data??");

#ifdef ENABLETRACE
    TraceTag(ttidAdvCfg, "Associating the following binding path with tree "
             "item %S", szBuffer);
#endif
    DbgDumpBindPath(pncbpThis);

    if (dwFlags & ASSCF_ON_ENABLE)
    {
        BIND_PATH_INFO *    pbpi;

        pbpi = new BIND_PATH_INFO;
        if (pbpi)
        {
            AddRefObj(pbpi->pncbp = pncbpThis);

            // Note: (danielwe) 25 Nov 1997: Let's see if we need this. Until
            // then, set to 0

            pbpi->dwLength = 0;

            AddToListIfNotAlreadyAdded(ptid->listbpipOnEnable, pbpi);
        }
    }

    if (dwFlags & ASSCF_ON_DISABLE)
    {
        BIND_PATH_INFO *    pbpi;

        pbpi = new BIND_PATH_INFO;
        if (pbpi)
        {
            AddRefObj(pbpi->pncbp = pncbpThis);

            // Note: (danielwe) 25 Nov 1997: Let's see if we need this. Until
            // then, set to 0

            pbpi->dwLength = 0;

            AddToListIfNotAlreadyAdded(ptid->listbpipOnDisable, pbpi);
        }
    }

    if (dwFlags & ASSCF_ANCESTORS)
    {
        // Now associate the same binding with my parent (this will recurse to
        // cover all ancestors)
        HTREEITEM htiParent = TreeView_GetParent(m_hwndTV, hti);
        if (htiParent)
        {
            AssociateBinding(pncbpThis, htiParent, dwFlags);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrHandleSubpath
//
//  Purpose:    Handles the case of the given binding path being a subpath
//              of an already associated binding path
//
//  Arguments:
//      listsbp  [in, ref]  Sorted list of binding paths to use in checking
//      pncbpSub [in]       Binding path to compare
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrHandleSubpath(SBP_LIST &listsbp,
                                    INetCfgBindingPath *pncbpSub)
{
    HRESULT     hr = S_OK;
    BOOL        fProcessed = FALSE;

    SBP_LIST::iterator  iterlist;

    TraceTag(ttidAdvCfg, "---------------------------------------------------"
             "-------------------------");
    DbgDumpBindPath(pncbpSub);
    TraceTag(ttidAdvCfg, "...is being compared to the following...");

    for (iterlist = listsbp.begin();
         iterlist != listsbp.end() && SUCCEEDED(hr);
         iterlist++)
    {
        INetCfgBindingPath *    pncbp;
        INetCfgComponent *      pnccOwner;

        pncbp = (*iterlist).GetPath();
        Assert(pncbp);

        if (S_OK == pncbp->IsSamePathAs(pncbpSub))
        {
            // Don't compare path to itself
            continue;
        }

        hr = pncbp->GetOwner(&pnccOwner);
        if (SUCCEEDED(hr))
        {
            if (FIsHidden(pnccOwner))
            {
                ReleaseObj(pnccOwner);
                continue;
            }
            else
            {
                ReleaseObj(pnccOwner);
            }

            DbgDumpBindPath(pncbp);
            hr = pncbpSub->IsSubPathOf(pncbp);
            if (S_OK == hr)
            {
                CIterTreeView   iterTV(m_hwndTV);
                HTREEITEM       hti;
                TV_ITEM         tvi = {0};
#ifdef ENABLETRACE
                WCHAR           szBuf[256] = {0};
#endif

                while ((hti = iterTV.HtiNext()) && SUCCEEDED(hr))
                {
                    TREE_ITEM_DATA *    ptid;

#ifdef ENABLETRACE
                    tvi.mask = TVIF_TEXT | TVIF_PARAM | TVIF_HANDLE;
                    tvi.pszText = szBuf;
                    tvi.cchTextMax = celems(szBuf);
#else
                    tvi.mask = TVIF_PARAM | TVIF_HANDLE;
#endif
                    tvi.hItem = hti;
                    TreeView_GetItem(m_hwndTV, &tvi);

#ifdef ENABLETRACE
                    TraceTag(ttidAdvCfg, "TreeView item: %S.", szBuf);
#endif
                    ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
                    AssertSz(ptid, "No tree item data??");

                    // Look for pncbp in OnEnable of this item
                    BPIP_LIST::iterator     iterBpip;

                    for (iterBpip = ptid->listbpipOnEnable.begin();
                         iterBpip != ptid->listbpipOnEnable.end();
                         iterBpip++)
                    {
                        INetCfgBindingPath *    pncbpIter;
                        BIND_PATH_INFO *        pbpi = *iterBpip;

                        pncbpIter = pbpi->pncbp;
                        AssertSz(pncbpIter, "No binding path?");

#ifdef ENABLETRACE
                        TraceTag(ttidAdvCfg, "OnEnable bindpath is");
                        DbgDumpBindPath (pncbpIter);
#endif

                        if (S_OK == pncbpIter->IsSamePathAs(pncbp))
                        {
                            hr = HrHandleSubItem(pncbpSub, pncbp, ptid, hti);
                            fProcessed = TRUE;
                        }
                    }
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = fProcessed ? S_OK : S_FALSE;
    }

    TraceError("CBindingsDlg::HrHandleSubpath", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HtiIsSubItem
//
//  Purpose:    Determines if the given component is already a sub item of
//              the given tree item
//
//  Arguments:
//      pncc [in]   Component to check
//      hti  [in]   HTREEITEM of item to check
//
//  Returns:    HTREEITEM of sub item, NULL if it is not a subitem
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
HTREEITEM CBindingsDlg::HtiIsSubItem(INetCfgComponent *pncc, HTREEITEM hti)
{
    HTREEITEM   htiCur;

    htiCur = TreeView_GetChild(m_hwndTV, hti);
    while (htiCur)
    {
        TREE_ITEM_DATA *    ptid;
        TV_ITEM             tvi = {0};

        tvi.hItem = htiCur;
        tvi.mask = TVIF_HANDLE | TVIF_PARAM;
        TreeView_GetItem(m_hwndTV, &tvi);
        ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);

        AssertSz(ptid, "No item data??");

        // Note: (danielwe) 26 Nov 1997: Make sure pointer comparison is
        // ok.
        if (pncc == ptid->pncc)
        {
            return htiCur;
        }

        htiCur = TreeView_GetNextSibling(m_hwndTV, htiCur);
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrHandleSubItem
//
//  Purpose:    Handles the case of a single sub-item existing in the tree
//              that matches the given binding path.
//
//  Arguments:
//      pncbpThis    [in]   Binding path being evaluated
//      pncbpMatch   [in]   Binding path it is a subpath of
//      ptid         [in]   Tree item data for tree view item that pncbpMatch
//                          is associated with
//      htiMatchItem [in]   HTREEITEM of above
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrHandleSubItem(INetCfgBindingPath *pncbpThis,
                                    INetCfgBindingPath *pncbpMatch,
                                    TREE_ITEM_DATA *ptid,
                                    HTREEITEM htiMatchItem)
{
    HRESULT             hr = S_OK;
    DWORD               dwThisLen;
    DWORD               dwMatchLen;
    DWORD               dLen;
    INetCfgComponent *  pnccMatchItem;

    pnccMatchItem = ptid->pncc;

    Assert(pnccMatchItem);

    dwThisLen = GetDepthSpecialCase(pncbpThis);
    dwMatchLen = GetDepthSpecialCase(pncbpMatch);

    dLen = dwMatchLen - dwThisLen;

    if ((dwMatchLen - dwThisLen) == 1 ||
        (S_OK == (hr = HrComponentIsHidden(pncbpMatch, dLen))))
    {
        INetCfgComponent *  pnccThisOwner;
        INetCfgComponent *  pnccMatchOwner;

        hr = pncbpThis->GetOwner(&pnccThisOwner);
        if (SUCCEEDED(hr))
        {
            hr = pncbpMatch->GetOwner(&pnccMatchOwner);
            if (SUCCEEDED(hr))
            {
                if (!FIsHidden(pnccThisOwner) &&
                    !FDontExposeLower(pnccMatchOwner))
                {
                    hr = HrHandleValidSubItem(pncbpThis, pncbpMatch,
                                              pnccThisOwner,
                                              htiMatchItem, ptid);
                }

                ReleaseObj(pnccMatchOwner);
            }

            ReleaseObj(pnccThisOwner);
        }
    }

    AssociateBinding(pncbpThis, htiMatchItem,
                     ASSCF_ON_ENABLE | ASSCF_ANCESTORS);

    TraceError("CBindingsDlg::HrHandleSubItem", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrHandleValidSubItem
//
//  Purpose:    Handles the case of the given binding path being a sub item
//              of at least on item in the tree.
//
//  Arguments:
//      pncbpThis     [in]  THIS binding path
//      pncbpMatch    [in]  MATCH binding path
//      pnccThisOwner [in]  Owner of THIS binding path
//      htiMatchItem  [in]  HTREEITEM of match item
//      ptid          [in]  TREE item data for match item
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrHandleValidSubItem(INetCfgBindingPath *pncbpThis,
                                         INetCfgBindingPath *pncbpMatch,
                                         INetCfgComponent *pnccThisOwner,
                                         HTREEITEM htiMatchItem,
                                         TREE_ITEM_DATA *ptid)
{
    HRESULT     hr = S_OK;
    HTREEITEM   htiNew = NULL;

    if (pnccThisOwner != ptid->pncc)
    {
        // Check if it is already present as a subitem
        htiNew = HtiIsSubItem(pnccThisOwner, htiMatchItem);
        if (!htiNew)
        {
            htiNew = HtiAddTreeViewItem(pnccThisOwner, htiMatchItem);
        }

        AssertSz(htiNew, "No new or existing tree item!?!");

        AssociateBinding(pncbpMatch, htiNew,
                         ASSCF_ON_ENABLE | ASSCF_ON_DISABLE);
        AssociateBinding(pncbpThis, htiNew, ASSCF_ON_ENABLE);
    }

    TraceError("CBindingsDlg::HrHandleComponent", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrComponentIsHidden
//
//  Purpose:    Determines if the Nth component of the given binding path is
//              hidden.
//
//  Arguments:
//      pncbp [in]  Binding path to check
//      iComp [in]  Index of component to check for hidden characterstic
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrComponentIsHidden(INetCfgBindingPath *pncbp,
                                        DWORD iComp)
{
    Assert(pncbp);

    HRESULT                     hr = S_OK;
    CIterNetCfgBindingInterface ncbiIter(pncbp);
    INetCfgBindingInterface *   pncbi;

    // Convert from component count to interface count
    iComp--;

    AssertSz(iComp > 0, "We should never be looking for the first component!");

    while (SUCCEEDED(hr) && iComp && S_OK == (hr = ncbiIter.HrNext(&pncbi)))
    {
        iComp--;
        if (!iComp)
        {
            INetCfgComponent *  pnccLower;

            hr = pncbi->GetLowerComponent(&pnccLower);
            if (SUCCEEDED(hr))
            {
                if (!FIsHidden(pnccLower))
                {
                    hr = S_FALSE;
                }

                ReleaseObj(pnccLower);
            }
        }
        ReleaseObj(pncbi);
    }

    TraceError("CBindingsDlg::HrComponentIsHidden", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrHandleTopLevel
//
//  Purpose:    Handles the case of the given binding path not being associated
//              with any existing tree view item
//
//  Arguments:
//      pncbpThis [in]  Binding path being evaluated
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrHandleTopLevel(INetCfgBindingPath *pncbpThis)
{
    HRESULT             hr = S_OK;
    INetCfgComponent *  pnccOwner;
    BOOL                fFound = FALSE;

    // Check if the owner of this path is already present in the tree
    hr = pncbpThis->GetOwner(&pnccOwner);
    if (SUCCEEDED(hr))
    {
        CIterTreeView   iterTV(m_hwndTV);
        HTREEITEM       hti;
        TV_ITEM         tvi = {0};

        while ((hti = iterTV.HtiNext()) && SUCCEEDED(hr))
        {
            TREE_ITEM_DATA *    ptid;

            tvi.mask = TVIF_PARAM | TVIF_HANDLE;
            tvi.hItem = hti;
            TreeView_GetItem(m_hwndTV, &tvi);

            ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
            AssertSz(ptid, "No tree item data??");

            // Note: (danielwe) 25 Nov 1997: Pointer comparison may not
            // work. Use GUIDs if necessary.
            if (ptid->pncc == pnccOwner)
            {
                // Found match with THIS binding owner and an existing tree
                // item
                AssociateBinding(pncbpThis, hti, ASSCF_ON_ENABLE |
                                 ASSCF_ON_DISABLE);

                fFound = TRUE;
                break;
            }
        }

        if (SUCCEEDED(hr) && !fFound)
        {
            // Not found in the tree
            if (!FIsHidden(pnccOwner))
            {
                DWORD   dwLen;

                dwLen = GetDepthSpecialCase(pncbpThis);

                if (dwLen > 2)
                {
                    HTREEITEM   hti;

                    hti = HtiAddTreeViewItem(pnccOwner, NULL);
                    if (hti)
                    {
                        AssociateBinding(pncbpThis, hti,
                                         ASSCF_ON_ENABLE |
                                         ASSCF_ON_DISABLE);
                    }
                }
            }
        }

        ReleaseObj(pnccOwner);
    }

    TraceError("CBindingsDlg::HrHandleTopLevel", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChangeTreeItemParam
//
//  Purpose:    Helper function to change the lParam of a tree view item
//
//  Arguments:
//      hwndTV [in]     Tree view window
//      hitem  [in]     Handle to item to change
//      lparam [in]     New value of lParam
//
//  Returns:    Nothing
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
VOID ChangeTreeItemParam(HWND hwndTV,  HTREEITEM hitem, LPARAM lparam)
{
    TV_ITEM tvi;

    tvi.hItem = hitem;
    tvi.mask = TVIF_PARAM;
    tvi.lParam = lparam;

    TreeView_SetItem(hwndTV, &tvi);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HtiMoveTreeItemAfter
//
//  Purpose:    Moves the given tree view item and all its children after the
//              given treeview item
//
//  Arguments:
//      htiParent [in]  Parent treeview item
//      htiDest   [in]  Item to move after
//      htiSrc    [in]  Item to move
//
//  Returns:    Newly added treeview item
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
HTREEITEM CBindingsDlg::HtiMoveTreeItemAfter(HTREEITEM htiParent,
                                           HTREEITEM htiDest,
                                           HTREEITEM htiSrc)
{
    HTREEITEM       htiNew;
    HTREEITEM       htiChild;
    HTREEITEM       htiNextChild;
    TV_INSERTSTRUCT tvis;
    WCHAR           szText[256];

    TraceTag(ttidAdvCfg, "Moving ...");
    DbgDumpTreeViewItem(m_hwndTV, htiSrc);
    TraceTag(ttidAdvCfg, "... after ...");
    DbgDumpTreeViewItem(m_hwndTV, htiDest);

    // retieve the items data
    tvis.item.hItem = htiSrc;
    tvis.item.mask = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE |
                     TVIF_TEXT | TVIF_STATE;
    tvis.item.stateMask = TVIS_STATEIMAGEMASK;
    tvis.item.pszText = szText;
    tvis.item.cchTextMax = celems(szText);
    TreeView_GetItem(m_hwndTV, &tvis.item);

    if (NULL == htiDest)
    {
        tvis.hInsertAfter = TVI_LAST;
    }
    else
    {
        if (htiParent == htiDest)
        {
            tvis.hInsertAfter = TVI_FIRST;
        }
        else
        {
            tvis.hInsertAfter = htiDest;
        }
    }

    tvis.hParent = htiParent;

    // add our new one
    htiNew = TreeView_InsertItem(m_hwndTV, &tvis);

    // copy all children
    htiChild = TreeView_GetChild(m_hwndTV, htiSrc);
    while (htiChild)
    {
        htiNextChild = TreeView_GetNextSibling(m_hwndTV, htiChild);

        HtiMoveTreeItemAfter(htiNew, NULL, htiChild);
        htiChild = htiNextChild;
    }

    // set old location param to null, so when it is removed,
    // our lparam is not deleted by our remove routine
    ChangeTreeItemParam(m_hwndTV, htiSrc, NULL);

    // remove from old location
    TreeView_DeleteItem(m_hwndTV, htiSrc);

    return htiNew;
}

//
// Treeview flat iterator
//

//+---------------------------------------------------------------------------
//
//  Member:     CIterTreeView::HtiNext
//
//  Purpose:    Advances the iterator to the next treeview item
//
//  Arguments:
//      (none)
//
//  Returns:    Next HTREEITEM in tree view
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:      Uses a systematic iteration. First all children of first item
//              are returned, then all siblings, then next sibling and so on
//
HTREEITEM CIterTreeView::HtiNext()
{
    HTREEITEM   htiRet;
    HTREEITEM   hti;

    if (m_stackHti.empty())
    {
        return NULL;
    }

    htiRet = Front();
    hti = TreeView_GetChild(m_hwndTV, htiRet);
    if (!hti)
    {
        PopAndDelete();
        hti = TreeView_GetNextSibling(m_hwndTV, htiRet);
        if (hti)
        {
            PushAndAlloc(hti);
        }
        else
        {
            if (!m_stackHti.empty())
            {
                hti = TreeView_GetNextSibling(m_hwndTV, Front());
                PopAndDelete();
                if (hti)
                {
                    PushAndAlloc(hti);
                }
            }
        }
    }
    else
    {
        PushAndAlloc(hti);
    }

    return htiRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\advcfg\order.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O R D E R . H
//
//  Contents:   Header file for Advanced Options->Provider Order
//
//  Notes:
//
//  Author:     sumitc   1 Dec 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nsbase.h"     // must be first to include atl

#include "nsres.h"
#include "resource.h"


typedef list<tstring *>::iterator   ListIter;


static HTREEITEM AppendItem(HWND hwndTV, HTREEITEM hroot, PCWSTR szText, void * lParam, INT iImage);
static void AppendItemList(HWND hwndTV, HTREEITEM hroot, ListStrings lstr, ListStrings lstr2, INT iImage);


bool AreThereMultipleProviders(void);

static HRESULT ReadNetworkProviders(ListStrings& m_lstr, ListStrings& m_lstrDisp);
static HRESULT ReadPrintProviders(ListStrings& m_lstr, ListStrings& m_lstrDisp);

//
// CProviderOrderDlg
//

class CProviderOrderDlg :
    public CPropSheetPage
{
    BEGIN_MSG_MAP(CProviderOrderDlg)

        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_ID_HANDLER(IDC_MOVEUP, OnMoveUp)
        COMMAND_ID_HANDLER(IDC_MOVEDOWN, OnMoveDown)
        NOTIFY_CODE_HANDLER(TVN_SELCHANGED, OnTreeItemChanged)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
    END_MSG_MAP()

    enum { IDD = IDD_PROVIDER};

    CProviderOrderDlg();
    ~CProviderOrderDlg();

    BOOL FShowPage()
    {
        return AreThereMultipleProviders();
    }

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& Handled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnMoveUp(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                         BOOL& bHandled);
    LRESULT OnMoveDown(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                         BOOL& bHandled);
    LRESULT OnTreeItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
#if 0
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                         BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
#endif

private:
    HCURSOR     m_hcurAfter;        // cursor after drag has started
    HCURSOR     m_hcurNoDrop;       // cursor indicating can't drop here
    HICON       m_hiconUpArrow;     // icon for up arrow
    HICON       m_hiconDownArrow;   // icon for down arrow
    HTREEITEM   m_htiNetwork;       // treeitem root for Network (one below actual root)
    HTREEITEM   m_htiPrint;         // treeitem root for Print (one below actual root)

    ListStrings m_lstrNetwork;      // list of strings with (ordered) Network providers
    ListStrings m_lstrNetworkDisp;  // list of display names for Network providers (same order)

    ListStrings m_lstrPrint;        // list of strings with (ordered) Print providers
    ListStrings m_lstrPrintDisp;    // list of display names for Print providers (same order)

    bool        m_fNoNetworkProv:1; // flag to indicate that we failed to get any network providers
    bool        m_fNoPrintProv:1;   // flag to indicate that we failed to get any print providers

    // the following functions fill up lstrDisplayNames with the list of net/print providers
    HRESULT     WriteProviders(HWND hwndTV, bool fPrint);
    HRESULT     MoveItem(bool fMoveUp);
    HRESULT     UpdateUpDownButtons(HWND hwndTV);
};


#if DBG
static void DumpItemList(ListStrings& lstr, PSTR szInfoAboutList);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\commconn\commconn.cpp ===
#include "pch.h"
#pragma hdrstop
#include "commconn.h"    // Standard shell\commconn includes
#include "commconp.h"    // Private shell\commconn includes
#include "conprops.h"
#include "nceh.h"
#include "resource.h"
#include "wizentry.h"


CConnectionCommonUi::CConnectionCommonUi() :
        m_pconMan(NULL),
        m_hIL(NULL)
{
}

CConnectionCommonUi::~CConnectionCommonUi()
{
    ReleaseObj(m_pconMan);
    if (NULL != m_hIL)
        ImageList_Destroy(m_hIL);
}

HRESULT CConnectionCommonUi::HrInitialize()
{
    HRESULT hr = NOERROR;

    // Get the connection manager if we haven't already
    if (NULL == m_pconMan)
    {
        INITCOMMONCONTROLSEX iccex = {0};
        iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
        iccex.dwICC = ICC_USEREX_CLASSES;

        hr = HrCreateInstance(
            CLSID_ConnectionManager,
            CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            &m_pconMan);

        TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

        if (FAILED(hr))
            goto Error;

        // Init the new common controls
        if (FALSE == InitCommonControlsEx(&iccex))
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            goto Error;
        }

        hr = CChooseConnectionDlg::HrLoadImageList(&m_hIL);
    }

Error:
    TraceError("CConnectionCommonUi::HrInitialize",hr);
    return hr;
}

HRESULT CConnectionCommonUi::ChooseConnection(
        NETCON_CHOOSECONN * pChooseConn,
        INetConnection** ppConn)
{
    HRESULT hr     = E_POINTER;

    COM_PROTECT_TRY
    {
        INT                    nRet;
        CChooseConnectionDlg * pdlg = NULL;

        // Parameter Validation
        if ((NULL == pChooseConn) ||
            IsBadReadPtr(pChooseConn, sizeof(NETCON_CHOOSECONN)) ||
            ((NULL != ppConn) && IsBadWritePtr(ppConn, sizeof(INetConnection*))))
        {
            goto Error;
        }

        if ((sizeof(NETCON_CHOOSECONN) != pChooseConn->lStructSize) ||
            ((~NCCHT_ALL) & pChooseConn->dwTypeMask) ||
            ((NULL != pChooseConn->hwndParent) && !IsWindow(pChooseConn->hwndParent)) ||
            (~(NCCHF_CONNECT | NCCHF_CAPTION | NCCHF_AUTOSELECT |
               NCCHF_OKBTTNTEXT | NCCHF_DISABLENEW) & pChooseConn->dwFlags))
        {
            hr = E_INVALIDARG;
            goto Error;
        }

        if ((pChooseConn->dwFlags & NCCHF_CAPTION) &&
            ((NULL == pChooseConn->lpstrCaption) ||
             IsBadStringPtr(pChooseConn->lpstrCaption, 1024)))
        {
            goto Error;
        }

        if ((pChooseConn->dwFlags & NCCHF_OKBTTNTEXT) &&
            ((NULL == pChooseConn->lpstrOkBttnText) ||
             IsBadStringPtr(pChooseConn->lpstrOkBttnText, 1024)))
        {
            goto Error;
        }

        // Initialize
        hr = HrInitialize();
        if (FAILED(hr))
        {
            goto Error;
        }

        // Render the dialog
        Assert(PConMan());
        pdlg = new CChooseConnectionDlg(pChooseConn, this, ppConn);
        if (NULL == pdlg)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        hr = S_OK;
        nRet = DialogBoxParam(_Module.GetResourceInstance(),
                              MAKEINTRESOURCE(IDD_ConnChooser),
                              pChooseConn->hwndParent,
                              (DLGPROC)CChooseConnectionDlg::dlgprocConnChooser,
                              (LPARAM)pdlg);
        if (IDOK != nRet)
        {
            hr = S_FALSE;
        }

        delete pdlg;

Error:
    ;
    }
    COM_PROTECT_CATCH

    TraceErrorOptional("CConnectionCommonUi::ChooseConnection", hr, (S_FALSE==hr));
    return hr;
}


HRESULT CConnectionCommonUi::ShowConnectionProperties (
        HWND hwndParent,
        INetConnection* pCon)
{
    HRESULT          hr       = E_INVALIDARG;
    INetConnection * pConnTmp = NULL;

    COM_PROTECT_TRY
    {
        // Parameter Validation
        if (((NULL != hwndParent) && !IsWindow(hwndParent)))
        {
            goto Error;
        }

        if ((NULL == pCon) || IsBadReadPtr(pCon, sizeof(INetConnection*)))
        {
            hr = E_POINTER;
            goto Error;
        }

        if (FAILED(HrQIAndSetProxyBlanket(pCon, &pConnTmp)))
        {
            hr = E_NOINTERFACE;
            goto Error;
        }
        Assert(NULL != pConnTmp);
        pConnTmp->Release();

        // Initialize
        hr = HrInitialize();
        if (FAILED(hr))
        {
            goto Error;
        }

        hr = HrRaiseConnectionProperties(hwndParent, pCon);

Error:
    ;
    }
    COM_PROTECT_CATCH

    TraceErrorOptional("CConnectionCommonUi::ShowConnectionProperties", hr, (S_FALSE==hr));
    return hr;
}

HRESULT CConnectionCommonUi::StartNewConnectionWizard (
        HWND hwndParent,
        INetConnection** ppCon)
{
    HRESULT hr = E_INVALIDARG;

    COM_PROTECT_TRY
    {
        // Parameter Validation
        if ((NULL != hwndParent) && !IsWindow(hwndParent))
        {
            goto Error;
        }

        if ((NULL == ppCon) || IsBadWritePtr(ppCon, sizeof(INetConnection*)))
        {
            hr = E_POINTER;
            goto Error;
        }

        // Initialize
        hr = HrInitialize();
        if (FAILED(hr))
        {
            goto Error;
        }

        *ppCon = NULL;
        hr = NetSetupAddRasConnection(hwndParent, ppCon);

Error:
    ;
    }
    COM_PROTECT_CATCH

    TraceErrorOptional("CConnectionCommonUi::StartNewConnectionWizard", hr, (S_FALSE==hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\advcfg\order.cpp ===
//+-------------------------------------------------------------------
//
//  File:       order.cpp
//
//  Synopsis:   code for Advanced Options->Provider Order
//
//  History:    1-Dec-97    SumitC      Created
//
//  Copyright 1985-1997 Microsoft Corporation, All Rights Reserved
//
//--------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "achelp.h"
#include "acsheet.h"
#include "order.h"
#include "ncui.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "winspool.h"

extern const WCHAR c_szNetCfgHelpFile[];

const int   c_nMaxProviderTitle = 128;

const WCHAR c_chComma = WCHAR(',');

const WCHAR c_szNetwkProviderKey[] =   L"System\\CurrentControlSet\\Control\\NetworkProvider\\Order";
const WCHAR c_szNetwkProviderValue[] = L"ProviderOrder";
const WCHAR c_szNetwkService0[] =      L"System\\CurrentControlSet\\Services\\%s\\NetworkProvider";
const WCHAR c_szNetwkDisplayName[] =   L"Name";
const WCHAR c_szNetwkClass[] =         L"Class";

const WCHAR c_szPrintProviderKey[] =   L"System\\CurrentControlSet\\Control\\Print\\Providers";
const WCHAR c_szPrintProviderValue[] = L"Order";
const WCHAR c_szPrintService0[] =      L"System\\CurrentControlSet\\Control\\Print\\Providers\\%s";
const WCHAR c_szPrintDisplayName[] =   L"DisplayName";

const WCHAR c_szNetwkGetFailed[] =     L"failed to get network providers";
const WCHAR c_szPrintGetFailed[] =     L"failed to get print providers";


const DWORD g_aHelpIDs_IDD_ADVCFG_Provider[]=
{
    IDC_TREEVIEW,IDH_TREEVIEW,
    IDC_MOVEUP,IDH_MOVEUP,
    IDC_MOVEDOWN,IDH_MOVEDOWN,
    0,0
};

CProviderOrderDlg::CProviderOrderDlg()
{
    m_hcurAfter = m_hcurNoDrop = NULL;
    m_hiconUpArrow = m_hiconDownArrow = NULL;
}


CProviderOrderDlg::~CProviderOrderDlg()
{
    DeleteColString(&m_lstrNetwork);
    DeleteColString(&m_lstrNetworkDisp);
    DeleteColString(&m_lstrPrint);
    DeleteColString(&m_lstrPrintDisp);
    if (m_hiconUpArrow)
    {
        DeleteObject(m_hiconUpArrow);
    }
    if (m_hiconDownArrow)
    {
        DeleteObject(m_hiconDownArrow);
    }

}


LRESULT
CProviderOrderDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HWND        hwndTV;
    HTREEITEM   htiRoot;
    HRESULT     hr;
    PCWSTR      pszNetwork, pszPrint;
    HIMAGELIST  hil = NULL;
    INT         iNetClient, iPrinter;

//    CascadeDialogToWindow(hwndDlg, porder->GetParent(), FALSE);

    // setup drag and drop cursors

    m_hcurAfter = LoadCursor(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDCUR_AFTER));
    m_hcurNoDrop = LoadCursor(NULL, IDC_NO);
    m_hiconUpArrow = (HICON)LoadImage(_Module.GetResourceInstance(),
                                      MAKEINTRESOURCE(IDI_UP_ARROW),
                                      IMAGE_ICON, 16, 16, 0);
    m_hiconDownArrow = (HICON)LoadImage(_Module.GetResourceInstance(),
                                        MAKEINTRESOURCE(IDI_DOWN_ARROW),
                                        IMAGE_ICON, 16, 16, 0);

    m_htiNetwork = NULL;
    m_htiPrint = NULL;

    m_fNoNetworkProv = m_fNoPrintProv = FALSE;

    pszNetwork = SzLoadIds(IDS_NCPA_NETWORK);
    pszPrint = SzLoadIds(IDS_NCPA_PRINT);

    //$ REVIEW (sumitc, 11-dec-97): why exactly do we have this separator line?  (NT4 has it too)
    // Changes the style of the static control so it displays
    HWND hLine = GetDlgItem(IDC_STATIC_LINE);
    ::SetWindowLong(hLine, GWL_EXSTYLE, WS_EX_STATICEDGE | ::GetWindowLong(hLine, GWL_EXSTYLE));
    ::SetWindowPos(hLine, 0, 0,0,0,0, SWP_FRAMECHANGED|SWP_NOMOVE|
                            SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    // treeview stuff

    hwndTV = GetDlgItem(IDC_TREEVIEW);

    // prepare treeview
    {
        // use system imagelist functions

        SP_CLASSIMAGELIST_DATA cild;

        hr = HrSetupDiGetClassImageList(&cild);

        hil = ImageList_Duplicate(cild.ImageList);
        //$ REVIEW (sumitc, 11-dec-97) note down these indices and hardcode them?
        hr = ::HrSetupDiGetClassImageIndex(
                        &cild,
                        const_cast<LPGUID>(&GUID_DEVCLASS_NETCLIENT),
                        &iNetClient);
        hr = ::HrSetupDiGetClassImageIndex(
                        &cild,
                        const_cast<LPGUID>(&GUID_DEVCLASS_PRINTER),
                        &iPrinter);
        hr = HrSetupDiDestroyClassImageList(&cild);
    }

    TreeView_SetImageList(hwndTV, hil, TVSIL_NORMAL);

    // fill treeview
    //

    // Network Providers
    hr = ReadNetworkProviders(m_lstrNetwork, m_lstrNetworkDisp);

#if DBG
    DumpItemList(m_lstrNetworkDisp, "Network Provider Order");
#endif

    if (hr == S_OK)
    {
        htiRoot = AppendItem(hwndTV, (HTREEITEM)NULL, pszNetwork, NULL, iNetClient);
        AppendItemList(hwndTV, htiRoot, m_lstrNetworkDisp, m_lstrNetwork, iNetClient);
        TreeView_Expand(hwndTV, htiRoot, TVE_EXPAND);
        m_htiNetwork = htiRoot;
    }
    else
    {
        AppendItem(hwndTV, NULL, c_szNetwkGetFailed, NULL, iNetClient);
        m_fNoNetworkProv = TRUE;
    }

    // Print Providers
    hr = ReadPrintProviders(m_lstrPrint, m_lstrPrintDisp);

#if DBG
    DumpItemList(m_lstrPrintDisp, "Print Provider Order");
#endif
    if (hr == S_OK)
    {
        htiRoot = AppendItem(hwndTV, (HTREEITEM)NULL, pszPrint, NULL, iPrinter);
        AppendItemList(hwndTV, htiRoot, m_lstrPrintDisp, m_lstrPrint, iPrinter);
        TreeView_Expand(hwndTV, htiRoot, TVE_EXPAND);
        m_htiPrint = htiRoot;
    }
    else
    {
        AppendItem(hwndTV, NULL, c_szPrintGetFailed, NULL, iPrinter);
        m_fNoPrintProv = TRUE;
    }

    SendDlgItemMessage(IDC_MOVEUP, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(m_hiconUpArrow));
    SendDlgItemMessage(IDC_MOVEDOWN, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(m_hiconDownArrow));

    UpdateUpDownButtons(hwndTV);

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Method: CProviderOrderDlg::OnContextMenu
//
//  Desc:   Bring up context-sensitive help
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
LRESULT
CProviderOrderDlg::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    ::WinHelp(m_hWnd,
              c_szNetCfgHelpFile,
              HELP_CONTEXTMENU,
              reinterpret_cast<ULONG_PTR>(g_aHelpIDs_IDD_ADVCFG_Provider));
    
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Method: CProviderOrderDlg::OnHelp
//
//  Desc:   Bring up context-sensitive help when dragging ? icon over a control
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
//
LRESULT
CProviderOrderDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((g_aHelpIDs_IDD_ADVCFG_Provider != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)g_aHelpIDs_IDD_ADVCFG_Provider);
    }
    return 0;
}

//+--------------------------------------------------------------------------
//
//  Method: CProviderOrderDlg::OnOk
//
//  Desc:   if we found network or print providers, write out the new values
//
//  Args:   [usual dialog stuff]
//
//  Return: LRESULT
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
LRESULT
CProviderOrderDlg::OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr;
    HWND        hwndTV;

    CWaitCursor wc;

    hwndTV = GetDlgItem(IDC_TREEVIEW);
    hr = m_fNoNetworkProv ? S_OK : WriteProviders(hwndTV, FALSE);
    if (hr == S_OK)
    {
        hr = m_fNoPrintProv ? S_OK : WriteProviders(hwndTV, TRUE);
        if (FAILED(hr))
        {
            NcMsgBox(_Module.GetResourceInstance(), m_hWnd, 
                IDS_ADVANCEDLG_WRITE_PROVIDERS_CAPTION, 
                IDS_ADVANCEDLG_WRITE_PRINT_PROVIDERS_ERROR, 
                MB_OK | MB_ICONEXCLAMATION);
        }
    }
    else
    {
        NcMsgBox(_Module.GetResourceInstance(), m_hWnd, 
            IDS_ADVANCEDLG_WRITE_PROVIDERS_CAPTION, 
            IDS_ADVANCEDLG_WRITE_NET_PROVIDERS_ERROR, 
            MB_OK | MB_ICONEXCLAMATION);
    }

    

    TraceError("CProviderOrderDlg::OnOk", hr);
    return LresFromHr(hr);
}


LRESULT
CProviderOrderDlg::OnMoveUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    MoveItem(TRUE);

    return 0;
}


LRESULT
CProviderOrderDlg::OnMoveDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    MoveItem(FALSE);

    return 0;
}


LRESULT
CProviderOrderDlg::OnTreeItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)pnmh;

    HWND hwndTV = GetDlgItem(IDC_TREEVIEW);

    if (pnmtv && pnmtv->itemOld.hItem)
        UpdateUpDownButtons(hwndTV);

    return 0;
}



//+--------------------------------------------------------------------------
//
//      Utility member functions
//
//---------------------------------------------------------------------------


//+--------------------------------------------------------------------------
//
//  Method: CProviderOrderDlg::MoveItem
//
//  Desc:   does the list mangling required in order to move an item
//
//  Args:   [fMoveUp] -- true -> move up, false -> move down
//
//  Return: HRESULT
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
HRESULT
CProviderOrderDlg::MoveItem(bool fMoveUp)
{
    HWND        hwndTV = GetDlgItem(IDC_TREEVIEW);
    HTREEITEM   htiSel = TreeView_GetSelection(hwndTV);
    HTREEITEM   htiOther;
    HTREEITEM   flag;
    WCHAR       achText[c_nMaxProviderTitle+1];
    TV_ITEM     tvi;
    TV_INSERTSTRUCT tvii;

    // find tree element, find which element (iElement)

    tvi.hItem       = htiSel;
    tvi.mask        = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT;
    tvi.pszText     = achText;
    tvi.cchTextMax  = c_nMaxProviderTitle;
    TreeView_GetItem(hwndTV, &tvi);

    // find the item to insert the item after
    if (fMoveUp)
    {
        htiOther = TreeView_GetPrevSibling(hwndTV, htiSel);
        if (NULL != htiOther)
        {
            htiOther = TreeView_GetPrevSibling(hwndTV, htiOther);
        }
        flag = TVI_FIRST;
    }
    else
    {
        htiOther = TreeView_GetNextSibling(hwndTV, htiSel);
        flag = TVI_LAST;
    }

    // insert into new location
    if (NULL == htiOther)
    {
        tvii.hInsertAfter = flag;
    }
    else
    {
        tvii.hInsertAfter = htiOther;
    }
    tvii.hParent = TreeView_GetParent(hwndTV, htiSel);
    tvii.item = tvi;

    htiOther = TreeView_InsertItem(hwndTV, &tvii);

    // remove from old location
    TreeView_DeleteItem(hwndTV, htiSel);

    // set selection focus to new location
    TreeView_SelectItem(hwndTV, htiOther);

    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Method: CProviderOrderDlg::UpdateUpDownButtons
//
//  Desc:   enables/disables the up and down arrows as appropriate
//
//  Args:   [hwndTV] -- handle to the treeview root
//
//  Return: HRESULT
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
HRESULT
CProviderOrderDlg::UpdateUpDownButtons(HWND hwndTV)
{
    HTREEITEM   htiSel;
    bool        fEnableUp, fEnableDown;
    HWND        hwndUp = GetDlgItem(IDC_MOVEUP);
    HWND        hwndDn = GetDlgItem(IDC_MOVEDOWN);
    HWND        hwndFocus = GetFocus();
    HWND        hwndNewFocus = hwndTV;
    UINT        nIdNewDef = 0;

    // Initialize to disabled
    fEnableUp = fEnableDown = FALSE;

    if (htiSel = TreeView_GetSelection(hwndTV))
    {
        // if this item has no children it can be moved.
        //
        if (TreeView_GetChild(hwndTV, htiSel) == NULL)
        {
            if (TreeView_GetPrevSibling(hwndTV, htiSel) != NULL)
            {
                // Enable Move Up button
                fEnableUp = TRUE;
            }

            if (TreeView_GetNextSibling(hwndTV, htiSel) != NULL)
            {
                // Enable Move Down button
                fEnableDown = TRUE;
            }
        }
    }

    if ((hwndFocus == hwndUp) && (FALSE == fEnableUp))
    {
        if (fEnableDown)
        {
            hwndNewFocus = hwndDn;
            nIdNewDef = IDC_MOVEDOWN;
        }

        SetDefaultButton(m_hWnd, nIdNewDef);
        ::SetFocus(hwndNewFocus);
    }
    else if ((hwndFocus == hwndDn) && (FALSE == fEnableDown))
    {
        if (fEnableUp)
        {
            hwndNewFocus = hwndUp;
            nIdNewDef = IDC_MOVEUP;
        }

        SetDefaultButton(m_hWnd, nIdNewDef);
        ::SetFocus(hwndNewFocus);
    }
    else
    {
        // Neither Up or Down is button with focus, remove any default button
        //
        SetDefaultButton(m_hWnd, 0);
    }

    ::EnableWindow(hwndUp, fEnableUp);
    ::EnableWindow(hwndDn, fEnableDown);

    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Method: CProviderOrderDlg::WriteProviders
//
//  Desc:   writes out, to the registry, the providers for network/print,
//
//  Args:   [hwndTV] -- handle to treeview
//          [fPrint] -- true -> print, false -> network
//
//  Return: HRESULT
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
HRESULT
CProviderOrderDlg::WriteProviders(HWND hwndTV, bool fPrint)
{
    HRESULT     hr = S_OK;
    ListStrings lstrNewOrder;
    HTREEITEM   htvi;
    TV_ITEM     tvi;
    WCHAR       achBuf[c_nMaxProviderTitle+1];
    HKEY        hkey = NULL;

    tvi.mask = TVIF_TEXT;
    tvi.pszText = achBuf;
    tvi.cchTextMax = c_nMaxProviderTitle;

    // retrieve items in order

    ListStrings * plstrProvider = fPrint ? &m_lstrPrint : &m_lstrNetwork;

#if DBG
    DumpItemList(*plstrProvider, "WriteProviders list (just before clearing)");
#endif
    plstrProvider->clear();
    //  we clear out the provider list, but NOTE! we don't delete the tstrings,
    //  since they're still being referenced by the lParams of the treeview items.
    //  the following block of code gets them back into (a new) m_lstrX.

    htvi = TreeView_GetChild(hwndTV, fPrint ? m_htiPrint : m_htiNetwork);
    while (NULL != htvi)
    {
        tvi.hItem = htvi;
        TreeView_GetItem(hwndTV, &tvi);
        TraceTag(ttidAdvCfg, "recovered item: %S and %S", tvi.pszText, ((tstring *)(tvi.lParam))->c_str());
        plstrProvider->push_back((tstring *)(tvi.lParam));
        htvi = TreeView_GetNextSibling(hwndTV, htvi);
    }

    if (fPrint)
    {
#if DBG
        DumpItemList(m_lstrPrint, "PrintProviders");
#endif
        PROVIDOR_INFO_2  p2info;

        ColStringToMultiSz(m_lstrPrint, &p2info.pOrder);
        if (!AddPrintProvidor(NULL, 2, reinterpret_cast<LPBYTE>(&p2info)))
        {
            hr = HrFromLastWin32Error();
        }
        delete [] p2info.pOrder;
    }
    else
    {
        hr = ::HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szNetwkProviderKey, KEY_WRITE, &hkey);
        if (hr == S_OK)
        {
            tstring str;

            ::ConvertColStringToString(m_lstrNetwork, c_chComma, str);
#if DBG
            TraceTag(ttidAdvCfg, "net providers = %S", str.c_str());
#endif
            hr = ::HrRegSetSz(hkey, c_szNetwkProviderValue, str.c_str());
        }
    }

    RegSafeCloseKey(hkey);
    return hr;
}



//+--------------------------------------------------------------------------
//
//      Utility functions (non-member)
//
//---------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Func:   AppendItem
//
//  Desc:   adds one item into a treeview control
//
//  Args:
//
//  Return:
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//--------------------------------------------------------------------------

HTREEITEM
AppendItem(HWND hwndTV, HTREEITEM htiRoot, PCWSTR pszText, void * lParam, INT iImage)
{
    TV_INSERTSTRUCT tvis;

    tvis.hParent                = htiRoot;
    tvis.hInsertAfter           = TVI_LAST;
    tvis.item.mask              = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvis.item.pszText           = (PWSTR) pszText;
    tvis.item.iImage            = iImage;
    tvis.item.iSelectedImage    = iImage;
    tvis.item.lParam            = (LPARAM) lParam;
    TraceTag(ttidAdvCfg, "append item: item = %S, data = %S", pszText, lParam ? ((tstring *)(lParam))->c_str() : L"null");

    return( TreeView_InsertItem( hwndTV, &tvis ) );
}


//+--------------------------------------------------------------------------
//
//  Func:   AppendItemList
//
//  Desc:   adds a list of providers as subitems to a given tree node.
//
//  Args:
//
//  Return: (void)
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
void
AppendItemList(HWND hwndTV, HTREEITEM htiRoot, ListStrings lstr, ListStrings lstr2, INT iImage)
{
    ListIter    iter;
    ListIter    iter2;

    AssertSz(lstr.size() == lstr2.size(), "data corruption - these lists should the same size");
    for (iter = lstr.begin(), iter2 = lstr2.begin();
         iter != lstr.end();
         iter++, iter2++)
    {
        AppendItem(hwndTV, (HTREEITEM)htiRoot, (*iter)->c_str(), (void *)(*iter2), iImage);
    }
}


//+--------------------------------------------------------------------------
//
//  Meth:   ReadNetworkProviders
//
//  Desc:   fills up lstr with network provider names, and lstrDisp with the
//          corresponding 'friendly' names.
//
//  Args:   [lstr]     -- string list for providers (short names)
//          [lstrDisp] -- string list for provider display-names (friendly names)
//
//  Return: HRESULT
//
//  Notes:  m_lstrNetwork and m_lstrNetworkDisp must be empty on entry.
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
HRESULT
ReadNetworkProviders(ListStrings& lstr, ListStrings& lstrDisp)
{
    HKEY        hkey;
    HRESULT     hr;
    ListIter    iter;

    AssertSz(lstr.empty(), "incorrect call order (this should be empty)");

    WCHAR szBuf[c_nMaxProviderTitle + 1];
    DWORD cBuf = sizeof(szBuf);

    hr = ::HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szNetwkProviderKey, KEY_READ, &hkey);
    if (hr == S_OK)
    {
        hr = ::HrRegQuerySzBuffer(hkey, c_szNetwkProviderValue, szBuf, &cBuf);
        if (hr == S_OK)
        {
            ConvertStringToColString(szBuf, c_chComma, lstr);
        }
        RegSafeCloseKey(hkey);
    }

    if (hr)
        goto Error;

    AssertSz(lstrDisp.empty(), "incorrect call order (this should be empty)");
    for (iter = lstr.begin(); iter != lstr.end(); iter++)
    {
        WCHAR   szBuf[c_nMaxProviderTitle + sizeof(c_szNetwkService0)];
        tstring str;
        HKEY    hkeyProv;

        wsprintfW(szBuf, c_szNetwkService0, (*iter)->c_str());
        hr = ::HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf, KEY_READ, &hkeyProv);
        if (hr == S_OK)
        {
#if 0
            DWORD dwClass = 0;

            // now get displayname and class
            hr = ::HrRegQueryDword(hkeyProv, c_szNetwkClass, &dwClass);
            if (dwClass & WN_NETWORK_CLASS)
            {
#endif
                hr = ::HrRegQueryString(hkeyProv, c_szNetwkDisplayName, &str);
                if (hr == S_OK)
                {
                    lstrDisp.push_back(new tstring(str));
                }
                else
                {
                    TraceTag(ttidAdvCfg, "failed to get DisplayName for network provider %S", (*iter)->c_str());
                }
#if 0
            }
            else
            {
                hr = S_OK;
                // actually, if we start taking the netclass into account we'll
                // have to delete the corresponding item (*iter) from m_lstrNetwork,
                // otherwise the two lists will be out of sync.
            }
#endif
            RegSafeCloseKey(hkeyProv);
        }
        else
        {
            TraceTag(ttidAdvCfg, "a member of the networkprovider string is missing NetworkProvider key under Services!");
        }
    }

    AssertSz(lstr.size() == lstrDisp.size(), "lists must be the same size");

Error:
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Method: ReadPrintProviders
//
//  Desc:   fills up lstr with print provider names, and lstrDisp with the
//          corresponding 'friendly' names.
//
//  Args:   [lstr]     -- string list for providers (short names)
//          [lstrDisp] -- string list for provider display-names (friendly names)
//
//  Return: HRESULT
//
//  Notes:  m_lstrPrint and m_lstrPrintDisp must be empty on entry.
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
HRESULT
ReadPrintProviders(ListStrings& lstr, ListStrings& lstrDisp)
{
    HKEY        hkey;
    HRESULT     hr;
    ListIter    iter;

    AssertSz(lstr.empty(), "incorrect call order (this should be empty)");
    hr = ::HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szPrintProviderKey, KEY_READ, &hkey);
    if (hr == S_OK)
    {
        hr = ::HrRegQueryColString(hkey, c_szPrintProviderValue, &lstr);
        RegSafeCloseKey(hkey);
    }

    AssertSz(lstrDisp.empty(), "incorrect call order (this should be empty)");
    for (iter = lstr.begin(); iter != lstr.end(); iter++)
    {
        WCHAR   szBuf[c_nMaxProviderTitle + sizeof(c_szPrintService0)];
        tstring str;
        HKEY    hkeyProv;

        wsprintfW(szBuf, c_szPrintService0, (*iter)->c_str());
        hr = ::HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf, KEY_READ, &hkeyProv);
        if (hr == S_OK)
        {
            hr = ::HrRegQueryString(hkeyProv, c_szPrintDisplayName, &str);
            if (hr == S_OK)
            {
                lstrDisp.push_back(new tstring(str));
            }
            else
            {
                TraceTag(ttidAdvCfg, "failed to get DisplayName for printer %S", (*iter)->c_str());
            }
            RegSafeCloseKey(hkeyProv);
        }
        else
        {
            TraceTag(ttidAdvCfg, "a member of the print/providers/order string doesn't have key under control/print/providers!");
        }
    }

    AssertSz(lstr.size() == lstrDisp.size(), "lists must be the same size");

    return hr;
}


bool
AreThereMultipleProviders(void)
{
    HRESULT             hr;
    ListStrings         lstrN, lstrND, lstrP, lstrPD;   // netwk, netwk display, etc..
    bool                fRetval = FALSE;

    hr = ReadNetworkProviders(lstrN, lstrND);
    if (hr == S_OK)
    {
        hr = ReadPrintProviders(lstrP, lstrPD);
        if (hr == S_OK)
        {
            fRetval = ((lstrN.size() > 1) || (lstrP.size() > 1));
        }
    }

    DeleteColString(&lstrN);
    DeleteColString(&lstrND);
    DeleteColString(&lstrP);
    DeleteColString(&lstrPD);

    return fRetval;
}


#if DBG

//+--------------------------------------------------------------------------
//
//  Funct:  DumpItemList
//
//  Desc:   debug utility function to dump out the given list
//
//  Args:
//
//  Return: (void)
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
static void
DumpItemList(ListStrings& lstr, PSTR szInfoAboutList = NULL)
{
    ListIter iter;

    if (szInfoAboutList)
    {
        TraceTag(ttidAdvCfg, "Dumping contents of: %s", szInfoAboutList);
    }

    for (iter = lstr.begin(); iter != lstr.end(); ++iter)
    {
        PWSTR psz = (PWSTR)((*iter)->c_str());
        TraceTag(ttidAdvCfg, "%S", psz);
    }
    TraceTag(ttidAdvCfg, "... end list");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\commconn\resource.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R E S O U R C E . H
//
//  Contents:   defines constants for the connections common ui
//
//  Notes:
//
//  Author:     scottbri   14 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _RESOURCE_H_
#define _RESOURCE_H_


// Dialog IDD's 
#define IDD_ConnChooser         22000

// String ID's   
#define IDS_CONNECT_CAPTION     22010
#define IDS_OKBTTNTEXT          22011
#define IDS_NO_CONNECTIONS      22012

// Control ID's
#define BTN_CHOOSER_OK          22040
#define BTN_CHOOSER_NEW         22041
#define BTN_CHOOSER_PROPS       22042
#define CMB_CHOOSER_LIST        22043
#define TXT_CHOOSER_CMB         22044

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\commconn\commconp.cpp ===
#include "pch.h"
#pragma hdrstop

#include "ncnetcon.h"
#include "conprops.h"
#include "commconn.h"    // Standard shell\commconn includes
#include "commconp.h"    // Private shell\commconn includes
#include "resource.h"
#include "ncperms.h"



typedef struct
{
    NETCON_MEDIATYPE  nct;
    NETCON_CHOOSETYPE ncct;
    UINT              nIDI;
    INT               nIDI_Idx;
} ConnTypeChooserMap;
static ConnTypeChooserMap ConnTypeMap[] = {
        {NCM_DIRECT,         NCCHT_DIRECT_CONNECT, IDI_DB_GEN_S_16, 0},
        {NCM_LAN,            NCCHT_LAN,            IDI_LB_GEN_S_16, 0},
        {NCM_PHONE,          NCCHT_PHONE,          IDI_PB_GEN_S_16, 0},
        {NCM_ISDN,           NCCHT_ISDN,           IDI_PB_GEN_S_16, 0},
        {NCM_TUNNEL,         NCCHT_TUNNEL,         IDI_TB_GEN_S_16, 0}};

CChooseConnectionData::CChooseConnectionData(INetConnection * pConn)
{
    Assert(pConn);
    m_pConn = pConn;
    AddRefObj(m_pConn);

    m_Nct    = NCM_LAN;
    m_Ncs    = NCS_DISCONNECTED;
    m_dwChar = 0;
}

HRESULT CChooseConnectionData::HrCreate(INetConnection * pNetCon,
                                        CChooseConnectionData **ppData)
{
    HRESULT                 hr = E_OUTOFMEMORY;
    CChooseConnectionData * pData = NULL;
    NETCON_PROPERTIES *     pProps = NULL;

    pData = new CChooseConnectionData(pNetCon);
    if (NULL == pData)
        goto Error;

    hr = pNetCon->GetProperties(&pProps);
    if (FAILED(hr))
        goto Error;

    Assert(NULL != pProps->pszwName);
    pData->SetName(pProps->pszwName);
    pData->SetCharacteristics(pProps->dwCharacter);
    pData->SetType(pProps->MediaType);
    pData->SetStatus(pProps->Status);

Error:
    if (FAILED(hr))
    {
        delete pData;
    }
    else
    {
        Assert(NULL != pData);
        *ppData = pData;
    }

    FreeNetconProperties(pProps);

    TraceError("CChooseConnectionData::HrCreate",hr);
    return hr;
}

CChooseConnectionData::~CChooseConnectionData()
{
    ReleaseObj(m_pConn);
}


CChooseConnectionDlg::CChooseConnectionDlg(NETCON_CHOOSECONN * pChooseConn,
                                           CConnectionCommonUi * pConnUi,
                                           INetConnection** ppConn)
{
    Assert(pChooseConn);
    Assert(pConnUi);

    m_pChooseConn = pChooseConn;
    m_pConnUi = pConnUi;
    m_ppConn = ppConn;          // The optional out parameter
    if (NULL != m_ppConn)
    {
        *m_ppConn = NULL;
    }

    m_hWnd = NULL;
}

CChooseConnectionDlg::~CChooseConnectionDlg()
{
    m_pChooseConn = NULL;
    m_pConnUi = NULL;
}

HRESULT CChooseConnectionDlg::HrLoadImageList(HIMAGELIST  * pIL)
{
    UINT        nIdx;
    HRESULT     hr  = E_OUTOFMEMORY;
    HIMAGELIST  hIL = ImageList_Create(16, 16, TRUE, 6, 1);
    if (NULL == hIL)
        goto Error;

    for (nIdx=0; nIdx<celems(ConnTypeMap); nIdx++)
    {
        HICON hIcon = LoadIcon(_Module.GetResourceInstance(),
                               MAKEINTRESOURCE(ConnTypeMap[nIdx].nIDI));
        Assert(NULL != hIcon);
        ConnTypeMap[nIdx].nIDI_Idx = ImageList_AddIcon(hIL, hIcon);
        if (-1 == ConnTypeMap[nIdx].nIDI_Idx)
            goto Error;
    }

    *pIL = hIL;
    hr = S_OK;

Error:
    TraceError("CChooseConnectionDlg::HrLoadImageList",hr);
    return hr;
}

VOID CChooseConnectionDlg::ReleaseData()
{
    if (NULL != m_hWnd)
    {
        HWND hwndCMB = GetDlgItem(m_hWnd, CMB_CHOOSER_LIST);
        LONG lCnt = SendMessage(hwndCMB, CB_GETCOUNT, 0, 0);
        for (;lCnt>0;)
        {
            CChooseConnectionData * pData = GetData(--lCnt);
            delete pData;
        }

        SendMessage(hwndCMB, CB_RESETCONTENT, 0, 0);
    }
}

BOOL CChooseConnectionDlg::IsConnTypeInMask(NETCON_MEDIATYPE nct)
{
    BOOL fFound = FALSE;

    for (UINT nIdx=0; nIdx<celems(ConnTypeMap); nIdx++)
    {
        if ((ConnTypeMap[nIdx].nct == nct) &&
            (ConnTypeMap[nIdx].ncct & m_pChooseConn->dwTypeMask))
        {
            fFound = TRUE;
            break;
        }
    }

    return fFound;
}

INT CChooseConnectionDlg::ConnTypeToImageIdx(NETCON_MEDIATYPE nct)
{
    UINT nIdx;
    for (nIdx=0; nIdx<celems(ConnTypeMap); nIdx++)
        if (ConnTypeMap[nIdx].nct == nct)
            break;

    Assert(nIdx < celems(ConnTypeMap));;
    return ConnTypeMap[nIdx].nIDI_Idx;
}

LONG CChooseConnectionDlg::FillChooserCombo()
{
    HRESULT         hr;
    LONG            lCnt = 0;
    COMBOBOXEXITEM  CBItem = {0};
    HWND            hwndCMB = GetDlgItem(m_hWnd, CMB_CHOOSER_LIST);

    // Free anything currently in the combo box
    ReleaseData();

    // Query new data for the combo box
    Assert(NULL != m_pConnUi->PConMan());

    INetConnection * pNetCon;
    CIterNetCon ncIter(m_pConnUi->PConMan(), NCME_DEFAULT);
    hr = S_OK;
    while (SUCCEEDED(hr) &&
           S_OK == (hr = ncIter.HrNext(&pNetCon)))
    {
        NETCON_PROPERTIES* pProps;
        hr = pNetCon->GetProperties(&pProps);

        if (SUCCEEDED(hr))
        {
            if (IsConnTypeInMask(pProps->MediaType))
            {
                CChooseConnectionData * pData = NULL;
                hr = CChooseConnectionData::HrCreate(pNetCon, &pData);
                if (SUCCEEDED(hr))
                {
                    pData->SetCharacteristics(pProps->dwCharacter);
                    pData->SetType(pProps->MediaType);
                    pData->SetStatus(pProps->Status);

                    CBItem.mask = CBEIF_IMAGE | CBEIF_SELECTEDIMAGE | CBEIF_LPARAM | CBEIF_TEXT;
                    CBItem.iItem = -1;
                    CBItem.pszText = const_cast<PWSTR>(pData->SzName());
                    CBItem.cchTextMax = lstrlenW(pData->SzName());
                    CBItem.iImage = ConnTypeToImageIdx(pProps->MediaType);
                    CBItem.iSelectedImage = CBItem.iImage;
                    CBItem.lParam = reinterpret_cast<LPARAM>(pData);

                    if (-1 != SendMessage(hwndCMB, CBEM_INSERTITEM, 0, (LPARAM)&CBItem))
                        lCnt++;
                }
            }

            FreeNetconProperties(pProps);
        }

        ReleaseObj(pNetCon);
    }

    if (0 == lCnt)
    {
        // Add a "No connection found" line
        CBItem.mask = CBEIF_IMAGE | CBEIF_SELECTEDIMAGE | CBEIF_TEXT;
        CBItem.iItem = -1;
        CBItem.pszText = const_cast<PWSTR>(SzLoadIds(IDS_NO_CONNECTIONS));
        CBItem.cchTextMax = lstrlenW(SzLoadIds(IDS_NO_CONNECTIONS));
        CBItem.iImage = ConnTypeToImageIdx(NCM_LAN);
        CBItem.iSelectedImage = CBItem.iImage;
        CBItem.lParam = NULL;

        if (-1 != SendMessage(hwndCMB, CBEM_INSERTITEM, 0, (LPARAM)&CBItem))
        {
            SendMessage(hwndCMB, CB_SETCURSEL, 0, 0);
        }
    }

    EnableWindow(hwndCMB, !!lCnt);

    TraceError("CChooseConnectionDlg::FillChooserCombo",hr==S_FALSE ? S_OK: hr);
    return lCnt;
}

CChooseConnectionData * CChooseConnectionDlg::GetData(LPARAM lIdx)
{
    CChooseConnectionData * pData = NULL;
    HWND hwndCMB = GetDlgItem(m_hWnd, CMB_CHOOSER_LIST);
    COMBOBOXEXITEM CBItem = {0};

    CBItem.iItem = lIdx;
    CBItem.mask = CBEIF_LPARAM;
    if (0 != SendMessage(hwndCMB, CBEM_GETITEM, 0, (LPARAM)(PCOMBOBOXEXITEM) &CBItem))
    {
        pData = reinterpret_cast<CChooseConnectionData *>(CBItem.lParam);
    }

    return pData;
}

CChooseConnectionData * CChooseConnectionDlg::GetCurrentData()
{
    HWND hwndCMB = GetDlgItem(m_hWnd, CMB_CHOOSER_LIST);
    LPARAM lParam = SendMessage(hwndCMB, CB_GETCURSEL, 0, 0);

    if (CB_ERR == lParam)
        return NULL;

    return GetData(lParam);
}

BOOL CChooseConnectionDlg::OnInitDialog(HWND hwndDlg)
{
    HWND hwndOk = GetDlgItem(hwndDlg, BTN_CHOOSER_OK);
    HWND hwndCMB = GetDlgItem(hwndDlg, CMB_CHOOSER_LIST);

    m_hWnd = hwndDlg;

    // Set the caption text if necessary
    if (NCCHF_CAPTION & m_pChooseConn->dwFlags)
    {
        SetWindowText(m_hWnd, m_pChooseConn->lpstrCaption);
    }
    else if (NCCHF_CONNECT & m_pChooseConn->dwFlags)
    {
        SetWindowText(m_hWnd, SzLoadIds(IDS_CONNECT_CAPTION));
    }

    // Set the Ok text if necessary
    if (NCCHF_OKBTTNTEXT & m_pChooseConn->dwFlags)
    {
        SetWindowText(hwndOk, m_pChooseConn->lpstrOkBttnText);
    }
    else if (NCCHF_CONNECT & m_pChooseConn->dwFlags)
    {
        SetWindowText(hwndOk, SzLoadIds(IDS_OKBTTNTEXT));
    }

    // Disable the New button if requested or if the user doesn't
    // have rights for it.
    //
    if ((NCCHF_DISABLENEW & m_pChooseConn->dwFlags) ||
        !FHasPermission(NCPERM_NewConnectionWizard))
    {
        EnableWindow(GetDlgItem(m_hWnd, BTN_CHOOSER_NEW), FALSE);
    }

    // Populate the UI
    LONG lCnt = FillChooserCombo();

    Assert(NULL != m_pConnUi->HImageList());
    SendMessage(hwndCMB, CBEM_SETIMAGELIST, 0, (LPARAM)m_pConnUi->HImageList());
    ::SendMessage(hwndCMB, CB_SETCURSEL, 0, 0L);

    // Enable the buttons based on what was found
    UpdateOkState();

    // Special case, if they don't want to be able to create new connections
    // and we're in chooser mode and only one connection exists and the
    // autoselect option is selected, select it and return
    //
    if ((1 == lCnt) && (NCCHF_AUTOSELECT & m_pChooseConn->dwFlags) &&
        IsWindowEnabled(hwndOk))
    {
        PostMessage(hwndDlg, WM_COMMAND, MAKEWPARAM(BTN_CHOOSER_OK, 0),
                    (LPARAM)hwndOk);
    }

    return FALSE;
}

VOID CChooseConnectionDlg::UpdateOkState()
{
    BOOL fEnabledOk = TRUE;
    BOOL fEnabledProps = TRUE;

    CChooseConnectionData * pData = GetCurrentData();
    if (NULL == pData)
    {
        fEnabledOk = FALSE;
        fEnabledProps = FALSE;
    }
    else
    {
        if (NCCHF_CONNECT & m_pChooseConn->dwFlags)
        {
            // If the current connection is not disconnected or if it's
            // a LAN/RAS connection and they don't have connect rights
            // then disable the OK button
            //
            if ((pData->ConnStatus() != NCS_DISCONNECTED) ||
                ((pData->ConnType() == NCM_LAN) && !FHasPermission(NCPERM_LanConnect)) ||
                ((pData->ConnType() != NCM_LAN) && !FHasPermission(NCPERM_RasConnect)))
            {
                fEnabledOk = FALSE;
            }
        }

        // If this is a LAN connection and the user doesn't have rights
        // then disallow properties
        //
        if ((NCM_LAN == pData->ConnType()) &&
              !FHasPermission(NCPERM_LanProperties))
        {
            fEnabledProps = FALSE;
        }

        // If this is a RAS connection and the user doesn't have rights
        // then disallow properties
        //
        if (NCM_LAN != pData->ConnType())
        {
            if (((pData->Characteristics() & NCCF_ALL_USERS) &&
                 !FHasPermission(NCPERM_RasAllUserProperties)) ||
                !FHasPermission(NCPERM_RasMyProperties))
            {
                fEnabledProps = FALSE;
            }
        }
    }

    EnableWindow(GetDlgItem(m_hWnd, BTN_CHOOSER_OK), fEnabledOk);
    EnableWindow(GetDlgItem(m_hWnd, BTN_CHOOSER_PROPS), fEnabledProps);
}

BOOL CChooseConnectionDlg::OnNew()
{
    INetConnection * pConn = NULL;
    HRESULT hr = m_pConnUi->StartNewConnectionWizard (m_hWnd, &pConn);
    if ((S_OK == hr) && (NULL != pConn))
    {
        NETCON_PROPERTIES * pProps = NULL;
        LONG lCnt = FillChooserCombo();
        int  nIdx = CB_ERR;
        HWND hwndCMB = GetDlgItem(m_hWnd, CMB_CHOOSER_LIST);

        Assert(pConn);
        hr = pConn->GetProperties(&pProps);
        ReleaseObj(pConn);
        if (SUCCEEDED(hr) && lCnt && pProps->pszwName)
        {
            nIdx = ::SendMessage(hwndCMB, CB_FINDSTRINGEXACT,
                        -1, (LPARAM)pProps->pszwName);
        }

        // Select whatever was found
        ::SendMessage(hwndCMB, CB_SETCURSEL, ((CB_ERR == nIdx) ? 0 : nIdx), 0L);

        UpdateOkState();
        FreeNetconProperties(pProps);
    }
    TraceErrorOptional("CChooseConnectionDlg::OnProps", hr, (S_FALSE==hr));
    return TRUE;
}

BOOL CChooseConnectionDlg::OnProps()
{
    CChooseConnectionData * pData = GetCurrentData();
    if (NULL != pData)
    {
        HRESULT hr = m_pConnUi->ShowConnectionProperties(m_hWnd,
                                        pData->PConnection());
        TraceErrorOptional("CChooseConnectionDlg::OnProps", hr, (S_FALSE==hr));
    }
    return TRUE;
}

BOOL CChooseConnectionDlg::OnOk()
{
    CChooseConnectionData * pData = GetCurrentData();
    if ((NULL != pData) && pData->PConnection())
    {
        if (m_ppConn)
        {
            *m_ppConn = pData->PConnection();
            (*m_ppConn)->AddRef();
        }

        // Launch the connection if we're in NCCHF_CONNECT mode
        if (NCCHF_CONNECT & m_pChooseConn->dwFlags)
        {
            Assert(*m_ppConn);
            HRESULT hr = HrConnectOrDisconnectNetConObject(
                            m_hWnd, pData->PConnection(), CD_CONNECT);
        }

        EndDialog(m_hWnd, IDOK);
    }
    return TRUE;
}

INT_PTR CALLBACK
CChooseConnectionDlg::dlgprocConnChooser(HWND hwndDlg, UINT uMsg,
                                         WPARAM wParam, LPARAM lParam)
{
    BOOL                   frt = FALSE;
    LONG_PTR                lTmp = ::GetWindowLongPtr(hwndDlg, DWLP_USER);
    CChooseConnectionDlg * pdlg = reinterpret_cast<CChooseConnectionDlg *>(lTmp);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            Assert(lParam);
            ::SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
            pdlg = reinterpret_cast<CChooseConnectionDlg *>(lParam);
            frt = pdlg->OnInitDialog(hwndDlg);
        }
        break;

    case WM_DESTROY:
        if (NULL != pdlg)
        {
            pdlg->ReleaseData();
        }
        break;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case CBN_SELENDOK:
            if (LOWORD(wParam) == CMB_CHOOSER_LIST)
            {
                Assert(pdlg);
                pdlg->UpdateOkState();
            }
            break;

        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case BTN_CHOOSER_NEW:
                Assert(pdlg);
                frt = pdlg->OnNew();
                break;
            case BTN_CHOOSER_PROPS:
                Assert(pdlg);
                frt = pdlg->OnProps();
                break;
            case BTN_CHOOSER_OK:
                Assert(pdlg);
                frt = pdlg->OnOk();
                break;
            case IDCANCEL:
                frt = TRUE;
                EndDialog(hwndDlg, IDCANCEL);
                break;
            }
            break;
        }
        break;

    default:
        frt = FALSE;
        break;
    }

    return frt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\commconn\commconn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O M M C O N N . H
//
//  Contents:   defines the INetConnectionCommonUi interface.
//
//  Notes:
//
//  Author:     scottbri   14 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _COMMCONN_H_
#define _COMMCONN_H_

#include <netshell.h>
#include "nsbase.h"
#include "nsres.h"

//    typedef enum tagNETCON_CHOOSEFLAGS
//    {
//        NCCHF_CONNECT    = 0x0001,      // Selected Connection is activated
//                                        // and returned. If not set then
//                                        // the selected connection interface
//                                        // is returned without being activated
//        NCCHF_CAPTION    = 0x0002,
//        NCCHF_OKBTTNTEXT = 0x0004,
//    } NETCON_CHOOSEFLAGS;
//
//    typedef enum tagNETCON_CHOOSETYPE
//    {
//        NCCHT_DIRECT_CONNECT = 0x0001,
//        NCCHT_INBOUND        = 0x0002,
//        NCCHT_CONNECTIONMGR  = 0x0004,
//        NCCHT_LAN            = 0x0008,
//        NCCHT_PHONE          = 0x0010,
//        NCCHT_TUNNEL         = 0x0020,
//        NCCHT_ALL            = 0x003F
//    } NETCON_CHOOSETYPE;
//
//    typedef struct tagNETCON_CHOOSECONN
//    {
//        DWORD       lStructSize;
//        HWND        hwndParent;
//        DWORD       dwFlags;            // Combine NCCHF_* flags
//        DWORD       dwTypeMask;         // Combine NCCHT_* flags
//        PCWSTR     lpstrCaption;
//        PCWSTR     lpstrOkBttnText;
//    } NETCON_CHOOSECONN;

class ATL_NO_VTABLE CConnectionCommonUi :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CConnectionCommonUi, &CLSID_ConnectionCommonUi>,
    public INetConnectionCommonUi
{
public:
    DECLARE_REGISTRY_RESOURCEID(IDR_COMMCONN)

    BEGIN_COM_MAP(CConnectionCommonUi)
        COM_INTERFACE_ENTRY(INetConnectionCommonUi)
    END_COM_MAP()

    CConnectionCommonUi();
    ~CConnectionCommonUi();

    STDMETHODIMP ChooseConnection(
        NETCON_CHOOSECONN * pChooseConn,
        INetConnection** ppCon);

    STDMETHODIMP ShowConnectionProperties (
        HWND hwndParent,
        INetConnection* pCon);

    STDMETHODIMP StartNewConnectionWizard (
        HWND hwndParent,
        INetConnection** ppCon);

    INetConnectionManager * PConMan()    {return m_pconMan;}
    HIMAGELIST              HImageList() {return m_hIL;}

private:
    HRESULT                 HrInitialize();

private:
    INetConnectionManager * m_pconMan;
    HIMAGELIST              m_hIL;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\cpl\cpl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C P L . C P P
//
//  Contents:   Entrypoints and other code for the new NCPA
//
//  Notes:
//
//  Author:     jeffspr   12 Jan 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "cplres.h"

#include <openfold.h>   // For launching connections folder
#include <cpl.h>


//---[ Globals ]--------------------------------------------------------------

HINSTANCE   g_hInst = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Purpose:    Standard DLL entrypoint
//
//  Arguments:
//      hInstance  []   Our instance handle
//      dwReason   []   reason for invocation (attach/detach/etc)
//      lpReserved []   Unused
//
//  Returns:
//
//  Author:     jeffspr   12 Jan 1998
//
//  Notes:
//
BOOL APIENTRY DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )
{
    g_hInst = hInstance;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        InitializeDebugging();

        if (FIsDebugFlagSet (dfidNetShellBreakOnInit))
        {
            DebugBreak();
        }

        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        UnInitializeDebugging();
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CPlApplet
//
//  Purpose:
//
//  Arguments:
//      hwndCPL [in]    Handle of control panel window
//      uMsg    [in]    message
//      lParam1 [in]
//      lParam2 [in]
//
//  Returns:
//
//  Author:     jeffspr   12 Jan 1998
//
//  Notes:
//
LONG CALLBACK CPlApplet( HWND hwndCPL, UINT uMsg, LPARAM lParam1, LPARAM lParam2 )
{
    TraceFileFunc(ttidShellFolder);
    
    LPNEWCPLINFO    pNewCPlInfo     = NULL;
    LPCPLINFO       pCPlInfo        = NULL;
    INT             iApp            = NULL;
    LONG            lReturn         = 0;

    iApp = ( int ) lParam1;

    switch ( uMsg )
    {
        // First message, sent once.
        //
        case CPL_INIT:
            TraceTag(ttidShellFolder, "NCPA message: CPL_INIT");
            lReturn = 1;    // Successfully initialized
            break;

        // Second message, sent once.
        //
        case CPL_GETCOUNT:
            TraceTag(ttidShellFolder, "NCPA message: CPL_GETCOUNT");
            lReturn = 1;        // We only have one app to support
            break;

        // Third message (alternate, old). Sent once per app
        //
        case CPL_INQUIRE:
            TraceTag(ttidShellFolder, "NCPA message: CPL_INQUIRE");
            pCPlInfo = ( LPCPLINFO ) lParam2;
            pCPlInfo->idIcon = IDI_NCPA;
            pCPlInfo->idName = IDS_NCPTITLE;
            pCPlInfo->idInfo = IDS_NCPDESC;
            pCPlInfo->lData = NULL;
            lReturn = 0;    // Processed successfully
            break;

        // Alternate third message, sent once per app
        //
        case CPL_NEWINQUIRE:
            TraceTag(ttidShellFolder, "NCPA message: CPL_NEWINQUIRE");
            lReturn = 1;    // Ignore this message
            break;

        // Application icon selected. We should never get this message
        //
        case CPL_SELECT:
            TraceTag(ttidShellFolder, "NCPA message: CPL_SELECT");
            lReturn = 1;    // Who cares? We never get this.
            break;

        // Application icon double-clicked.
        // Or application invoked via STARTWPARAMS (through rundll)
        //
        case CPL_DBLCLK:
        case CPL_STARTWPARMSW:
        case CPL_STARTWPARMSA:
            switch(uMsg)
            {
                case CPL_STARTWPARMSW:
                    TraceTag(ttidShellFolder, "NCPA message: CPL_STARTWPARMSW, app: %d, parms: %S",
                        lParam1, lParam2 ? (PWSTR) lParam2 : L"");
                    break;
                case CPL_STARTWPARMSA:
                    TraceTag(ttidShellFolder, "NCPA message: CPL_STARTWPARMSA, app: %d, parms: %s",
                        lParam1, lParam2 ? (PSTR) lParam2 : "");
                    break;
                case CPL_DBLCLK:
                    TraceTag(ttidShellFolder, "NCPA message: CPL_DBLCLK");
                    break;
            }

            // No matter what, we're doing the same thing here
            //
            (VOID) HrOpenConnectionsFolder();

            // Return the correct code. DBLCLK wants 0 == success, the others want (TRUE)
            //
            if (uMsg == CPL_DBLCLK)
                lReturn = 0;    // Processed successfully
            else
                lReturn = 1;    // TRUE, which for the START versions means success
            break;

        // Controlling application closing.
        //
        case CPL_STOP:
            TraceTag(ttidShellFolder, "NCPA message: CPL_STOP");
            lReturn = 0;    // Processed succesfully
            break;

        // We're about to be released. Sent after last CPL_STOP
        //
        case CPL_EXIT:
            TraceTag(ttidShellFolder, "NCPA message: CPL_EXIT");
            lReturn = 0;    // Processed successfully
            break;

        default:
            TraceTag(ttidShellFolder, "NCPA message: CPL_? (%d)", uMsg);
            lReturn = 1;
            break;
    }

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\common\windutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       W I N D U T I L . C P P
//
//  Contents:   Window utilities -- For now, just CenterWindow
//
//  Notes:
//
//  Author:     jeffspr   22 May 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop



//+---------------------------------------------------------------------------
//
//  Function:   FCenterWindow
//
//  Purpose:    Center a child window on the parent
//
//  Arguments:
//      hwndChild  [in]     Child window handle
//      hwndParent [in]     Parent window handle (or NULL for desktop)
//
//  Returns:
//
//  Author:     jeffspr   22 May 1998
//
//  Notes:
//
BOOL FCenterWindow (HWND hwndChild, HWND hwndParent)
{
    RECT    rChild, rParent;
    int     wChild, hChild, wParent, hParent;
    int     wScreen, hScreen, xNew, yNew;
    HDC     hdc = NULL;
    BOOL    fReturn = TRUE;

    AssertSz(hwndChild, "Bad Child Window param to CenterWindow");

    // Get the Height and Width of the child window
    //
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
    //
    if (NULL == hwndParent)
    {
        GetWindowRect (GetDesktopWindow(), &rParent);
    }
    else
    {
        GetWindowRect (hwndParent, &rParent);
    }

    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the display limits
    //
    hdc = GetDC (hwndChild);
    if (hdc)
    {
        wScreen = GetDeviceCaps (hdc, HORZRES);
        hScreen = GetDeviceCaps (hdc, VERTRES);
        ReleaseDC (hwndChild, hdc);

        // Calculate new X position, then adjust for screen
        //
        xNew = rParent.left + ((wParent - wChild) / 2);
        if (xNew < 0)
        {
            xNew = 0;
        }
        else if ((xNew + wChild) > wScreen)
        {
            xNew = wScreen - wChild;
        }

        // Calculate new Y position, then adjust for screen
        //
        yNew = rParent.top + ((hParent - hChild) / 2);
        if (yNew < 0)
        {
            yNew = 0;
        }
        else if ((yNew + hChild) > hScreen)
        {
            yNew = hScreen - hChild;
        }

        // Set it, and return
        //
        fReturn = SetWindowPos (hwndChild, NULL,
                             xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
    }
    else
    {
        fReturn = FALSE;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\commconn\commconp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O M M C O N P . H
//
//  Contents:   Private includes for the common connection ui
//
//  Notes:
//
//  Author:     scottbri   15 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _COMMCONP_H_
#define _COMMCONP_H_

class CChooseConnectionData
{
public:
    static HRESULT HrCreate(INetConnection *, CChooseConnectionData **);
    ~CChooseConnectionData();

    INetConnection * PConnection() {return m_pConn;}
    PCWSTR          SzName() {return m_strName.c_str();}
    VOID             SetCharacteristics(DWORD dw) {m_dwChar = dw;};
    VOID             SetName(PCWSTR sz) {m_strName = sz;}
    VOID             SetStatus(NETCON_STATUS ncs) {m_Ncs = ncs;}
    VOID             SetType(NETCON_MEDIATYPE nct) {m_Nct = nct;}
    NETCON_STATUS    ConnStatus() {return m_Ncs;}
    NETCON_MEDIATYPE ConnType() {return m_Nct;}
    DWORD            Characteristics() {return m_dwChar;}

private:
    CChooseConnectionData(INetConnection *);

private:
    INetConnection * m_pConn;
    NETCON_MEDIATYPE m_Nct;
    NETCON_STATUS    m_Ncs;
    DWORD            m_dwChar;
    tstring          m_strName;
};

class CChooseConnectionDlg
{
public:
    CChooseConnectionDlg(NETCON_CHOOSECONN * pChooseConn,
                         CConnectionCommonUi * pConnUi,
                         INetConnection** ppConn);
    ~CChooseConnectionDlg();

    static INT_PTR CALLBACK dlgprocConnChooser(HWND, UINT, WPARAM, LPARAM);
    static HRESULT HrLoadImageList(HIMAGELIST *);

private:
    CChooseConnectionData * GetData(LPARAM lIdx);
    CChooseConnectionData * GetCurrentData();

    BOOL OnInitDialog(HWND);
    VOID ReleaseData();
    BOOL OnOk();
    BOOL OnNew();
    BOOL OnProps();
    VOID UpdateOkState();
    LONG FillChooserCombo();
    BOOL IsConnTypeInMask(NETCON_MEDIATYPE nct);
    INT  ConnTypeToImageIdx(NETCON_MEDIATYPE nct);

private:
    NETCON_CHOOSECONN   *   m_pChooseConn;
    CConnectionCommonUi *   m_pConnUi;
    INetConnection **       m_ppConn;         // Output parameter

    HWND                    m_hWnd;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\common\openfold.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O P E N F O L D . C P P
//
//  Contents:   Folder launching code for the connections folder
//
//  Notes:
//
//  Author:     jeffspr   12 Jan 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

// Undocument shell32 stuff.  Sigh.
#define DONT_WANT_SHELLDEBUG 1
#define NO_SHIDLIST 1
#define USE_SHLWAPI_IDLIST

#include "pidlutil.h"

#include <ncdebug.h>

#define AVOID_NET_CONFIG_DUPLICATES

#include "nsbase.h"
#include "nsres.h"
#include <ncdebug.h>
#include <ncreg.h>
#include <netshell.h>
#include <netconp.h>
#include <ncui.h>

#include "cfpidl.h"
#include "openfold.h"

// Note -- Don't convert this to a constant. We need copies of it within the
// functions because ParseDisplayName actually mangles the string.
//
// CLSID_MyComputer
// CLSID_ControlPanel
// CLSID_NetworkConnections
#define NETCON_FOLDER_PATH   L"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\" \
                             L"::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\" \
                             L"::{7007ACC7-3202-11D1-AAD2-00805FC1270E}";


//+---------------------------------------------------------------------------
//
//  Function:   HrGetConnectionsFolderPidl
//
//  Purpose:    Get the connections folder pidl. Used in places where we're
//              not folder specific, but we still need to update folder
//              entries.
//
//  Arguments:
//      ppidlFolder [out]   Return parameter for the folder pidl
//
//  Returns:
//
//  Author:     jeffspr   13 Jun 1998
//
//  Notes:
//
HRESULT HrGetConnectionsFolderPidl(OUT PCONFOLDPIDLFOLDER& ppidlFolder)
{
    HRESULT         hr          = S_OK;
    LPSHELLFOLDER   pshf        = NULL;
    LPITEMIDLIST    pidlFolder  = NULL;

    // "::CLSID_MyComputer\\::CLSID_ControlPanel\\::CLSID_ConnectionsFolder"
    WCHAR szNetConFoldPath[] = NETCON_FOLDER_PATH;

    // Get the desktop folder, so we can parse the display name and get
    // the UI object of the connections folder
    //
    hr = SHGetDesktopFolder(&pshf);
    if (SUCCEEDED(hr))
    {
        ULONG           chEaten;

        pidlFolder = NULL;
        hr = pshf->ParseDisplayName(NULL, 0, (WCHAR *) szNetConFoldPath,
            &chEaten, &pidlFolder, NULL);

        ReleaseObj(pshf);
    }

    // If succeeded, fill in the return param.
    //
    if (SUCCEEDED(hr))
    {
        hr = ppidlFolder.InitializeFromItemIDList(pidlFolder);

        SHFree(pidlFolder); // ISSUE: Why can't we free regardless?
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrGetConnectionsFolderPidl");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOpenConnectionsFolder
//
//  Purpose:    Open the connections folder in explorer.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   16 Apr 1998
//
//  Notes:
//
HRESULT HrOpenConnectionsFolder()
{
    HRESULT         hr          = S_OK;
    HCURSOR         hcWait      = SetCursor(LoadCursor(NULL, IDC_WAIT));
    PCONFOLDPIDLFOLDER    pidlFolder;

    hr = HrGetConnectionsFolderPidl(pidlFolder);
    if (SUCCEEDED(hr))
    {
        Assert(!pidlFolder.empty());

        SHELLEXECUTEINFO shei = { 0 };
        shei.cbSize     = sizeof(shei);
        shei.fMask      = SEE_MASK_IDLIST | SEE_MASK_INVOKEIDLIST | SEE_MASK_FLAG_DDEWAIT;
        shei.nShow      = SW_SHOW;    // used to be SW_SHOWNORMAL
        shei.lpIDList   = const_cast<LPITEMIDLIST>(pidlFolder.GetItemIdList());

        ShellExecuteEx(&shei);
    }

    if (hcWait)
    {
        SetCursor(hcWait);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOpenConnectionsFolder");
    return hr;
}

HRESULT HrGetConnectionsIShellFolder(
    const PCONFOLDPIDLFOLDER& pidlFolder,
    LPSHELLFOLDER * ppsf)
{
    HRESULT         hr          = S_OK;
    LPSHELLFOLDER   psfDesktop  = NULL;

    Assert(ppsf);
    *ppsf = NULL;

    // Get the desktop folder so we can use it to retrieve the
    // connections folder
    //
    hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        Assert(psfDesktop);

        hr = psfDesktop->BindToObject(pidlFolder.GetItemIdList(), NULL, IID_IShellFolder,
            (LPVOID*) ppsf);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrGetConnectionsIShellFolder");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\cpl\cplres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R E S O U R C E . H 
//
//  Contents:   Resource identifiers for the connections folder CPL
//
//  Notes:      
//
//  Author:     jeffspr   12 Jan 1998
//
//----------------------------------------------------------------------------

#ifndef _CPLRES_H_
#define _CPLRES_H_

// Our CPL icon
#define IDI_NCPA                        1001

// Our CPL strings              
#define IDS_NCPTITLE                    2001
#define IDS_NCPDESC                     2002

#endif // _CPLRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\cpl\openfold.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O P E N F O L D . H 
//
//  Contents:   Utility function for opening the connections folder
//
//  Notes:      
//
//  Author:     jeffspr   12 Jan 1998
//
//----------------------------------------------------------------------------

#ifndef _OPENFOLD_H_
#define _OPENFOLD_H_

// Get our folder pidl
//
HRESULT HrGetConnectionsFolderPidl(LPITEMIDLIST *ppidlFolder);

// Bring up the connections folder UI
//
HRESULT HrOpenConnectionsFolder();

// Get an IShellFolder * given the folder pidl
//
HRESULT HrGetConnectionsIShellFolder(
    LPITEMIDLIST    pidlFolder, 
    LPSHELLFOLDER * ppsf);

// Note -- This code is actually in folder\oncommand.cpp, but can be
// referenced from any place that needs it.
//
VOID    RefreshFolderItem(LPITEMIDLIST pidlFolder, 
                          LPITEMIDLIST pidlItemOld,
                          LPITEMIDLIST pidlItemNew,
                          BOOL fRestart = FALSE);

#endif // _OPENFOLD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\dll\dlldatax.h ===
#pragma once

#ifdef _MERGE_PROXYSTUB

extern "C"
{

BOOL
WINAPI
PrxDllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved);

STDAPI
PrxDllCanUnloadNow ();

STDAPI
PrxDllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv);

STDAPI
PrxDllRegisterServer ();

STDAPI
PrxDllUnregisterServer ();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\cpl\openfold.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O P E N F O L D . C P P
//
//  Contents:   Folder launching code for the connections folder
//
//  Notes:
//
//  Author:     jeffspr   12 Jan 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

// Undocument shell32 stuff.  Sigh.
#define DONT_WANT_SHELLDEBUG 1
#define NO_SHIDLIST 1
#define USE_SHLWAPI_IDLIST

#include <commctrl.h>
#include <ncdebug.h>
#include <openfold.h>   // For launching connections folder



// Note -- Don't convert this to a constant. We need copies of it within the
// functions because ParseDisplayName actually mangles the string.
//
// CLSID_MyComputer
// CLSID_ControlPanel
// CLSID_NetworkConnections
#define NETCON_FOLDER_PATH   L"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\" \
                             L"::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\" \
                             L"::{7007ACC7-3202-11D1-AAD2-00805FC1270E}";


//+---------------------------------------------------------------------------
//
//  Function:   HrGetConnectionsFolderPidl
//
//  Purpose:    Get the connections folder pidl. Used in places where we're
//              not folder specific, but we still need to update folder
//              entries.
//
//  Arguments:
//      ppidlFolder [out]   Return parameter for the folder pidl
//
//  Returns:
//
//  Author:     jeffspr   13 Jun 1998
//
//  Notes:
//
HRESULT HrGetConnectionsFolderPidl(LPITEMIDLIST *ppidlFolder)
{
    HRESULT         hr          = S_OK;
    LPSHELLFOLDER   pshf        = NULL;
    LPITEMIDLIST    pidlFolder  = NULL;

    Assert(ppidlFolder);

    // "::CLSID_MyComputer\\::CLSID_ControlPanel\\::CLSID_ConnectionsFolder"
    WCHAR szNetConFoldPath[] = NETCON_FOLDER_PATH;

    // Get the desktop folder, so we can parse the display name and get
    // the UI object of the connections folder
    //
    hr = SHGetDesktopFolder(&pshf);
    if (SUCCEEDED(hr))
    {
        ULONG           chEaten;

        hr = pshf->ParseDisplayName(NULL, 0, (WCHAR *) szNetConFoldPath,
            &chEaten, &pidlFolder, NULL);

        ReleaseObj(pshf);
    }

    // If succeeded, fill in the return param.
    //
    if (SUCCEEDED(hr))
    {
        *ppidlFolder = pidlFolder;
    }
    else
    {
        // If we failed, then delete the pidl if we already got it.
        //
        if (pidlFolder)
            SHFree(pidlFolder);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrGetConnectionsFolderPidl");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOpenConnectionsFolder
//
//  Purpose:    Open the connections folder in explorer.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   16 Apr 1998
//
//  Notes:
//
HRESULT HrOpenConnectionsFolder()
{
    HRESULT         hr          = S_OK;
    HCURSOR         hcWait      = SetCursor(LoadCursor(NULL, IDC_WAIT));
    LPITEMIDLIST    pidlFolder  = NULL;;

    hr = HrGetConnectionsFolderPidl(&pidlFolder);
    if (SUCCEEDED(hr))
    {
        Assert(pidlFolder);

        SHELLEXECUTEINFO shei = { 0 };
        shei.cbSize     = sizeof(shei);
        shei.fMask      = SEE_MASK_IDLIST | SEE_MASK_INVOKEIDLIST | SEE_MASK_FLAG_DDEWAIT;
        shei.nShow      = SW_SHOW;    // used to be SW_SHOWNORMAL
        shei.lpIDList   = pidlFolder;

        ShellExecuteEx(&shei);
        SHFree(pidlFolder);
    }

    if (hcWait)
    {
        SetCursor(hcWait);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOpenConnectionsFolder");
    return hr;
}

HRESULT HrGetConnectionsIShellFolder(
    LPITEMIDLIST    pidlFolder,
    LPSHELLFOLDER * ppsf)
{
    HRESULT         hr          = S_OK;
    LPSHELLFOLDER   psfDesktop  = NULL;

    Assert(ppsf);
    *ppsf = NULL;

    // Get the desktop folder so we can use it to retrieve the
    // connections folder
    //
    hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        Assert(psfDesktop);

        hr = psfDesktop->BindToObject(pidlFolder, NULL, IID_IShellFolder,
            (LPVOID*) ppsf);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrGetConnectionsIShellFolder");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\cpl\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Connections Control-Panel Stub"
#define VER_INTERNALNAME_STR            "ncpa.cpl"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\dll\dllmain.cpp ===
#include "pch.h"
#pragma hdrstop

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES

#include "nsbase.h"
#include "nsres.h"
#include "netshell.h"
#include "ncnetcon.h"
#include "ncui.h"

// Connection Folder Objects
//
// Undocument shell32 stuff.  Sigh.
#define DONT_WANT_SHELLDEBUG 1
#define NO_SHIDLIST 1
#define USE_SHLWAPI_IDLIST

#include <commctrl.h>

#include <netcfgp.h>
#include <netconp.h>
#include <ncui.h>

// Connection UI Objects
//
#include "..\lanui\lanuiobj.h"
#include "..\lanui\lanui.h"
#include "dialupui.h"
#include "intnetui.h"
#include "directui.h"
#include "inbui.h"
#include "vpnui.h"
#include "pppoeui.h"
#include "..\lanui\saui.h"
#include "..\lanui\sauiobj.h"

#include "foldinc.h"
#include "openfold.h"
#include "..\folder\confold.h"
#include "..\folder\foldglob.h"
#include "..\folder\oncommand.h"
#include "..\folder\shutil.h"
#include "..\dun\dunimport.h"

// Connection Tray Objects
//
#include "..\folder\contray.h"

// Common Connection Ui Objects
#include "..\commconn\commconn.h"

#include "netshell_i.c"

// Icon support
#include "..\folder\iconhandler.h"

#include "..\folder\cmdtable.h"

#include "repair.h"

#define INITGUID
#include "nsclsid.h"

//+---------------------------------------------------------------------------
// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for foo.idl by adding the following
//      files to the Outputs.
//          foo_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f foops.mk in the project directory.

// Proxy/Stub registration entry points
//
#include "dlldatax.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

CNetConfigIcons *g_pNetConfigIcons = NULL;
CRITICAL_SECTION g_csPidl;

BEGIN_OBJECT_MAP(ObjectMap)

    // Connection UI Objects
    //
    OBJECT_ENTRY(CLSID_DialupConnectionUi,      CDialupConnectionUi)
    OBJECT_ENTRY(CLSID_DirectConnectionUi,      CDirectConnectionUi)
    OBJECT_ENTRY(CLSID_InboundConnectionUi,     CInboundConnectionUi)
    OBJECT_ENTRY(CLSID_LanConnectionUi,         CLanConnectionUi)
    OBJECT_ENTRY(CLSID_VpnConnectionUi,         CVpnConnectionUi)
    OBJECT_ENTRY(CLSID_PPPoEUi,                 CPPPoEUi)
    OBJECT_ENTRY(CLSID_SharedAccessConnectionUi, CSharedAccessConnectionUi)
    OBJECT_ENTRY(CLSID_InternetConnectionUi,      CInternetConnectionUi)

    // Connection Folder and enumerator
    //
    OBJECT_ENTRY(CLSID_ConnectionFolder,        CConnectionFolder)
    OBJECT_ENTRY(CLSID_ConnectionFolderWin98,   CConnectionFolder)
    OBJECT_ENTRY(CLSID_ConnectionFolderEnum,    CConnectionFolderEnum)
    OBJECT_ENTRY(CLSID_ConnectionTray,          CConnectionTray)

    // Connection Common Ui
    OBJECT_ENTRY(CLSID_ConnectionCommonUi,      CConnectionCommonUi)

    OBJECT_ENTRY(CLSID_NetConnectionUiUtilities, CNetConnectionUiUtilities)

END_OBJECT_MAP()

//+---------------------------------------------------------------------------
// DLL Entry Point
//
EXTERN_C
BOOL
WINAPI
DllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
    {
        return FALSE;
    }
#endif

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        BOOL fRetVal = FALSE;

        DisableThreadLibraryCalls(hInstance);

        InitializeDebugging();

        if (FIsDebugFlagSet (dfidNetShellBreakOnInit))
        {
            DebugBreak();
        }

        // Initialize fusion
        fRetVal = SHFusionInitializeFromModuleID(hInstance, 50);

        Assert(fRetVal);

        _Module.Init(ObjectMap, hInstance);

        InitializeCriticalSection(&g_csPidl);

        // Initialize the list and tie it to the tray (param == TRUE)
        //
        g_ccl.Initialize(TRUE, TRUE);
        
        g_pNetConfigIcons = new CNetConfigIcons(_Module.GetResourceInstance());
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DbgCheckPrematureDllUnload ("netshell.dll", _Module.GetLockCount());

        delete g_pNetConfigIcons;

        EnterCriticalSection(&g_csPidl);
        LeaveCriticalSection(&g_csPidl);
        
        DeleteCriticalSection(&g_csPidl);
    
        g_ccl.Uninitialize(TRUE);

        _Module.Term();

        SHFusionUninitialize();

        UnInitializeDebugging();
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
// Used to determine whether the DLL can be unloaded by OLE
//
STDAPI
DllCanUnloadNow ()
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
    {
        return S_FALSE;
    }
#endif

    return (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
// Returns a class factory to create an object of the requested type
//
STDAPI
DllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
    {
        return S_OK;
    }
#endif

    // The check is to works around an ATL problem where AtlModuleGetClassObject will AV
    // if _Module.m_pObjMap == NULL
    if (_Module.m_pObjMap) 
    {
        return _Module.GetClassObject(rclsid, riid, ppv);
    }
    else
    {
        return E_FAIL;
    }
}

//+---------------------------------------------------------------------------
// DllRegisterServer - Adds entries to the system registry
//
STDAPI
DllRegisterServer ()
{
    BOOL fCoUninitialize = TRUE;

    HRESULT hr = CoInitializeEx (NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        fCoUninitialize = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
#ifdef _MERGE_PROXYSTUB
        hr = PrxDllRegisterServer ();
        if (FAILED(hr))
        {
            goto Exit;
        }
#endif

        HKEY hkey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_SHELLSERVICEOBJECTDELAYED, 0, KEY_WRITE, &hkey))
        {
            RegDeleteValue(hkey, TEXT("Network.ConnectionTray"));
            RegCloseKey(hkey);
        }

        hr = NcAtlModuleRegisterServer (&_Module);
        if (SUCCEEDED(hr))
        {
            hr = HrRegisterFolderClass();
            if (SUCCEEDED(hr))
            {
                hr = HrRegisterDUNFileAssociation();
            }
        }

Exit:
        if (fCoUninitialize)
        {
            CoUninitialize ();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "netshell!DllRegisterServer");
    return hr;
}

//+---------------------------------------------------------------------------
// DllUnregisterServer - Removes entries from the system registry
//
STDAPI
DllUnregisterServer ()
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer ();
#endif

    _Module.UnregisterServer ();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   NcFreeNetconProperties
//
//  Purpose:    Free the memory assicated with the return value from
//              INetConnection->GetProperties.  This is a helper function
//              used by clients of INetConnection.
//
//  Arguments:
//      pProps  [in] The properties to free.
//
//  Returns:    nothing.
//
//  Author:     shaunco   1 Feb 1998
//
//  Notes:
//
STDAPI_(VOID)
NcFreeNetconProperties (
    NETCON_PROPERTIES* pProps)
{
    // Defer to the common function in nccon.h.
    // We do this so that netman.exe doesn't have to link to netshell.dll
    // just for this function.
    //
    FreeNetconProperties (pProps);
}

STDAPI_(BOOL)
NcIsValidConnectionName (
    PCWSTR pszwName)
{
    return FIsValidConnectionName (pszwName);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLaunchNetworkOptionalComponents
//
//  Purpose:    External Entry point for launching the Network Optional Components
//
//  Arguments:
//
//  Returns:
//
//  Author:     scottbri   29 Oct 1998
//
//  Notes:      The CreateFile in this function will fail if the user does
//              this very quickly twice in a row. In that case, the second
//              instance will fall out unharmed before the first one even
//              comes up, which is no big deal. The only negative impact
//              would be if the second client in rewrote the file while the
//              oc manager was attempting to read it, but oc manager would
//              have to allow FILE_SHARE_WRITE, which is doubtful.
//
//              I've opened this window due to RAID 336302, which requires
//              that only a single instance of NETOC is running.
//
//
const WCHAR c_szTmpMasterOC[]   = L"[Version]\r\nSignature = \"$Windows NT$\"\r\n[Components]\r\nNetOC=netoc.dll,NetOcSetupProc,netoc.inf\r\niis=iis.dll,OcEntry,iis.inf,hide,7\r\n[Global]\r\nWindowTitle=\"";
const WCHAR c_szQuote[]         = L"\"";
const WCHAR c_szTmpFileName[]   = L"NDCNETOC.INF";
const WCHAR c_szSysOCMgr[]      = L"%SystemRoot%\\System32\\sysocmgr.exe";

EXTERN_C
HRESULT
APIENTRY
HrLaunchNetworkOptionalComponents()
{
    DWORD   BytesWritten = 0;
    HANDLE  hFile = NULL;
    HRESULT hr = S_OK;
    PCWSTR pszName = NULL;
    WCHAR   szName[MAX_PATH + 1];

    // Jump to the existing netoc dialog, if present
    //
    HWND hwnd = FindWindow(NULL, SzLoadIds(IDS_CONFOLD_OC_TITLE));
    if (IsWindow(hwnd))
    {
        SetForegroundWindow(hwnd);
    }
    else
    {
        // Generate a temporary filename
        //
        if (0 == GetTempPath(celems(szName), szName))
        {
            hr = ::HrFromLastWin32Error();
            TraceTag(ttidShellFolder, "Unable to get temporary path for Optional Component Launch\n");
            goto Error;
        }

        lstrcatW(szName, c_szTmpFileName);

        // Create the file
        //
        hFile = CreateFile(szName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
                           NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = ::HrFromLastWin32Error();
            goto Error;
        }

        // Generate the file contents
        //
        if (WriteFile(hFile, c_szTmpMasterOC, lstrlenW(c_szTmpMasterOC) * sizeof(WCHAR),
                      &BytesWritten, NULL))
        {
            // Write the OC Dialog Title
            //
            WCHAR szBufW[256];
            if (LoadStringW(_Module.GetResourceInstance(), IDS_CONFOLD_OC_TITLE,
                            szBufW, celems(szBufW)-1))
            {
                szBufW[255] = 0;
                if (WriteFile(hFile, szBufW, lstrlenW(szBufW) * sizeof(WCHAR), &BytesWritten, NULL) == FALSE)
                {
                    CloseHandle(hFile);
                    return(::HrFromLastWin32Error());
                }
            }

            if (WriteFile(hFile, c_szQuote, lstrlenW(c_szQuote) * sizeof(WCHAR), &BytesWritten, NULL) == FALSE)
            {
                CloseHandle(hFile);
                return(::HrFromLastWin32Error());
            }

            CloseHandle(hFile);

            SHELLEXECUTEINFO seiTemp    = { 0 };
            tstring strParams = L"/x /i:";
            strParams += szName;

            //  Fill in the data structure
            //
            seiTemp.cbSize          = sizeof(SHELLEXECUTEINFO);
            seiTemp.fMask           = SEE_MASK_DOENVSUBST;
            seiTemp.hwnd            = NULL;
            seiTemp.lpVerb          = NULL;
            seiTemp.lpFile          = c_szSysOCMgr;
            seiTemp.lpParameters    = strParams.c_str();
            seiTemp.lpDirectory     = NULL;
            seiTemp.nShow           = SW_SHOW;
            seiTemp.hInstApp        = NULL;
            seiTemp.hProcess        = NULL;

            // Execute the OC Manager Script
            //
            if (!::ShellExecuteEx(&seiTemp))
            {
                hr = ::HrFromLastWin32Error();
            }
        }
        else
        {
            CloseHandle(hFile);
            hr = HrFromLastWin32Error();
        }
    }

Error:
    TraceError("HrOnCommandOptionalComponents", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateDeskTopIcon
//
//  Purpose:    External Entry point for creating a desktop shortcut to
//              an existing connection
//
//  Arguments:  guidId: GUID of the connection
//
//  Returns:    S_OK if succeeded
//              S_FALSE if the GUID does not match any existing connection
//              standard error code otherwise
//
//  Author:     tongl   19 Feb 1999
//
//  Notes:
//
EXTERN_C
HRESULT APIENTRY HrCreateDesktopIcon(const GUID& guidId, PCWSTR pszDir)
{
    HRESULT                 hr              = S_OK;
    PCONFOLDPIDL            pidlCon;
    PCONFOLDPIDLFOLDER      pidlFolder;
    BOOL                    fValidConnection= FALSE;

    #ifdef DBG
        WCHAR   szwGuid[c_cchGuidWithTerm];
        StringFromGUID2(guidId, szwGuid, c_cchGuidWithTerm);
        TraceTag(ttidShellFolder, "HrCreateDeskTopIcon called with GUID: %S", szwGuid);
        TraceTag(ttidShellFolder, "Dir path is: %S", pszDir);
    #endif

    // Initialize COM on this thread
    //
    BOOL fUninitCom = FALSE;

    hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (RPC_E_CHANGED_MODE == hr)
        {
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        fUninitCom = TRUE;

        hr = HrGetConnectionPidlWithRefresh(guidId, pidlCon);
        if (S_OK == hr)
        {
            AssertSz(!pidlCon.empty(), "We should have a valid PIDL for the connection !");

            // Get the pidl for the Connections Folder
            //
            hr = HrGetConnectionsFolderPidl(pidlFolder);
            if (SUCCEEDED(hr))
            {
                // Get the Connections Folder object
                //
                LPSHELLFOLDER psfConnections;

                hr = HrGetConnectionsIShellFolder(pidlFolder, &psfConnections);
                if (SUCCEEDED(hr))
                {
                    PCONFOLDPIDLVEC pidlVec;
                    pidlVec.push_back(pidlCon);
                    hr = HrCreateShortcutWithPath(pidlVec,
                                                  NULL,
                                                  psfConnections,
                                                  pszDir);
                    ReleaseObj(psfConnections);
                }
            }
        }
    }

    if (fUninitCom)
    {
        CoUninitialize();
    }

    TraceError("HrCreateDeskTopIcon", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLaunchConnection
//
//  Purpose:    External Entry point for "connecting" an existing connection
//
//  Arguments:  guidId: GUID of the connection
//
//  Returns:    S_OK if succeeded
//              S_FALSE if the GUID does not match any existing connection
//              standard error code otherwise
//
//  Author:     tongl   19 Feb 1999
//
//  Notes:
//
EXTERN_C
HRESULT APIENTRY HrLaunchConnection(const GUID& guidId)
{
    HRESULT                 hr              = S_OK;
    PCONFOLDPIDL            pidlCon;
    PCONFOLDPIDLFOLDER      pidlFolder;

    #ifdef DBG
        WCHAR   szwGuid[c_cchGuidWithTerm];
        StringFromGUID2(guidId, szwGuid, c_cchGuidWithTerm);
        TraceTag(ttidShellFolder, "HrLaunchConnection called with GUID: %S", szwGuid);
    #endif

    // Initialize COM on this thread
    //
    BOOL fUninitCom = FALSE;

    hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
    }
    if (SUCCEEDED(hr))
    {
        fUninitCom = TRUE;

        hr = HrGetConnectionPidlWithRefresh(guidId, pidlCon);
        if (S_OK == hr)
        {
            AssertSz(!pidlCon.empty(), "We should have a valid PIDL for the connection !");

            // Get the pidl for the Connections Folder
            //
            hr = HrGetConnectionsFolderPidl(pidlFolder);
            if (SUCCEEDED(hr))
            {
                // Get the Connections Folder object
                //
                LPSHELLFOLDER psfConnections;

                hr = HrGetConnectionsIShellFolder(pidlFolder, &psfConnections);
                if (SUCCEEDED(hr))
                {
                    PCONFOLDPIDLVEC pidlVec;
                    pidlVec.push_back(pidlCon);

                    hr = HrOnCommandConnect(pidlVec, NULL, psfConnections);
                    ReleaseObj(psfConnections);
                }
            }
        }
    }

    if (fUninitCom)
    {
        CoUninitialize();
    }

    TraceError("HrLaunchConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLaunchConnectionEx
//
//  Purpose:    External Entry point for "connecting" an existing connection
//
//  Arguments:  dwFlags: Flags.
//                       0x00000001 - Opens the folder before launching the connection
//
//              guidId: GUID of the connection
//
//  Returns:    S_OK if succeeded
//              S_FALSE if the GUID does not match any existing connection
//              standard error code otherwise
//
//  Author:     deonb    8 May 2001
//
//  Notes:
//
EXTERN_C
HRESULT APIENTRY HrLaunchConnectionEx(DWORD dwFlags, const GUID& guidId)
{
    HRESULT                 hr              = S_OK;
    PCONFOLDPIDL            pidlCon;
    PCONFOLDPIDLFOLDER      pidlFolder;
    HWND hwndConnFolder     = NULL;

    #ifdef DBG
        WCHAR   szwGuid[c_cchGuidWithTerm];
        StringFromGUID2(guidId, szwGuid, c_cchGuidWithTerm);
        TraceTag(ttidShellFolder, "HrLaunchConnection called with GUID: %S", szwGuid);
    #endif

    if (dwFlags & 0x00000001)
    {
        hwndConnFolder = FindWindow(NULL, SzLoadIds(IDS_CONFOLD_NAME));
        if (!hwndConnFolder)
        {
            HrOpenConnectionsFolder();

            DWORD dwRetries = 120; // 1 Minute
            while (!hwndConnFolder && dwRetries--)
            {
                hwndConnFolder = FindWindow(NULL, SzLoadIds(IDS_CONFOLD_NAME));
                Sleep(500);
            }
        }

        if (hwndConnFolder)
        {
            SetForegroundWindow(hwndConnFolder);
        }
        else
        {
            TraceError("Could not open the Network Connections Folder in time", E_FAIL);
        }
    }

    // Initialize COM on this thread
    //
    BOOL fUninitCom = FALSE;

    hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
    }
    if (SUCCEEDED(hr))
    {
        fUninitCom = TRUE;

        hr = HrGetConnectionPidlWithRefresh(guidId, pidlCon);
        if (S_OK == hr)
        {
            AssertSz(!pidlCon.empty(), "We should have a valid PIDL for the connection !");

            // Get the pidl for the Connections Folder
            //
            hr = HrGetConnectionsFolderPidl(pidlFolder);
            if (SUCCEEDED(hr))
            {
                // Get the Connections Folder object
                //
                LPSHELLFOLDER psfConnections;

                hr = HrGetConnectionsIShellFolder(pidlFolder, &psfConnections);
                if (SUCCEEDED(hr))
                {
                    PCONFOLDPIDLVEC pidlVec;
                    pidlVec.push_back(pidlCon);

                    hr = HrOnCommandConnect(pidlVec, hwndConnFolder, psfConnections);
                    ReleaseObj(psfConnections);
                }
            }
        }
    }

    if (fUninitCom)
    {
        CoUninitialize();
    }

    TraceError("HrLaunchConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRenameConnection
//
//  Purpose:    External Entry point for renaming an existing connection
//
//  Arguments:  guidId: GUID of the connection
//
//
//  Returns:    S_OK if succeeded
//              S_FALSE if the GUID does not match any existing connection
//              standard error code otherwise
//
//  Author:     tongl   26 May 1999
//
//  Notes:
//

EXTERN_C
HRESULT APIENTRY HrRenameConnection(const GUID& guidId, PCWSTR pszNewName)
{
    HRESULT                 hr              = S_OK;
    PCONFOLDPIDL            pidlCon;
    PCONFOLDPIDLFOLDER      pidlFolder;

    #ifdef DBG
        WCHAR   szwGuid[c_cchGuidWithTerm];
        StringFromGUID2(guidId, szwGuid, c_cchGuidWithTerm);
        TraceTag(ttidShellFolder, "HrRenameConnection called with GUID: %S, NewName: %S",
                 szwGuid, pszNewName);
    #endif

    if (!pszNewName)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // check lpszName for validity
        if (!FIsValidConnectionName(pszNewName))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
        }
    }

    if (SUCCEEDED(hr))
    {
        // Initialize COM on this thread
        //
        BOOL fUninitCom = FALSE;

        hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
        if (SUCCEEDED(hr))
        {
            fUninitCom = TRUE;

            hr = HrGetConnectionPidlWithRefresh(guidId, pidlCon);
            if (S_OK == hr)
            {
                AssertSz(!pidlCon.empty(), "We should have a valid PIDL for the connection !");

                // Get the pidl for the Connections Folder
                //
                hr = HrGetConnectionsFolderPidl(pidlFolder);
                if (SUCCEEDED(hr))
                {
                    PCONFOLDPIDL pcfpEmpty;
                    hr = HrRenameConnectionInternal(pidlCon, pidlFolder, pszNewName,
                                                    FALSE, NULL, pcfpEmpty);
                }
            }
        }

        if (fUninitCom)
        {
            CoUninitialize();
        }

    }

    TraceError("HrRenameConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   InvokeDunFile
//  Purpose:    External Entry point for launching .dun files
//
//  Arguments:
//
//  Returns:
//
//  Author:     tongl  4 Feb 1999
//
//  Notes:
//

EXTERN_C
VOID APIENTRY InvokeDunFile(HWND hwnd, HINSTANCE hinst, LPCSTR lpszCmdLine, int nCmdShow)
{
    if (lpszCmdLine)
    {
        INT     cch         = 0;
        WCHAR * pszFileW    = NULL;

        cch = lstrlenA(lpszCmdLine) + 1;
        pszFileW = new WCHAR[cch];

        if (pszFileW)
        {
            int iRet = MultiByteToWideChar( CP_ACP,
                                            MB_PRECOMPOSED,
                                            lpszCmdLine,
                                            -1,
                                            pszFileW,
                                            cch);
            if (iRet)
            {
                HRESULT hr = HrInvokeDunFile_Internal(pszFileW);
                TraceError("Failed to invoke the DUN file", hr);
            }
            else
            {
                HRESULT hr = HrFromLastWin32Error();
                TraceError("Failed converting commandline to UniCode string", hr);
            }

            delete pszFileW;
        }
    }
}

EXTERN_C 
HRESULT APIENTRY RepairConnection(GUID guidConnection, LPWSTR * ppszMessage)
{
    return RepairConnectionInternal(guidConnection, ppszMessage);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetIconFromIconId
//
//  Purpose:    Exported version of CNetConfigIcons::HrGetIconFromMediaType
//
//  Arguments:
//      dwIconSize        [in] Size of the icon required
//      ncm               [in] The NETCON_MEDIATYPE
//      ncsm              [in] The NETCON_SUBMEDIATYPE
//      dwConnectionIcon  [in] ENUM_CONNECTION_ICON (Not shifted (IOW: 0 or 4,5,6,7)
//      dwCharacteristics [in] The NCCF_CHARACTERISTICS flag (0 allowed)
//      phIcon            [in] The resulting icon. Destroy using DestroyIcon
//
//  Returns:
//
//  Author:     deonb    23 Apr 2001
//
//  Notes:
//
EXTERN_C 
HRESULT APIENTRY HrGetIconFromMediaType(DWORD dwIconSize, IN NETCON_MEDIATYPE ncm, IN NETCON_SUBMEDIATYPE ncsm, IN DWORD dwConnectionIcon, IN DWORD dwCharacteristics, OUT HICON *phIcon)
{
    Assert(g_pNetConfigIcons);
    if (g_pNetConfigIcons)
    {
        return g_pNetConfigIcons->HrGetIconFromMediaType(dwIconSize, ncm, ncsm, dwConnectionIcon, dwCharacteristics, phIcon);
    }
    else
    {
        return E_UNEXPECTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\dll\implinc.cpp ===
#include "pch.h"
#pragma hdrstop
#include "nsbase.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

// Include ATL's implementation.  Substitute _ASSERTE with our Assert.
//
#ifdef _ASSERTE
#undef _ASSERTE
#define _ASSERTE Assert
#endif

#include <atlimpl.cpp>
#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>
#include <atlwin.cpp>


#define INITGUID
#include <nmclsid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\dll\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Connections Shell"
#define VER_INTERNALNAME_STR            "netshell.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\dll\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

//#pragma comment(lib, "rpcndr.lib")
//#pragma comment(lib, "rpcns4.lib")
//#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "netshell_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL
WINAPI
PrxDllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    return TRUE;
}

STDAPI
PrxDllCanUnloadNow ()
{
    return S_OK;
}

STDAPI
PrxDllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv)
{
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI
PrxDllRegisterServer ()
{
    return S_OK;
}

STDAPI
PrxDllUnregisterServer ()
{
    return S_OK;
}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\dun\dunimport.h ===
#pragma once
#include "ncstring.h"
#include "ras.h"

HRESULT HrInvokeDunFile_Internal(IN LPWSTR szDunFile);

HRESULT HrGetPhoneBookFile(tstring& strPhoneBook);

HRESULT HrGetEntryName(IN LPWSTR szDunFile, 
                       IN LPWSTR szEntryName, 
                       tstring & strPhoneBook);

HRESULT HrImportPhoneBookInfo(  IN LPWSTR szDunFile, 
                                IN LPWSTR szEntryName, 
                                tstring & strPhoneBook);

HRESULT HrImportPhoneInfo(RASENTRY * pRasEntry, 
                          IN LPWSTR  szDunFile);

VOID ImportDeviceInfo(RASENTRY * pRasEntry, 
                      IN LPWSTR  szDunFile);

VOID ImportServerInfo(RASENTRY * pRasEntry, 
                      IN LPWSTR  szDunFile);


VOID ImportIPInfo(RASENTRY * pRasEntry, 
                  IN LPWSTR  szDunFile);

VOID ImportScriptFileName(RASENTRY * pRasEntry, 
                          IN LPWSTR  szDunFile);

VOID SzToRasIpAddr(IN LPWSTR szIPAddr, 
                   OUT RASIPADDR * pIpAddr);

HRESULT HrImportMLInfo( IN LPWSTR szDunFile, 
                        IN LPWSTR szEntryName, 
                        tstring & pRasIpAddr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\dun\dunimport.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       D U N I M P O R T . C P P
//
//  Contents:   Functions that handles .DUN files for RAS connections
//              created in win9x
//
//  Notes:
//
//  Author:     TongL   15 March 1999
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "dunimport.h"
#include "raserror.h"
#include "ncras.h"
#include "connutil.h"

#define RAS_MaxEntryName    256
#define MAXLONGLEN          11              // Maximum long string length
#define MAXIPADDRLEN        20
#define SIZE_ReadBuf        0x00008000      // 32K buffer size
#define NUM_IP_FIELDS       4
#define MIN_IP_VALUE        0
#define MAX_IP_VALUE        255
#define CH_DOT              L'.'

const WCHAR c_szPhoneBookPath[]     = L"\\Microsoft\\Network\\Connections\\Pbk\\rasphone.pbk";
const WCHAR c_szRASDT[]             = L"RASDT_";

const WCHAR c_szEntrySection[]      = L"Entry";
const WCHAR c_szEntryName[]         = L"Entry_Name";
const WCHAR c_szML[]                = L"Multilink";

const WCHAR c_szPhoneSection[] = L"Phone";
const WCHAR c_szDialAsIs[]     = L"Dial_As_Is";
const WCHAR c_szPhoneNumber[]  = L"Phone_Number";
const WCHAR c_szAreaCode[]     = L"Area_Code";
const WCHAR c_szCountryCode[]  = L"Country_Code";
const WCHAR c_szCountryID[]    = L"Country_ID";

const WCHAR c_szYes[]          = L"yes";
const WCHAR c_szNo[]           = L"no";

const WCHAR c_szDeviceSection[] = L"Device";
const WCHAR c_szDeviceType[]    = L"Type";
const WCHAR c_szModem[]         = L"modem";
const WCHAR c_szVpn[]           = L"vpn";
const WCHAR c_szDeviceName[]    = L"Name";

const WCHAR c_szServerSection[] = L"Server";
const WCHAR c_szServerType[]    = L"Type";
const WCHAR c_szPPP[]           = L"PPP";
const WCHAR c_szSLIP[]          = L"SLIP";
const WCHAR c_szRAS[]           = L"RAS";
const WCHAR c_szSWCompress[]    = L"SW_Compress";
const WCHAR c_szPWEncrypt[]     = L"PW_Encrypt";
const WCHAR c_szNetLogon[]      = L"Network_Logon";
const WCHAR c_szSWEncrypt[]     = L"SW_Encrypt";
const WCHAR c_szNetBEUI[]       = L"Negotiate_NetBEUI";
const WCHAR c_szIPX[]           = L"Negotiate_IPX/SPX";
const WCHAR c_szIP[]            = L"Negotiate_TCP/IP";

const WCHAR c_szIPSection[]     = L"TCP/IP";
const WCHAR c_szIPSpec[]        = L"Specify_IP_Address";
const WCHAR c_szIPAddress[]     = L"IP_address";
const WCHAR c_szServerSpec[]    = L"Specify_Server_Address";
const WCHAR c_szDNSAddress[]    = L"DNS_address";
const WCHAR c_szDNSAltAddress[] = L"DNS_Alt_address";
const WCHAR c_szWINSAddress[]   = L"WINS_address";
const WCHAR c_szWINSAltAddress[]= L"WINS_Alt_address";
const WCHAR c_szIPCompress[]    = L"IP_Header_Compress";
const WCHAR c_szRemoteGateway[] = L"Gateway_On_Remote";

//+---------------------------------------------------------------------------
//
//  Function:   HrInvokeDunFile_Internal
//
//  Purpose:    This is the entry point for DUN file invoking
//
//  Arguments:
//      szFileName [in] The .DUN file name
//
//  Returns:    S_OK if succeeded, failure code otherwise
//

HRESULT HrInvokeDunFile_Internal(IN LPWSTR szDunFile)
{
    HRESULT hr = S_OK;
    WCHAR   szEntryName[RAS_MaxEntryName+1];
    tstring strPhoneBook;

    hr = HrGetPhoneBookFile(strPhoneBook);
    if (SUCCEEDED(hr))
    {
        // Get the size of device configuration
        // This also validates an exported file
        //
        hr = HrGetEntryName(szDunFile, szEntryName, strPhoneBook);

        if ((HRESULT_FROM_WIN32(ERROR_CANNOT_OPEN_PHONEBOOK) == hr) ||
            (HRESULT_FROM_WIN32(ERROR_CANNOT_FIND_PHONEBOOK_ENTRY) == hr))
        {
            // create a new entry in the current user's phonebook
            hr = HrImportPhoneBookInfo(szDunFile, szEntryName, strPhoneBook);
        }

        if (SUCCEEDED(hr))
        {
            // get the GUID of this connection
            RASENTRY*   pRasEntry = NULL;
            hr = HrRasGetEntryProperties( strPhoneBook.c_str(),
                                          szEntryName,
                                          &pRasEntry,
                                          NULL);
            if(SUCCEEDED(hr))
            {
                // dial the connection
                hr = HrLaunchConnection(pRasEntry->guidId);
                MemFree(pRasEntry);
            }
        }
    }

    TraceError("HrInvokeDunFile_Internal", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetPhoneBookFile
//
//  Purpose:    This function will return the proper path to the current user's
//              phonebook.
//
//  Arguments:
//      szFileName [in] The .DUN file name
//
//  Returns:    S_OK if succeeded, failure code otherwise
//
HRESULT HrGetPhoneBookFile(tstring& strPhoneBook)
{
    HRESULT hr = S_OK;
    strPhoneBook = c_szEmpty;

    LPITEMIDLIST    pidl;
    LPMALLOC        pMalloc;
    WCHAR           szDir[MAX_PATH+1];

    hr = SHGetSpecialFolderLocation(NULL,
                                    CSIDL_APPDATA,
                                    &pidl);
    if(SUCCEEDED(hr))
    {
        if (SHGetPathFromIDList(pidl, szDir))
        {
            strPhoneBook = szDir;
            TraceTag(ttidDun, "The path to the application directory is: %S", strPhoneBook.c_str());

            // release the memory by using the the shell's IMalloc ptr
            //
            if (SUCCEEDED(SHGetMalloc(&pMalloc)))
            {
                pMalloc->Free(pidl);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr))
    {
        TraceTag(ttidDun, "The path to the phonebook is: %S", strPhoneBook.c_str());
        strPhoneBook += c_szPhoneBookPath;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetEntryName
//
//  Purpose:    This function validates and returns the entry name
//
//  Arguments:
//      szDunFile   [in] The .dun file created on win9x
//      szEntryName [in] The entry name for this connection
//
//  Returns:    S_OK if valid and is a new entry
//              S_FALSE if valid and but is an existing entry
//              otherwise, specific error
//
HRESULT HrGetEntryName(IN LPWSTR szFileName,
                       IN LPWSTR szEntryName,
                       tstring & strPhoneBook)
{
    HRESULT hr = S_OK;
    DWORD dwRet;

    // Get the entry name
    //
    dwRet = GetPrivateProfileString(c_szEntrySection,
                                    c_szEntryName,
                                    c_szEmpty,
                                    szEntryName,
                                    RAS_MaxEntryName+1,
                                    szFileName);
    // no entry name
    if (dwRet <= 0)
    {
        return HRESULT_FROM_WIN32(ERROR_CORRUPT_PHONEBOOK);
    }

    // Check if entry name already exists in phonebook
    //
    RASENTRY*   pRasEntry = NULL;
    hr = HrRasGetEntryProperties( strPhoneBook.c_str(),
                                  szEntryName,
                                  &pRasEntry,
                                  NULL);
    MemFree(pRasEntry);

    TraceErrorOptional("HrGetEntryName", hr,
                       ((HRESULT_FROM_WIN32(ERROR_CANNOT_OPEN_PHONEBOOK) == hr) ||
                        (HRESULT_FROM_WIN32(ERROR_CANNOT_FIND_PHONEBOOK_ENTRY) == hr)));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrImportPhoneBookInfo
//
//  Purpose:    This function checks if the RAS entry already exists in the
//              current user's phonebook
//
//  Arguments:
//      szEntryName [in] The entry name for this connection
//
//  Returns:    TRUE if already exists, FALSE otherwise
//
HRESULT HrImportPhoneBookInfo(  IN LPWSTR szDunFile,
                                IN LPWSTR szEntryName,
                                tstring & strPhoneBook)
{
    HRESULT hr = S_OK;
    RASENTRY RasEntry = {0};

    // Get the phone number
    //
    hr = HrImportPhoneInfo(&RasEntry, szDunFile);
    if (SUCCEEDED(hr))
    {
        // Get device name, type and config
        //
        ImportDeviceInfo(&RasEntry, szDunFile);

        // Get Server Type settings
        //
        ImportServerInfo(&RasEntry, szDunFile);

        // Get IP address
        //
        ImportIPInfo(&RasEntry, szDunFile);

        // Prompt for user name and password
        RasEntry.dwfOptions |= RASEO_PreviewUserPw;

        // Save it to the phonebook
        //
        DWORD dwRet;
        RasEntry.dwSize = sizeof(RASENTRY);
        RasEntry.dwType = RASET_Phone;
        dwRet = RasSetEntryProperties(strPhoneBook.c_str(),
                                      szEntryName,
                                      &RasEntry,
                                      sizeof(RASENTRY),
                                      NULL,
                                      0);

        hr = HRESULT_FROM_WIN32(dwRet);
        TraceError("RasSetEntryProperties", hr);
    }

    TraceError("HrImportPhoneBookInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrImportPhoneInfo
//
//  Purpose:    This function imports the phone number
//
//  Arguments:
//      szFileName [in] The .DUN file name
//
//  Returns:
//
HRESULT HrImportPhoneInfo(RASENTRY * pRasEntry,
                          IN LPWSTR  szFileName)
{
    HRESULT hr = S_OK;

    // szLocalPhoneNumber
    if (GetPrivateProfileString(c_szPhoneSection,
                                c_szPhoneNumber,
                                c_szEmpty,
                                pRasEntry->szLocalPhoneNumber,
                                celems(pRasEntry->szLocalPhoneNumber),
                                szFileName) == 0)
    {
        hr = HRESULT_FROM_WIN32(ERROR_CORRUPT_PHONEBOOK);
    };

    if (SUCCEEDED(hr))
    {
        WCHAR   szYesNo[MAXLONGLEN+1];

        GetPrivateProfileString(c_szPhoneSection,
                                c_szDialAsIs,
                                c_szYes,
                                szYesNo,
                                celems(szYesNo),
                                szFileName);

        // Do we have to get country code and area code?
        //
        if (!lstrcmpiW(szYesNo, c_szNo))
        {
            // use country and area codes
            pRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;

            // If we cannot get the country ID or it is zero, default to dial as is
            //
            if ((pRasEntry->dwCountryID = GetPrivateProfileInt( c_szPhoneSection,
                                                                c_szCountryID,
                                                                0,
                                                                szFileName)) != 0)
            {
                pRasEntry->dwCountryCode = GetPrivateProfileInt(c_szPhoneSection,
                                                                c_szCountryCode,
                                                                1,
                                                                szFileName);
            }

            GetPrivateProfileString(c_szPhoneSection,
                                    c_szAreaCode,
                                    c_szEmpty,
                                    pRasEntry->szAreaCode,
                                    celems(pRasEntry->szAreaCode),
                                    szFileName);
        };
    }

    TraceError("HrImportPhoneInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ImportDeviceInfo
//
//  Purpose:    This function imports the device info
//
//  Arguments:
//      szFileName [in] The .DUN file name
//
//  Returns:
//
VOID ImportDeviceInfo(RASENTRY * pRasEntry,
                      IN LPWSTR  szFileName)
{
    WCHAR szDeviceType[RAS_MaxDeviceType+1];

    // Get the device type
    //
    if (GetPrivateProfileString(c_szDeviceSection,
                                c_szDeviceType,
                                c_szEmpty,
                                szDeviceType,
                                celems(szDeviceType),
                                szFileName))
    {
        if (!lstrcmpiW(szDeviceType, c_szModem))
        {
            lstrcpyW(pRasEntry->szDeviceType, RASDT_Modem);
        }
        else if (!lstrcmpiW(szDeviceType, c_szVpn))
        {
            lstrcpyW(pRasEntry->szDeviceType, RASDT_Vpn);
        }
        else
        {
            AssertSz(FALSE, "Unknown device type");
        }

        // Get the device name
        //
        GetPrivateProfileString( c_szDeviceSection,
                                 c_szDeviceName,
                                 c_szEmpty,
                                 pRasEntry->szDeviceName,
                                 celems(pRasEntry->szDeviceName),
                                 szFileName);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ImportServerInfo
//
//  Purpose:    This function imports the server type name and settings
//
//  Arguments:
//      szFileName [in] The .DUN file name
//
//  Returns:
//

VOID ImportServerInfo(RASENTRY * pRasEntry,
                      IN LPWSTR  szFileName)
{
    HRESULT hr = S_OK;

    WCHAR szValue[MAXLONGLEN];
    WCHAR szYesNo[MAXLONGLEN];
    DWORD dwRet;

    // Get the server type: PPP, SLIP or RAS
    //
    if (GetPrivateProfileString(c_szServerSection,
                                c_szServerType,
                                c_szEmpty,
                                szValue,
                                celems(szValue),
                                szFileName))
    {
        if (!lstrcmpiW(szValue, c_szPPP))
        {
            pRasEntry->dwFramingProtocol = RASFP_Ppp;
        }
        else if (!lstrcmpiW(szValue, c_szSLIP))
        {
            pRasEntry->dwFramingProtocol = RASFP_Slip;
        }
        else if (!lstrcmpiW(szValue, c_szRAS))
        {
            pRasEntry->dwFramingProtocol = RASFP_Ras;
        }
    }

    // SW_Compress
    //
    if (GetPrivateProfileString(c_szServerSection,
                                c_szSWCompress,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfOptions |= RASEO_SwCompression;
        };
    };

    // PW_Encrypt
    //
    if (GetPrivateProfileString(c_szServerSection,
                                c_szPWEncrypt,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfOptions |= RASEO_RequireEncryptedPw;
        };
    };

    // Network_Logon
    //
    if (GetPrivateProfileString(c_szServerSection,
                                c_szNetLogon,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfOptions |= RASEO_NetworkLogon;
        };
    };


    // SW_Encrypt
    //
    // set both RASEO_RequireMsEncryptedPw and RASEO_RequireDataEncryption
    // if SW_Encrypt is TRUE
    //
    if (GetPrivateProfileString(c_szServerSection,
                                c_szSWEncrypt,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfOptions |= RASEO_RequireMsEncryptedPw;
            pRasEntry->dwfOptions |= RASEO_RequireDataEncryption;
        };
    };

    // Get the network protocols to negotiate
    //
    if (GetPrivateProfileString(c_szServerSection,
                                c_szNetBEUI,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfNetProtocols |= RASNP_NetBEUI;
        };
    };

    if (GetPrivateProfileString(c_szServerSection,
                                c_szIPX,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfNetProtocols |= RASNP_Ipx;
        };
    };

    if (GetPrivateProfileString(c_szServerSection,
                                c_szIP,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfNetProtocols |= RASNP_Ip;
        };
    };
}


//+---------------------------------------------------------------------------
//
//  Function:   ImportIPInfo
//
//  Purpose:    This function imports the device info
//
//  Arguments:
//      szFileName [in] The .DUN file name
//
//  Returns:
//

VOID ImportIPInfo(RASENTRY * pRasEntry,
                  IN LPWSTR  szFileName)
{
    WCHAR   szIPAddr[MAXIPADDRLEN];
    WCHAR   szYesNo[MAXLONGLEN];

    // Import IP address information
    //
    if (GetPrivateProfileString(c_szIPSection,
                                c_szIPSpec,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfOptions |= RASEO_SpecificIpAddr;

            // Get the IP address
            //
            if (GetPrivateProfileString(c_szIPSection,
                                        c_szIPAddress,
                                        c_szEmpty,
                                        szIPAddr,
                                        celems(szIPAddr),
                                        szFileName))
            {
                SzToRasIpAddr(szIPAddr, &(pRasEntry->ipaddr));
            };
        }
    };

    // Import Server address information
    //
    if (GetPrivateProfileString(c_szIPSection,
                                c_szServerSpec,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            // The import file has server address specified, get the server address
            //
            pRasEntry->dwfOptions |= RASEO_SpecificNameServers;

            if (GetPrivateProfileString(c_szIPSection,
                                        c_szDNSAddress,
                                        c_szEmpty,
                                        szIPAddr,
                                        celems(szIPAddr),
                                        szFileName))
            {
                SzToRasIpAddr(szIPAddr, &(pRasEntry->ipaddrDns));
            };

            if (GetPrivateProfileString(c_szIPSection,
                                        c_szDNSAltAddress,
                                        c_szEmpty,
                                        szIPAddr,
                                        celems(szIPAddr),
                                        szFileName))
            {
                SzToRasIpAddr(szIPAddr, &(pRasEntry->ipaddrDnsAlt));
            };

            if (GetPrivateProfileString(c_szIPSection,
                                        c_szWINSAddress,
                                        c_szEmpty,
                                        szIPAddr,
                                        celems(szIPAddr),
                                        szFileName))
            {
                SzToRasIpAddr(szIPAddr, &(pRasEntry->ipaddrWins));
            };

            if (GetPrivateProfileString(c_szIPSection,
                                        c_szWINSAltAddress,
                                        c_szEmpty,
                                        szIPAddr,
                                        celems(szIPAddr),
                                        szFileName))
            {
                SzToRasIpAddr(szIPAddr, &(pRasEntry->ipaddrWinsAlt));
            };
        }
    };

    // Header compression and the gateway settings
    //
    if (GetPrivateProfileString(c_szIPSection,
                                c_szIPCompress,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
        }
    };

    if (GetPrivateProfileString(c_szIPSection,
                                c_szRemoteGateway,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
        }
    };
}

VOID SzToRasIpAddr(IN LPWSTR szIPAddress,
                   OUT RASIPADDR * pIpAddr)
{
    list<tstring *> listFields;
    ConvertStringToColString(szIPAddress,
                             CH_DOT,
                             listFields);

    list<tstring *>::const_iterator iter = listFields.begin();

    if (listFields.size() == NUM_IP_FIELDS)
    {
        // Go through each field and get the number value
        BYTE a = _wtol((*iter++)->c_str());
        BYTE b = _wtol((*iter++)->c_str());
        BYTE c = _wtol((*iter++)->c_str());
        BYTE d = _wtol((*iter++)->c_str());

        // validate the address
        if ((a >= MIN_IP_VALUE) && (a <= MAX_IP_VALUE) &&
            (b >= MIN_IP_VALUE) && (b <= MAX_IP_VALUE) &&
            (c >= MIN_IP_VALUE) && (c <= MAX_IP_VALUE) &&
            (d >= MIN_IP_VALUE) && (d <= MAX_IP_VALUE))
        {
            pIpAddr->a = a;
            pIpAddr->b = b;
            pIpAddr->c = c;
            pIpAddr->d = d;
        }
    }
    FreeCollectionAndItem(listFields);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\ac_ctrayui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ac_CTrayUi.h
//
//  Contents:   Home Networking Auto Config Tray Icon UI code
//
//  Author:     jeffsp    9/27/2000
//
//----------------------------------------------------------------------------

#pragma once

extern HWND g_hwndHnAcTray;



LRESULT
CALLBACK
CHnAcTrayUI_WndProc (
                 HWND    hwnd,       // window handle
                 UINT    uiMessage,  // type of message
                 WPARAM  wParam,     // additional information
                 LPARAM  lParam);    // additional information


LRESULT 
OnHnAcTrayWmNotify(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam 
);	

LRESULT 
OnHnAcTrayWmTimer(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam 
);	

HRESULT HrRunHomeNetworkWizard(
	HWND                    hwndOwner
);


LRESULT OnHnAcTrayWmCreate(
    HWND hwnd
);

LRESULT OnHnAcMyWMNotifyIcon(HWND hwnd,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam
);


HRESULT ac_CreateHnAcTrayUIWindow();
LRESULT ac_DestroyHnAcTrayUIWindow();
LRESULT ac_DeviceChange(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
HRESULT ac_Register(HWND hWindow);
HRESULT ac_Unregister(HWND hWindow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\ac_sink.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       ac_sink.cpp
//
//  Contents:   Home Networking Auto Config Sink object code.
//
//  Author:     jeffsp   9/27/00
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#ifdef PROVIDE_AUTO_CONFIG_SERVICES

#include "ac_sink.h"
#include "ac_CTrayUi.h"



HRESULT STDMETHODCALLTYPE CAutoConfigUISink::DisplayHomeNetWizardHint() 
{
	HRESULT hr;
	hr = ac_CreateHnAcTrayUIWindow();

	return S_OK;
}	


void ac_CreateHomeNetAutoConfigSink()
{	
    HRESULT hr  = S_OK;

	DWORD mTmp_dwAutoAdviseCookie; // HACKHACK

	IHomeNetAutoConfigService *pI = NULL;
	IConnectionPointContainer *pContainer = NULL;
	IConnectionPoint *pIMyConnPoint = NULL;
	IAutoConfigUISink *pSink = NULL;
	CAutoConfigUISink *pObj = NULL;

	hr = CoCreateInstance( CLSID_HomeNetAutoConfigService, NULL, CLSCTX_ALL, IID_IHomeNetAutoConfigService, (void **)&pI );
	if( !SUCCEEDED(hr) ){
//		this->SetDlgItemText(IDC_EDIT2, "CoCreateInstance Failed!");
        goto done;
	}

	if( pI == NULL ){
//		this->SetDlgItemText(IDC_EDIT2, "pI NULL!");
        goto done;
	}

	hr = pI->QueryInterface( IID_IConnectionPointContainer, (void **)&pContainer );
	if( !SUCCEEDED(hr) ){
//		this->SetDlgItemText(IDC_EDIT2, "QI for container fialed!");
		goto done;
	}
    hr = pContainer->FindConnectionPoint(IID_IAutoConfigUISink, &pIMyConnPoint);
  	    pContainer->Release();
		pContainer = NULL;
    if( !SUCCEEDED(hr) ){
//		this->SetDlgItemText(IDC_EDIT2, "Find connection point failed!");
		goto done;
	}

//    this->SetDlgItemText(IDC_EDIT2, "Looks Good");

	pObj = new CComObject <CAutoConfigUISink>;
	if( !pObj ){

//		this->SetDlgItemText(IDC_EDIT2, "New failed" );
		goto done;
	}
//	pObj->Init(this);
	
	hr = pObj->QueryInterface(IID_IAutoConfigUISink, (void **)&pSink);
	if( !SUCCEEDED(hr) ){
//		this->SetDlgItemText(IDC_EDIT2, "QI for IID_IAutoConfigUISink failed" );
		delete pObj;
		goto done;
	}

	hr = pIMyConnPoint->Advise(pSink, &mTmp_dwAutoAdviseCookie );
	if( SUCCEEDED(hr)){
//		this->SetDlgItemText(IDC_EDIT2, "Advise Succeeded" );
	}else{
//		this->SetDlgItemText(IDC_EDIT2, "Advise Failed" );
		pSink->Release();
	}
	
	return;


done: 

	if( pContainer ){
		pContainer->Release();
	}
	if( pIMyConnPoint ){
		pIMyConnPoint->Release();
	}
	if( pI ){
		pI->Release();
	}

    return;
}

void ac_DestroyHomeNetAutoConfigSink(void)
{	
	HRESULT hr;

	IHomeNetAutoConfigService *pI = NULL;
	IConnectionPointContainer *pContainer = NULL;
	IConnectionPoint *pIMyConnPoint = NULL;
	IAutoConfigUISink *pSink = NULL;
	CAutoConfigUISink *pObj = NULL;


	hr = CoCreateInstance( CLSID_HomeNetAutoConfigService, NULL, CLSCTX_ALL, IID_IHomeNetAutoConfigService, (void **)&pI );
	if( !SUCCEEDED(hr) ){
//		this->SetDlgItemText(IDC_EDIT2, "CoCreateInstance Failed!");
		return;
	}

	if( pI == NULL ){
//		this->SetDlgItemText(IDC_EDIT2, "pI NULL!");
		return;
	}

	hr = pI->QueryInterface( IID_IConnectionPointContainer, (void **)&pContainer );
	if( !SUCCEEDED(hr) ){
//		this->SetDlgItemText(IDC_EDIT2, "QI for container fialed!");
		goto done;
	}
    hr = pContainer->FindConnectionPoint(IID_IAutoConfigUISink, &pIMyConnPoint);
  	    pContainer->Release();
		pContainer = NULL;
    if( !SUCCEEDED(hr) ){
//		this->SetDlgItemText(IDC_EDIT2, "Find connection point failed!");
		goto done;
	}

//    this->SetDlgItemText(IDC_EDIT2, "Looks Good");

// HACKHACK	hr = pIMyConnPoint->Unadvise(m_dwAutoAdviseCookie );
// HACKHACK	hr = pIMyConnPoint->Unadvise(m_dwAutoAdviseCookie );
// HACKHACK	hr = pIMyConnPoint->Unadvise(m_dwAutoAdviseCookie );
// HACKHACK	hr = pIMyConnPoint->Unadvise(m_dwAutoAdviseCookie );
// HACKHACK	hr = pIMyConnPoint->Unadvise(m_dwAutoAdviseCookie );
// HACKHACK	hr = pIMyConnPoint->Unadvise(m_dwAutoAdviseCookie );
// HACKHACK	hr = pIMyConnPoint->Unadvise(m_dwAutoAdviseCookie );
// HACKHACK	hr = pIMyConnPoint->Unadvise(m_dwAutoAdviseCookie );

	if( SUCCEEDED(hr)){
//		this->SetDlgItemText(IDC_EDIT2, "Unadvise Succeeded" );
	}else{
//		this->SetDlgItemText(IDC_EDIT2, "Unadvise Failed" );
		pSink->Release();
	}
	
	return;


done: 

	if( pContainer ){
		pContainer->Release();
	}
	if( pIMyConnPoint ){
		pIMyConnPoint->Release();
	}
	if( pI ){
		pI->Release();
	}

    return;
}

#endif //#ifdef PROVIDE_AUTO_CONFIG_SERVICES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\ac_sink.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ac_sink.h
//
//  Contents:   Home Networking Auto Config Sink class definition
//
//  Author:     jeffsp    9/27/2000
//
//----------------------------------------------------------------------------



#pragma once

#ifdef PROVIDE_AUTO_CONFIG_SERVICES


#include <netshell.h>
#include "nsbase.h"
#include "nsres.h"

void ac_CreateHomeNetAutoConfigSink(void);

class ATL_NO_VTABLE CAutoConfigUISink :
    public CComObjectRootEx<CComObjectThreadModel>,
	public IAutoConfigUISink
{
private:
	class CMyDialogTst *m_Dialog;

public:
    BEGIN_COM_MAP(CAutoConfigUISink)
        COM_INTERFACE_ENTRY(IAutoConfigUISink)
    END_COM_MAP()


	CAutoConfigUISink(){
	}
	~CAutoConfigUISink(){
	}

	
	void Init(class CMyDialogTst *pDialog){
		m_Dialog = pDialog;
	}

	// IAutoConfigUISink
    STDMETHOD(DisplayHomeNetWizardHint)();
    		
};
#endif //#ifdef PROVIDE_AUTO_CONFIG_SERVICES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\ac_ctrayui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ac_CTrayUiCpp.h
//
//  Contents:   Home Networking Auto Config Tray Icon UI code
//
//  Author:     jeffsp    9/27/2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop



#include "ac_CTrayUi.h"
#include "foldinc.h"    // Standard shell\tray includes
#include <nsres.h>
#include "foldres.h"
#include "traymsgs.h"
#include <dbt.h>
#include <ndisguid.h>
#include "lm.h"



UINT g_uWindowRefCount = 0;
HWND g_hwndHnAcTray = NULL;
UINT_PTR g_HnAcTimerHandle = NULL;
HDEVNOTIFY  g_hDeviceChangeNotify = NULL;


CRITICAL_SECTION g_WindowCriticalSection;
const WCHAR c_szHnAcTrayClass[]             = L"Home Net Auto Config Tray";
const DWORD c_dwAutoConfigBalloonTimeoutSeconds   = 15;
static const WCHAR c_szRunDll32[]             = L"rundll32.exe";
static const WCHAR c_szRunHomeNetworkWizard[] = L"hnetwiz.dll,HomeNetWizardRunDll";

DWORD WINAPI ac_AsyncDeviceChange(LPVOID lpParam);
HRESULT IsAdapterPhysical(GUID* pGuid, BOOL* bPhysical);


LRESULT
CALLBACK
CHnAcTrayUI_WndProc (
                 HWND    hwnd,       // window handle
                 UINT    uiMessage,  // type of message
                 WPARAM  wParam,     // additional information
                 LPARAM  lParam)     // additional information
{
    switch (uiMessage)
    {
      case WM_CREATE:
        return OnHnAcTrayWmCreate(hwnd);

      case MYWM_NOTIFYICON:
        return OnHnAcMyWMNotifyIcon(hwnd, uiMessage, wParam, lParam);

      case WM_DESTROY:
        g_hwndHnAcTray = NULL;
        PostQuitMessage(0);
        break;


      default:     // Passes it on if unproccessed
        return (DefWindowProc (hwnd, uiMessage, wParam, lParam));
    }
    return (0);
}

HRESULT ac_CreateHnAcTrayUIWindow()
{

    HRESULT hr = S_OK;

    // create a hidden window
    //
    WNDCLASS wndclass;
    ZeroMemory (&wndclass, sizeof(wndclass));

    wndclass.lpfnWndProc   = CHnAcTrayUI_WndProc;
    wndclass.hInstance     = _Module.GetResourceInstance();
    wndclass.lpszClassName = c_szHnAcTrayClass;

    RegisterClass (&wndclass);

    EnterCriticalSection(&g_WindowCriticalSection); // we have to protect this since we are on a thread pool callback

    if(0 == g_uWindowRefCount++)
    {
        CreateWindow(c_szHnAcTrayClass,
        c_szHnAcTrayClass,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        _Module.GetResourceInstance(),
        NULL);
    }
    LeaveCriticalSection(&g_WindowCriticalSection);

    BOOL bGetMessage;
    MSG Message;

    while(bGetMessage = GetMessage(&Message, g_hwndHnAcTray, 0, 0) && -1 != bGetMessage)
    {
        DispatchMessage(&Message);
    }

    return hr;
}





LRESULT OnHnAcTrayWmCreate(HWND hwnd)
{
    g_hwndHnAcTray = hwnd;


    HICON hiconTray;
    HRESULT hr = S_OK;

    hiconTray = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_CONFOLD_HOMENET_WIZARD));

    if (hiconTray)
    {
        NOTIFYICONDATA  nid;

        ZeroMemory (&nid, sizeof(nid));
        nid.cbSize              = sizeof(NOTIFYICONDATA);
        nid.hWnd                = g_hwndHnAcTray;
        nid.uID                 = 9998;
        nid.uFlags              = NIF_MESSAGE | NIF_ICON; // | NIF_STATE;
        nid.uCallbackMessage    = MYWM_NOTIFYICON;
        nid.hIcon               = hiconTray;
//      nid.dwState             = NIS_HIDDEN;
//      nid.dwStateMask         = nid.dwState;

        // Configure the balloon tip
        {
            nid.uFlags |= NIF_INFO;
            nid.dwInfoFlags = NIIF_INFO;
            nid.uTimeout = c_dwAutoConfigBalloonTimeoutSeconds * 1000;

            // WARNING these fields are 64 and 256 chars max
            lstrcpyW(nid.szInfoTitle, SzLoadIds(IDS_AUTOCONFIGTRAY_RUN_HOME_NET_WIZARD_BALLOON_TITLE));
            lstrcpyW(nid.szInfo, SzLoadIds(IDS_AUTOCONFIGTRAY_RUN_HOME_NET_WIZARD_BALLOON));
        }

        hr = HrShell_NotifyIcon(NIM_ADD, &nid);

        nid.uVersion = NOTIFYICON_VERSION;
        nid.uFlags   = 0;
        hr = HrShell_NotifyIcon(NIM_SETVERSION, &nid);

    }

    return 0;
}

LRESULT OnHnAcTrayWmNotify(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam )
{

    return (DefWindowProc (hwnd, WM_NOTIFY, wParam, lParam));

}


LRESULT OnHnAcMyWMNotifyIcon(HWND hwnd, UINT uiMessage, WPARAM wParam, LPARAM lParam)
{
    UINT    uiIcon;
    UINT    uiMouseMsg;

    uiIcon = (UINT) wParam;
    uiMouseMsg = (UINT) lParam;

    switch (uiMouseMsg)
    {
      case NIN_BALLOONTIMEOUT:
        ac_DestroyHnAcTrayUIWindow();
        break;
      case NIN_BALLOONHIDE:
        break;
      case NIN_BALLOONSHOW:
        break;
      case NIN_BALLOONUSERCLICK:
        HrRunHomeNetworkWizard(hwnd);
        ac_DestroyHnAcTrayUIWindow();
        break;
      case NIN_KEYSELECT:
        break;
      case NIN_SELECT:
        break;

    }

    return 0;
}


HRESULT HrRunHomeNetworkWizard(
    HWND                    hwndOwner)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT   hr          = S_OK;
    WCHAR     szPath[MAX_PATH];
    
    hr = SHGetFolderPath(
                hwndOwner,
                CSIDL_SYSTEM,
                NULL,
                SHGFP_TYPE_CURRENT,
                szPath);

    if (SUCCEEDED(hr))
    {
        HINSTANCE hInst = ::ShellExecute(hwndOwner, NULL, c_szRunDll32, c_szRunHomeNetworkWizard, szPath, SW_SHOW );
        if (hInst <= reinterpret_cast<HINSTANCE>(32))
        {
            hr = HRESULT_FROM_WIN32(static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(hInst)));
        }
    }
    
    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrRunHomeNetworkWizard");
    return hr;
}



LRESULT ac_DestroyHnAcTrayUIWindow()
{
    HRESULT hr = S_OK;
    NOTIFYICONDATA  nid;

    ZeroMemory (&nid, sizeof(nid));
    nid.cbSize              = sizeof(NOTIFYICONDATA);
    nid.hWnd                = g_hwndHnAcTray;
    nid.uID                 = 9998;
    nid.uFlags              = 0;
    nid.uCallbackMessage    = MYWM_NOTIFYICON;
    nid.hIcon               = 0;

    hr = HrShell_NotifyIcon(NIM_DELETE, &nid);

#if 0
    if (!SUCCEEDED(hr)){
        MessageBox( NULL,
        L"NotifyIcon DELETE failed",
        L"This is a test...",
        MB_OK | MB_ICONERROR);
    }
#endif

    EnterCriticalSection(&g_WindowCriticalSection);
    if(0 == --g_uWindowRefCount)
    {
        DestroyWindow(g_hwndHnAcTray);
    }
    LeaveCriticalSection(&g_WindowCriticalSection);

    return 0;
}

LRESULT ac_DeviceChange(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{

    // COM is initialized

    if(NULL != g_hDeviceChangeNotify)
    {
        HRESULT hr;
        if(DBT_DEVICEARRIVAL == wParam)
        {
            DEV_BROADCAST_DEVICEINTERFACE* pInfo = (DEV_BROADCAST_DEVICEINTERFACE*)lParam;

            if (DBT_DEVTYP_DEVICEINTERFACE == pInfo->dbcc_devicetype)
            {
                LPWSTR pszNetDeviceGuid = wcsrchr(pInfo->dbcc_name, L'\\'); // need a better way to do this, but shouldn't crash
                if(NULL != pszNetDeviceGuid)
                {
                    GUID* pDeviceGuid = reinterpret_cast<GUID*>(CoTaskMemAlloc(sizeof(GUID)));
                    if(NULL != pDeviceGuid)
                    {
                        hr = CLSIDFromString(pszNetDeviceGuid + 1, pDeviceGuid); // +1 is safe, at worst it will point to L'\0'
                        if(SUCCEEDED(hr))
                        {
                            // we have to move this off-uithread
                            if(0 == QueueUserWorkItem(ac_AsyncDeviceChange, pDeviceGuid, WT_EXECUTELONGFUNCTION))
                            {
                                hr = E_FAIL;
                            }
                        }

                        if(FAILED(hr))
                        {
                            CoTaskMemFree(pDeviceGuid);
                        }
                    }
                }
            }
        }
    }
    return TRUE;
}

HRESULT ac_Register(HWND hWindow)
{

    HRESULT hr = S_OK;

#ifdef _WIN64
    // The autoconfig service is not available on IA64 (since the homenet wizard
    // isn't present)
    hr = E_FAIL;
#else
    //if the machine is a server SKU we don't create the autocfg stuff
    OSVERSIONINFOEXW verInfo = {0};
    ULONGLONG ConditionMask = 0;

    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    verInfo.wProductType = VER_NT_SERVER;

    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_GREATER_EQUAL);

    if(TRUE == (VerifyVersionInfo(&verInfo, VER_PRODUCT_TYPE, ConditionMask)))
    {
        hr = E_FAIL;
    }
#endif

    if(SUCCEEDED(hr))
    {
        // if machine is joined to a domain don't create the autocfg stuff
        LPWSTR pszNameBuffer;
        NETSETUP_JOIN_STATUS BufferType;

        if(NERR_Success == NetGetJoinInformation(NULL, &pszNameBuffer, &BufferType))
        {
            NetApiBufferFree(pszNameBuffer);
            if(NetSetupDomainName == BufferType)
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if(SUCCEEDED(hr))
    {

        DEV_BROADCAST_DEVICEINTERFACE PnpFilter;  // device change notifications for homenet auto config service
        ZeroMemory (&PnpFilter, sizeof(PnpFilter));

        PnpFilter.dbcc_size         = sizeof(PnpFilter);
        PnpFilter.dbcc_devicetype   = DBT_DEVTYP_DEVICEINTERFACE;
        PnpFilter.dbcc_classguid    = GUID_NDIS_LAN_CLASS;
        g_hDeviceChangeNotify = RegisterDeviceNotification( hWindow, &PnpFilter, DEVICE_NOTIFY_WINDOW_HANDLE);
        if(NULL != g_hDeviceChangeNotify)
        {
            InitializeCriticalSection(&g_WindowCriticalSection); // REVIEW: no memory exception
        }
    }
    return hr;
}

HRESULT ac_Unregister(HWND hWindow)
{
    if(NULL != g_hDeviceChangeNotify)
    {
        UnregisterDeviceNotification(g_hDeviceChangeNotify);
        g_hDeviceChangeNotify = NULL;
        DeleteCriticalSection(&g_WindowCriticalSection);
    }

    return S_OK;
}

DWORD WINAPI ac_AsyncDeviceChange(LPVOID lpParam)
{
    HRESULT hr;
    GUID* pDeviceGuid = reinterpret_cast<GUID*>(lpParam);
    BOOL fUninitializeCOM = TRUE;

    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED  | COINIT_DISABLE_OLE1DDE);
    if (RPC_E_CHANGED_MODE == hr)
    {
        fUninitializeCOM = FALSE;
        hr = S_OK;
    }

    if(SUCCEEDED(hr))
    {
        BOOL fPhysical;
        hr = IsAdapterPhysical(pDeviceGuid, &fPhysical);
        if(SUCCEEDED(hr) && TRUE == fPhysical)
        {
            IHNetCfgMgr* pHomenetConfigManager;
            hr = HrCreateInstance(CLSID_HNetCfgMgr, CLSCTX_INPROC, &pHomenetConfigManager);
            if(SUCCEEDED(hr))
            {
                IHNetConnection* pHomenetConnection;
                hr = pHomenetConfigManager->GetIHNetConnectionForGuid(pDeviceGuid, TRUE, TRUE, &pHomenetConnection);
                if(SUCCEEDED(hr))
                {
                    BOOLEAN fShowBalloon;
                    hr = pHomenetConnection->ShowAutoconfigBalloon(&fShowBalloon);
                    if(SUCCEEDED(hr) && fShowBalloon)
                    {
                        ac_CreateHnAcTrayUIWindow();
                    }
                    ReleaseObj(pHomenetConnection);
                }
                ReleaseObj(pHomenetConfigManager);
            }
        }

        if(TRUE == fUninitializeCOM)
        {
            CoUninitialize();
        }
    }
    CoTaskMemFree(pDeviceGuid);
    return hr;
}

HRESULT IsAdapterPhysical(GUID* pGuid, BOOL* bPhysical)
{
    // com is initialized
    HRESULT hr;
    *bPhysical = FALSE;

    INetCfg* pNetConfig;
    hr = HrCreateInstance(CLSID_CNetCfg, CLSCTX_SERVER, &pNetConfig);
    if(SUCCEEDED(hr))
    {
        INetCfgLock* pNetConfigLock;
        hr = pNetConfig->QueryInterface(&pNetConfigLock);
        if(SUCCEEDED(hr))
        {
            hr = pNetConfig->Initialize(NULL);
            if(SUCCEEDED(hr))
            {
                GUID NetDevClass = GUID_DEVCLASS_NET;
                IEnumNetCfgComponent* pNetConfigComponentEnum;
                hr = pNetConfig->EnumComponents(&NetDevClass, &pNetConfigComponentEnum);
                if (SUCCEEDED(hr))
                {
                    INetCfgComponent* pNetConfigComponent;
                    BOOL fFound = FALSE;
                    ULONG ulFetched;
                    while (FALSE == fFound && S_OK == pNetConfigComponentEnum->Next(1, &pNetConfigComponent, &ulFetched))
                    {
                        Assert(1 == ulFetched);
                        GUID DeviceGuid;
                        hr = pNetConfigComponent->GetInstanceGuid( &DeviceGuid );
                        if (SUCCEEDED(hr) && (InlineIsEqualGUID(DeviceGuid,*pGuid)))
                        {
                            fFound = TRUE;

                            DWORD dwCharacteristics;
                            hr = pNetConfigComponent->GetCharacteristics(&dwCharacteristics);
                            if(SUCCEEDED(hr))
                            {
                                if(NCF_PHYSICAL & dwCharacteristics)
                                {
                                    *bPhysical = TRUE;
                                }
                            }
                        }
                        ReleaseObj(pNetConfigComponent);
                    }
                    ReleaseObj(pNetConfigComponentEnum);
                }
                pNetConfig->Uninitialize();
            }
            ReleaseObj(pNetConfigLock);
        }
        ReleaseObj(pNetConfig);
    }
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\cfpidl.cpp ===
// ****************************************************************************
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C F P I D L . C P P
//
//  Contents:   Connections Folder structures and classes.
//
//  Author:     jeffspr   11 Nov 1997
//
// ****************************************************************************

#include "pch.h"
#pragma hdrstop

#include "ncperms.h"
#include "ncras.h"
#include "initguid.h"
#include "foldinc.h"    // Standard shell\folder includes
#include "ncnetcon.h"
#include "ncmisc.h"

extern CRITICAL_SECTION g_csPidl;
// #define STRICTDEBUGGING

BOOL fIsConnectedStatus(NETCON_STATUS ncs)
{
    switch (ncs)
    {
        case NCS_CONNECTED:
        case NCS_AUTHENTICATING:
        case NCS_AUTHENTICATION_FAILED:
        case NCS_AUTHENTICATION_SUCCEEDED:
        case NCS_CREDENTIALS_REQUIRED:
            return TRUE;
        default:
            return FALSE;
    }
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::CConFoldEntry
//
//  Purpose:    Constructor for CConFoldEntry
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   11 Nov 1997
// ****************************************************************************

CConFoldEntry::CConFoldEntry()
{
    m_bDirty = TRUE;
    TraceFileFunc(ttidConFoldEntry);

    // Need to clear out the pointers, otherwise clear() will AV
    m_pszName       = NULL;
    m_pszDeviceName = NULL;
    m_pbPersistData = NULL;
    m_pszPhoneOrHostAddress = NULL;
    
    clear();
}

CConFoldEntry::CConFoldEntry(const CConFoldEntry& ConFoldEntry)
{
    TraceFileFunc(ttidConFoldEntry);
    m_bDirty = TRUE;
    
    if (!ConFoldEntry.empty())
    {
        HRESULT hr = HrDupFolderEntry(ConFoldEntry);
        if (FAILED(hr))
        {
            clear();
        }
    }
    else
    {
        // Need to clear out the pointers, otherwise clear() will AV
        m_pszName       = NULL;
        m_pszDeviceName = NULL;
        m_pbPersistData = NULL;
        m_pszPhoneOrHostAddress = NULL;
        
        clear();
    }
}

CConFoldEntry& CConFoldEntry::operator =(const CConFoldEntry& ConFoldEntry)
{
    TraceFileFunc(ttidConFoldEntry);
    m_bDirty = TRUE;
    
    if (!ConFoldEntry.empty())
    {
        HRESULT hr = HrDupFolderEntry(ConFoldEntry);
        if (FAILED(hr))
        {
            clear();
        }
    }
    else
    {
        clear();
    }
    return *this;
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::~CConFoldEntry
//
//  Purpose:    Destructor for CConFoldEntry
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   11 Nov 1997
// ****************************************************************************

CConFoldEntry::~CConFoldEntry()
{
    TraceFileFunc(ttidConFoldEntry);
    clear();
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::SetDeviceName
//
//  Purpose:    Set the name of the device used by this connection
//
//  Arguments:
//      pszDeviceName - New device name (NULL is valid)
//
//  Returns:
//
//  Author:     scottbri   11 Nov 1999
// ****************************************************************************

HRESULT CConFoldEntry::SetDeviceName(LPCWSTR pszDeviceName)
{
    HRESULT hr      = S_OK;
    PWSTR  pszOld  = m_pszDeviceName;
    
    m_bDirty = TRUE;
    
    if (pszDeviceName)
    {
        // Only change the text is the text is actually different
        //
        if ((NULL == GetDeviceName()) ||
            wcscmp(pszDeviceName, GetDeviceName()))
        {
            hr = HrDupeShellString(pszDeviceName, &m_pszDeviceName);
        }
        else
        {
            // NOTE: In this one case, nothing change so there is
            //       nothing to free so short circut the clean-up below
            //
            pszOld = NULL;
            hr = S_OK;
        }
    }
    else
    {
        hr = HrDupeShellString(L"", &m_pszDeviceName);
    }
    
    // Free the old string
    //
    if (SUCCEEDED(hr) && pszOld)
    {
        SHFree(pszOld);
    }
    
    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::HrSetDeviceName");
    return hr;
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::SetPhoneOrHostAddress
//
//  Purpose:    Set the name of the device used by this connection
//
//  Arguments:
//      pszDeviceName - New device name (NULL is valid)
//
//  Returns:
//
//  Author:     scottbri   11 Nov 1999
// ****************************************************************************

HRESULT CConFoldEntry::SetPhoneOrHostAddress(LPCWSTR pszPhoneOrHostAddress)
{
    HRESULT hr      = S_OK;
    PWSTR  pszOld  = m_pszPhoneOrHostAddress;
    
    m_bDirty = TRUE;
    
    if (pszPhoneOrHostAddress)
    {
        // Only change the text is the text is actually different
        //
        if ((NULL == GetPhoneOrHostAddress()) ||
            wcscmp(pszPhoneOrHostAddress, GetPhoneOrHostAddress()))
        {
            hr = HrDupeShellString(pszPhoneOrHostAddress, &m_pszPhoneOrHostAddress);
        }
        else
        {
            // NOTE: In this one case, nothing change so there is
            //       nothing to free so short circut the clean-up below
            //
            pszOld = NULL;
            hr = S_OK;
        }
    }
    else
    {
        hr = HrDupeShellString(L"", &m_pszPhoneOrHostAddress);
    }
    
    // Free the old string
    //
    if (SUCCEEDED(hr) && pszOld)
    {
        SHFree(pszOld);
    }
    
    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::HrSetDeviceName");
    return hr;
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::SetName
//
//  Purpose:    Set the name of the connection
//
//  Arguments:
//      pszName - New connection name (NULL is valid)
//
//  Returns:
//
//  Author:     scottbri   11 Nov 1999
// ****************************************************************************

HRESULT CConFoldEntry::SetName(LPCWSTR pszName)
{
    HRESULT hr      = S_OK;
    PWSTR  pszOld  = m_pszName;
    
    m_bDirty = TRUE;
    
    if (pszName)
    {
        // Only change the text is the text is actually different
        //
        if ((NULL == GetName()) ||
            wcscmp(pszName, GetName()))
        {
            hr = HrDupeShellString(pszName, &m_pszName);
        }
        else
        {
            pszOld = NULL;
            hr = S_OK;
        }
    }
    else
    {
        PWSTR  pszLoad  = NULL;
        
        if (GetWizard() == WIZARD_MNC)
        {
            pszLoad = (PWSTR) SzLoadIds(IDS_CONFOLD_WIZARD_DISPLAY_NAME);
        }
        else if (GetWizard() == WIZARD_HNW)
        {
            pszLoad = (PWSTR) SzLoadIds(IDS_CONFOLD_HOMENET_WIZARD_DISPLAY_NAME);
        }
        
        //$$REVIEW: Change this to use c_szEmpty
        //
        hr = HrDupeShellString(pszLoad ? pszLoad : L"", &m_pszName);
        Assert(GetName());
    }
    
    // Free the old string
    //
    if (SUCCEEDED(hr) && pszOld)
    {
        SHFree(pszOld);
    }
    
    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::HrSetConnectionName");
    return hr;
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::HrInitData
//
//  Purpose:    Initialize the CConFoldEntry data. Not all fields are
//              required at this time, though they will most likely be
//              required at some point during the life of the object.
//
//  Arguments:
//      wizWizard           [in]  Wizard type?
//      ncm                 [in]  Connection type
//      ncs                 [in]  Connection status
//      pclsid              [in]  Pointer to CLSID of the connection
//      pguidId             [in]  Pointer to unique GUID for the connection
//      dwCharacteristics   [in]  Connection characteristics
//      pbPersistData       [in]  Persistant data for this connection
//      ulPersistSize       [in]  Size of the persist data blob
//      pszName             [in]  Name of the connection
//      pszDeviceName       [in]  Name of the connection's device
//
//  Returns:    S_OK or valid OLE return code.
//
//  Author:     jeffspr   11 Nov 1997
// ****************************************************************************
HRESULT CConFoldEntry::HrInitData(const WIZARD        wizWizard,
                                  const NETCON_MEDIATYPE    ncm,
                                  const NETCON_SUBMEDIATYPE ncsm,
                                  const NETCON_STATUS       ncs,
                                  const CLSID *       pclsid,
                                  LPCGUID             pguidId,
                                  const DWORD         dwCharacteristics,
                                  const BYTE *        pbPersistData,
                                  const ULONG         ulPersistSize,
                                  LPCWSTR             pszName,
                                  LPCWSTR             pszDeviceName,
                                  LPCWSTR             pszPhoneOrHostAddress)
{
    TraceFileFunc(ttidConFoldEntry);
    HRESULT hr  = S_OK;
    
    // Initialize the internal data
    //
    m_bDirty = TRUE;
    m_wizWizard = wizWizard;
    m_ncm = ncm;
    m_ncs = ncs;
    m_dwCharacteristics = dwCharacteristics;;

    BOOL fOldEapolStatus = ((ncsm == NCSM_CM) && (ncm == NCM_LAN)) // NCSM_CM used to be NCM_AUTHENTICATING
                         || (ncsm > NCSM_CM); // E.g. NCM_AUTHENTICATION_SUCCEEDED etc.

    if (!fOldEapolStatus)        
    {
        m_ncsm = ncsm;
    }
    else
    {
        // ISSUE: This is for the migration of EAPOL state out off our PIDL
        // This should be taken out after the no-prior-upgrades RC1 build is released.
        if (NCM_LAN == ncm)
        {
            m_ncsm = NCSM_LAN; // If all else file, we'll pretend to be a normal LAN card.

            CIntelliName inName(NULL, NULL);
            NETCON_MEDIATYPE    ncmTmp;
            NETCON_SUBMEDIATYPE ncsmTmp;

            // Try get the status from the OID or Bindings
            HRESULT hrT = inName.HrGetPseudoMediaTypes(*pguidId, &ncmTmp, &ncsmTmp);
            if (SUCCEEDED(hrT))
            {
                m_ncsm = ncsmTmp;
            }
            else
            {
                // Ok. That didn't work. Try the connections list next.
                if (g_ccl.IsInitialized())
                {
                    ConnListEntry cle;
                    hrT = g_ccl.HrFindConnectionByGuid(pguidId, cle);
                    if (S_OK == hrT)
                    {
                        m_ncsm = cle.ccfe.GetNetConSubMediaType();
                    }
                }

            }        
        }
        else
        {
            m_ncsm = NCSM_NONE;
        }
    }

    if (pclsid)
    {
        m_clsid = *pclsid;
    }
    else
    {
        AssertSz(wizWizard != WIZARD_NOT_WIZARD, "If you're not a wizard, you must give me a CLSID for the class!");
    }
    
    if (pguidId)
    {
        m_guidId = *pguidId;
    }

    AssertSz(pguidId, "You must give me a GUID for the object!");
    
    // Copy the persist buffer
    //
    if (pbPersistData)
    {
        LPBYTE bufTemp = (BYTE *) SHAlloc(ulPersistSize);
        if (!bufTemp)
        {
            SetPersistData(NULL, 0);
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        
        CopyMemory(bufTemp, pbPersistData, ulPersistSize);
        SetPersistData(bufTemp, ulPersistSize);
    }
    else
    {
        AssertSz(wizWizard != WIZARD_NOT_WIZARD, "If you're not a wizard, you must give me a pbPersistData for the object!");
        SetPersistData(NULL, 0);
    }

    // Copy the device name
    //
    hr = SetDeviceName(pszDeviceName);
    
    if (SUCCEEDED(hr))
    {
        // Copy the name
        //
        hr = SetName(pszName);
        
        if (SUCCEEDED(hr))
        {
            hr = SetPhoneOrHostAddress(pszPhoneOrHostAddress);
        }
    }
    

Exit:
    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::HrInitData");
    return hr;
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::UpdateData
//
//  Purpose:    Modify the values in a CConFoldEntry
//
//  Arguments:
//            DWORD            dwChangeFlags
//            NETCON_MEDIATYPE MediaType
//            NETCON_STATUS    Status
//            DWORD            dwCharacteristics
//            PWSTR            pszName
//            PWSTR            pszDeviceName
//
//  Returns:    HRESULT
//
//  Author:     scottbri   10 Nov 1998
// ****************************************************************************

HRESULT CConFoldEntry::UpdateData( const DWORD dwChangeFlags,
  const NETCON_MEDIATYPE MediaType,
  const NETCON_SUBMEDIATYPE SubMediaType,
  const NETCON_STATUS Status,
  const DWORD dwCharacteristics,
  PCWSTR pszName,
  PCWSTR pszDeviceName,
  PCWSTR pszPhoneOrHostAddress)
{
    TraceFileFunc(ttidConFoldEntry);
    HRESULT hr = S_OK;
    HRESULT hrTmp;
    
    m_bDirty = TRUE;
    
    if (dwChangeFlags & CCFE_CHANGE_MEDIATYPE)
    {
        SetNetConMediaType(MediaType);
    }
            
    if (dwChangeFlags & CCFE_CHANGE_SUBMEDIATYPE)
    {
        SetNetConSubMediaType(SubMediaType);
    }
    
    if (dwChangeFlags & CCFE_CHANGE_STATUS)
    {
        SetNetConStatus(Status);
    }
    
    if (dwChangeFlags & CCFE_CHANGE_CHARACTERISTICS)
    {
        SetCharacteristics(dwCharacteristics);
    }

    if (dwChangeFlags & CCFE_CHANGE_NAME)
    {
        hrTmp = SetName(pszName);
        if (FAILED(hrTmp))
        {
            hr = hrTmp;
        }
    }
    
    if (dwChangeFlags & CCFE_CHANGE_DEVICENAME)
    {
        hrTmp = SetDeviceName(pszDeviceName);
        if (FAILED(hrTmp))
        {
            hr = hrTmp;
        }
    }
    
    if (dwChangeFlags & CCFE_CHANGE_PHONEORHOSTADDRESS)
    {
        hrTmp = SetPhoneOrHostAddress(pszPhoneOrHostAddress);
        if (FAILED(hrTmp))
        {
            hr = hrTmp;
        }
    }
    
    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::UpdateData");
    return hr;
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::HrDupFolderEntry
//
//  Purpose:    Duplicate a connection folder entry.
//
//  Arguments:
//      pccfe       The source folder entry to dup from
//
//  Returns:
//
//  Author:     tongl   9/3/98
// ****************************************************************************

HRESULT CConFoldEntry::HrDupFolderEntry(const CConFoldEntry& ccfe)
{
    TraceFileFunc(ttidConFoldEntry);
    m_bDirty = TRUE;
    
    Assert(!ccfe.empty());
    
    clear();
    
    return HrInitData( ccfe.GetWizard(),
        ccfe.GetNetConMediaType(),
        ccfe.GetNetConSubMediaType(),
        ccfe.GetNetConStatus(),
        &(ccfe.GetCLSID()),
        &(ccfe.GetGuidID()),
        ccfe.GetCharacteristics(),
        ccfe.GetPersistData(),
        ccfe.GetPersistSize(),
        ccfe.GetName(),
        ccfe.GetDeviceName(),
        ccfe.GetPhoneOrHostAddress());
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::FShouldHaveTrayIconDisplayed
//
//  Purpose:    Return TRUE if this entry should have a tray icon displayed.
//
//  Arguments:
//      (none)
//
//  Returns:    TRUE or FALSE.
//
//  Author:     shaunco   2 Nov 1998
// ****************************************************************************

BOOL CConFoldEntry::FShouldHaveTrayIconDisplayed() const
{
    // If we're either MEDIA_DISCONNECTED (lan) or
    // we're connected and have the correct bits turned on
    // then we should display the icon
    //
    return ( !IsConnected() ||
        (fIsConnectedStatus(GetNetConStatus()) &&
        (GetCharacteristics() & NCCF_SHOW_ICON) &&
        !GetWizard() && FHasPermission(NCPERM_Statistics)));
}

// ****************************************************************************
//  Function:   

//
//  Purpose:    Translate from a pidl to a CConFoldEntry class object
//
//  Arguments:
//      pidl   [in]     PIDL from which to create
//      ppccfe [out]    Resultant CConFoldEntry object pointer
//
//  Returns:
//
//  Author:     jeffspr   11 Nov 1997
// ****************************************************************************


// ****************************************************************************
//
//  Function:   HrCreateConFoldPidlInternal
//
//  Purpose:    Utility function for creating new Connections Folder PIDLs.
//              This function is primarily called from HrCreateConFoldPidl,
//              but can also be called directly by those that have already
//              loaded the properties and persist data.
//
//  Arguments:
//      pProps    [in]  From GetProperties
//      pbBuf     [in]  The persist buffer
//      ulBufSize [in]  Size of the persist buffer
//      ppidl     [out] Return pointer for the resultant pidl
//
//  Returns:
//
//  Author:     jeffspr   27 Aug 1998
// ****************************************************************************

HRESULT HrCreateConFoldPidlInternal(IN  const NETCON_PROPERTIES * pProps,
                                    IN  const BYTE *        pbBuf,
                                    IN  ULONG               ulBufSize,
                                    IN  LPCWSTR             szPhoneOrHostAddress,
                                    OUT PCONFOLDPIDL &      pidl)
{
    HRESULT         hr      = S_OK;
    CONFOLDENTRY    ccfe;
    
    // Trace the useful info
    //
    TraceTag(ttidShellFolder, "Enum: %S, Ncm: %d, Ncs: %d, Char: 0x%08x "
        "(Show: %d, Del: %d, All: %d), Dev: %S",
        (pProps->pszwName) ? pProps->pszwName : L"null",
        pProps->MediaType, pProps->Status, pProps->dwCharacter,
        ((pProps->dwCharacter & NCCF_SHOW_ICON) > 0),
        ((pProps->dwCharacter & NCCF_ALLOW_REMOVAL) > 0),
        ((pProps->dwCharacter & NCCF_ALL_USERS) > 0),
        (pProps->pszwDeviceName) ? pProps->pszwDeviceName : L"null");
    
    // Init the CConFoldEntry from the data that we've retrieved.
    //
    hr = ccfe.HrInitData(WIZARD_NOT_WIZARD,
        pProps->MediaType, 
        NCSM_NONE,
        pProps->Status,
        &pProps->clsidThisObject,
        &pProps->guidId,
        pProps->dwCharacter, 
        pbBuf,
        ulBufSize, 
        pProps->pszwName, 
        pProps->pszwDeviceName,
        szPhoneOrHostAddress);
    if (FAILED(hr))
    {
        TraceHr(ttidShellFolder, FAL, hr, FALSE, "ccfe.HrInitData failed for "
            "non-wizard");
        goto Exit;
    }
    
    // Translate into the actual pidl
    //
    hr = ccfe.ConvertToPidl(pidl);
    if (FAILED(hr))
    {
        TraceHr(ttidShellFolder, FAL, hr, FALSE, "ConvertToPidl failed for non-wizard");
    }
    
Exit:
    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateConFoldPidlInternal");
    return hr;
}

// ****************************************************************************
//
//  Function:   HrCreateConFoldPidl
//
//  Purpose:    Utility function for creating new Connections Folder PIDLs.
//
//  Arguments:
//      wizWizard   [in]    Is this PIDL for a wizard?
//      pNetCon     [in]    INetConnection interface from the enumerator
//      pPersist    [in]    IPersist interface QI'd from the pNetCon
//      ppidl       [out]   Return pointer for the new pidl
//
//  Returns:    S_OK or valid OLE return code.
//
//  Author:     jeffspr   6 Oct 1997
//
//  Notes:  If the connection that you're adding is a real connection object
//          (not the wizard) and you already have loaded the persist data and
//          properties, you should call HrCreateConFoldPidlInternal directly
// ****************************************************************************

HRESULT HrCreateConFoldPidl(IN  const WIZARD      wizWizard,
                            IN  INetConnection *  pNetCon,
                            OUT PCONFOLDPIDL &    ppidl)
{
    HRESULT             hr              = S_OK;
    LPBYTE              pbBuf           = NULL;
    ULONG               ulBufSize       = 0;
    NETCON_PROPERTIES * pProps          = NULL;
    CConFoldEntry       ccfe;
    
    if (wizWizard == WIZARD_NOT_WIZARD)
    {
        Assert(pNetCon);
        
        hr = pNetCon->GetProperties (&pProps);
        if (FAILED(hr))
        {
            TraceHr(ttidShellFolder, FAL, hr, FALSE, "pNetCon->GetProperties failed in "
                "CConnectionFolderEnum::HrCreateConFoldPidl");
            goto Exit;
        }
        Assert (pProps);
        
        // Get the persist data from the connection
        //
        hr = HrGetConnectionPersistData(pNetCon, &pbBuf, &ulBufSize, NULL);
        if (FAILED(hr))
        {
            TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrGetConnectionPersistData failed in "
                "CConnectionFolderEnum::HrCreateConFoldPidl");
            goto Exit;
        }

        WCHAR szPhoneOrHostAddress[MAX_PATH];
        wcscpy(szPhoneOrHostAddress, L" ");
        
        if ( (NCM_TUNNEL == pProps->MediaType) || (NCM_PHONE == pProps->MediaType) )
        {
            HRESULT hrTmp;
            RASCON_INFO RasConInfo;
            if (SUCCEEDED(hr))
            {
                
                hrTmp = HrRciGetRasConnectionInfo(pNetCon, &RasConInfo);
                if (SUCCEEDED(hrTmp))
                {
                    GetPrivateProfileString(RasConInfo.pszwEntryName, L"PhoneNumber",
                        L" ", szPhoneOrHostAddress, MAX_PATH, 
                        RasConInfo.pszwPbkFile);
                    
                    RciFree(&RasConInfo);
                }
            }
        }

        // Call the pre-read-data version of this function to actually pack the
        // ccfe and insert.
        //
        hr = HrCreateConFoldPidlInternal(pProps, pbBuf, ulBufSize, szPhoneOrHostAddress, ppidl);
        if (FAILED(hr))
        {
            goto Exit;
        }
        
    }
    else
    {
        GUID guidWiz;
        if (wizWizard == WIZARD_MNC)
        {
            guidWiz = GUID_MNC_WIZARD;
        }
        else
        {
            guidWiz = GUID_HNW_WIZARD;
            Assert(wizWizard == WIZARD_HNW);
        }

        // Pack the CConFoldEntry data from the retrieved info
        //
        hr = ccfe.HrInitData(wizWizard, NCM_NONE, NCSM_NONE, NCS_DISCONNECTED, 
            NULL, &guidWiz, 0, NULL, 0, NULL, NULL, NULL);
        if (FAILED(hr))
        {
            TraceHr(ttidShellFolder, FAL, hr, FALSE, "ccfe.HrInitData failed for "
                "Wizard");
            goto Exit;
        }
        
        // Translate into an actual pidl
        //
        hr = ccfe.ConvertToPidl(ppidl);
        if (FAILED(hr))
        {
            TraceHr(ttidShellFolder, FAL, hr, FALSE, "ConvertToPidl failed for wizard");
        }
    }
    
Exit:
    MemFree(pbBuf);
    FreeNetconProperties(pProps);
    
    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateConFoldPidl");
    return hr;
}


// ****************************************************************************
//
//  Function:   HrCreateConFoldPidl
//
//  Purpose:    Utility function for creating new Connections Folder PIDLs.
//
//  Arguments:
//      wizWizard   [in]    Is this PIDL for a wizard?
//      PropsEx     [in]    PropsEx structure
//      ppidl       [out]   Return pointer for the new pidl
//
//  Returns:    S_OK or valid OLE return code.
//
//  Author:     deonb   26 Mar 2001
//
//  Notes:  
// ****************************************************************************

HRESULT HrCreateConFoldPidl(IN  const NETCON_PROPERTIES_EX& PropsEx,
                            OUT PCONFOLDPIDL &    ppidl)
{
    HRESULT             hr              = S_OK;
    NETCON_PROPERTIES * pProps          = NULL;
    CConFoldEntry       ccfe;


    // Trace the useful info
    //
    TraceTag(ttidShellFolder, "Enum: %S, Ncm: %d, Ncs: %d, Char: 0x%08x "
        "(Show: %d, Del: %d, All: %d), Dev: %S",
        (PropsEx.bstrName) ? PropsEx.bstrName : L"null",
        PropsEx.ncMediaType, 
        PropsEx.ncStatus, 
        PropsEx.dwCharacter,
        ((PropsEx.dwCharacter & NCCF_SHOW_ICON) > 0),
        ((PropsEx.dwCharacter & NCCF_ALLOW_REMOVAL) > 0),
        ((PropsEx.dwCharacter & NCCF_ALL_USERS) > 0),
        (PropsEx.bstrDeviceName) ? PropsEx.bstrDeviceName : L"null");

    // Init the CConFoldEntry from the data that we've retrieved.
    //
    hr = ccfe.HrInitData(WIZARD_NOT_WIZARD,
        PropsEx.ncMediaType, 
        PropsEx.ncSubMediaType,
        PropsEx.ncStatus,
        &PropsEx.clsidThisObject,
        &PropsEx.guidId,
        PropsEx.dwCharacter, 
        reinterpret_cast<const BYTE*>(PropsEx.bstrPersistData),
        SysStringByteLen(PropsEx.bstrPersistData),
        PropsEx.bstrName, 
        PropsEx.bstrDeviceName,
        PropsEx.bstrPhoneOrHostAddress);

    if (SUCCEEDED(hr))
    {
        // Translate into the actual pidl
        //
        hr = ccfe.ConvertToPidl(ppidl);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrCreateConFoldPidl");
    return hr;
}

// ****************************************************************************
//
//  Function:   ConvertToPidlInCache
//
//  Purpose:    Determine whether a particular PIDL is in a format we support.
//              If so but it is not in the CONFOLDPIDL format, then find a match
//              in our cache and allocate a new pisl
//
//  Arguments:
//      pidl []     PIDL to test
//      ppcfpRet    PIDL converted to PCONFOLDPIDL, if required and it
//                  matches an existing connection in the cache
//
//  Returns:    NONE
//
//  Author:     tongl, 4 April, 1999
// ****************************************************************************

// ****************************************************************************
//
//  Function:   HrNetConFromPidl
//
//  Purpose:    Translate from a packed PIDL to a INetConnection pointer.
//              Do this by converting to a ConFoldEntry and getting the
//              pointer from there
//
//  Arguments:
//      pidl        [in]    Pidl that contains the connection persist data
//      ppNetCon    [out]   INetConnection * return
                            //
                            //  Returns:
//
//  Author:     jeffspr   11 Nov 1997
// ****************************************************************************

HRESULT HrNetConFromPidl( const PCONFOLDPIDL & pidl,
                         INetConnection **   ppNetCon)
{
    HRESULT       hr      = S_OK;
    CONFOLDENTRY  pccfe;
    
    Assert(ppNetCon);
    
    hr = pidl.ConvertToConFoldEntry(pccfe);
    if (SUCCEEDED(hr))
    {
        Assert(!pccfe.empty());
        
        hr = pccfe.HrGetNetCon(IID_INetConnection, 
            reinterpret_cast<VOID**>(ppNetCon));
    }
    
    // Free the CConFoldEntry class, if successfully created
    //
    
    TraceHr(ttidError, FAL, hr, FALSE, "HrNetConFromPidl");
    return hr;
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::HrGetNetCon
//
//  Purpose:    Get the INetConnection pointer from the persisted data
//
//  Arguments:
//      ppNetCon []     Return pointer for the INetConnection
//
//  Returns:
//
//  Author:     jeffspr   11 Nov 1997
// ****************************************************************************

HRESULT CConFoldEntry::HrGetNetCon( IN REFIID riid,
                                   IN VOID** ppv) const
{
    HRESULT hr = HrGetConnectionFromPersistData( GetCLSID(),
        GetPersistData(),
        GetPersistSize(),
        riid,
        ppv);
    
    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::HrGetNetCon");
    return hr;
}

// ****************************************************************************

HRESULT PConfoldPidlVecFromItemIdListArray(LPCITEMIDLIST * apidl, DWORD dwPidlCount, PCONFOLDPIDLVEC& vecConfoldPidl)
{
    HRESULT hr = S_OK;
    if (NULL == apidl)
    {
        return S_FALSE;
    }
    
    LPCITEMIDLIST   *tmpIdList = apidl;
    for (DWORD i = 0; i < dwPidlCount; i++)
    {
        PCONFOLDPIDL newPidl;
        hr = newPidl.InitializeFromItemIDList(*tmpIdList);
        if (SUCCEEDED(hr))
        {
            vecConfoldPidl.push_back(newPidl);
        }
        else
        {
            break;
        }
        
        tmpIdList++;
    }
    
    return hr;
}

#ifdef DBG_VALIDATE_PIDLS
inline BOOL IsValidPIDL(LPCITEMIDLIST pidl)
{
    CExceptionSafeLock esLock(&g_csPidl);
    if (NULL == pidl)
    {
        return TRUE;
    }
    
    if (IsBadReadPtr(pidl, sizeof(USHORT)))
    {
        AssertSz(FALSE, "invalid read pointer");
        return FALSE;
    }
    else
    {
        if (IsBadReadPtr(pidl, pidl->mkid.cb) )
        {
            AssertSz(FALSE, "invalid read buffer");
            return FALSE;
        }
        else
        {
            if (0 == _ILNext(pidl)->mkid.cb || IsValidPIDL(_ILNext(pidl)) )
            {
                return TRUE;
            }
            else
            {
                // Don't need to assert since called IsValidPidl would have asserted already
                return FALSE;
            }
        }
    }
    return FALSE;
}
#endif

BOOL ConFoldPidl_v1::IsPidlOfThisType() const
{
    if ( GetPidlType(reinterpret_cast<LPCITEMIDLIST>(this)) == PIDL_TYPE_V1 )
    {
#if defined( DBG ) && defined ( STRICTDEBUGGING )
        DWORD dwDataOffset = bData - reinterpret_cast<const BYTE *>(this); // Get bData offset;

        DWORD dwPidlSize;
        dwPidlSize = dwDataOffset;
        dwPidlSize += ulPersistBufSize;
        dwPidlSize += ulStrNameSize;
        dwPidlSize += ulStrDeviceNameSize;
        dwPidlSize += sizeof(USHORT); // Terminating
    
        AssertSz(dwPidlSize <= iCB, "Self-inconsistend PIDL"); // Sometimes V1 PIDLs are shorter - hence not == a check.
        AssertSz(ulPersistBufPos + ulPersistBufSize < iCB, "Self-inconsistend PIDL");
        AssertSz(ulStrDeviceNamePos  + ulStrDeviceNameSize < iCB, "Self-inconsistend PIDL");
        AssertSz(ulStrNamePos + ulStrNameSize < iCB, "Self-inconsistend PIDL");

        AssertSz(ulStrNamePos == 0, "Name doesn't start at 0");
        AssertSz(ulStrDeviceNamePos == ulStrNameSize, "Device name misaligned");
        AssertSz(ulPersistBufPos == ulStrDeviceNamePos + ulStrDeviceNameSize, "Persisted buffer misaligned");
        AssertSz(dwDataOffset + ulPersistBufPos + ulPersistBufSize <= iCB, "Persisted buffer larger than PIDL");
#endif
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL ConFoldPidl_v2::IsPidlOfThisType() const
{
    if ( GetPidlType(reinterpret_cast<LPCITEMIDLIST>(this)) == PIDL_TYPE_V2 )
    {
#if defined( DBG ) && defined ( STRICTDEBUGGING )
        DWORD dwDataOffset = bData - reinterpret_cast<const BYTE *>(this); // Get bData offset;
        
        DWORD dwPidlSize;
        dwPidlSize = dwDataOffset;
        dwPidlSize += ulPersistBufSize;
        dwPidlSize += ulStrNameSize;
        dwPidlSize += ulStrDeviceNameSize;
        dwPidlSize += ulStrPhoneOrHostAddressSize;
        dwPidlSize += sizeof(USHORT); // Terminating 0
        
        AssertSz(dwPidlSize <= iCB, "Self-inconsistend PIDL"); // Sometimes V1 PIDLs are shorter - hence not == a check.
        AssertSz(ulPersistBufPos + ulPersistBufSize < iCB, "Self-inconsistend PIDL");
        AssertSz(ulStrDeviceNamePos  + ulStrDeviceNameSize < iCB, "Self-inconsistend PIDL");
        AssertSz(ulStrNamePos + ulStrNameSize < iCB, "Self-inconsistend PIDL");
        AssertSz(ulStrPhoneOrHostAddressPos + ulStrPhoneOrHostAddressSize < iCB, "Self-inconsistend PIDL");
        
        AssertSz(ulStrNamePos == 0, "Name doesn't start at 0");
        AssertSz(ulStrDeviceNamePos == ulStrNameSize, "Device name misaligned");
        AssertSz(ulPersistBufPos == ulStrDeviceNamePos + ulStrDeviceNameSize, "Persisted buffer misaligned");
        AssertSz(ulStrPhoneOrHostAddressPos == ulPersistBufPos + ulPersistBufSize, "Phone/Host address misaligned");
        AssertSz(dwDataOffset + ulPersistBufPos + ulPersistBufSize <= iCB, "Buffer larger than PIDL");

#endif
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL ConFoldPidlFolder::IsPidlOfThisType() const
{
    // We can't tell if it's a PIDL_TYPE_FOLDER - this is shell internal
    if ( GetPidlType(reinterpret_cast<LPCITEMIDLIST>(this)) == PIDL_TYPE_UNKNOWN ) 
    {
#ifdef DBG
        if ( (dwLength != 0x14) || (dwId != 0x1f) )
        {
            return FALSE;
        }
#endif
        return TRUE;
    }
    else
    {
        return FALSE; 
    }
}

BOOL ConFoldPidl98::IsPidlOfThisType(BOOL * pfIsWizard) const
{
    if ( GetPidlType(reinterpret_cast<LPCITEMIDLIST>(this)) == PIDL_TYPE_98 )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

const DWORD CConFoldEntry::GetCharacteristics() const
{
    return m_dwCharacteristics;
}

HRESULT CConFoldEntry::SetCharacteristics(const DWORD dwCharacteristics)
{
    m_bDirty = TRUE;
    m_dwCharacteristics = dwCharacteristics;
    return S_OK;
}

const GUID CConFoldEntry::GetGuidID() const
{
    return m_guidId;
}

HRESULT CConFoldEntry::SetGuidID(const GUID guidId)
{
    m_bDirty = TRUE;
    m_guidId = guidId;
    return S_OK;
}

const CLSID CConFoldEntry::GetCLSID() const
{
    return m_clsid;
}

HRESULT CConFoldEntry::SetCLSID(const CLSID clsid)
{
    m_bDirty = TRUE;
    m_clsid = clsid;
    return S_OK;
}

PCWSTR CConFoldEntry::GetName() const
{
    return m_pszName;
}

HRESULT CConFoldEntry::SetPName(IN TAKEOWNERSHIP SHALLOCATED PWSTR pszName)
{
    m_bDirty = TRUE;
    m_pszName = pszName;
    return S_OK;
}

PCWSTR CConFoldEntry::GetDeviceName() const
{
    return m_pszDeviceName;
}

HRESULT CConFoldEntry::SetPDeviceName(IN TAKEOWNERSHIP SHALLOCATED PWSTR pszDeviceName)
{
    m_bDirty = TRUE;
    m_pszDeviceName = pszDeviceName;
    return S_OK;
}

PCWSTR CConFoldEntry::GetPhoneOrHostAddress() const
{
    return m_pszPhoneOrHostAddress;
}

HRESULT CConFoldEntry::SetPPhoneOrHostAddress(IN TAKEOWNERSHIP SHALLOCATED PWSTR pszPhoneOrHostAddress)
{
    m_bDirty = TRUE;
    m_pszPhoneOrHostAddress = pszPhoneOrHostAddress;
    return S_OK;
}

const NETCON_STATUS CConFoldEntry::GetNetConStatus() const
{
    return m_ncs;
}

const BOOL CConFoldEntry::IsConnected() const
{
    return (m_ncs != NCS_MEDIA_DISCONNECTED) && (m_ncs != NCS_INVALID_ADDRESS);
}

HRESULT CConFoldEntry::SetNetConStatus(const NETCON_STATUS ncs)
{
    m_bDirty = TRUE;
    m_ncs = ncs;
    return S_OK;
}

const NETCON_MEDIATYPE CConFoldEntry::GetNetConMediaType() const
{
    return m_ncm;
}

HRESULT CConFoldEntry::SetNetConMediaType(const NETCON_MEDIATYPE ncm)
{
    m_bDirty = TRUE;
    m_ncm = ncm;
    return S_OK;
}

const NETCON_SUBMEDIATYPE CConFoldEntry::GetNetConSubMediaType() const
{
    return m_ncsm;
}

HRESULT CConFoldEntry::SetNetConSubMediaType(const NETCON_SUBMEDIATYPE ncsm)
{
    m_bDirty = TRUE;
    m_ncsm = ncsm;
    return S_OK;
}


const WIZARD CConFoldEntry::GetWizard() const
{
    return m_wizWizard;
}

HRESULT CConFoldEntry::SetWizard(const WIZARD  wizWizard)
{
    m_bDirty = TRUE;
    m_wizWizard = wizWizard;
    return S_OK;
}

const BYTE * CConFoldEntry::GetPersistData() const
{
    return m_pbPersistData;
}

const ULONG  CConFoldEntry::GetPersistSize() const
{
    return m_ulPersistSize;
}

HRESULT CConFoldEntry::SetPersistData(BYTE * pbPersistData, const ULONG ulPersistSize)
{
    m_bDirty = TRUE;
    m_pbPersistData = pbPersistData;
    m_ulPersistSize = ulPersistSize;
    return S_OK;
}

BOOL CConFoldEntry::empty() const
{
    if (GetWizard())
    {
        return FALSE;
    }
    else
    {
        if (IsEqualGUID(GetCLSID(), GUID_NULL) )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
}

void CConFoldEntry::clear()
{
    TraceFileFunc(ttidConFoldEntry);
    m_bDirty = TRUE;
    
    if (GetName())
    {
        SHFree(m_pszName);
        m_pszName = NULL;
    }
    
    if (GetDeviceName())
    {
        SHFree(m_pszDeviceName);
        m_pszDeviceName = NULL;
    }
    
    if (GetPhoneOrHostAddress())
    {
        SHFree(m_pszPhoneOrHostAddress);
        m_pszPhoneOrHostAddress = NULL;
    }
    
    if (GetPersistData())
    {
        SHFree(m_pbPersistData);
        m_pbPersistData = NULL;
        m_ulPersistSize = 0;
    }
    
    m_wizWizard = WIZARD_NOT_WIZARD;
    m_ncm = NCM_NONE;
    m_ncsm= NCSM_NONE;
    m_ncs = NCS_DISCONNECTED;
    m_dwCharacteristics = 0;
    m_clsid = GUID_NULL;
    m_guidId = GUID_NULL;
}

LPITEMIDLIST CConFoldEntry::TearOffItemIdList() const
{
    PCONFOLDPIDL pidl;
    
    m_bDirty = TRUE;
    
    ConvertToPidl(pidl);
    return pidl.TearOffItemIdList();
}

HRESULT CConFoldEntry::InitializeFromItemIdList(LPCITEMIDLIST lpItemIdList)
{
    PCONFOLDPIDL pidl;
    HRESULT hr = S_OK;
    
    m_bDirty = TRUE;
    
    hr = pidl.InitializeFromItemIDList(lpItemIdList);
    if (FAILED(hr))
    {
        return hr;
    }
    
    hr = pidl.ConvertToConFoldEntry(*this);
    return hr;
}

HRESULT CConFoldEntry::ConvertToPidl( OUT CPConFoldPidl<ConFoldPidl_v1>& pidl) const
{
    TraceFileFunc(ttidConFoldEntry);
    
    HRESULT         hr                  = S_OK;
    DWORD           dwNameSize          = 0;
    DWORD           dwDeviceNameSize    = 0;
    DWORD           dwPidlSize          = sizeof(ConFoldPidl_v1); // Initialize the PIDL byte count with the base size
    
    Assert(!empty());
    Assert(GetName());
    Assert(GetDeviceName());

    NETCFG_TRY

        if (m_bDirty)
        {
            // Get the size of the name, and tack on a trailing NULL (since we now
            // have something else in the buffer behind it.
            //
            dwNameSize                  = lstrlenW(GetName()) + 1;
            dwDeviceNameSize            = lstrlenW(GetDeviceName()) + 1;

            // Add the size of the string to the PIDL struct size. We don't need to include
            // an extra byte for the string's terminating NULL because we've already
            // included a WCHAR[1] in the struct.
            //
            dwPidlSize += ((dwNameSize) * sizeof(WCHAR));
            dwPidlSize += ((dwDeviceNameSize) * sizeof(WCHAR));
            
            // Tack of the length of the persist buffer
            //
            dwPidlSize += GetPersistSize();
            
            // Allocate the PIDL.
            //
            hr = pidl.ILCreate(dwPidlSize + sizeof(USHORT));   // Terminating 0 for the PIDL
            if (SUCCEEDED(hr))
            {
                PWSTR          pszName         = NULL;
                PWSTR          pszDeviceName   = NULL;
                PWSTR          pszPhoneOrHostAddress = NULL;
                
                // Fill in the pidl info.
                //
                pidl->wizWizard         = GetWizard();
                pidl->iCB               = dwPidlSize;
                //            pidl->dwVersion         = CONNECTIONS_FOLDER_IDL_VERSION_V1;
                pidl->ncm               = GetNetConMediaType();
                pidl->ncs               = GetNetConStatus();
                pidl->uLeadId           = CONFOLDPIDL_LEADID;
                pidl->uTrailId          = CONFOLDPIDL_TRAILID;
                pidl->clsid             = GetCLSID();
                pidl->guidId            = GetGuidID();
                pidl->dwCharacteristics = GetCharacteristics();
                
                // Fill in the name
                //
                pidl->ulStrNamePos = 0;             // offset into the PIDL's pbBuf
                pidl->ulStrNameSize = dwNameSize * sizeof(WCHAR);   // in bytes
                
                pszName = pidl->PszGetNamePointer();
                lstrcpyW(pszName, GetName());
                pszName[dwNameSize] = 0;
                
                // Fill in the device name, and set the offset info
                //
                pidl->ulStrDeviceNamePos = pidl->ulStrNamePos + pidl->ulStrNameSize;
                pidl->ulStrDeviceNameSize = dwDeviceNameSize * sizeof(WCHAR);   // in bytes
                pszDeviceName = pidl->PszGetDeviceNamePointer();
                lstrcpyW(pszDeviceName, GetDeviceName());
                pszDeviceName[dwDeviceNameSize] = 0;
                
                // Set the offset into the PIDL's pbBuf
                //
                pidl->ulPersistBufPos = pidl->ulStrDeviceNamePos + pidl->ulStrDeviceNameSize;
                
                // Fill in the persist buffer, if present (it won't be on a wizard)
                //
                if (GetPersistData())
                {
                    pidl->ulPersistBufSize = GetPersistSize();
                    CopyMemory(pidl->bData + pidl->ulPersistBufPos, GetPersistData(), GetPersistSize());
                }
                else
                {
                    // Since we're the wizard, there shouldn't be a buffer, so the size
                    // should always be passed in as 0.
                    //
                    Assert(GetPersistSize() == 0);
                    pidl->ulPersistBufSize = 0;
                }

                // Don't forget to terminate the list!
                //
                LPITEMIDLIST pidlTerminate;
                pidlTerminate = ILNext( pidl.GetItemIdList() );
                pidlTerminate->mkid.cb = 0;
            }
            else
            {
                AssertSz(FALSE, "CConFoldEntry::ConvertToPidl is hosed");
                hr = E_OUTOFMEMORY;
            }
            
#ifdef DBG_VALIDATE_PIDLS
            Assert(IsValidPIDL( pidl.GetItemIdList() ));
#endif
            Assert( pidl->IsPidlOfThisType() ) ;
            
            if (SUCCEEDED(hr))
            {
                m_bDirty = FALSE;
                m_CachedV1Pidl = pidl;
            }
        }
        else
        {
            TraceTag(ttidShellFolder, "Using internally cached PIDL");
            pidl = m_CachedV1Pidl;
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::ConvertToPidl");
    return hr;
}

HRESULT CConFoldEntry::ConvertToPidl( OUT CPConFoldPidl<ConFoldPidl_v2>& pidl) const
{
    TraceFileFunc(ttidConFoldEntry);
    
    HRESULT         hr                  = S_OK;
    DWORD           dwNameSize          = 0;
    DWORD           dwDeviceNameSize    = 0;
    DWORD           dwPhoneOrHostAddressSize  = 0;
    DWORD           dwPidlSize          = sizeof(ConFoldPidl_v2); // Initialize the PIDL byte count with the base size
    
    Assert(!empty());
    Assert(GetName());
    Assert(GetDeviceName());
    Assert(GetPhoneOrHostAddress());

    NETCFG_TRY
        
        if (m_bDirty)
        {
            // Get the size of the name, and tack on a trailing NULL (since we now
            // have something else in the buffer behind it.
            //
            dwNameSize                  = lstrlenW(GetName()) + 1;
            dwDeviceNameSize            = lstrlenW(GetDeviceName()) + 1;
            dwPhoneOrHostAddressSize    = lstrlenW(GetPhoneOrHostAddress()) + 1;
            
            // Add the size of the string to the PIDL struct size. We don't need to include
            // an extra byte for the string's terminating NULL because we've already
            // included a WCHAR[1] in the struct.
            //
            dwPidlSize += ((dwNameSize) * sizeof(WCHAR));
            dwPidlSize += ((dwDeviceNameSize) * sizeof(WCHAR));
            dwPidlSize += ((dwPhoneOrHostAddressSize) * sizeof(WCHAR));
            
            // Tack of the length of the persist buffer
            //
            dwPidlSize += GetPersistSize();
            
            // Allocate the PIDL.
            //
            hr = pidl.ILCreate(dwPidlSize + sizeof(USHORT));   // Terminating 0 for the PIDL
            if (SUCCEEDED(hr))
            {
                PWSTR          pszName         = NULL;
                PWSTR          pszDeviceName   = NULL;
                PWSTR          pszPhoneOrHostAddress = NULL;
                
                // Fill in the pidl info.
                //
                pidl->wizWizard         = GetWizard();
                pidl->iCB               = dwPidlSize;
                //            pidl->dwVersion         = CONNECTIONS_FOLDER_IDL_VERSION_V1;
                pidl->ncm               = GetNetConMediaType();
                pidl->ncs               = GetNetConStatus();
                pidl->ncsm              = GetNetConSubMediaType();
                pidl->uLeadId           = CONFOLDPIDL_LEADID;
                pidl->uTrailId          = CONFOLDPIDL_TRAILID;
                pidl->clsid             = GetCLSID();
                pidl->guidId            = GetGuidID();
                pidl->dwCharacteristics = GetCharacteristics();
                
                // Fill in the name
                //
                pidl->ulStrNamePos = 0;             // offset into the PIDL's pbBuf
                pidl->ulStrNameSize = dwNameSize * sizeof(WCHAR);   // in bytes
                
                pszName = pidl->PszGetNamePointer();
                lstrcpyW(pszName, GetName());
                pszName[dwNameSize] = 0;
                
                // Fill in the device name, and set the offset info
                //
                pidl->ulStrDeviceNamePos = pidl->ulStrNamePos + pidl->ulStrNameSize;
                pidl->ulStrDeviceNameSize = dwDeviceNameSize * sizeof(WCHAR);   // in bytes
                pszDeviceName = pidl->PszGetDeviceNamePointer();
                lstrcpyW(pszDeviceName, GetDeviceName());
                pszDeviceName[dwDeviceNameSize] = 0;

                // Set the offset into the PIDL's pbBuf
                //
                pidl->ulPersistBufPos = pidl->ulStrDeviceNamePos + pidl->ulStrDeviceNameSize;

                // Fill in the persist buffer, if present (it won't be on a wizard)
                //
                if (GetPersistData())
                {
                    pidl->ulPersistBufSize = GetPersistSize();
                    CopyMemory(pidl->bData + pidl->ulPersistBufPos, GetPersistData(), GetPersistSize());
                }
                else
                {
                    // Since we're the wizard, there shouldn't be a buffer, so the size
                    // should always be passed in as 0.
                    //
                    Assert(GetPersistSize() == 0);
                    pidl->ulPersistBufSize = 0;
                }
                
                // Fill in the Phone Number & Host Address name, and set the offset info
                //
                pidl->ulStrPhoneOrHostAddressPos  = pidl->ulPersistBufPos + pidl->ulPersistBufSize; // offset
                pidl->ulStrPhoneOrHostAddressSize = dwPhoneOrHostAddressSize * sizeof(WCHAR);   // in bytes
                pszPhoneOrHostAddress = pidl->PszGetPhoneOrHostAddressPointer();
                lstrcpyW(pszPhoneOrHostAddress, GetPhoneOrHostAddress());
                pszPhoneOrHostAddress[dwPhoneOrHostAddressSize] = 0;

                Assert( !lstrcmpW(pidl->PszGetNamePointer(), GetName()) );
                Assert( !lstrcmpW(pidl->PszGetPhoneOrHostAddressPointer(), GetPhoneOrHostAddress()) );
                Assert( !lstrcmpW(pidl->PszGetDeviceNamePointer(), GetDeviceName()) );
                Assert( !memcmp(pidl->PbGetPersistBufPointer(), GetPersistData(), GetPersistSize()) );
                
                // Don't forget to terminate the list!
                //
                LPITEMIDLIST pidlTerminate;
                pidlTerminate = ILNext( pidl.GetItemIdList() );
                pidlTerminate->mkid.cb = 0;
            }
            else
            {
                AssertSz(FALSE, "CConFoldEntry::ConvertToPidl is hosed");
                hr = E_OUTOFMEMORY;
            }

#ifdef DBG_VALIDATE_PIDLS
            Assert(IsValidPIDL( pidl.GetItemIdList() ));
#endif
            Assert( pidl->IsPidlOfThisType() ) ;
            
            if (SUCCEEDED(hr))
            {
                m_bDirty = FALSE;
                m_CachedV2Pidl = pidl;
            }
        }
        else
        {
            TraceTag(ttidShellFolder, "Using internally cached PIDL");
            pidl = m_CachedV2Pidl;
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::ConvertToPidl");
    return hr;
}

CONFOLDPIDLTYPE GetPidlType(LPCITEMIDLIST pidl)
{
    CONFOLDPIDLTYPE bRet = PIDL_TYPE_UNKNOWN;
    
    if (!pidl)
    {
        return bRet;
    }
    
    // V1 check
    if (pidl->mkid.cb >= CBCONFOLDPIDLV1_MIN)
    {
        const UNALIGNED ConFoldPidl_v1* pcfp = reinterpret_cast<const ConFoldPidl_v1*>(pidl);
        
        if ( (pcfp->iCB >= CBCONFOLDPIDLV1_MIN) && (pcfp->iCB <= CBCONFOLDPIDLV1_MAX))
        {
            if (pcfp->uLeadId == CONFOLDPIDL_LEADID &&
                pcfp->uTrailId == CONFOLDPIDL_TRAILID)
            {
                if (pcfp->dwVersion == ConFoldPidl_v1::CONNECTIONS_FOLDER_IDL_VERSION)
                {
                    bRet = PIDL_TYPE_V1;
                    return bRet;
                }
            }
        }
    }   
    
    // V2 check
    if (pidl->mkid.cb >= CBCONFOLDPIDLV2_MIN)
    {
        const UNALIGNED ConFoldPidl_v2* pcfp = reinterpret_cast<const ConFoldPidl_v2 *>(pidl);
        if ( (pcfp->iCB >= CBCONFOLDPIDLV2_MIN) && (pcfp->iCB <= CBCONFOLDPIDLV2_MAX))
        {
            if (pcfp->uLeadId == CONFOLDPIDL_LEADID &&
                pcfp->uTrailId == CONFOLDPIDL_TRAILID)
            {
                if (pcfp->dwVersion == ConFoldPidl_v2::CONNECTIONS_FOLDER_IDL_VERSION)
                {
                    bRet = PIDL_TYPE_V2;
                    return bRet;
                }
            }
        }
    }
    
    // 98 Check
    if (pidl->mkid.cb >= CBCONFOLDPIDL98_MIN)
    {
        const UNALIGNED ConFoldPidl98*  pcfp = reinterpret_cast<const ConFoldPidl98 *>(pidl);
        if ((pcfp->cbSize >= CBCONFOLDPIDL98_MIN) && (pcfp->cbSize <= CBCONFOLDPIDL98_MAX))
        {
            if ((SOF_REMOTE == pcfp->uFlags) || (SOF_NEWREMOTE == pcfp->uFlags) ||
                (SOF_MEMBER == pcfp->uFlags))
            {
                if (pcfp->nIconIndex >= 0)
                {
                    bRet = PIDL_TYPE_98;
                    return bRet;
                }
            }
        }
    }
    
    return bRet;
}

HRESULT ConFoldPidl_v1::ConvertToConFoldEntry(OUT CConFoldEntry& ccfe) const
{
    HRESULT         hr      = S_OK;
    
    Assert(this);
    if (!this)
    {
        return E_UNEXPECTED;
    }
    
#if ( defined (MMMDBG) && defined ( _X86_ ) )
    if ( (g_ccl.m_csMain.OwningThread == (HANDLE)GetCurrentThreadId()) && (g_ccl.m_csMain.LockCount != -1) )
    {
        AssertSz(NULL, ".ConvertToConFoldEntry is called while the thread is owning g_ccl's Critical section. \r\n"
            "This may deadlock since .ConvertToConFoldEntry needs to marshall COM calls to other threads \r\n\r\n"
            "To Fix: Make a copy of ccfe from the pidl and Release the lock before calling .ConvertToConFoldEntry.");
    }
#endif
    
    // hr = ConvertToPidlInCache(*this, pcfp); // NOT REQUIRED. WE KNOW THIS IS A V1 PIDL!
    
    // Initialize the data from the pidl
    hr = ccfe.HrInitData(wizWizard,
        ncm,
        NCSM_NONE,
        ncs,
        &clsid,
        &guidId,
        dwCharacteristics,
        PbGetPersistBufPointer(),
        ulPersistBufSize,
        PszGetNamePointer(),
        PszGetDeviceNamePointer(),
        NULL /*PszGetPhoneOrHostAddressPointer()*/);
    
    if (FAILED(hr))
    {
        TraceHr(ttidShellFolder, FAL, hr, FALSE, "Failed in call to pcfe->HrInitData in ConvertToConFoldEntry");
    }
    
    TraceHr(ttidError, FAL, hr, FALSE, "ConvertToConFoldEntry");
    return hr;
}

HRESULT ConFoldPidl_v2::ConvertToConFoldEntry(OUT CConFoldEntry& ccfe) const
{
    HRESULT         hr      = S_OK;
    
    Assert(this);
    if (!this)
    {
        return E_UNEXPECTED;
    }
    
#if ( defined (MMMDBG) && defined ( _X86_ ) )
    if ( (g_ccl.m_csMain.OwningThread == (HANDLE)GetCurrentThreadId()) && (g_ccl.m_csMain.LockCount != -1) )
    {
        AssertSz(NULL, ".ConvertToConFoldEntry is called while the thread is owning g_ccl's Critical section. \r\n"
            "This may deadlock since .ConvertToConFoldEntry needs to marshall COM calls to other threads \r\n\r\n"
            "To Fix: Make a copy of ccfe from the pidl and Release the lock before calling .ConvertToConFoldEntry.");
    }
#endif
    
    // hr = ConvertToPidlInCache(*this, pcfp); // NOT REQUIRED. WE KNOW THIS IS A V2 PIDL!
    
    // Initialize the data from the pidl
    hr = ccfe.HrInitData(wizWizard,
        ncm,
        ncsm,
        ncs,
        &clsid,
        &guidId,
        dwCharacteristics,
        PbGetPersistBufPointer(),
        ulPersistBufSize,
        PszGetNamePointer(),
        PszGetDeviceNamePointer(),
        PszGetPhoneOrHostAddressPointer());
    
    if (FAILED(hr))
    {
        TraceHr(ttidShellFolder, FAL, hr, FALSE, "Failed in call to pcfe->HrInitData in ConvertToConFoldEntry");
    }
    
    TraceHr(ttidError, FAL, hr, FALSE, "ConvertToConFoldEntry");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\cfpidl_templates.cpp ===
// ****************************************************************************
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C F P I D L _ T E M P L A T E S . C P P
//
//  Contents:   Connections Folder template structures.
//
//  Author:     deonb     12 Jan 2001
//
// ****************************************************************************

#include "pch.h"
#pragma hdrstop


#include "ncperms.h"
#include "ncras.h"
#include "foldinc.h"    // Standard shell\folder includes
#include "ncnetcon.h"

template <class T>
HRESULT CPConFoldPidl<T>::FreePIDLIfRequired()
{
    if ( m_pConFoldPidl )
    {
        FreeIDL(reinterpret_cast<LPITEMIDLIST>(m_pConFoldPidl));
        m_pConFoldPidl = NULL;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

template <class T>
HRESULT CPConFoldPidl<T>::Clear()
{
    FreePIDLIfRequired();

    return S_OK;
}

template <class T>
T& CPConFoldPidl<T>::operator *()
{
    return (*m_pConFoldPidl);
}

template <class T>
UNALIGNED T* CPConFoldPidl<T>::operator->()
{
    return m_pConFoldPidl;
}

template <class T>
const UNALIGNED T* CPConFoldPidl<T>::operator->() const
{
    return m_pConFoldPidl;
}

template <class T>
HRESULT CPConFoldPidl<T>::ILCreate(const DWORD dwSize)
{
    Assert(dwSize >= sizeof(T));
    FreePIDLIfRequired();
    
    // Just call the constructor on T (placement form of new doesn't allocate any more memory).
    LPVOID pPlacement = ::ILCreate(dwSize);
    if (!pPlacement)
    {
        return E_OUTOFMEMORY;
    }
#if DBG
    ZeroMemory(pPlacement, dwSize);
#endif

    // Basically call the constructor
    // Semantic equivalent to m_pConFoldPidl = pPlacement;
    // m_pConFoldPidl::T();
    m_pConFoldPidl = new( pPlacement ) T; 

    Assert(pPlacement == m_pConFoldPidl);

    return S_OK;
}

template <class T>
HRESULT CPConFoldPidl<T>::SHAlloc(const SIZE_T cb)
{
    FreePIDLIfRequired();

    LPVOID pPlacement = reinterpret_cast<UNALIGNED T*>(::SHAlloc(cb));
    if (!pPlacement)
    {
        return E_OUTOFMEMORY;
    }

    // Basically call the constructor
    // Semantic equivalent to m_pConFoldPidl = pPlacement;
    // m_pConFoldPidl::T();
    m_pConFoldPidl = new( pPlacement ) T; 
    Assert(pPlacement == m_pConFoldPidl);

    if (m_pConFoldPidl)
    {
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

template <class T>
HRESULT CPConFoldPidl<T>::ILClone(const CPConFoldPidl<T>& PConFoldPidl)
{
    C_ASSERT(PIDL_VERSION == T::CONNECTIONS_FOLDER_IDL_VERSION);
    FreePIDLIfRequired();

    LPVOID pPlacement = reinterpret_cast<UNALIGNED T*>(::ILClone(reinterpret_cast<LPITEMIDLIST>(PConFoldPidl.m_pConFoldPidl)));
    if (!pPlacement)
    {
        return E_OUTOFMEMORY;
    }

    // Basically call the constructor
    // Semantic equivalent to m_pConFoldPidl = pPlacement;
    // m_pConFoldPidl::T();
    m_pConFoldPidl = new( pPlacement ) T; 
    Assert(pPlacement == m_pConFoldPidl);
    if (m_pConFoldPidl)
    {
        Assert(m_pConFoldPidl->IsPidlOfThisType());
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

template <class T>
LPITEMIDLIST CPConFoldPidl<T>::TearOffItemIdList() const
{
    TraceFileFunc(ttidConFoldEntry);

    Assert(m_pConFoldPidl);
    Assert( m_pConFoldPidl->IsPidlOfThisType() );
    LPITEMIDLIST retList = ::ILClone(reinterpret_cast<LPITEMIDLIST>(m_pConFoldPidl));

#ifdef DBG_VALIDATE_PIDLS
    Assert(IsValidPIDL(retList));
#endif

    return retList;
}

template <class T>
LPITEMIDLIST CPConFoldPidl<T>::Detach()
{
    TraceFileFunc(ttidConFoldEntry);

    Assert(m_pConFoldPidl);
    Assert( m_pConFoldPidl->IsPidlOfThisType() );
    LPITEMIDLIST retList = reinterpret_cast<LPITEMIDLIST>(m_pConFoldPidl);

#ifdef DBG_VALIDATE_PIDLS
    Assert(IsValidPIDL(retList));
#endif

    m_pConFoldPidl = NULL;
    return retList;
}

template <class T>
LPCITEMIDLIST CPConFoldPidl<T>::GetItemIdList() const
{
    TraceFileFunc(ttidConFoldEntry);

    Assert(m_pConFoldPidl);
    Assert( m_pConFoldPidl->IsPidlOfThisType() );
    LPCITEMIDLIST tmpItemIdList = reinterpret_cast<LPCITEMIDLIST>(m_pConFoldPidl);

#ifdef DBG_VALIDATE_PIDLS
    Assert(IsValidPIDL(tmpItemIdList));
#endif

    return tmpItemIdList;
}

#ifdef DBG_VALIDATE_PIDLS
template <class T>
BOOL CPConFoldPidl<T>::IsValidConFoldPIDL() const
{
    return IsValidPIDL(reinterpret_cast<LPCITEMIDLIST>(m_pConFoldPidl));
}
#endif

template <class T>
HRESULT CPConFoldPidl<T>::InitializeFromItemIDList(LPCITEMIDLIST pItemIdList)
{
    DWORD dwPidlSize = 0;
    UNALIGNED ConFoldPidl_v1  * cfpv1  = NULL;
    UNALIGNED ConFoldPidl_v2  * cfpv2  = NULL;
    UNALIGNED ConFoldPidl98   * cfpv98 = NULL;
    LPVOID pPlacement = NULL;
    
    HRESULT hr = S_OK;
    Assert(pItemIdList);

#ifdef DBG_VALIDATE_PIDLS
    if (!IsValidPIDL(pItemIdList))
    {
        TraceError("Invalid PIDL passed to InitializeFromItemIDList", E_INVALIDARG);
    }
#endif

    Clear();

    CONFOLDPIDLTYPE pidlType = GetPidlType(pItemIdList);
    if ( (PIDL_TYPE_UNKNOWN == pidlType) && (PIDL_VERSION == PIDL_TYPE_FOLDER) )
    {
        pidlType = PIDL_TYPE_FOLDER; // Give it the benefit of the doubt
    }

    if (pidlType == PIDL_VERSION)
    {
        pPlacement = reinterpret_cast<UNALIGNED T*>(::ILClone(pItemIdList));
        if (!pPlacement)
        {
            return E_OUTOFMEMORY;
        }

        // Basically call the constructor
        // Semantic equivalent to m_pConFoldPidl = pPlacement;
        // m_pConFoldPidl::T();

        m_pConFoldPidl = new( pPlacement ) T;
        Assert(pPlacement == m_pConFoldPidl);
    }
    else // We'll have to convert:
    {
        TraceTag(ttidShellFolderIface, "InitializeFromItemIDList: Converting PIDL from type %d to %d", pidlType, PIDL_VERSION);

        switch (PIDL_VERSION)
        {
            case PIDL_TYPE_UNKNOWN: // This is what we are
                {
                    switch (pidlType)   
                    {
                        // This is what we're getting
                        case PIDL_TYPE_UNKNOWN:
                            AssertSz(FALSE, "PIDL is already of this type.");
                            break;
                        case PIDL_TYPE_V1:
                        case PIDL_TYPE_V2:
                        case PIDL_TYPE_98:
                        case PIDL_TYPE_FOLDER:
                        default:
                            AssertSz(FALSE, "Can't upgrade PIDL to UNKNOWN type");
                            hr = E_INVALIDARG;
                            break;
                    }
                }  
                break;

            case PIDL_TYPE_V1: // This is what we are
                {
                    switch (pidlType)
                    {
                         // This is what we're getting
                        case PIDL_TYPE_V1:
                            AssertSz(FALSE, "PIDL is already of this type.");
                            break;

                        case PIDL_TYPE_UNKNOWN:
                        case PIDL_TYPE_V2:
                        case PIDL_TYPE_98:
                        case PIDL_TYPE_FOLDER:
                        default:
                            AssertSz(FALSE, "Can't upgrade PIDL to PIDL_V1 type");
                            hr = E_INVALIDARG;
                            break;
                    }
                }
                break;
                
            case PIDL_TYPE_FOLDER: // This is what we are
                {
                    switch (pidlType)
                    {
                        // This is what we're getting
                        case PIDL_TYPE_FOLDER:
                            AssertSz(FALSE, "PIDL is already of this type.");
                            break;

                        case PIDL_TYPE_V1:
                        case PIDL_TYPE_98:
                        case PIDL_TYPE_UNKNOWN:
                        case PIDL_TYPE_V2:
                        default:
                            AssertSz(FALSE, "Can't upgrade PIDL to PIDL_TYPE_FOLDER type");
                            hr = E_INVALIDARG;
                            break;
                    }
                }
                break;

            case PIDL_TYPE_98: // This is what we are
                {
                    switch (pidlType)
                    {
                            // This is what we're getting
                        case PIDL_TYPE_98:
                            AssertSz(FALSE, "PIDL is already of this type.");
                            break;
                        case PIDL_TYPE_V1:
                        case PIDL_TYPE_V2:
                        case PIDL_TYPE_UNKNOWN:
                        case PIDL_TYPE_FOLDER:
                        default:
                            AssertSz(FALSE, "Can't upgrade PIDL to PIDL_TYPE_98 type");
                            hr = E_INVALIDARG;
                            break;
                    }
                }
                break;

            case PIDL_TYPE_V2: // This is what we are
                {
                    switch (pidlType)
                    {
                        // This is what we're getting
                        case PIDL_TYPE_V2:
                            AssertSz(FALSE, "PIDL is already of this type.");
                            break;
                            
                        case PIDL_TYPE_V1:
                            {
                                // Do the convert.
                                cfpv1 = const_cast<ConFoldPidl_v1 *>(reinterpret_cast<const ConFoldPidl_v1 *>(pItemIdList));
                                Assert(cfpv1->IsPidlOfThisType());
                                if (!cfpv1->IsPidlOfThisType())
                                {
                                    return E_INVALIDARG;
                                }

                                dwPidlSize = cfpv1->iCB + CBCONFOLDPIDLV2_MIN - CBCONFOLDPIDLV1_MIN;
                                dwPidlSize += sizeof(WCHAR); // Adding NULL for PhoneOrHostAddress in bData

                                pPlacement = reinterpret_cast<UNALIGNED T*>(::ILCreate(dwPidlSize + sizeof(USHORT))); // Terminating 0
                                if (!pPlacement)
                                {
                                    return E_OUTOFMEMORY;
                                }
                                TraceTag(ttidShellFolderIface, "InitializeFromItemIDList: Original: 0x%08x  New:0x%08x", pItemIdList, pPlacement);
                                
                                // Basically call the constructor
                                // Semantic equivalent to m_pConFoldPidl = pPlacement;
                                // m_pConFoldPidl::T();
                                m_pConFoldPidl = new( pPlacement ) T;
                                Assert(pPlacement == m_pConFoldPidl);

                                Assert(sizeof(ConFoldPidlBase) <= cfpv1->iCB );

                                // Copy the ConFoldPidlBase data
                                CopyMemory(m_pConFoldPidl, cfpv1, sizeof(ConFoldPidlBase)); 

                                // I know we're already a ConFoldPidl_v2 - but this is a template, so we'll have to cast
                                // to get it to compile. This code path is dead for non-v2 classes though.                                
                                cfpv2 = reinterpret_cast<ConFoldPidl_v2 *>(m_pConFoldPidl);

                                // Copy the bData member (everything but ConFoldPidlBase in this case)
                                CopyMemory(cfpv2->bData, cfpv1->bData, cfpv1->iCB - sizeof(ConFoldPidlBase));

                                // Force update the version number and byte count
                                cfpv2->iCB  = dwPidlSize;
                                const_cast<DWORD&>(cfpv2->dwVersion) = PIDL_TYPE_V2;

                                if (NCM_LAN == cfpv2->ncm)
                                {
                                    cfpv2->ncsm = NCSM_LAN;
                                }
                                else
                                {
                                    cfpv2->ncsm = NCSM_NONE;
                                }

                                cfpv2->ulStrPhoneOrHostAddressPos = cfpv2->ulPersistBufPos + cfpv2->ulPersistBufSize;

                                LPWSTR pszPhoneOrHostAddress = cfpv2->PszGetPhoneOrHostAddressPointer();
                                *pszPhoneOrHostAddress = L'\0';
                                cfpv2->ulStrPhoneOrHostAddressSize = sizeof(WCHAR); // Size of NULL

                                // Don't forget to terminate the list!
                                //
                                LPITEMIDLIST pidlTerminate;
                                pidlTerminate = ILNext( reinterpret_cast<LPCITEMIDLIST>( m_pConFoldPidl ) );
                                pidlTerminate->mkid.cb = 0;

#ifdef DBG_VALIDATE_PIDLS
                                Assert(IsValidConFoldPIDL());
#endif
                                Assert(m_pConFoldPidl->IsPidlOfThisType());
                                if (!m_pConFoldPidl->IsPidlOfThisType())
                                {
                                    ::SHFree(m_pConFoldPidl);
                                    m_pConFoldPidl = NULL;
                                    return E_FAIL;
                                }
                            }
                            break;                            

                        case PIDL_TYPE_98:
                            {
                                cfpv98 = const_cast<ConFoldPidl98 *>(reinterpret_cast<const ConFoldPidl98 *>(pItemIdList));
                                Assert(cfpv98->IsPidlOfThisType());
                                if (!cfpv98->IsPidlOfThisType())
                                {
                                    return E_INVALIDARG;
                                }

                                WCHAR szName[MAX_PATH];
                                mbstowcs(szName, cfpv98->szaName, MAX_PATH);

                                ConnListEntry cle;
                                PCONFOLDPIDL pidlv2;

                                HRESULT hrTmp = g_ccl.HrFindConnectionByName(szName, cle);
                                if (hrTmp != S_OK)
                                {
                                    return E_FAIL;
                                }
                                
                                cle.ccfe.ConvertToPidl(pidlv2);
                                LPITEMIDLIST pIdl = pidlv2.TearOffItemIdList();
                                
                                m_pConFoldPidl = reinterpret_cast<T *>(pIdl);

                                LPITEMIDLIST pidlTerminate;
                                pidlTerminate = ILNext( reinterpret_cast<LPCITEMIDLIST>( m_pConFoldPidl ) );
                                pidlTerminate->mkid.cb = 0;

#ifdef DBG_VALIDATE_PIDLS                                
                                Assert(IsValidConFoldPIDL());
#endif
                                Assert(m_pConFoldPidl->IsPidlOfThisType());
                                if (!m_pConFoldPidl->IsPidlOfThisType())
                                {
                                    ::SHFree(m_pConFoldPidl);
                                    m_pConFoldPidl = NULL;
                                    return E_FAIL;
                                }
                            }
                            break;

                        case PIDL_TYPE_FOLDER:
                            AssertSz(FALSE, "Can't upgrade PIDL to PIDL_V2 type");

                        case PIDL_TYPE_UNKNOWN:
                        default:
                            hr = E_INVALIDARG;
                            break;
                    }
                }
                break;

           default:
                AssertSz(FALSE, "Can't upgrade PIDL");
                hr = E_INVALIDARG;
                break;
        }
    }
    
    if ( FAILED(hr) )
    {
        ::SHFree(m_pConFoldPidl);
        m_pConFoldPidl = NULL;
    }
    else
    {
        Assert(m_pConFoldPidl->IsPidlOfThisType());
    }

    return hr;
}

template <class T>
CPConFoldPidl<T>::CPConFoldPidl()
{
    m_pConFoldPidl = NULL;
}

template <class T>
CPConFoldPidl<T>::CPConFoldPidl(const CPConFoldPidl& PConFoldPidl)
{
    m_pConFoldPidl = NULL;
    
    HRESULT hr = InitializeFromItemIDList(reinterpret_cast<LPCITEMIDLIST>(PConFoldPidl.m_pConFoldPidl));
    if (FAILED(hr))
    {
        throw hr;
    }
}

template <class T>
CPConFoldPidl<T>::~CPConFoldPidl()
{
    FreePIDLIfRequired();
    m_pConFoldPidl = NULL;
}

template <class T>
CPConFoldPidl<T>& CPConFoldPidl<T>::operator =(const CPConFoldPidl<T>& PConFoldPidl)
{
    FreePIDLIfRequired();
    
    if (PConFoldPidl.m_pConFoldPidl)
    {
        HRESULT hr = InitializeFromItemIDList(reinterpret_cast<LPCITEMIDLIST>(PConFoldPidl.m_pConFoldPidl));
        if (FAILED(hr))
        {
            throw hr;
        }
    }
    else
    {
        m_pConFoldPidl = NULL;
    }
    return *this;
}


template <class T>
inline BOOL CPConFoldPidl<T>::empty() const
{
    return (m_pConFoldPidl == NULL);
}

template <class T>
    HRESULT CPConFoldPidl<T>::ConvertToConFoldEntry(OUT CConFoldEntry& cfe) const
{
    Assert(m_pConFoldPidl);
    if (!m_pConFoldPidl)
    {
        return E_UNEXPECTED;
    }

    return m_pConFoldPidl->ConvertToConFoldEntry(cfe);
}

template <class T>
HRESULT CPConFoldPidl<T>::Swop(OUT CPConFoldPidl<T>& cfe)
{
    UNALIGNED T* pTemp = m_pConFoldPidl;
    m_pConFoldPidl = cfe.m_pConFoldPidl;
    cfe.m_pConFoldPidl = pTemp;
    return S_OK;
}

template CPConFoldPidl<ConFoldPidl_v1>;
template CPConFoldPidl<ConFoldPidl_v2 >;
template CPConFoldPidl<ConFoldPidlFolder>;
template CPConFoldPidl<ConFoldPidl98>;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\cfutils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C F U T I L S . H
//
//  Contents:   Various utility functions for the connections folder
//
//  Notes:
//
//  Author:     jeffspr   20 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _CFUTILS_H_
#define _CFUTILS_H_

VOID MapNCMToResourceId(
        NETCON_MEDIATYPE    ncm,
        DWORD               dwCharacteristics,
        INT *               piStringRes);

#define CONFOLD_MAX_STATUS_LENGTH 255

VOID MapNCSToComplexStatus(
        NETCON_STATUS       ncs,
        NETCON_MEDIATYPE    ncm,
        NETCON_SUBMEDIATYPE ncsm,
        DWORD dwCharacteristics,
        LPWSTR              pszString,
        DWORD               cString,
        GUID                gdDevice);

VOID MapNCSToStatusResourceId(
        NETCON_STATUS       ncs,
        NETCON_MEDIATYPE    ncm,
        NETCON_SUBMEDIATYPE ncsm,
        DWORD               dwCharacteristics,
        INT *               piStringRes,
        GUID                gdDevice);

DWORD  MapRSSIToWirelessSignalStrength(int iRSSI);

PCWSTR PszGetRSSIString(int iRSSI);

PCWSTR PszGetOwnerStringFromCharacteristics(
        PCWSTR        pszUserName,
        DWORD         dwCharacteristics);

BOOL IsMediaLocalType(
        NETCON_MEDIATYPE    ncm);

BOOL IsMediaRASType(
        NETCON_MEDIATYPE    ncm);

BOOL IsMediaSharedAccessHostType(
        NETCON_MEDIATYPE    ncm);

#endif // _CFUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\confold.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N F O L D . C P P
//
//  Contents:   CConnectionFolder base functions.
//
//  Notes:
//
//  Author:     jeffspr   18 Mar 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "webview.h"


// Map of replaceable items in connfold.rgs file
// this allows us to localize these items
//
struct _ATL_REGMAP_ENTRY g_FolderRegMap[] =
{
    { L"ConnectionsFolderName",    NULL },
    { L"ConnectionsFolderInfoTip", NULL },
    { NULL,                             NULL }
};


//+---------------------------------------------------------------------------
//
// Function:  CConnectionFolder::UpdateRegistry
//
// Purpose:   Apply registry data in connfold.rgs
//
// Arguments:
//    fRegister [in]  whether to register
//
//  Returns:  S_OK if success, otherwise an error code
//
// Author:    kumarp 15-September-98
//
// Notes:
//
HRESULT WINAPI CConnectionFolder::UpdateRegistry(BOOL fRegister)
{
    TraceFileFunc(ttidConFoldEntry);

    // fill-in localized strings for the two replaceable parameters
    g_FolderRegMap[0].szData = SzLoadIds(IDS_CONFOLD_NAME);
    g_FolderRegMap[1].szData = SzLoadIds(IDS_CONFOLD_INFOTIP);

    return _Module.UpdateRegistryFromResourceD(IDR_CONFOLD, fRegister,
                                               g_FolderRegMap);
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::CConnectionFolder
//
//  Purpose:    Constructor for the primary Folder object
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
CConnectionFolder::CConnectionFolder()
{
    TraceFileFunc(ttidConFoldEntry);

    DWORD   dwLength = UNLEN+1;

    // By default, we want to enumerate all connection types
    //
    m_dwEnumerationType = CFCOPT_ENUMALL;
    m_hwndMain          = NULL;
    m_pWebView          = NULL;

    m_pWebView          = new CNCWebView(this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::~CConnectionFolder
//
//  Purpose:    Destructor for the primary folder object
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
CConnectionFolder::~CConnectionFolder()
{
    Assert(m_pWebView);

    delete m_pWebView;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::PidlGetFolderRoot
//
//  Purpose:    Return the folder pidl. If NULL at this time, generate
//              the pidl for future usage.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   10 Jan 1999
//
//  Notes:
//
PCONFOLDPIDLFOLDER& CConnectionFolder::PidlGetFolderRoot()
{
    TraceFileFunc(ttidConFoldEntry);

    HRESULT hr  = S_OK;

    if (m_pidlFolderRoot.empty())
    {
        // Ignore this hr. For debugging only
        //
        hr = HrGetConnectionsFolderPidl(m_pidlFolderRoot);
    }

    return m_pidlFolderRoot;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::pszGetUserName
//
//  Purpose:    Return the user name of the Connectoid.
//              Currently makes the assumption that any active user can only
//              read either System Wide or his own Connectoids.
//              Probably should cache the user name, however this component
//              is MTA and the UserName is per thread.
//              I don't want to use up a TLS just for this.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     deonb   19 June 1999
//
//  Notes:
//
PCWSTR  CConnectionFolder::pszGetUserName()
{
    TraceFileFunc(ttidConFoldEntry);

    DWORD dwSize = UNLEN+1;

    if (GetUserName(m_szUserName, &dwSize))
    {
        return m_szUserName;
    }
    else
    {
        return NULL;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\cfutils.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C F U T I L S . C P P
//
//  Contents:   Various utility functions for the connections folder
//
//  Notes:
//
//  Author:     jeffspr   20 Jan 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "nsres.h"      // Netshell strings
#include "cfutils.h"    // Connection folder utility functions

VOID MapNCMToResourceId(
        NETCON_MEDIATYPE    nct,
        DWORD               dwCharacteristics,
        INT *               piStringRes)
{
    Assert(piStringRes);

    if (dwCharacteristics & NCCF_BRANDED)
    {
        *piStringRes = IDS_CONFOLD_OBJECT_TYPE_CONMAN;
    }
    else
    if (dwCharacteristics & NCCF_INCOMING_ONLY)
    {
        *piStringRes = IDS_CONFOLD_OBJECT_TYPE_INBOUND;
    }
    else
    {
        switch(nct)
        {
            case NCM_NONE:
                Assert(dwCharacteristics & NCCF_INCOMING_ONLY);
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_INBOUND;
                break;

            case NCM_DIRECT:
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_DIRECT;
                break;

            case NCM_ISDN:
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_PHONE;
                break;

            case NCM_LAN:
                if(dwCharacteristics & NCCF_BRIDGED)
                {
                    *piStringRes = IDS_CONFOLD_OBJECT_TYPE_BRIDGE;
                }
                else
                {
                    *piStringRes = IDS_CONFOLD_OBJECT_TYPE_LAN;
                }
                break;

            case NCM_PHONE:
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_PHONE;
                break;

            case NCM_TUNNEL:
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_TUNNEL;
                break;

            case NCM_BRIDGE:
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_BRIDGE;
                break;

            case NCM_SHAREDACCESSHOST_LAN:
            case NCM_SHAREDACCESSHOST_RAS:
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_SHAREDACCESSHOST;
                break;
            
            case NCM_PPPOE:
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_PPPOE;
                break;

            default:
                AssertSz(FALSE, "Marfa -- I can't find my teef!  (You may ignore.)");
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_UNKNOWN;
                break;
        }
    }
}

VOID MapNCSToComplexStatus(
        NETCON_STATUS       ncs,
        NETCON_MEDIATYPE    ncm,
        NETCON_SUBMEDIATYPE ncsm,
        DWORD dwCharacteristics,
        LPWSTR              pszString,
        DWORD               cString,
        GUID                gdDevice)
{
    Assert(cString >= CONFOLD_MAX_STATUS_LENGTH); 
    *pszString = L'\0';

    PCWSTR szArgs[4] = {L"", L"", L"", L""};
    DWORD dwArg = 0;

    WCHAR  szTmpString[MAX_PATH];
    
    INT iStringRes = 0;

    if ((NCM_NONE == ncm) && (dwCharacteristics & NCCF_INCOMING_ONLY) )
    {
        DWORD dwIncomingCount;
        HRESULT hr = g_ccl.HasActiveIncomingConnections(&dwIncomingCount);
        if (SUCCEEDED(hr) && dwIncomingCount)
        {
            if (1 == dwIncomingCount)
            {
                szArgs[dwArg++] = SzLoadIds(IDS_CONFOLD_STATUS_INCOMING_ONE);
            }
            else
            {
                if (DwFormatString(SzLoadIds(IDS_CONFOLD_STATUS_INCOMING_MULTI), szTmpString, MAX_PATH, dwIncomingCount))
                {
                    szArgs[dwArg++] = szTmpString;
                }
            }
        }
        else
        {
            szArgs[dwArg++] = SzLoadIds(IDS_CONFOLD_STATUS_INCOMING_NONE);
        }
    }
    else
    {
        MapNCSToStatusResourceId(ncs, ncm, ncsm, dwCharacteristics, &iStringRes, gdDevice);
    }

    if (iStringRes)
    {
        szArgs[dwArg++] = SzLoadIds(iStringRes);
    }
    
    if (ncs == NCS_DISCONNECTED || fIsConnectedStatus(ncs))
    {
        if(NCCF_BRIDGED & dwCharacteristics)
        {
            szArgs[dwArg++] = SzLoadIds(IDS_CONFOLD_STATUS_BRIDGED);
        }
        
        if(NCCF_SHARED & dwCharacteristics)
        {
            szArgs[dwArg++] = SzLoadIds(IDS_CONFOLD_STATUS_SHARED);
        }
        
        if(NCCF_FIREWALLED & dwCharacteristics)
        {
            szArgs[dwArg++] = SzLoadIds(IDS_CONFOLD_STATUS_FIREWALLED);
        }
    }

    if(0 == FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, L"%1%2%3%4", 0, 0, pszString, cString, (va_list*) &szArgs))
    {
        *pszString = L'\0'; // on error return empty
    }
}


VOID MapNCSToStatusResourceId(
        NETCON_STATUS       ncs,
        NETCON_MEDIATYPE    ncm,
        NETCON_SUBMEDIATYPE ncsm,
        DWORD dwCharacteristics,
        INT *               piStringRes,
        GUID                gdDevice)
{
    Assert(piStringRes);

    switch(ncs)
    {
        case NCS_DISCONNECTED:
            if (IsMediaLocalType(ncm) || NCM_SHAREDACCESSHOST_LAN == ncm)
            {
                *piStringRes = IDS_CONFOLD_STATUS_DISABLED;
            }
            else
            {
                *piStringRes = IDS_CONFOLD_STATUS_DISCONNECTED;
            }
            break;

        case NCS_CONNECTING:
            if (IsMediaLocalType(ncm) || NCM_SHAREDACCESSHOST_LAN == ncm)
                *piStringRes = IDS_CONFOLD_STATUS_ENABLING;
            else
                *piStringRes = IDS_CONFOLD_STATUS_CONNECTING;
            break;

        case NCS_CONNECTED:
            if (IsMediaLocalType(ncm) || NCM_SHAREDACCESSHOST_LAN == ncm)
            {
                *piStringRes = IDS_CONFOLD_STATUS_ENABLED;
            }
            else
            {
                *piStringRes = IDS_CONFOLD_STATUS_CONNECTED;
            }
            break;

        case NCS_DISCONNECTING:
            if (IsMediaLocalType(ncm) || NCM_SHAREDACCESSHOST_LAN == ncm)
                *piStringRes = IDS_CONFOLD_STATUS_DISABLING;
            else
                *piStringRes = IDS_CONFOLD_STATUS_DISCONNECTING;
            break;

        case NCS_HARDWARE_NOT_PRESENT:
            *piStringRes = IDS_CONFOLD_STATUS_HARDWARE_NOT_PRESENT;
            break;

        case NCS_HARDWARE_DISABLED:
            *piStringRes = IDS_CONFOLD_STATUS_HARDWARE_DISABLED;
            break;

        case NCS_HARDWARE_MALFUNCTION:
            *piStringRes = IDS_CONFOLD_STATUS_HARDWARE_MALFUNCTION;
            break;

        case NCS_MEDIA_DISCONNECTED:
            if ( (ncm == NCM_LAN) && (ncsm == NCSM_WIRELESS) )
            {
                *piStringRes = IDS_CONFOLD_STATUS_WIRELESS_DISCONNECTED;
            }
            else
            {
                *piStringRes = IDS_CONFOLD_STATUS_MEDIA_DISCONNECTED;
            }
            break;

        case NCS_INVALID_ADDRESS:
            *piStringRes = IDS_CONFOLD_STATUS_INVALID_ADDRESS;
            break;

        case NCS_AUTHENTICATION_FAILED:
            *piStringRes = IDS_CONFOLD_STATUS_AUTHENTICATION_FAILED;
            break;

        case NCS_AUTHENTICATING:
            *piStringRes = IDS_CONFOLD_STATUS_AUTHENTICATING;
            break;

        case NCS_AUTHENTICATION_SUCCEEDED:
            *piStringRes = IDS_CONFOLD_STATUS_AUTHENTICATION_SUCCEEDED;
            break;

        case NCS_CREDENTIALS_REQUIRED:
            *piStringRes = IDS_CONFOLD_STATUS_CREDENTIALS_REQUIRED;
            break;

        default:
            AssertSz(FALSE, "Unknown status in MapNCSToStatusResourceId");
            *piStringRes = IDS_CONFOLD_STATUS_DISCONNECTED;
            break;
    }
}

DWORD MapRSSIToWirelessSignalStrength(int iRSSI)
{
    if (iRSSI < -90)
    {
        return 0;
    }
    
    if (iRSSI < -81)
    {
        return 1;
    }
    
    if (iRSSI < -71)
    {
        return 2;
    }
    
    if (iRSSI < -67)
    {
        return 3;
    }

    if (iRSSI < -57)
    {
        return 4;
    }

    return 5;
}

PCWSTR PszGetRSSIString(INT iRSSI)
{
    DWORD wss = MapRSSIToWirelessSignalStrength(iRSSI);

    Assert(wss <= (IDS_802_11_LEVEL5 - IDS_802_11_LEVEL0) );

    return SzLoadIds(IDS_802_11_LEVEL0 + wss);
}

//+---------------------------------------------------------------------------
//
//  Function:   PszGetOwnerStringFromCharacteristics
//
//  Purpose:    Get the owner string from the CONFOLDENTRY. This will
//              return the string for "System" if the connection is for
//              all users, and will return the particular user if
//              appropriate
//
//  Arguments:
//      pcfe [in]   The ConFoldEntry for this connection
//
//  Returns:    The string for the user name
//
//  Author:     jeffspr   20 Jan 1998
//
//  Notes:
//
PCWSTR PszGetOwnerStringFromCharacteristics(PCWSTR pszUserName, DWORD dwCharacteristics)

{
    PCWSTR  pszOwner    = NULL;
    BOOL    fAllUsers   = (dwCharacteristics & NCCF_ALL_USERS) > 0;

    // If they both have the same user type, then they're equal
    //
    if (fAllUsers)
    {
        pszOwner = SzLoadIds(IDS_CONFOLD_DETAILS_OWNER_SYSTEM);
    }
    else
    {
        pszOwner = pszUserName;
    }

    return pszOwner;
}

BOOL IsMediaLocalType(NETCON_MEDIATYPE ncm)
{
    return (ncm == NCM_LAN || ncm == NCM_BRIDGE);
}

BOOL IsMediaRASType(NETCON_MEDIATYPE ncm)
{
    return (ncm == NCM_DIRECT || ncm == NCM_ISDN || ncm == NCM_PHONE || ncm == NCM_TUNNEL || ncm == NCM_PPPOE);// REVIEW DIRECT correct?
}

BOOL IsMediaSharedAccessHostType(NETCON_MEDIATYPE ncm)
{
    return (ncm == NCM_SHAREDACCESSHOST_LAN || ncm == NCM_SHAREDACCESSHOST_RAS);
}


//+---------------------------------------------------------------------------
//
//  Function Name:  ImageList_LoadImageAndMirror
//
//  Purpose:    This function creates an image list from the specified bitmap or icon resource.
//
//  Arguments:
//      hi          [in] Handle to the instance of an application or DLL that contains an image. 
//      lpbmp       [in] Long pointer to the image to load. 
//                       If the uFlags parameter includes LR_LOADFROMFILE, lpbmp is the address 
//                       of a null-terminated string that names the file containing the image to load. 
//
//                       If the hi parameter is non-NULL and LR_LOADFROMFILE is not specified, lpbmp is the 
//                          address of a null-terminated string that contains the name of the image resource in the hi module. 
//
//                       If hi is NULL and LR_LOADFROMFILE is not specified, the low-order word of this 
//                          parameter must be the identifier of an OEM image to load. To create this value, use the 
//                          MAKEINTRESOURCE macro with one of the OEM image identifiers defined in Winuser.h. 
//                       These identifiers have the following prefixes: 
//                          OBM_ for OEM bitmaps 
//                          OIC_ for OEM icons 
//
//      cx          [in] Width of each image. The height of each image and the initial number of images are inferred 
//                          by the dimensions of the specified resource. 
//      cGrow       [in] Number of images by which the image list can grow when the system needs to make room for new 
//                          images. This parameter represents the number of new images that the resized image list can contain. 
//      crMask      [in] Color used to generate a mask. Each pixel of this color in the specified bitmap or icon is changed to 
//                          black, and the corresponding bit in the mask is set to 1. If this parameter is the CLR_NONE value, 
//                          no mask is generated. If this parameter is the CLR_DEFAULT value, the color of the pixel at the 
//                          upper-left corner of the image is treated as the mask color. 
//      uType       [in] Flag that specifies the type of image to load. This parameter can be one of the following values: 
//                          IMAGE_BITMAP Loads a bitmap. 
//                          IMAGE_ICON Loads an icon. 
//      uFlags      [in] Unsupported; set to 0. 
//
//  Returns:    
//      The handle to the image list indicates success. NULL indicates failure. 
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//      This is an exact duplication of the implementation of shell's ImageList_LoadImage function EXCEPT for the 
//      fact that we set ILC_MIRROR in order to create the second, mirrored image list which will be used
//      by RTL languages
//      
HIMAGELIST WINAPI ImageList_LoadImageAndMirror(
                            HINSTANCE hi, 
                            LPCTSTR lpbmp, 
                            int cx, 
                            int cGrow, 
                            COLORREF crMask, 
                            UINT uType, 
                            UINT uFlags)
{
    HBITMAP hbmImage;
    HIMAGELIST piml = NULL;
    BITMAP bm;
    int cy, cInitial;
    UINT flags;
	
    hbmImage = (HBITMAP)LoadImage(hi, lpbmp, uType, 0, 0, uFlags);
    if (hbmImage && (sizeof(bm) == GetObject(hbmImage, sizeof(bm), &bm)))
    {
        // If cx is not stated assume it is the same as cy.
        // ASSERT(cx);
        cy = bm.bmHeight;
		
        if (cx == 0)
            cx = cy;
		
        cInitial = bm.bmWidth / cx;
		
        flags = 0;
        if (crMask != CLR_NONE)
            flags |= ILC_MASK;
        if (bm.bmBits)
            flags |= (bm.bmBitsPixel & ILC_COLORMASK);

        flags |= ILC_MIRROR;

        piml = ImageList_Create(cx, cy, flags, cInitial, cGrow);
        if (piml)
        {
            int added;
			
            if (crMask == CLR_NONE)
                added = ImageList_Add(piml, hbmImage, NULL);
            else
                added = ImageList_AddMasked(piml, hbmImage, crMask);
			
            if (added < 0)
            {
                ImageList_Destroy(piml);
                piml = NULL;
            }
        }
    }
	
    if (hbmImage)
        DeleteObject(hbmImage);
	
    return reinterpret_cast<HIMAGELIST>(piml);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\cmdtable.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C M D T A B L E . C P P
//
//  Contents:   Command-table code -- determines which menu options are
//              available by the selection count, among other criteria
//
//  Notes:
//
//  Author:     jeffspr   28 Jan 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "foldres.h"    // Folder resource IDs
#include "nsres.h"      // Netshell strings
#include "cmdtable.h"   // Header for this file
#include "ncperms.h"    // For checking User's rights on actions/menu items
#include "cfutils.h"
#include "hnetcfg.h"
#include "lm.h"

//---[ Constants ]------------------------------------------------------------

const DWORD NCCF_ALL      = 0xffffffff; // NCCF_ALL      - For all Characteristics
const DWORD S_REMOVE = 2;
#define TRACESTRLEN 65535


// Active must be a subset of Visible (Opening connections folder using a CHK DLL asserts integrity of table).
// DO NOT use NCM_ and NCS_ flags in this table!!! You should use NBM_ and NBS_ flags over here.
COMMANDENTRY g_cteCommandMatrix[] =
{
    //iCommandId    dwDefaultPriority             dwFlags                HrEnableDisableCB HrCustomMenuStringCB
    // |                      |  dwValidWhen         |                           |           |
    // |                      |    |                 | dwMediaTypeVisible        |           |  dwMediaTypeActive
    // |                      |    |                 | dwStatusVisible           |           |  dwStatusActive
    // |                      |    |                 | dwCharacteristicsVisible  |           |  dwCharacteristicsActive
    // |                      |    |                 |  (VISIBLE)                |           |  (ACTIVE... (NOT REMOVED))
    // v                      v    v                 v     |                     v           v    |
    //                                                     v                                      v
    { CMIDM_HOMENET_WIZARD,   5, NCWHEN_ANYSELECT,  NB_REMOVE_TOPLEVEL_ITEM,HrIsHomeNewWizardSupported, NULL,
                                                          NBM_HNW_WIZARD,                    NBM_HNW_WIZARD,            // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_NET_TROUBLESHOOT, 5, NCWHEN_TOPLEVEL,   NB_REMOVE_TOPLEVEL_ITEM,HrIsTroubleShootSupported,  NULL,
                                                          NBM_NOMEDIATYPE,                   NBM_NOMEDIATYPE,           // Media Type
                                                          NBS_NONE,                          NBS_NONE,                  // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_CONMENU_ADVANCED_CONFIG,  
                              5, NCWHEN_TOPLEVEL,   NB_NO_FLAGS,                       NULL,  NULL,
                                                    NBM_NOMEDIATYPE,                   NBM_NOMEDIATYPE,           // Media Type
                                                    NBS_NONE,                          NBS_NONE,                  // Status
                                                    NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_CONMENU_DIALUP_PREFS,  
                              5, NCWHEN_TOPLEVEL,
                                                    NB_NO_FLAGS,                       NULL,  NULL,
                                                    NBM_NOMEDIATYPE,                   NBM_NOMEDIATYPE,           // Media Type
                                                    NBS_NONE,                          NBS_NONE,                  // Status
                                                    NCCF_ALL,                          NCCF_ALL},                 // Characteristics
    
    { CMIDM_NEW_CONNECTION,   5, NCWHEN_ANYSELECT,  NB_VERB,                    HrIsNCWSupported, NULL,
                                                          NBM_MNC_WIZARD,                    NBM_MNC_WIZARD,                // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_CONNECT,          3, NCWHEN_ONESELECT,  NB_VERB,                    NULL,        NULL,
                                                          NBM_SHAREDACCESSHOST_RAS | NBM_ISRASTYPE, NBM_SHAREDACCESSHOST_RAS | NBM_ISRASTYPE, // Media Type
                                                          NBS_HW_ISSUE | NBS_DISCONNECTED | NBS_CONNECTING, NBS_DISCONNECTED,          // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_DISCONNECT,       0, NCWHEN_ONESELECT,  NB_VERB,                    NULL,        NULL,
                                                          NBM_SHAREDACCESSHOST_RAS|NBM_ISRASTYPE,NBM_SHAREDACCESSHOST_RAS|NBM_ISRASTYPE,             // Media Type
                                                          NBS_IS_CONNECTED | NBS_DISCONNECTING, NBS_IS_CONNECTED,             // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_ENABLE,           3, NCWHEN_ONESELECT,  NB_VERB,                    NULL,        NULL,
                                                          NBM_SHAREDACCESSHOST_LAN|NBM_ISLANTYPE,NBM_SHAREDACCESSHOST_LAN|NBM_ISLANTYPE,             // Media Type
                                                          NBS_HW_ISSUE | NBS_DISCONNECTED | NBS_CONNECTING,    NBS_DISCONNECTED,          // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_DISABLE,          0, NCWHEN_ONESELECT,  NB_VERB,                    NULL,        NULL,
                                                          NBM_SHAREDACCESSHOST_LAN|NBM_ISLANTYPE,NBM_SHAREDACCESSHOST_LAN|NBM_ISLANTYPE,             // Media Type
                                                          NBS_DISCONNECTING | NBS_IS_CONNECTED | NBS_MEDIA_DISCONNECTED | NBS_INVALID_ADDRESS,   NBS_NOT_DISCONNECT,        // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_WZCDLG_SHOW,      4, NCWHEN_ONESELECT,  NB_VERB,                    HrIsMediaWireless, NULL,
                                                          NBM_LAN,                           NBM_LAN,                  // Media Type
                                                          NBS_NOT_DISCONNECT,                NBS_NOT_DISCONNECT, // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics
    
    { CMIDM_STATUS,           5, NCWHEN_ONESELECT,  NB_VERB,                    NULL,        NULL,
                                                          NBM_INCOMING | NBM_SHAREDACCESSHOST_LAN|NBM_SHAREDACCESSHOST_RAS|NBM_ISCONNECTIONTYPE, NBM_INCOMING | NBM_SHAREDACCESSHOST_LAN|NBM_SHAREDACCESSHOST_RAS|NBM_ISCONNECTIONTYPE,
                                                          NBS_ANY,                           NBS_IS_CONNECTED | NBS_INVALID_ADDRESS, // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_FIX,              0, NCWHEN_SOMESELECT, NB_NO_FLAGS,                NULL,        NULL,
                                                          NBM_ISLANTYPE,                     NBM_ISLANTYPE,             // Media Type
                                                          NBS_IS_CONNECTED | NBS_DISCONNECTING| NBS_MEDIA_DISCONNECTED| NBS_INVALID_ADDRESS, NBS_INVALID_ADDRESS | NBS_IS_CONNECTED, // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_SEPARATOR,        0,0,0,0,0,  0,0,  0,0,  0,0 },

    { CMIDM_SET_DEFAULT,      0, NCWHEN_ONESELECT,  NB_NEGATE_CHAR_MATCH,  NULL,  NULL,
                                                          NBM_INCOMING | NBM_ISRASTYPE,      NBM_INCOMING | NBM_ISRASTYPE,             // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_INCOMING_ONLY | NCCF_DEFAULT, NCCF_INCOMING_ONLY | NCCF_DEFAULT}, // Characteristics

    { CMIDM_UNSET_DEFAULT,    0, NCWHEN_ONESELECT,  NB_NO_FLAGS,           NULL,  NULL,
                                                          NBM_INCOMING | NBM_ISRASTYPE,      NBM_INCOMING | NBM_ISRASTYPE,             // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_DEFAULT,                      NCCF_DEFAULT},             // Characteristics

    { CMIDM_SEPARATOR,        0,0,0,0,0,  0,0,  0,0,  0,0 },

    { CMIDM_CREATE_BRIDGE,    0, NCWHEN_ANYSELECT,   NB_NO_FLAGS,           HrIsBridgeSupported, NULL,
                                                          NBM_LAN,                           NBM_LAN,                  // Media Type
                                                          NBS_IS_CONNECTED | NBS_DISCONNECTING| NBS_MEDIA_DISCONNECTED| NBS_INVALID_ADDRESS, NBS_DISCONNECTING|NBS_IS_CONNECTED|NBS_MEDIA_DISCONNECTED|NBS_INVALID_ADDRESS, // Status
                                                          NCCF_ALL,                          NCCF_ALL   },             // Characteristics

    { CMIDM_CONMENU_CREATE_BRIDGE,0, NCWHEN_TOPLEVEL,NB_REMOVE_TOPLEVEL_ITEM,HrIsBridgeSupported,  NULL,
                                                          NBM_NOMEDIATYPE,                   NBM_NOMEDIATYPE,           // Media Type
                                                          NBS_NONE,                          NBS_NONE,                  // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_ADD_TO_BRIDGE,    0, NCWHEN_SOMESELECT,  NB_NEGATE_CHAR_MATCH,   HrIsBridgeSupported, NULL,
                                                          NBM_LAN,                           NBM_LAN,                  // Media Type
                                                          NBS_IS_CONNECTED | NBS_DISCONNECTING| NBS_MEDIA_DISCONNECTED| NBS_INVALID_ADDRESS, NBS_DISCONNECTING|NBS_IS_CONNECTED|NBS_MEDIA_DISCONNECTED|NBS_INVALID_ADDRESS, // Status
                                                          NCCF_BRIDGED | NCCF_FIREWALLED | NCCF_SHARED, NCCF_BRIDGED | NCCF_FIREWALLED | NCCF_SHARED   },            // Characteristics

    { CMIDM_REMOVE_FROM_BRIDGE, 0, NCWHEN_SOMESELECT,NB_NO_FLAGS,            HrIsBridgeSupported, NULL,
                                                          NBM_LAN,                           NBM_LAN,                  // Media Type
                                                          NBS_IS_CONNECTED | NBS_DISCONNECTING| NBS_MEDIA_DISCONNECTED| NBS_INVALID_ADDRESS, NBS_DISCONNECTING|NBS_IS_CONNECTED|NBS_MEDIA_DISCONNECTED|NBS_INVALID_ADDRESS, // Status
                                                          NCCF_BRIDGED,                      NCCF_BRIDGED                                              },            // Characteristics

    { CMIDM_SEPARATOR,        0,0,0,0,0,  0,0,  0,0,  0,0 },

    { CMIDM_CREATE_COPY,      0, NCWHEN_ONESELECT,   NB_NEGATE_VIS_CHAR_MATCH,  NULL,        NULL,
                                                          NBM_INCOMING | NBM_SHAREDACCESSHOST_RAS | NBM_ISRASTYPE, NBM_INCOMING | NBM_SHAREDACCESSHOST_RAS | NBM_ISRASTYPE,             // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_INCOMING_ONLY,                NCCF_ALLOW_DUPLICATION},   // Characteristics

    { CMIDM_SEPARATOR,        0,0,0,0,0,  0,0,  0,0,  0,0 },

    { CMIDM_CREATE_SHORTCUT,  0, NCWHEN_ONESELECT,   NB_NEGATE_CHAR_MATCH,      NULL,        NULL,
                                                          NBM_ANY,                           NBM_ANY,    // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_INCOMING_ONLY,                NCCF_INCOMING_ONLY},       // Characteristics

    { CMIDM_DELETE,           0, NCWHEN_SOMESELECT,  NB_NO_FLAGS,               NULL,        NULL,
                                                          NBM_NOTWIZARD,                     NBM_NOTWIZARD,           // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_ALL,                          NCCF_ALLOW_REMOVAL},       // Characteristics


    { CMIDM_RENAME,           0, NCWHEN_ONESELECT,   NB_NO_FLAGS,               HrCanRenameConnection, NULL,
                                                          NBM_NOTWIZARD,                     NBM_NOTWIZARD,            // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_ALL,                          NCCF_ALLOW_RENAME},        // Characteristics

    { CMIDM_SEPARATOR,        0,0,0,0,0,  0,0,  0,0,  0,0 },

    { CMIDM_PROPERTIES,       2, NCWHEN_ONESELECT,   NB_NO_FLAGS,               HrCanShowProperties,        NULL,
                                                          NBM_INCOMING|NBM_SHAREDACCESSHOST_LAN|NBM_SHAREDACCESSHOST_RAS|NBM_ISCONNECTIONTYPE, NBM_INCOMING|NBM_SHAREDACCESSHOST_LAN|NBM_SHAREDACCESSHOST_RAS|NBM_ISCONNECTIONTYPE,      // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics
};

// What is the difference between NCCF_INCOMING_ONLY, ~NCCF_INCOMING_ONLY and NCCF_INCOMING_ONLY + NB_NEGATE_CHAR_MATCH?
// NCCF_INCOMING_ONLY | NCCF_ALLOW_REMOVAL means: NCCF_INCOMING_ONLY or NCCF_ALLOW_REMOVAL or BOTH should be set.
// ~NCCF_INCOMING_ONLY means: One or flag (irrespective of NCCF_INCOMING_ONLY flag) should be set.
// NB_NEGATE_CHAR_MATCH + NCCF_INCOMING_ONLY means: Check that NCCF_INCOMING_ONLY is not set.

const DWORD g_cteCommandMatrixCount = celems(g_cteCommandMatrix);

COMMANDPERMISSIONSENTRY g_cteCommandPermissionsMatrix[] =
{
    { CMIDM_NEW_CONNECTION, NBM_ANY,                  NCCF_ALL,           NB_TOPLEVEL_PERM | NB_REMOVE_IF_NOT_MATCH,NBPERM_NewConnectionWizard,  APPLY_TO_ALL_USERS    },
    { CMIDM_CONNECT,        NBM_ISRASTYPE,            NCCF_ALL,           NB_NO_FLAGS,         NBPERM_RasConnect,           APPLY_TO_ALL_USERS    },
    { CMIDM_CONNECT,        NBM_SHAREDACCESSHOST_RAS, NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Always,               APPLY_TO_ALL_USERS    },

    { CMIDM_DISCONNECT,     NBM_ISRASTYPE,            NCCF_INCOMING_ONLY, NB_NEGATE_CHAR_MATCH,NBPERM_RasConnect,           APPLY_TO_ALL_USERS    },
    { CMIDM_DISCONNECT,     NBM_ISRASTYPE,            NCCF_INCOMING_ONLY, NB_NO_FLAGS,         NBPERM_RasConnect,           APPLY_TO_ADMIN        },
    { CMIDM_DISCONNECT,     NBM_SHAREDACCESSHOST_RAS, NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Always,               APPLY_TO_ALL_USERS    },
    { CMIDM_ENABLE,         NBM_LAN,                  NCCF_ALL,           NB_NO_FLAGS,         NBPERM_LanConnect,           APPLY_TO_ALL_USERS    },

    { CMIDM_ENABLE,         NBM_SHAREDACCESSHOST_LAN, NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Always,               APPLY_TO_ALL_USERS    },
    { CMIDM_ENABLE,         NBM_BRIDGE,               NCCF_ALL,           NB_NO_FLAGS,         NBPERM_AllowNetBridge_NLA,   APPLY_TO_OPS_OR_ADMIN },
    { CMIDM_DISABLE,        NBM_LAN,                  NCCF_ALL,           NB_NO_FLAGS,         NBPERM_LanConnect,           APPLY_TO_ALL_USERS },
    { CMIDM_DISABLE,        NBM_SHAREDACCESSHOST_LAN, NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Always,               APPLY_TO_ALL_USERS    },
    { CMIDM_DISABLE,        NBM_BRIDGE,               NCCF_ALL,           NB_NO_FLAGS,         NBPERM_AllowNetBridge_NLA,   APPLY_TO_OPS_OR_ADMIN },

    { CMIDM_STATUS,         NBM_ANY,                  NCCF_INCOMING_ONLY, NB_NEGATE_CHAR_MATCH,NBPERM_Statistics,           APPLY_TO_ALL_USERS    },
    { CMIDM_STATUS,         NBM_ANY,                  NCCF_INCOMING_ONLY, NB_NO_FLAGS,         NBPERM_Statistics,           APPLY_TO_ADMIN        },

    { CMIDM_CREATE_BRIDGE,  NBM_ANY,                  NCCF_ALL,           NB_NO_FLAGS,         NBPERM_AllowNetBridge_NLA,   APPLY_TO_OPS_OR_ADMIN },
    { CMIDM_ADD_TO_BRIDGE,  NBM_ANY,                  NCCF_ALL,           NB_NO_FLAGS,         NBPERM_AllowNetBridge_NLA,   APPLY_TO_OPS_OR_ADMIN },
    { CMIDM_REMOVE_FROM_BRIDGE,  NBM_ANY,             NCCF_ALL,           NB_NO_FLAGS,         NBPERM_AllowNetBridge_NLA,   APPLY_TO_OPS_OR_ADMIN },

    { CMIDM_CREATE_COPY,    NBM_ANY,                  NCCF_ALL_USERS,     NB_NO_FLAGS,         NBPERM_NewConnectionWizard | NBPERM_RasAllUserProperties,  APPLY_TO_ALL_USERS    },
    { CMIDM_CREATE_COPY,    NBM_ANY,                  NCCF_ALL_USERS,     NB_NEGATE_CHAR_MATCH,NBPERM_NewConnectionWizard, APPLY_TO_ALL_USERS    },

    { CMIDM_FIX,            NBM_ANY,                  NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Repair,               APPLY_TO_POWERUSERSPLUS },

    { CMIDM_DELETE,         NBM_ANY,                  NCCF_ALL_USERS,     NB_NO_FLAGS,         NBPERM_DeleteConnection | NBPERM_DeleteAllUserConnection, APPLY_TO_ALL_USERS    },
    { CMIDM_DELETE,         NBM_ANY,                  NCCF_ALL_USERS,     NB_NEGATE_CHAR_MATCH,NBPERM_DeleteConnection,     APPLY_TO_ALL_USERS    },

    { CMIDM_SET_DEFAULT,    NBM_INCOMING |
                            NBM_ISRASTYPE,            NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Always,               APPLY_TO_OPS_OR_ADMIN     },
    { CMIDM_UNSET_DEFAULT,  NBM_INCOMING |
                            NBM_ISRASTYPE,            NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Always,               APPLY_TO_OPS_OR_ADMIN     },

    { CMIDM_CONMENU_ADVANCED_CONFIG,
                            NBM_ANY,                  NCCF_ALL_USERS,     NB_TOPLEVEL_PERM,    NBPERM_AdvancedSettings,     APPLY_TO_ADMIN        },

    { CMIDM_CONMENU_DIALUP_PREFS,
                            NBM_ANY,                  NCCF_ALL_USERS,     NB_TOPLEVEL_PERM,    NBPERM_DialupPrefs,          APPLY_TO_ALL_USERS    },
    
    { CMIDM_PROPERTIES,     NBM_INCOMING,             NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Always,               APPLY_TO_ADMIN        },
    { CMIDM_PROPERTIES,     NBM_ISRASTYPE,            NCCF_ALL_USERS,     NB_NEGATE_CHAR_MATCH,NBPERM_RasMyProperties,      APPLY_TO_ALL_USERS    },
    { CMIDM_PROPERTIES,     NBM_ISRASTYPE,            NCCF_ALL_USERS,     NB_NO_FLAGS,         NBPERM_RasAllUserProperties, APPLY_TO_ALL_USERS    },
    { CMIDM_PROPERTIES,     NBM_LAN,                  NCCF_ALL,           NB_NO_FLAGS,         NBPERM_LanProperties,        APPLY_TO_ALL_USERS    }
};

const DWORD g_cteCommandPermissionsMatrixCount = celems(g_cteCommandPermissionsMatrix);

SFVCOMMANDMAP g_cteSFVCommandMap[] =
{
    { SFVIDM_FILE_DELETE,       CMIDM_DELETE},
    { SFVIDM_FILE_LINK,         CMIDM_CREATE_SHORTCUT},
    { SFVIDM_FILE_PROPERTIES,   CMIDM_PROPERTIES},
    { SFVIDM_FILE_RENAME,       CMIDM_RENAME}
};

const DWORD g_cteSFVCommandMapCount = celems(g_cteSFVCommandMap);

CMDCHKENTRY  g_cceFolderChecks[] =
{
    // command id
    //                                  currently checked
    //                                   |      new check state
    //                                   |       |
    //                                   v       v
    { CMIDM_CONMENU_OPERATOR_ASSIST,    false,  false }
};

const DWORD g_nFolderCheckCount = celems(g_cceFolderChecks);

inline DWORD dwNegateIf(DWORD dwInput, DWORD dwFlags, DWORD dwNegateCondition)
{
    if (dwFlags & dwNegateCondition)
    {
        return ~dwInput;
    }
    else
    {
        return dwInput;
    }
}

inline BOOL bContains(DWORD dwContainee, DWORD dwContainer, DWORD dwFlags, DWORD dwContaineeNegateCondition, DWORD dwContainerNegateCondition)
{
    dwContainer = dwNegateIf(dwContainer, dwFlags, dwContainerNegateCondition);
    dwContainee = dwNegateIf(dwContainee, dwFlags, dwContaineeNegateCondition);

    if ( (dwContainee & dwContainer) != dwContainee)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     HrAssertIntegrityAgainstOldMatrix
//
//  Purpose:    Asserts the internal integrity of the Command Matrix
//              Currently checks for:
//                1. No duplicate CMDIDs
//                2. Each NCWHEN flag at least specified NCWHEN_ONESELECT
//
//  Arguments:
//      none
//
//  Returns:
//              S_OK is succeeded
//              E_FAIL if not
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:      Asserts on failure
//
HRESULT HrAssertCommandMatrixIntegrity()
{
    TraceFileFunc(ttidMenus);

    HRESULT hr = S_OK;

    LPSTR szErr = new CHAR[TRACESTRLEN];
    for (DWORD x = 0; x < g_cteCommandMatrixCount; x++)
    {
        // Check that there isn't another entry with the same CommandID and Media Type.
        const COMMANDENTRY& cte = g_cteCommandMatrix[x];
        if (CMIDM_SEPARATOR == cte.iCommandId)
        {
            continue;
        }

        for (DWORD y = x + 1; y < g_cteCommandMatrixCount; y++)
        {
            const COMMANDENTRY& ctecmp = g_cteCommandMatrix[y];
            if (cte.iCommandId == ctecmp.iCommandId)
            {
                sprintf(szErr, "Multiple lines (%d and %d) in the COMMANDENTRY table describe the same CmdID", x+1, y+1);
                AssertSz(FALSE, szErr);
                hr = E_FAIL;
            }
        }

        if ( !bContains(cte.dwCharacteristicsActive, cte.dwCharacteristicsVisible, cte.dwFlags, NB_NEGATE_ACT_CHAR_MATCH, NB_NEGATE_VIS_CHAR_MATCH) )
        {
            sprintf(szErr, "Row %d. ACTIVE flags not a subset of VISIBLE flags for Characteristics? ", x+1);
            AssertSz(FALSE, szErr);
            hr = E_FAIL;
        }

        if ( !bContains(cte.dwStatusActive, cte.dwStatusVisible, cte.dwFlags, NB_NEGATE_ACT_NBS_MATCH, NB_NEGATE_VIS_NBS_MATCH) )
        {
            sprintf(szErr, "Row %d. ACTIVE flags not a subset of VISIBLE flags for Status... did you use NCS_ instead of NBM_? ", x+1);
            AssertSz(FALSE, szErr);
            hr = E_FAIL;
        }

        if ( !bContains(cte.dwMediaTypeActive, cte.dwMediaTypeVisible, cte.dwFlags, NB_NEGATE_ACT_NBM_MATCH, NB_NEGATE_VIS_NBM_MATCH) )
        {
            sprintf(szErr, "Row %d. ACTIVE flags not a subset of VISIBLE flags for MediaType... did you use NCM_ instead of NBM_? ", x+1);
            AssertSz(FALSE, szErr);
            hr = E_FAIL;
        }
    }

    // Assert the permissions table
    for (x = 0; x < g_cteCommandPermissionsMatrixCount; x++)
    {
        const COMMANDPERMISSIONSENTRY cpe = g_cteCommandPermissionsMatrix[x];

        // Check that each CMD entry has a corresponding entry in the Command Table
        BOOL bFound = FALSE;
        for (DWORD y = 0; y < g_cteCommandMatrixCount; y++)
        {
            const COMMANDENTRY& ctecmp = g_cteCommandMatrix[y];

            if (cpe.iCommandId == ctecmp.iCommandId)
            {
                bFound = TRUE;
                if ( (cpe.dwMediaType != NBM_ANY) &&
                     ((cpe.dwMediaType & ctecmp.dwMediaTypeActive) != cpe.dwMediaType) )
                {
                    sprintf(szErr, "A permission has been specified in the Permissions table (row %d) for a MediaType that is not active in the Command Table (row %d)... did you use NCM_ instead of NBM_?", x+1, y+1);
                    AssertSz(FALSE, szErr);
                    hr = E_FAIL;
                }
//                if ( (cpe.dwCharacteristicsActive != NCCF_ALL) &&
//                     ((cpe.dwCharacteristicsActive & ctecmp.dwCharacteristicsActive) != cpe.dwCharacteristicsActive) )
//                {
//                    sprintf(szErr, "A permission has been specified in the Permissions table (row %d) for a Characteristics that is not active in the Command Table (row %d)", x+1, y+1);
//                    AssertSz(FALSE, szErr);
//                    hr = E_FAIL;
//                }
            }
        }

        if (!bFound)
        {
            sprintf(szErr, "An entry has been found in the Permissions table (row %d) without a corresponding CMDID entry in the Command Table", x+1);
            AssertSz(FALSE, szErr);
            hr = E_FAIL;
        }

        // Check that no CmdId/MediaType/Characteristics has been duplicated
        for (y = x + 1; y < g_cteCommandPermissionsMatrixCount; y++)
        {
            const COMMANDPERMISSIONSENTRY& cpecmp = g_cteCommandPermissionsMatrix[y];
            if ( (cpe.iCommandId == cpecmp.iCommandId) &&
                 (dwNegateIf(cpe.dwMediaType, cpe.dwFlags, NB_NEGATE_NBM_MATCH) &
                   dwNegateIf(cpecmp.dwMediaType, cpecmp.dwFlags, NB_NEGATE_NBM_MATCH)) &&
                 (dwNegateIf(cpe.dwCharacteristicsActive, cpe.dwFlags, NB_NEGATE_CHAR_MATCH) &
                   dwNegateIf(cpecmp.dwCharacteristicsActive, cpecmp.dwFlags, NB_NEGATE_CHAR_MATCH)) )
            {
                sprintf(szErr, "Multiple lines (%d and %d) in the COMMANDENTRY table describe the same CmdID/MediaType/Characteristics combo", x+1, y+1);
                AssertSz(FALSE, szErr);
                hr = E_FAIL;
            }
        }

        if (! ((APPLY_TO_NETCONFIGOPS & cpe.ncpAppliesTo) ||
               (APPLY_TO_USER & cpe.ncpAppliesTo) ||
               (APPLY_TO_ADMIN & cpe.ncpAppliesTo) || 
               (APPLY_TO_POWERUSERS & cpe.ncpAppliesTo) ))
        {
            sprintf(szErr, "Lines (%d) in the Permissionstable - permissions must apply to someone", x+1);
            AssertSz(FALSE, szErr);
            hr = E_FAIL;
        }

        // !!(A & B) != !!(A & C) means: If either B or C is set in A, both B and C must be set (or neither). I hope...
        // kill me... kill me now.
        if ((!!(cpe.dwFlags & NB_NEGATE_VIS_NBM_MATCH)   != !!(cpe.dwFlags & NB_NEGATE_ACT_NBM_MATCH)) ||
            (!!(cpe.dwFlags & NB_NEGATE_VIS_NBS_MATCH)   != !!(cpe.dwFlags & NB_NEGATE_ACT_NBS_MATCH)) ||
            (!!(cpe.dwFlags & NB_NEGATE_VIS_CHAR_MATCH)  != !!(cpe.dwFlags & NB_NEGATE_ACT_CHAR_MATCH)) ||
            (!!(cpe.dwFlags & NB_NEGATE_VIS_PERMS_MATCH) != !!(cpe.dwFlags & NB_NEGATE_ACT_PERMS_MATCH)) )
        {
            sprintf(szErr, "Lines (%d) in the Permissionstable should use NB_NEGATE_xxx instead of NB_NEGATE_VIS_xxx or NB_NEGATE_ACT_xxx ", x+1);
            AssertSz(FALSE, szErr);
            hr = E_FAIL;
        }
    }

    delete[] szErr;
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrAssertMenuStructuresValid
//
//  Purpose:    Runs various asserts to make sure the menu structures are intact
//              Called on NetShell startup
//
//  Arguments:
//      [in] hwndOwner    Owner window
//
//  Returns:
//              S_OK is succeeded
//              E_FAIL if not
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:      Asserts on failure
//
HRESULT HrAssertMenuStructuresValid(HWND hwndOwner)
{
#ifdef DBG
    static fBeenHereDoneThat = FALSE;

    if (fBeenHereDoneThat)
    {
        return S_OK;
    }
    else
    {
        fBeenHereDoneThat = TRUE;
    }

    TraceFileFunc(ttidMenus);

    HRESULT hr;
    hr = HrAssertCommandMatrixIntegrity();

    return hr;
#else
    return S_OK;
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     AdjustNCCS
//
//  Purpose:    Up-adjusts an NCCS_STATE flag. Will move ENABLED to DISABLED,
//              and DISABLED to REMOVE but not backwards.
//
//  Arguments:
//     [in out] nccsCurrent    NCCS to be adjusted
//     [in]     nccsNew        New state
//
//  Returns:
//     none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
inline void AdjustNCCS(OUT IN NCCS_STATE& nccsCurrent, IN NCCS_STATE nccsNew)
{
    if (nccsNew > nccsCurrent)
    {
        nccsCurrent = nccsNew;
    }
}

inline BOOL fMatchFlags(IN DWORD dwFlagsMask, IN DWORD dwFlagsTest, IN DWORD dwNegateFlagMask, IN DWORD dwNegateFlagTest)
{
    bool bMatch = FALSE;

    if ( (0xffffffff == dwFlagsTest) || // Means always succeed.
         (dwFlagsMask & dwFlagsTest) )
    {
        bMatch = TRUE;
    }
    else
    {
        bMatch = FALSE;
    }

    if ( (dwNegateFlagMask & dwNegateFlagTest) == dwNegateFlagTest) // Do a negative compare
    {
        return !bMatch;
    }
    else
    {
        return bMatch;
    }
}
//+---------------------------------------------------------------------------
//
//  Member:     HrGetCommandStateFromCMDTABLEEntry
//
//  Purpose:    Get the command state for a given Connection Folder Entry,
//              given the Command Table Entry entry that should be used.
//
//  Arguments:
//     [in]  cfe            Connection Folder Entry
//     [in]  cte            Command Table Entry
//     [in]  fMultiSelect   Was this part of a multi-selection?
//     [out] nccs           State that the item should be (NCCS_ENABLED/NCCS_DISABLED/NCCS_NOTSHOWN)
//
//  Returns:
//     none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes: This function uses Cached Permissions. YOU MUST CALL RefreshAllPermission before calling this function.
//
HRESULT HrGetCommandStateFromCMDTABLEEntry(IN const CConFoldEntry& cfe, IN const COMMANDENTRY& cte, IN BOOL fMultiSelect, OUT NCCS_STATE& nccs, OUT LPDWORD pdwResourceId)
{
    TraceFileFunc(ttidMenus);

    Assert(pdwResourceId);

    HRESULT hr = S_OK;
    nccs       = NCCS_ENABLED;

    DWORD dwNCMbm = (1 << cfe.GetNetConMediaType());        // Convert to bitmask

    // If we're a wizard, add as Wizard media type.
    if (cfe.GetWizard() == WIZARD_MNC)
    {
        dwNCMbm |= NBM_MNC_WIZARD;
        dwNCMbm &= ~NBM_INCOMING;    // clear the INCOMINGCONNECTIONS flag (old NCM_NONE) if we're a wizard.
    }
    else if (cfe.GetWizard() == WIZARD_HNW)
    {
        dwNCMbm |= NBM_HNW_WIZARD;
        dwNCMbm &= ~NBM_INCOMING;    // clear the INCOMINGCONNECTIONS flag (old NCM_NONE) if we're a wizard.
    }

    DWORD dwNCSbm = (1 << cfe.GetNetConStatus());           // Convert to bitmask
    DWORD dwNCCF  = cfe.GetCharacteristics();               // Already a bitmask

    // Check if the command can participate in multi-select
    if ( fMultiSelect &&
        !(cte.dwValidWhen & NCWHEN_MULTISELECT) )
    {
        AdjustNCCS(nccs, NCCS_DISABLED);
    }

    // Check if the command should be visible
    if (!((fMatchFlags(dwNCMbm, cte.dwMediaTypeVisible,      cte.dwFlags, NB_NEGATE_VIS_NBM_MATCH)) &&
          (fMatchFlags(dwNCSbm, cte.dwStatusVisible,         cte.dwFlags, NB_NEGATE_VIS_NBS_MATCH)) &&
          (fMatchFlags(dwNCCF , cte.dwCharacteristicsVisible,cte.dwFlags, NB_NEGATE_VIS_CHAR_MATCH)) ))
    {
        AdjustNCCS(nccs, NCCS_NOTSHOWN);
    }

    // Check if the command should be grayed out
    if (!((fMatchFlags(dwNCMbm, cte.dwMediaTypeActive,       cte.dwFlags, NB_NEGATE_ACT_NBM_MATCH)) &&
          (fMatchFlags(dwNCSbm, cte.dwStatusActive,          cte.dwFlags, NB_NEGATE_ACT_NBS_MATCH)) &&
          (fMatchFlags(dwNCCF , cte.dwCharacteristicsActive, cte.dwFlags, NB_NEGATE_ACT_CHAR_MATCH)) ))
    {
        AdjustNCCS(nccs, NCCS_DISABLED);
    }

    // Check if the command should be grayed out based on permissions
    for (DWORD x = 0; nccs == NCCS_ENABLED, x < g_cteCommandPermissionsMatrixCount; x++)// Permissions won't affect NOT_SHOWN or DISABLED
    {
        const COMMANDPERMISSIONSENTRY cpe = g_cteCommandPermissionsMatrix[x];

        if ( (cpe.iCommandId == cte.iCommandId) &&
             (fMatchFlags(dwNCMbm, cpe.dwMediaType, cpe.dwFlags, NB_NEGATE_NBM_MATCH)) &&
             (fMatchFlags(dwNCCF,  cpe.dwCharacteristicsActive, cpe.dwFlags, NB_NEGATE_CHAR_MATCH)) )
        {
            for (DWORD dwPerm = 0; dwPerm < sizeof(DWORD)*8; dwPerm++)
            {
                if (cpe.dwPermissionsActive & (1 << static_cast<DWORD64>(dwPerm)) )
                {
                    if (!FHasPermissionFromCache(dwPerm))
                    {
                        if (cpe.dwFlags & NB_REMOVE_IF_NOT_MATCH)
                        {
                            AdjustNCCS(nccs, NCCS_NOTSHOWN);
                        }
                        else
                        {
                            AdjustNCCS(nccs, NCCS_DISABLED);
                        }
                        break; // will break anyway.
                    }
                }
            }

            if (APPLY_TO_USER & cpe.ncpAppliesTo)
            {
                break;
            }

            if ( (APPLY_TO_POWERUSERS & cpe.ncpAppliesTo) && FIsUserPowerUser() )
            {
                break;
            }

            if ( (APPLY_TO_NETCONFIGOPS & cpe.ncpAppliesTo) && FIsUserNetworkConfigOps() )
            {
                break;
            }

            if ( (APPLY_TO_ADMIN & cpe.ncpAppliesTo) && FIsUserAdmin())
            {
                break;
            }

            // At this point all group access checks failed, so disable the connection.
            AdjustNCCS(nccs, NCCS_DISABLED);
            break;
        }
    }

    // Check for callback
    if ( (nccs != NCCS_NOTSHOWN) &&
         (cte.pfnHrEnableDisableCB) )
    {
        HRESULT hrTmp;
        NCCS_STATE nccsTemp;
        hrTmp = (*cte.pfnHrEnableDisableCB)(cfe, fMultiSelect, cte.iCommandId, nccsTemp);
        if (S_OK == hrTmp)
        {
            AdjustNCCS(nccs, nccsTemp);
        }
        else
        {
            if (FAILED(hrTmp))
            {
                AdjustNCCS(nccs, NCCS_NOTSHOWN);
            }
        } // If the function returns S_FALSE it's an indication it didn't change the state.
    }

    // Check for Resource String callback:
    if ( (nccs != NCCS_NOTSHOWN) && // What's the point?
         (0 == *pdwResourceId) && // Must not already have a resource Id
         (cte.pfnHrCustomMenuStringCB) )
    {
        HRESULT hrTmp;
        DWORD dwResourceIdTmp = *pdwResourceId;
        hrTmp = (*cte.pfnHrCustomMenuStringCB)(cfe, cte.iCommandId, &dwResourceIdTmp);
        if (S_OK == hr)
        {
            *pdwResourceId = dwResourceIdTmp;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrGetCommandState
//
//  Purpose:    Get the command state for a given Connection Folder Entry,
//              given the Command ID.
//
//  Arguments:
//     [in]  cfpl           List (0 or more) of PIDLs that are selected
//     [in]  dwCmdID        Command ID
//     [out] nccs           State that the item should be (NCCS_ENABLED/NCCS_DISABLED/NCCS_NOTSHOWN)
//
//  Returns:
//     none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
HRESULT HrGetCommandState(IN const PCONFOLDPIDLVEC& cfpl, IN const DWORD dwCmdID, OUT NCCS_STATE& nccs, OUT LPDWORD pdwResourceId, IN DWORD cteHint, IN DWORD dwOverrideFlag)
{
    TraceFileFunc(ttidMenus);

    Assert(pdwResourceId);
    if (!pdwResourceId)
    {
        return E_POINTER;
    }

    RefreshAllPermission();

    HRESULT hr = S_OK;
    BOOL bFound = FALSE;
    DWORD dwNumItems = cfpl.size();
    *pdwResourceId = 0;

    if ( dwOverrideFlag & NB_FLAG_ON_TOPMENU )
    {
        for (DWORD x = 0; x < g_cteCommandMatrixCount; x++)
        {
            if ( (g_cteCommandMatrix[x].iCommandId == dwCmdID) )
            {
                bFound = TRUE;

                const COMMANDENTRY& cte = g_cteCommandMatrix[x];
                if ((cte.dwValidWhen == NCWHEN_TOPLEVEL) ||         // Toplevel-ONLY menu (doesn't matter if items).
                    ((cte.dwValidWhen & NCWHEN_TOPLEVEL) &&
                            (!dwNumItems || (cte.dwValidWhen & NCWHEN_TOPLEVEL_DISREGARD_ITEM)) ) )
                {                                                  // Must be marked to allow incompatible selection,
                    nccs = NCCS_ENABLED;                           // Otherwise, we'll do the item check (below).

                    // Check for permissions
                    for (DWORD x = 0; nccs == NCCS_ENABLED, x < g_cteCommandPermissionsMatrixCount; x++)// Permissions won't affect NOT_SHOWN or DISABLED
                    {
                        const COMMANDPERMISSIONSENTRY cpe = g_cteCommandPermissionsMatrix[x];

                        if ( (cpe.iCommandId == cte.iCommandId) &&
                             (cpe.dwFlags & NB_TOPLEVEL_PERM) )
                        {
                            for (DWORD dwPerm = 0; dwPerm < sizeof(DWORD)*8; dwPerm++)
                            {
                                if (cpe.dwPermissionsActive & (1 << static_cast<DWORD64>(dwPerm)) )
                                {
                                    if (!FHasPermissionFromCache(dwPerm))
                                    {
                                        if (cpe.dwFlags & NB_REMOVE_IF_NOT_MATCH)
                                        {
                                            AdjustNCCS(nccs, NCCS_NOTSHOWN);
                                        }
                                        else
                                        {
                                            AdjustNCCS(nccs, NCCS_DISABLED);
                                        }
                                        break; // will break anyway.
                                    }
                                }
                            }

                            if (APPLY_TO_USER & cpe.ncpAppliesTo)
                            {
                                break;
                            }

                            if ( (APPLY_TO_NETCONFIGOPS & cpe.ncpAppliesTo) && FIsUserNetworkConfigOps() )
                            {
                                break;
                            }

                            if ( (APPLY_TO_ADMIN & cpe.ncpAppliesTo) && FIsUserAdmin())
                            {
                                break;
                            }

                            // At this point all group access checks failed, so disable the connection.
                            AdjustNCCS(nccs, NCCS_DISABLED);
                            break;
                        }
                    }


                    // Check for callback
                    if (cte.pfnHrEnableDisableCB)
                    {
                        HRESULT hrTmp;
                        NCCS_STATE nccsTemp;
                        CONFOLDENTRY cfe;
                        cfe.clear();

                        if (dwNumItems > 0)
                        {
                            hrTmp = cfpl[0].ConvertToConFoldEntry(cfe);
                            if (FAILED(hrTmp))
                            {
                                cfe.clear();
                            }
                        }
                        
                        hrTmp = (*cte.pfnHrEnableDisableCB)(cfe, dwNumItems > 1, cte.iCommandId, nccsTemp);
                        if (S_OK == hrTmp)
                        {
                            AdjustNCCS(nccs, nccsTemp);
                        }
                        else
                        {
                            if (FAILED(hrTmp))
                            {
                                AdjustNCCS(nccs, NCCS_NOTSHOWN);
                            }
                        } // If the function returns S_FALSE it's an indication it didn't change the state.
                    }

                    if (!(NB_REMOVE_TOPLEVEL_ITEM & cte.dwFlags))
                    {
                        if (nccs == NCCS_NOTSHOWN)
                        {
                            nccs = NCCS_DISABLED;
                        }
                    }

                    return S_OK;
                }

                break; // we won't find another CMDID
            }
        }

        if (!dwNumItems)
        {
            nccs = NCCS_DISABLED;
            if (bFound)
            {
                return S_OK;
            }
            else
            {
                return E_FILE_NOT_FOUND;
            }
        }
    }

    AssertSz(dwNumItems, "You don't have any items selected, but you're not a top-level menu... how come?");

    bFound = FALSE;
    nccs   = NCCS_ENABLED;

    // This will effectively loop through all the selected PIDLs and apply the strictest
    // nccs that applies to everything.

    for (PCONFOLDPIDLVEC::const_iterator cfp = cfpl.begin(); cfp != cfpl.end(); cfp++)
    {
        CONFOLDENTRY cfe;
        hr = cfp->ConvertToConFoldEntry(cfe);
        if (FAILED(hr))
        {
            return E_FAIL;
        }

        DWORD dwPos  = 0xffffffff;

        // This is a O(n^(2+)) algorithm when called from HrBuildMenu.
        // We pass a hint to check if we can quickly find the cte.
        if ( (cteHint != 0xffffffff) &&
             (g_cteCommandMatrix[cteHint].iCommandId == dwCmdID) )
        {
            dwPos  = cteHint;
        }

        if (dwPos == 0xffffffff)
        {
            for (DWORD x = 0; x < g_cteCommandMatrixCount && SUCCEEDED(hr); x++)
            {
                if (g_cteCommandMatrix[x].iCommandId == dwCmdID)
                {
                    dwPos = x;
                    break;
                }
            }
        }

        if (dwPos == 0xffffffff)
        {
            return E_FILE_NOT_FOUND;
        }
        else
        {
            bFound = TRUE;

            NCCS_STATE nccsTmp;
            hr = HrGetCommandStateFromCMDTABLEEntry(cfe, g_cteCommandMatrix[dwPos], dwNumItems != 1, nccsTmp, pdwResourceId);
            if (FAILED(hr))
            {
                return hr;
            }

            AdjustNCCS(nccs, nccsTmp);
    
            if ( (dwOverrideFlag & NB_FLAG_ON_TOPMENU) &&
                 (!(NB_REMOVE_TOPLEVEL_ITEM & g_cteCommandMatrix[dwPos].dwFlags)) &&                    
                 (nccs == NCCS_NOTSHOWN) )
            {
                nccs = NCCS_DISABLED;
            }
        }
    }

    if (!bFound)
    {
        return E_FILE_NOT_FOUND;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrGetCheckState
//
//  Purpose:    Get the check state for a given Connection Folder Entry,
//              given the Command ID.
//
//  Arguments:
//     [in]  cfpl           List (0 or more) of PIDLs that are selected
//     [in]  dwCmdID        Command ID
//     [out] nccs           State that the item should be (NCCS_CHECKED/NCCS_UNCHECKED)
//
//  Returns:
//     HRESULT
//
//  Author:     deonb   7 Mar 2001
//
//  Notes:
//
HRESULT HrGetCheckState(IN const PCONFOLDPIDLVEC& cfpl, IN const DWORD dwCmdID, OUT NCCS_CHECKED_STATE& nccs)
{
    HRESULT hr = S_FALSE;
    DWORD   dwLoop  = 0;

    nccs = NCCS_UNCHECKED;

    for (; dwLoop < g_nFolderCheckCount; dwLoop++)
    {
        if (dwCmdID == g_cceFolderChecks[dwLoop].iCommandId)
        {
            switch(g_cceFolderChecks[dwLoop].iCommandId)
            {
                case CMIDM_CONMENU_OPERATOR_ASSIST:
                    hr = S_OK;
                    if (g_fOperatorAssistEnabled)
                    {
                        nccs = NCCS_CHECKED;
                    }
                    break;
                default:
                    break;
            }
        }
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     NCCMDFromSFV
//
//  Purpose:    Return a NetShell CMDID for Shell Internal IDs
//
//  Arguments:
//     [in]     iCmdID     CMDID to map
//
//  Returns:
//     Returns iCmdID if not shell message, or a iCmdID mapping
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
int NCCMDFromSFV(int iCmdID, DWORD idCmdFirst)
{
    for (int x = 0; x < g_cteSFVCommandMapCount; x++)
    {
        if (g_cteSFVCommandMap[x].iSFVCommandId == iCmdID)
        {
            return g_cteSFVCommandMap[x].iCommandId + idCmdFirst;
        }
    }
    return iCmdID;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUpdateMenuItemChecks
//
//  Purpose:    Walk through the list of checkmark-able commands and check if
//              applicable.
//
//  Arguments:
//      None
//
//  Returns:
//
//  Author:     deonb   7 Mar 2001
//
//  Notes:
//
HRESULT HrUpdateMenuItemChecks(IN PCONFOLDPIDLVEC& cfpl, IN OUT HMENU hMenu, IN DWORD idCmdFirst)
{
    HRESULT hr = S_FALSE;
    DWORD   dwLoop  = 0;

    Assert(hMenu)
    if (!hMenu)
    {
        return E_INVALIDARG;
    }

    int cMenuItems = GetMenuItemCount(hMenu);

    for (int x = 0; x < cMenuItems; x++)
    {
        UINT nMenuID = GetMenuItemID(hMenu, x);

        NCCS_CHECKED_STATE nccs;
        DWORD dwCustomResourceId = 0;
        DWORD dwCmdId = NCCMDFromSFV(nMenuID, idCmdFirst) - idCmdFirst;

        hr = HrGetCheckState(cfpl, dwCmdId, nccs);
        if (S_OK == hr) // don't need to set if not supported on this item (S_FALSE)
        {
             CheckMenuItem(
                hMenu,
                x,
                nccs == NCCS_CHECKED ?
                MF_CHECKED | MF_BYPOSITION :     // checked
                MF_UNCHECKED | MF_BYPOSITION);   // unchecked
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrBuildMenu
//
//  Purpose:    Build the context menu for for a given Connection Folder Entry..
//
//  Arguments:
//     [in out] hMenu       Handle to menu which is to be updated
//     [in]     fVerbsOnly  Should return Verbs only (shortcuts)
//     [in]     cfpl        List (0 or more) of PIDLs that are selected
//     [in]     idCmdFirst  Min value the handler can specify for a menu item
//
//  Returns:
//     none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
HRESULT HrBuildMenu(IN OUT HMENU &hMenu, IN BOOL fVerbsOnly, IN PCONFOLDPIDLVEC& cfpl, IN DWORD idCmdFirst)
{
    TraceFileFunc(ttidMenus);

    HRESULT hr = S_OK;

    Assert(hMenu)
    if (!hMenu)
    {
        return E_INVALIDARG;
    }

    DWORD dwCurrentDefaultPriority = 0;

    BOOL fShouldAppendSeparator = FALSE;
    DWORD dwInsertPos = 1;
    for (DWORD x = 0; x < g_cteCommandMatrixCount && SUCCEEDED(hr); x++)
    {
        const COMMANDENTRY& cte = g_cteCommandMatrix[x];

        if ( (fVerbsOnly) && !(cte.dwFlags & NB_VERB) )
        {
            continue;
        }

        if (CMIDM_SEPARATOR == cte.iCommandId)
        {
            fShouldAppendSeparator = TRUE;
        }
        else
        {
            NCCS_STATE nccs;
            DWORD dwCustomResourceId = 0;

            hr = HrGetCommandState(cfpl, cte.iCommandId, nccs, &dwCustomResourceId, x);
            if (SUCCEEDED(hr))
            {
                if ( nccs != NCCS_NOTSHOWN )
                {
                    if (fShouldAppendSeparator)
                    {
                        fShouldAppendSeparator = FALSE;
                        if (!InsertMenu(hMenu, dwInsertPos++, MF_BYPOSITION | MF_SEPARATOR, CMIDM_SEPARATOR, NULL))
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                    }

                    LPCWSTR szMenuString;
                    if (!dwCustomResourceId)
                    {
                        szMenuString = SzLoadIds(IDS_MENU_CMIDM_START + cte.iCommandId - CMIDM_FIRST);
                    }
                    else
                    {
                        szMenuString = SzLoadIds(dwCustomResourceId);
                    }

                    if (!InsertMenu(hMenu, dwInsertPos++, MF_BYPOSITION | MF_STRING | (nccs == NCCS_DISABLED ? MF_GRAYED : MF_ENABLED), idCmdFirst + cte.iCommandId - CMIDM_FIRST, szMenuString))
                    {
                        AssertSz(FALSE, "Couldn't append menu item");
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    else
                    {
                        if ( (nccs == NCCS_ENABLED) &&
                             (cte.dwDefaultPriority > dwCurrentDefaultPriority) ) // Not 0 is implied.
                        {
                            dwCurrentDefaultPriority = cte.dwDefaultPriority;
                            if (!SetMenuDefaultItem(hMenu, idCmdFirst + cte.iCommandId - CMIDM_FIRST, FALSE))
                            {
                                AssertSz(FALSE, "Couldn't set default menu item");
                                hr = HRESULT_FROM_WIN32(GetLastError());
                            }
                        }
                    }
                }
            }
            else
            {
                if (E_FILE_NOT_FOUND == hr)
                {
                    AssertSz(FALSE, "Didn't find the CMDID inside CMDTABLE");
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = HrUpdateMenuItemChecks(cfpl, hMenu, idCmdFirst);
        if (S_FALSE == hr)
        {
            hr = S_OK;
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     HrUpdateMenu
//
//  Purpose:    Update a menu for for a given Connection Folder Entry..
//
//  Arguments:
//     [in out] hMenu       Handle to menu which is to be updated
//     [in]     cfpl        List (0 or more) of PIDLs that are selected
//     [in]     idCmdFirst  Min value the handler can specify for a menu item
//
//  Returns:
//     none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
HRESULT HrUpdateMenu(IN OUT HMENU &hMenu, IN PCONFOLDPIDLVEC& cfpl, IN DWORD idCmdFirst)
{
    TraceFileFunc(ttidMenus);

    HRESULT hr = S_OK;

    Assert(hMenu)
    if (!hMenu)
    {
        return E_INVALIDARG;
    }

    int cMenuItems = GetMenuItemCount(hMenu);

    for (int x = 0; x < cMenuItems; x++)
    {
        UINT nMenuID = GetMenuItemID(hMenu, x);
//        UINT uiState = GetMenuState(hMenu, nMenuID, MF_BYCOMMAND );

        NCCS_STATE nccs;
        DWORD dwCustomResourceId = 0;
        DWORD dwCmdId = NCCMDFromSFV(nMenuID, idCmdFirst) - idCmdFirst;

        hr = HrGetCommandState(cfpl, dwCmdId, nccs, &dwCustomResourceId, 0xffffffff, NB_FLAG_ON_TOPMENU);
        if (SUCCEEDED(hr))
        {
            if (nccs == NCCS_NOTSHOWN)
            {
#ifdef DBG
                WCHAR szTemp[MAX_PATH];
                GetMenuStringW(hMenu, x, szTemp, MAX_PATH, MF_BYPOSITION );
                TraceTag(ttidMenus, "Received request to permanently remove menu item: '%S' for CMDID: %d MenuID: %d", szTemp, dwCmdId, nMenuID);
#endif
                RemoveMenu(hMenu, x, MF_BYPOSITION);
            }
            else
            {
                EnableMenuItem(
                     hMenu,
                     x,
                     nccs == NCCS_ENABLED ?
                     MF_ENABLED | MF_BYPOSITION:     // enable
                     MF_GRAYED | MF_BYPOSITION);   
            }
        }

        NCCS_CHECKED_STATE nccCheckedState;
        hr = HrGetCheckState(cfpl, dwCmdId, nccCheckedState);
        if (S_OK == hr) // don't need to set if not supported on this item (S_FALSE)
        {
             CheckMenuItem(
                hMenu,
                x,
                nccCheckedState == NCCS_CHECKED ?
                MF_CHECKED | MF_BYPOSITION :     // checked
                MF_UNCHECKED | MF_BYPOSITION);   // unchecked
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HasPermissionToRenameConnection
//
//  Purpose:    Checks if the Thread Local user has access to rename a given
//              connection
//
//  Arguments:
//     [in] pcfp     PIDL that wants to be renamed
//
//  Returns:
//     TRUE    if has permissions
//     FALSE   if no permissions
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//  ISSUE: Move out of this file
//
BOOL HasPermissionToRenameConnection(const PCONFOLDPIDL& pcfp)
{
    TraceFileFunc(ttidMenus);

    BOOL fPermission = FALSE;

    // ISSUE: Due to a clarification in the spec this code is unreasonably complex.
    // If possible clean it up in the future.

    if (((!(pcfp->dwCharacteristics & NCCF_ALL_USERS) &&
        FHasPermissionFromCache(NCPERM_RenameMyRasConnection))))
    {
        fPermission = TRUE;
    }
    else if (FIsPolicyConfigured(NCPERM_RenameConnection))
    {
        if (((!(pcfp->dwCharacteristics & NCCF_ALL_USERS) &&
            FHasPermissionFromCache(NCPERM_RenameMyRasConnection))))
        {
            fPermission = TRUE;
        }
        else if ((pcfp->ncm != NCM_LAN) && (pcfp->dwCharacteristics & NCCF_ALL_USERS) &&
                FHasPermissionFromCache(NCPERM_RenameConnection) ||
                (pcfp->ncm == NCM_LAN) && FHasPermissionFromCache(NCPERM_RenameConnection))
        {
            fPermission = TRUE;
        }
    }
    else if (((pcfp->ncm == NCM_LAN) && FHasPermissionFromCache(NCPERM_RenameLanConnection))
        || ((pcfp->ncm != NCM_LAN) && (pcfp->dwCharacteristics & NCCF_ALL_USERS) &&
        FHasPermissionFromCache(NCPERM_RenameAllUserRasConnection)))
    {
        fPermission = TRUE;
    }

    return fPermission;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetConnectMenuItem
//
//  Purpose:    This function goes in and modifies the first menu item so
//              that it shows the correct test based on the connection
//              state (enabled or not) or the connection type (LAN / WAN).
//
//  Arguments:
//      hmenu         [in]  Menu to operate on
//      bLan          [in]  Whether or not this is a LAN connection
//      idCmdFirst    [in]  Are commands are really an offset to this value
//      bEnable       [in]  If the connection is enabled or not
//
//  Returns:
//
//  Author:     mbend   8 Mar 2000
//
//  Notes:
//
VOID SetConnectMenuItem(
                        HMENU   hmenu,
                        BOOL    bLan,
                        INT     idCmdFirst,
                        BOOL    bEnable)
{
    // Different strings for WAN/LAN
    INT             iEnableString   =
        bLan ? IDS_DISABLE_MENUITEM : IDS_DISCONNECT_MENUITEM;
    INT             iDisableString  =
        bLan ? IDS_ENABLE_MENUITEM : IDS_CONNECT_MENUITEM;
    INT             iMenuString     =
        bEnable ? iEnableString : iDisableString;
    PCWSTR          pszMenuString   = SzLoadIds(iMenuString);
    MENUITEMINFO    mii;
    // Different commands for WAN/LAN
    INT             iConnect        = bLan ? CMIDM_ENABLE : CMIDM_CONNECT;
    INT             iDisconnect     = bLan ? CMIDM_DISABLE : CMIDM_DISCONNECT;
    INT             iOffset         = bEnable ? iDisconnect : iConnect;
    INT             iNewCommand     = idCmdFirst + iOffset;

    Assert(pszMenuString);

    // Set the menuitem fields
    //
    mii.cbSize      = sizeof(MENUITEMINFO);
    mii.fMask       = MIIM_TYPE | MIIM_ID;
    mii.fType       = MFT_STRING;
    mii.dwTypeData  = (PWSTR) pszMenuString;
    mii.wID         = iNewCommand;

    // This is assuming that we want to take out the first menu item.
    if (!SetMenuItemInfo(hmenu, 0, TRUE, &mii))
    {
        TraceTag(ttidMenus, "SetMenuItemInfo returned: 0x%08x for CMIDM_DISCONNECT",
            GetLastError());
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetConnectDisconnectMenuItem
//
//  Purpose:    Modify the menu item (if necessary) for connect/disconnect.
//              We change this back and forth as needed since only one can be
//              supported at a time, and those in charge don't want both
//              appearing at any given time.
//
//  Arguments:
//      apidlSelected [in]  List of selected objects
//      cPidl         [in]  Count of selected objects
//      hmenu         [in]  Our menu handle
//
//  Returns:
//
//  Author:     jeffspr   1 May 1998
//
//  Notes:
//
HRESULT HrSetConnectDisconnectMenuItem(
                                       const PCONFOLDPIDLVEC& apidlSelected,
                                       HMENU           hmenu,
                                       INT             idCmdFirst)
{
    HRESULT         hr              = S_OK;

    if (apidlSelected.size() == 1)
    {
        Assert(!apidlSelected[0].empty() );

        const PCONFOLDPIDL& pcfp = apidlSelected[0];

        switch(pcfp->ncs)
        {
        case NCS_CONNECTED:
        case NCS_DISCONNECTING:
        case NCS_MEDIA_DISCONNECTED:
        case NCS_INVALID_ADDRESS:
        case NCS_AUTHENTICATING:
        case NCS_AUTHENTICATION_FAILED:
        case NCS_AUTHENTICATION_SUCCEEDED:
        case NCS_CREDENTIALS_REQUIRED:
            SetConnectMenuItem(hmenu, IsMediaLocalType(pcfp->ncm), idCmdFirst, TRUE);
            break;

        case NCS_DISCONNECTED:
        case NCS_CONNECTING:
        case NCS_HARDWARE_NOT_PRESENT:
        case NCS_HARDWARE_DISABLED:
        case NCS_HARDWARE_MALFUNCTION:
            SetConnectMenuItem(hmenu, IsMediaLocalType(pcfp->ncm), idCmdFirst, FALSE);
            break;

        default:
            AssertSz(FALSE, "HrSetConnectDisconnectMenuItem: What in the heck state is this?");
            break;
        }
    }

    TraceHr(ttidMenus, FAL, hr, FALSE, "HrSetConnectDisconnectMenuItem");
    return hr;
}


HRESULT HrCanRenameConnection(
    IN    const CConFoldEntry& cfe,
    IN    BOOL                 fMultiSelect,
    IN    int                  iCommandId,
    OUT   NCCS_STATE&          nccs
    )
{
    if (cfe.empty())
    {
        return S_FALSE;
    }

    if (cfe.GetCharacteristics() & NCCF_INCOMING_ONLY)
    {
        if (cfe.GetNetConMediaType() == NCM_NONE) // Incoming server - don't care
        {
            return S_FALSE;
        }
        else
        {
            nccs = NCCS_NOTSHOWN;
            return S_OK;
        }
    }
    else
    {
        CPConFoldPidl<ConFoldPidl_v2> pcfp;

        cfe.ConvertToPidl(pcfp);

        if (!HasPermissionToRenameConnection(pcfp))
        {
            nccs = NCCS_DISABLED;
        }
        else
        {
            return S_FALSE;
        }
        return S_OK;
    }
}

HRESULT HrCanShowProperties(
      IN    const CConFoldEntry& cfe,
      IN    BOOL                 fMultiSelect,
      IN    int                  iCommandId,
      OUT   NCCS_STATE&          nccs
      )
{
    if (cfe.empty())
    {
        return S_FALSE;
    }
    
    if (cfe.GetCharacteristics() & NCCF_INCOMING_ONLY)
    {
        if (cfe.GetNetConMediaType() == NCM_NONE) // Incoming server - don't care
        {
            return S_FALSE;
        }
        else
        {
            nccs = NCCS_NOTSHOWN;
            return S_OK;
        }
    }
    return S_FALSE;
}


BOOL IsBridgeInstalled()
{
    BOOL fBridgePresent = FALSE;  // fail to false
    HRESULT hResult;

    IHNetCfgMgr* pHomeNetConfigManager;
    hResult = HrCreateInstance(CLSID_HNetCfgMgr, CLSCTX_INPROC, &pHomeNetConfigManager);
    if(SUCCEEDED(hResult))
    {
        IHNetBridgeSettings* pNetBridgeSettings;
        hResult = pHomeNetConfigManager->QueryInterface(IID_IHNetBridgeSettings, reinterpret_cast<void**>(&pNetBridgeSettings));
        if(SUCCEEDED(hResult))
        {
            IHNetBridge* pNetBridge;
            IEnumHNetBridges* pNetBridgeEnum;
            hResult = pNetBridgeSettings->EnumBridges(&pNetBridgeEnum);
            if(SUCCEEDED(hResult))
            {
                hResult = pNetBridgeEnum->Next(1, &pNetBridge, NULL);
                if(S_OK == hResult)
                {
                    fBridgePresent = TRUE;
                    ReleaseObj(pNetBridge);
                }
                ReleaseObj(pNetBridgeEnum);
            }
            ReleaseObj(pNetBridgeSettings);
        }
        ReleaseObj(pHomeNetConfigManager);
    }
    return fBridgePresent;
}

HRESULT HrIsBridgeSupported(
    IN    const CConFoldEntry& cfe,
    IN    BOOL                 fMultiSelect,
    IN    int                  iCommandId,
    OUT   NCCS_STATE&          nccs
    )
{
//    if (cfe.empty())
//    {
//        return S_FALSE;
//    }
//
#ifdef _WIN64
        // Homenet technologies are not available at all on IA64
        nccs = NCCS_NOTSHOWN;
        return S_OK;
#else
        // If the machine is Advanced server or data center, delete the bridge menu item
        OSVERSIONINFOEXW verInfo = {0};
        ULONGLONG ConditionMask = 0;

        verInfo.dwOSVersionInfoSize = sizeof(verInfo);
        verInfo.wSuiteMask = VER_SUITE_ENTERPRISE;

        VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);

        if (VerifyVersionInfo(&verInfo, VER_SUITENAME, ConditionMask))
        {
            nccs = NCCS_NOTSHOWN;
            return S_OK;
        }
        else
        {
            BOOL fUserIsAdmin = FALSE;
            HRESULT hr = S_OK;
            CComPtr<INetConnectionUiUtilities> pConnectionUi;
            
            hr = CoCreateInstance(CLSID_NetConnectionUiUtilities, NULL, CLSCTX_INPROC, 
                                  IID_INetConnectionUiUtilities, reinterpret_cast<void**>(&pConnectionUi));

            if (FAILED(hr))
            {
                return hr;
            }

            fUserIsAdmin = FIsUserAdmin();
            
            if (IsBridgeInstalled())
            {
                if (CMIDM_CREATE_BRIDGE == iCommandId)
                {
                    nccs = NCCS_NOTSHOWN;
                    return S_OK;
                }
                else if (CMIDM_CONMENU_CREATE_BRIDGE == iCommandId)
                {
                    nccs = NCCS_DISABLED;
                    return S_OK;
                }
                else // CMIDM_ADD_TO_BRIDGE or CMID_REMOVE_FROM_BRIDGE
                {
                    if (!fUserIsAdmin || !pConnectionUi->UserHasPermission(NCPERM_AllowNetBridge_NLA))
                    {
                        nccs = NCCS_DISABLED;
                        return S_OK;
                    }
                    else
                    {
                        return S_FALSE; // Leave alone
                    }
                }
            }
            else
            {
                if ( (CMIDM_CREATE_BRIDGE == iCommandId) ||
                     (CMIDM_CONMENU_CREATE_BRIDGE == iCommandId) )
                {
                    if (!fUserIsAdmin || !pConnectionUi->UserHasPermission(NCPERM_AllowNetBridge_NLA))
                    {
                        nccs = NCCS_DISABLED;
                        return S_OK;
                    }
                    else
                    {
                        return S_FALSE; // Leave alone
                    }
                }
                else // CMIDM_ADD_TO_BRIDGE or CMID_REMOVE_FROM_BRIDGE
                {
                    nccs = NCCS_NOTSHOWN;
                    return S_OK;
                }
            }
        }
#endif
}

HRESULT HrOsIsLikePersonal()
{
    if (IsOS(OS_PERSONAL))
    {
        return S_OK;
    }

    if (IsOS(OS_PROFESSIONAL))
    {
        LPWSTR pszDomain;
        NETSETUP_JOIN_STATUS njs = NetSetupUnknownStatus;
        if (NERR_Success == NetGetJoinInformation(NULL, &pszDomain, &njs))
        {
            NetApiBufferFree(pszDomain);
        }

        if (NetSetupDomainName == njs)
        {
            return S_FALSE; // connected to domain
        }
        else
        {
            return S_OK; // Professional, but not a domain member
        }
    }
    return S_FALSE; // not personal or non-domain professional
}

HRESULT HrShouldHaveHomeNetWizard()
{
#ifdef _WIN64
    return S_FALSE;
#else
    if ( ( HrOsIsLikePersonal() == S_OK ) &&
        FIsUserAdmin())
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
   }
#endif
}

HRESULT HrIsHomeNewWizardSupported(
    IN    const CConFoldEntry& cfe,
    IN    BOOL                 fMultiSelect,
    IN    int                  iCommandId,
    OUT   NCCS_STATE&          nccs
    )
{
    if (S_OK == HrShouldHaveHomeNetWizard() )
    {
        nccs = NCCS_ENABLED;
        return S_OK;
    }
    else
    {
        nccs = NCCS_NOTSHOWN;
        return S_OK;
   }
}

HRESULT HrIsTroubleShootSupported(
    IN    const CConFoldEntry& cfe,
    IN    BOOL                 fMultiSelect,
    IN    int                  iCommandId,
    OUT   NCCS_STATE&          nccs
    )
{
    if ( cfe.empty() && (!fMultiSelect) )
    {
        if ( ! IsOS(OS_ANYSERVER) )
        {
            nccs = NCCS_ENABLED;
            return S_OK;
        }
        else
        {
            nccs = NCCS_ENABLED;
            return S_OK;
       }
    }
    else
    {
        nccs = NCCS_DISABLED;
        return S_OK;
    }
}

HRESULT HrIsNCWSupported(
    IN    const CConFoldEntry& cfe,
    IN    BOOL                 fMultiSelect,
    IN    int                  iCommandId,
    OUT   NCCS_STATE&          nccs
    )
{
    if ( (HrOsIsLikePersonal() == S_OK) &&
         !FIsUserAdmin() )
    {
        nccs = NCCS_NOTSHOWN;
        return S_OK;
    }
    else
    {
        return S_FALSE;
   }
}


HRESULT HrIsMediaWireless(
    IN    const CConFoldEntry& cfe,
    IN    BOOL                 fMultiSelect,
    IN    int                  iCommandId,
    OUT   NCCS_STATE&          nccs
    )
{
    if (cfe.GetNetConSubMediaType() != NCSM_WIRELESS)
    {
        nccs = NCCS_NOTSHOWN;
        return S_OK;
    }

    return S_FALSE; // Continue with processing
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\confold.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N F O L D . H
//
//  Contents:   CConnectionFolder object definition.
//
//  Notes:
//
//  Author:     jeffspr   30 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _CONFOLD_H_
#define _CONFOLD_H_

#include <netshell.h>
#include "nsbase.h"
#include "nsres.h"
#include "cfpidl.h"
#include "pidlutil.h"
#include "contray.h"
#include "connlist.h"
#include <lmcons.h>         // For UNLEN definition

//---[ Connection Folder Types ]----------------------------------------------

// The details list view columns.  These are used by the view and
// context menus

enum
{
    ICOL_NAME           = 0,
    ICOL_TYPE,               // 1
    ICOL_STATUS,             // 2
    ICOL_DEVICE_NAME,        // 3
    ICOL_PHONEORHOSTADDRESS, // 4
    ICOL_OWNER,              // 5
    ICOL_ADDRESS,            // 6
    ICOL_PHONENUMBER,        // 7
    ICOL_HOSTADDRESS,        // 8
    ICOL_WIRELESS_MODE,      // 9
   
    ICOL_MAX,                // 10 - End of list.
    ICOL_NETCONMEDIATYPE      = 0x101, // - not enumerated, just accessed through GetDetailsEx (keep this value in sync with shell)
    ICOL_NETCONSUBMEDIATYPE   = 0x102, // - not enumerated, just accessed through GetDetailsEx (keep this value in sync with shell)
    ICOL_NETCONSTATUS         = 0x103, // - not enumerated, just accessed through GetDetailsEx (keep this value in sync with shell)
    ICOL_NETCONCHARACTERISTICS= 0x104  // - not enumerated, just accessed through GetDetailsEx (keep this value in sync with shell)
};

// The details list view columns.  These are used by the view and
// context menus

typedef struct tagCOLS
{
    short int iColumn;
    short int iStringRes;
    short int iColumnSize;
    short int iFormat;
    DWORD csFlags; // SHCOLSTATE flags
} COLS;

DEFINE_GUID(IID_IExplorerToolbar,       0x8455F0C1L, 0x158F, 0x11D0, 0x89, 0xAE, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);
#define SID_SExplorerToolbar IID_IExplorerToolbar

class CNCWebView;

//---[ Connection Folder Classes ]--------------------------------------------

class ATL_NO_VTABLE CConnectionFolder :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CConnectionFolder, &CLSID_ConnectionFolder>,
    public IPersistFolder2,
    public IShellExtInit,
    public IShellFolder2,
    public IOleCommandTarget,
    public IShellFolderViewCB
{
private:
    CPConFoldPidl<ConFoldPidlFolder>    m_pidlFolderRoot;
    DWORD                 m_dwEnumerationType;
    
    WCHAR           m_szUserName[UNLEN+1];
    HWND            m_hwndMain;
    CNCWebView*     m_pWebView;
public:

    CConnectionFolder();
    ~CConnectionFolder();

    static HRESULT WINAPI UpdateRegistry(BOOL fRegister);

    BEGIN_COM_MAP(CConnectionFolder)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IPersistFolder)
        COM_INTERFACE_ENTRY(IPersistFolder2)
        COM_INTERFACE_ENTRY(IShellExtInit)
        COM_INTERFACE_ENTRY(IShellFolder)
        COM_INTERFACE_ENTRY_IID(IID_IShellFolder2, IShellFolder2)
        COM_INTERFACE_ENTRY(IOleCommandTarget)
        COM_INTERFACE_ENTRY(IShellFolderViewCB)
    END_COM_MAP()

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (
        LPCLSID lpClassID);

    // *** IPersistFolder methods ***
    STDMETHOD(Initialize) (
        LPCITEMIDLIST   pidl);

    // *** IPersistFolder2 methods ***
    STDMETHOD(GetCurFolder) (
        LPITEMIDLIST *ppidl);

    // *** IShellFolder2 methods from IShellFolder ***
    STDMETHOD(ParseDisplayName) (
        HWND            hwndOwner,
        LPBC            pbcReserved,
        LPOLESTR        lpszDisplayName,
        ULONG *         pchEaten,
        LPITEMIDLIST *  ppidl,
        ULONG *         pdwAttributes);

    STDMETHOD(EnumObjects) (
        HWND            hwndOwner,
        DWORD           grfFlags,
        LPENUMIDLIST *  ppenumIDList);

    STDMETHOD(BindToObject) (
        LPCITEMIDLIST   pidl,
        LPBC            pbcReserved,
        REFIID          riid,
        LPVOID *        ppvOut);

    STDMETHOD(BindToStorage) (
        LPCITEMIDLIST   pidl,
        LPBC            pbcReserved,
        REFIID          riid,
        LPVOID *        ppvObj);

    STDMETHOD(CompareIDs) (
        LPARAM          lParam,
        LPCITEMIDLIST   pidl1,
        LPCITEMIDLIST   pidl2);

    STDMETHOD(CreateViewObject) (
        HWND        hwndOwner,
        REFIID      riid,
        LPVOID *    ppvOut);

    STDMETHOD(GetAttributesOf) (
        UINT            cidl,
        LPCITEMIDLIST * apidl,
        ULONG *         rgfInOut);

    STDMETHOD(GetUIObjectOf) (
        HWND            hwndOwner,
        UINT            cidl,
        LPCITEMIDLIST * apidl,
        REFIID          riid,
        UINT *          prgfInOut,
        LPVOID *        ppvOut);

    STDMETHOD(GetDisplayNameOf) (
        LPCITEMIDLIST   pidl,
        DWORD           uFlags,
        LPSTRRET        lpName);

    STDMETHOD(SetNameOf) (
        HWND            hwndOwner,
        LPCITEMIDLIST   pidl,
        LPCOLESTR       lpszName,
        DWORD           uFlags,
        LPITEMIDLIST *  ppidlOut);

    // *** IShellFolder2 specific methods ***
    STDMETHOD(EnumSearches) (
           IEnumExtraSearch **ppEnum);
       
    STDMETHOD(GetDefaultColumn) (
            DWORD dwReserved,
            ULONG *pSort,
            ULONG *pDisplay );

    STDMETHOD(GetDefaultColumnState) (
            UINT iColumn,
            DWORD *pcsFlags );

    STDMETHOD(GetDefaultSearchGUID) (
            LPGUID lpGUID );

    STDMETHOD(GetDetailsEx) (
            LPCITEMIDLIST pidl,
            const SHCOLUMNID *pscid,
            VARIANT *pv );

    STDMETHOD(GetDetailsOf) (
            LPCITEMIDLIST pidl, 
            UINT iColumn, 
            LPSHELLDETAILS pDetails );

    STDMETHOD(MapColumnToSCID) (
            UINT iColumn,
            SHCOLUMNID *pscid );

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (
        HWND *  lphwnd);

    STDMETHOD(ContextSensitiveHelp) (
        BOOL    fEnterMode);

    // *** IShellExtInit methods ***
    STDMETHOD(Initialize) (
        LPCITEMIDLIST   pidlFolder,
        LPDATAOBJECT    lpdobj,
        HKEY            hkeyProgID);

    // IOleCommandTarget members
    STDMETHODIMP    QueryStatus(
        const GUID *    pguidCmdGroup,
        ULONG           cCmds,
        OLECMD          prgCmds[],
        OLECMDTEXT *    pCmdText);

    STDMETHODIMP    Exec(
        const GUID *    pguidCmdGroup,
        DWORD           nCmdID,
        DWORD           nCmdexecopt,
        VARIANTARG *    pvaIn,
        VARIANTARG *    pvaOut);

    // IShellFolderViewCB methods

    STDMETHOD(MessageSFVCB)
        (UINT uMsg, 
         WPARAM wParam, 
         LPARAM lParam);

    // Other interfaces
    STDMETHOD(RealMessage)( // This is kind'a a odd name, but used by the shell's MessageSFVCB 
        UINT uMsg,          // implementation, so I'm keeping this consistent for purposes
        WPARAM wParam,      // of search
        LPARAM lParam);

    PCONFOLDPIDLFOLDER& PidlGetFolderRoot();
    PCWSTR  pszGetUserName();
    IShellView *m_pShellView;
};

class ATL_NO_VTABLE CConnectionFolderEnum :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CConnectionFolderEnum, &CLSID_ConnectionFolderEnum>,
    public IEnumIDList
{
private:
    PCONFOLDPIDLFOLDER m_pidlFolder;
    PCONFOLDPIDLVEC m_apidl;
    PCONFOLDPIDLVEC::iterator m_iterPidlCurrent;
    DWORD           m_dwFlags;
    BOOL            m_fTray;                // Tray owns us.
    DWORD           m_dwEnumerationType;    // inbound/outbound/all

public:

    CConnectionFolderEnum();
    ~CConnectionFolderEnum();

    VOID PidlInitialize(
        BOOL            fTray,
        const PCONFOLDPIDLFOLDER& pidlFolder,
        DWORD           dwEnumerationType);

    DECLARE_REGISTRY_RESOURCEID(IDR_CONFOLDENUM)

    BEGIN_COM_MAP(CConnectionFolderEnum)
        COM_INTERFACE_ENTRY(IEnumIDList)
    END_COM_MAP()

    // *** IEnumIDList methods ***
    STDMETHOD(Next) (
        ULONG           celt,
        LPITEMIDLIST *  rgelt,
        ULONG *         pceltFetched);

    STDMETHOD(Skip) (
        ULONG   celt);

    STDMETHOD(Reset) ();

    STDMETHOD(Clone) (
        IEnumIDList **  ppenum);

public:
    static HRESULT CreateInstance (
        REFIID                              riid,
        void**                              ppv);

public:
    HRESULT HrRetrieveConManEntries();

};

typedef enum CMENU_TYPE
{
    CMT_OBJECT      = 1,
    CMT_BACKGROUND  = 2
};

class ATL_NO_VTABLE CConnectionFolderContextMenu :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CConnectionFolderContextMenu, &CLSID_ConnectionFolderContextMenu>,
    public IContextMenu
{
private:
    HWND                m_hwndOwner;
    PCONFOLDPIDLVEC     m_apidl;
    ULONG               m_cidl;
    LPSHELLFOLDER       m_psf;
    CMENU_TYPE          m_cmt;

public:
    CConnectionFolderContextMenu();
    ~CConnectionFolderContextMenu();

    DECLARE_REGISTRY_RESOURCEID(IDR_CONFOLDCONTEXTMENU)

    BEGIN_COM_MAP(CConnectionFolderContextMenu)
        COM_INTERFACE_ENTRY(IContextMenu)
    END_COM_MAP()

    // *** IContextMenu methods ***

    STDMETHOD(QueryContextMenu) (
        HMENU   hmenu,
        UINT    indexMenu,
        UINT    idCmdFirst,
        UINT    idCmdLast,
        UINT    uFlags);

    STDMETHOD(InvokeCommand) (
        LPCMINVOKECOMMANDINFO lpici);

    STDMETHOD(GetCommandString) (
        UINT_PTR    idCmd,
        UINT        uType,
        UINT *      pwReserved,
        PSTR       pszName,
        UINT        cchMax);

public:
    static HRESULT CreateInstance (
        REFIID                              riid,
        void**                              ppv,
        CMENU_TYPE                          cmt,
        HWND                                hwndOwner,
        const PCONFOLDPIDLVEC&              apidl,
        LPSHELLFOLDER                       psf);

private:
    HRESULT HrInitialize(
        CMENU_TYPE      cmt,
        HWND            hwndOwner,
        const PCONFOLDPIDLVEC& apidl,
        LPSHELLFOLDER   psf);

};

class ATL_NO_VTABLE CConnectionFolderExtractIcon :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CConnectionFolderExtractIcon, &CLSID_ConnectionFolderExtractIcon>,
    public IExtractIconW,
    public IExtractIconA
{
private:
    PCONFOLDPIDL m_pidl;

public:
    CConnectionFolderExtractIcon();
    ~CConnectionFolderExtractIcon();

    HRESULT HrInitialize(const PCONFOLDPIDL& pidl);

    DECLARE_REGISTRY_RESOURCEID(IDR_CONFOLDEXTRACTICON)

    BEGIN_COM_MAP(CConnectionFolderExtractIcon)
        COM_INTERFACE_ENTRY(IExtractIconW)
        COM_INTERFACE_ENTRY(IExtractIconA)
    END_COM_MAP()

    // *** IExtractIconW methods ***
    STDMETHOD(GetIconLocation) (
        UINT    uFlags,
        PWSTR  szIconFile,
        UINT    cchMax,
        int *   piIndex,
        UINT *  pwFlags);

    STDMETHOD(Extract) (
        PCWSTR pszFile,
        UINT    nIconIndex,
        HICON * phiconLarge,
        HICON * phiconSmall,
        UINT    nIconSize);

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation) (
        UINT    uFlags,
        PSTR   szIconFile,
        UINT    cchMax,
        int *   piIndex,
        UINT *  pwFlags);

    STDMETHOD(Extract) (
        PCSTR  pszFile,
        UINT    nIconIndex,
        HICON * phiconLarge,
        HICON * phiconSmall,
        UINT    nIconSize);

public:
    static HRESULT CreateInstance (
        LPCITEMIDLIST       apidl,
        REFIID              riid,
        void**              ppv);

};

// Util function for the IExtract code (also used elsewhere)
//
class ATL_NO_VTABLE CConnectionFolderQueryInfo :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CConnectionFolderQueryInfo, &CLSID_ConnectionFolderQueryInfo>,
    public IQueryInfo
{
private:
    PCONFOLDPIDL    m_pidl;

public:
    CConnectionFolderQueryInfo();
    ~CConnectionFolderQueryInfo();

    VOID PidlInitialize(const PCONFOLDPIDL& pidl)
    {
        m_pidl = pidl;
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_CONFOLDQUERYINFO)

    BEGIN_COM_MAP(CConnectionFolderQueryInfo)
        COM_INTERFACE_ENTRY(IQueryInfo)
    END_COM_MAP()

    // *** IQueryInfo methods ***
    STDMETHOD(GetInfoTip) (
        DWORD dwFlags,
        WCHAR **ppwszTip);

    STDMETHOD(GetInfoFlags) (
        DWORD *pdwFlags);

public:
    static HRESULT CreateInstance (
        REFIID                              riid,
        void**                              ppv);
};

//---[ Helper Functions ]------------------------------------------------------

HRESULT HrRegisterFolderClass(VOID);

HRESULT HrRegisterDUNFileAssociation();

HRESULT CALLBACK HrShellViewCallback(
    IShellView *    psvOuter,
    IShellFolder *  psf,
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam);

HRESULT CALLBACK HrShellContextMenuCallback(
    LPSHELLFOLDER   psf,
    HWND            hwndView,
    LPDATAOBJECT    pdtobj,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam);

HRESULT HrDataObjGetHIDA(
    IDataObject *   pdtobj,
    STGMEDIUM *     pmedium,
    LPIDA *         ppida);

VOID HIDAReleaseStgMedium(
    LPIDA       pida,
    STGMEDIUM * pmedium);

HRESULT HrSHReleaseStgMedium(
    LPSTGMEDIUM pmedium);

LPITEMIDLIST ILFromHIDA(
    LPIDA   pida,
    UINT    iPidaIndex);

EXTERN_C
HRESULT APIENTRY HrLaunchNetworkOptionalComponents(VOID);

#endif // _CONFOLD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\cmdtable.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C M D T A B L E . H 
//
//  Contents:   Command-table code -- determines which menu options are 
//              available by the selection count, among other criteria  
//
//  Notes:      
//
//  Author:     jeffspr   28 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once
#include "ncperms.h"

//---[ Constants ]------------------------------------------------------------
#define CMIDM_SEPARATOR 0xffffffff

typedef enum tagNETCON_MEDIATYPE_BM
{
    NBM_ANY     = 0xFFFFFFFF,
    NBM_NOMEDIATYPE = 0,
    NBM_MNC_WIZARD  = 0x80000000,
    NBM_HNW_WIZARD  = 0x40000000,
    NBM_INCOMING= 1 << NCM_NONE,
    NBM_DIRECT  = 1 << NCM_DIRECT,
    NBM_ISDN    = 1 << NCM_ISDN,
    NBM_LAN     = 1 << NCM_LAN,
    NBM_PHONE   = 1 << NCM_PHONE,
    NBM_TUNNEL    = 1 << NCM_TUNNEL,
    NBM_PPPOE    = 1 << NCM_PPPOE,
    NBM_BRIDGE    = 1 << NCM_BRIDGE,
    NBM_SHAREDACCESSHOST_LAN    = 1 << NCM_SHAREDACCESSHOST_LAN,
    NBM_SHAREDACCESSHOST_RAS    = 1 << NCM_SHAREDACCESSHOST_RAS,

    NBM_ISLANTYPE = NBM_LAN | NBM_BRIDGE,
    NBM_ISRASTYPE = NBM_ISDN | NBM_DIRECT | NBM_PHONE | NBM_TUNNEL | NBM_PPPOE,
    NBM_ISCONNECTIONTYPE = NBM_ISLANTYPE | NBM_ISRASTYPE,

    NBM_NOTWIZARD = ~(NBM_MNC_WIZARD | NBM_HNW_WIZARD)
} NETCON_MEDIATYPE_BM;

typedef enum tagNETCON_STATUS_BM
{
    NBS_ANY     = 0xFFFFFFFF,
    NBS_NONE                    = 0,
    NBS_DISCONNECTED            = 1 << NCS_DISCONNECTED,
    NBS_CONNECTING              = 1 << NCS_CONNECTING,
    NBS_CONNECTED               = 1 << NCS_CONNECTED,
    NBS_DISCONNECTING           = 1 << NCS_DISCONNECTING,
    NBS_HARDWARE_NOT_PRESENT    = 1 << NCS_HARDWARE_NOT_PRESENT,
    NBS_HARDWARE_DISABLED       = 1 << NCS_HARDWARE_DISABLED,
    NBS_HARDWARE_MALFUNCTION    = 1 << NCS_HARDWARE_MALFUNCTION,
    NBS_MEDIA_DISCONNECTED      = 1 << NCS_MEDIA_DISCONNECTED,
    NBS_AUTHENTICATING          = 1 << NCS_AUTHENTICATING,
    NBS_AUTHENTICATION_SUCCEEDED= 1 << NCS_AUTHENTICATION_SUCCEEDED,
    NBS_AUTHENTICATION_FAILED   = 1 << NCS_AUTHENTICATION_FAILED,
    NBS_INVALID_ADDRESS         = 1 << NCS_INVALID_ADDRESS,
    NBS_CREDENTIALS_REQUIRED    = 1 << NCS_CREDENTIALS_REQUIRED,

    NBS_NOT_DISCONNECTED        = NBS_ANY & ~NBS_DISCONNECTED,
    NBS_NOT_DISCONNECT          = NBS_CONNECTED | NBS_MEDIA_DISCONNECTED | NBS_INVALID_ADDRESS | NBS_AUTHENTICATING | NBS_AUTHENTICATION_SUCCEEDED | NBS_AUTHENTICATION_FAILED | NBS_CREDENTIALS_REQUIRED,
    NBS_HW_ISSUE                = NBS_HARDWARE_NOT_PRESENT | NBS_HARDWARE_DISABLED | NBS_HARDWARE_MALFUNCTION,
    NBS_IS_CONNECTED            = NBS_CONNECTED | NBS_AUTHENTICATION_SUCCEEDED | NBS_AUTHENTICATION_FAILED | NBS_AUTHENTICATING | NBS_CREDENTIALS_REQUIRED
} NETCON_STATUS_BM;

const DWORD64 NBPERM_NewConnectionWizard           = 1 << NCPERM_NewConnectionWizard;
const DWORD64 NBPERM_Statistics                    = 1 << NCPERM_Statistics;
const DWORD64 NBPERM_AddRemoveComponents           = 1 << NCPERM_AddRemoveComponents;
const DWORD64 NBPERM_RasConnect                    = 1 << NCPERM_RasConnect;
const DWORD64 NBPERM_LanConnect                    = 1 << NCPERM_LanConnect;
const DWORD64 NBPERM_DeleteConnection              = 1 << NCPERM_DeleteConnection;
const DWORD64 NBPERM_DeleteAllUserConnection       = 1 << NCPERM_DeleteAllUserConnection;
const DWORD64 NBPERM_RenameConnection              = 1 << NCPERM_RenameConnection;
const DWORD64 NBPERM_RenameMyRasConnection         = 1 << NCPERM_RenameMyRasConnection;
const DWORD64 NBPERM_ChangeBindState               = 1 << NCPERM_ChangeBindState;
const DWORD64 NBPERM_AdvancedSettings              = 1 << NCPERM_AdvancedSettings;
const DWORD64 NBPERM_DialupPrefs                   = 1 << NCPERM_DialupPrefs;
const DWORD64 NBPERM_LanChangeProperties           = 1 << NCPERM_LanChangeProperties;
const DWORD64 NBPERM_RasChangeProperties           = 1 << NCPERM_RasChangeProperties;
const DWORD64 NBPERM_LanProperties                 = 1 << NCPERM_LanProperties;
const DWORD64 NBPERM_RasMyProperties               = 1 << NCPERM_RasMyProperties;
const DWORD64 NBPERM_RasAllUserProperties          = 1 << NCPERM_RasAllUserProperties;
const DWORD64 NBPERM_ShowSharedAccessUi            = 1 << NCPERM_ShowSharedAccessUi;
const DWORD64 NBPERM_AllowAdvancedTCPIPConfig      = 1 << NCPERM_AllowAdvancedTCPIPConfig;
const DWORD64 NBPERM_OpenConnectionsFolder         = 1 << NCPERM_OpenConnectionsFolder;
const DWORD64 NBPERM_PersonalFirewallConfig        = 1 << NCPERM_PersonalFirewallConfig;
const DWORD64 NBPERM_AllowNetBridge_NLA            = 1 << NCPERM_AllowNetBridge_NLA;
const DWORD64 NBPERM_ICSClientApp                  = 1 << NCPERM_ICSClientApp;
const DWORD64 NBPERM_EnDisComponentsAllUserRas     = 1 << NCPERM_EnDisComponentsAllUserRas;
const DWORD64 NBPERM_EnDisComponentsMyRas          = 1 << NCPERM_EnDisComponentsMyRas;
const DWORD64 NBPERM_ChangeMyRasProperties         = 1 << NCPERM_ChangeMyRasProperties;
const DWORD64 NBPERM_ChangeAllUserRasProperties    = 1 << NCPERM_ChangeAllUserRasProperties;
const DWORD64 NBPERM_RenameLanConnection           = 1 << NCPERM_RenameLanConnection;
const DWORD64 NBPERM_RenameAllUserRasConnection    = 1 << NCPERM_RenameAllUserRasConnection;
const DWORD64 NBPERM_IpcfgOperation                = 1 << NCPERM_IpcfgOperation;
const DWORD64 NBPERM_Repair                        = 1 << NCPERM_Repair;
const DWORD64 NBPERM_Always                        = 0x00000000;

typedef enum tagNB_MENUVALID
{
    NCWHEN_ANYSELECT    = 0xFFFFFFFF,
    NCWHEN_TOPLEVEL     = 1,
    NCWHEN_ONESELECT    = 2,
    NCWHEN_MULTISELECT  = 4,
    NCWHEN_TOPLEVEL_DISREGARD_ITEM  = 8,
    NCWHEN_SOMESELECT   = NCWHEN_ONESELECT | NCWHEN_MULTISELECT
} NB_MENUVALID;

typedef enum tagNCCS_STATE
{
    NCCS_ENABLED  = 1,
    NCCS_DISABLED = 2,
    NCCS_NOTSHOWN = 3
} NCCS_STATE;

typedef enum tagNCCS_CHECKED_STATE
{
    NCCS_UNCHECKED = 0,
    NCCS_CHECKED   = 1
} NCCS_CHECKED_STATE;

typedef enum tagNB_REMOVEDISABLE
{
    NB_NO_FLAGS       = 0x0,

    NB_NEGATE_VIS_NBM_MATCH   = 0x1,
    NB_NEGATE_VIS_NBS_MATCH   = 0x2,
    NB_NEGATE_VIS_CHAR_MATCH  = 0x4,
    NB_NEGATE_VIS_PERMS_MATCH = 0x8,

    NB_NEGATE_ACT_NBM_MATCH   = 0x10,
    NB_NEGATE_ACT_NBS_MATCH   = 0x20,
    NB_NEGATE_ACT_CHAR_MATCH  = 0x40,
    NB_NEGATE_ACT_PERMS_MATCH = 0x80,
    
    NB_VERB                   = 0x100,
    NB_FLAG_ON_TOPMENU        = 0x1000,
    NB_TOPLEVEL_PERM          = 0x2000, // perms only
    NB_REMOVE_IF_NOT_MATCH    = 0x4000, // perms only

    NB_REMOVE_TOPLEVEL_ITEM   = 0x8000, // applies to top-level items only. WARNING: Permanent effect. 
                                        // Use this only for something that cannot change inside the same user session.

    NB_REVERSE_TOPLEVEL_ITEM  = 0x10000, // applies to top-level items only. WARNING: Permanent effect. 
                                        // Use this only for something that cannot change inside the same user session.

    NB_NEGATE_NBM_MATCH   = NB_NEGATE_VIS_NBM_MATCH   | NB_NEGATE_ACT_NBM_MATCH,
    NB_NEGATE_NBS_MATCH   = NB_NEGATE_VIS_NBS_MATCH   | NB_NEGATE_ACT_NBS_MATCH,
    NB_NEGATE_CHAR_MATCH  = NB_NEGATE_VIS_CHAR_MATCH  | NB_NEGATE_ACT_CHAR_MATCH,
    NB_NEGATE_PERMS_MATCH = NB_NEGATE_VIS_PERMS_MATCH | NB_NEGATE_ACT_PERMS_MATCH
} NB_REMOVEDISABLE;

struct CMDCHKENTRY
{
    int  iCommandId;        // Associated command ID
    bool fCurrentlyChecked; // Is this menu item already checked? 
    bool fNewCheckState;    // What's the new check state?        
};

// If this function returns S_FALSE it's an indication it didn't change the state.
typedef HRESULT (HrEnableDisableCB)(
    IN    const CConFoldEntry& cfe,
    IN    BOOL                 fMultiSelect,
    IN    int                  iCommandId,
    OUT   NCCS_STATE&          nccs
    );

// If this function returns S_FALSE it's an indication to use Default string
typedef HRESULT (HrCustomMenuStringCB)(
    IN    const CConFoldEntry& cfe,
    IN    int                  iCommandId,
    OUT   LPDWORD              pdwResourceId
    );

// Implementations of HrEnableDisableCB/HrCustomMenuStringCB
//HrEnableDisableCB    HrDisableForIncomingClients;
HrEnableDisableCB    HrCanRenameConnection;
HrEnableDisableCB    HrCanShowProperties;
HrEnableDisableCB    HrIsBridgeSupported;
HrEnableDisableCB    HrIsHomeNewWizardSupported;
HrEnableDisableCB    HrIsTroubleShootSupported;
HrEnableDisableCB    HrIsMediaWireless;
HrEnableDisableCB    HrIsNCWSupported;

struct COMMANDENTRY
{
    int     iCommandId;
    DWORD   dwDefaultPriority;   // The highest item that's visible+active will be the default. 0 item will never be selected.
    DWORD   dwValidWhen;         // NB_MENUVALID     flags
    DWORD   dwFlags;             // NB_REMOVEDISABLE flags (disabled unless specified in this flags - then removed).

    HrEnableDisableCB    *pfnHrEnableDisableCB;    // Callback function. Return S_FALSE to leave alone
    HrCustomMenuStringCB *pfnHrCustomMenuStringCB; // Callback function. Return S_FALSE/E_ to leave alone, or S_OK with a dwResourceID

    DWORD   dwMediaTypeVisible;   // NETCON_MEDIATYPE_BM flags
    DWORD   dwMediaTypeActive;    // NETCON_MEDIATYPE_BM flags

    DWORD   dwStatusVisible;      // NETCON_STATUS_BM flags  
    DWORD   dwStatusActive;       // NETCON_STATUS_BM flags 

    DWORD   dwCharacteristicsVisible; // NCCF_ flags
    DWORD   dwCharacteristicsActive;  // NCCF_ flags
};

struct COMMANDPERMISSIONSENTRY
{
    int     iCommandId;
    DWORD   dwMediaType;
    DWORD   dwCharacteristicsActive;
    DWORD   dwFlags;             // NB_REMOVEDISABLE flags (disabled unless specified in this flags - then removed).

    DWORD64 dwPermissionsActive;  // e.g. NBPERM_NewConnectionWizard - NBPERM_Always for always enabled
    NCPERM_APPLY_TO ncpAppliesTo;
};

struct SFVCOMMANDMAP
{
    int     iSFVCommandId;
    int     iCommandId;
};

extern COMMANDENTRY g_cteCommandMatrix[];
extern const DWORD g_cteCommandMatrixCount;

//---[ Prototypes ]-----------------------------------------------------------

HRESULT HrBuildMenu(IN OUT HMENU &hMenu, IN BOOL fVerbsOnly, IN PCONFOLDPIDLVEC& cfpl, IN DWORD idCmdFirst);
HRESULT HrUpdateMenu(IN OUT HMENU &hMenu, IN PCONFOLDPIDLVEC& cfpl, IN DWORD idCmdFirst);

HRESULT HrAssertTwoMenusEqual(HMENU hMenu1, HMENU hMenu2, UINT idCmdFirst, BOOL bIgnoreFlags, BOOL fPopupAsserts);

HRESULT HrAssertMenuStructuresValid(HWND hwndOwner);
HRESULT HrGetCommandState(IN const PCONFOLDPIDLVEC& cfpl, IN const DWORD dwCmdID, OUT NCCS_STATE& nccs, OUT LPDWORD dwResourceId, IN DWORD cteHint = 0xffffffff, IN DWORD dwOverrideFlag = 0);
BOOL    HasPermissionToRenameConnection(const PCONFOLDPIDL& pcfp);

HRESULT HrSetConnectDisconnectMenuItem(
    const PCONFOLDPIDLVEC& apidlSelected, 
    HMENU           hmenu,
    INT             idCmdFirst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\connlist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       C O N N L I S T . C P P
//
//  Contents:   Connection list class -- subclass of the stl list<> code.
//
//  Notes:
//
//  Author:     jeffspr   19 Feb 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "ncnetcon.h"
#include "ctrayui.h"
#include "traymsgs.h"
#include "ncerror.h"
#include "notify.h"
#include "ncperms.h"
#include "cmdtable.h"
#include "foldres.h"
#include "winuserp.h"

extern HWND g_hwndTray;

const DWORD c_dwInvalidCookie = -1;
DWORD  CConnectionList::m_dwNotifyThread = NULL;
HANDLE CConnectionList::m_hNotifyThread = NULL;

// use this for debugging. We don't usually want more than one advise, so for
// now I'm going to assert on this being false on advise creation
//
DWORD   g_dwAdvisesActive   = 0;

CTrayIconData::CTrayIconData(const CTrayIconData& TrayIconData)
{
    m_uiTrayIconId = TrayIconData.m_uiTrayIconId;
    m_ncs          = TrayIconData.m_ncs;
    m_pcpStat      = TrayIconData.m_pcpStat;
    m_pnseStats    = TrayIconData.m_pnseStats;
    m_pccts        = TrayIconData.m_pccts;

    m_dwLastBalloonMessage = TrayIconData.m_dwLastBalloonMessage;
    m_pfnBalloonFunction   = TrayIconData.m_pfnBalloonFunction;
    m_szCookie             = SysAllocStringByteLen(reinterpret_cast<LPCSTR>(TrayIconData.m_szCookie), SysStringByteLen(TrayIconData.m_szCookie));
    
    DWORD dwpcpStatCount = 0;
    DWORD dwpnseStats = 0;
    DWORD dwpccts = 0;

    if (m_pcpStat)
    {
        dwpcpStatCount = m_pcpStat->AddRef();
    }
    
    if (m_pnseStats)
    {
        dwpnseStats = m_pnseStats->AddRef();
    }
    
    if (m_pccts)
    {
        dwpccts = m_pccts->AddRef();
    }

    AssertSz(dwpcpStatCount < 100, "Possible IConnectionPoint reference leak");
    AssertSz(dwpnseStats < 100, "Possible INetStatisticsEngine*  reference leak");
    AssertSz(dwpccts < 100, "Possible CConnectionTrayStats*  reference leak");

    TraceTag(ttidConnectionList, "CTrayIconData::CTrayIconData(CTrayIconData&) [%d %d %d]", dwpcpStatCount, dwpnseStats, dwpccts);
}

CTrayIconData::CTrayIconData(UINT uiTrayIconId, NETCON_STATUS ncs, IConnectionPoint * pcpStat, INetStatisticsEngine * pnseStats, CConnectionTrayStats * pccts)
{
    m_uiTrayIconId = uiTrayIconId;
    m_ncs = ncs;
    m_pcpStat= pcpStat;
    m_pnseStats = pnseStats;
    m_pccts = pccts;
    m_szCookie = NULL;

    m_dwLastBalloonMessage = BALLOON_NOTHING;
    m_pfnBalloonFunction   = NULL;

    DWORD dwpcpStatCount = 0;
    DWORD dwpnseStats = 0;
    DWORD dwpccts = 0;

    if (m_pcpStat)
    {
        dwpcpStatCount = m_pcpStat->AddRef();
    }

    if (m_pnseStats)
    {
        dwpnseStats = m_pnseStats->AddRef();
    }

    if (m_pccts)
    {
        dwpccts = m_pccts->AddRef();
    }
    
    SetBalloonInfo(0, NULL, NULL);

    AssertSz(dwpcpStatCount < 100, "Possible IConnectionPoint reference leak");
    AssertSz(dwpnseStats < 100, "Possible INetStatisticsEngine*  reference leak");
    AssertSz(dwpccts < 100, "Possible CConnectionTrayStats*  reference leak");

#ifdef DBG
    if (FIsDebugFlagSet(dfidTraceFileFunc))
    {
        TraceTag(ttidConnectionList, "CTrayIconData::CTrayIconData(UINT, BOOL...) [%d %d %d]", dwpcpStatCount, dwpnseStats, dwpccts);
    }
#endif
}

CTrayIconData::~CTrayIconData()
{
    DWORD dwpcpStatCount = 0;
    DWORD dwpnseStats = 0;
    DWORD dwpccts = 0;

    if (m_pccts)
    {
        dwpccts = m_pccts->Release();
    }
    if (m_pcpStat)
    {
        dwpcpStatCount = m_pcpStat->Release();
    }
    if (m_pnseStats)
    {
        dwpnseStats = m_pnseStats->Release();
    }
    if (m_szCookie)
    {
        SysFreeString(m_szCookie);
    }

    AssertSz(dwpcpStatCount < 100, "Possible IConnectionPoint reference leak");
    AssertSz(dwpnseStats < 100, "Possible INetStatisticsEngine*  reference leak");
    AssertSz(dwpccts < 100, "Possible CConnectionTrayStats*  reference leak");

#ifdef DBG
    if (FIsDebugFlagSet(dfidTraceFileFunc))
    {
        TraceTag(ttidConnectionList, "CTrayIconData::~CTrayIconData [%d %d %d]", dwpcpStatCount, dwpnseStats, dwpccts);
    }
#endif
}

HRESULT CTrayIconData::SetBalloonInfo(DWORD dwLastBalloonMessage, BSTR szCookie, FNBALLOONCLICK* pfnBalloonFunction)
{
    m_dwLastBalloonMessage = dwLastBalloonMessage;
    m_pfnBalloonFunction   = pfnBalloonFunction;
    if (szCookie)
    {
        m_szCookie = SysAllocStringByteLen(reinterpret_cast<LPCSTR>(szCookie), SysStringByteLen(szCookie));;
    }
    else
    {
        m_szCookie = NULL;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::Initialize
//
//  Purpose:    Initialize class members.
//
//  Arguments:
//      fTieToTray [in] Use this list for tray support. This should be passed
//                      in as FALSE when the list is being used for temporary
//                      work.
//
//  Returns:
//
//  Author:     jeffspr   17 Nov 1998
//
//  Notes:
//
VOID CConnectionList::Initialize(BOOL fTieToTray, BOOL fAdviseOnThis)
{
    TraceFileFunc(ttidConnectionList);

    m_pcclc             = NULL;
    m_fPopulated        = false;
    m_dwAdviseCookie    = c_dwInvalidCookie;
    m_fTiedToTray       = fTieToTray;
    m_fAdviseOnThis     = fAdviseOnThis;

#if DBG
    m_dwCritSecRef      = 0;
    m_dwWriteLockRef    = 0;
#endif

    
    InitializeCriticalSection(&m_csMain);
    InitializeCriticalSection(&m_csWriteLock);
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::Uninitialize
//
//  Purpose:    Flush the connection list and do all cleanup
//              of tray icons and interfaces and such.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes: Don't make COM calls from this function if fFinalUninitialize is true. It's called from DllMain.
//  No need for EnsureConPointNotifyRemoved() as it's removed from 
//  CConnectionTray::HrHandleTrayClose
VOID CConnectionList::Uninitialize(BOOL fFinalUninitialize)
{    
    TraceFileFunc(ttidConnectionList);

    if (fFinalUninitialize)
    {
        Assert(FImplies(m_dwNotifyThread, m_hNotifyThread));
        if (m_dwNotifyThread && m_hNotifyThread)
        {
            PostThreadMessage(m_dwNotifyThread, WM_QUIT, NULL, NULL);
            if (WAIT_TIMEOUT == WaitForSingleObject(m_hNotifyThread, 30000))
            {
                TraceTag(ttidError, "Timeout waiting for Notify Thread to quit");
            }
        }
    }

    
    FlushConnectionList();

    delete m_pcclc;
    m_pcclc = NULL;

    Assert(m_dwCritSecRef == 0);
    Assert(m_dwWriteLockRef == 0);
    DeleteCriticalSection(&m_csWriteLock);
    DeleteCriticalSection(&m_csMain);
}

HRESULT ConnListEntry::SetTrayIconData(const CTrayIconData& TrayIconData)
{
    TraceFileFunc(ttidConnectionList);

    if (m_pTrayIconData)
    {
        delete m_pTrayIconData;
        m_pTrayIconData = NULL;
    }

    m_pTrayIconData = new CTrayIconData(TrayIconData);
    if (!m_pTrayIconData)
    {
        return E_OUTOFMEMORY;
    }
        
    return S_OK;
}

CONST_IFSTRICT CTrayIconData* ConnListEntry::GetTrayIconData() const 
{
    return m_pTrayIconData;
}

BOOL ConnListEntry::HasTrayIconData() const 
{
    return (m_pTrayIconData != NULL);
}


HRESULT ConnListEntry::DeleteTrayIconData()
{
    if (m_pTrayIconData)
    {
        delete m_pTrayIconData;
        m_pTrayIconData = NULL;
    }    
    return S_OK;
}

//
// Is this the main shell process? (eg the one that owns the desktop window)
//
// NOTE: if the desktop window has not been created, we assume that this is NOT the
//       main shell process and return FALSE;
//
STDAPI_(BOOL) IsMainShellProcess()
{
    static int s_fIsMainShellProcess = -1;

    if (s_fIsMainShellProcess == -1)
    {
        s_fIsMainShellProcess = FALSE;

        HWND hwndDesktop = GetShellWindow();
        if (hwndDesktop)
        {
            DWORD dwPid;
            if (GetWindowThreadProcessId(hwndDesktop, &dwPid))
            {
                if (GetCurrentProcessId() == dwPid)
                {
                    s_fIsMainShellProcess  = TRUE;
                }
            }
        }
        else
        {
            TraceTag(ttidError, "IsMainShellProcess: hwndDesktop does not exist, assuming we are NOT the main shell process");
            return FALSE;
        }

        if (s_fIsMainShellProcess)
        {
            TraceTag(ttidNotifySink, "We are running inside the main explorer process.");
        }
        else
        {
            TraceTag(ttidNotifySink, "We are NOT running inside the main explorer process.");
        }
    }

    return s_fIsMainShellProcess ? TRUE : FALSE;
}

DWORD CConnectionList::NotifyThread(LPVOID pConnectionList)
{
    CConnectionList *pThis = reinterpret_cast<CConnectionList *>(pConnectionList);

    HRESULT hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hr))
    {
        pThis->EnsureConPointNotifyAdded();

        MSG msg;
        while (GetMessage (&msg, 0, 0, 0))
        {
            DispatchMessage (&msg);
        }
    
        // Don't call EnsureConPointNotifyRemoved() since this function is called from DllMain.
        // We'll have to rely on Netman to detect by itself that this thread has died.
        CoUninitialize();
    }

    return SUCCEEDED(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrRetrieveConManEntries
//
//  Purpose:    Get the connection data from the enumerator, and build the
//              connection list and tray
//
//  Arguments:
//      papidlOut [out]     Retrieved entry pidl array
//      pcpidl    [out]     Count of above array
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrRetrieveConManEntries(
    PCONFOLDPIDLVEC& apidlOut)
{
    TraceFileFunc(ttidConnectionList);

    HRESULT         hr              = S_OK;
    DWORD           cpidl           = 0;

    NETCFG_TRY

        ConnListEntry   cle;
        BOOL            fLockAcquired   = FALSE;

         // If we haven't yet populated our list, do so.
        //
        if (!m_fPopulated)
        {
            static LONG lSyncAquired = 0;
            if (!InterlockedExchange(&lSyncAquired, 1))
            {
                if (!IsMainShellProcess() && (!g_dwAdvisesActive) && (m_fAdviseOnThis) )
                {
                    m_hNotifyThread = CreateThread(NULL, STACK_SIZE_SMALL, NotifyThread, this, 0, &m_dwNotifyThread);
                    if (!m_hNotifyThread)
                    {
                        TraceTag(ttidError, "Could not create sink thread");
                    }
                }
            }
        
            hr = HrRefreshConManEntries();
            if (FAILED(hr))
            {
                goto Exit;
            }

            m_fPopulated = true;
        }
      
        if (m_pcclc)
        {
            AcquireLock();
            fLockAcquired = TRUE;

            // Get the count of the elements
            //
            cpidl = m_pcclc->size();

            // Allocate an array to store the pidls that we'll retrieve
            //
            ConnListCore::iterator  clcIter;
            DWORD                   dwLoop  = 0;

            // Iterate through the list and build the ppidl array
            //
            for (clcIter = m_pcclc->begin();
                 clcIter != m_pcclc->end();
                 clcIter++)
            {
                Assert(!clcIter->second.empty());

                cle = clcIter->second;

                Assert(!cle.ccfe.empty() );
                if (!cle.ccfe.empty())
                {
                    // Convert the confoldentry to a pidl, so we can
                    // retrieve the size
                    //
                    PCONFOLDPIDL pConFoldPidlTmp;
                    hr = cle.ccfe.ConvertToPidl(pConFoldPidlTmp);
                    if (FAILED(hr))
                    {
                        goto Exit;
                    }
                    apidlOut.push_back(pConFoldPidlTmp);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            // Do NOT do FlushTrayPosts here. It doesn't work, and it causes a deadlock.
        }

Exit:
        if (fLockAcquired)
        {
            ReleaseLock();
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrRetrieveConManEntries");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrRemove
//
//  Purpose:    Remove a connection from the list based on a pccfe
//
//  Arguments:
//      pccfe [in]  Connection data (so we can find)
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrRemove(const CONFOLDENTRY& ccfe, BOOL * pfFlushPosts)
{
    TraceFileFunc(ttidConnectionList);

    HRESULT                 hr      = S_OK;

    AcquireLock();
    ConnListCore::iterator  clcIter;

    if (m_pcclc)
    {
        // Iterate through the list looking for the entry with the
        // matching guid.
        //
        for (clcIter = m_pcclc->begin();
             clcIter != m_pcclc->end();
             clcIter++)
        {
            ConnListEntry& cleIter    = clcIter->second;

            if (InlineIsEqualGUID(cleIter.ccfe.GetGuidID(), ccfe.GetGuidID()))
            {
                // Remove the entry, then break 'cause the ++
                // in the for loop would explode if we didn't
                //
                hr = HrRemoveByIter(clcIter, pfFlushPosts);
                break;
            }
        }
    }

    ReleaseLock();

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrRemove");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrRemoveByIter
//
//  Purpose:    Remove a list entry, using the list entry itself as
//              the search element.
//
//  Arguments:
//
//  Returns:
//
//  Author:     jeffspr   10 Apr 1998
//
//  Notes:
//
HRESULT CConnectionList::HrRemoveByIter(ConnListCore::iterator clcIter, BOOL *pfFlushTrayPosts)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr    = S_OK;
    ConnListEntry& cle    = clcIter->second;
    Assert(!cle.empty());

    AcquireLock();

    // If there's a tray item for this connection
    //
    if (cle.HasTrayIconData() )
    {
        // Since we're deleting the entry, remove the tray
        // icon associated with this entry. Ignore the return
        //
        if (m_fTiedToTray && g_pCTrayUI)
        {
            // Set the flag to inform the caller that they will need to flush this stuff.
            //
            if (pfFlushTrayPosts)
            {
                *pfFlushTrayPosts = TRUE;
            }

            CTrayIconData * pTrayIconData = new CTrayIconData(*cle.GetTrayIconData());
            cle.DeleteTrayIconData();
        
            TraceTag(ttidSystray, "HrRemoveByIter: Removing tray icon for %S", cle.ccfe.GetName());
            PostMessage(g_hwndTray, MYWM_REMOVETRAYICON, reinterpret_cast<WPARAM>(pTrayIconData), (LPARAM) 0);
        }
    }

    // release the branding info
    //
    // icon path
    CON_BRANDING_INFO * pcbi = cle.pcbi;
    if (pcbi)
    {
        CoTaskMemFree(pcbi->szwLargeIconPath);
        CoTaskMemFree(pcbi->szwTrayIconPath);
        CoTaskMemFree(pcbi);
    }

    // menu items
    CON_TRAY_MENU_DATA * pMenuData = cle.pctmd;
    if (pMenuData)
    {
        DWORD dwCount = pMenuData->dwCount;
        CON_TRAY_MENU_ENTRY * pMenuEntry = pMenuData->pctme;

        while (dwCount)
        {
            Assert(pMenuEntry);

            CoTaskMemFree(pMenuEntry->szwMenuText);
            CoTaskMemFree(pMenuEntry->szwMenuCmdLine);
            CoTaskMemFree(pMenuEntry->szwMenuParams);

            dwCount--;
            pMenuEntry++;
        }

        CoTaskMemFree(pMenuData->pctme);
        CoTaskMemFree(pMenuData);
    }

    // Remove the actual element from the list
    //
    Assert(m_pcclc);
    m_pcclc->erase(clcIter);

    ReleaseLock();

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrRemoveByIter");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::FlushTrayIcons
//
//  Purpose:    Remove all of our icons from the tray, since we're about
//              to either flush the connection list or turn off the tray.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
VOID CConnectionList::FlushTrayIcons()
{
    TraceFileFunc(ttidConnectionList);
    
    AssertSz(m_fTiedToTray, "This connection list not allowed to modify tray");

    if (!g_pCTrayUI || !m_fTiedToTray)
    {
        return;
    }

    AcquireLock();

    ConnListCore::iterator  clcIter;
    ConnListCore::iterator  clcNext;
    BOOL                    fFlushPosts = FALSE;

    if (m_pcclc)
    {
        // Iterate through the list and build the ppidl array
        //
        for (clcIter = m_pcclc->begin();
             clcIter != m_pcclc->end();
             clcIter = clcNext)
        {
            Assert(!clcIter->second.empty());

            clcNext = clcIter;
            clcNext++;

            ConnListEntry& cle = clcIter->second; // using non-const reference for renaming only (calling cle.DeleteTrayIconData).

            if ( cle.HasTrayIconData() )
            {
                fFlushPosts = TRUE;

                CTrayIconData *pTrayIconData = new CTrayIconData(*cle.GetTrayIconData());
                cle.DeleteTrayIconData();

                TraceTag(ttidSystray, "FlushTrayIcons: Removing tray icon for %S", cle.ccfe.GetName());
                PostMessage(g_hwndTray, MYWM_REMOVETRAYICON, (WPARAM) pTrayIconData , (LPARAM) 0);
            }
        }
    }

    g_pCTrayUI->ResetIconCount();

    ReleaseLock();

    if (fFlushPosts)
    {
        FlushTrayPosts(g_hwndTray);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::EnsureIconsPresent
//
//  Purpose:    Given an existing list, ensure that all of the tray
//              icons that should be shown are being shown. This needs to
//              be called when the tray was turned on AFTER enumeration.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
VOID CConnectionList::EnsureIconsPresent()
{
    TraceFileFunc(ttidConnectionList);
    
    Assert(m_fTiedToTray);

    if (!g_pCTrayUI || !m_fTiedToTray)
    {
        return;
    }

    AcquireLock();

    ConnListCore::iterator  clcIter;
    ConnListCore::iterator  clcNext;

    if (m_pcclc)
    {
        // Iterate through the list and build the ppidl array
        //
        for (clcIter = m_pcclc->begin();
             clcIter != m_pcclc->end();
             clcIter = clcNext)
        {
            Assert(!clcIter->second.empty());

            clcNext = clcIter;
            clcNext++;

            const ConnListEntry& cle = clcIter->second;

            if ((!cle.HasTrayIconData() ) &&
                 cle.ccfe.FShouldHaveTrayIconDisplayed())
            {
                CONFOLDENTRY pccfeDup;

                HRESULT hr = pccfeDup.HrDupFolderEntry(cle.ccfe);
                if (SUCCEEDED(hr))
                {
                    TraceTag(ttidSystray, "EnsureIconsPresent: Adding tray icon for %S", cle.ccfe.GetName());
                    PostMessage(g_hwndTray, MYWM_ADDTRAYICON, (WPARAM) pccfeDup.TearOffItemIdList(), (LPARAM) 0);
                }
            }
        }
    }

    ReleaseLock();
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::FlushConnectionList
//
//  Purpose:    Remove all entries from the connection list
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
VOID CConnectionList::FlushConnectionList()
{
    TraceFileFunc(ttidConnectionList);
    
    AcquireLock();

    ConnListCore::iterator  clcIter;
    ConnListCore::iterator  clcNext;
    BOOL                    fFlushTrayPosts = FALSE;

    TraceTag(ttidConnectionList, "Flushing the connection list");
    TraceStack(ttidConnectionList);

    if (m_pcclc)
    {
        // Iterate through the list and build the ppidl array
        //
        for (clcIter = m_pcclc->begin();
             clcIter != m_pcclc->end();
             clcIter = clcNext)
        {
            Assert(!clcIter->second.empty());

            clcNext = clcIter;
            clcNext++;

            (VOID) HrRemoveByIter(clcIter, &fFlushTrayPosts);
        }

        if (m_pcclc->size() != 0)
        {
            AssertSz(FALSE, "List not clear after deleting all elements in FlushConnectionList");

            // Flush the list itself
            //
            m_pcclc->clear();
        }
    }

    // Reset the icon's icon ID count, as we've cleared out all icons
    //
    if (g_pCTrayUI && m_fTiedToTray)
    {
        g_pCTrayUI->ResetIconCount();
    }

    m_fPopulated = FALSE;

    ReleaseLock();

    // If we need to do the SendMessage to flush any PostMessages to the tray
    // do so
    //
    if (g_pCTrayUI && g_hwndTray && fFlushTrayPosts)
    {
        FlushTrayPosts(g_hwndTray);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrRetrieveConManEntries
//
//  Purpose:    Retrieve the connection entries from the connection manager
//
//  Arguments:
//      None
//
//  Returns:
//
//  Author:     jeffspr   20 Feb 1998
//
//  Notes:
//
HRESULT CConnectionList::HrRefreshConManEntries()
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT                 hr          = S_OK;
    CONFOLDENTRY           ccfe;

    PCONFOLDPIDL           pidlMNCWizard;
    PCONFOLDPIDL           pidlHNWWizard;

    CComPtr<INetConnectionManager2> pconMan2;

    // Create an instance of the connection manager
    //
    hr = HrCreateInstance(
        CLSID_ConnectionManager2,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        &pconMan2);

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

    if (SUCCEEDED(hr))
    {
        HRESULT hrDebug = S_OK;
        HRESULT hrProp = S_OK;

        // Iterate through the connections
        //
        SAFEARRAY* psaConnectionProperties;
        hr = pconMan2->EnumConnectionProperties(&psaConnectionProperties);
        if (SUCCEEDED(hr))
        {
            FlushConnectionList();

            if (S_OK == hr)
            {
                Assert(psaConnectionProperties);
                AcquireWriteLock();

                AcquireLock();
                if (m_pcclc)
                {
                    m_pcclc->clear(); // Make sure somebody else didn't come in in between the two calls and added stuff to the list
                }
                ReleaseLock();

                // Add the wizards to the beginning of the list
                //
                PCONFOLDPIDLVEC pcfpvEmpty;
                NCCS_STATE nccs = NCCS_ENABLED;
                DWORD dwResourceId;

                // Add the Make New Connection Wizard
                // Check for permissions etc.
                HrGetCommandState(pcfpvEmpty, CMIDM_NEW_CONNECTION, nccs, &dwResourceId, 0xffffffff, NB_FLAG_ON_TOPMENU);
                if (NCCS_ENABLED == nccs)
                {
                    hr = HrCreateConFoldPidl(WIZARD_MNC, NULL, pidlMNCWizard);
                    if (SUCCEEDED(hr))
                    {
                        // Convert the pidl to a ConFoldEntry
                        //
                        hr = pidlMNCWizard.ConvertToConFoldEntry(ccfe);
                        if (SUCCEEDED(hr))
                        {
                            // Insert the wizard item
                            //
                            // $$NOTE: Let this fall through, even if the Insert of the wizard
                            // didn't work. Yeah, we'd be in a bad position, but we'd be even
                            // worse off if we just left an empty list. Whatever the case, it
                            // would be next to impossible for this to fail.
                            //
                            hr = HrInsert(ccfe);
                        }
                    }
                }

                // Add the Network Setup Wizard
                nccs = NCCS_ENABLED;
                // Check for permissions etc.
                HrGetCommandState(pcfpvEmpty, CMIDM_HOMENET_WIZARD, nccs, &dwResourceId, 0xffffffff, NB_FLAG_ON_TOPMENU);
                if (NCCS_ENABLED == nccs)
                {
                    hr = HrCreateConFoldPidl(WIZARD_HNW, NULL, pidlHNWWizard);
                    if (SUCCEEDED(hr))
                    {
                        // Convert the pidl to a ConFoldEntry
                        //
                        hr = pidlHNWWizard.ConvertToConFoldEntry(ccfe);
                        if (SUCCEEDED(hr))
                        {
                            hr = HrInsert(ccfe);
                        }
                    }
                }

                LONG lLBound;
                LONG lUBound;

                m_fPopulated = TRUE;
            
                hr = SafeArrayGetLBound(psaConnectionProperties, 1, &lLBound);
                if (SUCCEEDED(hr))
                {
                    hr = SafeArrayGetUBound(psaConnectionProperties, 1, &lUBound);
                    if (SUCCEEDED(hr))
                    {
                        for (LONG i = lLBound; i <= lUBound; i++)
                        {
                            CComVariant varRecord;
                    
                            hr = SafeArrayGetElement(psaConnectionProperties, &i, reinterpret_cast<LPVOID>(&varRecord));
                            if (FAILED(hr))
                            {
                                SafeArrayDestroy(psaConnectionProperties);
                                break;
                            }
                        
                            Assert( (VT_ARRAY | VT_VARIANT) == varRecord.vt);
                            if ( (VT_ARRAY | VT_VARIANT) != varRecord.vt)
                            {
                                SafeArrayDestroy(psaConnectionProperties);
                                break;
                            }

                            NETCON_PROPERTIES_EX *pPropsEx;
                            hrDebug = HrNetConPropertiesExFromSafeArray(varRecord.parray, &pPropsEx);
                            if (SUCCEEDED(hr))
                            {
                                // don't insert incoming connection in transit state
                                if (!((pPropsEx->dwCharacter & NCCF_INCOMING_ONLY) &&
                                      (pPropsEx->ncMediaType != NCM_NONE) &&
                                      !(fIsConnectedStatus(pPropsEx->ncStatus)) ))
                                {
                                    // Get this for debugging only.
                                    PCONFOLDPIDL pcfpEmpty;
                                    hrDebug = HrInsertFromNetConPropertiesEx(*pPropsEx, pcfpEmpty);

                                    TraceError("Could not Insert from NetConProperties", hrDebug);
                                }
                                HrFreeNetConProperties2(pPropsEx);
                            }
                            else
                            {
                                TraceError("Could not obtain properties from Safe Array", hrDebug);
                            }
                        }
                    }
                }

                ReleaseWriteLock();
            }
            else
            {
                TraceHr(ttidError, FAL, hr, FALSE, "EnumConnectionProperties of the Connection Manager failed");
            } // if S_OK == hr
        } // if SUCCEEDED(hr)
    }
    else
    {
        TraceHr(ttidError, FAL, hr, FALSE, "CoCreateInstance of the Connection Manager v2 failed. "
                "If you're in the process of shutting down, this is expected, as we can't do "
                "a CoCreate that would force a process to start (netman.exe). If you're not "
                "shutting down, then let us know the error code");
    }
    
#ifdef DBG
    if (SUCCEEDED(hr))
    {
        AcquireLock();

        TraceTag(ttidNotifySink, "CConnectionList::HrRefreshConManEntries:");

        if (m_pcclc)
        {
            for (ConnListCore::const_iterator i = m_pcclc->begin(); i != m_pcclc->end(); i++)
            {
                const CONFOLDENTRY& cfe = i->second.ccfe;
                WCHAR szTrace[MAX_PATH*2];

                OLECHAR szGuidString[MAX_GUID_STRING_LEN];
                StringFromGUID2(cfe.GetGuidID(), szGuidString, MAX_GUID_STRING_LEN);

                TraceTag(ttidNotifySink, "  ==>%S [%s:%s:%s:%s]", 
                cfe.GetName(), DbgNcm(cfe.GetNetConMediaType()), DbgNcsm(cfe.GetNetConSubMediaType()), DbgNcs(cfe.GetNetConStatus()), DbgNccf(cfe.GetCharacteristics()) );
            }
        }

        ReleaseLock();
    }
#endif

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrRetrieveConManEntries");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrGetBrandingInfo
//
//  Purpose:    Get the branding-specific information off of this particular
//              connection. It MUST be an NCCF_BRANDING-type connection, or
//              this information will not be present.
//
//  Arguments:
//      cle   [in, out]  The entry for this connection. cle.ccfe must have been
//                       set before this call.
//
//  Returns:
//
//  Author:     jeffspr   25 Mar 1998
//
//  Notes:
//
HRESULT CConnectionList::HrGetBrandingInfo(
    IN OUT ConnListEntry& cle)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT                         hr      = S_OK;
    INetConnectionBrandingInfo *    pncbi   = NULL;

    Assert(!cle.empty());
    Assert(!cle.ccfe.empty());

    if (cle.empty() || cle.ccfe.empty())
    {
        hr = E_POINTER;
    }
    else
    {
        Assert(cle.ccfe.GetCharacteristics() & NCCF_BRANDED);

        hr = cle.ccfe.HrGetNetCon(IID_INetConnectionBrandingInfo,
                                      reinterpret_cast<VOID**>(&pncbi));
        if (SUCCEEDED(hr))
        {
            // Everything is kosher. Grab the paths.
            //
            hr = pncbi->GetBrandingIconPaths(&(cle.pcbi));
            if (SUCCEEDED(hr))
            {
                // Trace the icon paths for debugging
                //
                if (cle.pcbi->szwLargeIconPath)
                {
                    TraceTag(ttidConnectionList, "  Branded icon [large]: %S",
                             cle.pcbi->szwLargeIconPath);
                }
                if (cle.pcbi->szwTrayIconPath)
                {
                    TraceTag(ttidConnectionList, "  Branded icon [tray]: %S",
                             cle.pcbi->szwTrayIconPath);
                }
            }

            // Grab any menu items
            hr = pncbi->GetTrayMenuEntries(&(cle.pctmd));
            if (SUCCEEDED(hr))
            {
                // Trace the menu items for debugging
                CON_TRAY_MENU_DATA * pMenuData = cle.pctmd;
                if (pMenuData)
                {
                    CON_TRAY_MENU_ENTRY * pMenuEntry = pMenuData->pctme;
                    DWORD dwCount = pMenuData->dwCount;
                    while (dwCount)
                    {
                       Assert(pMenuEntry);

                       TraceTag(ttidConnectionList, "***CM menu:*** \nItem: %S \nCommand: %S \nParameters: %S",
                                pMenuEntry->szwMenuText,
                                pMenuEntry->szwMenuCmdLine,
                                pMenuEntry->szwMenuParams);

                       dwCount--;
                       pMenuEntry++;
                    }
                }
            }

            ReleaseObj(pncbi);  // 180240
        }
        else
        {
            // Not a problem -- just doesn't have branding information
            //
            hr = S_OK;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrGetBrandingInfo");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::EnsureConPointNotifyAdded
//
//  Purpose:    Ensure that we create the con point notify
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   5 Oct 1998
//
//  Notes:
//
VOID CConnectionList::EnsureConPointNotifyAdded()
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT                     hr              = S_OK; // Not returned, but used for debugging
    IConnectionPoint *          pConPoint       = NULL;
    INetConnectionNotifySink *  pSink           = NULL;

    AssertSz(m_fAdviseOnThis, "Shouldn't even be calling EnsureConPointNotifyAdded if "
           "we don't want advises");

    if (m_fAdviseOnThis)
    {
        if (!InSendMessage())
        {
            // If we don't already have an advise sink
            //
            if (c_dwInvalidCookie == m_dwAdviseCookie)
            {
                AssertSz(g_dwAdvisesActive == 0, "An advise already exists. We should never "
                         "be creating more than one Advise per Explorer instance");

                // Make sure that we have a connection point.
                //
                hr = HrGetNotifyConPoint(&pConPoint);
                if (SUCCEEDED(hr))
                {
                    // Create the notify sink
                    //
                    hr = CConnectionNotifySink::CreateInstance(
                            IID_INetConnectionNotifySink,
                            (LPVOID*)&pSink);
                    if (SUCCEEDED(hr))
                    {
                        Assert(pSink);

                        hr = pConPoint->Advise(pSink, &m_dwAdviseCookie);
                        if (SUCCEEDED(hr))
                        {
                            TraceTag(ttidNotifySink, "Added advise sink. Cookie = %d", m_dwAdviseCookie);
                            g_dwAdvisesActive++;
                        }

                        TraceHr(ttidError, FAL, hr, FALSE, "pConPoint->Advise");

                        ReleaseObj(pSink);
                    }

                    ReleaseObj(pConPoint);
                }
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "EnsureConPointNotifyAdded");
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::EnsureConPointNotifyRemoved
//
//  Purpose:    Ensure that the connection point notify has been unadvised.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   7 Oct 1998
//
//  Notes:
//
VOID CConnectionList::EnsureConPointNotifyRemoved()
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT             hr          = S_OK;
    IConnectionPoint *  pConPoint   = NULL;

    AssertSz(m_fAdviseOnThis, "EnsureConPointNotifyRemoved shouldn't be "
            "called when we're not a notify capable connection list");

    // No more objects, so remove the advise if present
    //
    if (m_dwAdviseCookie != c_dwInvalidCookie)
    {
        hr = HrGetNotifyConPoint(&pConPoint);
        if (SUCCEEDED(hr))
        {
            // Unadvise
            //
            hr = pConPoint->Unadvise(m_dwAdviseCookie);
            TraceTag(ttidNotifySink, "Removed advise sink. Cookie = d", m_dwAdviseCookie);

            TraceHr(ttidError, FAL, hr, FALSE, "pConPoint->Unadvise");

            m_dwAdviseCookie = c_dwInvalidCookie;

            ReleaseObj(pConPoint);

            g_dwAdvisesActive--;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "EnsureConPointNotifyRemoved");
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrInsert
//
//  Purpose:    Insert a connection into the list, based on a pre-built
//              ConFoldEntry
//
//  Arguments:
//      pccfe [in]  ConFoldEntry describing the connection
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrInsert(const CONFOLDENTRY& pccfe)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr          = S_OK;
    HRESULT         hrFind      = S_OK;
    BOOL            fLockHeld   = FALSE;

    Assert(!pccfe.empty());

    // Get the lock, so our find/add can't allow a dupe.
    //

    // Fill the struct data, and push it on.
    //
    ConnListEntry   cle;
    cle.dwState     = CLEF_NONE;
    cle.ccfe        = pccfe;

    // Initialize the branding info
    cle.pcbi = NULL;
    cle.pctmd = NULL;
    if (cle.ccfe.GetCharacteristics() & NCCF_BRANDED)
    {
        HrGetBrandingInfo(cle);
    }
    Assert(!cle.empty());
    
    AcquireLock();
    
    TraceTag(ttidConnectionList, "Adding %S to the connection list", pccfe.GetName());

    ConnListEntry cleFind;
    hrFind =  HrFindConnectionByGuid(&(pccfe.GetGuidID()), cleFind);
    if (hrFind == S_FALSE)
    {
        // Allocate our list if we haven't already.
        //
        if (!m_pcclc)
        {
            m_pcclc = new ConnListCore;
        }

        // Allocate the structure to be pushed onto the STL list.
        //
        if (!m_pcclc)
        {
            hr = E_OUTOFMEMORY;
            ReleaseLock();
        }
        else
        {
            Assert(!cle.empty());

            (*m_pcclc)[cle.ccfe.GetGuidID()] = cle;
            ReleaseLock();

            if (m_fTiedToTray && g_pCTrayUI && cle.ccfe.FShouldHaveTrayIconDisplayed())
            {
                CONFOLDENTRY ccfeDup;
                hr = ccfeDup.HrDupFolderEntry(cle.ccfe);
                if (SUCCEEDED(hr))
                {
                    // Note: this must be a send message otherwise we can
                    // get duplicate icons in the tray. ;-(  We should set the
                    // uiTrayIconId here (while we have the lock) and PostMessage
                    // to actually add the tray icon, but that's a big change.
                    //
                    TraceTag(ttidSystray, "HrInsert: Adding tray icon for %S", cle.ccfe.GetName());
                    PostMessage(g_hwndTray, MYWM_ADDTRAYICON, (WPARAM) ccfeDup.TearOffItemIdList(), (LPARAM) 0);
                }
            }
        }
    }
    else
    {
        ReleaseLock();
        
        if (S_OK == hrFind)
        {
            TraceTag(ttidConnectionList, "Avoiding adding duplicate connection to the connection list");
        }
        else
        {
            // We had a failure finding the connection. We're hosed.
            TraceTag(ttidConnectionList, "Failure doing a findbyguid in the CConnectionList::HrInsert()");
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrInsert");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrInsertFromNetCon
//
//  Purpose:    Given an INetConnection *, build the cle data and insert
//              the new connection into the list. Return a PCONFOLDPIDL if
//              requested.
//
//  Arguments:
//      pNetCon [in]    The active INetConnection interface
//      ppcfp   [out]   Return pointer for PCFP, if requested
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrInsertFromNetCon(
    INetConnection *    pNetCon,
    PCONFOLDPIDL &      ppcfp)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT                hr              = S_OK;
    PCONFOLDPIDL           pidlConnection;
    CONFOLDENTRY           pccfe;

    Assert(pNetCon);

    NETCFG_TRY
    // From the net connection, create the pidl
        //
        hr = HrCreateConFoldPidl(WIZARD_NOT_WIZARD, pNetCon, pidlConnection);
        if (SUCCEEDED(hr))
        {
            // Convert the pidl to a ConFoldEntry.
            //
            hr = pidlConnection.ConvertToConFoldEntry(pccfe);
            if (SUCCEEDED(hr))
            {
                // Insert the item into the connection list. HrInsert should
                // take over this CONFOLDENTRY, so we can't delete it.
                // Note: We should kill this on fail, but we must make
                // sure that HrInsert doesn't keep the pointer anywhere on
                // failure.
                //
                hr = HrInsert(pccfe);
            }
        }

        if (SUCCEEDED(hr))
        {
            // Fill in the out param
            if ( !(pidlConnection.empty()) )
            {
                ppcfp = pidlConnection;
            }
        }

    NETCFG_CATCH(hr)
        
    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrInsertFromNetCon");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrInsertFromNetConPropertiesEx
//
//  Purpose:    Given an NETCON_PROPERTIES_EX&, build the cle data and insert
//              the new connection into the list. Return a PCONFOLDPIDL
//
//  Arguments:
//      pPropsEx [in]    The active NETCON_PROPERTIES_EX
//      ppcfp    [out]   Return PCONFOLDPIDL
//
//  Returns:
//
//  Author:     deonb   26 Mar 2001
//
//  Notes:
//
HRESULT CConnectionList::HrInsertFromNetConPropertiesEx(
        const NETCON_PROPERTIES_EX& pPropsEx,
        PCONFOLDPIDL &              ppcfp)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT                hr              = S_OK;
    PCONFOLDPIDL           pidlConnection;
    CONFOLDENTRY           pccfe;

    //
    hr = HrCreateConFoldPidl(pPropsEx, pidlConnection);
    if (SUCCEEDED(hr))
    {
        // Convert the pidl to a ConFoldEntry.
        //
        hr = pidlConnection.ConvertToConFoldEntry(pccfe);
        if (SUCCEEDED(hr))
        {
            // Insert the item into the connection list. HrInsert should
            // take over this CONFOLDENTRY, so we can't delete it.
            // Note: We should kill this on fail, but we must make
            // sure that HrInsert doesn't keep the pointer anywhere on
            // failure.
            //
            hr = HrInsert(pccfe);
        }
    }

    if (SUCCEEDED(hr))
    {
        // Fill in the out param
        if ( !(pidlConnection.empty()) )
        {
            ppcfp = pidlConnection;
        }
    }

        
    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrInsertFromNetCon");
    return hr;
}

// Old HrFindCallbackConnName
bool operator==(const ConnListCore::value_type& val, PCWSTR pszName)
{
    bool bRet = false;
    
    Assert(pszName);

    const ConnListEntry &cle = val.second;
    Assert(!cle.empty());
    Assert(!cle.ccfe.empty());
    Assert(cle.ccfe.GetName());
    
    if (lstrcmpiW(pszName, cle.ccfe.GetName()) == 0)
    {
        bRet = true;
    }
    
    return bRet;
}

// Old HrFindCallbackConFoldEntry
bool operator==(const ConnListCore::value_type& val, const CONFOLDENTRY& cfe)
{
    bool bRet = false;

    Assert(!cfe.empty())
    const ConnListEntry &cle = val.second;

    Assert(!cle.empty());
    Assert(!cfe.empty());
    
    Assert(!cle.ccfe.empty());
    Assert(cle.ccfe.GetName());
    
    if (cle.ccfe.GetWizard() && cfe.GetWizard())
    {
        bRet = true;
    }
    else
    {
        if (InlineIsEqualGUID(cfe.GetGuidID(), cle.ccfe.GetGuidID()))
        {
            bRet = true;
        }
    }
    
    return bRet;
}

// Old HrFindCallbackTrayIconId
bool operator==(const ConnListCore::value_type& val, const UINT& uiIcon)
{
    bool bRet = false;

    const ConnListEntry &cle = val.second;
    
    Assert(!cle.empty());
    Assert(!cle.ccfe.empty());

    if (cle.HasTrayIconData() && 
        (cle.GetTrayIconData()->GetTrayIconId() == uiIcon))
    {
        bRet = true;
    }
    
    return bRet;
}

// Old HrFindCallbackGuid
bool operator < (const GUID& rguid1, const GUID& rguid2)
{
    return memcmp(&rguid1, &rguid2, sizeof(GUID)) < 0;
}

BOOL ConnListEntry::empty() const
{
    return (ccfe.empty());
}

void ConnListEntry::clear()
{
    dwState = NULL;
    ccfe.clear();
    pctmd = NULL;
    pcbi = NULL;
    DeleteTrayIconData();
}

VOID CConnectionList::InternalAcquireLock()
{
    TraceFileFunc(ttidConnectionList);
    
    EnterCriticalSection(&m_csMain);
#if DBG
    m_dwCritSecRef++;
//    TraceTag(ttidConnectionList, "CConnectionList::AcquireLock (%d)", m_dwCritSecRef);
#endif
}

VOID CConnectionList::InternalReleaseLock()
{
    TraceFileFunc(ttidConnectionList);
    
#if DBG
    m_dwCritSecRef--;
//    TraceTag(ttidConnectionList, "CConnectionList::ReleaseLock (%d)", m_dwCritSecRef);
#endif
    LeaveCriticalSection(&m_csMain);
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrFindConnectionByName
//
//  Purpose:    Find a connection in the connection list, using
//              the connection name as the search key
//
//  Arguments:
//      pszName [in]    Name of the connection to find
//      cle     [out]   Return pointer for the connection entry
//
//  Returns:
//
//  Author:     jeffspr   20 Mar 1998
//
//  Notes:
//
inline HRESULT CConnectionList::HrFindConnectionByName(
    PCWSTR   pszName,
    ConnListEntry& cle)
{
    TraceFileFunc(ttidConnectionList);
    
    return HrFindConnectionByType( pszName, cle );
}

inline HRESULT CConnectionList::HrFindConnectionByConFoldEntry(
    const CONFOLDENTRY&  cfe,
    ConnListEntry& cle)
{
    TraceFileFunc(ttidConnectionList);
    
    return HrFindConnectionByType( cfe, cle );
}

inline HRESULT CConnectionList::HrFindConnectionByTrayIconId(
    UINT          uiIcon,
    ConnListEntry& cle)
{
    TraceFileFunc(ttidConnectionList);
    
    return HrFindConnectionByType( uiIcon, cle );
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrFindRasServerConnection
//
//  Purpose:    Find the RAS Server connection
//
//  Arguments:
//      cle [out] The connection list entry
//
//  Returns:
//
//  Author:     deonb 26 Apr 2001
//
//  Notes:
//
HRESULT CConnectionList::HrFindRasServerConnection(
    ConnListEntry& cle)
{
    HRESULT hr = S_FALSE;
    if (m_pcclc)
    {
        AcquireLock();

        ConnListCore::const_iterator clcIter;
        // Try to find the connection
        //
        for (clcIter = m_pcclc->begin(); clcIter != m_pcclc->end(); clcIter++)
        {
            if (!cle.ccfe.empty())
            {
                if (cle.ccfe.GetCharacteristics() & NCCF_INCOMING_ONLY)
                {
                    if (cle.ccfe.GetNetConMediaType() == NCM_NONE)
                    {
                        hr = S_OK;
                        break;
                    }
                }
            }
        }

        ReleaseLock();
    }
    else
    {
        hr = E_UNEXPECTED;
    }
    
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrFindPidlByGuid
//
//  Purpose:    Using a GUID, find the connection in the connection list
//              and, using the conlist pccfe member, generate a pidl. This
//              will be used in most of the notify sink refresh operations.
//
//  Arguments:
//      pguid [in]  Connection GUID
//      ppidl [out] Out param for the generated pidl
//
//  Returns:
//
//  Author:     jeffspr   28 Aug 1998
//
//  Notes:
//
HRESULT CConnectionList::HrFindPidlByGuid(
    IN const GUID *   pguid,
    OUT PCONFOLDPIDL& pidl)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr      = S_OK;
    ConnListEntry   cle;

    hr = HrFindConnectionByGuid(pguid, cle);
    if (S_OK == hr)
    {
        // convert to pidl and call the deleteccl
        //
        hr = cle.ccfe.ConvertToPidl(pidl);
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "CConnectionList::HrFindPidlByGuid");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrFindConnectionByGuid
//
//  Purpose:    Find the connection list entry based on the unique GUID
//              of the connection. Return the list entry to the caller.
//
//  Arguments:
//      pguid [in]  Lookup key
//      cle   [out] Return pointer for the list entry (see Notes:)
//
//  Returns:    S_OK, S_FALSE, or an error
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:      The list must be locked until the caller stops using
//              the returned entry
//
HRESULT CConnectionList::HrFindConnectionByGuid(
    const GUID UNALIGNED*pguid,
    ConnListEntry & cle)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT hr = S_FALSE;
    GUID alignedGuid;

    Assert(pguid);
    alignedGuid = *pguid;

    // Pre-NULL this out in case of failure.
    //
    if (m_pcclc)
    {
        AcquireLock();
        ConnListCore::iterator iter = m_pcclc->find(alignedGuid);

        if (iter != m_pcclc->end() )
        {
            cle = iter->second;

            Assert(!cle.ccfe.empty() );
            if (!cle.ccfe.empty())
            {
                cle.UpdateCreationTime();
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = S_FALSE;
        }
        ReleaseLock();
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrGetCurrentStatsForTrayIconId
//
//  Purpose:    Get the current statistics data from the connection
//              with the specified tray icon id.
//
//  Arguments:
//      uiIcon   [in]  Tray icon id.
//      ppData   [out] Address of where to return pointer to data.
//      pstrName [out] Address of a tstring where the name of the connection
//                     is returned.
//
//  Returns:    S_OK, S_FALSE if not found, or an error.
//
//  Author:     shaunco   7 Nov 1998
//
//  Notes:      Free the *ppData with CoTaskMemFree.
//
HRESULT CConnectionList::HrGetCurrentStatsForTrayIconId(
    UINT                    uiIcon,
    STATMON_ENGINEDATA**    ppData,
    tstring*                pstrName)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT                 hr;
    ConnListEntry           cle;
    INetStatisticsEngine*   pnse = NULL;

    // Initialize the output parameter.
    //
    if (ppData)
    {
        *ppData = NULL;
    }

    pstrName->erase();

    // Lock the list only long enough to find the entry and
    // get an AddRef'd copy of its INetStatisticsEngine interface pointer.
    // It's very important not to use this pointer while our lock is
    // held because doing so will cause it to try to get it's own lock.
    // If, on some other thread, that statistics engine is trying to call
    // back into us (and it already has its lock held), we'd have a dead lock.
    // AddRefing it ensures that the interface is valid even after we
    // release our lock.
    //
    AcquireLock();

    hr = HrFindConnectionByTrayIconId(uiIcon, cle);
    if (S_OK == hr)
    {
        Assert(cle.HasTrayIconData() );

        pnse = cle.GetTrayIconData()->GetNetStatisticsEngine();
        AddRefObj(pnse);
        
        // Make a copy of the name for the caller.
        //
        pstrName->assign(cle.ccfe.GetName());
    }

    ReleaseLock();

    // If we found the entry and obtained it's INetStatisticsEngine interface,
    // get the current statistics data from it and release it.
    //
    if (pnse && ppData)
    {
        hr = pnse->GetStatistics(ppData);
    }

    if (pnse)
    {
        ReleaseObj(pnse);
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "CConnectionList::HrGetCurrentStatsForTrayIconId");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrUpdateTrayIconIdByName
//
//  Purpose:    Update the connection list entry for a particular connection,
//              as the icon id has changed.
//
//  Arguments:
//      pszName     [in]    Name of the connection to update
//      pccts       [in]    Tray stats interface
//      pcpStat     [in]    Interface used for Advise
//      pnseStats   [in]    More statistics object crap
//      uiIcon      [in]    Icon ID to be stored in that entry
//
//  Returns:    S_OK, S_FALSE if not found, or an error code.
//
//  Author:     jeffspr   20 Mar 1998
//
//  Notes:
//
HRESULT CConnectionList::HrUpdateTrayIconDataByGuid(
        const GUID *            pguid,
        CConnectionTrayStats *  pccts,
        IConnectionPoint *      pcpStat,
        INetStatisticsEngine *  pnseStats,
        UINT                    uiIcon)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr              = S_OK;
    ConnListEntry   cle;

    AcquireWriteLock();
    hr = HrFindConnectionByGuid(pguid, cle);
    if (hr == S_OK)
    {
        Assert(!cle.empty());

        CTrayIconData pTrayIconData(uiIcon, cle.ccfe.GetNetConStatus(), pcpStat, pnseStats, pccts);
        cle.SetTrayIconData(pTrayIconData);

        hr = HrUpdateConnectionByGuid(pguid, cle);
    }
    ReleaseWriteLock();

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "CConnectionList::HrUpdateTrayIconDataByGuid");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrUpdateTrayBalloonInfoByGuid
//
//  Purpose:    Update the balloon entry for a particular connection,
//
//  Arguments:
//      pguid                [in] Guid of the connection to update
//      dwLastBalloonMessage [in] BALLOONS enum 
//      szCookie             [in] Cookie
//      pfnBalloonFunction   [in] Balloon callback function if BALLOONS == BALLOON_CALLBACK
//
//  Returns:    S_OK, S_FALSE if not found, or an error code.
//
//  Author:     deon   22 Mar 2001
//
//  Notes:
//
HRESULT CConnectionList::HrUpdateTrayBalloonInfoByGuid(
                                                       const GUID *     pguid,
                                                       DWORD            dwLastBalloonMessage, 
                                                       BSTR             szCookie,
                                                       FNBALLOONCLICK*  pfnBalloonFunction)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr              = S_OK;
    ConnListEntry   cle;
    
    AcquireWriteLock();
    hr = HrFindConnectionByGuid(pguid, cle);
    if (hr == S_OK)
    {
        Assert(!cle.empty());

        
        CTrayIconData * pTrayIconData = cle.GetTrayIconData();
        if (pTrayIconData != NULL)
        {
            hr = pTrayIconData->SetBalloonInfo(dwLastBalloonMessage, szCookie, pfnBalloonFunction);
            if (SUCCEEDED(hr))
            {
                hr = HrUpdateConnectionByGuid(pguid, cle);
            }
        }
    }
    ReleaseWriteLock();
    
    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "CConnectionList::HrUpdateTrayBalloonInfoByGuid");
    return hr;
}

HRESULT CConnectionList::HrUpdateConnectionByGuid(IN  const GUID *         pguid,
                                                  IN  const ConnListEntry& cle )
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT hr = S_OK;

    GUID alignedGuid;
    Assert(pguid);
    alignedGuid = *pguid;

    if (m_pcclc)
    {
        ConnListEntry cleCopy(cle);

        AcquireLock();
        ConnListCore::iterator iter = m_pcclc->find(alignedGuid);
        
        if (iter != m_pcclc->end() )
        {
            // If what we have in the list is already more recent, just discard the change
            if ( iter->second.GetCreationTime() <= cleCopy.GetCreationTime() )
            {
                iter->second = cleCopy;
                hr = S_OK;
            }
            else
            {
                TraceError("HrUpdateConnectionByGuid discarded older ConnectionListEntry", E_FAIL);
                hr = S_FALSE;
            }
                
            Assert(!cleCopy.empty());
        }
        else
        {
            hr = E_FAIL;
        }
        ReleaseLock();
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrUpdateNameByGuid
//
//  Purpose:    Update the list with the new connection name. Search for the
//              connection using the guid. Depending on the value of fForce,
//              either fail a duplicate connection name or force the issue
//              (since this might be as a result of a shell call, which we
//              have no control over)
//
//  Arguments:
//      pguid      [in]     Lookup key
//      pszNewName [in]     New name for the connection
//      ppidlOut   [out]    Output pidl, if requested
//      fForce     [in]     Force the name change, or fail on duplicate?
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrUpdateNameByGuid(
    IN  const GUID *        pguid,
    IN  PCWSTR              pszNewName,
    OUT PCONFOLDPIDL &      pidlOut,
    IN  BOOL                fForce)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr          = S_OK;
    ConnListEntry   cle;

    Assert(pguid);
    Assert(pszNewName);

    AcquireWriteLock();

    hr = HrFindConnectionByGuid(pguid, cle);
    if (S_OK == hr)
    {
        // Check to see if we already have an entry with this name
        //
        ConnListEntry   cleDupe;
        hr = HrFindConnectionByName(pszNewName, cleDupe);
        if (S_OK == hr && !fForce)
        {
            Assert(!cleDupe.empty());

            hr = NETCFG_E_NAME_IN_USE;
        }
        else
        {
            // This is what we want.. Either there's not already a connection
            // with this name or we are allowing ourselves to rename it to
            // a duplicate string (this can occur when RAS is notifying us of
            // a change -- you know, separate phonebooks and all).
            //
            if ((S_FALSE == hr) || (hr == S_OK && fForce))
            {
                PWSTR pszNewNameCopy = NULL;

                if (!(cle.ccfe.GetWizard()))
                {
                    hr = HrDupeShellString(pszNewName, &pszNewNameCopy);
                    if (SUCCEEDED(hr))
                    {
                        Assert(pszNewNameCopy);

                        // If it's not the static wizard string, and it's non-NULL then
                        // free it
                        //
                        cle.ccfe.SetPName(pszNewNameCopy);

                        // If we're to return a new PIDL for this entry
                        //
                        // Convert the class back to the pidl format
                        //
                        hr = cle.ccfe.ConvertToPidl(pidlOut);
                    }
                }
            }
            else
            {
                AssertSz(FALSE, "Error occurred while attempting to find a dupe in HrUpdateNameByGuid");
            }
        }
        
        if (SUCCEEDED(hr))
        {
            hr = HrUpdateConnectionByGuid(pguid, cle);
        }
    }

    ReleaseWriteLock();

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrUpdateNameByGuid");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrUpdateTrayIconByGuid
//
//  Purpose:    Update the icon image based on the connection changes.
//              Do the lookup by GUID.
//
//  Arguments:
//      pguid [in]  GUID of the changed connection
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrUpdateTrayIconByGuid(
    const GUID *    pguid,
    BOOL            fBrieflyShowBalloon)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr          = S_OK;
    ConnListEntry   cle;

    Assert(m_fTiedToTray);

    TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid");

    if (!g_pCTrayUI || !m_fTiedToTray)
    {
        TraceTag(ttidConnectionList, "!g_pCTrayUI || !m_fTiedToTray, so no updates");
        return S_OK;
    }

    Assert(pguid);

    AcquireWriteLock();

    hr = HrFindConnectionByGuid(pguid, cle);
    if (S_OK == hr)
    {
        GUID * pguidCopy = NULL;

        BOOL fShouldHaveIcon = cle.ccfe.FShouldHaveTrayIconDisplayed();
        BOOL fShouldRemoveOld = FALSE;

        TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: Found. fShouldHave: %d",
            fShouldHaveIcon);

        // If there's an existing icon, see if it needs to go away
        if (cle.HasTrayIconData())
        {
            // If we need to remove a media-disconnected icon, do so.
            //
            if (cle.ccfe.GetNetConStatus() != cle.GetTrayIconData()->GetConnected()) // If the status has changed.
            {
                NETCON_STATUS ncsOldStatus = cle.GetTrayIconData()->GetConnected();
                NETCON_STATUS ncsNewStatus = cle.ccfe.GetNetConStatus();

                if ( (NCS_INVALID_ADDRESS    == ncsNewStatus) || // Definitely changes the icon
                     (NCS_MEDIA_DISCONNECTED == ncsNewStatus) || // Definitely changes the icon
                     (NCS_INVALID_ADDRESS    == ncsOldStatus) || // Definitely changes the icon
                     (NCS_MEDIA_DISCONNECTED == ncsOldStatus) || // Definitely changes the icon
                     ( (fIsConnectedStatus(ncsOldStatus) != fIsConnectedStatus(ncsNewStatus)) && // From connect to disconnect or disconnect to connect
                       !((NCS_DISCONNECTING == ncsOldStatus) && (NCS_CONNECTED  == ncsNewStatus)) && // BUT NOT going from Disconnecting to Connect (BAP dialup failure)
                       !((NCS_CONNECTED     == ncsOldStatus) && (NCS_CONNECTING == ncsNewStatus)) // Or from Connect to Connecting (BAP dialup failure)
                     )
                   )
                {
                    // if we are changing to one of these states, we need to remove whatever was there previously
                    TraceTag(ttidConnectionList, "HrUpdateTrayByGuid: Need to remove icon");
                    fShouldRemoveOld = TRUE;
                }
            }
            // Else if we just don't need one anymore...
            //
            else if (!fShouldHaveIcon)
            {
                TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: Shouldn't have a tray icon. Need to remove");
                fShouldRemoveOld = TRUE;
            }
        }
        else
        {
            TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid. No existing icon (for removal)");
            pguidCopy = new GUID;

            // Copy the guid
            if (pguidCopy)
            {
                CopyMemory(pguidCopy, pguid, sizeof(GUID));
            }
        }

        TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: Found. fShouldHave: %d, fShouldRemove: %d",
            fShouldHaveIcon, fShouldRemoveOld);

        if (fShouldRemoveOld || pguidCopy)
        {
            TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: Posting icon removal");

            if (cle.HasTrayIconData())
            {
                CTrayIconData* pTrayIconData = new CTrayIconData(*cle.GetTrayIconData());
                cle.DeleteTrayIconData();

                TraceTag(ttidSystray, "HrUpdateTrayIconByGuid: Removing tray icon for %S", cle.ccfe.GetName());
                PostMessage(g_hwndTray, MYWM_REMOVETRAYICON, (WPARAM) pTrayIconData, (LPARAM) 0);
            }
            else
            {
                TraceTag(ttidSystray, "HrUpdateTrayIconByGuid: Removing tray icon [FROM GUID] for %S", cle.ccfe.GetName());
                PostMessage(g_hwndTray, MYWM_REMOVETRAYICON, (WPARAM) 0, (LPARAM) pguidCopy);
            }


            TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: Back from icon removal");
        }

        TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: cle.pTrayIconData: 0x%08x, fShouldHave: %d",
            cle.GetTrayIconData(), fShouldHaveIcon);

        // If there's no tray icon, but the characteristics say that there should be,
        // add one.
        //
        if ((!cle.HasTrayIconData()) && fShouldHaveIcon)
        {
            TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: Adding tray icon");

            CONFOLDENTRY ccfeDup;
            hr = ccfeDup.HrDupFolderEntry(cle.ccfe);
            if (SUCCEEDED(hr))
            {
                    TraceTag(ttidSystray, "HrUpdateTrayIconByGuid: Adding tray icon for %S", cle.ccfe.GetName());
                    PostMessage(g_hwndTray, MYWM_ADDTRAYICON, (WPARAM) ccfeDup.TearOffItemIdList(), (LPARAM) fBrieflyShowBalloon);
            }
        }
        else
        {
            TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: Not adding an icon");
        }

        if (SUCCEEDED(hr))
        {
            hr = HrUpdateConnectionByGuid(pguid, cle);
        }
    }

    ReleaseWriteLock();

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrUpdateTrayIconByGuid");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrSuggestNameForDuplicate
//
//  Purpose:    Given an existing connection name, suggest a new name
//              based on name conflict resolution rules
//
//  Arguments:
//      pszOriginal [in]    Name being copied
//      ppszNew     [out]   Suggested duplicate
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrSuggestNameForDuplicate(
    PCWSTR      pszOriginal,
    PWSTR *    ppszNew)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr              = S_OK;
    PWSTR           pszReturn       = NULL;
    DWORD           dwLength        = lstrlenW(pszOriginal);
    BOOL            fUnique         = FALSE;
    ConnListEntry   cle;

    // Maximum # of digits for resolving duplicates = 999999
    static const DWORD  c_cmaxDigits = 6;
    static const DWORD  c_cmaxSuggest = 999999;

    if (dwLength == 0)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        dwLength += lstrlenW(SzLoadIds(IDS_CONFOLD_DUPLICATE_PREFIX2)) +
            c_cmaxDigits;

        pszReturn = new WCHAR[dwLength + 1];
        if (!pszReturn)
        {
            hr = E_FAIL;
        }
        else
        {
            INT     cSuggest = 0;

            while (!fUnique && SUCCEEDED(hr) && (cSuggest <= c_cmaxSuggest))
            {
                if (!cSuggest)
                {
                    // Try "Copy of <foo>" first
                    DwFormatString(SzLoadIds(IDS_CONFOLD_DUPLICATE_PREFIX1),
                                   pszReturn, dwLength, pszOriginal);
                }
                else
                {
                    WCHAR   szDigits[c_cmaxDigits + 1];

                    wsprintfW(szDigits, L"%lu", cSuggest + 1);

                    // Try "Copy (x) of <foo>" now.
                    DwFormatString(SzLoadIds(IDS_CONFOLD_DUPLICATE_PREFIX2),
                                   pszReturn, dwLength, szDigits,
                                   pszOriginal);
                }

                if (lstrlenW(pszReturn) > 255)
                {
                    pszReturn[255] = '\0'; // Truncate if too long
                }

                // See if it already exists
                //
                hr = HrFindConnectionByName(pszReturn, cle);
                if (SUCCEEDED(hr))
                {
                    if (hr == S_FALSE)
                    {
                        // Normalize the hr -- don't want to return S_FALSE;
                        //
                        hr = S_OK;
                        fUnique = TRUE;
                    }
                }

                cSuggest++;
            }

            // If we're still not unique, then we're out of range, and fail out.
            //
            if (!fUnique)
            {
                hr = E_FAIL;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        *ppszNew = pszReturn;
    }
    else
    {
        if (pszReturn)
        {
            delete [] pszReturn;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrSuggestNameForDuplicate");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrGetCachedPidlCopyFromPidl
//
//  Purpose:    Given an existing (likely outdated) pidl, retrieve the
//              cached info from the list and build an up-to-date pidl
//
//  Arguments:
//      pidl  [in]      Not-necessarily-new pidl
//      ppcfp [out]     New pidl using cached data
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrGetCachedPidlCopyFromPidl(
    const PCONFOLDPIDL& pidl,
    PCONFOLDPIDL &      pcfp)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr      = S_OK;
    ConnListEntry   cle;

    Assert(!pidl.empty());

    NETCFG_TRY

        pcfp.Clear();

        // Verify that this is a confoldpidl
        //
        if (pidl->IsPidlOfThisType())
        {
            hr = HrFindConnectionByGuid(&(pidl->guidId), cle);
            if (S_OK == hr)
            {
                Assert(!cle.empty());
                Assert(!cle.ccfe.empty());

                CONFOLDENTRY &pccfe = cle.ccfe;
                hr = pccfe.ConvertToPidl(pcfp);
            }
            else
            {
                pcfp = pidl;
            }
        }
        else
        {
            pcfp = pidl;
            hr = S_OK;
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "CConnectionList::HrGetCachedPidlCopyFromPidl");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrMapCMHiddenConnectionToOwner
//
//  Purpose:    Maps a child connection to its parent connection.
//
//              Connection Manager has two stages: Dialup and VPN.
//              For the Dialup it creates a hidden connectoid that the 
//              folder (netshell) does not see. However netman caches
//              the name, guid and status of this connectedoid. Both 
//              the parent and child connectoid have the same name. When 
//              the status of the hidden connectiod is updated the folder 
//              recives the guid of the hidden connectoid and maps the 
//              connectiod to it parent (Connection Manager) by searching 
//              netmans cache for the name of the hidden connectoid. Then it
//              searches the connections in the folder for that name and thus
//              gets the guid of the parent connectoid.     
//
//              When the folder gets a notify message from netman for the hidden 
//              connection it uses this function to find the parent and update the 
//              parent's status. The hidden connection is not displayed.
//
//  Arguments:
//      guidHidden   [in]   GUID of the hidden connectiod
//      pguidOwner   [out]  GUID of the parent connectiod
//
//  Returns:    S_OK -- mapped the hidden connection to its parent
//
//  Author:     omiller   1 Jun 2000
//
//  Notes:
//
HRESULT CConnectionList::HrMapCMHiddenConnectionToOwner(REFGUID guidHidden, GUID * pguidOwner)
{
    TraceFileFunc(ttidConnectionList);
    
    INetConnectionCMUtil * pCMUtil;
    HRESULT hr = S_OK;

    hr = HrCreateInstance(
                CLSID_ConnectionManager,
                CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                &pCMUtil);   

    if( SUCCEEDED(hr) )
    {
        // Map the hidden connection to its parent.
        //
        hr = pCMUtil->MapCMHiddenConnectionToOwner(guidHidden, pguidOwner);

        ReleaseObj(pCMUtil);
    }

    
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrUnsetCurrentDefault
//
//  Purpose:    Searches for the current default connection and clear
//				the default flag.
//
//  Arguments:
//      guidHidden   [in]   GUID of the hidden connectiod
//      pguidOwner   [out]  GUID of the parent connectiod
//
//  Returns:    S_OK -- mapped the hidden connection to its parent
//
//  Author:     deonb   4 Apr 2001
//
//  Notes:
//
HRESULT CConnectionList::HrUnsetCurrentDefault(OUT PCONFOLDPIDL& cfpPreviousDefault)
{
    HRESULT hr = S_FALSE;

    AcquireLock();

    ConnListCore::iterator  clcIter;

    // Iterate through the list and search for the old default connection.
    //
    for (clcIter = m_pcclc->begin(); clcIter != m_pcclc->end(); clcIter++)
    {
        ConnListEntry &cle = clcIter->second;
        if (!cle.ccfe.empty())
        {
            if (cle.ccfe.GetCharacteristics() & NCCF_DEFAULT)
            {
                cle.ccfe.SetCharacteristics(cle.ccfe.GetCharacteristics() & ~NCCF_DEFAULT);
                hr = cle.ccfe.ConvertToPidl(cfpPreviousDefault);
                break;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    ReleaseLock();

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrHasActiveIncomingConnections
//
//  Purpose:    See if there are active incoming connections active (apart from
//              the RAS server).
//
//  Arguments:  pdwCount   [out]   Number of incoming connections
//
//  Returns:    S_OK    -- Has active incoming connections 
//              S_FALSE -- Does not have active incoming connections 
//              FAILED(HRESULT) if failed
//
//  Author:     deonb   24 Apr 2001
//
//  Notes:
//
HRESULT CConnectionList::HasActiveIncomingConnections(LPDWORD pdwCount)
{
    HRESULT hr = S_FALSE;

    Assert(pdwCount);
    *pdwCount = 0;

    AcquireLock();

    ConnListCore::iterator  clcIter;
    BOOL bRasServer = FALSE;

    // Iterate through the list and search for the old default connection.
    //
    for (clcIter = m_pcclc->begin(); clcIter != m_pcclc->end(); clcIter++)
    {
        ConnListEntry &cle = clcIter->second;
        if (!cle.ccfe.empty())
        {
            if (cle.ccfe.GetCharacteristics() & NCCF_INCOMING_ONLY)
            {
                if (cle.ccfe.GetNetConMediaType() == NCM_NONE)
                {
                    AssertSz(!bRasServer, "How did you get more than one RAS Server?");
                    bRasServer = TRUE;
                }
                else
                {
                    (*pdwCount)++;
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    ReleaseLock();

    if (SUCCEEDED(hr))
    {
        if (*pdwCount)
        {
            AssertSz(bRasServer, "How did you get Incoming Connections without a RAS Server?")
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCheckForActivation
//
//  Purpose:    Check to see if this connection is in the process of
//              activating (so we can disallow delete/rename/etc.).
//
//  Arguments:
//      pccfe        [in]   ConFoldEntry to check
//      pfActivating [out]  Return pointer for activating yes/no
//
//  Returns:    S_OK on success, S_FALSE if connection not found, or
//              any upstream error code.
//
//  Author:     jeffspr   4 Jun 1998
//
//  Notes:
//
HRESULT HrCheckForActivation(
    const PCONFOLDPIDL& pcfp,
    const CONFOLDENTRY& pccfe,
    BOOL *          pfActivating)
{
    HRESULT         hr          = S_OK;
    ConnListEntry   cle;
    BOOL            fActivating = FALSE;

    Assert(pfActivating);
    Assert(! (pccfe.empty() && pcfp.empty()) ); // Must specify one of the two

    if (!pccfe.empty())
    {
        hr = g_ccl.HrFindConnectionByConFoldEntry(pccfe, cle);
    }
    else
    {
        hr = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), cle);
    }

    if (S_OK == hr)
    {
        fActivating = (cle.dwState & CLEF_ACTIVATING);
    }

    if (SUCCEEDED(hr))
    {
        *pfActivating = fActivating;
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "HrCheckForActivation");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetActivationFlag
//
//  Purpose:    Set the activation flag for a particular connection
//
//  Arguments:
//      pcfp        [in]    Either this pidl or the pconfoldentry below
//      pccfe       [in]    must be valid.
//      fActivating [out]   Current activation status
//
//  Returns:
//
//  Author:     jeffspr   5 Jun 1998
//
//  Notes:
//
HRESULT HrSetActivationFlag(
    const PCONFOLDPIDL& pcfp,
    const CONFOLDENTRY& pccfe,
    BOOL            fActivating)
{
    HRESULT         hr          = S_OK;
    ConnListEntry   cle;

    // If the pccfe is valid, use that. Otherwise, use the guid from the pidl
    //
#ifdef DBG
    if (FIsDebugFlagSet(dfidTraceFileFunc))
    {
        TraceTag(ttidConnectionList, "Acquiring LOCK: %s, %s, %d", __FUNCTION__, __FILE__, __LINE__); 
    }
#endif
    g_ccl.AcquireWriteLock();

    if (!pccfe.empty())
    {
        hr = g_ccl.HrFindConnectionByConFoldEntry(pccfe, cle);
    }
    else
    {
        Assert(!pcfp.empty());
        hr = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), cle);
    }

    if (S_OK == hr)
    {
        // Assert that the state isn't already set this way.
        //
//        Assert((!!(cle.dwState & CLEF_ACTIVATING)) != fActivating);

        if (fActivating)
        {
            cle.dwState |= CLEF_ACTIVATING;
        }
        else
        {
            cle.dwState &= ~CLEF_ACTIVATING;
        }
        g_ccl.HrUpdateConnectionByGuid(&(cle.ccfe.GetGuidID()), cle);
    }
#ifdef DBG
if (FIsDebugFlagSet(dfidTraceFileFunc))
{
    TraceTag(ttidConnectionList, "Releasing LOCK: %s, %s, %d", __FUNCTION__, __FILE__, __LINE__); 
}
#endif
    g_ccl.ReleaseWriteLock();

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "HrSetActivationFlag");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetTrayIconLock
//
//  Purpose:    Get a lock for the tray icon -- keeps us from getting
//              duplicate icons in the tray if two enumerations are occurring
//              simultaneously
//
//  Arguments:
//      pguid [in] Item for which to set the lock
//
//  Returns:    S_OK if the lock could be set. S_FALSE otherwise.
//
//  Author:     jeffspr   23 Oct 1998
//
//  Notes:
//
HRESULT HrGetTrayIconLock(
    const GUID *          pguid,
    UINT *          puiIcon,
    LPDWORD pdwLockingThreadId)
{
    HRESULT         hr          = S_OK;
    ConnListEntry   cle;

    Assert(pguid);
    // Otherwise, use the guid from the pidl
    //
    TraceTag(ttidSystray, "Acquiring Tray icon lock"); 

    g_ccl.AcquireWriteLock();
    
    hr = g_ccl.HrFindConnectionByGuid(pguid, cle);
    if (S_OK == hr)
    {
        if (cle.dwState & CLEF_TRAY_ICON_LOCKED)
        {
            hr = S_FALSE;
#ifdef DBG
// if (pdwLockingThreadId)
{
    Assert(cle.dwLockingThreadId);
    *pdwLockingThreadId = cle.dwLockingThreadId;
}
#endif
        }
        else
        {
            cle.dwState |= CLEF_TRAY_ICON_LOCKED;
#ifdef DBG
            cle.dwLockingThreadId = GetCurrentThreadId();
#endif
            if (puiIcon)
            {
                if (cle.HasTrayIconData())
                {
                    *puiIcon = cle.GetTrayIconData()->GetTrayIconId();
                }
                else
                {
                    *puiIcon = BOGUS_TRAY_ICON_ID;
                }
            }
            g_ccl.HrUpdateConnectionByGuid(pguid, cle);
            Assert(cle.dwLockingThreadId);
        }
    }
    else
    {
        hr = E_FILE_NOT_FOUND;
    }

    g_ccl.ReleaseWriteLock();

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "HrGetTrayIconLock");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseTrayIconLock
//
//  Purpose:    Release a lock (if held) on a particular tray icon
//
//  Arguments:
//      pguid [in]  Item for which to release the lock
//
//  Returns:
//
//  Author:     jeffspr   23 Oct 1998
//
//  Notes:
//
VOID ReleaseTrayIconLock(
    const GUID *  pguid)
{
    HRESULT         hr          = S_OK;
    ConnListEntry   cle;

    g_ccl.AcquireWriteLock();
    Assert(pguid);

    hr = g_ccl.HrFindConnectionByGuid(pguid, cle);
    if (S_OK == hr)
    {
        // Ignore whether or not this flag has already been removed.
        //
        cle.dwState &= ~CLEF_TRAY_ICON_LOCKED;
#ifdef DBG
        cle.dwLockingThreadId = 0;
#endif
        g_ccl.HrUpdateConnectionByGuid(pguid, cle);
    }

    g_ccl.ReleaseWriteLock();
    
    TraceTag(ttidSystray, "Releasing Tray icon lock"); 
    
    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "ReleaseTrayIconLock");
}

ConnListEntry::ConnListEntry() : dwState(0), m_pTrayIconData(NULL), pctmd(NULL), pcbi(NULL)
{
    TraceFileFunc(ttidConnectionList);
    m_CreationTime = GetTickCount();
#ifdef DBG
    dwLockingThreadId = 0;
#endif
}

ConnListEntry::ConnListEntry(const ConnListEntry& ConnectionListEntry)
{
    TraceFileFunc(ttidConnectionList);

#ifdef DBG
    dwLockingThreadId = ConnectionListEntry.dwLockingThreadId;
#endif

    m_CreationTime  = ConnectionListEntry.m_CreationTime;
    
    dwState         = ConnectionListEntry.dwState;
    ccfe            = ConnectionListEntry.ccfe;
    if (ConnectionListEntry.HasTrayIconData())
    {
        m_pTrayIconData = new CTrayIconData(*ConnectionListEntry.GetTrayIconData());
    }
    else
    {
        m_pTrayIconData = NULL;
    }
    pctmd         = ConnectionListEntry.pctmd;
    pcbi          = ConnectionListEntry.pcbi;
}

ConnListEntry& ConnListEntry::operator =(const ConnListEntry& ConnectionListEntry)
{
    TraceFileFunc(ttidConnectionList);

    m_CreationTime  = ConnectionListEntry.m_CreationTime;

#ifdef DBG
    dwLockingThreadId = ConnectionListEntry.dwLockingThreadId;
#endif
    dwState         = ConnectionListEntry.dwState;
    ccfe            = ConnectionListEntry.ccfe;

    if (ConnectionListEntry.HasTrayIconData())
    {
        if (m_pTrayIconData)
        {
            delete m_pTrayIconData;
            m_pTrayIconData = NULL;
        }
        m_pTrayIconData = new CTrayIconData(*ConnectionListEntry.GetTrayIconData());
    }
    else
    {
        if (m_pTrayIconData)
        {
            delete m_pTrayIconData;
            m_pTrayIconData = NULL;
        }
        else
        {
            m_pTrayIconData = NULL;
        }
    }
    pctmd         = ConnectionListEntry.pctmd;
    pcbi          = ConnectionListEntry.pcbi;
    return *this;
}

ConnListEntry::~ConnListEntry()
{
    TraceFileFunc(ttidConnectionList);
    
    delete m_pTrayIconData;
    m_pTrayIconData = NULL;
}

void CConnectionList::AcquireWriteLock()
{

    EnterCriticalSection(&m_csWriteLock);
#ifdef DBG
    m_dwWriteLockRef++;
    TraceTag(ttidConnectionList, "CConnectionList::AcquireWriteLock (%d)", m_dwWriteLockRef);
#endif
}

void CConnectionList::ReleaseWriteLock()
{
#ifdef DBG
    m_dwWriteLockRef--;
    TraceTag(ttidConnectionList, "CConnectionList::ReleaseWriteLock (%d)", m_dwWriteLockRef);
#endif
    LeaveCriticalSection(&m_csWriteLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\connlist.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N N L I S T . H
//
//  Contents:   Connection list class -- subclass of the stl list<> code.
//
//  Notes:
//
//  Author:     jeffspr   19 Feb 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _CONNLIST_H_
#define _CONNLIST_H_

// Icon ID to use for a connection that doesn't have a tray entry
//
#define BOGUS_TRAY_ICON_ID      (UINT) -1


// #define VERYSTRICTCOMPILE

#ifdef VERYSTRICTCOMPILE
#define CONST_IFSTRICT const
#else
#define CONST_IFSTRICT 
#endif

typedef HRESULT FNBALLOONCLICK(IN const GUID * pGUIDConn, 
                               IN const BSTR pszConnectionName,
                               IN const BSTR szCookie);

typedef enum tagConnListEntryStateFlags
{
    CLEF_NONE               = 0x0000,   // No special characteristics
    CLEF_ACTIVATING         = 0x0001,   // In the process of connecting
    CLEF_TRAY_ICON_LOCKED   = 0x0002    // Tray icon state is being updated
} CONNLISTENTRYFLAGS;

// Define our structure that will be stored in the list<>
//
class CTrayIconData
{
private:
    CTrayIconData* operator &();
    CTrayIconData& operator =(const CTrayIconData&);
public:
    explicit CTrayIconData(const CTrayIconData &);
    CTrayIconData(UINT uiTrayIconId, NETCON_STATUS ncs, IConnectionPoint * pcpStat, INetStatisticsEngine * pnseStats, CConnectionTrayStats * pccts);
//private:
    ~CTrayIconData();

public:
    inline const UINT GetTrayIconId() const { return m_uiTrayIconId; }
    inline const NETCON_STATUS GetConnected() const  { return m_ncs; }
    inline CONST_IFSTRICT INetStatisticsEngine * GetNetStatisticsEngine() { return m_pnseStats; }
    inline CONST_IFSTRICT CConnectionTrayStats * GetConnectionTrayStats() { return m_pccts; }
    inline CONST_IFSTRICT IConnectionPoint     * GetConnectionPoint() { return m_pcpStat; }
    inline const DWORD GetLastBalloonMessage() { return m_dwLastBalloonMessage; }
    inline FNBALLOONCLICK* GetLastBalloonFunction() { return m_pfnBalloonFunction; }
    inline const BSTR GetLastBalloonCookie() { return m_szCookie; }
    
    HRESULT SetBalloonInfo(DWORD dwLastBalloonMessage, BSTR szCookie, FNBALLOONCLICK* pfnBalloonFunction);

private:
    UINT                    m_uiTrayIconId;
    NETCON_STATUS           m_ncs;
    IConnectionPoint *      m_pcpStat;
    INetStatisticsEngine *  m_pnseStats;
    CConnectionTrayStats *  m_pccts;

    DWORD                   m_dwLastBalloonMessage;
    BSTR                    m_szCookie;
    FNBALLOONCLICK *        m_pfnBalloonFunction;
};

// typedef TRAYICONDATA * PTRAYICONDATA;
// typedef const TRAYICONDATA * PCTRAYICONDATA;


class ConnListEntry
{
public:
    ConnListEntry& operator =(const ConnListEntry& ConnectionListEntry);
    explicit ConnListEntry(const ConnListEntry& ConnectionListEntry);
    ConnListEntry();
    ~ConnListEntry();
    
    DWORD             dwState;        // bitmask of CONNLISTENTRYFLAGS
    CONFOLDENTRY      ccfe;
    CONST_IFSTRICT CON_TRAY_MENU_DATA * pctmd;
    CONST_IFSTRICT CON_BRANDING_INFO  * pcbi;

    inline CONST_IFSTRICT CTrayIconData* GetTrayIconData() const;
    inline BOOL HasTrayIconData() const;
    inline const BOOL GetCreationTime() const { return m_CreationTime; };
    inline void UpdateCreationTime() { m_CreationTime = GetTickCount(); };
    
    HRESULT SetTrayIconData(const CTrayIconData& TrayIconData);
    HRESULT DeleteTrayIconData();
    
#ifdef DBG
    DWORD dwLockingThreadId;
#endif
private:
    CONST_IFSTRICT CTrayIconData * m_pTrayIconData;
    DWORD m_CreationTime;

#ifdef VERYSTRICTCOMPILE
private:
    const ConnListEntry* operator& ();
#endif
public:
    
    BOOL empty() const;
    void clear();

};

// This is the callback definition. Each find routine will be a separate
// callback function
//
// typedef HRESULT (CALLBACK *PFNCONNLISTICONREMOVALCB)(UINT);

// We are creating a list of Connection entries
//
typedef map<GUID, ConnListEntry> ConnListCore;

// Our find callbacks
//
// For ALGO find
bool operator==(const ConnListEntry& val, PCWSTR pszName);          // HrFindCallbackConnName
bool operator==(const ConnListEntry& cle, const CONFOLDENTRY& cfe); // HrFindCallbackConFoldEntry
bool operator==(const ConnListEntry& cle, const UINT& uiIcon);      // HrFindCallbackTrayIconId

// For map::find
bool operator < (const GUID& rguid1, const GUID& rguid2);           // HrFindCallbackGuid

// Global connection list wrapper
//
#ifdef DBG
    #define AcquireLock() if (FIsDebugFlagSet(dfidTraceFileFunc)) {TraceTag(ttidShellFolder, "Acquiring LOCK: %s, %s, %d", __FUNCTION__, __FILE__, __LINE__);} InternalAcquireLock();
    #define ReleaseLock() if (FIsDebugFlagSet(dfidTraceFileFunc)) {TraceTag(ttidShellFolder, "Releasing LOCK: %s, %s, %d", __FUNCTION__, __FILE__, __LINE__);} InternalReleaseLock();
#else
    #define AcquireLock() InternalAcquireLock();
    #define ReleaseLock() InternalReleaseLock();
#endif

class CConnectionList
{
  public:
    // No constructor/destructor because we have a global instance of this
    // object.  Use manual Initialize/Uninitialize instead.
    //
    VOID Initialize(BOOL fTieToTray, BOOL fAdviseOnThis);
    VOID Uninitialize(BOOL fFinalUninitialize = FALSE);

  private:
    template <class T> 
        HRESULT HrFindConnectionByType (const T& findbyType, ConnListEntry& cle)
        {
            HRESULT hr = S_FALSE;
            if (m_pcclc)
            {
                AcquireLock();
                
                // Try to find the connection
                //
                ConnListCore::const_iterator iter;
                iter = find(m_pcclc->begin(), m_pcclc->end(), findbyType);
                
                if (iter == m_pcclc->end())
                {
                    hr = S_FALSE;
                }
                else
                {
                    cle = iter->second;
                    Assert(!cle.ccfe.empty() );
                    if (!cle.ccfe.empty())
                    {                    
                        cle.UpdateCreationTime();
                        hr = S_OK;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                ReleaseLock();
            }
            else
            {
                return S_FALSE;
            }
            return hr;
        }
    
        ConnListCore*          m_pcclc;
        bool                   m_fPopulated;
        CRITICAL_SECTION       m_csMain;
        DWORD                  m_dwAdviseCookie;
        BOOL                   m_fTiedToTray;
    BOOL                   m_fAdviseOnThis;

    static DWORD  NotifyThread(LPVOID pConnectionList);
    static DWORD  m_dwNotifyThread;
    static HANDLE m_hNotifyThread;

    // This is for debugging only -- can check the refcount while in the debugger.
#if DBG
    DWORD               m_dwCritSecRef;
    DWORD               m_dwWriteLockRef;
#endif

public:

    CRITICAL_SECTION m_csWriteLock;
    void AcquireWriteLock();
    void ReleaseWriteLock();
    
private:
    VOID InternalAcquireLock();
    VOID InternalReleaseLock();

public:
    HRESULT HrFindConnectionByGuid(
        const GUID UNALIGNED *pguid,
        ConnListEntry& cle);
    
    inline HRESULT HrFindConnectionByName(
        PCWSTR   pszName,
        ConnListEntry& cle);
    
    inline HRESULT HrFindConnectionByConFoldEntry(
        const CONFOLDENTRY& ccfe,
        ConnListEntry& cle);
    
    inline HRESULT HrFindConnectionByTrayIconId(
        UINT     uiIcon,
        ConnListEntry& cle);

    HRESULT HrFindRasServerConnection(
        ConnListEntry& cle);
    
    inline BOOL IsInitialized()  {  return(m_pcclc != NULL); }

    VOID FlushConnectionList();
    VOID FlushTrayIcons();          // Flush just the tray icons
    VOID EnsureIconsPresent();

    HRESULT HrRetrieveConManEntries(
        PCONFOLDPIDLVEC& apidlOut);

    HRESULT HrRefreshConManEntries();
    
    HRESULT HrSuggestNameForDuplicate(
        PCWSTR      pszOriginal,
        PWSTR *    ppszNew);

    HRESULT HrInsert(
        const CONFOLDENTRY& pccfe);

    HRESULT HrRemoveByIter(
        ConnListCore::iterator clcIter,
        BOOL *          pfFlushPosts);

    HRESULT HrRemove(
        const CONFOLDENTRY& ccfe,
        BOOL *          pfFlushPosts);

    HRESULT HrInsertFromNetCon(
        INetConnection *    pNetCon,
        PCONFOLDPIDL &      ppcfp);
    
    HRESULT HrInsertFromNetConPropertiesEx(
        const NETCON_PROPERTIES_EX& PropsEx,
        PCONFOLDPIDL &              ppcfp);

    HRESULT HrFindPidlByGuid(
        IN  const GUID *        pguid,
        OUT PCONFOLDPIDL& pidl);
    
    HRESULT HrGetCurrentStatsForTrayIconId(
        UINT                    uiIcon,
        STATMON_ENGINEDATA**    ppData,
        tstring*                pstrName);

    HRESULT HrUpdateTrayIconDataByGuid(
        const GUID *            pguid,
        CConnectionTrayStats *  pccts,
        IConnectionPoint *      pcpStat,
        INetStatisticsEngine *  pnseStats,
        UINT                    uiIcon);
    
    HRESULT HrUpdateTrayBalloonInfoByGuid(
        const GUID *            pguid,
        DWORD                   dwLastBalloonMessage, 
        BSTR                    szCookie,
        FNBALLOONCLICK*         pfnBalloonFunction);

    HRESULT HrUpdateNameByGuid(
        IN  const GUID *    pguid,
        IN  PCWSTR          pszNewName,
        OUT PCONFOLDPIDL &  pidlOut,
        IN  BOOL            fForce);

    
    HRESULT HrUpdateConnectionByGuid(
        IN  const GUID *         pguid,
        IN  const ConnListEntry& cle );

    HRESULT HrUpdateTrayIconByGuid(
        const GUID *    pguid,
        BOOL            fBrieflyShowBalloon);

    HRESULT HrGetBrandingInfo(
        IN OUT ConnListEntry& cle);

    HRESULT HrGetCachedPidlCopyFromPidl(
        const PCONFOLDPIDL&   pidl,
        PCONFOLDPIDL &  pcfp);

    HRESULT HrMapCMHiddenConnectionToOwner(
        REFGUID guidHidden, 
        GUID * pguidOwner);

    HRESULT HrUnsetCurrentDefault(OUT PCONFOLDPIDL& cfpPreviousDefault);

    HRESULT HasActiveIncomingConnections(OUT LPDWORD pdwCount);

    BOOL    FExists(PWSTR pszName);
    VOID    EnsureConPointNotifyAdded();
    VOID    EnsureConPointNotifyRemoved();

#ifdef NCDBGEXT
    IMPORT_NCDBG_FRIENDS
#endif
};

// Helper routines
//
HRESULT HrCheckForActivation(
    const PCONFOLDPIDL& cfp,
    const CONFOLDENTRY& ccfe,
    BOOL *          pfActivating);

HRESULT HrSetActivationFlag(
    const PCONFOLDPIDL& cfp,
    const CONFOLDENTRY& ccfe,
    BOOL            fActivating);

HRESULT HrGetTrayIconLock(
    const GUID *  pguid,
    UINT *  puiIcon,
    LPDWORD pdwLockingThreadId);

VOID ReleaseTrayIconLock(
                         const GUID *  pguid);

#endif // _CONNLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\conprops.cpp ===
#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "conprops.h"
#include "ncnetcon.h"
#include "foldres.h"

class CConnectionPropPages
{
public:
    CConnectionPropPages();
    ~CConnectionPropPages();
    ULONG CntPages() {return m_culPages;}
    HPROPSHEETPAGE * PHPages() {return m_rghPages;}
    static BOOL FAddPropSheet(HPROPSHEETPAGE hPage, LPARAM lParam);

private:
    ULONG               m_culPages;
    ULONG               m_ulPageBufferLen;
    HPROPSHEETPAGE *    m_rghPages;
};

CConnectionPropPages::CConnectionPropPages()
{
    m_culPages = 0;
    m_ulPageBufferLen = 0;
    m_rghPages = NULL;
}

CConnectionPropPages::~CConnectionPropPages()
{
    delete [] (BYTE *)(m_rghPages);
}

//
// Function:    CConnectionPropPages::FAddPropSheet
//
// Purpose:     Callback function for the AddPages API used to accept
//              connection property pages handed back from a provider.
//
// Parameters:  hPage  [IN] - The page to add
//              lParam [IN] - 'this' casted to an LPARAM
//
// Returns:     BOOL, TRUE if the page was successfully added.
//
BOOL
CConnectionPropPages::FAddPropSheet(HPROPSHEETPAGE hPage, LPARAM lParam)
{
    CConnectionPropPages * pCPP = NULL;

    // Validate the input parameters
    //
    if ((0L == lParam) || (NULL == hPage))
    {
        Assert(lParam);
        Assert(hPage);

        TraceHr(ttidShellFolder, FAL, E_INVALIDARG, FALSE, "CConnectionPropPages::FAddPropSheet");
        return FALSE;
    }

    pCPP = reinterpret_cast<CConnectionPropPages*>(lParam);

    // Grow the buffer if necessary
    //
    if (pCPP->m_culPages == pCPP->m_ulPageBufferLen)
    {
        HPROPSHEETPAGE* rghPages = NULL;

        rghPages = (HPROPSHEETPAGE*)(new BYTE[sizeof(HPROPSHEETPAGE) *
                                   (pCPP->m_ulPageBufferLen + 10)]);

        if (NULL == rghPages)
        {
            TraceHr(ttidShellFolder, FAL, E_OUTOFMEMORY, FALSE, "CConnectionPropPages::FAddPropSheet");
            return FALSE;
        }

        // Copy the existing pages to the new buffer
        //
        memcpy(rghPages, pCPP->m_rghPages,
               sizeof(HPROPSHEETPAGE) * pCPP->m_ulPageBufferLen);
        delete [] (BYTE *)(pCPP->m_rghPages);

        pCPP->m_rghPages = rghPages;
        pCPP->m_ulPageBufferLen += 10;
    }

    // Retain the new page
    //
    pCPP->m_rghPages[pCPP->m_culPages++] = hPage;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUIInterfaceFromNetCon
//
//  Purpose:    Get the INetConnectionPropertyUI interface from an
//              INetConnection pointer.
//
//  Arguments:
//      pconn [in]      Valid INetConnection *
//      riid  [in]      IID of desired interface
//      ppv   [out]     Returned pointer to the interface
//
//  Returns:
//
//  Author:     jeffspr   12 Nov 1997
//
//  Notes:
//
HRESULT HrUIInterfaceFromNetCon(
    INetConnection *            pconn,
    REFIID                      riid,
    LPVOID *                    ppv)
{
    HRESULT hr      = S_OK;
    CLSID   clsid;

    Assert(pconn);
    Assert(ppv);

    // Validate the parameters.
    //
    if ((NULL == pconn) || (NULL == ppv))
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Initailize the output parameter.
    //
    *ppv = NULL;

    // Get the CLSID of the object which can provide the particular interface.
    //
    hr = pconn->GetUiObjectClassId(&clsid);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Create this object asking for the specified interface.
    //
    hr = CoCreateInstance(clsid, NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD, riid, ppv);

Error:

    TraceHr(ttidError, FAL, hr, (E_NOINTERFACE == hr),
        "HrUIInterfaceFromNetCon");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetPropertiesCaption
//
//  Purpose:    Generate the caption for a property page
//
//  Arguments:
//      pconn       [in]  Connection pointer passed in from the shell
//      ppszCaption [out] Resultant property page caption if successful
//
//  Returns:
//
//  Notes:
//
HRESULT HrGetPropertiesCaption(INetConnection * pconn, PWSTR * ppszCaption)
{
    HRESULT hr;

    Assert(pconn);
    Assert(ppszCaption);

    // Try to get the connection name
    //
    NETCON_PROPERTIES* pProps;
    hr = pconn->GetProperties(&pProps);
    if (SUCCEEDED(hr))
    {
        Assert (pProps->pszwName);

        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      SzLoadIds(IDS_CONPROP_CAPTION),
                      0, 0, (PWSTR)ppszCaption, 0,
                      (va_list *)&pProps->pszwName);

        FreeNetconProperties(pProps);
    }

    TraceHr(ttidError, FAL, hr, FALSE,"HrGetPropertiesCaption");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ActivatePropertyDialog
//
//  Purpose:    Try to locate a property dialog associated with pconn
//              then bring it to the foreground.
//
//  Arguments:
//      pconn       [in]  Connection pointer passed in from the shell
//
//  Returns:
//
//  Notes:
//
VOID ActivatePropertyDialog(INetConnection * pconn)
{
    PWSTR pszCaption = NULL;

    if (SUCCEEDED(HrGetPropertiesCaption(pconn, &pszCaption)))
    {
        Assert(pszCaption);

        // Find the dialog with this caption
        //
        HWND hwnd = FindWindow(NULL, pszCaption);
        if (IsWindow(hwnd))
        {
            SetForegroundWindow(hwnd);
        }

        LocalFree (pszCaption);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetPropertiesTaskbarIcon
//
//  Purpose:    Setup the dialog property sheet's taskbar icon.
//
//  Arguments:
//      hwndDlg  [in]  Dialog handle
//      uMsg     [in]  Message value
//      lparam   [in]  Long parameter
//
//  Returns:    0
//
//  Notes:      A standard Win32 commctrl PropSheetProc always return 0.  
//              See MSDN documentation.
//
int CALLBACK HrSetPropertiesTaskbarIcon(
    IN HWND   hwndDlg,
    IN UINT   uMsg,
    IN LPARAM lparam)

{
    switch (uMsg)
    {
        case PSCB_INITIALIZED:

            // Set the dialog window's icon

            // NTRAID#NTBUG9-366302-2001/04/11-roelfc Alt-tab icon
            // This requires a re-architecture in order to be able to retrieve
            // the appropiate icon for the property page through the 
            // IID_INetConnectionPropertyUi2 interface.

            // In the mean time, we query the small icon through the only link we have,
            // the dialog handle, and assign it as the big icon as well. Stretching the 
            // small icon is better than nothing at all...
            HICON  hIcon;

            hIcon = (HICON)SendMessage(hwndDlg, 
                                       WM_GETICON,
                                       ICON_SMALL,
                                       0);
            Assert(hIcon);

            if (hIcon)
            {
                SendMessage(hwndDlg,
                            WM_SETICON,
                            ICON_BIG,
                            (LPARAM)hIcon);
            }
            break;

        default:
            break;

    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRaiseConnectionPropertiesInternal
//
//  Purpose:    Bring up the propsheet page UI for the passed in connection
//
//  Arguments:
//      hwnd  [in]  Owner hwnd
//      pconn [in]  Connection pointer passed in from the shell
//
//  Returns:
//
//  Author:     jeffspr   12 Nov 1997
//
//  Notes:
//
HRESULT HrRaiseConnectionPropertiesInternal(HWND hwnd, UINT nStartPage, INetConnection * pconn)
{
    HRESULT                     hr          = NOERROR;
    INetConnectionPropertyUi *  pPUI        = NULL;
    PWSTR                       pszCaption  = NULL;

    Assert(pconn);
    hr = HrUIInterfaceFromNetCon(pconn, IID_INetConnectionPropertyUi,
            reinterpret_cast<void**>(&pPUI));

    if (E_NOINTERFACE == hr)
    {
        // What we want to check for here, is an object that when QI'd doesn't support IID_INetConnectionPropertyUi
        // but support IID_INetConnectionPropertyUi2.
        //
        // A reinterpret style-downcast directly from the QI would have been ok since INetConnectionPropertyUi2 inherit from 
        // INetConnectionPropertyUi. Hence an object can't multi-inherit from both, so we'll never have both vtable entries.
        // We could simply get the INetConnectionPropertyUi2 vtable entry and treat it like an INetConnectionPropertyUi.
        //
        // However, I'm doing the dynamic cast anyway since a cast-to-wrong-vtable is one of the most difficult
        // bugs to spot.
        INetConnectionPropertyUi2 *pPUI2 = NULL;
        hr = HrUIInterfaceFromNetCon(pconn, IID_INetConnectionPropertyUi2,
                reinterpret_cast<void**>(&pPUI2));

        if (SUCCEEDED(hr))
        {
            pPUI = dynamic_cast<INetConnectionPropertyUi *>(pPUI2);
        }
    }

    if (SUCCEEDED(hr))
    {
        INetConnectionUiLock * pUiLock = NULL;

        // Try to get the connection name
        //
        (VOID)HrGetPropertiesCaption(pconn, &pszCaption);

        Assert(pPUI);
        hr = pPUI->QueryInterface(IID_INetConnectionUiLock, (LPVOID *)&pUiLock);
        if (SUCCEEDED(hr))
        {
            // If the interface exists, we have work to do.
            PWSTR pszwMsg = NULL;
            hr = pUiLock->QueryLock(&pszwMsg);
            ReleaseObj(pUiLock);

            if (S_FALSE == hr)
            {
                // Format the error text
                //
                PWSTR  pszText = NULL;
                PCWSTR  pcszwTemp = pszwMsg;
                if (NULL == pcszwTemp)
                {
                    // Load <Unknown Application>
                    //
                    pcszwTemp = SzLoadIds(IDS_CONPROP_GENERIC_COMP);
                }

                Assert(pcszwTemp);
                FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                              FORMAT_MESSAGE_FROM_STRING |
                              FORMAT_MESSAGE_ARGUMENT_ARRAY,
                              SzLoadIds(IDS_CONPROP_NO_WRITE_LOCK),
                              0, 0, (PWSTR)&pszText, 0,
                              (va_list *)&pcszwTemp);

                if (pszwMsg)
                {
                    CoTaskMemFree(pszwMsg);
                }

                // No UI, couldn't acquire the lock
                //
                if (pszText)
                {
                    MessageBox(hwnd, pszText,
                               (pszCaption ? pszCaption : c_szEmpty),
                               MB_OK | MB_ICONERROR);

                    LocalFree(pszText);
                }

                goto Error;
            }
            else if (FAILED(hr))
            {
                goto Error;
            }
        }

        BOOL fShouldDestroyIcon = FALSE;

        hr = pPUI->SetConnection(pconn);
        if (SUCCEEDED(hr))
        {
            CComPtr<INetConnectionPropertyUi2> pUI2;

            HICON hIcon         = NULL;
            DWORD dwDisplayIcon = 0;
            hr = pPUI->QueryInterface(IID_INetConnectionPropertyUi2, reinterpret_cast<LPVOID *>(&pUI2) );
            if (SUCCEEDED(hr))
            {
                Assert(GetSystemMetrics(SM_CXSMICON) == GetSystemMetrics(SM_CYSMICON));
                
                hr = pUI2->GetIcon(GetSystemMetrics(SM_CXSMICON), &hIcon);
                if (SUCCEEDED(hr))
                {
                    fShouldDestroyIcon = TRUE;
                    dwDisplayIcon = PSH_USEHICON;
                }
                else
                {
                    hIcon = NULL;
                }
            }
            else
            {
                TraceTag(ttidError, "QI for INetConnectionPropertyUi2 failed using Default Icon");
                hIcon = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_CONNECTIONS_FOLDER_LARGE2));
                if (hIcon)
                {
                    dwDisplayIcon = PSH_USEHICON;
                }
            }
            Assert(hIcon);
                
            CConnectionPropPages    CPP;

            // Get the pages from the provider
            hr = pPUI->AddPages(hwnd,
                                CConnectionPropPages::FAddPropSheet,
                                reinterpret_cast<LPARAM>(&CPP));

            // If any pages were returned, display them
            if (SUCCEEDED(hr) && CPP.CntPages())
            {

                PROPSHEETHEADER     psh;
                ZeroMemory (&psh, sizeof(psh));
                psh.dwSize      = sizeof( PROPSHEETHEADER );
                psh.dwFlags     = PSH_NOAPPLYNOW | PSH_USECALLBACK | dwDisplayIcon;
                psh.hwndParent  = hwnd;
                psh.hInstance   = _Module.GetResourceInstance();
                psh.pszCaption  = pszCaption;
                psh.nPages      = CPP.CntPages();
                psh.phpage      = CPP.PHPages();
                psh.hIcon       = hIcon;
                psh.nStartPage  = nStartPage;
                psh.pfnCallback = HrSetPropertiesTaskbarIcon;

                // nRet used for debugging only
                //
                int nRet = PropertySheet(&psh);

                if (fShouldDestroyIcon)
                {
                    DestroyIcon(hIcon);
                }
            }
        }

Error:
        ReleaseObj(pPUI);
    }

    // Cleanup
    //
    if (pszCaption)
    {
        LocalFree (pszCaption);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrRaiseConnectionProperties");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrHandleDisconnectHResult
//
//  Purpose:    Put up the message box assocated with an HRESULT from
//              a diconnect operation if the HRESULT represents a failure.
//              Also translate any success codes back to S_OK as needed.
//
//  Arguments:
//      hr    [in] The HRESULT returned from a connection disconnect method.
//      pconn [in] INetConnection* for checking if this is a LAN or RAS connection.
//
//  Returns:    The translated HRESULT if needed
//
//  Author:     shaunco   3 Jun 1999
//
HRESULT HrHandleDisconnectHResult(HRESULT hr, INetConnection * pconn)
{
    if (FAILED(hr))
    {
       	NETCON_PROPERTIES* pProps = NULL;
        UINT nFailureCaptionID;
        UINT nFailureMessageID;

        TraceHr(ttidShellFolder, FAL, hr, FALSE, "pNetCon->Disconnect() failed");

        // Assume that is is a RAS/DIALUP connection unless we find otherwise
        nFailureCaptionID = IDS_CONFOLD_DISCONNECT_FAILURE_CAPTION;
        nFailureMessageID = IDS_CONFOLD_DISCONNECT_FAILURE;

    	hr = pconn->GetProperties(&pProps);
    	if (SUCCEEDED(hr))
    	{
    	    if (NCM_LAN == pProps->MediaType)
            {
                nFailureCaptionID = IDS_CONFOLD_DISABLE_FAILURE_CAPTION;
                nFailureMessageID = IDS_CONFOLD_DISABLE_FAILURE;
            }

    	    FreeNetconProperties(pProps);
    	}

        // Ignore the return from this, since we only allow OK
        //
        (void) NcMsgBox(
            _Module.GetResourceInstance(),
            NULL,
            nFailureCaptionID,
            nFailureMessageID,
            MB_OK | MB_ICONEXCLAMATION);

    }
    else
    {
        // If we get the object_nlv return, it means that the connection
        // is deleted on disconnect and we shouldn't perform an update of
        // that connection. We can normalize this for now, as we'll let the
        // notifysink take care of the delete update.
        //
        if (S_OBJECT_NO_LONGER_VALID == hr)
        {
            hr = S_OK;
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrConnectOrDisconnectNetConObject
//
//  Purpose:    Bring up the connection UI and make the connection for the
//              passed in connection.
//
//  Arguments:
//      hwnd  [in] Owner hwnd
//      pconn [in] Connection pointer passed in from the shell
//      Flag  [in] CD_CONNECT or CD_DISCONNECT.
//
//  Returns:
//
//  Author:     jeffspr   12 Nov 1997
//
//  Notes:
//
HRESULT HrConnectOrDisconnectNetConObject(HWND hwnd, INetConnection * pconn,
                                          CDFLAG Flag)
{
    HRESULT                     hr          = NOERROR;
    INetConnectionConnectUi *   pCUI        = NULL;
	
    Assert(pconn);

    // Get the INetConnectionConnectUi interface from the connection
    //
    hr = HrUIInterfaceFromNetCon(pconn, IID_INetConnectionConnectUi,
            reinterpret_cast<void**>(&pCUI));
    if (SUCCEEDED(hr))
    {
        Assert(pCUI);

        // Set the connection on the UI object
        //
        hr = pCUI->SetConnection(pconn);
        if (SUCCEEDED(hr))
        {
            if (CD_CONNECT == Flag)
            {
                // Connect, dangit!
                //
                hr = pCUI->Connect(hwnd, NCUC_DEFAULT);
                if (SUCCEEDED(hr))
                {
                    // heh heh, uhhhh, heh heh. Cool.
                }
                else if (HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED) == hr)
                {
                    // Ignore the return from this, since we only allow OK
                    //
                    (void) NcMsgBox(
                        _Module.GetResourceInstance(),
                        hwnd,
                        IDS_CONFOLD_CONNECT_FAILURE_CAPTION,
                        IDS_CONFOLD_CONNECT_FAILURE,
                        MB_OK | MB_ICONEXCLAMATION);
                }
            }
            else
            {
                // Disconnect the connection object
                //
                hr = pCUI->Disconnect(hwnd, NCUC_DEFAULT);
                hr = HrHandleDisconnectHResult(hr, pconn);
            }
        }

        ReleaseObj(pCUI);
    }
    else if ((E_NOINTERFACE == hr) && (CD_DISCONNECT == Flag))
    {
        // Incoming connection objects do not have a UI interface
        // so we disconect them on the object itself.
        //
        hr = pconn->Disconnect ();
        hr = HrHandleDisconnectHResult(hr, pconn);
    }

    AssertSz(E_NOINTERFACE != hr,
             "Should not have been able to attempt connection on object that doesn't support this interface");

    TraceHr(ttidShellFolder, FAL, hr, (E_NOINTERFACE == hr),
        "HrConnectOrDisconnectNetConObject");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\contray.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N T R A Y . H
//
//  Contents:   CConnectionTray object definition.
//
//  Notes:
//
//  Author:     jeffspr   30 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _CONTRAY_H_
#define _CONTRAY_H_

#include <netshell.h>
#include "nsbase.h"
#include "nsres.h"
#include "smutil.h"

//---[ Connection Tray Classes ]----------------------------------------------

class ATL_NO_VTABLE CConnectionTray :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CConnectionTray, &CLSID_ConnectionTray>,
    public IOleCommandTarget
{
private:
    LPITEMIDLIST    m_pidl;

public:
    CConnectionTray()
    {
        m_pidl = NULL;
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_CONTRAY)

    BEGIN_COM_MAP(CConnectionTray)
        COM_INTERFACE_ENTRY(IOleCommandTarget)
    END_COM_MAP()

    // IOleCommandTarget members
    STDMETHODIMP    QueryStatus(
        const GUID *    pguidCmdGroup,
        ULONG           cCmds,
        OLECMD          prgCmds[],
        OLECMDTEXT *    pCmdText);

    STDMETHODIMP    Exec(
        const GUID *    pguidCmdGroup,
        DWORD           nCmdID,
        DWORD           nCmdexecopt,
        VARIANTARG *    pvaIn,
        VARIANTARG *    pvaOut);

    // Handlers for various Exec Command IDs
    //
    HRESULT HrHandleTrayOpen();
    HRESULT HrHandleTrayClose();

};

class ATL_NO_VTABLE CConnectionTrayStats :
    public CComObjectRootEx <CComObjectThreadModel>,
    public INetConnectionStatisticsNotifySink
{
private:
    DWORD                       m_dwConPointCookie;
    CONFOLDENTRY                m_ccfe;
    UINT                        m_uiIcon;
    BOOL                        m_fStaticIcon;

public:
    CConnectionTrayStats();
    ~CConnectionTrayStats();

    DECLARE_REGISTRY_RESOURCEID(IDR_CONTRAY)

    BEGIN_COM_MAP(CConnectionTrayStats)
        COM_INTERFACE_ENTRY(INetConnectionStatisticsNotifySink)
    END_COM_MAP()

    // INetConnectionStatisticsNotifySink members
    //
    STDMETHOD(OnStatisticsChanged)(
        DWORD   dwChangeFlags);

public:
    static HRESULT CreateInstance (
        const CONFOLDENTRY &pcfe,
        UINT            uiIcon,
        BOOL            fStaticIcon,
        REFIID          riid,
        VOID**          ppv);

    LPDWORD GetConPointCookie() {return &m_dwConPointCookie;}
};


#endif // _CONTRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\disconnect.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D I S C O N N E C T . H 
//
//  Contents:   Code for disconnect confirmation and SyncMgr sync calls.
//
//  Notes:      
//
//  Author:     jeffspr   11 Mar 1998
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _DISCONNECT_H_
#define _DISCONNECT_H_

#include <syncrasp.h>   // for SYNCMGRQUERYSHOWSYNCUI

VOID PromptForSyncIfNeeded(
    const CONFOLDENTRY&  ccfe,
    HWND            hwndOwner);
                                                         
#endif // _DISCONNECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\contrays.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N T R A Y S . C P P
//
//  Contents:   Implementation of the CConnectionTrayStats object.
//
//  Notes:
//
//  Author:     jeffspr   11 Dec 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\tray includes
#include "ctrayui.h"
#include "traymsgs.h"
#include "trayres.h"
#include <confold.h>
#include <smutil.h>



extern HWND g_hwndTray;

CConnectionTrayStats::CConnectionTrayStats()
{
    m_dwConPointCookie  = 0;
    m_uiIcon            = 0;
    m_fStaticIcon       = FALSE;
    m_ccfe.clear();
}

CConnectionTrayStats::~CConnectionTrayStats()
{
    // $REVIEW(tongl 9/4/98): release the duplicate pccfe we created
    // when adding the icon
    m_ccfe.clear();
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::CreateInstance
//
//  Purpose:    Create an instance of the CConnectionFolderEnum object, and
//              returns the requested interface
//
//  Arguments:
//      riid [in]   Interface requested
//      ppv  [out]  Pointer to receive the requested interface
//
//  Returns:    Standard OLE HRESULT
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
HRESULT CConnectionTrayStats::CreateInstance(
        const CONFOLDENTRY&  ccfe,
        UINT            uiIcon,
        BOOL            fStaticIcon,
        REFIID          riid,
        VOID**          ppv)
{
    Assert(!ccfe.empty());
    Assert(!ccfe.GetWizard());

    HRESULT hr = E_OUTOFMEMORY;

    CConnectionTrayStats * pObj    = NULL;

    pObj = new CComObject <CConnectionTrayStats>;
    if (pObj)
    {
        Assert(!ccfe.GetWizard());
        Assert(uiIcon != BOGUS_TRAY_ICON_ID);

        hr = pObj->m_ccfe.HrDupFolderEntry(ccfe);
        if (SUCCEEDED(hr))
        {
            pObj->m_uiIcon = uiIcon;
            pObj->m_fStaticIcon = fStaticIcon;

            // Do the standard CComCreator::CreateInstance stuff.
            //
            pObj->SetVoid (NULL);
            pObj->InternalFinalConstructAddRef ();
            hr = pObj->FinalConstruct ();
            pObj->InternalFinalConstructRelease ();

            if (SUCCEEDED(hr))
            {
                hr = pObj->QueryInterface (riid, ppv);
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }



    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionTrayStats::CreateInstance");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionTrayStats::OnStatisticsChanged
//
//  Purpose:    Callback from the stats engine that tells us when data
//              has actually changed
//
//  Arguments:
//      dwCookie      [in]  Our interface cookie
//      dwChangeFlags [in]  Undefined, as of yet
//
//  Returns:
//
//  Author:     jeffspr   12 Dec 1997
//
//  Notes:
//
HRESULT CConnectionTrayStats::OnStatisticsChanged(
        DWORD   dwChangeFlags)
{
    HRESULT     hr          = S_OK;

    // Updage the icon.
    //
    if (g_pCTrayUI)
    {
        if (!m_fStaticIcon)
        {
            INT iIconResourceId;

            iIconResourceId = IGetCurrentConnectionTrayIconId(
                                    m_ccfe.GetNetConMediaType(), m_ccfe.GetNetConStatus(), dwChangeFlags);

            PostMessage(g_hwndTray, MYWM_UPDATETRAYICON,
                        (WPARAM) m_uiIcon, (LPARAM) iIconResourceId);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionTrayStats::OnStatisticsChanged", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\ctrayui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C T R A Y U I . H
//
//  Contents:   Connections Tray UI class
//
//  Notes:
//
//  Author:     jeffspr   13 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _CTRAYUI_H_
#define _CTRAYUI_H_

#include "connlist.h"

typedef enum tagBALLOONS
{
    BALLOON_NOTHING = 0,
    BALLOON_CALLBACK,
    BALLOON_USE_NCS
} BALLOONS;

class CTrayBalloon
{
public:
    ~CTrayBalloon()
    {
        SysFreeString(m_szCookie);
        m_szCookie = NULL;
    }
    GUID            m_gdGuid;
    CComBSTR        m_szAdapterName;
    CComBSTR        m_szMessage;
    BSTR            m_szCookie;
    FNBALLOONCLICK* m_pfnFuncCallback;
    DWORD           m_dwTimeOut;        // in milliseconds
};

class CTrayUI
{
private:
    // Used to protect member data which is modified by different threads.
    //
    CRITICAL_SECTION    m_csLock;

    UINT                m_uiNextIconId;
    UINT                m_uiNextHiddenIconId;

    typedef map<INT, HICON, less<INT> >   MapIdToHicon;
    MapIdToHicon        m_mapIdToHicon;

public:
    CTrayUI();
    ~CTrayUI()
    {
        DeleteCriticalSection(&m_csLock);
    }

    HRESULT HrInitTrayUI(VOID);
    HRESULT HrDestroyTrayUI(VOID);

    VOID UpdateTrayIcon(
        UINT    uiTrayIconId,
        INT     iIconResourceId);

    VOID    ResetIconCount()    {m_uiNextIconId = 0;};

    friend HRESULT HrDoMediaDisconnectedIcon(const CONFOLDENTRY& ccfe, BOOL fShowBalloon);
    friend LRESULT OnMyWMAddTrayIcon(HWND hwndMain, WPARAM wParam, LPARAM lParam);
    friend LRESULT OnMyWMRemoveTrayIcon(HWND hwndMain, WPARAM wParam, LPARAM lParam);
    friend LRESULT OnMyWMShowTrayIconBalloon(HWND hwndMain, WPARAM wParam, LPARAM lParam);

private:
    HICON GetCachedHIcon(
        INT     iIconResourceId);
};

extern CTrayUI *    g_pCTrayUI;

HRESULT HrAddTrayExtension(VOID);
HRESULT HrRemoveTrayExtension(VOID);
VOID FlushTrayPosts(HWND hwndTray);


#endif // _CTRAYUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\disconnect.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D I S C O N N E C T . C P P
//
//  Contents:   Code for disconnect confirmation and SyncMgr sync calls.
//
//  Notes:
//
//  Author:     jeffspr   11 Mar 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include <nsres.h>
#include "shutil.h"
#include "disconnect.h"

//+---------------------------------------------------------------------------
//
//  Function:   PromptForSyncIfNeeded
//
//  Purpose:    Query for SyncMgr processing if appropriate and call SyncMgr
//              if requested.
//
//  Arguments:
//      pccfe     [in]  Our connection
//      hwndOwner [in]  Our parent hwnd
//
//  Author:     jeffspr   31 May 1999
//
//  Notes:
//
VOID PromptForSyncIfNeeded(
    const CONFOLDENTRY&  ccfe,
    HWND            hwndOwner)
{
    LRESULT                 lResult         = 0;
    SYNCMGRQUERYSHOWSYNCUI  smqss;
    SYNCMGRSYNCDISCONNECT   smsd;

    smqss.cbSize            = sizeof(SYNCMGRQUERYSHOWSYNCUI);
    smqss.GuidConnection    = ccfe.GetGuidID();
    smqss.pszConnectionName = ccfe.GetName();
    smqss.fShowCheckBox     = FALSE;
    smqss.nCheckState       = 0;

    // We only want to allow sync on dialup connections, and
    // not on incoming connections.
    //
    if (ccfe.GetNetConMediaType() == NCM_PHONE &&
        !(ccfe.GetCharacteristics() & NCCF_INCOMING_ONLY))
    {
        // Get the lResult, but for debugging only. We want to allow the
        // disconnect dialog to come up even if the sync functions failed.
        //
        lResult = SyncMgrRasProc(
                SYNCMGRRASPROC_QUERYSHOWSYNCUI,
                0,
                (LPARAM) &smqss);

        AssertSz(lResult == 0, "Call to SyncMgrRasProc failed for the QuerySyncUI");
        TraceTag(ttidShellFolder, "Call to SyncMgrRasProc returned: 0x%08x", lResult);
    }

    if (smqss.fShowCheckBox)
    {
        // pop up message box and set smqss.nCheckState
        if(NcMsgBox(_Module.GetResourceInstance(),
                    NULL,
                    IDS_CONFOLD_SYNC_CONFIRM_WINDOW_TITLE,
                    IDS_CONFOLD_SYNC_CONFIRM,
                    smqss.nCheckState ?
                        MB_APPLMODAL|MB_ICONEXCLAMATION|MB_YESNO:
                        MB_APPLMODAL|MB_ICONEXCLAMATION|MB_YESNO|MB_DEFBUTTON2)
           == IDYES)
        {
            smqss.nCheckState = BST_CHECKED;
        }
        else
        {
            smqss.nCheckState = BST_UNCHECKED;
        }
    }

    // If the user wanted the sync to occur...
    //
    if (smqss.fShowCheckBox && smqss.nCheckState == BST_CHECKED)
    {
        CWaitCursor wc;     // Bring up wait cursor now. Remove when we go out of scope.

        // Fill in the disconnect data
        //
        smsd.cbSize             = sizeof(SYNCMGRSYNCDISCONNECT);
        smsd.GuidConnection     = ccfe.GetGuidID();
        smsd.pszConnectionName  = ccfe.GetName();

        // Call the syncmgr's disconnect code
        //
        lResult = SyncMgrRasProc(
            SYNCMGRRASPROC_SYNCDISCONNECT,
            0,
            (LPARAM) &smsd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\droptarget.cpp ===
//
// DropTarget.cpp
//

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "droptarget.h"

CDropTarget::CDropTarget(IShellFolder *psfParent)
{
	m_uiRefCount = 1;

	m_psfParent = psfParent;
	if(m_psfParent)
	{
		m_psfParent->AddRef();
	}

	m_bAcceptFmt = FALSE;
	// TODO : Register your own clipboard format here

    m_cfPrivatePidlData = static_cast<CLIPFORMAT>(RegisterClipboardFormat(CFSTR_SHELLIDLIST));
    m_cfPrivateFileData = CF_HDROP;
}

CDropTarget::~CDropTarget()
{
	if(m_psfParent)
	{
		m_psfParent->Release();
	}
}

///////////////////////////////////////////////////////////
// IUnknown Implementation
//
STDMETHODIMP CDropTarget::QueryInterface(REFIID riid, LPVOID *ppReturn)
{
	*ppReturn = NULL;

	//IUnknown
	if(IsEqualIID(riid, IID_IUnknown))
	{
		*ppReturn = this;
	}
	//IDropTarget
	else if(IsEqualIID(riid, IID_IDropTarget))
	{
		*ppReturn = (IDropTarget*)this;
	}
	if(*ppReturn)
	{
		(*(LPUNKNOWN*)ppReturn)->AddRef();
		return S_OK;
	}
	return E_NOINTERFACE;
}

STDMETHODIMP_(DWORD) CDropTarget::AddRef(VOID)
{
	return ++m_uiRefCount;
}

STDMETHODIMP_(DWORD) CDropTarget::Release(VOID)
{
	if(--m_uiRefCount == 0)
	{
		delete this;
		return 0;
	}
	return m_uiRefCount;
}

///////////////////////////////////////////////////////////
// IDropTarget implemenatation
//
STDMETHODIMP CDropTarget::DragEnter(   LPDATAOBJECT pDataObj, 
                                       DWORD dwKeyState, 
                                       POINTL pt, 
                                       LPDWORD pdwEffect)
{  
    // TODO : Handle DragEnter here
	FORMATETC   fmtetc;

	fmtetc.cfFormat   = m_cfPrivatePidlData;
	fmtetc.ptd        = NULL;
	fmtetc.dwAspect   = DVASPECT_CONTENT;
	fmtetc.lindex     = -1;
	fmtetc.tymed      = TYMED_HGLOBAL;

	// QueryGetData for pDataObject for our format
	m_bAcceptFmt = (S_OK == pDataObj->QueryGetData(&fmtetc)) ? TRUE : FALSE;

    if (m_bAcceptFmt)
    {
        if (queryDrop(dwKeyState, pdwEffect))
        {   
            HRESULT hr;
            FORMATETC   fe;
            STGMEDIUM   stgmed;
            
            fe.cfFormat   = m_cfPrivatePidlData;
            fe.ptd        = NULL;
            fe.dwAspect   = DVASPECT_CONTENT;
            fe.lindex     = -1;
            fe.tymed      = TYMED_HGLOBAL;
            
            // Get the storage medium from the data object.
            hr = pDataObj->GetData(&fe, &stgmed);
            if (SUCCEEDED(hr))
            {
                m_bAcceptFmt = CanDropPidl(stgmed.hGlobal);
            }
            else
            {
                m_bAcceptFmt = FALSE;
            }
        }
        else
        {
            m_bAcceptFmt = FALSE;   
        }
    }

    if (!m_bAcceptFmt)
    {
        *pdwEffect = DROPEFFECT_NONE;
    }
    
	return m_bAcceptFmt ? E_FAIL : E_FAIL;
}

STDMETHODIMP CDropTarget::DragOver(DWORD dwKeyState, POINTL pt, LPDWORD pdwEffect)
{
	BOOL bRet = queryDrop(dwKeyState, pdwEffect);
    
	return bRet ? E_FAIL : E_FAIL;
}

STDMETHODIMP CDropTarget::DragLeave(VOID)
{
	m_bAcceptFmt = FALSE;
	return S_OK;
}

STDMETHODIMP CDropTarget::Drop(LPDATAOBJECT pDataObj,
                                 DWORD dwKeyState,
                                 POINTL pt,
                                 LPDWORD pdwEffect)
{   
	HRESULT  hr = E_FAIL;
	if (queryDrop(dwKeyState, pdwEffect))
	{      
		FORMATETC   fe;
		STGMEDIUM   stgmed;

		fe.cfFormat   = m_cfPrivatePidlData;
		fe.ptd        = NULL;
		fe.dwAspect   = DVASPECT_CONTENT;
		fe.lindex     = -1;
		fe.tymed      = TYMED_HGLOBAL;

		// Get the storage medium from the data object.
		hr = pDataObj->GetData(&fe, &stgmed);
		if (SUCCEEDED(hr))
		{
			BOOL bRet = doPIDLDrop(stgmed.hGlobal, DROPEFFECT_MOVE == *pdwEffect);

			//release the STGMEDIUM
			ReleaseStgMedium(&stgmed);

			return bRet ? S_OK : E_FAIL;
		}
	}
	*pdwEffect = DROPEFFECT_NONE;
	return hr;
}

// Private helper functions:
// TODO : Modify to suit your needs
BOOL CDropTarget::queryDrop(DWORD dwKeyState, LPDWORD pdwEffect)
{
	DWORD dwOKEffects = *pdwEffect;

	*pdwEffect = DROPEFFECT_NONE;

	if (m_bAcceptFmt)
	{
		*pdwEffect = getDropEffectFromKeyState(dwKeyState);

		if(DROPEFFECT_LINK == *pdwEffect)
		{
			*pdwEffect = DROPEFFECT_NONE;
		}

		if(*pdwEffect & dwOKEffects)
		{
			return TRUE;
		}
	}
	return FALSE;
}

// TODO : Modify to suit your needs
DWORD CDropTarget::getDropEffectFromKeyState(DWORD dwKeyState)
{
	DWORD dwDropEffect = DROPEFFECT_MOVE;

	if(dwKeyState & MK_CONTROL)
	{
		if(dwKeyState & MK_SHIFT)
		{
			dwDropEffect = DROPEFFECT_LINK;
		}
		else
		{
		dwDropEffect = DROPEFFECT_COPY;
		}
	}
	return dwDropEffect;
}

#define HIDA_GetPIDLFolder(pida) (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[0])
#define HIDA_GetPIDLItem(pida, i) (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])

LPCITEMIDLIST IDA_GetIDListPtr(LPIDA pida, UINT i)
{
    if (NULL == pida)
    {
        return NULL;
    }

    if (i == (UINT)-1 || i < pida->cidl)
    {
        return HIDA_GetPIDLItem(pida, i);
    }

    return NULL;
}

// in:
//      psf     OPTIONAL, if NULL assume psfDesktop
//      pidl    to bind to from psfParent
//      pbc     bind context

STDAPI SHBindToObjectEx(IShellFolder *psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut)
{
    HRESULT hr;
    IShellFolder *psfRelease;

    if (!psf)
    {
        SHGetDesktopFolder(&psf);
        psfRelease = psf;
    }
    else
    {
        psfRelease = NULL;
    }

    if (psf)
    {
        if (!pidl || ILIsEmpty(pidl))
        {
            hr = psf->QueryInterface(riid, ppvOut);
        }
        else
        {
            hr = psf->BindToObject(pidl, pbc, riid, ppvOut);
        }
    }
    else
    {
        *ppvOut = NULL;
        hr = E_FAIL;
    }

    if (psfRelease)
    {
        psfRelease->Release();
    }

    if (SUCCEEDED(hr) && (*ppvOut == NULL))
    {
        // Some shell extensions (eg WS_FTP) will return success and a null out pointer
        hr = E_FAIL;
    }

    return hr;
}

STDAPI SHBindToObject(IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppvOut)
{
    // NOTE: callers should use SHBindToObjectEx!!!
    return SHBindToObjectEx(psf, pidl, NULL, riid, ppvOut);
}

BOOL CDropTarget::CanDropPidl(HGLOBAL hMem)
{
    CONFOLDENTRY cfeEmpty;
    return CanDropPidl(hMem, cfeEmpty);
}

BOOL CDropTarget::CanDropPidl(HGLOBAL hMem, CONFOLDENTRY& cfe)
{
    BOOL     fSuccess   = FALSE;
        
    USES_CONVERSION;
    if(hMem)
    {
        LPIDA pida = (LPIDA)GlobalLock(hMem);
        if (pida)
        {
            if (pida->cidl != 1)
            {
                return FALSE; // Don't support multiple files
            }

            HRESULT hr;
            IShellFolder *psf;

            LPCITEMIDLIST pIdList = IDA_GetIDListPtr(pida, (UINT)-1);
            hr = SHBindToObject(NULL, IID_IShellFolder, pIdList, reinterpret_cast<LPVOID *>(&psf) );
            if (SUCCEEDED(hr))
            {
                for (UINT i = 0; i < pida->cidl; i++) 
                {
                    LPCITEMIDLIST pidlLast = IDA_GetIDListPtr(pida, i);
                    IShellLink *psl;
                    hr = psf->GetUIObjectOf(NULL, 1, &pidlLast, IID_IShellLink, NULL, reinterpret_cast<LPVOID *>(&psl) );
                    if (SUCCEEDED(hr))
                    {
                        LPITEMIDLIST pItemIdList = NULL;
                        hr = psl->GetIDList(&pItemIdList);
                        if (SUCCEEDED(hr))
                        {   
                            pItemIdList = ILFindLastIDPriv(pItemIdList); // Desktop
                            if (pItemIdList)
                            {
                                PCONFOLDPIDL cfp;
                                hr = cfp.InitializeFromItemIDList(pItemIdList);
                                if (SUCCEEDED(hr))
                                {
                                    hr = cfp.ConvertToConFoldEntry(cfe);
                                    if (SUCCEEDED(hr))
                                    {
                                        if ( !(cfe.GetCharacteristics() & NCCF_BRANDED) && 
                                            ((cfe.GetNetConMediaType() == NCM_PHONE) || (cfe.GetNetConMediaType() == NCM_TUNNEL)) )
                                        {
                                            fSuccess = TRUE;
                                        }
                                    }
                                }
                            }
                        }
                        psl->Release();
                    }
                }
            }
            GlobalUnlock(hMem);
        }
    }
    
    return fSuccess;
}

#include "nccom.h"
#include "..\\dun\\dunimport.h"

HRESULT HrGetNewConnection (INetConnection**  ppCon, const CONFOLDENTRY& cfe)
{
    static const CLSID CLSID_DialupConnection =
        {0xBA126AD7,0x2166,0x11D1,{0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

    HRESULT hr;

    // Validate parameters.
    //
    if (!ppCon)
    {
        hr = E_POINTER;
    }
    else if (!cfe.GetName())
    {
        hr = E_INVALIDARG;
    }
    else
    {
         // Create an uninitialized dialup connection object.
        // Ask for the INetRasConnection interface so we can
        // initialize it.
        //
        INetRasConnection* pRasCon;
        
        hr = HrCreateInstance(
            CLSID_DialupConnection,
            CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            &pRasCon);
        
        TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");
        
        if (SUCCEEDED(hr))
        {
            NcSetProxyBlanket (pRasCon);

            tstring strPhoneBook;
            hr = HrGetPhoneBookFile(strPhoneBook);
            if (SUCCEEDED(hr))
            {
                RASENTRY RasEntry = {0};
                wcsncpy(RasEntry.szLocalPhoneNumber, cfe.GetPhoneOrHostAddress(), RAS_MaxPhoneNumber);
                RasEntry.dwfOptions |= RASEO_PreviewUserPw;
                RasEntry.dwSize = sizeof(RASENTRY);

                if (cfe.GetNetConMediaType() == NCM_PHONE)
                {
                    lstrcpyW(RasEntry.szDeviceType, RASDT_Modem);
                }
                if (cfe.GetNetConMediaType() == NCM_TUNNEL)
                {
                    lstrcpyW(RasEntry.szDeviceType, RASDT_Vpn);
                }
                lstrcpyW(RasEntry.szDeviceName, L"Standard Modem");
                RasEntry.dwFramingProtocol = RASFP_Ras;

                DWORD dwRet = RasSetEntryProperties(strPhoneBook.c_str(),
                    cfe.GetName(),
                    &RasEntry,
                    sizeof(RASENTRY),
                    NULL,
                    0);
                
                hr = HRESULT_FROM_WIN32(dwRet);
                Assert(SUCCEEDED(hr));
            }
            
            ReleaseObj (pRasCon);
        }
    }
    TraceError ("CRasUiBase::HrGetNewConnection", hr);
    return hr;
}


BOOL CDropTarget::doPIDLDrop(HGLOBAL hMem, BOOL bCut)
{
    BOOL fSuccess = FALSE;
    CONFOLDENTRY cfe;
    
    if (CanDropPidl(hMem, cfe))
    {
        ConnListEntry cle;
        HRESULT hr = g_ccl.HrFindConnectionByGuid(&cfe.GetGuidID(), cle);
        if (S_FALSE == hr)
        {
            INetConnection *pInetcon;
            HrGetNewConnection(&pInetcon, cfe);
        }
        else
        {
            ::MessageBox(NULL, L"This item already exists in the Network Connections folder", L"Error", MB_OK);
        }
        fSuccess = TRUE;
    }
	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\ctrayui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       T R A Y U I . C P P
//
//  Contents:   Tray window code for the CConnectionTray object.
//
//  Notes:
//
//  Author:     jeffspr   13 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\tray includes
#include "ctrayui.h"
#include "cfutils.h"
#include "loadicon.h"
#include "ncmisc.h"
#include "oncommand.h"
#include "traymsgs.h"
#include "trayres.h"
#include "ndispnp.h"
#include "ntddndis.h"
#include <confold.h>
#include <smcent.h>
#include <smutil.h>
#include <ncperms.h>
#include "cfutils.h"
#include "ac_ctrayui.h"

const WCHAR c_szTrayClass[]             = L"Connections Tray";
const WCHAR c_szTipTrailer[]            = L" ...";
const WCHAR c_szDelayLoadKey[]          = L"Software\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad";
const WCHAR c_szDelayLoadName[]         = L"Connections Tray";
const WCHAR c_szDelayLoadClassID[]      = L"7007ACCF-3202-11D1-AAD2-00805FC1270E";
const DWORD c_dwBalloonTimeoutSeconds   = 5;
const WCHAR c_szDotDotDot[]             = L"...";   // For balloon tip

// don't change this unless you know better
const UINT_PTR c_unTimerIdDblClick      = 1;
const INT   c_idDefaultCMCommand        = CMIDM_TRAY_STATUS;
const INT   c_idDefaultDisconCMCommand  = CMIDM_OPEN_CONNECTIONS_FOLDER;
const INT   c_idDefaultDisconCMWirelessCommand  = CMIDM_TRAY_WZCDLG_SHOW;


CTrayUI *   g_pCTrayUI;  // TrayUI object (not COM)
HWND        g_hwndTray      = NULL;

//---[ Prototypes ]-----------------------------------------------------------

VOID
GetInitialBalloonText(
                      INetStatisticsEngine*   pnse,
                      PWSTR                   pszBuf,
                      DWORD                   dwSize);

LRESULT
CALLBACK
CTrayUI_WndProc (
                 HWND hwnd,        // window handle
                 UINT uiMessage,   // type of message
                 WPARAM wParam,    // additional information
                 LPARAM lParam);   // additional information

BOOL FInitFoldEnumerator(HWND hwnd, DWORD * pdwIconsAdded);
VOID OnTaskBarIconRButtonUp(HWND hwnd, UINT uiIcon);
VOID OnTaskBarIconBalloonClick(HWND hwnd, UINT uiIcon);
VOID OnTaskBarIconLButtonDblClk(HWND hwnd, UINT uiIcon);
HRESULT HrOpenContextMenu(HWND hwnd, POINT * pPoint, UINT uiIcon);

// Window message handlers
//
LRESULT OnTrayWmCreate(HWND hwnd);
LRESULT OnTrayWmDestroy(HWND hwnd);
LRESULT OnTrayWmCommand(HWND hwnd, UINT uiMessage, WPARAM wParam, LPARAM lParam);
LRESULT OnMyWMNotifyIcon(HWND hwnd, UINT uiMessage, WPARAM wParam, LPARAM lParam);
LRESULT OnMyWMOpenStatus(HWND hwnd, WPARAM wParam, LPARAM lParam);
LRESULT OnMyWMUpdateTrayIcon(HWND hwnd, WPARAM wParam, LPARAM lParam);
LRESULT OnMyWMShowTrayIconBalloon (HWND hwnd, WPARAM wParam, LPARAM lParam);
LRESULT OnMyWMFlushNoop(HWND hwnd, WPARAM wParam, LPARAM lParam);

//+---------------------------------------------------------------------------
//
//  Function:   CopyAndAdvanceIfSpaceAvailable
//
//  Purpose:    Helper routine for FormatToolTip.  This manages the current
//              pointer into the tooltip and the count of characters
//              remaining in the buffer.
//
//  Arguments:
//      pchTip         [in out] Current pointer into the tooltip.
//      cchRemaining   [in out] Count of characters remaining in its buffer.
//      pszLine        [in]     New line to append to the tooltip.
//      cchLine        [in]     Count of characters in the line to append.
//      fInsertNewline [in]     TRUE to insert a newline first.
//
//  Returns:    nothing
//
//  Author:     shaunco   7 Nov 1998
//
//  Notes:
//
VOID
CopyAndAdvanceIfSpaceAvailable (
                                WCHAR*&     pchTip,
                                INT&        cchRemaining,
                                PCWSTR      pszLine,
                                INT         cchLine,
                                BOOL        fInsertNewline)
{
    TraceFileFunc(ttidSystray);
   
    if (cchLine < cchRemaining - (fInsertNewline) ? 1 : 0)
    {
        if (fInsertNewline)
        {
            *pchTip = L'\n';
            pchTip++;
            cchRemaining--;
        }
        
        lstrcpyW(pchTip, pszLine);
        pchTip += cchLine;
        cchRemaining -= cchLine;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FormatToolTip
//
//  Purpose:    Format a tooltip for the connection with the matching
//              icon id.
//
//  Arguments:
//      hwnd   [in] Window handle of the tray.
//      uiIcon [in] Icon id of the tray icon.
//
//  Returns:    nothing
//
//  Author:     shaunco   7 Nov 1998
//
//  Notes:
//
VOID
FormatToolTip (
               HWND    hwnd,
               UINT    uiIcon)
{
    TraceFileFunc(ttidSystray);

    HRESULT             hr   = S_OK;
    NETCON_STATUS       ncs  = NCS_CONNECTED;
    NETCON_MEDIATYPE    ncm  = NCM_NONE;
    NETCON_SUBMEDIATYPE ncsm = NCSM_NONE;
    tstring         strName;
    WCHAR           pszValue[64];
    WCHAR           pszLine[256];
    INT             cch;
    GUID            gdPcleGuid;

    NOTIFYICONDATA  nid;
    ZeroMemory(&nid, sizeof(nid));
    nid.cbSize  = sizeof(NOTIFYICONDATA);
    nid.hWnd    = hwnd;
    nid.uID     = uiIcon;
    nid.uFlags  = NIF_TIP;

    // Get the info on the connection so we know how to label the tooltip
    //
    ConnListEntry cle;
    hr = g_ccl.HrFindConnectionByTrayIconId(uiIcon, cle);
    if (hr == S_OK)
    {
        Assert(!cle.ccfe.empty());

        ncs = cle.ccfe.GetNetConStatus();
        gdPcleGuid = cle.ccfe.GetGuidID();
        ncm = cle.ccfe.GetNetConMediaType();
        ncsm = cle.ccfe.GetNetConSubMediaType();
    }
    else // Orphaned item -remove it.
    { 
        NOTIFYICONDATA  nid;
       
        ZeroMemory (&nid, sizeof(nid));
        nid.cbSize  = sizeof(NOTIFYICONDATA);
        nid.hWnd    = g_hwndTray;
        nid.uID = uiIcon;        
        hr = HrShell_NotifyIcon(NIM_DELETE, &nid);
        TraceTag(ttidSystray, "WARNING: Removing Orphan Tray Icon: %d", uiIcon);
        return;
    }

    // g_ccl.ReleaseLock();

    // Media status based tool tip
    if (fIsConnectedStatus(ncs))
    {
        WCHAR*  pchTip = nid.szTip;
        INT     cchRemaining = celems(nid.szTip);

        // Get a copy of the current stats and the connection's name.
        //
        STATMON_ENGINEDATA* pData;
        hr = g_ccl.HrGetCurrentStatsForTrayIconId(uiIcon, &pData, &strName);
        if (S_OK == hr && pData)
        {
            UINT   unTransmitSpeed = pData->SMED_SPEEDTRANSMITTING;
            UINT   unRecieveSpeed  = pData->SMED_SPEEDRECEIVING;
            UINT64 u64Sent         = pData->SMED_BYTESTRANSMITTING;
            UINT64 u64Rcvd         = pData->SMED_BYTESRECEIVING;
            INT    idsSent         = IDS_TOOLTIP_LINE_BYTES_SENT;
            INT    idsRcvd         = IDS_TOOLTIP_LINE_BYTES_RCVD;
            INFRASTRUCTURE_MODE infraStructureMode = pData->SMED_INFRASTRUCTURE_MODE;
            DWORD  dwEncryption    = pData->SMED_802_11_ENCRYPTION_ENABLED;
            INT    iSignalStrength = pData->SMED_802_11_SIGNAL_STRENGTH;
            WCHAR  szSSID[32];
            wcsncpy(szSSID, pData->SMED_802_11_SSID, celems(szSSID));

            WCHAR szNamePostFix[celems(nid.szTip)];
            ZeroMemory(szNamePostFix, celems(nid.szTip));

            if ((0 == u64Sent) && (0 == u64Rcvd))
            {
                // Use packets instead.
                //
                u64Sent = pData->SMED_PACKETSTRANSMITTING;
                u64Rcvd = pData->SMED_PACKETSRECEIVING;
                idsSent = IDS_TOOLTIP_LINE_PACKETS_SENT;
                idsRcvd = IDS_TOOLTIP_LINE_PACKETS_RCVD;
            }

            CoTaskMemFree(pData);
            pData = NULL;

            BOOL fNewLine = FALSE;

            // Speed
            //
            if ((unTransmitSpeed >0) || ( unRecieveSpeed >0))
            {
                FormatTransmittingReceivingSpeed (
                unTransmitSpeed,
                unRecieveSpeed,
                pszValue);

                cch = DwFormatString(SzLoadIds(IDS_TOOLTIP_LINE_SPEED), pszLine, celems(pszLine), pszValue);
                CopyAndAdvanceIfSpaceAvailable(pchTip, cchRemaining, pszLine, cch, FALSE);
                fNewLine = TRUE;
            }

            if ( (ncm == NCM_LAN) && (ncsm == NCSM_WIRELESS) )
            {
                switch (infraStructureMode)
                {
                    case IM_NDIS802_11IBSS:
                        DwFormatString(SzLoadIds(IDS_NAME_NETWORK), szNamePostFix, celems(szNamePostFix), SzLoadIds(IDS_TOOLTIP_ADHOC));
                        break;

                    case IM_NDIS802_11INFRASTRUCTURE:
                        if (*szSSID)
                        {
                            DwFormatString(SzLoadIds(IDS_NAME_NETWORK), szNamePostFix, celems(szNamePostFix), szSSID);
                        }
                        else
                        {
                            DwFormatString(SzLoadIds(IDS_NAME_NETWORK), szNamePostFix, celems(szNamePostFix), SzLoadIds(IDS_TOOLTIP_INFRASTRUCTURE));
                        }
                        break;
                    case IM_NDIS802_11AUTOUNKNOWN:
                    case IM_NOT_SUPPORTED:
                    default:
                        break;
                }

                cch = DwFormatString(SzLoadIds(IDS_SIGNAL_STRENGTH), pszLine, celems(pszLine), PszGetRSSIString(iSignalStrength));
                CopyAndAdvanceIfSpaceAvailable(pchTip, cchRemaining, pszLine, cch, fNewLine);
                fNewLine = TRUE;
            }

            if ( IsMediaRASType(ncm) )
            {
                // Bytes or packets sent
                //
                Format64bitInteger(
                    u64Sent,
                    FALSE,
                    pszValue,
                    celems(pszValue));

                cch = DwFormatString(SzLoadIds(idsSent), pszLine, celems(pszLine), pszValue);
                CopyAndAdvanceIfSpaceAvailable(pchTip, cchRemaining, pszLine, cch, fNewLine);

                // Bytes or packets received
                //
                Format64bitInteger(
                    u64Rcvd,
                    FALSE,
                    pszValue,
                    celems(pszValue));

                cch = DwFormatString(SzLoadIds(idsRcvd), pszLine, celems(pszLine), pszValue);
                CopyAndAdvanceIfSpaceAvailable(pchTip, cchRemaining, pszLine, cch, TRUE);
            }
            
            // Name
            //
            if ((INT)(strName.length() + 1) < cchRemaining)
            {
                WCHAR pszTip [celems(nid.szTip)];
                lstrcpyW(pszTip, strName.c_str());
                if (*szNamePostFix)
                {
                    lstrcatW(pszTip, szNamePostFix);
                }
                lstrcatW(pszTip, L"\n");
                lstrcatW(pszTip, nid.szTip);

                lstrcpyW(nid.szTip, pszTip);
            }
        }
    }
    else   // MEDIA_DISCONNECTED
    {
        WCHAR*  pchTip = nid.szTip;
        INT     cchRemaining = celems(nid.szTip);
        BOOL    fNewLine = FALSE;

        if (ncs == NCS_INVALID_ADDRESS)
        {
            UINT idString = IDS_CONTRAY_ADDRESS_INVALID_TOOLTIP;
            STATMON_ENGINEDATA* pData = NULL;
            tstring strName;
            hr = g_ccl.HrGetCurrentStatsForTrayIconId(uiIcon, &pData, &strName);

            if (S_OK == hr && pData)
            {
                if (STATIC_ADDR == pData->SMED_DHCP_ADDRESS_TYPE)
                {
                    idString = IDS_CONTRAY_STATIC_ADDR_INVALID_TOOLTIP;
                }

                CoTaskMemFree(pData);
            }

            lstrcpynW(pszLine, SzLoadIds(idString), celems(pszLine));

            cch = wcslen(pszLine);
        }
        else
        {
            if ( (ncm == NCM_LAN) && (ncsm == NCSM_WIRELESS) )
            {
               lstrcpynW(pszLine, SzLoadIds(IDS_CONTRAY_WIRELESS_DISCONN_BALLOON), celems(pszLine));
               cch = wcslen(pszLine);
            }
            else
            {
                lstrcpynW(pszLine, SzLoadIds(IDS_CONTRAY_MEDIA_DISCONN_BALLOON), celems(pszLine));
                cch = wcslen(pszLine);
            }
        }

        CopyAndAdvanceIfSpaceAvailable(pchTip, cchRemaining, pszLine, cch, fNewLine);
        fNewLine = TRUE;

        hr = g_ccl.HrGetCurrentStatsForTrayIconId(uiIcon, NULL, &strName);
        if (SUCCEEDED(hr))
        {
            // Name
            //
            if ((INT)(strName.length() + 1) < cchRemaining)
            {
                
                WCHAR pszTip [celems(nid.szTip)];
                lstrcpyW(pszTip, strName.c_str());
                lstrcatW(pszTip, L"\n");
                lstrcatW(pszTip, nid.szTip);

                lstrcpyW(nid.szTip, pszTip);
            }
        }
    }

    hr = HrShell_NotifyIcon(NIM_MODIFY, &nid);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTrayUI::CTrayUI
//
//  Purpose:    Constructor for the CTrayUI class. Initialize the base junk
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   13 Nov 1997
//
//  Notes:
//
CTrayUI::CTrayUI()
{
    TraceFileFunc(ttidSystray);

    // There should only be one of these objects
    //
    Assert(!g_pCTrayUI);
    
    InitializeCriticalSection(&m_csLock);
    m_uiNextIconId = 0;
    m_uiNextHiddenIconId = UINT_MAX;
}

HRESULT CTrayUI::HrInitTrayUI(VOID)
{
    TraceFileFunc(ttidSystray);

    HRESULT hr  = S_OK;
    HWND    hwnd;
    
    // create a hidden window
    //
    WNDCLASS wndclass;
    ZeroMemory (&wndclass, sizeof(wndclass));
    
    wndclass.lpfnWndProc   = CTrayUI_WndProc;
    wndclass.hInstance     = _Module.GetResourceInstance();
    wndclass.lpszClassName = c_szTrayClass;
    
    RegisterClass (&wndclass);
    
    hwnd = CreateWindow(c_szTrayClass,
        c_szTrayClass,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        _Module.GetResourceInstance(),
        NULL);
    
    if (hwnd)
    {
        // Assigned during WM_CREATE
        //
        Assert(hwnd == g_hwndTray);
        
        ShowWindow(hwnd, SW_HIDE);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr(ttidSystray, FAL, hr, FALSE, "CTrayUI::HrInitTrayUI");
    return hr;
}

HRESULT CTrayUI::HrDestroyTrayUI(VOID)
{
    TraceFileFunc(ttidSystray);

    HRESULT hr  = S_OK;
    
    // Remove the tray icons before destroying ourselves
    //
    g_ccl.FlushTrayIcons();
    
    if (g_hwndTray)
    {
        // Don't bother checking the return code here. Most likely, this window
        // is already gone by the time the tray is calling our shutdown.. We'll
        // still grab the return code for debugging purposes, though.
        //
        BOOL fReturn = DestroyWindow(g_hwndTray);
        
        g_hwndTray = NULL;
    }
    
    TraceHr(ttidSystray, FAL, hr, FALSE, "CTrayUI::HrDestroyTrayUI");
    return S_OK;
}

VOID SetIconFocus(HWND hwnd, UINT uiIcon)
{
    TraceFileFunc(ttidSystray);

    HRESULT hr;
    NOTIFYICONDATA nid;
    
    ZeroMemory (&nid, sizeof(nid));
    nid.cbSize  = sizeof(NOTIFYICONDATA);
    nid.hWnd    = hwnd;
    nid.uID     = uiIcon;
    
    hr = HrShell_NotifyIcon(NIM_SETFOCUS, &nid);
    TraceHr(ttidSystray, FAL, hr, FALSE, "SetIconFocus");
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckMenuPermissions
//
//  Purpose:    Update the tray items based on system policy
//
//  Arguments:
//      hmenu [in]  The tray context menu
//
//  Returns:
//
//  Author:     jeffspr   8 Apr 1999
//
//  Notes:
//
VOID CheckMenuPermissions(HMENU hmenu, const CONFOLDENTRY& ccfe)
{
    TraceFileFunc(ttidSystray);

    // Check the permissions for bringing up statistics. If no,
    // then disable the context menu item
    //
    if (!FHasPermission(NCPERM_Statistics))
    {
        // Enable or disable the menu item, as appopriate
        //
        EnableMenuItem(
            hmenu,
            CMIDM_TRAY_STATUS,
            MF_GRAYED);
    }

    // Check the permission to disconnect
    BOOL fCanDisconnect = TRUE;
    
    switch(ccfe.GetNetConMediaType())
    {
        case NCM_LAN:
        case NCM_BRIDGE:
            fCanDisconnect = FHasPermission(NCPERM_LanConnect);
            if (!FHasPermission(NCPERM_Repair))
            {
                EnableMenuItem(
                    hmenu,
                    CMIDM_TRAY_REPAIR,
                    MF_GRAYED);
            }
            break;
        case NCM_PPPOE:
        case NCM_DIRECT:
        case NCM_ISDN:
        case NCM_PHONE:
        case NCM_TUNNEL:
        case NCM_NONE:
            fCanDisconnect = FHasPermission(NCPERM_RasConnect);
            break;
        case NCM_SHAREDACCESSHOST_LAN:
        case NCM_SHAREDACCESSHOST_RAS:
            fCanDisconnect = TRUE; // group policy is enforced by the enumerator, if you can see it you can use it.  
            break;
        default:
            AssertSz(FALSE, "Need to add a switch for this connection type in the menuing code");
            break;
    }
    
    if (!fCanDisconnect)
    {
        EnableMenuItem(
            hmenu,
            CMIDM_TRAY_DISCONNECT,
            MF_GRAYED);
        
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FAddMenuBranding
//
//  Purpose:    Process the CM branding tray menu extensions. Add them to the
//              menu if needed
//
//  Arguments:
//      hmenu         [in]  Incoming hmenu
//      cfe           [in]  Our cache entry
//      IdMinMenuID   [in]  The smallest allowable menu ID to use
//      pMenuData     [in]  Menu Data
//      piIdCustomMin [out] Our custom range min
//      piIdCustomMax [out] Our custom range max
//
//  Returns:    TRUE if we added anything, FALSE if we didn't
//
//  Author:     jeffspr   8 Apr 1999
//
//  Notes:
//
BOOL FAddMenuBranding(
                      HMENU                   hmenu,
                      const ConnListEntry&    cle,
                      INT                     IdMinMenuID,
                      INT *                   piIdCustomMin,
                      INT *                   piIdCustomMax)
{
    TraceFileFunc(ttidSystray);

    BOOL    fBranded        = FALSE;
    int     iIdCustomMin    = -1;
    int     iIdCustomMax    = -1;
    HMENU   hmenuTrack      = NULL;
    
    Assert(hmenu);
    Assert(!cle.empty());
    Assert(!cle.ccfe.empty());
    
    if (cle.ccfe.GetCharacteristics() & NCCF_BRANDED)
    {
        // we may have custom menus for CM connections, merge them in
        //
        const CON_TRAY_MENU_DATA* pMenuData = cle.pctmd;
        if (pMenuData)
        {
            Assert(pMenuData->dwCount);
            
            int cMenuItems = GetMenuItemCount(hmenu);
            if (-1 == cMenuItems)
            {
                TraceLastWin32Error("GetMenuItemCount failed on tray menu");
            }
            else
            {
                BOOL fRet;
                MENUITEMINFO mii;
                
                // add a separator bar
                ZeroMemory(&mii, sizeof(mii));
                mii.cbSize = sizeof(mii);
                mii.fMask = MIIM_TYPE;
                mii.fType = MFT_SEPARATOR;
                
                fRet = InsertMenuItem( hmenu,
                    cMenuItems++,
                    TRUE,    // fByPosition
                    &mii);
                if (fRet)
                {
                    DWORD dwCount = pMenuData->dwCount;
                    CON_TRAY_MENU_ENTRY * pMenuEntry = pMenuData->pctme;
                    
                    // this is the first id for our custom menu items
                    iIdCustomMin = CMIDM_FIRST+cMenuItems+1;
                    iIdCustomMin = iIdCustomMin < IdMinMenuID ? IdMinMenuID : iIdCustomMin;

                    iIdCustomMax = iIdCustomMin+dwCount;
                    
                    int iMenu = 0;
                    
                    while (dwCount)
                    {
                        Assert(pMenuEntry);
                        fRet = AppendMenu(  hmenu,
                            MF_STRING,
                            iIdCustomMin+iMenu,
                            pMenuEntry->szwMenuText);
                        
                        if (!fRet)
                        {
                            DWORD dwError = GetLastError();
                            
                            TraceTag(ttidSystray, "Failed adding custom menu: %S, error: %d",
                                pMenuEntry->szwMenuText,
                                dwError);
                        }
                        
                        // move to the next item
                        iMenu++;
                        dwCount--;
                        pMenuEntry++;
                    }
                    
                    // Mark it as branded to say "hey, we actually added items"
                    //
                    fBranded = TRUE;
                }
            }
        }
    }
    
    if (fBranded)
    {
        *piIdCustomMin = iIdCustomMin;
        *piIdCustomMax = iIdCustomMax;
    }
    
    return fBranded;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrProcessBrandedTrayMenuCommand
//
//  Purpose:    Perform the custom action specified in the selected
//              branded menu
                      //
                      //  Arguments:
                      //      iMenuEntry [in]     Our branded command
                      //      pMenuData  [in]     Our branded menu struct
//
//  Returns:
//
//  Author:     jeffspr   8 Apr 1999
//
//  Notes:
//
HRESULT HrProcessBrandedTrayMenuCommand(
                                        INT                        iMenuEntry,
                                        const CON_TRAY_MENU_DATA * pMenuData)
{
    TraceFileFunc(ttidSystray);

    HRESULT hr  = S_OK;
    
    Assert(iMenuEntry != -1);
    Assert(pMenuData);
    
    DWORD dwCount = pMenuData->dwCount;
    
    Assert(dwCount > 0);
    
    CON_TRAY_MENU_ENTRY * pMenuEntry = pMenuData->pctme + iMenuEntry;
    Assert(pMenuEntry);
    
    SHELLEXECUTEINFO seiTemp    = { 0 };
    
    //  Fill in the data structure
    //
    seiTemp.cbSize          = sizeof(SHELLEXECUTEINFO);
    seiTemp.fMask           = SEE_MASK_DOENVSUBST;
    seiTemp.hwnd            = NULL;
    seiTemp.lpVerb          = NULL;
    seiTemp.lpFile          = pMenuEntry->szwMenuCmdLine;
    seiTemp.lpParameters    = pMenuEntry->szwMenuParams;
    seiTemp.lpDirectory     = NULL;
    seiTemp.nShow           = SW_SHOW;
    seiTemp.hInstApp        = NULL;
    seiTemp.hProcess        = NULL;
    
    // Launch the tool
    //
    if (!::ShellExecuteEx(&seiTemp))
    {
        hr = ::HrFromLastWin32Error();
    }
    
    TraceHr(ttidSystray, FAL, hr, FALSE, "HrProcessBrandedMenuCommand");
    return hr;
}

HRESULT HrOpenContextMenu(HWND hwnd, POINT * pPoint, UINT uiIcon)
{
    TraceFileFunc(ttidSystray);

    HRESULT         hr                      = S_OK;
    INT             iCmd                    = 0;
    HMENU           hmenu                   = 0;
    PCONFOLDPIDL    pidlItem;
    BOOL            fSetIconFocus           = TRUE;
    INT             iIdCustomMin            = -1;
    INT             iIdCustomMax            = -1;
    BOOL            fBranded                = FALSE;
    
    Assert(pPoint);
    Assert(hwnd);
    
    // Find the connection info based on the tray icon id.
    //
    ConnListEntry cle;
    hr = g_ccl.HrFindConnectionByTrayIconId(uiIcon, cle);
    if (hr == S_OK)
    {
        Assert(!cle.ccfe.empty());
        
        if (!cle.ccfe.empty())
        {
            // Load the menu resource
            //
            INT iMenuToLoad = POPUP_CONTRAY_GENERIC_MENU_RAS;
            
            if (cle.ccfe.GetNetConStatus() ==  NCS_MEDIA_DISCONNECTED)
            {
                if (IsMediaLocalType(cle.ccfe.GetNetConMediaType()) &&
                    (NCSM_WIRELESS == cle.ccfe.GetNetConSubMediaType()) )
                {
                    iMenuToLoad = POPUP_CONTRAY_WIRELESS_DISCONNECTED_LAN;
                }
                else
                {
                    iMenuToLoad = POPUP_CONTRAY_MEDIA_DISCONNECTED_MENU;
                }
            }
            else if (IsMediaLocalType(cle.ccfe.GetNetConMediaType()) || NCM_SHAREDACCESSHOST_LAN == cle.ccfe.GetNetConMediaType())     
            {
                if (NCSM_WIRELESS == cle.ccfe.GetNetConSubMediaType())
                {
                    iMenuToLoad = POPUP_CONTRAY_GENERIC_MENU_WIRELESS_LAN;
                }
                else
                {
                    iMenuToLoad = POPUP_CONTRAY_GENERIC_MENU_LAN;
                }
            }
            
            hmenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(iMenuToLoad));
            if (!hmenu)
            {
                hr = E_FAIL;
            }
            
            if (SUCCEEDED(hr))
            {
                // Get the first menu from the popup. For some reason, this hack is
                // required instead of tracking on the outside menu
                //
                HMENU   hmenuTrack  = GetSubMenu(hmenu, 0);

                //Repair is only availabe for LAN and Bridge adapters
                if ( ((POPUP_CONTRAY_GENERIC_MENU_LAN == iMenuToLoad) ||
                      (POPUP_CONTRAY_GENERIC_MENU_WIRELESS_LAN == iMenuToLoad)) && 
                     (NCM_BRIDGE != cle.ccfe.GetNetConMediaType()) &&
                     (NCM_LAN != cle.ccfe.GetNetConMediaType()) )
                {
                    DeleteMenu(hmenuTrack, 
                               CMIDM_TRAY_REPAIR, 
                               MF_BYCOMMAND);
                }
                
                // Don't drop out of the loop if we can't get this right.
                //
                CheckMenuPermissions(hmenuTrack, cle.ccfe);
                fBranded = FAddMenuBranding(hmenuTrack, cle, CMIDM_TRAY_MAX+1, &iIdCustomMin, &iIdCustomMax);
                
                // Set the default menu item
                //
                if (cle.ccfe.GetNetConStatus() == NCS_MEDIA_DISCONNECTED)
                {
                    if (IsMediaLocalType(cle.ccfe.GetNetConMediaType()) &&
                        (NCSM_WIRELESS == cle.ccfe.GetNetConSubMediaType()) )
                    {
                        SetMenuDefaultItem(hmenuTrack, c_idDefaultDisconCMWirelessCommand, FALSE);
                    }
                    else
                    {
                        SetMenuDefaultItem(hmenuTrack, c_idDefaultDisconCMCommand, FALSE);
                    }
                }
                else
                {
                    SetMenuDefaultItem(hmenuTrack, c_idDefaultCMCommand, FALSE);
                }
                
                // Set the owner window to be foreground as a hack so the
                // popup menu disappears when the user clicks elsewhere.
                //
                SetForegroundWindow(hwnd);
                
                // Part of the above hack. Bring up the menu and figure out the result
                iCmd = TrackPopupMenu(hmenuTrack, TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON,
                    pPoint->x, pPoint->y, 0, hwnd, NULL);
                DestroyMenu(hmenu);
                
                MSG msgTmp;
                while (PeekMessage(&msgTmp, hwnd, WM_LBUTTONDOWN, WM_LBUTTONUP, PM_REMOVE))
                {
                    DispatchMessage(&msgTmp);
                }
                
                // Process the command
                //
                switch (iCmd)
                {
                case CMIDM_OPEN_CONNECTIONS_FOLDER:
                    hr = HrOpenConnectionsFolder();
                    
                    if (S_OK == hr)
                    {
                        // The folder should have focus
                        fSetIconFocus = FALSE;
                    }
                    break;

                case CMIDM_TRAY_REPAIR:
                    HrOnCommandFixInternal(
                            cle.ccfe,
                            g_hwndTray,
                            NULL);
                    break;

                case CMIDM_TRAY_WZCDLG_SHOW:
                    {
                        PCONFOLDPIDLVEC pcfpVec;
                        PCONFOLDPIDL    pcfp;
                        hr = cle.ccfe.ConvertToPidl(pcfp);
                        if (SUCCEEDED(hr))
                        {
                            pcfpVec.insert(pcfpVec.begin(), pcfp);
                            HrOnCommandWZCDlgShow(pcfpVec,
                            g_hwndTray,
                            NULL);
                        }
                    }
                    break;
                    
                case CMIDM_TRAY_DISCONNECT:
                    // Ignore the return from this. If it's NULL, we'll just
                    // pass it in, and it just won't get refreshed properly
                    //
                    hr = HrOnCommandDisconnectInternal(
                        cle.ccfe,
                        g_hwndTray,
                        NULL);
                    
                    // Normalize the return code on success. We don't care
                    // if the dialog was canceled or not.
                    //
                    switch(hr)
                    {
                        // If succeeded, mark us as disconnected.
                        //
                    case S_OK:
                        // If we disconnected and the icon went away, then don't
                        // bother trying to set the focus back
                        //
                        fSetIconFocus = FALSE;
                        break;
                        
                        // If S_FALSE, we didn't disconnect. Go ahead
                        // and normalize the return code.
                        //
                    case S_FALSE:
                        hr = S_OK;
                        break;
                    }
                    break;
                    
                    case CMIDM_TRAY_STATUS:
                        hr = HrOnCommandStatusInternal(cle.ccfe, FALSE);
                        break;
                        
                    case 0:
                        // Tray menu cancelled without selection
                        break;
                        
                    default:
                        if ((iCmd >= iIdCustomMin) && (iCmd < iIdCustomMax))
                        {
                            AssertSz(fBranded, "Hey, what fool added this command?");
                            hr = HrProcessBrandedTrayMenuCommand(iCmd-iIdCustomMin, cle.pctmd);
                        }
                        else
                        {
                            AssertSz(FALSE, "Not in custom range, not a known command, what the...?");
                        }
                        break;
                }
                
                if (fSetIconFocus)
                {
                    // Shift the focus back to the shell
                    //
                    SetIconFocus(hwnd, uiIcon);
                }
            }
        }
        else
        {
            // Data returned from the FindByIconId was bogus
            //
            hr = E_FAIL;
        }
    }
    else // Orphaned item -remove it.
    { 
        NOTIFYICONDATA  nid;
       
        ZeroMemory (&nid, sizeof(nid));
        nid.cbSize  = sizeof(NOTIFYICONDATA);
        nid.hWnd    = g_hwndTray;
        nid.uID = uiIcon;        
        hr = HrShell_NotifyIcon(NIM_DELETE, &nid);

        TraceTag(ttidSystray, "WARNING: Connection not found opening context menu, hr: 0x%08x, uiIcon: %d", hr, uiIcon);
        // Removed this assert because we can have a valid state in the connections folder
        // where we've updated our cache but the PostMessages to remove the tray icons
        // haven't come through yet.
        //
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnTrayWmCreate
//
//  Purpose:    Tray window message handler for WM_CREATE.
//              We will perform the connection enumeration and create the
//              appropriate taskbar icons, including the generic connection
//              icon if no connections were present.
//
//  Arguments:
//      hwnd [in]   Tray window
//
//  Returns:
//
//  Author:     jeffspr   14 Dec 1997
//
//  Notes:
//
LRESULT OnTrayWmCreate(HWND hwnd)
{
    TraceFileFunc(ttidSystray);

    BOOL    fResult = 0;
    DWORD   dwIconsAdded  = 0;
    
    // Do the connections enumeration and add the icons.
    // fResult it for debugging only. We'll always do everything here
    //
    fResult = FInitFoldEnumerator(hwnd, &dwIconsAdded);
    
    g_ccl.EnsureIconsPresent();

    ac_Register(hwnd); // homenet auto config service
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnTrayWmDestroy
//
//  Purpose:    Tray window message handler for WM_DESTROY.
//              We will perform the connection enumeration and create the
//              appropriate taskbar icons, including the generic connection
//              icon if no connections were present.
//
//  Arguments:
//      hwnd [in]   Tray window
//
//  Returns:
//
//  Author:     jeffspr   14 Dec 1997
//
//  Notes:
//
LRESULT OnTrayWmDestroy(HWND hwnd)
{
    TraceFileFunc(ttidSystray);

    ac_Unregister(hwnd);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CTrayUI_WndProc
//
//  Purpose:    Window proc for the tray's hidden window
//
//  Arguments:
//      hwnd      [in]    See windows documentation
//      uiMessage [in]    See windows documentation
//      wParam    [in]    See windows documentation
//      lParam    [in]    See windows documentation
//
//  Returns:    See windows documentation
//
//  Author:     jeffspr   14 Dec 1997
//
//  Notes:
//
LRESULT
CALLBACK
CTrayUI_WndProc (
                 HWND    hwnd,       // window handle
                 UINT    uiMessage,  // type of message
                 WPARAM  wParam,     // additional information
                 LPARAM  lParam)     // additional information
{
    TraceFileFunc(ttidSystray);

    switch (uiMessage)
    {
    case WM_CREATE:
        // Note: Move this to a better place.
        g_hwndTray = hwnd;
        return OnTrayWmCreate(hwnd);

    case WM_DESTROY:
        return OnTrayWmDestroy(hwnd);

    case MYWM_NOTIFYICON:
        return OnMyWMNotifyIcon(hwnd, uiMessage, wParam, lParam);
        
    case MYWM_OPENSTATUS:
        return OnMyWMOpenStatus(hwnd, wParam, lParam);
        
    case MYWM_ADDTRAYICON:
        return OnMyWMAddTrayIcon(hwnd, wParam, lParam);
        
    case MYWM_REMOVETRAYICON:
        return OnMyWMRemoveTrayIcon(hwnd, wParam, lParam);
        
    case MYWM_UPDATETRAYICON:
        return OnMyWMUpdateTrayIcon(hwnd, wParam, lParam);
        
    case MYWM_SHOWBALLOON:
        return OnMyWMShowTrayIconBalloon(hwnd, wParam, lParam);

    case MYWM_FLUSHNOOP:
        return OnMyWMFlushNoop(hwnd, wParam, lParam);

    case WM_DEVICECHANGE:
        return ac_DeviceChange(hwnd, uiMessage, wParam, lParam);
        
    default:                                 // Passes it on if unproccessed
        return (DefWindowProc (hwnd, uiMessage, wParam, lParam));
    }
    return (0);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDoMediaDisconnectedIcon
//
//  Purpose:    Add a Media-disconnected icon to the tray. We're in the 
//              state where our cable is unplugged on a LAN adapter and 
//              we want to inform the user of the situation
//
//  Arguments:  
//      pccfe           [in]  Our connection
//      fShowBalloon    [in]  Show the balloon tip?
//
//  Returns:    
//
//  Author:     jeffspr   14 Jul 1999
//
//  Notes:      
//
HRESULT HrDoMediaDisconnectedIcon(const CONFOLDENTRY& pccfe, BOOL fShowBalloon)
{
    TraceFileFunc(ttidSystray);

    HRESULT hr      = S_OK;
    UINT    uiIcon  = 0;
    
    TraceTag(ttidSystray, "HrDoMediaDisconnectedIcon");
    
    DWORD dwLockingThreadId = 0;
    hr = HrGetTrayIconLock(&(pccfe.GetGuidID()), &uiIcon, &dwLockingThreadId);
    if (S_OK == hr)
    {
        if (uiIcon == BOGUS_TRAY_ICON_ID)
        {
            TraceTag(ttidSystray, "Adding MediaDisconnected icon for: %S", pccfe.GetName());
            NETCON_MEDIATYPE ncm = pccfe.GetNetConMediaType();
            if (IsMediaLocalType(ncm) || IsMediaSharedAccessHostType(ncm)) // ics beacon will say disconnected if it is in a unknown state.  
            {
                HICON hiconTray = LoadIcon(_Module.GetResourceInstance(), 
                    MAKEINTRESOURCE(IDI_CFT_DISCONNECTED));
                
                if (hiconTray)
                {
                    ConnListEntry cleFind;
                    g_ccl.AcquireWriteLock();
                    hr = g_ccl.HrFindConnectionByGuid(&(pccfe.GetGuidID()), cleFind);
                    if (S_OK == hr)
                    {
                        Assert(!cleFind.ccfe.empty());

                        g_ccl.HrUpdateTrayBalloonInfoByGuid(&(pccfe.GetGuidID()), BALLOON_USE_NCS, NULL, NULL);
                        g_ccl.ReleaseWriteLock();
            
                        NOTIFYICONDATA  nid;
                    
                        ZeroMemory (&nid, sizeof(nid));
                        nid.cbSize              = sizeof(NOTIFYICONDATA);
                        nid.hWnd                = g_hwndTray;
                        nid.uID                 = g_pCTrayUI->m_uiNextIconId++;
                        nid.uFlags              = NIF_MESSAGE | NIF_ICON | NIF_STATE;
                        nid.uCallbackMessage    = MYWM_NOTIFYICON;
                        nid.hIcon               = hiconTray;
                    
                        if (fShowBalloon)
                        {
                            nid.uFlags |= NIF_INFO;
                            nid.dwInfoFlags = NIIF_INFO | NIIF_NOSOUND;
                            nid.uTimeout = c_dwBalloonTimeoutSeconds * 1000;
                        
                            if (lstrlenW(pccfe.GetName()) >= celems(nid.szInfoTitle))
                            {
                                lstrcpynW(nid.szInfoTitle, pccfe.GetName(),
                                    celems(nid.szInfoTitle) -
                                    celems(c_szDotDotDot) - 1);
                                lstrcatW(nid.szInfoTitle, c_szDotDotDot);
                            }
                            else
                            {
                                lstrcpyW(nid.szInfoTitle, pccfe.GetName());
                            }
                        
                            if ( (pccfe.GetNetConMediaType() == NCM_LAN) && (pccfe.GetNetConSubMediaType() == NCSM_WIRELESS) )
                            {
                                lstrcpyW(nid.szInfo, SzLoadIds(IDS_CONTRAY_WIRELESS_DISCONN_BALLOON));
                            }
                            else
                            {
                                lstrcpyW(nid.szInfo, SzLoadIds(IDS_CONTRAY_MEDIA_DISCONN_BALLOON));
                            }
                        }
                    
                        hr = HrShell_NotifyIcon(NIM_ADD, &nid);
                    
                        if (SUCCEEDED(hr))
                        {
                            Assert(!pccfe.empty());
                        
                            // Update the connection list with the new icon identifier
                            //
                            hr = g_ccl.HrUpdateTrayIconDataByGuid(
                                &(pccfe.GetGuidID()),
                                NULL,
                                NULL,
                                NULL,
                                nid.uID);
                            
                            if (SUCCEEDED(hr))
                            {
                                hr = g_ccl.HrUpdateTrayBalloonInfoByGuid(&(pccfe.GetGuidID()), BALLOON_USE_NCS, NULL, NULL);
                            }
                                                    
                            TraceTag(ttidSystray, "Successfully added mediadisconnected icon for %S, uiIcon: %d",
                                pccfe.GetName(), nid.uID);
                        }
                    }
                    else
                    {
                        g_ccl.ReleaseWriteLock();
                    }
                }
            }
            else
            {
                AssertSz(IsMediaLocalType(pccfe.GetNetConMediaType()) || IsMediaSharedAccessHostType(pccfe.GetNetConMediaType()), "I need a dangling cable, not a phone line");
            }
        }
        else
        {
            TraceTag(ttidSystray, "Preventing the addition of a duplicate media "
                "disconnected icon. uiIcon == %d", uiIcon);
        }
        
        ReleaseTrayIconLock(&(pccfe.GetGuidID()));
    }
    else
    {
        TraceTag(ttidSystray, "Can't get tray icon lock in HrDoMediaDisconnectedIcon for uiIcon: %d as it has been locked by thread %d", uiIcon, dwLockingThreadId);
        // Someone else is already mucking with this icon
        hr = S_FALSE;
    }
    
    TraceHr(ttidSystray, FAL, hr, FALSE, "HrDoMediaDisconnectedIcon");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMyWMAddTrayIcon
//
//  Purpose:    Process the status message for the tray window
//
//  Arguments:
//      hwnd    [in]
//      wParam  [in] Pointer to CCONFOLDENTRY.
//      lParam  [in] TRUE if we are to briefly show the balloon.
//
//  Returns:
//
//  Author:
//
//  Notes:
//
//
LRESULT OnMyWMAddTrayIcon(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    TraceFileFunc(ttidSystray);

    HRESULT                 hr                  = S_OK;
    HICON                   hIcon               = NULL;
    INetStatisticsEngine *  pnseStats           = NULL;
    IConnectionPoint *      pcpStat             = NULL;
    CConnectionTrayStats *  pccts               = NULL;
    CONFOLDENTRY            pccfe;
    BOOL                    fStaticIcon         = FALSE;
    BOOL                    fBrieflyShowBalloon = (BOOL) lParam;
    NOTIFYICONDATA          nid;
    UINT                    uiIcon;
    
    Assert(wParam);
    pccfe.InitializeFromItemIdList(reinterpret_cast<LPCITEMIDLIST>(wParam));
    ::SHFree(reinterpret_cast<LPITEMIDLIST>(wParam));
    
    Assert(!pccfe.empty());
    Assert(pccfe.FShouldHaveTrayIconDisplayed());
    
    TraceTag(ttidSystray, "In OnMyWMAddTrayIcon message handler");
    
    if (pccfe.GetNetConStatus() == NCS_MEDIA_DISCONNECTED)
    {
        hr = HrDoMediaDisconnectedIcon(pccfe, fBrieflyShowBalloon);
        goto Exit;
    }
    
    // Raid #379459: If logged in as non-admin and incoming, don't show systray icon
    if (FIsUserAdmin() || 
        !(pccfe.GetCharacteristics() & NCCF_INCOMING_ONLY))
    {
        g_ccl.AcquireWriteLock();

        DWORD dwLockingThreadId = 0;
        hr = HrGetTrayIconLock(&(pccfe.GetGuidID()), &uiIcon, &dwLockingThreadId);
        if (S_OK == hr)
        {
            ConnListEntry cle;
            hr = g_ccl.HrFindConnectionByGuid(&(pccfe.GetGuidID()), cle);
            if (S_OK == hr)
            {
                g_ccl.HrUpdateTrayBalloonInfoByGuid(&(pccfe.GetGuidID()), BALLOON_USE_NCS, NULL, NULL);
                g_ccl.ReleaseWriteLock();
                
                if (uiIcon == BOGUS_TRAY_ICON_ID)
                {
                    // Try to load the branded tray icon, if present
                    //
                    if (pccfe.GetCharacteristics() & NCCF_BRANDED)
                    {
                        if (cle.pcbi && cle.pcbi->szwTrayIconPath)
                        {
                            hIcon = (HICON) LoadImage(
                                NULL,
                                cle.pcbi->szwTrayIconPath,
                                IMAGE_ICON,
                                0, 0,
                                LR_LOADFROMFILE);

                            if (hIcon)
                            {
                                // When we create the ConTrayStats object, we'll mark it as having
                                // a static icon so we don't update it on stat changes.
                                //
                                fStaticIcon = TRUE;
                            }
                        }
                    }
            
                    // If either the branded icon wasn't present or didn't load, or there
                    // was no branding to begin with, load the standard icon
                    //
                    if (!hIcon)
                    {
                        INT iConnIcon = IGetCurrentConnectionTrayIconId(pccfe.GetNetConMediaType(), pccfe.GetNetConStatus(), SMDCF_NULL);
                        hIcon = g_pCTrayUI->GetCachedHIcon(iConnIcon);
                    }
                }
            
                ZeroMemory (&nid, sizeof(nid));
                nid.cbSize              = sizeof(NOTIFYICONDATA);
                nid.hWnd                = g_hwndTray;
                nid.uID                 = g_pCTrayUI->m_uiNextIconId++;
                nid.uFlags              = NIF_MESSAGE | NIF_ICON | NIF_STATE;
                nid.uCallbackMessage    = MYWM_NOTIFYICON;
                nid.hIcon               = hIcon;
            
                // If we're not static, then tell the tray that we're using the cached icons
                //
                if (!fStaticIcon)
                {
                    nid.dwState  = NIS_SHAREDICON;
                    if (IsMediaRASType(pccfe.GetNetConMediaType()) || 
                        (NCM_SHAREDACCESSHOST_RAS == pccfe.GetNetConMediaType()) || 
                        ( (NCM_LAN == pccfe.GetNetConSubMediaType()) && 
                          (NCSM_WIRELESS == pccfe.GetNetConSubMediaType()) ) 
                       )
                    {
                         nid.dwState |= NIS_SHOWALWAYS;
                    }
                    nid.dwStateMask     = nid.dwState;
                }
            
                // Create the statistics objects
                //
                hr = HrGetStatisticsEngineForEntry(pccfe, &pnseStats, TRUE);
                if (SUCCEEDED(hr))
                {
                    // Advise the interface
                    hr = HrGetPcpFromPnse(pnseStats, &pcpStat);
                    if (SUCCEEDED(hr))
                    {
                        INetConnectionStatisticsNotifySink *  pncsThis;
                        hr = CConnectionTrayStats::CreateInstance (
                            pccfe,
                            nid.uID,
                            fStaticIcon,
                            IID_INetConnectionStatisticsNotifySink,
                            reinterpret_cast<VOID**>(&pncsThis));
                
                        if (SUCCEEDED(hr))
                        {
                            pccts = reinterpret_cast<CConnectionTrayStats*>(pncsThis);
                    
                            hr = pnseStats->StartStatistics();

                            if (SUCCEEDED(hr))
                            {
                                // Don't release this. We need to store it with
                                // the entry so we can UnAdvise later
                                //
                                hr = pcpStat->Advise(pncsThis, pccts->GetConPointCookie());
                            }
                        }
           
                        if (fBrieflyShowBalloon)
                        {
                            if ( (NCS_CONNECTED                == pccfe.GetNetConStatus()) ||
                                 (NCS_AUTHENTICATION_SUCCEEDED == pccfe.GetNetConStatus()) ||
                                 (NCS_INVALID_ADDRESS          == pccfe.GetNetConStatus()) )
                            {
                                nid.uFlags |= NIF_INFO;
                                nid.dwInfoFlags = NIIF_INFO | NIIF_NOSOUND;
                                nid.uTimeout = c_dwBalloonTimeoutSeconds * 1000;

                                WCHAR szBalloonStr[MAX_PATH];
                                UINT idTitle = (NCS_INVALID_ADDRESS == pccfe.GetNetConStatus()) ? 
                                                IDS_BALLOON_UNAVAILABLE : IDS_BALLOON_CONNECTED;

                                int dwMaxNameLen = celems(nid.szInfoTitle) - celems(c_szDotDotDot) - lstrlenW(SzLoadIds(IDS_BALLOON_CONNECTED)) - 1;
                                DwFormatString(SzLoadIds(idTitle), szBalloonStr, MAX_PATH, pccfe.GetName());
                
                                if (lstrlenW(szBalloonStr) >= dwMaxNameLen)
                                {
                                    lstrcpyW(szBalloonStr, pccfe.GetName());        // Only use the Connection Name

                                    if (lstrlenW(nid.szInfoTitle) >= dwMaxNameLen)  // Still bigger?
                                    {
                                        lstrcpynW(nid.szInfoTitle, szBalloonStr, dwMaxNameLen);
                                        lstrcatW(nid.szInfoTitle, c_szDotDotDot);
                                    }
                                    else
                                    {
                                        lstrcpyW(nid.szInfoTitle, szBalloonStr);
                                    }
                                }
                                else
                                {
                                    lstrcpyW(nid.szInfoTitle, szBalloonStr);
                                }

                                AssertSz(lstrlenW(nid.szInfoTitle) < celems(nid.szInfoTitle),
                                    "Balloon tooltip text is too long!");
                
                
                                if (pccfe.GetNetConStatus() == NCS_INVALID_ADDRESS)
                                {
                                    STATMON_ENGINEDATA* pData = NULL;
                                    UINT idString = IDS_CONTRAY_ADDRESS_INVALID_BALLOON;
                                    if (S_OK == pnseStats->GetStatistics(&pData) && pData)
                                    {
                                        if (STATIC_ADDR == pData->SMED_DHCP_ADDRESS_TYPE)
                                        {
                                            idString = IDS_CONTRAY_STATIC_ADDR_INVALID_BALLON;
                                        }

                                        CoTaskMemFree(pData);
                                    }
                        
                                    lstrcpynW(nid.szInfo, SzLoadIds(idString), celems(nid.szInfo));
                                }
                                else
                                {
                                    GetInitialBalloonText(
                                        pnseStats,
                                        nid.szInfo,
                                        celems(nid.szInfo));
                                }
                            }
                        }
            
                        // Add the icon itself.
                        //
                        TraceTag(ttidSystray, "Adding shared shell icon: uID=%u, hIcon=0x%x",
                            nid.uID,
                            nid.hIcon);
            
                        hr = HrShell_NotifyIcon(NIM_ADD, &nid);
                        if (SUCCEEDED(hr) && pccts)
                        {
                            Assert(!pccfe.empty());
                
                            // Update the connection list with the new icon identifier
                            //
                            hr = g_ccl.HrUpdateTrayIconDataByGuid(
                                &(pccfe.GetGuidID()),
                                pccts,
                                pcpStat,
                                pnseStats,
                                nid.uID);

                            if (SUCCEEDED(hr))
                            {
                                hr = g_ccl.HrUpdateTrayBalloonInfoByGuid(&(pccfe.GetGuidID()), BALLOON_USE_NCS, NULL, NULL);
                            }

                        }

                        ::ReleaseObj(pccts);
                        ::ReleaseObj(pcpStat);
                    }
                    ::ReleaseObj(pnseStats);
                }
            }
            else
            {
                g_ccl.ReleaseWriteLock();
            }

            // Release the lock on the tray icon
            //
            ReleaseTrayIconLock(&(pccfe.GetGuidID()));
        }
        else
        {
            g_ccl.ReleaseWriteLock();

            // Could not obtain an icon lock
            //
#ifdef DBG
            if (S_FALSE == hr)
            {
                Assert(dwLockingThreadId);
                TraceTag(ttidSystray, "Tray icon locked by thread id %d", dwLockingThreadId);
            }
            else
            {
                TraceTag(ttidError, "Could not obtain tray icon data for connection %S", pccfe.GetName());
            }
#endif
            hr = S_FALSE;
        }
    }
    else
    {
        // Non-admin, or incoming connection
        //
        hr = S_FALSE;
    }
    
Exit:
    TraceHr(ttidSystray, FAL, hr, SUCCEEDED(hr), "OnMyWMAddTrayIcon");
    return 0;
}



//+---------------------------------------------------------------------------
//
//  Function:   OnMyRemoveTrayIcon
//
//  Purpose:    Process the status message for the tray window
//
//  Arguments:
//      hwnd    []
//      wParam  []
//      lParam  []
//
//  Returns:
//
//  Author:
//
//  Notes:
//
//
LRESULT OnMyWMRemoveTrayIcon(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    TraceFileFunc(ttidSystray);

    HRESULT         hr = E_FAIL;
    GUID *          pGuid            = reinterpret_cast<GUID *>(lParam);
    NOTIFYICONDATA  nid;
    
    // This is returned from a cle, hence should be locked
#ifdef VERYSTRICTCOMPILE
    const CTrayIconData * pTrayIconData = reinterpret_cast<const CTrayIconData *>(wParam);
#else
    CTrayIconData * pTrayIconData = reinterpret_cast<CTrayIconData *>(wParam);
#endif
    
    
    TraceTag(ttidSystray, "In OnMyWMRemoveTrayIcon message handler");
    
    ZeroMemory (&nid, sizeof(nid));
    nid.cbSize  = sizeof(NOTIFYICONDATA);
    nid.hWnd    = g_hwndTray;
    
    // We'll make do if this wasn't passed in. What that means is that we may
    // have a timing window where we are adding and removing these icons
    // at such a rate that the add has occurred before the connection has
    // had a chance to add the previous icon (so we don't know to remove it).
    //
    if (!pTrayIconData)
    {
        TraceTag(ttidSystray, "No tray icon data found, loading from cache");
        
        Assert(pGuid);
        
        g_ccl.AcquireWriteLock();
        ConnListEntry cle;
        hr = g_ccl.HrFindConnectionByGuid(pGuid, cle);
        if (S_OK == hr)
        {
            TraceTag(ttidSystray, "Tray icon data found in cache");
            
            Assert(!cle.empty())
                if (cle.HasTrayIconData())
                {
                    TraceTag(ttidSystray, "pTrayIconData was valid");

                    pTrayIconData = new CTrayIconData(*cle.GetTrayIconData());
                    if (!pTrayIconData)
                    {
                        g_ccl.ReleaseWriteLock();
                        return E_OUTOFMEMORY;
                    }
                    cle.DeleteTrayIconData();
                    
                    g_ccl.HrUpdateConnectionByGuid(pGuid, cle);
                }
        }
        
        g_ccl.ReleaseWriteLock();
        
        // This is a copy that we should delete
        //
        delete pGuid;
        pGuid = NULL;
    }

    if (pTrayIconData)
    {
        nid.uID = pTrayIconData->GetTrayIconId();
        
        TraceTag(ttidSystray, "Removing tray icon with id=%u",
            pTrayIconData->GetTrayIconId() );
        
        int nCount = 5;
        hr = E_FAIL;   // Make sure we get at least one attempt in
        
        while ((nCount--) && (S_OK != hr))
        {
            hr = HrShell_NotifyIcon(NIM_DELETE, &nid);
            
            if (E_FAIL == hr)
            {
                TraceTag(ttidSystray, "Tray icon: %d failed in delete via "
                    "HrShell_NotifyIcon. Will retry shortly", pTrayIconData->GetTrayIconId() );
                
                // Raid #370358
                Sleep(500);
            }
            else
            {
                TraceTag(ttidSystray, "Tray icon: %d removed succesfully", pTrayIconData->GetTrayIconId());
            }
        }

        // Unadvise the statistics interface
        //
        if (pTrayIconData->GetConnectionPoint() && pTrayIconData->GetConnectionTrayStats() )
        {
            pTrayIconData->GetConnectionPoint()->Unadvise(*pTrayIconData->GetConnectionTrayStats()->GetConPointCookie());
        }

        // Stop the statistics
        //
        if (pTrayIconData->GetNetStatisticsEngine() )
        {
            pTrayIconData->GetNetStatisticsEngine()->StopStatistics();
        }

        // Delete the structure
        //
        delete pTrayIconData;
    }
    
    TraceHr(ttidSystray, FAL, hr, FALSE, "OnMyWMRemoveTrayIcon");
    
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMyUpdateTrayIcon
//
//  Purpose:    Process the status message for the tray window
//
//  Arguments:
//      hwnd    []
//      wParam  []
//      lParam  []
//
//  Returns:
//
//  Author:
//
//  Notes:
//
//
LRESULT OnMyWMUpdateTrayIcon(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    TraceFileFunc(ttidSystray);

    if (g_pCTrayUI)
    {
        g_pCTrayUI->UpdateTrayIcon((UINT)wParam, (int)lParam);
    }
    
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   OnMyWMShowTrayIconBalloon
//
//  Purpose:    Puts balloon text on the icon for the tray window
//              Change the state of the connection
//
//  Arguments:
//      hwnd    [in]
//      wParam  [in]
//      lParam  [in] Point to CTrayBalloon structure
//
//  Returns:
//
//  Author:
//
//  Notes:
//
//
LRESULT OnMyWMShowTrayIconBalloon(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    TraceFileFunc(ttidSystray);

    HRESULT        hr           = S_OK;
    HRESULT        hrFind       = S_OK;
    BOOL           fLockHeld    = FALSE;

    Assert(lParam);
    if (!lParam)
    {
        return FALSE;
    }

    CTrayBalloon * pTrayBalloon = reinterpret_cast<CTrayBalloon *>(lParam);
    UINT           uiIcon;

    DWORD dwLockingThreadId = 0;
    hr = HrGetTrayIconLock(&(pTrayBalloon->m_gdGuid), &uiIcon, &dwLockingThreadId);
    if (S_OK == hr)
    {
        if (uiIcon != BOGUS_TRAY_ICON_ID)
        {
            ConnListEntry  cleFind;

            g_ccl.AcquireWriteLock();
            hrFind = g_ccl.HrFindConnectionByGuid(&(pTrayBalloon->m_gdGuid), cleFind);
            if (S_OK == hrFind)
            {
                Assert(!cleFind.ccfe.empty());
                Assert(pTrayBalloon->m_pfnFuncCallback);

                g_ccl.HrUpdateTrayBalloonInfoByGuid(&(pTrayBalloon->m_gdGuid), BALLOON_CALLBACK, pTrayBalloon->m_szCookie, pTrayBalloon->m_pfnFuncCallback);
                g_ccl.ReleaseWriteLock();
            
                NOTIFYICONDATA  nid;
                INT iIconResourceId;
                iIconResourceId = IGetCurrentConnectionTrayIconId(
                                        cleFind.ccfe.GetNetConMediaType(), 
                                        cleFind.ccfe.GetNetConStatus(),
                                        0);

                ZeroMemory (&nid, sizeof(nid));
                nid.cbSize              = sizeof(NOTIFYICONDATA);
                nid.hWnd                = g_hwndTray;
                nid.uID                 = uiIcon;
                nid.uFlags              = NIF_MESSAGE | NIF_ICON | NIF_STATE;
                nid.hIcon               = g_pCTrayUI->GetCachedHIcon(iIconResourceId);
                nid.dwState             = NIS_SHAREDICON;
                nid.dwStateMask         = nid.dwState;
                nid.uCallbackMessage    = MYWM_NOTIFYICON;

                // Prepare the balloon data

                nid.uFlags     |= NIF_INFO;
                nid.dwInfoFlags = NIIF_INFO | NIIF_NOSOUND;
                nid.uTimeout = pTrayBalloon->m_dwTimeOut;

                if (lstrlenW(cleFind.ccfe.GetName()) >= celems(nid.szInfoTitle))
                {
                    lstrcpynW(nid.szInfoTitle, cleFind.ccfe.GetName(),
                             celems(nid.szInfoTitle) -
                             celems(c_szDotDotDot) - 1);
                    lstrcatW(nid.szInfoTitle, c_szDotDotDot);
                }
                else
                {
                    lstrcpyW(nid.szInfoTitle, cleFind.ccfe.GetName());
                }

                lstrcpynW(nid.szInfo, pTrayBalloon->m_szMessage, celems(nid.szInfo));

                // Display the balloon 
                HrShell_NotifyIcon(NIM_MODIFY, &nid);
            }
            else
            {
                g_ccl.ReleaseWriteLock();
            }
        }
        else
        {
            TraceTag(ttidSystray, "No existing icon data!!!");
        }

        // Release the lock on the tray icon
        //
        ReleaseTrayIconLock(&(pTrayBalloon->m_gdGuid));
    }
    else
    {
        TraceTag(ttidSystray, "Can't get tray icon lock in OnMyWMShowTrayIconBalloon for uiIcon: %d as it has been locked by thread %d", uiIcon, dwLockingThreadId);
    }

    delete pTrayBalloon; 

    TraceHr(ttidSystray, FAL, hr, SUCCEEDED(hr), "OnMyWMShowTrayIconBalloon");
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   OnMyWMOpenStatus
//
//  Purpose:    Process the status message for the tray window
//
//  Arguments:
//      hwnd    []
//      wParam  []
//      lParam  []
//
//  Returns:
//
//  Author:     jeffspr   15 Dec 1997
//
//  Notes:
//
//
LRESULT OnMyWMOpenStatus(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    TraceFileFunc(ttidSystray);

    Assert(wParam);
    
    CONFOLDENTRY   pccfe;
    pccfe.InitializeFromItemIdList(reinterpret_cast<LPCITEMIDLIST>(wParam));
    
    BOOL  fCreateEngine = (BOOL)lParam;
    Assert(!pccfe.empty());
    
    HRESULT hr;
    ConnListEntry cle;
    hr = g_ccl.HrFindConnectionByGuid(&(pccfe.GetGuidID()), cle);
    if (S_OK == hr)
    {
        if (FHasPermission(NCPERM_Statistics))
        {
            if (!pccfe.empty())
            {
                INetStatisticsEngine* pnseNew;
                hr = HrGetStatisticsEngineForEntry(pccfe, &pnseNew, fCreateEngine);
                if (SUCCEEDED(hr))
                {
                    hr = pnseNew->ShowStatusMonitor();
                    ReleaseObj(pnseNew);
                }
                else
                {
                    TraceTag(ttidSystray, 
                        "OnMyWMOpenStatus: Statistics Engine for connection %S has been removed."
                        "It's ok if this connection is being disconnected", pccfe.GetName());
                }
            }
        }
    }
    
    return 0;
}

LRESULT OnMyWMNotifyIcon(HWND hwnd, UINT uiMessage, WPARAM wParam, LPARAM lParam)
{
    TraceFileFunc(ttidSystray);

    UINT    uiIcon;
    UINT    uiMouseMsg;
    
    uiIcon = (UINT) wParam;
    uiMouseMsg = (UINT) lParam;
    
    switch (uiMouseMsg)
    {
    case WM_MOUSEMOVE:
        FormatToolTip(hwnd, uiIcon);
        break;
        
    case WM_RBUTTONUP:
        OnTaskBarIconRButtonUp(hwnd, uiIcon);
        break;
        
    case NIN_BALLOONUSERCLICK:
        OnTaskBarIconBalloonClick(hwnd, uiIcon);
        break;

    case WM_LBUTTONUP:
        OnTaskBarIconLButtonDblClk(hwnd, uiIcon);
        break;
    }
    
    return 0;
}

VOID OnTaskBarIconRButtonUp(HWND hwnd, UINT uiIcon)
{
    TraceFileFunc(ttidSystray);

    POINT   pt;
    
    GetCursorPos(&pt);
    (VOID) HrOpenContextMenu(hwnd, &pt, uiIcon);
}

//+---------------------------------------------------------------------------
//
//  Function:   OnTaskBarIconLButtonDblClk
//
//  Purpose:    Message handler for the Left-button double click from
//              a tray icon
//
//  Arguments:
//      hwnd   []   Our window handle
//      uiIcon []   Our Icon ID.
//
//  Returns:
//
//  Author:     jeffspr   12 Jan 1998
//
//  Notes:
//
VOID OnTaskBarIconLButtonDblClk(HWND hwnd, UINT uiIcon)
{
    TraceFileFunc(ttidSystray);

    HRESULT         hr      = S_OK;
    if (GetKeyState(VK_SHIFT))
    {
        // Uh, nothing special to do here yet, but just in case...
    }
    
    // Perform the default context menu action
    // Find the connection info based on the tray icon id.
    //
    ConnListEntry cle;
    hr = g_ccl.HrFindConnectionByTrayIconId(uiIcon, cle);
    if (hr == S_OK)
    {
        Assert(!cle.ccfe.empty());
        
        if (!cle.ccfe.empty())
        {
            if (cle.ccfe.GetNetConStatus() == NCS_MEDIA_DISCONNECTED)
            {
                if (IsMediaLocalType(cle.ccfe.GetNetConMediaType()) &&
                    (NCSM_WIRELESS == cle.ccfe.GetNetConSubMediaType()) )
                {
                    PCONFOLDPIDLVEC pcfpVec;
                    PCONFOLDPIDL    pcfp;
                    hr = cle.ccfe.ConvertToPidl(pcfp);
                    if (SUCCEEDED(hr))
                    {
                        pcfpVec.insert(pcfpVec.begin(), pcfp);
                        HrOnCommandWZCDlgShow(pcfpVec,
                        g_hwndTray,
                        NULL);
                    }
                }
                else
                {
                    hr = HrOpenConnectionsFolder();
                }
            }
            else
            {
                switch(c_idDefaultCMCommand)
                {
                case CMIDM_TRAY_STATUS:
                    hr = HrOnCommandStatusInternal(cle.ccfe, FALSE);
                    break;
                    
                default:
                    AssertSz(FALSE, "Default tray context menu item unhandled");
                    break;
                }
            }
        }
    }
    
    return;
}

DWORD WINAPI OnTaskBarIconBalloonClickThread(LPVOID lpParam)
{
    HRESULT hr = E_FAIL;

    CTrayBalloon *pTrayBalloon = reinterpret_cast<CTrayBalloon *>(lpParam);
    Assert(pTrayBalloon);

    FNBALLOONCLICK *pFNBalloonClick;
    pFNBalloonClick = pTrayBalloon->m_pfnFuncCallback;
    if (pFNBalloonClick)
    {
        hr = (pFNBalloonClick)(&(pTrayBalloon->m_gdGuid), pTrayBalloon->m_szAdapterName, pTrayBalloon->m_szCookie);
    }

    if (E_PENDING == hr)
    {
        MSG msg;
        while (GetMessage (&msg, 0, 0, 0))
        {
            DispatchMessage (&msg);
        }
        
        hr = S_OK;
    }

    delete pTrayBalloon;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnTaskBarIconBalloonClick
//
//  Purpose:    Message handler for the balloon click from
//              a tray icon
//
//  Arguments:
//      hwnd   []   Our window handle
//      uiIcon []   Our Icon ID.
//
//  Returns:
//
//  Author:     deon   20 Mar 2001
//
//  Notes:
//
VOID OnTaskBarIconBalloonClick(HWND hwnd, UINT uiIcon)
{
    TraceFileFunc(ttidSystray);

    HRESULT         hr      = S_OK;
    if (GetKeyState(VK_SHIFT))
    {
        // Uh, nothing special to do here yet, but just in case...
    }
    
    // Perform the default context menu action
    // Find the connection info based on the tray icon id.
    //
    ConnListEntry cle;
    hr = g_ccl.HrFindConnectionByTrayIconId(uiIcon, cle);
    if (hr == S_OK)
    {
        Assert(!cle.ccfe.empty());
        
        if (!cle.ccfe.empty())
        {
            if (!cle.GetTrayIconData())
            {
                ASSERT (0);
            }
                    
            switch ((cle.GetTrayIconData())->GetLastBalloonMessage())
            {
                case BALLOON_NOTHING:
                    AssertSz(NULL, "You didn't set the balloon");
                    break;

                case BALLOON_CALLBACK:
                    {
                        CTrayBalloon *pTrayBalloon = new CTrayBalloon();
                        if (pTrayBalloon)
                        {
                            pTrayBalloon->m_gdGuid   = cle.ccfe.GetGuidID();
                            pTrayBalloon->m_szCookie = SysAllocStringByteLen(reinterpret_cast<LPCSTR>(cle.GetTrayIconData()->GetLastBalloonCookie()), SysStringByteLen(cle.GetTrayIconData()->GetLastBalloonCookie()));
                            pTrayBalloon->m_pfnFuncCallback = cle.GetTrayIconData()->GetLastBalloonFunction();
                            pTrayBalloon->m_dwTimeOut= 0;
                            pTrayBalloon->m_szAdapterName = cle.ccfe.GetName();

                            CreateThread(NULL, STACK_SIZE_SMALL, OnTaskBarIconBalloonClickThread, pTrayBalloon, 0, NULL);
                        }
                    }
                    break;

                case BALLOON_USE_NCS:
                    if (cle.ccfe.GetNetConStatus() == NCS_MEDIA_DISCONNECTED)
                    {
                        Assert(c_idDefaultDisconCMCommand == CMIDM_OPEN_CONNECTIONS_FOLDER);
                        hr = HrOpenConnectionsFolder();
                    }
                    else
                    {
                        switch(c_idDefaultCMCommand)
                        {
                        case CMIDM_TRAY_STATUS:
                            hr = HrOnCommandStatusInternal(cle.ccfe, FALSE);
                            break;
                    
                        default:
                            AssertSz(FALSE, "Default tray context menu item unhandled");
                            break;
                        }
                    }
                    break;
                    
                default:
                    ASSERT (0);
                    break;

            }
        }
    }
    
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMyWMFlushNoop
//
//  Purpose:    Process the MYWM_FLUSHNOOP message for the tray. This is used
//              via SendMessage to clear the tray message queue.
//
//  Arguments:  
//      hwnd   [in]     Our hwnd
//      wParam [in]     Unused
//      lParam [in]     Unused
//
//  Returns:    
//
//  Author:     jeffspr   30 Aug 1999
//
//  Notes:      
//
LRESULT OnMyWMFlushNoop(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    TraceFileFunc(ttidSystray);

    TraceTag(ttidSystray, 
        "Tray received tray FLUSH Noop. This should clear the tray message loop");
    
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   FlushTrayPosts
//
//  Purpose:    Flush the tray message queue by doing a SendMessage of a NOOP
//
//  Arguments:  
//      hwnd [in] Where to post to.
//
//  Returns:    
//
//  Author:     jeffspr   8 Sep 1999
//
//  Notes:      
//
VOID FlushTrayPosts(HWND hwnd)
{
    TraceFileFunc(ttidSystray);

    // Flush the tray posts
    //
    SendMessage(hwnd, MYWM_FLUSHNOOP, (WPARAM) 0, (LPARAM) 0);
}


BOOL FInitFoldEnumerator(HWND hwnd, DWORD * pdwIconsAdded)
{
    TraceFileFunc(ttidSystray);
    
    BOOL                    fReturn         = FALSE;
    HRESULT                 hr              = S_OK;
    CConnectionFolderEnum * pCFEnum         = NULL;
    PCONFOLDPIDL            pidlCon;
    DWORD                   dwFetched       = 0;
    DWORD                   dwIconsAdded    = 0;
    PCONFOLDPIDLFOLDER      pidlFolder;
    
    NETCFG_TRY

        // Create the IEnumIDList object (CConnectionFolderEnum)
        //
        hr = CConnectionFolderEnum::CreateInstance (
            IID_IEnumIDList,
            (VOID **)&pCFEnum);
        
        if (SUCCEEDED(hr))
        {
            Assert(pCFEnum);
            
            // Call the PidlInitialize function to allow the enumeration
            // object to copy the list.
            //
            PCONFOLDPIDLFOLDER pcfpEmpty;
            pCFEnum->PidlInitialize(TRUE, pcfpEmpty, CFCOPT_ENUMALL);
        }
        
        if (SUCCEEDED(hr))
        {
            while (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                // Clear out the previous results, if any.
                //
                pidlCon.Clear();
                dwFetched   = 0;
                
                // Get the next connection
                //
                LPITEMIDLIST pTempItemIdList;
                hr = pCFEnum->Next(1, &pTempItemIdList, &dwFetched);
                if (S_OK == hr)
                {
                    pidlCon.InitializeFromItemIDList(pTempItemIdList);
                    const PCONFOLDPIDL& pcfp = pidlCon;
                    
                    // If it's not a wizard pidl, then update the
                    // icon data.
                    //
                    if (WIZARD_NOT_WIZARD == pcfp->wizWizard)
                    {
                        // If the folder pidl hasn't already been loaded
                        // then get it
                        //
                        if (pidlFolder.empty())
                        {
                            hr = HrGetConnectionsFolderPidl(pidlFolder);
                        }
                        
                        // Assuming that succeeded (or hr will be S_OK if
                        // the HrGet... wasn't called)
                        //
                        if (SUCCEEDED(hr))
                        {
                            // Refresh this item -- this will make the desktop shortcuts
                            // update to the correct state.
                            //
                            RefreshFolderItem(pidlFolder, pidlCon, pidlCon, TRUE);
                        }
                    }
                }
            }
        }
        
        if (SUCCEEDED(hr))
        {
            // Normalize the return code.
            //
            hr = S_OK;
            fReturn = TRUE;
            
            // If the caller wants the fetched count
            //
            if (pdwIconsAdded)
            {
                *pdwIconsAdded = dwIconsAdded;
            }
        }
        
        ReleaseObj(pCFEnum);
    
    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, FALSE, "FInitFoldEnumerator");
    return fReturn;
    
}

HICON CTrayUI::GetCachedHIcon(INT iIconResourceId)
{
    TraceFileFunc(ttidSystray);

    CExceptionSafeLock esLock(&m_csLock);
    
    HICON hIcon = m_mapIdToHicon [iIconResourceId];
    if (!hIcon)
    {
        TraceTag(ttidSystray, "Loading HICON for resource id %u and adding it to our map.",
            iIconResourceId);
        
        hIcon = LoadIcon(_Module.GetResourceInstance(),
            MAKEINTRESOURCE(iIconResourceId));
        
        //AssertSz (hIcon, "Couldn't load a tray icon.  You may ignore this "
        //    "assert and a default icon will be used.");
        
        if (!hIcon)
        {
            hIcon = LoadIcon(_Module.GetResourceInstance(),
                MAKEINTRESOURCE(IDI_LB_GEN_S_16));
            AssertSz (hIcon, "Okay, now you're hosed.  Couldn't load the "
                "default icon either.  email jeffspr.");
        }
        
        m_mapIdToHicon [iIconResourceId] = hIcon;
        
        // Add a hidden icon to the tray so that the shell will cache it.
        //
        NOTIFYICONDATA  nid;
        ZeroMemory (&nid, sizeof(nid));
        nid.cbSize      = sizeof(NOTIFYICONDATA);
        nid.hWnd        = g_hwndTray;
        nid.uID         = m_uiNextHiddenIconId--;
        nid.uFlags      = NIF_ICON | NIF_STATE;
        nid.hIcon       = hIcon;
        nid.dwState     = NIS_HIDDEN;
        nid.dwStateMask = nid.dwState;
        
        /*
        nid.uFlags |= NIF_TIP;
        wsprintfW(nid.szTip, L"hidden: uID=%u, hIcon=0x%x", nid.uID, nid.hIcon);
        */
        
        TraceTag(ttidSystray, "Adding hidden shell icon: uID=%u, hIcon=0x%x",
            nid.uID,
            nid.hIcon);
        
        HRESULT hr = HrShell_NotifyIcon(NIM_ADD, &nid);
        if (SUCCEEDED(hr))
        {
            // We can now destroy the icon.  This looks weird, but we're only
            // going to use the hIcon for passing to Shell_NotifyIcon again
            // when we add the shared icon with a different uID.
            //
            DestroyIcon(hIcon);
        }
    }
    
    Assert (hIcon);
    return hIcon;
}

VOID CTrayUI::UpdateTrayIcon(UINT    uiTrayIconId,
                             INT     iIconResourceId)
{
    TraceFileFunc(ttidSystray);

    NOTIFYICONDATA  nid;
    
    ZeroMemory (&nid, sizeof(nid));
    nid.cbSize      = sizeof(NOTIFYICONDATA);
    nid.hWnd        = g_hwndTray;
    nid.uID         = uiTrayIconId;
    nid.uFlags      = NIF_ICON | NIF_STATE;
    nid.hIcon       = GetCachedHIcon(iIconResourceId);
    nid.dwState     = NIS_SHAREDICON;
    nid.dwStateMask = nid.dwState;
    
    Shell_NotifyIcon(NIM_MODIFY, &nid);
}

VOID GetInitialBalloonText(INetStatisticsEngine*   pnse,
                           PWSTR                   pszBuf,
                           DWORD                   dwSize)
{
    TraceFileFunc(ttidSystray);

    *pszBuf = 0;
    
    if (pnse)
    {
        STATMON_ENGINEDATA* pData = NULL;
        
        HRESULT hr = pnse->GetStatistics(&pData);
        if (SUCCEEDED(hr) && pData)
        {
            if (pData->SMED_802_11_SSID && pData->SMED_802_11_SIGNAL_STRENGTH)
            {
                DwFormatString(SzLoadIds(IDS_TOOLTIP_WIRELESS_CONNECTED), pszBuf, dwSize, 
                                pData->SMED_802_11_SSID, PszGetRSSIString(pData->SMED_802_11_SIGNAL_STRENGTH));
            }
            else 
            if ((pData->SMED_SPEEDTRANSMITTING>0) || (pData->SMED_SPEEDRECEIVING>0))
            {
                WCHAR pszValue [64];
                
                // Format the transmitting (and possibly the receiving) speed
                // into the buffer.
                //
                FormatTransmittingReceivingSpeed (
                    pData->SMED_SPEEDTRANSMITTING,
                    pData->SMED_SPEEDRECEIVING,
                    pszValue);
                
                DwFormatString(SzLoadIds(IDS_TOOLTIP_LINE_SPEED), pszBuf, dwSize, pszValue);
            }

            CoTaskMemFree(pData);
        }
    }
    
    // Provide a default.
    //
    if (!*pszBuf)
    {
        lstrcpyW(pszBuf, SzLoadIds(IDS_CONTRAY_INITIAL_BALLOON));
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddTrayExtension
//
//  Purpose:    Add the tray extension to the Shell's delay load key
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   28 Jul 1998
//
//  Notes:
//
HRESULT HrAddTrayExtension()
{
    TraceFileFunc(ttidSystray);

    HRESULT hr              = S_OK;
    HKEY    hkeyDelayLoad   = NULL;
    
    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szDelayLoadKey,
        REG_OPTION_NON_VOLATILE, KEY_WRITE,
        NULL, &hkeyDelayLoad, NULL);
    if (SUCCEEDED(hr))
    {
        hr = HrRegSetString(hkeyDelayLoad, c_szDelayLoadName, c_szDelayLoadClassID);
        
        RegCloseKey(hkeyDelayLoad);
    }
    
    TraceHr(ttidSystray, FAL, hr, FALSE, "HrAddTrayExtension");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveTrayExtension
//
//  Purpose:    Remove the tray extension from the shell's delay load key
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   28 Jul 1998
//
//  Notes:
//
HRESULT HrRemoveTrayExtension()
{
    TraceFileFunc(ttidSystray);

    HRESULT hr              = S_OK;
    HKEY    hkeyDelayLoad   = NULL;
    
    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szDelayLoadKey,
        REG_OPTION_NON_VOLATILE, KEY_WRITE,
        NULL, &hkeyDelayLoad, NULL);
    if (SUCCEEDED(hr))
    {
        (void) HrRegDeleteValue(hkeyDelayLoad, c_szDelayLoadName);
        
        RegCloseKey(hkeyDelayLoad);
    }
    
    TraceHr(ttidSystray, FAL, hr, FALSE, "HrRemoveTrayExtension");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\droptarget.h ===
//
// DropTarget.h
//
#pragma once 

class CDropTarget : public IDropTarget
{
public:
	CDropTarget(IShellFolder *);
	~CDropTarget();

	//IUnknown methods
	STDMETHOD(QueryInterface)(REFIID, LPVOID*);
	STDMETHOD_(ULONG, AddRef)(void);
	STDMETHOD_(ULONG, Release)(void);

	//IDropTarget methods
	STDMETHOD(DragEnter)(LPDATAOBJECT, DWORD, POINTL, LPDWORD);
	STDMETHOD(DragOver)(DWORD, POINTL, LPDWORD);
	STDMETHOD(DragLeave)(VOID);
	STDMETHOD(Drop)(LPDATAOBJECT, DWORD, POINTL, LPDWORD);
private:
	IShellFolder   *m_psfParent;
	ULONG          m_uiRefCount;  
private:
	BOOL           m_bAcceptFmt;
    
	CLIPFORMAT     m_cfPrivatePidlData;
    CLIPFORMAT     m_cfPrivateFileData;
private:
	BOOL queryDrop(DWORD, LPDWORD);
	DWORD getDropEffectFromKeyState(DWORD);

    BOOL CanDropFile(HGLOBAL);
    BOOL CanDropPidl(HGLOBAL, CONFOLDENTRY& cfe);
    BOOL CanDropPidl(HGLOBAL);

    BOOL CDropTarget::doPIDLDrop(HGLOBAL hMem, BOOL bCut);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\foldglob.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       F O L D G L O B . C P P
//
//  Contents:   Globals for the shell foldering code.
//
//  Notes:
//
//  Author:     jeffspr   23 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "connlist.h"   // CConnectionList class.



// Connection list global
//
CConnectionList g_ccl;  // our global list.

// The state of the operator assist dial flag
//
bool    g_fOperatorAssistEnabled;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\foldglob.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       F O L D G L O B . H
//
//  Contents:   Global definitions for the shell foldering code
//
//  Notes:
//
//  Author:     jeffspr   23 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _FOLDGLOB_H_
#define _FOLDGLOB_H_

// The connection list
//
extern CConnectionList  g_ccl;

// The state of the operator assist dial flag
//
extern bool             g_fOperatorAssistEnabled;

#endif // _FOLDGLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\icomtargf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       I C O M T A R G F . C P P
//
//  Contents:   ICommandTarget implementation for IConnectionFolder
//
//  Notes:
//
//  Author:     jeffspr   12 Mar 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\tray includes



const IID CGID_ConnectionsFolder =
{0xeaf70ce4,0xb521,0x11d1,{0xb5,0x50,0x00,0xc0,0x4f,0xd9,0x18,0xd0}};


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::QueryStatus
//
//  Purpose:    [IOleCommandTarget] Queries the object for the status of one 
//              or more commands generated by user interface events.
//
//              This interface is required but is currently unimplemented
//
//  Arguments:  
//      pguidCmdGroup [in]      // Pointer to command group
//      cCmds         [in]      // Number of commands in prgCmds array
//      prgCmds       [in,out]  // Array of commands
//      pCmdText      [in,out]  // Pointer to name or status of command
//
//  Returns:    
//
//  Author:     jeffspr   12 Aug 1999
//
//  Notes:      
//
HRESULT CConnectionFolder::QueryStatus(
    const GUID *    pguidCmdGroup,
    ULONG           cCmds,
    OLECMD          prgCmds[],
    OLECMDTEXT *    pCmdText)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = E_NOTIMPL;

    TraceHr(ttidError, FAL, hr, (hr == E_NOTIMPL), "CConnectionFolder::QueryStatus");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::Exec
//
//  Purpose:    [IOleCommandTarget] Executes a specified command or displays 
//              help for a command.
//  
//              This method is not currently referenced, but if the shell
//              wanted to enumerate only incoming our outgoing connections,
//              it would use the CFCID_SETENUMTYPE command to force the 
//              issue (that is unimplemented on our side, however)
//
//  Arguments:  
//      pguidCmdGroup [in]      // Pointer to command group
//      nCmdID        [in]      // Identifier of command to execute
//      nCmdexecopt   [in]      // Options for executing the command
//      pvaIn         [in]      // Pointer to input arguments
//      pvaOut        [in,out]  // Pointer to command output
//
//  Returns:    
//
//  Author:     jeffspr   12 Aug 1999
//
//  Notes:      
//
HRESULT CConnectionFolder::Exec(
    const GUID *    pguidCmdGroup,
    DWORD           nCmdID,
    DWORD           nCmdexecopt,
    VARIANTARG *    pvaIn,
    VARIANTARG *    pvaOut)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = NOERROR;

    if (!pguidCmdGroup)
    {
        return hr;
    }
    
    // Handle Shell pre-enumeration commands here.
    //
    if (IsEqualGUID(*pguidCmdGroup, CGID_ConnectionsFolder))
    {
        switch (nCmdID)
        {
            case CFCID_SETENUMTYPE:
                m_dwEnumerationType = nCmdexecopt;
                break;
            default:
                hr = S_OK;
                break;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolder::Exec");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\icomtarg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I C O M T A R G . C P P
//
//  Contents:   ICommandTarget implementation for IConnectionTray
//
//  Notes:
//
//  Author:     jeffspr   12 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\tray includes
#include "ctrayui.h"    // extern for the global tray object

HRESULT CConnectionTray::QueryStatus(
    const GUID *    pguidCmdGroup,
    ULONG           cCmds,
    OLECMD          prgCmds[],
    OLECMDTEXT *    pCmdText)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = E_NOTIMPL;

    TraceHr(ttidError, FAL, hr, (hr == E_NOTIMPL), "CConnectionTray::QueryStatus");
    return hr;
}

HRESULT CConnectionTray::Exec(
    const GUID *    pguidCmdGroup,
    DWORD           nCmdID,
    DWORD           nCmdexecopt,
    VARIANTARG *    pvaIn,
    VARIANTARG *    pvaOut)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = S_OK;

    // Set the DisableTray flag in netcfg.ini to prevent the network connections
    // tray code from executing.
    //
    if (!FIsDebugFlagSet (dfidDisableTray))
    {
        if (IsEqualGUID(*pguidCmdGroup, CGID_ShellServiceObject))
        {
            // Handle Shell Service Object notifications here.
            switch (nCmdID)
            {
                case SSOCMDID_OPEN:
                    TraceTag(ttidShellFolder, "The Net Connections Tray is being initialized");
                    hr = HrHandleTrayOpen();
                    break;

                case SSOCMDID_CLOSE:
                    TraceTag(ttidShellFolder, "The Net Connections Tray is being destroyed");
                    hr = HrHandleTrayClose();
                    break;

                default:
                    hr = S_OK;
                    break;
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionTray::Exec");
    return hr;
}

DWORD WINAPI TrayInitThreadProc(LPVOID lpParam)
{
    HRESULT hr          = S_OK;
    BOOL    fCoInited   = FALSE;

    hr = CoInitializeEx (NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hr))
    {
        // We don't care if this is S_FALSE or not, since we'll soon
        // overwrite the hr. If it's already initialized, great...

        fCoInited = TRUE;

        // Create the TrayUI object and save it in a global.
        //
        Assert(!g_pCTrayUI);

        if (!g_pCTrayUI)
        {
            g_pCTrayUI = new CTrayUI();
            if (!g_pCTrayUI)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Initialize the tray UI object
        //
        if (g_pCTrayUI)
        {
            hr = g_pCTrayUI->HrInitTrayUI();
        }
    }

    MSG msg;
    while (GetMessage (&msg, 0, 0, 0))
    {
        DispatchMessage (&msg);
    }

    if (fCoInited)
    {
        CoUninitialize();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionTray::HrHandleTrayOpen
//
//  Purpose:    Handler for the Net Connections Tray object ::Exec call
//              SSOCMDID_OPEN command
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   7 Jan 1998
//
//  Notes:
//
HRESULT CConnectionTray::HrHandleTrayOpen()
{
    HRESULT hr  = S_OK;

    // Turn off separate thread for Whistler. The proper way to do this is to register at runtime
    // a ShellServiceObject when UI is needed and de-register when not needed, using 
#if 0
    TraceTag(ttidShellFolder, "Starting tray thread proc");
    QueueUserWorkItem(TrayInitThreadProc, NULL, WT_EXECUTELONGFUNCTION);
#else
    if (SUCCEEDED(hr))
    {
        // We don't care if this is S_FALSE or not, since we'll soon
        // overwrite the hr. If it's already initialized, great...

        // Create the TrayUI object and save it in a global.
        //
        Assert(!g_pCTrayUI);

        if (!g_pCTrayUI)
        {
            g_pCTrayUI = new CTrayUI();
            if (!g_pCTrayUI)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Initialize the tray UI object
        //
        if (g_pCTrayUI)
        {
            hr = g_pCTrayUI->HrInitTrayUI();
        }

        // Add the Notify Sink
        if (SUCCEEDED(hr))
        {
            g_ccl.EnsureConPointNotifyAdded(); 
        }
    }
#endif

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionTray::HrHandleTrayOpen()");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionTray::HrHandleTrayClose
//
//  Purpose:    Handler for the Net Connections Tray object ::Exec call
//              SSOCMDID_CLOSE command
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   7 Jan 1998
//
//  Notes:
//
HRESULT CConnectionTray::HrHandleTrayClose()
{
    HRESULT hr  = S_OK;

    g_ccl.EnsureConPointNotifyRemoved();

    if (g_pCTrayUI)
    {
        // Destroy the tray UI object
        //
        hr = g_pCTrayUI->HrDestroyTrayUI();

        // Check the outcome, and trace it if it failed, but ignore a failure,
        // and continue to destroy the object
        //
        TraceHr(ttidError, FAL, hr, FALSE,
            "Failed in call to g_pCTrayUI->HrDestroyTrayUI");

        // Delete the tray object
        //
        delete g_pCTrayUI;
        g_pCTrayUI = NULL;

        TraceTag(ttidShellFolder, "Deleted the connections tray object");
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionTray::HrHandleTrayClose()");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\foldres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       F O L D R E S . H
//
//  Contents:   Folder resources
//
//  Notes:
//
//  Author:     jeffspr   29 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once

// Foldres owns from 0-1, and 10000 - 15999

// Connections folder icon
//
#define IDI_CONNECTIONS_FOLDER_LARGE    0
#define IDI_CONNECTIONS_FOLDER_LARGE2   5

// NT4 .RNK file icon
//
#define IDI_RNK_FILE                    1   // NT4 .RNK file

// PBK file icon
//
#define IDI_PBK_FILE                    2   // .BPK file

// The item icon for the wizard
//
#define IDI_CONFOLD_WIZARD              3
#define IDI_CONFOLD_HOMENET_WIZARD      4

// Toolbar bitmap
#define IDB_TB_SMALL                    10100

// Dialog
#define IDD_STATUS                      10500
#define IDC_TXT_STATUS                  10501

// Message Strings
#define IDS_STATUS_BRIDGE_CREATION      10600
#define IDS_STATUS_BRIDGE_DELETING      10601
#define IDS_STATUS_BRIDGE_REMOVE_MEMBER 10602
#define IDS_CONFOLD_BRIDGE_NOLOCK       10603
#define IDS_BRIDGE_EDUCATION            10604
#define IDS_CONFOLD_BRIDGE_UNEXPECTED   10605

//---[ Menus, etc ]------------------------------------------------------------

// $$NOTE - Don't change the ordering of these menus, at least not the
// relation of CONNECTED, DISCONNECTED, and UNAVAILABLE. The code uses
// this ordering to decide which of the three menus to bring up based
// on the state of the connection
//
#define MENU_WIZARD                     11000
#define MENU_WIZARD_V                   11001

#define MENU_LAN_DISCON                 11010
#define MENU_LAN_DISCON_V               11011
#define MENU_LAN_CON                    11012
#define MENU_LAN_CON_V                  11013
#define MENU_LAN_UNAVAIL                11014
#define MENU_LAN_UNAVAIL_V              11015

#define MENU_DIAL_DISCON                11020
#define MENU_DIAL_DISCON_V              11021
#define MENU_DIAL_CON                   11022
#define MENU_DIAL_CON_V                 11023
#define MENU_DIAL_UNAVAIL               11024
#define MENU_DIAL_UNAVAIL_V             11025
#define MENU_DIAL_CON_UNSET             11026
#define MENU_DIAL_DISCON_UNSET          11027
#define MENU_DIAL_UNAVAIL_UNSET         11028

#define MENU_INCOM_DISCON               11030
#define MENU_INCOM_DISCON_V             11031
#define MENU_INCOM_CON                  11032
#define MENU_INCOM_CON_V                11033
#define MENU_INCOM_UNAVAIL              11034
#define MENU_INCOM_UNAVAIL_V            11035

#define MENU_INET_DISCON                11040
#define MENU_INET_DISCON_V              11041
#define MENU_INET_CON                   11042
#define MENU_INET_CON_V                 11043
#define MENU_INET_UNAVAIL               11044
#define MENU_INET_UNAVAIL_V             11045

#define MENU_SALAN_CON                  11050
#define MENU_SALAN_DISCON               11051
#define MENU_SARAS_CON                  11052
#define MENU_SARAS_DISCON               11053

#define MENU_MERGE_INBOUND_DISCON       11100
#define MENU_MERGE_INBOUND_CON          11101
#define MENU_MERGE_INBOUND_UNAVAIL      11102
#define MENU_MERGE_OUTBOUND_DISCON      11103
#define MENU_MERGE_OUTBOUND_CON         11104
#define MENU_MERGE_OUTBOUND_UNAVAIL     11105
#define MENU_MERGE_FOLDER_BACKGROUND    11110
#define POPUP_MERGE_FOLDER_CONNECTIONS  11112

#define MENU_DIAL98_UNAVAIL_V           11113


//---[ Commands (context/menus) ]----------------------------------------------

#define CMIDM_FIRST                         0x0000
#define CMIDM_NEW_CONNECTION                (CMIDM_FIRST + 0x0001)
#define CMIDM_CONNECT                       (CMIDM_FIRST + 0x0002)
#define CMIDM_DISCONNECT                    (CMIDM_FIRST + 0x0003)
#define CMIDM_STATUS                        (CMIDM_FIRST + 0x0004)
#define CMIDM_CREATE_SHORTCUT               (CMIDM_FIRST + 0x0005)
#define CMIDM_DELETE                        (CMIDM_FIRST + 0x0006)
#define CMIDM_RENAME                        (CMIDM_FIRST + 0x0007)
#define CMIDM_PROPERTIES                    (CMIDM_FIRST + 0x0008)
#define CMIDM_CREATE_COPY                   (CMIDM_FIRST + 0x0009)
#define CMIDM_ENABLE                        (CMIDM_FIRST + 0x0010)
#define CMIDM_DISABLE                       (CMIDM_FIRST + 0x0011)
#define CMIDM_CREATE_BRIDGE                 (CMIDM_FIRST + 0x0012)
#define CMIDM_ADD_TO_BRIDGE                 (CMIDM_FIRST + 0x0013)
#define CMIDM_REMOVE_FROM_BRIDGE            (CMIDM_FIRST + 0x0014)
#define CMIDM_SET_DEFAULT                   (CMIDM_FIRST + 0x0015)
#define CMIDM_UNSET_DEFAULT                 (CMIDM_FIRST + 0x0016)
#define CMIDM_FIX                           (CMIDM_FIRST + 0x0017)
#define CMIDM_WZCDLG_SHOW                   (CMIDM_FIRST + 0x0018)
#define CMIDM_WZCPROPERTIES                 (CMIDM_FIRST + 0x0019)

// We use different command IDs for the Connections Menu because they're
// mostly duplicates of what's found in the File menu, and having
// dupes prevents correct enable/disable by ID.
//
#define CMIDM_CONNECTIONS                   (CMIDM_FIRST + 0x0020)
#define CMIDM_CONMENU_DIALUP_PREFS          (CMIDM_FIRST + 0x0021)
#define CMIDM_CONMENU_ADVANCED_CONFIG       (CMIDM_FIRST + 0x0022)
#define CMIDM_CONMENU_NETWORK_ID            (CMIDM_FIRST + 0x0023)
#define CMIDM_CONMENU_OPERATOR_ASSIST       (CMIDM_FIRST + 0x0024)
#define CMIDM_CONMENU_OPTIONALCOMPONENTS    (CMIDM_FIRST + 0x0025)

#define CMIDM_ARRANGE                       (CMIDM_FIRST + 0x0026)
#define CMIDM_ARRANGE_BY_NAME               (CMIDM_FIRST + 0x0027)
#define CMIDM_ARRANGE_BY_TYPE               (CMIDM_FIRST + 0x0028)
#define CMIDM_ARRANGE_BY_STATUS             (CMIDM_FIRST + 0x0029)
#define CMIDM_ARRANGE_BY_OWNER              (CMIDM_FIRST + 0x0030)
#define CMIDM_ARRANGE_BY_PHONEORHOSTADDRESS (CMIDM_FIRST + 0x0031)
#define CMIDM_ARRANGE_BY_DEVICE_NAME        (CMIDM_FIRST + 0x0032)

#define CMIDM_CONMENU_CREATE_BRIDGE         (CMIDM_FIRST + 0x0033)
#define CMIDM_HOMENET_WIZARD                (CMIDM_FIRST + 0x0034)
#define CMIDM_NET_DIAGNOSTICS               (CMIDM_FIRST + 0x0035)
#define CMIDM_NET_TROUBLESHOOT              (CMIDM_FIRST + 0x0036)

// Debug only commands
//
#if DBG
#define CMIDM_DEBUG                         (CMIDM_FIRST + 0x0040)
#define CMIDM_DEBUG_TRAY                    (CMIDM_FIRST + 0x0041)
#define CMIDM_DEBUG_TRACING                 (CMIDM_FIRST + 0x0042)
#define CMIDM_DEBUG_NOTIFYADD               (CMIDM_FIRST + 0x0044)
#define CMIDM_DEBUG_NOTIFYREMOVE            (CMIDM_FIRST + 0x0045)
#define CMIDM_DEBUG_NOTIFYTEST              (CMIDM_FIRST + 0x0046)
#define CMIDM_DEBUG_REFRESH                 (CMIDM_FIRST + 0x0047)
#define CMIDM_DEBUG_REFRESHNOFLUSH          (CMIDM_FIRST + 0x0048)
#define CMIDM_DEBUG_REFRESHSELECTED         (CMIDM_FIRST + 0x0049)
#define CMIDM_DEBUG_REMOVETRAYICONS         (CMIDM_FIRST + 0x004A)
#endif

// Menu options
//
#define IDM_OPEN                            11200

//---[ Strings for command ID's (shows in status line) ]-----------------------
//
#define IDS_CMIDM_START                         12000

#define IDS_CMIDM_NEW_CONNECTION                (IDS_CMIDM_START + CMIDM_NEW_CONNECTION)
#define IDS_CMIDM_CONNECT                       (IDS_CMIDM_START + CMIDM_CONNECT)
#define IDS_CMIDM_ENABLE                        (IDS_CMIDM_START + CMIDM_ENABLE)
#define IDS_CMIDM_DISCONNECT                    (IDS_CMIDM_START + CMIDM_DISCONNECT)
#define IDS_CMIDM_DISABLE                       (IDS_CMIDM_START + CMIDM_DISABLE)
#define IDS_CMIDM_STATUS                        (IDS_CMIDM_START + CMIDM_STATUS)
#define IDS_CMIDM_CREATE_SHORTCUT               (IDS_CMIDM_START + CMIDM_CREATE_SHORTCUT)
#define IDS_CMIDM_DELETE                        (IDS_CMIDM_START + CMIDM_DELETE)
#define IDS_CMIDM_RENAME                        (IDS_CMIDM_START + CMIDM_RENAME)
#define IDS_CMIDM_PROPERTIES                    (IDS_CMIDM_START + CMIDM_PROPERTIES)
#define IDS_CMIDM_CREATE_COPY                   (IDS_CMIDM_START + CMIDM_CREATE_COPY)
#define IDS_CMIDM_CREATE_BRIDGE                 (IDS_CMIDM_START + CMIDM_CREATE_BRIDGE)
#define IDS_CMIDM_ADD_TO_BRIDGE                 (IDS_CMIDM_START + CMIDM_ADD_TO_BRIDGE)
#define IDS_CMIDM_REMOVE_FROM_BRIDGE            (IDS_CMIDM_START + CMIDM_REMOVE_FROM_BRIDGE)
#define IDS_CMIDM_SET_DEFAULT                   (IDS_CMIDM_START + CMIDM_SET_DEFAULT)
#define IDS_CMIDM_UNSET_DEFAULT                 (IDS_CMIDM_START + CMIDM_UNSET_DEFAULT)
#define IDS_CMIDM_FIX                           (IDS_CMIDM_START + CMIDM_FIX)
#define IDS_CMIDM_HOMENET_WIZARD                (IDS_CMIDM_START + CMIDM_HOMENET_WIZARD)
#define IDS_CMIDM_WZCDLG_SHOW                   (IDS_CMIDM_START + CMIDM_WZCDLG_SHOW)
#define IDS_CMIDM_NET_TROUBLESHOOT              (IDS_CMIDM_START + CMIDM_NET_TROUBLESHOOT)

#define IDS_CMIDM_CONNECTIONS                   (IDS_CMIDM_START + CMIDM_CONNECTIONS)
#define IDS_CMIDM_CONMENU_DIALUP_PREFS          (IDS_CMIDM_START + CMIDM_CONMENU_DIALUP_PREFS)
#define IDS_CMIDM_CONMENU_ADVANCED_CONFIG       (IDS_CMIDM_START + CMIDM_CONMENU_ADVANCED_CONFIG)
#define IDS_CMIDM_CONMENU_CREATE_BRIDGE         (IDS_CMIDM_START + CMIDM_CONMENU_CREATE_BRIDGE)
#define IDS_CMIDM_CONMENU_NETWORK_ID            (IDS_CMIDM_START + CMIDM_CONMENU_NETWORK_ID)
#define IDS_CMIDM_CONMENU_OPERATOR_ASSIST       (IDS_CMIDM_START + CMIDM_CONMENU_OPERATOR_ASSIST)
#define IDS_CMIDM_CONMENU_OPTIONALCOMPONENTS    (IDS_CMIDM_START + CMIDM_CONMENU_OPTIONALCOMPONENTS)

#define IDS_CMIDM_ARRANGE                       (IDS_CMIDM_START + CMIDM_ARRANGE)
#define IDS_CMIDM_ARRANGE_BY_NAME               (IDS_CMIDM_START + CMIDM_ARRANGE_BY_NAME)
#define IDS_CMIDM_ARRANGE_BY_TYPE               (IDS_CMIDM_START + CMIDM_ARRANGE_BY_TYPE)
#define IDS_CMIDM_ARRANGE_BY_STATUS             (IDS_CMIDM_START + CMIDM_ARRANGE_BY_STATUS)
#define IDS_CMIDM_ARRANGE_BY_OWNER              (IDS_CMIDM_START + CMIDM_ARRANGE_BY_OWNER)
#define IDS_CMIDM_ARRANGE_BY_PHONEORHOSTADDRESS (IDS_CMIDM_START + CMIDM_ARRANGE_BY_PHONEORHOSTADDRESS)
#define IDS_CMIDM_ARRANGE_BY_DEVICE_NAME        (IDS_CMIDM_START + CMIDM_ARRANGE_BY_DEVICE_NAME)

// Debug only commands
//
#if DBG
#define IDS_CMIDM_DEBUG                         (IDS_CMIDM_START + CMIDM_DEBUG)
#define IDS_CMIDM_DEBUG_TRAY                    (IDS_CMIDM_START + CMIDM_DEBUG_TRAY)
#define IDS_CMIDM_DEBUG_TRACING                 (IDS_CMIDM_START + CMIDM_DEBUG_TRACING)
#define IDS_CMIDM_DEBUG_NOTIFYADD               (IDS_CMIDM_START + CMIDM_DEBUG_NOTIFYADD)
#define IDS_CMIDM_DEBUG_NOTIFYREMOVE            (IDS_CMIDM_START + CMIDM_DEBUG_NOTIFYREMOVE)
#define IDS_CMIDM_DEBUG_NOTIFYTEST              (IDS_CMIDM_START + CMIDM_DEBUG_NOTIFYTEST)
#define IDS_CMIDM_DEBUG_REFRESH                 (IDS_CMIDM_START + CMIDM_DEBUG_REFRESH)
#define IDS_CMIDM_DEBUG_REFRESHNOFLUSH          (IDS_CMIDM_START + CMIDM_DEBUG_REFRESHNOFLUSH)
#define IDS_CMIDM_DEBUG_REFRESHSELECTED         (IDS_CMIDM_START + CMIDM_DEBUG_REFRESHSELECTED)
#define IDS_CMIDM_DEBUG_REMOVETRAYICONS         (IDS_CMIDM_START + CMIDM_DEBUG_REMOVETRAYICONS)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\foldreg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       F O L D R E G . C P P
//
//  Contents:   Register the folder class
//
//  Notes:
//
//  Author:     jeffspr   30 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes

extern const WCHAR c_szNetShellDll[];

//---[ Constants ]------------------------------------------------------------

static const WCHAR* c_szShellFoldDefaultIconVal     =   c_szNetShellDll;
static const WCHAR  c_szShellFolderAttributeVal[]   =   L"Attributes";
static const WCHAR  c_szShellFolderLocalizedString[] =   L"LocalizedString";
static const WCHAR  c_szShellFolderInfoTip[]         =   L"InfoTip";

static const WCHAR  c_szShellFolderClsID[]  =
        L"CLSID\\{7007ACC7-3202-11D1-AAD2-00805FC1270E}";

static const WCHAR  c_szShellFolder98ClsID[]  =
        L"CLSID\\{992CFFA0-F557-101A-88EC-00DD010CCC48}";

static const WCHAR  c_szShellFoldDefaultIcon[]  =
        L"CLSID\\{7007ACC7-3202-11D1-AAD2-00805FC1270E}\\DefaultIcon";

static const WCHAR  c_szShellFoldDefaultIcon98[]  =
        L"CLSID\\{992CFFA0-F557-101A-88EC-00DD010CCC48}\\DefaultIcon";

static const WCHAR  c_szShellFolderKey[]        =
        L"CLSID\\{7007ACC7-3202-11D1-AAD2-00805FC1270E}\\ShellFolder";

static const WCHAR  c_szShellFolderKey98[]        =
        L"CLSID\\{992CFFA0-F557-101A-88EC-00DD010CCC48}\\ShellFolder"; 

static const WCHAR  c_szDotDun[]                = L".dun";
static const WCHAR  c_szDunFile[]               = L"dunfile";
static const WCHAR  c_szDunFileFriendlyName[]   = L"Dialup Networking File";
static const WCHAR  c_szDefaultIcon[]           = L"DefaultIcon";
static const WCHAR  c_szDunIconPath[]           = L"%SystemRoot%\\system32\\netshell.dll,1";
static const WCHAR  c_szShellOpenCommand[]      = L"shell\\open\\command";

static const WCHAR  c_szNetShellEntry[]     = 
        L"%SystemRoot%\\system32\\RUNDLL32.EXE NETSHELL.DLL,InvokeDunFile %1";

static const WCHAR c_szApplicationsNetShell[] =
        L"Applications\\netshell.dll";
static const WCHAR c_szNoOpenWith[]         = L"NoOpenWith";

//+---------------------------------------------------------------------------
//
//  Function:   HrRegisterFolderClass
//
//  Purpose:    Fix the registry values for the Shell entries under HKCR,
//              CLSID\{CLSID}. The code generated from the RGS script doesn't
//              support our replaceable params by default, so we'll fix
//              it up after the fact.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   23 Sep 1997
//
//  Notes:
//
HRESULT HrRegisterFolderClass()
{
    HRESULT hr      = S_OK;
    LONG    lResult = 0;

    WCHAR szRegValue[MAX_PATH+1];
    WCHAR szWinDir[MAX_PATH+1];

    // Adjust the AppID for Local Server or Service
    CRegKey keyShellDefaultIcon;
    CRegKey keyShellFolder;

    if (GetSystemWindowsDirectory(szWinDir, MAX_PATH+1))
    {
        lResult = keyShellDefaultIcon.Open(HKEY_CLASSES_ROOT, c_szShellFoldDefaultIcon);
        if (lResult == ERROR_SUCCESS)
        {
            wsprintfW(szRegValue, L"%s\\system32\\%s", szWinDir, c_szShellFoldDefaultIconVal);
            keyShellDefaultIcon.SetValue(szRegValue);
            keyShellDefaultIcon.Close();

            lResult = keyShellFolder.Open(HKEY_CLASSES_ROOT, c_szShellFolderKey);
            if (lResult == ERROR_SUCCESS)
            {
                DWORD dwFlags   = SFGAO_FOLDER;

                hr = HrRegSetValueEx(keyShellFolder,
                        c_szShellFolderAttributeVal,
                        REG_BINARY,
                        (LPBYTE) &dwFlags,
                        sizeof (dwFlags));

                keyShellFolder.Close();
            }

            // Write the MUI versions of LocalizedString & InfoTip out to the registry
            lResult = keyShellFolder.Open(HKEY_CLASSES_ROOT, c_szShellFolderClsID);
            if (lResult == ERROR_SUCCESS)
            {
                TCHAR szLocalizedString[MAX_PATH];
                TCHAR szInfoTip[MAX_PATH];

                wsprintf(szLocalizedString, _T("@%s\\system32\\%s,-%d"), szWinDir, c_szNetShellDll, IDS_CONFOLD_NAME);
                wsprintf(szInfoTip, _T("@%s\\system32\\%s,-%d"), szWinDir, c_szNetShellDll, IDS_CONFOLD_INFOTIP);
                hr = HrRegSetValueEx(keyShellFolder,
                    c_szShellFolderLocalizedString,
                    REG_SZ,
                    (LPBYTE) &szLocalizedString,
                    (lstrlen(szLocalizedString) + 1) * sizeof(TCHAR));

                hr = HrRegSetValueEx(keyShellFolder,
                    c_szShellFolderInfoTip,
                    REG_SZ,
                    (LPBYTE) &szInfoTip,
                    (lstrlen(szInfoTip) + 1) * sizeof(TCHAR));
                
                keyShellFolder.Close();
            }

            lResult = keyShellFolder.Open(HKEY_CLASSES_ROOT, c_szShellFolder98ClsID);
            if (lResult == ERROR_SUCCESS)
            {
                TCHAR szLocalizedString[MAX_PATH];
                TCHAR szInfoTip[MAX_PATH];

                wsprintf(szLocalizedString, _T("@%s\\system32\\%s,-%d"), szWinDir, c_szNetShellDll, IDS_CONFOLD_NAME);
                wsprintf(szInfoTip, _T("@%s\\system32\\%s,-%d"), szWinDir, c_szNetShellDll, IDS_CONFOLD_INFOTIP);
                hr = HrRegSetValueEx(keyShellFolder,
                    c_szShellFolderLocalizedString,
                    REG_SZ,
                    (LPBYTE) &szLocalizedString,
                    (lstrlen(szLocalizedString) + 1) * sizeof(TCHAR));

                hr = HrRegSetValueEx(keyShellFolder,
                    c_szShellFolderInfoTip,
                    REG_SZ,
                    (LPBYTE) &szInfoTip,
                    (lstrlen(szInfoTip) + 1) * sizeof(TCHAR));
                
                keyShellFolder.Close();
            }
            
            // added for #413840
            CRegKey keyShellDefaultIcon98;
            CRegKey keyShellFolder98;

            lResult = keyShellDefaultIcon98.Open(HKEY_CLASSES_ROOT, c_szShellFoldDefaultIcon98);
            if (lResult == ERROR_SUCCESS)
            {
                wsprintfW(szRegValue, L"%s\\system32\\%s", szWinDir, c_szShellFoldDefaultIconVal);
                keyShellDefaultIcon98.SetValue(szRegValue);
                keyShellDefaultIcon98.Close();
            }

            lResult = keyShellFolder98.Open(HKEY_CLASSES_ROOT, c_szShellFolderKey98);
            if (lResult == ERROR_SUCCESS)
            {
                DWORD dwFlags   = SFGAO_FOLDER;

                hr = HrRegSetValueEx(keyShellFolder98,
                        c_szShellFolderAttributeVal,
                        REG_BINARY,
                        (LPBYTE) &dwFlags,
                        sizeof (dwFlags));

                keyShellFolder98.Close();
            }
        }
        else
        {
            // Translate LRESULT to HR
            //
            hr = HRESULT_FROM_WIN32(lResult);
        }
    }
    else    // GetWindowsDirectory failed
    {
        hr = HrFromLastWin32Error();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegisterDUNFileAssociation
//
//  Purpose:    Add or upgrade the registry associate for .DUN fles
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     tongl 2 Feb, 1999
//
//  Notes:
//

HRESULT HrRegisterDUNFileAssociation()
{
    HRESULT hr = S_OK;
    
    HKEY    hkeyRootDun     = NULL;
    HKEY    hkeyRootDunFile = NULL;
    HKEY    hkeyCommand     = NULL;
    HKEY    hkeyIcon        = NULL;
    DWORD   dwDisposition;
    WCHAR   szFriendlyTypeName[MAX_PATH+1];


    // Create or open HKEY_CLASSES_ROOT\.dun
    hr = HrRegCreateKeyEx(HKEY_CLASSES_ROOT, 
                          c_szDotDun,
                          REG_OPTION_NON_VOLATILE, 
                          KEY_WRITE, 
                          NULL,
                          &hkeyRootDun, 
                          &dwDisposition);
    if (SUCCEEDED(hr))
    {
        if (REG_CREATED_NEW_KEY == dwDisposition)
        {
            hr = HrRegSetSz(hkeyRootDun, 
                            c_szEmpty, 
                            c_szDunFile);

            TraceError("Error creating file association for .dun files", hr);
        }

        RegSafeCloseKey(hkeyRootDun);

        if (SUCCEEDED(hr))
        {
            // create or open HKEY_CLASSES_ROOT\dunfile
            hr = HrRegCreateKeyEx(HKEY_CLASSES_ROOT, 
                                  c_szDunFile,
                                  REG_OPTION_NON_VOLATILE, 
                                  KEY_WRITE, 
                                  NULL,
                                  &hkeyRootDunFile, 
                                  &dwDisposition);
            if (SUCCEEDED(hr))
            {
                // Set friendly type name
                hr = HrRegSetValueEx(hkeyRootDunFile,
                                     c_szEmpty,
                                     REG_SZ,
                                     (LPBYTE) c_szDunFileFriendlyName,
                                     CbOfSzAndTermSafe(c_szDunFileFriendlyName));

                // trace the error 
                TraceError("Error creating friendly name for .DUN files", hr);

                // Now, write MUI compliant friendly type name.
                                     
                wsprintf(szFriendlyTypeName,
                         L"@%%SystemRoot%%\\system32\\%s,-%d",
                         c_szNetShellDll,
                         IDS_DUN_FRIENDLY_NAME);

                hr = HrRegSetValueEx(hkeyRootDunFile,
                                     L"FriendlyTypeName",
                                     REG_EXPAND_SZ,
                                     (LPBYTE)szFriendlyTypeName,
                                     CbOfSzAndTermSafe(szFriendlyTypeName));

                // trace the error 
                TraceError("Error creating MUI friendly name for .DUN files", hr);

                hr = S_OK;


                // Set DefaultIcon
                // HKEY_CLASSES_ROOT\dunfile\DefaultIcon = "%SystemRoot%\System32\netshell.dll,1"
                hr = HrRegCreateKeyEx(hkeyRootDunFile, 
                                      c_szDefaultIcon,
                                      REG_OPTION_NON_VOLATILE, 
                                      KEY_WRITE, 
                                      NULL,
                                      &hkeyIcon, 
                                      &dwDisposition);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegSetValueEx (hkeyIcon,
                                          c_szEmpty,
                                          REG_EXPAND_SZ,
                                          (LPBYTE) c_szDunIconPath,
                                          CbOfSzAndTermSafe(c_szDunIconPath));

                    RegSafeCloseKey(hkeyIcon);
                }

                // trace the error 
                TraceError("Error creating DefaultIcon for .DUN files", hr);
                hr = S_OK;
                
                // Set or update Command to invoke 
                // HKEY_CLASSES_ROOT\dunfile\shell\open\command = 
                // "%%SystemRoot%%\system32\RUNDLL32.EXE NETSHELL.DLL,RunDunImport %1"
                hr = HrRegCreateKeyEx(hkeyRootDunFile, 
                                      c_szShellOpenCommand,
                                      REG_OPTION_NON_VOLATILE, 
                                      KEY_WRITE, 
                                      NULL,
                                      &hkeyCommand, 
                                      &dwDisposition);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegSetValueEx(hkeyCommand,
                                         c_szEmpty,
                                         REG_EXPAND_SZ,
                                         (LPBYTE) c_szNetShellEntry,
                                         CbOfSzAndTermSafe(c_szNetShellEntry));
                    if(SUCCEEDED(hr))
                    {
                        HKEY hkeyNetShell = NULL;
                        HRESULT hr2 = HrRegCreateKeyEx(HKEY_CLASSES_ROOT, 
                                                       c_szApplicationsNetShell,
                                                       REG_OPTION_NON_VOLATILE, 
                                                       KEY_WRITE, 
                                                       NULL,
                                                       &hkeyNetShell, 
                                                       &dwDisposition);

                        if(SUCCEEDED(hr2) && (REG_CREATED_NEW_KEY == dwDisposition))
                        {
                            hr2 = HrRegSetValueEx(hkeyNetShell,
                                                  c_szNoOpenWith,
                                                  REG_SZ,
                                                  (LPBYTE) c_szEmpty,
                                                  CbOfSzAndTermSafe(c_szEmpty));
                        }

                        // trace the error 
                        TraceError("Error creating NoOpenWith value for .DUN files", hr2);
                        RegSafeCloseKey(hkeyNetShell);
                    }
    
                    // trace the error 
                    TraceError("Error creating ShellCommand for .DUN files", hr);
                    hr = S_OK;

                    RegSafeCloseKey(hkeyCommand);
                }

                RegSafeCloseKey(hkeyRootDunFile);
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\iconhandler.cpp ===
#include "pch.h"
#pragma hdrstop

#include "nsbase.h"
#include <nsres.h>
#include "ncmisc.h"
#include "foldres.h"
#include "foldinc.h"    // Standard shell\folder includes
#include "connlist.h"
#include "iconhandler.h"

template <class E> class ENUM_IDI_MAP
{
public:
    E   EnumEntry;
    int iIcon;
};

template <class E> int MapIconEnumToResourceID(const ENUM_IDI_MAP<E> IconEnumArray[], DWORD dwElems, const E EnumMatch)
{
    if (0 == EnumMatch)
    {
        return 0;
    }
    
    for (DWORD x = 0; x < dwElems; x++)
    {
        if (EnumMatch == IconEnumArray[x].EnumEntry)
        {
            return IconEnumArray[x].iIcon;
        }  
    }
    
    AssertSz(FALSE, "Could not map match to Icon enum array");
    return 0;
};

static const ENUM_IDI_MAP<ENUM_STAT_ICON> c_STATUS_ICONS[] = 
{
    ICO_STAT_FAULT,         IDI_CFI_STAT_FAULT,
    ICO_STAT_INVALID_IP,    IDI_CFI_STAT_QUESTION,
    ICO_STAT_EAPOL_FAILED,  IDI_CFI_STAT_QUESTION
};

static const ENUM_IDI_MAP<ENUM_CHARACTERISTICS_ICON> c_CHARACTERISTICS_ICON[] = 
{
    ICO_CHAR_INCOMING,      IDI_OVL_INCOMING,
    ICO_CHAR_DEFAULT,       IDI_OVL_DEFAULT,
    ICO_CHAR_FIREWALLED,    IDI_OVL_FIREWALLED,
    ICO_CHAR_SHARED,        IDI_OVL_SHARED,
};

static const ENUM_IDI_MAP<ENUM_CONNECTION_ICON> c_CONNECTION_ICONS[] = 
{
    ICO_CONN_BOTHOFF,       IDI_CFI_CONN_ALLOFF,
    ICO_CONN_RIGHTON,       IDI_CFI_CONN_RIGHTON,
    ICO_CONN_LEFTON,        IDI_CFI_CONN_LEFTON,
    ICO_CONN_BOTHON,        IDI_CFI_CONN_BOTHON,
};

struct NC_MEDIATYPE_ICON
{
    DWORD               ncm;  // NETCON_MEDIATYPE (Shifted left by SHIFT_NETCON_MEDIATYPE)
    DWORD               ncsm; // NETCON_SUBMEDIATYPE (Shifted left by SHIFT_NETCON_SUBMEDIATYPE)
    DWORD               dwMasksSupported;
    INT                 iIcon;
    INT                 iIconDisabled; // Only for dwMasksSupported == MASK_NO_CONNECTIONOVERLAY
};

static const NC_MEDIATYPE_ICON c_NCM_ICONS[] = 
{
//    NETCON_MEDIATYPE (Shifted left by SHIFT_NETCON_MEDIATYPE)
//      |                                              NETCON_SUBMEDIATYPE (Shifted left by SHIFT_NETCON_SUBMEDIATYPE (0) )
//      |                                                       |            dwMasksSupported
//      |                                                       |                  |                       iIcon                 
//      |                                                       |                  |                          |                    Disabled Icon 
//      |                                                       |                  |                          |                        | (for MASK_NO_CONNECTIONOVERLAY)
//      v                                                       v                  v                          v                        v 
    NCM_NONE                 << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,    MASK_NO_CONNECTIONOVERLAY,    IDI_CFI_RASSERVER,        IDI_CFI_RASSERVER,
    NCM_BRIDGE               << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,    MASK_STATUSOVERLAY,           IDI_CFI_BRIDGE_CONNECTED, IDI_CFI_BRIDGE_DISCONNECTED,
    NCM_SHAREDACCESSHOST_LAN << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,    MASK_NO_CONNECTIONOVERLAY,    IDI_CFI_SAH_LAN,          IDI_CFI_SAH_LAN,   
    NCM_SHAREDACCESSHOST_RAS << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,    MASK_NO_CONNECTIONOVERLAY,    IDI_CFI_SAH_RAS,          IDI_CFI_SAH_RAS,   
    NCM_DIRECT               << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,    MASK_SUPPORT_ALL,             IDI_CFI_DIRECT,           0,
    NCM_DIRECT               << SHIFT_NETCON_MEDIATYPE, NCSM_DIRECT,  MASK_SUPPORT_ALL,             IDI_CFI_DIRECT,           0,
    NCM_DIRECT               << SHIFT_NETCON_MEDIATYPE, NCSM_IRDA,    MASK_SUPPORT_ALL,             IDI_CFI_DIRECT,           0,
    NCM_ISDN                 << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,    MASK_SUPPORT_ALL,             IDI_CFI_ISDN,             0,
    NCM_LAN                  << SHIFT_NETCON_MEDIATYPE, NCSM_1394,    MASK_SUPPORT_ALL,             IDI_CFI_LAN,              0,
    NCM_LAN                  << SHIFT_NETCON_MEDIATYPE, NCSM_ATM,     MASK_SUPPORT_ALL,             IDI_CFI_LAN,              0,
    NCM_LAN                  << SHIFT_NETCON_MEDIATYPE, NCSM_ELAN,    MASK_SUPPORT_ALL,             IDI_CFI_LAN,              0,
    NCM_LAN                  << SHIFT_NETCON_MEDIATYPE, NCSM_LAN,     MASK_SUPPORT_ALL,             IDI_CFI_LAN,              0,
    NCM_LAN                  << SHIFT_NETCON_MEDIATYPE, NCSM_WIRELESS,MASK_SUPPORT_ALL,             IDI_CFI_WIRELESS,         0,
    NCM_PPPOE                << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,    MASK_SUPPORT_ALL,             IDI_CFI_PPPOE,            0,
    NCM_PHONE                << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,    MASK_SUPPORT_ALL,             IDI_CFI_PHONE,            0,
    NCM_PHONE                << SHIFT_NETCON_MEDIATYPE, NCSM_CM,      MASK_SUPPORT_ALL,             IDI_CFI_CM,               0,
    NCM_TUNNEL               << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,    MASK_SUPPORT_ALL,             IDI_CFI_VPN,              0,
    NCM_TUNNEL               << SHIFT_NETCON_MEDIATYPE, NCSM_CM,      MASK_SUPPORT_ALL,             IDI_CFI_CM,               0,
};

struct NC_STATUS_ICON
{
    NETCON_STATUS        ncs;
    DWORD                dwStatIcon;
    ENUM_CONNECTION_ICON enumConnectionIcon;
};

static const NC_STATUS_ICON c_NCS_ICONS[] = 
{
//   NETCON_STATUS
//        |                         dwStatIcon
//        |                           |                                  enumConnectionIcon
//        |                           |                                      |
//        v                           v                                      v
    NCS_AUTHENTICATING,           ICO_STAT_NONE,                           ICO_CONN_BOTHON,
    NCS_AUTHENTICATION_SUCCEEDED, ICO_STAT_NONE,                           ICO_CONN_BOTHON,
    NCS_AUTHENTICATION_FAILED,    ICO_STAT_EAPOL_FAILED,                   ICO_CONN_BOTHON,
    NCS_CREDENTIALS_REQUIRED,     ICO_STAT_EAPOL_FAILED,                   ICO_CONN_BOTHON,
    NCS_CONNECTED,                ICO_STAT_NONE,                           ICO_CONN_BOTHON,
    NCS_DISCONNECTING,            ICO_STAT_NONE,                           ICO_CONN_BOTHON,
    NCS_CONNECTING,               ICO_STAT_DISABLED | ICO_STAT_NONE,       ICO_CONN_BOTHOFF,
    NCS_DISCONNECTED,             ICO_STAT_DISABLED | ICO_STAT_NONE,       ICO_CONN_BOTHOFF,
    NCS_INVALID_ADDRESS,          ICO_STAT_INVALID_IP,                     ICO_CONN_BOTHON,
    NCS_HARDWARE_DISABLED,        ICO_STAT_FAULT,                          ICO_CONN_BOTHON,
    NCS_HARDWARE_MALFUNCTION,     ICO_STAT_FAULT,                          ICO_CONN_BOTHON,
    NCS_HARDWARE_NOT_PRESENT,     ICO_STAT_FAULT,                          ICO_CONN_BOTHON,
    NCS_MEDIA_DISCONNECTED,       ICO_STAT_FAULT,                          ICO_CONN_BOTHON,
};

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::CNetConfigIcons
//
//  Purpose:    CNetConfigIcons constructor
//
//  Arguments:
//      none
//
//  Returns:
//      none
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:  
//
CNetConfigIcons::CNetConfigIcons(IN HINSTANCE hInstance) : m_hInstance(hInstance)
{
    TraceFileFunc(ttidIcons);

    dwLastBrandedId = 0;
    InitializeCriticalSection(&csNetConfigIcons);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::~CNetConfigIcons
//
//  Purpose:    CNetConfigIcons destructor
//
//  Arguments:
//      none
//
//  Returns:
//      none
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:  
//
CNetConfigIcons::~CNetConfigIcons()
{
    // Can't trace in this function!

    IMAGELISTMAP::iterator iter;
    
    for (iter = m_ImageLists.begin(); iter != m_ImageLists.end(); iter++)
    {
        HIMAGELIST hImageLst = iter->second;
        ImageList_Destroy(hImageLst);
    }

    m_ImageLists.clear();
    DeleteCriticalSection(&csNetConfigIcons);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrMergeTwoIcons
//
//  Purpose:    Merge a new icon unto an existing one
//
//  Arguments:
//      dwIconSize     [in]     Size of the icon
//      phMergedIcon   [in out] Icon 1 to merge, and contains the merged
//                              icon on output
//      hIconToMerge   [in]     Icon 2 to merge with
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    4 Apr 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrMergeTwoIcons(IN DWORD dwIconSize, IN OUT HICON *phMergedIcon, IN HICON hIconToMergeWith)
{
    HRESULT hr = S_FALSE;
    Assert(phMergedIcon);

    HIMAGELIST hImageLst = NULL;

    IMAGELISTMAP::iterator i = m_ImageLists.find(dwIconSize);
    if (i == m_ImageLists.end())
    {
        hImageLst = ImageList_Create(dwIconSize, dwIconSize, ILC_COLOR32 | ILC_MASK, 2, 0);
        if (hImageLst)
        {
            m_ImageLists[dwIconSize] = hImageLst;
        }
        else
        {
            hr = E_FAIL;
        }             
    }
    else
    {
        hImageLst = i->second;
    }

    if (SUCCEEDED(hr))
    {
        if (*phMergedIcon)
        {
            if (hIconToMergeWith)
            {
                hr = E_FAIL;

                // Merge the 2 icons;
                if (ImageList_RemoveAll(hImageLst))
                {
                    int iIcon1 = ImageList_AddIcon(hImageLst, *phMergedIcon);
                    if (-1 != iIcon1)
                    {
                        int iIcon2 = ImageList_AddIcon(hImageLst, hIconToMergeWith);
                        if (-1 != iIcon2)
                        {
                            if (ImageList_SetOverlayImage(hImageLst, iIcon2, 1))
                            {
                                DestroyIcon(*phMergedIcon); // Delete the current icon

                                *phMergedIcon = ImageList_GetIcon(hImageLst, iIcon1, INDEXTOOVERLAYMASK(1));
                                hr = S_OK;
                            }
                        }
                    }
                }
            }
            // else Nothing. Stays the same.
        }
        else
        {
            // Copy icon 2 to icon 1
            *phMergedIcon = CopyIcon(hIconToMergeWith);
        }
    }

    return hr;
};

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetInternalIconIDForPIDL
//
//  Purpose:    Map the connection state and connection type to the
//              appropriate icon resource IDs.
//
//  Arguments:
//      uFlags     [in]    The GIL_xxx shell flags
//      cfe        [in]    The connection folder entry
//      dwIcon     [out]   The ID of the icon
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrGetInternalIconIDForPIDL(IN UINT uFlags, IN const CConFoldEntry& cfe, OUT DWORD& dwIcon)
{
    TraceFileFunc(ttidIcons);

    if (cfe.GetCharacteristics() & NCCF_BRANDED)
    {
        AssertSz(FALSE, "Call HrGetBrandedIconIDForPIDL instead for branded icons");
        return E_INVALIDARG;
    }

    Assert(!cfe.empty());

    BOOL fValidIcon = FALSE;
    if (cfe.GetWizard() == WIZARD_MNC)
    {
        dwIcon = ICO_MGR_RESOURCEID | IDI_CONFOLD_WIZARD;
        fValidIcon = TRUE;
    }
    else if (cfe.GetWizard() == WIZARD_HNW)
    {
        dwIcon = ICO_MGR_RESOURCEID | IDI_CONFOLD_HOMENET_WIZARD;
        fValidIcon = TRUE;
    }
    else
    {
        dwIcon = ICO_MGR_INTERNAL;

        Assert(cfe.GetWizard() == WIZARD_NOT_WIZARD);

        const NETCON_SUBMEDIATYPE ncsm = cfe.GetNetConSubMediaType();
        const NETCON_MEDIATYPE    ncm  = cfe.GetNetConMediaType();
        const NETCON_STATUS       ncs  = cfe.GetNetConStatus();
        
        // Find the Status part of the icon
        for (DWORD dwLoop = 0; (dwLoop < celems(c_NCM_ICONS)); dwLoop++)
        {
            const NC_STATUS_ICON& ncsIcon = c_NCS_ICONS[dwLoop];

            if (ncs == ncsIcon.ncs)
            {
                Assert((ncsIcon.dwStatIcon         & (MASK_STATUS | MASK_STATUS_DISABLED) ) == ncsIcon.dwStatIcon);
                Assert((ncsIcon.enumConnectionIcon & (MASK_CONNECTION) ) == ncsIcon.enumConnectionIcon);

                dwIcon |= ncsIcon.dwStatIcon;
                dwIcon |= ncsIcon.enumConnectionIcon;
                dwIcon |= ncm  << SHIFT_NETCON_MEDIATYPE;
                dwIcon |= ncsm << SHIFT_NETCON_SUBMEDIATYPE;
                fValidIcon = TRUE;
                
                break;
            }
        }
    }

    AssertSz(fValidIcon, "Could not obtain an icon for this connection");

    if (fValidIcon)
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrMergeCharacteristicsIcons
//
//  Purpose:    Merge the characteristics icons unto an input icon
//
//  Arguments:
//      dwIconSize     [in]     Size of the icon
//      dwIconId       [in]     Icon ID (to read Characteristics info from)
//      phMergedIcon   [in out] The icon to merge with, and contains the merged
//                              icon on output
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    4 Apr 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrMergeCharacteristicsIcons(IN DWORD dwIconSize, IN DWORD dwIconId, IN OUT HICON *phMergedIcon)
{
    HRESULT hr = S_OK;

    Assert(phMergedIcon);

    if (!(dwIconId & MASK_CHARACTERISTICS))
    {
        return S_FALSE;
    }

    // Characteristics
    int iFireWalled   = MapIconEnumToResourceID(c_CHARACTERISTICS_ICON, celems(c_CHARACTERISTICS_ICON), static_cast<ENUM_CHARACTERISTICS_ICON>(dwIconId & ICO_CHAR_FIREWALLED));
    int iIncoming     = MapIconEnumToResourceID(c_CHARACTERISTICS_ICON, celems(c_CHARACTERISTICS_ICON), static_cast<ENUM_CHARACTERISTICS_ICON>(dwIconId & ICO_CHAR_INCOMING));
    int iShared       = MapIconEnumToResourceID(c_CHARACTERISTICS_ICON, celems(c_CHARACTERISTICS_ICON), static_cast<ENUM_CHARACTERISTICS_ICON>(dwIconId & ICO_CHAR_SHARED));
    int iDefault      = MapIconEnumToResourceID(c_CHARACTERISTICS_ICON, celems(c_CHARACTERISTICS_ICON), static_cast<ENUM_CHARACTERISTICS_ICON>(dwIconId & ICO_CHAR_DEFAULT));

    HICON hFireWalled = iFireWalled ? LoadIconSize(m_hInstance, MAKEINTRESOURCE(iFireWalled), dwIconSize) : NULL;
    HICON hShared     = iShared     ? LoadIconSize(m_hInstance, MAKEINTRESOURCE(iShared),     dwIconSize) : NULL;
    HICON hDefault    = iDefault    ? LoadIconSize(m_hInstance, MAKEINTRESOURCE(iDefault),    dwIconSize) : NULL;
    HICON hIncoming   = NULL;
    
    if (dwIconSize != GetSystemMetrics(SM_CXSMICON)) // Shouldn't display in 16x16
    {
        hIncoming = iIncoming ? LoadIconSize(m_hInstance, MAKEINTRESOURCE(iIncoming), dwIconSize) : NULL;
        AssertSz(FImplies(iIncoming, hIncoming),     "Could not load the Incoming Icon");
    }

    AssertSz(FImplies(iFireWalled, hFireWalled), "Could not load the FireWalled Icon");
    AssertSz(FImplies(iShared, hShared),         "Could not load the Shared Icon");
    AssertSz(FImplies(iDefault, hDefault),       "Could not load the Default Icon");

    HICON hIconArray[] = {hFireWalled, hIncoming, hShared, hDefault};

    for (int x = 0; x < celems(hIconArray); x++)
    {
        hr = HrMergeTwoIcons(dwIconSize, phMergedIcon, hIconArray[x]);
        if (FAILED(hr))
        {
            break;
        }
    }

    for (int x = 0; x < celems(hIconArray); x++)
    {
        if (hIconArray[x])
        {
            DestroyIcon(hIconArray[x]);
            hIconArray[x] = NULL;
        }
    }

    AssertSz(SUCCEEDED(hr) && *phMergedIcon, "Could not load a characteristics icon");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetInternalIconFromIconId
//
//  Purpose:    Loads the netshell internal icon given the icon ID 
//               (from HrGetInternalIconIDForPIDL)
//
//  Arguments:
//      dwIconSize [in] Size of the icon required
//      dwIconId   [in] Icon ID - from HrGetInternalIconIDForPIDL
//      hIcon      [in] The icon that was loaded
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrGetInternalIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon)
{
    TraceFileFunc(ttidIcons);

    DWORD dwlrFlags = 0;

    if ( (dwIconId & MASK_ICONMANAGER) != ICO_MGR_INTERNAL)
    {
        AssertSz(FALSE, "This is not an internal icon");
        return E_INVALIDARG;
    }

    HRESULT hr = E_FAIL;

    DWORD ncm  = (dwIconId & MASK_NETCON_MEDIATYPE);
    DWORD ncsm = (dwIconId & MASK_NETCON_SUBMEDIATYPE);

    BOOL fDisabledStatus = (dwIconId & ICO_STAT_DISABLED);

    // Status & Connection
    int iStatus       = MapIconEnumToResourceID(c_STATUS_ICONS,     celems(c_STATUS_ICONS),     static_cast<ENUM_STAT_ICON>(dwIconId & MASK_STATUS));
    int iConnection   = MapIconEnumToResourceID(c_CONNECTION_ICONS, celems(c_CONNECTION_ICONS), static_cast<ENUM_CONNECTION_ICON>(dwIconId & MASK_CONNECTION));

    int iMediaType          = 0;

    // Media Type
    for (int x = 0; x < celems(c_NCM_ICONS); x++)
    {
        const NC_MEDIATYPE_ICON& ncmIcon = c_NCM_ICONS[x];

        // Use NCSM if available, otherwise use NCM
        if ( ((NCSM_NONE == ncsm) && (NCSM_NONE == ncmIcon.ncsm) && (ncm == ncmIcon.ncm)) ||
             ((NCSM_NONE != ncsm) && (ncsm == ncmIcon.ncsm)) )
        {
            if (!(ncmIcon.dwMasksSupported & MASK_CONNECTION))
            {
                iConnection    = 0;
            }

            if (!(ncmIcon.dwMasksSupported & MASK_STATUS))
            {
                iStatus        = 0;
            }
            
            iMediaType = ncmIcon.iIcon;

            if (!(iConnection || iStatus) && 
                 (fDisabledStatus))
            {
                Assert(ncmIcon.iIconDisabled);
                iMediaType = ncmIcon.iIconDisabled;
            }
        }
    }

    Assert(iMediaType);
    if (iMediaType)
    {
        HICON hMediaType  = iMediaType  ? LoadIconSize(m_hInstance, MAKEINTRESOURCE(iMediaType), dwIconSize)  : NULL;
        HICON hStatus     = iStatus     ? LoadIconSize(m_hInstance, MAKEINTRESOURCE(iStatus),    dwIconSize)  : NULL;
        HICON hConnection = NULL;

        if (dwIconSize != GetSystemMetrics(SM_CXSMICON)) // Shouldn't display in 16x16
        {
            hConnection = iConnection ? LoadIconSize(m_hInstance, MAKEINTRESOURCE(iConnection),  dwIconSize)  : NULL;
            AssertSz(FImplies(iConnection, hConnection), "Could not load the Connection Icon");
        }

        AssertSz(FImplies(iMediaType, hMediaType),   "Could not load the Media Type Icon");
        AssertSz(FImplies(iStatus, hStatus),         "Could not load the Status Icon");

        HICON hIconArray[] = {hMediaType, hStatus, hConnection};
        hIcon = NULL;

        for (int x = 0; x < celems(hIconArray); x++)
        {
            hr = HrMergeTwoIcons(dwIconSize, &hIcon, hIconArray[x]);
            if (FAILED(hr))
            {
                break;
            }
        }

        for (int x = 0; x < celems(hIconArray); x++)
        {
            if (hIconArray[x])
            {
                DestroyIcon(hIconArray[x]);
                hIconArray[x] = NULL;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = HrMergeCharacteristicsIcons(dwIconSize, dwIconId, &hIcon);
            if (SUCCEEDED(hr))
            {
                hr = S_OK;
            }

        }
    }

    AssertSz(SUCCEEDED(hr) && hIcon, "Could not load any icon");

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetResourceIconFromIconId
//
//  Purpose:    Loads a resource icon given the icon ID 
//               (from HrGetInternalIconIDForPIDL)
//
//  Arguments:
//      dwIconSize [in] Size of the icon required
//      dwIconId   [in] Icon ID - from HrGetInternalIconIDForPIDL
//      hIcon      [in] The icon that was loaded
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrGetResourceIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon)
{
    TraceFileFunc(ttidIcons);

    DWORD dwlrFlags = 0;

    if ( (dwIconId & MASK_ICONMANAGER) != ICO_MGR_RESOURCEID)
    {
        AssertSz(FALSE, "This is not a resource id icon manager icon");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    int iIcon = dwIconId & MASK_BRANDORRESOURCEID; // Clear the rest of the bits;

    hIcon = LoadIconSize(m_hInstance, MAKEINTRESOURCE(iIcon), dwIconSize);
    if (!hIcon)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        hr = HrMergeCharacteristicsIcons(dwIconSize, dwIconId, &hIcon);
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "Could not load icon %d (size %d x %d) from resource file", iIcon, dwIconSize, dwIconSize);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetBrandedIconIDForPIDL
//
//  Purpose:    Initializes the branded icon info from a file
//
//  Arguments:
//      uFlags     [in]    The GIL_xxx shell flags
//      cfe        [in]    The connection folder entry
//      dwIcon     [out]   The ID of the icon
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    18 Feb 2001
//
//  Notes: We store this internally into a map - hence we can't cache
//         branded icons since we might not end up with the same id in the map
//
HRESULT CNetConfigIcons::HrGetBrandedIconIDForPIDL(IN UINT uFlags, IN const CConFoldEntry& cfe, OUT DWORD& dwIcon)
{
    TraceFileFunc(ttidIcons);

    HRESULT hr = S_OK;

    if (!(cfe.GetCharacteristics() & NCCF_BRANDED))
    {
        AssertSz(FALSE, "Call HrGetInternalIconIDForPIDL instead for non-branded icons");
        return E_INVALIDARG;
    }

    Assert(!cfe.empty());

    if (cfe.GetWizard() != WIZARD_NOT_WIZARD)
    {
        AssertSz(FALSE, "You're not allowed to brand the wizard");
        hr = E_INVALIDARG;
    }
    else
    {
        dwIcon = ICO_MGR_CM;

        if (g_ccl.IsInitialized() == FALSE)
        {
            g_ccl.HrRefreshConManEntries();
        }
        
        ConnListEntry  cle;
        hr = g_ccl.HrFindConnectionByGuid(&(cfe.GetGuidID()), cle);
        if (S_OK == hr)
        {
            tstring szBrandedFileName;
            BOOL bBrandedName = FALSE;
            
            if (cle.pcbi)
            {
                if (cle.pcbi->szwLargeIconPath)
                {
                    szBrandedFileName = cle.pcbi->szwLargeIconPath;
                    bBrandedName = TRUE;
                }
                else if (cle.pcbi->szwSmallIconPath)
                {
                    szBrandedFileName = cle.pcbi->szwSmallIconPath;
                    bBrandedName = TRUE;
                }
            }

            if (bBrandedName)
            {
                BrandedNames::const_iterator i = m_BrandedNames.find(szBrandedFileName);
                if (i == m_BrandedNames.end()) // Doesn't exist yet
                {
                    dwLastBrandedId++;
                    m_BrandedNames[szBrandedFileName] = dwLastBrandedId;
                    dwIcon |= dwLastBrandedId;
                }
                else
                {
                    dwIcon |= i->second;
                }
            }
            else
            {
                CConFoldEntry cfeTmp;
                cfeTmp = cfe;
                cfeTmp.SetCharacteristics(cfe.GetCharacteristics() & ~NCCF_BRANDED);
                cfeTmp.SetNetConSubMediaType(NCSM_CM);
                dwIcon = 0;
                hr = HrGetInternalIconIDForPIDL(uFlags, cfeTmp, dwIcon);
            }
        }
        else
        {
            hr = E_FILE_NOT_FOUND;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "Could not obtain an icon for this connection");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetBrandedIconFromIconId
//
//  Purpose:    Loads the branded icon given the icon ID 
//               (from HrGetBrandedIconIDForPIDL)
//
//  Arguments:
//      dwIconSize [in] Size of the icon required
//      dwIconId   [in] Icon ID - from HrGetBrandedIconIDForPIDL
//      hIcon      [in] The icon that was loaded
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrGetBrandedIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon)
{
    TraceFileFunc(ttidIcons);

    if ( (dwIconId & MASK_ICONMANAGER) != ICO_MGR_CM)
    {
        AssertSz(FALSE, "This is not a branded icon");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    
    DWORD dwIconIdTmp;
    dwIconIdTmp = dwIconId & MASK_BRANDORRESOURCEID;

    Assert(dwIconIdTmp);

    if (dwIconIdTmp)
    {
        BOOL bFound = FALSE;
        tstring szBrandedFileName;
        for (BrandedNames::iterator i = m_BrandedNames.begin(); i != m_BrandedNames.end(); i++)
        {
            if (i->second == dwIconIdTmp)
            {
#ifdef DBG
                if (bFound)
                {
                    AssertSz(FALSE, "Multiple icon IDs in branded table found");
                }
#endif
                bFound = TRUE;
                szBrandedFileName = i->first;
                break;
            }
        }

        if (!bFound)
        {
            AssertSz(FALSE, "Branded icon id not found in branded table");
            return E_FAIL;
        }

        hIcon = static_cast<HICON>(LoadImage(
            NULL,
            szBrandedFileName.c_str(),
            IMAGE_ICON,
            dwIconSize, dwIconSize,
            LR_LOADFROMFILE));
    }

    if (!hIcon)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        hr = HrMergeCharacteristicsIcons(dwIconSize, dwIconId, &hIcon);
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
        }

    }
    
    TraceHr(ttidError, FAL, hr, FALSE, "CNetConfigIcons::HrGetBrandedIconFromIconId");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetIconIDForPIDL
//
//  Purpose:    Get a unique icon number given a Connection Folder Entry
//
//  Arguments:
//      uFlags     [in]    The GIL_xxx shell flags
//      cfe        [in]   The connection folder entry
//      dwIcon     [out]  The ID of the icon
//      pfCanCache [out]  Whether we can cache the icon
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrGetIconIDForPIDL(IN UINT uFlags, IN const CConFoldEntry& cfe, OUT DWORD& dwIconId, OUT LPBOOL pfCanCache)
{
    TraceFileFunc(ttidIcons);

    CExceptionSafeLock EsLock(&csNetConfigIcons);

    HRESULT hr = S_OK;
    if (cfe.GetCharacteristics() & NCCF_BRANDED)
    {
        *pfCanCache = FALSE;
        hr = HrGetBrandedIconIDForPIDL(uFlags, cfe, dwIconId);
    }
    else
    {
#ifdef DBG
        if (FIsDebugFlagSet(dfidDontCacheShellIcons))
        {
            *pfCanCache = FALSE;
        }
        else
        {
            *pfCanCache = TRUE;
        }
#else
        *pfCanCache = TRUE;
#endif
        hr = HrGetInternalIconIDForPIDL(uFlags, cfe, dwIconId);
    }

    if (FAILED(hr))
    {
        return hr;
    }

    Assert( (dwIconId & ~MASK_CHARACTERISTICS) == dwIconId); // Make sure we did't overflow into the overlay

    if (!(GIL_FORSHORTCUT & uFlags))
    {
        DWORD dwOverlay = 0;
        if ( (cfe.GetCharacteristics() & NCCF_INCOMING_ONLY) &&
             (cfe.GetNetConMediaType() != NCM_NONE) ) // No overlay for "default" incoming connection
        {
            dwIconId |= ICO_CHAR_INCOMING;
        }

        if (cfe.GetCharacteristics() & NCCF_SHARED)
        {
            dwIconId |= ICO_CHAR_SHARED;
        }
    
        if (cfe.GetCharacteristics() & NCCF_FIREWALLED)
        {
            dwIconId |= ICO_CHAR_FIREWALLED;
        }

        if (cfe.GetCharacteristics() & NCCF_DEFAULT)
        {
            dwIconId |= ICO_CHAR_DEFAULT;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetIconFromIconId
//
//  Purpose:    Loads an icon given the icon ID (branded or internal)
//
//  Arguments:
//      dwIconSize [in] Size of the icon required
//      dwIconId   [in] Icon ID - from HrGetIconIDForPIDL
//      hIcon      [in] The icon that was loaded
//
//  Returns:
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrGetIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon)
{ 
    TraceFileFunc(ttidIcons);

    CExceptionSafeLock EsLock(&csNetConfigIcons);

    HRESULT hr = S_OK;
    switch (dwIconId & MASK_ICONMANAGER)
    {
        case ICO_MGR_CM:
            hr = HrGetBrandedIconFromIconId(dwIconSize, dwIconId, hIcon);
            break;

        case ICO_MGR_INTERNAL:
            hr = HrGetInternalIconFromIconId(dwIconSize, dwIconId, hIcon);
            break;

        case ICO_MGR_RESOURCEID:
            hr = HrGetResourceIconFromIconId(dwIconSize, dwIconId, hIcon);
            break;

        default:
            hr = E_INVALIDARG;
            AssertSz(FALSE, "Unknown Icon manager");
            break;
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwOverlays = (dwIconId & MASK_CHARACTERISTICS); // get the mask bits
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetIconFromIconId
//
//  Purpose:    Loads an icon given the icon ID (branded or internal)
//
//  Arguments:
//      dwIconSize        [in] Size of the icon required
//      ncm               [in] The NETCON_MEDIATYPE
//      ncsm              [in] The NETCON_SUBMEDIATYPE
//      dwConnectionIcon  [in] ENUM_CONNECTION_ICON (Not shifted (IOW: 0 or 4,5,6,7)
//      dwCharacteristics [in] The NCCF_CHARACTERISTICS flag (0 allowed)
//      phIcon            [in] The resulting icon. Destroy using DestroyIcon
//
//  Returns:
//
//  Author:     deonb    23 Apr 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrGetIconFromMediaType(DWORD dwIconSize, IN NETCON_MEDIATYPE ncm, IN NETCON_SUBMEDIATYPE ncsm, IN DWORD dwConnectionIcon, IN DWORD dwCharacteristics, OUT HICON *phIcon)
{
    HRESULT hr = S_OK;

    CConFoldEntry cfe;

    // Is this a request for a special folder icon?
    if ( (0xFFFFFFFF == dwCharacteristics)  &&
         (NCM_NONE == ncm) &&
         (NCSM_NONE == ncsm)
        )
    {
        BOOL bFoundIcon = FALSE;
        int iIcon = 0;

        switch (dwConnectionIcon)
        {
            case 0x80000000:
                iIcon = IDI_CONNECTIONS_FOLDER_LARGE2;
                bFoundIcon = TRUE;
                break;

            case 0x80000001:
                iIcon = IDI_CONFOLD_WIZARD;
                bFoundIcon = TRUE;
                break;

            case 0x80000002:
                iIcon = IDI_CONFOLD_HOMENET_WIZARD;
                bFoundIcon = TRUE;
                break;
        }

        if (bFoundIcon)
        {
            *phIcon = LoadIconSize(_Module.GetResourceInstance(), MAKEINTRESOURCE(iIcon), dwIconSize);
            if (*phIcon)
            {
                return S_OK;
            }
            else
            {
                return HrFromLastWin32Error();
            }
        }
    }

    // No? Then load a media type icon
    NETCON_STATUS ncs;
    if (ICO_CONN_BOTHOFF == dwConnectionIcon)
    {
        ncs = NCS_DISCONNECTED;
    }
    else
    {
        ncs = NCS_CONNECTED;
    }

    // Most of these values (except for ncm, ncsm, ncs) are totally fake. 
    // However, we need to initialize this structure with 
    // something or it will assert on us.
    //
    // HrGetIconIDForPidl will only use ncm, ncsm, ncs & dwCharacteristics
    hr = cfe.HrInitData(WIZARD_NOT_WIZARD,
                        ncm,
                        ncsm,
                        ncs,
                        &(CLSID_ConnectionCommonUi), // FAKE
                        &(CLSID_ConnectionCommonUi), // FAKE
                        dwCharacteristics,
                        reinterpret_cast<LPBYTE>("PersistData"), // FAKE
                        celems("PersistData"),      // FAKE
                        L"Name",                    // FAKE
                        L"DeviceName",              // FAKE
                        L"PhoneOrHostAddress");     // FAKE
    if (SUCCEEDED(hr))
    {
        DWORD dwIconId;
        BOOL  fCanCache;
        hr = HrGetIconIDForPIDL(0, cfe, dwIconId, &fCanCache);
        if (SUCCEEDED(hr))
        {
            dwIconId &= ~MASK_CONNECTION; // Clear the current connection mask
            dwIconId |= (dwConnectionIcon << SHIFT_CONNECTION); // Set the new connection mask

            hr = HrGetIconFromIconId(dwIconSize, dwIconId, *phIcon);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrUpdateSystemImageListForPIDL
//
//  Purpose:    Notifies the shell that we've changed an icon
//
//  Arguments:
//      cfe [in] The connection folder entry that changed
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrUpdateSystemImageListForPIDL(IN const CConFoldEntry& cfe)
{
    TraceFileFunc(ttidIcons);

    HRESULT hr = S_OK;
    DWORD dwIcon;
    BOOL  fCacheThisIcon;
    hr = g_pNetConfigIcons->HrGetIconIDForPIDL(0, cfe, dwIcon, &fCacheThisIcon);
    if (SUCCEEDED(hr))
    {
        ULONG  uFlags = GIL_PERINSTANCE | GIL_NOTFILENAME;
        if (!fCacheThisIcon)
        {
             uFlags |= GIL_DONTCACHE;
        }
        int    iIcon = static_cast<int>(dwIcon);
        int    iCachedImage = Shell_GetCachedImageIndex(c_szNetShellIcon, iIcon, uFlags);

        TraceTag(ttidIcons, "%S->SHUpdateImage [0x%08x] (iCachedImage=%d)", cfe.GetName(), dwIcon, iCachedImage);
        if (-1 != iCachedImage)
        {
            SHUpdateImage(c_szNetShellIcon, iIcon, uFlags, iCachedImage);
        }

        DWORD dwIconForShortcut;
        hr = g_pNetConfigIcons->HrGetIconIDForPIDL(GIL_FORSHORTCUT, cfe, dwIconForShortcut, &fCacheThisIcon);
        {
            if (dwIconForShortcut != dwIcon)
            {
                iIcon = static_cast<int>(dwIconForShortcut);
                iCachedImage = Shell_GetCachedImageIndex(c_szNetShellIcon, iIcon, uFlags);

                TraceTag(ttidIcons, "%S->SHUpdateImage GIL_FORSHORTCUT [0x%08x] (iCachedImage=%d)", cfe.GetName(), dwIcon, iCachedImage);
                if (-1 != iCachedImage)
                {
                    SHUpdateImage(c_szNetShellIcon, iIcon, uFlags, iCachedImage);
                }
            }
        }
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\iconhandler.h ===
// The icons ID passed to the shell contains the following format:
//
// B: Designates value is a bitmask
// M: Designates value is mutually exclusive
// 
// Icon Handler Flag (01 = NetConfig, 10 = Connection Manager, 11 = Static Icon from Resource)
//  |
//  | For Icon Handler == 00 (NetConfig)
//  | ==================================
//  |  Characteristics Overlay (B: Reserved)
//  |    |  Characteristics Overlay          (B: 000001000 - Shared)
//  |    |   | Characteristics Overlay       (B: 000000100 - Firewalled)
//  |    |   |  | Characteristics Overlay    (B: 000000010 - Default)
//  |    |   |  |  | Characteristics Overlay (B: 000000001 - Incoming)
//  |    |   |  |  |  |
//  |    |   |  |  |  |  Status Overlay (M: 0000 - None)
//  |    |   |  |  |  |  Status Overlay (M: 0001 - Hardware Not Present)
//  |    |   |  |  |  |  Status Overlay (M: 0010 - Invalid IP)
//  |    |   |  |  |  |  Status Overlay (M: 0011 - EAPOL Authentication Failed)
//  |    |   |  |  |  |  
//  |    |   |  |  |  |  Status Overlay (M: 1xxx - Disabled status)
//  |    |   |  |  |  |   |
//  |    |   |  |  |  |   |  Connection Icon (Flashy Computer) (M: 000 - No Overlay)
//  |    |   |  |  |  |   |  Connection Icon (Flashy Computer) (M: 100 - Both Lights Off)
//  |    |   |  |  |  |   |  Connection Icon (Flashy Computer) (M: 110 - Left Light On (Sent))
//  |    |   |  |  |  |   |  Connection Icon (Flashy Computer) (M: 101 - Right Light On (Received))
//  |    |   |  |  |  |   |  Connection Icon (Flashy Computer) (M: 111 - Both Lights On (Sent + Received))
//  |    |   |  |  |  |   |    |
//  |    |   |  |  |  |   |    |    Media Type (M: NETCON_MEDIATYPE (0x1111111 is Connection Manager)
//  |    |   |  |  |  |   |    |     |     Media Type (M: NETCON_SUBMEDIATYPE)
//  |    |   |  |  |  |   |    |     |      |
//  v    v   v  v  v  v   v    v     v      v
//  01 00000 0  0  0  0 0000  000 0000000 0000000
//  | 
//  |
//  | For Icon Handler == 01 (Connection Manager)
//  | ===========================================
//  |  Characteristics Overlay (B: Reserved)
//  |    |  Characteristics Overlay          (B: 000001000 - Shared)
//  |    |   | Characteristics Overlay       (B: 000000100 - Firewalled)
//  |    |   |  | Characteristics Overlay    (B: 000000010 - Default)
//  |    |   |  |  | Characteristics Overlay (B: 000000001 - Incoming)
//  |    |   |  |  |  |
//  |    |   |  |  |  |
//  |    |   |  |  |  |  Reserved
//  |    |   |  |  |  |   |
//  |    |   |  |  |  |   |    BrandedNames Lookup Table Entry
//  |    |   |  |  |  |   |         |
//  v    v   v  v  v  v   v         v (16 bits)
//  10 00000 0  0  0  0  00000  0000000000000000 
//  |
//  |
//  | For Icon Handler == 10 (10 = Static Icon from Resource)
//  | =======================================================
//  |  Characteristics Overlay (B: Reserved)
//  |    |  Characteristics Overlay          (B: 000001000 - Shared)
//  |    |   | Characteristics Overlay       (B: 000000100 - Firewalled)
//  |    |   |  | Characteristics Overlay    (B: 000000010 - Default)
//  |    |   |  |  | Characteristics Overlay (B: 000000001 - Incoming)
//  |    |   |  |  |  |
//  |    |   |  |  |  |
//  |    |   |  |  |  |  Reserved
//  |    |   |  |  |  |   |
//  |    |   |  |  |  |   |    Resource ID
//  |    |   |  |  |  |   |         |
//  v    v   v  v  v  v   v         v (16 bits)
//  11 00000 0  0  0  0  00000  0000000000000000 

enum ENUM_MEDIA_ICONMASK
{
    MASK_NETCON_SUBMEDIATYPE = 0x0000007f, // 00000000000000000000000001111111
    MASK_NETCON_MEDIATYPE    = 0x00003F80, // 00000000000000000011111110000000
    MASK_CONNECTION          = 0x0001C000, // 00000000000000011100000000000000
    MASK_STATUS              = 0x000E0000, // 00000000000011100000000000000000
    MASK_STATUS_DISABLED     = 0x00100000, // 00000000000100000000000000000000
    MASK_CHARACTERISTICS     = 0x3FE00000, // 00111111111000000000000000000000
    MASK_ICONMANAGER         = 0xC0000000, // 11000000000000000000000000000000
    
    
    MASK_BRANDORRESOURCEID   = 0x0000FFFF, // 00000000000000001111111111111111

    MASK_SUPPORT_ALL         = 0xFFFFFFFF,
    MASK_NO_CONNECTIONOVERLAY= MASK_NETCON_SUBMEDIATYPE | MASK_NETCON_MEDIATYPE | MASK_CHARACTERISTICS | MASK_ICONMANAGER,
    MASK_STATUSOVERLAY       = MASK_NETCON_SUBMEDIATYPE | MASK_NETCON_MEDIATYPE | MASK_CHARACTERISTICS | MASK_ICONMANAGER | MASK_STATUS | MASK_STATUS_DISABLED,
};

enum ENUM_MEDIA_ICONSHIFT
{
    SHIFT_NETCON_SUBMEDIATYPE = 0,
    SHIFT_NETCON_MEDIATYPE    = 7,
    SHIFT_CONNECTION          = 14,
    SHIFT_STATUS              = 17,
    SHIFT_CHARACTERISTICS     = 21,
    SHIFT_ICONMANAGER         = 30
};

enum ENUM_ICON_MANAGER
{
    ICO_MGR_INTERNAL      = 0x1 << SHIFT_ICONMANAGER,
    ICO_MGR_CM            = 0x2 << SHIFT_ICONMANAGER,
    ICO_MGR_RESOURCEID    = 0x3 << SHIFT_ICONMANAGER
};

enum ENUM_STAT_ICON
{
    ICO_STAT_NONE         = 0x0 << SHIFT_STATUS,
    ICO_STAT_FAULT        = 0x1 << SHIFT_STATUS,
    ICO_STAT_INVALID_IP   = 0x2 << SHIFT_STATUS,
    ICO_STAT_EAPOL_FAILED = 0x3 << SHIFT_STATUS,

    ICO_STAT_DISABLED     = 0x8 << SHIFT_STATUS // Flag
};

enum ENUM_CONNECTION_ICON
{
    ICO_CONN_NONE         = 0x0 << SHIFT_CONNECTION,
    ICO_CONN_BOTHOFF      = 0x4 << SHIFT_CONNECTION,
    ICO_CONN_RIGHTON      = 0x5 << SHIFT_CONNECTION,
    ICO_CONN_LEFTON       = 0x6 << SHIFT_CONNECTION,
    ICO_CONN_BOTHON       = 0x7 << SHIFT_CONNECTION,
};

enum ENUM_CHARACTERISTICS_ICON
{
    ICO_CHAR_INCOMING     = 0x1 << SHIFT_CHARACTERISTICS,
    ICO_CHAR_DEFAULT      = 0x2 << SHIFT_CHARACTERISTICS,
    ICO_CHAR_FIREWALLED   = 0x4 << SHIFT_CHARACTERISTICS,
    ICO_CHAR_SHARED       = 0x8 << SHIFT_CHARACTERISTICS
};

class CNetConfigIcons;

typedef map<tstring, DWORD> BrandedNames;
typedef map<DWORD, HIMAGELIST> IMAGELISTMAP;

// CNetConfigIcons
// The main icon manager for NetShell
class CNetConfigIcons
{
private:
    CRITICAL_SECTION csNetConfigIcons;
    
    BOOL m_bInitialized;

    IMAGELISTMAP m_ImageLists;
    HINSTANCE    m_hInstance;

    BrandedNames m_BrandedNames;
    DWORD        dwLastBrandedId;

    HRESULT HrMergeTwoIcons(IN DWORD dwIconSize, IN OUT HICON *phMergedIcon, IN HICON hIconToMergeWith);

    HRESULT HrMergeCharacteristicsIcons(IN DWORD dwIconSize, IN DWORD dwIconId, IN OUT HICON *phMergedIcon);

    HRESULT HrGetBrandedIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon);  // Use destroyicon after
    HRESULT HrGetInternalIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon); // Use destroyicon after
    HRESULT HrGetResourceIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon); // Use destroyicon after

    HRESULT HrGetInternalIconIDForPIDL(IN UINT uFlags, IN const CConFoldEntry& cfe, OUT DWORD &dwIconId); // Use destroyicon after
    HRESULT HrGetBrandedIconIDForPIDL(IN UINT uFlags, IN const CConFoldEntry& cfe, OUT DWORD &dwIconId);  // Use destroyicon after

public:
	CNetConfigIcons(IN HINSTANCE hInstance);
    virtual ~CNetConfigIcons();

    // All external calls are thread safe.
    HRESULT HrGetIconIDForPIDL(IN UINT uFlags, IN const CConFoldEntry& cfe, OUT DWORD &dwIconId, OUT LPBOOL pfCanCache);
    HRESULT HrGetIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon);  // Use destroyicon after

    HRESULT HrUpdateSystemImageListForPIDL(IN const CConFoldEntry& cfe);
    
    HRESULT HrGetIconFromMediaType(DWORD dwIconSize, IN NETCON_MEDIATYPE ncm, IN NETCON_SUBMEDIATYPE ncsm, IN DWORD dwConnectionIcon, IN DWORD dwCharacteristics, OUT HICON *phIcon);
};

extern CNetConfigIcons *g_pNetConfigIcons;
extern const WCHAR c_szNetShellIcon[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\icontextm.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I C O N T E X T M . C P P
//
//  Contents:   IContextMenu implementation for CConnectionFolderExtractIcon
//
//  Notes:
//
//  Author:     jeffspr   24 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include <nsres.h>
#include "foldres.h"
#include "oncommand.h"
#include "cmdtable.h"

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderContextMenu::CreateInstance
//
//  Purpose:    Create an instance of the CConnectionFolderContextMenu object
//
//  Arguments:
//      riid [in]   Interface requested
//      ppv  [out]  Pointer to receive the requested interface
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
HRESULT CConnectionFolderContextMenu::CreateInstance(
    REFIID          riid,
    void**          ppv,
    CMENU_TYPE      cmt,
    HWND            hwndOwner,
    const PCONFOLDPIDLVEC& apidl,
    LPSHELLFOLDER   psf)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr = E_OUTOFMEMORY;

    CConnectionFolderContextMenu * pObj    = NULL;

    pObj = new CComObject <CConnectionFolderContextMenu>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->HrInitialize(cmt, hwndOwner, apidl, psf);
            if (SUCCEEDED(hr))
            {
                hr = pObj->QueryInterface (riid, ppv);
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolderContextMenu::CreateInstance");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderContextMenu::CConnectionFolderContextMenu
//
//  Purpose:    Constructor for CConnectionFolderContextMenu. Initialize
//              data members
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
CConnectionFolderContextMenu::CConnectionFolderContextMenu()
{
    TraceFileFunc(ttidShellFolderIface);

    m_psf           = NULL;
    m_cidl          = 0;
    m_hwndOwner     = NULL;
    m_cmt           = CMT_OBJECT;   // arbitrary. Just make sure it's something
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderContextMenu::HrInitialize
//
//  Purpose:    Initialization for the context menu object. Make copies of
//              the pidl array, etc.
//
//  Arguments:
//      hwndOwner [in]  Our parent hwnd
//      apidl     [in]  Pidl array of selected items
//      psf       [in]  Our shell folder pointer
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
HRESULT CConnectionFolderContextMenu::HrInitialize(
    CMENU_TYPE      cmt,
    HWND            hwndOwner,
    const PCONFOLDPIDLVEC& apidl,
    LPSHELLFOLDER   psf)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = NOERROR;

    // Grab and addref the folder object
    //
    Assert(psf);
    psf->AddRef();
    m_psf = static_cast<CConnectionFolder *>(psf);

    // Copy the context menu type (object -vs- background)
    //
    m_cmt = cmt;

    // Note: This will be NULL if the context menu is invoked from the desktop
    //
    m_hwndOwner = hwndOwner;

    if (!apidl.empty())
    {
        Assert(CMT_OBJECT == cmt);

        // Clone the pidl array using the cache
        //
        hr = HrCloneRgIDL(apidl, TRUE, TRUE, m_apidl);
        if (FAILED(hr))
        {
            TraceHr(ttidError, FAL, hr, FALSE, "HrCloneRgIDL failed on apidl in "
                    "CConnectionFolderContextMenu::HrInitialize");
        }
    }
    else
    {
        Assert(CMT_BACKGROUND == cmt);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolderContextMenu::HrInitialize");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderContextMenu::~CConnectionFolderContextMenu
//
//  Purpose:    Destructor. Free the pidl array and release the shell folder
//              object
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
CConnectionFolderContextMenu::~CConnectionFolderContextMenu()
{
    TraceFileFunc(ttidShellFolderIface);

    if (m_psf)
    {
        ReleaseObj(reinterpret_cast<LPSHELLFOLDER>(m_psf));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderContextMenu::QueryContextMenu
//
//  Purpose:    Adds menu items to the specified menu. The menu items should
//              be inserted in the menu at the position specified by
//              indexMenu, and their menu item identifiers must be between
//              the idCmdFirst and idCmdLast parameter values.
//
//  Arguments:
//      hmenu      [in] Handle to the menu. The handler should specify this
//                      handle when adding menu items
//      indexMenu  [in] Zero-based position at which to insert the first
//                      menu item.
//      idCmdFirst [in] Min value the handler can specify for a menu item
//      idCmdLast  [in] Max value the handler can specify for a menu item
//      uFlags     [in] Optional flags specifying how the context menu
//                      can be changed. See MSDN for the full list.
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
HRESULT CConnectionFolderContextMenu::QueryContextMenu(
    HMENU   hmenu,
    UINT    indexMenu,
    UINT    idCmdFirst,
    UINT    idCmdLast,
    UINT    uFlags)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT         hr                  = S_OK;
    BOOL            fVerbsOnly          = !!(uFlags & CMF_VERBSONLY);


    if ( (m_apidl.size() != 0) && !(uFlags & CMF_DVFILE))
    {
        HMENU hMenuTmp = NULL;

        hMenuTmp = CreateMenu();
        if (hMenuTmp)
        {
            hr = HrBuildMenu(hMenuTmp, fVerbsOnly, m_apidl, 0);
            
            if (SUCCEEDED(hr))
            {
                UINT idMax = Shell_MergeMenus(
                    hmenu,
                    hMenuTmp,
                    0,
                    idCmdFirst,
                    idCmdLast,
                    MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);
                
                hr = ResultFromShort(idMax - idCmdFirst);
            }
            DestroyMenu(hMenuTmp);
        }
    }
    else
    {
        // mbend - we skip this because defview does file menu merging.
    }

    // Ignore this trace if it's a short, basically.
    //
    TraceHr(ttidError, FAL, hr, SUCCEEDED(hr), "CConnectionFolderContextMenu::QueryContextMenu");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderContextMenu::InvokeCommand
//
//  Purpose:    Carries out the command associated with a context menu item.
//
//  Arguments:
//      lpici [in]  Address of a CMINVOKECOMMANDINFO structure containing
//                  information about the command.
//
//  Returns:        Returns NOERROR if successful, or an OLE-defined
//                  error code otherwise.
//
//  Author:     jeffspr   27 Apr 1999
//
//  Notes:
//
HRESULT CConnectionFolderContextMenu::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT             hr      = NOERROR;
    UINT                uiCmd   = 0;

    Assert(lpici);
    Assert(lpici->lpVerb);

    if (HIWORD(lpici->lpVerb))
    {
        // Deal with string commands
        PSTR pszCmd = (PSTR)lpici->lpVerb;

        // Only folder objects currently support string-based invoke commands.
        // (The background does not)
        //
        if (CMT_OBJECT == m_cmt)
        {
            if (0 == lstrcmpA(pszCmd, "delete"))
            {
                uiCmd = CMIDM_DELETE;
            }
            else if (0 == lstrcmpA(pszCmd, "properties"))
            {
                uiCmd = CMIDM_PROPERTIES;
            }
            else if (0 == lstrcmpA(pszCmd, "wzcproperties"))
            {
                uiCmd = CMIDM_WZCPROPERTIES;
            }
            else if (0 == lstrcmpA(pszCmd, "rename"))
            {
                uiCmd = CMIDM_RENAME;
            }
            else if (0 == lstrcmpA(pszCmd, "link"))
            {
                uiCmd = CMIDM_CREATE_SHORTCUT;
            }
        }

        if (0 == uiCmd)
        {
            TraceTag(ttidError, "Unprocessed InvokeCommand<%s>\n", pszCmd);
            hr = E_INVALIDARG;
        }
    }
    else
    {
        uiCmd = (UINT)LOWORD((DWORD_PTR)lpici->lpVerb);
    }

    if (SUCCEEDED(hr))
    {
        // Handle the actual command
        //
        hr = HrFolderCommandHandler(uiCmd, m_apidl, m_hwndOwner, lpici, m_psf);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolderContextMenu::InvokeCommand");
    return hr;
}

HRESULT CConnectionFolderContextMenu::GetCommandString(
    UINT_PTR    idCmd,
    UINT        uType,
    UINT *      pwReserved,
    PSTR       pszName,
    UINT        cchMax)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = E_FAIL;   // Not handled

    *((PWSTR)pszName) = L'\0';

    if (uType == GCS_HELPTEXT)
    {
        int iLength = LoadString(   _Module.GetResourceInstance(),
                                    idCmd + IDS_CMIDM_START,
                                    (PWSTR) pszName,
                                    cchMax);
        if (iLength > 0)
        {
            hr = NOERROR;
        }
        else
        {
            AssertSz(FALSE, "Resource string not found for one of the connections folder commands");
        }
    }
    else
    {
        if (uType == GCS_VERB && idCmd == CMIDM_RENAME)
        {
            // "rename" is language independent
            lstrcpyW((PWSTR)pszName, L"rename");

            hr = NOERROR;
        }
    }

    TraceHr(ttidError, FAL, hr, (hr == E_FAIL), "CConnectionFolderContextMenu::GetCommandString");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\iolewind.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I O L E W I N D . C P P
//
//  Contents:   IOleWindow implementation for CConnectionFolder
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes




STDMETHODIMP CConnectionFolder::GetWindow(
        HWND *  lphwnd)
{
    TraceFileFunc(ttidShellFolderIface);

    return E_NOTIMPL;
}

STDMETHODIMP CConnectionFolder::ContextSensitiveHelp(
        BOOL    fEnterMode)
{
    TraceFileFunc(ttidShellFolderIface);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\ienumidl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I E N U M I D L . C P P
//
//  Contents:   IEnumIDList implementation for CConnectionFolderEnum
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "ncnetcon.h"
#include "webview.h"

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::CConnectionFolderEnum
//
//  Purpose:    Constructor for the enumerator
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
CConnectionFolderEnum::CConnectionFolderEnum()
{
    TraceFileFunc(ttidShellFolderIface);

    m_pidlFolder.Clear();
    m_dwFlags               = 0;
    m_fTray                 = FALSE;
    m_dwEnumerationType     = CFCOPT_ENUMALL;   // all connection types
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionFolderEnum
//
//  Purpose:    Destructor for the enumerator. Standard cleanup.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
CConnectionFolderEnum::~CConnectionFolderEnum()
{
    TraceFileFunc(ttidShellFolderIface);

    m_pidlFolder.Clear();
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionFolderEnum::PidlInitialize
//
//  Purpose:    Initialization for the enumerator object
//
//  Arguments:
//      fTray             [in]  Are we owned by the tray
//      pidlFolder        [in]  Pidl for the folder itself
//      dwEnumerationType [in]  Enumeration type (inbound/outbound/all)
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
VOID CConnectionFolderEnum::PidlInitialize(
    BOOL            fTray,
    const PCONFOLDPIDLFOLDER& pidlFolder,
    DWORD           dwEnumerationType)
{
    TraceFileFunc(ttidShellFolderIface);

    NETCFG_TRY

        m_fTray             = fTray;
        m_pidlFolder        = pidlFolder;
        m_dwEnumerationType = dwEnumerationType;
        
    NETCFG_CATCH_AND_RETHROW
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::CreateInstance
//
//  Purpose:    Create an instance of the CConnectionFolderEnum object, and
//              returns the requested interface
//
//  Arguments:
//      riid [in]   Interface requested
//      ppv  [out]  Pointer to receive the requested interface
//
//  Returns:    Standard OLE HRESULT
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
HRESULT CConnectionFolderEnum::CreateInstance(
    REFIID  riid,
    void**  ppv)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT                 hr      = E_OUTOFMEMORY;
    CConnectionFolderEnum * pObj    = NULL;

    pObj = new CComObject <CConnectionFolderEnum>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolderEnum::CreateInstance");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::Next
//
//  Purpose:    Retrieves the specified number of item identifiers in the
//              enumeration sequence and advances the current position
//              by the number of items retrieved.
//
//  Arguments:
//      celt         []     Max number requested
//      rgelt        []     Array to fill
//      pceltFetched []     Return count for # filled.
//
//  Returns:    S_OK if successful, S_FALSE if there are no more items
//              in the enumeration sequence, or an OLE-defined error value
//              otherwise.
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolderEnum::Next(
        ULONG           celt,
        LPITEMIDLIST *  rgelt,
        ULONG *         pceltFetched)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = S_OK;

    Assert(celt >= 1);
    Assert(rgelt);
    Assert(pceltFetched || (celt == 1));

    // If the caller asks for the fetch count, zero it out for now.
    //
    if (pceltFetched)
    {
        *pceltFetched   = 0;
    }

    // Init the output list pointer
    //
    *rgelt          = NULL;

    // If there's not currently a list, build one.
    //
    if (m_apidl.empty())
    {
        hr = Reset();

        // This will have returned either S_FALSE (no wizard? weird!), an
        // error (meaning creating the wizard failed), or S_OK, meaning
        // that (at least) the wizard creation succeeded. Enum of the connections
        // failing will get filtered by Reset().
    }

    if (SUCCEEDED(hr))
    {
        // If there are NOW items in the list
        //
        if (!m_apidl.empty() )
        {
            BOOL    fMatchFound = FALSE;

            // Check that we've set the current pointer to at least the root
            //
            // Normalize the return code
            hr = S_OK;

            while ((S_OK == hr) && !fMatchFound)
            {
                // If there are no remaining entries, return S_FALSE.
                //
                if ( m_iterPidlCurrent == m_apidl.end() )
                {
                    hr = S_FALSE;
                }
                else
                {
                    const PCONFOLDPIDL& pcfp = *m_iterPidlCurrent;

                    // Else, Return the first entry, then increment the current
                    // pointer
                    //
                    Assert(!pcfp.empty());

                    // Check to see if we want to return this type, based on
                    // the enumeration type & connection type. The wizard
                    // should always be included.
                    //
                    if ( WIZARD_NOT_WIZARD != pcfp->wizWizard )
                    {
                        if (HrIsWebViewEnabled() == S_OK)
                        {
                            m_iterPidlCurrent++; // skip over this item
                            continue;
                        }
                        else
                        {
                            fMatchFound = TRUE;
                        }
                    }
                    else
                    {
                        switch(m_dwEnumerationType)
                        {
                            case CFCOPT_ENUMALL:
                                fMatchFound = TRUE;
                                break;
                            case CFCOPT_ENUMINCOMING:
                                fMatchFound = (pcfp->dwCharacteristics & NCCF_INCOMING_ONLY);
                                break;
                            case CFCOPT_ENUMOUTGOING:
                                fMatchFound = !(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY);
                                break;
                        }
                    }

                    // If we've found one that needn't be filtered out,
                    // then fill in the return param, etc.
                    //
                    if (fMatchFound)
                    {
                        // Copy the pidl for return
                        //
                        rgelt[0] = m_iterPidlCurrent->TearOffItemIdList();
                        if (!rgelt[0])
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            // If they requested a return count, fill it in.
                            //
                            if (pceltFetched)
                            {
                                *pceltFetched = 1;
                            }

                            // ISSUE:
                            // IsValidPIDL is debug code. However, we're doing this in release mode until we
                            // find the bug from NTRAID#NTBUG9-125787-2000/07/26-deonb.
#ifdef DBG_VALIDATE_PIDLS
                            if (!IsValidPIDL(rgelt[0]))
                            {
                                return E_ABORT;
                            }
#endif
                        }
                    }

                    // Move the pointer to the next pidl in the list.
                    //
                    m_iterPidlCurrent++;
                }
            }
        }
        else
        {
            // There are no items in the list, return S_FALSE
            //
            hr = S_FALSE;
        }
    }
#ifdef DBG
    if (pceltFetched)
    {
        TraceTag(ttidShellFolderIface, "IEnumIDList::Next generated PIDL: 0x%08x", rgelt[0]);
    }
#endif

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "CConnectionFolderEnum::Next");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::Skip
//
//  Purpose:    Skips over the specified number of elements in the
//              enumeration sequence.
//
//  Arguments:
//      celt [in]   Number of item identifiers to skip.
//
//  Returns:    Returns S_OK if successful, or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolderEnum::Skip(
        ULONG   celt)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = S_OK;

    NYI("CConnectionFolderEnum::Skip");

    // Currently, do nothing
    //

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolderEnum::Skip");
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::Reset
//
//  Purpose:    Returns to the beginning of the enumeration sequence. For us,
//              this means do all of the actual enumeration
//
//  Arguments:
//      (none)
//
//  Returns:    Returns S_OK if successful, or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolderEnum::Reset()
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = S_OK;

    // If there's already a list, free it and rebuild.
    //
    if (!m_apidl.empty())
    {
        m_apidl.clear();
        m_iterPidlCurrent = m_apidl.end();
    }

    // Yes, I know that the code below looks strange, as both cases do the same thing,
    // but it makes it a bit easier to debug, and it makes the comments more obvious.
    //
    hr = HrRetrieveConManEntries();
    if (SUCCEEDED(hr))
    {
        // Normalize the return code. HrRetrieveConManEntries... may have returned
        // S_FALSE, meaning that there we no connections (fine).
        //
        hr = S_OK;
        m_iterPidlCurrent = m_apidl.begin();
    }
    else
    {
        // Actually, we're still going to return noerror here after tracing the problem,
        // as we don't want to keep the enumerator from returning an error
        // if the wizard is present (no connections, but hey, better than nothing).
        //
        TraceHr(ttidError, FAL, hr, FALSE,
                "CConnectionsFolderEnum failed in call to HrRetrieveConManEntries");

        hr = S_FALSE;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolderEnum::Reset");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::Clone
//
//  Purpose:    Creates a new item enumeration object with the same contents
//              and state as the current one.
//
//  Arguments:
//      ppenum [out]    Return a clone of the current internal PIDL
//
//  Returns:    Returns S_OK if successful, or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolderEnum::Clone(
        IEnumIDList **  ppenum)
{
    TraceFileFunc(ttidShellFolderIface);

    NYI("CConnectionFolderEnum::Clone");

    *ppenum = NULL;

    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::HrRetrieveConManEntries
//
//  Purpose:    Enumerate all connections from the ConnectionManagers, and
//              add them to our IDL.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   8 Oct 1997
//
//  Notes:
//
HRESULT CConnectionFolderEnum::HrRetrieveConManEntries()
{
    TraceFileFunc(ttidShellFolderIface);
    
    HRESULT         hr          = S_OK;

    NETCFG_TRY

        PCONFOLDPIDLVEC apidlNew;

        hr = g_ccl.HrRetrieveConManEntries(apidlNew);
        if (SUCCEEDED(hr))
        {
            m_apidl.clear();
            m_apidl = apidlNew;
        }

        TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolder::HrRetrieveConManEntries");

    NETCFG_CATCH(hr)
        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\ipersist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I P E R S I S T . C P P
//
//  Contents:   IPersist implementation fopr CConnectionFolder
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes




//+---------------------------------------------------------------------------
//
//  Member:     CJobFolder::GetClassID
//
//  Purpose:    IPersist::GetClassID implementation for CConnectionFolder
//
//  Arguments:
//      lpClassID []
//
//  Returns:
//
//  Author:     jeffspr   22 Sep 1997
//
//  Notes:
//
STDMETHODIMP
CConnectionFolder::GetClassID(
    LPCLSID lpClassID)
{
    TraceFileFunc(ttidShellFolderIface);

    *lpClassID = CLSID_ConnectionFolder;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\iextract.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I E X T R A C T . C P P
//
//  Contents:   IExtract implementation for CConnectionFolderExtractIcon
//
//  Notes:
//                             
//  Author:     jeffspr   7 Oct 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include <nsres.h>
#include "foldres.h"
#include "iconhandler.h"

static const WCHAR c_szNetShellIcon[] = L"netshellicon";

HRESULT CConnectionFolderExtractIcon::CreateInstance(
    LPCITEMIDLIST apidl,
    REFIID  riid,
    void**  ppv)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr = E_OUTOFMEMORY;

    CConnectionFolderExtractIcon * pObj    = NULL;

    pObj = new CComObject <CConnectionFolderExtractIcon>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            PCONFOLDPIDL pcfp;
            hr = pcfp.InitializeFromItemIDList(apidl);
            if (SUCCEEDED(hr))
            {
                hr = pObj->HrInitialize(pcfp);
                if (SUCCEEDED(hr))
                {
                    hr = pObj->GetUnknown()->QueryInterface (riid, ppv);
                }
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    return hr;
}

CConnectionFolderExtractIcon::CConnectionFolderExtractIcon()
{
    TraceFileFunc(ttidShellFolderIface);
}

CConnectionFolderExtractIcon::~CConnectionFolderExtractIcon()
{
    TraceFileFunc(ttidShellFolderIface);
}

HRESULT CConnectionFolderExtractIcon::HrInitialize(
    const PCONFOLDPIDL& pidl)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT         hr      = S_FALSE;
    ConnListEntry   cle;

    if (SUCCEEDED(hr))
    {
        hr = g_ccl.HrFindConnectionByGuid(&(pidl->guidId), cle);
    }

    if (hr == S_OK)
    {
        Assert(!cle.empty());
        Assert(!cle.ccfe.empty());

        hr = cle.ccfe.ConvertToPidl(m_pidl);
    }
    else
    {
        // Couldn't find the icon in the cache.. Good chance that it hasn't been loaded
        // yet. That being the case, go ahead and use the persisted pidl data to
        // load the icon
        //
        TraceTag(ttidShellFolderIface, "IExtractIcon - Couldn't find connection in the cache.");
        hr = m_pidl.ILClone(pidl);
    }

    TraceHr(ttidShellFolderIface, FAL, hr, FALSE, "CConnectionFolderExtractIcon::HrInitialize");
    return hr;
}

//+---------------------------------------------------------------------------
////
////  Function:   HrLoadBrandedIcons
////
////  Purpose:    Load the branded icons from the specified files
////
////  Arguments:
////      cle         [in]    Our connlist entry structure
////      dwIconSize  [in]    Size of icon requested
////      phicon      [out]   Out param for icon
////
////  Returns:
////
////  Author:     jeffspr   21 May 1998
////
////  Notes:
////
//HRESULT HrLoadBrandedIcons(
//    const ConnListEntry& cle,
//    HICON *phicon,
//    DWORD dwIconSize)
//{
//    TraceFileFunc(ttidShellFolderIface);
//
//    Assert(phicon);
//    
//    if (!phicon)
//    {
//        return E_INVALIDARG;
//    }
//
//    HRESULT hr  = S_OK;
//
//    if (cle.pcbi->szwLargeIconPath)
//    {
//        *phicon = (HICON) LoadImage(
//            NULL,
//            cle.pcbi->szwLargeIconPath,
//            IMAGE_ICON,
//            dwIconSize, dwIconSize,
//            LR_LOADFROMFILE);
//
//        if (!*phicon)
//        {
//            hr = E_FAIL;
//        }
//    }
//    else
//    {
//        hr = E_FAIL;
//    }
//
//    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrLoadBrandedIcons");
//    return hr;
//}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderExtractIcon::GetIconLocation
//
//  Purpose:
//
//  Arguments:
//      uFlags     [in]     Address of a UINT value that receives zero or a
//                          combination of the following values:
//
//          GIL_ASYNC       The calling application supports asynchronous
//                          retrieval of icons.
//          GIL_FORSHELL    The icon is to be displayed in a shell folder.
//
//      wzIconFile [out]    Address of the buffer that receives the icon
//                          location. The icon location is a null-terminated
//                          string that identifies the file that contains
//                          the icon.
//      cchMax     [in]     Size of the buffer that receives the icon location.
//      piIndex    [out]    Address of an INT that receives the icon index,
//                          which further describes the icon location.
//      pwFlags    [in]     Address of a UINT value that receives zero or a
//                          combination of the following values:
//
//          GIL_DONTCACHE   Don't cache the physical bits.
//          GIL_NOTFILENAME This isn't a filename/index pair. Call
//                          IExtractIcon::Extract instead
//          GIL_PERCLASS    (Only internal to the shell)
//          GIL_PERINSTANCE Each object of this class has the same icon.
//          GIL_FORSHORTCUT The icon is to be used for a shortcut.
//
//
//  Returns:    S_OK if the function returned a valid location,
//              or S_FALSE if the shell should use a default icon.
//
//  Author:     jeffspr   25 Nov 1998
//
//  Notes:
//
STDMETHODIMP CConnectionFolderExtractIcon::GetIconLocation(
    UINT    uFlags,
    PWSTR   szIconFile,
    UINT    cchMax,
    int *   piIndex,
    UINT *  pwFlags)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = S_FALSE;

    Assert(pwFlags);
    Assert(szIconFile);
    Assert(piIndex);

#ifdef DBG
    // Easy way to check if certain flags are set
    //
    BOOL    fAsync      = (uFlags & GIL_ASYNC);
    BOOL    fForShell   = (uFlags & GIL_FORSHELL);
    BOOL    fOpenIcon   = (uFlags & GIL_OPENICON);
    DWORD   dwOldpwFlags = *pwFlags;
#endif

    BOOL            fIsWizard       = FALSE;

    const PCONFOLDPIDL& pcfp = m_pidl;

    Assert(!pcfp.empty());
    if (!pcfp.empty())
    {
        BOOL  fCacheThisIcon  = TRUE;

        CConFoldEntry cfe;
        hr = pcfp.ConvertToConFoldEntry(cfe);
        if (SUCCEEDED(hr))
        {
            DWORD dwIcon;
            hr = g_pNetConfigIcons->HrGetIconIDForPIDL(uFlags, cfe, dwIcon, &fCacheThisIcon);
            if (SUCCEEDED(hr))
            {
                *piIndex = static_cast<int>(dwIcon);
                wcsncpy(szIconFile, c_szNetShellIcon, cchMax);
                *pwFlags = GIL_PERINSTANCE  | GIL_NOTFILENAME; 

                if (!fCacheThisIcon)
                {
                    *pwFlags |= GIL_DONTCACHE;
                }
            }
        }
    }

#ifdef DBG
    TraceTag(ttidIcons, "%S->GetIconLocation(0x%04x/0x%04x,%S,0x%08x,0x%08x)", pcfp->PszGetNamePointer(), uFlags, dwOldpwFlags, szIconFile, *piIndex, *pwFlags);
#endif
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderExtractIcon::GetIconLocation
//
//  Purpose:    ANSI wrapper for the above UNICODE GetIconLocation
//
//  Arguments:
//      uFlags     []   See above
//      szIconFile []   See above
//      cchMax     []   See above
//      piIndex    []   See above
//      pwFlags    []   See above
//
//  Returns:
//
//  Author:     jeffspr   6 Apr 1999
//
//  Notes:
//
STDMETHODIMP CConnectionFolderExtractIcon::GetIconLocation(
    UINT    uFlags,
    PSTR   szIconFile,
    UINT    cchMax,
    int *   piIndex,
    UINT *  pwFlags)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = S_OK;
    
    WCHAR * pszIconFileW = new WCHAR[cchMax];
    if (!pszIconFileW)
    {
        hr = ERROR_OUTOFMEMORY;
    }
    else
    {
        hr = GetIconLocation(uFlags, pszIconFileW, cchMax, piIndex, pwFlags);
        if (SUCCEEDED(hr))
        {
            WideCharToMultiByte(CP_ACP, 0, pszIconFileW, -1, szIconFile, cchMax, NULL, NULL);
        }

        delete [] pszIconFileW;
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "CConnectionFolderExtractIcon::GetIconLocation(A)");
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderExtractIcon::Extract
//
//  Purpose:    Grab the actual icon for the caller.
//
//  Arguments:
//      wzFile      []  Filename from where we'll retrieve the icon
//      nIconIndex  []  Index of the icon (though this is bogus)
//      phiconLarge []  Return pointer for the large icon handle
//      phiconSmall []  Return pointer for the small icon handle
//      nIconSize   []  Size of the icon requested.
//
//  Returns:
//
//  Author:     jeffspr   9 Oct 1997
// 
//  Notes:
//
STDMETHODIMP CConnectionFolderExtractIcon::Extract(
    PCWSTR  wzFile,
    UINT    nIconIndex,
    HICON * phiconLarge,
    HICON * phiconSmall,
    UINT    nIconSize)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT         hr              = S_OK;
    ConnListEntry   cle;

    Assert(wzFile);
    Assert(phiconLarge);
    Assert(phiconSmall);

    if (wcscmp(wzFile, c_szNetShellIcon))
    {
        TraceHr(ttidError, FAL, E_INVALIDARG, FALSE, "This is not my icon.");
        return E_INVALIDARG;
    }

    Assert(!m_pidl.empty());

    DWORD dwIconLargeSize = LOWORD(nIconSize);
    DWORD dwIconSmallSize = HIWORD(nIconSize);

    hr = g_pNetConfigIcons->HrGetIconFromIconId(dwIconSmallSize, nIconIndex, *phiconSmall);
    if (SUCCEEDED(hr))
    {
        hr = g_pNetConfigIcons->HrGetIconFromIconId(dwIconLargeSize, nIconIndex, *phiconLarge);
        if (FAILED(hr))
        {
            DestroyIcon(*phiconSmall);
            *phiconSmall = NULL;
            *phiconLarge = NULL;
        }
    }
    else
    {
        *phiconSmall = NULL;
        *phiconLarge = NULL;
    }

    TraceTag(ttidIcons, "%S,0x%08x->Extract(%d %d)", wzFile, nIconIndex, dwIconLargeSize, dwIconSmallSize);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderExtractIcon::Extract
//
//  Purpose:    ANSI version of the above Extract
//
//  Arguments:
//      pszFile     [] Filename from where we'll retrieve the icon
//      nIconIndex  [] Index of the icon (though this is bogus)
//      phiconLarge [] Return pointer for the large icon handle
//      phiconSmall [] Return pointer for the small icon handle
//      nIconSize   [] Size of the icon requested.
//
//  Returns:
//
//  Author:     jeffspr   6 Apr 1999
//
//  Notes:
//
STDMETHODIMP CConnectionFolderExtractIcon::Extract(
    PCSTR  pszFile,
    UINT    nIconIndex,
    HICON * phiconLarge,
    HICON * phiconSmall,
    UINT    nIconSize)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr          = S_OK;
    INT     cch         = 0;
    WCHAR * pszFileW    = NULL;

    Assert(pszFile);

    cch = lstrlenA(pszFile) + 1;
    pszFileW = new WCHAR[cch];

    if (!pszFileW)
    {
        hr = ERROR_OUTOFMEMORY;
    }
    else
    {
        MultiByteToWideChar(CP_ACP, 0, pszFile, -1, pszFileW, cch);

        hr = Extract(pszFileW, nIconIndex, phiconLarge, phiconSmall, nIconSize);

        delete [] pszFileW;
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "CConnectionFolderExtractIcon::Extract(A)");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\ipersistf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I P E R S I S T F . C P P
//
//  Contents:   IPersistFolder implementation for CConnectionFolder
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "ncperms.h"    // Permissions (policies)




//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::Initialize
//
//  Purpose:    IPersistFolder::Initialize implementation for
//              CConnectionFolder
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   22 Sep 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::Initialize(
    LPCITEMIDLIST   pidl)
{
    HRESULT hr  = S_OK;

    TraceFileFunc(ttidShellFolderIface);

    // Store the pidl for the relative position in the namespace. We'll
    // use this later to generate absolute pidls
    //
    hr = m_pidlFolderRoot.InitializeFromItemIDList(pidl);

    // This should always be valid
    //
    AssertSz(!m_pidlFolderRoot.empty(), "Hey, we should have a valid folder pidl");
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\ishellei.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S H E L L E I . C P P
//
//  Contents:   IShellExtInit implementation for CConnectionFolder
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes



STDMETHODIMP CConnectionFolder::Initialize(
        LPCITEMIDLIST   pidlFolder,
        LPDATAOBJECT    lpdobj,
        HKEY            hkeyProgID)
{
    TraceFileFunc(ttidShellFolderIface);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\ipersistf2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       I P E R S I S T F 2 . C P P
//
//  Contents:   IPersistFolder2 interface for CConnectionFolder
//
//  Notes:
//
//  Author:     jeffspr   16 Mar 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes



//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::GetCurFolder
//
//  Purpose:    Return a copy of the item id list for the current folder.
//
//  Arguments:
//      ppidl [out] Return pointer for the pidl
//
//  Returns:
//
//  Author:     jeffspr   16 Mar 1998
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetCurFolder(
    LPITEMIDLIST *ppidl)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT hr  = NOERROR;

    *ppidl = m_pidlFolderRoot.TearOffItemIdList();

    if (NULL == *ppidl)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // NOTE: if this is being invoked remotely, we assume that IRemoteComputer
    // is invoked *before* IPersistFolder2.

Exit:
    TraceHr(ttidShellFolder, FAL, hr, FALSE, "CConnectionFolder::GetCurFolder");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\ishellf2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       I S H E L L F 2 . C P P
//
//  Contents:   Provide IShellFolder2 interface for CConnectionsFolderDetails
//              interface. Supercedes IShellDetails. This does not describe
//              IShellFolder members of IShellFolder2 - those are provided in ishellf.cpp
//              This object is created by the ishellv code, primarily to support the 
//              WebView data pane in the folder
//
//  Notes:
//
//  Author:     deonb       18 May  20000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "cfutils.h"    // Connections folder utilities
#include "raserror.h"
#include "naming.h"
//---[ externs ]--------------------------------------------------------------

extern COLS c_rgCols[];

inline HRESULT HrCopyToSTRRET(
    STRRET *    pstr,
    PCWSTR     pszIn)
{
    HRESULT hr          = S_OK;
    UINT    uiByteLen   = (lstrlen(pszIn) + 1) * sizeof(WCHAR);

    Assert(pstr);

    if (!pstr)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        pstr->uType   = STRRET_WSTR;
        pstr->pOleStr = (PWSTR) SHAlloc(uiByteLen);

        if (pstr->pOleStr == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory(pstr->pOleStr, pszIn, uiByteLen);
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrCopyToSTRRET");
    return hr;
}

const WCHAR c_szDevice[] = L"\\DEVICE\\";
const WCHAR c_szLocalSubnet[] = L"255.255.255.255";
const WCHAR c_crlf[] = L"\r\n";

HRESULT HrGetAutoNetSetting(PWSTR pszGuid, DHCP_ADDRESS_TYPE * pAddrType);
HRESULT HrGetAutoNetSetting(REFGUID pGuidId, DHCP_ADDRESS_TYPE * pAddrType);

//+---------------------------------------------------------------------------
//
//  Member:     GetAutoNetSettingsForAdapter
//
//  Purpose:    Get the AutoNet settings for an adapter and return inside a
//              formatted string
//
//  Arguments:
//      cfe            [in]  The connectoid
//      uiFormatString [in]  ResourceID of the FormatMessage (not sprintf) compatible 
//                           Format string
//      szString       [out] Output string
//
//  Returns:
//
//  Author:     deonb   2 April 2001
//
//  Notes:
//
HRESULT GetAutoNetSettingsForAdapter(IN const CConFoldEntry& cfe, IN UINT uiFormatString, OUT tstring& szString)
{
    HRESULT hr = S_OK;

    LPCWSTR szTmpString = NULL;

    if (IsMediaRASType(cfe.GetNetConMediaType()))
    {
        szTmpString = SzLoadIds(IDS_DHCP_ISP);
    }
    else
    {
        DHCP_ADDRESS_TYPE DhcpAddress;
        hr = HrGetAutoNetSetting(cfe.GetGuidID(), &DhcpAddress);
        if (SUCCEEDED(hr))
        {   
            switch (DhcpAddress)
            {
                case UNKNOWN_ADDR:
                    hr = E_FAIL;
                    break;
                case NORMAL_ADDR:
                    szTmpString = SzLoadIds(IDS_DHCP);
                    break;
                case AUTONET_ADDR:
                    szTmpString = SzLoadIds(IDS_AUTONET);
                    break;
                case ALTERNATE_ADDR:
                    szTmpString = SzLoadIds(IDS_ALTERNATE_ADDR);
                    break;
                case STATIC_ADDR:
                    szTmpString = SzLoadIds(IDS_STATIC_CFG);
                    break;
                default:
                    hr = E_FAIL;
                    AssertSz(NULL, "Invalid DHCP Address type");
            }
        }
    }

    if (szTmpString)
    {
        WCHAR szFormatBuf[1024];
        if (DwFormatString(SzLoadIds(uiFormatString), szFormatBuf, 1024, szTmpString))
        {
            szString = szFormatBuf;
        }
        else
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "GetAutoNetSettingsForAdapter");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetPrimaryIPAddressForAdapter
//
//  Purpose:    Get the primary IP Address for an adapter and return inside a
//              formatted string
//
//  Arguments:
//      cfe            [in]  The connectoid
//      uiFormatString [in]  ResourceID of the FormatMessage (not sprintf) compatible 
//                           Format string
//      szString       [out] Output string
//
//  Returns:
//
//  Author:     deonb   2 April 2001
//
//  Notes:
//
HRESULT GetPrimaryIPAddressForAdapter(IN const CConFoldEntry& cfe, IN UINT uiFormatString, OUT tstring& szString)
{
    HRESULT hr = S_OK;

    if (IsMediaRASType(cfe.GetNetConMediaType()))
    {
        DWORD     cb = sizeof(RASCONN);
        DWORD     cConnections;
        DWORD     dwErr;
        LPRASCONN pRasConn = reinterpret_cast<LPRASCONN>(new BYTE[cb]);
        if (!pRasConn)
        {
            return E_OUTOFMEMORY;
        }
        pRasConn->dwSize = sizeof(RASCONN);
            
        do 
        {
            dwErr = RasEnumConnections(pRasConn, &cb, &cConnections);
            if (ERROR_BUFFER_TOO_SMALL == dwErr)
            {
                delete[] pRasConn;
                pRasConn = reinterpret_cast<LPRASCONN>(new BYTE[cb]);
                if (!pRasConn)
                {
                    return E_OUTOFMEMORY;
                }
            }
        } while (ERROR_BUFFER_TOO_SMALL == dwErr);

        if (!dwErr)
        {
            Assert( (cb % sizeof(RASCONN)) == 0);

            DWORD dwItems = cb / sizeof(RASCONN);
            for (DWORD x = 0; x < dwItems; x++)
            {
                if (pRasConn[x].guidEntry == cfe.GetGuidID())
                {
                    RASPPPIP rasPPPIP;
                    rasPPPIP.dwSize = sizeof(RASPPPIP);
                    DWORD dwSize = rasPPPIP.dwSize;
                    dwErr = RasGetProjectionInfo(pRasConn[x].hrasconn, RASP_PppIp, &rasPPPIP, &dwSize);
                    if (!dwErr)
                    {
                        WCHAR szFormatBuf[MAX_PATH];
                        if (DwFormatString(
                                    SzLoadIds(uiFormatString),
                                    szFormatBuf,
                                    MAX_PATH, 
                                    rasPPPIP.szIpAddress, 
                                    c_szLocalSubnet
                                    ) )
                        {
                            szString = szFormatBuf;
                        }
                        else
                        {
                            hr = HrFromLastWin32Error();
                        }
                    }
                    else
                    {
                        Assert(dwErr != ERROR_BUFFER_TOO_SMALL);

                        hr = HrFromLastWin32Error();
                    }
                }
            }
        }
        else
        {
            hr = HrFromLastWin32Error();
        }
    }
    else
    {
   
        PIP_ADAPTER_INFO pAdapterInfo = NULL;
        DWORD dwOutBufLen = 0;
        DWORD dwRet = ERROR_SUCCESS;

        dwRet = GetAdaptersInfo(pAdapterInfo, &dwOutBufLen);
        if (dwRet == ERROR_BUFFER_OVERFLOW)
        {
            pAdapterInfo = (PIP_ADAPTER_INFO) CoTaskMemAlloc(dwOutBufLen);
            if (NULL == pAdapterInfo)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else if (ERROR_SUCCESS == dwRet)
        {
            hr = E_FAIL;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwRet);
        }

        if (SUCCEEDED(hr))
        {
            dwRet = GetAdaptersInfo(pAdapterInfo, &dwOutBufLen);
            if (ERROR_SUCCESS != dwRet)
            {
                CoTaskMemFree(pAdapterInfo);
                hr = HRESULT_FROM_WIN32(dwRet);
            }

            if (SUCCEEDED(hr))
            {
                WCHAR   wszGuid[c_cchGuidWithTerm];
            
                ::StringFromGUID2(cfe.GetGuidID(), wszGuid, c_cchGuidWithTerm);

                BOOL fFound = FALSE;
                PIP_ADAPTER_INFO pAdapterInfoEnum = pAdapterInfo;
                while (pAdapterInfoEnum)
                {
                    USES_CONVERSION;

                    if (lstrcmp(wszGuid, A2W(pAdapterInfoEnum->AdapterName)) == 0)
                    {
                        LPCWSTR strIPAddress = A2W(pAdapterInfoEnum->IpAddressList.IpAddress.String);
                        LPCWSTR strSubnetMask = A2W(pAdapterInfoEnum->IpAddressList.IpMask.String);
                        LPCWSTR strGateway = A2W(pAdapterInfoEnum->GatewayList.IpAddress.String);

                        WCHAR   szFormatBuf[MAX_PATH];
                        LPCWSTR szMode = NULL;
        
                        if (strIPAddress && strSubnetMask && strGateway)
                        {
                            LPCWSTR szArgs[] = {strIPAddress, strSubnetMask};

                            if (DwFormatString(
                                        SzLoadIds(uiFormatString), // lpSource
                                        szFormatBuf,  // Buffer
                                        MAX_PATH,  // Len
                                        strIPAddress, 
                                        strSubnetMask
                                        ) )
                            {
                                szString = szFormatBuf;
                            }
                            else
                            {
                                hr = HrFromLastWin32Error();
                            }
                        }
                        break;
                    }

                    pAdapterInfoEnum = pAdapterInfoEnum->Next;
                }

                CoTaskMemFree(pAdapterInfo);
            }
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "GetPrimaryIPAddressForAdapter");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetWirelessModeForAdapter
//
//  Purpose:    Get the Wireless mode for an adapter and return inside a
//              formatted string
//
//  Arguments:
//      cfe            [in]  The connectoid
//      uiFormatString [in]  ResourceID of the FormatMessage (not sprintf) compatible 
//                           Format string
//      szString       [out] Output string
//
//  Returns:
//
//  Author:     deonb   2 April 2001
//
//  Notes:
//
HRESULT GetWirelessModeForAdapter(IN const CConFoldEntry& cfe, IN UINT uiFormatString, OUT tstring& szString)
{
    HRESULT hr = S_OK;

    DWORD dwInfraStructureMode = 0;
    DWORD dwInfraStructureModeSize = sizeof(DWORD);
    
    hr = HrQueryNDISAdapterOID(cfe.GetGuidID(), 
                          OID_802_11_INFRASTRUCTURE_MODE, 
                          &dwInfraStructureModeSize,
                          &dwInfraStructureMode);
    if (SUCCEEDED(hr))
    {
        WCHAR   szTmpBuf[MAX_PATH];
        LPCWSTR szMode = NULL;
    
        switch (dwInfraStructureMode)
        {
            case Ndis802_11IBSS:
                szMode = SzLoadIds(IDS_TOOLTIP_ADHOC);
                break;
            case Ndis802_11Infrastructure:
                szMode = SzLoadIds(IDS_TOOLTIP_INFRASTRUCTURE);
                break;
        }

        if (szMode)
        {
            if (DwFormatString(
                        SzLoadIds(uiFormatString), 
                        szTmpBuf,  // Buffer
                        MAX_PATH,  // Len
                        szMode
                        ))
            {
                szString = szTmpBuf;
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "GetWirelessModeForAdapter");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetWirelessSSIDForAdapter
//
//  Purpose:    Get the Wireless SSID for an adapter and return inside a
//              formatted string
//
//  Arguments:
//      cfe            [in]  The connectoid
//      uiFormatString [in]  ResourceID of the FormatMessage (not sprintf) compatible 
//                           Format string
//      szString       [out] Output string
//
//  Returns:
//
//  Author:     deonb   4 April 2001
//
//  Notes:
//
HRESULT GetWirelessSSIDForAdapter(IN const CConFoldEntry& cfe, IN UINT uiFormatString, OUT tstring& szString)
{
    HRESULT hr = S_OK;
    
    NDIS_802_11_SSID ndisSSID;
    DWORD dwndisSSIDSize = sizeof(NDIS_802_11_SSID);
    
    hr = HrQueryNDISAdapterOID(cfe.GetGuidID(), 
                          OID_802_11_SSID, 
                          &dwndisSSIDSize,
                          &ndisSSID);

    if (SUCCEEDED(hr))
    {
        if (ndisSSID.SsidLength > 1)
        {
            WCHAR szuSSID[sizeof(ndisSSID.Ssid)+1];

            DWORD dwLen = ndisSSID.SsidLength;
            if (dwLen > sizeof(ndisSSID.Ssid))
            {
                dwLen = sizeof(ndisSSID.Ssid);
                AssertSz(FALSE, "Unexpected SSID encountered");
            }

            ndisSSID.Ssid[dwLen] = 0;
            mbstowcs(szuSSID, reinterpret_cast<LPSTR>(ndisSSID.Ssid), celems(szuSSID));

            WCHAR   szTmpBuf[MAX_PATH];

            if (DwFormatString(
                        SzLoadIds(uiFormatString), 
                        szTmpBuf,  // Buffer
                        MAX_PATH,  // Len
                        szuSSID
                        ))
            {
                szString = szTmpBuf;
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "GetWirelessModeForAdapter");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetWirelessEncryptionForAdapter
//
//  Purpose:    Get the Wireless Encryption for an adapter and return inside a
//              formatted string
//
//  Arguments:
//      cfe            [in]  The connectoid
//      uiFormatString [in]  ResourceID of the FormatMessage (not sprintf) compatible 
//                           Format string
//      szString       [out] Output string
//
//  Returns:
//
//  Author:     deonb   4 April 2001
//
//  Notes:
//
HRESULT GetWirelessEncryptionForAdapter(IN const CConFoldEntry& cfe, IN UINT uiFormatString, OUT tstring& szString)
{
    HRESULT hr = S_OK;
    
    DWORD dwEncryption = 0;
    DWORD dwEncryptionSize = sizeof(DWORD);
    
    hr = HrQueryNDISAdapterOID(cfe.GetGuidID(), 
                          OID_802_11_WEP_STATUS, 
                          &dwEncryptionSize,
                          &dwEncryption);
    if (SUCCEEDED(hr))
    {
        WCHAR   szTmpBuf[MAX_PATH];
        LPCWSTR szMode = NULL;
    
        if (Ndis802_11WEPEnabled == dwEncryption)
        {
            szMode = SzLoadIds(IDS_CONFOLD_STATUS_ENABLED);
        }
        else
        {
            szMode = SzLoadIds(IDS_CONFOLD_STATUS_DISABLED);
        }

        if (szMode)
        {
            if (DwFormatString(
                        SzLoadIds(uiFormatString), 
                        szTmpBuf,  // Buffer
                        MAX_PATH,  // Len
                        szMode
                        ))
            {
                szString = szTmpBuf;
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "GetWirelessEncryptionForAdapter");
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     GetWirelessSignalStrengthForAdapter
//
//  Purpose:    Get the Wireless Signal Strength for an adapter and return inside a
//              formatted string
//
//  Arguments:
//      cfe            [in]  The connectoid
//      uiFormatString [in]  ResourceID of the FormatMessage (not sprintf) compatible 
//                           Format string
//      szString       [out] Output string
//
//  Returns:
//
//  Author:     deonb   4 April 2001
//
//  Notes:
//
HRESULT GetWirelessSignalStrengthForAdapter(IN const CConFoldEntry& cfe, IN UINT uiFormatString, OUT tstring& szString)
{
    HRESULT hr = S_OK;
    
    DWORD pdwEnumValue;

    LONG  lSignalStrength = 0;
    DWORD dwSignalStrengthSize = sizeof(DWORD);
    
    hr = HrQueryNDISAdapterOID(cfe.GetGuidID(), 
                          OID_802_11_RSSI, 
                          &dwSignalStrengthSize,
                          &lSignalStrength);
    if (SUCCEEDED(hr))
    {
        WCHAR   szTmpBuf[MAX_PATH];
 
        if (DwFormatString(
                    SzLoadIds(uiFormatString), 
                    szTmpBuf,  // Buffer
                    MAX_PATH,  // Len
                    PszGetRSSIString(lSignalStrength)))
        {
            szString = szTmpBuf;
        }
        else
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "GetWirelessSignalStrengthForAdapter");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderDetails::GetDetailsOf
//
//  Purpose:    Returns the column information, either for the columns
//              themselves, or for the actual details of the view items.
//
//  Arguments:
//      pidl      [in]  The pidl for the object being requested
//      iColumn   [in]  The details column needed
//      lpDetails [in]  Buffer that receives the detail data
//
//  Returns:
//
//  Author:     jeffspr   16 Mar 1998
//
//  Notes:
//
HRESULT CConnectionFolder::GetDetailsOf(
                                        LPCITEMIDLIST   pidl,
                                        UINT            iColumn,
                                        LPSHELLDETAILS  lpDetails)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT         hr          = S_OK;
    PCWSTR          pszString   = NULL;
    WCHAR szStatus[CONFOLD_MAX_STATUS_LENGTH];
    tstring szTmpString;

    // If the column requested is beyond our set of columns,
    // return failure.
    //
    if (((INT)iColumn < 0) || ((INT)iColumn >= ICOL_MAX))
    {
        hr = E_FAIL;
    }
    else
    {
        // If NULL, caller wants strings for the column headers
        //
        CONFOLDENTRY  cfe; // Need this scope as we assign pszString from it.
        
        if (NULL == pidl)
        {
            if (c_rgCols[iColumn].iStringRes)
            {
                pszString = SzLoadIds(c_rgCols[iColumn].iStringRes);
            }
            lpDetails->fmt = c_rgCols[iColumn].iFormat;
            lpDetails->cxChar = c_rgCols[iColumn].iColumnSize;

        }
        else
        {
            INT             iStringRes  = 0;

            PCONFOLDPIDL  pcfp;
            hr = pcfp.InitializeFromItemIDList(pidl);
            if (FAILED(hr))
            {
                return hr;               
            }

            hr = pcfp.ConvertToConFoldEntry(cfe);

            if (SUCCEEDED(hr))
            {
                Assert(!cfe.empty());
                lpDetails->fmt = c_rgCols[iColumn].iColumnSize;
                lpDetails->cxChar = c_rgCols[iColumn].iColumnSize;

                if (!cfe.GetWizard())
                {
                    // Retrieve the appropriate column
                    //
                    switch(iColumn)
                    {
                        case ICOL_NAME:         // 0
                            pszString = cfe.GetName();
                            break;

                        case ICOL_TYPE:         // 1
                            MapNCMToResourceId(cfe.GetNetConMediaType(), cfe.GetCharacteristics(), &iStringRes);
                            pszString = SzLoadIds(iStringRes);
                            break;

                        case ICOL_STATUS:       // 2
                            MapNCSToComplexStatus(cfe.GetNetConStatus(), cfe.GetNetConMediaType(), cfe.GetNetConSubMediaType(), cfe.GetCharacteristics(), szStatus, CONFOLD_MAX_STATUS_LENGTH, cfe.GetGuidID());
                            pszString = szStatus;
                            break;

                        case ICOL_DEVICE_NAME:  // 3
                            pszString = cfe.GetDeviceName();
                            break;

                        case ICOL_PHONEORHOSTADDRESS:  // 4
                        case ICOL_PHONENUMBER:         // 7 
                        case ICOL_HOSTADDRESS:         // 8
                            pszString = cfe.GetPhoneOrHostAddress();
                            break;

                        case ICOL_OWNER:        // 5
                            if (cfe.GetCharacteristics() & NCCF_ALL_USERS)
                            {
                                pszString = SzLoadIds(IDS_CONFOLD_DETAILS_OWNER_SYSTEM);
                            }
                            else
                            {
                                pszString = PszGetOwnerStringFromCharacteristics(pszGetUserName(), cfe.GetCharacteristics() );
                            }
                            break;

                        case ICOL_ADDRESS:  //6
                            {
                                if (!fIsConnectedStatus(cfe.GetNetConStatus()))
                                {
                                    hr = E_FAIL;
                                }
                                else
                                {
                                    BOOL bSomeDetail = FALSE;
                                    tstring szAutonet;
                                    tstring szIp;

                                    hr = GetPrimaryIPAddressForAdapter(cfe, IDS_DETAILS_IP_ADDRESS, szIp);
                                    if (SUCCEEDED(hr))
                                    {
                                        szTmpString += szIp;
                                        bSomeDetail = TRUE;
                                    }

                                    hr = GetAutoNetSettingsForAdapter(cfe, IDS_DETAILS_ADDRESS_TYPE, szAutonet);
                                    if (SUCCEEDED(hr))
                                    {
                                        if (bSomeDetail)
                                        {
                                            szTmpString += c_crlf;
                                        }
                                        szTmpString += szAutonet;
                                        bSomeDetail = TRUE;
                                    }

                                    if (bSomeDetail)
                                    {
                                        hr = S_OK;
                                        pszString = szTmpString.c_str();
                                    }
                                }
                            }

                            break;

                        case ICOL_WIRELESS_MODE:
                            {
                                if ( (NCS_DISCONNECTED != cfe.GetNetConStatus()) &&
                                     (NCS_HARDWARE_DISABLED != cfe.GetNetConStatus()) &&
                                     (NCS_HARDWARE_MALFUNCTION!= cfe.GetNetConStatus()) &&
                                     (NCS_HARDWARE_NOT_PRESENT!= cfe.GetNetConStatus()) &&
                                     (NCS_MEDIA_DISCONNECTED != cfe.GetNetConStatus()) &&
                                     (cfe.GetNetConMediaType() == NCM_LAN) && 
                                     (cfe.GetNetConSubMediaType() == NCSM_WIRELESS) )
                                {
                                    BOOL bSomeDetail = FALSE;
                                    tstring szString;

                                    hr = GetWirelessModeForAdapter(cfe, IDS_DETAILS_802_11_MODE, szString);
                                    if (SUCCEEDED(hr))
                                    {
                                        szTmpString += szString;
                                        bSomeDetail = TRUE;
                                    }

                                    
                                    hr = GetWirelessSSIDForAdapter(cfe, IDS_DETAILS_802_11_SSID_TYPE, szString);
                                    if (SUCCEEDED(hr))
                                    {
                                        if (bSomeDetail)
                                        {
                                            szTmpString += c_crlf;
                                        }
                                        szTmpString += szString;
                                        bSomeDetail = TRUE;
                                    }
                                    
                                    hr = GetWirelessEncryptionForAdapter(cfe, IDS_DETAILS_802_11_ENCRYPTION_TYPE, szString);
                                    if (SUCCEEDED(hr))
                                    {
                                        if (bSomeDetail)
                                        {
                                            szTmpString += c_crlf;
                                        }
                                        szTmpString += szString;
                                        bSomeDetail = TRUE;
                                    }       
                                    
                                    hr = GetWirelessSignalStrengthForAdapter(cfe, IDS_DETAILS_802_11_SIGNAL_STRENGTH, szString);
                                    if (SUCCEEDED(hr))
                                    {
                                        if (bSomeDetail)
                                        {
                                            szTmpString += c_crlf;
                                        }
                                        szTmpString += szString;
                                        bSomeDetail = TRUE;
                                    }       
                                    
                                    if (bSomeDetail)
                                    {
                                        hr = S_OK;
                                        pszString = szTmpString.c_str();
                                    }
                                }
                                else
                                {
                                    hr = E_FAIL;
                                }
                            }

                            break;

                        default:
                            AssertSz(FALSE, "CConnectionFolder::GetDetailsOf - Invalid ICOL from the Shell");
                            pszString = NULL;
                            hr = E_FAIL;
                            break;
                    }
                }
                else
                {
                    // If we're the wizard, and they want the name, then load
                    // the friendly rendition for webview's sake
                    //
                    switch(iColumn)
                    {
                        case ICOL_NAME:         // 0
                            pszString = SzLoadIds(IDS_CONFOLD_WIZARD_DISPLAY_NAME);
                            break;
                            
                        case ICOL_TYPE:         // 1
                            pszString = SzLoadIds(IDS_CONFOLD_WIZARD_TYPE);
                            break;
                    }
                }
            }
        }
        
        if (SUCCEEDED(hr))
        {
            // Copy the string to the return buffer type. If there was no string loaded,
            // then just copy a null string a return it. This will happen for each
            // wizard item, since we provide no text.
            //
            hr = HrCopyToSTRRET(&(lpDetails->str), pszString ? pszString : L" \0");
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderDetails::EnumSearches
//
//  Purpose:    Requests a pointer to an interface that allows a client to 
//              enumerate the available search objects.
//
//  Arguments:
//      IEnumExtraSearch  [in]  Address of a pointer to an enumerator object's 
//                              IEnumExtraSearch interface. 
//
//  Returns:   
//
//  Author:     deonb      17 May 2000
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::EnumSearches (
           IEnumExtraSearch **ppEnum)
{
    TraceFileFunc(ttidShellFolder);
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderDetails::GetDefaultColumn
//
//  Purpose:    Gets the default sorting and display columns.
//
//  Arguments:
//      dwReserved  [in] Reserved. Set to zero. 
//      pSort      [out] Pointer to a value that receives the index of the default sorted column. 
//      pDisplay   [out] Pointer to a value that receives the index of the default display column. 
//
//  Returns:
//
//  Author:     deonb      17 May 2000
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetDefaultColumn (
            DWORD dwReserved,
            ULONG *pSort,
            ULONG *pDisplay )
{
    TraceFileFunc(ttidShellFolder);
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderDetails::GetDefaultColumnState
//
//  Purpose:    Retrieves the default state for a specified column.
//
//  Arguments:
//      iColumn   [in] Integer that specifies the column number. 
//      pcsFlags [out] Pointer to flags that indicate the default column state. 
//
//  Returns:
//
//  Author:     deonb      17 May 2000
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetDefaultColumnState (
            UINT iColumn,
            DWORD *pcsFlags )
{
    TraceFileFunc(ttidShellFolder);

    HRESULT hr;
    if ( (static_cast<INT>(iColumn) >= ICOL_NAME) && (static_cast<INT>(iColumn) < ICOL_MAX) )
    {
        *pcsFlags = c_rgCols[iColumn].csFlags;
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}            

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderDetails::GetDefaultSearchGUID
//
//  Purpose:    Returns the globally unique identifier (GUID) of the default 
//              search object for the folder.
//
//  Arguments:
//      lpGUID  [out] GUID of the default search object. 
//
//  Returns:
//
//  Author:     deonb      17 May 2000
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetDefaultSearchGUID (
            LPGUID lpGUID )
{
    TraceFileFunc(ttidShellFolder);
    return E_NOTIMPL;
}            

#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderDetails::GetDetailsEx
//
//  Purpose:    Retrieves detailed information, identified by a property set ID 
//              (FMTID) and property ID (PID), on an item in a shell folder.
//
//  Arguments:
//     pidl    [in] PIDL of the item, relative to the parent folder. This method accepts 
//                  only single-level PIDLs. The structure must contain exactly one 
//                  SHITEMID structure followed by a terminating zero. 
//     pscid   [in] Pointer to an SHCOLUMNID structure that identifies the column. 
//     pv     [out] Pointer to a VARIANT with the requested information. 
//                 The value will be fully typed. 
//  Returns:
//
//  Author:     deonb      17 May 2000
//
//  Notes:
//
#define STR_FMTID_DUIWebViewProp   TEXT("{4BF1583F-916B-4719-AC31-8896A4BD8D8B}")
#define PSCID_DUIWebViewProp     {0x4bf1583f, 0x916b, 0x4719, 0xac, 0x31, 0x88, 0x96, 0xa4, 0xbd, 0x8d, 0x8b}
DEFINE_SCID(SCID_WebViewDisplayProperties, PSGUID_WEBVIEW, PID_DISPLAY_PROPERTIES);
#ifdef __cplusplus
#define IsEqualSCID(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid) )
#else
#define IsEqualSCID(a, b)   (((a).pid == (b).pid) && IsEqualIID(&((a).fmtid),&((b).fmtid)))
#endif

const TCHAR szDUI_LAN_Props[] = 
    TEXT("prop:")
    TEXT("Name;")                                       // ICOL_NAME (0)
    STR_FMTID_DUIWebViewProp TEXT("1")                  // ICOL_TYPE (1)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("2")                  // ICOL_STATUS (2)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("3")                  // ICOL_DEVICE_NAME (3)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("6")                  // ICOL_ADDRESS (6)
    TEXT(";")
    ;

const TCHAR szDUI_WIRELESS_LAN_Props[] = 
    TEXT("prop:")
    TEXT("Name;")                                       // ICOL_NAME (0)
    STR_FMTID_DUIWebViewProp TEXT("2")                  // ICOL_STATUS (2)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("6")                  // ICOL_ADDRESS (6)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("9")                  // ICOL_WIRELESS_MODE (9)
    TEXT(";")
    ;

const TCHAR szDUI_PHONEISDN_Props[] = 
    TEXT("prop:")
    TEXT("Name;")                                       // ICOL_NAME (0)
    STR_FMTID_DUIWebViewProp TEXT("1")                  // ICOL_TYPE (1)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("2")                  // ICOL_STATUS (2)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("3")                  // ICOL_DEVICE_NAME (3)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("7")                  // ICOL_PHONENUMBER (7)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("6")                  // ICOL_ADDRESS (6)
    TEXT(";")
    ;

const TCHAR szDUI_RASOTHER_Props[] = 
    TEXT("prop:")
    TEXT("Name;")                                       // ICOL_NAME (0)
    STR_FMTID_DUIWebViewProp TEXT("1")                  // ICOL_TYPE (1)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("2")                  // ICOL_STATUS (2)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("3")                  // ICOL_DEVICE_NAME (3)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("8")                  // ICOL_HOSTADDRESS (8)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("6")                  // ICOL_ADDRESS (6)
    TEXT(";")
    ;

STDMETHODIMP CConnectionFolder::GetDetailsEx (
            LPCITEMIDLIST pidl,
            const SHCOLUMNID *pscid,
            VARIANT *pv )
{

    TraceFileFunc(ttidShellFolder);

    HRESULT         hr              = S_OK;

    if ( (!pidl) || (!pscid) || (!pv) )
    {
        return E_INVALIDARG;
    }

    VariantInit(pv);
    
    if (IsEqualSCID(*pscid, SCID_WebViewDisplayProperties))
    {
        VariantInit(pv);

        pv->vt = VT_BSTR;

        PCONFOLDPIDL  pcfp;
        hr = pcfp.InitializeFromItemIDList(pidl);
        if (FAILED(hr))
        {
            return hr;
        }

        switch (pcfp->ncm)
        {
            case NCM_LAN:
                if ( pcfp->ncsm == NCSM_WIRELESS )
                {
                    pv->bstrVal = SysAllocString(szDUI_WIRELESS_LAN_Props);
                }
                else
                {
                    pv->bstrVal = SysAllocString(szDUI_LAN_Props);
                }
                break;

            case NCM_BRIDGE:
                pv->bstrVal = SysAllocString(szDUI_LAN_Props);
                break;

            case NCM_NONE:
            case NCM_DIRECT:
            case NCM_PPPOE:
            case NCM_SHAREDACCESSHOST_LAN:
            case NCM_SHAREDACCESSHOST_RAS:
            case NCM_TUNNEL:
                pv->bstrVal = SysAllocString(szDUI_RASOTHER_Props);
                break;

            case NCM_PHONE:
            case NCM_ISDN:
                pv->bstrVal = SysAllocString(szDUI_PHONEISDN_Props);
                break;

            default:
                AssertSz(NULL, "Unexpected NetCon Media Type");
                hr = E_FAIL;
        }
    }
    else if (IsEqualIID(pscid->fmtid, FMTID_DUIWebViewProp) && pscid->pid < ICOL_MAX)
    {
        // this is a webview property -- get the value from GetDetailsOf(...)
        SHELLDETAILS sd = {0};
        hr = GetDetailsOf(pidl, pscid->pid, &sd);
        if (SUCCEEDED(hr))
        {
            WCHAR szTemp[INFOTIPSIZE];
            hr = StrRetToBufW(&sd.str, pidl, szTemp, INFOTIPSIZE);
            if (SUCCEEDED(hr))
            {
                pv->vt = VT_BSTR;
                pv->bstrVal = SysAllocString(szTemp);
            }
        }
    }
    else 
    if (IsEqualGUID(pscid->fmtid, GUID_NETSHELL_PROPS))
    {
        CComBSTR bstrDisplayString;

        PCONFOLDPIDL  pcfp;
        hr = pcfp.InitializeFromItemIDList(pidl);
        if FAILED(hr)
        {
            return hr;
        }

        CONFOLDENTRY  cfe;
        hr = pcfp.ConvertToConFoldEntry(cfe);
        
        if (SUCCEEDED(hr))
        {
            Assert(!cfe.empty());

            INT iStringRes;
            if (!cfe.GetWizard())
            {
                switch (pscid->pid)
                {
                    case ICOL_NAME:
                        WCHAR           szDisplayName[2];
                        szDisplayName[0] = towupper(*cfe.GetName());
                        szDisplayName[1] = NULL;
                        bstrDisplayString = szDisplayName;
                        break;
                        
                    case ICOL_DEVICE_NAME:
                        bstrDisplayString = cfe.GetDeviceName();
                        if (bstrDisplayString.Length() == 0) // e.g. Incoming Connections
                        {
                            bstrDisplayString = cfe.GetName();
                        }
                        break;

                    case ICOL_PHONEORHOSTADDRESS:
                        AssertSz(FALSE, "Can't group by this column - IDefCategoryProvider should have prevented this.");
                        bstrDisplayString = cfe.GetPhoneOrHostAddress();
                        break;
 
                    case ICOL_TYPE:
                        MapNCMToResourceId(pcfp->ncm, pcfp->dwCharacteristics, &iStringRes);
                        bstrDisplayString = SzLoadIds(iStringRes);
                        break;

                    case ICOL_NETCONMEDIATYPE:
                        pv->vt = VT_I4;
                        pv->lVal = pcfp->ncm;
                        return S_OK;

                    case ICOL_NETCONSUBMEDIATYPE:
                        pv->vt = VT_I4;
                        pv->lVal = pcfp->ncsm;
                        return S_OK;

                    case ICOL_NETCONSTATUS:
                        pv->vt = VT_I4;
                        pv->lVal = pcfp->ncs;
                        return S_OK;

                    case ICOL_NETCONCHARACTERISTICS:
                        pv->vt = VT_I4;
                        pv->lVal = pcfp->dwCharacteristics;
                        return S_OK;
                        
                    case ICOL_STATUS:
                        WCHAR szStatus[CONFOLD_MAX_STATUS_LENGTH];
                        MapNCSToComplexStatus(pcfp->ncs, pcfp->ncm, pcfp->ncsm, pcfp->dwCharacteristics, szStatus, CONFOLD_MAX_STATUS_LENGTH, pcfp->guidId);
                        bstrDisplayString = szStatus;
                        break;

                    case ICOL_OWNER:
                        if (cfe.GetCharacteristics() & NCCF_ALL_USERS)
                        {
                            bstrDisplayString = SzLoadIds(IDS_CONFOLD_DETAILS_OWNER_SYSTEM);
                        }
                        else
                        {
                            bstrDisplayString = PszGetOwnerStringFromCharacteristics(pszGetUserName(), cfe.GetCharacteristics() );
                        }
                        break;

                    default:
                        hr = E_FAIL;
                        break;
                }
            }
            else // if !(pccfe.GetWizard())
            {
                switch (pscid->pid)
                {
                    case ICOL_NAME:         // 0
                        WCHAR           szDisplayName[2];
                        szDisplayName[0] = towupper(*cfe.GetName());
                        szDisplayName[1] = NULL;
                        bstrDisplayString = szDisplayName;
                        break;
                    case ICOL_TYPE:         // 1
                    default:
                        bstrDisplayString = SzLoadIds(IDS_CONFOLD_WIZARD_TYPE);
                        break;
                }
            }

        }
   
        if (SUCCEEDED(hr))
        {
            if (bstrDisplayString.Length() == 0)
            {
                hr = E_FAIL;
            }
            else
            {
                pv->vt = VT_BSTR;
                pv->bstrVal = bstrDisplayString.Detach();
            }
        }
    }
    else
    {  
        hr = E_FAIL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderDetails::MapNameToSCID
//
//  Purpose:    Converts a column name to the appropriate property set ID (FMTID) 
//              and property ID (PID).
//
//  Arguments:
//    iColumn  [in] Zero-based index of the desired information field. It is 
//                  identical to the column number of the information as it is 
//                  displayed in a Microsoft Windows Explorer Details view. 
//    pscid   [out] Pointer to an SHCOLUMNID structure containing the FMTID and PID. 

//  Returns:
//
//  Author:     deonb      17 May 2000
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::MapColumnToSCID (

            UINT iColumn,
            SHCOLUMNID *pscid )
{
    TraceFileFunc(ttidShellFolder);

    HRESULT hr = S_OK;
    if (!pscid)
    {
        return E_INVALIDARG;
    }

    if ( (static_cast<INT>(iColumn) >= ICOL_NAME) && (static_cast<INT>(iColumn) < ICOL_MAX) )
    {
        pscid->fmtid = GUID_NETSHELL_PROPS;
        pscid->pid = iColumn;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\ishellv.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S H E L L V . C P P
//
//  Contents:   IShellView implementation for CConnectionFolder
//
//  Notes:      The IShellView interface is implemented to present a view
//              in the Windows Explorer or folder windows. The object that
//              exposes IShellView is created by a call to the
//              IShellFolder::CreateViewObject method. This provides the
//              channel of communication between a view object and the
//              Explorer's outermost frame window. The communication
//              involves the translation of messages, the state of the frame
//              window (activated or deactivated), and the state of the
//              document window (Activated or deactivated), and the merging
//              of menus and toolbar items. This object is created by the
//              IShellFolder object that hosts the view.
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "foldres.h"    // Folder resource IDs
#include "nsres.h"      // Netshell strings
#include "oncommand.h"  // Command handlers
#include "cmdtable.h"   // Table of command properties
#include <ras.h>        // for RAS_MaxEntryName
#include "webview.h"

//---[ Compile flags ]--------------------------------------------------------

#define NEW_CONNECTION_IN_TOOLBAR       0
#define ANY_FREEKIN_THING_IN_TOOLBAR    0   // have any toolbar buttons?

//---[ Constants ]------------------------------------------------------------

#if ANY_FREEKIN_THING_IN_TOOLBAR
const TBBUTTON c_tbConnections[] = {
#if NEW_CONNECTION_IN_TOOLBAR
    { 0,    CMIDM_NEW_CONNECTION,   TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, IDS_TOOLBAR_MAKE_NEW_STRING },
#endif
    { 1,    CMIDM_CONNECT,          TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, IDS_TOOLBAR_CONNECT_STRING },
    { 0,    0,                      TBSTATE_ENABLED, TBSTYLE_SEP   , {0,0}, 0L, -1 },
    };

const DWORD c_nToolbarButtons = celems(c_tbConnections);
#else
const DWORD c_nToolbarButtons = 0;
#endif

//---[ Prototypes ]-----------------------------------------------------------

HRESULT HrOnFolderRefresh(
    HWND            hwndOwner,
    LPARAM          lParam,
    WPARAM          wParam);

HRESULT HrOnFolderGetButtonInfo(
    TBINFO *    ptbilParam);

HRESULT HrOnFolderGetButtons(
    HWND            hwnd,
    LPSHELLFOLDER   psf,
    UINT            idCmdFirst,
    LPTBBUTTON      ptButton);

HRESULT HrOnFolderInitMenuPopup(
    HWND    hwnd,
    UINT    idCmdFirst,
    INT     iIndex,
    HMENU   hmenu);

HRESULT HrOnFolderMergeMenu(
    LPQCMINFO   pqcm);

HRESULT HrOnFolderInvokeCommand(
    HWND            hwndOwner,
    WPARAM          wParam,
    LPSHELLFOLDER   psf);

HRESULT HrCheckFolderInvokeCommand(
    HWND            hwndOwner,
    WPARAM          wParam,
    LPARAM          lParam,
    BOOL            bLevel,
    LPSHELLFOLDER   psf);

HRESULT HrOnFolderGetNotify(
    HWND            hwndOwner,
    LPSHELLFOLDER   psf,
    WPARAM          wParam,
    LPARAM          lParam);

HRESULT HrOnGetHelpTopic(
    SFVM_HELPTOPIC_DATA * phtd);

HRESULT HrOnGetCchMax(
    HWND            hwnd,
    const PCONFOLDPIDL& pidl,
    INT *           pcchMax);

HRESULT HrOnGetHelpText(
    UINT idCmd, 
    UINT cchMax, 
    LPWSTR pszName);

VOID TraceUnhandledMessages(
    UINT    uMsg,
    LPARAM  lParam,
    WPARAM  wParam);

//---[ Column struct and global array ]---------------------------------------

COLS c_rgCols[] =
{
    {ICOL_NAME,               IDS_CONFOLD_DETAILS_NAME,                40, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT},
    {ICOL_TYPE,               IDS_CONFOLD_DETAILS_TYPE,                24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT},
    {ICOL_STATUS,             IDS_CONFOLD_DETAILS_STATUS,              24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT},
    {ICOL_DEVICE_NAME,        IDS_CONFOLD_DETAILS_DEVICE_NAME,         24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT},
    {ICOL_PHONEORHOSTADDRESS, IDS_CONFOLD_DETAILS_PHONEORHOSTADDRESS,  24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT},
    {ICOL_OWNER,              IDS_CONFOLD_DETAILS_OWNER,               24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT},
    
    {ICOL_ADDRESS,            IDS_CONFOLD_DETAILS_ADDRESS,             24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_HIDDEN},
    {ICOL_PHONENUMBER,        IDS_CONFOLD_DETAILS_PHONENUMBER,         24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_HIDDEN},
    {ICOL_HOSTADDRESS,        IDS_CONFOLD_DETAILS_HOSTADDRESS,         24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_HIDDEN},
    {ICOL_WIRELESS_MODE,      IDS_CONFOLD_DETAILS_WIRELESS_MODE,       24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_HIDDEN},
};

#if DBG

struct ShellViewTraceMsgEntry
{
    UINT    uMsg;
    CHAR    szMsgName[32];   // Use Char because it's for Tracing only
    CHAR    szLparamHint[32];
    CHAR    szWparamHint[32];
};

static const ShellViewTraceMsgEntry   c_SVTMEArray[] =
{
    { DVM_GETBUTTONINFO      ,  "DVM_GETBUTTONINFO"      ,"TBINFO *"           ,"-"} ,
    { DVM_GETBUTTONS         ,  "DVM_GETBUTTONS"         ,"idCmdFirst"         ,"ptButton" },
    { DVM_COLUMNCLICK        ,  "DVM_COLUMNCLICK"        ,"-"                  ,"-" },
    { DVM_DEFVIEWMODE        ,  "DVM_DEFVIEWMODE"        ,"FOLDERVIEWMODE*"    ,"-" },
    { DVM_DIDDRAGDROP        ,  "DVM_DIDDRAGDROP"        ,"-"                  ,"-" },
    { DVM_QUERYCOPYHOOK      ,  "DVM_QUERYCOPYHOOK"      ,"-"                  ,"-" },
    { DVM_SELCHANGE          ,  "DVM_SELCHANGE"          ,"-"                  ,"-" },
    { DVM_MERGEMENU          ,  "DVM_MERGEMENU"          ,"LPQCMINFO"          ,"-" },
    { DVM_INITMENUPOPUP      ,  "DVM_INITMENUPOPUP"      ,"iIndex"             ,"HMENU" },
    { DVM_REFRESH            ,  "DVM_REFRESH"            ,"-"                  ,"fPreRefresh" },
    { DVM_INVOKECOMMAND      ,  "DVM_INVOKECOMMAND"      ,"LPSHELLFOLDER"      ,"wParam" },
    { SFVM_MERGEMENU         ,  "SFVM_MERGEMENU"         ,"0"                  ,"LPQCMINFO" },
    { SFVM_INVOKECOMMAND     ,  "SFVM_INVOKECOMMAND"     ,"idCmd"              ,"0" },
    { SFVM_GETHELPTEXT       ,  "SFVM_GETHELPTEXT"       ,"idCmd,cchMax"       ,"pszText - Ansi" },
    { SFVM_GETTOOLTIPTEXT    ,  "SFVM_GETTOOLTIPTEXT"    ,"idCmd,cchMax"       ,"pszText - Ansi" },
    { SFVM_GETBUTTONINFO     ,  "SFVM_GETBUTTONINFO"     ,"0"                  ,"LPTBINFO" },
    { SFVM_GETBUTTONS        ,  "SFVM_GETBUTTONS"        ,"idCmdFirst,cbtnMax" ,"LPTBBUTTON" },
    { SFVM_INITMENUPOPUP     ,  "SFVM_INITMENUPOPUP"     ,"idCmdFirst,nIndex"  ,"hmenu" },
    { SFVM_SELCHANGE         ,  "SFVM_SELCHANGE"         ,"idCmdFirst,nItem"   ,"SFVM_SELCHANGE_DATA*" },
    { SFVM_DRAWITEM          ,  "SFVM_DRAWITEM"          ,"idCmdFirst"         ,"DRAWITEMSTRUCT*" },
    { SFVM_MEASUREITEM       ,  "SFVM_MEASUREITEM"       ,"idCmdFirst"         ,"MEASUREITEMSTRUCT*" },
    { SFVM_EXITMENULOOP      ,  "SFVM_EXITMENULOOP"      ,"-"                  ,"-" },
    { SFVM_PRERELEASE        ,  "SFVM_PRERELEASE"        ,"-"                  ,"-" },
    { SFVM_GETCCHMAX         ,  "SFVM_GETCCHMAX"         ,"LPCITEMIDLIST"      ,"pcchMax" },
    { SFVM_FSNOTIFY          ,  "SFVM_FSNOTIFY"          ,"LPCITEMIDLIST*"     ,"lEvent" },
    { SFVM_WINDOWCREATED     ,  "SFVM_WINDOWCREATED"     ,"hwnd"               ,"-" },
    { SFVM_WINDOWDESTROY     ,  "SFVM_WINDOWDESTROY"     ,"hwnd"               ,"-" },
    { SFVM_REFRESH           ,  "SFVM_REFRESH"           ,"BOOL fPreOrPost"    ,"-" },
    { SFVM_SETFOCUS          ,  "SFVM_SETFOCUS"          ,"-"                  ,"-" },
    { SFVM_QUERYCOPYHOOK     ,  "SFVM_QUERYCOPYHOOK"     ,"-"                  ,"-" },
    { SFVM_NOTIFYCOPYHOOK    ,  "SFVM_NOTIFYCOPYHOOK"    ,"-"                  ,"COPYHOOKINFO*" },
    { SFVM_COLUMNCLICK       ,  "SFVM_COLUMNCLICK"       ,"iColumn"            ,"-" },
    { SFVM_QUERYFSNOTIFY     ,  "SFVM_QUERYFSNOTIFY"     ,"-"                  ,"SHChangeNotifyEntry *" },
    { SFVM_DEFITEMCOUNT      ,  "SFVM_DEFITEMCOUNT"      ,"-"                  ,"UINT*" },
    { SFVM_DEFVIEWMODE       ,  "SFVM_DEFVIEWMODE"       ,"-"                  ,"FOLDERVIEWMODE*" },
    { SFVM_UNMERGEMENU       ,  "SFVM_UNMERGEMENU"       ,"-"                  ,"hmenu" },
    { SFVM_INSERTITEM        ,  "SFVM_INSERTITEM"        ,"pidl"               ,"-" },
    { SFVM_DELETEITEM        ,  "SFVM_DELETEITEM"        ,"pidl"               ,"-" },
    { SFVM_UPDATESTATUSBAR   ,  "SFVM_UPDATESTATUSBAR"   ,"fInitialize"        ,"-" },
    { SFVM_BACKGROUNDENUM    ,  "SFVM_BACKGROUNDENUM"    ,"-"                  ,"-" },
    { SFVM_GETWORKINGDIR     ,  "SFVM_GETWORKINGDIR"     ,"uMax"               ,"pszDir" },
    { SFVM_GETCOLSAVESTREAM  ,  "SFVM_GETCOLSAVESTREAM"  ,"flags"              ,"IStream **" },
    { SFVM_SELECTALL         ,  "SFVM_SELECTALL"         ,"-"                  ,"-" },
    { SFVM_DIDDRAGDROP       ,  "SFVM_DIDDRAGDROP"       ,"dwEffect"           ,"IDataObject *" },
    { SFVM_SUPPORTSIDENTITY  ,  "SFVM_SUPPORTSIDENTITY"  ,"-"                  ,"-" },
    { SFVM_FOLDERISPARENT    ,  "SFVM_FOLDERISPARENT"    ,"-"                  ,"pidlChild" },
    { SFVM_SETISFV           ,  "SFVM_SETISFV"           ,"-"                  ,"IShellFolderView*" },
    { SFVM_GETVIEWS          ,  "SFVM_GETVIEWS"          ,"SHELLVIEWID*"       ,"IEnumSFVViews **" },
    { SFVM_THISIDLIST        ,  "SFVM_THISIDLIST"        ,"-"                  ,"LPITMIDLIST*" },
    { SFVM_GETITEMIDLIST     ,  "SFVM_GETITEMIDLIST"     ,"iItem"              ,"LPITMIDLIST*" },
    { SFVM_SETITEMIDLIST     ,  "SFVM_SETITEMIDLIST"     ,"iItem"              ,"LPITEMIDLIST" },
    { SFVM_INDEXOFITEMIDLIST ,  "SFVM_INDEXOFITEMIDLIST" ,"*iItem"             ,"LPITEMIDLIST" },
    { SFVM_ODFINDITEM        ,  "SFVM_ODFINDITEM"        ,"*iItem"             ,"NM_FINDITEM*" },
    { SFVM_HWNDMAIN          ,  "SFVM_HWNDMAIN"          ,""                   ,"hwndMain" },
    { SFVM_ADDPROPERTYPAGES  ,  "SFVM_ADDPROPERTYPAGES"  ,"-"                  ,"SFVM_PROPPAGE_DATA *" },
    { SFVM_BACKGROUNDENUMDONE,  "SFVM_BACKGROUNDENUMDONE","-"                  ,"-" },
    { SFVM_GETNOTIFY         ,  "SFVM_GETNOTIFY"         ,"LPITEMIDLIST*"      ,"LONG*" },
    { SFVM_ARRANGE           ,  "SFVM_ARRANGE"           ,"-"                  ,"lParamSort" },
    { SFVM_QUERYSTANDARDVIEWS,  "SFVM_QUERYSTANDARDVIEWS","-"                  ,"BOOL *" },
    { SFVM_QUERYREUSEEXTVIEW ,  "SFVM_QUERYREUSEEXTVIEW" ,"-"                  ,"BOOL *" },
    { SFVM_GETSORTDEFAULTS   ,  "SFVM_GETSORTDEFAULTS"   ,"iDirection"         ,"iParamSort" },
    { SFVM_GETEMPTYTEXT      ,  "SFVM_GETEMPTYTEXT"      ,"cchMax"             ,"pszText" },
    { SFVM_GETITEMICONINDEX  ,  "SFVM_GETITEMICONINDEX"  ,"iItem"              ,"int *piIcon" },
    { SFVM_DONTCUSTOMIZE     ,  "SFVM_DONTCUSTOMIZE"     ,"-"                  ,"BOOL *pbDontCustomize" },
    { SFVM_SIZE              ,  "SFVM_SIZE"              ,"resizing flag"      ,"cx, cy" },
    { SFVM_GETZONE           ,  "SFVM_GETZONE"           ,"-"                  ,"DWORD*" },
    { SFVM_GETPANE           ,  "SFVM_GETPANE"           ,"Pane ID"            ,"DWORD*" },
    { SFVM_ISOWNERDATA       ,  "SFVM_ISOWNERDATA"       ,"ISOWNERDATA"        ,"BOOL *" },
    { SFVM_GETODRANGEOBJECT  ,  "SFVM_GETODRANGEOBJECT"  ,"iWhich"             ,"ILVRange **" },
    { SFVM_ODCACHEHINT       ,  "SFVM_ODCACHEHINT"       ,"-"                  ,"NMLVCACHEHINT *" },
    { SFVM_GETHELPTOPIC      ,  "SFVM_GETHELPTOPIC"      ,"0"                  ,"SFVM_HELPTOPIC_DATA *" },
    { SFVM_OVERRIDEITEMCOUNT ,  "SFVM_OVERRIDEITEMCOUNT" ,"-"                  ,"UINT*" },
    { SFVM_GETHELPTEXTW      ,  "SFVM_GETHELPTEXTW"      ,"idCmd,cchMax"       ,"pszText - unicode" },
    { SFVM_GETTOOLTIPTEXTW   ,  "SFVM_GETTOOLTIPTEXTW"   ,"idCmd,cchMax"       ,"pszText - unicode" },
    { SFVM_GETWEBVIEWLAYOUT  ,  "SFVM_GETWEBVIEWLAYOUT"  ,"SFVM_WEBVIEW_LAYOUT_DATA*",     "uViewMode" },
    { SFVM_GETWEBVIEWTASKS   ,  "SFVM_GETWEBVIEWTASKS"   ,"SFVM_WEBVIEW_TASKSECTION_DATA*","pv" },
    { SFVM_GETWEBVIEWCONTENT ,  "SFVM_GETWEBVIEWCONTENT" ,"SFVM_WEBVIEW_CONTENT_DATA*", "pv" }
};

const INT   g_iSVTMEArrayEntryCount = celems(c_SVTMEArray);

VOID TraceShellViewMsg(
    UINT    uMsg,
    LPARAM  lParam,
    WPARAM  wParam)
{
    INT     iLoop       = 0;
    INT     iFoundPos   = -1;

    for (iLoop = 0; iLoop < g_iSVTMEArrayEntryCount && (-1 == iFoundPos); iLoop++)
    {
        if (c_SVTMEArray[iLoop].uMsg == uMsg)
        {
            iFoundPos = iLoop;
        }
    }

    if (-1 != iFoundPos)
    {
        UINT    uMsg;
        CHAR    szMsgName[32];   // Use Char because it's for Tracing only
        CHAR    szLparamHint[32];
        CHAR    szWparamHint[32];

        TraceTag(ttidShellViewMsgs,
            "%s (%d), lParam: 0x%08x [%s], wParam: 0x%08x [%s]",
            c_SVTMEArray[iFoundPos].szMsgName,
            c_SVTMEArray[iFoundPos].uMsg,
            lParam,
            c_SVTMEArray[iFoundPos].szLparamHint,
            wParam,
            c_SVTMEArray[iFoundPos].szWparamHint);
    }
    else
    {
#ifdef SHOW_NEW_MSG_ASSERT

        AssertSz(FALSE,
            "Totally inert assert -- Unknown message in HrShellViewCallback. "
            "I just want to know about new ones");

#endif

        TraceTag(ttidShellViewMsgs,
            "(Jeffspr) Unknown Message (%d) in HrShellViewCallback, lParam: 0x%08x, wParam, 0x%08x",
            uMsg, lParam, wParam);
    }
}

#endif

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::MessageSFVCB
//
//  Purpose:    Deferred Implementation of IShellViewCB::MessageSFVCB after
//              basic functionality was implemented.
//
//  Arguments:
//      [uMsg]  Message - depends on implementation
//     [wParam] WORD param - depends on implementation
//     [lParam] LONG param - - depends on implementation
//
//  Returns:    S_OK is succeeded
//              COM error code if not
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:      CBaseShellFolderViewCB
//
STDMETHODIMP CConnectionFolder::RealMessage(
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam)
{
    HRESULT hr = S_OK;

    TraceFileFunc(ttidShellFolder);

#if DBG
    // Trace the shell message when we're in the checked builds
    //
    TraceShellViewMsg(uMsg, lParam, wParam);
#endif

    switch (uMsg)
    {
        case DVM_GETBUTTONINFO:
            hr = HrOnFolderGetButtonInfo((TBINFO *)lParam);
            break;

        case DVM_GETBUTTONS:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                hr = HrOnFolderGetButtons(m_hwndMain, this, LOWORD(wParam), (TBBUTTON *)lParam);
            }
            break;

        case DVM_COLUMNCLICK:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                ShellFolderView_ReArrange (m_hwndMain, wParam);
            }
            break;

        case DVM_DEFVIEWMODE:
            *(FOLDERVIEWMODE *)lParam = FVM_TILE;
            break;

        case DVM_DIDDRAGDROP:
        case DVM_QUERYCOPYHOOK:
        case DVM_SELCHANGE:
            hr = S_FALSE;
            break;

        case DVM_MERGEMENU :
            hr = HrOnFolderMergeMenu((LPQCMINFO)lParam);
            break;

        case DVM_INITMENUPOPUP:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                hr = HrOnFolderInitMenuPopup(m_hwndMain, LOWORD(wParam), HIWORD(wParam), (HMENU) lParam);
            }
            break;

        case DVM_REFRESH:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                hr = HrOnFolderRefresh(m_hwndMain, lParam, wParam);
            }
            break;

        case DVM_INVOKECOMMAND:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                hr = HrOnFolderInvokeCommand(m_hwndMain, wParam, this);
            }
            break;

        case MYWM_QUERYINVOKECOMMAND_ITEMLEVEL:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                hr = HrCheckFolderInvokeCommand(m_hwndMain, wParam, lParam, FALSE, this);
            }
            break;

        case MYWM_QUERYINVOKECOMMAND_TOPLEVEL:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                hr = HrCheckFolderInvokeCommand(m_hwndMain, wParam, lParam, TRUE, this);
            }
            break;

        case SFVM_HWNDMAIN:
            m_hwndMain = (HWND)lParam;

            HrAssertMenuStructuresValid(m_hwndMain);
            break;

        case SFVM_GETDEFERREDVIEWSETTINGS:
            ((SFVM_DEFERRED_VIEW_SETTINGS *)lParam)->fvm = FVM_TILE;
            break;

        case SFVM_GETNOTIFY:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                hr = HrOnFolderGetNotify(m_hwndMain, this, wParam, lParam);
            }
            break;

        case SFVM_GETHELPTOPIC:
            hr = HrOnGetHelpTopic((SFVM_HELPTOPIC_DATA*)lParam);
            break;

        case SFVM_GETCCHMAX:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                PCONFOLDPIDL pidlParm;
                if (FAILED(pidlParm.InitializeFromItemIDList((LPCITEMIDLIST) wParam)))
                {
                    return E_INVALIDARG;
                }
                
                hr = HrOnGetCchMax(m_hwndMain, pidlParm, (INT *) lParam);
            }
            break;

        case SFVM_GETHELPTEXTW:
            hr = HrOnGetHelpText(LOWORD(wParam), HIWORD(wParam), reinterpret_cast<PWSTR>(lParam));
            break;

        default:
            hr = m_pWebView->RealMessage(uMsg, wParam, lParam); // defer to the webview's handler
            break;
       }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnGetHelpText
//
//  Purpose:    Folder message handler for defview's SFVM_GETHELPTEXTW. This
//              message is received when the status bar text for a command is needed.
//
//  Arguments:
//      idCmd   [in]    Id of the menu command
//      cchMax  [in]    Size of buffer
//      pszName [out]   Status bar text
//
//  Returns:
//
//  Author:     mbend   3 May 2000
//
//  Notes:
//
HRESULT HrOnGetHelpText(UINT idCmd, UINT cchMax, PWSTR pszName)
{
    HRESULT hr = E_FAIL;
    *((PWSTR)pszName) = L'\0';

    int iLength = LoadString(   _Module.GetResourceInstance(),
                                idCmd + IDS_CMIDM_START,
                                (PWSTR) pszName,
                                cchMax);
    if (iLength > 0)
    {
        hr = NOERROR;
    }
    else
    {
        AssertSz(FALSE, "Resource string not found for one of the connections folder commands");
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnGetCchMax
//
//  Purpose:    Folder message handler for defview's SFVM_GETCCHMAX. This
//              message is received when a rename is attempted, and causes
//              the edit control to be limited to the size returned.
//
//  Arguments:
//      hwnd    [in]    Folder window handle
//      pidl    [in]    The object pidl
//      pcchMax [out]   Return pointer for max name length
//
//  Returns:
//
//  Author:     jeffspr   21 Jul 1998
//
//  Notes:
//
HRESULT HrOnGetCchMax(HWND hwnd, const PCONFOLDPIDL& pidl, INT * pcchMax)
{
    HRESULT hr  = S_OK;

    Assert(!pidl.empty());
    Assert(pcchMax);

    // If the passed in info is valid
    //
    if ( (!pidl.empty()) && pcchMax && pidl->IsPidlOfThisType() )
    {
        // Set the max to be the max length of a RAS entry. Currently,
        // that's our only requirement
        //
        *pcchMax = RAS_MaxEntryName;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnGetCchMax");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnFolderRefresh
//
//  Purpose:    Folder message handler for defview's DVM_REFRESH
//
//  Arguments:
//      hwndOwner [in]  Our parent window
//      lParam    [in]  Ignored
//      wParam    [in]  BOOL -- TRUE = Pre-refresh, FALSE = Post-refresh
//
//  Returns:
//
//  Author:     jeffspr   10 Apr 1998
//
//  Notes:
//
HRESULT HrOnFolderRefresh(
    HWND            hwndOwner,
    LPARAM          lParam,
    WPARAM          wParam)
{
    TraceFileFunc(ttidShellFolder);
    
    HRESULT hr          = S_OK;
    BOOL    fPreRefresh = (wParam > 0);

    // If this refresh notification is coming BEFORE the refresh, then we want to
    // flush the connection list. Two reasons for this:
    //
    // 1: We don't ever want to re-enumerate AFTER the refresh has occurred.
    // 2: We get a POST refresh notify on folder entry, which shouldn't necessitate
    //    a refresh
    //

    if (fPreRefresh)
    {
        // Rebuild the cache
        //
        // Note: Remove this when we get RAS notifications, because
        // we will already know about the CM connections and won't have to refresh.
        // Revert the #if 0'd code above to just do the fPreRefresh flush.
        //

        hr = g_ccl.HrRefreshConManEntries();
        if (FAILED(hr))
        {
            NcMsgBox(_Module.GetResourceInstance(), 
                NULL, 
                IDS_CONFOLD_WARNING_CAPTION,
                IDS_ERR_NO_NETMAN, 
                MB_ICONEXCLAMATION | MB_OK);
                     
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnFolderRefresh");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnFolderGetNotify
//
//  Purpose:    Folder message handler for defview's DVM_GETNOTIFY
//
//  Arguments:
//      hwndOwner [in]  Our parent window
//      psf       [in]  Our shell folder
//      wParam    [out] Return pointer for our folder pidl
//      lParam    [out] Return pointer for notify flags
//
//  Returns:
//
//  Author:     jeffspr   10 Apr 1998
//
//  Notes:
//
HRESULT HrOnFolderGetNotify(
    HWND            hwndOwner,
    LPSHELLFOLDER   psf,
    WPARAM          wParam,
    LPARAM          lParam)
{
    HRESULT             hr              = S_OK;
    CConnectionFolder * pcf             = static_cast<CConnectionFolder *>(psf);
    PCONFOLDPIDLFOLDER  pidlRoot;
    PCONFOLDPIDLFOLDER  pidlRootCopy;

    NETCFG_TRY
            
        if (!psf || !wParam || !lParam)
        {
            Assert(psf);
            Assert(lParam);
            Assert(wParam);

            hr = E_INVALIDARG;
        }
        else
        {
            pidlRoot = pcf->PidlGetFolderRoot();
            if (pidlRoot.empty())
            {
                hr = E_FAIL;
            }
            else
            {
                hr = pidlRootCopy.ILClone(pidlRoot);
                if (SUCCEEDED(hr))
                {
                    *(LPCITEMIDLIST*)wParam = pidlRootCopy.TearOffItemIdList();
                    *(LONG*)lParam =
                        SHCNE_RENAMEITEM|
                        SHCNE_CREATE    |
                        SHCNE_DELETE    |
                        SHCNE_UPDATEDIR |
                        SHCNE_UPDATEITEM;
                }
            }
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnFolderGetNotify");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnGetHelpTopic
//
//  Purpose:    Folder message handler for defview's SFVM_GETHELPTOPIC
//
//  Arguments:
//      phtd    [in out]  Pointer to SFVM_HELPTOPIC_DATA structure with default values set
//
//  Returns:
//      S_OK    Help file name is correctly set
//
//  Author:     toddb   21 Jun 1998
//
//  Notes:
//
HRESULT HrOnGetHelpTopic(
    SFVM_HELPTOPIC_DATA * phtd)
{
    Assert(phtd);

    Assert(phtd->wszHelpFile);
    *(phtd->wszHelpFile) = L'\0';

    Assert(phtd->wszHelpTopic);
    lstrcpyW(phtd->wszHelpTopic, L"hcp://services/subsite?node=Unmapped/Network_connections&select=Unmapped/Network_connections/Getting_started");

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnFolderInvokeCommand
//
//  Purpose:    Folder message handler for defview's DVM_INVOKECOMMAND
//
//  Arguments:
//      hwndOwner [in]  Our window handle
//      wParam    [in]  Command that's being invoked
//      psf       [in]  Our shell folder
//
//  Returns:
//
//  Author:     jeffspr   10 Apr 1998
//
//  Notes:
//
HRESULT HrOnFolderInvokeCommand(
    HWND            hwndOwner,
    WPARAM          wParam,
    LPSHELLFOLDER   psf)
{
    HRESULT         hr              = S_OK;
    PCONFOLDPIDLVEC apidlSelected;
    PCONFOLDPIDLVEC apidlCache;

    // Get the selected objects. If there are objects present, try to get them from the
    // cache. Regardless, call the command handler
    //
    hr = HrShellView_GetSelectedObjects(hwndOwner, apidlSelected);
    if (SUCCEEDED(hr))
    {
        // If there are objects, try to get the cached versions
        //
        if (!apidlSelected.empty())
        {
            hr = HrCloneRgIDL(apidlSelected, TRUE, TRUE, apidlCache);
        }

        // If either the clone succeeded, or there were no items, call the command handler
        //
        if (SUCCEEDED(hr))
        {
            hr = HrFolderCommandHandler(
                (UINT) wParam,
                apidlCache,
                hwndOwner,
                NULL,
                psf);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnFolderInvokeCommand");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrCheckFolderInvokeCommand
//
//  Purpose:    Test if a message handler can be invoked 
//
//  Arguments:
//      hwndOwner [in]  Our window handle
//      wParam    [in]  Command that's being invoked
//      psf       [in]  Our shell folder
//
//  Returns:
//
//  Author:     deonb  10 Feb 2001
//
//  Notes:
//
HRESULT HrCheckFolderInvokeCommand(
    HWND            hwndOwner,
    WPARAM          wParam,
    LPARAM          lParam,
    BOOL            bLevel,
    LPSHELLFOLDER   psf)
{
    HRESULT         hr              = S_OK;
    PCONFOLDPIDLVEC apidlSelected;
    PCONFOLDPIDLVEC apidlCache;

    // Get the selected objects. If there are objects present, try to get them from the
    // cache. Regardless, call the command handler
    //
    hr = HrShellView_GetSelectedObjects(hwndOwner, apidlSelected);
    if (SUCCEEDED(hr))
    {
        // If there are objects, try to get the cached versions
        //
        if (!apidlSelected.empty())
        {
            hr = HrCloneRgIDL(apidlSelected, TRUE, TRUE, apidlCache);
        }

        // If either the clone succeeded, or there were no items, call the command handler
        //
        if (SUCCEEDED(hr))
        {
            DWORD dwVerbId = wParam;
            NCCS_STATE *nccsState = reinterpret_cast<NCCS_STATE *>(lParam);
            DWORD dwResourceId;

            hr = HrGetCommandState(apidlCache, dwVerbId, *nccsState, &dwResourceId, 0xFFFFFFFF, bLevel ? NB_FLAG_ON_TOPMENU : NB_NO_FLAGS);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnFolderInvokeCommand");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnFolderInitMenuPopup
//
//  Purpose:    Folder message handler for defview's DVM_INITMENUPOPUP
//
//  Arguments:
//      hwnd       []   Our window handle
//      idCmdFirst []   First command ID in the menu
//      iIndex     []   ???
//      hmenu      []   Our menu handle
//
//  Returns:
//
//  Author:     jeffspr   13 Jan 1998
//
//  Notes:
//
HRESULT HrOnFolderInitMenuPopup(
    HWND    hwnd,
    UINT    idCmdFirst,
    INT     iIndex,
    HMENU   hmenu)
{
    HRESULT         hr              = S_OK;
    PCONFOLDPIDLVEC apidlSelected;
    PCONFOLDPIDLVEC apidlCache;

    // Get the currently selected object
    //
    hr = HrShellView_GetSelectedObjects(hwnd, apidlSelected);
    if (SUCCEEDED(hr))
    {
        // If we have a selection, clone it. Otherwise, we can live with a NULL apidlCache
        // (HrSetConnectDisconnectMenuItem and HrEnableOrDisableMenuItems both allow
        // NULL pidl arrays
        //
        if (!apidlSelected.empty())
        {
            // Clone the pidl array using the cache
            //
            hr = HrCloneRgIDL(apidlSelected, TRUE, TRUE, apidlCache);
            if (FAILED(hr))
            {
                TraceHr(ttidError, FAL, hr, FALSE, "HrCloneRgIDL failed on apidl in "
                        "HrOnFolderInitMenuPopup");
            }
        }

        // Only do this for the file menu (iIndex=0)
        if(0 == iIndex)
        {
            // Ignore the return from this, since we want to do both regardless.
            // We retrieve this value for debugging purposes only
            //
            hr = HrSetConnectDisconnectMenuItem(apidlCache, hmenu, idCmdFirst);
            if (FAILED(hr))
            {
                AssertSz(FALSE, "Failed to set the connect/disconnect menu items");
            }
        }

        HrUpdateMenu(hmenu, apidlCache, idCmdFirst);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnFolderInitMenuPopup");
    return hr;
}

HRESULT HrOnFolderMergeMenu(LPQCMINFO pqcm)
{
    HRESULT hr    = S_OK;
    HMENU   hmenu = NULL;

    hmenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(MENU_MERGE_INBOUND_DISCON));

    if (hmenu)
    {
        MergeMenu(_Module.GetResourceInstance(), POPUP_MERGE_FOLDER_CONNECTIONS, MENU_MERGE_INBOUND_DISCON, pqcm);
        DestroyMenu(hmenu);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnFolderMergeMenu");
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOnFolderGetButtons
//
//  Purpose:    Folder message handler for defview's DVM_GETBUTTONS
//
//  Arguments:
//      hwnd        [in]        Folder window handle
//      psf         [in]        Pointer to the IShellFolder interface
//      idCmdFirst  [in]        Our command ID base
//      ptButton    [in/out]    Button structures to fill
//
//  Returns:
//
//  Author:     jeffspr   15 Dec 1997
//
//  Notes:
//
HRESULT HrOnFolderGetButtons(
    HWND            hwnd,
    LPSHELLFOLDER   psf,
    UINT            idCmdFirst,
    LPTBBUTTON      ptButton)
{
    HRESULT             hr                  = S_OK;

#if ANY_FREEKIN_THING_IN_TOOLBAR
    UINT                i                   = 0;
    LRESULT             iBtnOffset          = 0;
    IShellBrowser *     psb                 = FileCabinet_GetIShellBrowser(hwnd);
    TBADDBITMAP         ab;

    PWSTR              pszToolbarStrings[2];

    for (DWORD dwLoop = 0; dwLoop < c_nToolbarButtons; dwLoop++)
    {
        // If this isn't a separator, load the text/tip string
        //
        if (!(c_tbConnections[dwLoop].fsStyle & TBSTYLE_SEP))
        {
            Assert(c_tbConnections[dwLoop].iString != -1);
            pszToolbarStrings[dwLoop] = (PWSTR) SzLoadIds(c_tbConnections[dwLoop].iString);
        }
    }

    // Add the toolbar button bitmap, get it's offset
    //
    ab.hInst = _Module.GetResourceInstance();
    ab.nID   = IDB_TB_SMALL;        // std bitmaps

    hr = psb->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, c_nToolbarButtons,
                             (LONG_PTR)&ab, &iBtnOffset);
    if (SUCCEEDED(hr))
    {
        for (i = 0; i < c_nToolbarButtons; i++)
        {
            ptButton[i] = c_tbConnections[i];

            if (!(c_tbConnections[i].fsStyle & TBSTYLE_SEP))
            {
                ptButton[i].idCommand += idCmdFirst;
                ptButton[i].iBitmap += (int) iBtnOffset;
                ptButton[i].iString = (INT_PTR) pszToolbarStrings[i];
            }
        }
    }
#endif // ANY_FREEKIN_THING_IN_TOOLBAR

    // We always want to return success, even if we added nothing.
    //
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnFolderGetButtonInfo
//
//  Purpose:    Folder message handler for defview's DVM_GETBUTTONINFO
//
//  Arguments:
//      ptbInfo [in/out]    Structure that we'll fill in (flags and button
//                          count)
//
//  Returns:
//
//  Author:     jeffspr   15 Dec 1997
//
//  Notes:
//
HRESULT HrOnFolderGetButtonInfo(TBINFO * ptbInfo)
{
    ptbInfo->uFlags = TBIF_PREPEND;
    ptbInfo->cbuttons = c_nToolbarButtons;  // size of toolbar array

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\iqinfo.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I Q I N F O . C P P
//
//  Contents:   IQueryInfo implementation for CConnectionFolderQueryInfo
//
//  Notes:
//
//  Author:     jeffspr   16 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include <nsres.h>
#include "shutil.h"



HRESULT CConnectionFolderQueryInfo::CreateInstance(
    REFIID  riid,
    void**  ppv)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr = E_OUTOFMEMORY;

    CConnectionFolderQueryInfo * pObj    = NULL;

    pObj = new CComObject <CConnectionFolderQueryInfo>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    return hr;
}

CConnectionFolderQueryInfo::CConnectionFolderQueryInfo()
{
    m_pidl.Clear();
}

CConnectionFolderQueryInfo::~CConnectionFolderQueryInfo()
{
}

HRESULT CConnectionFolderQueryInfo::GetInfoTip(
    DWORD dwFlags,
    WCHAR **ppwszTip)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT         hr      = NOERROR;

    if(m_pidl.empty())
    {
        hr = E_FAIL;
    }
    else
    {
        if (*m_pidl->PszGetDeviceNamePointer())
        {
            hr = HrDupeShellString(m_pidl->PszGetDeviceNamePointer(), ppwszTip);
        }
        else
        {
            hr = HrDupeShellString(m_pidl->PszGetNamePointer(), ppwszTip);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolderQueryInfo::GetInfoTip");
    return hr;
}

HRESULT CConnectionFolderQueryInfo::GetInfoFlags(
    DWORD *pdwFlags)
{
    TraceFileFunc(ttidShellFolderIface);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\ishellf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S H E L L F . C P P
//
//  Contents:   IShellFolder implementation for CConnectionFolder
//
//  Notes:      The IShellFolder interface is used to manage folders within
//              the namespace. Objects that support IShellFolder are
//              usually created by other shell folder objects, with the root
//              object (the Desktop shell folder) being returned from the
//              SHGetDesktopFolder function.
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "cfutils.h"    // Connections folder utilities
#include "foldres.h"
#include "ncnetcon.h"
#include "droptarget.h"
#include "ncperms.h"
#include "ncras.h"
#include "cmdtable.h"
#include "webview.h"

#define ENABLE_CONNECTION_TOOLTIP

const WCHAR c_szNetworkConnections[] = L"NetworkConnections";

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::ParseDisplayName
//
//  Purpose:    Translates a file object or folder's display name into an
//              item identifier.
//
//  Arguments:
//      hwndOwner       [in]    Handle of owner window
//      pbcReserved     [in]    Reserved
//      lpszDisplayName [in]    Pointer to diplay name
//      pchEaten        [out]   Pointer to value for parsed characters
//      ppidl           [out]   Pointer to new item identifier list
//      pdwAttributes   [out]   Address receiving attributes of file object
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Author:     jeffspr   18 Oct 1997

STDMETHODIMP CConnectionFolder::ParseDisplayName(
    HWND            hwndOwner,
    LPBC            pbcReserved,
    LPOLESTR        lpszDisplayName,
    ULONG *         pchEaten,
    LPITEMIDLIST *  ppidl,
    ULONG *         pdwAttributes)
{
    HRESULT hr = S_OK;
    TraceFileFunc(ttidShellFolder);

    if (!ppidl)
    {
        return E_POINTER;
    }

    *ppidl = NULL;

    if ((lpszDisplayName == NULL) ||
        (wcslen(lpszDisplayName) < (c_cchGuidWithTerm - 1)))
    {
        return E_INVALIDARG;
    }

    while (*lpszDisplayName == ':')
    {
        lpszDisplayName++;
    }

    if (*lpszDisplayName != '{')
    {
        return E_INVALIDARG;
    }

    GUID guid;

    if (SUCCEEDED(CLSIDFromString(lpszDisplayName, &guid)))
    {
        if (g_ccl.IsInitialized() == FALSE)
        {
            g_ccl.HrRefreshConManEntries();
        }

        PCONFOLDPIDL pidl;
        hr = g_ccl.HrFindPidlByGuid(&guid, pidl);
        if (S_OK == hr)
        {
            *ppidl = pidl.TearOffItemIdList();
            TraceTag(ttidShellFolderIface, "IShellFolder::ParseDisplayName generated PIDL: 0x%08x", *ppidl);
        }
        else
        {
            hr = E_FILE_NOT_FOUND;
        }
    }
    else
    {
        return(E_FAIL);
    }

    if (SUCCEEDED(hr) && pdwAttributes)
    {   
        LPCITEMIDLIST pidlArr[1];
        pidlArr[0] = *ppidl;
        hr = GetAttributesOf(1, pidlArr, pdwAttributes);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::EnumObjects
//
//  Purpose:    Determines the contents of a folder by creating an item
//              enumeration object (a set of item identifiers) that can be
//              retrieved using the IEnumIDList interface.
//
//  Arguments:
//      hwndOwner    [in]   Handle of owner window
//      grfFlags     [in]   Items to include in enumeration
//      ppenumIDList [out]  Pointer to IEnumIDList
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::EnumObjects(
    HWND            hwndOwner,
    DWORD           grfFlags,
    LPENUMIDLIST *  ppenumIDList)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT hr  = NOERROR;

    Assert(ppenumIDList);

    NETCFG_TRY
        // Create the IEnumIDList object (CConnectionFolderEnum)
        //
        hr = CConnectionFolderEnum::CreateInstance (
                IID_IEnumIDList,
                reinterpret_cast<void**>(ppenumIDList));

        if (SUCCEEDED(hr))
        {
            Assert(*ppenumIDList);

            // Call the PidlInitialize function to allow the enumeration
            // object to copy the list.
            //
            reinterpret_cast<CConnectionFolderEnum *>(*ppenumIDList)->PidlInitialize(
                FALSE, m_pidlFolderRoot, m_dwEnumerationType);

        }
        else
        {
            // On all failures, this should be NULL.
            if (*ppenumIDList)
            {
                ReleaseObj(*ppenumIDList);
            }

            *ppenumIDList = NULL;
        }

    NETCFG_CATCH(hr)
        
    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolder::EnumObjects");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::BindToObject
//
//  Purpose:    Creates an IShellFolder object for a subfolder.
//
//  Arguments:
//      pidl        [in]    Pointer to an ITEMIDLIST
//      pbcReserved [in]    Reserved - specify NULL
//      riid        [in]    Interface to return
//      ppvOut      [out]   Address that receives interface pointer;
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:      We don't need this function, since we don't have subfolders.
//
STDMETHODIMP CConnectionFolder::BindToObject(
    LPCITEMIDLIST   pidl,
    LPBC            pbcReserved,
    REFIID          riid,
    LPVOID *        ppvOut)
{
    TraceFileFunc(ttidShellFolder);

    // Note - If we add code here, then we ought to param check pidl
    //
    Assert(pidl);

    *ppvOut = NULL;

    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::BindToStorage
//
//  Purpose:    Reserved for a future use. This method should
//              return E_NOTIMPL.
//
//  Arguments:
//      pidl        []  Pointer to an ITEMIDLIST
//      pbcReserved []  Reservedspecify NULL
//      riid        []  Interface to return
//      ppvObj      []  Address that receives interface pointer);
//
//  Returns:    E_NOTIMPL always
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::BindToStorage(
    LPCITEMIDLIST   pidl,
    LPBC            pbcReserved,
    REFIID          riid,
    LPVOID *        ppvObj)
{
    TraceFileFunc(ttidShellFolder);

    // Note - If we add code here, then we ought to param check pidl
    //
    Assert(pidl);

    *ppvObj = NULL;

    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::CompareIDs
//
//  Purpose:    Determines the relative ordering of two file objects or
//              folders, given their item identifier lists.
//
//  Arguments:
//      lParam [in]     Type of comparison to perform
//      pidl1  [in]     Address of ITEMIDLIST structure
//      pidl2  [in]     Address of ITEMIDLIST structure
//
//  Returns:    Returns a handle to a result code. If this method is
//              successful, the CODE field of the status code (SCODE) has
//              the following meaning:
//
//              CODE field          Meaning
//              ----------          -------
//              Less than zero      The first item should precede the second
//                                  (pidl1 < pidl2).
//              Greater than zero   The first item should follow the second
//                                  (pidl1 > pidl2)
//              Zero                The two items are the same (pidl1 = pidl2)
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:      Passing 0 as the lParam indicates sort by name.
//              0x00000001-0x7fffffff are for folder specific sorting rules.
//              0x80000000-0xfffffff are used the system.
//
STDMETHODIMP CConnectionFolder::CompareIDs(
    LPARAM          lParam,
    LPCITEMIDLIST   pidl1,
    LPCITEMIDLIST   pidl2)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT         hr          = S_OK;
    int             iCompare    = 0;
    CONFOLDENTRY    pccfe1;
    CONFOLDENTRY    pccfe2;
    PCONFOLDPIDL    pcfp1;
    PCONFOLDPIDL    pcfp2;
    ConnListEntry   cle1;
    ConnListEntry   cle2;
    PCWSTR          pszString1  = NULL;
    PCWSTR          pszString2  = NULL;
    INT             iStringID1  = 0;
    INT             iStringID2  = 0;

    hr = pcfp1.InitializeFromItemIDList(pidl1);
    if (SUCCEEDED(hr))
    {
        hr = pcfp2.InitializeFromItemIDList(pidl2);
    }
    
    // Make sure that the pidls passed in are our pidls.
    //
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (WIZARD_NOT_WIZARD != pcfp1->wizWizard && WIZARD_NOT_WIZARD != pcfp2->wizWizard)
    {
        hr = ResultFromShort(0);

        if (pcfp1->wizWizard > pcfp2->wizWizard)
            hr = ResultFromShort(-1);

        if (pcfp1->wizWizard < pcfp2->wizWizard)
            hr = ResultFromShort(1);

        goto Exit;
    }

    // If the first item is a wizard, then it comes first.
    //
    if (WIZARD_NOT_WIZARD != pcfp1->wizWizard)
    {
        hr = ResultFromShort(-1);
        goto Exit;
    }

    // If the second item is a wizard, then, well, you get the picture.
    //
    if (WIZARD_NOT_WIZARD != pcfp2->wizWizard)
    {
        hr = ResultFromShort(1);
        goto Exit;
    }

    // Note: (jeffspr) & SHC... should be removed once Victor Tan checks in a fix 
    // for the IShellFolder2 params being used in IShellFolder
    //
    switch(lParam & SHCIDS_COLUMNMASK)
    {
        case ICOL_NAME:
            {
                // Check the name. If the name is the same, then we need to
                // check the GUID as well, because we HAVE TO allow duplicate names,
                // and this function is used to uniquely identify connections for
                // notification purposes
                //
                LPCWSTR szPcfpName1 = pcfp1->PszGetNamePointer() ? pcfp1->PszGetNamePointer() : L"\0";
                LPCWSTR szPcfpName2 = pcfp2->PszGetNamePointer() ? pcfp2->PszGetNamePointer() : L"\0";

                iCompare = lstrcmpW(szPcfpName1, szPcfpName2);
                if (iCompare == 0)
                {
                    if (!InlineIsEqualGUID(pcfp1->guidId, pcfp2->guidId))
                    {
                        // Doesn't really matter which order we put them
                        // in, as long as we call them non-equal
                        iCompare = -1;
                    }
                }
            }
            break;

        case ICOL_TYPE:
            {
                MapNCMToResourceId(pcfp1->ncm, pcfp1->dwCharacteristics, &iStringID1);
                MapNCMToResourceId(pcfp2->ncm, pcfp2->dwCharacteristics, &iStringID2);
                pszString1 = (PWSTR) SzLoadIds(iStringID1);
                pszString2 = (PWSTR) SzLoadIds(iStringID2);
                if (pszString1 && pszString2)
                {
                    iCompare = lstrcmpW(pszString1, pszString2);
                }
            }
            break;

        case ICOL_STATUS:
            {
                WCHAR szString1[CONFOLD_MAX_STATUS_LENGTH];
                WCHAR szString2[CONFOLD_MAX_STATUS_LENGTH];
                MapNCSToComplexStatus(pcfp1->ncs, pcfp1->ncm, pcfp1->ncsm, pcfp1->dwCharacteristics, szString1, CONFOLD_MAX_STATUS_LENGTH, pcfp1->guidId);
                MapNCSToComplexStatus(pcfp2->ncs, pcfp2->ncm, pcfp1->ncsm, pcfp2->dwCharacteristics, szString2, CONFOLD_MAX_STATUS_LENGTH, pcfp2->guidId);
                iCompare = lstrcmpW(szString1, szString2);
            }
            break;

        case ICOL_DEVICE_NAME:
            {
                LPCWSTR szPcfpDeviceName1 = pcfp1->PszGetDeviceNamePointer() ? pcfp1->PszGetDeviceNamePointer() : L"\0";
                LPCWSTR szPcfpDeviceName2 = pcfp2->PszGetDeviceNamePointer() ? pcfp2->PszGetDeviceNamePointer() : L"\0";
                iCompare = lstrcmpW(szPcfpDeviceName1, szPcfpDeviceName2);
            }
            break;

        case ICOL_OWNER:
            {
                pszString1 = PszGetOwnerStringFromCharacteristics(pszGetUserName(), pcfp1->dwCharacteristics);
                pszString2 = PszGetOwnerStringFromCharacteristics(pszGetUserName(), pcfp2->dwCharacteristics);
                iCompare = lstrcmpW(pszString1, pszString2);
            }
            break;

        case ICOL_PHONEORHOSTADDRESS:
            {
                LPCWSTR szPcfpPhoneHostAddress1 = pcfp1->PszGetPhoneOrHostAddressPointer() ? pcfp1->PszGetPhoneOrHostAddressPointer() : L"\0";
                LPCWSTR szPcfpPhoneHostAddress2 = pcfp2->PszGetPhoneOrHostAddressPointer() ? pcfp2->PszGetPhoneOrHostAddressPointer() : L"\0";
                iCompare = lstrcmpW(szPcfpPhoneHostAddress1, szPcfpPhoneHostAddress2);
            }
            break;

        default:
//            AssertFmt(FALSE, FAL, "Shell bug - Sorting on unknown category. Column = %x", (lParam & SHCIDS_COLUMNMASK));
            hr = E_INVALIDARG;
            break;
    }


    if (SUCCEEDED(hr))
    {
        hr = ResultFromShort(iCompare);
    }

Exit:
    // If these were allocated instead of cached, delete them
    //
    TraceHr(ttidError, FAL, hr,
            (ResultFromShort(-1) == hr) || (ResultFromShort(1) == hr),
            "CConnectionFolder::CompareIDs");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::CreateViewObject
//
//  Purpose:    Creates a view object of a folder.
//
//  Arguments:
//      hwndOwner [in]      Handle of owner window
//      riid      [in]      Interface identifier
//      ppvOut    [none]    Reserved
//
//  Returns:    Returns NOERROR if successful or an OLE defined error
//              value otherwise.
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::CreateViewObject(
    HWND        hwndOwner,
    REFIID      riid,
    LPVOID *    ppvOut)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT hr  = E_NOINTERFACE;

    Assert(ppvOut);
    Assert(this);

    // Pre-initialize the out param, per OLE guidelines
    //
    *ppvOut = NULL;

    if (riid == IID_IShellView)
    {
        if (FHasPermission(NCPERM_OpenConnectionsFolder))
        {
            SFV_CREATE sfv = {0};
            sfv.cbSize         = sizeof(sfv);
            sfv.pshf           = dynamic_cast<IShellFolder2*>(this);
            sfv.psfvcb         = dynamic_cast<IShellFolderViewCB*>(this);

            // Note: The shell never gets around to freeing the last view
            //          when shutting down...
            //
            hr = SHCreateShellFolderView(&sfv, &m_pShellView);
            if (SUCCEEDED(hr))
            {
                *ppvOut = m_pShellView;
                DWORD   dwErr   = 0;

                // Get the state of the "ManualDial" flag from RAS
                // so we can initialize our global
                //
                dwErr = RasUserGetManualDial(
                    hwndOwner,
                    FALSE,
                    (PBOOL) (&g_fOperatorAssistEnabled));

                // Ignore the error (don't shove it in the Hr), because
                // we still want to run even if we failed to get the value
                // Trace it, though
                Assert(dwErr == 0);
                TraceHr(ttidShellFolder, FAL, HRESULT_FROM_WIN32(dwErr), FALSE,
                        "RasUserGetManualDial call from CreateViewObject");
            }
        }
        else
        {
            TraceTag(ttidShellFolder, "No permission to open connections folder (FHasPermission returned 0)");
            AssertSz(FALSE, "get off!");

            if (hwndOwner)
            {
                NcMsgBox(_Module.GetResourceInstance(), hwndOwner,
                    IDS_CONFOLD_WARNING_CAPTION,
                    IDS_CONFOLD_NO_PERMISSIONS_FOR_OPEN,
                    MB_ICONEXCLAMATION | MB_OK);

                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // user saw the error
            }
            else
            {
                hr = E_ACCESSDENIED;
            }
        }
    }
    else if (riid == IID_IContextMenu)
    {
        // Create our context menu object for the background CMs.
        //
        hr = CConnectionFolderContextMenu::CreateInstance (
                IID_IContextMenu,
                reinterpret_cast<void**>(ppvOut),
                CMT_BACKGROUND,
                hwndOwner,
                PCONFOLDPIDLVEC(NULL),
                this);
        if (SUCCEEDED(hr))
        {
            Assert(*ppvOut);
        }
     }
     else if (riid == IID_ICategoryProvider)
     {
         // Create our context menu object for the background CMs.
         //
         
         CComPtr<IDefCategoryProvider> pDevCategoryProvider;
         hr = CoCreateInstance(CLSID_DefCategoryProvider, NULL, CLSCTX_ALL, IID_IDefCategoryProvider, reinterpret_cast<LPVOID *>(&pDevCategoryProvider));
         if (SUCCEEDED(hr))
         {
             
             SHCOLUMNID pscidType, pscidPhoneOrHostAddress;
             MapColumnToSCID(ICOL_TYPE, &pscidType);
             MapColumnToSCID(ICOL_PHONEORHOSTADDRESS, &pscidPhoneOrHostAddress);
             
             SHCOLUMNID pscidExclude[2];
             pscidExclude[0].fmtid = GUID_NETSHELL_PROPS;
             pscidExclude[0].pid   = ICOL_PHONEORHOSTADDRESS;
             
             pscidExclude[1].fmtid = GUID_NULL;
             pscidExclude[1].pid   = 0;
             
             CATLIST catList[] = 
             {
                 {&GUID_NULL, NULL}
             };
             
             if (SUCCEEDED(hr))
             {
                 pDevCategoryProvider->Initialize(&GUID_NETSHELL_PROPS,
                     &pscidType,
                     pscidExclude,
                     NULL,
                     catList,
                     this);
                 
                 hr = pDevCategoryProvider->QueryInterface(IID_ICategoryProvider, ppvOut);
             }
         }
     }
     else
     {
         goto Exit;
     }

Exit:

    TraceHr(ttidError, FAL, hr, (E_NOINTERFACE == hr),
            "CConnectionFolder::CreateViewObject");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::GetAttributesOf
//
//  Purpose:    Retrieves the attributes that all passed-in objects (file
//              objects or subfolders) have in common.
//
//  Arguments:
//      cidl     [in]   Number of file objects
//      apidl    [in]   Pointer to array of pointers to ITEMIDLIST structures
//      rgfInOut [out]  Address of value containing attributes of the
//                      file objects
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetAttributesOf(
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    ULONG *         rgfInOut)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT         hr              = S_OK;
    ULONG           rgfMask         = 0;
    PCONFOLDPIDL    pcfp;

    if (cidl > 0)
    {
        PCONFOLDPIDLVEC pcfpVec;
        hr = PConfoldPidlVecFromItemIdListArray(apidl, cidl, pcfpVec);
        if (FAILED(hr))
        {
            return E_INVALIDARG;
        }
        
        // Prepopulate with all values (removed CANCOPY and CANMOVE)
        //
        rgfMask =   SFGAO_CANDELETE |
                    SFGAO_CANRENAME     |
                    SFGAO_CANLINK       |
                    SFGAO_HASPROPSHEET;

        // Disable propsheets for > 1 connection
        //
        if (cidl > 1)
        {
            rgfMask &= ~SFGAO_HASPROPSHEET;
        }

        PCONFOLDPIDLVEC::const_iterator iterLoop;
        for (iterLoop = pcfpVec.begin(); iterLoop != pcfpVec.end(); iterLoop++)
        {
            // Translate the PIDL to our struct, and check for wizard inclusion.
            // If so, then we don't support anything but "link". If not, then
            // we support all of the standard actions

            const PCONFOLDPIDL& pcfp = *iterLoop;
            if(!pcfp.empty())
            {
                if (((*rgfInOut) & SFGAO_VALIDATE))
                {
                    ConnListEntry cleDontCare;
                    hr = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), cleDontCare);
                    if (hr != S_OK)
                    {
                        // Note: Remove this when we get RAS notifications, because
                        // we will ALWAYS have the information we need to find the connections
                        // We're doing this because the CM folks are creating RAS icons on the
                        // desktop without us knowing about it.
                        //
                        // If we didn't find it, then flush the cache and try again.
                        //
                        if (S_FALSE == hr)
                        {
                            hr = g_ccl.HrRefreshConManEntries();
                            if (SUCCEEDED(hr))
                            {
                                hr = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), cleDontCare);
                                if (hr != S_OK)
                                {
                                    hr = E_FAIL;
                                    goto Exit;
                                }
                            }
                        }
                        else
                        {
                            hr = E_FAIL;
                            goto Exit;
                        }
                    }
                }

                if (WIZARD_NOT_WIZARD != pcfp->wizWizard)
                {
                    // No support for delete/rename/etc, since it's the wizard.
                    // However, we want to provide our own "delete" warning when the
                    // wizard is selected along with deleteable connections
                    //
                    rgfMask = SFGAO_CANLINK | SFGAO_CANDELETE;
                }

                if (pcfp->dwCharacteristics & NCCF_BRANDED)
                {
                    if ( !fIsConnectedStatus(pcfp->ncs) && (pcfp->ncs != NCS_DISCONNECTING) )
                    {
                        rgfMask |= SFGAO_GHOSTED;
                    }
                }

                if (pcfp->dwCharacteristics & NCCF_INCOMING_ONLY)
                {
                    rgfMask &= ~SFGAO_CANLINK;
                }

                // Mask out the unavailable attributes for this connection
                //
                if (!(pcfp->dwCharacteristics & NCCF_ALLOW_RENAME) || !HasPermissionToRenameConnection(pcfp))
                {
                    rgfMask &= ~SFGAO_CANRENAME;
                }

    #if 0   // If I mask this out, I can't give user feedback for objects that can't be deleted.
                if (pcfp->dwCharacteristics & NCCF_ALLOW_REMOVAL)
                {
                    rgfMask |= SFGAO_CANDELETE;
                }
    #endif
            }
        }
    }
    else
    {
        // Apparently, we're called with 0 objects to indicate that we're
        // supposed to return flags for the folder itself, not an individual
        // object. Weird.
        rgfMask = SFGAO_CANCOPY   |
                  SFGAO_CANDELETE |
                  SFGAO_CANMOVE   |
                  SFGAO_CANRENAME |
                  SFGAO_DROPTARGET;
    }

Exit:
    if (SUCCEEDED(hr))
    {
        *rgfInOut &= rgfMask;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::GetUIObjectOf
//
//  Purpose:    Creates a COM object that can be used to carry out actions
//              on the specified file objects or folders, typically, to
//              create context menus or carry out drag-and-drop operations.
//
//  Arguments:
//      hwndOwner [in]      Handle to owner window
//      cidl      [in]      Number of objects specified in apidl
//      apidl     [in]      Pointer to an array of pointers to an ITEMIDLIST
//      riid      [in]      Interface to return
//      prgfInOut [none]    Reserved
//      ppvOut    [out]     Address to receive interface pointer
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetUIObjectOf(
    HWND            hwndOwner,
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    REFIID          riid,
    UINT *          prgfInOut,
    LPVOID *        ppvOut)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT hr  = E_NOINTERFACE;

    NETCFG_TRY
        
        if (cidl >= 1)
        {
            Assert(apidl);
            Assert(apidl[0]);
            Assert(ppvOut);

            if (riid == IID_IDataObject)
            {
                // Need to initialize so the SUCCEEED check below doesn't fail.
                //
                hr = S_OK;

                if (m_pidlFolderRoot.empty())
                {
                    hr = HrGetConnectionsFolderPidl(m_pidlFolderRoot);
                }
                
                if (SUCCEEDED(hr))
                {
                    Assert(!m_pidlFolderRoot.empty());

                    // Internal IDataObject impl removed. Replaced with common
                    // shell code.
                    //
                    hr = CIDLData_CreateFromIDArray(m_pidlFolderRoot.GetItemIdList(), cidl, apidl, (IDataObject **) ppvOut);
                }
            }
            else if (riid == IID_IContextMenu)
            {
                PCONFOLDPIDLVEC pcfpVec;
                hr = PConfoldPidlVecFromItemIdListArray(apidl, cidl, pcfpVec);
                if (FAILED(hr))
                {
                    return E_INVALIDARG;
                }
                
                // Create our context menu object for the background CMs.
                //
                if (SUCCEEDED(hr))
                {
                    hr = CConnectionFolderContextMenu::CreateInstance (
                            IID_IContextMenu,
                            reinterpret_cast<void**>(ppvOut),
                            CMT_OBJECT,
                            hwndOwner,
                            pcfpVec,
                            this);
                    if (SUCCEEDED(hr))
                    {
                        Assert(*ppvOut);
                    }
                    else
                    {
                        hr = E_NOINTERFACE;
                    }
                }
            }
            else if (riid == IID_IExtractIconA || riid == IID_IExtractIconW)
            {
                if (cidl == 1)
                {
                    hr = CConnectionFolderExtractIcon::CreateInstance (
                            apidl[0],
                            riid,
                            reinterpret_cast<void**>(ppvOut));

                    if (SUCCEEDED(hr))
                    {
                        Assert(*ppvOut);
                    }
                }
                else
                {
                    hr = E_NOINTERFACE;
                }
            }
            else if (riid == IID_IDropTarget)
            {
                hr = E_NOINTERFACE;
            }
            else if (riid == IID_IQueryAssociations)
            {
                CComPtr<IQueryAssociations> pQueryAssociations;

                hr = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, reinterpret_cast<LPVOID *>(&pQueryAssociations));
                if (SUCCEEDED(hr))
                {
                    hr = pQueryAssociations->Init(0, c_szNetworkConnections, NULL, NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = pQueryAssociations->QueryInterface(IID_IQueryAssociations, ppvOut);
                    }
                }
            }
            else if (riid == IID_IQueryInfo)
            {
    #ifdef ENABLE_CONNECTION_TOOLTIP
                if (cidl == 1)
                {
                    PCONFOLDPIDLVEC pcfpVec;
                    hr = PConfoldPidlVecFromItemIdListArray(apidl, cidl, pcfpVec);
                    if (FAILED(hr))
                    {
                        return E_INVALIDARG;
                    }
                    
                    const PCONFOLDPIDL& pcfp = *pcfpVec.begin();

                    // Create the IQueryInfo interface
                    hr = CConnectionFolderQueryInfo::CreateInstance (
                            IID_IQueryInfo,
                            reinterpret_cast<void**>(ppvOut));

                    if (SUCCEEDED(hr))
                    {
                        Assert(*ppvOut);

                        reinterpret_cast<CConnectionFolderQueryInfo *>
                            (*ppvOut)->PidlInitialize(*pcfpVec.begin());

                        // Normalize return code
                        //
                        hr = NOERROR;
                    }
                }
                else
                {
                    AssertSz(FALSE, "GetUIObjectOf asked for query info for more than one item!");
                    hr = E_NOINTERFACE;
                }
    #else
                hr = E_NOINTERFACE;
    #endif // ENABLE_CONNECTION_TOOLTIP

            }
            else
            {
                TraceTag(ttidShellFolder, "CConnectionFolder::GetUIObjectOf asked for object "
                         "that it didn't know how to create. 0x%08x", riid.Data1);

                hr = E_NOINTERFACE;
            }
        }

        if (FAILED(hr))
        {
            *ppvOut = NULL;
        }

    NETCFG_CATCH(hr)
        
    TraceHr(ttidError, FAL, hr, (hr == E_NOINTERFACE), "CConnectionFolder::GetUIObjectOf");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::GetDisplayNameOf
//
//  Purpose:    Retrieves the display name for the specified file object or
//              subfolder, returning it in a STRRET structure.
//
//  Arguments:
//      pidl   [in]     Pointer to an ITEMIDLIST
//      uFlags [in]     Type of display to return
//      lpName [out]    Pointer to a STRRET structure
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetDisplayNameOf(
    LPCITEMIDLIST   pidl,
    DWORD           uFlags,
    LPSTRRET        lpName)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT         hr              = S_OK;
    PWSTR           pszStrToCopy    = NULL;

    Assert(lpName);

    if (!pidl || !lpName)
    {
        return E_INVALIDARG;
    }

    PCONFOLDPIDL   pcfpLatestVersion;
    PCONFOLDPIDL   pcfpLatestVersionCached;
    PCONFOLDPIDL98 pcfp98;

    CONFOLDPIDLTYPE cfpt = GetPidlType(pidl);
    switch (cfpt)
    {
        case PIDL_TYPE_V1:
        case PIDL_TYPE_V2:
            if (FAILED(pcfpLatestVersion.InitializeFromItemIDList(pidl)))
            {
               return E_INVALIDARG;
            }
            break;
        case PIDL_TYPE_98: 
            if (FAILED(pcfp98.InitializeFromItemIDList(pidl)))
            {
                return E_INVALIDARG;
            }
            break;

        default:
            AssertSz(FALSE, "CConnectionFolder::GetDisplayNameOf - Invalid PIDL");
            return E_INVALIDARG;
            break;
    }

    if ( (PIDL_TYPE_V1 == cfpt) || (PIDL_TYPE_V2 == cfpt) )
    {
    #ifdef DBG
        // Throw these in here just so I can quickly peek at the values
        // set while I'm dorking around in the debugger.
        //
        DWORD   dwInFolder          = (uFlags & SHGDN_INFOLDER);
        DWORD   dwForAddressBar     = (uFlags & SHGDN_FORADDRESSBAR);
        DWORD   dwForParsing        = (uFlags & SHGDN_FORPARSING);
    #endif

        // Find the correct string for the display name. For the wizard, we get it
        // from the resources. Otherwise, we use the actual connection name
        //
        lpName->uType = STRRET_WSTR;

        if (uFlags & SHGDN_FORPARSING)
        {
            lpName->pOleStr = (LPWSTR)SHAlloc(c_cbGuidWithTerm);

            if (lpName->pOleStr == NULL)
            {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            if (StringFromGUID2(pcfpLatestVersion->clsid, lpName->pOleStr, c_cbGuidWithTerm) == 0)
            {
                return(ERROR_INVALID_NAME);
            }

            return(S_OK);
        }
        else if (WIZARD_MNC == pcfpLatestVersion->wizWizard)
        {
            pszStrToCopy = (PWSTR) SzLoadIds(IDS_CONFOLD_WIZARD_DISPLAY_NAME);
        }
        else if (WIZARD_HNW == pcfpLatestVersion->wizWizard)
        {
            pszStrToCopy = (PWSTR) SzLoadIds(IDS_CONFOLD_HOMENET_WIZARD_DISPLAY_NAME);
        }
        else
        {
            hr = g_ccl.HrGetCachedPidlCopyFromPidl(pcfpLatestVersion, pcfpLatestVersionCached);
            if (S_OK == hr)
            {
                pszStrToCopy = pcfpLatestVersionCached->PszGetNamePointer();
            }
            else
            {
                pszStrToCopy = pcfpLatestVersion->PszGetNamePointer();
                hr = S_OK;
            }
        }

        Assert(pszStrToCopy);

        // Allocate a new POLESTR block, which the shell can then free,
        // and copy the displayable portion to it.
        //
        // Note that &lpName->pOleStr is likely misaligned.
        //

        LPWSTR pOleStr;

        pOleStr = lpName->pOleStr;

        hr = HrDupeShellString(pszStrToCopy, &pOleStr );

        lpName->pOleStr = pOleStr;
    }
    else if (PIDL_TYPE_98 == cfpt)
    {
        // Raid#214057, handle win98 pidl for shortcuts
        // Return the offset to the string because we store the display
        // name in the opaque structure.

        lpName->uType = STRRET_OFFSET;
        lpName->uOffset = _IOffset(CONFOLDPIDL98, szaName);
    }
    else
    {
        // not a valid connections pidl (neither Win2K nor Win98).
        //
        hr = E_INVALIDARG;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolder::GetDisplayNameOf");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::SetNameOf
//
//  Purpose:    Changes the name of a file object or subfolder, changing its
//              item identifier in the process.
//
//  Arguments:
//      hwndOwner [in]      Handle of owner window
//      pidl      [in]      Pointer to an ITEMIDLIST structure
//      lpszName  [in]      Pointer to string specifying new display name
//      uFlags    [in]      Type of name specified in lpszName
//      ppidlOut  [out]     Pointer to new ITEMIDLIST
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::SetNameOf(
    HWND            hwndOwner,
    LPCITEMIDLIST   pidlShell,
    LPCOLESTR       lpszName,
        DWORD           uFlags,
    LPITEMIDLIST *  ppidlOut)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT             hr          = NOERROR;
    /*
    PWSTR              pszWarning  = NULL;
    INetConnection *    pNetCon     = NULL;
    LPITEMIDLIST        pidlNew     = NULL;
    BOOL                fRefresh    = FALSE;
    BOOL                fActivating = FALSE;
    PCONFOLDENTRY      pccfe       = NULL;
    */
    PCONFOLDPIDL        pcfp;

    Assert(hwndOwner);
    Assert(pidlShell);
    Assert(lpszName);

    if (!pidlShell && !lpszName)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // check lpszName for validity

        if (!FIsValidConnectionName(lpszName))
        {
            (void) NcMsgBox(
                _Module.GetResourceInstance(),
                hwndOwner,
                IDS_CONFOLD_RENAME_FAIL_CAPTION,
                IDS_CONFOLD_RENAME_INVALID,
                MB_OK | MB_ICONEXCLAMATION);
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
        }

        if (SUCCEEDED(hr))
        {
            // Get what's current from the cache so rename works properly
            //
            PCONFOLDPIDL pcfpShell;
            hr = pcfpShell.InitializeFromItemIDList(pidlShell);
            if (SUCCEEDED(hr))
            {
                hr = g_ccl.HrGetCachedPidlCopyFromPidl(pcfpShell, pcfp);
                if (SUCCEEDED(hr))
                {
                    PCONFOLDPIDL pidlOut;
                    hr = HrRenameConnectionInternal(pcfp, m_pidlFolderRoot, lpszName, TRUE, hwndOwner, pidlOut);
                    if ( (ppidlOut) && (SUCCEEDED(hr)) )
                    {
                        *ppidlOut = pidlOut.TearOffItemIdList();
                    }
                }
            }
        }
    }

    if (FAILED(hr) && (ppidlOut))
    {
        *ppidlOut = NULL;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolder::SetNameOf");
    return hr;
}

STDMETHODIMP CConnectionFolder::MessageSFVCB(
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam)
{
    TraceFileFunc(ttidShellFolder);
    
    HRESULT hr = RealMessage(uMsg, wParam, lParam);
    if (FAILED(hr))
    {
        switch (uMsg)
        {
        case DVM_INVOKECOMMAND:
            if ((CMIDM_RENAME == wParam) && m_hwndMain && m_pShellView)
            {
                PCONFOLDPIDLVEC apidlSelected;
                PCONFOLDPIDLVEC apidlCache;
                hr = HrShellView_GetSelectedObjects(m_hwndMain, apidlSelected);
                if (SUCCEEDED(hr))
                {
                    // If there are objects, try to get the cached versions
                    if (!apidlSelected.empty())
                    {   
                        hr = HrCloneRgIDL(apidlSelected, TRUE, TRUE, apidlCache);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    Assert(apidlCache.size() == 1);
                    if (apidlCache.size() == 1)
                    {
                        hr = m_pShellView->SelectItem(apidlCache[0].GetItemIdList(), SVSI_EDIT);
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
            }
            break;

        case SFVM_HWNDMAIN:
            // _hwndMain = (HWND)lParam;
            hr = S_OK;
            break;
        }
    }
    return hr;
}

/*
//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::GetOverlayIndex
//
//  Purpose:    Adds icon overlays to connections that need them
//
//  Arguments:
//      pidlItem [in]     Pidl to item in question
//      pIndex [out]      Address of overlay index into system image list
//        
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise.
//
//  Author:     kenwic   10 May 2000 created, support for sharing overlay
//
//  Notes:
//

STDMETHODIMP CConnectionFolder::GetOverlayIndex(
    LPCITEMIDLIST pidlItem,
    int* pIndex)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT hResult = E_FAIL;
    *pIndex = -1;

    // check to see if connection is sharing, and if so add sharing hand overlay
    // i can't call HrNetConFromPidl, because it asserts if passed the wizard icon
    
    PCONFOLDPIDL pcfpItem;
    pcfpItem.InitializeFromItemIDList(pidlItem);

    CONFOLDENTRY pConnectionFolderEntry;
    hResult = pcfpItem.ConvertToConFoldEntry(pConnectionFolderEntry);
    if(SUCCEEDED(hResult))
    {
        if(FALSE == pConnectionFolderEntry.GetWizard()) // sharing the wizard is not yet supported
        {
            if(NCCF_SHARED & pConnectionFolderEntry.GetCharacteristics())
            {
                *pIndex = SHGetIconOverlayIndex(NULL, IDO_SHGIOI_SHARE);
                hResult = S_OK;
            }
            else
            {
                hResult = E_FAIL; // the docs for IShellIconOverlay are wrong, we must return failure to deny the icon
            }
        }
        else
        {
            hResult = E_FAIL;
        }
    }
    
    TraceHr(ttidShellFolder, FAL, hResult, TRUE, "CConnectionFolder::GetOverlayIndex");
    return hResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::GetOverlayIconIndex
//
//  Purpose:    Adds icon overlays to connections that need them
//
//  Arguments:
//      pidlItem [in]     Pidl to item in question
//      pIconIndex [out]      Address of index into system image list
//        
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise.
//
//  Author:     kenwic   10 May 2000 created
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetOverlayIconIndex(
    LPCITEMIDLIST pidlItem,
    int* pIconIndex)
{
    TraceFileFunc(ttidShellFolder);

    *pIconIndex = -1;

    HRESULT hResult = GetOverlayIndex(pidlItem, pIconIndex);
    if(SUCCEEDED(hResult))
    {
        *pIconIndex = INDEXTOOVERLAYMASK(*pIconIndex);
    }

    TraceHr(ttidShellFolder, FAL, hResult, TRUE, "CConnectionFolder::GetOverlayIconIndex");
    return hResult;
}*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\legacymenus.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       L E G A C Y M E N U S . C P P
//
//  Contents:   Legacy menu implementation for debug purposes
//              This is used to double check the new command handler
//              implementation against the new one.
//
//              Most of the code from the previous cmdhandler.cpp has been
//              moved to this file.
//
//  Notes:
//
//  Author:     deonb   8 Feb 2001
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#ifdef DBG // Make sure this is not called in release mode.

#include "foldinc.h"    // Standard shell\folder includes
#include "foldres.h"    // Folder resource IDs
#include "nsres.h"
#include "cmdtable.h"
#include "ncperms.h"    // For checking User's rights on actions/menu items
#include "cfutils.h"
#include "oncommand.h"
#include "hnetcfg.h"
#include "legacymenus.h"
#include "nsclsid.h"

#define TRACESTRLEN 65535

//---[ Prototypes ]-----------------------------------------------------------

VOID DoMenuItemExceptionLoop(
                             const PCONFOLDPIDLVEC& apidlSelected);

VOID DoMenuItemCheckLoop(VOID);

bool FEnableConnectDisconnectMenuItem(
                                      const PCONFOLDPIDL& pcfp,
                                      int             iCommandId);

HRESULT HrEnableOrDisableMenuItems(
    HWND            hwnd,
    const PCONFOLDPIDLVEC& apidlSelected,
    HMENU           hmenu,
    UINT            idCmdFirst);

BOOL IsBridgeInstalled(
    VOID);

struct ContextMenuEntry
{
    WIZARD              wizWizard;
    NETCON_MEDIATYPE    ncm;
    BOOL                fInbound;
    BOOL                fIsDefault;     // 1 if currently the default. 0 otherwise.
    NETCON_STATUS       ncs;
    INT                 iMenu;
    INT                 iVerbMenu;      // This flag is set if the context menu is for a shortcut object.
    INT                 iDefaultCmd;
};

static const ContextMenuEntry   c_CMEArray[] =
{
   //wizWizard
   // |    ncm
   // |    |       fInbound?
   // |    |         | fIsDefault?
   // |    |         |  |      Status (ncs)
   // |    |         |  |        |                     iMenu
   // |    |         |  |        |                      |                  iVerbMenu
   // |    |         |  |        |                      |                      |                  iDefaultCmd
   // |    |         |  |        |                      |                      |                      |
   // v    v         v  v        v                      v                      v                      v
  // wizard
    { WIZARD_MNC, NCM_NONE,   0, 0, (NETCON_STATUS)0,         MENU_WIZARD,       MENU_WIZARD_V,       CMIDM_NEW_CONNECTION },

  // incoming w/ no clients
    { WIZARD_NOT_WIZARD, NCM_NONE,   1, 0, NCS_DISCONNECTED,         MENU_INCOM_DISCON, MENU_INCOM_DISCON_V, CMIDM_PROPERTIES     },

  // Note: Temporary hack for CM connections
// DEONB: ISSUE: Removing hack for CM connections. This doesn't appear to be used anymore.
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 0, NCS_DISCONNECTED,         MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 0, NCS_CONNECTED,            MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 0, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 0, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 0, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 1, NCS_CONNECTED,            MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,    CMIDM_STATUS         },
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 1, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 1, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 1, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},

  // lan
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_DISCONNECTED,         MENU_LAN_DISCON   ,MENU_LAN_DISCON_V,CMIDM_ENABLE            },
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_CONNECTED,            MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_DISCONNECTING,        MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS         },
// DEONB: ISSUE: What on earth is an incoming LAN card???
//  { WIZARD_NOT_WIZARD, NCM_LAN,    1, 0, NCS_CONNECTED,            MENU_LAN_CON,      MENU_INCOM_CON_V,    CMIDM_STATUS         },
//  { WIZARD_NOT_WIZARD, NCM_LAN,    1, 0, NCS_DISCONNECTING,        MENU_LAN_CON,      MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_MEDIA_DISCONNECTED,   MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_INVALID_ADDRESS,      MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_HARDWARE_NOT_PRESENT, MENU_LAN_UNAVAIL,  MENU_LAN_UNAVAIL_V,  CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_HARDWARE_MALFUNCTION, MENU_LAN_UNAVAIL,  MENU_LAN_UNAVAIL_V,  CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_HARDWARE_DISABLED,    MENU_LAN_UNAVAIL,  MENU_LAN_UNAVAIL_V,  CMIDM_PROPERTIES     },

  // dialup
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 0, NCS_DISCONNECTED,         MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 0, NCS_CONNECTING,           MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 0, NCS_CONNECTED,            MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 0, NCS_DISCONNECTING,        MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 0, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 0, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 0, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },

    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 1, NCS_DISCONNECTED,         MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 1, NCS_CONNECTING,           MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 1, NCS_CONNECTED,            MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 1, NCS_DISCONNECTING,        MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 1, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 1, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 1, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},

  // dialup inbound
    { WIZARD_NOT_WIZARD, NCM_PHONE,  1, 0, NCS_CONNECTED,            MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  1, 0, NCS_DISCONNECTING,        MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },

  // isdn
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 0, NCS_DISCONNECTED,         MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 0, NCS_CONNECTING,           MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 0, NCS_CONNECTED,            MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 0, NCS_DISCONNECTING,        MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   1, 0, NCS_CONNECTED,            MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   1, 0, NCS_DISCONNECTING,        MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 0, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 0, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 0, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },

    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 1, NCS_DISCONNECTED,         MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 1, NCS_CONNECTING,           MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 1, NCS_CONNECTED,            MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 1, NCS_DISCONNECTING,        MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 1, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 1, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 1, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},

  // tunnel
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 0, NCS_DISCONNECTED,         MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 0, NCS_CONNECTING,           MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 0, NCS_CONNECTED,            MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 0, NCS_DISCONNECTING,        MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 1, 0, NCS_CONNECTED,            MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 1, 0, NCS_DISCONNECTING,        MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 0, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 0, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 0, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },

    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 1, NCS_DISCONNECTED,         MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 1, NCS_CONNECTING,           MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 1, NCS_CONNECTED,            MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 1, NCS_DISCONNECTING,        MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 1, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 1, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 1, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},

  // direct connect
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 0, NCS_DISCONNECTED,         MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 0, NCS_CONNECTING,           MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 0, NCS_CONNECTED,            MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 0, NCS_DISCONNECTING,        MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 1, 0, NCS_CONNECTED,            MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 1, 0, NCS_DISCONNECTING,        MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 0, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 0, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 0, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },

    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 1, NCS_DISCONNECTED,         MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 1, NCS_CONNECTING,           MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 1, NCS_CONNECTED,            MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 1, NCS_DISCONNECTING,        MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 1, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 1, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 1, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},

    // bridge - largely the same as lan
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_DISCONNECTED,         MENU_LAN_DISCON,   MENU_LAN_DISCON_V,   CMIDM_ENABLE         },
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_CONNECTING,           MENU_LAN_DISCON,   MENU_LAN_DISCON_V,   CMIDM_ENABLE         },
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_CONNECTED,            MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_DISCONNECTING,        MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS         },
// DEONB: ISSUE: What on earth is an incoming bridge???
//  { WIZARD_NOT_WIZARD, NCM_BRIDGE, 1, 0, NCS_CONNECTED,            MENU_LAN_CON,      MENU_INCOM_CON_V,    CMIDM_STATUS         },
//  { WIZARD_NOT_WIZARD, NCM_BRIDGE, 1, 0, NCS_DISCONNECTING,        MENU_LAN_CON,      MENU_INCOM_CON_V,    CMIDM_STATUS         },

    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_MEDIA_DISCONNECTED,   MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_INVALID_ADDRESS,      MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_HARDWARE_NOT_PRESENT, MENU_LAN_UNAVAIL,  MENU_LAN_UNAVAIL_V,  CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_HARDWARE_MALFUNCTION, MENU_LAN_UNAVAIL,  MENU_LAN_UNAVAIL_V,  CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_HARDWARE_DISABLED,    MENU_LAN_UNAVAIL,  MENU_LAN_UNAVAIL_V,  CMIDM_PROPERTIES     },

    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_RAS,  0, 0, NCS_DISCONNECTED,         MENU_SARAS_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_RAS,  0, 0, NCS_CONNECTING,           MENU_SARAS_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_RAS,  0, 0, NCS_CONNECTED,            MENU_SARAS_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_RAS,  0, 0, NCS_DISCONNECTING,        MENU_SARAS_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_RAS,  0, 0, NCS_HARDWARE_DISABLED,    MENU_SARAS_DISCON,  MENU_SARAS_DISCON, CMIDM_PROPERTIES       },

    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_LAN,    0, 0, NCS_DISCONNECTED,         MENU_SALAN_DISCON,   MENU_LAN_DISCON_V,   CMIDM_ENABLE      },
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_LAN,    0, 0, NCS_CONNECTED,            MENU_SALAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS      },
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_LAN,    0, 0, NCS_DISCONNECTING,        MENU_SALAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS      },
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_LAN,    0, 0, NCS_HARDWARE_DISABLED,    MENU_SALAN_DISCON,   MENU_SALAN_DISCON,  CMIDM_PROPERTIES   },

};

const DWORD g_dwContextMenuEntryCount = celems(c_CMEArray);

COMMANDTABLEENTRY   g_cteFolderCommands[] =
{
    // command id
    //    |                           valid when 0 items selected
    //    |                             |   valid when only wizard selected
    //    |                             |       |      valid when multiple items selected
    //    |                             |       |       |       command is currently enabled
    //    |                             |       |       |        |      new state (temp)
    //    |                             |       |       |        |       |
    //    |                             |       |       |        |       |
    //    |                             |       |       |        |       |
    //    |                             |       |       |        |       |
    //    v                             v       v       v        v       v
    //
    { CMIDM_NEW_CONNECTION,             true,   true,   true,   true,   true     },
    { CMIDM_CONNECT,                    false,  false,  false,  true,   true     },
    { CMIDM_ENABLE,                     false,  false,  false,  true,   true     },
    { CMIDM_DISCONNECT,                 false,  false,  false,  true,   true     },
    { CMIDM_DISABLE,                    false,  false,  false,  true,   true     },
    { CMIDM_STATUS,                     false,  false,  false,  true,   true     },
    { CMIDM_CREATE_BRIDGE,              true,   false,  true,   true,   true     },
    { CMIDM_ADD_TO_BRIDGE,              false,  false,  true,   true,   true     },
    { CMIDM_REMOVE_FROM_BRIDGE,         false,  false,  true,   true,   true     },
    { CMIDM_CREATE_SHORTCUT,            false,  true,   false,  true,   true     },
    { SFVIDM_FILE_LINK,                 false,  true,   false,  true,   true     },
    { CMIDM_DELETE,                     false,  false,  true,   true,   true     },
    { SFVIDM_FILE_DELETE,               false,  false,  true,   true,   true     },
    { CMIDM_RENAME,                     false,  false,  false,  true,   true     },
    { CMIDM_PROPERTIES,                 false,  false,  false,  true,   true     },
    { SFVIDM_FILE_PROPERTIES,           false,  false,  false,  true,   true     },
    { CMIDM_CREATE_COPY,                false,  false,  false,  true,   true     },
    { SFVIDM_FILE_RENAME,               false,  false,  false,  true,   true     },
    { CMIDM_SET_DEFAULT,                false,  false,  false,  true,   true     },
    { CMIDM_UNSET_DEFAULT,              false,  false,  false,  true,   true     },
    { CMIDM_FIX,                        false,  false,  false,  true,   true     },
    { CMIDM_CONMENU_ADVANCED_CONFIG,    true,   true,   false,  true,   true     },
    { CMIDM_CONMENU_CREATE_BRIDGE,      true,   false,  true,   true,   true     },
    { CMIDM_CONMENU_DIALUP_PREFS,       true,   true,   true,   true,   true     },
    { CMIDM_CONMENU_NETWORK_ID,         true,   true,   true,   true,   true     },
    { CMIDM_CONMENU_OPTIONALCOMPONENTS, true,   true,   true,   true,   true     },
    { CMIDM_CONMENU_OPERATOR_ASSIST,    true,   true,   true,   true,   true     },
    { CMIDM_ARRANGE_BY_NAME,            true,   true,   true,   true,   true     },
    { CMIDM_ARRANGE_BY_TYPE,            true,   true,   true,   true,   true     },
    { CMIDM_ARRANGE_BY_STATUS,          true,   true,   true,   true,   true     },
    { CMIDM_ARRANGE_BY_OWNER,           true,   true,   true,   true,   true     },
    { CMIDM_ARRANGE_BY_PHONEORHOSTADDRESS, true, true,  true,   true,   true,    },
    { CMIDM_ARRANGE_BY_DEVICE_NAME,     true,   true,   true,   true,   true     }
};

const DWORD g_nFolderCommandCount = celems(g_cteFolderCommands);

//+---------------------------------------------------------------------------
//
//  Member:     HrBuildMenuOldWay
//
//  Purpose:    Adds menu items to the specified menu. The menu items should
//              be inserted in the menu at the position specified by
//              indexMenu, and their menu item identifiers must be between
//              the idCmdFirst and idCmdLast parameter values.
//
//  Arguments:
//      hmenu      [in out] Handle to the menu. The handler should specify this
//                      handle when adding menu items
//      cfpl       [in] List of selected PIDLS
//      hwndOwner  [in] Window owner of the menu
//      cmt        [in] Menu type (CMT_OBJECT or CMT_BACKGROUND)
//      indexMenu  [in] Zero-based position at which to insert the first
//                      menu item.
//      idCmdFirst [in] Min value the handler can specify for a menu item
//      idCmdLast  [in] Max value the handler can specify for a menu item
//      fVerbsOnly [in] Verb only required
//
//  Returns:
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
HRESULT HrBuildMenuOldWay(IN OUT HMENU hmenu, IN PCONFOLDPIDLVEC& cfpl, IN HWND hwndOwner, IN CMENU_TYPE cmt, IN UINT indexMenu, IN DWORD idCmdFirst, IN UINT idCmdLast, IN BOOL fVerbsOnly)
{
    TraceFileFunc(ttidMenus);

    HRESULT hr = S_OK;

    INT     iMenuResourceId     = 0;
    INT     iPopupResourceId    = 0;
    QCMINFO qcm                 = {hmenu, indexMenu, idCmdFirst, idCmdLast};
    INT     iDefaultCmd         = 0;

    BOOL            fValidMenu          = FALSE;
    const PCONFOLDPIDL& pcfp = cfpl[0];
    DWORD           dwLoop  = 0;
    for (dwLoop = 0; (dwLoop < g_dwContextMenuEntryCount) && !fValidMenu; dwLoop++)
    {
        if (c_CMEArray[dwLoop].wizWizard == pcfp->wizWizard)
        {
            if (pcfp->wizWizard != WIZARD_NOT_WIZARD)
            {
                fValidMenu = TRUE;
            }
            else
            {
                // If the mediatype is the same
                //
                if (pcfp->ncm == c_CMEArray[dwLoop].ncm)
                {
                    // If the presence of the NCCF_INCOMING_ONLY characteristic (demoted to 0 | 1),
                    // matches the inbound flag
                    //
                    if ((!!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY)) ==
                        c_CMEArray[dwLoop].fInbound)
                    {
                        // If not the wizard, then we need to check the state of the connection
                        // as well.
                        //
                        if (pcfp->ncs == c_CMEArray[dwLoop].ncs)
                        {
                            if ((!!(pcfp->dwCharacteristics & NCCF_DEFAULT)) == c_CMEArray[dwLoop].fIsDefault)
                            {
                                fValidMenu = TRUE;
                            }
                        }
                    }
                }
            }
        }

        if (fValidMenu)
        {
            iPopupResourceId = 0;
            if (fVerbsOnly)
            {
                iMenuResourceId = c_CMEArray[dwLoop].iVerbMenu;
            }
            else
            {
                iMenuResourceId = c_CMEArray[dwLoop].iMenu;
            }

            iDefaultCmd = c_CMEArray[dwLoop].iDefaultCmd;
        }
    }

    if (fValidMenu)
    {
        MergeMenu(_Module.GetResourceInstance(),
                    iMenuResourceId,
                    iPopupResourceId,
                    (LPQCMINFO)&qcm);

        // Enable/Disable the menu items as appropriate. Ignore the return from this
        // as we're getting it for debugging purposes only.
        //
        hr = HrEnableOrDisableMenuItems(
            hwndOwner,
            cfpl,
            hmenu,
            idCmdFirst);

        if (CMT_OBJECT == cmt)
        {
            // $$REVIEW: Find out why I'm only doing this for CMT_OBJECT instead of for background.
            // Pre-icomtextm|mb combine, mb had this commented out.
            //
            SetMenuDefaultItem(hmenu, idCmdFirst + iDefaultCmd, FALSE);
        }

        hr = ResultFromShort(qcm.idCmdFirst - idCmdFirst);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

static const ContextMenuEntry  c_BadBadLegacyImplementationsToIgnore[] =
{
   //wizWizard
   // |    ncm
   // |    |         fInbound?
   // |    |           | fIsDefault?
   // |    |           |  |      Status (ncs)
   // |    |           |  |        |
   // v    v           v  v        v
    { WIZARD_NOT_WIZARD, NCM_LAN,      0, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_LAN,      1, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_LAN,      0, 0, NCS_DISCONNECTED,      0,0,0}, // Disabled "Status" menu item is also default.

    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_RAS,0,0, NCS_CONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_RAS,0,0, NCS_DISCONNECTING,  0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_LAN,0,0, NCS_DISCONNECTING,  0,0,0}, // Disabled "Status" menu item is also default.

    { WIZARD_NOT_WIZARD, NCM_BRIDGE,   0, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_BRIDGE,   0, 0, NCS_CONNECTING,        0,0,0}, // Disabled "Enable" menu item is also default.

    // Connection manager
    { WIZARD_NOT_WIZARD, NCM_NONE,     0, 0, NCS_DISCONNECTED,     0,0,0}, // Disabled "Connect" menu item is also default.


    { WIZARD_NOT_WIZARD, NCM_ISDN,     1, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_ISDN,     0, 0, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_ISDN,     0, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_ISDN,     0, 1, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_ISDN,     0, 1, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.

    { WIZARD_NOT_WIZARD, NCM_DIRECT,   1, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_DIRECT,   0, 0, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_DIRECT,   0, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_DIRECT,   0, 1, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_DIRECT,   0, 1, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.

    { WIZARD_NOT_WIZARD, NCM_TUNNEL,   1, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_TUNNEL,   0, 0, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_TUNNEL,   0, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_TUNNEL,   0, 1, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_TUNNEL,   0, 1, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.

    { WIZARD_NOT_WIZARD, NCM_PHONE,    1, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_PHONE,    0, 0, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_PHONE,    0, 1, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_PHONE,    0, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_PHONE,    0, 1, NCS_DISCONNECTING,     0,0,0}  // Disabled "Status" menu item is also default.
};

const DWORD g_dwBadBadLegacyImplementationsToIgnoreCount = celems(c_BadBadLegacyImplementationsToIgnore);

//+---------------------------------------------------------------------------
//
//  Member:     IsBadBadLegacyImplementation
//
//  Purpose:    Checks against the list of known bad legacy implementations
//              This is just for the Status field, which we can ignore
//
//  Arguments:
//      [in] cme     Context Menu Entry
//
//  Returns:
//      none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
BOOL IsBadBadLegacyImplementation(const ContextMenuEntry& cme)
{
    for (int x = 0; x < g_dwBadBadLegacyImplementationsToIgnoreCount; x++)
    {
        const ContextMenuEntry& bbliti = c_BadBadLegacyImplementationsToIgnore[x];
        if ( (cme.wizWizard  == bbliti.wizWizard) &&
             (cme.fInbound   == bbliti.fInbound) &&
             (cme.fIsDefault == bbliti.fIsDefault) &&
             (cme.ncs        == bbliti.ncs) &&
             (cme.ncm        == bbliti.ncm) )
        {
            return TRUE;
        }
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetMenuAsString
//
//  Purpose:    Gets the commands on a menu as a string.
//
//  Arguments:
//      [in] hMenu     Menu
//     [out] szMenu    Menu as a string
//
//  Returns:
//      none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
void GetHMenuAsString(HMENU hMenu, LPSTR lpszMenu)
{
    int cMenuItems = GetMenuItemCount(hMenu);
    Assert(lpszMenu);

    if (!cMenuItems)
    {
        strcpy(lpszMenu, "<empty>");
        return;
    }

    LPWSTR szTmp  = new WCHAR[TRACESTRLEN];
    LPSTR  szTmp2 = lpszMenu;
    DWORD  dwLen  = 0;
    for (int x = 0; x < cMenuItems; x++)
    {
        UINT nMenuID = GetMenuItemID(hMenu, x);

        GetMenuStringW(hMenu, nMenuID, szTmp, TRACESTRLEN, MF_BYCOMMAND );

        UINT uiState = GetMenuState(hMenu, nMenuID, MF_BYCOMMAND );

        WCHAR szExtra[MAX_PATH] = {L'\0'};
        if (MF_CHECKED & uiState)
        {
            wcscat(szExtra, L"MF_CHECKED ");
        }
        if (MF_DISABLED & uiState)
        {
            wcscat(szExtra, L"MF_DISABLED ");
        }
        if (MF_GRAYED & uiState)
        {
            wcscat(szExtra, L"MF_GRAYED ");
        }
        if (MF_HILITE & uiState)
        {
            wcscat(szExtra, L"MF_HILITE ");
        }
        if (MF_MENUBARBREAK & uiState)
        {
            wcscat(szExtra, L"MF_MENUBARBREAK ");
        }
        if (MF_MENUBREAK & uiState)
        {
            wcscat(szExtra, L"MF_MENUBREAK ");
        }
        if (MF_OWNERDRAW & uiState)
        {
            wcscat(szExtra, L"MF_OWNERDRAW ");
        }
        if (MF_POPUP & uiState)
        {
            wcscat(szExtra, L"MF_POPUP ");
        }
        if (MF_SEPARATOR & uiState)
        {
            wcscat(szExtra, L"MF_SEPARATOR ");
        }
        if (MF_DEFAULT & uiState)
        {
            wcscat(szExtra, L"MF_DEFAULT ");
        }

        dwLen = sprintf(szTmp2, "\r\n  %d. %S=%x (State:%08x = %S)", x+1, szTmp, nMenuID, uiState, szExtra);
        szTmp2 += dwLen;
    }
    AssertSz( (dwLen*2) < TRACESTRLEN, "Buffer overrun");
    delete[] szTmp;
}

//+---------------------------------------------------------------------------
//
//  Member:     TraceMenu
//
//  Purpose:    Trace the commands on a menu to the trace window.
//
//  Arguments:
//      [in] hmenu     Menu to be traced
//
//  Returns:
//      none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
void TraceMenu(TRACETAGID ttId, HMENU hMenu)
{
    LPSTR szMenu = new CHAR[TRACESTRLEN];
    GetHMenuAsString(hMenu, szMenu);

    TraceTag(ttId, "%s", szMenu);
    delete [] szMenu;
}

#define TRACEMENUS(ttid, hMenu1, hMenu2) \
        TraceTag(ttid, "Menu not identical to previous implementation: OLD:"); \
        TraceMenu(ttid, hMenu1); \
        TraceTag(ttid, "=== vs. NEW: === "); \
        TraceMenu(ttid, hMenu2);

//+---------------------------------------------------------------------------
//
//  Member:     HrAssertTwoMenusEqual
//
//  Purpose:    Asserts that 2 menus are equal by comparing.
//               1. Number of items
//               2. CmdID of each item
//               3. State flags of each item
//               4. String of each item
//
//  Arguments:
//      none
//
//  Returns:
//              S_OK is succeeded
//              E_FAIL if not
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:      Asserts on failure
//
HRESULT HrAssertTwoMenusEqual(HMENU hMenu1, HMENU hMenu2, UINT idCmdFirst, BOOL bIgnoreFlags, BOOL fPopupAsserts)
{
    TraceFileFunc(ttidMenus);

    TRACETAGID ttid = fPopupAsserts ? ttidError : ttidMenus;

    LPSTR szErr = new CHAR[TRACESTRLEN];
    int cMenuItems = GetMenuItemCount(hMenu1);
    if (cMenuItems != GetMenuItemCount(hMenu2))
    {
        TRACEMENUS(ttid, hMenu1, hMenu2);

        sprintf(szErr, "Two menus don't have the same number of items");
        TraceTag(ttidError, szErr);
        if (fPopupAsserts)
        {
            AssertSz(FALSE, szErr);
        }
        delete[] szErr;
        return E_FAIL;
    }

    for (int x = 0; x < cMenuItems; x++)
    {
        UINT nMenuID1 = GetMenuItemID(hMenu1, x);
        UINT nMenuID2 = GetMenuItemID(hMenu2, x);
        if (nMenuID1 != nMenuID2)
        {
            if (!(((nMenuID1-idCmdFirst == CMIDM_CREATE_BRIDGE) || (nMenuID2-idCmdFirst == CMIDM_CREATE_BRIDGE)) &&
                  ((nMenuID1-idCmdFirst == CMIDM_ADD_TO_BRIDGE) || (nMenuID2-idCmdFirst == CMIDM_ADD_TO_BRIDGE)) )) // These are equivalent between old & new.
            {

                TRACEMENUS(ttid, hMenu1, hMenu2);
                sprintf(szErr, "Two menus don't have the same nMenuID for item %d", x+1);
                TraceTag(ttidError, szErr);
                if (fPopupAsserts)
                {
                    AssertSz(FALSE, szErr);
                }
                delete[] szErr;
                return E_FAIL;
            }
        }

        WCHAR szMenu1[8192];
        WCHAR szMenu2[8192];

        GetMenuString(hMenu1, nMenuID1, szMenu1, 8192, MF_BYCOMMAND );
        GetMenuString(hMenu2, nMenuID2, szMenu2, 8192, MF_BYCOMMAND );

        if (wcscmp(szMenu1, szMenu2))
        {
            TRACEMENUS(ttid, hMenu1, hMenu2);
            sprintf(szErr, "Two menus don't have the same strings for item %d (%S vs %S)", x+1, szMenu1, szMenu2);
            TraceTag(ttidError, szErr);
            if (fPopupAsserts)
            {
                AssertSz(FALSE, szErr);
            }

            delete[] szErr;
            return E_FAIL;
        }

        UINT uiState1;
        UINT uiState2;

        uiState1 = GetMenuState( hMenu1, nMenuID1, MF_BYCOMMAND );
        uiState2 = GetMenuState( hMenu2, nMenuID2, MF_BYCOMMAND );

        if (bIgnoreFlags) // Ignore Default Flags
        {
            uiState1 &= ~MF_DEFAULT;
            uiState2 &= ~MF_DEFAULT;
        }

        if (uiState1 != uiState2)
        {
            TRACEMENUS(ttid, hMenu1, hMenu2);

            sprintf(szErr, "Two menus don't have the same state for item %d (%S) ... %08x vs %08x", x+1, szMenu1, uiState1, uiState2);
            TraceTag(ttidError, szErr);
            if (fPopupAsserts)
            {
                AssertSz(FALSE, szErr);
            }
            delete[] szErr;
            return E_FAIL;
        }
    }
    delete[] szErr;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrAssertIntegrityAgainstOldMatrix
//
//  Purpose:    Asserts the integrity of the Command Matrix by comparing it
//              with the old implementation
//
//  Arguments:
//      none
//
//  Returns:
//              S_OK is succeeded
//              E_FAIL if not
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:      Asserts on failure
//
HRESULT HrAssertIntegrityAgainstOldMatrix()
{
    TraceFileFunc(ttidMenus);

    HRESULT hr = S_OK;

    CHAR szErr[8192];
    for (DWORD x = 0; x < g_cteCommandMatrixCount; x++)
    {
        const COMMANDENTRY& cte = g_cteCommandMatrix[x];
        if (CMIDM_SEPARATOR == cte.iCommandId)
        {
            continue;
        }

        if (NCWHEN_TOPLEVEL == cte.dwValidWhen)
        {
            continue; // new commands we didn't have previously
        }

        if (CMIDM_HOMENET_WIZARD == cte.iCommandId)
        {
            continue; // new commands we didn't have previously
        }

        if ( (CMIDM_WZCDLG_SHOW  == cte.iCommandId) )
        {
            continue;
        }

        // Check that the ValidWhen flags match the ones from g_cteFolderCommands
        BOOL bMatch = FALSE;
        for (DWORD y = 0; y < g_nFolderCommandCount; y++)
        {
            COMMANDTABLEENTRY ctecmp = g_cteFolderCommands[y];
            if (cte.iCommandId == ctecmp.iCommandId)
            {
                bMatch = TRUE;

                if (ctecmp.fValidOnMultiple != (!!(cte.dwValidWhen & NCWHEN_MULTISELECT)))
                {
                    if (cte.iCommandId != CMIDM_FIX) // We know fix is broken in legacy implementation.
                    {
                        sprintf(szErr, "New (row %d) and old (row %d) multiselect fields are inconsistent", x+1, y+1);
                        AssertSz(FALSE, szErr);
                        hr = E_FAIL;
                    }
                }

                // We can check for Visible only since Active is always a subset of visible (enforced by HrAssertCommandMatrixIntegrity)
                if (ctecmp.fValidOnWizardOnly  != (!!(cte.dwMediaTypeVisible & NBM_MNC_WIZARD)))
                {
                    sprintf(szErr, "New (row %d) and old (row %d) wizard select fields are inconsistent", x+1, y+1);
                    AssertSz(FALSE, szErr);
                    hr = E_FAIL;
                }

                if (ctecmp.fValidOnZero != (!!(cte.dwValidWhen & NCWHEN_TOPLEVEL)))
                {
                    sprintf(szErr, "New (row %d) and old (row %d) Zero select fields are inconsistent", x+1, y+1);
                    AssertSz(FALSE, szErr);
                    hr = E_FAIL;
                }
            }
        }

        if (!bMatch)
        {
            sprintf(szErr, "Could not find corresponding entry for (row %d) in old table", x+1);
            AssertSz(FALSE, szErr);
            hr = E_FAIL;
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrAssertMenuAgainstOldImplementation
//
//  Purpose:    Asserts the integrity of a menu by comparing the old and
//              new implementations
//
//  Arguments:
//      none
//
//  Returns:
//              S_OK is succeeded
//              E_FAIL if not
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:      Asserts on failure
//
HRESULT HrAssertMenuAgainstOldImplementation(HWND hwndOwner, WIZARD wizWizard, NETCON_STATUS ncs, NETCON_MEDIATYPE ncm, DWORD nccf, LPDWORD pdwFailCount, LPDWORD pdwSucceedCount, DWORD dwPermOutside, DWORD dwPerm)
{
    CConFoldEntry cfe;
    PCONFOLDPIDL  pcfp;

    BYTE blob[MAX_PATH];

    HRESULT hr = cfe.HrInitData(
        wizWizard,
        ncm,
        NCSM_NONE,
        ncs,
        &CLSID_ConnectionFolder, // Bogus - but doesn't matter - as long as it's not NULL.
        &CLSID_ConnectionFolder, // Bogus - but doesn't matter - as long as it's not NULL.
        nccf,
        blob,
        MAX_PATH,
        L"Test PIDL",
        NULL,
        NULL);

    if (SUCCEEDED(hr))
    {
        hr = cfe.ConvertToPidl(pcfp);
    }

    if (SUCCEEDED(hr))
    {
        PCONFOLDPIDLVEC pcfpVec;
        pcfpVec.push_back(pcfp);

        UINT  idCmdFirst = 1234;
        UINT  idCmdLast  = idCmdFirst+1000;
        BOOL  fVerbsOnly = FALSE;

        HMENU hMenu1 = CreateMenu();
        HMENU hMenu2 = CreateMenu();
        if ( (hMenu1) && (hMenu2) )
        {
            hr = HrBuildMenuOldWay(hMenu1, pcfpVec, hwndOwner, CMT_OBJECT, 0, idCmdFirst, idCmdLast, fVerbsOnly);

            if (SUCCEEDED(hr))
            {
                hr = HrBuildMenu(hMenu2, fVerbsOnly, pcfpVec, idCmdFirst);

                if (SUCCEEDED(hr))
                {
                    BOOL bIgnoreFlags = TRUE;

                    hr = HrAssertTwoMenusEqual(hMenu1, hMenu2, idCmdFirst, bIgnoreFlags, FALSE);
                    if (FAILED(hr))
                    {
                        TraceTag(ttidMenus, "  + PIDL of failed menu compare:");
                        TraceTag(ttidMenus, "  + wizWizard       = %d\r\n", cfe.GetWizard());
                        TraceTag(ttidMenus, "  + ncm             = %d [%s]\r\n", cfe.GetNetConMediaType(), DbgNcm(cfe.GetNetConMediaType()));
                        TraceTag(ttidMenus, "  + ncs             = %d [%s]\r\n", cfe.GetNetConStatus(), DbgNcs(cfe.GetNetConStatus()));
                        TraceTag(ttidMenus, "  + Characteristics = %08x [%s]\r\n", cfe.GetCharacteristics(), DbgNccf(cfe.GetCharacteristics()));
                        TraceTag(ttidMenus, "  + Permissions     = %d (%d & %d)\r\n", g_dwDbgPermissionsFail, dwPermOutside-1, dwPerm-1);
                        *pdwFailCount++;
                    }
                    else
                    {
                        *pdwSucceedCount++;
                    }
                }
            }

            DestroyMenu(hMenu1);
            DestroyMenu(hMenu2);
            hr = S_OK;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrAssertMenuAgainstOldImplementation");
    return hr;
}


extern ULONG g_dwDbgWin2kPoliciesSet;
//+---------------------------------------------------------------------------
//
//  Member:     HrAssertAllLegacyMenusAgainstNew
//
//  Purpose:    Loads each of the menus from the old Command Matrix, and
//              Compare with the newer menus
//
//  Arguments:
//      [in] hwndOwner    Owner window
//
//  Returns:
//              S_OK is succeeded
//              E_FAIL if not
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:      Asserts on failure
//
HRESULT HrAssertAllLegacyMenusAgainstNew(HWND hwndOwner)
{
    TraceFileFunc(ttidMenus);

    HRESULT hr = S_OK;
    DWORD dwFailCount    = 0;
    DWORD dwSucceedCount = 0;
    DWORD dwIgnoredCount = 0;
    CHAR szErr[8192];

    const dwHighestPermissionToCheck = NCPERM_Repair+1; // 0;

    TraceTag(ttidMenus, "Asserting all Menus against their Legacy implementation. This may take a while...");

    DWORD dwCurrentCount = 0;

    DWORD dwTotalCount = 12 * (g_dwContextMenuEntryCount * (1 + ((dwHighestPermissionToCheck+1)*dwHighestPermissionToCheck/2))); // Sum of a series
                         // + ((1 + g_dwContextMenuEntryCount)*(g_dwContextMenuEntryCount))/2; // Multi-select items (sum of series)
    DWORD dwFrequency  = dwTotalCount / 200;
    dwFrequency = dwFrequency ? dwFrequency : 1;

    // 0xFFFFFFFF to NCPERM_Repair inclusive.
    g_dwDbgWin2kPoliciesSet = 1;
    for (int i = 0; i <= 1; i++, g_dwDbgWin2kPoliciesSet--)
    {
        for (DWORD dwPermOutside = 0; dwPermOutside <= dwHighestPermissionToCheck; dwPermOutside++)
        {
            for (DWORD dwPerm = dwPermOutside; dwPerm <= dwHighestPermissionToCheck; dwPerm++)
            {
                if (dwPerm == dwPermOutside)
                {
                    if (0 == dwPerm) // 0,0 is interesting - otherwise x,x is dup of x,0 (A | B == A | 0 if A==B)
                    {
                        g_dwDbgPermissionsFail = 0xFFFFFFFF;
                    }
                    else
                    {
                        continue;
                    }
                }
                else
                {
                    if (dwPermOutside)
                    {
                        g_dwDbgPermissionsFail = (1 << (dwPermOutside-1));
                    }
                    else
                    {
                        g_dwDbgPermissionsFail = 0;
                    }

                    if (dwPerm)
                    {
                        g_dwDbgPermissionsFail |= (1 << (dwPerm-1));
                    }
                }

                for (DWORD x = 0; x < g_dwContextMenuEntryCount; x++)
                {
                    for (int dwInc = 1; dwInc<= 6; dwInc++)  // we compare 6 menus at a time
                    {
                        if ( (dwCurrentCount % dwFrequency) == 0)
                        {
                            TraceTag(ttidMenus, "%d%% done with menu assertions (%d of %d menus compared. Currently using permissions: %08x)", static_cast<DWORD>( (100 * dwCurrentCount) / dwTotalCount), dwCurrentCount, dwTotalCount, g_dwDbgPermissionsFail);
                        }
                        dwCurrentCount++;
                    }

                    const ContextMenuEntry& cme = c_CMEArray[x];

                    DWORD dwCharacteristics = 0;

                    if (cme.fInbound)
                    {
                        dwCharacteristics |= NCCF_INCOMING_ONLY;
                    }

                    if (cme.fIsDefault)
                    {
                        dwCharacteristics |= NCCF_DEFAULT;
                    }

                    Sleep(0); // Yield to kernel
                    HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);

                    dwCharacteristics |= NCCF_ALLOW_RENAME;
                    HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);

                    if (IsMediaLocalType(cme.ncm))
                    {
                        dwCharacteristics |= NCCF_BRIDGED;
                        HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);

                        dwCharacteristics |= NCCF_FIREWALLED;
                        HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);
                    }
                    else
                    {
                        dwCharacteristics |= NCCF_ALL_USERS;
                        HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);

                        dwCharacteristics |= NCCF_ALLOW_REMOVAL;
                        HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);
                    }

                    Sleep(0); // Yield to kernel
                    dwCharacteristics |= NCCF_SHARED;
                    HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);

                    dwCharacteristics |= NCCF_FIREWALLED;
                    HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);
                }
            }
        }
    }

    g_dwDbgWin2kPoliciesSet = 0xFFFFFFFF; // retore to original value
    g_dwDbgPermissionsFail  = 0xFFFFFFFF; // retore to original value

    // Now, compare multiple items selected menus:
    // ***** THIS TEST IS NOT USEFUL. THE LEGACY IMPLEMENTATION SUCKS. COMMENTING OUT FOR NOW *****

//    for (DWORD x = 0; x < g_dwContextMenuEntryCount; x++)
//    {
//        for (DWORD y = x; y < g_dwContextMenuEntryCount; y++)
//        {
//            if ( (dwCurrentCount % dwFrequency) == 0)
//            {
//                TraceTag(ttidError, "%d%% done with menu assertions (%d of %d menus compared). Currently multi-comparing %d and %d", static_cast<DWORD>( (100 * dwCurrentCount) / dwTotalCount), dwCurrentCount, dwTotalCount, x, y);
//            }
//            dwCurrentCount++;
//
//            const ContextMenuEntry& cme1 = c_CMEArray[x];
//            const ContextMenuEntry& cme2 = c_CMEArray[y];
//
//            DWORD dwCharacteristics1 = 0;
//            DWORD dwCharacteristics2 = 0;
//            if (cme1.fInbound)
//            {
//                dwCharacteristics1 |= NCCF_INCOMING_ONLY;
//            }
//            if (cme2.fInbound)
//            {
//                dwCharacteristics2 |= NCCF_INCOMING_ONLY;
//            }
//
//            if (cme1.fIsDefault)
//            {
//                dwCharacteristics1 |= NCCF_DEFAULT;
//            }
//            if (cme2.fIsDefault)
//            {
//                dwCharacteristics2 |= NCCF_DEFAULT;
//            }
//
//            CConFoldEntry cfe1,  cfe2;
//            PCONFOLDPIDL  pcfp1, pcfp2;
//
//            BYTE blob[MAX_PATH];
//
//            hr = cfe1.HrInitData(
//                cme1.wizWizard, cme1.ncm, cme1.ncs, NCS_AUTHENTICATION_SUCCEEDED, &CLSID_ConnectionFolder, &CLSID_ConnectionFolder,
//                dwCharacteristics1, blob, MAX_PATH, L"Test PIDL", NULL,  NULL);
//
//            hr = cfe2.HrInitData(
//                cme2.wizWizard, cme2.ncm, cme2.ncs, NCS_AUTHENTICATION_SUCCEEDED, &CLSID_ConnectionFolder, &CLSID_ConnectionFolder,
//                dwCharacteristics2, blob, MAX_PATH, L"Test PIDL", NULL,  NULL);
//
//            if (SUCCEEDED(hr))
//            {
//                hr = cfe1.ConvertToPidl(pcfp1);
//                if (SUCCEEDED(hr))
//                {
//                    hr = cfe2.ConvertToPidl(pcfp2);
//                }
//            }
//
//            if (SUCCEEDED(hr))
//            {
//                PCONFOLDPIDLVEC pcfpVec;
//                pcfpVec.push_back(pcfp1);
//                pcfpVec.push_back(pcfp2);
//
//                UINT  idCmdFirst = 1234;
//                UINT  idCmdLast  = idCmdFirst+1000;
//                BOOL  fVerbsOnly = FALSE;
//
//                HMENU hMenu1 = CreateMenu();
//                HMENU hMenu2 = CreateMenu();
//                if ( (hMenu1) && (hMenu2) )
//                {
//                    hr = HrBuildMenuOldWay(hMenu1, pcfpVec, hwndOwner, CMT_OBJECT, 0, idCmdFirst, idCmdLast, fVerbsOnly);
//
//                    if (SUCCEEDED(hr))
//                    {
//                        hr = HrBuildMenu(hMenu2, fVerbsOnly, pcfpVec, idCmdFirst);
//
//                        if (SUCCEEDED(hr))
//                        {
//                            BOOL bIgnoreFlags = TRUE;
//                            // Ignore Default flag for multi-compare. The entire legacy implementation is wrong).
//
//                            hr = HrAssertTwoMenusEqual(hMenu1, hMenu2, idCmdFirst, bIgnoreFlags, FALSE);
//                            if (FAILED(hr))
//                            {
//                                TraceTag(ttidError, "  + PIDL of failed multi-menu compare:");
//                                TraceTag(ttidError, "  + PIDL 1:");
//                                TraceTag(ttidError, "    + wizWizard         = %d\r\n", cfe1.GetWizard());
//                                TraceTag(ttidError, "    + ncm             = %d [%s]\r\n", cfe1.GetNetConMediaType(), DBG_NCMAMES[cfe1.GetNetConMediaType()]);
//                                TraceTag(ttidError, "    + ncs             = %d [%s]\r\n", cfe1.GetNetConStatus(), DBG_NCSNAMES[cfe1.GetNetConStatus()]);
//                                TraceTag(ttidError, "    + Characteristics = %08x\r\n", cfe1.GetCharacteristics());
//                                TraceTag(ttidError, "    + Permissions     = %d\r\n", g_dwDbgPermissionsFail);
//                                TraceTag(ttidError, "  + PIDL 2:");
//                                TraceTag(ttidError, "    + wizWizard         = %d\r\n", cfe2.GetWizard());
//                                TraceTag(ttidError, "    + ncm             = %d [%s]\r\n", cfe2.GetNetConMediaType(), DBG_NCMAMES[cfe2.GetNetConMediaType()]);
//                                TraceTag(ttidError, "    + ncs             = %d [%s]\r\n", cfe2.GetNetConStatus(), DBG_NCSNAMES[cfe2.GetNetConStatus()]);
//                                TraceTag(ttidError, "    + Characteristics = %08x\r\n", cfe2.GetCharacteristics());
//                                TraceTag(ttidError, "    + Permissions     = %d\r\n", g_dwDbgPermissionsFail);
//                                dwFailCount++;
//                            }
//                            else
//                            {
//                                dwSucceedCount++;
//                            }
//                        }
//                    }
//
//                    DestroyMenu(hMenu1);
//                    DestroyMenu(hMenu2);
//                    hr = S_OK;
//                }
//            }
//
//            TraceHr(ttidError, FAL, hr, FALSE, "HrAssertAllLegacyMenusAgainstNew");
//        }
//    }


    TraceTag(ttidMenus, "Number of FAILED menu compares:    %d", dwFailCount);
    TraceTag(ttidMenus, "Number of SUCCEEDED menu compares: %d", dwSucceedCount);
    TraceTag(ttidMenus, "Number of ITEMS in menu array    : %d", (g_dwContextMenuEntryCount + 1) * dwHighestPermissionToCheck);

    sprintf(szErr, "%d of %d menus did not initialize consistend with the old way. (%d initialized correctly. %d was partially ignored due to known bad old implementation)", dwFailCount, dwTotalCount, dwSucceedCount, dwIgnoredCount);
    AssertSz(FALSE, szErr);
    return S_OK;
}

COMMANDCHECKENTRY   g_cceFolderCommands[] =
{
    // command id
    //                                  currently checked
    //                                   |      new check state
    //                                   |       |
    //                                   v       v
    { CMIDM_CONMENU_OPERATOR_ASSIST,    false,  false }
};

const DWORD g_nFolderCommandCheckCount = celems(g_cceFolderCommands);

//+---------------------------------------------------------------------------
//
//  Function:   HrEnableOrDisableMenuItems
//
//  Purpose:    Enable, disable, and or check/uncheck menu items depending
//              on the current selection count, as well as exceptions for
//              the type and state of the connections themselves
//
//  Arguments:
//      hwnd            [in]   Our window handle
//      apidlSelected   [in]   Currently selected objects
//      cPidl           [in]   Number selected
//      hmenu           [in]   Our command menu handle
//      idCmdFirst      [in]   First valid command
//
//  Returns:
//
//  Author:     jeffspr   2 Feb 1998
//
//  Notes:
//
HRESULT HrEnableOrDisableMenuItems(
                                   HWND            hwnd,
                                   const PCONFOLDPIDLVEC&  apidlSelected,
                                   HMENU           hmenu,
                                   UINT            idCmdFirst)
{
    HRESULT hr      = S_OK;
    DWORD   dwLoop  = 0;

    RefreshAllPermission();

    // Loop through, and set the new state, based on the selection
    // count compared to the flags for 0-select and multi-select
    //
    for (dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
    {
        // If nothing is selected, then check the current state, and
        // if different, adjust
        //
        if (apidlSelected.size() == 0)
        {
            g_cteFolderCommands[dwLoop].fNewState =
                g_cteFolderCommands[dwLoop].fValidOnZero;
        }
        else
        {
            // If singly-selected, then by default, we're always on.
            //
            if (apidlSelected.size() == 1)
            {
                CONFOLDENTRY  ccfe;

                // Special case this where one item is selected, but it's the
                // wizard. Use the fValidOnWizardOnly element here.
                //
                hr = apidlSelected[0].ConvertToConFoldEntry(ccfe);
                if (SUCCEEDED(hr))
                {
                    if (ccfe.GetWizard())
                    {
                        g_cteFolderCommands[dwLoop].fNewState =
                            g_cteFolderCommands[dwLoop].fValidOnWizardOnly;
                    }
                    else
                    {
                        g_cteFolderCommands[dwLoop].fNewState = true;
                    }
                }
            }
            else
            {
                // Multi-selected
                //
                g_cteFolderCommands[dwLoop].fNewState =
                    g_cteFolderCommands[dwLoop].fValidOnMultiple;
            }
        }
    }

    // Check for various menu item exceptions. Removed from this
    // function for readability's sake.
    //
    DoMenuItemExceptionLoop(apidlSelected);

    // Do the check/uncheck loop.
    //
    DoMenuItemCheckLoop();

    // Update bridge menu item


    // Check to see if it's a LAN connection. If so, disable
    // Loop through the array again, and do the actual EnableMenuItem
    // calls based on the new state compared to the current state.
    // Update the current state as well
    //
    for (dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
    {
#ifdef SHELL_CACHING_MENU_STATE
        // The shell is now enabling these for every call. If they switch
        // to a cached mechanism, change the #define above

        if (g_cteFolderCommands[dwLoop].fNewState !=
            g_cteFolderCommands[dwLoop].fCurrentlyValid)
#endif
        {
            DWORD dwCommandId = 0;

            switch(g_cteFolderCommands[dwLoop].iCommandId)
            {
            case SFVIDM_FILE_DELETE:
            case SFVIDM_FILE_RENAME:
            case SFVIDM_FILE_LINK:
            case SFVIDM_FILE_PROPERTIES:
                dwCommandId = g_cteFolderCommands[dwLoop].iCommandId;
                break;
            default:
                dwCommandId = g_cteFolderCommands[dwLoop].iCommandId +
                    idCmdFirst - CMIDM_FIRST;
                break;
            }

            // Enable or disable the menu item, as appopriate
            //
            EnableMenuItem(
                hmenu,
                dwCommandId,
                g_cteFolderCommands[dwLoop].fNewState ?
                MF_ENABLED | MF_BYCOMMAND :     // enable
            MF_GRAYED | MF_BYCOMMAND);      // disable

            // Set the state to reflect the enabling/graying
            //
            g_cteFolderCommands[dwLoop].fCurrentlyValid =
                g_cteFolderCommands[dwLoop].fNewState;
        }
    }

    // Loop through the checkmark-able command list, and mark the menu
    // items appropriately
    //
    for (dwLoop = 0; dwLoop < g_nFolderCommandCheckCount; dwLoop++)
    {

#ifdef SHELL_CACHING_MENU_STATE
        if (g_cceFolderCommands[dwLoop].fCurrentlyChecked !=
            g_cceFolderCommands[dwLoop].fNewCheckState)
#endif
        {
            DWORD dwCommandId   = 0;

            // If we re-add defview menu items that need to be checked/unchecked,
            // the code below will take care of it for us. Note that we
            // don't add the idCmdFirst + CMIDM_FIRST as we do with our own
            // commands
            //          switch(g_cceFolderCommands[dwLoop].iCommandId)
            //          {
            //              case SFVIDM_ARRANGE_AUTO:
            //                  dwCommandId = g_cceFolderCommands[dwLoop].iCommandId;
            //                  break;
            //              default:
            //                  dwCommandId = g_cceFolderCommands[dwLoop].iCommandId +
            //                      idCmdFirst - CMIDM_FIRST;
            //                  break;

            dwCommandId = g_cceFolderCommands[dwLoop].iCommandId +
                idCmdFirst - CMIDM_FIRST;

            // Check or uncheck the item, as appropriate
            //
            CheckMenuItem(
                hmenu,
                dwCommandId,
                g_cceFolderCommands[dwLoop].fNewCheckState ?
                MF_CHECKED | MF_BYCOMMAND :     // checked
            MF_UNCHECKED | MF_BYCOMMAND);   // unchecked

            // Set the state to reflect the checking/unchecking
            //
            g_cceFolderCommands[dwLoop].fCurrentlyChecked =
                g_cceFolderCommands[dwLoop].fNewCheckState;
        }
    }

    //special handling for the "Create Bridge" menu item

    //check whether "Create Bridge" exist in the menu
    BOOL fBgMenuExist = (-1 != GetMenuState(hmenu,
                                    CMIDM_CREATE_BRIDGE + idCmdFirst - CMIDM_FIRST,
                                    MF_BYCOMMAND));
    BOOL fBgCoMenuExist = (-1 != GetMenuState(hmenu,
                                    CMIDM_CONMENU_CREATE_BRIDGE + idCmdFirst - CMIDM_FIRST,
                                    MF_BYCOMMAND));

    if (fBgMenuExist || fBgCoMenuExist)
    {
        BOOL fRemoveBrdgMenu = FALSE;

#ifdef _WIN64
        // Homenet technologies are not available at all on IA64
        fRemoveBrdgMenu = TRUE;
#else
        // If the machine is Advanced server or data center, delete the bridge menu item
        OSVERSIONINFOEXW verInfo = {0};
        ULONGLONG ConditionMask = 0;

        verInfo.dwOSVersionInfoSize = sizeof(verInfo);
        verInfo.wSuiteMask = VER_SUITE_ENTERPRISE;
        verInfo.wProductType = VER_NT_SERVER;

        VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_GREATER_EQUAL);
        VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);

        fRemoveBrdgMenu = !!(VerifyVersionInfo(&verInfo,
                            VER_PRODUCT_TYPE | VER_SUITENAME,
                            ConditionMask));
#endif

        if (fRemoveBrdgMenu)
        {
            if (fBgMenuExist)
            {
                DeleteMenu(hmenu,
                        CMIDM_CREATE_BRIDGE + idCmdFirst - CMIDM_FIRST,
                        MF_BYCOMMAND);
            }

            if (fBgCoMenuExist)
            {
                DeleteMenu(hmenu,
                        CMIDM_CONMENU_CREATE_BRIDGE + idCmdFirst - CMIDM_FIRST,
                        MF_BYCOMMAND);
            }
        }
        else if (IsBridgeInstalled()) // REVIEW can we cache this somehow
        {
            //if the bridge is already installed, modify the menu item string
            MENUITEMINFO MenuItemInfo = {sizeof(MenuItemInfo)};
            MenuItemInfo.fMask = MIIM_STRING;
            MenuItemInfo.fType = MFT_STRING;
            MenuItemInfo.dwTypeData = const_cast<LPWSTR>(SzLoadIds(IDS_CMIDM_ADD_TO_BRIDGE));

            if (fBgMenuExist)
                SetMenuItemInfo(hmenu,
                        CMIDM_CREATE_BRIDGE + idCmdFirst - CMIDM_FIRST,
                        FALSE,
                        &MenuItemInfo);

            if (fBgCoMenuExist)
            {
                MenuItemInfo.fMask = MIIM_STATE;
                MenuItemInfo.fState = MFS_DISABLED;
                SetMenuItemInfo(hmenu,
                            CMIDM_CONMENU_CREATE_BRIDGE + idCmdFirst - CMIDM_FIRST,
                            FALSE,
                            &MenuItemInfo);
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrEnableOrDisableMenuItems");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FEnableConnectDisconnectMenuItem
//
//  Purpose:    Enable or disable the connect/disconnect menu item
//              depending on permissions and the current state of the
//              connection (already connected, disconnected, in the state
//              of connecting, etc.)
//
//  Arguments:
//      pcfp       [in]     Our pidl
//      iCommandId [in]     CMIDM_CONNECT, CMIDM_ENABLE, CMIDM_DISABLE, or CMIDM_DISCONNECT
//
//  Returns:
//
//  Author:     jeffspr   8 Apr 1999
//
//  Notes:
//
bool FEnableConnectDisconnectMenuItem(const PCONFOLDPIDL& pcfp, int iCommandId)
{
    bool    fEnableAction       = false;
    BOOL    fPermissionsValid   = false;

    Assert(!pcfp.empty());
    Assert(iCommandId == CMIDM_CONNECT || iCommandId == CMIDM_DISCONNECT || iCommandId == CMIDM_ENABLE || iCommandId == CMIDM_DISABLE);

    // Make the permissions check based on media type
    //
    switch(pcfp->ncm )
    {
    case NCM_BRIDGE:
        fPermissionsValid = FHasPermissionFromCache(NCPERM_AllowNetBridge_NLA);
        break;

    case NCM_SHAREDACCESSHOST_LAN:
    case NCM_SHAREDACCESSHOST_RAS:
        fPermissionsValid = FHasPermissionFromCache(NCPERM_ShowSharedAccessUi);
        break;

    case NCM_LAN:
        fPermissionsValid = FHasPermissionFromCache(NCPERM_LanConnect);
        break;
    case NCM_DIRECT:
    case NCM_ISDN:
    case NCM_PHONE:
    case NCM_TUNNEL:
        fPermissionsValid = FHasPermissionFromCache(NCPERM_RasConnect);
        break;
    case NCM_NONE:
        // No media-type, no connect
        fPermissionsValid = FALSE;
        break;
    default:
        AssertSz(FALSE, "Need to add a switch for this connection type in the menuing code");
        break;
    }

    if (fPermissionsValid)
    {
        switch(pcfp->ncs)
        {
        case NCS_CONNECTING:
            if (iCommandId == CMIDM_CONNECT || iCommandId == CMIDM_ENABLE)
            {
                if (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY))
                {
                    fEnableAction = false;
                }
            }
            break;

        case NCS_DISCONNECTED:
            // Don't check for activating because the
            // default command "Connect" will be disabled.
            // The code currently handles attempts to connect
            // to a connected/ing connection.
            //
            if (iCommandId == CMIDM_CONNECT || iCommandId == CMIDM_ENABLE)
            {
                if (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY))
                {
                    fEnableAction = true;
                }
            }
            break;
        case NCS_DISCONNECTING:
            if (iCommandId == CMIDM_DISCONNECT || iCommandId == CMIDM_DISABLE)
            {
                fEnableAction = false;
            }
            break;

        case NCS_CONNECTED:
        case NCS_MEDIA_DISCONNECTED:
        case NCS_INVALID_ADDRESS:
            if (iCommandId == CMIDM_DISCONNECT || iCommandId == CMIDM_DISABLE)
            {
                fEnableAction = true;
            }
            break;
        case NCS_HARDWARE_NOT_PRESENT:
        case NCS_HARDWARE_DISABLED:
        case NCS_HARDWARE_MALFUNCTION:
            // Certainly don't support connect/disconnect actions here.
            break;
        default:
            AssertSz(FALSE, "Who invented a new connection state, and when can I horsewhip them?");
            break;
        }
    }

    return (fEnableAction);
}

//+---------------------------------------------------------------------------
//
//  Function:   DoMenuItemExceptionLoop
//
//  Purpose:    Check for various menu item exceptions.
//
//  Arguments:
//      apidlSelected   [in]   Selected items
//      cPidl           [in]   Count of selected items
//
//  Returns:
//
//  Author:     jeffspr   26 Feb 1998
//
//  Notes:
//
VOID DoMenuItemExceptionLoop(const PCONFOLDPIDLVEC& apidlSelected)
{
    DWORD   dwLoop               = 0;
    PCONFOLDPIDLVEC::const_iterator iterObjectLoop;
    bool    fEnableDelete        = false;
    bool    fEnableStatus        = false;
    bool    fEnableRename        = false;
    bool    fEnableShortcut      = false;
    bool    fEnableConnect       = false;
    bool    fEnableDisconnect    = false;
    bool    fEnableCreateCopy    = false;
    bool    fEnableProperties    = false;
    bool    fEnableCreateBridge  = true;
    bool    fEnableFix           = true;

    // Loop through each of the selected objects
    //
    for (iterObjectLoop = apidlSelected.begin(); iterObjectLoop != apidlSelected.end(); iterObjectLoop++)
    {
        // Validate the pidls
        //
        const PCONFOLDPIDL& pcfp = *iterObjectLoop;
        if ( pcfp.empty() )
        {
            AssertSz(FALSE, "Bogus pidl array in DoMenuItemExceptionLoop (status)");
        }
        else
        {
            BOOL    fActivating = FALSE;

            CONFOLDENTRY cfEmpty;
            (VOID) HrCheckForActivation(pcfp, cfEmpty, &fActivating);

            // Loop through the commands
            //
            for (dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
            {
                // Only allow items to be changed to ENABLED states when they're
                // previously DISABLED
                //
                if (g_cteFolderCommands[dwLoop].fNewState)
                {
                    int iCommandId = g_cteFolderCommands[dwLoop].iCommandId;
                    switch(iCommandId)
                    {
                        // For status, verify that at least ONE of the entries is connected.
                        // If not, then we don't allow status.
                        //
                    case CMIDM_STATUS:
                        if ( ( fIsConnectedStatus(pcfp->ncs) || (pcfp->ncs == NCS_INVALID_ADDRESS) ) &&
                            FHasPermissionFromCache(NCPERM_Statistics))
                        {
                            // Raid #379459: If logged on as non-admin, disable status
                            if (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY) ||
                                    FIsUserAdmin())
                            {
                                fEnableStatus = true;
                            }
                        }
                        break;

                    case CMIDM_CREATE_SHORTCUT:
                    case SFVIDM_FILE_LINK:
                        if (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY))
                        {
                            fEnableShortcut = true;
                        }
                        break;

                        // For delete, verify that at least ONE of the entries has removeable
                        // flag set. If not, then disable the command
                        //
                    case CMIDM_DELETE:
                    case SFVIDM_FILE_DELETE:
                        if (pcfp->dwCharacteristics & NCCF_ALLOW_REMOVAL)
                        {
                            // Note: Need to convert this back to using
                            // the DeleteAllUserConnection when that functionality
                            // is added to the System.ADM file.
                            //
                            if (FHasPermissionFromCache(NCPERM_DeleteConnection))
                            {
                                if (!(pcfp->dwCharacteristics & NCCF_ALL_USERS) ||
                                    ((pcfp->dwCharacteristics & NCCF_ALL_USERS) &&
                                    FHasPermissionFromCache(NCPERM_DeleteAllUserConnection)))
                                {
                                    fEnableDelete = true;
                                }
                            }
                        }
                        break;

                        // For rename, verify that at least ONE of the entries has the rename
                        // flag set. If not, then disable the command
                        //
                    case CMIDM_RENAME:
                    case SFVIDM_FILE_RENAME:
                        if (pcfp->dwCharacteristics & NCCF_ALLOW_RENAME)
                        {
                            if (HasPermissionToRenameConnection(pcfp))
                            {
                                fEnableRename = true;
                            }
                        }
                        break;

                        // For duplicate, verify that at least ONE of the entries
                        // has the duplicate flag set and that the user can create
                        // new connections. If not, then disable the command.
                        //
                    case CMIDM_CREATE_COPY:
                        if ((pcfp->dwCharacteristics & NCCF_ALLOW_DUPLICATION) &&
                            FHasPermissionFromCache(NCPERM_NewConnectionWizard))
                        {
                            // In all cases except when the connection is an
                            // all user connection and the user does NOT have
                            // permissions to view all user properties, we'll
                            // allow it to be enabled.
                            //
                            if ((!(pcfp->dwCharacteristics & NCCF_ALL_USERS)) ||
                                (FHasPermissionFromCache(NCPERM_RasAllUserProperties)))
                            {
                                fEnableCreateCopy = true;
                            }
                        }
                        break;

                        case CMIDM_CONNECT:
                        case CMIDM_ENABLE:
                            // Raid #379459: If logged on as non-admin, disable connect
                            if (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY) ||
                                FIsUserAdmin())
                            {
                                fEnableConnect = FEnableConnectDisconnectMenuItem(pcfp, CMIDM_CONNECT);
                            }
                            break;

                        case CMIDM_DISCONNECT:
                        case CMIDM_DISABLE:
                            // Raid #379459: If logged on as non-admin, disable disconnect
                            if (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY) ||
                                FIsUserAdmin())
                            {
                                fEnableDisconnect = FEnableConnectDisconnectMenuItem(pcfp, CMIDM_DISCONNECT);
                            }
                            break;

                        case CMIDM_FIX:
                            fEnableFix = ((NCS_INVALID_ADDRESS == pcfp->ncs || fIsConnectedStatus(pcfp->ncs) ) &&
                                          FHasPermission(NCPERM_Repair));
                            break;

                        case CMIDM_PROPERTIES:
                        case SFVIDM_FILE_PROPERTIES:
                            // Raid #379459: If logged on as non-admin, disable properties
                        // We only enable if this is not a LAN connection, or the user has the correct
                        // permissions.  That way we don't accidentally give user that doesn't have permission
                        // the ability to do something they shouldn't, either in the case of a call failing or an
                        // unforeseen error occuring.
                            if (IsMediaRASType(pcfp->ncm))
                            {
                                fEnableProperties = (TRUE == ((pcfp->dwCharacteristics & NCCF_ALL_USERS) ?
                                                    (FHasPermission(NCPERM_RasAllUserProperties)) :
                                                    (FHasPermission(NCPERM_RasMyProperties))));
                            }
                            else    // This is a lan connection.
                            {
                                fEnableProperties = true;
                            }

                        case CMIDM_CREATE_BRIDGE:
                        case CMIDM_CONMENU_CREATE_BRIDGE:
                            if((NCCF_BRIDGED | NCCF_FIREWALLED | NCCF_SHARED) & pcfp->dwCharacteristics || NCM_LAN != pcfp->ncm || !FHasPermission(NCPERM_AllowNetBridge_NLA))
                            {
                                fEnableCreateBridge = false;
                            }
                            break;

                        default:
                            break;
                    }
                }
            }
        }

        // Loop through the commands, and disable the commands, if appropriate
        //
        for (dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
        {
            switch(g_cteFolderCommands[dwLoop].iCommandId)
            {
            case CMIDM_RENAME:
            case SFVIDM_FILE_RENAME:
                g_cteFolderCommands[dwLoop].fNewState = fEnableRename;
                break;

            case CMIDM_DELETE:
            case SFVIDM_FILE_DELETE:
                g_cteFolderCommands[dwLoop].fNewState = fEnableDelete;
                break;

            case CMIDM_STATUS:
                g_cteFolderCommands[dwLoop].fNewState = fEnableStatus;
                break;

            case CMIDM_CREATE_SHORTCUT:
            case SFVIDM_FILE_LINK:
                g_cteFolderCommands[dwLoop].fNewState = fEnableShortcut;
                break;

            case CMIDM_CONNECT:
            case CMIDM_ENABLE:
                g_cteFolderCommands[dwLoop].fNewState = fEnableConnect;
                break;

            case CMIDM_DISCONNECT:
            case CMIDM_DISABLE:
                g_cteFolderCommands[dwLoop].fNewState = fEnableDisconnect;
                break;

            case CMIDM_FIX:
                g_cteFolderCommands[dwLoop].fNewState = fEnableFix;
                break;
            case CMIDM_CREATE_COPY:
                g_cteFolderCommands[dwLoop].fNewState = fEnableCreateCopy;
                break;

            case CMIDM_PROPERTIES:
            case SFVIDM_FILE_PROPERTIES:
                g_cteFolderCommands[dwLoop].fNewState = fEnableProperties;
                break;

            case CMIDM_CREATE_BRIDGE:
            case CMIDM_CONMENU_CREATE_BRIDGE:
                g_cteFolderCommands[dwLoop].fNewState = fEnableCreateBridge;
                break;

            default:
                break;
            }
        }
    }

    // Process commands whose state is not controlled by selection
    //
    for (dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
    {
        // Only allow items to be changed to ENABLED states when they're
        // previously DISABLED
        //
        switch(g_cteFolderCommands[dwLoop].iCommandId)
        {
        case CMIDM_NEW_CONNECTION:
            if (!FHasPermissionFromCache(NCPERM_NewConnectionWizard))
            {
                g_cteFolderCommands[dwLoop].fNewState = false;
            }
            break;

        case CMIDM_CONMENU_ADVANCED_CONFIG:
            if (!FHasPermissionFromCache(NCPERM_AdvancedSettings))
            {
                g_cteFolderCommands[dwLoop].fNewState = false;
            }
            break;

        case CMIDM_CONMENU_OPTIONALCOMPONENTS:
            if (!FHasPermissionFromCache(NCPERM_AddRemoveComponents))
            {
                g_cteFolderCommands[dwLoop].fNewState = false;
            }
            break;

        case CMIDM_CONMENU_DIALUP_PREFS:
            if (!FHasPermissionFromCache(NCPERM_DialupPrefs))
            {
                g_cteFolderCommands[dwLoop].fNewState = false;
            }
        default:
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DoMenuItemCheckLoop
//
//  Purpose:    Walk through the list of checkmark-able commands and get
//              their values.
//
//  Arguments:
//      None
//
//  Returns:
//
//  Author:     jeffspr   26 Feb 1998
//
//  Notes:
//
VOID DoMenuItemCheckLoop(VOID)
{
    DWORD   dwLoop  = 0;

    for (; dwLoop < g_nFolderCommandCheckCount; dwLoop++)
    {
        switch(g_cceFolderCommands[dwLoop].iCommandId)
        {
            // We used to check SFVIDM_AUTO_ARRANGE, but we no longer force it on.
            //

        case CMIDM_CONMENU_OPERATOR_ASSIST:
            g_cceFolderCommands[dwLoop].fNewCheckState = g_fOperatorAssistEnabled;
            break;
        default:
            break;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\legacymenus.h ===
#pragma once

#ifdef DBG

struct CommandTableEntry
{
    int     iCommandId;         // Associated command ID
    bool    fValidOnZero;       // Is this option valid when 0 items selected?
    bool    fValidOnWizardOnly; // Is this option valid when only wizard selected?
    bool    fValidOnMultiple;   // Is this option valid with > 1 selected?
    bool    fCurrentlyValid;    // Is this option currently valid in the menu?
    bool    fNewState;          // What's the new state? (work variable)
};

typedef CommandTableEntry   COMMANDTABLEENTRY;
typedef CommandTableEntry * PCOMMANDTABLEENTRY;

extern COMMANDTABLEENTRY    g_cteFolderCommands[];
extern const DWORD          g_nFolderCommandCount;

struct CommandCheckEntry
{
    int  iCommandId;        // Associated command ID
    bool fCurrentlyChecked; // Is this menu item already checked? 
    bool fNewCheckState;    // What's the new check state?        
};

typedef CommandCheckEntry   COMMANDCHECKENTRY;
typedef CommandCheckEntry * PCOMMANDCHECKENTRY;

extern COMMANDCHECKENTRY    g_cceFolderCommands[];
extern const DWORD          g_nFolderCommandCheckCount;

HRESULT HrBuildMenuOldWay(IN OUT HMENU hmenu, IN PCONFOLDPIDLVEC& cfpl, IN HWND hwndOwner, IN CMENU_TYPE cmt, IN UINT indexMenu, IN DWORD idCmdFirst, IN UINT idCmdLast, IN BOOL fVerbsOnly);
HRESULT HrAssertIntegrityAgainstOldMatrix();
HRESULT HrAssertAllLegacyMenusAgainstNew(HWND hwndOwner);
void TraceMenu(HMENU hMenu);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\oncommand_dbg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O N C O M M A N D _ D B G . H 
//
//  Contents:   Debug command handler header
//
//  Notes:      
//
//  Author:     jeffspr   23 Jul 1998
//
//----------------------------------------------------------------------------

#ifndef _ONCOMMAND_DBG_H_
#define _ONCOMMAND_DBG_H_

// All of these below handle individual commands
//
HRESULT HrOnCommandDebugTray(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugTracing(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugNotifyAdd(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugNotifyRemove(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugNotifyTest(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugRefresh(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugRefreshNoFlush(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugRefreshSelected(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugRemoveTrayIcons(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

#endif // _ONCOMMAND_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\loadicon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L O A D I C O N . H 
//
//  Contents:   Load the connection icons for the connections tray, as needed
//
//  Notes:      
//
//  Author:     jeffspr   5 Dec 1997
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _LOADICON_H_
#define _LOADICON_H_

#include <confold.h>

HRESULT HrGetConnectionIcon(const CONFOLDENTRY& pccfe, INT *piConnIcon);

#endif // _LOADICON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\oncommand.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O N C O M M A N D . C P P
//
//  Contents:   Command handlers for the context menus, etc.
//
//  Notes:
//
//  Author:     jeffspr   4 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "advcfg.h"
#include "conprops.h"
#include "foldres.h"
#include "oncommand.h"

#if DBG                     // Debug menu commands
#include "oncommand_dbg.h"  //
#endif

#include "shutil.h"
#include "ncras.h"
#include "traymsgs.h"
#include <ncnetcon.h>
#include <nsres.h>
#include <wizentry.h>
#include "disconnect.h"
#include "ncperms.h"
#include "smcent.h"
#include "cfutils.h"

#include "HNetCfg.h"

#include "..\lanui\lanui.h"
#include "repair.h"
#include "iconhandler.h"
#include "wzcdlg.h"

//---[ Externs ]--------------------------------------------------------------

extern HWND g_hwndTray;
extern const WCHAR c_szNetShellDll[];

//---[ Constants ]------------------------------------------------------------

// Command-line for the control-panel applet.
//
static const WCHAR c_szRunDll32[]         = L"rundll32.exe";
static const WCHAR c_szNetworkIdCmdLine[] = L"shell32.dll,Control_RunDLL sysdm.cpl,,1";

//---[ Local functions ]------------------------------------------------------

    // None


class CCommandHandlerParams
{
public:
    const PCONFOLDPIDLVEC*  apidl;
    HWND                    hwndOwner;
    LPSHELLFOLDER           psf;

    UINT_PTR                nAdditionalParam;
} ;


HRESULT HrCommandHandlerThread(
    FOLDERONCOMMANDPROC     pfnCommandHandler,
    IN const PCONFOLDPIDLVEC&  apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT          hr          = S_OK;
    PCONFOLDPIDLVEC  apidlCopy;

    // If there are pidls to copy, copy them
    //
    if (!apidl.empty())
    {
        hr = HrCloneRgIDL(apidl, FALSE, TRUE, apidlCopy);
    }

    // If either there were no pidls, or the Clone succeeded, then we want to continue
    //
    if (SUCCEEDED(hr))
    {
        PCONFOLDONCOMMANDPARAMS  pcfocp = new CONFOLDONCOMMANDPARAMS;

        if (pcfocp)
        {
            pcfocp->pfnfocp         = pfnCommandHandler;
            pcfocp->apidl           = apidlCopy;
            pcfocp->hwndOwner       = hwndOwner;
            pcfocp->psf             = psf;
            pcfocp->hInstNetShell   = NULL;

            // This should be Release'd in the thread called.
            //
            psf->AddRef();

            // This will always succeed in retail, but will test the flag in debug
            //
            if (!FIsDebugFlagSet (dfidDisableShellThreading))
            {
                // Run in a thread using the QueueUserWorkItem
                //

                HANDLE      hthrd = NULL;
                HINSTANCE   hInstNetShell = LoadLibrary(c_szNetShellDll);

                if (hInstNetShell)
                {
                    pcfocp->hInstNetShell = hInstNetShell;

                    DWORD  dwThreadId;
                    hthrd = CreateThread(NULL, STACK_SIZE_DEFAULT,
                                    (LPTHREAD_START_ROUTINE)FolderCommandHandlerThreadProc,
                                    (LPVOID)pcfocp, 0, &dwThreadId);
                }

                if (NULL != hthrd)
                {
                    CloseHandle(hthrd);
                }
                else
                {
                    pcfocp->hInstNetShell = NULL;
                    FolderCommandHandlerThreadProc(pcfocp);
                }
            }
            else
            {
                // Run directly in this same thread
                //
                FolderCommandHandlerThreadProc((PVOID) pcfocp);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }


    // Don't release the psf here. This should have been taken care of by the called ThreadProc
    //
    return hr;
}

DWORD WINAPI FolderCommandHandlerThreadProc(LPVOID lpParam)
{
    HRESULT                     hr                  = S_OK;
    PCONFOLDONCOMMANDPARAMS     pcfocp              = (PCONFOLDONCOMMANDPARAMS) lpParam;
    BOOL                        fCoInited           = FALSE;
    IUnknown *                  punkExplorerProcess = NULL;

    Assert(pcfocp);

    SHGetInstanceExplorer(&punkExplorerProcess);

    hr = CoInitializeEx (NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hr))
    {
        // We don't care if this is S_FALSE or not, since we'll soon
        // overwrite the hr. If it's already initialized, great...

        fCoInited = TRUE;

        // Call the specific handler
        //
        hr = pcfocp->pfnfocp(
            pcfocp->apidl,
            pcfocp->hwndOwner,
            pcfocp->psf);
    }

    // Remove the ref that we have on this object. The thread handler would have addref'd
    // this before queueing our action
    //
    if (pcfocp->psf)
    {
        ReleaseObj(pcfocp->psf);
    }

    // Remove this object. We're responsible for this now.
    //
    HINSTANCE hInstNetShell = pcfocp->hInstNetShell;
    pcfocp->hInstNetShell = NULL;

    delete pcfocp;

    if (fCoInited)
    {
        CoUninitialize();
    }

    ::ReleaseObj(punkExplorerProcess);

    if (hInstNetShell)
        FreeLibraryAndExitThread(hInstNetShell, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCommandHomeNetWizard
//
//  Purpose:    Command handler to start the home networking wizard
//
//  Arguments:  none
//
//  Returns:    S_OK if succeeded
//              E_FAIL otherwise
//
//  Author:     deonb     10 Feb 2001
//
//  Notes:
//
HRESULT HrCommandHomeNetWizard()
{
    // ShellExecute returns <32 if an error
    if (ShellExecute(NULL, NULL, L"rundll32.exe", L"hnetwiz.dll,HomeNetWizardRunDll", NULL, SW_SHOWNORMAL) > reinterpret_cast<HINSTANCE>(32))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

//
//
//
LONG
TotalValidSelectedConnectionsForBridge(
    IN const PCONFOLDPIDLVEC&   apidlSelected
    )
{
    int nTotalValidCandidateForBridge = 0;

    //
    // Loop through each of the selected objects
    //
    for ( PCONFOLDPIDLVEC::const_iterator iterObjectLoop = apidlSelected.begin(); iterObjectLoop != apidlSelected.end(); iterObjectLoop++ )
    {
        // Validate the pidls
        //
        const PCONFOLDPIDL& pcfp = *iterObjectLoop;

        if ( !pcfp.empty() )
        {
            //
            // needs to be a LAN Adapter and NOT (Firewalled/Shared or Bridge)
            //
            if ( (NCM_LAN == pcfp->ncm) )
                if ( !( (NCCF_BRIDGED|NCCF_FIREWALLED|NCCF_SHARED) & pcfp->dwCharacteristics ) )
                {
                    //
                    // Ok we have a winner it's a nice clean adapter
                    //
                    nTotalValidCandidateForBridge ++;
                }
        }
    }

    return nTotalValidCandidateForBridge;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCommandNetworkDiagnostics
//
//  Purpose:    Command handler to start the Network Diagnostics page
//
//  Arguments:  none
//
//  Returns:    S_OK if succeeded
//              E_FAIL otherwise
//
//  Author:     deonb     10 Feb 2001
//
//  Notes:
//

HRESULT HrCommandNetworkDiagnostics()
{
    // ShellExecute returns <32 if an error
    if (ShellExecute(NULL, NULL, L"hcp://system/netdiag/dglogs.htm", L"", NULL, SW_SHOWNORMAL) > reinterpret_cast<HINSTANCE>(32))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   HrCommandNetworkTroubleShoot
//
//  Purpose:    Command handler to start the Network Troubleshooter page
//
//  Arguments:  none
//
//  Returns:    S_OK if succeeded
//              E_FAIL otherwise
//
//  Author:     deonb     4 April 2001
//
//  Notes:
//

HRESULT HrCommandNetworkTroubleShoot()
{
    // ShellExecute returns <32 if an error
    if (ShellExecute(NULL, NULL, L"hcp://system/panels/Topics.htm?path=TopLevelBucket_4/Fixing_a_problem/Home_Networking_and_network_problems", L"", NULL, SW_SHOWNORMAL) > reinterpret_cast<HINSTANCE>(32))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFolderCommandHandler
//
//  Purpose:    Command handler switch -- all commands come through this
//              point.
//
//  Arguments:
//      uiCommand [in]  The command-id that's been invoked.
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      lpici     [in]  Command context info
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jeffspr   11 Feb 1998
//
//  Notes:
//
HRESULT HrFolderCommandHandler(
    UINT                    uiCommand,
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPCMINVOKECOMMANDINFO   lpici,
    LPSHELLFOLDER           psf)
{
    HRESULT hr  = S_OK;

    CWaitCursor wc;     // Bring up wait cursor now. Remove when we go out of scope.

    // refresh all permission so subsequent calls can use cached value
    RefreshAllPermission();

    switch(uiCommand)
    {
        case CMIDM_ARRANGE_BY_NAME:
            ShellFolderView_ReArrange(hwndOwner, ICOL_NAME);
            break;

        case CMIDM_ARRANGE_BY_TYPE:
            ShellFolderView_ReArrange(hwndOwner, ICOL_TYPE);
            break;

        case CMIDM_ARRANGE_BY_STATUS:
            ShellFolderView_ReArrange(hwndOwner, ICOL_STATUS);
            break;

        case CMIDM_ARRANGE_BY_OWNER:
            ShellFolderView_ReArrange(hwndOwner, ICOL_OWNER);
            break;

        case CMIDM_ARRANGE_BY_PHONEORHOSTADDRESS:
            ShellFolderView_ReArrange(hwndOwner, ICOL_PHONEORHOSTADDRESS);
            break;

        case CMIDM_ARRANGE_BY_DEVICE_NAME:
            ShellFolderView_ReArrange(hwndOwner, ICOL_DEVICE_NAME);
            break;

        case CMIDM_NEW_CONNECTION:
            hr = HrCommandHandlerThread(HrOnCommandNewConnection, apidl, hwndOwner, psf);
            break;

        case CMIDM_HOMENET_WIZARD:
            hr = HrCommandHomeNetWizard();
            break;

        case CMIDM_NET_DIAGNOSTICS:
            hr = HrCommandNetworkDiagnostics();
            break;

        case CMIDM_NET_TROUBLESHOOT:
            hr = HrCommandNetworkTroubleShoot();
            break;

        case CMIDM_CONNECT:
        case CMIDM_ENABLE:
            hr = HrCommandHandlerThread(HrOnCommandConnect, apidl, hwndOwner, psf);
            break;

        case CMIDM_DISCONNECT:
        case CMIDM_DISABLE:
            hr = HrCommandHandlerThread(HrOnCommandDisconnect, apidl, hwndOwner, psf);
            break;

        case CMIDM_STATUS:
            // the status monitor is already on its own thread
            //
            hr = HrOnCommandStatus(apidl, hwndOwner, psf);
            break;

        case CMIDM_FIX:
            hr = HrCommandHandlerThread(HrOnCommandFix, apidl, hwndOwner, psf);
            break;

        case CMIDM_CREATE_SHORTCUT:
            hr = HrCommandHandlerThread(HrOnCommandCreateShortcut, apidl, hwndOwner, psf);
            break;

        case CMIDM_DELETE:
            hr = HrCommandHandlerThread(HrOnCommandDelete, apidl, hwndOwner, psf);
            break;

        case CMIDM_PROPERTIES:
            hr = HrCommandHandlerThread(HrOnCommandProperties, apidl, hwndOwner, psf);
            break;

        case CMIDM_WZCPROPERTIES:
            hr = HrCommandHandlerThread(HrOnCommandWZCProperties, apidl, hwndOwner, psf);
            break;

        case CMIDM_WZCDLG_SHOW:
            hr = HrCommandHandlerThread(HrOnCommandWZCDlgShow, apidl, hwndOwner, psf);
            break;

        case CMIDM_CREATE_COPY:
            hr = HrOnCommandCreateCopy(apidl, hwndOwner, psf);
            break;

        case CMIDM_CONMENU_ADVANCED_CONFIG:
            hr = HrCommandHandlerThread(HrOnCommandAdvancedConfig, apidl, hwndOwner, psf);
            break;

        case CMIDM_SET_DEFAULT:
            hr = HrOnCommandSetDefault(apidl, hwndOwner, psf);
            break;

        case CMIDM_UNSET_DEFAULT:
            hr = HrOnCommandUnsetDefault(apidl, hwndOwner, psf);
            break;

        case CMIDM_CREATE_BRIDGE:
        case CMIDM_CONMENU_CREATE_BRIDGE:
                if ( TotalValidSelectedConnectionsForBridge(apidl) < 2 )
                {
                    // tell users that he/she needs select 2 or more valid connections in order to acomplish this
                    NcMsgBox(
                        _Module.GetResourceInstance(),
                        NULL,
                        IDS_CONFOLD_OBJECT_TYPE_BRIDGE,
                        IDS_BRIDGE_EDUCATION,
                        MB_ICONEXCLAMATION | MB_OK
                        );
                }
                else
                    HrOnCommandBridgeAddConnections(apidl, hwndOwner, psf);
            break;

        case CMIDM_ADD_TO_BRIDGE:
            HrOnCommandBridgeAddConnections(apidl, hwndOwner, psf);
            break;

        case CMIDM_REMOVE_FROM_BRIDGE:
            HrOnCommandBridgeRemoveConnections(apidl, hwndOwner, psf, CMIDM_REMOVE_FROM_BRIDGE);
            break;

        case CMIDM_CONMENU_NETWORK_ID:
            hr = HrOnCommandNetworkId(apidl, hwndOwner, psf);
            break;

        case CMIDM_CONMENU_OPTIONALCOMPONENTS:
            hr = HrOnCommandOptionalComponents(apidl, hwndOwner, psf);
            break;

        case CMIDM_CONMENU_DIALUP_PREFS:
            hr = HrCommandHandlerThread(HrOnCommandDialupPrefs, apidl, hwndOwner, psf);
            break;

        case CMIDM_CONMENU_OPERATOR_ASSIST:
            hr = HrOnCommandOperatorAssist(apidl, hwndOwner, psf);
            break;

#if DBG
        case CMIDM_DEBUG_TRAY:
            hr = HrOnCommandDebugTray(apidl, hwndOwner, psf);
            break;

        case CMIDM_DEBUG_TRACING:
            hr = HrOnCommandDebugTracing(apidl, hwndOwner, psf);
            break;

        case CMIDM_DEBUG_NOTIFYADD:
            hr = HrOnCommandDebugNotifyAdd(apidl, hwndOwner, psf);
            break;

        case CMIDM_DEBUG_NOTIFYREMOVE:
            hr = HrOnCommandDebugNotifyRemove(apidl, hwndOwner, psf);
            break;

        case CMIDM_DEBUG_NOTIFYTEST:
            hr = HrOnCommandDebugNotifyTest(apidl, hwndOwner, psf);
            break;

        case CMIDM_DEBUG_REFRESH:
            hr = HrOnCommandDebugRefresh(apidl, hwndOwner, psf);
            break;

        case CMIDM_DEBUG_REFRESHNOFLUSH:
            hr = HrOnCommandDebugRefreshNoFlush(apidl, hwndOwner, psf);
            break;

        case CMIDM_DEBUG_REFRESHSELECTED:
            hr = HrCommandHandlerThread(HrOnCommandDebugRefreshSelected, apidl, hwndOwner, psf);
            break;

        case CMIDM_DEBUG_REMOVETRAYICONS:
            hr = HrCommandHandlerThread(HrOnCommandDebugRemoveTrayIcons, apidl, hwndOwner, psf);
            break;

#endif

        default:
#if DBG
            char sz[128];
            ZeroMemory(sz, 128);
            sprintf(sz, "Unknown command (%d) in HrFolderCommandHandler", uiCommand);
            TraceHr(ttidError, FAL, hr, FALSE, sz);
#endif
            hr = E_INVALIDARG;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrFolderCommandHandler");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandCreateCopy
//
//  Purpose:    Command handler for the CMIDM_CREATE_COPY command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//      psf       [in]  The shell folder interface
//
//  Returns:
//
//  Author:     jeffspr   31 Jan 1998
//
//  Notes:
//
HRESULT HrOnCommandCreateCopy(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)

{
    HRESULT             hr              = S_OK;
    INetConnection *    pNetCon         = NULL;
    INetConnection *    pNetConDupe     = NULL;
    CConnectionFolder * pcf             = static_cast<CConnectionFolder *>(psf);

    NETCFG_TRY
        PCONFOLDPIDLFOLDER        pidlFolder;
        if (pcf)
        {
            pidlFolder = pcf->PidlGetFolderRoot();
        }

        PCONFOLDPIDL        pidlConnection;
        PCONFOLDPIDLVEC::const_iterator iterLoop;

        for (iterLoop = apidl.begin(); iterLoop != apidl.end() ; iterLoop++)
        {
            // Get the INetConnection object from the persist data
            //
            hr = HrNetConFromPidl(*iterLoop, &pNetCon);
            if (SUCCEEDED(hr))
            {
                CONFOLDENTRY  ccfe;

                Assert(pNetCon);

                hr = iterLoop->ConvertToConFoldEntry(ccfe);
                if (SUCCEEDED(hr))
                {
                    if (ccfe.GetCharacteristics() & NCCF_ALLOW_DUPLICATION)
                    {
                        PWSTR  pszDupeName = NULL;

                        hr = g_ccl.HrSuggestNameForDuplicate(ccfe.GetName(), &pszDupeName);
                        if (SUCCEEDED(hr))
                        {
                            Assert(pszDupeName);

                            // Duplicate the connection
                            //
                            hr = pNetCon->Duplicate(pszDupeName, &pNetConDupe);
                            if (SUCCEEDED(hr))
                            {
                                Assert(pNetConDupe);

                                if (pNetConDupe)
                                {
                                    hr = g_ccl.HrInsertFromNetCon(pNetConDupe,
                                        pidlConnection);
                                    if (SUCCEEDED(hr))
                                    {
                                        GenerateEvent(SHCNE_CREATE, pidlFolder, pidlConnection, NULL);
                                        pidlConnection.Clear();
                                    }

                                    ReleaseObj(pNetConDupe);
                                    pNetConDupe = NULL;
                                }
                            }

                            delete pszDupeName;
                        }
                    }
                    else
                    {
                        AssertSz(ccfe.GetCharacteristics() & NCCF_ALLOW_DUPLICATION,
                            "What menu supported duplicating this connection?");
                    }
                }

                ReleaseObj(pNetCon);
                pNetCon = NULL;
            }
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnCommandCreateCopy");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandProperties
//
//  Purpose:    Command handler for the CMIDM_PROPERTIES command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jeffspr   4 Nov 1997
//
//  Notes:
//
HRESULT HrOnCommandProperties(
    IN const PCONFOLDPIDLVEC&  apidl,
    IN HWND                 hwndOwner,
    LPSHELLFOLDER           psf)
{
    INT                 cch;
    HRESULT             hr                  = S_OK;
    HANDLE              hMutex              = NULL;
    INetConnection *    pNetCon             = NULL;
    WCHAR               szConnectionGuid [c_cchGuidWithTerm];

    // Just skip out of here if no pidl was supplied
    if (apidl.empty())
    {
        return S_OK;
    }

    // We can only deal with a single connection. If we have
    // multiple, then just use the first one.
    //
    const PCONFOLDPIDL& pcfp = apidl[0];

    if (pcfp.empty())
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // If this is an individual incoming connection - disallow this:
    if ( (NCCF_INCOMING_ONLY & pcfp->dwCharacteristics)  &&
         (NCM_NONE != pcfp->ncm) )
    {
        hr = E_UNEXPECTED;
        goto Error;
    }

    // If this is a LAN connection and the user doesn't have rights
    // then disallow properties
    //
    if ((IsMediaLocalType(pcfp->ncm)) &&
          !FHasPermission(NCPERM_LanProperties))
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto Error;
    }

    // If this is a RAS connection and the user doesn't have rights
    // then disallow properties
    //
    if (IsMediaRASType(pcfp->ncm))
    {
        BOOL fAllowProperties = (TRUE == ((pcfp->dwCharacteristics & NCCF_ALL_USERS) ?
            (FHasPermission(NCPERM_RasAllUserProperties)) :
            (FHasPermission(NCPERM_RasMyProperties))));

        if (!fAllowProperties)
        {
            hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            goto Error;
        }
    }


    hr = HrNetConFromPidl(apidl[0], &pNetCon);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Aquire a lock on this connection object
    //
    cch = StringFromGUID2 (pcfp->guidId, szConnectionGuid,
                           c_cchGuidWithTerm);
    Assert (c_cchGuidWithTerm == cch);
    hMutex = CreateMutex(NULL, TRUE, szConnectionGuid);
    if ((NULL == hMutex) || (ERROR_ALREADY_EXISTS == GetLastError()))
    {
        // if the mutex already exists try to find the connection window
        //
        if (ERROR_ALREADY_EXISTS == GetLastError())
        {
            Assert(pNetCon);
            ActivatePropertyDialog(pNetCon);
            Assert(S_OK == hr);

            // Don't let the error reporting below display the error.
            // We want the user to acknowledge the message box above
            // then we'll be nice an bring the property page to the
            // foreground.
            goto Error;
        }

        hr = HrFromLastWin32Error();
        goto Error;
    }

    Assert(SUCCEEDED(hr));

    // Bring up the connection Properties UI.
    //
    hr = HrRaiseConnectionPropertiesInternal(
        NULL,   // ISSUE: Going modal -- hwndOwner ? hwndOwner : GetDesktopWindow(),
        0, // First page
        pNetCon);

Error:
    if (FAILED(hr))
    {
        UINT ids = 0;

        switch(hr)
        {
        case E_UNEXPECTED:
            ids = IDS_CONFOLD_PROPERTIES_ON_RASSERVERINSTEAD;
            break;
        case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
            ids = IDS_CONFOLD_PROPERTIES_NOACCESS;
            break;
        case HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY):
            ids = IDS_CONFOLD_OUTOFMEMORY;
            break;
        default:
            ids = IDS_CONFOLD_UNEXPECTED_ERROR;
            break;
        }

        NcMsgBox(_Module.GetResourceInstance(), NULL, IDS_CONFOLD_WARNING_CAPTION,
                 ids, MB_ICONEXCLAMATION | MB_OK);
    }

    if (hMutex)
    {
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }

    ReleaseObj(pNetCon);

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnCommandProperties");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandWZCProperties
//
//  Purpose:    Command handler for the CMIDM_WZCPROPERTIES command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     deonb   5 Apr 2001
//
//  Notes:
//
HRESULT HrOnCommandWZCProperties(
    IN const PCONFOLDPIDLVEC&  apidl,
    IN HWND                 hwndOwner,
    LPSHELLFOLDER           psf)
{
    INT                 cch;
    HRESULT             hr                  = S_OK;
    HANDLE              hMutex              = NULL;
    INetConnection *    pNetCon             = NULL;
    WCHAR               szConnectionGuid [c_cchGuidWithTerm];

    // Just skip out of here if no pidl was supplied
    if (apidl.empty())
    {
        return S_OK;
    }

    // We can only deal with a single connection. If we have
    // multiple, then just use the first one.
    //
    const PCONFOLDPIDL& pcfp = apidl[0];

    if (pcfp.empty())
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // If this is a LAN connection and the user doesn't have rights
    // then disallow properties
    //
    if ((IsMediaLocalType(pcfp->ncm)) &&
          !FHasPermission(NCPERM_LanProperties))
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto Error;
    }

    // If this is a RAS connection and the user doesn't have rights
    // then disallow properties
    //
    if (IsMediaRASType(pcfp->ncm))
    {
        BOOL fAllowProperties = (TRUE == ((pcfp->dwCharacteristics & NCCF_ALL_USERS) ?
            (FHasPermission(NCPERM_RasAllUserProperties)) :
            (FHasPermission(NCPERM_RasMyProperties))));

        if (!fAllowProperties)
        {
            hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            goto Error;
        }
    }


    hr = HrNetConFromPidl(apidl[0], &pNetCon);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Aquire a lock on this connection object
    //
    cch = StringFromGUID2 (pcfp->guidId, szConnectionGuid,
                           c_cchGuidWithTerm);
    Assert (c_cchGuidWithTerm == cch);
    hMutex = CreateMutex(NULL, TRUE, szConnectionGuid);
    if ((NULL == hMutex) || (ERROR_ALREADY_EXISTS == GetLastError()))
    {
        // if the mutex already exists try to find the connection window
        //
        if (ERROR_ALREADY_EXISTS == GetLastError())
        {
            Assert(pNetCon);
            ActivatePropertyDialog(pNetCon);
            Assert(S_OK == hr);

            // Don't let the error reporting below display the error.
            // We want the user to acknowledge the message box above
            // then we'll be nice an bring the property page to the
            // foreground.
            goto Error;
        }

        hr = HrFromLastWin32Error();
        goto Error;
    }

    Assert(SUCCEEDED(hr));

    // Bring up the connection Properties UI.
    //
    hr = HrRaiseConnectionPropertiesInternal(
        NULL,   // ISSUE: Going modal -- hwndOwner ? hwndOwner : GetDesktopWindow(),
        1, // Second page
        pNetCon);

Error:
    if (FAILED(hr))
    {
        UINT ids = 0;

        switch(hr)
        {
        case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
            ids = IDS_CONFOLD_PROPERTIES_NOACCESS;
            break;
        case HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY):
            ids = IDS_CONFOLD_OUTOFMEMORY;
            break;
        default:
            ids = IDS_CONFOLD_UNEXPECTED_ERROR;
            break;
        }

        NcMsgBox(_Module.GetResourceInstance(), NULL, IDS_CONFOLD_WARNING_CAPTION,
                 ids, MB_ICONEXCLAMATION | MB_OK);
    }

    if (hMutex)
    {
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }

    ReleaseObj(pNetCon);

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnCommandProperties");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandWZCDlgShow
//
//  Purpose:    Command handler for the CMIDM_WZCDLG_SHOW command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     deonb   15 May 2001
//
//  Notes:
//
#define WZCDLG_FAILED            0x00010001     // 802.11 automatic configuration failed
HRESULT HrOnCommandWZCDlgShow(
    IN const PCONFOLDPIDLVEC&  apidl,
    IN HWND                 hwndOwner,
    LPSHELLFOLDER           psf)
{
    INT                 cch;
    HRESULT             hr  = S_OK;

    // Just skip out of here if no pidl was supplied
    if (apidl.empty())
    {
        return S_OK;
    }

    // We can only deal with a single connection. If we have
    // multiple, then just use the first one.
    //
    const PCONFOLDPIDL& pcfp = apidl[0];
    if (!pcfp.empty())
    {
        WZCDLG_DATA wzcDlgData = {0};
        wzcDlgData.dwCode = WZCDLG_FAILED;
        wzcDlgData.lParam = 1;

        BSTR szCookie = SysAllocStringByteLen(reinterpret_cast<LPSTR>(&wzcDlgData), sizeof(wzcDlgData));
        BSTR szName   = SysAllocString(pcfp->PszGetNamePointer());

        if (szCookie && szName)
        {
            GUID gdGuid = pcfp->guidId;
            hr = WZCOnBalloonClick(&gdGuid, szName, szCookie);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        SysFreeString(szName);
        SysFreeString(szCookie);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRaiseConnectionProperties
//
//  Purpose:    Public function for bringing up the propsheet page UI for
//              the passed in connection
//
//  Arguments:
//      hwnd  [in]  Owner hwnd
//      pconn [in]  Connection pointer passed in from the shell
//
//  Returns:
//
//  Author:     scottbri   3 Nov 1998
//
//  Notes:      Needs to convert the INetConnection * below into suitable
//              parameters for a call to HrOnCommandProperties above.
//
HRESULT HrRaiseConnectionProperties(HWND hwnd, INetConnection * pConn)
{
    HRESULT                 hr              = S_OK;
    PCONFOLDPIDL            pidl;
    PCONFOLDPIDLFOLDER      pidlFolder;
    LPSHELLFOLDER           psfConnections  = NULL;

    if (NULL == pConn)
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Create a pidl for the connection
    //
    hr = HrCreateConFoldPidl(WIZARD_NOT_WIZARD, pConn, pidl);
    if (SUCCEEDED(hr))
    {
        // Get the pidl for the Connections Folder
        //
        hr = HrGetConnectionsFolderPidl(pidlFolder);
        if (SUCCEEDED(hr))
        {
            // Get the Connections Folder object
            //
            hr = HrGetConnectionsIShellFolder(pidlFolder, &psfConnections);
            if (SUCCEEDED(hr))
            {
                PCONFOLDPIDLVEC vecPidls;
                vecPidls.push_back(pidl);
                hr = HrOnCommandProperties(vecPidls, hwnd, psfConnections);
                ReleaseObj(psfConnections);
            }
        }
    }

Error:
    TraceHr(ttidError, FAL, hr, FALSE, "HrRaiseConnectionProperties");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandConnectInternal
//
//  Purpose:    The guts of the Connect code. This is called both from
//              HrOnCommandConnect and from HrOnCommandNewConnection, since
//              that now connects after creating the new connection
//
//  Arguments:
//      pNetCon   [in]  INetConnection * of the connection to activate
//      hwndOwner [in]  Our parent hwnd
//      pcfp      [in]  Our pidl structure
//      psf       [in]  Shell Folder
//
//  Returns:
//
//  Author:     jeffspr   10 Jun 1998
//
//  Notes:
//
HRESULT HrOnCommandConnectInternal(
    INetConnection *    pNetCon,
    HWND                hwndOwner,
    const PCONFOLDPIDL& pcfp,
    LPSHELLFOLDER       psf)
{
    HRESULT             hr          = S_OK;
    CConnectionFolder * pcf         = static_cast<CConnectionFolder *>(psf);

    NETCFG_TRY
        PCONFOLDPIDLFOLDER  pidlFolder;
        if (pcf)
        {
            pidlFolder = pcf->PidlGetFolderRoot();
        }

        BOOL                fActivating = FALSE;

        // Use a separate var so we can keep track of the result of the connect
        // and the result of the get_Status.
        //
        HRESULT         hrConnect   = S_OK;

        Assert(pNetCon);
        Assert(psf);

        // Get current activation state
        //
        CONFOLDENTRY cfEmpty;
        (void) HrCheckForActivation(pcfp, cfEmpty, &fActivating);

        // Check for rights to connect
        //
        if (((IsMediaLocalType(pcfp->ncm)) && !FHasPermission(NCPERM_LanConnect)) ||
            ((IsMediaRASType(pcfp->ncm)) && !FHasPermission(NCPERM_RasConnect)))
        {
            (void) NcMsgBox(
                _Module.GetResourceInstance(),
                NULL,
                IDS_CONFOLD_WARNING_CAPTION,
                IDS_CONFOLD_CONNECT_NOACCESS,
                MB_OK | MB_ICONEXCLAMATION);
        }
        // Drop out of this call unless we're currently disconnected.
        //
        else if (pcfp->ncs == NCS_DISCONNECTED && !fActivating)
        {
            // Ignore the return code. Failing to set this flag shouldn't keep
            // us from attempting to connect.
            //
            (void) HrSetActivationFlag(pcfp, cfEmpty, TRUE);

            // Get the INetConnectionConnectUi interface and make the connection
            // Get the hr (for debugging), but we want to update the status
            // of the connection even if the connect failed
            //
            hrConnect = HrConnectOrDisconnectNetConObject(
                // It's OK if the hwnd is NULL. We don't want to go modal
                // on the desktop.
                NULL, // FIXED -- Was going modal with   hwndOwner ? hwndOwner : GetDesktopWindow(),
                pNetCon,
                CD_CONNECT);

            // Even on failure, we want to continue, because we might find that
            // the device is now listed as unavailable. On cancel (S_FALSE), we
            // don't have that concern.
            //
            if (S_FALSE != hrConnect)
            {
                // Even on failure, we want to continue, because we might find that
                // the device is now listed as unavailable.
                if (FAILED(hrConnect))
                {
                    TraceTag(ttidShellFolder, "HrOnCommandConnect: Connect failed, 0x%08x", hrConnect);
                }

    #if 0   // (JEFFSPR) - 11/20/98 turning this on until the notify COM failures are worked out.
            // Now taken care of by the notification engine.
            //
                // Get the new status from the connection
                //
                NETCON_PROPERTIES * pProps;
                hr = pNetCon->GetProperties(&pProps);
                if (SUCCEEDED(hr))
                {
                    // This won't necessarily be connected -- we used to assert here, but it's
                    // actually possible for the connection to go dead between when we connect
                    // and when we ask for the status.
                    //
                    hr = HrUpdateConnectionStatus(pcfp, pProps->Status, pidlFolder, TRUE, pProps->dwCharacter);

                    FreeNetconProperties(pProps);
                }
    #endif
            }
            else
            {
                // hrConnect is S_FALSE. Pass that on.
                //
                hr = hrConnect;
            }

            // Set us as "not in the process of activating"
            //
            hr = HrSetActivationFlag(pcfp, cfEmpty, FALSE);
        }
        else
        {
            if ((IsMediaRASType(pcfp->ncm)) &&
                (pcfp->ncm != NCM_NONE))
            {
                // For non-LAN connections, attempt to bring the RAS dialer UI
                // into focus instead of putting up an error message

                HWND                hwndDialer;
                LPWSTR              pszTitle;
                NETCON_PROPERTIES * pProps;

                hr = pNetCon->GetProperties(&pProps);
                if (SUCCEEDED(hr))
                {
                    DwFormatStringWithLocalAlloc(SzLoadIds(IDS_CONFOLD_RAS_DIALER_TITLE_FMT),
                                                 &pszTitle, pProps->pszwName);

                    hwndDialer = FindWindowEx(NULL, NULL, L"#32770", pszTitle);
                    if (hwndDialer)
                    {
                        SetForegroundWindow(hwndDialer);
                    }

                    FreeNetconProperties(pProps);
                    MemFree(pszTitle);
                }
            }
            else if (fActivating)
            {
                (void) NcMsgBox(
                    _Module.GetResourceInstance(),
                    NULL,
                    IDS_CONFOLD_WARNING_CAPTION,
                    IDS_CONFOLD_CONNECT_IN_PROGRESS,
                    MB_OK | MB_ICONEXCLAMATION);
            }
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandConnectInternal");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandFixInternal
//
//  Purpose:    handle the fix and bring up the progress dialog
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
HRESULT HrOnCommandFixInternal(
    const CONFOLDENTRY&   ccfe,
    HWND            hwndOwner,
    LPSHELLFOLDER   psf)
{
    HRESULT             hr              = S_OK;
    INetConnection *    pNetCon         = NULL;
    CConnectionFolder * pcf             = static_cast<CConnectionFolder *>(psf);

    Assert(!ccfe.empty());

    NETCON_MEDIATYPE ncmType = ccfe.GetNetConMediaType();

    //fix is only avalable for LAN and bridge connections
    if (NCM_LAN != ncmType && NCM_BRIDGE != ncmType)
    {
        return S_FALSE;
    }

    hr = ccfe.HrGetNetCon(IID_INetConnection, reinterpret_cast<VOID**>(&pNetCon));
    if (SUCCEEDED(hr))
    {
        NETCON_PROPERTIES* pProps;
        hr = pNetCon->GetProperties(&pProps);
        if (SUCCEEDED(hr))
        {
            tstring strMessage = L"";
            CLanConnectionUiDlg dlg;
            HWND                hwndDlg;

            //bring up the dialog to tell the user we're doing the fix
            dlg.SetConnection(pNetCon);
            hwndDlg = dlg.Create(hwndOwner);

            PCWSTR szw = SzLoadIds(IDS_FIX_REPAIRING);
            SetDlgItemText(hwndDlg, IDC_TXT_Caption, szw);

            //do the fix
            hr = HrTryToFix(pProps->guidId, strMessage);
            FreeNetconProperties(pProps);

            if (NULL != hwndDlg)
            {
                DestroyWindow(hwndDlg);
            }

            //tell users the results
            NcMsgBox(_Module.GetResourceInstance(),
                NULL,
                IDS_FIX_CAPTION,
                IDS_FIX_MESSAGE,
                MB_OK | MB_TOPMOST,
                strMessage.c_str());
        }

        ReleaseObj(pNetCon);
    }

    TraceHr(ttidShellFolder, FAL, hr, (S_FALSE == hr), "HrOnCommandFixInternal");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandFix
//
//  Purpose:    Command handler for the CMIDM_FIX command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
HRESULT HrOnCommandFix(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT            hr          = S_OK;
    CONFOLDENTRY       ccfe;

    if (!apidl.empty())
    {
        hr = apidl[0].ConvertToConFoldEntry(ccfe);
        if (SUCCEEDED(hr))
        {
            if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL))
            {
                TraceTag(ttidError, "Could not set priority for Repair thread");
            }

            // We don't care if whether the fix succeeds or not
            // if it fails, there will be a pop-up saying that

            HrOnCommandFixInternal(ccfe, hwndOwner, psf);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnCommandFix");
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandConnect
//
//  Purpose:    Command handler for the CMIDM_CONNECT or CMIDM_ENABLE command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jeffspr   12 Nov 1997
//
//  Notes:
//
HRESULT HrOnCommandConnect(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT             hr          = S_OK;
    INetConnection *    pNetCon     = NULL;

    NETCFG_TRY
        if (apidl.size() == 1)
        {
            PCONFOLDPIDL pcfp = apidl[0];
            if (!pcfp.empty())
            {
                // Get the cached pidl. If it's found, then use the copy. If not
                // then use whatever info we have (but this might be outdated)
                //
                PCONFOLDPIDL pcfpCopy;
                hr = g_ccl.HrGetCachedPidlCopyFromPidl(apidl[0], pcfpCopy);
                if (S_OK == hr)
                {
                    pcfp.Swop(pcfpCopy); // pcfp = pcfpCopy;
                }
                else
                {
                    TraceHr(ttidShellFolder, FAL, hr, FALSE, "Cached pidl not retrievable in HrOnCommandConnect");
                }

                // Make sure that this connection is valid for connection (not a wizrd,
                // and not already connected. If so, then connect.
                //
                if ( (WIZARD_NOT_WIZARD == pcfp->wizWizard) && !(fIsConnectedStatus(pcfp->ncs)) )
                {
                    // Ignore this entry if we're getting a connect verb on an incoming connections
                    // object
                    //
                    if (pcfp->ncm != NCM_NONE && (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY)))
                    {
                        // Get the INetConnection object from the persist data
                        //
                        hr = HrNetConFromPidl(apidl[0], &pNetCon);
                        if (SUCCEEDED(hr))
                        {
                            hr = HrOnCommandConnectInternal(pNetCon, hwndOwner, pcfp, psf);
                            ReleaseObj(pNetCon);
                        }
                    }
                }
            }
          //  else if (FIsConFoldPidl98(apidl[0]) && FALSE )
    //        {
    //            // ISSUE - FIsConFoldPidl98 doesn't give ua a wizWizard anymore! Used to be:
    //            // FIsConFoldPidl98(apidl[0], &fIsWizard) && !fIsWizard)
    //
    //            // raise an error that the connection is not found
    //            //
    //            NcMsgBox(_Module.GetResourceInstance(), NULL,
    //                     IDS_CONFOLD_WARNING_CAPTION,
    //                     IDS_CONFOLD_NO_CONNECTION,
    //                     MB_ICONEXCLAMATION | MB_OK);
    //        }
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnCommandConnect");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDisconnectInternal
//
//  Purpose:    Internal command handler for the CMIDM_DISCONNECT or CMIDM_DISABLE command.
//              This function is callable by the tray, which doesn't have
//              the data in pidls, but rather has the actual data that we're
//              concerned with. HrOnCommandDisconnect retrieves this data
//              and passes on the call to this function
//
//  Arguments:
//      ccfe      [in]  Our ConFoldEntry (our connection data)
//      hwndOwner [in]  Our parent hwnd
//
//  Returns:
//
//  Author:     jeffspr   20 Mar 1998
//
//  Notes:
//
HRESULT HrOnCommandDisconnectInternal(
    const CONFOLDENTRY&   ccfe,
    HWND            hwndOwner,
    LPSHELLFOLDER   psf)
{
    HRESULT             hr              = S_OK;
    INetConnection *    pNetCon         = NULL;
    CConnectionFolder * pcf             = static_cast<CConnectionFolder *>(psf);

    Assert(!ccfe.empty());

    // Check for rights to disconnect
    //
    if (((IsMediaLocalType(ccfe.GetNetConMediaType())) && !FHasPermission(NCPERM_LanConnect)) ||
        ((IsMediaRASType(ccfe.GetNetConMediaType())) && !FHasPermission(NCPERM_RasConnect)))
    {
        (void) NcMsgBox(
            _Module.GetResourceInstance(),
            NULL,
            IDS_CONFOLD_WARNING_CAPTION,
            IDS_CONFOLD_DISCONNECT_NOACCESS,
            MB_OK | MB_ICONEXCLAMATION);
    }
    else
    {
        PromptForSyncIfNeeded(ccfe, hwndOwner);

        {
            CWaitCursor wc;     // Bring up wait cursor now. Remove when we go out of scope.

            // Get the INetConnection object from the persist data
            //
            hr = ccfe.HrGetNetCon(IID_INetConnection, reinterpret_cast<VOID**>(&pNetCon));
            if (SUCCEEDED(hr))
            {
                Assert(pNetCon);

                hr = HrConnectOrDisconnectNetConObject (
                        hwndOwner, pNetCon, CD_DISCONNECT);

                ReleaseObj(pNetCon);
            }
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, (S_FALSE == hr), "HrOnCommandDisconnectInternal");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDisconnect
//
//  Purpose:    Command handler for the CMIDM_DISCONNECT or CMIDM_DISABLE command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jeffspr   12 Nov 1997
//
//  Notes:  We only act on a single entry in this function
//
HRESULT HrOnCommandDisconnect(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT            hr          = S_OK;
    CONFOLDENTRY       ccfe;

    if (!apidl.empty())
    {
        hr = apidl[0].ConvertToConFoldEntry(ccfe);
        if (SUCCEEDED(hr))
        {
            hr = HrOnCommandDisconnectInternal(ccfe, hwndOwner, psf);

            // Normalize the return code. We don't care if whether the connection
            // was actually disconnected or not (if canceled, it would have \
            // returned S_FALSE;
            //
            if (SUCCEEDED(hr))
            {
                hr = S_OK;
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnCommandDisconnect");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandStatusInternal
//
//  Purpose:    Internal command handler for the CMIDM_STATUS command.
//              This function is callable by the tray, which doesn't have
//              the data in pidls, but rather has the actual data that we're
//              concerned with. HrOnCommandStatus retrieves this data
//              and passes on the call to this function
//
//  Arguments:
//      ccfe [in]  ConFoldEntry for the connection in question
//      fCreateEngine [in] Whether a status engine should be created if not exist
//
//  Returns:
//
//  Author:     jeffspr   20 Mar 1998
//
//  Notes:
//
HRESULT HrOnCommandStatusInternal(
    const CONFOLDENTRY& ccfe,
    BOOL            fCreateEngine)
{
    HRESULT hr  = S_OK;

    Assert(!ccfe.empty());

    // see if we are in safe mode with networking
    int iRet = GetSystemMetrics(SM_CLEANBOOT);
    if (!iRet)
    {
        // normal boot
        Assert(g_hwndTray);

        // The permissions check will be done in the tray message processing.
        //
        PostMessage(g_hwndTray, MYWM_OPENSTATUS, (WPARAM) ccfe.TearOffItemIdList(), (LPARAM) fCreateEngine);
    }
    else if (2 == iRet)
    {
        // safemode with networking, statmon is not tied to tray icon
        if (FHasPermission(NCPERM_Statistics))
        {
            INetStatisticsEngine* pnseNew;
            hr = HrGetStatisticsEngineForEntry(ccfe, &pnseNew, TRUE);
            if (SUCCEEDED(hr))
            {
                hr = pnseNew->ShowStatusMonitor();
                ReleaseObj(pnseNew);
            }
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandStatusInternal");
    return hr;
}

//+-------------------------------