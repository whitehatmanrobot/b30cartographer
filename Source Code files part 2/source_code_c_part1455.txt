Event).
	//
	// This means that the base dispatcher is able to invoke simple COM objects.  If you
	// provide your own CallObject() routine, your routine call delegate this this base
	// implementation if you want to "inherit" this functionality.
	if (!pUnkSink) {
		return (E_POINTER);
	}
	pSink = pUnkSink;
	if (!pSink) {
		pSinkDisp = pUnkSink;
	}
	if (!pSink && !pSinkDisp) {
		return (E_NOINTERFACE);
	}
	if (pSink) {
		hrRes = pSink->OnEvent();
		return (S_OK);
	}
	hrRes = pSinkDisp->Invoke(DISPID_VALUE,
							  IID_NULL,
							  GetUserDefaultLCID(),
							  DISPATCH_METHOD,
							  &dpNoArgs,
							  NULL,
							  NULL,
							  NULL);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT CEventBaseDispatcher::CParams::Abort() {

	return (S_FALSE);
}


HRESULT CEventBaseDispatcher::Dispatcher(REFGUID rguidEventType, CParams *pParams) {
	HRESULT hrRes;
	CETData *petdData;
	BOOL bObjectCalled = FALSE;

	petdData = m_Data.Find(rguidEventType);
	if (!petdData) {
		return (S_FALSE);
	}
	for (DWORD dwIdx=0;dwIdx<petdData->Count();dwIdx++) {
		if (!petdData->Index(dwIdx)->m_bIsValid) {
			continue;
		}
		if (bObjectCalled && petdData->Index(dwIdx)->m_bExclusive) {
			continue;
		}
		if (pParams->Abort() == S_OK) {
			break;
		}
		hrRes = pParams->CheckRule(*petdData->Index(dwIdx));
		if (hrRes == S_OK) {
			if (pParams->Abort() == S_OK) {
				break;
			}
			hrRes = pParams->CallObject(m_piEventManager,*petdData->Index(dwIdx));
			if (!SUCCEEDED(hrRes)) {
				continue;
			}
			bObjectCalled = TRUE;
			if ((hrRes == S_FALSE) || petdData->Index(dwIdx)->m_bExclusive) {
				break;
			}
		}
	}
	return (bObjectCalled?S_OK:S_FALSE);
}


HRESULT CEventBaseDispatcher::SetContext(REFGUID rguidEventType, IEventRouter *piRouter, IEventBindings *piBindings) {
	CETData* petData;
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkEnum;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnum;

	if (!piRouter || !piBindings) {
		return (E_POINTER);
	}
	if (!m_piEventManager) {
		hrRes = CoCreateInstance(CLSID_CEventManager,
								 NULL,
								 CLSCTX_ALL,
								 IID_IEventManager,
								 (LPVOID *) &m_piEventManager);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		m_piRouter = piRouter;
	}
	petData = m_Data.Find(rguidEventType);
	if (!petData) {
		hrRes = AllocETData(rguidEventType,piBindings,&petData);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		petData->m_guidEventType = rguidEventType;
		hrRes = m_Data.Add(petData);
		if (!SUCCEEDED(hrRes)) {
			delete petData;
			return (hrRes);
		}
	}
	petData->RemoveAll();
	hrRes = piBindings->get__NewEnum(&pUnkEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pEnum = pUnkEnum;
	if (!pEnum) {
		return (E_NOINTERFACE);
	}
	while (1) {
		CComVariant varValue;
		CComQIPtr<IEventBinding,&IID_IEventBinding> pBinding;
		CBinding *pNewBinding;

		varValue.Clear();
		hrRes = pEnum->Next(1,&varValue,NULL);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			break;
		}
		hrRes = varValue.ChangeType(VT_UNKNOWN);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			continue;
		}
		pBinding = varValue.punkVal;
		if (!pBinding) {
			_ASSERTE(FALSE);
			continue;
		}
		hrRes = AllocBinding(rguidEventType,pBinding,&pNewBinding);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = pNewBinding->Init(pBinding);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = petData->Add(pNewBinding);
		if (!SUCCEEDED(hrRes)) {
			delete pNewBinding;
			return (hrRes);
		}
	}
	return (S_OK);
}


CEventBaseDispatcher::CETData::CETData() {

	// nothing
}


CEventBaseDispatcher::CETData::~CETData() {

	// nothing
}


CEventBaseDispatcher::CETData* CEventBaseDispatcher::CETDataList::Find(REFGUID guidEventType) {

	// tbd - optimize
	for (DWORD dwIdx=0;dwIdx<Count();dwIdx++) {
		if (Index(dwIdx)->m_guidEventType == guidEventType) {
			return (Index(dwIdx));
		}
	}
	return (NULL);
}


HRESULT CEventBaseDispatcher::AllocBinding(REFGUID rguidEventType,
										   IEventBinding *piBinding,
										   CBinding **ppNewBinding) {

	if (ppNewBinding) {
		*ppNewBinding = NULL;
	}
	if (!piBinding || !ppNewBinding) {
		return (E_POINTER);
	}
	*ppNewBinding = new CBinding;
	if (!*ppNewBinding) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT CEventBaseDispatcher::AllocETData(REFGUID guidEventType,
										  IEventBindings *piBindings,
										  CETData **ppNewETData) {

	if (ppNewETData) {
		*ppNewETData = NULL;
	}
	if (!piBindings || !ppNewETData) {
		return (E_POINTER);
	}
	*ppNewETData = new CETData;
	if (!*ppNewETData) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


static HRESULT SEOGetSources(REFGUID rguidSourceType, IEventSources **ppSources) {
	HRESULT hrRes;
	CComPtr<IEventManager> pManager;
	CComPtr<IEventSourceTypes> pSourceTypes;
	CComPtr<IEventSourceType> pSourceType;
	CComPtr<IEventSources> pSources;

	if (ppSources) {
		*ppSources = NULL;
	}
	if (!ppSources) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = CoCreateInstance(CLSID_CEventManager,NULL,CLSCTX_ALL,IID_IEventManager,(LPVOID *) &pManager);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = pManager->get_SourceTypes(&pSourceTypes);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = pSourceTypes->Item(&CComVariant((LPCOLESTR) CStringGUID(rguidSourceType)),&pSourceType);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSourceType) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = pSourceType->get_Sources(ppSources);
error:
	return (hrRes);
}


static HRESULT SEOGetSourcesEnum(REFGUID rguidSourceType, IEnumVARIANT **ppEnum) {
	HRESULT hrRes;
	CComPtr<IEventSources> pSources;
	CComPtr<IUnknown> pUnkEnum;

	if (ppEnum) {
		*ppEnum = NULL;
	}
	if (!ppEnum) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSources(rguidSourceType,&pSources);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSources) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = pSources->get__NewEnum(&pUnkEnum);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = pUnkEnum->QueryInterface(IID_IEnumVARIANT,(LPVOID *) ppEnum);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, REFGUID rguidSource, IEventSource **ppSource) {
	HRESULT hrRes;
	CComPtr<IEventSources> pSources;

	if (ppSource) {
		*ppSource = NULL;
	}
	if (!ppSource) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSources(rguidSourceType,&pSources);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSources) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = pSources->Item(&CComVariant((LPCOLESTR) CStringGUID(rguidSource)),ppSource);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, REFGUID rguidSourceBase, DWORD dwSourceIndex, IEventSource **ppSource) {

	return (SEOGetSource(rguidSourceType,(REFGUID) CStringGUID(rguidSourceBase,dwSourceIndex),ppSource));
}


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszDisplayName, IEventSource **ppSource) {
	HRESULT hrRes;
	CComPtr<IEnumVARIANT> pEnum;
	CComVariant varValue;
	CComQIPtr<IEventSource,&IID_IEventSource> pSource;
	CComBSTR strDisplayName;
	CComBSTR strDesiredName;

	if (ppSource) {
		*ppSource = NULL;
	}
	if (!ppSource || !pszDisplayName) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSourcesEnum(rguidSourceType,&pEnum);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pEnum) {
		hrRes = S_FALSE;
		goto error;
	}
	strDesiredName = pszDisplayName;
	while (1) {
		varValue.Clear();
		hrRes = pEnum->Next(1,&varValue,NULL);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		if (hrRes == S_FALSE) {
			break;
		}
		hrRes = varValue.ChangeType(VT_UNKNOWN);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		pSource = varValue.punkVal;
		if (!pSource) {
			hrRes = E_NOINTERFACE;
			goto error;
		}
		strDisplayName.Empty();
		hrRes = pSource->get_DisplayName(&strDisplayName);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		if (wcscmp(strDisplayName,strDesiredName) == 0) {
			*ppSource = pSource;
			(*ppSource)->AddRef();
			hrRes = S_OK;
			break;
		}
	}
error:
	return (hrRes);
}


class CValueBase {
	public:
		virtual BOOL Match(VARIANT *pValue) = 0;
};


static HRESULT SEOGetSource(REFGUID rguidSourceType, LPCSTR pszProperty, CValueBase *pValue, IEventSource **ppSource) {
	HRESULT hrRes;
	CComPtr<IEnumVARIANT> pEnum;
	CComVariant varValue;
	CComQIPtr<IEventSource,&IID_IEventSource> pSource;
	CComVariant varProperty;
	CComPtr<IEventPropertyBag> pProperties;

	if (ppSource) {
		*ppSource = NULL;
	}
	if (!ppSource || !pszProperty) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSourcesEnum(rguidSourceType,&pEnum);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pEnum) {
		hrRes = S_FALSE;
		goto error;
	}
	varProperty = pszProperty;
	while (1) {
		varValue.Clear();
		hrRes = pEnum->Next(1,&varValue,NULL);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		if (hrRes == S_FALSE) {
			break;
		}
		hrRes = varValue.ChangeType(VT_UNKNOWN);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		pSource = varValue.punkVal;
		if (!pSource) {
			hrRes = E_NOINTERFACE;
			goto error;
		}
		pProperties.Release();
		hrRes = pSource->get_Properties(&pProperties);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		varValue.Clear();
		hrRes = pProperties->Item(&varProperty,&varValue);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		if (hrRes == S_FALSE) {
			continue;
		}
		if (pValue->Match(&varValue)) {
			*ppSource = pSource;
			(*ppSource)->AddRef();
			hrRes = S_OK;
			break;
		}
	}
error:
	return (hrRes);
}


class CValueDWORD : public CValueBase {
	public:
		CValueDWORD(DWORD dwValue) {
			m_dwValue = dwValue;
		};
		virtual BOOL Match(VARIANT *pValue) {
			HRESULT hrRes = VariantChangeType(pValue,pValue,0,VT_I4);
			if (!SUCCEEDED(hrRes)) {
				return (FALSE);
			}
			if ((DWORD) pValue->lVal != m_dwValue) {
				return (FALSE);
			}
			return (TRUE);
		};
	private:
		DWORD m_dwValue;
};


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszProperty, DWORD dwValue, IEventSource **ppSource) {

	return (SEOGetSource(rguidSourceType,pszProperty,&CValueDWORD(dwValue),ppSource));
}


class CValueBSTR : public CValueBase {
	public:
		CValueBSTR(LPCWSTR pszValue) {
			m_strValue = SysAllocString(pszValue);
		};
		CValueBSTR(LPCSTR pszValue) {
			USES_CONVERSION;
			m_strValue = SysAllocString(A2W(pszValue));
		};
		~CValueBSTR() {
			SysFreeString(m_strValue);
		};
		virtual BOOL Match(VARIANT *pValue) {
			HRESULT hrRes = VariantChangeType(pValue,pValue,0,VT_BSTR);
			if (!SUCCEEDED(hrRes)) {
				return (FALSE);
			}
			if (wcscmp(pValue->bstrVal,m_strValue) != 0) {
				return (FALSE);
			}
			return (TRUE);
		};
	private:
		BSTR m_strValue;
};


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszProperty, LPCSTR pszValue, IEventSource **ppSource) {

	return (SEOGetSource(rguidSourceType,pszProperty,&CValueBSTR(pszValue),ppSource));
}


static HRESULT SEOGetRouter(IEventSource *pSource, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventBindingManager> pManager;
	CComPtr<IEventRouter> pRouter;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!pSource || !ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = pSource->GetBindingManager(&pManager);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = CoCreateInstance(CLSID_CEventRouter,NULL,CLSCTX_ALL,IID_IEventRouter,(LPVOID *) &pRouter);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = pRouter->put_Database(pManager);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	*ppRouter = pRouter;
	(*ppRouter)->AddRef();
error:
	return (hrRes);
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, REFGUID rguidSource, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventSource> pSource;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSource(rguidSourceType,rguidSource,&pSource);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSource) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = SEOGetRouter(pSource,ppRouter);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, REFGUID rguidSourceBase, DWORD dwSourceIndex, IEventRouter **ppRouter) {

	return (SEOGetRouter(rguidSourceType,(REFGUID) CStringGUID(rguidSourceBase,dwSourceIndex),ppRouter));
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszDisplayName, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventSource> pSource;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSource(rguidSourceType,pszDisplayName,&pSource);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSource) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = SEOGetRouter(pSource,ppRouter);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszProperty, DWORD dwValue, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventSource> pSource;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSource(rguidSourceType,pszProperty,dwValue,&pSource);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSource) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = SEOGetRouter(pSource,ppRouter);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszProperty, LPCSTR pszValue, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventSource> pSource;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSource(rguidSourceType,pszProperty,pszValue,&pSource);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSource) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = SEOGetRouter(pSource,ppRouter);
error:
	return (hrRes);
}


#include <initguid.h>

// This CLSID must match the one in SEO.DLL.
// {A4BE1350-1051-11d1-AA1E-00AA006BC80B}
DEFINE_GUID(CLSID_CEventServiceObject,
0xa4be1350, 0x1051, 0x11d1, 0xaa, 0x1e, 0x0, 0xaa, 0x0, 0x6b, 0xc8, 0xb);


STDMETHODIMP SEOGetServiceHandle(IUnknown **ppUnkHandle) {

	return (CoCreateInstance(CLSID_CEventServiceObject,
							 NULL,
							 CLSCTX_ALL,
							 IID_IUnknown,
							 (LPVOID *) ppUnkHandle));
}


STDMETHODIMP SEOCreateObject(VARIANT *pvarClass,
							 IEventBinding *pBinding,
							 IUnknown *pInitProperties,
							 REFIID iidDesired,
							 IUnknown **ppUnkObject) {

	return (SEOCreateObjectEx(pvarClass,pBinding,pInitProperties,iidDesired,NULL,ppUnkObject));
}


STDMETHODIMP SEOCreateObjectEx(VARIANT *pvarClass,
							   IEventBinding *pBinding,
							   IUnknown *pInitProperties,
							   REFIID iidDesired,
							   IUnknown *pUnkCreateOptions,
							   IUnknown **ppUnkObject) {
	HRESULT hrRes;
	CStringGUID objGuid;
	BSTR strClass;
	CComQIPtr<IEventCreateOptions,&IID_IEventCreateOptions> pOpt;

	if (ppUnkObject) {
		*ppUnkObject = NULL;
	}
	if (!pvarClass || !ppUnkObject) {
		return (E_POINTER);
	}
	if (pUnkCreateOptions) {
		pOpt = pUnkCreateOptions;
	}
	if (pvarClass->vt == VT_BSTR) {
		strClass = pvarClass->bstrVal;
	} else if (pvarClass->vt == (VT_BYREF|VT_BSTR)) {
		strClass = *pvarClass->pbstrVal;
	} else {
		hrRes = VariantChangeType(pvarClass,pvarClass,0,VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		strClass = pvarClass->bstrVal;
	}
	objGuid.CalcFromProgID(strClass);
	if (!objGuid) {
		objGuid = strClass;
		if (!objGuid) {
			CComPtr<IBindCtx> pBindCtx;
			CComPtr<IMoniker> pMoniker;
			DWORD dwEaten;

			if (!pOpt || ((hrRes=pOpt->CreateBindCtx(0,&pBindCtx))==E_NOTIMPL)) {
				hrRes = CreateBindCtx(0,&pBindCtx);
			}
			_ASSERTE(SUCCEEDED(hrRes));
			if (SUCCEEDED(hrRes)) {
				if (!pOpt || ((hrRes=pOpt->MkParseDisplayName(pBindCtx,
															  strClass,
															  &dwEaten,
															  &pMoniker))==E_NOTIMPL)) {
					hrRes = MkParseDisplayName(pBindCtx,strClass,&dwEaten,&pMoniker);
				}
			}
			_ASSERTE(!SUCCEEDED(hrRes)||pMoniker);
			if (!SUCCEEDED(hrRes)) {
#if 0	// tbd - We try both the normal and the Ex versions of MkParseDisplayName.  Just use one.
				pBindCtx.Release();
				hrRes = CreateBindCtx(0,&pBindCtx);
				_ASSERTE(SUCCEEDED(hrRes));
				if (!SUCCEEDED(hrRes)) {
					return (hrRes);
				}
				if (!pOpt||((hrRes=pOpt->MkParseDisplayNameEx(pBindCtx,
															  strClass,
															  &dwEaten,
															  &pMoniker))==E_NOTIMPL) {
					hrRes = MkParseDisplayNameEx(pBindCtx,strClass,&dwEaten,&pMoniker);
				}
				_ASSERTE(!SUCCEEDED(hrRes)||pMoniker);
				if (!SUCCEEDED(hrRes)) {
					return (hrRes);
				}
#else
				return (hrRes);
#endif
			}
			pBindCtx.Release();
			if (!pOpt || ((hrRes=pOpt->CreateBindCtx(0,&pBindCtx))==E_NOTIMPL)) {
				hrRes = CreateBindCtx(0,&pBindCtx);
			}
			if (!SUCCEEDED(hrRes)) {
				_ASSERTE(FALSE);
				return (hrRes);
			}
			if (!pOpt || ((hrRes=pOpt->BindToObject(pMoniker,
													pBindCtx,
													NULL,
													iidDesired,
													(LPVOID *) ppUnkObject))==E_NOTIMPL)) {
				hrRes = pMoniker->BindToObject(pBindCtx,NULL,iidDesired,(LPVOID *) ppUnkObject);
			}
			_ASSERTE(!SUCCEEDED(hrRes)||!*ppUnkObject);
			// Fall through
		}
	}
	// At this point, objGuid will only be TRUE if either CalcFromProgID or
	// operator =(LPCOLESTR) succeeded.  If both of these failed, then it will
	// be FALSE and we will have attempted to interpret the SinkClass as a
	// moniker.
	if (!!objGuid) {	// Use !! to hack-past ambiguous-conversion issues...
		if (!pOpt || ((hrRes=pOpt->CoCreateInstance(objGuid,
													NULL,
													CLSCTX_ALL,
													iidDesired,
													(LPVOID *) ppUnkObject))==E_NOTIMPL)) {
			hrRes = CoCreateInstance(objGuid,NULL,CLSCTX_ALL,iidDesired,(LPVOID *) ppUnkObject);
		}
		_ASSERTE(!SUCCEEDED(hrRes)||*ppUnkObject);
	}
	// At this point, hrRes has the result either from pMoniker->BindToObject or
	// CoCreateInstance.
	if (SUCCEEDED(hrRes)) {
		if (!pOpt || ((hrRes=pOpt->Init(iidDesired,ppUnkObject,pBinding,pInitProperties))==E_NOTIMPL)) {
			hrRes = S_OK;
			CComQIPtr<IEventPersistBinding,&IID_IEventPersistBinding> pBindingInit;

			if (pBinding) {
				pBindingInit = *ppUnkObject;
			}
			if (pBindingInit) {
				HRESULT hrResTmp;

				hrResTmp = pBindingInit->Load(pBinding);
				_ASSERTE(SUCCEEDED(hrResTmp));
			} else {
				CComQIPtr<IPersistPropertyBag,&IID_IPersistPropertyBag> pInit;

				if (pInitProperties) {
					pInit = *ppUnkObject;
				}
				if (pInit) {
					HRESULT hrResTmp;
					CComQIPtr<IPropertyBag,&IID_IPropertyBag> pProps;

					pProps = pInitProperties;
					_ASSERTE(pProps);
					if (pProps) {
						hrResTmp = pInit->InitNew();
						_ASSERTE(SUCCEEDED(hrResTmp));
						if (SUCCEEDED(hrResTmp)) {
							hrResTmp = pInit->Load(pProps,NULL);	// tbd - pass an IErrorLog object
							_ASSERTE(SUCCEEDED(hrResTmp));
						}
					}
				}
			}
		}
		if (!SUCCEEDED(hrRes)) {
			(*ppUnkObject)->Release();
			*ppUnkObject = NULL;
		}
	}
	return (hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop\dll\dispatch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	dispatch.h

Abstract:

	This module contains the class definition for the Server
	Extension Object Dispatcher service.

Author:

	Andy Jacobs	(andyj@microsoft.com)

Revision History:

	andyj	12/04/96	created
	andyj	02/12/97	Converted PropertyBag's to Dictonary's
	dondu	03/14/97	Major rewrite
	dondu	03/31/97	Updated for ISEODispatcher::SetContext

--*/


/*
	Typical usage...

	class CMyDispatcher :
		public CSEOBaseDispatcher,
		public IMyDispatcher,
		public CComObjectRoot,
		public CCoClass<CMyDispatcher,CLSID_CCMyDispatcher> {

		DECLARE_PROTECT_FINAL_CONSTRUCT();

		DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
									   L"MyDispatcher Class",
									   L"My.MyDispatcher.1",
									   L"My.MyDispatcher");

		DECLARE_GET_CONTROLLING_UNKNOWN();

		BEGIN_COM_MAP(CSEORouter)
			COM_INTERFACE_ENTRY(ISEODispatcher)
			COM_INTERFACE_ENTRY(IMyDispatcher)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)	// if free-threaded
		END_COM_MAP()

		// You implement this if you need to do something during init...
		HRESULT FinalConstruct() {
			// If you are free-threaded, you must at least do this.
			return (CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p));
		}

		// You implement this if you need to do something during term...
		void FinalRelease();

		// Private stuff
		class CMyEventParams : CEventParams {
			virtual HRESULT CheckRule(CBinding& bBinding);	// you have to implement this ...
			virtual HRESULT CallObject(CBinding& bBinding);	// ... and this too
			DWORD m_dwWhatever;			// these are your parameters which ...
			IUnknown *pUnkWhatever;		// ... you are going to pass to the sink
		};

		// You have to implement this.
		HRESULT CMyEventParams::CheckRule(CBinding& bBinding) {
			if (bBinding.m_piRuleEngine) {
				// call the external rule engine
			} else {
				// do internal rule evaluation
			}
			// return values are either S_OK to call the object, or anything else (usually
			// S_FALSE for no error) if not to call the object
			return (S_OK);
		}

		// And you have to implement this.
		HRESULT CMyEventParams::CallObject(CBinding& bBinding) {
			// use bBinding.clsidObject to create the object
			// QI for the interface you want
			// call the object
			return (S_OK);
		}

		// IMyDispatcher - this is your server-specific dispatcher interface
		// Do something like this...
		HRESULT STDMETHODCALLTYPE OnEvent(DWORD dwWhatever, IUnknown *pUnkWhatever) {
			CMyEventParams epParams;

			epParams.m_dwWhatever = dwWhatever;
			epParams.m_dwUnkWhatever = pUnkWhatever;
			return (Dispatch(&epParams));
		}

		// If you want to add stuff to the CBinding object, you can override
		// CSEOBaseDispatcher::AllocBinding, and use that function to allocate,
		// initialize, and return an object which is derived from CBinding.
		class CMyBinding : public CBinding {
			DWORD m_dwSomeNewProperty;
			HRESULT Init(ISEODictionary *piBinding) {
				// some custom init code
				return (S_OK);
			}
		};
		HRESULT AllocBinding(ISEODictionary *piBinding, CBinding **ppbBinding) {
			*ppbBinding = new CMyBinding;
			if (!*ppbBinding) {
				return (E_OUTOFMEMORY);
			}
			hrRes = ((CMyBinding *) (*ppbBinding))->Init(piBinding);
			if (!SUCCEEDED(hrRes)) {
				delete *ppbBinding;
				*ppbBinding = NULL;
			}
			return (hrRes);
		}

	};

*/


class CSEOBaseDispatcher : public ISEODispatcher {

	public:
		CSEOBaseDispatcher();
		virtual ~CSEOBaseDispatcher();
		class CBinding {
			public:
				CBinding() { m_bValid = FALSE; };
				virtual ~CBinding() {};
				HRESULT Init(ISEODictionary *piBinding);
				virtual int Compare(const CBinding& b) const;
			public:
				DWORD m_dwPriority;
				CComPtr<ISEODictionary> m_piBinding;
				CComPtr<ISEOBindingRuleEngine> m_piRuleEngine;
				BOOL m_bExclusive;
				CLSID m_clsidObject;
				BOOL m_bValid;
		};
		class CEventParams {
			public:
				virtual HRESULT CheckRule(CBinding& bBinding) = 0;
				virtual HRESULT CallObject(CBinding& bBinding) = 0;
		};
		virtual HRESULT Dispatch(CEventParams *pEventParams);

	public:
		// ISEODispatcher
		HRESULT STDMETHODCALLTYPE SetContext(ISEORouter *piRouter, ISEODictionary *pdictBP);

	protected:
		virtual HRESULT AllocBinding(ISEODictionary *pdictBinding, CBinding **ppbBinding);
		CComPtr<ISEORouter> m_piRouter;
		CComPtr<ISEODictionary> m_pdictBP;

	private:
		friend static int _cdecl comp_binding(const void *pv1, const void *pv2);
		CBinding **m_apbBindings;
		DWORD m_dwBindingsCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop\dll\filter.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	filter.cpp

Abstract:

	This module contains the implementation for the DirDropS
	CDDropFilter class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/17/97	created

--*/


// filter.cpp : Implementation of CDropFilter
#include "stdafx.h"
#include "dbgtrace.h"
#include "resource.h"
#include "seo.h"
#include "ddrops.h"
#include "filter.h"
#include <stdio.h>


/////////////////////////////////////////////////////////////////////////////
// CDDMessageFilter


HRESULT CDDropFilter::FinalConstruct() {
	TraceFunctEnter("CDDropFilter::FinalConstruct");

	TraceFunctLeave();
	return (CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p));
}


void CDDropFilter::FinalRelease() {
	TraceFunctEnter("CDDropFilter::FinalRelease");

	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CDDropFilter::OnFileChange(DWORD dwAction, LPCOLESTR pszFileName) {

	printf("\tCDDropFilter::OnFileChange dwAction=%u, pszFileName=%ls.\n",dwAction,pszFileName);
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop\dll\dispatch.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	dispatch.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Object Dispatcher service.

Author:

	Andy Jacobs	(andyj@microsoft.com)

Revision History:

	andyj	11/26/96	created

--*/


#include "stdafx.h"
#include "seo.h"
#include "dispatch.h"


class CDictItemNameList {
	public:
		CDictItemNameList(ISEODictionary *piFrom);
		~CDictItemNameList();
	public:
		DWORD m_dwCount;
		CComVariant *m_aNames;
};


static HRESULT ReallocCComVariant(CComVariant **ppBase,
								  DWORD dwBaseCnt,
								  DWORD dwNewBaseCnt) {
	CComVariant *pNew = NULL;

	if (dwBaseCnt == dwNewBaseCnt) {
		return (S_OK);
	}
	if (!dwNewBaseCnt) {
		delete[] *ppBase;
		*ppBase = NULL;
		return (S_OK);
	}
	ATLTRY(pNew = new CComVariant[dwNewBaseCnt];)
	_ASSERTE(pNew);
	if (!pNew) {
		return (E_OUTOFMEMORY);
	}
	for (DWORD dwIdx=0;(dwIdx<dwBaseCnt)&&(dwIdx<dwNewBaseCnt);dwIdx++) {
		pNew[dwIdx].Attach(&(*ppBase)[dwIdx]);
	}
	delete[] *ppBase;
	*ppBase = pNew;
	return (S_OK);
}


static HRESULT ReallocCComVariant(CComVariant **ppBase,
								  DWORD dwBaseCnt,
								  CComVariant *pAdd,
								  DWORD dwAddCnt) {
	HRESULT hrRes;

	hrRes = ReallocCComVariant(ppBase,dwBaseCnt,dwBaseCnt+dwAddCnt);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	for (DWORD dwIdx=0;dwIdx<dwAddCnt;dwIdx++) {
		(*ppBase)[dwIdx+dwBaseCnt].Attach(&pAdd[dwIdx]);
	}
	return (S_OK);
}


CDictItemNameList::CDictItemNameList(ISEODictionary *piFrom) {
	HRESULT hrRes;

	m_dwCount = 0;
	m_aNames = NULL;
	if (piFrom) {
		CComPtr<IUnknown> pUnkEnum;

		hrRes = piFrom->get__NewEnum(&pUnkEnum);
		if (SUCCEEDED(hrRes)) {
			CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pevEnum(pUnkEnum);

			if (pevEnum) {
				while (1) {
					CComVariant aNew[20];
					DWORD dwCnt;

					hrRes = pevEnum->Next(sizeof(aNew)/sizeof(aNew[0]),aNew,&dwCnt);
					if (!SUCCEEDED(hrRes)) {
						break;
					}
					if (!dwCnt) {
						break;
					}
					hrRes = ReallocCComVariant(&m_aNames,m_dwCount,aNew,dwCnt);
					if (!SUCCEEDED(hrRes)) {
						break;
					}
					for (DWORD dwIdx=0;dwIdx<dwCnt;dwIdx++) {
						hrRes = m_aNames[dwIdx+m_dwCount].ChangeType(VT_BSTR);
						_ASSERTE(SUCCEEDED(hrRes));
						if (!SUCCEEDED(hrRes)) {
							// Ack!  Ok - just drop this name off the list by moving the last name
							// on the list to this position, and fiddling the indexes so that we
							// attemp to convert this position again.
							if (dwIdx<dwCnt-1) {
								m_aNames[dwIdx+m_dwCount].Attach(&m_aNames[dwCnt+m_dwCount-1]);
							}
							dwIdx--;
							dwCnt--;
						}
					}
					m_dwCount += dwCnt;
				}
			}
		}
	}
}


CDictItemNameList::~CDictItemNameList() {

	delete[] m_aNames;
	m_dwCount = 0;
	m_aNames = NULL;
}


CSEOBaseDispatcher::CSEOBaseDispatcher() {

	m_apbBindings = NULL;
	m_dwBindingsCount = 0;
}


CSEOBaseDispatcher::~CSEOBaseDispatcher() {

	while (m_dwBindingsCount) {
		delete m_apbBindings[--m_dwBindingsCount];
	}
	delete[] m_apbBindings;
	m_apbBindings = NULL;
}


HRESULT STDMETHODCALLTYPE CSEOBaseDispatcher::SetContext(ISEORouter *piRouter, ISEODictionary *pdictBP) {
	HRESULT hrRes;
	CComPtr<ISEODictionary> pdictBindings;

	_ASSERT(!m_dwBindingsCount&&!m_apbBindings);
	hrRes = pdictBP->GetInterfaceA(BD_BINDINGS,IID_ISEODictionary,(IUnknown **) &pdictBindings);
	if (SUCCEEDED(hrRes)) {
		CDictItemNameList dinlBindings(pdictBindings);

		if (dinlBindings.m_dwCount) {
			m_apbBindings = new CBinding *[dinlBindings.m_dwCount];
			if (!m_apbBindings) {
				return (E_OUTOFMEMORY);
			}
			memset(m_apbBindings,0,sizeof(CBinding *)*dinlBindings.m_dwCount);
			for (m_dwBindingsCount=0;m_dwBindingsCount<dinlBindings.m_dwCount;m_dwBindingsCount++) {
				CComPtr<ISEODictionary> pdictBinding;

				pdictBinding.Release();
				hrRes = pdictBindings->GetInterfaceW(dinlBindings.m_aNames[m_dwBindingsCount].bstrVal,
													 IID_ISEODictionary,
													 (IUnknown **) &pdictBinding);
				_ASSERT(SUCCEEDED(hrRes));
				if (SUCCEEDED(hrRes)) {
					hrRes = AllocBinding(pdictBinding,&m_apbBindings[m_dwBindingsCount]);
					_ASSERT(SUCCEEDED(hrRes));
				}
			}
			qsort(m_apbBindings,m_dwBindingsCount,sizeof(m_apbBindings[0]),comp_binding);
		}
	}
	if (SUCCEEDED(hrRes)) {
		m_piRouter = piRouter;
		m_pdictBP = pdictBP;
	}
	return (hrRes);
}


static HRESULT GetCLSIDFromBinding(LPCSTR pszCLSID,
								   LPCSTR pszProgID,
								   ISEODictionary *piBinding,
								   CLSID *pclsid) {
	HRESULT hrRes;
	CComVariant varTmp;

	if (!piBinding) {
		return (E_POINTER);
	}
	if (pszCLSID) {
		hrRes = piBinding->GetVariantA(pszCLSID,&varTmp);
		if (SUCCEEDED(hrRes)) {
			hrRes = varTmp.ChangeType(VT_BSTR);
			if (SUCCEEDED(hrRes)) {
				hrRes = CLSIDFromString(varTmp.bstrVal,pclsid);
				if (SUCCEEDED(hrRes)) {
					return (hrRes);
				}
			}
		}
		varTmp.Clear();
	}
	if (!pszProgID) {
		return (E_FAIL);	// tbd - come up with a better error code
	}
	hrRes = piBinding->GetVariantA(pszProgID,&varTmp);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = varTmp.ChangeType(VT_BSTR);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = CLSIDFromProgID(varTmp.bstrVal,pclsid);
	return (hrRes);
}


HRESULT CSEOBaseDispatcher::CBinding::Init(ISEODictionary *piBinding) {
	HRESULT hrRes;
	CComVariant varTmp;
	CLSID clsidTmp;

	if (!piBinding) {
		return (E_POINTER);
	}
	// Try to get the CLSID of the object - if an error occurs,
	// this binding is invalid.
	hrRes = GetCLSIDFromBinding(BD_OBJECT,BD_PROGID,piBinding,&m_clsidObject);
	if (!SUCCEEDED(hrRes)) {
		return (S_FALSE);
	}
	// From this point on, all errors are silently ignored - we
	// use default values if we can't get something from the binding
	// database.
	hrRes = piBinding->GetVariantA(BD_PRIORITY,&varTmp);
	if (SUCCEEDED(hrRes)) {
		hrRes = varTmp.ChangeType(VT_I4);
		if (SUCCEEDED(hrRes)) {
			m_dwPriority = (DWORD) varTmp.lVal;
		}
	}
	if (!SUCCEEDED(hrRes)) {
		// If the priority isn't set, default to "last".
		m_dwPriority = (DWORD) -1;
	}
	varTmp.Clear();
	m_piBinding = piBinding;
	// Try to get an instance of the rule engine.
	hrRes = GetCLSIDFromBinding(BD_RULEENGINE,NULL,piBinding,&clsidTmp);
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateInstance(clsidTmp,
								 NULL,
								 CLSCTX_ALL,
								 IID_ISEOBindingRuleEngine,
								 (LPVOID *) &m_piRuleEngine);
	}
	// See if the 'exclusive' flag has been set.
	m_bExclusive = FALSE;
	hrRes = piBinding->GetVariantA(BD_EXCLUSIVE,&varTmp);
	if (SUCCEEDED(hrRes)) {
		hrRes = varTmp.ChangeType(VT_BOOL);
		if (SUCCEEDED(hrRes)) {
			if (varTmp.boolVal) {
				m_bExclusive = TRUE;
			}
		} else {
			hrRes = varTmp.ChangeType(VT_I4);
			if (SUCCEEDED(hrRes)) {
				if (varTmp.lVal) {
					m_bExclusive = TRUE;
				}
			}
		}
	}
	varTmp.Clear();
	m_bValid = TRUE;
	return (S_OK);
}


int CSEOBaseDispatcher::CBinding::Compare(const CBinding& b) const {

	if (m_dwPriority == b.m_dwPriority) {
		return (0);
	} else {
		return ((m_dwPriority>b.m_dwPriority)?1:-1);
	}
}


HRESULT CSEOBaseDispatcher::AllocBinding(ISEODictionary *pdictBinding, CBinding **ppbBinding) {
	HRESULT hrRes;

	if (!ppbBinding) {
		return (E_POINTER);
	}
	*ppbBinding = new CBinding;
	if (!*ppbBinding) {
		return (E_OUTOFMEMORY);
	}
	hrRes = (*ppbBinding)->Init(pdictBinding);
	if (!SUCCEEDED(hrRes)) {
		delete *ppbBinding;
		*ppbBinding = NULL;
	}
	return (hrRes);
}


static int _cdecl comp_binding(const void *pv1, const void *pv2) {
	const CSEOBaseDispatcher::CBinding **ppb1 = (const CSEOBaseDispatcher::CBinding **) pv1;
	const CSEOBaseDispatcher::CBinding **ppb2 = (const CSEOBaseDispatcher::CBinding **) pv2;

	return ((*ppb1)->Compare(**ppb2));
}


HRESULT CSEOBaseDispatcher::Dispatch(CEventParams *pEventParams) {
	BOOL bObjectCalled = FALSE;
	HRESULT hrRes;

	for (DWORD dwIdx=0;dwIdx<m_dwBindingsCount;dwIdx++) {
		if (!m_apbBindings[dwIdx]->m_bValid) {
			continue;
		}
		if (m_apbBindings[dwIdx]->m_bExclusive && bObjectCalled) {
			continue;
		}
		hrRes = pEventParams->CheckRule(*m_apbBindings[dwIdx]);
		if (hrRes == S_OK) {
			hrRes = pEventParams->CallObject(*m_apbBindings[dwIdx]);
			if ((hrRes == SEO_S_DONEPROCESSING) || m_apbBindings[dwIdx]->m_bExclusive) {
				break;
			}
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop\dll\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the DirDropS
	project.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/17/96	created

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SEO.rc
//
#define IDS_PROJNAME					100
#define IDR_StdAfx						101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop\dll\filter.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	filter.h

Abstract:

	This module contains the definition for the DirDropS
	CDDropFilter class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/17/97	created

--*/


// filter.h : Declaration of the CDDropFilter

/////////////////////////////////////////////////////////////////////////////
// CDDMessageFilter
class ATL_NO_VTABLE CDDropFilter :
	public IDDropFilter,
	public CComObjectRoot,
	public CComCoClass<CDDropFilter, &CLSID_CDDropFilter>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"DDropS Filter Class",
								   L"DDropS.Filter.1",
								   L"DDropS.Filter");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CDDropFilter)
		COM_INTERFACE_ENTRY(IDDropFilter)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IDDropFilter
	public:
		HRESULT STDMETHODCALLTYPE OnFileChange(DWORD dwAction, LPCOLESTR pszFileName);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop\dll\ddrops.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	ddrops.cpp

Abstract:

	This module contains the implementation for the DirDropS
	sample.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/17/97	created

--*/


// DDropS.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 or higher in order to build 
// this project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		<<TBD>>.

#include "stdafx.h"
#include "dbgtrace.h"
#include "resource.h"

//#define IID_DEFINED
#include "initguid.h"

#include "seo.h"
#include "SEO_i.c"
#include "ddrops.h"
#include "ddrops_i.c"
#include "dispatch.h"
#include "disp.h"
#include "filter.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CDDropDispatcher, CDDropDispatcher)
	OBJECT_ENTRY(CLSID_CDDropFilter, CDDropFilter)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/) {

	if (dwReason == DLL_PROCESS_ATTACH) {
		_Module.Init(ObjectMap,hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {
		_Module.Term();
	}
	return (TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void) {

	TraceFunctEnter("DllCanUnloadNow");
	HRESULT hRes = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
	DebugTrace(0,"Returns %s.",(hRes==S_OK)?"S_OK":"S_FALSE");
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {

	TraceFunctEnter("DllGetClassObject");
	HRESULT hRes = _Module.GetClassObject(rclsid,riid,ppv);
	DebugTrace(0,"Returns 0x%08x.",hRes);
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void) {

	TraceFunctEnter("DllRegisterServer");
	// registers object, typelib and all interfaces in typelib
	HRESULT hRes = _Module.RegisterServer(TRUE);
	DebugTrace(0,"Returns 0x%08x.",hRes);
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void) {

	TraceFunctEnter("DllUnregisterServer");
	_Module.UnregisterServer();
	DebugTrace(0,"Returns S_OK");
	TraceFunctLeave();
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop\dll\disp.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	disp.cpp

Abstract:

	This module contains the implementation for the DirDropS
	CDDropDispatcher class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/17/97	created

--*/


// disp.cpp : Implementation of CDDropDispatcher
#include "stdafx.h"
#include "dbgtrace.h"
#include "resource.h"
#include "seo.h"
#include "ddrops.h"
#include "dispatch.h"
#include "disp.h"
#include <stdio.h>


/////////////////////////////////////////////////////////////////////////////
// CDDMessageFilter


HRESULT CDDropDispatcher::FinalConstruct() {
	TraceFunctEnter("CDDropDispatcher::FinalConstruct");

	TraceFunctLeave();
	return (CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p));
}


void CDDropDispatcher::FinalRelease() {
	TraceFunctEnter("CDDropDispatcher::FinalRelease");

	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


HRESULT CDDropDispatcher::CDDropEventParams::CheckRule(CBinding& bBinding) {
	CDDropBinding *pbBinding = static_cast<CDDropBinding *> (&bBinding);
	HRESULT hrRes;

	printf("\tpri %u",pbBinding->m_dwPriority);
	if (!pbBinding->m_bstrFileName) {
		return (S_OK);
	}
	hrRes = (_wcsicmp(m_pszFileName,pbBinding->m_bstrFileName)==0) ? S_OK : S_FALSE;
	if (hrRes == S_FALSE) {
		printf(" - Rule failed.\n");
	}
	return (hrRes);
}


HRESULT CDDropDispatcher::CDDropEventParams::CallObject(CBinding& bBinding) {
	HRESULT hrRes;
	CComPtr<IDDropFilter> pFilter;

	hrRes = CoCreateInstance(bBinding.m_clsidObject,
							 NULL,
							 CLSCTX_ALL,
							 IID_IDDropFilter,
							 (LPVOID *) &pFilter);
	if (SUCCEEDED(hrRes)) {
		hrRes = pFilter->OnFileChange(m_dwAction,m_pszFileName);
	}
	return (S_OK);
}


HRESULT CDDropDispatcher::CDDropBinding::Init(ISEODictionary *pdictBinding) {
	HRESULT hrRes;
	CComVariant varTmp;

	hrRes = CBinding::Init(pdictBinding);
	if (SUCCEEDED(hrRes) && (hrRes != S_FALSE)) {
		if (SUCCEEDED(pdictBinding->GetVariantA(BD_RULE,&varTmp))) {
			if (SUCCEEDED(varTmp.ChangeType(VT_BSTR))) {
				m_bstrFileName = varTmp.bstrVal;
			}
		}
	}
	return (hrRes);
}


HRESULT STDMETHODCALLTYPE CDDropDispatcher::OnFileChange(DWORD dwAction, LPCOLESTR pszFileName) {
	CDDropEventParams epParam;

	epParam.m_dwAction = dwAction;
	epParam.m_pszFileName = pszFileName;
	return (Dispatch(&epParam));
}


HRESULT CDDropDispatcher::AllocBinding(ISEODictionary *pdictBinding, CBinding **ppbBinding) {
	HRESULT hrRes;

	if (!ppbBinding) {
		return (E_POINTER);
	}
	*ppbBinding = new CDDropBinding;
	if (!*ppbBinding) {
		return (E_OUTOFMEMORY);
	}
	hrRes = ((CDDropBinding *) (*ppbBinding))->Init(pdictBinding);
	if (!SUCCEEDED(hrRes)) {
		delete *ppbBinding;
		*ppbBinding = NULL;
	}
	return (hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop\dll\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   12/04/96        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif


#ifdef _ATL_NO_DEBUG_CRT
	#include "windows.h"
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif


//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop\dll\disp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	disp.h

Abstract:

	This module contains the definition for the DirDropS
	CDDropDispatcher class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/17/97	created

--*/


// disp.h : Declaration of the CDDropDispatcher

/////////////////////////////////////////////////////////////////////////////
// CDDDispatcher
class ATL_NO_VTABLE CDDropDispatcher : 
	public CSEOBaseDispatcher,
	public IDDropDispatcher,
	public CComObjectRoot,
	public CComCoClass<CDDropDispatcher, &CLSID_CDDropDispatcher>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"DDropS Dispatcher Class",
								   L"DDropS.Dispatcher.1",
								   L"DDropS.Dispatcher");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CDDropDispatcher)
		COM_INTERFACE_ENTRY(ISEODispatcher)
		COM_INTERFACE_ENTRY(IDDropDispatcher)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// IDDropDispatcher
	public:
		HRESULT STDMETHODCALLTYPE OnFileChange(DWORD dwAction, LPCOLESTR pszFileName);

	// CDDropDispatcher
	private:
		class CDDropEventParams : public CSEOBaseDispatcher::CEventParams {
			public:
				DWORD m_dwAction;
				LPCOLESTR m_pszFileName;
				HRESULT CheckRule(CBinding &bBinding);
				HRESULT CallObject(CBinding &bBinding);
		};
		class CDDropBinding : public CSEOBaseDispatcher::CBinding {
			public:
				CComBSTR m_bstrFileName;
				HRESULT Init(ISEODictionary *pdictBinding);
		};
		virtual HRESULT AllocBinding(ISEODictionary *pdictBinding, CBinding **ppBinding);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop\exe\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   12/04/96        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif


#ifdef _ATL_NO_DEBUG_CRT
	#include "windows.h"
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif


//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\stressdict\stressdict.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	StressDict.cpp

Abstract:

	This console app was made to stress objects with an
	ISEODictionary interface.

Author:

	Andy Jacobs	(andyj@microsoft.com)

Revision History:

	andyj	03/10/97	created

--*/

/* Notes:

Future inhancements may include a standard suite of tests, such as:
	Suite includes writing tests of:
		* Typical Name Strings (Registry type names)
		* Typical Name Strings with numbers
		* Name string with Spaces
		* Name string over 64K
		* Name string with all ANSI Printable characters
		* Name string with mixed case
		* Name string of Null and Empty
		* Name variant passed as non-string type
		* Writing duplicate entry via a different Ansi/Wide "Set" method
		* Writing similarly named entry with different case
		* Writing with each "Set" method
		* Add 10,000 unique entries (time this)

		* Value string with CR's
		* Value string with CR/LF's
		* Value string with Spaces
		* Value string containing Nulls
		* Value string over 64K (BSTR, StringA and StringW)
		* Value string with all 256 characters
		* Value string with mixed case
		* Value of a Null String
		* Value of Interface
		* Value of Null Interface
		* Value of 0
		* Value of 4,294,967,295 (max DWORD)
		* Value of -1
		* Value of 4,294,967,296 (max DWORD + 1)

	Suite includes reading test of:
		* All of the written info, exactly as specified, from each "Get" method.
		* Read as each possible type
		* Read with switched case
		* Read with first characters case switched
		* Read with first character non-alpha-numeric, and next char case switched
		* Read with last character case switched
		* Read with a middle character case switched

*/

// Wizard added these libs which I removed:
// gdi32.lib winspool.lib comdlg32.lib shell32.lib

#include <stdio.h>
#include <objbase.h>
#include <urlmon.h>
#include <initguid.h>
#include "IADM.H" // Needed for MD_ERROR_NOT_INITIALIZED
#include <ATLbase.h>
#include <ATLimpl.cpp>

#include "seo.h" // This must be included for seo_i.c to work... (it seems)
#include "seo_i.c"
#include <fstream.h>

// Command Line Options
const char PRINTHELP = '?';
const char OFF = '-';

// Script commands
const char DICTIONARY = 'd'; // Load the specified dictionary (via ProgID)
const char MONIKER = 'k'; // Load Dictionary as Moniker
const char WRITE = 'w'; // Write data to the Dictionary
const char REMOVE = 'r'; // Remove specified data
const char LOAD = 'l'; // Load Subkey as Current Dictionary
const char PRINT = 'p'; // Print the current dictionary (not recursive)
const char COPY = 'm'; // Copy current dictionary to Memory (like calculator)
const char INCLUDE = 'i'; // Execute commands from the specified file 
const char POP = '-'; // Pop the current dictionary, previous will become current
const char VERBOSE = 'v'; // Set Verbose mode
const char UNICODE_MODE = 'u';
const char VARIANT_MODE = 'a';
const char PAUSE = 'z';
const char ECHO = 'e'; // Echo remainder of line
const char COMMENT = '#'; // Do not interpret the line

// WRITE sub-commands
const char DWORD_COMMAND = 'd';
const char INTERFACE_COMMAND = 'i';
const char STRING_COMMAND = 's';

BOOL g_bVerbose = TRUE;
BOOL g_bUnicodeMode = FALSE;
BOOL g_bVariantMode = FALSE;
CComPtr<ISEODictionary> g_pMemory = NULL;


void UseObject(ISEODictionary *pCurrentDict, ifstream &strInput, int &iLine);
void ReadFile(ISEODictionary *pCurrentDict, LPCSTR psFileName);

class DebugManager {
public:
	long flags() {return cout.flags();};
	long flags(long lFlags) {return cout.flags(lFlags);};
} OUTPUT; // Use like cout to only print when g_bVerbose is set

template<class T>
DebugManager &operator<<(DebugManager &dm, T &tStuff) {
	if(g_bVerbose) cout << tStuff;
	return dm;
}


void PrintUsage(LPCSTR psProgram) {
	printf("\nUsage: %s [options] file [...]\n\n", psProgram);
	printf("Where:\n");
	printf("\tfile = File to use as test script\n\n");
	printf("\toptions:\n");
	printf("\t\t-%c[%c] = [Non-]Verbose Mode\n", VERBOSE, OFF);
	printf("\t\t-%c = Print (this) Help Message\n\n\n", PRINTHELP);
	printf("File Syntax:\n\n");
	printf("%c ProgID\n", DICTIONARY);
	printf("\tCreate the specified Dictionary.  Push the current dictionary.\n");
	printf("\tProgID = OLE Program ID in Registry (e.g., SEO.SEOMetaDictionary)\n");
	printf("%c MonikerString\n", MONIKER);
	printf("\tCreate a Dictionary from a Moniker string.  Push the current dictionary.\n");
	printf("\tMonikerString = E.g., \"SEO.SEOGenericMoniker MonikerType=SEO.SEOMetaDictionary\"\n");
	printf("%c Subkey\n", LOAD);
	printf("\tLoad the specified subkey as a Dictionary.  Push the current dictionary.\n");
	printf("%c[type] name [data]\n", WRITE);
	printf("\tWrite the specified data to the Dictionary using the name key.\n");
	printf("\t\tData is interpreted according to the specified type:\n");
	printf("\t\ttype = %c[word], or\n", DWORD_COMMAND);
	printf("\t\ttype = %c[nterface] (uses the memory Dictionary), or\n", INTERFACE_COMMAND);
	printf("\t\ttype = %c[tring] (default).\n", STRING_COMMAND);
	printf("%c name\n", REMOVE);
	printf("\tRemove the named entry.\n");
	printf("%c\n", INCLUDE);
	printf("\tExecute commands from the specified file.\n");
	printf("%c[%c]\n", PRINT, OFF);
	printf("\tPrint the current dictionary [non-recursively].\n");
	printf("%c\n", COPY);
	printf("\tCopy current dictionary to Memory (like calculator).\n");
	printf("%c\n", POP);
	printf("\tPop the current dictionary, previous will become current.\n");
	printf("%c[%c]\n", UNICODE_MODE, OFF);
	printf("\tSet Unicode mode for writing [off].\n");
	printf("%c[%c]\n", VARIANT_MODE, OFF);
	printf("\tSet Variant mode for writing [off].\n");
	printf("%c[%c]\n", VERBOSE, OFF);
	printf("\tSet Verbose mode [off].\n");
	printf("%c\n", PAUSE);
	printf("\tWait for user to press Enter before continuing.\n");
	printf("%c[text]\n", ECHO);
	printf("\tPrint the text.\n");
	printf("%c\n", COMMENT);
	printf("\tDo not interpret the rest of the line.\n");
	printf("\n");
}

void DisplayResult(HRESULT hRes) {
#define DISPLAY(x)	if(hRes == x) {OUTPUT << #x << endl; return;}
	DISPLAY(S_OK)
	DISPLAY(S_FALSE)
	DISPLAY(E_FAIL)
	DISPLAY(MD_ERROR_NOT_INITIALIZED)
	DISPLAY(MD_ERROR_DATA_NOT_FOUND)
	DISPLAY(MD_ERROR_INVALID_VERSION)
	DISPLAY(MD_WARNING_PATH_NOT_FOUND)
	DISPLAY(MD_WARNING_DUP_NAME)
	DISPLAY(MD_WARNING_INVALID_DATA)
	DISPLAY(MD_ERROR_SECURE_CHANNEL_FAILURE)

	if(HRESULT_FACILITY(hRes) == FACILITY_WIN32) {
#define DISPLAY_WIN32(x)	if(HRESULT_FROM_WIN32(x) == hRes) {OUTPUT << #x << endl; return;}
		DISPLAY_WIN32(ERROR_INVALID_PARAMETER)
		DISPLAY_WIN32(ERROR_ACCESS_DENIED)
		DISPLAY_WIN32(ERROR_NOT_ENOUGH_MEMORY)
		DISPLAY_WIN32(ERROR_PATH_NOT_FOUND)
		DISPLAY_WIN32(ERROR_PATH_BUSY)
		DISPLAY_WIN32(ERROR_DUP_NAME)
		DISPLAY_WIN32(ERROR_INVALID_NAME)
		// TBD: Why does the next line not compile with OUTPUT
		cout << "Return code (Win32): " << HRESULT_CODE(hRes) << endl;
		return;
	}


	// Didn't find a match, so print it in hex
	long lOldFlags = OUTPUT.flags();
	OUTPUT.flags(lOldFlags | ios::hex | ios::showbase | ios::uppercase);
	OUTPUT << "Return code: " << hRes << endl;
	OUTPUT.flags(lOldFlags);
}

void SkipWhitespace(LPCSTR &pLine) {
	while(*pLine && ((*pLine == ' ') || (*pLine == '\t'))) ++pLine;
}

void FindWhitespace(LPCSTR &pLine) {
	while(*pLine && (' ' != *pLine) && ('\t' != *pLine)) ++pLine; // Find first whitespace
}

BOOL ParseOption(int argc, char *argv[], char cOption, BOOL bDefault = FALSE) {
	for(int iIndex = 1; iIndex < argc; ++iIndex) {
		if(*argv[iIndex] == '-') {
			char *pFound = strchr(argv[iIndex], cOption);
			if(pFound) return (pFound[1] != OFF); // TRUE if not followed by "-"
		}
	}

	return bDefault; // Not found
}

void PrintBag(ISEODictionary *pBag, BOOL bRecurse, int indent = 0) {
	if(!pBag) return; // Nothing to print
	const int TAB_SIZE = 4;
	USES_CONVERSION;

	LPSTR indentSpaces = (LPSTR) _alloca(1 + (indent * TAB_SIZE));
	indentSpaces[0] = 0; // Terminate string
	for(int j = indent * TAB_SIZE; j > 0; --j) lstrcat(indentSpaces, " ");

	CComPtr<IUnknown> piUnk;
	HRESULT hr = pBag->get__NewEnum(&piUnk);
	if(FAILED(hr) || !piUnk) return;
	CComQIPtr<IEnumVARIANT, &IID_IEnumVARIANT> pieEnum = piUnk;
	piUnk.Release(); // Done with piUnk - use pieEnum now
	if(!pieEnum) return;

	CComVariant varName; // Hold the current property name

	// Read in and print all of the properties
	while(S_OK == pieEnum->Next(1, &varName, NULL)) {
		hr = varName.ChangeType(VT_BSTR); // Try to get a string
		CComVariant varDest; // Hold the current result
		pBag->get_Item(&varName, &varDest);

		if(varDest.vt == VT_UNKNOWN) {  // It's a sub-bag
			cout << indentSpaces << OLE2A(varName.bstrVal) << " (Subkey)" << endl; // Print it

			if(bRecurse) {
				CComQIPtr<ISEODictionary, &IID_ISEODictionary> pidNext = varDest.punkVal;
				PrintBag(pidNext, TRUE, indent + 1);
			}
		} else {
			VARTYPE vtType = varDest.vt; // Save type
			hr = varDest.ChangeType(VT_BSTR); // Try to get a printable format

			if(SUCCEEDED(hr) && (varDest.vt == VT_BSTR)) { // If coercion worked
				cout   << indentSpaces << OLE2A(varName.bstrVal);
				OUTPUT << " (vt=" << vtType << ")"; // Only add this if verbose
				cout   << ": " << OLE2A(varDest.bstrVal) << endl;
			}
		}
	}
}

void LoadAndUseDict(LPCSTR pLine, ifstream &strInput, int &iLine) {
	USES_CONVERSION;
	CLSID clsid;
	OUTPUT << "CLSIDFromProgID(" << pLine << ") - ";
	HRESULT hRes = CLSIDFromProgID(A2OLE(pLine), &clsid);
	DisplayResult(hRes);

	OUTPUT << "CoCreateInstance() - ";
	CComPtr<ISEODictionary> pNextDict = NULL;
	hRes = CoCreateInstance(clsid, NULL, CLSCTX_ALL,
	            IID_ISEODictionary, (LPVOID *) &pNextDict);
	DisplayResult(hRes);

	UseObject(pNextDict, strInput, iLine);
	//pNextDict.Release();
}

void LoadAndUseMoniker(LPCSTR pLine, ifstream &strInput, int &iLine) {
	USES_CONVERSION;
	OUTPUT << "CreateBindCtx() - ";
	CComPtr<IBindCtx> pBindCtx;
	HRESULT hRes = CreateBindCtx(0, &pBindCtx);
	DisplayResult(hRes);

	OUTPUT << "MkParseDisplayNameEx(" << pLine << ") - ";
	ULONG ulEaten = 0;
	CComPtr<IMoniker> pMoniker;
	hRes = MkParseDisplayName(pBindCtx, A2W(pLine), &ulEaten, &pMoniker);
//	hRes = MkParseDisplayName(pBindCtx, L"@SEO.SEOGenericMoniker:", &ulEaten, &pMoniker);
	OUTPUT << "(eaten: " << ulEaten << ") ";
	DisplayResult(hRes);
	if(!pMoniker) return;

	OUTPUT << "BindToObject() - ";
	CComPtr<ISEODictionary> pNextDict = NULL;
	hRes = pMoniker->BindToObject(pBindCtx, NULL, IID_ISEODictionary,
	                              (LPVOID *) &pNextDict);
	DisplayResult(hRes);

	UseObject(pNextDict, strInput, iLine);
}

void LoadAndUseSubDict(ISEODictionary *pCurrentDict, LPCSTR pLine,
                       ifstream &strInput, int &iLine) {
	USES_CONVERSION;

	OUTPUT << "GetInterfaceA(" << pLine << ") - ";
	CComPtr<ISEODictionary> pNextDict = NULL;
	HRESULT hRes = pCurrentDict->GetInterfaceA(pLine, IID_ISEODictionary, 
	                                           (LPUNKNOWN *) &pNextDict);
	DisplayResult(hRes);

	UseObject(pNextDict, strInput, iLine);
	//pNextDict.Release();
}

void WriteData(ISEODictionary *pCurrentDict, LPSTR pLine) {
	USES_CONVERSION;
	HRESULT hRes = E_FAIL;
	CComVariant varResult; // Used for g_bVariantMode
	char cType = *pLine; // Get the type
	FindWhitespace(pLine); // Point past the command
	SkipWhitespace(pLine); // Point past the spaces
	LPCSTR pName = pLine; // This is the name
	FindWhitespace(pLine); // Point past the name
	*pLine = 0; // Terminate pName string
	++pLine; // Point past terminator
	SkipWhitespace(pLine); // Point past the spaces (if any)

// Output function name, and then call it
#define WRITE_CALL(x) OUTPUT << #x " - "; hRes = pCurrentDict->x

	if(DWORD_COMMAND == cType) { // If it's a DWORD
		if(g_bVariantMode) {
			varResult = atol(pLine);
		} else if(g_bUnicodeMode) {
			WRITE_CALL(SetDWordW)(A2W(pName), (DWORD) atol(pLine));
		} else { // ANSI mode
			WRITE_CALL(SetDWordA)(pName, (DWORD) atol(pLine));
		}
	} else if(INTERFACE_COMMAND == cType) {
		if(g_bVariantMode) {
			varResult = g_pMemory;
		} else if(g_bUnicodeMode) {
			WRITE_CALL(SetInterfaceW)(A2W(pName), g_pMemory);
		} else { // ANSI mode
			WRITE_CALL(SetInterfaceA)(pName, g_pMemory);
		}
	} else { // Default is a string
		if(g_bVariantMode) {
			varResult = pLine;
		} else if(g_bUnicodeMode) {
			WRITE_CALL(SetStringW)(A2W(pName), lstrlen(pLine) + 1, A2W(pLine));
		} else { // ANSI mode
			WRITE_CALL(SetStringA)(pName, lstrlen(pLine) + 1, pLine);
		}
	}

	if(g_bVariantMode) { // Time to save the variant we initialized above
		if(g_bUnicodeMode) {
			WRITE_CALL(SetVariantW)(A2W(pName), &varResult);
		} else { // ANSI mode
			WRITE_CALL(SetVariantA)(pName, &varResult);
		}
	}

	DisplayResult(hRes);
}

void RemoveData(ISEODictionary *pCurrentDict, LPSTR pLine) {
	USES_CONVERSION;
	HRESULT hRes = E_FAIL;
	CComVariant varResult; // Set to VT_EMPTY, to delete entry
	FindWhitespace(pLine); // Point past the command
	SkipWhitespace(pLine); // Point past the spaces

	// Use WRITE_CALL defined above.
	if(g_bUnicodeMode) {
		WRITE_CALL(SetVariantW)(A2W(pLine), &varResult);
	} else { // ANSI mode
		WRITE_CALL(SetVariantA)(pLine, &varResult);
	}

	DisplayResult(hRes);
}

void UseObject(ISEODictionary *pCurrentDict, ifstream &strInput, int &iLine) {
	while(strInput) {
		char sLine[1024];
		char *pLine = sLine;

		++iLine;
		strInput.getline(sLine, sizeof(sLine)); // Read a line
		OUTPUT << "Line #" << iLine << ": " << sLine << endl;
		SkipWhitespace(pLine);
		if(!*pLine) continue; // Skip blank lines

		switch(*pLine) {
			case DICTIONARY:
				++pLine;
				SkipWhitespace(pLine);
				if(!*pLine) printf("Error: Missing PROG_ID\n");
				else LoadAndUseDict(pLine, strInput, iLine);
				break;

			case MONIKER:
				++pLine;
				SkipWhitespace(pLine);
				if(!*pLine) printf("Error: Missing MonikerString\n");
				else LoadAndUseMoniker(pLine, strInput, iLine);
				break;

			case LOAD:
				++pLine;
				SkipWhitespace(pLine);
				if(!*pLine) printf("Error: Missing Subkey\n");
				else LoadAndUseSubDict(pCurrentDict, pLine, strInput, iLine);
				break;

			case WRITE:
				++pLine; // Point past the command character
				WriteData(pCurrentDict, pLine);
				break;

			case REMOVE:
				++pLine; // Point past the command character
				RemoveData(pCurrentDict, pLine);
				break;

			case PRINT:
				PrintBag(pCurrentDict, (pLine[1] != OFF));
				break;

			case COPY: // Copy current dictionary to Memory (like calculator)
				g_pMemory = pCurrentDict;
				break;

			case POP: // Pop the current dictionary, previous will become current
				return;

			case UNICODE_MODE:
				g_bUnicodeMode = (pLine[1] != OFF);
				break;

			case VARIANT_MODE:
				g_bVariantMode = (pLine[1] != OFF);
				break;

			case VERBOSE:
				g_bVerbose = (pLine[1] != OFF);
				break;

			case PAUSE:
				cout << endl << "\nPress Enter to Continue." << flush;
				cin.getline(sLine, sizeof(sLine)); // Read a line
				// _getch();
				cout << endl;
				break;

			case INCLUDE:
				++pLine;
				SkipWhitespace(pLine);
				if(!*pLine) printf("Error: Missing Filename\n");
				else ReadFile(pCurrentDict, pLine);
				break;

			case ECHO:
				++pLine;
				cout << pLine << endl;
				break;

			case COMMENT:
				break;

			default:
				OUTPUT << "Unrecognized command: " << pLine << endl;
				break;
		} // End Switch
	} // End While

	// pCurrentDict.Release(); - should happen automagically
}

void ReadFile(ISEODictionary *pCurrentDict, LPCSTR psFileName) {
	int iLine = 0;
	ifstream strInput(psFileName);

	UseObject(pCurrentDict, strInput, iLine);
}

int __cdecl main(int argc, char *argv[]) {
	if(!ParseOption(argc, argv, VERBOSE, g_bVerbose)) g_bVerbose = FALSE;

	// Print help if no parameters, or -? specified
	if((argc <= 1) || ParseOption(argc, argv, PRINTHELP)) {
		PrintUsage(argv[0]);
		return 0;
	}

	OUTPUT << "\nCoInitialize() - ";
	HRESULT hRes = CoInitialize(NULL);
	DisplayResult(hRes);

	if(SUCCEEDED(hRes)) { // Only do this if CoInitialized worked
		for(int iIndex = 1; iIndex < argc; ++iIndex) { // Look for file parameters
			if(*argv[iIndex] != '-') ReadFile(NULL, argv[iIndex]);
		}

		g_pMemory.Release(); // Done with this dictionary

		CoFreeUnusedLibraries();
		CoUninitialize();
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ddrop2.rc
//
#define IDS_PROJNAME 100

#define IDR_StdAfx	 100


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop\dll\stdafx.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.cpp

Abstract:

	This module contains the implementation for the base
	ATL methods.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	12/04/96	created

--*/


// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...) {
	LPBYTE pbAdd = NULL;		// Working pointer to the next available "scratch space" in the map.
	DWORD dwCnt = 0;			// The count of entries in the map.
	LPOLESTR pszCLSID = NULL;	// The CLSID as a string.
	LPOLESTR pszTLID = NULL;	// The TLID as a string.

	if (!pparmeResult) {
		// The caller did not give us a place to return the result.
		return (E_POINTER);
	}
	*pparmeResult = NULL;	// For the first time through the loop, the result is NULL.
	// We are going to loop through twice.  The first time through, we haven't allocate the map yet, so
	// we will count all the strings, and add up their lenghts - this will give us the size of the buffer
	// we need to allocate for the map.  Then the second time through the loop, we will store all the
	// strings in the map.
	while (1) {
		if (pclsid) {
			// If we were passed a CLSID, then we want to include that in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to convert the CLSID to a string.
				HRESULT hrRes;

				hrRes = StringFromCLSID(*pclsid,&pszCLSID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the CLSID to a string.
					CoTaskMemFree(*pparmeResult);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the CLSID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"CLSID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszCLSID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the CLSID string and the fact that we have a CLSID in the map.
			pbAdd += (wcslen(pszCLSID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszCLSID);
				pszCLSID = NULL;
			}
		}
		if (pmodule) {
			// If we were passed a module, then we want to include the TLID in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to load the type library, get its
				// TLID, and convert it to a string.
				USES_CONVERSION;
				HRESULT hrRes;
				TCHAR szModule[MAX_PATH];
				LPOLESTR pszModule;
				CComPtr<ITypeLib> pTypeLib;
				TLIBATTR *ptlaAttr;
				if (!GetModuleFileName(pmodule->GetTypeLibInstance(),
									   szModule,
									   sizeof(szModule)/sizeof(TCHAR))) {
					hrRes = HRESULT_FROM_WIN32(GetLastError());
					if (SUCCEEDED(hrRes)) {
						// GetModuleFileName() failed, but GetLastError() didn't report an error - so
						// fake it.
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				if (pszIndex) {
					// If we were passed an index, that means that the type library desired is not the
					// first type library in the resources - so append the index to the module name.
					lstrcat(szModule,OLE2T(pszIndex));
				}
				pszModule = T2OLE(szModule);
				hrRes = LoadTypeLib(pszModule,&pTypeLib);
				if (!SUCCEEDED(hrRes)) {
					// If we couldn't load the type library from the module, let's try changing the
					// module name to a type library name (change the extension to .TLB) and try to load
					// *that*.
					LPTSTR pszExt = NULL;
					LPTSTR psz;

					for (psz=szModule;*psz;psz=CharNext(psz)) {
						if (*psz == _T('.')) {
							pszExt = psz;
						}
					}
					if (!pszExt) {
						pszExt = psz;
					}
					lstrcpy(pszExt,_T(".tlb"));
					pszModule = T2OLE(szModule);
					hrRes = LoadTypeLib(pszModule,&pTypeLib);
				}
				if (!SUCCEEDED(hrRes)) {
					// We failed to load the type library.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = pTypeLib->GetLibAttr(&ptlaAttr);
				if (!SUCCEEDED(hrRes)) {
					// We failed to get the type library attributes.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = StringFromCLSID(ptlaAttr->guid,&pszTLID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the TLID to a string.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the TLID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"LIBID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszTLID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the TLID string and the fact that we have a TLID in the map.
			pbAdd += (wcslen(pszTLID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszTLID);
				pszTLID = NULL;
			}
		}
		{	// Now we need to go through the varargs.  All of the varargs must be LPOLESTR (i.e. they
			// must be UNICODE), and they will consist of pairs - the key name followed by the data.  If
			// either member of the pair is NULL, that signals the end of the varargs.
			va_list valArgs;

			// Set the va_list to the start of the varargs.
			va_start(valArgs,pszIndex);
			while (1) {
				LPCOLESTR pszKey;
				LPCOLESTR pszData;

				// Get the first of the pair - this is the key name.
				pszKey = va_arg(valArgs,LPCOLESTR);
				if (!pszKey) {
					break;
				}
				// Get the second of the pair - this is the data.
				pszData = va_arg(valArgs,LPCOLESTR);
				if (!pszData) {
					break;
				}
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the key name to the
					// map.
					(*pparmeResult)[dwCnt].szKey = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szKey,pszKey);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string.
				pbAdd += (wcslen(pszKey)+1) * sizeof(OLECHAR);
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the data to the map.
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszData);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string and the fact that we have a string in the map.
				pbAdd += (wcslen(pszData)+1) * sizeof(OLECHAR);
				dwCnt++;
			}
			// Reset the va_list, for the sake of cleanliness.
			va_end(valArgs);
		}
		if (*pparmeResult) {
			// If we have allocated the map, that means that we are finishing the second time through
			// the loop - so we are done!
			break;
		}
		if (!*pparmeResult) {
			// If we havemn't allocate the map, that means that we are finishing the first time through
			// the loop - so we need to allocate the map in preparation for the second time through.
			// First we calculate the number of bytes needed for the map - this is one ATL_REGMAP_ENTRY
			// for each entry, plus one _ATL_REGMAP_ENTRY which signals the end of the map, plus enough
			// space for all of the strings to follow.
			DWORD dwBytes = (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY) + (pbAdd-(LPBYTE) NULL);

			*pparmeResult = (_ATL_REGMAP_ENTRY *) CoTaskMemAlloc(dwBytes);
			if (!*pparmeResult) {
				// The memory allocation failed.
				CoTaskMemFree(pszCLSID);
				CoTaskMemFree(pszTLID);
				return (E_OUTOFMEMORY);
			}
			// The memory allocation was successful - fill the memory with zeroes in preparation for
			// loading with the values.
			memset(*pparmeResult,0,dwBytes);
			// Reset the counters to the "beginning" - so that on the second time through, they are used
			// to keep track of where each successive value gets stored in the memory block.
			pbAdd = ((LPBYTE) *pparmeResult) + (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY);
			dwCnt = 0;
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop\exe\stdafx.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.cpp

Abstract:

	This module contains the implementation for the base
	ATL methods.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	12/04/96	created

--*/


// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...) {
	LPBYTE pbAdd = NULL;		// Working pointer to the next available "scratch space" in the map.
	DWORD dwCnt = 0;			// The count of entries in the map.
	LPOLESTR pszCLSID = NULL;	// The CLSID as a string.
	LPOLESTR pszTLID = NULL;	// The TLID as a string.

	if (!pparmeResult) {
		// The caller did not give us a place to return the result.
		return (E_POINTER);
	}
	*pparmeResult = NULL;	// For the first time through the loop, the result is NULL.
	// We are going to loop through twice.  The first time through, we haven't allocate the map yet, so
	// we will count all the strings, and add up their lenghts - this will give us the size of the buffer
	// we need to allocate for the map.  Then the second time through the loop, we will store all the
	// strings in the map.
	while (1) {
		if (pclsid) {
			// If we were passed a CLSID, then we want to include that in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to convert the CLSID to a string.
				HRESULT hrRes;

				hrRes = StringFromCLSID(*pclsid,&pszCLSID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the CLSID to a string.
					CoTaskMemFree(*pparmeResult);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the CLSID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"CLSID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszCLSID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the CLSID string and the fact that we have a CLSID in the map.
			pbAdd += (wcslen(pszCLSID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszCLSID);
				pszCLSID = NULL;
			}
		}
		if (pmodule) {
			// If we were passed a module, then we want to include the TLID in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to load the type library, get its
				// TLID, and convert it to a string.
				USES_CONVERSION;
				HRESULT hrRes;
				TCHAR szModule[MAX_PATH];
				LPOLESTR pszModule;
				CComPtr<ITypeLib> pTypeLib;
				TLIBATTR *ptlaAttr;
				if (!GetModuleFileName(pmodule->GetTypeLibInstance(),
									   szModule,
									   sizeof(szModule)/sizeof(TCHAR))) {
					hrRes = HRESULT_FROM_WIN32(GetLastError());
					if (SUCCEEDED(hrRes)) {
						// GetModuleFileName() failed, but GetLastError() didn't report an error - so
						// fake it.
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				if (pszIndex) {
					// If we were passed an index, that means that the type library desired is not the
					// first type library in the resources - so append the index to the module name.
					lstrcat(szModule,OLE2T(pszIndex));
				}
				pszModule = T2OLE(szModule);
				hrRes = LoadTypeLib(pszModule,&pTypeLib);
				if (!SUCCEEDED(hrRes)) {
					// If we couldn't load the type library from the module, let's try changing the
					// module name to a type library name (change the extension to .TLB) and try to load
					// *that*.
					LPTSTR pszExt = NULL;
					LPTSTR psz;

					for (psz=szModule;*psz;psz=CharNext(psz)) {
						if (*psz == _T('.')) {
							pszExt = psz;
						}
					}
					if (!pszExt) {
						pszExt = psz;
					}
					lstrcpy(pszExt,_T(".tlb"));
					pszModule = T2OLE(szModule);
					hrRes = LoadTypeLib(pszModule,&pTypeLib);
				}
				if (!SUCCEEDED(hrRes)) {
					// We failed to load the type library.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = pTypeLib->GetLibAttr(&ptlaAttr);
				if (!SUCCEEDED(hrRes)) {
					// We failed to get the type library attributes.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = StringFromCLSID(ptlaAttr->guid,&pszTLID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the TLID to a string.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the TLID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"LIBID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszTLID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the TLID string and the fact that we have a TLID in the map.
			pbAdd += (wcslen(pszTLID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszTLID);
				pszTLID = NULL;
			}
		}
		{	// Now we need to go through the varargs.  All of the varargs must be LPOLESTR (i.e. they
			// must be UNICODE), and they will consist of pairs - the key name followed by the data.  If
			// either member of the pair is NULL, that signals the end of the varargs.
			va_list valArgs;

			// Set the va_list to the start of the varargs.
			va_start(valArgs,pszIndex);
			while (1) {
				LPCOLESTR pszKey;
				LPCOLESTR pszData;

				// Get the first of the pair - this is the key name.
				pszKey = va_arg(valArgs,LPCOLESTR);
				if (!pszKey) {
					break;
				}
				// Get the second of the pair - this is the data.
				pszData = va_arg(valArgs,LPCOLESTR);
				if (!pszData) {
					break;
				}
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the key name to the
					// map.
					(*pparmeResult)[dwCnt].szKey = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szKey,pszKey);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string.
				pbAdd += (wcslen(pszKey)+1) * sizeof(OLECHAR);
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the data to the map.
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszData);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string and the fact that we have a string in the map.
				pbAdd += (wcslen(pszData)+1) * sizeof(OLECHAR);
				dwCnt++;
			}
			// Reset the va_list, for the sake of cleanliness.
			va_end(valArgs);
		}
		if (*pparmeResult) {
			// If we have allocated the map, that means that we are finishing the second time through
			// the loop - so we are done!
			break;
		}
		if (!*pparmeResult) {
			// If we havemn't allocate the map, that means that we are finishing the first time through
			// the loop - so we need to allocate the map in preparation for the second time through.
			// First we calculate the number of bytes needed for the map - this is one ATL_REGMAP_ENTRY
			// for each entry, plus one _ATL_REGMAP_ENTRY which signals the end of the map, plus enough
			// space for all of the strings to follow.
			DWORD dwBytes = (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY) + (pbAdd-(LPBYTE) NULL);

			*pparmeResult = (_ATL_REGMAP_ENTRY *) CoTaskMemAlloc(dwBytes);
			if (!*pparmeResult) {
				// The memory allocation failed.
				CoTaskMemFree(pszCLSID);
				CoTaskMemFree(pszTLID);
				return (E_OUTOFMEMORY);
			}
			// The memory allocation was successful - fill the memory with zeroes in preparation for
			// loading with the values.
			memset(*pparmeResult,0,dwBytes);
			// Reset the counters to the "beginning" - so that on the second time through, they are used
			// to keep track of where each successive value gets stored in the memory block.
			pbAdd = ((LPBYTE) *pparmeResult) + (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY);
			dwCnt = 0;
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop2\ddrop2.cpp ===
// ddrop2.cpp : Implementation of main


/*

This is a sample of the how to source server events.  It watches for
directory changes, and signals events when directory changes happen.

The ddrop2.vbs script must be run prior to running the sample - the
script enters the necessary registrations into the server event
database.  The script enters information about the source type, as well
as about the event type, and the specific source.  Finally, in order
for this to be a complete xample, the script enters a binding for a test
sink which will actually receives the events.

This sample logically consists of several parts:

1)  The server itself.  This performs initialization, and then waits for
directory changes.  Part of the initialization is getting  the binding
data, and giving it to the router.  When it sees directory changes,
it asks the router for a dispatcher, and then tells the dispatcher
to signal the event.

2)  The router.  This is implemented by the server events system - there
are no parts of the router implemented by the sample. The router manages
the binding data, and also manages the lifetime of the dispatcher.  The
router implements the IEventRouter interface.

3)  The dispatcher.  This is a full-fledged COM object, but it is *not*
CoCreate-able - it can only be created with assistance from the server.
It implements several interfaces - IEventDispatcher, which is used by
the router to initialize the dispatcher, and IDDrop2Dispatcher, which is
used by the server to signal the event.  The dispatcher expects the sink
to implement either IDDrop2SinkNotify or IEventNotify - it adapts its
behavior depending on which interface the sink provides.

4)  The test sink.  In order to be a complete sample, there is also a
test sink implemented by the same executable.  The test sink *is*
CoCreate-able - when the server is running, the test sink's class
factory is registered using CoRegisterClassObject - this registration
happens during server initialization.  The test sink implements both
the IDDrop2SinkNotify interface, as well as the more generic
IEventSinkNotify - this is done as an example of how a source can adapt
its behavior based on which interfaces the sink implements.

*/


#include "stdafx.h"
#include <stdio.h>
#include <conio.h>
#include "resource.h"
#include "initguid.h"
#include "seo.h"
#include "seolib.h"
#include "seo_i.c"


// ************************************************************************
//
// These values must match those in the ddrop2.vbs script.  They
// are part of the registration of the event source, event type, source
// and test binding.
//
// This is the source type.
// {01199F22-FA25-11d0-AA14-00AA006BC80B}
DEFINE_GUID(GUID_DDrop2_SourceType, 0x1199f22, 0xfa25, 0x11d0, 0xaa, 0x14, 0x0, 0xaa, 0x0, 0x6b, 0xc8, 0xb);
//
// This is the source.
// {01199F23-FA25-11d0-AA14-00AA006BC80B}
DEFINE_GUID(GUID_DDrop2_Source, 0x1199f23, 0xfa25, 0x11d0, 0xaa, 0x14, 0x0, 0xaa, 0x0, 0x6b, 0xc8, 0xb);
//
// This is the event type.
// {01199F21-FA25-11d0-AA14-00AA006BC80B}
DEFINE_GUID(CATID_DDrop2FileEvent, 0x1199f21, 0xfa25, 0x11d0, 0xaa, 0x14, 0x0, 0xaa, 0x0, 0x6b, 0xc8, 0xb);
//
// This value must also match that in the ddop2.vbs script.  It is
// the CLSID of the test sink.
//
// This is the test sink.
// {DE9B91F1-FA12-11d0-AA14-00AA006BC80B}
DEFINE_GUID(CLSID_CDDrop2Sink, 0xde9b91f1, 0xfa12, 0x11d0, 0xaa, 0x14, 0x0, 0xaa, 0x0, 0x6b, 0xc8, 0xb);
//
// ************************************************************************


// ************************************************************************
//
// These values are strictly local to the source - they do not get
// exported anywhere.
//
// This is the CLSID of the dispatcher.
// {DE9B91F0-FA12-11d0-AA14-00AA006BC80B}
DEFINE_GUID(CLSID_CDDrop2Dispatcher, 0xde9b91f0, 0xfa12, 0x11d0, 0xaa, 0x14, 0x0, 0xaa, 0x0, 0x6b, 0xc8, 0xb);
//
// This is the IID of the interface to the dispatcher.
// {01199F20-FA25-11d0-AA14-00AA006BC80B}
DEFINE_GUID(IID_IDDrop2Dispatch, 0x1199f20, 0xfa25, 0x11d0, 0xaa, 0x14, 0x0, 0xaa, 0x0, 0x6b, 0xc8, 0xb);
//
// This is the IID of the interface to the sink.
// {DC857810-FD4F-11d0-AA17-00AA006BC80B}
DEFINE_GUID(IID_IDDrop2SinkNotify, 0xdc857810, 0xfd4f, 0x11d0, 0xaa, 0x17, 0x0, 0xaa, 0x0, 0x6b, 0xc8, 0xb);

//
// ************************************************************************


// ************************************************************************
//
// This is the interface to the dispatcher.  This interface is strictly
// local to the server - it never gets exported externally.
//
/////////////////////////////////////////////////////////////////////////////
// IDDrop2Dispatch
class IDDrop2Dispatch : public IUnknown {
	public:
		virtual HRESULT STDMETHODCALLTYPE DoNotify(LPCOLESTR pszFile, DWORD dwAction) = 0;
};


// ************************************************************************
//
// This is the interface to the sink.  Since the test sink is implemented
// locally to the server, this interface can be declared locally - for this
// sample, nothing outside of the server needs this interface.  However, if
// an external sink was going to be used, and the external sink was going to
// implement this interface, then this interface would need to be declared
// externally (like in an .IDL file).
//
/////////////////////////////////////////////////////////////////////////////
// IDDrop2SinkNotify
class IDDrop2SinkNotify : public IUnknown {
	public:
		virtual HRESULT STDMETHODCALLTYPE OnEvent(LPCOLESTR pszFile, DWORD dwAction) = 0;
};


// ************************************************************************
//
// This is the dispatcher itself.  It inherits from CEventBaseDispatcher
// (which means that it implements IEventDispatcher, and also that it
// gets implementations of some methods from that class), as well as from
// CComObjectRoot (which means that it gets implementations of some
// methods from that class), and from IDDrop2Dispatch (which is the
// internal interface to the dispatcher).
//
// It does *not* inherit from CComCoClass<>, so it is *not* CoCreate-able.
//
/////////////////////////////////////////////////////////////////////////////
// CDDrop2Dispatcher
class ATL_NO_VTABLE CDDrop2Dispatcher :
	public CEventBaseDispatcher,
	public CComObjectRoot,
//	public CComCoClass<CDDrop2Dispatcher,&CLSID_CDDrop2Dispatcher>,
	public IDDrop2Dispatch
{

	public:

		// Declare a class factory.  This is done so that the class factory
		// can be given to IEventRouter::CreateDispatcherByClassFactory
		DECLARE_CLASSFACTORY();

		DECLARE_PROTECT_FINAL_CONSTRUCT();

//		DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
//									   L"DDrop2Dispatcher Class",
//									   L"DDrop2.Dispatcher.1",
//									   L"DDrop2.Dispatcher");

		// We implement multiple versions of IUnknown, so declare the
		// GetControllingUnknown() method - so we can use that to get
		// the One True IUnknown for ourselves.
		DECLARE_GET_CONTROLLING_UNKNOWN();

		// We never create aggregates of this object, so don't bother
		// generating aggregate support.
		DECLARE_NOT_AGGREGATABLE(CDDrop2Dispatcher);

		// This is the list of interfaces which we implement.
		BEGIN_COM_MAP(CDDrop2Dispatcher)
			COM_INTERFACE_ENTRY(IDDrop2Dispatch)
			COM_INTERFACE_ENTRY(IEventDispatcher)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)	// if free-threaded
		END_COM_MAP()

		// Since this object is free-threaded, we aggregate with COM's free-threaded
		// marshaler.
		HRESULT FinalConstruct() {
			HRESULT hrRes;

			hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
			_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
			return (SUCCEEDED(hrRes)?S_OK:hrRes);
		}

		void FinalRelease() {
			m_pUnkMarshaler.Release();
		};

		// We want to cache the "rule" for each binding.  So, we will extend the
		// CBinding class to include the extra functionality we need.  This includes
		// adding our own ctor and dtor, as well as adding out own Init() method.  And
		// of course, we add a data member to actually hold the cached rule.
		class CDDrop2Binding : public CEventBaseDispatcher::CBinding {
			public:
				CDDrop2Binding() {
					m_strRule = NULL;
				};
				~CDDrop2Binding() {
					if (m_strRule) {
						SysFreeString(m_strRule);
						m_strRule = NULL;
					};
				};
				virtual HRESULT Init(IEventBinding *piBinding) {
					// Call the parent's Init() method, to give it the first shot.
					CComPtr<IEventPropertyBag> pProps;
					HRESULT hrRes;
					CComVariant varValue;

					hrRes = CBinding::Init(piBinding);
					if (!SUCCEEDED(hrRes)) {
						return (hrRes);
					}
					// If the parent managed to init, then do out custom init work here...
					hrRes = piBinding->get_SourceProperties(&pProps);
					if (!SUCCEEDED(hrRes)) {
						return (hrRes);
					}
					hrRes = pProps->Item(&CComVariant(L"Rule"),&varValue);
					if (!SUCCEEDED(hrRes)) {
						return (hrRes);
					}
					if (hrRes != S_FALSE) {
						hrRes = varValue.ChangeType(VT_BSTR);
						if (SUCCEEDED(hrRes)) {
							m_strRule = varValue.bstrVal;
							varValue.vt = VT_EMPTY;
						}
					}
					return (S_OK);
				}
			public:
				BSTR m_strRule;
		};

		// Since we are extending the CBinding class, we need to override the method
		// for allocating new instances of CBinding - we will allocate a CDDrop2Binding
		// object instead.
		virtual HRESULT AllocBinding(REFGUID rguidEventType,
									 IEventBinding *piBinding,
									 CBinding **ppNewBinding) {
			if (ppNewBinding) {
				*ppNewBinding = NULL;
			}
			if (!piBinding || !ppNewBinding) {
				return (E_POINTER);
			}
			*ppNewBinding = new CDDrop2Binding;
			if (!*ppNewBinding) {
				return (E_OUTOFMEMORY);
			}
			// maybe do some initialization here, if you need to
			return (S_OK);
		};

		// We need to extend the functionality of the CParams class - we want to provide our
		// own functions for checking the rule and calling the sink, and we want to include
		// some data members which contain information about the event being signaled.  Again,
		// we implement our own ctor and dtor, and we override the base functions to include
		// the new functionality we need.  And we add some data members for the data we want
		// to pass along.
		class CDDrop2Params : public CEventBaseDispatcher::CParams {
			public:
				CDDrop2Params() {
					m_pszFile = NULL;
					m_dwAction = 0;
				};
				CDDrop2Params(LPCOLESTR pszFile, DWORD dwAction) {
					m_pszFile = pszFile;
					m_dwAction = dwAction;
				};
				virtual HRESULT CheckRule(CBinding& bBinding) {
					CDDrop2Binding& bTmp = static_cast<CDDrop2Binding&>(bBinding);

					if (!bTmp.m_strRule) {
						// If no rule was specified, then assume we should always call the sink.
						return (S_OK);
					}
					if (_wcsicmp(bTmp.m_strRule,m_pszFile) == 0) {
						printf("CDDrop2Dispatcher::CDDrop2Params::CheckRule() %ls == %ls, rule passed.\n",bTmp.m_strRule,m_pszFile);
						// The names match, so call the sink.
						return (S_OK);
					}
					printf("CDDrop2Dispatcher::CDDrop2Params::CheckRule() %ls != %ls, rule failed.\n",bTmp.m_strRule,m_pszFile);
					return (S_FALSE);
				};
				virtual HRESULT CallObject(CBinding& bBinding, IUnknown *pUnkSink) {
					CDDrop2Binding& bTmp = static_cast<CDDrop2Binding&>(bBinding);
					CComQIPtr<IDDrop2SinkNotify,&IID_IDDrop2SinkNotify> pSink;

					if (!pUnkSink) {
						return (E_POINTER);
					}
					pSink = pUnkSink;
					if (pSink) {
						return (pSink->OnEvent(m_pszFile,m_dwAction));
					}
					return (CParams::CallObject(bBinding,pUnkSink));
				}
			public:
				LPCOLESTR m_pszFile;
				DWORD m_dwAction;
		};

	//
	// This is the internal interface to our dispatcher.  The core server code will get
	// a pointer to this interface, and call the method to signal the event.  In our case,
	// this method just sticks the parameters into a DDrop2Params object, and calls the
	// base Dispatcher() method.
	//
	// IDDrop2Dispatch
	public:
		HRESULT STDMETHODCALLTYPE DoNotify(LPCOLESTR pszFile, DWORD dwAction) {
			CDDrop2Params params(pszFile,dwAction);

			return (Dispatcher(CATID_DDrop2FileEvent,&params));
		};

	// This dispatcher is a free-threaded object - so we will aggregate with COM's
	// free-threaded marshaler.  And we need a data member to hold the free-threaded
	// marshaler in.
	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


// ************************************************************************
//
// This is the test sink.  In order to make the sample program easier to
// build, this test sink is implemented by the same executable which
// implements the source.
//
// The test sink implements the IDDrop2Notify interface.  This is the
// primary way that it expects to receive notifications about events.
//
// The test sink also implements IEventSinkNotify - by disabling the sink's
// IDDrop2SinkNotify interface, you can see how the dispatcher adapts its
// bahavior depending on which interfaces the sink implements.
//
// Finally, the sink implements IPersistPropertyBag, so that it can receive
// the SinkProperties for the binding.
//
/////////////////////////////////////////////////////////////////////////////
// CDDrop2Sink
class ATL_NO_VTABLE CDDrop2Sink :
	public IDDrop2SinkNotify,
	public IEventSinkNotify,
	public CComObjectRoot,
	public CComCoClass<CDDrop2Sink,&CLSID_CDDrop2Sink>,
	public IPersistPropertyBag,
	public IEventPersistBinding,
	public IEventIsCacheable
{

	public:

		DECLARE_PROTECT_FINAL_CONSTRUCT();

		// Since this test sink is implemtented by the server itself,
 		// this information about the ProgID and such is not needed.  It
		// is just included here for completeness - this sink never gets
		// entered in the registry, so this information is never actually
		// used in this sample.
		DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
									   L"DDrop2Sink Class",
									   L"DDrop2.Sink.1",
									   L"DDrop2.Sink");

		DECLARE_GET_CONTROLLING_UNKNOWN();

		// These are the interfaces which the sink implements.
		BEGIN_COM_MAP(CDDrop2Sink)
			COM_INTERFACE_ENTRY(IEventSinkNotify)
			//
			// If you comment out the entry for IDDrop2SinkNotify, you can
			// observe how the sample dispatcher adapts its bevahior based on
			// which interfaces the sink implements.
			COM_INTERFACE_ENTRY(IDDrop2SinkNotify)
			COM_INTERFACE_ENTRY(IPersistPropertyBag)
			COM_INTERFACE_ENTRY(IEventPersistBinding)
			COM_INTERFACE_ENTRY(IEventIsCacheable)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)	// if free-threaded
		END_COM_MAP()

		// This sink is free-threaded, so we aggregate with COM's free-threaded marshaler.
		HRESULT FinalConstruct() {
			HRESULT hrRes;

			m_dwParam = 0;
			m_bCache = FALSE;
			hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
			_ASSERTE(!SUCCEEDED(hrRes)||m_pUnkMarshaler);
			return (SUCCEEDED(hrRes)?S_OK:hrRes);
		}

		void FinalRelease() {
			m_pUnkMarshaler.Release();
		};

	// IDDrop2SinkNotify
	public:
		HRESULT STDMETHODCALLTYPE OnEvent(LPCOLESTR pszFile, DWORD dwAction) {

			printf("CDDrop2Sink::OnEvent(pszFile=%ls,dwAction=%d) m_dwParam=%u.\n",pszFile,dwAction,m_dwParam);
			return (S_OK);
		};

	// IEventSinkNotify
	public:
		HRESULT STDMETHODCALLTYPE OnEvent() {

			printf("CDDrop2Sink::OnEvent() - m_dwParam=%u.\n",m_dwParam);
			return (S_OK);
		};

	// IPersistPropertyBag
	public:
		HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pCLSID) {
			if (!pCLSID) {
				return (E_POINTER);
			}
			*pCLSID = CLSID_CDDrop2Sink;
			return (S_OK);
		};

		HRESULT STDMETHODCALLTYPE InitNew() {
			return (S_OK);
		};

		HRESULT STDMETHODCALLTYPE Load(IPropertyBag *pProps, IErrorLog *pErrorLog) {
			HRESULT hrRes;
			CComVariant varValue;

			if (!pProps) {
				return (E_POINTER);
			}
			hrRes = pProps->Read(L"Param",&varValue,pErrorLog);
			if (SUCCEEDED(hrRes) && (hrRes != S_FALSE)) {
				hrRes = varValue.ChangeType(VT_I4);
				if (SUCCEEDED(hrRes)) {
					m_dwParam = varValue.lVal;
				}
			}
			varValue.Clear();
			hrRes = pProps->Read(L"Cache",&varValue,pErrorLog);
			if (SUCCEEDED(hrRes) && (hrRes != S_FALSE)) {
				hrRes = varValue.ChangeType(VT_BOOL);
				if (SUCCEEDED(hrRes)) {
					m_bCache = varValue.boolVal ? TRUE : FALSE;
				}
			}
			return (S_OK);
		};

		HRESULT STDMETHODCALLTYPE Save(IPropertyBag *pProps, BOOL fClearDirty, BOOL fSaveAllProperties) {
			// tbd
			return (S_OK);
		};

	// IEventPersistBinding
	public:
		// Share GetClassID with IPersistPropertyBag
		HRESULT STDMETHODCALLTYPE IsDirty(void) {

			return (S_FALSE);
		};

		HRESULT STDMETHODCALLTYPE Load(IEventBinding *pBinding) {
			HRESULT hrRes;
			CComPtr<IEventPropertyBag> pProps;
			CComQIPtr<IPropertyBag,&IID_IPropertyBag> pPropBag;

			if (!pBinding) {
				return (E_POINTER);
			}
			hrRes = pBinding->get_SinkProperties(&pProps);
			if (!SUCCEEDED(hrRes)) {
				return (hrRes);
			}
			pPropBag = pProps;
			if (!pPropBag) {
				return (E_NOINTERFACE);
			}
			return (Load(pPropBag,NULL));
		};

		HRESULT STDMETHODCALLTYPE Save(IEventBinding *pBinding, VARIANT_BOOL fClearDirty) {

			return (S_OK);
		};

	public:
		HRESULT STDMETHODCALLTYPE IsCacheable() {

			return (m_bCache?S_OK:S_FALSE);
		};

	private:
		DWORD m_dwParam;
		BOOL m_bCache;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


// ************************************************************************


// This is the code for the server.  It consists of helper functions,
// global variables, the actual server code which watches for the change
// notifications, and of course the main() functions.


/////////////////////////////////////////////////////////////////////////////
// Helper Functions


static LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2) {
	while (*p1 != NULL) {
		LPCTSTR p = p2;
		while (*p != NULL) {
			if (*p1 == *p++) {
				return (p1+1);
			}
		}
		p1++;
	}
	return (NULL);
}


/////////////////////////////////////////////////////////////////////////////
// Globals


LONG CExeModule::Unlock() {
	LONG l = CComModule::Unlock();
	return (l);
}


CExeModule _Module;

// This object map is used by ATL to perform object registration.  We enter
// information about the test sink, so that ATL can call CoRegisterClassObject
// for us.
BEGIN_OBJECT_MAP(ObjectMap)
//	OBJECT_ENTRY(CLSID_CDDrop2Dispatcher,CDDrop2Dispatcher)
	OBJECT_ENTRY(CLSID_CDDrop2Sink,CDDrop2Sink)
END_OBJECT_MAP()


//
// This is the function which watches for change notifications.  It checks
// the command line for which directory to watch, then it loads and
// initializes the router.  Finally, it goes into a loop watching for
// change notifications - when they happen, it uses the router to load the
// dispatcher, and then uses the dispatcher to signal the event.  It exits
// the loop when the uses presses any key.
//
/////////////////////////////////////////////////////////////////////////////
// DoDDrop2
static void DoDDrop2(int argc, char **argv) {
	CComPtr<IUnknown> pServiceHandle;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	HANDLE hDir = INVALID_HANDLE_VALUE;
	HRESULT hrRes;
	CComPtr<IEventRouter> pRouter;
	HANDLE hEvent = NULL;
	CComPtr<IClassFactory> pClassFactory;

	if (argc < 2) {
		printf("Usage:\n"
			   "\tddrop2 DIRECTORY\n"
			   "where DIRECTORY is the directory to watch.\n");
		return;
	}
	// Just make sure the directory exists...
	hDir = CreateFile(argv[1],
					  FILE_LIST_DIRECTORY,
					  FILE_SHARE_READ|FILE_SHARE_DELETE,
					  NULL,
					  OPEN_EXISTING,
					  FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_OVERLAPPED,
					  NULL);
	if (hDir == INVALID_HANDLE_VALUE) {
		printf("File open for %s failed - GetLastError() = %u.",argv[2],GetLastError());
		goto done;
	}
	// Get the service handle - not strictly needed in this sample, but it is needed by
	// anyone who wants to create router objects from within the metabase change
	// notification callback.
	hrRes = SEOGetServiceHandle(&pServiceHandle);
	_ASSERTE(SUCCEEDED(hrRes));
	if (!SUCCEEDED(hrRes)) {
		goto done;
	}
	// Get the router object, initialized for our source.
	hrRes = SEOGetRouter(GUID_DDrop2_SourceType,GUID_DDrop2_Source,&pRouter);
	_ASSERTE(SUCCEEDED(hrRes));
	if (!SUCCEEDED(hrRes)) {
		goto done;
	}
	if (hrRes == S_FALSE) {
		_ASSERTE(!pRouter);
		printf("The proper registrations have not been done.\n");
		goto done;
	}
	_ASSERTE(pRouter);
	// Get the class factory for the dispatcher.
	hrRes = CComObject<CDDrop2Dispatcher>::_ClassFactoryCreatorClass::CreateInstance(CComObject<CDDrop2Dispatcher>::_CreatorClass::CreateInstance,
																				     IID_IClassFactory,
																				     (LPVOID *) &pClassFactory);
	_ASSERTE(SUCCEEDED(hrRes));
	if (!SUCCEEDED(hrRes)) {
		goto done;
	}
	// At this point, we are ready to go - we have checked our parameters, we have loaded the
	// router and initialized it with the binding database, and we have a class factory for
	// our dispatcher.  Now we do the actually directory change notification stuff.
	hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
	_ASSERT(hEvent);
	if (!hEvent) {
		goto done;
	}
	while (1) {
		BOOL bRes;
		BYTE pbBuffer[sizeof(FILE_NOTIFY_INFORMATION)+(MAX_PATH+1)*sizeof(WCHAR)];
		DWORD dwWritten;
		OVERLAPPED ov;
		DWORD dwRes;
		FILE_NOTIFY_INFORMATION *pNotify;

		memset(&ov,0,sizeof(ov));
		ov.hEvent = hEvent;
		bRes = ReadDirectoryChangesW(hDir,
									 pbBuffer,
									 sizeof(pbBuffer),
									 FALSE,
									 FILE_NOTIFY_CHANGE_FILE_NAME,
									 NULL,
									 &ov,
									 NULL);
		_ASSERT(bRes);
		if (!bRes) {
			goto done;
		}
		printf("Waiting for change notification (press any key to exit) ... ");
		while ((dwRes=WaitForSingleObject(hEvent,1000L)) == WAIT_TIMEOUT) {
			if (!_kbhit()) {
				continue;
			}
			while (_kbhit()) {
				_getch();
			}
			break;
		}
		if (dwRes == WAIT_TIMEOUT) {
			printf("Exiting.\n");
			goto done;
		}
		_ASSERTE(dwRes==WAIT_OBJECT_0);
		if (dwRes != WAIT_OBJECT_0) {
			goto done;
		}
		printf("Got one!\n");
		bRes = GetOverlappedResult(hDir,&ov,&dwWritten,FALSE);
		_ASSERT(bRes);
		if (!bRes) {
			goto done;
		}
		pNotify = (FILE_NOTIFY_INFORMATION *) pbBuffer;
		// Ok - we have some number of change notifications.  We're going
		// to walk through them, and ask the dispatcher to signal each of
		// them.
		while (1) {
			CComPtr<IDDrop2Dispatch> pDispatcher;
			WCHAR achFileName[MAX_PATH+1];

			memset(achFileName,0,sizeof(achFileName));
			memcpy(achFileName,pNotify->FileName,pNotify->FileNameLength);
			printf("\tNotify => %u - %ls.\n",
				   pNotify->Action,
				   achFileName);
			pDispatcher.Release();
			// This is the meat of dispatching events.  First, we ask the router object for the
			// dispatcher object for this type of event.
			hrRes = pRouter->GetDispatcherByClassFactory(CLSID_CDDrop2Dispatcher,
														 pClassFactory,
														 CATID_DDrop2FileEvent,
													     IID_IDDrop2Dispatch,
											      		 (IUnknown **) &pDispatcher);
			_ASSERT(SUCCEEDED(hrRes));
			if (!SUCCEEDED(hrRes)) {
				goto done;
			}
			// Then we just call the dispatcher's entry point to let it fire the
			// event to all of the bindings.
			hrRes = pDispatcher->DoNotify(achFileName,pNotify->Action);
			_ASSERT(SUCCEEDED(hrRes));
			if (!SUCCEEDED(hrRes)) {
				goto done;
			}
			// Check to see if there are more directory changes that happened - if not
			// then break out of this loop.
			if (!pNotify->NextEntryOffset) {
				break;
			}
			pNotify = (FILE_NOTIFY_INFORMATION *) (((LPBYTE) pNotify) + pNotify->NextEntryOffset);
		}
	}
done:
	if (hEvent) {
		CloseHandle(hEvent);
	}
	if (hDir != INVALID_HANDLE_VALUE) {
		CloseHandle(hDir);
	}
	if (hFile != INVALID_HANDLE_VALUE) {
		CloseHandle(hFile);
	}
}


/////////////////////////////////////////////////////////////////////////////
// main
int _cdecl main(int argc, char **argv) {
	LPTSTR lpCmdLine = GetCommandLine();	// necessary for minimal CRT
//	HRESULT hRes = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//	instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
	HRESULT hRes = CoInitializeEx(NULL,COINIT_MULTITHREADED);
	_ASSERTE(SUCCEEDED(hRes));
	_Module.Init(ObjectMap,GetModuleHandle(NULL));
	_Module.dwThreadID = GetCurrentThreadId();
	TCHAR szTokens[] = _T("-/");

	int nRet = 0;
	BOOL bRun = TRUE;
	LPCTSTR lpszToken = FindOneOf(lpCmdLine,szTokens);
	while (lpszToken != NULL) {
		lpszToken = FindOneOf(lpszToken,szTokens);
	}

	if (bRun) {
		hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER,REGCLS_MULTIPLEUSE);
		_ASSERTE(SUCCEEDED(hRes));

		DoDDrop2(argc,argv);

		_Module.RevokeClassObjects();
	}

	CoUninitialize();
	return (nRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop2\stdafx.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.cpp

Abstract:

	This module contains the implementation for the base
	ATL methods.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	12/04/96	created

--*/


// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...) {
	LPBYTE pbAdd = NULL;		// Working pointer to the next available "scratch space" in the map.
	DWORD dwCnt = 0;			// The count of entries in the map.
	LPOLESTR pszCLSID = NULL;	// The CLSID as a string.
	LPOLESTR pszTLID = NULL;	// The TLID as a string.

	if (!pparmeResult) {
		// The caller did not give us a place to return the result.
		return (E_POINTER);
	}
	*pparmeResult = NULL;	// For the first time through the loop, the result is NULL.
	// We are going to loop through twice.  The first time through, we haven't allocate the map yet, so
	// we will count all the strings, and add up their lenghts - this will give us the size of the buffer
	// we need to allocate for the map.  Then the second time through the loop, we will store all the
	// strings in the map.
	while (1) {
		if (pclsid) {
			// If we were passed a CLSID, then we want to include that in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to convert the CLSID to a string.
				HRESULT hrRes;

				hrRes = StringFromCLSID(*pclsid,&pszCLSID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the CLSID to a string.
					CoTaskMemFree(*pparmeResult);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the CLSID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"CLSID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszCLSID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the CLSID string and the fact that we have a CLSID in the map.
			pbAdd += (wcslen(pszCLSID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszCLSID);
				pszCLSID = NULL;
			}
		}
		if (pmodule) {
			// If we were passed a module, then we want to include the TLID in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to load the type library, get its
				// TLID, and convert it to a string.
				USES_CONVERSION;
				HRESULT hrRes;
				TCHAR szModule[MAX_PATH];
				LPOLESTR pszModule;
				CComPtr<ITypeLib> pTypeLib;
				TLIBATTR *ptlaAttr;
				if (!GetModuleFileName(pmodule->GetTypeLibInstance(),
									   szModule,
									   sizeof(szModule)/sizeof(TCHAR))) {
					hrRes = HRESULT_FROM_WIN32(GetLastError());
					if (SUCCEEDED(hrRes)) {
						// GetModuleFileName() failed, but GetLastError() didn't report an error - so
						// fake it.
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				if (pszIndex) {
					// If we were passed an index, that means that the type library desired is not the
					// first type library in the resources - so append the index to the module name.
					lstrcat(szModule,OLE2T(pszIndex));
				}
				pszModule = T2OLE(szModule);
				hrRes = LoadTypeLib(pszModule,&pTypeLib);
				if (!SUCCEEDED(hrRes)) {
					// If we couldn't load the type library from the module, let's try changing the
					// module name to a type library name (change the extension to .TLB) and try to load
					// *that*.
					LPTSTR pszExt = NULL;
					LPTSTR psz;

					for (psz=szModule;*psz;psz=CharNext(psz)) {
						if (*psz == _T('.')) {
							pszExt = psz;
						}
					}
					if (!pszExt) {
						pszExt = psz;
					}
					lstrcpy(pszExt,_T(".tlb"));
					pszModule = T2OLE(szModule);
					hrRes = LoadTypeLib(pszModule,&pTypeLib);
				}
				if (!SUCCEEDED(hrRes)) {
					// We failed to load the type library.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = pTypeLib->GetLibAttr(&ptlaAttr);
				if (!SUCCEEDED(hrRes)) {
					// We failed to get the type library attributes.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = StringFromCLSID(ptlaAttr->guid,&pszTLID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the TLID to a string.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the TLID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"LIBID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszTLID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the TLID string and the fact that we have a TLID in the map.
			pbAdd += (wcslen(pszTLID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszTLID);
				pszTLID = NULL;
			}
		}
		{	// Now we need to go through the varargs.  All of the varargs must be LPOLESTR (i.e. they
			// must be UNICODE), and they will consist of pairs - the key name followed by the data.  If
			// either member of the pair is NULL, that signals the end of the varargs.
			va_list valArgs;

			// Set the va_list to the start of the varargs.
			va_start(valArgs,pszIndex);
			while (1) {
				LPCOLESTR pszKey;
				LPCOLESTR pszData;

				// Get the first of the pair - this is the key name.
				pszKey = va_arg(valArgs,LPCOLESTR);
				if (!pszKey) {
					break;
				}
				// Get the second of the pair - this is the data.
				pszData = va_arg(valArgs,LPCOLESTR);
				if (!pszData) {
					break;
				}
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the key name to the
					// map.
					(*pparmeResult)[dwCnt].szKey = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szKey,pszKey);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string.
				pbAdd += (wcslen(pszKey)+1) * sizeof(OLECHAR);
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the data to the map.
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszData);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string and the fact that we have a string in the map.
				pbAdd += (wcslen(pszData)+1) * sizeof(OLECHAR);
				dwCnt++;
			}
			// Reset the va_list, for the sake of cleanliness.
			va_end(valArgs);
		}
		if (*pparmeResult) {
			// If we have allocated the map, that means that we are finishing the second time through
			// the loop - so we are done!
			break;
		}
		if (!*pparmeResult) {
			// If we havemn't allocate the map, that means that we are finishing the first time through
			// the loop - so we need to allocate the map in preparation for the second time through.
			// First we calculate the number of bytes needed for the map - this is one ATL_REGMAP_ENTRY
			// for each entry, plus one _ATL_REGMAP_ENTRY which signals the end of the map, plus enough
			// space for all of the strings to follow.
			DWORD dwBytes = (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY) + (pbAdd-(LPBYTE) NULL);

			*pparmeResult = (_ATL_REGMAP_ENTRY *) CoTaskMemAlloc(dwBytes);
			if (!*pparmeResult) {
				// The memory allocation failed.
				CoTaskMemFree(pszCLSID);
				CoTaskMemFree(pszTLID);
				return (E_OUTOFMEMORY);
			}
			// The memory allocation was successful - fill the memory with zeroes in preparation for
			// loading with the values.
			memset(*pparmeResult,0,dwBytes);
			// Reset the counters to the "beginning" - so that on the second time through, they are used
			// to keep track of where each successive value gets stored in the memory block.
			pbAdd = ((LPBYTE) *pparmeResult) + (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY);
			dwCnt = 0;
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\seotlib\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   12/04/96        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif


#ifdef _ATL_NO_DEBUG_CRT
	#include "windows.h"
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif


//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop\exe\ddrop.cpp ===
#include "stdafx.h"
#include "dbgtrace.h"
#include "seo.h"
#include "seo_i.c"
#include "ddrops.h"
#include "ddrops_i.c"
#include <stdio.h>
#include <conio.h>


#define BP_GUID_STR	"{3994B810-98E1-11d0-A9E8-00AA00685C74}"
#define BPS_BP_GUID_STR	"BindingPoints\\" BP_GUID_STR "\\"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


int _cdecl main(int argc, char**argv) {
	HANDLE hFile = INVALID_HANDLE_VALUE;
	HANDLE hDir = INVALID_HANDLE_VALUE;
	HRESULT hrRes;
	CComPtr<ISEORouter> pRouter;
	CComPtr<IStream> pStream;
	CComPtr<ISEODictionary> pDict;
	HANDLE hEvent = NULL;
	BOOL bMeta = FALSE;

	if (argc != 3) {
		printf("Usage:\n"
			   "\tddrop FILE DIRECTORY\n"
			   "where FILE is either\n"
			   "\tthe name of a binding database file\n"
			   "\tor /meta indicating that the metabase should be used,\n"
			   "and where DIRECTORY is the directory to watch.\n");
		exit(1);
	}
	// Some quick-n-dirty initialization
	hrRes = CoInitializeEx(NULL,COINIT_MULTITHREADED);
	_ASSERT(SUCCEEDED(hrRes));
	if (!SUCCEEDED(hrRes)) {
		exit(1);
	}
	_Module.Init(ObjectMap,GetModuleHandle(NULL));
	if (_stricmp(argv[1],"/meta") != 0) {
		// Just make sure the input file exists...
		hFile = CreateFile(argv[1],
						   GENERIC_READ,
						   FILE_SHARE_READ,
						   NULL,
						   OPEN_EXISTING,
						   FILE_ATTRIBUTE_NORMAL,
						   NULL);
		if (hFile == INVALID_HANDLE_VALUE) {
			printf("File open for %s failed - GetLastError() = %u.",argv[1],GetLastError());
			goto done;
		}
	} else {
		bMeta = TRUE;
	}
	// Just make sure the directory exists...
	hDir = CreateFile(argv[2],
					  FILE_LIST_DIRECTORY,
					  FILE_SHARE_READ|FILE_SHARE_DELETE,
					  NULL,
					  OPEN_EXISTING,
					  FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_OVERLAPPED,
					  NULL);
	if (hDir == INVALID_HANDLE_VALUE) {
		printf("File open for %s failed - GetLastError() = %u.",argv[2],GetLastError());
		goto done;
	}
	// Get the router object
	if (bMeta) {
		// Initialize from the metabase.
		hrRes = MCISInitSEOA("DDROP_SVC",0,&pRouter);
		_ASSERT(SUCCEEDED(hrRes));
		if (!SUCCEEDED(hrRes)) {
			goto done;
			exit(1);
		}
	} else {
		// Initialize from a file.
		hrRes = CoCreateInstance(CLSID_CSEORouter,NULL,CLSCTX_ALL,IID_ISEORouter,(LPVOID *) &pRouter);
		_ASSERT(SUCCEEDED(hrRes));
		if (!pRouter) {
			goto done;
		}
		// Turn the file into an IStream...
		hrRes = SEOCreateIStreamFromFileA(hFile,NULL,&pStream);
		_ASSERT(SUCCEEDED(hrRes));
		if (!pStream) {
			goto done;
		}
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
		// ... and then turn the IStream into a dictionary
		hrRes = SEOCreateDictionaryFromIStream(pStream,&pDict);
		_ASSERT(SUCCEEDED(hrRes));
		pStream.Release();
		if (!pDict) {
			goto done;
		}
		// Give the dictionary to the router
		hrRes = pRouter->put_Database(pDict);
		_ASSERT(SUCCEEDED(hrRes));
		pDict.Release();
		if (!SUCCEEDED(hrRes)) {
			goto done;
		}
	}
	// At this point, we're ready to go.  We have loaded a binding databas (from the text file
	// whose filename was given on the command line), we have created a router object, and we
	// have given the router object a pointer to the dictionary.
	hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
	_ASSERT(hEvent);
	if (!hEvent) {
		goto done;
	}
	while (1) {
		BOOL bRes;
		BYTE pbBuffer[sizeof(FILE_NOTIFY_INFORMATION)+(MAX_PATH+1)*sizeof(WCHAR)];
		DWORD dwWritten;
		OVERLAPPED ov;
		DWORD dwRes;
		FILE_NOTIFY_INFORMATION *pNotify;

		memset(&ov,0,sizeof(ov));
		ov.hEvent = hEvent;
		bRes = ReadDirectoryChangesW(hDir,
									 pbBuffer,
									 sizeof(pbBuffer),
									 FALSE,
									 FILE_NOTIFY_CHANGE_FILE_NAME,
									 NULL,
									 &ov,
									 NULL);
		_ASSERT(bRes);
		if (!bRes) {
			goto done;
		}
		printf("Waiting for change notification (press any key to exit) ... ");
		while ((dwRes=WaitForSingleObject(hEvent,1000L)) == WAIT_TIMEOUT) {
			if (!_kbhit()) {
				continue;
			}
			while (_kbhit()) {
				_getch();
			}
			break;
		}
		if (dwRes == WAIT_TIMEOUT) {
			printf("Exiting.\n");
			goto done;
		}
		_ASSERTE(dwRes==WAIT_OBJECT_0);
		if (dwRes != WAIT_OBJECT_0) {
			goto done;
		}
		printf("Got one!\n");
		bRes = GetOverlappedResult(hDir,&ov,&dwWritten,FALSE);
		_ASSERT(bRes);
		if (!bRes) {
			goto done;
		}
		pNotify = (FILE_NOTIFY_INFORMATION *) pbBuffer;
		while (1) {
			CComPtr<IDDropDispatcher> pDispatcher;
			WCHAR achFileName[MAX_PATH+1];

			memset(achFileName,0,sizeof(achFileName));
			memcpy(achFileName,pNotify->FileName,pNotify->FileNameLength);
			printf("\tNotify => %u - %ls.\n",
				   pNotify->Action,
				   achFileName);
			pDispatcher.Release();
			// This is the meat of dispatching events.  First, we ask the router object for the
			// dispatcher object for this type of event.
			hrRes = pRouter->GetDispatcher(CLSID_CDDropDispatcher,
										   IID_IDDropDispatcher,
										   (IUnknown **) &pDispatcher);
			_ASSERT(SUCCEEDED(hrRes));
			if (!SUCCEEDED(hrRes)) {
				goto done;
			}
			// Then we test to see if there are any bindings at out binding point -
			// ISEORouter::GetDispatcher returns S_FALSE if there are no bindings.
			if (hrRes != S_FALSE) {
				// Then we just call the dispatcher's entry point to let it fire the
				// event to all of the bindings.
				hrRes = pDispatcher->OnFileChange(pNotify->Action,achFileName);
				_ASSERT(SUCCEEDED(hrRes));
				if (!SUCCEEDED(hrRes)) {
					goto done;
				}
			}
			if (!pNotify->NextEntryOffset) {
				break;
			}
			pNotify = (FILE_NOTIFY_INFORMATION *) (((LPBYTE) pNotify) + pNotify->NextEntryOffset);
		}
	}
done:
#if 0
	if (pRouter) {
		// Do this so that the router releases all of the references to any
		// dispatchers which may have been created.  Since the dispatchers
		// might themselves be holding references to the router, this is the
		// only way to release the circular references...
		pRouter->put_Database(NULL);
	}
#endif
	if (hEvent) {
		CloseHandle(hEvent);
	}
	if (hDir != INVALID_HANDLE_VALUE) {
		CloseHandle(hDir);
	}
	if (hFile != INVALID_HANDLE_VALUE) {
		CloseHandle(hFile);
	}
	// Do all these releases before CoUninitialize() because CoUnitialize() may unload
	// in-proc .DLL's.
	pDict.Release();
	pRouter.Release();
	pStream.Release();
	CoUninitialize();
	return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\ddrop2\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   12/04/96        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif


#ifdef _ATL_NO_DEBUG_CRT
	#include "windows.h"
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif


//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
};
extern CExeModule _Module;
#include <atlcom.h>


#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\testsrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by TESTSRV.RC
//
#define IDR_MAINFRAME					128
#define IDM_ABOUTBOX					0x0010
#define IDD_ABOUTBOX					100
#define IDS_ABOUTBOX					101
#define IDD_TESTSRV_DIALOG				102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\seotlib\seotlib.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	seotlib.cpp

Abstract:

	This module contains the implementation for the Server
	Extension Objects Test Library.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	6/9/97	created

--*/


// SEOTLib.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 or higher in order to build 
// this project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		<<TBD>>.

#include "stdafx.h"
#include "dbgtrace.h"
#include "resource.h"

//#define IID_DEFINED
#include "initguid.h"

#include "seo.h"
#include "SEO_i.c"
#include "seotlib.h"
#include "seotlib_i.c"

#include "IADM.H"


/////////////////////////////////////////////////////////////////////////////
// CSEOTMetaBaseChanges
class ATL_NO_VTABLE CSEOTMetaBaseChanges :
	public CComObjectRoot,
	public CComCoClass<CSEOTMetaBaseChanges, &CLSID_CSEOTMetaBaseChanges>,
	public IDispatchImpl<ISEOTMetaBaseChanges, &IID_ISEOTMetaBaseChanges, &LIBID_SEOTLib>,
	public IConnectionPointContainerImpl<CSEOTMetaBaseChanges>,
	public IConnectionPointImpl<CSEOTMetaBaseChanges,&IID_ISEOTMetaBaseChangeSinkDisp>,
	public IConnectionPointImpl<CSEOTMetaBaseChanges,&IID_ISEOTMetaBaseChangeSink>,
	public IProvideClassInfo2Impl<&CLSID_CSEOTMetaBaseChanges,&IID_ISEOTMetaBaseChangeSinkDisp,&LIBID_SEOTLib>,
	public IMSAdminBaseSinkA,
	public IMSAdminBaseSinkW
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();
		HRESULT SinkNotify(BOOL bUnicode, DWORD dwMDNumElemtns, MD_CHANGE_OBJECT_W pcoChangeList[]);

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEOTMetaBaseChanges Class",
								   L"SEOT.MetaBaseChanges.1",
								   L"SEOT.MetaBaseChanges");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEOTMetaBaseChanges)
		COM_INTERFACE_ENTRY(ISEOTMetaBaseChanges)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, ISEOTMetaBaseChanges)
		COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
		COM_INTERFACE_ENTRY(IProvideClassInfo2)
		COM_INTERFACE_ENTRY_IID(IID_IMSAdminBaseSink_A,IMSAdminBaseSinkA)
		COM_INTERFACE_ENTRY_IID(IID_IMSAdminBaseSink_W,IMSAdminBaseSinkW)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	BEGIN_CONNECTION_POINT_MAP(CSEOTMetaBaseChanges)
		CONNECTION_POINT_ENTRY(IID_ISEOTMetaBaseChangeSinkDisp)
		CONNECTION_POINT_ENTRY(IID_ISEOTMetaBaseChangeSink)
	END_CONNECTION_POINT_MAP()

	// ISEOTMetaBaseChanges
	public:
		// nothing

	// IMSAdminBaseSinkA
	public:
		HRESULT STDMETHODCALLTYPE SinkNotify(DWORD dwMDNumElements, MD_CHANGE_OBJECT_A pcoChangeList[]);

	// IMSAdminBaseSinkW
	public:
		HRESULT STDMETHODCALLTYPE SinkNotify(DWORD dwMDNumElements, MD_CHANGE_OBJECT_W pcoChangeList[]);

	private:
		CComPtr<IConnectionPointContainer> m_pCPC;
		DWORD m_dwCookie_A;
		DWORD m_dwCookie_W;
		CComPtr<IConnectionPoint> m_pCP_A;
		CComPtr<IConnectionPoint> m_pCP_W;
		CComPtr<IUnknown> m_pUnkMarshaler;
};


HRESULT CSEOTMetaBaseChanges::FinalConstruct() {
	TraceFunctEnter("CSEOTMetaBaseChanges::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateInstance(CLSID_MSAdminBase,
							 NULL,
							 CLSCTX_ALL,
							 IID_IConnectionPointContainer,
							 (LPVOID *) &m_pCPC);
	if (SUCCEEDED(hrRes)) {
		hrRes = m_pCPC->FindConnectionPoint(IID_IMSAdminBaseSink_A,&m_pCP_A);
		if (SUCCEEDED(hrRes)) {
			hrRes = m_pCP_A->Advise(GetControllingUnknown(),&m_dwCookie_A);
			if (!SUCCEEDED(hrRes)) {
				m_pCP_A.Release();
			}
		}
		hrRes = S_OK;
	}
	if (SUCCEEDED(hrRes)) {
		hrRes = m_pCPC->FindConnectionPoint(IID_IMSAdminBaseSink_W,&m_pCP_W);
		if (SUCCEEDED(hrRes)) {
			hrRes = m_pCP_W->Advise(GetControllingUnknown(),&m_dwCookie_W);
			if (!SUCCEEDED(hrRes)) {
				m_pCP_W.Release();
			}
		}
		hrRes = S_OK;
	}
	if (SUCCEEDED(hrRes) && !m_pCP_A && !m_pCP_W) {
		hrRes = E_NOINTERFACE;
	}
	if (SUCCEEDED(hrRes)) {
		hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	}
	TraceFunctLeave();
	return (hrRes);
}


void CSEOTMetaBaseChanges::FinalRelease() {
	TraceFunctEnter("CSEOTMetaBaseChanges::FinalRelease");
	HRESULT hrRes;

	if (m_pCP_A) {
		hrRes = m_pCP_A->Unadvise(m_dwCookie_A);
		_ASSERTE(SUCCEEDED(hrRes));
	}
	if (m_pCP_W) {
		hrRes = m_pCP_W->Unadvise(m_dwCookie_W);
		_ASSERTE(SUCCEEDED(hrRes));
	}
	m_pCP_A.Release();
	m_pCP_W.Release();
	m_pCPC.Release();
	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


HRESULT CSEOTMetaBaseChanges::SinkNotify(BOOL bUnicode, DWORD dwMDNumElements, MD_CHANGE_OBJECT_W pcoChangeList[]) {
	HRESULT hrRes;
	SAFEARRAY *psaPaths;
	DWORD dwIdx;
	CComPtr<IConnectionPoint> pCP;
	CComPtr<IEnumConnections> pEnum;

	if (dwMDNumElements && !pcoChangeList) {
		_ASSERTE(FALSE);
		return (E_POINTER);
	}
	psaPaths = SafeArrayCreateVector(VT_VARIANT,0,dwMDNumElements);
	if (!psaPaths) {
		_ASSERTE(FALSE);
		return (E_OUTOFMEMORY);
	}
	hrRes = SafeArrayLock(psaPaths);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		SafeArrayDestroy(psaPaths);
		return (hrRes);
	}
	for (dwIdx=0;dwIdx<dwMDNumElements;dwIdx++) {
		VARIANT *pvarElt;

		hrRes = SafeArrayPtrOfIndex(psaPaths,(long *) &dwIdx,(LPVOID *) &pvarElt);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			SafeArrayUnlock(psaPaths);
			SafeArrayDestroy(psaPaths);
			return (hrRes);
		}
		pvarElt->bstrVal = SysAllocString(pcoChangeList[dwIdx].pszMDPath);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			SafeArrayUnlock(psaPaths);
			SafeArrayDestroy(psaPaths);
			return (E_OUTOFMEMORY);
		}
		pvarElt->vt = VT_BSTR;
	}
	SafeArrayUnlock(psaPaths);
	hrRes = FindConnectionPoint(IID_ISEOTMetaBaseChangeSink,&pCP);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		SafeArrayDestroy(psaPaths);
		return (hrRes);
	}
	hrRes = pCP->EnumConnections(&pEnum);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		SafeArrayDestroy(psaPaths);
		return (hrRes);
	}
	while (1) {
		CONNECTDATA cdNotify;

		hrRes = pEnum->Next(1,&cdNotify,NULL);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			SafeArrayDestroy(psaPaths);
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			break;
		}
		if (bUnicode) {
			hrRes = ((ISEOTMetaBaseChangeSink *) cdNotify.pUnk)->OnChangeW(psaPaths);
		} else {
			hrRes = ((ISEOTMetaBaseChangeSink *) cdNotify.pUnk)->OnChangeA(psaPaths);
		}
		_ASSERTE(SUCCEEDED(hrRes));
		cdNotify.pUnk->Release();
	}
	pCP.Release();
	pEnum.Release();
	hrRes = FindConnectionPoint(IID_ISEOTMetaBaseChangeSinkDisp,&pCP);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		SafeArrayDestroy(psaPaths);
		return (hrRes);
	}
	hrRes = pCP->EnumConnections(&pEnum);
	if (!SUCCEEDED(hrRes)) {
		_ASSERTE(FALSE);
		SafeArrayDestroy(psaPaths);
		return (hrRes);
	}
	while (1) {
		CONNECTDATA cdNotify;
		DISPID dispid;
		LPWSTR pszName = bUnicode ? L"OnChangeW" : L"OnChangeA";
		VARIANTARG avaArgs[1];
		DISPPARAMS dpParams = {avaArgs,NULL,sizeof(avaArgs)/sizeof(avaArgs[0]),0};

		hrRes = pEnum->Next(1,&cdNotify,NULL);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			SafeArrayDestroy(psaPaths);
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			break;
		}
#if 0
		hrRes = ((IDispatch *) cdNotify.pUnk)->GetIDsOfNames(IID_NULL,
															 &pszName,
															 1,
															 GetUserDefaultLCID(),
															 &dispid);
		_ASSERTE(SUCCEEDED(hrRes));
#else
		hrRes = S_OK;
		dispid = bUnicode ? 1 : 2;
#endif
		if (SUCCEEDED(hrRes)) {
			avaArgs[0].vt = VT_ARRAY | VT_BYREF | VT_VARIANT;
			avaArgs[0].pparray = &psaPaths;
			hrRes = ((IDispatch *) cdNotify.pUnk)->Invoke(dispid,
														  IID_NULL,
														  GetUserDefaultLCID(),
														  DISPATCH_METHOD,
														  &dpParams,
														  NULL,
														  NULL,
														  NULL);
			_ASSERTE(SUCCEEDED(hrRes));
		}
		cdNotify.pUnk->Release();
	}
	SafeArrayDestroy(psaPaths);
	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CSEOTMetaBaseChanges::SinkNotify(DWORD dwMDNumElements, MD_CHANGE_OBJECT_A pcoChangeList[]) {
	MD_CHANGE_OBJECT_W *pcoTmp = NULL;
	USES_CONVERSION;

	_ASSERTE(sizeof(MD_CHANGE_OBJECT_A)==sizeof(MD_CHANGE_OBJECT_W));
	if (dwMDNumElements && pcoChangeList) {
		pcoTmp = (MD_CHANGE_OBJECT_W *) _alloca(sizeof(MD_CHANGE_OBJECT_W)*dwMDNumElements);
		memcpy(pcoTmp,pcoChangeList,sizeof(MD_CHANGE_OBJECT_W)*dwMDNumElements);
		for (DWORD dwIdx=0;dwIdx<dwMDNumElements;dwIdx++) {
			pcoTmp[dwIdx].pszMDPath = A2W((LPCSTR) pcoChangeList[dwIdx].pszMDPath);
		}
	}
	return (SinkNotify(FALSE,dwMDNumElements,pcoTmp));
}


HRESULT STDMETHODCALLTYPE CSEOTMetaBaseChanges::SinkNotify(DWORD dwMDNumElements, MD_CHANGE_OBJECT_W pcoChangeList[]) {

	return (SinkNotify(TRUE,dwMDNumElements,pcoChangeList));
}


/////////////////////////////////////////////////////////////////////////////
// CSEOTConsoleUtil
class ATL_NO_VTABLE CSEOTConsoleUtil :
	public CComObjectRoot,
	public CComCoClass<CSEOTConsoleUtil, &CLSID_CSEOTConsoleUtil>,
	public IDispatchImpl<ISEOTConsoleUtil, &IID_ISEOTConsoleUtil, &LIBID_SEOTLib>
{
	public:
		HRESULT FinalConstruct();
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEOTConsoleUtil Class",
								   L"SEOT.ConsoleUtil.1",
								   L"SEOT.ConsoleUtil");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEOTConsoleUtil)
		COM_INTERFACE_ENTRY(ISEOTConsoleUtil)
		COM_INTERFACE_ENTRY_IID(IID_IDispatch, ISEOTConsoleUtil)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	// ISEOTConsoleUtil
	public:
		HRESULT STDMETHODCALLTYPE WaitForAnyKey(long lTimeoutMS);

	private:
		CComPtr<IUnknown> m_pUnkMarshaler;
};


HRESULT CSEOTConsoleUtil::FinalConstruct() {
	TraceFunctEnter("CSEOTConsoleUtil::FinalConstruct");
	HRESULT hrRes = S_OK;

	hrRes = CoCreateFreeThreadedMarshaler(GetControllingUnknown(),&m_pUnkMarshaler.p);
	TraceFunctLeave();
	return (hrRes);
}


void CSEOTConsoleUtil::FinalRelease() {
	TraceFunctEnter("CSEOTConsoleUtil::FinalRelease");

	m_pUnkMarshaler.Release();
	TraceFunctLeave();
}


HRESULT STDMETHODCALLTYPE CSEOTConsoleUtil::WaitForAnyKey(long lTimeoutMS) {
	HANDLE hConsole;
	DWORD dwStartTime;
	DWORD dwTempTime;

	hConsole = GetStdHandle(STD_INPUT_HANDLE);
	if (hConsole == INVALID_HANDLE_VALUE) {
		_ASSERTE(FALSE);
		return (HRESULT_FROM_WIN32(GetLastError()));
	}
	dwStartTime = GetTickCount();
	dwTempTime = dwStartTime;
	while (1) {
		BOOL bRes;
		MSG msg;
		INPUT_RECORD airInput[1];
		DWORD dwInputRecords;
		DWORD dwIdx;
		BOOL bKeyInput;

		if ((lTimeoutMS != INFINITE) && (((DWORD) lTimeoutMS)+dwStartTime < dwTempTime)) {
			return (HRESULT_FROM_WIN32(ERROR_TIMEOUT));
		}
		bRes = PeekMessage(&msg,NULL,0,0,PM_REMOVE);
		if (bRes) {
			bRes = TranslateMessage(&msg);
			if (!bRes) {
				DispatchMessage(&msg);
			}
		}
		bKeyInput = FALSE;
		while (1) {
			bRes = PeekConsoleInput(hConsole,
									airInput,
									sizeof(airInput)/sizeof(airInput[0]),
									&dwInputRecords);
			if (bRes && dwInputRecords) {
				bRes = ReadConsoleInput(hConsole,
										airInput,
										sizeof(airInput)/sizeof(airInput[0]),
										&dwInputRecords);
			}
			if (!bRes) {
				_ASSERTE(FALSE);
				return (HRESULT_FROM_WIN32(GetLastError()));
			}
			if (dwInputRecords) {
				for (dwIdx=0;dwIdx<dwInputRecords;dwIdx++) {
					if (airInput[dwIdx].EventType == KEY_EVENT) {
						bKeyInput = TRUE;
					}
				}
			}
			if (!dwInputRecords) {
				break;
			}
		}
		if (bKeyInput) {
			return (S_OK);
		}
		Sleep(0);
	}
}


/////////////////////////////////////////////////////////////////////////////
// Globals

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CSEOTMetaBaseChanges, CSEOTMetaBaseChanges)
	OBJECT_ENTRY(CLSID_CSEOTConsoleUtil, CSEOTConsoleUtil)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/) {

	if (dwReason == DLL_PROCESS_ATTACH) {
		_Module.Init(ObjectMap,hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {
		_Module.Term();
	}
	return (TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void) {

	TraceFunctEnter("DllCanUnloadNow");
	HRESULT hRes = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
	DebugTrace(0,"Returns %s.",(hRes==S_OK)?"S_OK":"S_FALSE");
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {

	TraceFunctEnter("DllGetClassObject");
	HRESULT hRes = _Module.GetClassObject(rclsid,riid,ppv);
	DebugTrace(0,"Returns 0x%08x.",hRes);
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void) {

	TraceFunctEnter("DllRegisterServer");
	// registers object, typelib and all interfaces in typelib
	HRESULT hRes = _Module.RegisterServer(TRUE);
	DebugTrace(0,"Returns 0x%08x.",hRes);
	TraceFunctLeave();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void) {

	TraceFunctEnter("DllUnregisterServer");
	_Module.UnregisterServer();
	DebugTrace(0,"Returns S_OK");
	TraceFunctLeave();
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\seotlib\resource.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the Server
	Extension Objects Test Library resources.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	6/9/97	created

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SEOTLIB.rc
//
#define IDS_PROJNAME					100
#define IDR_StdAfx						101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\testsrv\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	TestSrv.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\testsrv\testsrv.cpp ===
// TestSrv.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "TestSrv.h"
#include "TestSrvDlg.h"

#include "initguid.h"
#include "seo.h" // This must be included for seo_i.c to work... (it seems)
#include "..\seo_i.c"
#include "mimeole.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTestSrvApp

BEGIN_MESSAGE_MAP(CTestSrvApp, CWinApp)
	//{{AFX_MSG_MAP(CTestSrvApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTestSrvApp construction

CTestSrvApp::CTestSrvApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CTestSrvApp object

CTestSrvApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CTestSrvApp initialization

BOOL CTestSrvApp::InitInstance()
{
	HRESULT hr = CoInitialize(NULL);
	if(FAILED(hr)) return FALSE;

	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CTestSrvDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

int CTestSrvApp::ExitInstance() 
{
	CoUninitialize();
	
	return CWinApp::ExitInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\testsrv\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\test\seotlib\stdafx.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.cpp

Abstract:

	This module contains the implementation for the base
	ATL methods.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	12/04/96	created

--*/


// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...) {
	LPBYTE pbAdd = NULL;		// Working pointer to the next available "scratch space" in the map.
	DWORD dwCnt = 0;			// The count of entries in the map.
	LPOLESTR pszCLSID = NULL;	// The CLSID as a string.
	LPOLESTR pszTLID = NULL;	// The TLID as a string.

	if (!pparmeResult) {
		// The caller did not give us a place to return the result.
		return (E_POINTER);
	}
	*pparmeResult = NULL;	// For the first time through the loop, the result is NULL.
	// We are going to loop through twice.  The first time through, we haven't allocate the map yet, so
	// we will count all the strings, and add up their lenghts - this will give us the size of the buffer
	// we need to allocate for the map.  Then the second time through the loop, we will store all the
	// strings in the map.
	while (1) {
		if (pclsid) {
			// If we were passed a CLSID, then we want to include that in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to convert the CLSID to a string.
				HRESULT hrRes;

				hrRes = StringFromCLSID(*pclsid,&pszCLSID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the CLSID to a string.
					CoTaskMemFree(*pparmeResult);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the CLSID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"CLSID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszCLSID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the CLSID string and the fact that we have a CLSID in the map.
			pbAdd += (wcslen(pszCLSID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszCLSID);
				pszCLSID = NULL;
			}
		}
		if (pmodule) {
			// If we were passed a module, then we want to include the TLID in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to load the type library, get its
				// TLID, and convert it to a string.
				USES_CONVERSION;
				HRESULT hrRes;
				TCHAR szModule[MAX_PATH];
				LPOLESTR pszModule;
				CComPtr<ITypeLib> pTypeLib;
				TLIBATTR *ptlaAttr;
				if (!GetModuleFileName(pmodule->GetTypeLibInstance(),
									   szModule,
									   sizeof(szModule)/sizeof(TCHAR))) {
					hrRes = HRESULT_FROM_WIN32(GetLastError());
					if (SUCCEEDED(hrRes)) {
						// GetModuleFileName() failed, but GetLastError() didn't report an error - so
						// fake it.
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				if (pszIndex) {
					// If we were passed an index, that means that the type library desired is not the
					// first type library in the resources - so append the index to the module name.
					lstrcat(szModule,OLE2T(pszIndex));
				}
				pszModule = T2OLE(szModule);
				hrRes = LoadTypeLib(pszModule,&pTypeLib);
				if (!SUCCEEDED(hrRes)) {
					// If we couldn't load the type library from the module, let's try changing the
					// module name to a type library name (change the extension to .TLB) and try to load
					// *that*.
					LPTSTR pszExt = NULL;
					LPTSTR psz;

					for (psz=szModule;*psz;psz=CharNext(psz)) {
						if (*psz == _T('.')) {
							pszExt = psz;
						}
					}
					if (!pszExt) {
						pszExt = psz;
					}
					lstrcpy(pszExt,_T(".tlb"));
					pszModule = T2OLE(szModule);
					hrRes = LoadTypeLib(pszModule,&pTypeLib);
				}
				if (!SUCCEEDED(hrRes)) {
					// We failed to load the type library.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = pTypeLib->GetLibAttr(&ptlaAttr);
				if (!SUCCEEDED(hrRes)) {
					// We failed to get the type library attributes.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = StringFromCLSID(ptlaAttr->guid,&pszTLID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the TLID to a string.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the TLID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"LIBID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszTLID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the TLID string and the fact that we have a TLID in the map.
			pbAdd += (wcslen(pszTLID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszTLID);
				pszTLID = NULL;
			}
		}
		{	// Now we need to go through the varargs.  All of the varargs must be LPOLESTR (i.e. they
			// must be UNICODE), and they will consist of pairs - the key name followed by the data.  If
			// either member of the pair is NULL, that signals the end of the varargs.
			va_list valArgs;

			// Set the va_list to the start of the varargs.
			va_start(valArgs,pszIndex);
			while (1) {
				LPCOLESTR pszKey;
				LPCOLESTR pszData;

				// Get the first of the pair - this is the key name.
				pszKey = va_arg(valArgs,LPCOLESTR);
				if (!pszKey) {
					break;
				}
				// Get the second of the pair - this is the data.
				pszData = va_arg(valArgs,LPCOLESTR);
				if (!pszData) {
					break;
				}
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the key name to the
					// map.
					(*pparmeResult)[dwCnt].szKey = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szKey,pszKey);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string.
				pbAdd += (wcslen(pszKey)+1) * sizeof(OLECHAR);
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the data to the map.
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszData);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string and the fact that we have a string in the map.
				pbAdd += (wcslen(pszData)+1) * sizeof(OLECHAR);
				dwCnt++;
			}
			// Reset the va_list, for the sake of cleanliness.
			va_end(valArgs);
		}
		if (*pparmeResult) {
			// If we have allocated the map, that means that we are finishing the second time through
			// the loop - so we are done!
			break;
		}
		if (!*pparmeResult) {
			// If we havemn't allocate the map, that means that we are finishing the first time through
			// the loop - so we need to allocate the map in preparation for the second time through.
			// First we calculate the number of bytes needed for the map - this is one ATL_REGMAP_ENTRY
			// for each entry, plus one _ATL_REGMAP_ENTRY which signals the end of the map, plus enough
			// space for all of the strings to follow.
			DWORD dwBytes = (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY) + (pbAdd-(LPBYTE) NULL);

			*pparmeResult = (_ATL_REGMAP_ENTRY *) CoTaskMemAlloc(dwBytes);
			if (!*pparmeResult) {
				// The memory allocation failed.
				CoTaskMemFree(pszCLSID);
				CoTaskMemFree(pszTLID);
				return (E_OUTOFMEMORY);
			}
			// The memory allocation was successful - fill the memory with zeroes in preparation for
			// loading with the values.
			memset(*pparmeResult,0,dwBytes);
			// Reset the counters to the "beginning" - so that on the second time through, they are used
			// to keep track of where each successive value gets stored in the memory block.
			pbAdd = ((LPBYTE) *pparmeResult) + (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY);
			dwCnt = 0;
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\testsrv\testsrv.h ===
// TestSrv.h : main header file for the TESTSRV application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CTestSrvApp:
// See TestSrv.cpp for the implementation of this class
//

class CTestSrvApp : public CWinApp
{
public:
	CTestSrvApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTestSrvApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CTestSrvApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\browsedi.h ===
//
// BrowseDir.h
//

#ifndef __BROWSEDIR_H__
#define __BROWSEDIR_H__

BOOL BrowseForDirectory(
		HWND hwndParent,
		LPCTSTR pszInitialDir,
		LPTSTR pszBuf,
		int cchBuf,
		LPCTSTR pszDialogTitle,
		BOOL bRemoveTrailingBackslash );

#endif // !__BROWSEDIR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\testsrv\testsrvdlg.cpp ===
// TestSrvDlg.cpp : implementation file
//

#include "stdafx.h"
#include <ole2.h>

#include "TestSrv.h"
#include "TestSrvDlg.h"
#include "seo.h"
//#include "dispatch.h"
#include "sampprnt.h"
#include "mimeole.h"
//#include "..\mimebag.h"
#include "cstream.h"
#include "seoutils.h"
#include "..\SampPrnt\SampPrnt_i.c" // OLE Definitions

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTestSrvDlg dialog

CTestSrvDlg::CTestSrvDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CTestSrvDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTestSrvDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CTestSrvDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTestSrvDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CTestSrvDlg, CDialog)
	//{{AFX_MSG_MAP(CTestSrvDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTestSrvDlg message handlers

BOOL CTestSrvDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	CString strAboutMenu;
	strAboutMenu.LoadString(IDS_ABOUTBOX);
	if (!strAboutMenu.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CTestSrvDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CTestSrvDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CTestSrvDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CTestSrvDlg::OnOK() 
{
	char str[200];
	CComPtr<ISEOMessageFilter> pExtension;
	CComPtr<ISEORegDictionary> pBag1; // Test CSEORegDictionary
	CComPtr<ISEODictionary> pBag2;    // Test CSEOMimeDictionary
	CComPtr<IMimeMessage> pMessage;
	CStreamFile *pStream = NULL;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	HRESULT hr = S_OK;

	hr = CoCreateInstance(CLSID_CSEORegDictionary, NULL, CLSCTX_ALL,
	                      IID_ISEORegDictionary, (LPVOID *) &pBag1);
	if(FAILED(hr)) {
		if(hr == REGDB_E_CLASSNOTREG) {
			OutputDebugString("Class not registered\n");
		} else if(hr == CLASS_E_NOAGGREGATION) {
			OutputDebugString("Cannot be created as part of an aggregate\n");
		} else {
			wsprintf(str, "Result: %lX\n", hr);
			OutputDebugString(str);
		}
	}

	pBag1->Load(L"", (SEO_HKEY) (DWORD) HKEY_LOCAL_MACHINE, L"SOFTWARE\\ODBC", NULL);

	hr = CoCreateInstance(CLSID_CSEOMimeDictionary, NULL, CLSCTX_ALL,
	                      IID_ISEODictionary, (LPVOID *) &pBag2);
	
	if(FAILED(hr)) {
		if(hr == REGDB_E_CLASSNOTREG) {
			OutputDebugString("Class not registered\n");
		} else if(hr == CLASS_E_NOAGGREGATION) {
			OutputDebugString("Cannot be created as part of an aggregate\n");
		} else {
			wsprintf(str, "Result: %lX\n", hr);
			OutputDebugString(str);
		}
	} else {
		HANDLE hFile = CreateFile("c:\\Source\\tests\\mimeole\\1000000.nws",
								  GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
								  NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if(hFile != INVALID_HANDLE_VALUE) {
			pStream = new CStreamFile(hFile);
			hr = pBag2->QueryInterface(IID_IMimeMessageTree, (LPVOID *) &pMessage);
			hr = pMessage->BindToMessage(pStream);
			pMessage.Release();
		}
	}

	// Now, create the Extension object
	hr = CoCreateInstance(CLSID_CSEOSamplePrintExt, NULL, CLSCTX_ALL,
	                      IID_ISEOMessageFilter, (LPVOID *) &pExtension);
	
	if(FAILED(hr)) {
		if(hr == REGDB_E_CLASSNOTREG) {
			OutputDebugString("Class not registered\n");
		} else if(hr == CLASS_E_NOAGGREGATION) {
			OutputDebugString("Cannot be created as part of an aggregate\n");
		} else {
			wsprintf(str, "Result: %lX\n", hr);
			OutputDebugString(str);
		}
	} else {
		if(!!pBag1) hr = pExtension->OnMessage(pBag1);
		if(!!pBag2) hr = pExtension->OnMessage(pBag2);
	}

	// Cleanup:
	delete pStream;
	pStream = 0;
	if(hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	// CDialog::OnOK(); - skip this so dialog won't be dismissed
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\elem.h ===
#ifndef _ELEM_H_
#define _ELEM_H_

class CElem : public CObject
{
public:
    CElem();
    ~CElem();

    HKEY m_hKey;
    int m_index;
    CString m_ip;
    CString m_name;
    CString m_value;

    BOOL OpenReg(LPCTSTR szSubKey);
    void CloseReg();
    BOOL GetNext();
    void ReadRegVRoots(LPCTSTR szSubKey, CMapStringToOb *pMap);
    void Add(CMapStringToOb *pMap);
};

#endif // _ELEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\dllmain.cpp ===
#include "stdafx.h"
#include "k2suite.h"

#include <ole2.h>
#include "helper.h"

#include "setupapi.h"
#include "ocmanage.h"

#include "utils.h"

#include "log.h"
#include "wizpages.h"

#pragma hdrstop

void CreateNNTPGroups(void);
/*
SETUPMODE_UNKNOWN
SETUPMODE_MINIMAL
SETUPMODE_TYPICAL
SETUPMODE_LAPTOP
SETUPMODE_CUSTOM

SETUPMODE_STANDARD_MASK
SETUPMODE_PRIVATE_MASK
*/

#ifndef UNICODE
#error UNICODE not defined
#endif

OCMANAGER_ROUTINES gHelperRoutines;
HINF gMyInfHandle;
HANDLE gMyModuleHandle;
HANDLE g_hUnattended = INVALID_HANDLE_VALUE;

// Logging class
MyLogFile g_MyLogFile;

TCHAR szSysDrive[3] = _T("C:");

TCHAR szComponentNames[MC_MAXMC][24] =
{
    _T("ims"),
    _T("ins")
};

TCHAR szSubcomponentNames[SC_MAXSC][24] =
{
    _T("iis_smtp"),
    _T("iis_nntp"),
    _T("iis_smtp_docs"),
    _T("iis_nntp_docs")
};

TCHAR szDocComponentNames[2][24] =
{
    _T("iis_smtp_docs"),
    _T("iis_nntp_docs")
};

TCHAR szActionTypeNames[AT_MAXAT][24] =
{
    _T("AT_DO_NOTHING"),
    _T("AT_FRESH_INSTALL"),
    _T("AT_REINSTALL"),
    _T("AT_UPGRADE"),
    _T("AT_REMOVE"),
    _T("AT_UPGRADEK2")
};

#define NUM_OC_STATES        (OC_QUERY_IMAGE_EX + 1)
TCHAR szOCMStates[NUM_OC_STATES][40] =
{
    _T("OC_PREINITIALIZE"),
    _T("OC_INIT_COMPONENT"),
    _T("OC_SET_LANGUAGE"),
    _T("OC_QUERY_IMAGE"),
    _T("OC_REQUEST_PAGES"),
    _T("OC_QUERY_CHANGE_SEL_STATE"),
    _T("OC_CALC_DISK_SPACE"),
    _T("OC_QUEUE_FILE_OPS"),
    _T("OC_NOTIFICATION_FROM_QUEUE"),
    _T("OC_QUERY_STEP_COUNT"),
    _T("OC_COMPLETE_INSTALLATION"),
    _T("OC_CLEANUP"),
    _T("OC_QUERY_STATE"),
    _T("OC_NEED_MEDIA"),
    _T("OC_ABOUT_TO_COMMIT_QUEUE"),
    _T("OC_QUERY_SKIP_PAGE"),
	_T("OC_WIZARD_CREATED"),
	_T("OC_FILE_BUSY	"),
	_T("OC_EXTRA_ROUTINES"),
	_T("OC_QUERY_IMAGE_EX"),
};

unsigned MyStepCount;

CInitApp theApp;

DWORD OC_PREINITIALIZE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD OC_INIT_COMPONENT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD OC_SET_LANGUAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD_PTR OC_QUERY_IMAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD OC_REQUEST_PAGES_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD OC_QUERY_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD OC_QUERY_CHANGE_SEL_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD OC_QUERY_SKIP_PAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD OC_CALC_DISK_SPACE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD OC_QUEUE_FILE_OPS_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD OC_NEED_MEDIA_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD OC_NOTIFICATION_FROM_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD OC_QUERY_STEP_COUNT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD OC_ABOUT_TO_COMMIT_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD OC_COMPLETE_INSTALLATION_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD OC_CLEANUP_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2);
DWORD BringALLIISClusterResourcesOffline(void);

BOOL
WINAPI
DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
/*++

Routine Description:

    This routine is called by CRT when _DllMainCRTStartup is the
    DLL entry point.

Arguments:

    Standard Win32 DLL Entry point parameters.

Return Value:

    Standard Win32 DLL Entry point return code.

--*/
{
    BOOL b;

    UNREFERENCED_PARAMETER(Reserved);

    b = TRUE;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        gMyModuleHandle = DllHandle;
        //
        // Fall through to process first thread
        //
        g_MyLogFile.LogFileCreate(_T("imsins.log"));

    case DLL_THREAD_ATTACH:

        b = TRUE;
        break;

    case DLL_PROCESS_DETACH:
        g_MyLogFile.LogFileClose();
        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return(b);
}

DWORD GetComponentFromId(LPCTSTR ComponentId)
{
    DWORD i;

    if (!ComponentId)
        return(MC_NONE);

    for (i = 0; i < (DWORD)MC_MAXMC; i++)
        if (!lstrcmpi(ComponentId, szComponentNames[i]))
            return(i);
    return(MC_NONE);
}

DWORD GetSubcomponentFromId(LPCTSTR SubcomponentId)
{
    DWORD i;

    if (!SubcomponentId)
        return(SC_NONE);

    for (i = 0; i < (DWORD)SC_MAXSC; i++)
        if (!lstrcmpi(SubcomponentId, szSubcomponentNames[i]))
            return(i);
    return(SC_NONE);
}

ACTION_TYPE GetSubcompActionFromCheckboxState(DWORD Id)
{
    DWORD State = 0;
    DWORD OldState = 0;

    ACTION_TYPE at = AT_DO_NOTHING;

    // Get the check box state
    State = gHelperRoutines.QuerySelectionState(
                        gHelperRoutines.OcManagerContext,
                        szSubcomponentNames[Id],
                        OCSELSTATETYPE_CURRENT
                        );
    if (GetLastError() != NO_ERROR)
    {
        DebugOutput(_T("Failed to get current state for <%s> (%u)"),
                        szSubcomponentNames[Id], GetLastError());
        State = 0;
    }

    // Check orignal state
    OldState = gHelperRoutines.QuerySelectionState(
                        gHelperRoutines.OcManagerContext,
                        szSubcomponentNames[Id],
                        OCSELSTATETYPE_ORIGINAL
                        );
    if (GetLastError() != NO_ERROR)
    {
        DebugOutput(_T("Failed to get original state for <%s> (%u)"),
                        szSubcomponentNames[Id], GetLastError());
        OldState = 0;
    }

    if (State && !OldState)
    {
        // Change in state from OFF->ON = install docs
        at = AT_FRESH_INSTALL;

        DebugOutput(_T("Installing subcomponent <%s>"), szSubcomponentNames[Id]);
    }
    else if (!State && OldState)
    {
        // Change in state from ON->OFF = uninstall docs
        at = AT_REMOVE;

        DebugOutput(_T("Removing subcomponent <%s>"), szSubcomponentNames[Id]);
    }
    else if (State && OldState)
    {
        // Change in state from ON->ON : couple of cases here...
        if (theApp.m_eState[Id] == IM_UPGRADE || theApp.m_eState[Id] == IM_UPGRADEK2 || theApp.m_eState[Id] == IM_UPGRADE10 || theApp.m_eState[Id] == IM_UPGRADE20)
        {
            // Upgrade if we were upgrading...
            at = AT_UPGRADE;

            DebugOutput(_T("Upgrading subcomponent <%s>"), szSubcomponentNames[Id]);
        }

        if (GetIMSSetupMode() == IIS_SETUPMODE_REINSTALL || (theApp.m_fNTGuiMode && ((theApp.m_eState[Id] == IM_MAINTENANCE) || (theApp.m_eState[Id] == IM_UPGRADEB2))))
        {
            // Reinstall if doing minor NT5 os upgrade, both from NT5 Beta2, or NT5 Beta3
            at = AT_REINSTALL;

            DebugOutput(_T("Reinstalling subcomponent <%s>"), szSubcomponentNames[Id]);
        }

        if (!theApp.m_fValidSetupString[Id]) {
            at = AT_REINSTALL;
            DebugOutput(_T("Reinstalling subcomponent <%s>"), szSubcomponentNames[Id]);
        }

    }

    return(at);
}


BOOL IsSubcomponentCore(DWORD dwSubcomponentId)
{
    if (dwSubcomponentId == SC_SMTP || dwSubcomponentId == SC_NNTP)
        return TRUE;
    return FALSE;
}

STATUS_TYPE GetSubcompInitStatus(DWORD Id)
{
    STATUS_TYPE nStatus = ST_UNINSTALLED;
    BOOL OriginalState;

    if (Id != SC_NONE)
    {
        OriginalState = gHelperRoutines.QuerySelectionState(
                            gHelperRoutines.OcManagerContext,
                            szSubcomponentNames[Id],
                            OCSELSTATETYPE_ORIGINAL
                            );
        if (OriginalState == 1)
            nStatus = ST_INSTALLED;
        if (OriginalState == 0)
            nStatus = ST_UNINSTALLED;
    }

    return(nStatus);
}

/*

    The subcomponent action is a table-driven value which
    is dependent on 3 things:
    1) the master install mode
    2) the installed state of the subcomponent in question
    3) the state of the subcomponent check box

    We use the following matrix to determine the action.
    Note that an 'x' indicates invalid combinations and
    should have been coerced earlier by
    CInitApp::DetectPreviousINstallations().

    ----------------+-----------------------+-----------------------
    Check box        |            1            |            0
    ----------------+-----------------------+-----------------------
        \ Component    | Fresh    Upgrade Maint.    | Fresh      Upgrade Maint.
    Global            |                        |
    ----------------+-----------------------+-----------------------
    Fresh           | FRESH    x        x        | NOTHING x          x
    Upgrade         | FRESH    UPGRADE    x        | NOTHING NOTHING x
    Maintenance     | FRESH    UPGRADE    NOTHING    | NOTHING NOTHING REMOVE
    ----------------+-----------------------+-----------------------

*/
ACTION_TYPE GetSubcompAction(DWORD Id)
{
    ACTION_TYPE atReturn = AT_DO_NOTHING;
    ACTION_TYPE atSubcomp = GetSubcompActionFromCheckboxState(Id);

    DebugOutput(_T("GetSubcompAction(): %s=%s"), szSubcomponentNames[Id], szActionTypeNames[atSubcomp]);

    //
    //  Let's do it the way I thing we should do and modify it
    //  if errors found.
    //
    return atSubcomp;
}

void CreateAllRequiredDirectories(DWORD Id)
{
    ACTION_TYPE atComp;

    // If SMTP is being installed fresh, we need to create
    // the Queue, Pickup, Drop, and Badmail directories
    if (Id != SC_NNTP)
    {
        atComp = GetSubcompAction(Id);
        if (atComp == AT_FRESH_INSTALL)
        {
            if (Id == SC_SMTP)
            {
                CreateLayerDirectory(theApp.m_csPathMailroot + SZ_SMTP_QUEUEDIR);
                CreateLayerDirectory(theApp.m_csPathMailroot + SZ_SMTP_BADMAILDIR);
                CreateLayerDirectory(theApp.m_csPathMailroot + SZ_SMTP_DROPDIR);
                CreateLayerDirectory(theApp.m_csPathMailroot + SZ_SMTP_PICKUPDIR);
                CreateLayerDirectory(theApp.m_csPathMailroot + SZ_SMTP_SORTTEMPDIR);
            }
            CreateLayerDirectory(theApp.m_csPathMailroot + SZ_SMTP_ROUTINGDIR);
            CreateLayerDirectory(theApp.m_csPathMailroot + SZ_SMTP_MAILBOXDIR);
        }
    }
}

LPTSTR szServiceNames[MC_MAXMC] =
{
    SZ_SMTPSERVICENAME,
    SZ_NNTPSERVICENAME,
};

void StopAllServices()
{
    DWORD i;

    // Note that we only stop services that have not yet been stopped. If
    // a service has already been marked as started, then we know it must
    // have been previously stopped
    if (!theApp.m_fW3Started)
        theApp.m_fW3Started =
            (InetStopService(SZ_WWWSERVICENAME) == NO_ERROR)?TRUE:FALSE;
    if (!theApp.m_fFtpStarted)
        theApp.m_fFtpStarted =
            (InetStopService(SZ_FTPSERVICENAME) == NO_ERROR)?TRUE:FALSE;
    if (!theApp.m_fSpoolerStarted)
        theApp.m_fSpoolerStarted =
            (InetStopService(SZ_SPOOLERSERVICENAME) == NO_ERROR)?TRUE:FALSE;
    if (!theApp.m_fSnmpStarted)
        theApp.m_fSnmpStarted =
            (InetStopService(SZ_SNMPSERVICENAME) == NO_ERROR)?TRUE:FALSE;
    if (!theApp.m_fCIStarted)
        theApp.m_fCIStarted =
            (InetStopService(SZ_CISERVICENAME) == NO_ERROR)?TRUE:FALSE;

    for (i = 0; i < MC_MAXMC; i++)
    {
        if (!theApp.m_fStarted[i])
            theApp.m_fStarted[i] =
                (InetStopService(szServiceNames[i]) == NO_ERROR)?TRUE:FALSE;
    }

    // We are at the top level, we will stop the
    // IISADMIN service ...
    InetStopService(SZ_MD_SERVICENAME);
}

BOOL ShouldSkipSMTPEarlyPages()
{
    // If we have a fresh install, of IMAP, POP3 and/or
    // SMTP, we will activate the input pages, else
    // we skip them
    // The main OCM thread is blocked when the UI thread is up,
    // so we modify theApp.m_dwCompId to what we want
    BOOL fRet = TRUE;
    DWORD dwTempId = theApp.m_dwCompId;

    // If we are doing silent install, we will return TRUE to skip
    if (theApp.m_fIsUnattended)
        return(TRUE);

    theApp.m_dwCompId = MC_IMS;
    if (GetSubcompAction(SC_SMTP) == AT_FRESH_INSTALL)
        fRet = FALSE;

    theApp.m_dwCompId = dwTempId;
    return(fRet);
}


BOOL ShouldSkipNNTPEarlyPages()
{
    // If we have a fresh install, of NNTP
    // we will activate the input pages, else
    // we skip them
    // The main OCM thread is blocked when the UI thread is up,
    // so we modify theApp.m_dwCompId to what we want
    BOOL fRet = TRUE;
    DWORD dwTempId = theApp.m_dwCompId;

    // If we are doing silent install, we will return TRUE to skip
    if (theApp.m_fIsUnattended)
        return(TRUE);

    theApp.m_dwCompId = MC_INS;
    if (GetSubcompAction(SC_NNTP) == AT_FRESH_INSTALL)
        fRet = FALSE;

    theApp.m_dwCompId = dwTempId;
    return(fRet);
}


BOOL GetInetpubPathFromPrivData(CString &csPathInetpub)
{
    TCHAR szPath[_MAX_PATH];
    UINT uType, uSize;
    // If we are not upgrading, we get the info from the private data
    uSize = _MAX_PATH * sizeof(TCHAR);
    if ((gHelperRoutines.GetPrivateData(gHelperRoutines.OcManagerContext,
                                _T("iis"),
                                _T("PathWWWRoot"),
                                (LPVOID)szPath,
                                &uSize,
                                &uType) == NO_ERROR) &&
        (uType == REG_SZ))
    {
        GetParentDir(szPath, csPathInetpub.GetBuffer(512));
        csPathInetpub.ReleaseBuffer();
        return TRUE;
    }
    else
        return FALSE;
}

void SetupMailAndNewsRoot( void )
{
    if (!theApp.m_fMailPathSet)
        theApp.m_csPathMailroot = theApp.m_csPathInetpub + _T("\\mailroot");
    if (!theApp.m_fNntpPathSet)
    {
        theApp.m_csPathNntpFile = theApp.m_csPathInetpub + _T("\\nntpfile");
        theApp.m_csPathNntpRoot = theApp.m_csPathNntpFile + _T("\\root");
    }
}

/* =================================================================

The sequence of OCM Calls are as follows:

OC_PREINITIALIZE
OC_INIT_COMPONENT
OC_SET_LANGUAGE
OC_QUERY_STATE
OC_CALC_DISK_SPACE
OC_REQUEST_PAGES

UI Appears with Welcome, EULA, and mode page

OC_QUERY_STATE
OC_QUERY_SKIP_PAGE

OC Page "Check boxes" appears

OC_QUERY_IMAGE

Detail pages
Wizard pages ...

OC_QUEUE_FILE_OPS
OC_QUERY_STEP_COUNT
OC_ABOUT_TO_COMMIT_QUEUE
OC_NEED_MEDIA (if required)
OC_COMPLETE_INSTALLATION

OC_CLEANUP

*/

// NT5 - Leave the DummyOcEntry there for safeguard
//#ifdef K2INSTALL

DWORD
DummyOcEntry(
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2
    );
//#endif

extern "C"
DWORD_PTR
OcEntry(
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2
    )
{
    DWORD_PTR d = 0;
    DWORD CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    // Set the current top-level component so other functions can access it!
    theApp.m_dwCompId = CompId;

    // Output some debug information ...
    if (Function == OC_PREINITIALIZE || Function == OC_INIT_COMPONENT) {
	    DebugOutput(
            _T("Entering OCEntry; Component = <%s> (%u)"),
            ComponentId?ComponentId:_T(""), CompId);
    } else {
	    DebugOutput(
            _T("Entering OCEntry; Component = <%s> (%u), Subcomponent = <%s> (%u)"),
            ComponentId?ComponentId:_T(""), CompId,
            SubcomponentId?SubcomponentId:_T(""), Id);
    }
    DebugOutput(
            _T("\tFunction = %s (%u), Param1 = %08X (%u), Param2 = %p (%p)"),
            (Function <  NUM_OC_STATES) ? szOCMStates[Function] : _T("unknown state"),
            Function,
            (DWORD)Param1, (DWORD)Param1,
            (DWORD_PTR)Param2, (DWORD_PTR)Param2);

// NT5 - Leave the DummyOcEntry there for safeguard
//#ifdef K2INSTALL
    // HACK for standalone only!!
    // We are forced to handle the IIS section for standalone or we'll face an AV
    if (CompId == MC_NONE)
    {
        // Well, we will ignore all master sections that we do not know about.
        // This includes the IIS Master section
        DebugOutput(_T("Unknown master section, calling DummyOcEntry ..."));
        d = DummyOcEntry(ComponentId,
                            SubcomponentId,
                            Function,
                            Param1,
                            Param2);
        DebugOutput(_T("DummyOcEntry returning %u"), d);
        return(d);
    }
//#endif


    switch(Function)
    {
    case OC_PREINITIALIZE:
        d = OC_PREINITIALIZE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_INIT_COMPONENT:
        d = OC_INIT_COMPONENT_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_SET_LANGUAGE:
        d = OC_SET_LANGUAGE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_IMAGE:
        d = OC_QUERY_IMAGE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_REQUEST_PAGES:
        d = OC_REQUEST_PAGES_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_STATE:
        d = OC_QUERY_STATE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        d = OC_QUERY_CHANGE_SEL_STATE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_SKIP_PAGE:
        d = OC_QUERY_SKIP_PAGE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_CALC_DISK_SPACE:
        d = OC_CALC_DISK_SPACE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUEUE_FILE_OPS:
        d = OC_QUEUE_FILE_OPS_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_NEED_MEDIA:
        d = OC_NEED_MEDIA_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
        d = OC_NOTIFICATION_FROM_QUEUE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_STEP_COUNT:
        d = OC_QUERY_STEP_COUNT_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        d = OC_ABOUT_TO_COMMIT_QUEUE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_COMPLETE_INSTALLATION:
        d = OC_COMPLETE_INSTALLATION_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_CLEANUP:
        d = OC_CLEANUP_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    default:
        d = 0;
        break;
    }

    DebugOutput(_T("Leaving OCEntry.  Return=%d\n"), d);

    return(d);

}



//
// Param1 = char width flags
// Param2 = unused
//
// Return value is a flag indicating to OC Manager
// which char width we want to run in. Run in "native"
// char width.
//
DWORD OC_PREINITIALIZE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d = 0;

#ifdef UNICODE
    d = OCFLAG_UNICODE;
#else
    d = OCFLAG_ANSI;
#endif

    return d;
}


//
// Param1 = unused
// Param2 = points to SETUP_INIT_COMPONENT structure
//
// Return code is Win32 error indicating outcome.
//
DWORD OC_INIT_COMPONENT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d;
    BOOL    b;
    DWORD CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    PSETUP_INIT_COMPONENT InitComponent = (PSETUP_INIT_COMPONENT)Param2;

    theApp.m_hDllHandle = (HINSTANCE)gMyModuleHandle;

    // Check for workstation or server!
    theApp.m_fNTUpgrade_Mode = (InitComponent->SetupData.OperationFlags & SETUPOP_NTUPGRADE) > 0;
    theApp.m_fNTGuiMode = (InitComponent->SetupData.OperationFlags & SETUPOP_STANDALONE) == 0;
    theApp.m_fNtWorkstation = InitComponent->SetupData.ProductType == PRODUCT_WORKSTATION;

    // a superset of m_fNTGuiMode and controlpanel add/remove
    theApp.m_fInvokedByNT = theApp.m_fNTGuiMode;

    // if ran from sysoc.inf then set m_fInvokedByNT (for control panel add/remove)
    TCHAR szCmdLine1[_MAX_PATH];
    _tcscpy(szCmdLine1, GetCommandLine());
    _tcslwr(szCmdLine1);
    if (_tcsstr(szCmdLine1, _T("sysoc.inf"))) {theApp.m_fInvokedByNT = TRUE;}

    // Call this stuff after setting m_fNTGuiMode and m_fNtWorkstation
    // since it maybe used in InitApplication().
    if ( theApp.InitApplication() == FALSE )
    {
        // setup should be terminated.
        d = ERROR_CANCELLED;
        goto OC_INIT_COMPONENT_Func_Exit;
    }

    //
    // The OC Manager passes us some information that we want to save,
    // such as an open handle to our per-component INF. As long as we have
    // a per-component INF, append-open any layout file that is
    // associated with it, in preparation for later inf-based file
    // queuing operations.
    //
    // We save away certain other stuff that gets passed to us now,
    // since OC Manager doesn't guarantee that the SETUP_INIT_COMPONENT
    // will persist beyond processing of this one interface routine.
    //

    if (InitComponent->ComponentInfHandle == INVALID_HANDLE_VALUE) {
        MyMessageBox(NULL, _T("Invalid inf handle."), _T(""), MB_OK | MB_SETFOREGROUND);
        d = ERROR_CANCELLED;
        goto OC_INIT_COMPONENT_Func_Exit;
    }

    theApp.m_hInfHandle[CompId] = InitComponent->ComponentInfHandle;

    theApp.m_csPathSource = InitComponent->SetupData.SourcePath;
    gHelperRoutines = InitComponent->HelperRoutines;

    // See if we are doing an unattended install
    theApp.m_fIsUnattended = (((DWORD)InitComponent->SetupData.OperationFlags) & SETUPOP_BATCH);
    if (theApp.m_fIsUnattended)
    {
        // Save the file handle as well ...
        DebugOutput(_T("Entering unattended install mode"));
        g_hUnattended = gHelperRoutines.GetInfHandle(INFINDEX_UNATTENDED,
                                                     gHelperRoutines.OcManagerContext);
    }

    // We must see if the Exchange IMC is installed. If it is we
    // will disable SMTP so we don't hose IMC. Make sure this check is
    // AFTER the check to see if we are doing unattended setup.
    if (CompId == MC_IMS)
    {
        theApp.m_fSuppressSmtp = DetectExistingSmtpServers();
    }

    // Set up the directory ID for Inetpub
    b = SetupSetDirectoryId(theApp.m_hInfHandle[CompId], 32768, theApp.m_csPathInetpub);

    //  Setup strind id for 34000/34001
    SetupSetStringId_Wrapper( theApp.m_hInfHandle[CompId] );

    d = NO_ERROR;

OC_INIT_COMPONENT_Func_Exit:

    return d;
}



//
// Param1 = low 16 bits specify Win32 LANGID
// Param2 = unused
//
// Return code is a boolean indicating whether we think we
// support the requested language. We remember the language id
// and say we support the language. A more exact check might involve
// looking through our resources via EnumResourcesLnguages() for
// example, or checking our inf to see whether there is a matching
// or closely matching [strings] section. We don't bother with
// any of that here.
//
// Locate the component and remember the language id for later use.
//
DWORD OC_SET_LANGUAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d = TRUE;
    theApp.m_wLanguage = Param1 & 0XFFFF;
    return d;
}


DWORD_PTR OC_QUERY_IMAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD_PTR d = (DWORD)NULL;
    DWORD CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    if (LOWORD(Param1) == SubCompInfoSmallIcon)
    {
        if (Id != SC_NONE)
        {
            switch (Id)
            {
            case SC_SMTP:
                d = (DWORD_PTR)LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_SMTP));
                break;
            case SC_NNTP:
                d = (DWORD_PTR)LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_NNTP));
                break;
            case SC_SMTP_DOCS:
            case SC_NNTP_DOCS:
                d = (DWORD_PTR)LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_DOCS));
                break;

            default:
                break;
            }
        }
        else
        {
            switch (CompId)
            {
            // Load top-level bitmaps for group
            case MC_IMS:
                d = (DWORD_PTR)LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_SMTP));
                break;
            case MC_INS:
                d = (DWORD_PTR)LoadBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(IDB_NNTP));
                break;
            default:
                break;
            }
        }

    }

    return d;
}


DWORD OC_REQUEST_PAGES_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d = 0;
    WizardPagesType PageType;
    PSETUP_REQUEST_PAGES pSetupRequestPages = NULL;
    UINT MaxPages;
    HPROPSHEETPAGE pPage;

    PageType = (WizardPagesType)Param1;

    if ( PageType == WizPagesWelcome ) {

        // NT5 - No Welcome page
        if (theApp.m_fInvokedByNT)
        {
            d = 0;
        }
        else
        {
#if 0
//  No welcome page!!!
           // Set the product name here
            SetProductName();

            pSetupRequestPages = (PSETUP_REQUEST_PAGES)Param2;
            MaxPages = pSetupRequestPages->MaxPages;
            pPage = CreatePage(IDD_PROPPAGE_WELCOME, pWelcomePageDlgProc);
            pSetupRequestPages->MaxPages = 1;
            pSetupRequestPages->Pages[0] = pPage;
            d = 1;
#endif
        }

        goto OC_REQUEST_PAGES_Func_Exit;
    }

    if ( PageType == WizPagesMode ) {
        pSetupRequestPages = (PSETUP_REQUEST_PAGES)Param2;
        MaxPages = pSetupRequestPages->MaxPages;
        pSetupRequestPages->MaxPages = 0;
        switch (theApp.m_eInstallMode)
        {
        case IM_UPGRADE:
            // NT5 - No Welcome page
            if (theApp.m_fInvokedByNT)
            {
                pSetupRequestPages->MaxPages = 0;
            }
            else
            {
#if 0
// no Upgrade page
                pPage = CreatePage(IDD_PROPPAGE_MODE_UPGRADE, pUpgradePageDlgProc);
                pSetupRequestPages->Pages[0] = pPage;
                pSetupRequestPages->MaxPages = 1;
#endif
            }
            break;
        case IM_MAINTENANCE:
            // NT5 - No Welcome page
            if (theApp.m_fInvokedByNT)
            {
                pSetupRequestPages->MaxPages = 0;
            }
            else
            {
#if 0
// no Maintanence page
                pPage = CreatePage(IDD_PROPPAGE_MODE_MAINTANENCE, pMaintanencePageDlgProc);
                pSetupRequestPages->Pages[0] = pPage;
                pSetupRequestPages->MaxPages = 1;
#endif
            }
            break;
        case IM_FRESH:
            // NT5 - No Welcome page
            if (theApp.m_fInvokedByNT)
            {
                pSetupRequestPages->MaxPages = 0;
            }
            else
            {
#if 0
// no EULA page
                pPage = CreatePage(IDD_PROPPAGE_EULA, pEULAPageDlgProc);
                pSetupRequestPages->Pages[0] = pPage;
                pPage = CreatePage(IDD_PROPPAGE_MODE_FRESH, pFreshPageDlgProc);
                pSetupRequestPages->Pages[1] = pPage;
                pSetupRequestPages->MaxPages = 2;
#endif
            }
            break;
        default:
            pSetupRequestPages->MaxPages = 0;
        }

        d = pSetupRequestPages->MaxPages;
        goto OC_REQUEST_PAGES_Func_Exit;
    }

    if (!theApp.m_fWizpagesCreated && (PageType == WizPagesEarly))
    {
        // Get the pages, if we don't want it, we'll skip it later
        pSetupRequestPages = (PSETUP_REQUEST_PAGES)Param2;

        if (theApp.m_fInvokedByNT)
        {
            pSetupRequestPages->MaxPages = 0;
            d = 0;
            goto OC_REQUEST_PAGES_Func_Exit;
        }

        // Create each page and fill in the buffer of pages.
        // pPage = CreatePage(IDD_PROPPAGE_DEFAULT_DOMAIN, pDefaultDomainPageDlgProc);
        // pSetupRequestPages->Pages[0] = pPage;
        d = 0;

#if 0
//  not event Mailroot/nntpfile page
        pPage = CreatePage(IDD_PROPPAGE_MAILROOT_DIR, pMailrootPageDlgProc);
        pSetupRequestPages->Pages[d++] = pPage;
        if (pSetupRequestPages->MaxPages < d)
            goto OC_REQUEST_PAGES_Func_Exit;

        pPage = CreatePage(IDD_PROPPAGE_NNTPFILE_DIR, pNntpFilePageDlgProc);
        pSetupRequestPages->Pages[d++] = pPage;
        if (pSetupRequestPages->MaxPages < d)
            goto OC_REQUEST_PAGES_Func_Exit;
#endif

        // Once we returned the Wizard pages, we will not return for
        // subsequent calls
        theApp.m_fWizpagesCreated = TRUE;
        goto OC_REQUEST_PAGES_Func_Exit;
    }

    if ( PageType == WizPagesFinal ) {
        // Get the pages, if we don't want it, we'll skip it later
        pSetupRequestPages = (PSETUP_REQUEST_PAGES)Param2;
        MaxPages = pSetupRequestPages->MaxPages;
        pSetupRequestPages->MaxPages = 0;

        // NT5 - No Final page
        if (theApp.m_fInvokedByNT)
        {
            pSetupRequestPages->MaxPages = 0;
        }
        else
        {
#if 0
// no FINAL page
            pSetupRequestPages = (PSETUP_REQUEST_PAGES)Param2;
            MaxPages = pSetupRequestPages->MaxPages;
            pPage = CreatePage(IDD_PROPPAGE_END, pEndPageDlgProc);
            pSetupRequestPages->MaxPages = 1;
            pSetupRequestPages->Pages[0] = pPage;
#endif
        }
        d = pSetupRequestPages->MaxPages;
        goto OC_REQUEST_PAGES_Func_Exit;
    }

    d = 0;

OC_REQUEST_PAGES_Func_Exit:

    return d;
}



DWORD OC_QUERY_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d = SubcompUseOcManagerDefault;
    DWORD   CompId, Id;
    ACTION_TYPE atComp;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    if (Id != SC_NONE)
    {
        // Merge all subcomponents here including iis_nntp_docs, iis_smtp_docs!
        // We track core components such as iis_nntp and iis_smtp here.
        // We track whether a component is active here: if it is queried of
        // its initial state, we assume that it's active
        theApp.m_fActive[CompId][Id] = TRUE;

        switch (Param1) {
            case OCSELSTATETYPE_ORIGINAL:
                switch (GetIMSSetupMode()) {
                    case IIS_SETUPMODE_UPGRADEONLY:
                        atComp = GetSubcompAction(Id);

                        if (atComp == AT_UPGRADE || atComp == AT_REINSTALL)
                        {
                            //  3/30/99 - Both cases have original state turn ON!
                            //  IM_REMOVE?
                            d = SubcompOn;
                        }
                        else
                        {
                            d = SubcompUseOcManagerDefault;
                        }

                        break;

                    default:
                        d = SubcompUseOcManagerDefault;
                        break;
                }

                DebugOutput(_T("Original state is: %s"),
                            (d == SubcompUseOcManagerDefault)?_T("DEFAULT"):
                                (d == SubcompOn)?_T("ON"):_T("OFF"));
                break;

            case OCSELSTATETYPE_CURRENT:

                // If we are doing unattended setup, we will override all
                // other modes ...
                if (theApp.m_fIsUnattended)
                {
                    d = GetUnattendedModeFromSetupMode(g_hUnattended, CompId, SubcomponentId);

                    // We force SMTP to be off if we are suppressing it
                    // Bug 130734: Leave SMTP installed on the box if IMC is there
                    if (theApp.m_fSuppressSmtp &&
                            (Id == SC_SMTP || Id == SC_SMTP_DOCS) &&
                            (GetIMSSetupMode() == IIS_SETUPMODE_CUSTOM))
                    {
                            //d = SubcompOff;
                            //DebugOutput(_T("Suppressed SMTP %s"), (Id == SC_SMTP_DOCS)?_T("Docs"):_T(""));
                    }
                    break;
                }

                switch (GetIMSSetupMode()) {
                    case IIS_SETUPMODE_REMOVEALL:
                        d = SubcompOff;
                        break;

                    case IIS_SETUPMODE_MINIMUM:
                    case IIS_SETUPMODE_TYPICAL:
                    case IIS_SETUPMODE_CUSTOM:
                        // Here's a new catch: if we are installing SMTP and
                        // we are asked to suppress it because of existence of
	                    // Bug 130734: Leave SMTP installed on the box if IMC is there                        // other mail servers, we will return off.
#if 0
                        if (theApp.m_fSuppressSmtp && (Id == SC_SMTP || Id == SC_SMTP_DOCS))
                            d = SubcompOff;
                        else
                            d = SubcompUseOcManagerDefault;
#endif
                        theApp.m_eState[Id] = IM_FRESH;
                        break;

                    
                    case IIS_SETUPMODE_UPGRADEONLY:
// NT5 - Same here, for upgradeonly, we compare against our orignal state
// If it's ON, it's ON, if it's OFF, it's OFF
/*
#ifndef    K2INSTALL
                        d = SubcompOn;
                        break;
#endif
*/
                    case IIS_SETUPMODE_ADDEXTRACOMPS:
                    case IIS_SETUPMODE_ADDREMOVE:
                    case IIS_SETUPMODE_REINSTALL:
                        d = gHelperRoutines.QuerySelectionState(
                                 gHelperRoutines.OcManagerContext,
                                 SubcomponentId,
                                 OCSELSTATETYPE_ORIGINAL) ? SubcompOn : SubcompOff;
                        break;

                    default:
                        _ASSERT(FALSE);
                        break;
                }

                DebugOutput(_T("Current state is: %s"),
                            (d == SubcompUseOcManagerDefault)?_T("DEFAULT"):
                                (d == SubcompOn)?_T("ON"):_T("OFF"));
                break;
            default:
                break;
        }
    }

    return d;
}


// Called by OCMANAGE when a selection state is changed
// Param1 - Proposed new selection state 0=unselected, non-0=selected
// return value: 0 rejected, non-0 accepted
DWORD OC_QUERY_CHANGE_SEL_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d = 1;
    DWORD CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    if (Id != SC_NONE)
    {
        BOOL OriginalState;
        OriginalState = gHelperRoutines.QuerySelectionState(
                            gHelperRoutines.OcManagerContext,
                            SubcomponentId,
                            OCSELSTATETYPE_ORIGINAL
                            );
        if (OriginalState == 1)
        {
            if ((BOOL)Param1)
                d = 1;
            else
            {
                // In upgrade case, we don't allow user to uncheck previously
                // installed components
                if ((GetIMSSetupMode() == IIS_SETUPMODE_ADDEXTRACOMPS) ||
                    (theApp.m_eState[Id] == IM_UPGRADE || theApp.m_eState[Id] == IM_UPGRADE10 || theApp.m_eState[Id] == IM_UPGRADEK2 || theApp.m_eState[Id] == IM_UPGRADE20))
                    d = 0;
            }
        }
            
        // If we have a subcomponent and it is a subcomponent,
        // mark its state ...
        if ((d == 1) && ((DWORD_PTR)Param2 & OCQ_ACTUAL_SELECTION))
            theApp.m_fSelected[Id] = (Param1)?TRUE:FALSE;
    }

    DebugOutput(_T("New state is: %s"),d?_T("Accepted"):_T("Rejected"));

    return d;
}


//
// gets called right before we show your page!
//
DWORD OC_QUERY_SKIP_PAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d = 0;

    WizardPagesType PageType = (WizardPagesType)Param1;
    
    theApp.m_dwSetupMode = GetIMSSetupMode();
    switch (theApp.m_dwSetupMode) {
        case IIS_SETUPMODE_UPGRADEONLY:
        case IIS_SETUPMODE_REMOVEALL:
        case IIS_SETUPMODE_MINIMUM:
        case IIS_SETUPMODE_TYPICAL:
        case IIS_SETUPMODE_REINSTALL:
            d = 1;
            break;

        case IIS_SETUPMODE_ADDREMOVE:
        case IIS_SETUPMODE_CUSTOM:

            // We have to handle Unattended setup here:
            // If unattended, we will skip all wizard pages
            if (theApp.m_fIsUnattended)
            {
                d = 1;
                break;
            }
            // Else fall thru ...

        case IIS_SETUPMODE_ADDEXTRACOMPS:
            break;
    }

    return d;
}


//
// Param1 = 0 if for removing component or non-0 if for adding component
// Param2 = HDSKSPC to operate on
//
// Return value is Win32 error code indicating outcome.
//
// In our case the private section for this component/subcomponent pair
// is a simple standard inf install section, so we can use the high-level
// disk space list api to do what we want.

// HACK: we need to determine which components are active and which
// are not. This determination must occur after OC_QUERY_STATE and
// before OC_REQUEST_PAGES
DWORD OC_CALC_DISK_SPACE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d = NO_ERROR;
    DWORD   CompId, Id;
    BOOL    b;
    TCHAR   SectionName[128];
    DWORD   dwErr;


    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);
    
    theApp.m_eInstallMode = theApp.DetermineInstallMode(CompId);

    // Logic is not correct here !!!
    //
    
    if (SubcomponentId) {
        b = TRUE;
        _stprintf(SectionName,TEXT("%s_%s"),SubcomponentId, _T("install"));

        if (Param1 != 0) { // add component
            b = SetupAddInstallSectionToDiskSpaceList(
                Param2,
                theApp.m_hInfHandle[CompId],
                NULL,
                SectionName,
                0,0
                );
        } else { // removing component
            b = SetupRemoveInstallSectionFromDiskSpaceList(
                Param2,
                theApp.m_hInfHandle[CompId],
                NULL,
                SectionName,
                0,0
                );
        }

        if (!b)
        {
            dwErr = GetLastError();
        }

        d = b ? NO_ERROR : GetLastError();
    }

    return d;
}


//
// Param1 = unused
// Param2 = HSPFILEQ to operate on
//
// Return value is Win32 error code indicating outcome.
//
// OC Manager calls this routine when it is ready for files to be copied
// to effect the changes the user requested. The component DLL must figure out
// whether it is being installed or uninstalled and take appropriate action.
// For this sample, we look in the private data section for this component/
// subcomponent pair, and get the name of an uninstall section for the
// uninstall case.
//
// Note that OC Manager calls us once for the *entire* component
// and then once per subcomponent. We ignore the first call.
//
DWORD OC_QUEUE_FILE_OPS_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d = NO_ERROR;
    BOOL    b;
    TCHAR   SectionName[128];
    DWORD   CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    //  Setup 34000/34001 string id
    SetupSetStringId_Wrapper( theApp.m_hInfHandle[CompId] );

    if (!SubcomponentId)
    {
        // We will setup the proper public directory from IIS private data
        if (! GetInetpubPathFromPrivData(theApp.m_csPathInetpub))
        {
            // Fail to get private data from wwwroot to get inetpub path
            // Try to get it from metabase
            GetInetpubPathFromMD( theApp.m_csPathInetpub );
        }
        SetupSetDirectoryId(theApp.m_hInfHandle[CompId], 32768, theApp.m_csPathInetpub);

        // For unattended setup, we need to change the NntpFile, NntpRoot, and MailRoot
        // based on m_csPathInetpub
        // NT5 - Not just for unattended, we want to set these path no matter what
        SetupMailAndNewsRoot();

        // We will remove all shared files if we are doing a K2 uninstall
        if (GetIMSSetupMode() == IIS_SETUPMODE_REMOVEALL)
        {
            _stprintf(SectionName,TEXT("iis_%s_uninstall"),ComponentId);
            DebugOutput(_T("Queueing <%s>"), SectionName);

            // Remove all shared files
            b = SetupInstallFilesFromInfSection(
                     theApp.m_hInfHandle[CompId],
                     NULL,
                     Param2,
                     SectionName,
                     //theApp.m_csPathSource,     // BUGBUGBUG: Should be NULL!!!
                     NULL,
                     SP_COPY_IN_USE_NEEDS_REBOOT
                     );

            d = b ? NO_ERROR : GetLastError();
        }
    }
    else
    {
        ACTION_TYPE atComp;

        if (Id != SC_NONE)
        {
            // We have a known subcomponent, so process it as such
            // Can be iis_nntp, iis_smtp, iis_nntp_docs, iis_smtp_docs...
            atComp = GetSubcompAction(Id);
            if (atComp == AT_FRESH_INSTALL || atComp == AT_UPGRADE || atComp == AT_REMOVE || atComp == AT_REINSTALL)
                b = TRUE;
            else
                goto OC_QUEUE_FILE_OPS_Func_Exit;
        }
        else
        {
            // If this is not a real subcomponent, nor is it documentation, we
            // break out of the loop. Otherwise we will queue the documentation
            // files
            goto OC_QUEUE_FILE_OPS_Func_Exit;
        }

        _stprintf(SectionName,TEXT("%s_%s"),SubcomponentId, (atComp == AT_REMOVE) ? _T("uninstall") : _T("install"));
        DebugOutput(_T("Queueing <%s>"), SectionName);

        UINT uiCopyMode = SP_COPY_IN_USE_NEEDS_REBOOT;

        //  Handles NT5 Beta2-> Beta3 upgrade as well as upgrade between builds in Beta3
        //  If it's not these cases, we do FORCE_NEWER.  Otherwise, we just copy over the new bits.
        //  11/28/98 - FORCE_NEWER seems to be causing more trouble in K2 upgrade as well
        //  since we have 5.5.1774 verion in K2 while 5.0.19xx in NT5.  Take it out!
        //if (atComp != AT_REINSTALL || theApp.m_eState[Id] != IM_UPGRADEB2)
        //    uiCopyMode |= SP_COPY_FORCE_NEWER;

        b = SetupInstallFilesFromInfSection(
                 theApp.m_hInfHandle[CompId],
                 NULL,
                 Param2,
                 SectionName,
                 //theApp.m_csPathSource,     // BUGBUGBUG: should be NULL
                 NULL,
                 uiCopyMode
                 );

        d = b ? NO_ERROR : GetLastError();

        if (atComp != AT_FRESH_INSTALL && atComp != AT_DO_NOTHING) {
        	//
        	// See if we can open the directory.  If we can't, then we
        	// don't bother to delete the files
        	//

        	HANDLE h = CreateFile(
                (LPCTSTR)theApp.m_csPathInetpub,
                GENERIC_WRITE,
                FILE_SHARE_DELETE,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS,
                NULL);

            if (h != INVALID_HANDLE_VALUE) {

            	DebugOutput(_T("Removing webadmin"));

            	b = SetupInstallFilesFromInfSection(
                 	theApp.m_hInfHandle[CompId],
                 	NULL,
                 	Param2,
                 	TEXT("remove_webadmin"),
                 	NULL,
                 	uiCopyMode
                 	);

            	d = b ? NO_ERROR : GetLastError();
            	
            	CloseHandle(h);
            } else {
            	DebugOutput(_T("Not removing webadmin, GLE %d"), GetLastError);
            }
        }

        // Handle the MCIS 1.0 upgrade case for mail and news where
        // we delete the old files left over from MCIS 1.0
        if (IsSubcomponentCore(Id))
        {
            if (theApp.m_eState[Id] == IM_UPGRADE10)
            {
                // Establish the section name and queue files for removal
                _stprintf(SectionName,
                            TEXT("%s_mcis10_product_upgrade"),
                            SubcomponentId);
                DebugOutput(_T("Queueing <%s>"), SectionName);
                b = SetupInstallFilesFromInfSection(
                    theApp.m_hInfHandle[CompId],
                    NULL,
                    Param2,
                    SectionName,
                    //theApp.m_csPathSource,      // BUGBUGBUG: should be NULL
                    NULL,
                    0
                    );
            }
        }

    }

OC_QUEUE_FILE_OPS_Func_Exit:

    return d;
}


DWORD OC_NEED_MEDIA_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d = 0;
    return d;
}


DWORD OC_NOTIFICATION_FROM_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d = 0;
    return d;
}


//
// Param1 = unused
// Param2 = unused
//
// Return value is an arbitrary 'step' count or -1 if error.
//
// OC Manager calls this routine when it wants to find out how much
// work the component wants to perform for nonfile operations to
// install/uninstall a component/subcomponent.
// It is called once for the *entire* component and then once for
// each subcomponent in the component.
//
// One could get arbitrarily fancy here but we simply return 1 step
// per subcomponent. We ignore the "entire component" case.
//
DWORD OC_QUERY_STEP_COUNT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d = 2;

    return d;
}


DWORD OC_ABOUT_TO_COMMIT_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d = NO_ERROR;
    TCHAR   SectionName[128];
    DWORD   CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    //  Setup 34000/34001 string id
    SetupSetStringId_Wrapper( theApp.m_hInfHandle[CompId] );

    SetCurrentDirectory(theApp.m_csPathInetsrv);
    if (Id == SC_NONE)
    {
        if (!theApp.m_fNTGuiMode)
        {
#if 0
            // BUGBUG: don't stop any services???
            // Only if we are not running GUI mode setup!!!
            // Don't want to do that since Spooler may be needed by other
            // components during setup!!!
            // We want to stop all services
            StopAllServices();
#endif
            if (GetSubcompAction(Id) != AT_DO_NOTHING) {
                BringALLIISClusterResourcesOffline();
                StopServiceAndDependencies(SZ_MD_SERVICENAME, TRUE);
            }
        }
    }
    else if (IsSubcomponentCore(Id))
    {
        // for SC_NNTP & SC_SMTP...
        ACTION_TYPE atComp = GetSubcompAction(Id);
        if (atComp == AT_REMOVE)
        {
            // For each component that we are removing, we will
            // unregister the service.
            switch (Id)
            {
            case SC_SMTP:
                Unregister_iis_smtp();
                RemoveServiceFromDispatchList(SZ_SMTPSERVICENAME);
                break;
            case SC_NNTP:
                Unregister_iis_nntp();
                RemoveServiceFromDispatchList(SZ_NNTPSERVICENAME);
                break;
            }

            _stprintf(SectionName,TEXT("%s_%s"),SubcomponentId, _T("uninstall"));
            SetupInstallFromInfSection(
                        NULL, theApp.m_hInfHandle[CompId], SectionName,
                        SPINST_REGISTRY, NULL, NULL, //theApp.m_csPathSource,
                        0, NULL, NULL, NULL, NULL );
        }
        else if (atComp == AT_FRESH_INSTALL || atComp == AT_UPGRADE || atComp == AT_REINSTALL)
        {
            // NT5 - We need to unregister mnntpsnp.dll
            // when upgrading from NT4 MCIS20 to NT5 Server

            // in the K2 to MCIS upgrade for NNTP we need to unregister
            // the K2 version of the admin and plug in the MCIS version
            // of it.
            if (Id == SC_NNTP && theApp.m_eState[Id] == IM_UPGRADE20) {
                CString csOcxFile;

                csOcxFile = theApp.m_csPathInetsrv + _T("\\mnntpsnp.dll");
                RegisterOLEControl(csOcxFile, FALSE);
            }

            // If upgrade from MCIS2.0, we need to remove "Use Express" from registry
            // to disable Active Messaging.
            if (Id == SC_SMTP && theApp.m_eState[Id] == IM_UPGRADE20)
            {
                CRegKey regActiveMsg( REG_ACTIVEMSG, HKEY_LOCAL_MACHINE );
                if ((HKEY) regActiveMsg )
                {
                    regActiveMsg.DeleteValue( _T("Use Express"));
                }
            }

            // A new component should be started
            theApp.m_fStarted[CompId] = TRUE;
        }
    }

    gHelperRoutines.TickGauge(gHelperRoutines.OcManagerContext);

    return d;
}


DWORD OC_COMPLETE_INSTALLATION_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d = NO_ERROR;
    TCHAR   SectionName[128];
    BOOL    b;
    DWORD   CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    //  Setup 34000/34001 string id
    SetupSetStringId_Wrapper( theApp.m_hInfHandle[CompId] );

    SetCurrentDirectory(theApp.m_csPathInetsrv);
    if (Id != SC_NONE)
    {
        ACTION_TYPE atComp = GetSubcompAction(Id);
        // Here we determine if we need to create or remove the doc links
        if (!IsSubcomponentCore(Id))
        {
            // iis_nntp_docs or iis_smtp_docs...
            // We are processing docs, see if we are adding or removing
            if (atComp == AT_FRESH_INSTALL || atComp == AT_UPGRADE)
            {
                //
                //  For both FRESH_INSTALL and AT_UPGRADE, we need to
                //  create the new link.
                //
#if 0
//  NT5 - don't want any more then one and only links - webadmin - under
//  administrative tools.  So get rid of these links!!!
//
//  Note:  Add any DOCS specific install options here, such as linking tegoether
//  with NT5 master help docs, if necessary!!!


                // NT5 - BUGBUG: We replace the m_fIsMcis flag to use the m_eNTOSType flag to decide
                // how to create internet shortcut.  This will give us a look and feel of MCIS 2.0
                // when running NT5 Server setup.  But that's what we have now.
                // TODO:  Need to figure out how the NT5 server internet shortcut looks like.
                //
                // NOTE: For SMTP, we do the same for NT5 Server and Workstation
                if (CompId == MC_IMS)
                    CreateInternetShortcut(CompId,
                                    IDS_PROGITEM_MAIL_DOCS,
                                    IDS_ITEMPATH_MAIL_DOCS,
                                    FALSE);  // NT5 - For SMTP, this is always FALSE for Wks & Srv
                else if (CompId == MC_INS)
                {
                    if (theApp.m_eNTOSType == OT_NTW)
                    {
                        CreateInternetShortcut(CompId,
                                    IDS_PROGITEM_NEWS_DOCS,
                                    IDS_ITEMPATH_NEWS_DOCS,
                                    FALSE);
                    }
                    else
                    {
                        //
                        //  We don't create the MCIS shortcut even in NTS
                        //  Use the old K2 way
                        CreateInternetShortcut(CompId,
                                    IDS_PROGITEM_NEWS_DOCS,
                                    IDS_ITEMPATH_NEWS_DOCS,
                                    FALSE);
                    }
                }
#endif
            }
            
            if (atComp == AT_REMOVE || atComp == AT_UPGRADE)
            {
                //
                //  For both AT_REMOVE, or AT_UPGRADE, including K2, MCIS10, or MCIS20
                //  we need to remove these old links.
                //
                if (CompId == MC_IMS)
                {
                    RemoveInternetShortcut(CompId,
                                    IDS_PROGITEM_MAIL_DOCS,
                                    FALSE);  // NT5 - For SMTP, this is always FALSE for Wks & Srv
                    //  11/30/98 - Don't care what are we upgrading from, just get rid of the link
                    //if (theApp.m_eNTOSType == OT_NTS)
                    {
                        RemoveInternetShortcut(CompId,
                                    IDS_PROGITEM_MCIS_MAIL_DOCS,
                                    TRUE);
                    }
                }
                else if (CompId == MC_INS)
                {
                    // remove K2 DOC link anyway regardless of MCIS/K2 remove-all
                    RemoveInternetShortcut(CompId,
                                    IDS_PROGITEM_NEWS_DOCS,
                                    FALSE);
                    //  11/30/98 - Don't care what are we upgrading from, just get rid of the link
                    //if (theApp.m_eNTOSType == OT_NTS)
                    {
                        RemoveInternetShortcut(CompId,
                                    IDS_PROGITEM_MCIS_NEWS_DOCS,
                                    TRUE);
                    }
                }

                //
                //  Todo: remove any possible DOC's links created by Setup
                //  during fresh install.
                //
            }
        }
        else // if (!IsSubcomponentCore(Id))
        {
            //  Core components iis_nntp or iis_smtp
            if (atComp == AT_FRESH_INSTALL || atComp == AT_UPGRADE || atComp == AT_REINSTALL)
            {
                b = (atComp == AT_UPGRADE) ? TRUE : FALSE;
                BOOL bReinstall = (atComp == AT_REINSTALL);
                if (atComp == AT_FRESH_INSTALL || theApp.m_eState[Id] == IM_UPGRADE10)
                {
                    // do this only if we are fresh-install, or upgrade from MCIS 1.0
                    // add any freshly installed or upgrading services to
                    // the dispatch list
                    AddServiceToDispatchList(szServiceNames[Id]);
                }

                // Next, we want to create all the required directories
                // for fresh setup
                CreateAllRequiredDirectories(Id);

                // Now, we realized that by stopping and restarting the IISADMIN
                // service we can rid ourselves of a lot of Metabase problems,
                // especially the 80070094 (ERROR_PATH_BUSY) problems

                if (!theApp.m_fNTGuiMode)
                {
                    // BUGBUG: don't stop any services???
                    // We should stop all services only if we are not running GUI Mode setup
                    // Don't want to do that since Spooler may be needed by other
                    // components during setup!!!

#if 0
                    StopAllServices();      // BUGBUGBUG: stop services needed???
#endif
                    BringALLIISClusterResourcesOffline();
                    StopServiceAndDependencies(SZ_MD_SERVICENAME, TRUE);
                    InetStartService(SZ_MD_SERVICENAME);
                    Sleep(2000);
                }

                //  Need to decide which functions to call here:
                //  1) Fresh install, or upgrade from MCIS 1.0 - Register_iis_xxxx_nt5
                //  2) Upgrade from NT4 K2, MCIS 2.0 - Register_iis_xxxx_nt5_fromk2( fFromK2 )
                //  3) Upgrade from NT5 Beta2, or Beta3 - Upgrade_iis_xxxx_nt5_fromb2( fBeta2 )
                if (atComp == AT_UPGRADE && (theApp.m_eState[Id] == IM_UPGRADEK2 || theApp.m_eState[Id] == IM_UPGRADE20))
                {
                    //  2) Upgrade from NT4 K2, MCIS 2.0 - Register_iis_xxxx_nt5_fromk2( fFromK2 )
                    BOOL    fFromK2 = (theApp.m_eState[Id] == IM_UPGRADEK2) ? TRUE : FALSE;
                    switch (Id)
                    {
                    case SC_SMTP:
                        Upgrade_iis_smtp_nt5_fromk2( fFromK2 );
                        break;
                    case SC_NNTP:
                        GetNntpFilePathFromMD(theApp.m_csPathNntpFile, theApp.m_csPathNntpRoot);
                        Upgrade_iis_nntp_nt5_fromk2( fFromK2 );
                        break;
                    }
                }
                else if (atComp == AT_REINSTALL && (theApp.m_eState[Id] == IM_UPGRADEB2 || theApp.m_eState[Id] == IM_MAINTENANCE || !theApp.m_fValidSetupString[Id]))
                {
                    //  3) Upgrade from NT5 Beta2, or Beta3 - Upgrade_iis_xxxx_nt5_fromb2( fBeta2 )
                    BOOL    fFromB2 = (theApp.m_eState[Id] == IM_UPGRADEB2) ? TRUE : FALSE;
                    switch (Id)
                    {
                    case SC_SMTP:
                        Upgrade_iis_smtp_nt5_fromb2( fFromB2 );
                        break;
                    case SC_NNTP:
                        Upgrade_iis_nntp_nt5_fromb2( fFromB2 );
                        break;
                    }
                }
                else
                {
                    //  1) Fresh install, or upgrade from MCIS 1.0 - Register_iis_xxxx_nt5
                    switch (Id)
                    {
                    case SC_SMTP:
                        Register_iis_smtp_nt5(b, bReinstall);
                        break;
                    case SC_NNTP:
                        Register_iis_nntp_nt5(b, bReinstall);
                        break;
                    }
                }

                // Update the registry
                _stprintf(SectionName,TEXT("%s_%s"),SubcomponentId, _T("install"));
                SetupInstallFromInfSection(
                            NULL, theApp.m_hInfHandle[CompId], SectionName,
                            SPINST_REGISTRY, NULL, NULL, //theApp.m_csPathSource,
                            0, NULL, NULL, NULL, NULL );


                // BINLIN: For MCIS 1.0 to NT5 upgrade
                // Perform AddReg/DelReg operation for this upgrade only.
                if (theApp.m_eState[Id] == IM_UPGRADE10)
                {
                    // Establish the section name and queue files for removal
                    _stprintf(SectionName,
                                TEXT("%s_mcis10_product_upgrade"),
                                SubcomponentId);
                    SetupInstallFromInfSection(
                                NULL,
                                theApp.m_hInfHandle[CompId],
                                SectionName,
                                SPINST_REGISTRY,
                                NULL,
                                //theApp.m_csPathSource,
                                NULL,
                                0, NULL, NULL, NULL, NULL );

                    // also remove the control panel add/remove items..
                    // ..and program groups
                    if (Id == SC_SMTP)
                    {
                        RemoveUninstallEntries(SZ_MCIS10_MAIL_UNINST);
                        RemoveMCIS10MailProgramGroup();
                    }
                    else
                    {
                        RemoveUninstallEntries(SZ_MCIS10_NEWS_UNINST);
                        RemoveMCIS10NewsProgramGroup();
                    }
                }
            }
            else if (atComp == AT_REMOVE)
            {
                // A removed component should not be re-started
                theApp.m_fStarted[CompId] = FALSE;
            }

            //
            // start the service if its appropriate
            //
            if (theApp.m_fStarted[CompId]) {
                InetStartService(szServiceNames[CompId]);
                if (Id == SC_NNTP && atComp == AT_FRESH_INSTALL) {
                    // if this is a fresh install than we need to make
                    // the nntp groups
                    CreateNNTPGroups();

                }
            }
        } // if (!IsSubcomponentCore(Id))
    } // if (Id != SC_NONE)

    gHelperRoutines.TickGauge(gHelperRoutines.OcManagerContext);

    return d;
}


DWORD OC_CLEANUP_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT Param1,IN OUT PVOID Param2)
{
    DWORD   d = 0;
    DWORD   CompId, Id;

    CompId = GetComponentFromId(ComponentId);
    Id = GetSubcomponentFromId(SubcomponentId);

    //if (!SubcomponentId)
    {

        if (!theApp.m_fNTGuiMode)
        {

#if 0
            // Only do this during GUI mode setup!!!
            // Start the services which we stopped to make this
            // install happen
            if (theApp.m_fW3Started)
                InetStartService(SZ_WWWSERVICENAME);

            if (theApp.m_fFtpStarted)
                InetStartService(SZ_FTPSERVICENAME);
    
            if (theApp.m_fSpoolerStarted)
                InetStartService(SZ_SPOOLERSERVICENAME);

            if (theApp.m_fSnmpStarted)
                InetStartService(SZ_SNMPSERVICENAME);

            if (theApp.m_fCIStarted)
                InetStartService(SZ_CISERVICENAME);
#endif
            ServicesRestartList_RestartServices();

        }

    }

    return d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\elem.cpp ===
#include "stdafx.h"

#include "elem.h"

CElem::CElem()
{
    m_hKey = NULL;
    m_index = 0;
    m_ip = _T("");
    m_name = _T("");
    m_value = _T("");
}

CElem::~CElem()
{
    if (m_hKey) 
        RegCloseKey(m_hKey);
}

BOOL CElem::OpenReg(LPCTSTR szSubKey)
{
    BOOL fReturn = FALSE;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_READ, &m_hKey) == ERROR_SUCCESS)
        fReturn = TRUE;
    else
        m_hKey = NULL;

    return (fReturn);
}

void CElem::CloseReg()
{
    if (m_hKey) {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
}

BOOL CElem::GetNext()
{
    BOOL fReturn = FALSE;
    LONG err = ERROR_SUCCESS;
    TCHAR szBufferL[_MAX_PATH], szBufferR[_MAX_PATH];
    DWORD dwBufferL = _MAX_PATH, dwBufferR = _MAX_PATH;

    err = RegEnumValue(m_hKey, m_index, szBufferL, &dwBufferL, NULL, NULL, (LPBYTE)szBufferR, &dwBufferR);
    if (err == ERROR_SUCCESS) {
        LPTSTR token;
        m_index++;
        m_value = szBufferR;
        token = _tcstok(szBufferL, _T(","));
        if (token) {
            m_name = token;
            token = _tcstok(NULL, _T(","));
            if (token) {
                m_ip = token;
            } else {
                m_ip = _T("null");
            }
            fReturn = TRUE;
        }
    }

    return (fReturn);
}

void CElem::ReadRegVRoots(LPCTSTR szSubKey, CMapStringToOb *pMap)
{
    if ( OpenReg(szSubKey) ) {
        while (GetNext()) {
            Add(pMap);
        }
        CloseReg();
    }
}

void CElem::Add(CMapStringToOb *pMap)
{
    CObject *pObj;
    CMapStringToString *pNew;

    if (pMap->Lookup(m_ip, pObj) == TRUE) {
        pNew = (CMapStringToString*)pObj;
        pNew->SetAt(m_name, m_value);
    } else {
        pNew = new CMapStringToString;
        pNew->SetAt(m_name, m_value);
        pMap->SetAt(m_ip, (CObject*)pNew);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\const.h ===
#ifndef CONST_H
#define CONST_H

//
// this is the max resource string length
//
#define MAX_STR_LEN 1024

//
// A whole load of defines
//
#define REG_INETSTP					_T("Software\\Microsoft\\InetStp")

#define REG_ACTIVEMSG				_T("Software\\Microsoft\\Exchange\\Active Messaging")

#define MD_SMTP_QUEUEROOT			_T("LM/SmtpSvc/1")
#define MD_SMTPQUEUE_DATA			36875
#define MD_POP3_MAILROOT			_T("LM/Pop3Svc/1/Root/Mailbox")
#define MD_IMAP_MAILROOT			_T("LM/ImapSvc/1/Root/Mailbox")
#define MD_MAILROOT_DATA			3001

#define MD_SMTP_DSAACCT				_T("LM/SmtpSvc/1/RoutingSources")
#define MD_SMTPACC_DATA				36957
#define MD_SMTPPASS_DATA			36958
#define MD_POP3_DSAACCT				_T("LM/Pop3Svc/1/RoutingSources")
#define MD_POP3ACC_DATA				41190
#define MD_POP3PASS_DATA			41191
#define MD_IMAP_DSAACCT				_T("LM/ImapSvc/1/RoutingSources")
#define MD_IMAPACC_DATA				49383
#define MD_IMAPPASS_DATA			49384
#define MD_DSAACCT_DATA			3001
#define SZ_MCISEVENTLOGNAME			_T("MCISMail")


#define REG_SERVICES				_T("System\\CurrentControlSet\\Services")
#define REG_SMTPSVC					_T("System\\CurrentControlSet\\Services\\SMTPSVC")
#define REG_POP3SVC					_T("System\\CurrentControlSet\\Services\\POP3SVC")
#define REG_IMAPSVC					_T("System\\CurrentControlSet\\Services\\IMAPSVC")
#define REG_NNTPSVC					_T("System\\CurrentControlSet\\Services\\NntpSvc")

#define REG_EXCHANGEIMCPARAMETERS	_T("System\\CurrentControlSet\\Services\\MsExchangeIMC\\Parameters")
#define REG_DSASVC					_T("System\\CurrentControlSet\\Services\\DSASVC")		// Used only to point out upgrade path for Exchange
#define REG_ROUTING_SOURCES_SUFFIX	_T("\\Parameters\\RoutingSources");

#define REG_RUN_SERVICES			_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunServices")

#define REG_WINDOW_CURRENTVER		_T("Software\\Microsoft\\Windows\\CurrentVersion")
#define REG_UNINSTALL				_T("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall")
#define REG_KEYRING					_T("Software\\Microsoft\\Keyring\\Parameters\\AddOnServices")
#define REG_EVENTLOG				_T("System\\CurrentControlSet\\Services\\EventLog\\System")
#define SZ_SVC_DEPEND				_T("IISADMIN\0Eventlog\0\0")
#define SZ_SVC_DEPEND_PLUS_DSA		_T("IISADMIN\0DSASVC\0\0")
#define REG_B3_SETUP_STRING			_T("K2 Beta 3")
#define REG_SETUP_STRING			_T("K2 RTM")
#define REG_SETUP_STRING_MCIS		_T("MCIS 2.0 B1")
#define REG_SETUP_STRING_MCIS_GEN	_T("MCIS 2.0")
#define REG_SETUP_STRING_STAXNT5WB2	_T("STAXNT5 WKS")
#define REG_SETUP_STRING_STAXNT5SB2	_T("STAXNT5 SRV")
#define REG_SETUP_STRING_NT5WKSB3	_T("STAXNT5 WKS Beta 3")
#define REG_SETUP_STRING_NT5SRVB3   _T("STAXNT5 SRV Beta 3")
#define REG_SETUP_STRING_NT5WKS		_T("STAX Win2000 WKS")
#define REG_SETUP_STRING_NT5SRV		_T("STAX Win2000 SRV")

#define SZ_IMS_DISPLAY_NAME			_T("MCIS 2.0 Mail Server")
#define SZ_INS_DISPLAY_NAME			_T("MCIS 2.0 News Server")
#define SZ_IMS_INF_FILE				_T("IMSMAIN.INF")
#define SZ_INS_INF_FILE				_T("INSMAIN.INF")
// BINLIN: MCIS 1.0 name under control panel add/remove
#define SZ_MCIS10_NEWS_UNINST		_T("MCIS News Server")
#define SZ_MCIS10_MAIL_UNINST		_T("MCIS Mail Server")

#define SZ_SMTPSERVICENAME			_T("SMTPSVC")
#define SZ_NTFSDRVSERVICENAME			_T("NTFSDRV")
#define REG_SMTPPARAMETERS			_T("System\\CurrentControlSet\\Services\\SMTPSVC\\Parameters")    
#define REG_SMTPPERFORMANCE			_T("System\\CurrentControlSet\\Services\\SMTPSVC\\Performance")
#define REG_SMTPVROOTS				_T("System\\CurrentControlSet\\Services\\SMTPSVC\\Parameters\\Virtual Roots")
#define REG_NTFSPERFORMANCE			_T("System\\CurrentControlSet\\Services\\NTFSDRV\\Performance")
#define MDID_SMTP_ROUTING_SOURCES		8046

#define SZ_SMTP_QUEUEDIR			_T("\\Queue")
#define SZ_SMTP_PICKUPDIR			_T("\\Pickup")
#define SZ_SMTP_DROPDIR				_T("\\Drop")
#define SZ_SMTP_BADMAILDIR			_T("\\Badmail")
#define SZ_SMTP_MAILBOXDIR			_T("\\Mailbox")
#define SZ_SMTP_SORTTEMPDIR			_T("\\SortTemp")
#define SZ_SMTP_ROUTINGDIR			_T("\\Route")
#define SZ_SMTP_OPSDIR				_T("\\Mail\\Docs\\WebDocs\\Mail_ops")
#define SZ_SMTP_REFDIR				_T("\\Mail\\Docs\\WebDocs\\Mail_ref")

#define SZ_POP3SERVICENAME			_T("POP3SVC")
#define REG_POP3PARAMETERS			_T("System\\CurrentControlSet\\Services\\POP3SVC\\Parameters")    
#define REG_POP3PERFORMANCE			_T("System\\CurrentControlSet\\Services\\POP3SVC\\Performance")
#define REG_POP3VROOTS				_T("System\\CurrentControlSet\\Services\\POP3SVC\\Parameters\\Virtual Roots")    
#define MDID_POP3_ROUTING_SOURCES		7214

#define SZ_IMAPSERVICENAME			_T("IMAPSVC")
#define REG_IMAPPARAMETERS			_T("System\\CurrentControlSet\\Services\\IMAPSVC\\Parameters")    
#define REG_IMAPPERFORMANCE			_T("System\\CurrentControlSet\\Services\\IMAPSVC\\Performance")
#define REG_IMAPVROOTS				_T("System\\CurrentControlSet\\Services\\IMAPSVC\\Parameters\\Virtual Roots")    
#define MDID_IMAP_ROUTING_SOURCES		8214

#define SZ_DSASERVICENAME			_T("DSASVC")
#define REG_DSAPARAMETERS			_T("System\\CurrentControlSet\\Services\\DSASVC\\Parameters")    

#define SZ_DSAEXCHANGENAME			_T("MSExchangeDS")
#define REG_EXCLANGUAGE				_T("SOFTWARE\\Microsoft\\Exchange\\Language")
#define	REG_APPNEVENTLOG			_T("System\\CurrentControlSet\\Services\\EventLog\\Application")
#define REG_EXCDSAEVENTLOG			_T("System\\CurrentControlSet\\Services\\EventLog\\Application\\MSExchangeDS")
#define REG_EXCDSAPERFORMANCE		_T("System\\CurrentControlSet\\Services\\MSExchangeDS\\Performance")
#define REG_EXCDSAROOT				_T("System\\CurrentControlSet\\Services\\MSExchangeDS")    
#define REG_EXCDSAPARAMETERS		_T("System\\CurrentControlSet\\Services\\MSExchangeDS\\Parameters")    
#define REG_EXCDSADIAGNOSTICS		_T("System\\CurrentControlSet\\Services\\MSExchangeDS\\Diagnostics")  
#define SZ_ESEEXCHANGENAME			_T("ESE97")
#define REG_ESE97EVENTLOG			_T("System\\CurrentControlSet\\Services\\EventLog\\Application\\ESE97")
#define REG_ESE97PERFORMANCE		_T("System\\CurrentControlSet\\Services\\ESE97\\Performance")

#define SZ_NNTPSERVICENAME			_T("NNTPSVC")
#define REG_NNTPPARAMETERS			_T("System\\CurrentControlSet\\Services\\NntpSvc\\Parameters")    
#define REG_NNTPPERFORMANCE			_T("System\\CurrentControlSet\\Services\\NntpSvc\\Performance")
#define REG_NNTPVROOTS				_T("System\\CurrentControlSet\\Services\\NntpSvc\\Parameters\\Virtual Roots")    

#define SZ_FTPSERVICENAME			_T("MSFTPSVC")
#define SZ_WWWSERVICENAME			_T("W3SVC")
#define SZ_SPOOLERSERVICENAME		_T("SPOOLER")
#define SZ_SNMPSERVICENAME			_T("SNMP")
#define SZ_CISERVICENAME			_T("CISVC")
#define SZ_U2SERVICENAME			_T("BROKSVC")
#define REG_CIPARAMETERS			_T("System\\CurrentControlSet\\Control\\ContentIndex")

#define SZ_INETINFO_EXE				_T("\\inetinfo.exe")
#define SZ_INETINFO					_T("InetInfo")
#define SZ_INETINFO_NAME			_T("Microsoft Internet Information Server")
#define REG_INETINFO				_T("System\\CurrentControlSet\\Services\\InetInfo")
#define REG_INETINFOPARAMETERS		_T("System\\CurrentControlSet\\Services\\InetInfo\\Parameters")
#define REG_INETINFOPERFORMANCE		_T("System\\CurrentControlSet\\Services\\InetInfo\\Performance")   
#define SZ_INETINFODISPATCH			_T("DispatchEntries")

#define SZ_MD_SERVICENAME			_T("IISADMIN")
#define SZ_MD_DEPEND				_T("RPCSS\0NTLMSSP\0\0")
#define SZ_MD_88E4					_T("{88E4BA60-537B-11D0-9B8E-00A0C922E703}")

#define REG_PRODUCT					_T("System\\CurrentControlSet\\Control\\ProductOptions")
#define REG_PRODUCTTYPE				_T("ProductType")

#define REG_SNMPPARAMETERS			_T("System\\CurrentControlSet\\Services\\SNMP\\Parameters" )
#define REG_SNMPEXTAGENT			_T("System\\CurrentControlSet\\Services\\SNMP\\Parameters\\ExtensionAgents" )
#define REG_SOFTWAREMSFT			_T("Software\\Microsoft")
#define REG_CURVERSION				_T("CurrentVersion")
#define MAJORVERSION				4
#define MINORVERSION				0

#define STACKSMAJORVERSION			2
#define STACKSMINORVERSION			0
#define STAXNT5MAJORVERSION			3
#define STAXNT5MINORVERSION			0

#define SZ_SETUP_STR_K2PDC			_T("K2 Alpha")
#define SZ_SETUP_STR_K2BETA1		_T("K2 Beta1")
#define SZ_SETUP_STR_K2BETA2		_T("K2 Beta2")
#define SZ_SETUP_STR_K2BETA3		_T("K2 Beta3")
#define SZ_SETUP_STR_K2RTM			_T("K2 RTM")

#define ADS_EXE_PATH				_T("ads.exe")
#define	ADS_FILE					_T("adsldp.dll")
#define ADSILOWPART					0xe32ca800
#define ADSIHIGHPART				0x01bcd84c

#define MCIS_MAX_POOL_THREADS		10

//
// Some new stuff for the resource kit
//
#define REG_MMC_ROOT				_T("Software\\Microsoft\\MMC")
#define REG_MMC_SNAPINS				_T("Software\\Microsoft\\MMC\\SnapIns")
#define REG_CLSIDS					_T("CLSID\\")


//
// Enumerated types
//
typedef enum _OS
{
	OS_NT, 
	OS_W95, 
	OS_OTHERS
	
} OS;

typedef enum _NT_OS_TYPE 
{
	OT_NT_UNKNOWN,
    OT_NTS, 
	OT_PDC_OR_BDC,
    OT_NTW, 
    OT_PDC, 
	OT_BDC, 
	OT_SAM,
	
} NT_OS_TYPE;

typedef enum _UPGRADE_TYPE 
{
	UT_NONE, 
	UT_20, 
	UT_30
	
} UPGRADE_TYPE;
        
typedef enum _INSTALL_MODE 
{
	IM_FRESH,
	IM_UPGRADE,
	IM_MAINTENANCE, 
	IM_DEGRADE,
	IM_UPGRADEK2,   // Upgrade from K2 RTM to NT5
	IM_UPGRADEB2,   // Upgrade from NT5 Beta2
	IM_UPGRADEB3,   // Upgrade from NT5 Beta3
    IM_UPGRADEWKS,  // Upgrade from NT5 Workstation to NT5 Server
    IM_UPGRADE10,   // Upgrade from MCIS 1.0 to NT5
    IM_UPGRADE20,   // Upgrade from MCIS 2.0 to NT5
	
} INSTALL_MODE;

typedef enum _ACTION_TYPE 
{
	AT_DO_NOTHING, 
	AT_FRESH_INSTALL, 
	AT_REINSTALL,
	AT_UPGRADE, 
	AT_REMOVE,
	AT_UPGRADEK2,
    AT_MAXAT

} ACTION_TYPE;

typedef enum _STATUS_TYPE 
{
	ST_UNKNOWN, 
	ST_INSTALLED, 
	ST_UNINSTALLED
	
} STATUS_TYPE;

typedef enum _MAIN_COMPONENT 
{
	MC_IMS, 
	MC_INS, 
	MC_NONE,
	MC_MAXMC
	
} MAIN_COMPONENT;

typedef enum _SUBCOMPONENT 
{
	SC_SMTP, 
	SC_NNTP,
    SC_SMTP_DOCS,
    SC_NNTP_DOCS, 
	SC_NONE,
	SC_MAXSC
	
} SUBCOMPONENT;

typedef enum _RESKIT_SUBCOMPONENT 
{
	RKSC_SMTP_MMC,
	RKSC_NNTP_MMC,
	RKSC_NONE,
	RKSC_MAXSC
	
} RESKIT_SUBCOMPONENT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\seo\testsrv\testsrvdlg.h ===
// TestSrvDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTestSrvDlg dialog

class CTestSrvDlg : public CDialog
{
// Construction
public:
	CTestSrvDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CTestSrvDlg)
	enum { IDD = IDD_TESTSRV_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTestSrvDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CTestSrvDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\dummy.cpp ===
#include "stdafx.h"

#include "setupapi.h"
#include "ocmanage.h"

#pragma hdrstop

/* =================================================================

The sequence of OCM Calls are as follows:

OC_PREINITIALIZE
OC_INIT_COMPONENT
OC_SET_LANGUAGE
OC_QUERY_STATE
OC_CALC_DISK_SPACE
OC_REQUEST_PAGES

UI Appears with Welcome, EULA, and mode page

OC_QUERY_STATE
OC_QUERY_SKIP_PAGE

OC Page "Check boxes" appears

OC_QUERY_IMAGE

Detail pages
Wizard pages ...

OC_QUEUE_FILE_OPS
OC_QUERY_STEP_COUNT
OC_ABOUT_TO_COMMIT_QUEUE
OC_NEED_MEDIA (if required)
OC_COMPLETE_INSTALLATION

OC_CLEANUP

*/
DWORD
DummyOcEntry(
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2
    )
{
    DWORD d;

    switch(Function) 
	{

    case OC_PREINITIALIZE:
#ifdef UNICODE
        d = OCFLAG_UNICODE;
#else
        d = OCFLAG_ANSI;
#endif
        break;

    case OC_INIT_COMPONENT:
		d = NO_ERROR;
        break;

    case OC_SET_LANGUAGE:
        d = TRUE;
        break;

    case OC_QUERY_IMAGE:
        d = (DWORD)NULL;
        break;

    case OC_REQUEST_PAGES:
        d = 0;
        break;

    case OC_QUERY_STATE:
        d = SubcompOff;
		break;

    case OC_QUERY_CHANGE_SEL_STATE:
		d = 0;
		break;

    case OC_CALC_DISK_SPACE:
        d = NO_ERROR;
        break;

    case OC_QUEUE_FILE_OPS:
        d = NO_ERROR;
		break;

    case OC_NEED_MEDIA:
        d = 1;
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
        d = 0;
        break;

    case OC_QUERY_STEP_COUNT:
        d = 0;
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        d = NO_ERROR;
		break;

    case OC_COMPLETE_INSTALLATION:
        d = NO_ERROR;
		break;

    case OC_CLEANUP:
        d = 0;
		break;

    default:
        d = 0;
        break;
    }

    return(d);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\helper.h ===
#ifndef _HELPER_H_
#define _HELPER_H_

class CInitApp;

extern CInitApp theApp;

BOOL IsFileExist(LPCTSTR szFile);

BOOL RunningAsAdministrator();

void DebugOutput(LPCTSTR szFormat, ...);
void DebugOutputSafe(TCHAR *pszfmt, ...);

LONG lodctr(LPCTSTR lpszIniFile);
LONG unlodctr(LPCTSTR lpszDriver);

BOOL FetchCabFile(LPCTSTR pszURL, LPCTSTR pszDest);
void InstallMimeMap(BOOL fUpgrade);

INT Register_iis_smtp_nt5(BOOL fUpgrade, BOOL fReinstall);
INT Unregister_iis_smtp();
INT Upgrade_iis_smtp_from_b2();
INT Upgrade_iis_smtp_from_b3();
INT Register_iis_smtp_mmc();
INT Unregister_iis_smtp_mmc();
INT Register_iis_pop3(BOOL fUpgrade);
INT Unregister_iis_pop3();
INT Register_iis_imap(BOOL fUpgrade);
INT Unregister_iis_imap();
INT Register_iis_nntp_nt5(BOOL fUpgrade, BOOL fReinstall);
INT Unregister_iis_nntp();
INT Upgrade_iis_nntp_from_b2();
INT Upgrade_iis_nntp_from_b3();
INT Register_iis_nntp_mmc();
INT Unregister_iis_nntp_mmc();
INT Register_iis_dsa(BOOL fUpgrade);
INT Unregister_iis_dsa();
INT ConfigureDsa();
INT Upgrade_iis_smtp_nt5_fromk2(BOOL fFromK2);
INT Upgrade_iis_smtp_nt5_fromb2(BOOL fFromB2);
INT Upgrade_iis_nntp_nt5_fromk2(BOOL fFromK2);
INT Upgrade_iis_nntp_nt5_fromb2(BOOL fFromB2);
void GetNntpFilePathFromMD(CString &csPathNntpFile, CString &csPathNntpRoot);

DWORD RegisterOLEControl(LPCTSTR lpszOcxFile, BOOL fAction);
BOOL InetDeleteFile(LPCTSTR szFileName);
BOOL RecRemoveEmptyDir(LPCTSTR szName);
BOOL RecRemoveDir(LPCTSTR szName);

INT     InetDisableService( LPCTSTR lpServiceName );
INT     InetStartService( LPCTSTR lpServiceName );
DWORD   InetQueryServiceStatus( LPCTSTR lpServiceName );
INT     InetStopService( LPCTSTR lpServiceName );
INT     InetDeleteService( LPCTSTR lpServiceName );
INT     InetCreateService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, DWORD dwStartType, LPCTSTR lpDependencies, LPCTSTR lpServiceDescription);
INT InetCreateDriver(LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, DWORD dwStartType);
INT     InetConfigService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, LPCTSTR lpDependencies, LPCTSTR lpServiceDescription);
BOOL InetRegisterService(LPCTSTR pszMachine, LPCTSTR pszServiceName, GUID *pGuid, DWORD SapId, DWORD TcpPort, BOOL fAdd = TRUE);
int StopServiceAndDependencies(LPCTSTR ServiceName, int AddToRestartList);
int ServicesRestartList_RestartServices(void);
int ServicesRestartList_Add(LPCTSTR szServiceName);

INT InstallPerformance(
                CString nlsRegPerf,
                CString nlsDll,
                CString nlsOpen,
                CString nlsClose,
                CString nlsCollect );
INT AddEventLog(CString nlsService, CString nlsMsgFile, DWORD dwType);
INT RemoveEventLog( CString nlsService );
INT InstallAgent( CString nlsName, CString nlsPath );
INT RemoveAgent( CString nlsServiceName );

DWORD
ChangeAppIDAccessACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    );

DWORD
ChangeAppIDLaunchACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    );

BOOL CreateLayerDirectory( CString &str );
BOOL SetEveryoneACL (CString &str, BOOL fAddAnonymousLogon = FALSE );

int MyMessageBox(HWND hWnd, LPCTSTR lpszTheMessage, LPCTSTR lpszTheTitle, UINT style);
void GetErrorMsg(int errCode, LPCTSTR szExtraMsg);
void MyLoadString(int nID, CString &csResult);
DWORD GetDebugLevel(void);

void    MakePath(LPTSTR lpPath);
void    AddPath(LPTSTR szPath, LPCTSTR szName );
CString AddPath(CString szPath, LPCTSTR szName );

DWORD SetAdminACL_wrap(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount, BOOL bDisplayMsgOnErrFlag);

void SetupSetStringId_Wrapper(HINF hInf);

#endif // _HELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\k2suite.h ===
#ifndef _K2SUITE_H_
#define _K2SUITE_H_

#define IIS_SETUPMODE_UPGRADEONLY	SETUPMODE_UPGRADEONLY
#define IIS_SETUPMODE_ADDEXTRACOMPS	SETUPMODE_ADDEXTRACOMPS

#define IIS_SETUPMODE_ADDREMOVE		SETUPMODE_ADDREMOVE
#define IIS_SETUPMODE_REINSTALL		SETUPMODE_REINSTALL
#define IIS_SETUPMODE_REMOVEALL		SETUPMODE_REMOVEALL

#define IIS_SETUPMODE_MINIMUM		SETUPMODE_MINIMAL
#define IIS_SETUPMODE_TYPICAL		SETUPMODE_TYPICAL
#define IIS_SETUPMODE_CUSTOM		SETUPMODE_CUSTOM

#endif //_K2SUITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\initapp.cpp ===
#include "stdafx.h"
#include "k2suite.h"

#undef UNICODE
#include "iadm.h"
#define UNICODE
#include "mdkey.h"
#include "mdentry.h"

#include "ocmanage.h"

#include "..\..\..\ui\admin\logui\resource.h"

static TCHAR    szTcpipPath[] = TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters");
static TCHAR    szWindowsNTOrg[] = _T("Software\\Microsoft\\Windows NT\\CurrentVersion");

extern void PopupOkMessageBox(DWORD dwMessageId, LPCTSTR szCaption);

extern "C"
{
    typedef LONG (*P_NetSetupFindSoftwareComponent)( PCWSTR pszInfOption,
                PWSTR pszInfName,
                PDWORD pcchInfName,
                PWSTR pszRegBase,     // optional, may be NULL
                PDWORD pcchRegBase ); // optional, NULL if pszRegBase is NULL
}

CInitApp::CInitApp()
{
	DWORD dwMC, dwSC;

    m_err = 0;
    m_hDllHandle = NULL;

	//
    // Establish the type of setup (MCIS / K2) using conditionally-compiled code
    // NT5 - Still leave this member variable here to get setup dll to build.
    // TODO: Get rid of it completely and only use m_eNTOSType and m_eOS.
    //
#ifdef K2INSTALL

	m_fIsMcis = FALSE;

#else

	m_fIsMcis = TRUE;

#endif // K2INSTALL

    // Product name and application name
    m_csProdName = _T("");       // IIS or PWS
    m_csAppName = _T("");        // equal to m_csProdName + "Setup"
    m_csGroupName = _T("");

    // machine status
    m_csMachineName = _T("");
	m_csCleanMachineName = _T("");

    m_csWinDir = _T("");
    m_csSysDir = _T("");
    m_csSysDrive = _T("");

    m_csPathSource = _T("");
    m_csPathInetsrv = _T("");  // the primary destination defaults to m_csSysDir\inetsrv
    m_csPathInetpub = _T("");
    m_csPathMailroot = _T("");
    m_csPathNntpRoot = _T("");
    m_csPathNntpFile = _T("");
	m_fMailPathSet = FALSE;
	m_fNntpPathSet = FALSE;

//    m_csPathExchangeDS = _T("");
    m_csExcEnterprise = _T("");
    m_csExcSite = _T("");
	m_csExcUserName = _T("");
	m_csExcPassword = _T("");
	m_csDsaUsername = _T("Username");
	m_csDsaDomain = _T("Domain");
	m_csDsaPassword = _T("");
	m_csDsaAccount = _T("");
	m_csDsaBindType = _T("None");
	m_fK2SmtpInstalled = TRUE;

    //
    //  Default to NO for MessageBox popup
    //
    m_bAllowMessageBoxPopups = FALSE;

	//
	//	Set the Default DSA Enterprise and Site.
	//

	HKEY    hNTParam = NULL;
	TCHAR	Organization[MAX_PATH];
	TCHAR	HostName[MAX_PATH];

    DWORD   SizeOfBuffer = 0;
    DWORD   dwType;
    DWORD   dwErr;

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szWindowsNTOrg, 0, KEY_QUERY_VALUE, &hNTParam) == ERROR_SUCCESS)
	{
		SizeOfBuffer = MAX_PATH;

		dwErr = RegQueryValueEx(hNTParam, _T("RegisteredOrganization"), 0, &dwType, (LPBYTE)Organization, &SizeOfBuffer);
		if (dwErr != ERROR_SUCCESS || SizeOfBuffer <= 2 || dwType != REG_SZ)
		{
			m_csExcEnterprise = _T("Company Name");
		}
		else
		{
			m_csExcEnterprise = Organization;
		}

		RegCloseKey(hNTParam);
	}
	else
	{
		m_csExcEnterprise = _T("Company Name");
	}

	SizeOfBuffer = MAX_PATH;
	if (!GetComputerName(HostName, &SizeOfBuffer))
	{
		m_csExcSite = _T("Department Name");
	}
	else
	{
		m_csExcSite = HostName;
	}


    m_eOS = OS_NT;                  // OS_W95, OS_NT, OS_OTHERS
    m_fNT4 = FALSE;                 // TRUE if NT 4.0 (SP2) or greater
    m_fNT5 = FALSE;
    m_fW95 = FALSE;                 // TRUE if Win95 (build xxx) or greater

    m_eNTOSType = OT_NTS;           // OT_PDC, OT_SAM, OT_BDC, OT_NTS, OT_NTW
    m_csPlatform = _T("");

    m_fTCPIP = FALSE;               // TRUE if TCP/IP is installed

    m_eUpgradeType = UT_NONE;       //  UT_NONE, UT_OLDFTP, UT_10, UT_20
    m_eInstallMode = IM_FRESH;      // IM_FRESH, IM_MAINTENANCE, IM_UPGRADE
    m_dwSetupMode = IIS_SETUPMODE_CUSTOM;

	m_fWizpagesCreated = FALSE;

	for (dwSC = 0; dwSC < SC_MAXSC; dwSC++)
	{
		m_fSelected[dwSC] = FALSE;
		//m_fStarted[dwSC] = FALSE;
		m_eState[dwSC] = IM_FRESH;
		m_fValidSetupString[dwSC] = TRUE;
	}

	for (dwMC = 0; dwMC < MC_MAXMC; dwMC++)
	{
	    m_hInfHandle[dwMC] = NULL;
        m_fStarted[dwMC] = FALSE;

		for (dwSC = 0; dwSC < SC_MAXSC; dwSC++)
			m_fActive[dwMC][dwSC] = FALSE;
	}

	m_fW3Started = FALSE;
	m_fFtpStarted = FALSE;
	m_fSpoolerStarted = FALSE;
	m_fSnmpStarted = FALSE;
	m_fCIStarted = FALSE;
	m_fU2Started = FALSE;
	m_fU2LdapStarted = FALSE;

    m_fNTUpgrade_Mode=0;
    m_fNTGuiMode=0;
    m_fNtWorkstation=0;
    m_fInvokedByNT = 0;

	m_fEULA = FALSE;
	m_fIsUnattended = FALSE;
	m_fSuppressSmtp = FALSE;
	m_fMailGroupInstalled = FALSE;
}

CInitApp::~CInitApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CInitApp object <Global variable>

BOOL CInitApp::GetMachineName()
{
    TCHAR buf[ CNLEN + 10 ];
    DWORD dwLen = CNLEN + 10;

    m_csMachineName = _T("");

    if ( GetComputerName( buf, &dwLen ))
    {
        if ( buf[0] != _T('\\') )
        {
            m_csMachineName = _T("\\");
            m_csMachineName += _T("\\");
			m_csCleanMachineName = buf;
        }
		else
		{
			TCHAR *							ch;
			ch = buf;
			while (*ch == '\\')
			{
				ch++;
			}
			m_csCleanMachineName = ch;
		}

        m_csMachineName += buf;

    } else
        m_err = IDS_CANNOT_GET_MACHINE_NAME;

    return ( !(m_csMachineName.IsEmpty()) );
}

// Return TRUE, if NT or Win95
BOOL CInitApp::GetOS()
{
    OSVERSIONINFO VerInfo;
    VerInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &VerInfo );

    switch (VerInfo.dwPlatformId) {
    case VER_PLATFORM_WIN32_NT:
        m_eOS = OS_NT;
        break;
    case VER_PLATFORM_WIN32_WINDOWS:
        m_eOS = OS_W95;
        break;
    default:
        m_eOS = OS_OTHERS;
        break;
    }

    if ( m_eOS == OS_OTHERS )
        m_err = IDS_OS_NOT_SUPPORT;

    return (m_eOS != OS_OTHERS);
}

// Support NT 4.0 (SP2) or greater
BOOL CInitApp::GetOSVersion()
{
    BOOL fReturn = FALSE;

    if ( m_eOS == OS_NT )
    {
        m_fNT4 = FALSE;
        m_fNT5 = FALSE;

        OSVERSIONINFO vInfo;

        vInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if ( GetVersionEx(&vInfo) )
        {
            // check if it's NT5 or NT 4.0 (SP2)
            if ( vInfo.dwMajorVersion >= 4 ) {
                if (vInfo.dwMajorVersion >= 5) {
                    m_fNT5 = TRUE;
                    fReturn = TRUE;
                } else {
                    CRegKey regSP(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Control\\Windows"), KEY_READ);
                    if ((HKEY)regSP) {
                        DWORD dwSP = 0;
                        regSP.QueryValue(_T("CSDVersion"), dwSP);
                        if (dwSP < 0x300) {
                            m_err = IDS_NT4_SP3_NEEDED;
                            return FALSE;
                        }
                        if (dwSP >= 0x300) {
                            m_fNT4 = TRUE;
                            fReturn = TRUE;
                        }
                    }
                }
            }
        }
    }

    if (m_eOS == OS_W95)
    {
        fReturn = TRUE;
    }

    if ( !fReturn )
        m_err = IDS_OS_VERSION_NOT_SUPPORTED;

    return (fReturn);
}

// find out it's a NTS, PDC, BDC, NTW, SAM(PDC)
BOOL CInitApp::GetOSType()
{
    BOOL fReturn = TRUE;

    if ( m_eOS == OS_NT )
    {
        // If we are in NT guimode setup
        // then the registry key stuff is not yet setup
        // use the passed in ocmanage.dll stuff to determine
        // what we are installing upon.
        if (theApp.m_fNTGuiMode)
        {
                if (theApp.m_fNtWorkstation) {m_eNTOSType = OT_NTW;}
                else {m_eNTOSType = OT_NTS;}
        }
        else
        {
            CRegKey regProductPath( HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Control\\ProductOptions"), KEY_READ);

            if ( (HKEY)regProductPath )
            {
                CString strProductType;
                LONG lReturnedErrCode = regProductPath.QueryValue( _T("ProductType"), strProductType );
                if (lReturnedErrCode == ERROR_SUCCESS)
                {
                    strProductType.MakeUpper();

                    // ToDo: Sam ?
                    if (strProductType == _T("WINNT")) {
                        m_eNTOSType = OT_NTW;
                    }
                    else if (strProductType == _T("SERVERNT"))
                    {
                        m_eNTOSType = OT_NTS;
                    }
                    else if (strProductType == _T("LANMANNT"))
                    {
                        m_eNTOSType = OT_PDC_OR_BDC;
                    }
                    else
                    {
                        fReturn = FALSE;
                    }

#if 0
//
// Replace with above code from iis
//
                    } else {

                        INT err = NERR_Success;
                        BYTE *pBuffer;
                        if ((err = NetServerGetInfo(NULL, 101, &pBuffer)) == NERR_Success) {
                            LPSERVER_INFO_101 pInfo = (LPSERVER_INFO_101)pBuffer;

                            if (pInfo->sv101_type & SV_TYPE_DOMAIN_CTRL)
                                m_eNTOSType = OT_PDC;
                            else if (pInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL)
                                m_eNTOSType = OT_BDC;
                            else if (pInfo->sv101_type & SV_TYPE_SERVER_NT)
                                m_eNTOSType = OT_NTS;
                            else
                                fReturn = FALSE;
                        } else {
                            fReturn = FALSE;
                        }
                    }
#endif

                }
                else
                {
                    // Shoot, we can't get the registry key,
                    // let's try using the ocmanage.dll passed in stuff.
                    if (theApp.m_fNTGuiMode)
                    {
                        if (theApp.m_fNtWorkstation) {m_eNTOSType = OT_NTW;}
                        else {m_eNTOSType = OT_NTS;}
                    }
                    else
                    {
                        GetErrorMsg(lReturnedErrCode, _T("System\\CurrentControlSet\\Control\\ProductOptions"));
                        m_eNTOSType = OT_NTS; // default to stand-alone NTS
                    }
                }
            }
            else
            {
                // Shoot, we can't get the registry key,
                // let's try using the ocmanage.dll passed in stuff.
                if (theApp.m_fNTGuiMode)
                {
                    if (theApp.m_fNtWorkstation) {m_eNTOSType = OT_NTW;}
                    else {m_eNTOSType = OT_NTS;}
                }
                else
                {
                    GetErrorMsg(ERROR_CANTOPEN, _T("System\\CurrentControlSet\\Control\\ProductOptions"));
                    m_eNTOSType = OT_NTS; // default to stand-alone NTS
                }
            }
        }
    }

    if ( !fReturn )
        m_err = IDS_CANNOT_DETECT_OS_TYPE;

    return(fReturn);
}

// Checks for NT Server
BOOL CInitApp::VerifyOSForSetup()
{
	// Make sure we have NT5 Server/Workstation, or NT4 SP3 Server
	if ((m_eOS != OS_NT) ||
		(m_fNT4 && m_eNTOSType == OT_NTW))
	{
        m_err = IDS_NT_SERVER_REQUIRED;
        return FALSE;
	}
	return(TRUE);
}

// Get WinDir and SysDir of the machine
//  WinDir = C:\winnt           SysDir = C:\Winnt\system32
BOOL CInitApp::GetSysDirs()
{
    BOOL fReturn = TRUE;

    TCHAR buf[_MAX_PATH];

    GetWindowsDirectory( buf, _MAX_PATH);
    m_csWinDir = buf;

    GetSystemDirectory( buf, _MAX_PATH);
    m_csSysDir = buf;

    buf[2] = _T('\0');  // now buf contains the system drive letter
    m_csSysDrive = buf;

    return fReturn;
}

// detect whether we have TCP/IP installed on this machine
BOOL CInitApp::IsTCPIPInstalled()
{
// we require K2, K2 requires TCP/IP, so we shouldn't need this check
// - awetmore
	return (TRUE);
}

BOOL CInitApp::SetInstallMode()
{
    BOOL fReturn = TRUE;

    m_eInstallMode = IM_FRESH;
    m_eUpgradeType = UT_NONE;

	// We will detect which version of IMS components we
	// have. We will then use that information to see
	// which install mode we should be in
	DetectPreviousInstallations();

    return(fReturn);
}

LPCTSTR aszServiceKeys[SC_MAXSC] =
{
	REG_SMTPPARAMETERS,
	REG_NNTPPARAMETERS,
	REG_SMTPPARAMETERS,
	REG_NNTPPARAMETERS,
};

// Detect previous installations of each component, we use a simple
// approach which checks the servicename\parameter registry value
BOOL CInitApp::DetectPreviousInstallations()
{
	DWORD i;
	DWORD dwMajorVersion = 0;
	DWORD dwMinorVersion = 0;
	INSTALL_MODE eMode = IM_FRESH;

	for (i = 0; i < SC_MAXSC; i++)
	{
		// See if the key is there ...
        CRegKey regSvc(HKEY_LOCAL_MACHINE, aszServiceKeys[i], KEY_READ);
        if ((HKEY)regSvc)
		{
			// Key is there, see if we have the version info
			// If we have version info (2.0), then we have a
			// comparable install (maintenance mode), if the
			// version info is not there, we have an upgrade.
            // Version check
			LONG lReturn1 = regSvc.QueryValue(_T("MajorVersion"), dwMajorVersion);
			LONG lReturn2 = regSvc.QueryValue(_T("MinorVersion"), dwMinorVersion);
            if (lReturn1 == NERR_Success && lReturn2 == NERR_Success)
			{
				// Got the key, just a check to see we have version 3.0 - NT5 Workstation/Server
	            if ((dwMajorVersion == STAXNT5MAJORVERSION) &&
					(dwMinorVersion == STAXNT5MINORVERSION))
                {
                    // This is STAXNT5 Setup on top of STAXNT5, check to see if it's NTW or NTS
                    // a) If we are running NTW setup and NTW is installed, IM_MAINTENANCE
                    // b) If we are running NTS setup and NTS is installed, IM_MAINTENANCE
                    // c) If we are running NTS setup and NTW is installed, IM_UPGRADEK2 (?) - NYI
                    // e) If we are running NTW setup and NTS is installed, IM_MAINTENANCE (?)
                    //

                    //  11/4/98 - Just to cut these cases simplier:
                    //  a) NT5 Beta2 -> NT5 Beta3, IM_UPGRADEB2 - include refresh bits, add keys
                    //  b) NT5 Beta3 -> Nt5 Beta3, IM_MAINTENANCE - only refresh bits
					CString csSetupString;

					if (regSvc.QueryValue(_T("SetupString"), csSetupString) == NERR_Success)
					{
                        if ((csSetupString == REG_SETUP_STRING_STAXNT5WB2 /*&& OT_NTW == m_eNTOSType*/) ||
                            (csSetupString == REG_SETUP_STRING_STAXNT5SB2 /*&& OT_NTS == m_eNTOSType*/))
						{
							// Upgrade from NT5 Beta2
							eMode = IM_UPGRADEB2;
						}
                        else if ((csSetupString == REG_SETUP_STRING_NT5WKSB3 /*&& OT_NTW == m_eNTOSType*/) ||
                                 (csSetupString == REG_SETUP_STRING_NT5SRVB3 /*&& OT_NTS == m_eNTOSType*/))
                        {
                            //  Upgrade between NT5 Beta3 bits
                            eMode = IM_MAINTENANCE;
                        }
                        else if ((csSetupString == REG_SETUP_STRING_NT5WKS /*&& OT_NTW == m_eNTOSType*/) ||
                                 (csSetupString == REG_SETUP_STRING_NT5SRV /*&& OT_NTS == m_eNTOSType*/))

                        {
                            //  Final release code..
                            eMode = IM_MAINTENANCE;
                        }
                        else
                            {
                            //  Other Setup string - Dump it out and treat it as FRESH
                            DebugOutput(_T("Unkown SetupString <%s>"), csSetupString);
                            eMode = IM_FRESH;
							m_fValidSetupString[i] = FALSE;
                        }
/*
                        else if (csSetupString == REG_SETUP_STRING_STAXNT5WB2 && OT_NTS == m_eNTOSType)
						{
							// Upgrade from NT5 Workstation to NT5 Server
                            // TODO:
                            //   This is NYI since we don't know what we need to do during this upgrade
                            //   But this case is similar to our K2 upgrade to MCIS 2.0.  Use IM_MAINTENANCE
                            //   for now.
							eMode = IM_MAINTENANCE;
						}
						else
						{
							// Downgrade from NT5 Server to NT5 Workstation
                            // TODO:
                            //   We also don't know what to do in this case yet.  Use IM_MAINTENANCE just
                            //   like old MCIS 2.0->K2 downgrade in IIS 4.0.
							eMode = IM_MAINTENANCE;
						}
*/
					}
					else
					{
						// No setup string, ooops, something is wrong,
                        // treat it as fresh
						eMode = IM_FRESH;
						m_fValidSetupString[i] = FALSE;
					}
                }
                else if ((dwMajorVersion == STACKSMAJORVERSION) &&
                         (dwMinorVersion == STACKSMINORVERSION))
                {
                    //
                    // This is upgrading from NT4 MCIS 2.0/K2 to NT5.  We are in this case
                    // only during NT4->NT5 upgrade.
                    // TODO: Handle following upgrade cases:
                    // a) If we are running NT5 Workstation setup, is it valid to upgrade
                    //    from NT4 Server to NT5 Workstation?  It's will be IM_UPGRADE for now.
                    // b) If NT5 Server setup, then it's most likely IM_UPGRADE as well
                    // Need to figure out what need to be done during these upgrade case with IIS
                    //

                    // But first, let's detect if it's upgrading from K2 or MCIS 2.0:
					// a) Read the SetupString from registry
                    // b) If it's prefix with K2, then it's K2, MCIS 2.0, then it's MCIS 2.0
                    //    Note: we only support K2 RTM upgrade
                    // c) For any other cases, force a fresh install

                    CString csSetupString;

					if (regSvc.QueryValue(_T("SetupString"), csSetupString) == NERR_Success)
					{
						CString csMCIS20(REG_SETUP_STRING_MCIS_GEN);
                        if (csSetupString == REG_SETUP_STRING)
                        {
                            // K2 upgrade
                            eMode = IM_UPGRADEK2;
                        }
                        else if ((csSetupString.GetLength() >= csMCIS20.GetLength()) && (csSetupString.Left(csMCIS20.GetLength()) == csMCIS20))
						{
							// MCIS 2.0 upgrade
							eMode = IM_UPGRADE20;
						}
#if 0
                        //  BINLIN - Don't support this anymore, IM_UPGRADEB3 is used for NT5
						else if (csSetupString == REG_B3_SETUP_STRING)
						{
							// Upgrade from Beta 3, we won't support this case
                            // but leave it here for now.
							eMode = IM_UPGRADEB3;
						}
#endif
						else
						{
							// Unsupported setup string, treat it as fresh
							eMode = IM_FRESH;
						}
					}
					else
					{
						// No setup string, treat it as K2 upgrade
                        // Should it be MCIS 2.0, or Fresh install???
						eMode = IM_UPGRADEK2;
					}

				}
                else
                {
                    // Not STAXNT5, nor MCIS 2.0, so we invalidate the install,
                    // whatever that is, and force a clean install.
                    eMode = IM_FRESH;
                }
			}
			else
			{
				// No version key, so we have MCIS 1.0

                // For NT5, this is also upgrade for:
                // a) NT4 MCIS 1.0 -> NT5 Server
                // TODO: ???
				eMode = IM_UPGRADE10;
			}
		}
		else
		{
			// Key is not even there, we consider it a fresh
			// install for this service
			eMode = IM_FRESH;
		}

		// Now we should know which mode we're in, so we can compare
		// the component mode with the global install mode. If they
		// are incompatible (i.e. the registry is inconsistent/screwed
		// up), we have to do coercion and force a clean install on
		// some components.
		//
		// We use the following coercion matrix:
		// -----------------+--------------------------------------
		//     \ Component	|	Fresh		Upgrade		Maintenance
		// Global			|
		// -----------------+--------------------------------------
		//  Fresh           |	OK			Fresh		Fresh
		//  Upgrade         |	OK			OK			Fresh
		//  Maintenance     |	OK			OK			OK
		// -----------------+--------------------------------------
		//
		// If an incompatible pair is detected, the component mode
		// will be coerced to a fresh install, since we cannot trust
		// the original install anymore.
		/*
		if ((m_eInstallMode == IM_FRESH) &&
			(eMode == IM_UPGRADE || eMode == IM_MAINTENANCE))
			eMode = IM_FRESH;
		if ((m_eInstallMode == IM_UPGRADE) &&
			(eMode == IM_MAINTENANCE))
			eMode = IM_FRESH;
		*/

		// Set the component mode if the component is deemed active in
		// OC_QUERY_STATE. If the component is not active, we will
		// indicate it as so.
		m_eState[i] = eMode;
	}
	return TRUE;
}

// This determines the master install mode using the install
// mode of each component
INSTALL_MODE CInitApp::DetermineInstallMode(DWORD dwComponent)
{
	// We will use the following rules to determine the master
	// install mode:
	//
	// 1) If one or more components are in maintenance mode, then
	//    the master mode is IM_MAINTENANCE
	// 2) If (1) is not satisfied and one or more of the
	//    components are in upgrade mode, then the master mode
	//    becomes IM_UPGRADE
	// 3) If both (1) and (2) are not satisfied, the master
	//    install mode becomes IM_FRESH
	DWORD i;

	for (i = 0; i < SC_MAXSC; i++)
		if (m_fActive[dwComponent][i] && m_eState[i] == IM_MAINTENANCE)
			return(IM_MAINTENANCE);

	for (i = 0; i < SC_MAXSC; i++)
		if (m_fActive[dwComponent][i] &&
            (m_eState[i] == IM_UPGRADE || m_eState[i] == IM_UPGRADEK2 || m_eState[i] == IM_UPGRADE20 || m_eState[i] == IM_UPGRADE10))
			return(IM_UPGRADE);

	return(IM_FRESH);
}

// Init/Set m_csGuestName, m_csGuestPassword, destinations
void CInitApp::SetSetupParams()
{
    // init all 4 destinations
    m_csPathInetsrv = m_csSysDir + _T("\\inetsrv");
    m_csPathInetpub = m_csSysDrive + _T("\\Inetpub");
    m_csPathMailroot = m_csPathInetpub + _T("\\mailroot");
    m_csPathNntpFile = m_csPathInetpub + _T("\\nntpfile");
    m_csPathNntpRoot = m_csPathNntpFile + _T("\\root");
    return;
}

// Get Platform info
void CInitApp::GetPlatform()
{
    if ( m_eOS == OS_NT)
    {
        TCHAR *p = _tgetenv(_T("PROCESSOR_ARCHITECTURE"));
        if ( p ) {
            m_csPlatform = p;
        } else
            m_csPlatform = _T("x86");
    }

    return;
}

BOOL CInitApp::GetMachineStatus()
{
    if ( ( !GetMachineName() )  ||    // m_csMachineName
         ( !GetOS() )           ||    // m_fOSNT
         ( !GetOSVersion() )    ||    // NT 4.0 (Build 1381) or greater
         ( !GetOSType() )       ||    // m_eOSType = NT_SRV or NT_WKS
         ( !VerifyOSForSetup() )||    // Must be NT server v4.0 SP2 or 5.0
         ( !GetSysDirs() )      ||    // m_csWinDir. m_csSysDir
         ( !IsTCPIPInstalled()) ||    // errmsg: if NO TCPIP is installed
         ( !SetInstallMode()) )       // errmsg: if down grade the product
    {
        return FALSE;
    }

    SetSetupParams();                // Guest account, destinations

	// figure out the old nntp file and nntp root if this is an NNTP upgrade
	if (m_eState[SC_NNTP] == IM_UPGRADE10) {
		CRegKey regMachine = HKEY_LOCAL_MACHINE;
		CRegKey regNNTP(REG_NNTPPARAMETERS, regMachine);
		if ((HKEY) regNNTP) {
			CString csArtTable;
			CString csVRoot;

			if (regNNTP.QueryValue(_T("ArticleTableFile"), csArtTable) == ERROR_SUCCESS) {
				// trim off the \article.hsh from the end
				int iLastSlash = csArtTable.ReverseFind('\\');
				if (iLastSlash == -1) {
					iLastSlash = csArtTable.ReverseFind('/');
				}

				if (iLastSlash > 1) {
					theApp.m_csPathNntpFile = csArtTable.Left(iLastSlash);
				}
			}

			// BUGBUG - later on we might want to get NNTP root too.  right
			// now it isn't used for upgraded values, so we don't bother
			// we'll set it to be under nntpfile just in case it is needed
			// for something
			theApp.m_csPathNntpRoot = theApp.m_csPathNntpFile + "\\root";
		}
	}

    GetPlatform();

    return TRUE;
}

int CInitApp::MsgBox(HWND hWnd, int iID, UINT nType)
{
    if (iID == -1)
        return IDOK;

    CString csMsg;
    MyLoadString(iID, csMsg);
    return (::MessageBoxEx(NULL, (LPCTSTR)csMsg, m_csAppName, nType, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)));
}

BOOL CInitApp::InitApplication()
// Return Value:
// TRUE: application is initiliazed correctly, continue processing
// FALSE: application is missing some required parameters, like the correct OS, TCPIP, etc.
//        setup should be terminated.
{
    BOOL fReturn = FALSE;

    do {
        if (!RunningAsAdministrator())
        {
            PopupOkMessageBox(IDS_NOT_ADMINISTRATOR, _T("Error"));
            break;
        }

        // Get Machine Status:
        // m_eInstallMode(Fresh, Maintanence, Upgrade, Degrade),
        // m_eUpgradeType(PROD 2.0, PROD 3.0)

        if ( !GetMachineStatus() )
        {
            PopupOkMessageBox(m_err, _T("Error"));
            break;
        }

		if (m_eInstallMode == IM_MAINTENANCE)
			m_fEULA = TRUE;

        fReturn = TRUE;

    } while (0);

    return fReturn;
}

BOOL
CInitApp::GetLogFileFormats() {

    const DWORD cLogResourceIds = 4;

    static const DWORD dwLogResourceIds[cLogResourceIds] = {
        IDS_MTITLE_NCSA,
        IDS_MTITLE_ODBC,
        IDS_MTITLE_MSFT,
        IDS_MTITLE_XTND
    };

    const DWORD cStringLen = 512;
    TCHAR str[cStringLen];

    HINSTANCE hInstance;
    CString csLogUiPath;

    m_csLogFileFormats = "";
    csLogUiPath = m_csPathInetsrv + _T("\\logui.ocx");

    hInstance = LoadLibraryEx((LPCTSTR)csLogUiPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hInstance == NULL)
        return FALSE;

    for (DWORD i=0; i<cLogResourceIds; i++) {
        if (LoadString(hInstance, dwLogResourceIds[i], str, cStringLen) != 0) {
            if (!m_csLogFileFormats.IsEmpty())
                m_csLogFileFormats += _T(",");
            m_csLogFileFormats += str;
        }
    }

    FreeLibrary(hInstance);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\log.h ===
#include <Windows.h>
#include <io.h>
#include <stdio.h>
#include <time.h>
#include <direct.h>
#include <prsht.h>
#include <commctrl.h>
#include <regstr.h>
#include <objbase.h>
#include <winnetwk.h>
#include <tchar.h>
#include <shlobj.h>
#include <shellapi.h>

#include "stdafx.h"
#include "resource.h"

// Stuff for logfile
LPWSTR	MakeWideStrFromAnsi(LPSTR psz);
void	MakePath(LPTSTR lpPath);
void	AddPath(LPTSTR szPath, LPCTSTR szName );
CString AddPath(CString szPath, LPCTSTR szName );

// Extra debugging thing.
int CallExternalFunction(LPCTSTR szName);


class MyLogFile
{
protected:
	// for our log file
	LPSTORAGE   m_pIStorage;
	LPSTREAM	m_pIStream;
	TCHAR		m_szLogFileName[MAX_PATH];
	BOOL        m_bDisplayTimeStamp;
	BOOL        m_bDisplayPreLineInfo;

	// logfile2
	HANDLE  m_hFile;


	int ConvertIStreamToFile(LPSTORAGE *pIStorage, LPSTREAM *pIStream);

public:
    TCHAR		m_szLogFileName_Full[MAX_PATH];

    MyLogFile();
    ~MyLogFile();

	TCHAR		m_szLogPreLineInfo[100];
	TCHAR		m_szLogPreLineInfo2[100];
	
	int  LogFileCreate(TCHAR * lpLogFileName);
	int  LogFileClose();

	void LogFileTimeStamp();
	void LogFileWrite(TCHAR * pszFormatString, ...);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\helper.cpp ===
#include "stdafx.h"
#include <loadperf.h>
#include <aclapi.h>
#include "setupapi.h"
#include "log.h"
#include "iiscnfg.h"
#include "iadmw.h"
#include "mdkey.h"

#define DBL_UNDEFINED   ((DWORD)-1)
DWORD gDebugLevel = DBL_UNDEFINED;
extern MyLogFile g_MyLogFile;

// Forward references
DWORD SetAdminACL_wrap(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount, BOOL bDisplayMsgOnErrFlag);
DWORD WriteSDtoMetaBase(PSECURITY_DESCRIPTOR outpSD, LPCTSTR szKeyPath);
DWORD GetPrincipalSID (LPTSTR Principal, PSID *Sid, BOOL *pbWellKnownSID);
DWORD SetAdminACL(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount);

void DebugOutputFile(TCHAR* pszTemp)
{
    //
    //  NT5 doesn't want us to put all the debug string
    //  in debugger.  So we skip them based on a regkey.
    //  See GetDebugLevel().
    //  Todo: Log strings to a logfile!!!
    //  See IIS log.h, log.cpp for examples!
    //
    g_MyLogFile.LogFileWrite(pszTemp);
    if (gDebugLevel == DBL_UNDEFINED) {gDebugLevel = GetDebugLevel();}
    if (gDebugLevel)
    {
	    OutputDebugString(pszTemp);
    }

}

void DebugOutput(LPCTSTR szFormat, ...)
{
    va_list marker;
	TCHAR   szTemp[1024];

    // Encompass this whole iisdebugout deal in a try-catch.
    // not too good to have this one access violating.
    // when trying to produce a debugoutput!
    __try
    {
        va_start( marker, szFormat );
        vswprintf(szTemp, szFormat, marker );
	    lstrcat(szTemp, _T("\n"));
        va_end( marker );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TCHAR szErrorString[100];
        _stprintf(szErrorString, _T("\r\n\r\nException Caught in DebugOutput().  GetExceptionCode()=0x%x.\r\n\r\n"), GetExceptionCode());
        OutputDebugString(szErrorString);
        g_MyLogFile.LogFileWrite(szErrorString);
    }

    // output to log file and the screen.
    DebugOutputFile(szTemp);

    return;
}

// This function requires inputs like this:
//   iisDebugOutSafeParams2("this %1!s! is %2!s! and has %3!d! args", "function", "kool", 3);
//   you must specify the %1 deals.  this is so that
//   if something like this is passed in "this %SYSTEMROOT% %1!s!", it will put the string into %1 not %s!
void DebugOutputSafe(TCHAR *pszfmt, ...)
{
    // The count of parameters do not match
    va_list va;
    TCHAR *pszFullErrMsg = NULL;

    va_start(va, pszfmt);
    FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                   (LPCVOID) pszfmt,
                   0,
                   0,
                   (LPTSTR) &pszFullErrMsg,
                   0,
                   &va);
    if (pszFullErrMsg)
    {
        // output to log file and the screen.
        DebugOutputFile(pszFullErrMsg);
    }
    va_end(va);

    if (pszFullErrMsg) {LocalFree(pszFullErrMsg);pszFullErrMsg=NULL;}
    return;
}


BOOL IsFileExist(LPCTSTR szFile)
{
    return (GetFileAttributes(szFile) != 0xFFFFFFFF);
}

BOOL InetDeleteFile(LPCTSTR szFileName)
{
    // if file exists but DeleteFile() fails
    if (IsFileExist(szFileName) && !(::DeleteFile(szFileName)))
	{
        // if we cannot delete it, then move delay until reboot
        // move it to top level dir on the same drive, and mark it as hidden
        // Note: MoveFileEx() works only on the same drive if dealing with file-in-use
        TCHAR TmpName[_MAX_PATH];
        TCHAR csTmpPath[5] = _T("C:\\.");
        csTmpPath[0] = *szFileName;
        if ( GetTempFileName( (LPCTSTR)csTmpPath, _T("INT"), 0, TmpName ) == 0 ||
            !MoveFileEx( szFileName, TmpName, MOVEFILE_REPLACE_EXISTING|MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH ) ) {
            return FALSE;
        }
        MoveFileEx( TmpName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT );
        SetFileAttributes(TmpName, FILE_ATTRIBUTE_HIDDEN);
    }

    return TRUE;
}

// Given a fullpathname of a directory, remove any empty dirs under it including itself

BOOL RecRemoveEmptyDir(LPCTSTR szName)
{
	DWORD retCode;
	BOOL fRemoveDir = TRUE;
	WIN32_FIND_DATA FindFileData;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	TCHAR szSubDir[_MAX_PATH] = _T("");
	TCHAR szDirName[_MAX_PATH] = _T("");

	retCode = GetFileAttributes(szName);

	if (retCode == 0xFFFFFFFF || !(retCode & FILE_ATTRIBUTE_DIRECTORY))
		return FALSE;

	_stprintf(szDirName, _T("%s\\*"), szName);
	hFile = FindFirstFile(szDirName, &FindFileData);

	if (hFile != INVALID_HANDLE_VALUE)
	{
		do
		{
			if (_tcsicmp(FindFileData.cFileName, _T(".")) != 0 &&
						_tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
			{
				if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
						_stprintf(szSubDir, _T("%s\\%s"), szName, FindFileData.cFileName);
						fRemoveDir = RecRemoveEmptyDir(szSubDir) && fRemoveDir;
				}
				else
				{
					CString csFileName = FindFileData.cFileName;
					CString csPrefix = csFileName.Left(3);
					CString csSuffix = csFileName.Right(4);
					if (_tcsicmp(csPrefix, _T("INT")) == 0 &&
						_tcsicmp(csSuffix, _T(".tmp")) == 0 )
					{
						// this is an INT*.tmp created by IIS
						_stprintf(szSubDir, _T("%s\\%s"), szName, FindFileData.cFileName);
						if (!::DeleteFile(szSubDir))
							fRemoveDir = FALSE; // this dir is not empty
					} else
						fRemoveDir = FALSE; // it is a file, this Dir is not empty
				}
			}

			if (!FindNextFile(hFile, &FindFileData))
			{
					FindClose(hFile);
					break;
			}
		} while (TRUE);
	}

	if (fRemoveDir)
		return( ::RemoveDirectory(szName) );
	else
		return FALSE;

}

// Given a fullpathname of a directory, remove the directory node

BOOL RecRemoveDir(LPCTSTR szName)
{
    DWORD retCode;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szSubDir[_MAX_PATH] = _T("");
    TCHAR szDirName[_MAX_PATH] = _T("");

    retCode = GetFileAttributes(szName);

    if (retCode == 0xFFFFFFFF)
        return FALSE;

    if (!(retCode & FILE_ATTRIBUTE_DIRECTORY)) {
        InetDeleteFile(szName);
        return TRUE;
    }

    _stprintf(szDirName, _T("%s\\*"), szName);
    hFile = FindFirstFile(szDirName, &FindFileData);

    if (hFile != INVALID_HANDLE_VALUE) {
        do {
            if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 &&
                 _tcsicmp(FindFileData.cFileName, _T("..")) != 0 ) {
                _stprintf(szSubDir, _T("%s\\%s"), szName, FindFileData.cFileName);
                RecRemoveDir(szSubDir);
            }

            if ( !FindNextFile(hFile, &FindFileData) ) {
                FindClose(hFile);
                break;
            }
        } while (TRUE);
    }

    return( ::RemoveDirectory(szName) );
}

INT InstallPerformance(
                CString nlsRegPerf,
                CString nlsDll,
                CString nlsOpen,
                CString nlsClose,
                CString nlsCollect )
{
    INT err = NERR_Success;

    if (theApp.m_eOS != OS_W95) {
        CRegKey regPerf( nlsRegPerf, HKEY_LOCAL_MACHINE );
        if (regPerf)
        {
            regPerf.SetValue(_T("Library"), nlsDll );
            regPerf.SetValue(_T("Open"),    nlsOpen );
            regPerf.SetValue(_T("Close"),   nlsClose );
            regPerf.SetValue(_T("Collect"), nlsCollect );
        }
    }

    return(err);
}
//
// Add eventlog to the registry
//

INT AddEventLog(CString nlsService, CString nlsMsgFile, DWORD dwType)
{
    INT err = NERR_Success;
    CString nlsLog = REG_EVENTLOG;
    nlsLog += _T("\\");
    nlsLog += nlsService;

    CRegKey regService( nlsLog, HKEY_LOCAL_MACHINE );
    if ( regService ) {
        regService.SetValue( _T("EventMessageFile"), nlsMsgFile, TRUE );
        regService.SetValue( _T("TypesSupported"), dwType );
    }
    return(err);
}

//
// Remove eventlog from the registry
//

INT RemoveEventLog( CString nlsService )
{
    INT err = NERR_Success;
    CString nlsLog = REG_EVENTLOG;

    CRegKey regService( HKEY_LOCAL_MACHINE, nlsLog );
    if ( regService )
        regService.DeleteTree( nlsService );
    return(err);
}

//
// Install SNMP agent to the registry
//

INT InstallAgent( CString nlsName, CString nlsPath )
{
    INT err = NERR_Success;
    do
    {
        CString nlsSnmpParam = REG_SNMPPARAMETERS;
        CRegKey regSnmpParam( HKEY_LOCAL_MACHINE, nlsSnmpParam );
        if ( regSnmpParam == (HKEY)NULL )
            break;

        CString nlsSoftwareMSFT = REG_SOFTWAREMSFT;
        CRegKey regSoftwareMSFT( HKEY_LOCAL_MACHINE, nlsSoftwareMSFT );
        if ( (HKEY) NULL == regSoftwareMSFT )
            break;

        // add agent key
        CRegKey regAgent( nlsName, regSoftwareMSFT );
        if ( (HKEY) NULL == regAgent )
            break;

        CString nlsCurVersion = REG_CURVERSION;
        CRegKey regAgentCurVersion( nlsCurVersion, regAgent );
        if ((HKEY) NULL == regAgentCurVersion )
            break;

        regAgentCurVersion.SetValue(_T("Pathname"), nlsPath );

        CRegKey regAgentParam( nlsName, regSnmpParam );
        if ((HKEY) NULL == regAgentParam )
            break;

        CString nlsSnmpExt = REG_SNMPEXTAGENT;
        CRegKey regSnmpExt( nlsSnmpExt, HKEY_LOCAL_MACHINE );
        if ((HKEY) NULL == regSnmpExt )
            break;

        // find the first available number slot
        for ( INT i=0; ;i++ )
        {
            CString nlsPos;
            nlsPos.Format( _T("%d"),i);
            CString nlsValue;

            if ( regSnmpExt.QueryValue( nlsPos, nlsValue ) != NERR_Success )
            {
                // okay, an empty spot
                nlsValue.Format(_T("%s\\%s\\%s"),
                    REG_SOFTWAREMSFT,
                    (LPCTSTR)nlsName,
                    REG_CURVERSION );

                regSnmpExt.SetValue( nlsPos, nlsValue );
                break;
            } else
            {
                if ( nlsValue.Find( nlsName) != (-1))
                {
                    break;
                }
            }
        }

    } while (FALSE);
    return(err);
}

//
// Remove an SNMP agent from the registry
//

INT RemoveAgent( CString nlsServiceName )
{
    INT err = NERR_Success;
    do
    {
        CString nlsSoftwareAgent = REG_SOFTWAREMSFT;

        CRegKey regSoftwareAgent( HKEY_LOCAL_MACHINE, nlsSoftwareAgent );
        if ((HKEY)NULL == regSoftwareAgent )
            break;
        regSoftwareAgent.DeleteTree( nlsServiceName );

        CString nlsSnmpParam = REG_SNMPPARAMETERS;

        CRegKey regSnmpParam( HKEY_LOCAL_MACHINE, nlsSnmpParam );
        if ((HKEY) NULL == regSnmpParam )
            break;
        regSnmpParam.DeleteTree( nlsServiceName );

        CString nlsSnmpExt = REG_SNMPEXTAGENT;
        CRegKey regSnmpExt( HKEY_LOCAL_MACHINE, nlsSnmpExt );
        if ((HKEY) NULL == regSnmpExt )
            break;

        CRegValueIter enumSnmpExt( regSnmpExt );

        CString strName;
        DWORD dwType;
        CString csServiceName;

        csServiceName = _T("\\") + nlsServiceName;
        csServiceName += _T("\\");

        while ( enumSnmpExt.Next( &strName, &dwType ) == NERR_Success )
        {
            CString nlsValue;

            regSnmpExt.QueryValue( strName, nlsValue );

            if ( nlsValue.Find( csServiceName ) != (-1))
            {
                // found it
                regSnmpExt.DeleteValue( (LPCTSTR)strName );
                break;
            }
        }
    } while (FALSE);
    return(err);
}

LONG lodctr(LPCTSTR lpszIniFile)
{
    CString csCmdLine = _T("lodctr ");
    csCmdLine += theApp.m_csSysDir;
    csCmdLine += _T("\\");
    csCmdLine += lpszIniFile;

    return (LONG)(LoadPerfCounterTextStrings((LPTSTR)(LPCTSTR)csCmdLine, TRUE));
}

LONG unlodctr(LPCTSTR lpszDriver)
{
    CString csCmdLine = _T("unlodctr ");
    csCmdLine += lpszDriver;

    return (LONG)(UnloadPerfCounterTextStrings((LPTSTR)(LPCTSTR)csCmdLine, TRUE));
}

//
// Given a directory path, set everyone full control security
//

BOOL SetEveryoneACL (CString &str, BOOL fAddAnonymousLogon)
{
    DWORD dwRes, dwDisposition;
    PSID pEveryoneSID = NULL;
    PSID pAnonymousLogonSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    const int cMaxExplicitAccess = 4;
    EXPLICIT_ACCESS ea[cMaxExplicitAccess];
    int cExplicitAccess = 0;
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    SECURITY_ATTRIBUTES sa;
    LONG lRes;
    BOOL fRet = FALSE;

    // Create a security descriptor for the files

    // Create a well-known SID for the Everyone group.

    if(! AllocateAndInitializeSid( &SIDAuthWorld, 1,
                 SECURITY_WORLD_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &pEveryoneSID) ) 
    {
        goto Exit;
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow Everyone read access to the key.

    ZeroMemory(&ea, sizeof(ea));
    ea[0].grfAccessPermissions = WRITE_DAC | WRITE_OWNER;
    ea[0].grfAccessMode = DENY_ACCESS;
    ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea[0].Trustee.ptstrName  = (LPTSTR) pEveryoneSID;

    ea[1].grfAccessPermissions = GENERIC_ALL;
    ea[1].grfAccessMode = SET_ACCESS;
    ea[1].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea[1].Trustee.ptstrName  = (LPTSTR) pEveryoneSID;

    cExplicitAccess = 2;

	if (fAddAnonymousLogon) {
		
    	if(! AllocateAndInitializeSid( &SIDAuthNT, 1,
                 SECURITY_ANONYMOUS_LOGON_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &pAnonymousLogonSID) ) 
		{
			goto Exit;
		}

		ea[2].grfAccessPermissions = WRITE_DAC | WRITE_OWNER;
		ea[2].grfAccessMode = DENY_ACCESS;
		ea[2].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
		ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
		ea[2].Trustee.TrusteeType = TRUSTEE_IS_USER;
		ea[2].Trustee.ptstrName  = (LPTSTR) pAnonymousLogonSID;

		ea[3].grfAccessPermissions = GENERIC_ALL;
		ea[3].grfAccessMode = SET_ACCESS;
		ea[3].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
		ea[3].Trustee.TrusteeForm = TRUSTEE_IS_SID;
		ea[3].Trustee.TrusteeType = TRUSTEE_IS_USER;
		ea[3].Trustee.ptstrName  = (LPTSTR) pAnonymousLogonSID;
		cExplicitAccess = 4;
	}


    // Create a new ACL that contains the new ACEs.

    dwRes = SetEntriesInAcl(cExplicitAccess, ea, NULL, &pACL);
    if (ERROR_SUCCESS != dwRes) 
    {
        goto Exit;
    }

    // Initialize a security descriptor.  
 
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, 
                         SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (pSD == NULL) 
    {
        goto Exit; 
    }
 
    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) 
    {
        goto Exit; 
    }
 
    // Add the ACL to the security descriptor. 
 
    if (!SetSecurityDescriptorDacl(pSD, 
        TRUE,     // fDaclPresent flag   
        pACL, 
        FALSE))   // not a default DACL 
    {
        goto Exit; 
    }

    // Initialize a security attributes structure.

    sa.nLength = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = FALSE;

    fRet = SetFileSecurity (str, DACL_SECURITY_INFORMATION, pSD);

Exit:
	if (pEveryoneSID) 
		FreeSid(pEveryoneSID);
	if (pAnonymousLogonSID)
		FreeSid(pAnonymousLogonSID);
    if (pACL) 
        LocalFree(pACL);
    if (pSD) 
        LocalFree(pSD);
    return fRet;

}

//
// Given a directory path, this subroutine will create the direct layer by layer
//

BOOL CreateLayerDirectory( CString &str )
{
    BOOL fReturn = TRUE;

    do
    {
        INT index=0;
        INT iLength = str.GetLength();

        // first find the index for the first directory
        if ( iLength > 2 )
        {
            if ( str[1] == _T(':'))
            {
                // assume the first character is driver letter
                if ( str[2] == _T('\\'))
                {
                    index = 2;
                } else
                {
                    index = 1;
                }
            } else if ( str[0] == _T('\\'))
            {
                if ( str[1] == _T('\\'))
                {
                    BOOL fFound = FALSE;
                    INT i;
                    INT nNum = 0;
                    // unc name
                    for (i = 2; i < iLength; i++ )
                    {
                        if ( str[i]==_T('\\'))
                        {
                            // find it
                            nNum ++;
                            if ( nNum == 2 )
                            {
                                fFound = TRUE;
                                break;
                            }
                        }
                    }
                    if ( fFound )
                    {
                        index = i;
                    } else
                    {
                        // bad name
                        break;
                    }
                } else
                {
                    index = 1;
                }
            }
        } else if ( str[0] == _T('\\'))
        {
            index = 0;
        }

        // okay ... build directory
        do
        {
            // find next one
            do
            {
                if ( index < ( iLength - 1))
                {
                    index ++;
                } else
                {
                    break;
                }
            } while ( str[index] != _T('\\'));


            TCHAR szCurrentDir[MAX_PATH+1];

            GetCurrentDirectory( MAX_PATH+1, szCurrentDir );

            if ( !SetCurrentDirectory( str.Left( index + 1 )))
            {
                if (( fReturn = CreateDirectory( str.Left( index + 1 ), NULL )) != TRUE )
                {
                    break;
                }
            }

            SetCurrentDirectory( szCurrentDir );

            if ( index >= ( iLength - 1 ))
            {
                fReturn = TRUE;
                break;
            }
        } while ( TRUE );
    } while (FALSE);

    return(fReturn);
}

//
// Used when the strings are passed in.
//
int MyMessageBox(HWND hWnd, LPCTSTR lpszTheMessage, LPCTSTR lpszTheTitle, UINT style)
{
    int iReturn = IDOK;

    // make sure it goes to DebugOutput
    DebugOutput(_T("MyMessageBox: Title:%s, Msg:%s"), lpszTheTitle, lpszTheMessage);

    if (style & MB_ABORTRETRYIGNORE)
    {
        iReturn = IDIGNORE;
    }

    // Check global variable to see if we can even display the popup!
    if (theApp.m_bAllowMessageBoxPopups)
    {
        // Suppress the message if unattened or remove all
        // Who cares the user can't do anything about it anyway?
        // no use upsetting them, we do log to the OCM though
        //
        //if (! theApp.m_fUnattended || theApp.m_dwSetupMode != SETUPMODE_REMOVEALL)
        {
            iReturn = ::MessageBox(hWnd, lpszTheMessage, lpszTheTitle, style | MB_SETFOREGROUND);
        }
    }
    return iReturn;
}

void GetErrorMsg(int errCode, LPCTSTR szExtraMsg)
{
	TCHAR pMsg[_MAX_PATH];

	FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, errCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
		pMsg, _MAX_PATH, NULL);
    lstrcat(pMsg, szExtraMsg);
    MyMessageBox(NULL, pMsg, _T(""), MB_OK | MB_SETFOREGROUND);
    return;
}

DWORD GetDebugLevel(void)
{
    DWORD rc;
    DWORD err;
    DWORD size;
    DWORD type;
    HKEY  hkey;
    err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\microsoft\\windows\\currentversion\\setup"), &hkey);
    if (err != ERROR_SUCCESS) {return 0;}
    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,_T("OC Manager Debug Level"),0,&type,(LPBYTE)&rc,&size);
    if (err != ERROR_SUCCESS || type != REG_DWORD) {rc = 0;}
    RegCloseKey(hkey);
    return rc;
}

void MyLoadString(int nID, CString &csResult)
{
    TCHAR buf[MAX_STR_LEN];

    if (LoadString(theApp.m_hDllHandle, nID, buf, MAX_STR_LEN))
        csResult = buf;

    return;
}

static TCHAR six2pr[64] =
{
        _T('A'), _T('B'), _T('C'), _T('D'), _T('E'), _T('F'), _T('G'), _T('H'), _T('I'), _T('J'), _T('K'), _T('L'), _T('M'),
        _T('N'), _T('O'), _T('P'), _T('Q'), _T('R'), _T('S'), _T('T'), _T('U'), _T('V'), _T('W'), _T('X'), _T('Y'), _T('Z'),
        _T('a'), _T('b'), _T('c'), _T('d'), _T('e'), _T('f'), _T('g'), _T('h'), _T('i'), _T('j'), _T('k'), _T('l'), _T('m'),
        _T('n'), _T('o'), _T('p'), _T('q'), _T('r'), _T('s'), _T('t'), _T('u'), _T('v'), _T('w'), _T('x'), _T('y'), _T('z'),
        _T('0'), _T('1'), _T('2'), _T('3'), _T('4'), _T('5'), _T('6'), _T('7'), _T('8'), _T('9'), _T('%'), _T('_')
};
typedef void (*P_SslGenerateRandomBits)( PUCHAR pRandomData, LONG size );
P_SslGenerateRandomBits ProcSslGenerateRandomBits = NULL;

int GetRandomNum()
{
    int RandomNum;
    UCHAR cRandomByte;

    if ( ProcSslGenerateRandomBits != NULL )
    {
        (*ProcSslGenerateRandomBits)( &cRandomByte, 1 );
        RandomNum = cRandomByte;
    } else
    {
        RandomNum = rand();
    }

    return(RandomNum);
}

void MakePath(LPTSTR lpPath)
{
   LPTSTR  lpTmp;
   lpTmp = CharPrev( lpPath, lpPath + _tcslen(lpPath));

   // chop filename off
   while ( (lpTmp > lpPath) && *lpTmp && (*lpTmp != '\\') )
      lpTmp = CharPrev( lpPath, lpTmp );

   if ( *CharPrev( lpPath, lpTmp ) != ':' )
       *lpTmp = '\0';
   else
       *CharNext(lpTmp) = '\0';
   return;
}

void AddPath(LPTSTR szPath, LPCTSTR szName )
{
        LPTSTR p = szPath;
    ASSERT(szPath);
    ASSERT(szName);

    // Find end of the string
    while (*p){p = _tcsinc(p);}

        // If no trailing backslash then add one
    if (*(_tcsdec(szPath, p)) != _T('\\'))
                {_tcscat(szPath, _T("\\"));}

        // if there are spaces precluding szName, then skip
    while ( *szName == ' ' ) szName = _tcsinc(szName);;

        // Add new name to existing path string
        _tcscat(szPath, szName);
}

CString AddPath(CString szPath, LPCTSTR szName )
{
    TCHAR szPathCopy[MAX_PATH] = _T("");
    _tcscpy(szPathCopy,szPath);
        LPTSTR p = szPathCopy;
    ASSERT(szPathCopy);
    ASSERT(szName);

    // Find end of the string
    while (*p){p = _tcsinc(p);}

        // If no trailing backslash then add one
    if (*(_tcsdec(szPathCopy, p)) != _T('\\'))
                {_tcscat(szPathCopy, _T("\\"));}

        // if there are spaces precluding szName, then skip
    while ( *szName == _T(' ') ) szName = _tcsinc(szName);;

    // make sure that the szName
    // does not look like this "\filename"
    CString csTempString = szName;
    if (_tcsicmp(csTempString.Left(1), _T("\\")) == 0)
    {
        csTempString = csTempString.Right( csTempString.GetLength() - 1);
    }

        // Add new name to existing path string
        _tcscat(szPathCopy, csTempString);

    return szPathCopy;
    //szPath = szPathCopy;
}

// GetPrincipalSID is from \nt\private\inet\iis\ui\setup\osrc\dcomperm.cpp

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{
    DebugOutput(_T("GetPrincipalSID:Principal=%s\n"), Principal);

    DWORD returnValue=ERROR_SUCCESS;
    CString csPrincipal = Principal;
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));
    csPrincipal.MakeLower();
    if ( csPrincipal.Find(_T("administrators")) != -1 ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if (csPrincipal.Find(_T("system")) != -1) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    } else if (csPrincipal.Find(_T("interactive")) != -1) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if (csPrincipal.Find(_T("everyone")) != -1) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority,
                                    (BYTE)Count,
		                            dwRID[0],
		                            dwRID[1],
		                            dwRID[2],
		                            dwRID[3],
		                            dwRID[4],
		                            dwRID[5],
		                            dwRID[6],
		                            dwRID[7],
                                    Sid) ) {
            returnValue = GetLastError();
        }
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();

        if (returnValue == ERROR_INSUFFICIENT_BUFFER) {
            *Sid = (PSID) malloc (sidSize);
            refDomainSize = 255;

            if (!LookupAccountName (NULL,
                                    Principal,
                                    *Sid,
                                    &sidSize,
                                    refDomain,
                                    &refDomainSize,
                                    &snu))
            {
                returnValue = GetLastError();
            } else {
                returnValue = ERROR_SUCCESS;
            }
        }
    }

    return returnValue;
}


// SetAdminACL taken from \nt\private\inet\iis\ui\setup\osrc\helper.cpp

DWORD SetAdminACL(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount)
{
    DebugOutputSafe(_T("SetAdminACL(%1!s!) Start.\n"), szKeyPath);

    int iErr=0;
    DWORD dwErr=ERROR_SUCCESS;

    BOOL b = FALSE;
    DWORD dwLength = 0;

    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR outpSD = NULL;
    DWORD cboutpSD = 0;
    PACL pACLNew = NULL;
    DWORD cbACL = 0;
    PSID pAdminsSID = NULL, pEveryoneSID = NULL;
    BOOL bWellKnownSID = FALSE;

    // Initialize a new security descriptor
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (NULL == pSD) {
    	dwErr = ERROR_NOT_ENOUGH_MEMORY;
    	DebugOutput(_T("LocalAlloc failed"));
    	goto Cleanup;
    }

    iErr = InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
    if (iErr == 0)
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:InitializeSecurityDescriptor FAILED.  GetLastError()= 0x%x\n"), dwErr);
        goto Cleanup;
    }

    // Get Local Admins Sid
    dwErr = GetPrincipalSID (_T("Administrators"), &pAdminsSID, &bWellKnownSID);
    if (dwErr != ERROR_SUCCESS)
    {
        DebugOutput(_T("SetAdminACL:GetPrincipalSID(Administrators) FAILED.  GetLastError()= 0x%x\n"), dwErr);
        goto Cleanup;
    }

    // Get everyone Sid
    dwErr = GetPrincipalSID (_T("Everyone"), &pEveryoneSID, &bWellKnownSID);
    if (dwErr != ERROR_SUCCESS)
    {
        DebugOutput(_T("SetAdminACL:GetPrincipalSID(Everyone) FAILED.  GetLastError()= 0x%x\n"), dwErr);
        goto Cleanup;
    }

    // Initialize a new ACL, which only contains 2 aaace
    cbACL = sizeof(ACL) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminsSID) - sizeof(DWORD)) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pEveryoneSID) - sizeof(DWORD)) ;
    pACLNew = (PACL) LocalAlloc(LPTR, cbACL);
    if ( !pACLNew )
    {
        dwErr=ERROR_NOT_ENOUGH_MEMORY;
        DebugOutput(_T("SetAdminACL:pACLNew LocalAlloc(LPTR,  FAILED. size = %u GetLastError()= 0x%x\n"), cbACL, dwErr);
        goto Cleanup;
    }

    if (!InitializeAcl(pACLNew, cbACL, ACL_REVISION))
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:InitializeAcl FAILED.  GetLastError()= 0x%x\n"), dwErr);
        goto Cleanup;
    }

    if (!AddAccessAllowedAce(pACLNew,ACL_REVISION,(MD_ACR_READ |MD_ACR_WRITE |MD_ACR_RESTRICTED_WRITE |MD_ACR_UNSECURE_PROPS_READ |MD_ACR_ENUM_KEYS |MD_ACR_WRITE_DAC),pAdminsSID))
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:AddAccessAllowedAce(pAdminsSID) FAILED.  GetLastError()= 0x%x\n"), dwErr);
        goto Cleanup;
    }
    if (!AddAccessAllowedAce(pACLNew,ACL_REVISION,dwAccessForEveryoneAccount,pEveryoneSID))
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:AddAccessAllowedAce(pEveryoneSID) FAILED.  GetLastError()= 0x%x\n"), dwErr);
        goto Cleanup;
    }

    // Add the ACL to the security descriptor
    b = SetSecurityDescriptorDacl(pSD, TRUE, pACLNew, FALSE);
    if (!b)
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:SetSecurityDescriptorDacl(pACLNew) FAILED.  GetLastError()= 0x%x\n"), dwErr);
        goto Cleanup;
    }
    b = SetSecurityDescriptorOwner(pSD, pAdminsSID, TRUE);
    if (!b)
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:SetSecurityDescriptorOwner(pAdminsSID) FAILED.  GetLastError()= 0x%x\n"), dwErr);
        goto Cleanup;
    }
    b = SetSecurityDescriptorGroup(pSD, pAdminsSID, TRUE);
    if (!b)
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:SetSecurityDescriptorGroup(pAdminsSID) FAILED.  GetLastError()= 0x%x\n"), dwErr);
        goto Cleanup;
    }

    // Security descriptor blob must be self relative
    b = MakeSelfRelativeSD(pSD, outpSD, &cboutpSD);
    if (!b && (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:MakeSelfRelativeSD FAILED.  GetLastError()= 0x%x\n"), dwErr);
        goto Cleanup;
    }

    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);
    if ( !outpSD )
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:GlobalAlloc FAILED. cboutpSD = %u  GetLastError()= 0x%x\n"), cboutpSD, dwErr);
        goto Cleanup;
    }

    b = MakeSelfRelativeSD( pSD, outpSD, &cboutpSD );
    if (!b)
    {
        dwErr=GetLastError();
        DebugOutput(_T("SetAdminACL:MakeSelfRelativeSD() FAILED. cboutpSD = %u GetLastError()= 0x%x\n"),cboutpSD, dwErr);
        goto Cleanup;
    }

    // Apply the new security descriptor to the metabase
    DebugOutput(_T("SetAdminACL:Write the new security descriptor to the Metabase. Start."));
    DebugOutput(_T("SetAdminACL:  At this point we have already been able to write basic entries to the metabase, so..."));
    DebugOutput(_T("SetAdminACL:  If this fails then there is a problem with setting up encryption for the metabase (RsaBase.dll)."));
    dwErr = WriteSDtoMetaBase(outpSD, szKeyPath);
    DebugOutput(_T("SetAdminACL:Write the new security descriptor to the Metabase.   End."));

Cleanup:
  // both of Administrators and Everyone are well-known SIDs, use FreeSid() to free them.
  if (outpSD){GlobalFree(outpSD);}
  if (pAdminsSID){FreeSid(pAdminsSID);}
  if (pEveryoneSID){FreeSid(pEveryoneSID);}
  if (pSD){LocalFree((HLOCAL) pSD);}
  if (pACLNew){LocalFree((HLOCAL) pACLNew);}
  DebugOutputSafe(_T("SetAdminACL(%1!s!)  End.\n"), szKeyPath);
  return (dwErr);
}


DWORD SetAdminACL_wrap(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount, BOOL bDisplayMsgOnErrFlag)
{
	int bFinishedFlag = FALSE;
	UINT iMsg = NULL;
	DWORD dwReturn = ERROR_SUCCESS;

	// LogHeapState(FALSE, __FILE__, __LINE__);

	do
	{
		dwReturn = SetAdminACL(szKeyPath, dwAccessForEveryoneAccount);
		// LogHeapState(FALSE, __FILE__, __LINE__);
		if (FAILED(dwReturn))
		{
		  // SetErrorFlag(__FILE__, __LINE__);
			if (bDisplayMsgOnErrFlag == TRUE)
			  {
			    CString msg;
			    MyLoadString(IDS_RETRY, msg);
                iMsg = MyMessageBox( NULL, msg, _T(""), MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
				switch ( iMsg )
				{
				case IDIGNORE:
					dwReturn = ERROR_SUCCESS;
					goto SetAdminACL_wrap_Exit;
				case IDABORT:
					dwReturn = ERROR_OPERATION_ABORTED;
					goto SetAdminACL_wrap_Exit;
				case IDRETRY:
					break;
				default:
					break;
				}
			}
			else
			{
				// return whatever err happened
				goto SetAdminACL_wrap_Exit;
			}
		}
                                    else
                                    {
                                                      break;
                                    }
	} while ( FAILED(dwReturn) );

SetAdminACL_wrap_Exit:
	return dwReturn;
}
DWORD WriteSDtoMetaBase(PSECURITY_DESCRIPTOR outpSD, LPCTSTR szKeyPath)
{
    DebugOutput(_T("WriteSDtoMetaBase: Start"));
    DWORD dwReturn = E_FAIL;
    DWORD dwLength = 0;
    CMDKey cmdKey;

    if (!outpSD)
    {
        dwReturn = ERROR_INVALID_SECURITY_DESCR;
        goto WriteSDtoMetaBase_Exit;
    }

    // Apply the new security descriptor to the metabase
    dwLength = GetSecurityDescriptorLength(outpSD);

    // open the metabase
    // stick it into the metabase.  warning those hoses a lot because
    // it uses encryption.  rsabase.dll
    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, szKeyPath);
    if ( (METADATA_HANDLE)cmdKey )
    {
        DebugOutput(_T("WriteSDtoMetaBase:cmdKey():SetData(MD_ADMIN_ACL), dwdata = %u; outpSD = %p, Start\n"), dwLength, outpSD );

        dwReturn = cmdKey.SetData(MD_ADMIN_ACL,METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE,IIS_MD_UT_SERVER,BINARY_METADATA,dwLength,(LPBYTE)outpSD);
        if (FAILED(dwReturn))
        {
	  // SetErrorFlag(__FILE__, __LINE__);
            DebugOutput(_T("WriteSDtoMetaBase:cmdKey():SetData(MD_ADMIN_ACL), FAILED. Code=0x%x.  End.\n"), dwReturn);
        }
        else
        {
            dwReturn = ERROR_SUCCESS;
            DebugOutput(_T("WriteSDtoMetaBase:cmdKey():SetData(MD_ADMIN_ACL), Success.  End.\n"));
        }
        cmdKey.Close();
    }
    else
    {
        dwReturn = E_FAIL;
    }

WriteSDtoMetaBase_Exit:
    DebugOutput(_T("WriteSDtoMetaBase:   End.  Return=0x%x"), dwReturn);
    return dwReturn;
}

void SetupSetStringId_Wrapper(HINF hInf)
{
    // Note, we only care about the intel variants since they're the only ones
    // special cased in the .INFs
    // Not anymore, we handles the [SourceDisksName] section as well
    SYSTEM_INFO SystemInfo;
    GetSystemInfo( &SystemInfo );
    TCHAR szSourceCatOSName[20];

    _tcscpy(szSourceCatOSName, _T("\\i386"));
    switch(SystemInfo.wProcessorArchitecture) {
    case PROCESSOR_ARCHITECTURE_AMD64:
        _tcscpy(szSourceCatOSName, _T("\\AMD64"));
        break;

	case PROCESSOR_ARCHITECTURE_IA64:
    	_tcscpy(szSourceCatOSName, _T("\\IA64"));
    	break;

    case PROCESSOR_ARCHITECTURE_INTEL:
        if (IsNEC_98) {
            _tcscpy(szSourceCatOSName, _T("\\Nec98"));
        }
        break;

    default:
        break;
    }

	// 34000 is no longer used
    //SetupSetDirectoryIdEx(hInf, 34000, szSourceCatOSName, SETDIRID_NOT_FULL_PATH, 0, 0);
    SetupSetDirectoryIdEx(hInf, 34001, szSourceCatOSName, SETDIRID_NOT_FULL_PATH, 0, 0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\initapp.h ===
#ifndef _INITAPP_H_
#define _INITAPP_H_

typedef PVOID HINF;

class CInitApp : public CObject
{
public:
        CInitApp();
        ~CInitApp();
public:
    int m_err;
    HINSTANCE m_hDllHandle;
    HINF m_hInfHandle[MC_MAXMC];

	BOOL m_fIsMcis;				// TRUE if doing MCIS setup, FALSE for K2
								// Note: this is conditionally-compiled, not
								// run time.
	BOOL m_fK2SmtpInstalled;
	BOOL m_fSetModeToAddRemove;

    // Product name and application name
    CString m_csProdName;       // IIS or PWS
    CString m_csAppName;        // equal to m_csProdName + "Setup"
    CString m_csGroupName;      // Start menu Program Group Name

    // machine status
    CString m_csMachineName;
	CString m_csCleanMachineName;

    CString m_csWinDir;
    CString m_csSysDir;
    CString m_csSysDrive;
	WORD	m_wLanguage;

    CString m_csPathSource;
    CString m_csPathInetsrv;
    CString m_csPathInetpub;
	BOOL	m_fExistingMailroot;
    CString m_csPathMailroot;
	CString m_csPathNntpRoot;
	CString m_csPathNntpFile;
	BOOL	m_fMailPathSet;
	BOOL	m_fNntpPathSet;

	CString m_csPathExchangeDS;
	CString m_csExcEnterprise;
	CString m_csExcSite;
	CString m_csExcUserName;
	CString m_csExcPassword;
	CString m_csDsaUsername;
	CString m_csDsaDomain;

	BOOL	m_fExchangeDSInstalled;
	BOOL	m_fExistingDSACredentials;
	CString m_csDsaAccount;
	CString m_csDsaPassword;
	CString m_csDsaBindType;

	CString m_csPostmasterName;

	CString m_csNtfsVolume;		// Drive that contains NTFS partition

    NT_OS_TYPE m_eNTOSType;
    OS m_eOS;
    BOOL m_fNT4;                // TRUE if OS is NT
    BOOL m_fNT5;                // TRUE if OS is NT
    BOOL m_fW95;                // TRUE if OS is NT
    CString m_csPlatform;       // Alpha, Mips, PPC, i386

    BOOL m_fTCPIP;               // TRUE if TCP/IP is installed

    UPGRADE_TYPE m_eUpgradeType;       //  UT_NONE, UT_OLDFTP, UT_10, UT_20
    INSTALL_MODE m_eInstallMode;      // IM_FRESH, IM_MAINTENANCE, IM_UPGRADE
    DWORD m_dwSetupMode;

	DWORD m_dwCompId;			// Stores the current top-level component
	BOOL  m_fWizpagesCreated;	// TRUE if wizard pages already created

	BOOL m_fSelected[SC_MAXSC];
	BOOL m_fActive[MC_MAXMC][SC_MAXSC];
	INSTALL_MODE m_eState[SC_MAXSC];
	BOOL m_fValidSetupString[SC_MAXSC];

	BOOL m_fW3Started;
	BOOL m_fFtpStarted;
	BOOL m_fSpoolerStarted;
	BOOL m_fSnmpStarted;
	BOOL m_fCIStarted;
	BOOL m_fU2Started;
	BOOL m_fU2LdapStarted;
	BOOL m_fStarted[MC_MAXMC];

    // Some Specific flags set from ocmanage
    BOOL m_fNTUpgrade_Mode;
    BOOL m_fNTGuiMode;
    BOOL m_fNtWorkstation;
    BOOL m_fInvokedByNT; // superset of m_fNTGuiMode and ControlPanel which contains sysoc.inf
        
	BOOL m_fEULA;

	BOOL m_fIsUnattended;
	BOOL m_fSuppressSmtp;		// TRUE if another SMTP server is detected and we
								// should not install on top of it.

	BOOL m_fMailGroupInstalled;	// TRUE if the Mail program grp has been installed by an earlier comp.

    ACTION_TYPE m_eAction;    // AT_FRESH, AT_ADDREMOVE, AT_REINSTALL, AT_REMOVEALL, AT_UPGRADE

    BOOL m_bAllowMessageBoxPopups;  // Allow MessageBox popup?  Default to NO for NT5

    CString m_csLogFileFormats;

public:
    // Implementation
    int MsgBox(HWND hWnd, int strID, UINT nType);

public:
    BOOL InitApplication();
    BOOL GetMachineStatus();
	INSTALL_MODE DetermineInstallMode(DWORD dwComponent);
    BOOL GetLogFileFormats();

private:
    BOOL GetMachineName();
    BOOL GetSysDirs();
    BOOL GetOS();
    BOOL GetOSVersion();
    BOOL GetOSType();
    BOOL IsTCPIPInstalled();
    BOOL SetInstallMode();
	BOOL DetectPreviousInstallations();
	BOOL CheckForADSIFile();
	BOOL DetectADSI();
	BOOL VerifyOSForSetup();
    void SetSetupParams();
    void GetPlatform();
};

/////////////////////////////////////////////////////////////////////////////
#endif  // _INITAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\log.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "log.h"


// critical section needed to safely write to the logfile
CRITICAL_SECTION        critical_section;


//***************************************************************************
//*                                                                         
//* purpose: constructor
//*
//***************************************************************************
MyLogFile::MyLogFile(void)
{
	m_pIStorage = NULL;
	m_pIStream = NULL;
	_tcscpy(m_szLogFileName, _T(""));
	_tcscpy(m_szLogFileName_Full, _T(""));
	_tcscpy(m_szLogPreLineInfo, _T(""));
	_tcscpy(m_szLogPreLineInfo2, _T(""));
	m_bDisplayTimeStamp = TRUE;
	m_bDisplayPreLineInfo = TRUE;

	m_hFile = NULL;

	// initialize the critical section
	InitializeCriticalSection( &critical_section );
}

//***************************************************************************
//*                                                                         
//* purpose: destructor
//*
//***************************************************************************
MyLogFile::~MyLogFile(void)
{
	DeleteCriticalSection( &critical_section );
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
int MyLogFile::LogFileCreate(TCHAR *lpLogFileName )
{
	int iReturn = FALSE;
	TCHAR szDrive_only[_MAX_DRIVE];
	TCHAR szPath_only[_MAX_PATH];
	TCHAR szFilename_only[_MAX_PATH];
	TCHAR szFilename_bak[_MAX_PATH];
	LPWSTR  pwsz = NULL;

	// because of the global flags and such, we'll make this critical
	EnterCriticalSection( &critical_section );

	if (lpLogFileName == NULL)
	{
		TCHAR szModuleFileName[_MAX_PATH];

		// if a logfilename was not specified then use the module name.
		GetModuleFileName(NULL, szModuleFileName, _MAX_PATH);

		// get only the filename
		_tsplitpath( szModuleFileName, NULL, NULL, szFilename_only, NULL);
		_tcscat(szFilename_only, _T(".LOG"));

		_tcscpy(m_szLogFileName, szFilename_only);
	}
	else
	{
		_tcscpy(m_szLogFileName, lpLogFileName);
	}

	if (GetWindowsDirectory(m_szLogFileName_Full, sizeof(m_szLogFileName_Full)))
    {
        AddPath(m_szLogFileName_Full, m_szLogFileName);
        if (GetFileAttributes(m_szLogFileName_Full) != 0xFFFFFFFF)
        {
            // Make a backup of the current log file
			_tsplitpath( m_szLogFileName_Full, szDrive_only, szPath_only, szFilename_only, NULL);

			_tcscpy(szFilename_bak, szDrive_only);
			_tcscat(szFilename_bak, szPath_only);
			_tcscat(szFilename_bak, szFilename_only);
            _tcscat(szFilename_bak, _T(".BAK"));

            SetFileAttributes(szFilename_bak, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szFilename_bak);
            if (MoveFile(m_szLogFileName_Full, szFilename_bak) == 0)
			{
				// This failed
                MyMessageBox(NULL,_T("LogFile MoveFile Failed"),_T("LogFile Error"), MB_OK | MB_SETFOREGROUND);
			}
        }

#if defined(UNICODE) || defined(_UNICODE)
	pwsz = m_szLogFileName_Full;
#else
	pwsz = MakeWideStrFromAnsi( m_szLogFileName_Full);
#endif

   
#if defined(USESTREAMS) || defined(_USESTREAMS)
        if ((pwsz) && (!FAILED(StgCreateDocfile(pwsz, STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &m_pIStorage))) )
        {
            m_pIStorage->CreateStream( L"CONTENTS", STGM_READWRITE | STGM_SHARE_EXCLUSIVE ,0, 0, &m_pIStream );
            if (m_pIStream == NULL )
            {
                // Could not open the stream, close the storage and delete the file
                m_pIStorage->Release();
                m_pIStorage = NULL;
                DeleteFile(m_szLogFileName_Full);
				MyMessageBox(NULL, _T("LogFile CreateStream Failed, No Logfile generated"), _T("LogFile Error"), MB_OK | MB_SETFOREGROUND);
            }
			else
			{
				iReturn = TRUE;
			}
        }

        if (pwsz){CoTaskMemFree(pwsz);}
#else
		// Open existing file or create a new one.
		m_hFile = CreateFile(m_szLogFileName_Full,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
		if (m_hFile == INVALID_HANDLE_VALUE)
		{
			m_hFile = NULL;
			MyMessageBox(NULL, _T("Unable to create log file iis5.log"), _T("LogFile Error"), MB_OK | MB_SETFOREGROUND);
		}
		else 
		{
			iReturn = TRUE;
		}
#endif
		//LogFileTimeStamp();
		LogFileWrite(_T("LogFile Open.\r\n"));
	}


	// safe to leave the critical section
	LeaveCriticalSection( &critical_section );

	return iReturn;
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
int MyLogFile::LogFileClose(void)
{

#if defined(USESTREAMS) || defined(_USESTREAMS)
	if (m_pIStream)
	{
		LogFileWrite(_T("LogFile Close.\r\n"));
		MyLogFile::ConvertIStreamToFile(&m_pIStorage, &m_pIStream);
		return TRUE;
	}
#else
	if (m_hFile)
	{
		LogFileWrite(_T("LogFile Close.\r\n"));
		CloseHandle(m_hFile);
		return TRUE;
	}
#endif
	return FALSE;
}


//***************************************************************************
//*                                                                         
//* purpose: add stuff to logfile
//*
//***************************************************************************
void MyLogFile::LogFileTimeStamp()
{
    SYSTEMTIME  SystemTime;
    GetLocalTime(&SystemTime);
	m_bDisplayTimeStamp = FALSE;
	m_bDisplayPreLineInfo = FALSE;
    LogFileWrite(_T("[%d/%d/%d %d:%d:%d]\r\n"),SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
	m_bDisplayTimeStamp = TRUE;
	m_bDisplayPreLineInfo = TRUE;
}


//***************************************************************************
//*                                                                         
//* purpose: 
//* 
//***************************************************************************
void MyLogFile::LogFileWrite(TCHAR *pszFormatString, ...)
{

    if (m_pIStream || m_hFile)
    {
		// because of the global flags and such, we'll make this critical
		EnterCriticalSection( &critical_section );

		va_list args;
		TCHAR pszFullErrMsg[1000];
		char   pszFullErrMsgA[1000];
		strcpy(pszFullErrMsgA, "");

		DWORD dwBytesWritten = 0;

        va_start(args, pszFormatString);
		_vstprintf(pszFullErrMsg, pszFormatString, args); 
		va_end(args);

        if (pszFullErrMsg)
        {
#if defined(UNICODE) || defined(_UNICODE)
	// convert to ascii then write to stream
    WideCharToMultiByte( CP_ACP, 0, (TCHAR *)pszFullErrMsg, -1, pszFullErrMsgA, sizeof(pszFullErrMsgA), NULL, NULL );
#else
	// the is already ascii so just copy the pointer
	strcpy(pszFullErrMsgA,pszFullErrMsg);
#endif

			// If the Display timestap is set then display the timestamp
			if (m_bDisplayTimeStamp == TRUE)
			{
				// Get timestamp
				SYSTEMTIME  SystemTime;
				GetLocalTime(&SystemTime);
				char szDateandtime[50];
				sprintf(szDateandtime,"[%d/%d/%d %2.2d:%2.2d:%2.2d] ",SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
				// Write time to stream
#if defined(USESTREAMS) || defined(_USESTREAMS)
				m_pIStream->Write(szDateandtime, strlen(szDateandtime), &dwBytesWritten);
#else
				if (m_hFile) {WriteFile(m_hFile,szDateandtime,strlen(szDateandtime),&dwBytesWritten,NULL);}
#endif
			}

			char szPrelineWriteString[100];
			char szPrelineWriteString2[100];

			// If the Display timestap is set then display the timestamp
			if (m_bDisplayPreLineInfo == TRUE)
			{
				if (_tcscmp(m_szLogPreLineInfo,_T("")) != 0)
				{
#if defined(UNICODE) || defined(_UNICODE)
					// convert to ascii
					WideCharToMultiByte( CP_ACP, 0, (TCHAR *)m_szLogPreLineInfo, -1, szPrelineWriteString, 100, NULL, NULL );
#else
					// the is already ascii so just copy
					strcpy(szPrelineWriteString, m_szLogPreLineInfo);
#endif
#if defined(USESTREAMS) || defined(_USESTREAMS)
					// Write to stream
					m_pIStream->Write(szPrelineWriteString, strlen(szPrelineWriteString), &dwBytesWritten);
#else
					if (m_hFile) {WriteFile(m_hFile,szPrelineWriteString,strlen(szPrelineWriteString),&dwBytesWritten,NULL);}
#endif
				}

				if (_tcscmp(m_szLogPreLineInfo2,_T("")) != 0)
				{
#if defined(UNICODE) || defined(_UNICODE)
					// convert to ascii
					WideCharToMultiByte( CP_ACP, 0, (TCHAR *)m_szLogPreLineInfo2, -1, szPrelineWriteString2, 100, NULL, NULL );
#else
					// the is already ascii so just copy
					strcpy(szPrelineWriteString2, m_szLogPreLineInfo2);
#endif
#if defined(USESTREAMS) || defined(_USESTREAMS)
					// Write to stream
					m_pIStream->Write(szPrelineWriteString2, strlen(szPrelineWriteString2), &dwBytesWritten);
#else
					if (m_hFile) {WriteFile(m_hFile,szPrelineWriteString2,strlen(szPrelineWriteString2),&dwBytesWritten,NULL);}
#endif
				}
			}

			// if it does not end if '\r\n' then make one.
			int nLen = strlen(pszFullErrMsgA);

			if (pszFullErrMsgA[nLen-1] != '\n')
				{strcat(pszFullErrMsgA, "\r\n");}
			else
			{
				if (pszFullErrMsgA[nLen-2] != '\r') 
					{
					char * pPointer = NULL;
					pPointer = pszFullErrMsgA + (nLen-1);
					strcpy(pPointer, "\r\n");
					}
			}


			// Write Regular data to stream
#if defined(USESTREAMS) || defined(_USESTREAMS)
			m_pIStream->Write(pszFullErrMsgA, strlen(pszFullErrMsgA), &dwBytesWritten);
#else
			if (m_hFile) {WriteFile(m_hFile,pszFullErrMsgA,strlen(pszFullErrMsgA),&dwBytesWritten,NULL);}
#endif
        }

		// safe to leave the critical section
		LeaveCriticalSection( &critical_section );
    }
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
#define BUFFERSIZE   1024
int MyLogFile::ConvertIStreamToFile(LPSTORAGE *pIStorage, LPSTREAM *pIStream)
{
	int iReturn = FALSE;
    HANDLE  fh;
    TCHAR szTempFile[_MAX_PATH];      // Should use the logfilename
    LPVOID lpv = NULL;
    LARGE_INTEGER li;
    DWORD   dwl;
    ULONG   ul;
    HRESULT hr;

    _tcscpy(szTempFile, m_szLogFileName_Full);
    MakePath(szTempFile);
    if (GetTempFileName(szTempFile, _T("INT"), 0, szTempFile) != 0)
    {
        fh = CreateFile(szTempFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (fh != INVALID_HANDLE_VALUE)
        {
            lpv = (LPTSTR)LocalAlloc(LPTR, BUFFERSIZE);
            if (lpv)
            {
                LISet32(li, 0);
                (*pIStream)->Seek(li, STREAM_SEEK_SET, NULL); // Set the seek pointer to the beginning
                do
                {
                    hr = (*pIStream)->Read(lpv, BUFFERSIZE, &ul);
                    if(SUCCEEDED(hr))
                    {
                        if (!WriteFile(fh, lpv, ul, &dwl, NULL))
                            hr = E_FAIL;
                    }
                }
                while ((SUCCEEDED(hr)) && (ul == BUFFERSIZE));

				if (lpv) LocalFree(lpv);
            }

            CloseHandle(fh);
            // Need to release stream and storage to close the storage file.
            (*pIStream)->Release();
            (*pIStorage)->Release();
            *pIStream = NULL;
            *pIStorage = NULL;

            if (SUCCEEDED(hr))
            {
                DeleteFile(m_szLogFileName_Full);
                MoveFile(szTempFile, m_szLogFileName_Full);
            }

        }

    }

    if (*pIStream)   
    {
        // If we did not manage to convert the file to a text file
        (*pIStream)->Release();
        (*pIStorage)->Release();
        *pIStream = NULL;
        *pIStorage = NULL;
		iReturn = FALSE;
    }

    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\license.cpp ===
/*
 *	license.cxx
 *
 *	Copyright (c) 1997 Microsoft Corporation
 *
 *	Purpose:	Licensing code from exsetup
 *
 *	Adapted from hiddenw1.cxx
 */

#include "stdafx.h"
#include <ole2.h>
#undef UNICODE
#include "iadm.h"
#define UNICODE
#include "mdkey.h"
#include "mdentry.h"

#include "utils.h"
#include "regctrl.h"

typedef LPSTR	(PASCAL * LPCPLSETUP)
				(DWORD nArgs, LPSTR rgszArgs[], LPSTR *ppszResult);

DWORD	ScDoLicensing(
	HWND		hwnd,
	BOOL		fUI,
	BOOL		fRefresh,
	BOOL		fForklift,
	BOOL		fLicPerSeat,
	LPTSTR		pstrLicPerServerUserNum,
	BOOL	*	pfQuit)
{
	char *		aszRet;

	CString		strHwndAddress;
	CString		strShortName;
	CString		strLongName;
	CString		strFamilyName;
	CString		strLicenseInfoKey;
	CString		strMSExchangeISKey;

	CString		strName;
	CString		strValue;

	INT			nArglist;
	char		*rgaszArgs[6];
	char 		rgrgachArgs[6][MAX_PATH];
	LPCTSTR		rgszArgs[6];
	BOOL		fLicenseInfoFound = FALSE;
	DWORD		dwMode = 0;				// previous license mode
	const INT	modePerSeat = 0;

	INT			iasz;

	DWORD		sc   = NO_ERROR;

	HINSTANCE	hLib = NULL;
	LPCPLSETUP	pfnCPlSetup = NULL;

	if (!pfQuit)
		return(ERROR_INVALID_PARAMETER);

	// Setup initial values
	*pfQuit = FALSE;
	strHwndAddress.Format(_T("%x"), HandleToUlong(hwnd));

	// Load resources
	MyLoadString(idsMDBShortName, strShortName);
	MyLoadString(idsProdName, strLongName);
	MyLoadString(idsProdFamilyName, strFamilyName);
	MyLoadString(idsRegLicenseInfoKey, strLicenseInfoKey);
	
	// Build strings
	strMSExchangeISKey.Format(_T("%s\\%s"), strLicenseInfoKey, strShortName);
	
	// If Exchange has been installed on this machine before license information will still
	// exist since this is not removed. If so, we need to make sure that the
	// display name (which includes a version number) is correct.

	// Check if the Exchange key exists. If it doesn't then we shouldn't do anything special.
	// Previously we always updated this key but this confused the License Manager on new installations.
	// Since the Prefs class will always create a key if it doesn't exist use a direct registry call
	// here instead to determine if a value already exists.

	// Open MS Exchange IS Key
	DebugOutput(_T("Opening: %s"), strMSExchangeISKey);
	CRegKey regISKey( HKEY_LOCAL_MACHINE, strMSExchangeISKey );
	if ((HKEY) regISKey)
	{
		// Load the display name from reg
		MyLoadString(idsRegDisplayName, strName);
		if (regISKey.QueryValue(strName, strValue) == NO_ERROR)
		{
			DebugOutput(_T("Display name: %s"), strValue);
			fLicenseInfoFound = TRUE;	// Existing value found
		}

		// Find out whether the previous setting was per seat or per server.
		MyLoadString(idsRegMode, strName);
		if (regISKey.QueryValue(strName, dwMode) == NO_ERROR)
		{
			DebugOutput(_T("Mode: %u"), dwMode);
			fLicenseInfoFound = TRUE;	// Existing value found
		}

		// If we are refreshing then we expect to find license information from our
		// previous install
		if (fRefresh && !fLicenseInfoFound && !fForklift)
			return(ERROR_INVALID_PARAMETER);

		if (fLicenseInfoFound)
		{
			// Update the registry key before calling the licensing dialog.
			// If the long name stored in the registry by the Licensing Manager is
			// not the same as our strLongName (eg, version number has changed),
			// then the licensing dialog will not be able to pick up correctly
			// previously stored license info.

			MyLoadString(idsRegDisplayName, strName);
			sc = regISKey.SetValue(strName, strLongName);
			if (sc != NO_ERROR)
				goto Error;

			DebugOutput(_T("Changed Display name to: %s"), strLongName);
		}
	}

	// If only doing an update then we're done UNLESS previous install was per server.
	// In this case must show per seat dialog box.
	if (!fForklift && fRefresh && (dwMode == modePerSeat))
		goto Cleanup;

	// Load up the entry point
	DebugOutput(_T("Loading liccpa.cpl ...\n"));
	hLib = LoadLibrary(_T("liccpa.cpl"));
	if (!hLib)
	{
		sc = GetLastError();
		DebugOutput(_T("Failed loading liccpa.cpl (%u)\n"), sc);
		goto Error;
	}
	
	DebugOutput(_T("Loading CPlSetup ...\n"));
	pfnCPlSetup = (LPCPLSETUP)GetProcAddress(hLib, "CPlSetup");
	if (!pfnCPlSetup)
	{
		sc = GetLastError();
		DebugOutput(_T("Failed loading CPlSetup (%u)\n"), sc);
		goto Error;
	}

	if (fUI)		//no ini file, bring up the dialogs
	{
		// This changed from FULLSETUP to PERSEAT in Exchange 5.5
		rgszArgs[0] = _T("PERSEAT");
		rgszArgs[1] = strHwndAddress;
		rgszArgs[2] = strShortName;
		rgszArgs[3] = strFamilyName;
		rgszArgs[4] = strLongName;
		nArglist = 5;
	}
	else
	{
		if (!fLicPerSeat)
		{
			sc = ERROR_INVALID_PARAMETER;
			DebugOutput(_T("fLicPerSeat must be TRUE"));
			goto Error;
		}
		rgszArgs[0] = _T("UNATTENDED");
		rgszArgs[1] = strShortName;
		rgszArgs[2] = strFamilyName;
		rgszArgs[3] = strLongName;
		rgszArgs[4] = _T("PerSeat");
		rgszArgs[5] = _T("0");
		nArglist = 6;
	}
	
	// There is no UNICODE entry point so convert all argument strings
	for (iasz = 0; iasz < nArglist; ++iasz)
	{
		DebugOutput(_T("Parameter %u: <%s>\n"), iasz, rgszArgs[iasz]);

#ifdef UNICODE
		::WideCharToMultiByte(CP_ACP, NULL, rgszArgs[iasz], -1,
							  rgrgachArgs[iasz], sizeof(rgrgachArgs[iasz]), NULL, NULL);
#else
		strcpyA(rgrgachArgs[iasz],rgszArgs[iasz]);
#endif
		rgaszArgs[iasz] = rgrgachArgs[iasz];
	}

	(*pfnCPlSetup)(nArglist, rgaszArgs, &aszRet);

	if((lstrcmpiA(aszRet, "exit") == 0) && fUI)	//not valid for unattended
	{
		*pfQuit = TRUE;
	}

	if(lstrcmpiA(aszRet, "error") == 0)
	{
		sc = ERROR_INVALID_DATA;
		goto Error;
	}

Cleanup:
	if (hLib)
		FreeLibrary(hLib);
	return sc;

Error:
	DebugOutput(_T("ScDoLicensing failed (%u)\n"), sc);
	goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\mdentry.cpp ===
#include "stdafx.h"

#include <ole2.h>
#undef UNICODE
#include "iadm.h"
#define UNICODE
#include "iiscnfg.h"
#include "mdkey.h"

#include "setupapi.h"
#include "elem.h"
#include "mdentry.h"
#include "inetinfo.h"
#include "helper.h"

DWORD atodw(LPCTSTR lpszData)
{
    DWORD i = 0, sum = 0;
    TCHAR *s, *t;

    s = (LPTSTR)lpszData;
    t = (LPTSTR)lpszData;

    while (*t)
        t++;
    t--;

    if (*s == _T('0') && (*(s+1) == _T('x') || *(s+1) == _T('X')))
        s += 2;

    while (s <= t) {
        if ( *s >= _T('0') && *s <= _T('9') )
            i = *s - _T('0');
        else if ( *s >= _T('a') && *s <= _T('f') )
            i = *s - _T('a') + 10;
        else if ( *s >= _T('A') && *s <= _T('F') )
            i = *s - _T('A') + 10;
        else
            break;

        sum = sum * 16 + i;
        s++;
    }
    return sum;
}

#define MAX_FIELDS  12
#define FIELD_SEPERATOR   _T("\t")
LPTSTR field[MAX_FIELDS];
BYTE g_DataBuf[1024 * 16];
DWORD g_dwValue;

// Split a line of entry into 10 fields for MDEntry datatype
BOOL SplitLine(LPTSTR szLine)
{
    int i = 0;
    TCHAR *token;

    token = _tcstok(szLine, FIELD_SEPERATOR);
    while (token && i < MAX_FIELDS) {
        field[i++] = token;
        token = _tcstok(NULL, FIELD_SEPERATOR);
    }

    if (i == MAX_FIELDS)
        return TRUE;
    else
	{
		SetLastError(ERROR_INVALID_DATA);
        return FALSE;
	}
}

// Fill in the structure of MDEntry
BOOL SetupMDEntry(LPTSTR szLine, BOOL fUpgrade)
{
    BOOL fMigrate;
    BOOL fKeepOldReg;
    HKEY hRegRootKey;
    LPTSTR szRegSubKey;
    LPTSTR szRegValueName;
	LPBYTE pbData = g_DataBuf;
	DWORD cbData;
	static TCHAR szMDPath[MAX_PATH];
	MDEntry mdentry, *pMDEntry = &mdentry;
	DWORD dwIndex=0;
	TCHAR pszEnumName[MAX_PATH];
	DWORD cbEnumName = sizeof(pszEnumName);
	BOOL fDoSet;
	BOOL fSetOnlyIfNotPresent;

    if (!SplitLine(szLine))
        return FALSE;

    if ( lstrcmp(field[0], _T("1")) == 0) {
        fMigrate = (TRUE && fUpgrade);
		fDoSet = TRUE;
		fSetOnlyIfNotPresent = FALSE;
	} else if (lstrcmp(field[0], _T("2")) == 0) {
        fMigrate = (TRUE && fUpgrade);
		fDoSet = FALSE;
		fSetOnlyIfNotPresent = FALSE;
	} else if (lstrcmp(field[0], _T("4")) == 0) {
        fMigrate = FALSE;
		fDoSet = TRUE;
		fSetOnlyIfNotPresent = TRUE;
    } else {
        fMigrate = FALSE;
		fDoSet = TRUE;
		fSetOnlyIfNotPresent = FALSE;
	}

    if ( lstrcmp(field[1], _T("1")) == 0)
        fKeepOldReg = TRUE;
    else
        fKeepOldReg = FALSE;

    if (lstrcmpi(field[2], _T("HKLM")) == 0)
        hRegRootKey = HKEY_LOCAL_MACHINE;
    else if (lstrcmpi(field[2], _T("HKCR")) == 0)
        hRegRootKey = HKEY_CLASSES_ROOT;
    else if (lstrcmpi(field[2], _T("HKCU")) == 0)
        hRegRootKey = HKEY_CURRENT_USER;
    else if (lstrcmpi(field[2], _T("HKU")) == 0)
        hRegRootKey = HKEY_USERS;
    else
        hRegRootKey = HKEY_LOCAL_MACHINE;

    szRegSubKey = field[3];
    szRegValueName = field[4];

    pMDEntry->szMDPath = field[5];
    pMDEntry->dwMDIdentifier = _ttoi(field[6]);
    pMDEntry->dwMDAttributes = atodw(field[7]);
    pMDEntry->dwMDUserType = _ttoi(field[8]);
    pMDEntry->dwMDDataType = _ttoi(field[9]);
    pMDEntry->dwMDDataLen = _ttoi(field[10]);

    DebugOutput(_T("SetupMDEntry(): szLine: field[4]=%s, [5]=%s, [6]=%s"), field[4], field[5], field[6]);

    if ( pMDEntry->dwMDDataType == DWORD_METADATA ) {
        g_dwValue = atodw(field[11]);
        pMDEntry->pbMDData = (LPBYTE) &g_dwValue;

    } else if ( pMDEntry->dwMDDataType == BINARY_METADATA ) {

		BYTE	rgbBinaryBuf[4096];
		TCHAR	rgtcByteValue[3] = { _T('\0'), _T('\0'), _T('\0') };
		LPTSTR	pbBinary = field[11];
		DWORD	dwCount = lstrlen(pbBinary);
		DWORD	dwLen = 0;

		// Convert to binary data:
		// "000102030405ff06" becomes
		// BYTE [] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0xff, 0x06 }
		while (dwCount)
		{
			if (dwCount == 1)
			{
				rgtcByteValue[0] = *pbBinary++;
				rgtcByteValue[1] = _T('\0');
				dwCount--;
			}
			else
			{
				rgtcByteValue[0] = *pbBinary++;
				rgtcByteValue[1] = *pbBinary++;
				dwCount -= 2;
			}

			rgbBinaryBuf[dwLen++] = (BYTE)atodw(rgtcByteValue);
		}
			
		// Set the records straight
		pMDEntry->pbMDData = rgbBinaryBuf;
        pMDEntry->dwMDDataLen = dwLen;

    } else {
		TCHAR szStringBuf[4096];
		TCHAR *pszStringData = field[11];

		*szStringBuf = 0;
		//
		// do env substitution if necessary
		//	
		int iStart, iEnd = 0;
		do {
			for (iStart = iEnd; pszStringData[iStart] != 0; iStart++) {
				if (pszStringData[iStart] == _T('%')) break;
			}
			if (pszStringData[iStart] != 0) {
				// copy from the last substitution to here
				pszStringData[iStart] = 0;
				lstrcat(szStringBuf, pszStringData + iEnd);
				pszStringData[iStart] = _T('%');
				// find the end %
				for (iEnd = iStart + 1; pszStringData[iEnd] != 0; iEnd++) {
					if (pszStringData[iEnd] == _T('%')) break;
				}
				if (iStart + 1 == iEnd) {
					// found %%, replace with %
					lstrcat(szStringBuf, _T("%"));
					iEnd++;
				} else if (pszStringData[iEnd] != 0) {
					// do the substitution
					pszStringData[iEnd] = 0;
					DWORD cbBuf = lstrlen(szStringBuf);
					GetEnvironmentVariable(pszStringData + iStart + 1,
									       szStringBuf+cbBuf,
										   sizeof(szStringBuf)-cbBuf);
					pszStringData[iEnd] = _T('%');
					iEnd++;
				} else {
					// no ending %, copy the rest
					lstrcat(szStringBuf, pszStringData + iStart);
				}
			}
		} while (pszStringData[iStart] != 0);
		lstrcat(szStringBuf, pszStringData + iEnd);
		lstrcpy(pszStringData, szStringBuf);

		pMDEntry->pbMDData = (LPBYTE)pszStringData;
    }

	BOOL fMore = TRUE;
	while (fMore) {
		//
		// reg enumeration support
		//
		TCHAR szBuf[MAX_PATH + 1];
		LPTSTR szRegKey = szBuf;
		// see if there is an '*' in the szRegSubKey field
		int iStar;
		for (iStar = 0; szRegSubKey[iStar] != 0; iStar++) {
			if (szRegSubKey[iStar] == _T('*')) break;
		}
		if (szRegSubKey[iStar] != 0 && (szRegSubKey[iStar + 1] == _T('\\') ||
										szRegSubKey[iStar + 1] == 0))
		{
			DWORD ec;
			HKEY hKey = NULL;
	
			// copy the base
			szRegSubKey[iStar] = 0;
			lstrcpy(szRegKey, szRegSubKey);
			szRegSubKey[iStar] = _T('*');
			// open the key
			ec = RegOpenKeyEx(hRegRootKey, szRegKey, 0, KEY_ALL_ACCESS, &hKey);
			if (ec == ERROR_SUCCESS) {
				// do an enum to find out what we should be opening
				cbEnumName = sizeof(pszEnumName) / sizeof(pszEnumName[0]);
				ec = RegEnumKeyEx(hKey, dwIndex++, pszEnumName, &cbEnumName,
								  NULL, NULL, 0, NULL);
				if (ec != ERROR_SUCCESS) {
					fMore = FALSE;
					continue;
				} else {
					fMore = TRUE;
				}
				lstrcat(szRegKey, pszEnumName);
				if (szRegSubKey[iStar + 1] != 0)
					lstrcat(szRegKey, szRegSubKey + iStar + 1);
				RegCloseKey(hKey);
			} else {
				// couldn't open key
				lstrcpy(szRegKey, szRegSubKey);
				fMore = FALSE;
			}
		} else {
			// no star
			lstrcpy(szRegKey, szRegSubKey);
			fMore = FALSE;
		}
			
	    // migrate if necessary
	    if (fMigrate) {
		    HKEY hKey = NULL;
			LONG err = ERROR_SUCCESS;
			DWORD dwType = 0;
			cbData = sizeof(g_DataBuf);
			err = RegOpenKeyEx(hRegRootKey, szRegKey, 0, KEY_ALL_ACCESS, &hKey);
			if ( err == ERROR_SUCCESS ) {
		        err = RegQueryValueEx(hKey, szRegValueName, NULL, &dwType, pbData, &cbData);
				if (err == ERROR_MORE_DATA) {
#ifdef DEBUG
					DebugBreak();
#endif
				}
	            if ( err == ERROR_SUCCESS)
				{
	                pMDEntry->pbMDData = pbData;
	                pMDEntry->dwMDDataLen = cbData;
					fDoSet = TRUE;
	            }
	
	            if (fKeepOldReg == FALSE)
	                err = RegDeleteValue(hKey, szRegValueName);
	
	            RegCloseKey(hKey);
	        }
	    } else if (fKeepOldReg == FALSE) {
	        HKEY hKey = NULL;
	        LONG err = ERROR_SUCCESS;
	        DWORD dwType = 0;
	        err = RegOpenKeyEx(hRegRootKey, szRegKey, 0, KEY_ALL_ACCESS, &hKey);
	        if ( err == ERROR_SUCCESS ) {
	            err = RegDeleteValue(hKey, szRegValueName);
	            RegCloseKey(hKey);
	        }
	    }
	
	    switch (pMDEntry->dwMDDataType) {
	    case DWORD_METADATA:
	        pMDEntry->dwMDDataLen = 4;
	        break;
	    case STRING_METADATA:
	    case EXPANDSZ_METADATA:
	        pMDEntry->dwMDDataLen = (lstrlen((LPTSTR)pMDEntry->pbMDData) + 1) * sizeof(TCHAR);
	        break;
	    case MULTISZ_METADATA:
			// We only allow a single string even for a multi-sz.
			pMDEntry->dwMDDataLen = (lstrlen((LPTSTR)pMDEntry->pbMDData) + 1) * sizeof(TCHAR);

			// Append the second NULL and bump the length by one at the same time
			*(LPTSTR)((LPBYTE)pMDEntry->pbMDData + pMDEntry->dwMDDataLen) = _T('\0');
			pMDEntry->dwMDDataLen += sizeof(TCHAR);
			break;
	    case BINARY_METADATA:
			// Everything is set upstream
	        break;
	    }

		if (fDoSet) {
			SetMDEntry(pMDEntry, pszEnumName, fSetOnlyIfNotPresent);
		}
	}

    return TRUE;
}

void SetMDEntry(MDEntry *pMDEntry, LPTSTR pszEnumName, BOOL fSetOnlyIfNotPresent)
{
    CMDKey cmdKey;
    BOOL fSet = TRUE;

	TCHAR szBuf[MAX_PATH + 1];
	LPTSTR szMDPath = szBuf;
	
    DebugOutput(_T("SetMDEntry(): pMDEntry=0x%x"), pMDEntry);

    if (pszEnumName != NULL) {
		// see if there is an '*' in the szMDPath field
		int iStar;
		for (iStar = 0; pMDEntry->szMDPath[iStar] != 0; iStar++) {
			if (pMDEntry->szMDPath[iStar] == _T('*')) break;
		}
		if (pMDEntry->szMDPath[iStar] != 0 && (pMDEntry->szMDPath[iStar + 1] == _T('\\') ||
											   pMDEntry->szMDPath[iStar + 1] == 0))
		{
			// copy the base
			pMDEntry->szMDPath[iStar] = 0;
			lstrcpy(szMDPath, pMDEntry->szMDPath);
			pMDEntry->szMDPath[iStar] = _T('*');
			// copy the substitued path
			lstrcat(szMDPath, pszEnumName);
			// finish the copy
			if (pMDEntry->szMDPath[iStar + 1] != 0)
				lstrcat(szMDPath, pMDEntry->szMDPath + iStar + 1);
		} else {
			// no star
			szMDPath = pMDEntry->szMDPath;
		}
	} else {
		szMDPath = pMDEntry->szMDPath;
	}
	
    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, (LPCTSTR)szMDPath);
    if ( (METADATA_HANDLE)cmdKey ) {
        BYTE pbData[32];
        DWORD dwAttr, dwUType, dwDType;
        DWORD dwLen=sizeof(pbData);
        if (fSetOnlyIfNotPresent && cmdKey.GetData(
            pMDEntry->dwMDIdentifier,
            &dwAttr,
            &dwUType,
            &dwDType,
            &dwLen,
            pbData)) {
            fSet = FALSE;
        }
        if (fSet) {
            cmdKey.SetData(
                pMDEntry->dwMDIdentifier,
                pMDEntry->dwMDAttributes,
                pMDEntry->dwMDUserType,
                pMDEntry->dwMDDataType,
                pMDEntry->dwMDDataLen,
                pMDEntry->pbMDData);
        }
        cmdKey.Close();
    }

    return;
}

void MigrateIMSToMD(HINF hInf, LPCTSTR szServerName,
					LPCTSTR szSection,
					DWORD dwRoutingSourcesMDID,
					BOOL fUpgrade,
					BOOL k2UpgradeToEE)
{
	TCHAR buf[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD dwLen = MAX_COMPUTERNAME_LENGTH;

	CString csDefaultSiteName, csDefaultSiteName2, csDefaultSiteName3;

	DebugOutput(_T("MigradeIMSToMD(): szSection=%s, fUpgrade=%d"), szSection, fUpgrade);

	GetComputerName(buf, &dwLen);

    AddVRootsToMD(szServerName, fUpgrade);

    // Migrate Virtual Roots and routing sources only on upgrade case
	if (fUpgrade && !k2UpgradeToEE)
	{
		MigrateRoutingSourcesToMD(szServerName, dwRoutingSourcesMDID);
	}

    theApp.GetLogFileFormats();

	MyLoadString(IDS_SMTP_DEFAULT_SITE_NAME, csDefaultSiteName);
	MyLoadString(IDS_POP3_DEFAULT_SITE_NAME, csDefaultSiteName2);
	MyLoadString(IDS_IMAP_DEFAULT_SITE_NAME, csDefaultSiteName3);

	SetEnvironmentVariable(_T("__INETPUB"), theApp.m_csPathInetpub);
	SetEnvironmentVariable(_T("__MAILROOT"), theApp.m_csPathMailroot);
	SetEnvironmentVariable(_T("__EQUALS"), _T("="));
	SetEnvironmentVariable(_T("__EMPTY"), _T(""));
	SetEnvironmentVariable(_T("__SEMICOL"), _T(";"));
	SetEnvironmentVariable(_T("__DSAHOST"), theApp.m_csCleanMachineName);
	SetEnvironmentVariable(_T("__SITE"), theApp.m_csExcSite);
	SetEnvironmentVariable(_T("__ENTERPRISE"),theApp.m_csExcEnterprise);
	SetEnvironmentVariable(_T("__DSABINDTYPE"),theApp.m_csDsaBindType);
	SetEnvironmentVariable(_T("__DSAACCOUNT"),theApp.m_csDsaAccount);
	SetEnvironmentVariable(_T("__DSAPASSWORD"),theApp.m_csDsaPassword);
	SetEnvironmentVariable(_T("__SMTP_DEFAULT_SITE_NAME"), csDefaultSiteName);
	SetEnvironmentVariable(_T("__POP3_DEFAULT_SITE_NAME"), csDefaultSiteName2);
	SetEnvironmentVariable(_T("__IMAP_DEFAULT_SITE_NAME"), csDefaultSiteName3);
	SetEnvironmentVariable(_T("__SMTP_LOG_FILE_FORMATS"), theApp.m_csLogFileFormats);
	SetEnvironmentVariable(_T("__MACHINENAME"), buf);

    MigrateInfSectionToMD(hInf, szSection, fUpgrade);

	if (!fUpgrade && !k2UpgradeToEE)
	{
		// If we are not upgrading, we will have to install the default
		// Mailroots and routing sources
		CString csFreshSection = szSection;
		csFreshSection += _T("_FRESH");
	    MigrateInfSectionToMD(hInf, (LPCTSTR)csFreshSection, fUpgrade);
	}

	SetEnvironmentVariable(_T("__INETPUB"), NULL);
	SetEnvironmentVariable(_T("__MAILROOT"), NULL);
	SetEnvironmentVariable(_T("__EQUALS"), NULL);
	SetEnvironmentVariable(_T("__EMPTY"), NULL);
	SetEnvironmentVariable(_T("__SEMICOL"), NULL);
	SetEnvironmentVariable(_T("__DSAHOST"), NULL);
	SetEnvironmentVariable(_T("__SITE"), NULL);
	SetEnvironmentVariable(_T("__ENTERPRISE"), NULL);
	SetEnvironmentVariable(_T("__DSABINDTYPE"), NULL);
	SetEnvironmentVariable(_T("__DSAACCOUNT"), NULL);
	SetEnvironmentVariable(_T("__DSAPASSWORD"), NULL);
	SetEnvironmentVariable(_T("__SMTP_DEFAULT_SITE_NAME"), NULL);
	SetEnvironmentVariable(_T("__POP3_DEFAULT_SITE_NAME"), NULL);
	SetEnvironmentVariable(_T("__IMAP_DEFAULT_SITE_NAME"), NULL);
	SetEnvironmentVariable(_T("__SMTP_LOG_FILE_FORMATS"), NULL);
	SetEnvironmentVariable(_T("__MACHINENAME"), NULL);

}

void MigrateNNTPToMD(HINF hInf, LPCTSTR szSection, BOOL fUpgrade)
{
	TCHAR buf[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD dwLen = MAX_COMPUTERNAME_LENGTH;

	DebugOutput(_T("MigradeNNTPToMD(): szSection=%s, fUpgrade=%d"), szSection, fUpgrade);

    GetComputerName(buf, &dwLen);

    // About Virtual Roots
    AddVRootsToMD(_T("NNTPSVC"), fUpgrade);

	CString csDefaultSiteName;
	CString csServiceName;
	CString csAdminName;
	CString csAdminEmail;

	MyLoadString(IDS_NNTP_DEFAULT_SITE_NAME, csDefaultSiteName);
	MyLoadString(IDS_NNTP_SERVICE_NAME, csServiceName);
	MyLoadString(IDS_NNTP_DEFAULT_ADMIN_NAME, csAdminName);
	MyLoadString(IDS_NNTP_DEFAULT_ADMIN_EMAIL, csAdminEmail);

    theApp.GetLogFileFormats();

	SetEnvironmentVariable(_T("__NNTPFILE"), theApp.m_csPathNntpFile);
	SetEnvironmentVariable(_T("__NNTPROOT"), theApp.m_csPathNntpRoot);
	SetEnvironmentVariable(_T("__MACHINENAME"), buf);
	SetEnvironmentVariable(_T("__INETPUB"), theApp.m_csPathInetpub);
	SetEnvironmentVariable(_T("__EMPTY"), NULL);
	SetEnvironmentVariable(_T("__NNTP_DEFAULT_SITE_NAME"), csDefaultSiteName);
	SetEnvironmentVariable(_T("__NNTP_SERVICE_NAME"), csServiceName);
	SetEnvironmentVariable(_T("__NNTP_DEFAULT_ADMIN_NAME"), csAdminName);
	SetEnvironmentVariable(_T("__NNTP_DEFAULT_ADMIN_EMAIL"), csAdminEmail);
	SetEnvironmentVariable(_T("__NNTP_LOG_FILE_FORMATS"), theApp.m_csLogFileFormats);

    MigrateInfSectionToMD(hInf, szSection, fUpgrade);

	SetEnvironmentVariable(_T("__NNTPFILE"), NULL);
	SetEnvironmentVariable(_T("__NNTPROOT"), NULL);
	SetEnvironmentVariable(_T("__MACHINENAME"), NULL);
	SetEnvironmentVariable(_T("__INETPUB"), NULL);
	SetEnvironmentVariable(_T("__NNTP_DEFAULT_SITE_NAME"), NULL);
	SetEnvironmentVariable(_T("__NNTP_SERVICE_NAME"), NULL);
	SetEnvironmentVariable(_T("__NNTP_DEFAULT_ADMIN_NAME"), NULL);
	SetEnvironmentVariable(_T("__NNTP_DEFAULT_ADMIN_EMAIL"), NULL);
	SetEnvironmentVariable(_T("__NNTP_LOG_FILE_FORMATS"), NULL);
}

void CreateVRMap(CMapStringToOb *pMap, LPCTSTR szVRootRegKey, LPCTSTR szRootDir, DWORD dwMdFlags, BOOL fUpgrade)
{
    CMapStringToString *pGlobalObj;

    DebugOutput(_T("CreateVRMap(): pMap=0x%x, szVRootRegKey=%s, szRootDir=%s, dwMdFlags=%d, fUpgrade=%d"), pMap, szVRootRegKey, szRootDir, dwMdFlags, fUpgrade);

    if (fUpgrade) {
        CElem elem;
        elem.ReadRegVRoots(szVRootRegKey, pMap);
    }

    if (pMap->IsEmpty() || pMap->Lookup(_T("null"), (CObject*&)pGlobalObj) == FALSE)
	{
        CString ip, name, value;
        CMapStringToString *pNew;
        pNew = new CMapStringToString;
        ip = _T("null");
        name = _T("/");
        value.Format(_T("%s,,%d"), szRootDir, dwMdFlags);
        pNew->SetAt(name, value);

        pMap->SetAt(ip, pNew);
    }
}

void MigrateInfSectionToMD(HINF hFile, LPCTSTR szSection, BOOL fUpgrade)
{
    TCHAR szLine[16 * 1024];
    DWORD dwLineLen = 0, dwRequiredSize;
	DWORD dwIndex = 0;

    BOOL b = FALSE;

    INFCONTEXT Context;

    DebugOutput(_T("MigrateInfSectionToMD(): szSection=%s, fUpgrade=%d"), szSection, fUpgrade);

    b = SetupFindFirstLine(hFile, szSection, NULL, &Context);
    if (!b) return;

    while (b) {
		BOOL fLoop = TRUE;
#ifdef DEBUG
        b = SetupGetLineText(&Context, NULL, NULL,
							NULL, NULL, 0, &dwRequiredSize);
		_ASSERT(dwRequiredSize < sizeof(szLine));
#endif
		ZeroMemory(szLine, sizeof(szLine));
        if (SetupGetLineText(&Context, NULL, NULL,
							 NULL, szLine, sizeof(szLine), NULL) == FALSE)
		{
			// We're done
            return;
		}

		dwIndex++;
		if (!SetupMDEntry(szLine, fUpgrade))
		{
			// If this fails we wiil not set up metabase stuff.
			_stprintf(szLine, TEXT("SplitLine [%s] line %u"),
						szSection, dwIndex);
			SetErrMsg(szLine, GetLastError());
		}

        b = SetupFindNextLine(&Context, &Context);
    }

    return;
}

void SplitVRString(CString csValue, LPTSTR szPath, LPTSTR szUserName, DWORD *pdwPerm)
{
    // csValue should be in format of "<path>,<username>,<perm>"
    CString csPath, csUserName;
    int i;

    DebugOutput(_T("SplitVRString(): csValue=%s, szPath=%s, szUserName=%s"), csValue, szPath, szUserName);

    csValue.TrimLeft();
    csValue.TrimRight();
    csPath = csValue;
    csUserName = _T("");
    *pdwPerm = 0;

    i = csValue.Find(_T(","));
    if (i != -1) {
        csPath = csValue.Mid(0, i);
        csPath.TrimRight();

        csValue = csValue.Mid(i+1);
        csValue.TrimLeft();

        i = csValue.Find(_T(","));
        if (i != -1) {
            csUserName = csValue.Mid(0, i);
            csUserName.TrimRight();
            csValue = csValue.Mid(i+1);
            csValue.TrimLeft();
            *pdwPerm = (DWORD)_ttoi((LPCTSTR)csValue);
        }
    }

    lstrcpy(szPath, (LPCTSTR)csPath);
    lstrcpy(szUserName, (LPCTSTR)csUserName);
    return;
}

void ApplyGlobalToMDVRootTree(CString csKeyPath, CMapStringToString *pGlobalObj)
{
    DebugOutput(_T("ApplyGlobalToMDVRootTree(): csKeyPath=%s, pGlobalObj=0x%x"), csKeyPath, pGlobalObj);

    if (pGlobalObj->GetCount() == 0)
        return;

    POSITION pos = pGlobalObj->GetStartPosition();
    while (pos) {
        BOOL fSkip = FALSE;
        CMDKey cmdKey;
        CString csName, csValue, csPath;

        pGlobalObj->GetNextAssoc(pos, csName, csValue);
        csPath = csKeyPath;
        if (csName.GetLength() > 0 && csName.Compare(_T("/")) != 0)
        {
            csPath += _T("/");
            csPath += csName; // LM/*SVC/N//iisadmin
        }

        cmdKey.OpenNode(csPath);
        if ( (METADATA_HANDLE)cmdKey ) {
            if (csName.Compare(_T("/")) == 0) {
                if (cmdKey.IsEmpty() == FALSE)
                    fSkip = TRUE;
            } else {
                fSkip = TRUE;
            }
            cmdKey.Close();
        }

        if ( !fSkip ) {
            CreateMDVRootTree(csKeyPath, csName, csValue);
        }
    }
}
void CreateMDVRootTree(CString csKeyPath, CString csName, CString csValue)
{
    CMDKey cmdKey;

    DebugOutput(_T("CreateMDVRootTree(): csKeyPath=%s, csName=%s, csValue=%s"), csKeyPath, csName, csValue);

    csKeyPath += _T("/Root");
    if (csName.Compare(_T("/")) != 0)
        csKeyPath += csName;   // LM/W3SVC/N/Root/iisadmin
    csKeyPath.MakeUpper();

    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, csKeyPath);
    if ( (METADATA_HANDLE)cmdKey ) {
        TCHAR szPath[_MAX_PATH], szUserName[_MAX_PATH];
        DWORD dwPerm;

        memset( (PVOID)szPath, 0, sizeof(szPath));
        memset( (PVOID)szUserName, 0, sizeof(szUserName));
        SplitVRString(csValue, szPath, szUserName, &dwPerm);
        cmdKey.SetData(
            MD_VR_PATH,
            METADATA_INHERIT,
            IIS_MD_UT_FILE,
            STRING_METADATA,
            (lstrlen(szPath) + 1) * sizeof(TCHAR),
            (LPBYTE)szPath);

		if (szUserName[0] != _T('\0')) { // do have username and path is UNC
            cmdKey.SetData(
                MD_VR_USERNAME,
                METADATA_INHERIT,
                IIS_MD_UT_FILE,
                STRING_METADATA,
                (lstrlen(szUserName) + 1) * sizeof(TCHAR),
                (LPBYTE)szUserName);

		/*
            CString csPassword = _T("");
            csKeyPath.MakeUpper();
            if (csKeyPath.Find(_T("W3SVC")) != -1)
                csPassword = g_csWWWVRootPassword;
            if (csKeyPath.Find(_T("MSFTPSVC")) != -1)
                csPassword = g_csFTPVRootPassword;
            if (csPassword.IsEmpty() == FALSE)
                cmdKey.SetData(
                    MD_VR_PASSWORD,
                    METADATA_INHERIT | METADATA_SECURE,
                    IIS_MD_UT_FILE,
                    STRING_METADATA,
                    (csPassword.GetLength() + 1) * sizeof(TCHAR),
                    (LPBYTE)(LPCTSTR)csPassword);
		*/
        }
        cmdKey.SetData(
            MD_ACCESS_PERM,
            METADATA_INHERIT,
            IIS_MD_UT_FILE,
            DWORD_METADATA,
            4,
            (LPBYTE)&dwPerm);

        cmdKey.Close();
    }
}

int GetMultiStrLen(LPTSTR p)
{
    int c = 0;

    while (1) {
        if (*p) {
            p++;
            c++;
        } else {
            c++;
            if (*(p+1)) {
                p++;
            } else {
                c++;
                break;
            }
        }
    }
    return c;
}

UINT GetInstNumber(LPCTSTR szMDPath, UINT i)
{
#if 0
    TCHAR Buf[10];
    CString csInstRoot, csMDPath;
    CMDKey cmdKey;

    csInstRoot = szMDPath;
    csInstRoot += _T("/");

    _itot(i, Buf, 10);
    csMDPath = csInstRoot + Buf;
    cmdKey.OpenNode(csMDPath);
    while ( (METADATA_HANDLE)cmdKey ) {
        cmdKey.Close();
        _itot(++i, Buf, 10);
        csMDPath = csInstRoot + Buf;
        cmdKey.OpenNode(csMDPath);
    }

    return (i);
#else
	return 1;
#endif
}
int GetPortNum(LPCTSTR szSvcName)
{
    CString csPath = _T("SYSTEM\\CurrentControlSet\\Control\\Service Provider\\Service Types\\");
    csPath += szSvcName;

    DWORD dwPort = 0;
    if (lstrcmpi(szSvcName, _T("SMTPSVC")) == 0)
        dwPort = 25;
    if (lstrcmpi(szSvcName, _T("POP3SVC")) == 0)
        dwPort = 110;
    if (lstrcmpi(szSvcName, _T("IMAP3SVC")) == 0)
        dwPort = 143;
    if (lstrcmpi(szSvcName, _T("NNTPSVC")) == 0)
        dwPort = 119;

    CRegKey regKey(HKEY_LOCAL_MACHINE, csPath);
    if ( (HKEY)regKey ) {
        regKey.QueryValue(_T("TcpPort"), dwPort);
    }

    return (int)dwPort;
}

void AddVRMapToMD(LPCTSTR szSvcName, CMapStringToOb *pMap)
{
    UINT i = 1;  // instance number is in range of 1 - 4 billion
    UINT n;
    CString csRoot = _T("LM/");
    csRoot += szSvcName; //  "LM/*SVC"
	csRoot.MakeUpper();
    TCHAR Buf[10];
    CMDKey cmdKey;

    DebugOutput(_T("AddVRMapToMD(): szSvcName=%s"), szSvcName );

    CMapStringToString *pGlobalObj;
    pMap->Lookup(_T("null"), (CObject*&)pGlobalObj);

    POSITION pos0 = pMap->GetStartPosition();
    while (pos0) {
        CMapStringToString *pObj;
        CString csIP;
        pMap->GetNextAssoc(pos0, csIP, (CObject*&)pObj);
		TCHAR szIP[256];

		lstrcpy(szIP, csIP);
		if (lstrcmp(szIP, TEXT("null")) == 0) szIP[0] = 0;

        n = GetInstNumber(csRoot, i);
        _itot(n, Buf, 10);
        CString csKeyPath = csRoot;
        csKeyPath += _T("/");
        csKeyPath += Buf; //  "LM/*SVC/N"

        cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, csKeyPath);
        if ( (METADATA_HANDLE)cmdKey ) {
            cmdKey.Close();

            MDEntry stMDEntry;

			HGLOBAL hBlock = NULL;
			hBlock = GlobalAlloc(GPTR, _MAX_PATH * sizeof(TCHAR));
			if (hBlock) {
	            stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
	            stMDEntry.dwMDIdentifier = MD_SERVER_BINDINGS;  // need to be created in iiscnfg.h
	            stMDEntry.dwMDAttributes = METADATA_INHERIT;
	            stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
	            stMDEntry.dwMDDataType = MULTISZ_METADATA;
	            _stprintf((LPTSTR)hBlock, _T("%s:%d:"), szIP, GetPortNum(szSvcName));
	            stMDEntry.dwMDDataLen = GetMultiStrLen((LPTSTR)hBlock) * sizeof(TCHAR);
	            stMDEntry.pbMDData = (LPBYTE)hBlock;
	            SetMDEntry(&stMDEntry, NULL);
			}

            POSITION pos1 = pObj->GetStartPosition();
            while (pos1) {
                CString csValue;
                CString csName;
                pObj->GetNextAssoc(pos1, csName, csValue);
                CreateMDVRootTree(csKeyPath, csName, csValue);
            }
        }

        if (szIP[0] != 0) {
            ApplyGlobalToMDVRootTree(csKeyPath, pGlobalObj);
        }

        i = n+1;
    }
}

void EmptyMap(CMapStringToOb *pMap)
{
    POSITION pos = pMap->GetStartPosition();
    while (pos) {
        CString csKey;
        CMapStringToString *pObj;
        pMap->GetNextAssoc(pos, csKey, (CObject*&)pObj);
        delete pObj;
    }
    pMap->RemoveAll();
}

void SsyncVRoots(LPCTSTR szSvcName, CMapStringToOb *pMap)
{
    CString csParam = _T("System\\CurrentControlSet\\Services\\");
    csParam += szSvcName;
    csParam += _T("\\Parameters");
    CRegKey regParam(HKEY_LOCAL_MACHINE, csParam);
    if ((HKEY)regParam) {
        // remove the old virtual roots key
        regParam.DeleteTree(_T("Virtual Roots"));

        // recreate the key
        CRegKey regVRoots(_T("Virtual Roots"), (HKEY)regParam);
        if ((HKEY)regVRoots) {
            CMapStringToString *pGlobalObj;
            pMap->Lookup(_T("null"), (CObject*&)pGlobalObj);
            POSITION pos = pGlobalObj->GetStartPosition();
            while (pos) {
                CString csValue;
                CString csName;
                pGlobalObj->GetNextAssoc(pos, csName, csValue);
                regVRoots.SetValue(csName, csValue);
            }
        }
    }
}

void AddVRootsToMD(LPCTSTR szSvcName, BOOL fUpgrade)
{
    CMapStringToOb Map;

    DebugOutput(_T("AddVRootsToMD(): szSvcName=%s, fUpgrade=%d"), szSvcName, fUpgrade );

    if (lstrcmpi(szSvcName, _T("NNTPSVC")) == 0)
        CreateVRMap(&Map, REG_NNTPVROOTS, theApp.m_csPathNntpRoot,
						MD_ACCESS_READ | MD_ACCESS_WRITE, fUpgrade);
    else if (lstrcmpi(szSvcName, _T("SMTPSVC")) == 0)
        return;
	else if (lstrcmpi(szSvcName, _T("POP3SVC")) == 0)
        CreateVRMap(&Map, REG_POP3VROOTS, theApp.m_csPathMailroot,
						MD_ACCESS_READ | MD_ACCESS_WRITE, fUpgrade);
    else if (lstrcmpi(szSvcName, _T("IMAPSVC")) == 0)
        CreateVRMap(&Map, REG_IMAPVROOTS, theApp.m_csPathMailroot,
						MD_ACCESS_READ | MD_ACCESS_WRITE, fUpgrade);

//  SsyncVRoots(szSvcName, &Map);

    AddVRMapToMD(szSvcName, &Map);

    EmptyMap(&Map);
}

BOOL MigrateRoutingSourcesToMD(LPCTSTR szSvcName, DWORD dwMDID)
{
	BOOL fResult = TRUE;
	DWORD ec;
	HKEY hKey = NULL;
	CString csKey;
	CString csRegKey;

	DWORD dwType;
	DWORD dwIndex;

	TCHAR pszEnumName[MAX_PATH];
	TCHAR pszData[MAX_PATH];
	TCHAR pszMultiSz[4096];
	TCHAR *pszTemp = pszMultiSz;
	DWORD cbEnumName = sizeof(pszEnumName);
	DWORD cbData = sizeof(pszData);
	DWORD cbMultiSz;
	
	DebugOutput(_T("MigrateRoutingSourcesToMD(): szSvcName=%s, dwMDID=%d"), szSvcName, dwMDID);

	// Initialize the paths
	csRegKey = REG_SERVICES;
	csRegKey += _T("\\");
	csRegKey += szSvcName;
	csRegKey += REG_ROUTING_SOURCES_SUFFIX;
	csKey = _T("LM/");
	csKey += szSvcName;
	csKey += _T("/1/Parameters");
	
	// Initialize the MultiSz
	pszMultiSz[0] = pszMultiSz[1] = 0;

	// Open the key
	ec = RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCTSTR)csRegKey, 0, KEY_ALL_ACCESS, &hKey);
	if (ec == ERROR_SUCCESS)
	{
		dwIndex = 0;
		do
		{
			// do an enum to find out what we should be opening
			cbEnumName = sizeof(pszEnumName) / sizeof(TCHAR);
			cbData = sizeof(pszData);

			ec = RegEnumValue(hKey, dwIndex++, pszEnumName, &cbEnumName,
							  NULL, &dwType, (LPBYTE)pszData, &cbData);
			if (ec != ERROR_SUCCESS)
			{
				// We are done if no more items, error otherwise
				if (ec != ERROR_NO_MORE_ITEMS)
				{
					TCHAR DebugStr[2048];

					wsprintf(DebugStr,
							_T("\nError migrating routing sources (%u)\n"),
							ec);
					DebugOutput(DebugStr);
					
					fResult = FALSE;
				}
				break;
			}

			// Process this value, basically, append it to the multisz
			DebugOutput(pszData);
			cbData /= sizeof(TCHAR);
			lstrcpyn(pszTemp, pszData, cbData);
			pszTemp += cbData;

		} while (1);

		// Add the final terminating NULL;
		*pszTemp++ = 0;

		RegCloseKey(hKey);

		// Now, we have the full MultiSz of routing sources, we can set it to
		// the Metabase.
		cbMultiSz = (DWORD)(pszTemp - pszMultiSz);
		if (cbMultiSz == 1)
			cbMultiSz++;

        MDEntry stMDEntry;
        stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKey;
        stMDEntry.dwMDIdentifier = dwMDID;
        stMDEntry.dwMDAttributes = 0;
        stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
        stMDEntry.dwMDDataType = MULTISZ_METADATA;
        stMDEntry.dwMDDataLen = cbMultiSz * sizeof(TCHAR);
        stMDEntry.pbMDData = (LPBYTE)pszMultiSz;
        SetMDEntry(&stMDEntry, NULL);
	}
	else
	{
		DebugOutput(_T("Unable to open registry key: "));
		DebugOutput(csRegKey);
		fResult = FALSE;
	}

	DebugOutput(_T("\nFinished Migrating Routing Sources\n"));
	return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\makefile.inc ===
$(O)\seo.h : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\mdentry.h ===
#ifndef _MDENTRY_H_
#define _MDENTRY_H_

class CDWord : public CObject
{
protected:
    DWORD m_dwData;

public:
    CDWord(DWORD dwData) { m_dwData = dwData; }
    ~CDWord() {};

    operator DWORD () { return m_dwData; }
};

// fMigrate, fKeepOldReg, hRegRootKey, szRegSubKey, szRegValueName, 
// szMDPath, dwMDId, dwMDAttr, dwMDuType, dwMDdType, dwMDDataLen, szMDData 

typedef struct _MDEntry {
    LPTSTR szMDPath;
    DWORD dwMDIdentifier;
    DWORD dwMDAttributes;
    DWORD dwMDUserType;
    DWORD dwMDDataType;
    DWORD dwMDDataLen;
    LPBYTE pbMDData;
} MDEntry;

DWORD atodw(LPCTSTR lpszData);
BOOL SplitLine(LPTSTR szLine);
// if the regkey part of szLine contains a * then this can enumerate across the keys.
// to enumerate dwIndex should be set to 0 on the first call.  pszKey gets the name where
// the * is in the regkey name.  if pszKey == \0 then enumeration is done.  dwIndex should
// be incremented on each call
BOOL SetupMDEntry(LPTSTR szLine, BOOL fUpgrade);
void SetMDEntry(MDEntry *pMDEntry, LPTSTR pszKey, BOOL fSetOnlyIfNotPresent=FALSE);
void MigrateNNTPToMD(HINF hInf, LPCTSTR szSection, BOOL fUpgrade);
void MigrateIMSToMD(
					HINF hInf, 
					LPCTSTR szServerName, 
					LPCTSTR szSection, 
					DWORD dwRoutingSourcesMDID, 
					BOOL fUpgrade,
					BOOL k2UpgradeToEE = FALSE
					);
void MigrateInfSectionToMD(HINF hInf, LPCTSTR szSection, BOOL fUpgrade);
void AddVRootsToMD(LPCTSTR szSvcName, BOOL fUpgrade);
void CreateMDVRootTree(CString csKeyPath, CString csName, CString csValue);
void SplitVRString(CString csValue, LPTSTR szPath, LPTSTR szUserName, DWORD *pdwPerm);

BOOL MigrateRoutingSourcesToMD(LPCTSTR szSvcName, DWORD dwMDID);

#endif // _MDENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\mdkey.cpp ===
#include "stdafx.h"

#define INITGUID
#define _WIN32_DCOM
#undef DEFINE_GUID      // Added for NT5 migration
#include <ole2.h>
#include <coguid.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"

#define TIMEOUT_VALUE 5000

CMDKey::CMDKey()
{
    m_pcCom = NULL;
    m_hKey = NULL;
    m_fNeedToClose = FALSE;
}

CMDKey::~CMDKey()
{
    this->Close();
}

void SetErrMsg(LPTSTR szMsg, HRESULT hRes)
{
    CString csMsg;
    csMsg.Format(_T("%s, %x"), szMsg, hRes);
    MyMessageBox(NULL, csMsg, _T("IMS/INS Metabase Error"), 
					MB_OK | MB_TASKMODAL | MB_SETFOREGROUND);

    return;
}

void TraceErrMsg(LPTSTR szMsg, HRESULT hRes)
{
    CString csMsg;
    csMsg.Format(_T("%s, %x"), szMsg, hRes);
	DebugOutput(csMsg);
    return;
}

void CMDKey::OpenNode(LPCTSTR pchSubKeyPath)
{
    BOOL fInitialized = FALSE;
    HRESULT hRes;
    IClassFactory * pcsfFactory = NULL;
    BOOL b = FALSE;
    m_pcCom = NULL;
    m_hKey = NULL;
    WCHAR szSubKeyPath[_MAX_PATH];
	DWORD dwRetry = 0;

    DebugOutput(_T("OpenNode(): pchSubKeyPath=%s"), pchSubKeyPath);

    pszFailedAPI = NULL;

    if ( !pchSubKeyPath || !(*pchSubKeyPath) ) {
        *szSubKeyPath = L'\0';
    } else {
#if defined(UNICODE) || defined(_UNICODE)
        lstrcpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH);
#endif
    }

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( SUCCEEDED(hRes) || hRes == E_INVALIDARG || hRes == RPC_E_CHANGED_MODE ) {
        fInitialized = TRUE;
        if ( SUCCEEDED(hRes) || hRes == E_INVALIDARG )
            m_fNeedToClose = TRUE; // need to be closed later
    }

    if (!fInitialized) {
        SetErrMsg(_T("CoInitializeEx"), hRes);
    } else {
		dwRetry = 0;
		do
		{
	        hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);

			if (FAILED(hRes))
			{
				TraceErrMsg(_T("Retrying on OpenNode::CoGetClassObject"), hRes);

				// Add a small delay
				Sleep(100);
			}

		} while ((FAILED(hRes)) && (++dwRetry < 5));

        if (FAILED(hRes)) {
            SetErrMsg(_T("CoGetClassObject"), hRes);
        } else {
            hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
            pcsfFactory->Release();
            if (FAILED(hRes)) {
                SetErrMsg(_T("CoCreateInstance"), hRes);
            } else {
				dwRetry = 0;
				do
				{
					hRes = m_pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
										  szSubKeyPath,
										  METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
										  TIMEOUT_VALUE,
										  &m_hKey);
					if (FAILED(hRes))
					{
						TraceErrMsg(_T("Retrying on OpenNode::OpenKey"), hRes);

						// Add a small delay
						Sleep(100);
					}

				} while ((FAILED(hRes)) && (++dwRetry < 5));
                if (FAILED(hRes)) {
                    if (hRes != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
                        SetErrMsg(_T("OpenKey"), hRes);
                    }
                } else {
                    b = TRUE;
                }
            } // end of CoCreateInstance
        } // end of CoGetClassObject
    }

    if (!b) {
        this->Close();
    }

    return;
}

void CMDKey::CreateNode(METADATA_HANDLE hKeyBase, LPCTSTR pchSubKeyPath)
{
    BOOL fInitialized = FALSE;
    HRESULT hRes;
    IClassFactory * pcsfFactory = NULL;
    BOOL b = FALSE;
    m_pcCom = NULL;
    m_hKey = NULL;
    WCHAR szSubKeyPath[_MAX_PATH];
	DWORD dwRetry = 0;

    DebugOutput(_T("CreateNode(): hKeyBase=0x%x, pchSubKeyPath=%s"), hKeyBase, pchSubKeyPath);
    
    pszFailedAPI = NULL;

    if ( !pchSubKeyPath || !(*pchSubKeyPath) ) {
        *szSubKeyPath = L'\0';
    } else {
#if defined(UNICODE) || defined(_UNICODE)
        lstrcpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH);
#endif
    }

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( SUCCEEDED(hRes) || hRes == E_INVALIDARG || hRes == RPC_E_CHANGED_MODE ) {
        fInitialized = TRUE;
        if ( SUCCEEDED(hRes) || hRes == E_INVALIDARG )
            m_fNeedToClose = TRUE; // need to be closed later
    }

    if (!fInitialized) {
        SetErrMsg(_T("CoInitializeEx"), hRes);
    } else {
        hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);
        if (FAILED(hRes)) {
            SetErrMsg(_T("CoGetClassObject"), hRes);
        } else {
            hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
            pcsfFactory->Release();
            if (FAILED(hRes)) {
                SetErrMsg(_T("CoCreateInstance"), hRes);
            } else {
				hRes = m_pcCom->OpenKey(hKeyBase,
									  szSubKeyPath,
									  METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
									  TIMEOUT_VALUE,
									  &m_hKey);
                if (FAILED(hRes)) 
				{
                    if (hRes == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
                        METADATA_HANDLE RootHandle;
                        hRes = m_pcCom->OpenKey(hKeyBase,
                                      L"",
                                      METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                                      TIMEOUT_VALUE,
                                      &RootHandle);
                        hRes = m_pcCom->AddKey(RootHandle, szSubKeyPath);
                        if (FAILED(hRes)) {
                            SetErrMsg(_T("AddKey"), hRes);
                        } 
                        hRes = m_pcCom->CloseKey(RootHandle);
                        if (FAILED(hRes)) {
                            SetErrMsg(_T("CloseKey of AddKey"), hRes);
                        } 
						else 
						{
							dwRetry = 0;
                            do
							{
								// open it again to set m_hKey
								hRes = m_pcCom->OpenKey(hKeyBase,
											  szSubKeyPath,
											  METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
											  TIMEOUT_VALUE,
											  &m_hKey);
								if (FAILED(hRes))
								{
									TraceErrMsg(_T("Retrying on CreateNode::OpenKey"), hRes);

									// Add a small delay
									Sleep(100);
								}

							} while ((FAILED(hRes)) && (++dwRetry < 5));

                            if (FAILED(hRes)) {
                                SetErrMsg(_T("OpenKey"), hRes);
                            } else {
                                b = TRUE;
                            }
                        }
                    } else {
                        SetErrMsg(_T("OpenKey"), hRes);
                    }
                } else {
                    b = TRUE;
                } // end of OpenKey
            } // end of CoCreateInstance
        } // end of CoGetClassObject
    } // end of CoInitializeEx

    if (!b) {
        this->Close();
    }

    return;
}

void CMDKey::Close()
{
    HRESULT hRes;
    if (m_pcCom) {
        if (m_hKey)
            hRes = m_pcCom->CloseKey(m_hKey);

		// Call save data anyway for good measure
		hRes = m_pcCom->SaveData();
        hRes = m_pcCom->Release();
    }
    if (m_fNeedToClose)
        CoUninitialize();

    m_pcCom = NULL;
    m_hKey = NULL;
    m_fNeedToClose = FALSE;

    return;
}
#define FILL_RETURN_BUFF   for(ReturnIndex=0;ReturnIndex<sizeof(ReturnBuf);ReturnIndex++)ReturnBuf[ReturnIndex]=0xff;

BOOL CMDKey::IsEmpty()
{
    int ReturnIndex;
    METADATA_RECORD mdrData;
    DWORD dwRequiredDataLen = 0;
    HRESULT hRes;
    UCHAR ReturnBuf[256];
    FILL_RETURN_BUFF;
    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
    hRes = m_pcCom->EnumData(m_hKey, L"", &mdrData, 0, &dwRequiredDataLen);
    if (FAILED(hRes)) {
        if(hRes == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS) ||
           hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER) ) {
            return TRUE;
        } else {
            SetErrMsg(_T("EnumData"), hRes);
        }
    }
    return (hRes != ERROR_SUCCESS);
}

int CMDKey::GetNumberOfSubKeys()
{
    int i=0;
    HRESULT hRes = ERROR_SUCCESS;
    WCHAR NameBuf[METADATA_MAX_NAME_LEN];
    while (hRes == ERROR_SUCCESS) {
        hRes = m_pcCom->EnumKeys(m_hKey, L"", NameBuf, i++);
    }
    if (hRes == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS))
        return (--i);
    else {
        SetErrMsg(_T("EnumKeys"), hRes);
        return (0);
    }
}

void MyMultiByteToWideChar( char *sData, WCHAR *wData, int cbBufSize, BOOL fMultiSZ)
{
    MultiByteToWideChar( CP_ACP, 0, sData, -1, wData, cbBufSize );
    while (fMultiSZ) {
        while (*sData++);
        while (*wData++);
        if (*sData)
            MultiByteToWideChar( CP_ACP, 0, sData, -1, wData, cbBufSize );
        else {
            *wData = L'\0';
            break;
        }
    }
    return;
}

BOOL CMDKey::SetData(
     DWORD id,
     DWORD attr,
     DWORD uType,
     DWORD dType,
     DWORD cbLen, // number of bytes
     LPBYTE pbData)
{
    HRESULT hRes;
    METADATA_RECORD mdrData;
    WCHAR *pData = NULL;
	BOOL fRet = FALSE;

    switch (dType) 
	{
	case DWORD_METADATA:
        pData = (WCHAR *)pbData;
		break;
	case BINARY_METADATA:
        pData = (WCHAR *)pbData;
		break;
    case STRING_METADATA:
    case EXPANDSZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
        pData = (WCHAR *)pbData;
#else
		pData = (WCHAR *)LocalAlloc(0, cbLen * sizeof(WCHAR));
		if (!pData)
            return FALSE;  // insufficient memory
        MyMultiByteToWideChar( (LPSTR)pbData, pData, cbLen, FALSE);
        cbLen = cbLen * sizeof(WCHAR);
#endif
        break;

    case MULTISZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
        pData = (WCHAR *)pbData;
#else
		pData = (WCHAR *)LocalAlloc(0, cbLen * sizeof(WCHAR));
		if (!pData)
            return FALSE;  // insufficient memory
        MyMultiByteToWideChar( (LPSTR)pbData, pData, cbLen, TRUE );
        cbLen = cbLen * sizeof(WCHAR);
#endif
        break;

    default:
        break;

    }

    if (cbLen > 0) 
	{
        MD_SET_DATA_RECORD(&mdrData, id, attr, uType, dType, cbLen, (LPBYTE)pData);

        hRes = m_pcCom->SetData(m_hKey, L"", &mdrData);
        if (FAILED(hRes)) 
            SetErrMsg(_T("SetData"), hRes);
		else
			fRet = TRUE;
    }

	if (pData && (pData != (WCHAR *)pbData))
		LocalFree(pData);

    return(fRet);
}

// Note: only use to access the AnonyName and AnonyPassword,
// buffer size 256 is big enough here
// sneely: Now used to see if a key exists as well.
BOOL CMDKey::GetData(DWORD id,
     DWORD *pdwAttr,
     DWORD *pdwUType,
     DWORD *pdwDType,
     DWORD *pcbLen, // number of bytes
     LPBYTE pbData)
{
    int ReturnIndex;
    BOOL fReturn = FALSE;
    HRESULT hRes;
    METADATA_RECORD mdrData;
    DWORD dwRequiredDataLen = 0;
    UCHAR ReturnBuf[256];
    FILL_RETURN_BUFF;
    MD_SET_DATA_RECORD(&mdrData, id, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf);

    hRes = m_pcCom->GetData(m_hKey, L"", &mdrData, &dwRequiredDataLen);
    if (FAILED(hRes)) {
		// MCIS uses this to see if an MD value exists, so we don't
		// complain if it's not found.
        //SetErrMsg(_T("GetData"), hRes);
    } else {
        *pdwAttr = mdrData.dwMDAttributes;
        *pdwUType = mdrData.dwMDUserType;
        *pdwDType = mdrData.dwMDDataType;
        *pcbLen = mdrData.dwMDDataLen; // number of SBCS chars + ending \0
        fReturn = TRUE;
        switch (*pdwDType) {
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
            memcpy(pbData, mdrData.pbMDData, *pcbLen);
#else
            *pcbLen = (*pcbLen) / sizeof(WCHAR);
            WideCharToMultiByte(
                CP_ACP,
                0,
                (WCHAR *)(mdrData.pbMDData),
                -1,
                (LPSTR)pbData,
                *pcbLen, NULL, NULL);
#endif
            break;
        default:
            memcpy(pbData, mdrData.pbMDData, *pcbLen);
            break;
        }
    }

    return fReturn;
}

void CMDKey::DeleteData(DWORD id, DWORD dType)
{
    m_pcCom->DeleteData(m_hKey, L"", id, dType);

    return;
}

BOOL CMDKey::SetData(PMETADATA_RECORD pRec)
{
    HRESULT hRes;
	BOOL	fResult = FALSE;

    hRes = m_pcCom->SetData(m_hKey, L"", pRec);
    if (FAILED(hRes)) 
        SetErrMsg(_T("SetData"), hRes);
	else
		fResult = TRUE;

    return fResult;
}

BOOL CMDKey::GetData(PMETADATA_RECORD pRec)
{
    BOOL fReturn = FALSE;
    HRESULT hRes;
    DWORD dwRequiredDataLen = 0;

    hRes = m_pcCom->GetData(m_hKey, L"", pRec, &dwRequiredDataLen);
    if (FAILED(hRes)) 
        SetErrMsg(_T("GetData"), hRes);
	else     
		fReturn = TRUE;
	
	return fReturn;
}

BOOL CMDKey::EnumData(DWORD dwIndex, PMETADATA_RECORD pRec)
{
    BOOL fReturn = FALSE;
    HRESULT hRes;
    DWORD dwRequiredDataLen = 0;

    hRes = m_pcCom->EnumData(m_hKey, L"", pRec, dwIndex, &dwRequiredDataLen);
	if (FAILED(hRes))
        if( hRes == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS) ||
            hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER) )
            fReturn = FALSE;
        else
            SetErrMsg(_T("EnumData"), hRes);
	else
		fReturn = TRUE;

	return fReturn;	
}

void CMDKey::DeleteNode(LPCTSTR pchSubKeyPath)
{
    HRESULT hRes;
    WCHAR szSubKeyPath[_MAX_PATH];

    if ( pchSubKeyPath && (*pchSubKeyPath) ) {
#if defined(UNICODE) || defined(_UNICODE)
        lstrcpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH );
#endif

        hRes = m_pcCom->DeleteKey(m_hKey, szSubKeyPath);
    }

    return;
}

CMDKeyIter::CMDKeyIter(CMDKey &cmdKey)
{
    m_hKey = cmdKey.GetMDKeyHandle();
    m_pcCom = cmdKey.GetMDKeyICOM();

    m_dwBuffer = _MAX_PATH;

    Reset();

    m_pBuffer = new WCHAR [m_dwBuffer];
}

CMDKeyIter::~CMDKeyIter()
{
    delete [] m_pBuffer;
}

LONG CMDKeyIter::Next(CString *pcsName)
{
    TCHAR tchData[_MAX_PATH];
    HRESULT hRes;
    hRes = m_pcCom->EnumKeys(m_hKey, L"", m_pBuffer, m_index);
    if (FAILED(hRes)) {
        return 1;
    } else {
#if defined(UNICODE) || defined(_UNICODE)
        lstrcpy(tchData, m_pBuffer);
#else
        WideCharToMultiByte(CP_ACP,0,m_pBuffer,-1,(LPSTR)tchData,_MAX_PATH, NULL, NULL);
#endif
        *pcsName = tchData;
        m_index++;
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\mycomput.h ===
// Nodetypes for the Computer Management snapin
// created by UUIDGEN 4/1/97 JonN

#ifndef _UUIDS_COMPUTER_MANAGEMENT_
#define _UUIDS_COMPUTER_MANAGEMENT_

#define struuidNodetypeComputer      "{476e6446-aaff-11d0-b944-00c04fd8d5b0}"
#define struuidNodetypeDrive         "{476e6447-aaff-11d0-b944-00c04fd8d5b0}"
#define struuidNodetypeSystemTools   "{476e6448-aaff-11d0-b944-00c04fd8d5b0}"
#define struuidNodetypeServerApps    "{476e6449-aaff-11d0-b944-00c04fd8d5b0}"
#define struuidNodetypeStorage       "{476e644a-aaff-11d0-b944-00c04fd8d5b0}"

#define lstruuidNodetypeComputer    L"{476e6446-aaff-11d0-b944-00c04fd8d5b0}"
#define lstruuidNodetypeDrive       L"{476e6447-aaff-11d0-b944-00c04fd8d5b0}"
#define lstruuidNodetypeSystemTools L"{476e6448-aaff-11d0-b944-00c04fd8d5b0}"
#define lstruuidNodetypeServerApps  L"{476e6449-aaff-11d0-b944-00c04fd8d5b0}"
#define lstruuidNodetypeStorage     L"{476e644a-aaff-11d0-b944-00c04fd8d5b0}"

#define structuuidNodetypeComputer    \
    { 0x476e6446, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
#define structuuidNodetypeDrive       \
    { 0x476e6447, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
#define structuuidNodetypeSystemTools \
    { 0x476e6448, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
#define structuuidNodetypeServerApps  \
    { 0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
#define structuuidNodetypeStorage     \
    { 0x476e644a, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }

#endif // _UUIDS_COMPUTER_MANAGEMENT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\mdkey.h ===
#ifndef _MDKEY_H_
#define _MDKEY_H_

interface IMSAdminBase;

void SetErrMsg(LPTSTR szMsg, HRESULT hRes);

class CMDKey : public CObject
{
protected: 
    IMSAdminBase * m_pcCom;
    METADATA_HANDLE m_hKey;
    BOOL m_fNeedToClose;
    LPTSTR pszFailedAPI;

public:
    CMDKey();
    ~CMDKey();

    // allow CMDKey to be used where type METADATA_HANDLE is required
    operator METADATA_HANDLE ()
        { return m_hKey; }
    METADATA_HANDLE GetMDKeyHandle() {return m_hKey;}
    IMSAdminBase *GetMDKeyICOM() {return m_pcCom;}

    // open an existing MD key
    void OpenNode(LPCTSTR pchSubKeyPath);
    // to open an existing MD key, or create one if doesn't exist
    void CreateNode(METADATA_HANDLE hKeyBase, LPCTSTR pchSubKeyPath);
    // close node opened/created by OpenNode() or CreateNode()
    void Close();

    void DeleteNode(LPCTSTR pchSubKeyPath);

    BOOL IsEmpty();
    int GetNumberOfSubKeys();

    BOOL SetData(
     DWORD id,
     DWORD attr,
     DWORD uType,
     DWORD dType,
     DWORD cbLen,
     LPBYTE pbData);
    BOOL GetData(DWORD id,
     DWORD *pdwAttr,
     DWORD *pdwUType,
     DWORD *pdwDType,
     DWORD *pcbLen,
     LPBYTE pbData);
    void DeleteData(DWORD id, DWORD dType);

    BOOL SetData(PMETADATA_RECORD pRec);
    BOOL GetData(PMETADATA_RECORD pRec);

	BOOL EnumData(DWORD dwIndex, PMETADATA_RECORD pRec);
};

class CMDKeyIter : public CObject
{
protected:
    IMSAdminBase * m_pcCom;
    METADATA_HANDLE m_hKey;
    DWORD m_index;
    LPWSTR m_pBuffer;
    DWORD m_dwBuffer;

public:
    CMDKeyIter(CMDKey &cmdKey);
    ~CMDKeyIter();

    LONG Next(CString *pcsName);

    void Reset() {m_index = 0;}
};

#endif // _MDKEY_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\ndmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Sat Aug 09 00:03:49 1997
 */
/* Compiler settings for ndmgr.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ndmgr_h__
#define __ndmgr_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IComponentData_FWD_DEFINED__
#define __IComponentData_FWD_DEFINED__
typedef interface IComponentData IComponentData;
#endif 	/* __IComponentData_FWD_DEFINED__ */


#ifndef __IComponent_FWD_DEFINED__
#define __IComponent_FWD_DEFINED__
typedef interface IComponent IComponent;
#endif 	/* __IComponent_FWD_DEFINED__ */


#ifndef __IResultDataCompare_FWD_DEFINED__
#define __IResultDataCompare_FWD_DEFINED__
typedef interface IResultDataCompare IResultDataCompare;
#endif 	/* __IResultDataCompare_FWD_DEFINED__ */


#ifndef __IResultOwnerData_FWD_DEFINED__
#define __IResultOwnerData_FWD_DEFINED__
typedef interface IResultOwnerData IResultOwnerData;
#endif 	/* __IResultOwnerData_FWD_DEFINED__ */


#ifndef __IConsole_FWD_DEFINED__
#define __IConsole_FWD_DEFINED__
typedef interface IConsole IConsole;
#endif 	/* __IConsole_FWD_DEFINED__ */


#ifndef __IHeaderCtrl_FWD_DEFINED__
#define __IHeaderCtrl_FWD_DEFINED__
typedef interface IHeaderCtrl IHeaderCtrl;
#endif 	/* __IHeaderCtrl_FWD_DEFINED__ */


#ifndef __IContextMenuCallback_FWD_DEFINED__
#define __IContextMenuCallback_FWD_DEFINED__
typedef interface IContextMenuCallback IContextMenuCallback;
#endif 	/* __IContextMenuCallback_FWD_DEFINED__ */


#ifndef __IContextMenuProvider_FWD_DEFINED__
#define __IContextMenuProvider_FWD_DEFINED__
typedef interface IContextMenuProvider IContextMenuProvider;
#endif 	/* __IContextMenuProvider_FWD_DEFINED__ */


#ifndef __IExtendContextMenu_FWD_DEFINED__
#define __IExtendContextMenu_FWD_DEFINED__
typedef interface IExtendContextMenu IExtendContextMenu;
#endif 	/* __IExtendContextMenu_FWD_DEFINED__ */


#ifndef __IImageList_FWD_DEFINED__
#define __IImageList_FWD_DEFINED__
typedef interface IImageList IImageList;
#endif 	/* __IImageList_FWD_DEFINED__ */


#ifndef __IResultData_FWD_DEFINED__
#define __IResultData_FWD_DEFINED__
typedef interface IResultData IResultData;
#endif 	/* __IResultData_FWD_DEFINED__ */


#ifndef __IConsoleNameSpace_FWD_DEFINED__
#define __IConsoleNameSpace_FWD_DEFINED__
typedef interface IConsoleNameSpace IConsoleNameSpace;
#endif 	/* __IConsoleNameSpace_FWD_DEFINED__ */


#ifndef __IPropertySheetCallback_FWD_DEFINED__
#define __IPropertySheetCallback_FWD_DEFINED__
typedef interface IPropertySheetCallback IPropertySheetCallback;
#endif 	/* __IPropertySheetCallback_FWD_DEFINED__ */


#ifndef __IPropertySheetProvider_FWD_DEFINED__
#define __IPropertySheetProvider_FWD_DEFINED__
typedef interface IPropertySheetProvider IPropertySheetProvider;
#endif 	/* __IPropertySheetProvider_FWD_DEFINED__ */


#ifndef __IExtendPropertySheet_FWD_DEFINED__
#define __IExtendPropertySheet_FWD_DEFINED__
typedef interface IExtendPropertySheet IExtendPropertySheet;
#endif 	/* __IExtendPropertySheet_FWD_DEFINED__ */


#ifndef __IControlbar_FWD_DEFINED__
#define __IControlbar_FWD_DEFINED__
typedef interface IControlbar IControlbar;
#endif 	/* __IControlbar_FWD_DEFINED__ */


#ifndef __IExtendControlbar_FWD_DEFINED__
#define __IExtendControlbar_FWD_DEFINED__
typedef interface IExtendControlbar IExtendControlbar;
#endif 	/* __IExtendControlbar_FWD_DEFINED__ */


#ifndef __IToolbar_FWD_DEFINED__
#define __IToolbar_FWD_DEFINED__
typedef interface IToolbar IToolbar;
#endif 	/* __IToolbar_FWD_DEFINED__ */


#ifndef __IConsoleVerb_FWD_DEFINED__
#define __IConsoleVerb_FWD_DEFINED__
typedef interface IConsoleVerb IConsoleVerb;
#endif 	/* __IConsoleVerb_FWD_DEFINED__ */


#ifndef __ISnapinAbout_FWD_DEFINED__
#define __ISnapinAbout_FWD_DEFINED__
typedef interface ISnapinAbout ISnapinAbout;
#endif 	/* __ISnapinAbout_FWD_DEFINED__ */


#ifndef __IMenuButton_FWD_DEFINED__
#define __IMenuButton_FWD_DEFINED__
typedef interface IMenuButton IMenuButton;
#endif 	/* __IMenuButton_FWD_DEFINED__ */


#ifndef __ISnapinHelp_FWD_DEFINED__
#define __ISnapinHelp_FWD_DEFINED__
typedef interface ISnapinHelp ISnapinHelp;
#endif 	/* __ISnapinHelp_FWD_DEFINED__ */


#ifndef __IPropertySheetChange_FWD_DEFINED__
#define __IPropertySheetChange_FWD_DEFINED__
typedef interface IPropertySheetChange IPropertySheetChange;
#endif 	/* __IPropertySheetChange_FWD_DEFINED__ */


#ifndef __IFramePrivate_FWD_DEFINED__
#define __IFramePrivate_FWD_DEFINED__
typedef interface IFramePrivate IFramePrivate;
#endif 	/* __IFramePrivate_FWD_DEFINED__ */


#ifndef __IScopeDataPrivate_FWD_DEFINED__
#define __IScopeDataPrivate_FWD_DEFINED__
typedef interface IScopeDataPrivate IScopeDataPrivate;
#endif 	/* __IScopeDataPrivate_FWD_DEFINED__ */


#ifndef __IImageListPrivate_FWD_DEFINED__
#define __IImageListPrivate_FWD_DEFINED__
typedef interface IImageListPrivate IImageListPrivate;
#endif 	/* __IImageListPrivate_FWD_DEFINED__ */


#ifndef __IResultDataPrivate_FWD_DEFINED__
#define __IResultDataPrivate_FWD_DEFINED__
typedef interface IResultDataPrivate IResultDataPrivate;
#endif 	/* __IResultDataPrivate_FWD_DEFINED__ */


#ifndef __IScopeTree_FWD_DEFINED__
#define __IScopeTree_FWD_DEFINED__
typedef interface IScopeTree IScopeTree;
#endif 	/* __IScopeTree_FWD_DEFINED__ */


#ifndef __IScopeTreeIter_FWD_DEFINED__
#define __IScopeTreeIter_FWD_DEFINED__
typedef interface IScopeTreeIter IScopeTreeIter;
#endif 	/* __IScopeTreeIter_FWD_DEFINED__ */


#ifndef __INodeCallback_FWD_DEFINED__
#define __INodeCallback_FWD_DEFINED__
typedef interface INodeCallback INodeCallback;
#endif 	/* __INodeCallback_FWD_DEFINED__ */


#ifndef __IControlbarsCache_FWD_DEFINED__
#define __IControlbarsCache_FWD_DEFINED__
typedef interface IControlbarsCache IControlbarsCache;
#endif 	/* __IControlbarsCache_FWD_DEFINED__ */


#ifndef __IContextMenuProviderPrivate_FWD_DEFINED__
#define __IContextMenuProviderPrivate_FWD_DEFINED__
typedef interface IContextMenuProviderPrivate IContextMenuProviderPrivate;
#endif 	/* __IContextMenuProviderPrivate_FWD_DEFINED__ */


#ifndef __INodeType_FWD_DEFINED__
#define __INodeType_FWD_DEFINED__
typedef interface INodeType INodeType;
#endif 	/* __INodeType_FWD_DEFINED__ */


#ifndef __INodeTypesCache_FWD_DEFINED__
#define __INodeTypesCache_FWD_DEFINED__
typedef interface INodeTypesCache INodeTypesCache;
#endif 	/* __INodeTypesCache_FWD_DEFINED__ */


#ifndef __IEnumGUID_FWD_DEFINED__
#define __IEnumGUID_FWD_DEFINED__
typedef interface IEnumGUID IEnumGUID;
#endif 	/* __IEnumGUID_FWD_DEFINED__ */


#ifndef __IEnumNodeTypes_FWD_DEFINED__
#define __IEnumNodeTypes_FWD_DEFINED__
typedef interface IEnumNodeTypes IEnumNodeTypes;
#endif 	/* __IEnumNodeTypes_FWD_DEFINED__ */


#ifndef __IDocConfig_FWD_DEFINED__
#define __IDocConfig_FWD_DEFINED__
typedef interface IDocConfig IDocConfig;
#endif 	/* __IDocConfig_FWD_DEFINED__ */


#ifndef __NodeInit_FWD_DEFINED__
#define __NodeInit_FWD_DEFINED__

#ifdef __cplusplus
typedef class NodeInit NodeInit;
#else
typedef struct NodeInit NodeInit;
#endif /* __cplusplus */

#endif 	/* __NodeInit_FWD_DEFINED__ */


#ifndef __ScopeTree_FWD_DEFINED__
#define __ScopeTree_FWD_DEFINED__

#ifdef __cplusplus
typedef class ScopeTree ScopeTree;
#else
typedef struct ScopeTree ScopeTree;
#endif /* __cplusplus */

#endif 	/* __ScopeTree_FWD_DEFINED__ */


#ifndef __MMCDocConfig_FWD_DEFINED__
#define __MMCDocConfig_FWD_DEFINED__

#ifdef __cplusplus
typedef class MMCDocConfig MMCDocConfig;
#else
typedef struct MMCDocConfig MMCDocConfig;
#endif /* __cplusplus */

#endif 	/* __MMCDocConfig_FWD_DEFINED__ */


#ifndef __IPropertySheetProviderPrivate_FWD_DEFINED__
#define __IPropertySheetProviderPrivate_FWD_DEFINED__
typedef interface IPropertySheetProviderPrivate IPropertySheetProviderPrivate;
#endif 	/* __IPropertySheetProviderPrivate_FWD_DEFINED__ */


#ifndef __IMMCListView_FWD_DEFINED__
#define __IMMCListView_FWD_DEFINED__
typedef interface IMMCListView IMMCListView;
#endif 	/* __IMMCListView_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0000
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 























typedef IConsole __RPC_FAR *LPCONSOLE;

typedef IHeaderCtrl __RPC_FAR *LPHEADERCTRL;

typedef IToolbar __RPC_FAR *LPTOOLBAR;

typedef IImageList __RPC_FAR *LPIMAGELIST;

typedef IResultData __RPC_FAR *LPRESULTDATA;

typedef IConsoleNameSpace __RPC_FAR *LPCONSOLENAMESPACE;

typedef IPropertySheetProvider __RPC_FAR *LPPROPERTYSHEETPROVIDER;

typedef IPropertySheetCallback __RPC_FAR *LPPROPERTYSHEETCALLBACK;

typedef IContextMenuProvider __RPC_FAR *LPCONTEXTMENUPROVIDER;

typedef IContextMenuCallback __RPC_FAR *LPCONTEXTMENUCALLBACK;

typedef IControlbar __RPC_FAR *LPCONTROLBAR;

typedef IConsoleVerb __RPC_FAR *LPCONSOLEVERB;

typedef IMenuButton __RPC_FAR *LPMENUBUTTON;

typedef IComponent __RPC_FAR *LPCOMPONENT;

typedef IComponentData __RPC_FAR *LPCOMPONENTDATA;

typedef IExtendPropertySheet __RPC_FAR *LPEXTENDPROPERTYSHEET;

typedef IExtendContextMenu __RPC_FAR *LPEXTENDCONTEXTMENU;

typedef IExtendControlbar __RPC_FAR *LPEXTENDCONTROLBAR;

typedef IResultDataCompare __RPC_FAR *LPRESULTDATACOMPARE;

typedef ISnapinAbout __RPC_FAR *LPSNAPABOUT;

typedef IResultOwnerData __RPC_FAR *LPRESULTOWNERDATA;

#define	MMCLV_AUTO	( -1 )

#define	MMCLV_NOPARAM	( -2 )

#define	MMCLV_NOICON	( -1 )

#define	MMCLV_VIEWSTYLE_ICON	( 0 )

#define	MMCLV_VIEWSTYLE_SMALLICON	( 0x2 )

#define	MMCLV_VIEWSTYLE_LIST	( 0x3 )

#define	MMCLV_VIEWSTYLE_REPORT	( 0x1 )

#define	MMCLV_NOPTR	( 0 )

#define	MMCLV_UPDATE_NOINVALIDATEALL	( 0x1 )

#define	MMCLV_UPDATE_NOSCROLL	( 0x2 )

static unsigned short __RPC_FAR *MMC_CALLBACK	=	( unsigned short __RPC_FAR * )-1;

typedef long HSCOPEITEM;

typedef long COMPONENTID;

typedef long HRESULTITEM;

#define	RDI_STR	( 0x2 )

#define	RDI_IMAGE	( 0x4 )

#define	RDI_STATE	( 0x8 )

#define	RDI_PARAM	( 0x10 )

#define	RDI_INDEX	( 0x20 )

#define	RDI_INDENT	( 0x40 )

typedef 
enum _MMC_RESULT_VIEW_STYLE
    {	MMC_SINGLESEL	= 0x1,
	MMC_SHOWSELALWAYS	= 0x2,
	MMC_NOSORTHEADER	= 0x4
    }	MMC_RESULT_VIEW_STYLE;

#define	MMC_VIEW_OPTIONS_NONE	( 0 )

#define	MMC_VIEW_OPTIONS_NOLISTVIEWS	( 0x1 )

#define	MMC_VIEW_OPTIONS_MULTISELECT	( 0x2 )

#define	MMC_VIEW_OPTIONS_OWNERDATALIST	( 0x4 )

#define	MMC_VIEW_OPTIONS_FILTERED	( 0x8 )

#define	MMC_VIEW_OPTIONS_CREATENEW	( 0x10 )

#define	MMC_PSO_NOAPPLYNOW	( 0x1 )

#define	MMC_PSO_HASHELP	( 0x2 )

#define	MMC_PSO_NEWWIZARDTYPE	( 0x4 )

typedef 
enum _MMC_CONTROL_TYPE
    {	TOOLBAR	= 0,
	MENUBUTTON	= TOOLBAR + 1,
	COMBOBOXBAR	= MENUBUTTON + 1
    }	MMC_CONTROL_TYPE;

typedef 
enum _MMC_CONSOLE_VERB
    {	MMC_VERB_NONE	= 0,
	MMC_VERB_OPEN	= 0x8000,
	MMC_VERB_COPY	= 0x8001,
	MMC_VERB_PASTE	= 0x8002,
	MMC_VERB_DELETE	= 0x8003,
	MMC_VERB_PROPERTIES	= 0x8004,
	MMC_VERB_RENAME	= 0x8005,
	MMC_VERB_REFRESH	= 0x8006,
	MMC_VERB_PRINT	= 0x8007
    }	MMC_CONSOLE_VERB;

typedef struct  _MMCButton
    {
    int nBitmap;
    int idCommand;
    BYTE fsState;
    BYTE fsType;
    LPOLESTR lpButtonText;
    LPOLESTR lpTooltipText;
    }	MMCBUTTON;

typedef MMCBUTTON __RPC_FAR *LPMMCBUTTON;

typedef 
enum _MMC_BUTTON_STATE
    {	ENABLED	= 0x1,
	CHECKED	= 0x2,
	HIDDEN	= 0x4,
	INDETERMINATE	= 0x8,
	BUTTONPRESSED	= 0x10
    }	MMC_BUTTON_STATE;

typedef struct  _RESULTDATAITEM
    {
    DWORD mask;
    BOOL bScopeItem;
    HRESULTITEM itemID;
    int nIndex;
    int nCol;
    LPOLESTR str;
    int nImage;
    UINT nState;
    LPARAM lParam;
    int iIndent;
    }	RESULTDATAITEM;

typedef RESULTDATAITEM __RPC_FAR *LPRESULTDATAITEM;

#define	RFI_PARTIAL	( 0x1 )

#define	RFI_WRAP	( 0x2 )

typedef struct  _RESULTFINDINFO
    {
    LPOLESTR psz;
    int nStart;
    DWORD dwOptions;
    }	RESULTFINDINFO;

typedef RESULTFINDINFO __RPC_FAR *LPRESULTFINDINFO;

#define	RSI_DESCENDING	( 0x1 )

#define	SDI_STR	( 0x2 )

#define	SDI_IMAGE	( 0x4 )

#define	SDI_OPENIMAGE	( 0x8 )

#define	SDI_STATE	( 0x10 )

#define	SDI_PARAM	( 0x20 )

#define	SDI_CHILDREN	( 0x40 )

#define	SDI_PARENT	( 0 )

#define	SDI_PREVIOUS	( 0x10000000 )

#define	SDI_NEXT	( 0x20000000 )

#define	SDI_FIRST	( 0x8000000 )

typedef struct  _SCOPEDATAITEM
    {
    DWORD mask;
    LPOLESTR displayname;
    int nImage;
    int nOpenImage;
    UINT nState;
    int cChildren;
    LPARAM lParam;
    HSCOPEITEM relativeID;
    HSCOPEITEM ID;
    }	SCOPEDATAITEM;

typedef SCOPEDATAITEM __RPC_FAR *LPSCOPEDATAITEM;

typedef 
enum _MMC_SCOPE_ITEM_STATE
    {	MMC_SCOPE_ITEM_STATE_NORMAL	= 0x1,
	MMC_SCOPE_ITEM_STATE_BOLD	= 0x2,
	MMC_SCOPE_ITEM_STATE_EXPANDEDONCE	= 0x3
    }	MMC_SCOPE_ITEM_STATE;

typedef struct  _CONTEXTMENUITEM
    {
    LPWSTR strName;
    LPWSTR strStatusBarText;
    LONG lCommandID;
    LONG lInsertionPointID;
    LONG fFlags;
    LONG fSpecialFlags;
    }	CONTEXTMENUITEM;

typedef CONTEXTMENUITEM __RPC_FAR *LPCONTEXTMENUITEM;

typedef 
enum _MMC_MENU_COMMAND_IDS
    {	MMCC_STANDARD_VIEW_SELECT	= -1
    }	MMC_MENU_COMMAND_IDS;

typedef struct  _MENUBUTTONDATA
    {
    int idCommand;
    int x;
    int y;
    }	MENUBUTTONDATA;

typedef MENUBUTTONDATA __RPC_FAR *LPMENUBUTTONDATA;

#define	MMC_MULTI_SELECT_COOKIE	( -2 )

typedef 
enum _MMC_NOTIFY_TYPE
    {	MMCN_ACTIVATE	= 0x8001,
	MMCN_ADD_IMAGES	= 0x8002,
	MMCN_BTN_CLICK	= 0x8003,
	MMCN_CLICK	= 0x8004,
	MMCN_COLUMN_CLICK	= 0x8005,
	MMCN_CONTEXTMENU	= 0x8006,
	MMCN_CUTORMOVE	= 0x8007,
	MMCN_DBLCLICK	= 0x8008,
	MMCN_DELETE	= 0x8009,
	MMCN_DESELECT_ALL	= 0x800a,
	MMCN_EXPAND	= 0x800b,
	MMCN_HELP	= 0x800c,
	MMCN_MENU_BTNCLICK	= 0x800d,
	MMCN_MINIMIZED	= 0x800e,
	MMCN_PASTE	= 0x800f,
	MMCN_PROPERTY_CHANGE	= 0x8010,
	MMCN_QUERY_PASTE	= 0x8011,
	MMCN_REFRESH	= 0x8012,
	MMCN_REMOVE_CHILDREN	= 0x8013,
	MMCN_RENAME	= 0x8014,
	MMCN_SELECT	= 0x8015,
	MMCN_SHOW	= 0x8016,
	MMCN_VIEW_CHANGE	= 0x8017,
	MMCN_SNAPINHELP	= 0x8018,
	MMCN_CONTEXTHELP	= 0x8019
    }	MMC_NOTIFY_TYPE;

typedef 
enum _DATA_OBJECT_TYPES
    {	CCT_SCOPE	= 0x8000,
	CCT_RESULT	= 0x8001,
	CCT_SNAPIN_MANAGER	= 0x8002,
	CCT_UNINITIALIZED	= 0xffff
    }	DATA_OBJECT_TYPES;

#define	MMC_NW_OPTION_LONGTITLE	( 0 )

#define	MMC_NW_OPTION_SHORTTITLE	( 0x1 )

#define	CCF_NODETYPE	( L"CCF_NODETYPE" )

#define	CCF_SZNODETYPE	( L"CCF_SZNODETYPE" )

#define	CCF_DISPLAY_NAME	( L"CCF_DISPLAY_NAME" )

#define	CCF_SNAPIN_CLASSID	( L"CCF_SNAPIN_CLASSID" )

#define	CCF_MMC_MULTISELECT_DATAOBJECT	( L"CCF_MMC_MULTISELECT_DATAOBJECT" )

#define	CCF_MULTI_SELECT_SNAPINS	( L"CCF_MULTI_SELECT_SNAPINS" )

#define	CCF_OBJECT_TYPES_IN_MULTI_SELECT	( L"CCF_OBJECT_TYPES_IN_MULTI_SELECT" )

STDAPI MMCPropertyChangeNotify(long lNotifyHandle, long param);
STDAPI MMCFreeNotifyHandle(long lNotifyHandle);
STDAPI MMCPropPageCallback(void* vpsp);
EXTERN_C const CLSID CLSID_NodeManager;


extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0000_v0_0_s_ifspec;

#ifndef __IComponentData_INTERFACE_DEFINED__
#define __IComponentData_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IComponentData
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IComponentData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("955AB28A-5218-11D0-A985-00C04FD8D565")
    IComponentData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPUNKNOWN pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
            /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ long cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponentData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponentData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ LPUNKNOWN pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateComponent )( 
            IComponentData __RPC_FAR * This,
            /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destroy )( 
            IComponentData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryDataObject )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ long cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayInfo )( 
            IComponentData __RPC_FAR * This,
            /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareObjects )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        END_INTERFACE
    } IComponentDataVtbl;

    interface IComponentData
    {
        CONST_VTBL struct IComponentDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponentData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponentData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponentData_Initialize(This,pUnknown)	\
    (This)->lpVtbl -> Initialize(This,pUnknown)

#define IComponentData_CreateComponent(This,ppComponent)	\
    (This)->lpVtbl -> CreateComponent(This,ppComponent)

#define IComponentData_Notify(This,lpDataObject,event,arg,param)	\
    (This)->lpVtbl -> Notify(This,lpDataObject,event,arg,param)

#define IComponentData_Destroy(This)	\
    (This)->lpVtbl -> Destroy(This)

#define IComponentData_QueryDataObject(This,cookie,type,ppDataObject)	\
    (This)->lpVtbl -> QueryDataObject(This,cookie,type,ppDataObject)

#define IComponentData_GetDisplayInfo(This,pScopeDataItem)	\
    (This)->lpVtbl -> GetDisplayInfo(This,pScopeDataItem)

#define IComponentData_CompareObjects(This,lpDataObjectA,lpDataObjectB)	\
    (This)->lpVtbl -> CompareObjects(This,lpDataObjectA,lpDataObjectB)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_Initialize_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ LPUNKNOWN pUnknown);


void __RPC_STUB IComponentData_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_CreateComponent_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);


void __RPC_STUB IComponentData_CreateComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_Notify_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject,
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ long arg,
    /* [in] */ long param);


void __RPC_STUB IComponentData_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_Destroy_Proxy( 
    IComponentData __RPC_FAR * This);


void __RPC_STUB IComponentData_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_QueryDataObject_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ long cookie,
    /* [in] */ DATA_OBJECT_TYPES type,
    /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);


void __RPC_STUB IComponentData_QueryDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_GetDisplayInfo_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);


void __RPC_STUB IComponentData_GetDisplayInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_CompareObjects_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObjectA,
    /* [in] */ LPDATAOBJECT lpDataObjectB);


void __RPC_STUB IComponentData_CompareObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponentData_INTERFACE_DEFINED__ */


#ifndef __IComponent_INTERFACE_DEFINED__
#define __IComponent_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IComponent
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IComponent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB2-D36C-11CF-ADBC-00AA00A80033")
    IComponent : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ long cookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ long cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ long cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponent __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IComponent __RPC_FAR * This,
            /* [in] */ LPCONSOLE lpConsole);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            IComponent __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destroy )( 
            IComponent __RPC_FAR * This,
            /* [in] */ long cookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryDataObject )( 
            IComponent __RPC_FAR * This,
            /* [in] */ long cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultViewType )( 
            IComponent __RPC_FAR * This,
            /* [in] */ long cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayInfo )( 
            IComponent __RPC_FAR * This,
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareObjects )( 
            IComponent __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        END_INTERFACE
    } IComponentVtbl;

    interface IComponent
    {
        CONST_VTBL struct IComponentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponent_Initialize(This,lpConsole)	\
    (This)->lpVtbl -> Initialize(This,lpConsole)

#define IComponent_Notify(This,lpDataObject,event,arg,param)	\
    (This)->lpVtbl -> Notify(This,lpDataObject,event,arg,param)

#define IComponent_Destroy(This,cookie)	\
    (This)->lpVtbl -> Destroy(This,cookie)

#define IComponent_QueryDataObject(This,cookie,type,ppDataObject)	\
    (This)->lpVtbl -> QueryDataObject(This,cookie,type,ppDataObject)

#define IComponent_GetResultViewType(This,cookie,ppViewType,pViewOptions)	\
    (This)->lpVtbl -> GetResultViewType(This,cookie,ppViewType,pViewOptions)

#define IComponent_GetDisplayInfo(This,pResultDataItem)	\
    (This)->lpVtbl -> GetDisplayInfo(This,pResultDataItem)

#define IComponent_CompareObjects(This,lpDataObjectA,lpDataObjectB)	\
    (This)->lpVtbl -> CompareObjects(This,lpDataObjectA,lpDataObjectB)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_Initialize_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ LPCONSOLE lpConsole);


void __RPC_STUB IComponent_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_Notify_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject,
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ long arg,
    /* [in] */ long param);


void __RPC_STUB IComponent_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_Destroy_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ long cookie);


void __RPC_STUB IComponent_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_QueryDataObject_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ long cookie,
    /* [in] */ DATA_OBJECT_TYPES type,
    /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);


void __RPC_STUB IComponent_QueryDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_GetResultViewType_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ long cookie,
    /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
    /* [out] */ long __RPC_FAR *pViewOptions);


void __RPC_STUB IComponent_GetResultViewType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_GetDisplayInfo_Proxy( 
    IComponent __RPC_FAR * This,
    /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);


void __RPC_STUB IComponent_GetDisplayInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_CompareObjects_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObjectA,
    /* [in] */ LPDATAOBJECT lpDataObjectB);


void __RPC_STUB IComponent_CompareObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponent_INTERFACE_DEFINED__ */


#ifndef __IResultDataCompare_INTERFACE_DEFINED__
#define __IResultDataCompare_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResultDataCompare
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IResultDataCompare;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E8315A52-7A1A-11D0-A2D2-00C04FD909DD")
    IResultDataCompare : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ long lUserParam,
            /* [in] */ long cookieA,
            /* [in] */ long cookieB,
            /* [out][in] */ int __RPC_FAR *pnResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultDataCompareVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultDataCompare __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultDataCompare __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultDataCompare __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Compare )( 
            IResultDataCompare __RPC_FAR * This,
            /* [in] */ long lUserParam,
            /* [in] */ long cookieA,
            /* [in] */ long cookieB,
            /* [out][in] */ int __RPC_FAR *pnResult);
        
        END_INTERFACE
    } IResultDataCompareVtbl;

    interface IResultDataCompare
    {
        CONST_VTBL struct IResultDataCompareVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultDataCompare_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultDataCompare_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultDataCompare_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultDataCompare_Compare(This,lUserParam,cookieA,cookieB,pnResult)	\
    (This)->lpVtbl -> Compare(This,lUserParam,cookieA,cookieB,pnResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataCompare_Compare_Proxy( 
    IResultDataCompare __RPC_FAR * This,
    /* [in] */ long lUserParam,
    /* [in] */ long cookieA,
    /* [in] */ long cookieB,
    /* [out][in] */ int __RPC_FAR *pnResult);


void __RPC_STUB IResultDataCompare_Compare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultDataCompare_INTERFACE_DEFINED__ */


#ifndef __IResultOwnerData_INTERFACE_DEFINED__
#define __IResultOwnerData_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResultOwnerData
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IResultOwnerData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9CB396D8-EA83-11d0-AEF1-00C04FB6DD2C")
    IResultOwnerData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItem( 
            /* [in] */ LPRESULTFINDINFO pFindInfo,
            /* [out] */ int __RPC_FAR *pnFoundIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CacheHint( 
            /* [in] */ int nStartIndex,
            /* [in] */ int nEndIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SortItems( 
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ long lUserParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultOwnerDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultOwnerData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultOwnerData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItem )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ LPRESULTFINDINFO pFindInfo,
            /* [out] */ int __RPC_FAR *pnFoundIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CacheHint )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ int nStartIndex,
            /* [in] */ int nEndIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SortItems )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ long lUserParam);
        
        END_INTERFACE
    } IResultOwnerDataVtbl;

    interface IResultOwnerData
    {
        CONST_VTBL struct IResultOwnerDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultOwnerData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultOwnerData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultOwnerData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultOwnerData_FindItem(This,pFindInfo,pnFoundIndex)	\
    (This)->lpVtbl -> FindItem(This,pFindInfo,pnFoundIndex)

#define IResultOwnerData_CacheHint(This,nStartIndex,nEndIndex)	\
    (This)->lpVtbl -> CacheHint(This,nStartIndex,nEndIndex)

#define IResultOwnerData_SortItems(This,nColumn,dwSortOptions,lUserParam)	\
    (This)->lpVtbl -> SortItems(This,nColumn,dwSortOptions,lUserParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultOwnerData_FindItem_Proxy( 
    IResultOwnerData __RPC_FAR * This,
    /* [in] */ LPRESULTFINDINFO pFindInfo,
    /* [out] */ int __RPC_FAR *pnFoundIndex);


void __RPC_STUB IResultOwnerData_FindItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultOwnerData_CacheHint_Proxy( 
    IResultOwnerData __RPC_FAR * This,
    /* [in] */ int nStartIndex,
    /* [in] */ int nEndIndex);


void __RPC_STUB IResultOwnerData_CacheHint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultOwnerData_SortItems_Proxy( 
    IResultOwnerData __RPC_FAR * This,
    /* [in] */ int nColumn,
    /* [in] */ DWORD dwSortOptions,
    /* [in] */ long lUserParam);


void __RPC_STUB IResultOwnerData_SortItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultOwnerData_INTERFACE_DEFINED__ */


#ifndef __IConsole_INTERFACE_DEFINED__
#define __IConsole_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IConsole
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IConsole;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB1-D36C-11CF-ADBC-00AA00A80033")
    IConsole : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetHeader( 
            /* [in] */ LPHEADERCTRL pHeader) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetToolbar( 
            /* [in] */ LPTOOLBAR pToolbar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryResultView( 
            /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryScopeImageList( 
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryResultImageList( 
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UpdateAllViews( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ long data,
            /* [in] */ long hint) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MessageBox( 
            /* [in] */ LPCWSTR lpszText,
            /* [in] */ LPCWSTR lpszTitle,
            /* [in] */ UINT fuStyle,
            /* [out] */ int __RPC_FAR *piRetval) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryConsoleVerb( 
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SelectScopeItem( 
            /* [in] */ HSCOPEITEM hScopeItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMainWindow( 
            /* [out] */ HWND __RPC_FAR *phwnd) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NewWindow( 
            /* [in] */ HSCOPEITEM hScopeItem,
            /* [in] */ unsigned long lOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsoleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsole __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsole __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHeader )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPHEADERCTRL pHeader);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetToolbar )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPTOOLBAR pToolbar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultView )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryScopeImageList )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultImageList )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateAllViews )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ long data,
            /* [in] */ long hint);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MessageBox )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPCWSTR lpszText,
            /* [in] */ LPCWSTR lpszTitle,
            /* [in] */ UINT fuStyle,
            /* [out] */ int __RPC_FAR *piRetval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryConsoleVerb )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectScopeItem )( 
            IConsole __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMainWindow )( 
            IConsole __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewWindow )( 
            IConsole __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem,
            /* [in] */ unsigned long lOptions);
        
        END_INTERFACE
    } IConsoleVtbl;

    interface IConsole
    {
        CONST_VTBL struct IConsoleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsole_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsole_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsole_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsole_SetHeader(This,pHeader)	\
    (This)->lpVtbl -> SetHeader(This,pHeader)

#define IConsole_SetToolbar(This,pToolbar)	\
    (This)->lpVtbl -> SetToolbar(This,pToolbar)

#define IConsole_QueryResultView(This,pUnknown)	\
    (This)->lpVtbl -> QueryResultView(This,pUnknown)

#define IConsole_QueryScopeImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryScopeImageList(This,ppImageList)

#define IConsole_QueryResultImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryResultImageList(This,ppImageList)

#define IConsole_UpdateAllViews(This,lpDataObject,data,hint)	\
    (This)->lpVtbl -> UpdateAllViews(This,lpDataObject,data,hint)

#define IConsole_MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)	\
    (This)->lpVtbl -> MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)

#define IConsole_QueryConsoleVerb(This,ppConsoleVerb)	\
    (This)->lpVtbl -> QueryConsoleVerb(This,ppConsoleVerb)

#define IConsole_SelectScopeItem(This,hScopeItem)	\
    (This)->lpVtbl -> SelectScopeItem(This,hScopeItem)

#define IConsole_GetMainWindow(This,phwnd)	\
    (This)->lpVtbl -> GetMainWindow(This,phwnd)

#define IConsole_NewWindow(This,hScopeItem,lOptions)	\
    (This)->lpVtbl -> NewWindow(This,hScopeItem,lOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_SetHeader_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPHEADERCTRL pHeader);


void __RPC_STUB IConsole_SetHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_SetToolbar_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPTOOLBAR pToolbar);


void __RPC_STUB IConsole_SetToolbar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryResultView_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown);


void __RPC_STUB IConsole_QueryResultView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryScopeImageList_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);


void __RPC_STUB IConsole_QueryScopeImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryResultImageList_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);


void __RPC_STUB IConsole_QueryResultImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_UpdateAllViews_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject,
    /* [in] */ long data,
    /* [in] */ long hint);


void __RPC_STUB IConsole_UpdateAllViews_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_MessageBox_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPCWSTR lpszText,
    /* [in] */ LPCWSTR lpszTitle,
    /* [in] */ UINT fuStyle,
    /* [out] */ int __RPC_FAR *piRetval);


void __RPC_STUB IConsole_MessageBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryConsoleVerb_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);


void __RPC_STUB IConsole_QueryConsoleVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_SelectScopeItem_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hScopeItem);


void __RPC_STUB IConsole_SelectScopeItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_GetMainWindow_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ HWND __RPC_FAR *phwnd);


void __RPC_STUB IConsole_GetMainWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_NewWindow_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hScopeItem,
    /* [in] */ unsigned long lOptions);


void __RPC_STUB IConsole_NewWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsole_INTERFACE_DEFINED__ */


#ifndef __IHeaderCtrl_INTERFACE_DEFINED__
#define __IHeaderCtrl_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHeaderCtrl
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 


#define	AUTO_WIDTH	( -1 )


EXTERN_C const IID IID_IHeaderCtrl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB3-D36C-11CF-ADBC-00AA00A80033")
    IHeaderCtrl : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertColumn( 
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title,
            /* [in] */ int nFormat,
            /* [in] */ int nWidth) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteColumn( 
            /* [in] */ int nCol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetColumnText( 
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetColumnText( 
            /* [in] */ int nCol,
            /* [out] */ LPOLESTR __RPC_FAR *pText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetColumnWidth( 
            /* [in] */ int nCol,
            /* [in] */ int nWidth) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetColumnWidth( 
            /* [in] */ int nCol,
            /* [out] */ int __RPC_FAR *pWidth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHeaderCtrlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHeaderCtrl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHeaderCtrl __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertColumn )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title,
            /* [in] */ int nFormat,
            /* [in] */ int nWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteColumn )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnText )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnText )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [out] */ LPOLESTR __RPC_FAR *pText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnWidth )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ int nWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnWidth )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [out] */ int __RPC_FAR *pWidth);
        
        END_INTERFACE
    } IHeaderCtrlVtbl;

    interface IHeaderCtrl
    {
        CONST_VTBL struct IHeaderCtrlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeaderCtrl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHeaderCtrl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHeaderCtrl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHeaderCtrl_InsertColumn(This,nCol,title,nFormat,nWidth)	\
    (This)->lpVtbl -> InsertColumn(This,nCol,title,nFormat,nWidth)

#define IHeaderCtrl_DeleteColumn(This,nCol)	\
    (This)->lpVtbl -> DeleteColumn(This,nCol)

#define IHeaderCtrl_SetColumnText(This,nCol,title)	\
    (This)->lpVtbl -> SetColumnText(This,nCol,title)

#define IHeaderCtrl_GetColumnText(This,nCol,pText)	\
    (This)->lpVtbl -> GetColumnText(This,nCol,pText)

#define IHeaderCtrl_SetColumnWidth(This,nCol,nWidth)	\
    (This)->lpVtbl -> SetColumnWidth(This,nCol,nWidth)

#define IHeaderCtrl_GetColumnWidth(This,nCol,pWidth)	\
    (This)->lpVtbl -> GetColumnWidth(This,nCol,pWidth)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_InsertColumn_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [in] */ LPCWSTR title,
    /* [in] */ int nFormat,
    /* [in] */ int nWidth);


void __RPC_STUB IHeaderCtrl_InsertColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_DeleteColumn_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol);


void __RPC_STUB IHeaderCtrl_DeleteColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_SetColumnText_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [in] */ LPCWSTR title);


void __RPC_STUB IHeaderCtrl_SetColumnText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_GetColumnText_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [out] */ LPOLESTR __RPC_FAR *pText);


void __RPC_STUB IHeaderCtrl_GetColumnText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_SetColumnWidth_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [in] */ int nWidth);


void __RPC_STUB IHeaderCtrl_SetColumnWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_GetColumnWidth_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [out] */ int __RPC_FAR *pWidth);


void __RPC_STUB IHeaderCtrl_GetColumnWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHeaderCtrl_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0098
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 



enum __MIDL___MIDL_itf_ndmgr_0098_0001
    {	CCM_INSERTIONPOINTID_MASK_SPECIAL	= 0xffff0000,
	CCM_INSERTIONPOINTID_MASK_SHARED	= 0x80000000,
	CCM_INSERTIONPOINTID_MASK_CREATE_PRIMARY	= 0x40000000,
	CCM_INSERTIONPOINTID_MASK_ADD_PRIMARY	= 0x20000000,
	CCM_INSERTIONPOINTID_MASK_ADD_3RDPARTY	= 0x10000000,
	CCM_INSERTIONPOINTID_MASK_RESERVED	= 0xfff0000,
	CCM_INSERTIONPOINTID_MASK_FLAGINDEX	= 0x1f,
	CCM_INSERTIONPOINTID_PRIMARY_TOP	= 0xa0000000,
	CCM_INSERTIONPOINTID_PRIMARY_NEW	= 0xa0000001,
	CCM_INSERTIONPOINTID_PRIMARY_TASK	= 0xa0000002,
	CCM_INSERTIONPOINTID_PRIMARY_VIEW	= 0xa0000003,
	CCM_INSERTIONPOINTID_3RDPARTY_NEW	= 0x90000001,
	CCM_INSERTIONPOINTID_3RDPARTY_TASK	= 0x90000002,
	CCM_INSERTIONPOINTID_ROOT_MENU	= 0x80000000
    };

enum __MIDL___MIDL_itf_ndmgr_0098_0002
    {	CCM_INSERTIONALLOWED_TOP	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_TOP & CCM_INSERTIONPOINTID_MASK_FLAGINDEX),
	CCM_INSERTIONALLOWED_NEW	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_NEW & CCM_INSERTIONPOINTID_MASK_FLAGINDEX),
	CCM_INSERTIONALLOWED_TASK	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_TASK & CCM_INSERTIONPOINTID_MASK_FLAGINDEX),
	CCM_INSERTIONALLOWED_VIEW	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_VIEW & CCM_INSERTIONPOINTID_MASK_FLAGINDEX)
    };

enum __MIDL___MIDL_itf_ndmgr_0098_0003
    {	CCM_COMMANDID_MASK_RESERVED	= 0xffff0000
    };

enum __MIDL___MIDL_itf_ndmgr_0098_0004
    {	CCM_SPECIAL_SEPARATOR	= 0x1,
	CCM_SPECIAL_SUBMENU	= 0x2,
	CCM_SPECIAL_DEFAULT_ITEM	= 0x4,
	CCM_SPECIAL_INSERTION_POINT	= 0x8,
	CCM_SPECIAL_TESTONLY	= 0x10
    };


extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0098_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0098_v0_0_s_ifspec;

#ifndef __IContextMenuCallback_INTERFACE_DEFINED__
#define __IContextMenuCallback_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IContextMenuCallback
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IContextMenuCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB7-D36C-11CF-ADBC-00AA00A80033")
    IContextMenuCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenuCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextMenuCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextMenuCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextMenuCallback __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            IContextMenuCallback __RPC_FAR * This,
            /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem);
        
        END_INTERFACE
    } IContextMenuCallbackVtbl;

    interface IContextMenuCallback
    {
        CONST_VTBL struct IContextMenuCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenuCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextMenuCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextMenuCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextMenuCallback_AddItem(This,pItem)	\
    (This)->lpVtbl -> AddItem(This,pItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuCallback_AddItem_Proxy( 
    IContextMenuCallback __RPC_FAR * This,
    /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem);


void __RPC_STUB IContextMenuCallback_AddItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextMenuCallback_INTERFACE_DEFINED__ */


#ifndef __IContextMenuProvider_INTERFACE_DEFINED__
#define __IContextMenuProvider_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IContextMenuProvider
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][object][uuid][object] */ 



EXTERN_C const IID IID_IContextMenuProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB6-D36C-11CF-ADBC-00AA00A80033")
    IContextMenuProvider : public IContextMenuCallback
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EmptyMenuList( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPrimaryExtensionItems( 
            /* [in] */ LPUNKNOWN piExtension,
            /* [in] */ LPDATAOBJECT piDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddThirdPartyExtensionItems( 
            /* [in] */ LPDATAOBJECT piDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShowContextMenu( 
            /* [in] */ HWND hwndParent,
            /* [in] */ long xPos,
            /* [in] */ long yPos,
            /* [retval][out] */ long __RPC_FAR *plSelected) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenuProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextMenuProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextMenuProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EmptyMenuList )( 
            IContextMenuProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPrimaryExtensionItems )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ LPUNKNOWN piExtension,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddThirdPartyExtensionItems )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowContextMenu )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ long xPos,
            /* [in] */ long yPos,
            /* [retval][out] */ long __RPC_FAR *plSelected);
        
        END_INTERFACE
    } IContextMenuProviderVtbl;

    interface IContextMenuProvider
    {
        CONST_VTBL struct IContextMenuProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenuProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextMenuProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextMenuProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextMenuProvider_AddItem(This,pItem)	\
    (This)->lpVtbl -> AddItem(This,pItem)


#define IContextMenuProvider_EmptyMenuList(This)	\
    (This)->lpVtbl -> EmptyMenuList(This)

#define IContextMenuProvider_AddPrimaryExtensionItems(This,piExtension,piDataObject)	\
    (This)->lpVtbl -> AddPrimaryExtensionItems(This,piExtension,piDataObject)

#define IContextMenuProvider_AddThirdPartyExtensionItems(This,piDataObject)	\
    (This)->lpVtbl -> AddThirdPartyExtensionItems(This,piDataObject)

#define IContextMenuProvider_ShowContextMenu(This,hwndParent,xPos,yPos,plSelected)	\
    (This)->lpVtbl -> ShowContextMenu(This,hwndParent,xPos,yPos,plSelected)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_EmptyMenuList_Proxy( 
    IContextMenuProvider __RPC_FAR * This);


void __RPC_STUB IContextMenuProvider_EmptyMenuList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_AddPrimaryExtensionItems_Proxy( 
    IContextMenuProvider __RPC_FAR * This,
    /* [in] */ LPUNKNOWN piExtension,
    /* [in] */ LPDATAOBJECT piDataObject);


void __RPC_STUB IContextMenuProvider_AddPrimaryExtensionItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_AddThirdPartyExtensionItems_Proxy( 
    IContextMenuProvider __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT piDataObject);


void __RPC_STUB IContextMenuProvider_AddThirdPartyExtensionItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_ShowContextMenu_Proxy( 
    IContextMenuProvider __RPC_FAR * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ long xPos,
    /* [in] */ long yPos,
    /* [retval][out] */ long __RPC_FAR *plSelected);


void __RPC_STUB IContextMenuProvider_ShowContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextMenuProvider_INTERFACE_DEFINED__ */


#ifndef __IExtendContextMenu_INTERFACE_DEFINED__
#define __IExtendContextMenu_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IExtendContextMenu
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IExtendContextMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F3B7A4F-CFAC-11CF-B8E3-00C04FD8D5B0")
    IExtendContextMenu : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems( 
            /* [in] */ LPDATAOBJECT piDataObject,
            /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
            /* [out][in] */ long __RPC_FAR *pInsertionAllowed) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command( 
            /* [in] */ long lCommandID,
            /* [in] */ LPDATAOBJECT piDataObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendContextMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendContextMenu __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendContextMenu __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendContextMenu __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMenuItems )( 
            IExtendContextMenu __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT piDataObject,
            /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
            /* [out][in] */ long __RPC_FAR *pInsertionAllowed);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Command )( 
            IExtendContextMenu __RPC_FAR * This,
            /* [in] */ long lCommandID,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        END_INTERFACE
    } IExtendContextMenuVtbl;

    interface IExtendContextMenu
    {
        CONST_VTBL struct IExtendContextMenuVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendContextMenu_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendContextMenu_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendContextMenu_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendContextMenu_AddMenuItems(This,piDataObject,piCallback,pInsertionAllowed)	\
    (This)->lpVtbl -> AddMenuItems(This,piDataObject,piCallback,pInsertionAllowed)

#define IExtendContextMenu_Command(This,lCommandID,piDataObject)	\
    (This)->lpVtbl -> Command(This,lCommandID,piDataObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendContextMenu_AddMenuItems_Proxy( 
    IExtendContextMenu __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT piDataObject,
    /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
    /* [out][in] */ long __RPC_FAR *pInsertionAllowed);


void __RPC_STUB IExtendContextMenu_AddMenuItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendContextMenu_Command_Proxy( 
    IExtendContextMenu __RPC_FAR * This,
    /* [in] */ long lCommandID,
    /* [in] */ LPDATAOBJECT piDataObject);


void __RPC_STUB IExtendContextMenu_Command_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendContextMenu_INTERFACE_DEFINED__ */


#ifndef __IImageList_INTERFACE_DEFINED__
#define __IImageList_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImageList
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IImageList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB8-D36C-11CF-ADBC-00AA00A80033")
    IImageList : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ImageListSetIcon( 
            /* [in] */ long __RPC_FAR *pIcon,
            /* [in] */ long nLoc) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ImageListSetStrip( 
            /* [in] */ long __RPC_FAR *pBMapSm,
            /* [in] */ long __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ COLORREF cMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImageList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImageList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImageList __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImageListSetIcon )( 
            IImageList __RPC_FAR * This,
            /* [in] */ long __RPC_FAR *pIcon,
            /* [in] */ long nLoc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImageListSetStrip )( 
            IImageList __RPC_FAR * This,
            /* [in] */ long __RPC_FAR *pBMapSm,
            /* [in] */ long __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ COLORREF cMask);
        
        END_INTERFACE
    } IImageListVtbl;

    interface IImageList
    {
        CONST_VTBL struct IImageListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImageList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImageList_ImageListSetIcon(This,pIcon,nLoc)	\
    (This)->lpVtbl -> ImageListSetIcon(This,pIcon,nLoc)

#define IImageList_ImageListSetStrip(This,pBMapSm,pBMapLg,nStartLoc,cMask)	\
    (This)->lpVtbl -> ImageListSetStrip(This,pBMapSm,pBMapLg,nStartLoc,cMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IImageList_ImageListSetIcon_Proxy( 
    IImageList __RPC_FAR * This,
    /* [in] */ long __RPC_FAR *pIcon,
    /* [in] */ long nLoc);


void __RPC_STUB IImageList_ImageListSetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IImageList_ImageListSetStrip_Proxy( 
    IImageList __RPC_FAR * This,
    /* [in] */ long __RPC_FAR *pBMapSm,
    /* [in] */ long __RPC_FAR *pBMapLg,
    /* [in] */ long nStartLoc,
    /* [in] */ COLORREF cMask);


void __RPC_STUB IImageList_ImageListSetStrip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImageList_INTERFACE_DEFINED__ */


#ifndef __IResultData_INTERFACE_DEFINED__
#define __IResultData_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResultData
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IResultData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31DA5FA0-E0EB-11cf-9F21-00AA003CA9F6")
    IResultData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertItem( 
            /* [out][in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ int nCol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItemByLParam( 
            /* [in] */ LPARAM lParam,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteAllRsltItems( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetItem( 
            /* [in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItem( 
            /* [out][in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextItem( 
            /* [out][in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ModifyItemState( 
            /* [in] */ int nIndex,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ UINT uAdd,
            /* [in] */ UINT uRemove) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ModifyViewStyle( 
            /* [in] */ MMC_RESULT_VIEW_STYLE add,
            /* [in] */ MMC_RESULT_VIEW_STYLE remove) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetViewMode( 
            /* [in] */ long lViewMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetViewMode( 
            /* [out] */ long __RPC_FAR *lViewMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UpdateItem( 
            /* [in] */ HRESULTITEM itemID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Sort( 
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ long lUserParam) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDescBarText( 
            /* [in] */ LPOLESTR DescText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetItemCount( 
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetQuickFilter( 
            /* [in] */ UINT nColumn,
            /* [in] */ long lFilter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetQuickFilter( 
            /* [in] */ UINT nColumn,
            /* [out] */ long __RPC_FAR *plFilter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IResultData __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IResultData __RPC_FAR * This,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ int nCol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItemByLParam )( 
            IResultData __RPC_FAR * This,
            /* [in] */ LPARAM lParam,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllRsltItems )( 
            IResultData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IResultData __RPC_FAR * This,
            /* [in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IResultData __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IResultData __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyItemState )( 
            IResultData __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ UINT uAdd,
            /* [in] */ UINT uRemove);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyViewStyle )( 
            IResultData __RPC_FAR * This,
            /* [in] */ MMC_RESULT_VIEW_STYLE add,
            /* [in] */ MMC_RESULT_VIEW_STYLE remove);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetViewMode )( 
            IResultData __RPC_FAR * This,
            /* [in] */ long lViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetViewMode )( 
            IResultData __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *lViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateItem )( 
            IResultData __RPC_FAR * This,
            /* [in] */ HRESULTITEM itemID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sort )( 
            IResultData __RPC_FAR * This,
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ long lUserParam);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescBarText )( 
            IResultData __RPC_FAR * This,
            /* [in] */ LPOLESTR DescText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItemCount )( 
            IResultData __RPC_FAR * This,
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetQuickFilter )( 
            IResultData __RPC_FAR * This,
            /* [in] */ UINT nColumn,
            /* [in] */ long lFilter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQuickFilter )( 
            IResultData __RPC_FAR * This,
            /* [in] */ UINT nColumn,
            /* [out] */ long __RPC_FAR *plFilter);
        
        END_INTERFACE
    } IResultDataVtbl;

    interface IResultData
    {
        CONST_VTBL struct IResultDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultData_InsertItem(This,item)	\
    (This)->lpVtbl -> InsertItem(This,item)

#define IResultData_DeleteItem(This,itemID,nCol)	\
    (This)->lpVtbl -> DeleteItem(This,itemID,nCol)

#define IResultData_FindItemByLParam(This,lParam,pItemID)	\
    (This)->lpVtbl -> FindItemByLParam(This,lParam,pItemID)

#define IResultData_DeleteAllRsltItems(This)	\
    (This)->lpVtbl -> DeleteAllRsltItems(This)

#define IResultData_SetItem(This,item)	\
    (This)->lpVtbl -> SetItem(This,item)

#define IResultData_GetItem(This,item)	\
    (This)->lpVtbl -> GetItem(This,item)

#define IResultData_GetNextItem(This,item)	\
    (This)->lpVtbl -> GetNextItem(This,item)

#define IResultData_ModifyItemState(This,nIndex,itemID,uAdd,uRemove)	\
    (This)->lpVtbl -> ModifyItemState(This,nIndex,itemID,uAdd,uRemove)

#define IResultData_ModifyViewStyle(This,add,remove)	\
    (This)->lpVtbl -> ModifyViewStyle(This,add,remove)

#define IResultData_SetViewMode(This,lViewMode)	\
    (This)->lpVtbl -> SetViewMode(This,lViewMode)

#define IResultData_GetViewMode(This,lViewMode)	\
    (This)->lpVtbl -> GetViewMode(This,lViewMode)

#define IResultData_UpdateItem(This,itemID)	\
    (This)->lpVtbl -> UpdateItem(This,itemID)

#define IResultData_Sort(This,nColumn,dwSortOptions,lUserParam)	\
    (This)->lpVtbl -> Sort(This,nColumn,dwSortOptions,lUserParam)

#define IResultData_SetDescBarText(This,DescText)	\
    (This)->lpVtbl -> SetDescBarText(This,DescText)

#define IResultData_SetItemCount(This,nItemCount,dwOptions)	\
    (This)->lpVtbl -> SetItemCount(This,nItemCount,dwOptions)

#define IResultData_SetQuickFilter(This,nColumn,lFilter)	\
    (This)->lpVtbl -> SetQuickFilter(This,nColumn,lFilter)

#define IResultData_GetQuickFilter(This,nColumn,plFilter)	\
    (This)->lpVtbl -> GetQuickFilter(This,nColumn,plFilter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_InsertItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out][in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_InsertItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_DeleteItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ HRESULTITEM itemID,
    /* [in] */ int nCol);


void __RPC_STUB IResultData_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_FindItemByLParam_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ LPARAM lParam,
    /* [out] */ HRESULTITEM __RPC_FAR *pItemID);


void __RPC_STUB IResultData_FindItemByLParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_DeleteAllRsltItems_Proxy( 
    IResultData __RPC_FAR * This);


void __RPC_STUB IResultData_DeleteAllRsltItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_SetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_GetItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out][in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_GetNextItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out][in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_GetNextItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_ModifyItemState_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ HRESULTITEM itemID,
    /* [in] */ UINT uAdd,
    /* [in] */ UINT uRemove);


void __RPC_STUB IResultData_ModifyItemState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_ModifyViewStyle_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ MMC_RESULT_VIEW_STYLE add,
    /* [in] */ MMC_RESULT_VIEW_STYLE remove);


void __RPC_STUB IResultData_ModifyViewStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetViewMode_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ long lViewMode);


void __RPC_STUB IResultData_SetViewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_GetViewMode_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *lViewMode);


void __RPC_STUB IResultData_GetViewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_UpdateItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ HRESULTITEM itemID);


void __RPC_STUB IResultData_UpdateItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_Sort_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ int nColumn,
    /* [in] */ DWORD dwSortOptions,
    /* [in] */ long lUserParam);


void __RPC_STUB IResultData_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetDescBarText_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ LPOLESTR DescText);


void __RPC_STUB IResultData_SetDescBarText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetItemCount_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ int nItemCount,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IResultData_SetItemCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetQuickFilter_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ UINT nColumn,
    /* [in] */ long lFilter);


void __RPC_STUB IResultData_SetQuickFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_GetQuickFilter_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ UINT nColumn,
    /* [out] */ long __RPC_FAR *plFilter);


void __RPC_STUB IResultData_GetQuickFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultData_INTERFACE_DEFINED__ */


#ifndef __IConsoleNameSpace_INTERFACE_DEFINED__
#define __IConsoleNameSpace_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IConsoleNameSpace
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IConsoleNameSpace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEDEB620-F24D-11cf-8AFC-00AA003CA9F6")
    IConsoleNameSpace : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertItem( 
            /* [out][in] */ LPSCOPEDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ long fDeleteThis) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetItem( 
            /* [in] */ LPSCOPEDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItem( 
            /* [out][in] */ LPSCOPEDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChildItem( 
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
            /* [out] */ long __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextItem( 
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
            /* [out] */ long __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetParentItem( 
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
            /* [out] */ long __RPC_FAR *plCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsoleNameSpaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsoleNameSpace __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsoleNameSpace __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ long fDeleteThis);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
            /* [out] */ long __RPC_FAR *plCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
            /* [out] */ long __RPC_FAR *plCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParentItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
            /* [out] */ long __RPC_FAR *plCookie);
        
        END_INTERFACE
    } IConsoleNameSpaceVtbl;

    interface IConsoleNameSpace
    {
        CONST_VTBL struct IConsoleNameSpaceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsoleNameSpace_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsoleNameSpace_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsoleNameSpace_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsoleNameSpace_InsertItem(This,item)	\
    (This)->lpVtbl -> InsertItem(This,item)

#define IConsoleNameSpace_DeleteItem(This,hItem,fDeleteThis)	\
    (This)->lpVtbl -> DeleteItem(This,hItem,fDeleteThis)

#define IConsoleNameSpace_SetItem(This,item)	\
    (This)->lpVtbl -> SetItem(This,item)

#define IConsoleNameSpace_GetItem(This,item)	\
    (This)->lpVtbl -> GetItem(This,item)

#define IConsoleNameSpace_GetChildItem(This,item,pItemChild,plCookie)	\
    (This)->lpVtbl -> GetChildItem(This,item,pItemChild,plCookie)

#define IConsoleNameSpace_GetNextItem(This,item,pItemNext,plCookie)	\
    (This)->lpVtbl -> GetNextItem(This,item,pItemNext,plCookie)

#define IConsoleNameSpace_GetParentItem(This,item,pItemParent,plCookie)	\
    (This)->lpVtbl -> GetParentItem(This,item,pItemParent,plCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_InsertItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [out][in] */ LPSCOPEDATAITEM item);


void __RPC_STUB IConsoleNameSpace_InsertItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_DeleteItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hItem,
    /* [in] */ long fDeleteThis);


void __RPC_STUB IConsoleNameSpace_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_SetItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ LPSCOPEDATAITEM item);


void __RPC_STUB IConsoleNameSpace_SetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [out][in] */ LPSCOPEDATAITEM item);


void __RPC_STUB IConsoleNameSpace_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetChildItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM item,
    /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
    /* [out] */ long __RPC_FAR *plCookie);


void __RPC_STUB IConsoleNameSpace_GetChildItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetNextItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM item,
    /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
    /* [out] */ long __RPC_FAR *plCookie);


void __RPC_STUB IConsoleNameSpace_GetNextItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetParentItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM item,
    /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
    /* [out] */ long __RPC_FAR *plCookie);


void __RPC_STUB IConsoleNameSpace_GetParentItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsoleNameSpace_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0105
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 



typedef struct _PSP __RPC_FAR *HPROPSHEETPAGE;



extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0105_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0105_v0_0_s_ifspec;

#ifndef __IPropertySheetCallback_INTERFACE_DEFINED__
#define __IPropertySheetCallback_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertySheetCallback
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object][local] */ 



EXTERN_C const IID IID_IPropertySheetCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85DE64DD-EF21-11cf-A285-00C04FD8DBE6")
    IPropertySheetCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPage( 
            /* [in] */ HPROPSHEETPAGE hPage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePage( 
            /* [in] */ HPROPSHEETPAGE hPage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySheetCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySheetCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySheetCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySheetCallback __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPage )( 
            IPropertySheetCallback __RPC_FAR * This,
            /* [in] */ HPROPSHEETPAGE hPage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemovePage )( 
            IPropertySheetCallback __RPC_FAR * This,
            /* [in] */ HPROPSHEETPAGE hPage);
        
        END_INTERFACE
    } IPropertySheetCallbackVtbl;

    interface IPropertySheetCallback
    {
        CONST_VTBL struct IPropertySheetCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySheetCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySheetCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySheetCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySheetCallback_AddPage(This,hPage)	\
    (This)->lpVtbl -> AddPage(This,hPage)

#define IPropertySheetCallback_RemovePage(This,hPage)	\
    (This)->lpVtbl -> RemovePage(This,hPage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetCallback_AddPage_Proxy( 
    IPropertySheetCallback __RPC_FAR * This,
    /* [in] */ HPROPSHEETPAGE hPage);


void __RPC_STUB IPropertySheetCallback_AddPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetCallback_RemovePage_Proxy( 
    IPropertySheetCallback __RPC_FAR * This,
    /* [in] */ HPROPSHEETPAGE hPage);


void __RPC_STUB IPropertySheetCallback_RemovePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySheetCallback_INTERFACE_DEFINED__ */


#ifndef __IPropertySheetProvider_INTERFACE_DEFINED__
#define __IPropertySheetProvider_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertySheetProvider
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IPropertySheetProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85DE64DE-EF21-11cf-A285-00C04FD8DBE6")
    IPropertySheetProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertySheet( 
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ long cookie,
            /* [in] */ LPDATAOBJECT pIDataObjectm,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindPropertySheet( 
            /* [in] */ long cookie,
            /* [in] */ LPCOMPONENT lpComponent,
            /* [in] */ LPDATAOBJECT lpDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPrimaryPages( 
            LPUNKNOWN lpUnknown,
            BOOL bCreateHandle,
            HWND hNotifyWindow,
            BOOL bScopePane) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddExtensionPages( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ long window,
            /* [in] */ int page) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySheetProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySheetProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySheetProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertySheet )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ long cookie,
            /* [in] */ LPDATAOBJECT pIDataObjectm,
            /* [in] */ DWORD dwOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindPropertySheet )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ long cookie,
            /* [in] */ LPCOMPONENT lpComponent,
            /* [in] */ LPDATAOBJECT lpDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPrimaryPages )( 
            IPropertySheetProvider __RPC_FAR * This,
            LPUNKNOWN lpUnknown,
            BOOL bCreateHandle,
            HWND hNotifyWindow,
            BOOL bScopePane);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddExtensionPages )( 
            IPropertySheetProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Show )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ long window,
            /* [in] */ int page);
        
        END_INTERFACE
    } IPropertySheetProviderVtbl;

    interface IPropertySheetProvider
    {
        CONST_VTBL struct IPropertySheetProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySheetProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySheetProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySheetProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySheetProvider_CreatePropertySheet(This,title,type,cookie,pIDataObjectm,dwOptions)	\
    (This)->lpVtbl -> CreatePropertySheet(This,title,type,cookie,pIDataObjectm,dwOptions)

#define IPropertySheetProvider_FindPropertySheet(This,cookie,lpComponent,lpDataObject)	\
    (This)->lpVtbl -> FindPropertySheet(This,cookie,lpComponent,lpDataObject)

#define IPropertySheetProvider_AddPrimaryPages(This,lpUnknown,bCreateHandle,hNotifyWindow,bScopePane)	\
    (This)->lpVtbl -> AddPrimaryPages(This,lpUnknown,bCreateHandle,hNotifyWindow,bScopePane)

#define IPropertySheetProvider_AddExtensionPages(This)	\
    (This)->lpVtbl -> AddExtensionPages(This)

#define IPropertySheetProvider_Show(This,window,page)	\
    (This)->lpVtbl -> Show(This,window,page)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_CreatePropertySheet_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    /* [in] */ LPCWSTR title,
    /* [in] */ boolean type,
    /* [in] */ long cookie,
    /* [in] */ LPDATAOBJECT pIDataObjectm,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IPropertySheetProvider_CreatePropertySheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_FindPropertySheet_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    /* [in] */ long cookie,
    /* [in] */ LPCOMPONENT lpComponent,
    /* [in] */ LPDATAOBJECT lpDataObject);


void __RPC_STUB IPropertySheetProvider_FindPropertySheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_AddPrimaryPages_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    LPUNKNOWN lpUnknown,
    BOOL bCreateHandle,
    HWND hNotifyWindow,
    BOOL bScopePane);


void __RPC_STUB IPropertySheetProvider_AddPrimaryPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_AddExtensionPages_Proxy( 
    IPropertySheetProvider __RPC_FAR * This);


void __RPC_STUB IPropertySheetProvider_AddExtensionPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_Show_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    /* [in] */ long window,
    /* [in] */ int page);


void __RPC_STUB IPropertySheetProvider_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySheetProvider_INTERFACE_DEFINED__ */


#ifndef __IExtendPropertySheet_INTERFACE_DEFINED__
#define __IExtendPropertySheet_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IExtendPropertySheet
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IExtendPropertySheet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85DE64DC-EF21-11cf-A285-00C04FD8DBE6")
    IExtendPropertySheet : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ long handle,
            /* [in] */ LPDATAOBJECT lpIDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
            /* [in] */ LPDATAOBJECT lpDataObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendPropertySheetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendPropertySheet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendPropertySheet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendPropertySheet __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertyPages )( 
            IExtendPropertySheet __RPC_FAR * This,
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ long handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryPagesFor )( 
            IExtendPropertySheet __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject);
        
        END_INTERFACE
    } IExtendPropertySheetVtbl;

    interface IExtendPropertySheet
    {
        CONST_VTBL struct IExtendPropertySheetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendPropertySheet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendPropertySheet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendPropertySheet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendPropertySheet_CreatePropertyPages(This,lpProvider,handle,lpIDataObject)	\
    (This)->lpVtbl -> CreatePropertyPages(This,lpProvider,handle,lpIDataObject)

#define IExtendPropertySheet_QueryPagesFor(This,lpDataObject)	\
    (This)->lpVtbl -> QueryPagesFor(This,lpDataObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendPropertySheet_CreatePropertyPages_Proxy( 
    IExtendPropertySheet __RPC_FAR * This,
    /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
    /* [in] */ long handle,
    /* [in] */ LPDATAOBJECT lpIDataObject);


void __RPC_STUB IExtendPropertySheet_CreatePropertyPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendPropertySheet_QueryPagesFor_Proxy( 
    IExtendPropertySheet __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject);


void __RPC_STUB IExtendPropertySheet_QueryPagesFor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendPropertySheet_INTERFACE_DEFINED__ */


#ifndef __IControlbar_INTERFACE_DEFINED__
#define __IControlbar_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IControlbar
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IControlbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69FB811E-6C1C-11D0-A2CB-00C04FD909DD")
    IControlbar : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPEXTENDCONTROLBAR pExtendControlbar,
            /* [out] */ LPUNKNOWN __RPC_FAR *ppUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPUNKNOWN lpUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Detach( 
            /* [in] */ LPUNKNOWN lpUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IControlbar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IControlbar __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPEXTENDCONTROLBAR pExtendControlbar,
            /* [out] */ LPUNKNOWN __RPC_FAR *ppUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Attach )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPUNKNOWN lpUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Detach )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ LPUNKNOWN lpUnknown);
        
        END_INTERFACE
    } IControlbarVtbl;

    interface IControlbar
    {
        CONST_VTBL struct IControlbarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlbar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IControlbar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IControlbar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IControlbar_Create(This,nType,pExtendControlbar,ppUnknown)	\
    (This)->lpVtbl -> Create(This,nType,pExtendControlbar,ppUnknown)

#define IControlbar_Attach(This,nType,lpUnknown)	\
    (This)->lpVtbl -> Attach(This,nType,lpUnknown)

#define IControlbar_Detach(This,lpUnknown)	\
    (This)->lpVtbl -> Detach(This,lpUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbar_Create_Proxy( 
    IControlbar __RPC_FAR * This,
    /* [in] */ MMC_CONTROL_TYPE nType,
    /* [in] */ LPEXTENDCONTROLBAR pExtendControlbar,
    /* [out] */ LPUNKNOWN __RPC_FAR *ppUnknown);


void __RPC_STUB IControlbar_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbar_Attach_Proxy( 
    IControlbar __RPC_FAR * This,
    /* [in] */ MMC_CONTROL_TYPE nType,
    /* [in] */ LPUNKNOWN lpUnknown);


void __RPC_STUB IControlbar_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbar_Detach_Proxy( 
    IControlbar __RPC_FAR * This,
    /* [in] */ LPUNKNOWN lpUnknown);


void __RPC_STUB IControlbar_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IControlbar_INTERFACE_DEFINED__ */


#ifndef __IExtendControlbar_INTERFACE_DEFINED__
#define __IExtendControlbar_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IExtendControlbar
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IExtendControlbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49506520-6F40-11D0-A98B-00C04FD8D565")
    IExtendControlbar : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControlbar( 
            /* [in] */ LPCONTROLBAR pControlbar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlbarNotify( 
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendControlbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendControlbar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendControlbar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendControlbar __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetControlbar )( 
            IExtendControlbar __RPC_FAR * This,
            /* [in] */ LPCONTROLBAR pControlbar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ControlbarNotify )( 
            IExtendControlbar __RPC_FAR * This,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param);
        
        END_INTERFACE
    } IExtendControlbarVtbl;

    interface IExtendControlbar
    {
        CONST_VTBL struct IExtendControlbarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendControlbar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendControlbar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendControlbar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendControlbar_SetControlbar(This,pControlbar)	\
    (This)->lpVtbl -> SetControlbar(This,pControlbar)

#define IExtendControlbar_ControlbarNotify(This,event,arg,param)	\
    (This)->lpVtbl -> ControlbarNotify(This,event,arg,param)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendControlbar_SetControlbar_Proxy( 
    IExtendControlbar __RPC_FAR * This,
    /* [in] */ LPCONTROLBAR pControlbar);


void __RPC_STUB IExtendControlbar_SetControlbar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendControlbar_ControlbarNotify_Proxy( 
    IExtendControlbar __RPC_FAR * This,
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ long arg,
    /* [in] */ long param);


void __RPC_STUB IExtendControlbar_ControlbarNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendControlbar_INTERFACE_DEFINED__ */


#ifndef __IToolbar_INTERFACE_DEFINED__
#define __IToolbar_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IToolbar
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IToolbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB9-D36C-11CF-ADBC-00AA00A80033")
    IToolbar : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddBitmap( 
            /* [in] */ int nImages,
            /* [in] */ HBITMAP hbmp,
            /* [in] */ int cxSize,
            /* [in] */ int cySize,
            /* [in] */ COLORREF crMask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddButtons( 
            /* [in] */ int nButtons,
            /* [in] */ LPMMCBUTTON lpButtons) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertButton( 
            /* [in] */ int nIndex,
            /* [in] */ LPMMCBUTTON lpButton) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteButton( 
            /* [in] */ int nIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetButtonState( 
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetButtonState( 
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IToolbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IToolbar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IToolbar __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddBitmap )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nImages,
            /* [in] */ HBITMAP hbmp,
            /* [in] */ int cxSize,
            /* [in] */ int cySize,
            /* [in] */ COLORREF crMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddButtons )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nButtons,
            /* [in] */ LPMMCBUTTON lpButtons);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertButton )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ LPMMCBUTTON lpButton);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteButton )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetButtonState )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetButtonState )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState);
        
        END_INTERFACE
    } IToolbarVtbl;

    interface IToolbar
    {
        CONST_VTBL struct IToolbarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IToolbar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IToolbar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IToolbar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IToolbar_AddBitmap(This,nImages,hbmp,cxSize,cySize,crMask)	\
    (This)->lpVtbl -> AddBitmap(This,nImages,hbmp,cxSize,cySize,crMask)

#define IToolbar_AddButtons(This,nButtons,lpButtons)	\
    (This)->lpVtbl -> AddButtons(This,nButtons,lpButtons)

#define IToolbar_InsertButton(This,nIndex,lpButton)	\
    (This)->lpVtbl -> InsertButton(This,nIndex,lpButton)

#define IToolbar_DeleteButton(This,nIndex)	\
    (This)->lpVtbl -> DeleteButton(This,nIndex)

#define IToolbar_GetButtonState(This,idCommand,nState,pState)	\
    (This)->lpVtbl -> GetButtonState(This,idCommand,nState,pState)

#define IToolbar_SetButtonState(This,idCommand,nState,bState)	\
    (This)->lpVtbl -> SetButtonState(This,idCommand,nState,bState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_AddBitmap_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nImages,
    /* [in] */ HBITMAP hbmp,
    /* [in] */ int cxSize,
    /* [in] */ int cySize,
    /* [in] */ COLORREF crMask);


void __RPC_STUB IToolbar_AddBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_AddButtons_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nButtons,
    /* [in] */ LPMMCBUTTON lpButtons);


void __RPC_STUB IToolbar_AddButtons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_InsertButton_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ LPMMCBUTTON lpButton);


void __RPC_STUB IToolbar_InsertButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_DeleteButton_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nIndex);


void __RPC_STUB IToolbar_DeleteButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_GetButtonState_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [out] */ BOOL __RPC_FAR *pState);


void __RPC_STUB IToolbar_GetButtonState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_SetButtonState_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [in] */ BOOL bState);


void __RPC_STUB IToolbar_SetButtonState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IToolbar_INTERFACE_DEFINED__ */


#ifndef __IConsoleVerb_INTERFACE_DEFINED__
#define __IConsoleVerb_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IConsoleVerb
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IConsoleVerb;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E49F7A60-74AF-11D0-A286-00C04FD8FE93")
    IConsoleVerb : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVerbState( 
            /* [in] */ MMC_CONSOLE_VERB eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVerbState( 
            /* [in] */ MMC_CONSOLE_VERB eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDefaultVerb( 
            /* [in] */ MMC_CONSOLE_VERB eCmdID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDefaultVerb( 
            /* [out] */ MMC_CONSOLE_VERB __RPC_FAR *peCmdID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsoleVerbVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsoleVerb __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsoleVerb __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVerbState )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ MMC_CONSOLE_VERB eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVerbState )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ MMC_CONSOLE_VERB eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultVerb )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ MMC_CONSOLE_VERB eCmdID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultVerb )( 
            IConsoleVerb __RPC_FAR * This,
            /* [out] */ MMC_CONSOLE_VERB __RPC_FAR *peCmdID);
        
        END_INTERFACE
    } IConsoleVerbVtbl;

    interface IConsoleVerb
    {
        CONST_VTBL struct IConsoleVerbVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsoleVerb_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsoleVerb_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsoleVerb_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsoleVerb_GetVerbState(This,eCmdID,nState,pState)	\
    (This)->lpVtbl -> GetVerbState(This,eCmdID,nState,pState)

#define IConsoleVerb_SetVerbState(This,eCmdID,nState,bState)	\
    (This)->lpVtbl -> SetVerbState(This,eCmdID,nState,bState)

#define IConsoleVerb_SetDefaultVerb(This,eCmdID)	\
    (This)->lpVtbl -> SetDefaultVerb(This,eCmdID)

#define IConsoleVerb_GetDefaultVerb(This,peCmdID)	\
    (This)->lpVtbl -> GetDefaultVerb(This,peCmdID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleVerb_GetVerbState_Proxy( 
    IConsoleVerb __RPC_FAR * This,
    /* [in] */ MMC_CONSOLE_VERB eCmdID,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [out] */ BOOL __RPC_FAR *pState);


void __RPC_STUB IConsoleVerb_GetVerbState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleVerb_SetVerbState_Proxy( 
    IConsoleVerb __RPC_FAR * This,
    /* [in] */ MMC_CONSOLE_VERB eCmdID,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [in] */ BOOL bState);


void __RPC_STUB IConsoleVerb_SetVerbState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleVerb_SetDefaultVerb_Proxy( 
    IConsoleVerb __RPC_FAR * This,
    /* [in] */ MMC_CONSOLE_VERB eCmdID);


void __RPC_STUB IConsoleVerb_SetDefaultVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleVerb_GetDefaultVerb_Proxy( 
    IConsoleVerb __RPC_FAR * This,
    /* [out] */ MMC_CONSOLE_VERB __RPC_FAR *peCmdID);


void __RPC_STUB IConsoleVerb_GetDefaultVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsoleVerb_INTERFACE_DEFINED__ */


#ifndef __ISnapinAbout_INTERFACE_DEFINED__
#define __ISnapinAbout_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISnapinAbout
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ISnapinAbout;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1245208C-A151-11D0-A7D7-00C04FD909DD")
    ISnapinAbout : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinDescription( 
            /* [out] */ LPOLESTR __RPC_FAR *lpDescription) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ LPOLESTR __RPC_FAR *lpName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinVersion( 
            /* [out] */ LPOLESTR __RPC_FAR *lpVersion) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinImage( 
            /* [out] */ HICON __RPC_FAR *hAppIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStaticFolderImage( 
            /* [out] */ HBITMAP __RPC_FAR *hSmallImage,
            /* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
            /* [out] */ HBITMAP __RPC_FAR *hLargeImage,
            /* [out] */ COLORREF __RPC_FAR *cMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISnapinAboutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISnapinAbout __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISnapinAbout __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISnapinAbout __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSnapinDescription )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpDescription);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProvider )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSnapinVersion )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpVersion);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSnapinImage )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ HICON __RPC_FAR *hAppIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStaticFolderImage )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ HBITMAP __RPC_FAR *hSmallImage,
            /* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
            /* [out] */ HBITMAP __RPC_FAR *hLargeImage,
            /* [out] */ COLORREF __RPC_FAR *cMask);
        
        END_INTERFACE
    } ISnapinAboutVtbl;

    interface ISnapinAbout
    {
        CONST_VTBL struct ISnapinAboutVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISnapinAbout_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISnapinAbout_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISnapinAbout_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISnapinAbout_GetSnapinDescription(This,lpDescription)	\
    (This)->lpVtbl -> GetSnapinDescription(This,lpDescription)

#define ISnapinAbout_GetProvider(This,lpName)	\
    (This)->lpVtbl -> GetProvider(This,lpName)

#define ISnapinAbout_GetSnapinVersion(This,lpVersion)	\
    (This)->lpVtbl -> GetSnapinVersion(This,lpVersion)

#define ISnapinAbout_GetSnapinImage(This,hAppIcon)	\
    (This)->lpVtbl -> GetSnapinImage(This,hAppIcon)

#define ISnapinAbout_GetStaticFolderImage(This,hSmallImage,hSmallImageOpen,hLargeImage,cMask)	\
    (This)->lpVtbl -> GetStaticFolderImage(This,hSmallImage,hSmallImageOpen,hLargeImage,cMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinDescription_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpDescription);


void __RPC_STUB ISnapinAbout_GetSnapinDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetProvider_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpName);


void __RPC_STUB ISnapinAbout_GetProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinVersion_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpVersion);


void __RPC_STUB ISnapinAbout_GetSnapinVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinImage_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ HICON __RPC_FAR *hAppIcon);


void __RPC_STUB ISnapinAbout_GetSnapinImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetStaticFolderImage_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ HBITMAP __RPC_FAR *hSmallImage,
    /* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
    /* [out] */ HBITMAP __RPC_FAR *hLargeImage,
    /* [out] */ COLORREF __RPC_FAR *cMask);


void __RPC_STUB ISnapinAbout_GetStaticFolderImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISnapinAbout_INTERFACE_DEFINED__ */


#ifndef __IMenuButton_INTERFACE_DEFINED__
#define __IMenuButton_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMenuButton
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IMenuButton;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("951ED750-D080-11d0-B197-000000000000")
    IMenuButton : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddButton( 
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetButton( 
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetButtonState( 
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMenuButtonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMenuButton __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMenuButton __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddButton )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetButton )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetButtonState )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState);
        
        END_INTERFACE
    } IMenuButtonVtbl;

    interface IMenuButton
    {
        CONST_VTBL struct IMenuButtonVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMenuButton_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMenuButton_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMenuButton_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMenuButton_AddButton(This,idCommand,lpButtonText,lpTooltipText)	\
    (This)->lpVtbl -> AddButton(This,idCommand,lpButtonText,lpTooltipText)

#define IMenuButton_SetButton(This,idCommand,lpButtonText,lpTooltipText)	\
    (This)->lpVtbl -> SetButton(This,idCommand,lpButtonText,lpTooltipText)

#define IMenuButton_SetButtonState(This,idCommand,nState,bState)	\
    (This)->lpVtbl -> SetButtonState(This,idCommand,nState,bState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMenuButton_AddButton_Proxy( 
    IMenuButton __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ LPOLESTR lpButtonText,
    /* [in] */ LPOLESTR lpTooltipText);


void __RPC_STUB IMenuButton_AddButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMenuButton_SetButton_Proxy( 
    IMenuButton __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ LPOLESTR lpButtonText,
    /* [in] */ LPOLESTR lpTooltipText);


void __RPC_STUB IMenuButton_SetButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMenuButton_SetButtonState_Proxy( 
    IMenuButton __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [in] */ BOOL bState);


void __RPC_STUB IMenuButton_SetButtonState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMenuButton_INTERFACE_DEFINED__ */


#ifndef __ISnapinHelp_INTERFACE_DEFINED__
#define __ISnapinHelp_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISnapinHelp
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ISnapinHelp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6B15ACE-DF59-11D0-A7DD-00C04FD909DD")
    ISnapinHelp : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHelpTopic( 
            /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISnapinHelpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISnapinHelp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISnapinHelp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISnapinHelp __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHelpTopic )( 
            ISnapinHelp __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);
        
        END_INTERFACE
    } ISnapinHelpVtbl;

    interface ISnapinHelp
    {
        CONST_VTBL struct ISnapinHelpVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISnapinHelp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISnapinHelp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISnapinHelp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISnapinHelp_GetHelpTopic(This,lpCompiledHelpFile)	\
    (This)->lpVtbl -> GetHelpTopic(This,lpCompiledHelpFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinHelp_GetHelpTopic_Proxy( 
    ISnapinHelp __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);


void __RPC_STUB ISnapinHelp_GetHelpTopic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISnapinHelp_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0115
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 
















typedef IFramePrivate __RPC_FAR *LPFRAMEPRIVATE;

typedef IScopeDataPrivate __RPC_FAR *LPSCOPEDATAPRIVATE;

typedef IResultDataPrivate __RPC_FAR *LPRESULTDATAPRIVATE;

typedef IImageListPrivate __RPC_FAR *LPIMAGELISTPRIVATE;

typedef IPropertySheetChange __RPC_FAR *LPPROPERTYSHEETCHANGE;

typedef INodeCallback __RPC_FAR *LPNODECALLBACK;

typedef IScopeTreeIter __RPC_FAR *LPSCOPETREEITER;

typedef IScopeTree __RPC_FAR *LPSCOPETREE;

typedef INodeType __RPC_FAR *LPNODETYPE;

typedef INodeTypesCache __RPC_FAR *LPNODETYPESCACHE;

typedef IEnumGUID __RPC_FAR *LPENUMGUID;

typedef IEnumNodeTypes __RPC_FAR *LPENUMNODETYPES;

typedef IDocConfig __RPC_FAR *LPDOCCONFIG;

typedef IPropertySheetProviderPrivate __RPC_FAR *LPPROPERTYSHEETPROVIDERPRIVATE;

STDAPI MMCIsMTNodeValid(void* pMTNode, BOOL bReset);
#define DATAWINDOW_CLASS_NAME L"MMCDataWindow"
#define WINDOW_DATA_SIZE (sizeof(long) * 4)
#define PROPERTY_SHEET_SLOT          0
#define COOKIE_SLOT                  4
#define MASTERTREE_PTR_SLOT          8
#define ORIGINAL_DATA_OBJECT_SLOT    12
typedef 
enum _MID_LIST
    {	MID_VIEW	= 1,
	MID_VIEW_LARGE	= MID_VIEW + 1,
	MID_VIEW_SMALL	= MID_VIEW_LARGE + 1,
	MID_VIEW_LIST	= MID_VIEW_SMALL + 1,
	MID_VIEW_DETAIL	= MID_VIEW_LIST + 1,
	MID_VIEW_HTML	= MID_VIEW_DETAIL + 1,
	MID_ARRANGE_ICONS	= MID_VIEW_HTML + 1,
	MID_LINE_UP_ICONS	= MID_ARRANGE_ICONS + 1,
	MID_PROPERTIES	= MID_LINE_UP_ICONS + 1,
	MID_CREATE_NEW	= MID_PROPERTIES + 1,
	MID_CREATE_NEW_FOLDER	= MID_CREATE_NEW + 1,
	MID_CREATE_NEW_SHORTCUT	= MID_CREATE_NEW_FOLDER + 1,
	MID_CREATE_NEW_HTML	= MID_CREATE_NEW_SHORTCUT + 1,
	MID_CREATE_NEW_OCX	= MID_CREATE_NEW_HTML + 1,
	MID_CREATE_NEW_MONITOR	= MID_CREATE_NEW_OCX + 1,
	MID_CREATE_NEW_TASKPADITEM	= MID_CREATE_NEW_MONITOR + 1,
	MID_TASK	= MID_CREATE_NEW_TASKPADITEM + 1,
	MID_SCOPE_PANE	= MID_TASK + 1,
	MID_SELECT_ALL	= MID_SCOPE_PANE + 1,
	MID_EXPLORE	= MID_SELECT_ALL + 1,
	MID_OPEN	= MID_EXPLORE + 1,
	MID_CUT	= MID_OPEN + 1,
	MID_COPY	= MID_CUT + 1,
	MID_PASTE	= MID_COPY + 1,
	MID_DELETE	= MID_PASTE + 1,
	MID_PRINT	= MID_DELETE + 1,
	MID_REFRESH	= MID_PRINT + 1,
	MID_RENAME	= MID_REFRESH + 1,
	MID_DOCKING	= MID_RENAME + 1,
	MID_ARRANGE_NAME	= MID_DOCKING + 1,
	MID_ARRANGE_TYPE	= MID_ARRANGE_NAME + 1,
	MID_ARRANGE_SIZE	= MID_ARRANGE_TYPE + 1,
	MID_ARRANGE_DATE	= MID_ARRANGE_SIZE + 1,
	MID_ARRANGE_AUTO	= MID_ARRANGE_DATE + 1,
	MID_SNAPINMANAGER	= MID_ARRANGE_AUTO + 1,
	MID_DESC_BAR	= MID_SNAPINMANAGER + 1,
	MID_LAST	= MID_DESC_BAR + 1
    }	MID_LIST;

typedef struct  _CCLVLParam_tag
    {
    DWORD flags;
    LPARAM lParam;
    COMPONENTID ID;
    int nIndex;
    }	CCLVLParam_tag;

typedef struct  _CCLVSortParams
    {
    BOOL bAscending;
    int nCol;
    HWND hListview;
    LPRESULTDATACOMPARE lpSnapinCallback;
    long lUserParam;
    }	CCLVSortParams;

#define	MMC_S_INCOMPLETE	( 0xff0001 )

#define	MMC_E_INVALID_FILE	( 0x80ff0002 )

typedef struct  _PROPERTYCHANGEINFO
    {
    LPCOMPONENTDATA pComponentData;
    LPCOMPONENT pComponent;
    BOOL fScopePane;
    HWND hwnd;
    }	PROPERTYCHANGEINFO;

typedef 
enum _CONTEXT_MENU_TYPES
    {	CONTEXT_MENU_DEFAULT	= 0,
	CONTEXT_MENU_VIEW	= 1
    }	CONTEXT_MENU_TYPES;

typedef struct  _CONTEXTMENUNODEINFO
    {
    POINT m_displayPoint;
    POINT m_listviewPoint;
    BOOL m_bDisplaySnapinMgr;
    BOOL m_bScopeVisible;
    CONTEXT_MENU_TYPES m_eContextMenuType;
    DATA_OBJECT_TYPES m_eDataObjectType;
    BOOL m_bBackground;
    BOOL m_bMultiSelect;
    HWND m_hWnd;
    HWND m_hStatus;
    HWND m_hScopePane;
    long m_lSelected;
    long m_listviewStyle;
    long m_lParam;
    long m_nViewMode;
    long m_resultItemParam;
    BOOL m_bDescBarVisible;
    long m_hSelectedScopeNode;
    long m_htiRClicked;
    }	CONTEXTMENUNODEINFO;

typedef CONTEXTMENUNODEINFO __RPC_FAR *LPCONTEXTMENUNODEINFO;

typedef PROPERTYCHANGEINFO __RPC_FAR *LPPROPERTYCHANGEINFO;

typedef long HMTNODE;

typedef unsigned long MTNODEID;

typedef long HNODE;

#define	ROOTNODEID	( 1 )

#define	COOKIE_BACKGROUND	( -2 )

typedef struct  _SELECTIONINFO
    {
    BOOL m_bScope;
    BOOL m_bBackground;
    IUnknown __RPC_FAR *m_pView;
    long m_lCookie;
    MMC_CONSOLE_VERB m_eCmdID;
    BOOL m_bDueToFocusChange;
    }	SELECTIONINFO;

typedef 
enum _NCLBK_NOTIFY_TYPE
    {	NCLBK_NONE	= 0x9000,
	NCLBK_ACTIVATE	= 0x9001,
	NCLBK_CACHEHINT	= 0x9002,
	NCLBK_CLICK	= 0x9003,
	NCLBK_CONTEXTMENU	= 0x9004,
	NCLBK_COPY	= 0x9005,
	NCLBK_CUT	= 0x9006,
	NCLBK_DBLCLICK	= 0x9007,
	NCLBK_DELETE	= 0x9008,
	NCLBK_EXPAND	= 0x9009,
	NCLBK_EXPANDED	= 0x900a,
	NCLBK_FINDITEM	= 0x900b,
	NCLBK_FOCUS_CHANGE	= 0x900c,
	NCLBK_FOLDER	= 0x900d,
	NCLBK_MINIMIZED	= 0x900e,
	NCLBK_MULTI_SELECT	= 0x900f,
	NCLBK_NEW_NODE_UPDATE	= 0x9010,
	NCLBK_PASTE	= 0x9011,
	NCLBK_PRINT	= 0x9012,
	NCLBK_PROPERTIES	= 0x9013,
	NCLBK_PROPERTY_CHANGE	= 0x9014,
	NCLBK_QUERYPASTE	= 0x9015,
	NCLBK_REFRESH	= 0x9016,
	NCLBK_RENAME	= 0x9017,
	NCLBK_SELECT	= 0x9018,
	NCLBK_SHOW	= 0x9019,
	NCLBK_SORT	= 0x901a,
	NCLBK_ROOTITEMSEL	= 0x901b,
	NCLBK_SHOWWEBBAR	= 0x901c,
	NCLBK_SCOPEPANEVISIBLE	= 0x901d
    }	NCLBK_NOTIFY_TYPE;

#define	CCF_MULTI_SELECT_STATIC_DATA	( L"CCF_MULTI_SELECT_STATIC_DATA" )

#define	CCF_NEWNODE	( L"CCF_NEWNODE" )

extern const CLSID CLSID_NDMGR_SNAPIN;

extern const GUID GUID_MMC_NEWNODETYPE;



extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0115_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0115_v0_0_s_ifspec;

#ifndef __IPropertySheetChange_INTERFACE_DEFINED__
#define __IPropertySheetChange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertySheetChange
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][local][object] */ 



EXTERN_C const IID IID_IPropertySheetChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d700dd8e-2646-11d0-a2a7-00c04fd909dd")
    IPropertySheetChange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ long handle,
            /* [in] */ long param) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySheetChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySheetChange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySheetChange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySheetChange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            IPropertySheetChange __RPC_FAR * This,
            /* [in] */ long handle,
            /* [in] */ long param);
        
        END_INTERFACE
    } IPropertySheetChangeVtbl;

    interface IPropertySheetChange
    {
        CONST_VTBL struct IPropertySheetChangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySheetChange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySheetChange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySheetChange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySheetChange_Update(This,handle,param)	\
    (This)->lpVtbl -> Update(This,handle,param)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertySheetChange_Update_Proxy( 
    IPropertySheetChange __RPC_FAR * This,
    /* [in] */ long handle,
    /* [in] */ long param);


void __RPC_STUB IPropertySheetChange_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySheetChange_INTERFACE_DEFINED__ */


#ifndef __IFramePrivate_INTERFACE_DEFINED__
#define __IFramePrivate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IFramePrivate
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IFramePrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d71d1f2a-1ba2-11d0-a29b-00c04fd909dd")
    IFramePrivate : public IConsole
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetResultView( 
            /* [in] */ LPUNKNOWN pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatusBar( 
            /* [in] */ long hwndStatusBar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetComponentID( 
            /* [out] */ COMPONENTID __RPC_FAR *lpComponentID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetComponentID( 
            /* [in] */ COMPONENTID id) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetNode( 
            /* [in] */ long lMTNode,
            /* [in] */ long lNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetComponent( 
            /* [in] */ LPCOMPONENT lpComponent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryScopeTree( 
            /* [out] */ IScopeTree __RPC_FAR *__RPC_FAR *ppScopeTree) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetScopeTree( 
            /* [in] */ IScopeTree __RPC_FAR *pScopeTree) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateScopeImageList( 
            /* [in] */ REFCLSID refClsidSnapIn) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetUsedByExtension( 
            /* [in] */ BOOL bExtension) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InitViewData( 
            /* [in] */ long lViewData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CleanupViewData( 
            /* [in] */ long lViewData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFramePrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFramePrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFramePrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHeader )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPHEADERCTRL pHeader);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetToolbar )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPTOOLBAR pToolbar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultView )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryScopeImageList )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultImageList )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateAllViews )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ long data,
            /* [in] */ long hint);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MessageBox )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPCWSTR lpszText,
            /* [in] */ LPCWSTR lpszTitle,
            /* [in] */ UINT fuStyle,
            /* [out] */ int __RPC_FAR *piRetval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryConsoleVerb )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectScopeItem )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMainWindow )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewWindow )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem,
            /* [in] */ unsigned long lOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetResultView )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPUNKNOWN pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusBar )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ long hwndStatusBar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponentID )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ COMPONENTID __RPC_FAR *lpComponentID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComponentID )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ COMPONENTID id);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNode )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ long lMTNode,
            /* [in] */ long lNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComponent )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPCOMPONENT lpComponent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryScopeTree )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ IScopeTree __RPC_FAR *__RPC_FAR *ppScopeTree);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetScopeTree )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ IScopeTree __RPC_FAR *pScopeTree);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateScopeImageList )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ REFCLSID refClsidSnapIn);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUsedByExtension )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ BOOL bExtension);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitViewData )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ long lViewData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CleanupViewData )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ long lViewData);
        
        END_INTERFACE
    } IFramePrivateVtbl;

    interface IFramePrivate
    {
        CONST_VTBL struct IFramePrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFramePrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFramePrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFramePrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFramePrivate_SetHeader(This,pHeader)	\
    (This)->lpVtbl -> SetHeader(This,pHeader)

#define IFramePrivate_SetToolbar(This,pToolbar)	\
    (This)->lpVtbl -> SetToolbar(This,pToolbar)

#define IFramePrivate_QueryResultView(This,pUnknown)	\
    (This)->lpVtbl -> QueryResultView(This,pUnknown)

#define IFramePrivate_QueryScopeImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryScopeImageList(This,ppImageList)

#define IFramePrivate_QueryResultImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryResultImageList(This,ppImageList)

#define IFramePrivate_UpdateAllViews(This,lpDataObject,data,hint)	\
    (This)->lpVtbl -> UpdateAllViews(This,lpDataObject,data,hint)

#define IFramePrivate_MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)	\
    (This)->lpVtbl -> MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)

#define IFramePrivate_QueryConsoleVerb(This,ppConsoleVerb)	\
    (This)->lpVtbl -> QueryConsoleVerb(This,ppConsoleVerb)

#define IFramePrivate_SelectScopeItem(This,hScopeItem)	\
    (This)->lpVtbl -> SelectScopeItem(This,hScopeItem)

#define IFramePrivate_GetMainWindow(This,phwnd)	\
    (This)->lpVtbl -> GetMainWindow(This,phwnd)

#define IFramePrivate_NewWindow(This,hScopeItem,lOptions)	\
    (This)->lpVtbl -> NewWindow(This,hScopeItem,lOptions)


#define IFramePrivate_SetResultView(This,pUnknown)	\
    (This)->lpVtbl -> SetResultView(This,pUnknown)

#define IFramePrivate_SetStatusBar(This,hwndStatusBar)	\
    (This)->lpVtbl -> SetStatusBar(This,hwndStatusBar)

#define IFramePrivate_GetComponentID(This,lpComponentID)	\
    (This)->lpVtbl -> GetComponentID(This,lpComponentID)

#define IFramePrivate_SetComponentID(This,id)	\
    (This)->lpVtbl -> SetComponentID(This,id)

#define IFramePrivate_SetNode(This,lMTNode,lNode)	\
    (This)->lpVtbl -> SetNode(This,lMTNode,lNode)

#define IFramePrivate_SetComponent(This,lpComponent)	\
    (This)->lpVtbl -> SetComponent(This,lpComponent)

#define IFramePrivate_QueryScopeTree(This,ppScopeTree)	\
    (This)->lpVtbl -> QueryScopeTree(This,ppScopeTree)

#define IFramePrivate_SetScopeTree(This,pScopeTree)	\
    (This)->lpVtbl -> SetScopeTree(This,pScopeTree)

#define IFramePrivate_CreateScopeImageList(This,refClsidSnapIn)	\
    (This)->lpVtbl -> CreateScopeImageList(This,refClsidSnapIn)

#define IFramePrivate_SetUsedByExtension(This,bExtension)	\
    (This)->lpVtbl -> SetUsedByExtension(This,bExtension)

#define IFramePrivate_InitViewData(This,lViewData)	\
    (This)->lpVtbl -> InitViewData(This,lViewData)

#define IFramePrivate_CleanupViewData(This,lViewData)	\
    (This)->lpVtbl -> CleanupViewData(This,lViewData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetResultView_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ LPUNKNOWN pUnknown);


void __RPC_STUB IFramePrivate_SetResultView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetStatusBar_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ long hwndStatusBar);


void __RPC_STUB IFramePrivate_SetStatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_GetComponentID_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [out] */ COMPONENTID __RPC_FAR *lpComponentID);


void __RPC_STUB IFramePrivate_GetComponentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetComponentID_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ COMPONENTID id);


void __RPC_STUB IFramePrivate_SetComponentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetNode_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ long lMTNode,
    /* [in] */ long lNode);


void __RPC_STUB IFramePrivate_SetNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetComponent_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ LPCOMPONENT lpComponent);


void __RPC_STUB IFramePrivate_SetComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_QueryScopeTree_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [out] */ IScopeTree __RPC_FAR *__RPC_FAR *ppScopeTree);


void __RPC_STUB IFramePrivate_QueryScopeTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetScopeTree_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ IScopeTree __RPC_FAR *pScopeTree);


void __RPC_STUB IFramePrivate_SetScopeTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_CreateScopeImageList_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ REFCLSID refClsidSnapIn);


void __RPC_STUB IFramePrivate_CreateScopeImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetUsedByExtension_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ BOOL bExtension);


void __RPC_STUB IFramePrivate_SetUsedByExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_InitViewData_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ long lViewData);


void __RPC_STUB IFramePrivate_InitViewData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_CleanupViewData_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ long lViewData);


void __RPC_STUB IFramePrivate_CleanupViewData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFramePrivate_INTERFACE_DEFINED__ */


#ifndef __IScopeDataPrivate_INTERFACE_DEFINED__
#define __IScopeDataPrivate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScopeDataPrivate
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IScopeDataPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60BD2FE0-F7C5-11cf-8AFD-00AA003CA9F6")
    IScopeDataPrivate : public IConsoleNameSpace
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IScopeDataPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScopeDataPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScopeDataPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ long fDeleteThis);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
            /* [out] */ long __RPC_FAR *plCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
            /* [out] */ long __RPC_FAR *plCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParentItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
            /* [out] */ long __RPC_FAR *plCookie);
        
        END_INTERFACE
    } IScopeDataPrivateVtbl;

    interface IScopeDataPrivate
    {
        CONST_VTBL struct IScopeDataPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScopeDataPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScopeDataPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScopeDataPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScopeDataPrivate_InsertItem(This,item)	\
    (This)->lpVtbl -> InsertItem(This,item)

#define IScopeDataPrivate_DeleteItem(This,hItem,fDeleteThis)	\
    (This)->lpVtbl -> DeleteItem(This,hItem,fDeleteThis)

#define IScopeDataPrivate_SetItem(This,item)	\
    (This)->lpVtbl -> SetItem(This,item)

#define IScopeDataPrivate_GetItem(This,item)	\
    (This)->lpVtbl -> GetItem(This,item)

#define IScopeDataPrivate_GetChildItem(This,item,pItemChild,plCookie)	\
    (This)->lpVtbl -> GetChildItem(This,item,pItemChild,plCookie)

#define IScopeDataPrivate_GetNextItem(This,item,pItemNext,plCookie)	\
    (This)->lpVtbl -> GetNextItem(This,item,pItemNext,plCookie)

#define IScopeDataPrivate_GetParentItem(This,item,pItemParent,plCookie)	\
    (This)->lpVtbl -> GetParentItem(This,item,pItemParent,plCookie)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IScopeDataPrivate_INTERFACE_DEFINED__ */


#ifndef __IImageListPrivate_INTERFACE_DEFINED__
#define __IImageListPrivate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImageListPrivate
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IImageListPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7538C620-0083-11d0-8B00-00AA003CA9F6")
    IImageListPrivate : public IImageList
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapRsltImage( 
            COMPONENTID id,
            /* [in] */ int nIndex,
            /* [out] */ int __RPC_FAR *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageListPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImageListPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImageListPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImageListPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImageListSetIcon )( 
            IImageListPrivate __RPC_FAR * This,
            /* [in] */ long __RPC_FAR *pIcon,
            /* [in] */ long nLoc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImageListSetStrip )( 
            IImageListPrivate __RPC_FAR * This,
            /* [in] */ long __RPC_FAR *pBMapSm,
            /* [in] */ long __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ COLORREF cMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapRsltImage )( 
            IImageListPrivate __RPC_FAR * This,
            COMPONENTID id,
            /* [in] */ int nIndex,
            /* [out] */ int __RPC_FAR *retVal);
        
        END_INTERFACE
    } IImageListPrivateVtbl;

    interface IImageListPrivate
    {
        CONST_VTBL struct IImageListPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageListPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageListPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImageListPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImageListPrivate_ImageListSetIcon(This,pIcon,nLoc)	\
    (This)->lpVtbl -> ImageListSetIcon(This,pIcon,nLoc)

#define IImageListPrivate_ImageListSetStrip(This,pBMapSm,pBMapLg,nStartLoc,cMask)	\
    (This)->lpVtbl -> ImageListSetStrip(This,pBMapSm,pBMapLg,nStartLoc,cMask)


#define IImageListPrivate_MapRsltImage(This,id,nIndex,retVal)	\
    (This)->lpVtbl -> MapRsltImage(This,id,nIndex,retVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IImageListPrivate_MapRsltImage_Proxy( 
    IImageListPrivate __RPC_FAR * This,
    COMPONENTID id,
    /* [in] */ int nIndex,
    /* [out] */ int __RPC_FAR *retVal);


void __RPC_STUB IImageListPrivate_MapRsltImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImageListPrivate_INTERFACE_DEFINED__ */


#ifndef __IResultDataPrivate_INTERFACE_DEFINED__
#define __IResultDataPrivate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResultDataPrivate
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IResultDataPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1EBA2300-0854-11d0-8B03-00AA003CA9F6")
    IResultDataPrivate : public IResultData
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetListStyle( 
            /* [out] */ long __RPC_FAR *pStyle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetListStyle( 
            /* [in] */ long Style) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Arrange( 
            long style) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InternalSort( 
            long lpHeaderCtl,
            long lUserParam) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ResetResultData( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ResultHitTest( 
            /* [in] */ int nX,
            /* [in] */ int nY,
            /* [out] */ int __RPC_FAR *piIndex,
            /* [out] */ unsigned int __RPC_FAR *pflags,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID,
            /* [out] */ COMPONENTID __RPC_FAR *pComponentID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultDataPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultDataPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultDataPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ int nCol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItemByLParam )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ LPARAM lParam,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllRsltItems )( 
            IResultDataPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyItemState )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ UINT uAdd,
            /* [in] */ UINT uRemove);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyViewStyle )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ MMC_RESULT_VIEW_STYLE add,
            /* [in] */ MMC_RESULT_VIEW_STYLE remove);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetViewMode )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ long lViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetViewMode )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *lViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ HRESULTITEM itemID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sort )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ long lUserParam);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescBarText )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ LPOLESTR DescText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItemCount )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetQuickFilter )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ UINT nColumn,
            /* [in] */ long lFilter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQuickFilter )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ UINT nColumn,
            /* [out] */ long __RPC_FAR *plFilter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListStyle )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *pStyle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListStyle )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ long Style);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Arrange )( 
            IResultDataPrivate __RPC_FAR * This,
            long style);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InternalSort )( 
            IResultDataPrivate __RPC_FAR * This,
            long lpHeaderCtl,
            long lUserParam);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetResultData )( 
            IResultDataPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResultHitTest )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ int nX,
            /* [in] */ int nY,
            /* [out] */ int __RPC_FAR *piIndex,
            /* [out] */ unsigned int __RPC_FAR *pflags,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID,
            /* [out] */ COMPONENTID __RPC_FAR *pComponentID);
        
        END_INTERFACE
    } IResultDataPrivateVtbl;

    interface IResultDataPrivate
    {
        CONST_VTBL struct IResultDataPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultDataPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultDataPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultDataPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultDataPrivate_InsertItem(This,item)	\
    (This)->lpVtbl -> InsertItem(This,item)

#define IResultDataPrivate_DeleteItem(This,itemID,nCol)	\
    (This)->lpVtbl -> DeleteItem(This,itemID,nCol)

#define IResultDataPrivate_FindItemByLParam(This,lParam,pItemID)	\
    (This)->lpVtbl -> FindItemByLParam(This,lParam,pItemID)

#define IResultDataPrivate_DeleteAllRsltItems(This)	\
    (This)->lpVtbl -> DeleteAllRsltItems(This)

#define IResultDataPrivate_SetItem(This,item)	\
    (This)->lpVtbl -> SetItem(This,item)

#define IResultDataPrivate_GetItem(This,item)	\
    (This)->lpVtbl -> GetItem(This,item)

#define IResultDataPrivate_GetNextItem(This,item)	\
    (This)->lpVtbl -> GetNextItem(This,item)

#define IResultDataPrivate_ModifyItemState(This,nIndex,itemID,uAdd,uRemove)	\
    (This)->lpVtbl -> ModifyItemState(This,nIndex,itemID,uAdd,uRemove)

#define IResultDataPrivate_ModifyViewStyle(This,add,remove)	\
    (This)->lpVtbl -> ModifyViewStyle(This,add,remove)

#define IResultDataPrivate_SetViewMode(This,lViewMode)	\
    (This)->lpVtbl -> SetViewMode(This,lViewMode)

#define IResultDataPrivate_GetViewMode(This,lViewMode)	\
    (This)->lpVtbl -> GetViewMode(This,lViewMode)

#define IResultDataPrivate_UpdateItem(This,itemID)	\
    (This)->lpVtbl -> UpdateItem(This,itemID)

#define IResultDataPrivate_Sort(This,nColumn,dwSortOptions,lUserParam)	\
    (This)->lpVtbl -> Sort(This,nColumn,dwSortOptions,lUserParam)

#define IResultDataPrivate_SetDescBarText(This,DescText)	\
    (This)->lpVtbl -> SetDescBarText(This,DescText)

#define IResultDataPrivate_SetItemCount(This,nItemCount,dwOptions)	\
    (This)->lpVtbl -> SetItemCount(This,nItemCount,dwOptions)

#define IResultDataPrivate_SetQuickFilter(This,nColumn,lFilter)	\
    (This)->lpVtbl -> SetQuickFilter(This,nColumn,lFilter)

#define IResultDataPrivate_GetQuickFilter(This,nColumn,plFilter)	\
    (This)->lpVtbl -> GetQuickFilter(This,nColumn,plFilter)


#define IResultDataPrivate_GetListStyle(This,pStyle)	\
    (This)->lpVtbl -> GetListStyle(This,pStyle)

#define IResultDataPrivate_SetListStyle(This,Style)	\
    (This)->lpVtbl -> SetListStyle(This,Style)

#define IResultDataPrivate_Arrange(This,style)	\
    (This)->lpVtbl -> Arrange(This,style)

#define IResultDataPrivate_InternalSort(This,lpHeaderCtl,lUserParam)	\
    (This)->lpVtbl -> InternalSort(This,lpHeaderCtl,lUserParam)

#define IResultDataPrivate_ResetResultData(This)	\
    (This)->lpVtbl -> ResetResultData(This)

#define IResultDataPrivate_ResultHitTest(This,nX,nY,piIndex,pflags,pItemID,pComponentID)	\
    (This)->lpVtbl -> ResultHitTest(This,nX,nY,piIndex,pflags,pItemID,pComponentID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_GetListStyle_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *pStyle);


void __RPC_STUB IResultDataPrivate_GetListStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_SetListStyle_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    /* [in] */ long Style);


void __RPC_STUB IResultDataPrivate_SetListStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_Arrange_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    long style);


void __RPC_STUB IResultDataPrivate_Arrange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_InternalSort_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    long lpHeaderCtl,
    long lUserParam);


void __RPC_STUB IResultDataPrivate_InternalSort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_ResetResultData_Proxy( 
    IResultDataPrivate __RPC_FAR * This);


void __RPC_STUB IResultDataPrivate_ResetResultData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_ResultHitTest_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    /* [in] */ int nX,
    /* [in] */ int nY,
    /* [out] */ int __RPC_FAR *piIndex,
    /* [out] */ unsigned int __RPC_FAR *pflags,
    /* [out] */ HRESULTITEM __RPC_FAR *pItemID,
    /* [out] */ COMPONENTID __RPC_FAR *pComponentID);


void __RPC_STUB IResultDataPrivate_ResultHitTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultDataPrivate_INTERFACE_DEFINED__ */


#ifndef __IScopeTree_INTERFACE_DEFINED__
#define __IScopeTree_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScopeTree
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IScopeTree;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d8dbf067-5fb2-11d0-a986-00c04fd8d565")
    IScopeTree : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ long lFrameWindow) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryIterator( 
            /* [out] */ IScopeTreeIter __RPC_FAR *__RPC_FAR *lpIter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryNodeCallback( 
            /* [out] */ INodeCallback __RPC_FAR *__RPC_FAR *ppNodeCallback) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ HMTNODE hMTNode,
            /* [in] */ long lViewData,
            /* [in] */ BOOL fRootNode,
            /* [out] */ HNODE __RPC_FAR *phNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteView( 
            /* [in] */ int nView) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CopyView( 
            /* [in] */ int nDestView,
            /* [in] */ int nSrcView) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DestroyNode( 
            /* [in] */ HNODE hNode,
            /* [in] */ BOOL bDestroyStorage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Find( 
            /* [in] */ MTNODEID mID,
            /* [out] */ HMTNODE __RPC_FAR *phMTNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetImageList( 
            /* [out] */ long __RPC_FAR *plImageList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RunSnapIn( 
            /* [in] */ long hwndParent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsValidDocFile( 
            /* [in] */ IStorage __RPC_FAR *pStorage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsValidDocFileName( 
            /* [in] */ LPOLESTR filename) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIDFromPath( 
            /* [in] */ UINT idStatic,
            /* [in] */ LPTSTR pszPath,
            /* [out] */ ULONG __RPC_FAR *pID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIDPath( 
            /* [in] */ MTNODEID id,
            /* [out] */ MTNODEID __RPC_FAR *__RPC_FAR *ppIDs,
            /* [out] */ long __RPC_FAR *pLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScopeTreeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScopeTree __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScopeTree __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ long lFrameWindow);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryIterator )( 
            IScopeTree __RPC_FAR * This,
            /* [out] */ IScopeTreeIter __RPC_FAR *__RPC_FAR *lpIter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryNodeCallback )( 
            IScopeTree __RPC_FAR * This,
            /* [out] */ INodeCallback __RPC_FAR *__RPC_FAR *ppNodeCallback);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNode )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ HMTNODE hMTNode,
            /* [in] */ long lViewData,
            /* [in] */ BOOL fRootNode,
            /* [out] */ HNODE __RPC_FAR *phNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteView )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ int nView);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyView )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ int nDestView,
            /* [in] */ int nSrcView);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyNode )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ BOOL bDestroyStorage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Find )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ MTNODEID mID,
            /* [out] */ HMTNODE __RPC_FAR *phMTNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImageList )( 
            IScopeTree __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *plImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RunSnapIn )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ long hwndParent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsValidDocFile )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ IStorage __RPC_FAR *pStorage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsValidDocFileName )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ LPOLESTR filename);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDFromPath )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ UINT idStatic,
            /* [in] */ LPTSTR pszPath,
            /* [out] */ ULONG __RPC_FAR *pID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDPath )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ MTNODEID id,
            /* [out] */ MTNODEID __RPC_FAR *__RPC_FAR *ppIDs,
            /* [out] */ long __RPC_FAR *pLength);
        
        END_INTERFACE
    } IScopeTreeVtbl;

    interface IScopeTree
    {
        CONST_VTBL struct IScopeTreeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScopeTree_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScopeTree_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScopeTree_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScopeTree_Initialize(This,lFrameWindow)	\
    (This)->lpVtbl -> Initialize(This,lFrameWindow)

#define IScopeTree_QueryIterator(This,lpIter)	\
    (This)->lpVtbl -> QueryIterator(This,lpIter)

#define IScopeTree_QueryNodeCallback(This,ppNodeCallback)	\
    (This)->lpVtbl -> QueryNodeCallback(This,ppNodeCallback)

#define IScopeTree_CreateNode(This,hMTNode,lViewData,fRootNode,phNode)	\
    (This)->lpVtbl -> CreateNode(This,hMTNode,lViewData,fRootNode,phNode)

#define IScopeTree_DeleteView(This,nView)	\
    (This)->lpVtbl -> DeleteView(This,nView)

#define IScopeTree_CopyView(This,nDestView,nSrcView)	\
    (This)->lpVtbl -> CopyView(This,nDestView,nSrcView)

#define IScopeTree_DestroyNode(This,hNode,bDestroyStorage)	\
    (This)->lpVtbl -> DestroyNode(This,hNode,bDestroyStorage)

#define IScopeTree_Find(This,mID,phMTNode)	\
    (This)->lpVtbl -> Find(This,mID,phMTNode)

#define IScopeTree_GetImageList(This,plImageList)	\
    (This)->lpVtbl -> GetImageList(This,plImageList)

#define IScopeTree_RunSnapIn(This,hwndParent)	\
    (This)->lpVtbl -> RunSnapIn(This,hwndParent)

#define IScopeTree_IsValidDocFile(This,pStorage)	\
    (This)->lpVtbl -> IsValidDocFile(This,pStorage)

#define IScopeTree_IsValidDocFileName(This,filename)	\
    (This)->lpVtbl -> IsValidDocFileName(This,filename)

#define IScopeTree_GetIDFromPath(This,idStatic,pszPath,pID)	\
    (This)->lpVtbl -> GetIDFromPath(This,idStatic,pszPath,pID)

#define IScopeTree_GetIDPath(This,id,ppIDs,pLength)	\
    (This)->lpVtbl -> GetIDPath(This,id,ppIDs,pLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_Initialize_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ long lFrameWindow);


void __RPC_STUB IScopeTree_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_QueryIterator_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [out] */ IScopeTreeIter __RPC_FAR *__RPC_FAR *lpIter);


void __RPC_STUB IScopeTree_QueryIterator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_QueryNodeCallback_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [out] */ INodeCallback __RPC_FAR *__RPC_FAR *ppNodeCallback);


void __RPC_STUB IScopeTree_QueryNodeCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_CreateNode_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ HMTNODE hMTNode,
    /* [in] */ long lViewData,
    /* [in] */ BOOL fRootNode,
    /* [out] */ HNODE __RPC_FAR *phNode);


void __RPC_STUB IScopeTree_CreateNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_DeleteView_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ int nView);


void __RPC_STUB IScopeTree_DeleteView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_CopyView_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ int nDestView,
    /* [in] */ int nSrcView);


void __RPC_STUB IScopeTree_CopyView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_DestroyNode_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ BOOL bDestroyStorage);


void __RPC_STUB IScopeTree_DestroyNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_Find_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ MTNODEID mID,
    /* [out] */ HMTNODE __RPC_FAR *phMTNode);


void __RPC_STUB IScopeTree_Find_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_GetImageList_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *plImageList);


void __RPC_STUB IScopeTree_GetImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_RunSnapIn_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ long hwndParent);


void __RPC_STUB IScopeTree_RunSnapIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_IsValidDocFile_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ IStorage __RPC_FAR *pStorage);


void __RPC_STUB IScopeTree_IsValidDocFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_IsValidDocFileName_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ LPOLESTR filename);


void __RPC_STUB IScopeTree_IsValidDocFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_GetIDFromPath_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ UINT idStatic,
    /* [in] */ LPTSTR pszPath,
    /* [out] */ ULONG __RPC_FAR *pID);


void __RPC_STUB IScopeTree_GetIDFromPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_GetIDPath_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ MTNODEID id,
    /* [out] */ MTNODEID __RPC_FAR *__RPC_FAR *ppIDs,
    /* [out] */ long __RPC_FAR *pLength);


void __RPC_STUB IScopeTree_GetIDPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScopeTree_INTERFACE_DEFINED__ */


#ifndef __IScopeTreeIter_INTERFACE_DEFINED__
#define __IScopeTreeIter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScopeTreeIter
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IScopeTreeIter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d779f8d1-6057-11d0-a986-00c04fd8d565")
    IScopeTreeIter : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCurrent( 
            /* [in] */ HMTNODE hStartMTNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ UINT nRequested,
            /* [out] */ HMTNODE __RPC_FAR *rghScopeItems,
            /* [out] */ UINT __RPC_FAR *pnFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Child( 
            /* [out] */ HMTNODE __RPC_FAR *phsiChild) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Parent( 
            /* [out] */ HMTNODE __RPC_FAR *phsiParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScopeTreeIterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScopeTreeIter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScopeTreeIter __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCurrent )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [in] */ HMTNODE hStartMTNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [in] */ UINT nRequested,
            /* [out] */ HMTNODE __RPC_FAR *rghScopeItems,
            /* [out] */ UINT __RPC_FAR *pnFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Child )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [out] */ HMTNODE __RPC_FAR *phsiChild);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Parent )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [out] */ HMTNODE __RPC_FAR *phsiParent);
        
        END_INTERFACE
    } IScopeTreeIterVtbl;

    interface IScopeTreeIter
    {
        CONST_VTBL struct IScopeTreeIterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScopeTreeIter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScopeTreeIter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScopeTreeIter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScopeTreeIter_SetCurrent(This,hStartMTNode)	\
    (This)->lpVtbl -> SetCurrent(This,hStartMTNode)

#define IScopeTreeIter_Next(This,nRequested,rghScopeItems,pnFetched)	\
    (This)->lpVtbl -> Next(This,nRequested,rghScopeItems,pnFetched)

#define IScopeTreeIter_Child(This,phsiChild)	\
    (This)->lpVtbl -> Child(This,phsiChild)

#define IScopeTreeIter_Parent(This,phsiParent)	\
    (This)->lpVtbl -> Parent(This,phsiParent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTreeIter_SetCurrent_Proxy( 
    IScopeTreeIter __RPC_FAR * This,
    /* [in] */ HMTNODE hStartMTNode);


void __RPC_STUB IScopeTreeIter_SetCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTreeIter_Next_Proxy( 
    IScopeTreeIter __RPC_FAR * This,
    /* [in] */ UINT nRequested,
    /* [out] */ HMTNODE __RPC_FAR *rghScopeItems,
    /* [out] */ UINT __RPC_FAR *pnFetched);


void __RPC_STUB IScopeTreeIter_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTreeIter_Child_Proxy( 
    IScopeTreeIter __RPC_FAR * This,
    /* [out] */ HMTNODE __RPC_FAR *phsiChild);


void __RPC_STUB IScopeTreeIter_Child_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTreeIter_Parent_Proxy( 
    IScopeTreeIter __RPC_FAR * This,
    /* [out] */ HMTNODE __RPC_FAR *phsiParent);


void __RPC_STUB IScopeTreeIter_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScopeTreeIter_INTERFACE_DEFINED__ */


#ifndef __INodeCallback_INTERFACE_DEFINED__
#define __INodeCallback_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: INodeCallback
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_INodeCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b241fced-5fb3-11d0-a986-00c04fd8d565")
    INodeCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IScopeTree __RPC_FAR *pIScopeTree) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetImages( 
            /* [in] */ HNODE hNode,
            /* [out] */ int __RPC_FAR *iImage,
            int __RPC_FAR *iSelectedImage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [in] */ HNODE hNode,
            /* [out] */ LPOLESTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDispInfo( 
            /* [in] */ HNODE hNode,
            /* [in] */ long dispInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultPane( 
            /* [in] */ HNODE hNode,
            /* [out] */ LPOLESTR __RPC_FAR *ppszResultPane,
            /* [out] */ long __RPC_FAR *pViewOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetControl( 
            /* [in] */ HNODE hNode,
            /* [in] */ CLSID clsid,
            /* [out] */ long __RPC_FAR *plControl) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControl( 
            /* [in] */ HNODE hNode,
            /* [in] */ CLSID clsid,
            /* [in] */ long lControl,
            /* [in] */ long destroyer,
            /* [in] */ IUnknown __RPC_FAR *pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetItemID( 
            /* [in] */ HNODE hNode,
            /* [in] */ UINT nID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItemID( 
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetID( 
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPath( 
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID,
            /* [out] */ LPTSTR __RPC_FAR *ppszPath,
            /* [out] */ UINT __RPC_FAR *pcch) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStaticParentID( 
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ HNODE hNode,
            /* [in] */ NCLBK_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMTNode( 
            /* [in] */ HNODE hNode,
            /* [out] */ HMTNODE __RPC_FAR *phMTNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMTNodePath( 
            /* [in] */ HNODE hNode,
            /* [out] */ HMTNODE __RPC_FAR *__RPC_FAR *pphMTNode,
            /* [out] */ long __RPC_FAR *plLength) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsExpandable( 
            /* [in] */ HNODE hNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCopyDataObject( 
            /* [in] */ HNODE hNode,
            /* [in] */ BOOL bScope,
            /* [in] */ BOOL bMultiSel,
            /* [in] */ long cookie,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Drop( 
            /* [in] */ HNODE hNode,
            /* [in] */ BOOL bScope,
            /* [in] */ long lCookie,
            /* [in] */ BOOL bMove,
            /* [in] */ IDataObject __RPC_FAR *pDataObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INodeCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INodeCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INodeCallback __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ IScopeTree __RPC_FAR *pIScopeTree);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImages )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ int __RPC_FAR *iImage,
            int __RPC_FAR *iSelectedImage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayName )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ LPOLESTR __RPC_FAR *pName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDispInfo )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ long dispInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultPane )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ LPOLESTR __RPC_FAR *ppszResultPane,
            /* [out] */ long __RPC_FAR *pViewOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetControl )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ CLSID clsid,
            /* [out] */ long __RPC_FAR *plControl);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetControl )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ CLSID clsid,
            /* [in] */ long lControl,
            /* [in] */ long destroyer,
            /* [in] */ IUnknown __RPC_FAR *pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItemID )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ UINT nID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItemID )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetID )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPath )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID,
            /* [out] */ LPTSTR __RPC_FAR *ppszPath,
            /* [out] */ UINT __RPC_FAR *pcch);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStaticParentID )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ NCLBK_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMTNode )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ HMTNODE __RPC_FAR *phMTNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMTNodePath )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ HMTNODE __RPC_FAR *__RPC_FAR *pphMTNode,
            /* [out] */ long __RPC_FAR *plLength);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsExpandable )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCopyDataObject )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ BOOL bScope,
            /* [in] */ BOOL bMultiSel,
            /* [in] */ long cookie,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Drop )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ BOOL bScope,
            /* [in] */ long lCookie,
            /* [in] */ BOOL bMove,
            /* [in] */ IDataObject __RPC_FAR *pDataObject);
        
        END_INTERFACE
    } INodeCallbackVtbl;

    interface INodeCallback
    {
        CONST_VTBL struct INodeCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INodeCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INodeCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INodeCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INodeCallback_Initialize(This,pIScopeTree)	\
    (This)->lpVtbl -> Initialize(This,pIScopeTree)

#define INodeCallback_GetImages(This,hNode,iImage,iSelectedImage)	\
    (This)->lpVtbl -> GetImages(This,hNode,iImage,iSelectedImage)

#define INodeCallback_GetDisplayName(This,hNode,pName)	\
    (This)->lpVtbl -> GetDisplayName(This,hNode,pName)

#define INodeCallback_GetDispInfo(This,hNode,dispInfo)	\
    (This)->lpVtbl -> GetDispInfo(This,hNode,dispInfo)

#define INodeCallback_GetState(This,hNode,pnState)	\
    (This)->lpVtbl -> GetState(This,hNode,pnState)

#define INodeCallback_GetResultPane(This,hNode,ppszResultPane,pViewOptions)	\
    (This)->lpVtbl -> GetResultPane(This,hNode,ppszResultPane,pViewOptions)

#define INodeCallback_GetControl(This,hNode,clsid,plControl)	\
    (This)->lpVtbl -> GetControl(This,hNode,clsid,plControl)

#define INodeCallback_SetControl(This,hNode,clsid,lControl,destroyer,pUnknown)	\
    (This)->lpVtbl -> SetControl(This,hNode,clsid,lControl,destroyer,pUnknown)

#define INodeCallback_SetItemID(This,hNode,nID)	\
    (This)->lpVtbl -> SetItemID(This,hNode,nID)

#define INodeCallback_GetItemID(This,hNode,pnID)	\
    (This)->lpVtbl -> GetItemID(This,hNode,pnID)

#define INodeCallback_GetID(This,hNode,pnID)	\
    (This)->lpVtbl -> GetID(This,hNode,pnID)

#define INodeCallback_GetPath(This,hNode,pnID,ppszPath,pcch)	\
    (This)->lpVtbl -> GetPath(This,hNode,pnID,ppszPath,pcch)

#define INodeCallback_GetStaticParentID(This,hNode,pnID)	\
    (This)->lpVtbl -> GetStaticParentID(This,hNode,pnID)

#define INodeCallback_Notify(This,hNode,event,arg,param)	\
    (This)->lpVtbl -> Notify(This,hNode,event,arg,param)

#define INodeCallback_GetMTNode(This,hNode,phMTNode)	\
    (This)->lpVtbl -> GetMTNode(This,hNode,phMTNode)

#define INodeCallback_GetMTNodePath(This,hNode,pphMTNode,plLength)	\
    (This)->lpVtbl -> GetMTNodePath(This,hNode,pphMTNode,plLength)

#define INodeCallback_IsExpandable(This,hNode)	\
    (This)->lpVtbl -> IsExpandable(This,hNode)

#define INodeCallback_GetCopyDataObject(This,hNode,bScope,bMultiSel,cookie,ppDataObject)	\
    (This)->lpVtbl -> GetCopyDataObject(This,hNode,bScope,bMultiSel,cookie,ppDataObject)

#define INodeCallback_Drop(This,hNode,bScope,lCookie,bMove,pDataObject)	\
    (This)->lpVtbl -> Drop(This,hNode,bScope,lCookie,bMove,pDataObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_Initialize_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ IScopeTree __RPC_FAR *pIScopeTree);


void __RPC_STUB INodeCallback_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetImages_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ int __RPC_FAR *iImage,
    int __RPC_FAR *iSelectedImage);


void __RPC_STUB INodeCallback_GetImages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetDisplayName_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ LPOLESTR __RPC_FAR *pName);


void __RPC_STUB INodeCallback_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetDispInfo_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ long dispInfo);


void __RPC_STUB INodeCallback_GetDispInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetState_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ UINT __RPC_FAR *pnState);


void __RPC_STUB INodeCallback_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetResultPane_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ LPOLESTR __RPC_FAR *ppszResultPane,
    /* [out] */ long __RPC_FAR *pViewOptions);


void __RPC_STUB INodeCallback_GetResultPane_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetControl_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ CLSID clsid,
    /* [out] */ long __RPC_FAR *plControl);


void __RPC_STUB INodeCallback_GetControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_SetControl_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ CLSID clsid,
    /* [in] */ long lControl,
    /* [in] */ long destroyer,
    /* [in] */ IUnknown __RPC_FAR *pUnknown);


void __RPC_STUB INodeCallback_SetControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_SetItemID_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ UINT nID);


void __RPC_STUB INodeCallback_SetItemID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetItemID_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ UINT __RPC_FAR *pnID);


void __RPC_STUB INodeCallback_GetItemID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetID_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ UINT __RPC_FAR *pnID);


void __RPC_STUB INodeCallback_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetPath_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ UINT __RPC_FAR *pnID,
    /* [out] */ LPTSTR __RPC_FAR *ppszPath,
    /* [out] */ UINT __RPC_FAR *pcch);


void __RPC_STUB INodeCallback_GetPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetStaticParentID_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ UINT __RPC_FAR *pnID);


void __RPC_STUB INodeCallback_GetStaticParentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_Notify_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ NCLBK_NOTIFY_TYPE event,
    /* [in] */ long arg,
    /* [in] */ long param);


void __RPC_STUB INodeCallback_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetMTNode_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ HMTNODE __RPC_FAR *phMTNode);


void __RPC_STUB INodeCallback_GetMTNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetMTNodePath_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ HMTNODE __RPC_FAR *__RPC_FAR *pphMTNode,
    /* [out] */ long __RPC_FAR *plLength);


void __RPC_STUB INodeCallback_GetMTNodePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_IsExpandable_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode);


void __RPC_STUB INodeCallback_IsExpandable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetCopyDataObject_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ BOOL bScope,
    /* [in] */ BOOL bMultiSel,
    /* [in] */ long cookie,
    /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);


void __RPC_STUB INodeCallback_GetCopyDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_Drop_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ BOOL bScope,
    /* [in] */ long lCookie,
    /* [in] */ BOOL bMove,
    /* [in] */ IDataObject __RPC_FAR *pDataObject);


void __RPC_STUB INodeCallback_Drop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INodeCallback_INTERFACE_DEFINED__ */


#ifndef __IControlbarsCache_INTERFACE_DEFINED__
#define __IControlbarsCache_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IControlbarsCache
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IControlbarsCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e9fcd38-b9a0-11d0-a79d-00c04fd8d565")
    IControlbarsCache : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DetachControlbars( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlbarsCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IControlbarsCache __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IControlbarsCache __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IControlbarsCache __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DetachControlbars )( 
            IControlbarsCache __RPC_FAR * This);
        
        END_INTERFACE
    } IControlbarsCacheVtbl;

    interface IControlbarsCache
    {
        CONST_VTBL struct IControlbarsCacheVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlbarsCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IControlbarsCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IControlbarsCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IControlbarsCache_DetachControlbars(This)	\
    (This)->lpVtbl -> DetachControlbars(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbarsCache_DetachControlbars_Proxy( 
    IControlbarsCache __RPC_FAR * This);


void __RPC_STUB IControlbarsCache_DetachControlbars_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IControlbarsCache_INTERFACE_DEFINED__ */


#ifndef __IContextMenuProviderPrivate_INTERFACE_DEFINED__
#define __IContextMenuProviderPrivate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IContextMenuProviderPrivate
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][object][uuid][object] */ 



EXTERN_C const IID IID_IContextMenuProviderPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9275b092-fe48-11d0-a7c9-00c04fd8d565")
    IContextMenuProviderPrivate : public IContextMenuProvider
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMultiSelectExtensionItems( 
            long lMultiSelection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenuProviderPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextMenuProviderPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextMenuProviderPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextMenuProviderPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            IContextMenuProviderPrivate __RPC_FAR * This,
            /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EmptyMenuList )( 
            IContextMenuProviderPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPrimaryExtensionItems )( 
            IContextMenuProviderPrivate __RPC_FAR * This,
            /* [in] */ LPUNKNOWN piExtension,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddThirdPartyExtensionItems )( 
            IContextMenuProviderPrivate __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowContextMenu )( 
            IContextMenuProviderPrivate __RPC_FAR * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ long xPos,
            /* [in] */ long yPos,
            /* [retval][out] */ long __RPC_FAR *plSelected);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMultiSelectExtensionItems )( 
            IContextMenuProviderPrivate __RPC_FAR * This,
            long lMultiSelection);
        
        END_INTERFACE
    } IContextMenuProviderPrivateVtbl;

    interface IContextMenuProviderPrivate
    {
        CONST_VTBL struct IContextMenuProviderPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenuProviderPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextMenuProviderPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextMenuProviderPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextMenuProviderPrivate_AddItem(This,pItem)	\
    (This)->lpVtbl -> AddItem(This,pItem)


#define IContextMenuProviderPrivate_EmptyMenuList(This)	\
    (This)->lpVtbl -> EmptyMenuList(This)

#define IContextMenuProviderPrivate_AddPrimaryExtensionItems(This,piExtension,piDataObject)	\
    (This)->lpVtbl -> AddPrimaryExtensionItems(This,piExtension,piDataObject)

#define IContextMenuProviderPrivate_AddThirdPartyExtensionItems(This,piDataObject)	\
    (This)->lpVtbl -> AddThirdPartyExtensionItems(This,piDataObject)

#define IContextMenuProviderPrivate_ShowContextMenu(This,hwndParent,xPos,yPos,plSelected)	\
    (This)->lpVtbl -> ShowContextMenu(This,hwndParent,xPos,yPos,plSelected)


#define IContextMenuProviderPrivate_AddMultiSelectExtensionItems(This,lMultiSelection)	\
    (This)->lpVtbl -> AddMultiSelectExtensionItems(This,lMultiSelection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProviderPrivate_AddMultiSelectExtensionItems_Proxy( 
    IContextMenuProviderPrivate __RPC_FAR * This,
    long lMultiSelection);


void __RPC_STUB IContextMenuProviderPrivate_AddMultiSelectExtensionItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextMenuProviderPrivate_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0125
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


typedef 
enum _EXTESION_TYPE
    {	EXTESION_NAMESPACE	= 0x1,
	EXTESION_CONTEXTMENU	= 0x2,
	EXTESION_TOOLBAR	= 0x3,
	EXTESION_PROPERTYSHEET	= 0x4
    }	EXTESION_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0125_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0125_v0_0_s_ifspec;

#ifndef __INodeType_INTERFACE_DEFINED__
#define __INodeType_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: INodeType
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_INodeType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B08A8368-967F-11D0-A799-00C04FD8D565")
    INodeType : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNodeTypeID( 
            /* [out] */ GUID __RPC_FAR *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddExtension( 
            /* [in] */ GUID guidSnapIn,
            /* [in] */ EXTESION_TYPE extnType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveExtension( 
            /* [in] */ GUID guidSnapIn,
            /* [in] */ EXTESION_TYPE extnType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumExtensions( 
            /* [in] */ EXTESION_TYPE extnType,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppEnumGUID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INodeTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INodeType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INodeType __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INodeType __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNodeTypeID )( 
            INodeType __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddExtension )( 
            INodeType __RPC_FAR * This,
            /* [in] */ GUID guidSnapIn,
            /* [in] */ EXTESION_TYPE extnType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveExtension )( 
            INodeType __RPC_FAR * This,
            /* [in] */ GUID guidSnapIn,
            /* [in] */ EXTESION_TYPE extnType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumExtensions )( 
            INodeType __RPC_FAR * This,
            /* [in] */ EXTESION_TYPE extnType,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppEnumGUID);
        
        END_INTERFACE
    } INodeTypeVtbl;

    interface INodeType
    {
        CONST_VTBL struct INodeTypeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INodeType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INodeType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INodeType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INodeType_GetNodeTypeID(This,pGUID)	\
    (This)->lpVtbl -> GetNodeTypeID(This,pGUID)

#define INodeType_AddExtension(This,guidSnapIn,extnType)	\
    (This)->lpVtbl -> AddExtension(This,guidSnapIn,extnType)

#define INodeType_RemoveExtension(This,guidSnapIn,extnType)	\
    (This)->lpVtbl -> RemoveExtension(This,guidSnapIn,extnType)

#define INodeType_EnumExtensions(This,extnType,ppEnumGUID)	\
    (This)->lpVtbl -> EnumExtensions(This,extnType,ppEnumGUID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INodeType_GetNodeTypeID_Proxy( 
    INodeType __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pGUID);


void __RPC_STUB INodeType_GetNodeTypeID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeType_AddExtension_Proxy( 
    INodeType __RPC_FAR * This,
    /* [in] */ GUID guidSnapIn,
    /* [in] */ EXTESION_TYPE extnType);


void __RPC_STUB INodeType_AddExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeType_RemoveExtension_Proxy( 
    INodeType __RPC_FAR * This,
    /* [in] */ GUID guidSnapIn,
    /* [in] */ EXTESION_TYPE extnType);


void __RPC_STUB INodeType_RemoveExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeType_EnumExtensions_Proxy( 
    INodeType __RPC_FAR * This,
    /* [in] */ EXTESION_TYPE extnType,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppEnumGUID);


void __RPC_STUB INodeType_EnumExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INodeType_INTERFACE_DEFINED__ */


#ifndef __INodeTypesCache_INTERFACE_DEFINED__
#define __INodeTypesCache_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: INodeTypesCache
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_INodeTypesCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DE40436E-9671-11D0-A799-00C04FD8D565")
    INodeTypesCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateNodeType( 
            /* [in] */ GUID guidNodeType,
            /* [out] */ INodeType __RPC_FAR *__RPC_FAR *ppNodeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteNodeType( 
            /* [in] */ GUID guidNodeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumNodeTypes( 
            /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppEnumNodeTypes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INodeTypesCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INodeTypesCache __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INodeTypesCache __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INodeTypesCache __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNodeType )( 
            INodeTypesCache __RPC_FAR * This,
            /* [in] */ GUID guidNodeType,
            /* [out] */ INodeType __RPC_FAR *__RPC_FAR *ppNodeType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteNodeType )( 
            INodeTypesCache __RPC_FAR * This,
            /* [in] */ GUID guidNodeType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumNodeTypes )( 
            INodeTypesCache __RPC_FAR * This,
            /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppEnumNodeTypes);
        
        END_INTERFACE
    } INodeTypesCacheVtbl;

    interface INodeTypesCache
    {
        CONST_VTBL struct INodeTypesCacheVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INodeTypesCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INodeTypesCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INodeTypesCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INodeTypesCache_CreateNodeType(This,guidNodeType,ppNodeType)	\
    (This)->lpVtbl -> CreateNodeType(This,guidNodeType,ppNodeType)

#define INodeTypesCache_DeleteNodeType(This,guidNodeType)	\
    (This)->lpVtbl -> DeleteNodeType(This,guidNodeType)

#define INodeTypesCache_EnumNodeTypes(This,ppEnumNodeTypes)	\
    (This)->lpVtbl -> EnumNodeTypes(This,ppEnumNodeTypes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INodeTypesCache_CreateNodeType_Proxy( 
    INodeTypesCache __RPC_FAR * This,
    /* [in] */ GUID guidNodeType,
    /* [out] */ INodeType __RPC_FAR *__RPC_FAR *ppNodeType);


void __RPC_STUB INodeTypesCache_CreateNodeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeTypesCache_DeleteNodeType_Proxy( 
    INodeTypesCache __RPC_FAR * This,
    /* [in] */ GUID guidNodeType);


void __RPC_STUB INodeTypesCache_DeleteNodeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeTypesCache_EnumNodeTypes_Proxy( 
    INodeTypesCache __RPC_FAR * This,
    /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppEnumNodeTypes);


void __RPC_STUB INodeTypesCache_EnumNodeTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INodeTypesCache_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0127
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#ifndef _LPENUMGUID_DEFINED
#define _LPENUMGUID_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0127_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0127_v0_0_s_ifspec;

#ifndef __IEnumGUID_INTERFACE_DEFINED__
#define __IEnumGUID_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumGUID
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumGUID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E000-0000-0000-C000-000000000046")
    IEnumGUID : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumGUIDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumGUID __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumGUID __RPC_FAR * This,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumGUIDVtbl;

    interface IEnumGUID
    {
        CONST_VTBL struct IEnumGUIDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumGUID_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumGUID_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumGUID_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumGUID_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumGUID_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumGUID_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumGUID_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumGUID_Next_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumGUID_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Skip_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumGUID_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Reset_Proxy( 
    IEnumGUID __RPC_FAR * This);


void __RPC_STUB IEnumGUID_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Clone_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumGUID_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumGUID_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0128
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0128_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0128_v0_0_s_ifspec;

#ifndef __IEnumNodeTypes_INTERFACE_DEFINED__
#define __IEnumNodeTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumNodeTypes
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumNodeTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ABBD61E6-9686-11D0-A799-00C04FD8D565")
    IEnumNodeTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ INodeType __RPC_FAR *__RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNodeTypesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumNodeTypes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumNodeTypes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumNodeTypes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumNodeTypes __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ INodeType __RPC_FAR *__RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumNodeTypes __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumNodeTypes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumNodeTypes __RPC_FAR * This,
            /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumNodeTypesVtbl;

    interface IEnumNodeTypes
    {
        CONST_VTBL struct IEnumNodeTypesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNodeTypes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumNodeTypes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumNodeTypes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumNodeTypes_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumNodeTypes_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumNodeTypes_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumNodeTypes_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumNodeTypes_Next_Proxy( 
    IEnumNodeTypes __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ INodeType __RPC_FAR *__RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumNodeTypes_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNodeTypes_Skip_Proxy( 
    IEnumNodeTypes __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumNodeTypes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNodeTypes_Reset_Proxy( 
    IEnumNodeTypes __RPC_FAR * This);


void __RPC_STUB IEnumNodeTypes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNodeTypes_Clone_Proxy( 
    IEnumNodeTypes __RPC_FAR * This,
    /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumNodeTypes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumNodeTypes_INTERFACE_DEFINED__ */


#ifndef __IDocConfig_INTERFACE_DEFINED__
#define __IDocConfig_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDocConfig
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IDocConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1E752C2-FD72-11D0-AEF6-00C04FB6DD2C")
    IDocConfig : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenFile( 
            /* [in] */ BSTR bstrFilePath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseFile( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveFile( 
            /* [optional][in] */ BSTR bstrFilePath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableSnapInExtension( 
            /* [in] */ BSTR bstrSnapInCLSID,
            /* [in] */ BSTR bstrExtensionCLSID,
            /* [in] */ VARIANT_BOOL bEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDocConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDocConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDocConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDocConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDocConfig __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDocConfig __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDocConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDocConfig __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenFile )( 
            IDocConfig __RPC_FAR * This,
            /* [in] */ BSTR bstrFilePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseFile )( 
            IDocConfig __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveFile )( 
            IDocConfig __RPC_FAR * This,
            /* [optional][in] */ BSTR bstrFilePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableSnapInExtension )( 
            IDocConfig __RPC_FAR * This,
            /* [in] */ BSTR bstrSnapInCLSID,
            /* [in] */ BSTR bstrExtensionCLSID,
            /* [in] */ VARIANT_BOOL bEnable);
        
        END_INTERFACE
    } IDocConfigVtbl;

    interface IDocConfig
    {
        CONST_VTBL struct IDocConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDocConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDocConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDocConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDocConfig_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDocConfig_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDocConfig_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDocConfig_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDocConfig_OpenFile(This,bstrFilePath)	\
    (This)->lpVtbl -> OpenFile(This,bstrFilePath)

#define IDocConfig_CloseFile(This)	\
    (This)->lpVtbl -> CloseFile(This)

#define IDocConfig_SaveFile(This,bstrFilePath)	\
    (This)->lpVtbl -> SaveFile(This,bstrFilePath)

#define IDocConfig_EnableSnapInExtension(This,bstrSnapInCLSID,bstrExtensionCLSID,bEnable)	\
    (This)->lpVtbl -> EnableSnapInExtension(This,bstrSnapInCLSID,bstrExtensionCLSID,bEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDocConfig_OpenFile_Proxy( 
    IDocConfig __RPC_FAR * This,
    /* [in] */ BSTR bstrFilePath);


void __RPC_STUB IDocConfig_OpenFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDocConfig_CloseFile_Proxy( 
    IDocConfig __RPC_FAR * This);


void __RPC_STUB IDocConfig_CloseFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDocConfig_SaveFile_Proxy( 
    IDocConfig __RPC_FAR * This,
    /* [optional][in] */ BSTR bstrFilePath);


void __RPC_STUB IDocConfig_SaveFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDocConfig_EnableSnapInExtension_Proxy( 
    IDocConfig __RPC_FAR * This,
    /* [in] */ BSTR bstrSnapInCLSID,
    /* [in] */ BSTR bstrExtensionCLSID,
    /* [in] */ VARIANT_BOOL bEnable);


void __RPC_STUB IDocConfig_EnableSnapInExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDocConfig_INTERFACE_DEFINED__ */



#ifndef __NODEMGRLib_LIBRARY_DEFINED__
#define __NODEMGRLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: NODEMGRLib
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_NODEMGRLib;

EXTERN_C const CLSID CLSID_NodeInit;

#ifdef __cplusplus

class DECLSPEC_UUID("43136EB5-D36C-11CF-ADBC-00AA00A80033")
NodeInit;
#endif

EXTERN_C const CLSID CLSID_ScopeTree;

#ifdef __cplusplus

class DECLSPEC_UUID("7F1899DA-62A6-11d0-A2C6-00C04FD909DD")
ScopeTree;
#endif

EXTERN_C const CLSID CLSID_MMCDocConfig;

#ifdef __cplusplus

class DECLSPEC_UUID("F1E752C3-FD72-11D0-AEF6-00C04FB6DD2C")
MMCDocConfig;
#endif
#endif /* __NODEMGRLib_LIBRARY_DEFINED__ */

#ifndef __IPropertySheetProviderPrivate_INTERFACE_DEFINED__
#define __IPropertySheetProviderPrivate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertySheetProviderPrivate
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IPropertySheetProviderPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FEF554F8-A55A-11D0-A7D7-00C04FD909DD")
    IPropertySheetProviderPrivate : public IPropertySheetProvider
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowEx( 
            /* [in] */ long window,
            /* [in] */ int page,
            /* [in] */ BOOL bModalPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePropertySheetEx( 
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ long cookie,
            /* [in] */ LPDATAOBJECT pIDataObject,
            /* [in] */ long lpMasterTreeNode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySheetProviderPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySheetProviderPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySheetProviderPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertySheet )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ long cookie,
            /* [in] */ LPDATAOBJECT pIDataObjectm,
            /* [in] */ DWORD dwOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindPropertySheet )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ long cookie,
            /* [in] */ LPCOMPONENT lpComponent,
            /* [in] */ LPDATAOBJECT lpDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPrimaryPages )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            LPUNKNOWN lpUnknown,
            BOOL bCreateHandle,
            HWND hNotifyWindow,
            BOOL bScopePane);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddExtensionPages )( 
            IPropertySheetProviderPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Show )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ long window,
            /* [in] */ int page);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowEx )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ long window,
            /* [in] */ int page,
            /* [in] */ BOOL bModalPage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertySheetEx )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ long cookie,
            /* [in] */ LPDATAOBJECT pIDataObject,
            /* [in] */ long lpMasterTreeNode);
        
        END_INTERFACE
    } IPropertySheetProviderPrivateVtbl;

    interface IPropertySheetProviderPrivate
    {
        CONST_VTBL struct IPropertySheetProviderPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySheetProviderPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySheetProviderPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySheetProviderPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySheetProviderPrivate_CreatePropertySheet(This,title,type,cookie,pIDataObjectm,dwOptions)	\
    (This)->lpVtbl -> CreatePropertySheet(This,title,type,cookie,pIDataObjectm,dwOptions)

#define IPropertySheetProviderPrivate_FindPropertySheet(This,cookie,lpComponent,lpDataObject)	\
    (This)->lpVtbl -> FindPropertySheet(This,cookie,lpComponent,lpDataObject)

#define IPropertySheetProviderPrivate_AddPrimaryPages(This,lpUnknown,bCreateHandle,hNotifyWindow,bScopePane)	\
    (This)->lpVtbl -> AddPrimaryPages(This,lpUnknown,bCreateHandle,hNotifyWindow,bScopePane)

#define IPropertySheetProviderPrivate_AddExtensionPages(This)	\
    (This)->lpVtbl -> AddExtensionPages(This)

#define IPropertySheetProviderPrivate_Show(This,window,page)	\
    (This)->lpVtbl -> Show(This,window,page)


#define IPropertySheetProviderPrivate_ShowEx(This,window,page,bModalPage)	\
    (This)->lpVtbl -> ShowEx(This,window,page,bModalPage)

#define IPropertySheetProviderPrivate_CreatePropertySheetEx(This,title,type,cookie,pIDataObject,lpMasterTreeNode)	\
    (This)->lpVtbl -> CreatePropertySheetEx(This,title,type,cookie,pIDataObject,lpMasterTreeNode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertySheetProviderPrivate_ShowEx_Proxy( 
    IPropertySheetProviderPrivate __RPC_FAR * This,
    /* [in] */ long window,
    /* [in] */ int page,
    /* [in] */ BOOL bModalPage);


void __RPC_STUB IPropertySheetProviderPrivate_ShowEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySheetProviderPrivate_CreatePropertySheetEx_Proxy( 
    IPropertySheetProviderPrivate __RPC_FAR * This,
    /* [in] */ LPCWSTR title,
    /* [in] */ boolean type,
    /* [in] */ long cookie,
    /* [in] */ LPDATAOBJECT pIDataObject,
    /* [in] */ long lpMasterTreeNode);


void __RPC_STUB IPropertySheetProviderPrivate_CreatePropertySheetEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySheetProviderPrivate_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0132
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


typedef long CCLVItemID;

#define	CCLV_HEADERPAD	( 15 )



extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0132_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0132_v0_0_s_ifspec;

#ifndef __IMMCListView_INTERFACE_DEFINED__
#define __IMMCListView_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMMCListView
 * at Sat Aug 09 00:03:49 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IMMCListView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1B3C1392-D68B-11CF-8C2B-00AA003CA9F6")
    IMMCListView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetListStyle( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetListStyle( 
            /* [in] */ long nNewValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertItem( 
            /* [in] */ LPOLESTR str,
            /* [in] */ long iconNdx,
            /* [in] */ long lParam,
            /* [in] */ long state,
            /* [in] */ long ownerID,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindItemByString( 
            /* [in] */ LPOLESTR str,
            /* [in] */ long nCol,
            /* [in] */ long occurrence,
            /* [in] */ long ownerID,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindItemByLParam( 
            /* [in] */ long owner,
            /* [in] */ long lParam,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertColumn( 
            /* [in] */ long nCol,
            /* [in] */ LPCOLESTR str,
            /* [in] */ long nFormat,
            /* [in] */ long width) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteColumn( 
            /* [in] */ long subIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindColumnByString( 
            /* [in] */ LPOLESTR str,
            /* [in] */ long occurrence,
            /* [out] */ long __RPC_FAR *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAllItems( 
            /* [in] */ long ownerID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColumn( 
            /* [in] */ long nCol,
            /* [in] */ LPCOLESTR str,
            /* [in] */ long nFormat,
            /* [in] */ long width) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumn( 
            /* [in] */ long nCol,
            /* [out] */ LPOLESTR __RPC_FAR *str,
            /* [out] */ long __RPC_FAR *nFormat,
            /* [out] */ int __RPC_FAR *width) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnCount( 
            /* [out] */ int __RPC_FAR *nColCnt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetItem( 
            /* [in] */ int nIndex,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol,
            /* [in] */ LPOLESTR str,
            /* [in] */ long nImage,
            /* [in] */ long lParam,
            /* [in] */ long nState,
            /* [in] */ long ownerID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ int nIndex,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol,
            /* [out] */ LPOLESTR __RPC_FAR *str,
            /* [out] */ int __RPC_FAR *nImage,
            /* [in] */ long __RPC_FAR *lParam,
            /* [out] */ unsigned int __RPC_FAR *nState,
            /* [in] */ long ownerID,
            /* [out] */ BOOL __RPC_FAR *pbScopeItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextItem( 
            /* [in] */ COMPONENTID ownerID,
            /* [in] */ long nIndex,
            /* [in] */ UINT nState,
            /* [out] */ long __RPC_FAR *plParam,
            /* [out] */ long __RPC_FAR *pnIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLParam( 
            /* [in] */ long nItem,
            /* [out] */ long __RPC_FAR *pLParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModifyItemState( 
            /* [in] */ long nItem,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ UINT add,
            /* [in] */ UINT remove) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIcon( 
            /* [in] */ long nID,
            /* [in] */ long __RPC_FAR *hIcon,
            /* [in] */ long nLoc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetImageStrip( 
            /* [in] */ long nID,
            /* [in] */ long __RPC_FAR *pBMapSm,
            /* [in] */ long __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ long cMask,
            /* [in] */ long nEntries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapImage( 
            /* [in] */ long nID,
            /* [in] */ long nLoc,
            /* [out] */ int __RPC_FAR *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTest( 
            /* [in] */ int nX,
            /* [in] */ int nY,
            /* [in] */ int __RPC_FAR *piItem,
            /* [out] */ UINT __RPC_FAR *flags,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Arrange( 
            /* [in] */ long style) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateItem( 
            /* [in] */ CCLVItemID itemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Sort( 
            /* [in] */ LPARAM lUserParam,
            /* [in] */ long __RPC_FAR *pParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetItemCount( 
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVirtualMode( 
            /* [in] */ BOOL bVirtual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Repaint( 
            /* [in] */ BOOL bErase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMMCListViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMMCListView __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMMCListView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListStyle )( 
            IMMCListView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListStyle )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nNewValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ LPOLESTR str,
            /* [in] */ long iconNdx,
            /* [in] */ long lParam,
            /* [in] */ long state,
            /* [in] */ long ownerID,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItemByString )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ LPOLESTR str,
            /* [in] */ long nCol,
            /* [in] */ long occurrence,
            /* [in] */ long ownerID,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItemByLParam )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long owner,
            /* [in] */ long lParam,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertColumn )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nCol,
            /* [in] */ LPCOLESTR str,
            /* [in] */ long nFormat,
            /* [in] */ long width);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteColumn )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long subIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindColumnByString )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ LPOLESTR str,
            /* [in] */ long occurrence,
            /* [out] */ long __RPC_FAR *pResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllItems )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long ownerID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumn )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nCol,
            /* [in] */ LPCOLESTR str,
            /* [in] */ long nFormat,
            /* [in] */ long width);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumn )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nCol,
            /* [out] */ LPOLESTR __RPC_FAR *str,
            /* [out] */ long __RPC_FAR *nFormat,
            /* [out] */ int __RPC_FAR *width);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnCount )( 
            IMMCListView __RPC_FAR * This,
            /* [out] */ int __RPC_FAR *nColCnt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol,
            /* [in] */ LPOLESTR str,
            /* [in] */ long nImage,
            /* [in] */ long lParam,
            /* [in] */ long nState,
            /* [in] */ long ownerID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol,
            /* [out] */ LPOLESTR __RPC_FAR *str,
            /* [out] */ int __RPC_FAR *nImage,
            /* [in] */ long __RPC_FAR *lParam,
            /* [out] */ unsigned int __RPC_FAR *nState,
            /* [in] */ long ownerID,
            /* [out] */ BOOL __RPC_FAR *pbScopeItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ COMPONENTID ownerID,
            /* [in] */ long nIndex,
            /* [in] */ UINT nState,
            /* [out] */ long __RPC_FAR *plParam,
            /* [out] */ long __RPC_FAR *pnIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLParam )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nItem,
            /* [out] */ long __RPC_FAR *pLParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyItemState )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nItem,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ UINT add,
            /* [in] */ UINT remove);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIcon )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nID,
            /* [in] */ long __RPC_FAR *hIcon,
            /* [in] */ long nLoc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetImageStrip )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nID,
            /* [in] */ long __RPC_FAR *pBMapSm,
            /* [in] */ long __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ long cMask,
            /* [in] */ long nEntries);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapImage )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nID,
            /* [in] */ long nLoc,
            /* [out] */ int __RPC_FAR *pResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IMMCListView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HitTest )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ int nX,
            /* [in] */ int nY,
            /* [in] */ int __RPC_FAR *piItem,
            /* [out] */ UINT __RPC_FAR *flags,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Arrange )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long style);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ CCLVItemID itemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sort )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ LPARAM lUserParam,
            /* [in] */ long __RPC_FAR *pParams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItemCount )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVirtualMode )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ BOOL bVirtual);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Repaint )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ BOOL bErase);
        
        END_INTERFACE
    } IMMCListViewVtbl;

    interface IMMCListView
    {
        CONST_VTBL struct IMMCListViewVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMMCListView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMMCListView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMMCListView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMMCListView_GetListStyle(This)	\
    (This)->lpVtbl -> GetListStyle(This)

#define IMMCListView_SetListStyle(This,nNewValue)	\
    (This)->lpVtbl -> SetListStyle(This,nNewValue)

#define IMMCListView_InsertItem(This,str,iconNdx,lParam,state,ownerID,pItemID)	\
    (This)->lpVtbl -> InsertItem(This,str,iconNdx,lParam,state,ownerID,pItemID)

#define IMMCListView_DeleteItem(This,itemID,nCol)	\
    (This)->lpVtbl -> DeleteItem(This,itemID,nCol)

#define IMMCListView_FindItemByString(This,str,nCol,occurrence,ownerID,pItemID)	\
    (This)->lpVtbl -> FindItemByString(This,str,nCol,occurrence,ownerID,pItemID)

#define IMMCListView_FindItemByLParam(This,owner,lParam,pItemID)	\
    (This)->lpVtbl -> FindItemByLParam(This,owner,lParam,pItemID)

#define IMMCListView_InsertColumn(This,nCol,str,nFormat,width)	\
    (This)->lpVtbl -> InsertColumn(This,nCol,str,nFormat,width)

#define IMMCListView_DeleteColumn(This,subIndex)	\
    (This)->lpVtbl -> DeleteColumn(This,subIndex)

#define IMMCListView_FindColumnByString(This,str,occurrence,pResult)	\
    (This)->lpVtbl -> FindColumnByString(This,str,occurrence,pResult)

#define IMMCListView_DeleteAllItems(This,ownerID)	\
    (This)->lpVtbl -> DeleteAllItems(This,ownerID)

#define IMMCListView_SetColumn(This,nCol,str,nFormat,width)	\
    (This)->lpVtbl -> SetColumn(This,nCol,str,nFormat,width)

#define IMMCListView_GetColumn(This,nCol,str,nFormat,width)	\
    (This)->lpVtbl -> GetColumn(This,nCol,str,nFormat,width)

#define IMMCListView_GetColumnCount(This,nColCnt)	\
    (This)->lpVtbl -> GetColumnCount(This,nColCnt)

#define IMMCListView_SetItem(This,nIndex,itemID,nCol,str,nImage,lParam,nState,ownerID)	\
    (This)->lpVtbl -> SetItem(This,nIndex,itemID,nCol,str,nImage,lParam,nState,ownerID)

#define IMMCListView_GetItem(This,nIndex,itemID,nCol,str,nImage,lParam,nState,ownerID,pbScopeItem)	\
    (This)->lpVtbl -> GetItem(This,nIndex,itemID,nCol,str,nImage,lParam,nState,ownerID,pbScopeItem)

#define IMMCListView_GetNextItem(This,ownerID,nIndex,nState,plParam,pnIndex)	\
    (This)->lpVtbl -> GetNextItem(This,ownerID,nIndex,nState,plParam,pnIndex)

#define IMMCListView_GetLParam(This,nItem,pLParam)	\
    (This)->lpVtbl -> GetLParam(This,nItem,pLParam)

#define IMMCListView_ModifyItemState(This,nItem,itemID,add,remove)	\
    (This)->lpVtbl -> ModifyItemState(This,nItem,itemID,add,remove)

#define IMMCListView_SetIcon(This,nID,hIcon,nLoc)	\
    (This)->lpVtbl -> SetIcon(This,nID,hIcon,nLoc)

#define IMMCListView_SetImageStrip(This,nID,pBMapSm,pBMapLg,nStartLoc,cMask,nEntries)	\
    (This)->lpVtbl -> SetImageStrip(This,nID,pBMapSm,pBMapLg,nStartLoc,cMask,nEntries)

#define IMMCListView_MapImage(This,nID,nLoc,pResult)	\
    (This)->lpVtbl -> MapImage(This,nID,nLoc,pResult)

#define IMMCListView_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMMCListView_HitTest(This,nX,nY,piItem,flags,pItemID)	\
    (This)->lpVtbl -> HitTest(This,nX,nY,piItem,flags,pItemID)

#define IMMCListView_Arrange(This,style)	\
    (This)->lpVtbl -> Arrange(This,style)

#define IMMCListView_UpdateItem(This,itemID)	\
    (This)->lpVtbl -> UpdateItem(This,itemID)

#define IMMCListView_Sort(This,lUserParam,pParams)	\
    (This)->lpVtbl -> Sort(This,lUserParam,pParams)

#define IMMCListView_SetItemCount(This,nItemCount,dwOptions)	\
    (This)->lpVtbl -> SetItemCount(This,nItemCount,dwOptions)

#define IMMCListView_SetVirtualMode(This,bVirtual)	\
    (This)->lpVtbl -> SetVirtualMode(This,bVirtual)

#define IMMCListView_Repaint(This,bErase)	\
    (This)->lpVtbl -> Repaint(This,bErase)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMMCListView_GetListStyle_Proxy( 
    IMMCListView __RPC_FAR * This);


void __RPC_STUB IMMCListView_GetListStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetListStyle_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nNewValue);


void __RPC_STUB IMMCListView_SetListStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_InsertItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ LPOLESTR str,
    /* [in] */ long iconNdx,
    /* [in] */ long lParam,
    /* [in] */ long state,
    /* [in] */ long ownerID,
    /* [out] */ CCLVItemID __RPC_FAR *pItemID);


void __RPC_STUB IMMCListView_InsertItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_DeleteItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ CCLVItemID itemID,
    /* [in] */ long nCol);


void __RPC_STUB IMMCListView_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_FindItemByString_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ LPOLESTR str,
    /* [in] */ long nCol,
    /* [in] */ long occurrence,
    /* [in] */ long ownerID,
    /* [out] */ CCLVItemID __RPC_FAR *pItemID);


void __RPC_STUB IMMCListView_FindItemByString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_FindItemByLParam_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long owner,
    /* [in] */ long lParam,
    /* [out] */ CCLVItemID __RPC_FAR *pItemID);


void __RPC_STUB IMMCListView_FindItemByLParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_InsertColumn_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nCol,
    /* [in] */ LPCOLESTR str,
    /* [in] */ long nFormat,
    /* [in] */ long width);


void __RPC_STUB IMMCListView_InsertColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_DeleteColumn_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long subIndex);


void __RPC_STUB IMMCListView_DeleteColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_FindColumnByString_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ LPOLESTR str,
    /* [in] */ long occurrence,
    /* [out] */ long __RPC_FAR *pResult);


void __RPC_STUB IMMCListView_FindColumnByString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_DeleteAllItems_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long ownerID);


void __RPC_STUB IMMCListView_DeleteAllItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetColumn_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nCol,
    /* [in] */ LPCOLESTR str,
    /* [in] */ long nFormat,
    /* [in] */ long width);


void __RPC_STUB IMMCListView_SetColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetColumn_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nCol,
    /* [out] */ LPOLESTR __RPC_FAR *str,
    /* [out] */ long __RPC_FAR *nFormat,
    /* [out] */ int __RPC_FAR *width);


void __RPC_STUB IMMCListView_GetColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetColumnCount_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [out] */ int __RPC_FAR *nColCnt);


void __RPC_STUB IMMCListView_GetColumnCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ CCLVItemID itemID,
    /* [in] */ long nCol,
    /* [in] */ LPOLESTR str,
    /* [in] */ long nImage,
    /* [in] */ long lParam,
    /* [in] */ long nState,
    /* [in] */ long ownerID);


void __RPC_STUB IMMCListView_SetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ CCLVItemID itemID,
    /* [in] */ long nCol,
    /* [out] */ LPOLESTR __RPC_FAR *str,
    /* [out] */ int __RPC_FAR *nImage,
    /* [in] */ long __RPC_FAR *lParam,
    /* [out] */ unsigned int __RPC_FAR *nState,
    /* [in] */ long ownerID,
    /* [out] */ BOOL __RPC_FAR *pbScopeItem);


void __RPC_STUB IMMCListView_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetNextItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ COMPONENTID ownerID,
    /* [in] */ long nIndex,
    /* [in] */ UINT nState,
    /* [out] */ long __RPC_FAR *plParam,
    /* [out] */ long __RPC_FAR *pnIndex);


void __RPC_STUB IMMCListView_GetNextItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetLParam_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nItem,
    /* [out] */ long __RPC_FAR *pLParam);


void __RPC_STUB IMMCListView_GetLParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_ModifyItemState_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nItem,
    /* [in] */ CCLVItemID itemID,
    /* [in] */ UINT add,
    /* [in] */ UINT remove);


void __RPC_STUB IMMCListView_ModifyItemState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetIcon_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nID,
    /* [in] */ long __RPC_FAR *hIcon,
    /* [in] */ long nLoc);


void __RPC_STUB IMMCListView_SetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetImageStrip_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nID,
    /* [in] */ long __RPC_FAR *pBMapSm,
    /* [in] */ long __RPC_FAR *pBMapLg,
    /* [in] */ long nStartLoc,
    /* [in] */ long cMask,
    /* [in] */ long nEntries);


void __RPC_STUB IMMCListView_SetImageStrip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_MapImage_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nID,
    /* [in] */ long nLoc,
    /* [out] */ int __RPC_FAR *pResult);


void __RPC_STUB IMMCListView_MapImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_Reset_Proxy( 
    IMMCListView __RPC_FAR * This);


void __RPC_STUB IMMCListView_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_HitTest_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ int nX,
    /* [in] */ int nY,
    /* [in] */ int __RPC_FAR *piItem,
    /* [out] */ UINT __RPC_FAR *flags,
    /* [out] */ CCLVItemID __RPC_FAR *pItemID);


void __RPC_STUB IMMCListView_HitTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_Arrange_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long style);


void __RPC_STUB IMMCListView_Arrange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_UpdateItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ CCLVItemID itemID);


void __RPC_STUB IMMCListView_UpdateItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_Sort_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ LPARAM lUserParam,
    /* [in] */ long __RPC_FAR *pParams);


void __RPC_STUB IMMCListView_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetItemCount_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ int nItemCount,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IMMCListView_SetItemCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetVirtualMode_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ BOOL bVirtual);


void __RPC_STUB IMMCListView_SetVirtualMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_Repaint_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ BOOL bErase);


void __RPC_STUB IMMCListView_Repaint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMMCListView_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  HBITMAP_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HBITMAP __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HBITMAP_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HBITMAP __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HBITMAP_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HBITMAP __RPC_FAR * ); 
void                      __RPC_USER  HBITMAP_UserFree(     unsigned long __RPC_FAR *, HBITMAP __RPC_FAR * ); 

unsigned long             __RPC_USER  HICON_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HICON __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HICON __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HICON __RPC_FAR * ); 
void                      __RPC_USER  HICON_UserFree(     unsigned long __RPC_FAR *, HICON __RPC_FAR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\nntp.cpp ===
#include "stdafx.h"
#include <ole2.h>
#undef UNICODE
#include "iadm.h"
#define UNICODE
#include "iiscnfg.h"
#include "mdkey.h"

#include "mdentry.h"

#include "utils.h"

#include "nntptype.h"
#include "nntpapi.h"
#include "userenv.h"
#include "userenvp.h"

GUID 	g_NNTPGuid   = { 0xe2939ef0, 0xaae2, 0x11d0, 0xb0, 0xba, 
						 0x00, 0xaa, 0x00, 0xc1, 0x48, 0xbe };

// MCIS NNTP SnapIn CLSID - {48b6742a-40f9-11d1-801a-00c04fc307bd}
const WCHAR *   wszMCISNntp_SnapIn = _T("{48b6742a-40f9-11d1-801a-00c04fc307bd}");

// K2 NNTP SnapIn CLSID - = {dc147890-91c2-11d0-8966-00aa00a74bf2}
const WCHAR *   wszNt5Nntp_SnapIn = _T("{dc147890-91c2-11d0-8966-00aa00a74bf2}");
const WCHAR *   wszNt5Nntp_SnapInName = _T("NNTP Snapin Extension");

typedef NET_API_STATUS (NET_API_FUNCTION *LPFNNntpCreateNewsgroup)(LPWSTR, DWORD, LPNNTP_NEWSGROUP_INFO);

void CreateNewsgroup(TCHAR *szComputerName, 
					 LPFNNntpCreateNewsgroup lpfnNCN, 
					 TCHAR *szGroupName) 
{
	DWORD dwErr = 0;
	NNTP_NEWSGROUP_INFO NewsgroupInfo;

	ZeroMemory(&NewsgroupInfo, sizeof(NewsgroupInfo));
	NewsgroupInfo.cbNewsgroup = (lstrlen(szGroupName) + 1) * sizeof(WCHAR);
	NewsgroupInfo.Newsgroup = (PUCHAR) szGroupName;

	DWORD rc = (*lpfnNCN)(szComputerName, 1, &NewsgroupInfo);
#ifdef DEBUG
	TCHAR szBuf[1024];

	swprintf(szBuf, _T("CreateNewsgroup returned %lu"), rc);
	DebugOutput(szBuf);
#endif
}

void CreateNNTPGroups(void) {
	TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
	DWORD cb = MAX_COMPUTERNAME_LENGTH;
	LPFNNntpCreateNewsgroup lpfnNCN = NULL;
	HINSTANCE hInst = 0;
	
	do {
		if (!(hInst = LoadLibrary(_T("nntpapi.dll")))) break;
		if (!(lpfnNCN = (LPFNNntpCreateNewsgroup) GetProcAddress(hInst, "NntpCreateNewsgroup"))) break;
		if (!(GetComputerName(szComputerName, &cb))) break;

// the server creates these groups now
#if 0
		CreateNewsgroup(szComputerName, lpfnNCN, _T("control.rmgroup"));
		CreateNewsgroup(szComputerName, lpfnNCN, _T("control.newgroup"));
		CreateNewsgroup(szComputerName, lpfnNCN, _T("control.cancel"));
#endif
		CreateNewsgroup(szComputerName, lpfnNCN, _T("microsoft.public.ins"));

		// post the welcome message
		CString csSrc = theApp.m_csPathInetsrv + _T("\\infomsg.nws");
		CString csDest = theApp.m_csPathNntpFile + _T("\\pickup\\infomsg.nws");
		MoveFileEx(csSrc, csDest, MOVEFILE_COPY_ALLOWED);
	} while (FALSE);

	if (hInst != NULL) FreeLibrary(hInst);
}

INT Register_iis_nntp_nt5(BOOL fUpgrade, BOOL fReinstall)
//
//  fUpgrade == TRUE:
//  1) IM_UPGRADEK2
//  2) IM_UPGRADE10
//  3) IM_UPGRADE20
//  4) IM_UPGRADE - obsolete
//
//  fReinstall == TRUE:
//  minor NT5 OS (between builds) upgrades
//
{
    INT err = NERR_Success;
    CString csBinPath;

    BOOL fSvcExist = FALSE;

    // for minor NT5 os upgrade
    if (fReinstall)
    {
        return err;
    }

    //
    // These are common things need to be done:
    // NT5 - The following code will be executed for either AT_UPGRADE, or AT_FRESH_INSTALL
    // For Component - INS, SubComponent - iis_nntp.
    // AT_UPGRADE = IM_UPGRADE, IM_UPGRADE10, IM_UPGRADEK2, IM_UPGRADE20
    // AT_FRESH_INSTALL = IM_FRESH
    //

    // set up registry values
    CRegKey regMachine = HKEY_LOCAL_MACHINE;

    // System\CurrentControlSet\Services\NNTPSVC\Parameters
    InsertSetupString( (LPCSTR) REG_NNTPPARAMETERS );

    CString csOcxFile;

    // register COM objects
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpadm.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpsnap.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    // NT5 - Enable snapin extension in iis.msc, always use nntpsnap.dll
    // NT5 - and compmgmt.msc
    CString csMMCFile = theApp.m_csPathInetsrv + _T("\\iis.msc");
    EnableSnapInExtension( csMMCFile, wszNt5Nntp_SnapIn, TRUE );
    //csMMCFile = theApp.m_csSysDir + _T("\\compmgmt.msc");
    //EnableSnapInExtension( csMMCFile, wszNt5Nntp_SnapIn, TRUE );
    
#if 0
    //  BINLIN 11/3/98 - fix 75049
    //
    //  For compmgmt snapin extension in NT5, we need to do some trick.
    //
    EnableCompMgmtExtension( wszNt5Nntp_SnapIn, wszNt5Nntp_SnapInName, TRUE );
#endif

#if 0
    csOcxFile = theApp.m_csSysDir + _T("\\inetcomm.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csSysDir + _T("\\mimefilt.dll");
    RegisterOLEControl(csOcxFile, TRUE);
#endif
    csOcxFile = theApp.m_csPathInetsrv + _T("\\seo.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\ddrop.dll");
    RegisterOLEControl(csOcxFile, TRUE);
#if 0				// No longer used    
    csOcxFile = theApp.m_csSysDir + _T("\\imsg.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpfilt.dll");
    RegisterOLEControl(csOcxFile, TRUE);
#endif
    csOcxFile = theApp.m_csPathInetsrv + _T("\\mailmsg.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpfs.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    csOcxFile = theApp.m_csPathInetsrv + _T("\\qryobj.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\qrydb.dll");
    RegisterOLEControl(csOcxFile, TRUE);


    // NT5 - for UPGRADEK2 or UPGRADE20, skip anything after this
    if (theApp.m_eNTOSType == OT_NTS && (theApp.m_eState[SC_NNTP] == IM_UPGRADEK2 || theApp.m_eState[SC_NNTP] == IM_UPGRADE20))
    {
        return err;
    }

	// add the nntpkey.dll to the keyring
    CRegKey regKeyring( _T("Software\\Microsoft\\Keyring\\Parameters\\AddOnServices"), regMachine );
    if ((HKEY) regKeyring) {
		CString csPath = theApp.m_csPathInetsrv + _T("\\nntpkey.dll");
	    regKeyring.SetValue(_T("NNTP"), csPath);
	}

	// if this is an upgrade then we need to remove the nntpcfg.dll key
	CRegKey regInetmgr( _T("Software\\Microsoft\\InetMGR\\Parameters\\AddOnServices"), regMachine);
	if ((HKEY) regInetmgr) {
		regInetmgr.DeleteValue(_T("NNTP"));
	}

    // Create or Config NNTP service
    CString csDisplayName;
    CString csDescription;

    MyLoadString( IDS_NNTPDISPLAYNAME, csDisplayName );
    MyLoadString(IDS_NNTPDESCRIPTION, csDescription);
    csBinPath = theApp.m_csPathInetsrv + _T("\\inetinfo.exe") ;

    err = InetCreateService(SZ_NNTPSERVICENAME, 
						(LPCTSTR)csDisplayName, 
						(LPCTSTR)csBinPath, 
						SERVICE_AUTO_START, 
						SZ_SVC_DEPEND,
						(LPCTSTR)csDescription);
    if ( err != NERR_Success )
    {
        if (err == ERROR_SERVICE_EXISTS)
		{
			fSvcExist = TRUE;
			err = InetConfigService(SZ_NNTPSERVICENAME, 
							(LPCTSTR)csDisplayName, 
							(LPCTSTR)csBinPath, 
							SZ_SVC_DEPEND,
							(LPCTSTR)csDescription);
			if (err != NERR_Success)
			{
				SetErrMsg(_T("NNTP InetConfigService failed"), err);
			}
		}
    }

    BOOL    fIISADMINExists = DetectExistingIISADMIN();

    // NT5 - only set the fUpgrade to TRUE is we are doing MCIS10 to NT5 upgrade
    // to migrate registry key to metabase.
    if (fIISADMINExists)
    {
        MigrateNNTPToMD(theApp.m_hInfHandle[MC_INS], _T("NNTP_REG"), fUpgrade && theApp.m_eState[SC_NNTP] == IM_UPGRADE10);
		SetAdminACL_wrap(_T("LM/NNTPSVC/1"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
    }

    // Create key \System\CurrentControlSet\Services\NntpSvc\Performance:
    // Add the following values:
    // Library = nntpctrs.DLL
    // Open = OpenNNTPPerformanceData
    // Close = CloseNNTPPerformanceData
    // Collect = CollectNNTPPerformanceData
    InstallPerformance(REG_NNTPPERFORMANCE, 
					_T("nntpctrs.DLL"), 
					_T("OpenNntpPerformanceData"),
					_T("CloseNntpPerformanceData"), 
					_T("CollectNntpPerformanceData"));

	//
	// We used to register the NNTP MIB agent here.  Now we unregister it in
	// case we're upgrading since it's no longer supported
	//

	RemoveAgent( SZ_NNTPSERVICENAME );
 
    // Create key \System\CurrentControlSet\Services\EventLog\System\NntpSvc:
    // Add the following values:
    // EventMessageFile = ..\nntpmsg.dll
    // TypesSupported = 7
    csBinPath = theApp.m_csPathInetsrv + _T("\\nntpsvc.dll");
    AddEventLog( SZ_NNTPSERVICENAME, csBinPath, 0x07 );
    if (!fSvcExist) {
        InetRegisterService( theApp.m_csMachineName, 
							SZ_NNTPSERVICENAME, 
							&g_NNTPGuid, 0, 119, TRUE );
    }

    // load counter
    unlodctr( SZ_NNTPSERVICENAME );
    lodctr(_T("nntpctrs.ini"));

	// set SYSTEM\CurrentControlSet\Control\ContentIndex\IsIndexingNNTPSvc to 1
    CRegKey regCIParam( REG_CIPARAMETERS, regMachine );
    if ((HKEY) regCIParam) {
		regCIParam.SetValue(_T("IsIndexingNNTPSvc"), (DWORD) 1);
	}

	// copy the anonpwd from w3svc
    if (fIISADMINExists)
    {
        CMDKey cmdW3SvcKey;
        CMDKey cmdNNTPSvcKey;
	    cmdW3SvcKey.OpenNode(_T("LM/w3svc"));
	    cmdNNTPSvcKey.OpenNode(_T("LM/nntpsvc"));
	    if ((METADATA_HANDLE) cmdW3SvcKey && (METADATA_HANDLE) cmdNNTPSvcKey) {
		    DWORD dwAttr;
		    DWORD dwUType;
		    DWORD dwDType;
		    DWORD cbLen;
		    BYTE pbData[2*(LM20_PWLEN+1)];
		    if (cmdW3SvcKey.GetData(MD_ANONYMOUS_PWD, &dwAttr, &dwUType, &dwDType, 
			    &cbLen, pbData))
		    {
			    cmdNNTPSvcKey.SetData(MD_ANONYMOUS_PWD, dwAttr, dwUType,
				    dwDType, cbLen, pbData);
		    }
		    cmdW3SvcKey.Close();
		    cmdNNTPSvcKey.Close();
	    }
    }

    // create some paths
    CreateLayerDirectory( theApp.m_csPathInetpub );

    CreateLayerDirectory( theApp.m_csPathNntpRoot );
    // set the root directories for NNTP to be everyone full control and let it propergate
    SetEveryoneACL ( theApp.m_csPathNntpRoot, TRUE );

    CreateLayerDirectory( theApp.m_csPathNntpFile );
    SetEveryoneACL ( theApp.m_csPathNntpFile );

    CreateLayerDirectory( theApp.m_csPathNntpFile + "\\pickup" );
    CreateLayerDirectory( theApp.m_csPathNntpFile + "\\failedpickup" );
    CreateLayerDirectory( theApp.m_csPathNntpFile + "\\drop" );
    CreateLayerDirectory( theApp.m_csPathNntpRoot + "\\_temp.files_");

#if 0
    // NT5 - Don't create any shortcuts like K2!!!
    // Create one and only one WebAdmin link under \programs\administrative tools!!!
    //

	// add items to the program group
    //
    // Always use the old K2 way in NT5 when creating internet shortcut
    //
    CreateInternetShortcut( MC_INS, 
                            IDS_PROGITEM_NEWS_WEBADMIN, 
                            IDS_ITEMPATH_NEWS_WEBADMIN,
                            FALSE /* fIsMcis */ );
	CreateInternetShortcut( MC_INS, 
                            IDS_PROGITEM_NEWS_README, 
                            IDS_ITEMPATH_NEWS_README,
                            FALSE /* fIsMcis */ );
#endif

#if 0
    //  fix 299130/299131 - no webadmin link

    //
    //  Create one and only one Webadmin link under \programs\administrative tools!!!
    //
    CreateNt5InternetShortcut( MC_INS, 
                            IDS_PROGITEM_NEWS_WEBADMIN, 
                            IDS_ITEMPATH_NEWS_WEBADMIN);
#endif

    return err;
}

INT Upgrade_iis_nntp_nt5_fromk2(BOOL fFromK2)
//
//  Handle upgrade from K2 and MCIS 2.0
//
{
    INT err = NERR_Success;

	DebugOutput(_T("Upgrading from %s to B3 ..."), (fFromK2)? "NT4 K2" : "MCIS 2.0");

    // System\CurrentControlSet\Services\NNTPSVC\Parameters
    InsertSetupString( (LPCSTR) REG_NNTPPARAMETERS );

    CString csOcxFile;

    // register COM objects
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpadm.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpsnap.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    // NT5 - Enable snapin extension in iis.msc, always use nntpsnap.dll
    // NT5 - and compmgmt.msc
    CString csMMCFile = theApp.m_csPathInetsrv + _T("\\iis.msc");
    EnableSnapInExtension( csMMCFile, wszNt5Nntp_SnapIn, TRUE );
    //csMMCFile = theApp.m_csSysDir + _T("\\compmgmt.msc");
    //EnableSnapInExtension( csMMCFile, wszNt5Nntp_SnapIn, TRUE );
    
#if 0
    csOcxFile = theApp.m_csSysDir + _T("\\inetcomm.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csSysDir + _T("\\mimefilt.dll");
    RegisterOLEControl(csOcxFile, TRUE);
#endif
    csOcxFile = theApp.m_csPathInetsrv + _T("\\seo.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\ddrop.dll");
    RegisterOLEControl(csOcxFile, TRUE);
#if 0				// No longer used    
    csOcxFile = theApp.m_csSysDir + _T("\\imsg.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpfilt.dll");
    RegisterOLEControl(csOcxFile, TRUE);
#endif
    csOcxFile = theApp.m_csPathInetsrv + _T("\\mailmsg.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpfs.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    csOcxFile = theApp.m_csPathInetsrv + _T("\\qryobj.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\qrydb.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    BOOL    fIISADMINExists = DetectExistingIISADMIN();

    // For K2 or MCIS 2.0 upgrade, add whatever necessary keys here
    if (fIISADMINExists)
    {
        MigrateNNTPToMD(theApp.m_hInfHandle[MC_INS], _T("NNTP_REG_UPGRADEK2"), FALSE);
		SetAdminACL_wrap(_T("LM/NNTPSVC/1"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
    }

	// remove items from the K2 program groups
    if (fFromK2)
    {
        // upgrade from K2, remove those K2 links
	    RemoveInternetShortcut(MC_INS, IDS_PROGITEM_NEWS_WEBADMIN, FALSE);
	    RemoveInternetShortcut(MC_INS, IDS_PROGITEM_NEWS_README, FALSE);
	    RemoveInternetShortcut(MC_INS, IDS_PROGITEM_NEWS_README_K2, FALSE);
    }
	else
	{
        // upgrade from MCIS 2.0, remove thos MCIS links
		RemoveInternetShortcut(MC_INS,  IDS_PROGITEM_NEWS_WEBADMIN, TRUE);
		RemoveInternetShortcut(MC_INS,  IDS_PROGITEM_MCIS_NEWS_README, TRUE);
		RemoveISMLink();
	}

#if 0
    //  fix 299130/299131 - no webadmin link

    //
    //  Create one and only one Webadmin link under \programs\administrative tools!!!
    //
    CreateNt5InternetShortcut( MC_INS, 
                            IDS_PROGITEM_NEWS_WEBADMIN, 
                            IDS_ITEMPATH_NEWS_WEBADMIN);
#endif

    return err;
}

INT Upgrade_iis_nntp_nt5_fromb2(BOOL fFromB2)
//
//  Handle upgrades from Beta2 -> Beta3, or minor NT5 Beta3 upgrades
//
{
    INT err = NERR_Success;

	DebugOutput(_T("Upgrading from NT5 %s to B3 ..."), (fFromB2)? "B2" : "B3");

    // System\CurrentControlSet\Services\NNTPSVC\Parameters
    InsertSetupString( (LPCSTR) REG_NNTPPARAMETERS );

    CString csOcxFile;

    // register COM objects
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpadm.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpsnap.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    // NT5 - Enable snapin extension in iis.msc, always use nntpsnap.dll
    // NT5 - and compmgmt.msc
    CString csMMCFile = theApp.m_csPathInetsrv + _T("\\iis.msc");
    EnableSnapInExtension( csMMCFile, wszNt5Nntp_SnapIn, TRUE );
    //csMMCFile = theApp.m_csSysDir + _T("\\compmgmt.msc");
    //EnableSnapInExtension( csMMCFile, wszNt5Nntp_SnapIn, TRUE );
    
#if 0
    csOcxFile = theApp.m_csSysDir + _T("\\inetcomm.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csSysDir + _T("\\mimefilt.dll");
    RegisterOLEControl(csOcxFile, TRUE);
#endif
    csOcxFile = theApp.m_csPathInetsrv + _T("\\seo.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\ddrop.dll");
    RegisterOLEControl(csOcxFile, TRUE);
#if 0				// No longer used    
    csOcxFile = theApp.m_csSysDir + _T("\\imsg.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpfilt.dll");
    RegisterOLEControl(csOcxFile, TRUE);
#endif
    csOcxFile = theApp.m_csPathInetsrv + _T("\\mailmsg.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpfs.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    csOcxFile = theApp.m_csPathInetsrv + _T("\\qryobj.dll");
    RegisterOLEControl(csOcxFile, TRUE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\qrydb.dll");
    RegisterOLEControl(csOcxFile, TRUE);

    if (!fFromB2)
    {
        //  If it's just upgrades between B3 bits, don't need to do any metabase operations.
        return err;
    }

    BOOL    fIISADMINExists = DetectExistingIISADMIN();

    // NT5 - only set the fUpgrade to TRUE is we are doing MCIS10 to NT5 upgrade
    // to migrate registry key to metabase.
    if (fIISADMINExists)
    {
        MigrateNNTPToMD(theApp.m_hInfHandle[MC_INS], _T("NNTP_REG_UPGRADEB2"), FALSE);
    }

    return err;
}

INT Unregister_iis_nntp()
{
    CRegKey regMachine = HKEY_LOCAL_MACHINE;

	// Unregister all of the NNTP sources in the SEO binding database
	UnregisterSEOSourcesForNNTP();

	// Unregister the OLE objets
    CString csOcxFile;
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpadm.dll");
    RegisterOLEControl(csOcxFile, FALSE);
   	csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpsnap.dll");
    RegisterOLEControl(csOcxFile, FALSE);
#if 0
// Don't unregiser these three DLL on uninstall
// as they may be needed by SMTP and IMAP
    csOcxFile = theApp.m_csSysDir + _T("\\inetcomm.dll");
    RegisterOLEControl(csOcxFile, FALSE);
    csOcxFile = theApp.m_csSysDir + _T("\\mimefilt.dll");
    RegisterOLEControl(csOcxFile, FALSE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\seo.dll");
    RegisterOLEControl(csOcxFile, FALSE);
#endif
    csOcxFile = theApp.m_csPathInetsrv + _T("\\ddrop.dll");
    RegisterOLEControl(csOcxFile, FALSE);
#if 0
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpfilt.dll");
    RegisterOLEControl(csOcxFile, FALSE);
// can't unregister mailmsg.dll since this will break SMTP
    csOcxFile = theApp.m_csPathInetsrv + _T("\\mailmsg.dll");
    RegisterOLEControl(csOcxFile, FALSE);
#endif
    csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpfs.dll");
    RegisterOLEControl(csOcxFile, FALSE);

    csOcxFile = theApp.m_csPathInetsrv + _T("\\qryobj.dll");
    RegisterOLEControl(csOcxFile, FALSE);
    csOcxFile = theApp.m_csPathInetsrv + _T("\\qrydb.dll");
    RegisterOLEControl(csOcxFile, FALSE);

    if (theApp.m_eNTOSType == OT_NTS)
        RemoveAgent( SZ_NNTPSERVICENAME );
    RemoveEventLog( SZ_NNTPSERVICENAME );
    unlodctr( SZ_NNTPSERVICENAME );
    InetDeleteService(SZ_NNTPSERVICENAME);
    InetRegisterService( theApp.m_csMachineName, 
					SZ_NNTPSERVICENAME, 
					&g_NNTPGuid, 0, 119, FALSE );

    // remove LM/NNTPSVC in the metabase
    if (DetectExistingIISADMIN())
    {
        CMDKey cmdKey;
        cmdKey.OpenNode(_T("LM"));
        if ( (METADATA_HANDLE)cmdKey ) {
            cmdKey.DeleteNode(_T("NNTPSVC"));
            cmdKey.Close();
        }

	    // remove the News key from the w3svc in the metabase
	    cmdKey.OpenNode(_T("LM"));
        if ( (METADATA_HANDLE)cmdKey ) {
            cmdKey.DeleteNode(_T("w3svc/1/root/News"));
            cmdKey.Close();
        }
    }

	// remove items from the K2 program groups
	RemoveInternetShortcut(MC_INS, IDS_PROGITEM_NEWS_WEBADMIN, FALSE);
	RemoveInternetShortcut(MC_INS, IDS_PROGITEM_NEWS_README, FALSE);
	RemoveInternetShortcut(MC_INS, IDS_PROGITEM_NEWS_README_K2, FALSE);
	if (theApp.m_eNTOSType == OT_NTS)
	{
		RemoveInternetShortcut(MC_INS, 
						IDS_PROGITEM_NEWS_WEBADMIN,
						TRUE);
		RemoveInternetShortcut(MC_INS, 
						IDS_PROGITEM_MCIS_NEWS_README,
						TRUE);
		RemoveISMLink();
	}
    //
    //  remove the one and only webadmin link from "administrative tools"
    //
	RemoveNt5InternetShortcut(MC_INS, 
					IDS_PROGITEM_NEWS_WEBADMIN);

    CString csMMCFile = theApp.m_csPathInetsrv + _T("\\iis.msc");
    EnableSnapInExtension( csMMCFile, wszNt5Nntp_SnapIn, FALSE );

#if 0
    //  BINLIN 11/3/98 - fix 75049
    //
    //  Unregister from compmgmt
    //
    EnableCompMgmtExtension( wszNt5Nntp_SnapIn, wszNt5Nntp_SnapInName, FALSE );
#endif

    return (0);
}

// BINLIN: support K2 B2 -> B3 upgrade
// BUGBUG: still need to figure out what to do about new keys added after B2.
INT Upgrade_iis_nntp_from_b2()
{
	INT err = NERR_Success;

	DebugOutput(_T("Upgrading from K2 B2 to B3 ..."));

    do {
        // set up registry values
        CRegKey regMachine = HKEY_LOCAL_MACHINE;

        // System\CurrentControlSet\Services\NNTPSVC\Parameters
        CRegKey regNNTPParam( REG_NNTPPARAMETERS, regMachine );
        if ((HKEY) regNNTPParam )
		{
			regNNTPParam.SetValue( _T("MajorVersion"), (DWORD)STACKSMAJORVERSION );
			regNNTPParam.SetValue( _T("MinorVersion"), (DWORD)STACKSMINORVERSION );
			regNNTPParam.SetValue( _T("InstallPath"), theApp.m_csPathInetsrv );

            if (!theApp.m_fIsMcis)
            {
                regNNTPParam.SetValue( _T("SetupString"), REG_SETUP_STRING );
            }
            else
            {
                regNNTPParam.SetValue( _T("SetupString"), REG_SETUP_STRING_MCIS );
            }
		}

		// Move all the parameters to the instance level.
		// News doesn't need to do this
        // UpdateServiceParameters(SZ_NNTPSERVICENAME);

		// We also need to remap all the metabase IDs as followed:
        // For beta 1 Meta IDs that are in the range (0x11000, 0x13000):
        // New meta ID 	= Old meta ID - (0x11000 - 0xB000)
		// = Old meta ID - 0x6000
        //
        //For beta 1 meta IDs that are in the range (0x13000+): 
        // New meta ID	= Old meta ID - 0x13000 + 0xB000 + 100 (100 decimal is the new offset)
		// = Old meta ID - 0x7F9C
		RemapServiceParameters(SZ_NNTPSERVICENAME, 0x11000, 100, 0xB000);
        RemapServiceParameters(SZ_NNTPSERVICENAME, 0x13000, 1000, 0xB064);

        // Add News metabase keys that are added after K2 B2
        MigrateNNTPToMD(theApp.m_hInfHandle[MC_INS], _T("NNTP_REG_UPGRADEB2"), FALSE);

        CString csOcxFile;

        // register COM objects
        csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpadm.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpsnap.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csSysDir + _T("\\exchmlng.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csSysDir + _T("\\exchcomm.dll");
        RegisterOLEControl(csOcxFile, TRUE);
#if 0
        csOcxFile = theApp.m_csSysDir + _T("\\mimefilt.dll");
        RegisterOLEControl(csOcxFile, TRUE);
#endif
        csOcxFile = theApp.m_csPathInetsrv + _T("\\seo.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csPathInetsrv + _T("\\ddrop.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csSysDir + _T("\\imsg.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpfilt.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csPathInetsrv + _T("\\qryobj.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csPathInetsrv + _T("\\qrydb.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csPathInetsrv + _T("\\nmadmin.dll");
        RegisterOLEControl(csOcxFile, TRUE);

#if 0
		// add items to the program group
		CreateInternetShortcut(MC_INS, 
						IDS_PROGITEM_NEWS_WEBADMIN, 
						IDS_ITEMPATH_NEWS_WEBADMIN,
						theApp.m_fIsMcis);
		CreateInternetShortcut(MC_INS, 
						theApp.m_fIsMcis ? IDS_PROGITEM_MCIS_NEWS_README : IDS_PROGITEM_NEWS_README, 
						IDS_ITEMPATH_NEWS_README,
						theApp.m_fIsMcis);
#endif
    } while ( 0 );

    return err;
}

// Upgrade from B3 to RTM: no reg keys added/deleted during B3 and RTM, simply
// register all the dll's
INT Upgrade_iis_nntp_from_b3()
{
	INT err = NERR_Success;

	DebugOutput(_T("Upgrading from K2 B3 to RTM ..."));

    do {
        // set up registry values
        CRegKey regMachine = HKEY_LOCAL_MACHINE;

        // System\CurrentControlSet\Services\NNTPSVC\Parameters
        CRegKey regNNTPParam( REG_NNTPPARAMETERS, regMachine );
        if ((HKEY) regNNTPParam )
        {
            regNNTPParam.SetValue( _T("MajorVersion"), (DWORD)STACKSMAJORVERSION );
            regNNTPParam.SetValue( _T("MinorVersion"), (DWORD)STACKSMINORVERSION );
            regNNTPParam.SetValue( _T("InstallPath"), theApp.m_csPathInetsrv );

            if (!theApp.m_fIsMcis)
            {
                regNNTPParam.SetValue( _T("SetupString"), REG_SETUP_STRING );
            }
            else
            {
                regNNTPParam.SetValue( _T("SetupString"), REG_SETUP_STRING_MCIS );
            }
        }

        CString csOcxFile;

        // register COM objects
        csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpadm.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpsnap.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csSysDir + _T("\\exchmlng.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csSysDir + _T("\\exchcomm.dll");
        RegisterOLEControl(csOcxFile, TRUE);
#if 0
        csOcxFile = theApp.m_csSysDir + _T("\\mimefilt.dll");
        RegisterOLEControl(csOcxFile, TRUE);
#endif
        csOcxFile = theApp.m_csPathInetsrv + _T("\\seo.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csPathInetsrv + _T("\\ddrop.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csSysDir + _T("\\imsg.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csPathInetsrv + _T("\\nntpfilt.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csPathInetsrv + _T("\\qryobj.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csPathInetsrv + _T("\\qrydb.dll");
        RegisterOLEControl(csOcxFile, TRUE);
        csOcxFile = theApp.m_csPathInetsrv + _T("\\nmadmin.dll");
        RegisterOLEControl(csOcxFile, TRUE);

#if 0
		// add items to the program group
		CreateInternetShortcut(MC_INS, 
						IDS_PROGITEM_NEWS_WEBADMIN, 
						IDS_ITEMPATH_NEWS_WEBADMIN,
						theApp.m_fIsMcis);
		CreateInternetShortcut(MC_INS, 
						theApp.m_fIsMcis ? IDS_PROGITEM_MCIS_NEWS_README : IDS_PROGITEM_NEWS_README, 
						IDS_ITEMPATH_NEWS_README,
						theApp.m_fIsMcis);
#endif
    } while ( 0 );

    return err;
}

void GetNntpFilePathFromMD(CString &csPathNntpFile, CString &csPathNntpRoot)
{
    TCHAR   szXover[] = _T("\\xover.hsh");
    TCHAR   szPathXover[_MAX_PATH];
    TCHAR   szPathNntpRoot[_MAX_PATH];
    TCHAR   szPathNntpFile[_MAX_PATH];

    ZeroMemory( szPathNntpRoot, sizeof(szPathNntpRoot) );
    ZeroMemory( szPathNntpFile, sizeof(szPathNntpFile) );
    ZeroMemory( szPathXover, sizeof(szPathXover) );

    // Called only during K2 Beta2 to Beta3 upgrade,
    // We use the existing nntpfile/nntproot setting,
    //  1/20/99 - BINLIN : Should support K2 to NT5 upgrade as well
    //if (theApp.m_eState[SC_NNTP] == IM_UPGRADEB2)
    {
        CMDKey NntpKey;
        DWORD  dwScratch;
        DWORD  dwType;
        DWORD  dwLength;

        // Get NntpRoot path
        NntpKey.OpenNode(_T("LM/NntpSvc/1/Root"));
        if ( (METADATA_HANDLE)NntpKey ) 
        {
            dwLength = _MAX_PATH;

            if (NntpKey.GetData(3001, &dwScratch, &dwScratch, 
                                &dwType, &dwLength, (LPBYTE)szPathNntpRoot))
            {
                if (dwType == STRING_METADATA)
                {

                    csPathNntpRoot.Empty();
                    lstrcpy( csPathNntpRoot.GetBuffer(512), szPathNntpRoot );
                    csPathNntpRoot.ReleaseBuffer();
                }
            }
        }
        NntpKey.Close();

        // Get NntpFile path from old XOVER path
        NntpKey.OpenNode(_T("LM/NntpSvc/1"));
        if ( (METADATA_HANDLE)NntpKey ) 
        {
            dwLength = _MAX_PATH;

            if (NntpKey.GetData(45161, &dwScratch, &dwScratch, 
                                &dwType, &dwLength, (LPBYTE)szPathXover))
            {
                if (dwType == STRING_METADATA)
                {
                    dwScratch = lstrlen(szXover);
                    dwLength = lstrlen(szPathXover);

                    // If it ends with "\\xover.hsh", then we copy the prefix into csPathNntpFile
                    if ((dwLength > dwScratch) &&
                        !lstrcmpi(szPathXover + (dwLength - dwScratch), szXover))
                    {
                        lstrcpyn( szPathNntpFile, szPathXover, (dwLength - dwScratch + 1));
                    }

                    csPathNntpFile.Empty();
                    lstrcpy( csPathNntpFile.GetBuffer(512), szPathNntpFile );
                    csPathNntpFile.ReleaseBuffer();
                }
            }
        }
        NntpKey.Close();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\netlogon.cpp ===
/*
 *	netlogon.cpp
 *
 *	Copyright (c) 1993-1998 Microsoft Corporation
 *
 *	Purpose:	This file contains the declaration of
 *				miscellanous classes and functions of the BASE
 *				subsystem. Copied from the Exchange setup program
 *
 *	Owner:		pierrec
 */

#include "stdafx.h"

// This is for the SEC_I_* definitions: \exdev\ntx\inc
#include "issperr.h"

//		global variables

//This next piece was provided by the NT team, so I left the header intact.  I have
//modified it to not deal with the token at all, since we don't need it.
//Also modified to conform closer to our coding style and memory handling.
//If there is a failure, it is up to the caller to call GetLastError.

/*++

Copyright (c) 1995, 1996  Scott A. Field

Module Name:

    logon.c

Abstract:

	This module implements the network logon type by interfacing
	with the NT Lan Man Security Support Provider (NTLMSSP).

	If the logon succeds via the provided credentials, we duplicate
	the resultant Impersonation token to a Primary level token.
	This allows the result to be used in a call to CreateProcessAsUser

Author:

	Scott Field (sfield)	09-Jun-96

Revision History:

--*/

#define SECURITY_WIN32

#define NTLMSP_NAME     TEXT("NTLM")

extern "C"
{
#include <rpc.h>
#include <sspi.h>
}

BOOL NetLogonUser(LPTSTR UserName, LPTSTR DomainName, LPTSTR Password)
{
	SECURITY_STATUS			SecStatus;
	CredHandle				CredentialHandle1;
	CredHandle				CredentialHandle2;
	CtxtHandle				ClientContextHandle;
	CtxtHandle				ServerContextHandle;
	ULONG					ContextAttributes;
	ULONG					PackageCount;
	ULONG					PackageIndex;
	PSecPkgInfo				PackageInfo;
	DWORD					cbMaxToken	= 0;
	TimeStamp				Lifetime;
	SEC_WINNT_AUTH_IDENTITY	AuthIdentity;
	SecBufferDesc			NegotiateDesc;
	SecBuffer				NegotiateBuffer;
	SecBufferDesc			ChallengeDesc;
	SecBuffer				ChallengeBuffer;
	SecBufferDesc			AuthenticateDesc;
	SecBuffer				AuthenticateBuffer;
	BOOL					bSuccess = FALSE ; // assume this function will fail

	//only domain name can be null
    ZeroMemory( &CredentialHandle1, sizeof(CredHandle) );
    ZeroMemory( &CredentialHandle2, sizeof(CredHandle) );
    ZeroMemory( &ClientContextHandle, sizeof(CtxtHandle) );
    ZeroMemory( &ServerContextHandle, sizeof(CtxtHandle) );
   
    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

//
// << this section could be cached in a repeat caller scenario >>
//

    //
    // Get info about the security packages.
    //

    if(EnumerateSecurityPackages(
    	&PackageCount,
    	&PackageInfo
    	) != NO_ERROR) return FALSE;

	//
	// loop through the packages looking for NTLM
	//

	for(PackageIndex = 0 ; PackageIndex < PackageCount ; PackageIndex++ ) {
		if(PackageInfo[PackageIndex].Name != NULL) {
			if(lstrcmpi(PackageInfo[PackageIndex].Name, NTLMSP_NAME) == 0) {
				cbMaxToken = PackageInfo[PackageIndex].cbMaxToken;
				bSuccess = TRUE;
				break;
			}
		}
	}

	FreeContextBuffer( PackageInfo );

	if(!bSuccess) return FALSE;

	bSuccess = FALSE; // reset to assume failure

//
// << end of cached section >>
//

    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTLMSP_NAME,    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle1,
                    &Lifetime
                    );

	if ( SecStatus != NO_ERROR ) {
		goto Cleanup;
    }


    //
    // Acquire a credential handle for the client side
    //

    ZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );

    if ( DomainName != NULL ) {
        AuthIdentity.Domain = DomainName;
        AuthIdentity.DomainLength = lstrlen(DomainName);
    }

    AuthIdentity.User = UserName;
    AuthIdentity.UserLength = lstrlen(UserName);

    AuthIdentity.Password = Password;
    AuthIdentity.PasswordLength = lstrlen(Password);

#ifdef UNICODE
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
#else
	AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
#endif

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTLMSP_NAME,    // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    (DomainName == NULL && UserName == NULL && Password == NULL) ?
                        NULL : &AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime
                    );

	if ( SecStatus != NO_ERROR ) {
		goto Cleanup;
    }

    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );

    if ( NegotiateBuffer.pvBuffer == NULL ) {
		goto Cleanup;
    }

    SecStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,                       // No Client context yet
                    NULL,						// target name
                    ISC_REQ_SEQUENCE_DETECT,
                    0,                          // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                       // No initial input token
                    0,                          // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime
                    );

    if (( SecStatus != NO_ERROR ) &&
    	( SecStatus != SEC_I_COMPLETE_NEEDED) &&
    	( SecStatus != SEC_I_COMPLETE_AND_CONTINUE) &&
    	( SecStatus != SEC_I_CONTINUE_NEEDED)) {
		goto Cleanup;
    }

    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );

    if ( ChallengeBuffer.pvBuffer == NULL ) {
		goto Cleanup;
    }

    SecStatus = AcceptSecurityContext(
                    &CredentialHandle1,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ISC_REQ_SEQUENCE_DETECT,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime
                    );

    if (( SecStatus != NO_ERROR ) &&
    	( SecStatus != SEC_I_COMPLETE_NEEDED) &&
    	( SecStatus != SEC_I_COMPLETE_AND_CONTINUE) &&
    	( SecStatus != SEC_I_CONTINUE_NEEDED)) {
		goto Cleanup;
    }

    //
    // Get the AuthenticateMessage (ClientSide)
    //

    ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
    AuthenticateDesc.ulVersion = 0;
    AuthenticateDesc.cBuffers = 1;
    AuthenticateDesc.pBuffers = &AuthenticateBuffer;

    AuthenticateBuffer.cbBuffer = cbMaxToken;
    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
    AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );

    if ( AuthenticateBuffer.pvBuffer == NULL ) {
		goto Cleanup;
    }

    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    NULL,					// target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    &ChallengeDesc,
                    0,                      // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime
                    );

    if (( SecStatus != NO_ERROR ) &&
    	( SecStatus != SEC_I_COMPLETE_NEEDED) &&
    	( SecStatus != SEC_I_COMPLETE_AND_CONTINUE) &&
    	( SecStatus != SEC_I_CONTINUE_NEEDED)) {
		goto Cleanup;
    }

    //
    // Finally authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime
                    );

    if (( SecStatus != NO_ERROR ) &&
    	( SecStatus != SEC_I_COMPLETE_NEEDED) &&
    	( SecStatus != SEC_I_COMPLETE_AND_CONTINUE) &&
    	( SecStatus != SEC_I_CONTINUE_NEEDED)) {
		goto Cleanup;
    }

    //
    // check that RPC can reauthenticate
    //

    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;

    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    NULL,					// target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,                      // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime
                    );

    if (( SecStatus != NO_ERROR ) &&
    	( SecStatus != SEC_I_COMPLETE_NEEDED) &&
    	( SecStatus != SEC_I_COMPLETE_AND_CONTINUE) &&
    	( SecStatus != SEC_I_CONTINUE_NEEDED)) {
		goto Cleanup;
    }

    //
    // Now try to re-authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime
                    );


    if (( SecStatus != NO_ERROR ) &&
    	( SecStatus != SEC_I_COMPLETE_NEEDED) &&
    	( SecStatus != SEC_I_COMPLETE_AND_CONTINUE) &&
    	( SecStatus != SEC_I_CONTINUE_NEEDED)) {
		goto Cleanup;
    }

    //
    // Impersonate the client (ServerSide)
    //

    if(ImpersonateSecurityContext( &ServerContextHandle ) != NO_ERROR)
    	goto Cleanup;

	bSuccess = TRUE;

	//
	// we waited until now to Revert back to ourselves to insure
	// the target user has access to their own token, because the
	// security attributes were inherited in the DuplicateTokenEx
	// call above.
	//

    RevertSecurityContext( &ServerContextHandle );

Cleanup:

    //
    // Delete context
    //

    DeleteSecurityContext( &ClientContextHandle );
    DeleteSecurityContext( &ServerContextHandle );

    //
    // Free credential handles
    //

    FreeCredentialsHandle( &CredentialHandle1 );
	FreeCredentialsHandle( &CredentialHandle2 );

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        LocalFree( AuthenticateBuffer.pvBuffer );
    }

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\regctrl.h ===
#ifndef _REGCTRL_H_
#define _REGCTRL_H_

//
// This function registers an OLE control
//
DWORD RegisterOLEControl(LPCTSTR lpszOcxFile, BOOL fAction);

//
// This function registers all OLE controls from a given INF section
// Note the filenames may contain environment strings. Make sure you
// set them before calling this function
//
DWORD RegisterOLEControlsFromInfSection(HINF hFile, LPCTSTR szSectionName, BOOL fRegister);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\regctrl.cpp ===
#include "stdafx.h"
#include "setupapi.h"
#include "ole2.h"


typedef HRESULT (CALLBACK *HCRET)(void);

//
// This function registers an OLE control
//
DWORD RegisterOLEControl(LPCTSTR lpszOcxFile, BOOL fAction)
{
    HINSTANCE hDll = NULL;
    HCRET hProc = NULL;
	DWORD dwErr = NO_ERROR;

	CoInitialize(NULL);
	if (GetFileAttributes(lpszOcxFile) != 0xFFFFFFFF)
	{
		hDll = LoadLibraryEx(lpszOcxFile, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
		if (hDll) 
		{
			if (fAction)
				hProc = (HCRET)GetProcAddress(hDll, "DllRegisterServer");
			else
				hProc = (HCRET)GetProcAddress(hDll, "DllUnregisterServer");
    
			if (hProc)
				dwErr = (*hProc)();
			else
				dwErr = GetLastError();
    
			FreeLibrary(hDll);
		} 
		else 
		{
			dwErr = GetLastError();
		}
	}
	CoUninitialize();

    return(dwErr);
}


//
// This function registers all OLE controls from a given INF section
//
DWORD RegisterOLEControlsFromInfSection(HINF hFile, LPCTSTR szSectionName, BOOL fRegister)
{
	LPTSTR		szLine;
    DWORD		dwLineLen = 0;
	DWORD		dwRequiredSize;
	DWORD		dwErr = NO_ERROR;
    BOOL		b = TRUE;
	TCHAR		szPath[MAX_PATH];

    INFCONTEXT	Context;

    if (!SetupFindFirstLine(hFile, szSectionName, NULL, &Context))
        return(GetLastError());

    if (szLine = (LPTSTR)calloc(1024, sizeof(TCHAR)))
        dwLineLen = 1024;
    else
        return(GetLastError());

    while (b) 
	{
        b = SetupGetLineText(&Context, NULL, NULL, 
							NULL, NULL, 0, &dwRequiredSize);
        if (dwRequiredSize > dwLineLen) 
		{
            free(szLine);
            if (szLine = (LPTSTR)calloc(dwRequiredSize, sizeof(TCHAR)))
                dwLineLen = dwRequiredSize;
            else
                return(GetLastError());
        }

        if (SetupGetLineText(&Context, NULL, NULL, 
							NULL, szLine, dwRequiredSize, NULL) == FALSE)
		{
			free(szLine);
            return(GetLastError());
		}

		// Expand the line to a fully-qualified path
		if (ExpandEnvironmentStrings(szLine, szPath, MAX_PATH) < MAX_PATH)
		{
			// Call function to register OLE control
			RegisterOLEControl(szPath, fRegister);
		}
		else
		{
			dwErr = ERROR_MORE_DATA;
			break;
		}

        b = SetupFindNextLine(&Context, &Context);
    }

    if (szLine)
        free(szLine);

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\offline.cpp ===
#include "stdafx.h"
#include <clusapi.h>
#include <resapi.h>

#define INITIAL_RESOURCE_NAME_SIZE 256 // In characters not in bytes
#define IIS_RESOURCE_TYPE_NAME L"IIS Server Instance"
#define SMTP_RESOURCE_TYPE_NAME L"SMTP Server Instance"
#define NNTP_RESOURCE_TYPE_NAME L"NNTP Server Instance"

#define MAX_OFFLINE_RETRIES 5 // Number of times to try and take a resources offline before giving up 
#define DELAY_BETWEEN_CALLS_TO_OFFLINE 1000*2 // in milliseconds

DWORD BringALLIISClusterResourcesOffline(void);

#ifdef UNIT_TEST
int main()
{
	DWORD dwResult = ERROR_SUCCESS;

	dwResult = BringALLIISClusterResourcesOffline();

	return dwResult;
}
#endif

/****************************************************
*
* Known "problem": If a resource doesn't come offline after the five
* retries than the function continues to try to take the other iis resources
* offline but there is no error reported. You could change this pretty simply I think.
*
*****************************************************/
DWORD BringALLIISClusterResourcesOffline(void)
{
	//
	// The return code
	//
	DWORD dwError = ERROR_SUCCESS;
	
	//
	// Handle for the cluster
	//
	HCLUSTER hCluster = NULL;

	//
	// Handle for the cluster enumerator
	//
	HCLUSENUM hClusResEnum = NULL;

	//
	// Handle to a resource
	// 
	HRESOURCE hResource = NULL;

	//
	// The index of the resources we're taking offline
	//
	DWORD dwResourceIndex = 0;

	//
	// The type cluster object being enumerated returned by the ClusterEnum function
	//
	DWORD dwObjectType = 0;

	//
	// The name of the cluster resource returned by the ClusterEnum function
	//
	LPWSTR lpwszResourceName = NULL;
	
	//
	// The return code from the call to ClusterEnum
	//
	DWORD dwResultClusterEnum = ERROR_SUCCESS;

	//
	// The size of the buffer (in characters) that is used to hold the resource name's length
	//	
	DWORD dwResourceNameBufferLength = INITIAL_RESOURCE_NAME_SIZE;

	//
	// Size of the resource name passed to and returned by the ClusterEnum function
	//	
	DWORD dwClusterEnumResourceNameLength = dwResourceNameBufferLength;


	//
	// Open the cluster
	//
	if ( !(hCluster = OpenCluster(NULL)) )
	{
		dwError = GetLastError();
		goto clean_up;
	}

	//
	// Get Enumerator for the cluster resouces
	// 
	if ( !(hClusResEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE )) )
	{
		dwError = GetLastError();
		goto clean_up;	
	}
	
	//
	// Enumerate the Resources in the cluster
	// 
	
	//
	// Allocate memory to hold the cluster resource name as we enumerate the resources
	//
	if ( !(lpwszResourceName = (LPWSTR) LocalAlloc(LPTR, dwResourceNameBufferLength * sizeof(WCHAR))) )
	{
		dwError = GetLastError();
		goto clean_up;
	}

	// 
	// Enumerate all of the resources in the cluster and take the IIS Server Instance's offline
	//
	while( ERROR_NO_MORE_ITEMS  != 
	       (dwResultClusterEnum = ClusterEnum(hClusResEnum,
			              dwResourceIndex, 
				      &dwObjectType, 
				      lpwszResourceName,
				      &dwClusterEnumResourceNameLength )) )
	{		
		//
		// If we have a resource's name
		//
		if( ERROR_SUCCESS == dwResultClusterEnum )
		{

			if ( !(hResource = OpenClusterResource( hCluster, lpwszResourceName )) )
			{
				dwError = GetLastError();
				break;
			}

			//
			// If the resource type is "IIS Server Instance",
			// "SMTP Server Instance" or "NNTP Server Instance" then delete it
			//
			if ( ResUtilResourceTypesEqual(IIS_RESOURCE_TYPE_NAME, hResource) || 
                ResUtilResourceTypesEqual(SMTP_RESOURCE_TYPE_NAME, hResource) || 
                ResUtilResourceTypesEqual(NNTP_RESOURCE_TYPE_NAME, hResource) )
			{

				//
				// If the resource doesn't come offline quickly then wait 
				//
				if ( ERROR_IO_PENDING == OfflineClusterResource( hResource ) )
				{
					for(int iRetry=0; iRetry < MAX_OFFLINE_RETRIES; iRetry++)
					{
						Sleep( DELAY_BETWEEN_CALLS_TO_OFFLINE );

						if ( ERROR_SUCCESS == OfflineClusterResource( hResource ) )
						{
							break;
						}
					}	
				}
			}

			CloseClusterResource( hResource );
			
			dwResourceIndex++;
		}
			
		//
		// If the buffer wasn't large enough then retry with a larger buffer
		//
		if( ERROR_MORE_DATA == dwResultClusterEnum )
		{
			//
			// Set the buffer size to the required size reallocate the buffer
			//
			LPWSTR lpwszResourceNameTmp = lpwszResourceName;

			//
			// After returning from ClusterEnum dwClusterEnumResourceNameLength 
			// doesn't include the null terminator character
			//
			dwResourceNameBufferLength = dwClusterEnumResourceNameLength + 1;

			if ( !(lpwszResourceName = 
			      (LPWSTR) LocalReAlloc (lpwszResourceName, dwResourceNameBufferLength * sizeof(WCHAR), 0)) )
			{
				dwError = GetLastError();

				LocalFree( lpwszResourceNameTmp );	
				lpwszResourceNameTmp = NULL;
				break;
			}
		}

		//
		// Reset dwResourceNameLength with the size of the number of characters in the buffer
		// You have to do this because everytime you call ClusterEnum is sets your buffer length 
		// argument to the number of characters in the string it's returning.
		//
		dwClusterEnumResourceNameLength = dwResourceNameBufferLength;
	}	


clean_up:

	if ( lpwszResourceName )
	{
		LocalFree( lpwszResourceName );
		lpwszResourceName = NULL;
	}
	
	if ( hClusResEnum )
	{
		ClusterCloseEnum( hClusResEnum );
		hClusResEnum = NULL;
	}

	if ( hCluster )
	{
		CloseCluster( hCluster );
		hCluster = NULL;
	}
			


	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\registry.cpp ===
#include "stdafx.h"

// open an existing key
CRegKey :: CRegKey ( 
    HKEY hKeyBase, 
    LPCTSTR pchSubKey,
    REGSAM regSam )
    : m_hKey( NULL ),
    m_dwDisposition( 0 ) 
{
    LONG err = ERROR_SUCCESS ;

    if ( pchSubKey ) 
        err = ::RegOpenKeyEx( hKeyBase, pchSubKey, 0, regSam, & m_hKey ) ;
    else
        m_hKey = hKeyBase ;
    
    if ( err != ERROR_SUCCESS ) 
    {
        if (m_hKey)
            ::RegCloseKey(m_hKey);
        m_hKey = NULL ;
    }
}

//  Constructor creating a new key/opening a key if already exist, and set value if specified
CRegKey :: CRegKey ( 
    LPCTSTR lpSubKey,
    HKEY hKeyBase,
    LPCTSTR lpValueName,
    DWORD dwType,
    LPBYTE lpValueData,
    DWORD cbValueData)
    : m_hKey( NULL ),
    m_dwDisposition( 0 ) 
{
    LONG err = ERROR_SUCCESS;

    err = ::RegCreateKeyEx( hKeyBase, lpSubKey, 0, _T(""), REG_OPTION_NON_VOLATILE, 
        KEY_ALL_ACCESS, NULL, & m_hKey, & m_dwDisposition ) ;
    if ( err != ERROR_SUCCESS) { 
        if ( m_hKey ) 
            ::RegCloseKey( m_hKey ) ;
        m_hKey = NULL ;
    } else {
        if (lpValueName)
            ::RegSetValueEx(m_hKey, lpValueName, 0, dwType, (const LPBYTE)lpValueData, cbValueData);
    }
}

CRegKey :: ~ CRegKey ()
{
    if ( m_hKey ) 
        ::RegCloseKey( m_hKey ) ;
}


    //  Prepare to read a value by finding the value's size.
LONG CRegKey :: PrepareValue ( 
    LPCTSTR pchValueName, 
    DWORD * pdwType,
    DWORD * pcbSize,
    BYTE ** ppbData )
{
    LONG err = 0 ;
    
    BYTE chDummy[2] ;
    DWORD cbData = 0 ;

    do
    {
        //  Set the resulting buffer size to 0.
        *pcbSize = 0 ;
        *ppbData = NULL ;

        err = ::RegQueryValueEx( *this, 
                      (TCHAR *) pchValueName, 
                      0, pdwType, 
                      chDummy, & cbData ) ;

        //  The only error we should get here is ERROR_MORE_DATA, but
        //  we may get no error if the value has no data.
        if ( err == 0 ) 
        {
            cbData = sizeof (LONG) ;  //  Just a fudgy number
        }
        else
            if ( err != ERROR_MORE_DATA ) 
                break ;

        //  Allocate a buffer large enough for the data.

        *ppbData = new BYTE [ (*pcbSize = cbData) + sizeof (LONG) ] ;

        if ( *ppbData == NULL ) 
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        //  Now that have a buffer, re-fetch the value.

        err = ::RegQueryValueEx( *this, 
                         (TCHAR *) pchValueName, 
                     0, pdwType, 
                     *ppbData, pcbSize ) ;

    } while ( FALSE ) ;

    if ( err ) 
    {
        delete [] *ppbData ;
    }

    return err ;
}

    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
    //  if data exists but not in correct form to deliver into result object.

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, CString & strResult )
{
    LONG err = 0 ;
    
    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;
   
        if (( dwType != REG_SZ ) && ( dwType != REG_EXPAND_SZ ))
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the data looks like a string
        pabData[cbData] = 0 ;

        //  Catch exceptions trying to assign to the caller's string
        TRY
        {
            strResult = (TCHAR *) pabData ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    } 
    while ( FALSE ) ;

    // Memory leak....
    //if ( err )
    //{
        delete [] pabData ;
    //}
    
    return err ; 
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, CStringList & strList ) 
{
    LONG err = 0 ;
    
    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;
    TCHAR * pbTemp,
         * pbTempLimit ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;
   
        if ( dwType != REG_MULTI_SZ ) 
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the trailing data looks like a string
        pabData[cbData] = 0 ;
        pbTemp = (TCHAR *) pabData ;
        pbTempLimit = & pbTemp[cbData] ;

        //  Catch exceptions trying to build the list
        TRY
        {
            for ( ; pbTemp < pbTempLimit ; )
            {
                strList.AddTail( pbTemp ) ;
                pbTemp += ::_tcslen( pbTemp ) + sizeof(TCHAR) ;
                //pbTemp += ::_tcslen( pbTemp ) + 1 ;
            }
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    } 
    while ( FALSE ) ;

    delete [] pabData ;

    return err ; 
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, DWORD & dwResult ) 
{
    LONG err = 0 ;
    
    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;
   
        if ( dwType != REG_DWORD || cbData != sizeof dwResult ) 
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        dwResult = *((DWORD *) pabData) ;
    } 
    while ( FALSE ) ;

    // Memory leak...
    //if ( err )
    //{
        delete [] pabData ;
    //}
    
    return err ; 
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, CByteArray & abResult )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;
   
        if ( dwType != REG_BINARY ) 
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Catch exceptions trying to grow the result array
        TRY
        {
            abResult.SetSize( cbData ) ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL

        if ( err ) 
            break ;

        //  Move the data to the result array.
        for ( DWORD i = 0 ; i < cbData ; i++ ) 
        {
            abResult[i] = pabData[i] ;
        }
    } 
    while ( FALSE ) ;

    // Memory leak....
    //if ( err )
    //{
        delete [] pabData ;
    //}
    
    return err ; 
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;
   
        if ( dwType != REG_BINARY ) 
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        if ( cbSize < cbData )
        {
            err = ERROR_MORE_DATA;
            break;
        }

        ::memcpy(pvResult, pabData, cbData);
    } 
    while ( FALSE ) ;

    // Memory leak....
    //if ( err )
    //{
        delete [] pabData ;
    //}

    return err ; 
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, LPTSTR szMultiSz, DWORD dwSize )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;
   
        if ( dwType != REG_MULTI_SZ ) 
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        if ( dwSize < cbData )
        {
            err = ERROR_MORE_DATA;
            break;
        }

        ::memcpy(szMultiSz, pabData, cbData);
    } 
    while ( FALSE ) ;

    delete [] pabData ;

    return err ; 
}

//  Overloaded value setting members.
LONG CRegKey :: SetValue ( LPCTSTR pchValueName, LPCTSTR szResult, BOOL fExpand )
{
    LONG err = 0;
    
    err = ::RegSetValueEx( *this, 
                    pchValueName,
                    0,
                    fExpand ? REG_EXPAND_SZ : REG_SZ,
                    (const BYTE *) szResult,
                    (_tcsclen(szResult) + 1) * sizeof(_TCHAR) ) ;

    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, CStringList & strList ) 
{

    LONG err = 0;
    
    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue( strList, & cbSize, & pbData ) ;

    if ( err == 0 ) 
    {
        err = ::RegSetValueEx( *this, 
                       pchValueName,
                       0,
                       REG_MULTI_SZ,
                       pbData, 
                       cbSize ) ;
    }

    delete pbData ;

    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, DWORD dwResult )
{
    LONG err = 0;

    err = ::RegSetValueEx( *this, 
                    pchValueName,
                    0,
                    REG_DWORD,
                    (const BYTE *) & dwResult,
                    sizeof dwResult ) ;

    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, CByteArray & abResult )
{

    LONG err = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue( abResult, & cbSize, & pbData ) ;

    if ( err == 0 ) 
    {
        err = ::RegSetValueEx( *this, 
                       pchValueName,
                       0,
                       REG_BINARY,
                       pbData, 
                       cbSize ) ;
    }

    delete pbData ;

    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize )
{

    LONG err = 0;

    err = ::RegSetValueEx( *this, 
                       pchValueName,
                       0,
                       REG_BINARY,
                       (const BYTE *)pvResult, 
                       cbSize ) ;

    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, LPCTSTR szMultiSz, DWORD dwSize )
{

    LONG err = 0;

    err = ::RegSetValueEx( *this, 
                       pchValueName,
                       0,
                       REG_MULTI_SZ,
                       (const BYTE *)szMultiSz, 
                       dwSize ) ;

    return err ;
}

LONG CRegKey::DeleteValue( LPCTSTR pchKeyName )
{
    LONG err = 0;
    err = ::RegDeleteValue( *this, pchKeyName );
    return(err);
}

LONG CRegKey::DeleteTree( LPCTSTR pchKeyName )
{
    LONG err = 0;
    CRegKey regSubKey( *this, pchKeyName );

    if ( NULL != (HKEY) regSubKey )
    {
        CString strName;
        CTime cTime;

        while (TRUE)
        {
            CRegKeyIter regEnum( regSubKey ); 

            if ( regEnum.Next( &strName, &cTime ) != ERROR_SUCCESS )
            {
                break;
            }

            regSubKey.DeleteTree( strName );
        }
        // delete myself
        err = ::RegDeleteKey( *this, pchKeyName );
    }
    return(err);

}

LONG CRegKey :: FlattenValue ( 
    CStringList & strList, 
    DWORD * pcbSize, 
    BYTE ** ppbData )
{

    LONG err = 0 ;

    POSITION pos ;
    CString * pstr ;
    int cbTotal = 0 ;

    //  Walk the list accumulating sizes
    for ( pos = strList.GetHeadPosition() ;
          pos != NULL && (pstr = & strList.GetNext( pos )) ; ) 
    {
        cbTotal += ((pstr->GetLength() + 1)*sizeof(TCHAR));
    }

    //  Allocate and fill a temporary buffer
    if (*pcbSize = cbTotal)
    {
        TRY
        {
            *ppbData = new BYTE[ *pcbSize ] ;

            BYTE * pbData = *ppbData ;

            //  Populate the buffer with the strings.
            for ( pos = strList.GetHeadPosition() ;
                pos != NULL && (pstr = & strList.GetNext( pos )) ; ) 
            {
                int cb = (pstr->GetLength() + 1)*sizeof(TCHAR) ;
                ::memcpy( pbData, (LPCTSTR) *pstr, cb ) ;
                pbData += cb ;
            }
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

    return err ;
}

LONG CRegKey :: FlattenValue ( 
    CByteArray & abData,
    DWORD * pcbSize,
    BYTE ** ppbData )
{
    LONG err = 0 ;
    
    DWORD i ;

    //  Allocate and fill a temporary buffer
    if (*pcbSize = DWORD(abData.GetSize()))
    {
        TRY
        {
            *ppbData = new BYTE[*pcbSize] ;

            for ( i = 0 ; i < *pcbSize ; i++ ) 
            {
                (*ppbData)[i] = abData[i] ;
            }

        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

    return err ;
}


LONG CRegKey :: QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo ) 
{
    LONG err = 0 ;

    pRegKeyInfo->dwClassNameSize = sizeof pRegKeyInfo->chBuff - 1 ;

    err = ::RegQueryInfoKey( *this,
                     pRegKeyInfo->chBuff,
                     & pRegKeyInfo->dwClassNameSize,
                     NULL,
                     & pRegKeyInfo->dwNumSubKeys,
                     & pRegKeyInfo->dwMaxSubKey,
                     & pRegKeyInfo->dwMaxClass,
                     & pRegKeyInfo->dwMaxValues,
                     & pRegKeyInfo->dwMaxValueName,
                     & pRegKeyInfo->dwMaxValueData,
                     & pRegKeyInfo->dwSecDesc,
                     & pRegKeyInfo->ftKey ) ;

    return err ;
}

CRegKeyIter :: CRegKeyIter ( CRegKey & regKey ) 
    : m_rk_iter( regKey ),
    m_p_buffer( NULL ),
    m_cb_buffer( 0 ) 
{
    LONG err = 0 ;

    CRegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 ) 
    {
        TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxSubKey + sizeof (DWORD) ;
            m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

    if ( err ) 
    {
        //ReportError( err ) ;
    }
}

CRegKeyIter :: ~ CRegKeyIter () 
{
    delete [] m_p_buffer ;
}


    // Get the name (and optional last write time) of the next key.
LONG CRegKeyIter :: Next ( CString * pstrName, CTime * pTime ) 
{
    LONG err = 0;

    FILETIME ftDummy ;
    DWORD dwNameSize = m_cb_buffer ;

    err = ::RegEnumKeyEx( m_rk_iter, 
                  m_dw_index, 
              m_p_buffer,
                  & dwNameSize, 
                  NULL,
                  NULL,
                  NULL,
                  & ftDummy ) ;    
    if ( err == 0 ) 
    {
        m_dw_index++ ;

        if ( pTime ) 
        {
            *pTime = ftDummy ;
        }

        TRY
        {
            *pstrName = m_p_buffer ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    
    return err ;
}


CRegValueIter :: CRegValueIter ( CRegKey & regKey ) 
    : m_rk_iter( regKey ),
    m_p_buffer( NULL ),
    m_cb_buffer( 0 ) 
{
    LONG err = 0 ;

    CRegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 ) 
    {
        TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxValueName + sizeof (DWORD) ;
            m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

    if ( err ) 
    {
        //ReportError( err ) ;
    }
    
}

CRegValueIter :: ~ CRegValueIter () 
{
    delete [] m_p_buffer ;
}

LONG CRegValueIter :: Next ( CString * pstrName, DWORD * pdwType )
{
    LONG err = 0 ;
    
    DWORD dwNameLength = m_cb_buffer ;

    err = ::RegEnumValue( m_rk_iter,
                  m_dw_index,
                  m_p_buffer,
                  & dwNameLength,
                  NULL,
                  pdwType,
                  NULL,
                  NULL ) ;
    
    if ( err == 0 ) 
    {
        m_dw_index++ ;

        TRY
    {
        *pstrName = m_p_buffer ;
    }
    CATCH_ALL(e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
    }
    END_CATCH_ALL
    }
    
    return err ;
}

LONG CRegValueIter :: Next ( CString * pstrName, CString * pstrValue )
{
    LONG err = 0 ;
    
    DWORD dwNameLength = m_cb_buffer ;

    TCHAR szValue[_MAX_PATH];
    DWORD dwValue = _MAX_PATH * sizeof(TCHAR);

    err = ::RegEnumValue( m_rk_iter,
                  m_dw_index,
                  m_p_buffer,
                  & dwNameLength,
                  NULL,
                  NULL,
                  (LPBYTE)szValue,
                  &dwValue ) ;
    
    if ( err == 0 ) 
    {
        m_dw_index++ ;

        TRY
        {
            *pstrName = m_p_buffer ;
            *pstrValue = szValue;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    
    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\registry.h ===
#ifndef _REGISTRY_H_
#define _REGISTRY_H_

/****************************************************************************
REGISTRY.H
****************************************************************************/

//  Forward declarations
class CRegKey ;
class CRegValueIter ;
class CRegKeyIter ;

//  Maximum size of a Registry class name
#define CREGKEY_MAX_CLASS_NAME MAX_PATH

//  Wrapper for a Registry key handle.

class CRegKey : public CObject
{
protected:
    HKEY m_hKey ;
    DWORD m_dwDisposition ;

    //  Prepare to read a value by finding the value's size.
    LONG PrepareValue ( LPCTSTR pchValueName,
                        DWORD * pdwType,
                        DWORD * pcbSize,
                        BYTE ** ppbData ) ;

    //  Convert a CStringList to the REG_MULTI_SZ format
    static LONG FlattenValue ( CStringList & strList,
                                DWORD * pcbSize,
                        BYTE ** ppbData ) ;

    //  Convert a CByteArray to a REG_BINARY block
    static LONG FlattenValue ( CByteArray & abData,
                        DWORD * pcbSize,
                        BYTE ** ppbData ) ;

public:
    //  Key information return structure
    typedef struct
    {
        TCHAR chBuff [CREGKEY_MAX_CLASS_NAME] ;
        DWORD dwClassNameSize,
              dwNumSubKeys,
              dwMaxSubKey,
              dwMaxClass,
              dwMaxValues,
              dwMaxValueName,
              dwMaxValueData,
              dwSecDesc ;
        FILETIME ftKey ;
    } CREGKEY_KEY_INFO ;

    //  Standard constructor for an existing key
    CRegKey ( HKEY hKeyBase,
              LPCTSTR pchSubKey = NULL,
              REGSAM regSam = KEY_ALL_ACCESS ) ;

    //  Constructor creating a new key.
    CRegKey ( LPCTSTR lpSubKey,
            HKEY hKeyBase,
            LPCTSTR lpValueName = NULL,
            DWORD dwType = 0,
            LPBYTE lpValueData = NULL,
            DWORD cbValueData = 0);

    ~ CRegKey () ;

    //  Allow a CRegKey to be used anywhere an HKEY is required.
    operator HKEY ()
        { return m_hKey ; }

    //  Fill a key information structure
    LONG QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo ) ;

    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
            //  if data exists but not in correct form to deliver into result object.
    LONG QueryValue ( LPCTSTR pchValueName, CString & strResult ) ;
    LONG QueryValue ( LPCTSTR pchValueName, CStringList & strList ) ;
    LONG QueryValue ( LPCTSTR pchValueName, DWORD & dwResult ) ;
    LONG QueryValue ( LPCTSTR pchValueName, CByteArray & abResult ) ;
    LONG QueryValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize );
	LONG QueryValue ( LPCTSTR pchValueName, LPTSTR szMultiSz, DWORD dwSize );

    //  Overloaded value setting members.
    LONG SetValue ( LPCTSTR pchValueName, LPCTSTR szResult, BOOL fExpand = FALSE ) ;
    LONG SetValue ( LPCTSTR pchValueName, CStringList & strList ) ;
    LONG SetValue ( LPCTSTR pchValueName, DWORD dwResult ) ;
    LONG SetValue ( LPCTSTR pchValueName, CByteArray & abResult ) ;
    LONG SetValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize );
    LONG SetValue ( LPCTSTR pchValueName, LPCTSTR szMultiSz, DWORD dwSize );

    LONG DeleteValue( LPCTSTR pchKeyName );
    LONG DeleteTree( LPCTSTR pchKeyName );
};


    //  Iterate the values of a key, return the name and type
    //  of each.
class CRegValueIter : public CObject
{
protected:
    CRegKey & m_rk_iter ;
    DWORD m_dw_index ;
    TCHAR * m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    CRegValueIter ( CRegKey & regKey ) ;
    ~ CRegValueIter () ;

    // Get the name (and optional last write time) of the next key.
    LONG Next ( CString * pstrName, DWORD * pdwType ) ;
    LONG Next ( CString * pstrName, CString * pstrValue );

    // Reset the iterator
    void Reset ()
        { m_dw_index = 0 ; }
};

    //  Iterate the sub-key names of a key.
class CRegKeyIter : public CObject
{
protected:
    CRegKey & m_rk_iter ;
        DWORD m_dw_index ;
    TCHAR * m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    CRegKeyIter ( CRegKey & regKey ) ;
    ~ CRegKeyIter () ;

    // Get the name (and optional last write time) of the next key.
    LONG Next ( CString * pstrName, CTime * pTime = NULL ) ;

    // Reset the iterator
    void Reset ()
        { m_dw_index = 0 ; }
};

#endif  // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#ifdef _DEBUG
#undef _DEBUG
#endif

#include <tchar.h>
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#undef ASSERT
#include <afxwin.h>
#include <afxext.h>
#include <afxcoll.h>
#include <afxcmn.h>

extern "C"
{
#include <ntsam.h>
#include <ntlsa.h>
#include <lm.h>
#include <lmerr.h>
}

#include "resource.h"
#include "registry.h"
#include "const.h"
#include "initapp.h"
#include "helper.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\runadmin.cpp ===
#include "stdafx.h"

//
// Check whether we are running as administrator on the machine
// or not
//

// Copy it from MSDN
// Windows Articles: Networking Articles, Windows NT Security

BOOL RunningAsAdministrator()
{
#ifdef _CHICAGO_
    return TRUE;
#else
    BOOL   fAdmin;
    HANDLE  hThread;
    TOKEN_GROUPS *ptg = NULL;
    DWORD  cbTokenGroups;
    DWORD  dwGroup;
    PSID   psidAdmin;
    
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;
    
    // First we must open a handle to the access token for this thread.
    
    if ( !OpenThreadToken ( GetCurrentThread(), TOKEN_QUERY, FALSE, &hThread))
    {
        if ( GetLastError() == ERROR_NO_TOKEN)
        {
            // If the thread does not have an access token, we'll examine the
            // access token associated with the process.
            
            if (! OpenProcessToken ( GetCurrentProcess(), TOKEN_QUERY, 
                         &hThread))
                return ( FALSE);
        }
        else 
            return ( FALSE);
    }
    
    // Then we must query the size of the group information associated with
    // the token. Note that we expect a FALSE result from GetTokenInformation
    // because we've given it a NULL buffer. On exit cbTokenGroups will tell
    // the size of the group information.
    
    if ( GetTokenInformation ( hThread, TokenGroups, NULL, 0, &cbTokenGroups))
        return ( FALSE);
    
    // Here we verify that GetTokenInformation failed for lack of a large
    // enough buffer.
    
    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        return ( FALSE);
    
    // Now we allocate a buffer for the group information.
    // Since _alloca allocates on the stack, we don't have
    // to explicitly deallocate it. That happens automatically
    // when we exit this function.
    
    if ( ! ( ptg= (TOKEN_GROUPS *)malloc ( cbTokenGroups))) 
        return ( FALSE);
    
    // Now we ask for the group information again.
    // This may fail if an administrator has added this account
    // to an additional group between our first call to
    // GetTokenInformation and this one.
    
    if ( !GetTokenInformation ( hThread, TokenGroups, ptg, cbTokenGroups,
          &cbTokenGroups) )
    {
        free(ptg);
        return ( FALSE);
    }
    
    // Now we must create a System Identifier for the Admin group.
    
    if ( ! AllocateAndInitializeSid ( &SystemSidAuthority, 2, 
            SECURITY_BUILTIN_DOMAIN_RID, 
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin) )
    {
        free(ptg);
        return ( FALSE);
    }
    
    // Finally we'll iterate through the list of groups for this access
    // token looking for a match against the SID we created above.
    
    fAdmin= FALSE;
    
    for ( dwGroup= 0; dwGroup < ptg->GroupCount; dwGroup++)
    {
        if ( EqualSid ( ptg->Groups[dwGroup].Sid, psidAdmin))
        {
            fAdmin = TRUE;
            
            break;
        }
    }
    
    // Before we exit we must explicity deallocate the SID we created.
    
    FreeSid ( psidAdmin);
    free(ptg);
    
    return ( fAdmin);
#endif //_CHICAGO_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\seoutils.cpp ===
#include "stdafx.h"

#include "utils.h"

#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>

#include "seo.h"
#include "seolib.h"

#include "seo_i.c"

#define INITGUID
#include <initguid.h>
#include "smtpguid.h"

#define STR_SMTP_NTFSDRV_DISPLAY_NAME   "Exchange Ntfs Store Driver"
#define STR_SMTP_NTFSDRV_SINKCLASS      "Exchange.NtfsDrv"
#define LONG_SMTP_NTFSDRV_PRIORITY      28000

// {C028FD82-F943-11d0-85BD-00C04FB960EA}
DEFINE_GUID(NNTP_SOURCE_TYPE_GUID, 
0xc028fd82, 0xf943, 0x11d0, 0x85, 0xbd, 0x0, 0xc0, 0x4f, 0xb9, 0x60, 0xea);

DEFINE_GUID(GUID_SMTP_NTFSDRV_BINDING,
0x609b7e3a, 0xc918, 0x11d1, 0xaa, 0x5e, 0x0, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);

HRESULT RegisterSEOService() 
{
    HRESULT hr;
    //
    // see if we've done the service level registration by getting the list
    // of source types and seeing if the SMTP source type is registered
    //
    CComPtr<IEventManager> pEventManager;
    hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
                          IID_IEventManager, (LPVOID *) &pEventManager);
    if (hr != S_OK)
        return hr;

    CComPtr<IEventSourceTypes> pSourceTypes;
    hr = pEventManager->get_SourceTypes(&pSourceTypes);
    if (FAILED(hr))
        return hr;

    CComPtr<IEventSourceType> pSourceType;
    CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(GUID_SMTP_SOURCE_TYPE);
    hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
    if (FAILED(hr))
        return hr;

    // if this failed then we need to register the source type and event
    // component categories
    if (hr == S_FALSE)
    {
        // register the component categories
        CComPtr<IEventComCat> pComCat;
        hr = CoCreateInstance(CLSID_CEventComCat, NULL, CLSCTX_ALL,
                              IID_IEventComCat, (LPVOID *) &pComCat);
        if (hr != S_OK)
            return hr;

        // register the source type
        hr = pSourceTypes->Add(bstrSourceTypeGUID, &pSourceType);
        if (FAILED(hr))
            return hr;

        _ASSERT(hr == S_OK);
        CComBSTR bstrSourceTypeDisplayName = "SMTP Server";
        hr = pSourceType->put_DisplayName(bstrSourceTypeDisplayName);
        if (FAILED(hr))
            return hr;

        hr = pSourceType->Save();
        if (FAILED(hr))
            return hr;

        // add the event types to the source type
        CComPtr<IEventTypes> pEventTypes;
        hr = pSourceType->get_EventTypes(&pEventTypes);
        if (FAILED(hr))
            return hr;

        //
        // Register the event categories
        //
        struct {
            CONST GUID * pcatid;
            LPSTR szDisplayName;
        }  rgCATTable[] = {
            //
            // Protocol event categories
            //
            { &CATID_SMTP_ON_INBOUND_COMMAND,              "SMTP Protocol OnInboundCommand" },
            { &CATID_SMTP_ON_SERVER_RESPONSE,              "SMTP Protocol OnServerResponse" },
            { &CATID_SMTP_ON_SESSION_START,                "SMTP Protocol OnSessionStart" },
            { &CATID_SMTP_ON_MESSAGE_START,                "SMTP Protocol OnMessageStart" },
            { &CATID_SMTP_ON_PER_RECIPIENT,                "SMTP Protocol OnPerRecipient" },
            { &CATID_SMTP_ON_BEFORE_DATA,                  "SMTP Protocol OnBeforeData" },
            { &CATID_SMTP_ON_SESSION_END,                  "SMTP Protocol OnSessionEnd" },

            { &CATID_SMTP_LOG, 								"SMTP OnEventLog" },

            //
            // Transport event categories
            //
            { &CATID_SMTP_STORE_DRIVER,                    "SMTP StoreDriver" },
            { &CATID_SMTP_TRANSPORT_SUBMISSION,            "SMTP Transport OnSubmission" },
            { &CATID_SMTP_TRANSPORT_PRECATEGORIZE,         "SMTP Transport OnPreCategorize" },
            { &CATID_SMTP_TRANSPORT_CATEGORIZE,            "SMTP Transport OnCategorize" },
            { &CATID_SMTP_TRANSPORT_POSTCATEGORIZE,        "SMTP Transport OnPostCategorize" },
            { &CATID_SMTP_TRANSPORT_ROUTER,                "SMTP Transport OnGetMessageRouter" },
            { &CATID_SMTP_MSGTRACKLOG,                     "SMTP Transport OnMsgTrackLog" },
            { &CATID_SMTP_DNSRESOLVERRECORDSINK,           "SMTP Transport OnDnsResolveRecord" },
            { &CATID_SMTP_MAXMSGSIZE,                      "SMTP Transport OnMaxMsgSize" },
            { &CATID_SMTP_GET_AUX_DOMAIN_INFO_FLAGS,	"SMTP Transport GetAuxiliaryDomainInfoFlags" }
        };

        for(DWORD dwCount = 0; 
            dwCount < (sizeof(rgCATTable)/sizeof(rgCATTable[0])); 
            dwCount++) {

            CComBSTR bstrCATID = (LPCOLESTR) CStringGUID( *(rgCATTable[dwCount].pcatid) );
            CComBSTR bstrDisplayName = rgCATTable[dwCount].szDisplayName;
            //
            // Register the category
            //
            hr = pComCat->RegisterCategory( bstrCATID, bstrDisplayName, 0);
            if(FAILED(hr))
                return hr;
            //
            // Add the category to the SMTP source type
            //
            hr = pEventTypes->Add( bstrCATID );
            if(FAILED(hr))
                return hr;
        }
    }

    return S_OK;
}

HRESULT pRegisterSEOForSmtp(BOOL fSetUpSourceType)
{
    HRESULT hr;
    CComPtr<IEventUtil> pEventUtil;
    TCHAR szDisplayName[32];
    CComPtr<IEventBindingManager> pBindingManager;
    CComPtr<IEventBindings> pBindings;
    CComPtr<IEventBinding> pBinding;
    CComPtr<IEventPropertyBag> pSourceProps;

    DebugOutput(_T("Registering Server Events"));

    // Register the source type, event types
    if (fSetUpSourceType)
    {
        DebugOutput(_T("Setting up source and event types"));
        hr = RegisterSEOService();
    }

    // Set up the default site (instance)
    lstrcpy(szDisplayName,_T("smtpsvc 1"));

    hr = CoCreateInstance(CLSID_CEventUtil,NULL,CLSCTX_ALL,IID_IEventUtil,(LPVOID *) &pEventUtil);
    if (FAILED(hr)) return(hr);
    hr = pEventUtil->RegisterSource(CComBSTR((LPCWSTR) CStringGUID(GUID_SMTP_SOURCE_TYPE)),
                                    CComBSTR((LPCWSTR) CStringGUID(GUID_SMTPSVC_SOURCE)),
                                    1,
                                    CComBSTR(_T("smtpsvc")),
                                    CComBSTR(_T("")),
                                    CComBSTR(_T("event.metabasedatabasemanager")),
                                    CComBSTR(szDisplayName),
                                    &pBindingManager);
    if (FAILED(hr)) goto Exit;
    hr = pBindingManager->get_Bindings(CComBSTR((LPCWSTR) CStringGUID(CATID_SMTP_STORE_DRIVER)),
                                       &pBindings);

    if (FAILED(hr)) goto Exit;

    // Set up the NTFS driver sink
    hr = pBindings->Add(CComBSTR((LPCWSTR) CStringGUID(GUID_SMTP_NTFSDRV_BINDING)),&pBinding);
    if (FAILED(hr)) goto Exit;
    hr = pBinding->put_DisplayName(CComBSTR(STR_SMTP_NTFSDRV_DISPLAY_NAME));
    if (FAILED(hr)) goto Exit;
    hr = pBinding->put_SinkClass(CComBSTR(STR_SMTP_NTFSDRV_SINKCLASS));
    if (FAILED(hr)) goto Exit;
    hr = pBinding->get_SourceProperties(&pSourceProps);
    if (FAILED(hr)) goto Exit;
    hr = pSourceProps->Add(CComBSTR(_T("priority")),&CComVariant(LONG_SMTP_NTFSDRV_PRIORITY));
    if (FAILED(hr)) goto Exit;
    hr = pBinding->Save();
    if (FAILED(hr)) goto Exit;

//  hr = pBindingManager->get_Bindings(CComBSTR((LPCWSTR) CStringGUID(CATID_SMTP_ON_DELIVERY)),
//                                 &pBindings);

Exit:
    return(hr);
}

HRESULT RegisterSEOForSmtp(BOOL fSetUpSourceType)
{
    HRESULT hr;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        DebugOutput(_T("Cannot CoInitialize()"));
        return(hr);
    }
    hr = pRegisterSEOForSmtp(fSetUpSourceType);
    CoUninitialize();

    return(hr);
}

HRESULT UnregisterSEOSourcesForSourceType(GUID guidSourceType) {
    HRESULT hr;

    //
    // find the NNTP source type in the event manager
    //
    CComPtr<IEventManager> pEventManager;
    hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL, 
                          IID_IEventManager, (LPVOID *) &pEventManager);
    if (hr != S_OK) return hr;
    CComPtr<IEventSourceTypes> pSourceTypes;
    hr = pEventManager->get_SourceTypes(&pSourceTypes);
    if (FAILED(hr)) return hr;
    CComPtr<IEventSourceType> pSourceType;
    CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(guidSourceType);
    hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
    _ASSERT(hr != S_OK || pSourceType != NULL);
    if (hr != S_OK) return hr;

    //
    // get the list of sources registered for this source type
    //
    CComPtr<IEventSources> pSources;
    hr = pSourceType->get_Sources(&pSources);
    if (FAILED(hr)) return hr;
    CComPtr<IEnumVARIANT> pSourceEnum;
    hr = pSources->get__NewEnum((IUnknown **) &pSourceEnum);
    if (FAILED(hr)) return hr;

    do {
        VARIANT varSource;

        hr = pSourceEnum->Next(1, &varSource, NULL);
        if (FAILED(hr)) return hr;
        if (hr == S_OK) {
            if (varSource.vt == VT_DISPATCH) {
                CComPtr<IEventSource> pSource;

                // QI for the IEventSource interface
                hr = varSource.punkVal->QueryInterface(IID_IEventSource, 
                                                     (void **) &pSource);
                if (FAILED(hr)) return hr;
                varSource.punkVal->Release();

                // get the binding manager
                CComBSTR bstrSourceID;
                hr = pSource->get_ID(&bstrSourceID);
                if (FAILED(hr)) return hr;

                hr = pSources->Remove(&CComVariant(bstrSourceID));
                _ASSERT(SUCCEEDED(hr));

                pSource.Release();
            } else {
                _ASSERT(FALSE);
            }
        }
    } while (hr == S_OK);

    return S_OK;
}

HRESULT UnregisterSEOSourcesForSMTP(void) {
    HRESULT hr;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        DebugOutput(_T("Cannot CoInitialize()"));
        return(hr);
    }
    hr = UnregisterSEOSourcesForSourceType(GUID_SMTP_SOURCE_TYPE);
    CoUninitialize();

    return hr;
}

HRESULT UnregisterSEOSourcesForNNTP(void) {
    HRESULT hr;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        DebugOutput(_T("Cannot CoInitialize()"));
        return(hr);
    }
    hr = UnregisterSEOSourcesForSourceType(NNTP_SOURCE_TYPE_GUID);
    CoUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\smtp.cpp ===
#include "stdafx.h"
#include <ole2.h>
#undef UNICODE
#include "iadm.h"
#define UNICODE
#include "iiscnfg.h"
#include "mdkey.h"
#include "mdentry.h"

#include "utils.h"
#include "regctrl.h"
#include "userenv.h"
#include "userenvp.h"

GUID    g_SMTPGuid   = { 0x475e3e80, 0x3193, 0x11cf, 0xa7, 0xd8,
						 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x35 };

// MCIS SMTP SnapIn CLSID - {135930f2-4689-11d1-8021-00c04fc307bd}
const WCHAR *   wszMCISSmtp_SnapIn = _T("{135930f2-4689-11d1-8021-00c04fc307bd}");

// NTOP SMTP SnapIn CLSID - {03f1f940-a0f2-11d0-bb77-00aa00a1eab7}
const WCHAR *   wszNt5Smtp_SnapIn = _T("{03f1f940-a0f2-11d0-bb77-00aa00a1eab7}");
const WCHAR *   wszNt5Smtp_SnapInName = _T("SMTP Snapin Extension");

static TCHAR szShortSvcName[] = _T("SMTP");
static char szTimebombName[] = "SMTP";

INT Register_iis_smtp_nt5(BOOL fUpgrade, BOOL fReinstall)
{
    INT err = NERR_Success;
    CString csBinPath;

    BOOL fSvcExist = FALSE;

    BOOL    fIISADMINExists = DetectExistingIISADMIN();

	if (fReinstall)
		return err;

    do {
        // set up registry values
        CRegKey regMachine = HKEY_LOCAL_MACHINE;

        // System\CurrentControlSet\Services\SMTPSVC\Parameters
        InsertSetupString( (LPCSTR) REG_SMTPPARAMETERS );

        // Software\Microsoft\Keyring\Parameters
		CString csSmtpkeyDll;
        CRegKey regKeyring( REG_KEYRING, regMachine );
        if ((HKEY) regKeyring )
		{
			csSmtpkeyDll = theApp.m_csPathInetsrv;
			csSmtpkeyDll += _T("\\smtpkey.dll");
			regKeyring.SetValue( szShortSvcName, csSmtpkeyDll );
		}

		// If we are upgrading, we will first delete the service and re-register
		if (fUpgrade)
		{
			InetDeleteService(SZ_SMTPSERVICENAME);
			InetRegisterService( theApp.m_csMachineName, 
							SZ_SMTPSERVICENAME, 
							&g_SMTPGuid, 0, 25, FALSE );
		}

		// Create or Config SMTP service
		CString csDisplayName;
		CString csDescription;

		MyLoadString( IDS_SMTPDISPLAYNAME, csDisplayName );
		MyLoadString(IDS_SMTPDESCRIPTION, csDescription);
		csBinPath = theApp.m_csPathInetsrv + _T("\\inetinfo.exe") ;

		err = InetCreateService(SZ_SMTPSERVICENAME, 
							(LPCTSTR)csDisplayName, 
							(LPCTSTR)csBinPath, 
							theApp.m_fSuppressSmtp ? SERVICE_DISABLED : SERVICE_AUTO_START, 
							SZ_SVC_DEPEND,
							(LPCTSTR)csDescription);
		if ( err != NERR_Success )
		{
			if (err == ERROR_SERVICE_EXISTS)
			{
				fSvcExist = TRUE;
				err = InetConfigService(SZ_SMTPSERVICENAME, 
								(LPCTSTR)csDisplayName, 
								(LPCTSTR)csBinPath, 
								SZ_SVC_DEPEND,
								(LPCTSTR)csDescription);
				if (err != NERR_Success)
				{
					SetErrMsg(_T("SMTP InetConfigService failed"), err);
				}
			}
		}

        if (fIISADMINExists)
        {
            // Migrate registry keys to the metabase. Or create from default values
		    // if fresh install
            MigrateIMSToMD(theApp.m_hInfHandle[MC_IMS],
						    SZ_SMTPSERVICENAME, 
						    _T("SMTP_REG"), 
						    MDID_SMTP_ROUTING_SOURCES,
						    fUpgrade);
	    // bugbug: x5 bug 72284, nt bug 202496  Uncomment this when NT
	    // is ready to accept these changes
	    SetAdminACL_wrap(_T("LM/SMTPSVC/1"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
        }

        // Create key \System\CurrentControlSet\Services\SmtpSvc\Performance:
        // Add the following values:
        // Library = smtpctrs.DLL
        // Open = OpenSMTPPerformanceData
        // Close = CloseSMTPPerformanceData
        // Collect = CollectSMTPPerformanceData
        InstallPerformance(REG_SMTPPERFORMANCE, 
						_T("smtpctrs.DLL"), 
						_T("OpenSmtpPerformanceData"),
						_T("CloseSmtpPerformanceData"), 
						_T("CollectSmtpPerformanceData"));
        InstallPerformance(REG_NTFSPERFORMANCE, 
						_T("snprfdll.DLL"), 
						_T("NTFSDrvOpen"),
						_T("NTFSDrvClose"), 
						_T("NTFSDrvCollect"));

		//
		// We used to register the SMTPB agent here.  Now we unregister it in
		// case we're upgrading since it's no longer supported
		//

		RemoveAgent( SZ_SMTPSERVICENAME );
 
        // Create key \System\CurrentControlSet\Services\EventLog\System\SmtpSvc:
        // Add the following values:
        // EventMessageFile = ..\smtpmsg.dll
        // TypesSupported = 7
        csBinPath = theApp.m_csPathInetsrv + _T("\\smtpsvc.dll");
        AddEventLog( SZ_SMTPSERVICENAME, csBinPath, 0x07 );

        if (!fSvcExist) 
		{
            InetRegisterService( theApp.m_csMachineName, 
								SZ_SMTPSERVICENAME, 
								&g_SMTPGuid, 0, 25, TRUE );
        }

        // Unload the counters and then reload them
        err = unlodctr( SZ_SMTPSERVICENAME );
	    err = unlodctr( SZ_NTFSDRVSERVICENAME );

        err = lodctr(_T("smtpctrs.ini"));
        err = lodctr(_T("ntfsdrct.ini"));

		// copy the anonpwd from w3svc
    	if (fIISADMINExists)
        {
            CMDKey cmdW3SvcKey;
    	    CMDKey cmdSMTPSvcKey;
		    cmdW3SvcKey.OpenNode(_T("LM/w3svc"));
		    cmdSMTPSvcKey.OpenNode(_T("LM/smtpsvc"));
		    if ((METADATA_HANDLE) cmdW3SvcKey && (METADATA_HANDLE) cmdSMTPSvcKey) {
			    DWORD dwAttr;
			    DWORD dwUType;
			    DWORD dwDType;
			    DWORD cbLen;
			    BYTE pbData[2*(LM20_PWLEN+1)];
			    if (cmdW3SvcKey.GetData(MD_ANONYMOUS_PWD, &dwAttr, &dwUType, &dwDType, 
				    &cbLen, pbData))
			    {
				    cmdSMTPSvcKey.SetData(MD_ANONYMOUS_PWD, dwAttr, dwUType,
					    dwDType, cbLen, pbData);
			    }
			    cmdW3SvcKey.Close();
			    cmdSMTPSvcKey.Close();
		    }
        }

        // register OLE objects
		SetEnvironmentVariable(_T("__SYSDIR"), theApp.m_csSysDir);
		SetEnvironmentVariable(_T("__INETSRV"), theApp.m_csPathInetsrv);

		err = (INT)RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
												_T("SMTP_REGISTER"), 
												TRUE);

        // NT5 - Enable snapin extension in iis.msc and compmgmt.msc
        CString csMMCFile = theApp.m_csPathInetsrv + _T("\\iis.msc");
        EnableSnapInExtension( csMMCFile, wszNt5Smtp_SnapIn, TRUE );
        //csMMCFile = theApp.m_csSysDir + _T("\\compmgmt.msc");
        //EnableSnapInExtension( csMMCFile, wszNt5Smtp_SnapIn, TRUE );

#if 0
        //  BINLIN 11/3/98 - fix 75049
        //  NT5 - do something special in compmgmt
        EnableCompMgmtExtension( wszNt5Smtp_SnapIn, wszNt5Smtp_SnapInName, TRUE );
#endif

		SetEnvironmentVariable(_T("__SYSDIR"), NULL);
		SetEnvironmentVariable(_T("__INETSRV"), NULL);

		// Server Events: We are clean installing MCIS, so we make sure we set up
		// everything, including the source type and event types.
		RegisterSEOForSmtp(TRUE);

#if 0
		// Create program group
		CreateInternetShortcut(MC_IMS, 
						IDS_PROGITEM_MAIL_SMTP_WEBADMIN, 
						IDS_ITEMPATH_MAIL_SMTP_WEBADMIN,
						FALSE);
		CreateInternetShortcut(MC_IMS, 
						IDS_PROGITEM_MAIL_README, 
						IDS_ITEMPATH_MAIL_README,
						FALSE);

#endif

#if 0
        //  fix 299130/299131 - no webadmin link

		//
        //  Create the one and only Webadmin link under "administrative tools"
        //
        CreateNt5InternetShortcut(MC_IMS, 
						IDS_PROGITEM_MAIL_SMTP_WEBADMIN, 
						IDS_ITEMPATH_MAIL_SMTP_WEBADMIN);
#endif

		if (!theApp.m_fMailGroupInstalled)
		{

			theApp.m_fMailGroupInstalled = TRUE;
		}

    } while ( 0 );

    return err;
}

INT Unregister_iis_smtp()
{
    CRegKey regMachine = HKEY_LOCAL_MACHINE;
	INT err = NERR_Success;

	// Unregister all of the NNTP sources in the SEO binding database
	UnregisterSEOSourcesForSMTP();

	// Unregister the OLE objets
	SetEnvironmentVariable(_T("__SYSDIR"), theApp.m_csSysDir);
	SetEnvironmentVariable(_T("__INETSRV"), theApp.m_csPathInetsrv);

	err = (INT)RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
											_T("SMTP_K2_UNREGISTER"), 
											FALSE);

	err = RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
											_T("SMTP_UNREGISTER"), 
											FALSE);

	SetEnvironmentVariable(_T("__SYSDIR"), NULL);
	SetEnvironmentVariable(_T("__INETSRV"), NULL);

	// Bug 51537: Remove MIB from K2 SMTP
	RemoveAgent( SZ_SMTPSERVICENAME );
	
	RemoveEventLog( SZ_SMTPSERVICENAME );
    
	err = unlodctr( SZ_SMTPSERVICENAME );
	err = unlodctr( SZ_NTFSDRVSERVICENAME );
    
	InetDeleteService(SZ_SMTPSERVICENAME);
    InetRegisterService( theApp.m_csMachineName, 
					SZ_SMTPSERVICENAME, 
					&g_SMTPGuid, 0, 25, FALSE );

	// Blow away the Services\SMTPSVC registry key
	CRegKey RegSvcs(HKEY_LOCAL_MACHINE, REG_SERVICES);
	if ((HKEY)RegSvcs)
	{
		RegSvcs.DeleteTree(SZ_SMTPSERVICENAME);
		RegSvcs.DeleteTree(SZ_NTFSDRVSERVICENAME);
	}

    // Blow away SMTP key manager
    CRegKey regKeyring( HKEY_LOCAL_MACHINE, REG_KEYRING );
    if ((HKEY) regKeyring )
	{
		regKeyring.DeleteValue(szShortSvcName);
	}

    // remove LM/SMTPSVC in the metabase
    if (DetectExistingIISADMIN())
    {
        CMDKey cmdKey;
        cmdKey.OpenNode(_T("LM"));
        if ( (METADATA_HANDLE)cmdKey ) {
            cmdKey.DeleteNode(SZ_SMTPSERVICENAME);
            cmdKey.Close();
        }
    }
     
	// remove K2 items from the program groups
	RemoveInternetShortcut(MC_IMS, 
					IDS_PROGITEM_MAIL_SMTP_WEBADMIN,
					FALSE);
	RemoveInternetShortcut(MC_IMS, 
					IDS_PROGITEM_MAIL_README,
					FALSE);
	RemoveInternetShortcut(MC_IMS, 
					IDS_PROGITEM_MAIL_README_K2,
					FALSE);

	RemoveInternetShortcut(MC_IMS, 
				IDS_PROGITEM_MCIS_MAIL_README,
				TRUE);
	RemoveInternetShortcut(MC_IMS, 
				IDS_PROGITEM_MAIL_SMTP_WEBADMIN,
				TRUE);

    //
    //  remove the one and only webadmin link from "administrative tools"
    //
	RemoveNt5InternetShortcut(MC_IMS, 
					IDS_PROGITEM_MAIL_SMTP_WEBADMIN);

    CString csMMCFile = theApp.m_csPathInetsrv + _T("\\iis.msc");
    EnableSnapInExtension( csMMCFile, wszNt5Smtp_SnapIn, FALSE );

#if 0
    //  BINLIN 11/3/98 - fix 75049
    //  NT5 - do something special in compmgmt
    EnableCompMgmtExtension( wszNt5Smtp_SnapIn, wszNt5Smtp_SnapInName, FALSE );
#endif

    return(err);
}
 
INT Upgrade_iis_smtp_nt5_fromk2(BOOL fFromK2)
{
    //  This function handles upgrade from NT4 K2, or MCIS 2.0
    INT err = NERR_Success;
    CString csBinPath;

	DebugOutput(_T("Upgrading from %s to B3 ..."), (fFromK2)? "NT4 K2" : "MCIS 2.0");

    BOOL    fSvcExist = FALSE;

    BOOL    fIISADMINExists = DetectExistingIISADMIN();

    // set up registry values
    CRegKey regMachine = HKEY_LOCAL_MACHINE;

    // System\CurrentControlSet\Services\SMTPSVC\Parameters
    InsertSetupString( (LPCSTR) REG_SMTPPARAMETERS );

    if (fIISADMINExists)
    {
        // Migrate registry keys to the metabase. Or create from default values
		// if fresh install
        MigrateIMSToMD(theApp.m_hInfHandle[MC_IMS],
						SZ_SMTPSERVICENAME, 
						_T("SMTP_REG_UPGRADEK2"), 
						MDID_SMTP_ROUTING_SOURCES,
						TRUE);
	    // bugbug: x5 bug 72284, nt bug 202496  Uncomment this when NT
	    // is ready to accept these changes
	    SetAdminACL_wrap(_T("LM/SMTPSVC/1"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
    }

    // Unload the counters and then reload them
    err = unlodctr( SZ_SMTPSERVICENAME );
    err = unlodctr( SZ_NTFSDRVSERVICENAME );

    err = lodctr(_T("smtpctrs.ini"));
    err = lodctr(_T("ntfsdrct.ini"));

	SetEnvironmentVariable(_T("__SYSDIR"), theApp.m_csSysDir);
	SetEnvironmentVariable(_T("__INETSRV"), theApp.m_csPathInetsrv);

	err = (INT)RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
											_T("SMTP_K2_UNREGISTER"), 
											FALSE);
	err = (INT)RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
											_T("SMTP_REGISTER"), 
											TRUE);

    // NT5 - Enable snapin extension in iis.msc and compmgmt.msc
    CString csMMCFile = theApp.m_csPathInetsrv + _T("\\iis.msc");
    EnableSnapInExtension( csMMCFile, wszNt5Smtp_SnapIn, TRUE );
    //csMMCFile = theApp.m_csSysDir + _T("\\compmgmt.msc");
    //EnableSnapInExtension( csMMCFile, wszNt5Smtp_SnapIn, TRUE );

	SetEnvironmentVariable(_T("__SYSDIR"), NULL);
	SetEnvironmentVariable(_T("__INETSRV"), NULL);

	// Server Events: We are clean installing MCIS, so we make sure we set up
	// everything, including the source type and event types.
	RegisterSEOForSmtp(TRUE);

	if (fFromK2)
    {
        // upgrade from K2, remove those K2 links
        RemoveInternetShortcut(MC_IMS, 
					    IDS_PROGITEM_MAIL_SMTP_WEBADMIN,
					    FALSE);
	    RemoveInternetShortcut(MC_IMS, 
					    IDS_PROGITEM_MAIL_README,
					    FALSE);
	    RemoveInternetShortcut(MC_IMS, 
					    IDS_PROGITEM_MAIL_README_K2,
					    FALSE);
    }
    else
    {
        // upgrade from MCIS 2.0, remove those MCIS links
	    RemoveInternetShortcut(MC_IMS, 
				    IDS_PROGITEM_MCIS_MAIL_README,
				    TRUE);
	    RemoveInternetShortcut(MC_IMS, 
				    IDS_PROGITEM_MAIL_SMTP_WEBADMIN,
				    TRUE);
        RemoveISMLink();
    }

#if 0
        //  fix 299130/299131 - no webadmin link

	//
    //  Create the one and only Webadmin link under "administrative tools"
    //
    CreateNt5InternetShortcut(MC_IMS, 
					IDS_PROGITEM_MAIL_SMTP_WEBADMIN, 
					IDS_ITEMPATH_MAIL_SMTP_WEBADMIN);
#endif

	if (!theApp.m_fMailGroupInstalled)
	{

		theApp.m_fMailGroupInstalled = TRUE;
	}

    return err;
}

INT Upgrade_iis_smtp_nt5_fromb2(BOOL fFromB2)
{
    INT err = NERR_Success;

	DebugOutput(_T("Upgrading from NT5 %s to B3 ..."), (fFromB2)? "B2" : "B3");

    BOOL    fIISADMINExists = DetectExistingIISADMIN();

	// set the K2 Upgrade key to true.
	if (fIISADMINExists)
    {
        MigrateIMSToMD( theApp.m_hInfHandle[MC_IMS],
                        NULL,
                        _T("SMTP_REG_K2_TO_EE"),
                        0,
                        FALSE,
                        TRUE );
        MigrateIMSToMD( theApp.m_hInfHandle[MC_IMS],
                        SZ_SMTPSERVICENAME,
                        _T("SMTP_REG_UPGRADEB2"),
                        MDID_SMTP_ROUTING_SOURCES,
						FALSE );
        // bugbug: x5 bug 72284, nt bug 202496  Uncomment this when NT
        // is ready to accept these changes
        SetAdminACL_wrap(_T("LM/SMTPSVC/1"), (MD_ACR_READ | MD_ACR_ENUM_KEYS), TRUE);
    }

	SetEnvironmentVariable(_T("__SYSDIR"), theApp.m_csSysDir);
	SetEnvironmentVariable(_T("__INETSRV"), theApp.m_csPathInetsrv);

	err = (INT)RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
											_T("SMTP_K2_UNREGISTER"), 
											FALSE);

	err = (INT)RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
											_T("SMTP_REGISTER"), 
											TRUE);

	SetEnvironmentVariable(_T("__SYSDIR"), NULL);
	SetEnvironmentVariable(_T("__INETSRV"), NULL);

    // NT5 - Enable snapin extension in iis.msc and compmgmt.msc
    CString csMMCFile = theApp.m_csPathInetsrv + _T("\\iis.msc");
    EnableSnapInExtension( csMMCFile, wszNt5Smtp_SnapIn, TRUE );
    //csMMCFile = theApp.m_csSysDir + _T("\\compmgmt.msc");
    //EnableSnapInExtension( csMMCFile, wszNt5Smtp_SnapIn, TRUE );

	// Server Events: We are upgrading from K2, so we will register the 
	// default site (instance) and the MBXSINK binding.
	RegisterSEOForSmtp(FALSE);

    // System\CurrentControlSet\Services\SMTPSVC\Parameters
	InsertSetupString( (LPCSTR) REG_SMTPPARAMETERS );

#if 0
        //  fix 299130/299131 - no webadmin link

	//
    //  Create the one and only Webadmin link under "administrative tools"
    //
    CreateNt5InternetShortcut(MC_IMS, 
					IDS_PROGITEM_MAIL_SMTP_WEBADMIN, 
					IDS_ITEMPATH_MAIL_SMTP_WEBADMIN);
#endif

	return err;

}

INT Upgrade_iis_smtp_from_b2()
{
	INT err = NERR_Success;

	DebugOutput(_T("Upgrading from K2 B2 to B3 ..."));

    do {
        // set up registry values
        CRegKey regMachine = HKEY_LOCAL_MACHINE;

		// Active Messaging
		if (theApp.m_fIsMcis)
		{
			CRegKey regActiveMsg( REG_ACTIVEMSG, regMachine );
			if ((HKEY) regActiveMsg )
			{
				regActiveMsg.SetValue( _T("Use Express"), (DWORD)0x1);
			}
		}

        // System\CurrentControlSet\Services\SMTPSVC\Parameters
        CRegKey regSMTPParam( REG_SMTPPARAMETERS, regMachine );
        if ((HKEY) regSMTPParam )
		{
			regSMTPParam.SetValue( _T("MajorVersion"), (DWORD)STACKSMAJORVERSION );
			regSMTPParam.SetValue( _T("MinorVersion"), (DWORD)STACKSMINORVERSION );
			regSMTPParam.SetValue( _T("InstallPath"), theApp.m_csPathInetsrv );

			if (!theApp.m_fIsMcis)
			{
				regSMTPParam.SetValue( _T("SetupString"), REG_SETUP_STRING );
			}
			else
			{
				regSMTPParam.SetValue( _T("SetupString"), REG_SETUP_STRING_MCIS );
			}
		}

		// Move all the parameters to the instance level.
		UpdateServiceParameters(SZ_SMTPSERVICENAME);

		// We also need to remap all the metabase IDs
		RemapServiceParameters(SZ_SMTPSERVICENAME, 8000, 1000, 0x9000);

        // Setup the extra metabase keys that were not in B2, such as ADSI Keys
        MigrateIMSToMD(theApp.m_hInfHandle[MC_IMS],
						SZ_SMTPSERVICENAME, 
						_T("SMTP_REG_B2_UPGRADE"), 
						MDID_SMTP_ROUTING_SOURCES,
						FALSE);

        // register the OLE objects
		SetEnvironmentVariable(_T("__SYSDIR"), theApp.m_csSysDir);
		SetEnvironmentVariable(_T("__INETSRV"), theApp.m_csPathInetsrv);

		err = (INT)RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
												_T("SMTP_REGISTER"), 
												TRUE);

		SetEnvironmentVariable(_T("__SYSDIR"), NULL);
		SetEnvironmentVariable(_T("__INETSRV"), NULL);

		// Create program group, the old group would be removed by IIS setup
		CreateInternetShortcut(MC_IMS, 
						IDS_PROGITEM_MAIL_SMTP_WEBADMIN, 
						IDS_ITEMPATH_MAIL_SMTP_WEBADMIN,
						theApp.m_fIsMcis);
		CreateInternetShortcut(MC_IMS, 
						theApp.m_fIsMcis?
						IDS_PROGITEM_MCIS_MAIL_README:
						IDS_PROGITEM_MAIL_README, 
						IDS_ITEMPATH_MAIL_README,
						theApp.m_fIsMcis);

		if (!theApp.m_fMailGroupInstalled)
		{
			// Set up the uninstall entries for MCIS
			if (theApp.m_fIsMcis)
				CreateUninstallEntries(SZ_IMS_INF_FILE, SZ_IMS_DISPLAY_NAME);

			theApp.m_fMailGroupInstalled = TRUE;
		}

    } while ( 0 );

    return err;
}

INT Upgrade_iis_smtp_from_b3()
{
	INT err = NERR_Success;

	DebugOutput(_T("Upgrading from K2 B3 to RTM ..."));

    do {
        // set up registry values
        CRegKey regMachine = HKEY_LOCAL_MACHINE;

		// Active Messaging
		if (theApp.m_fIsMcis)
		{
			CRegKey regActiveMsg( REG_ACTIVEMSG, regMachine );
			if ((HKEY) regActiveMsg )
			{
				regActiveMsg.SetValue( _T("Use Express"), (DWORD)0x1);
			}
		}

        // System\CurrentControlSet\Services\SMTPSVC\Parameters
        CRegKey regSMTPParam( REG_SMTPPARAMETERS, regMachine );
        if ((HKEY) regSMTPParam )
		{
			regSMTPParam.SetValue( _T("MajorVersion"), (DWORD)STACKSMAJORVERSION );
			regSMTPParam.SetValue( _T("MinorVersion"), (DWORD)STACKSMINORVERSION );
			regSMTPParam.SetValue( _T("InstallPath"), theApp.m_csPathInetsrv );

			if (!theApp.m_fIsMcis)
			{
				regSMTPParam.SetValue( _T("SetupString"), REG_SETUP_STRING );
			}
			else
			{
				regSMTPParam.SetValue( _T("SetupString"), REG_SETUP_STRING_MCIS );
			}
		}

		// Convert the domain routing entries from the B3 format to the
		// new format ...
		ReformatDomainRoutingEntries(SZ_SMTPSERVICENAME);

        // register the OLE objects
		SetEnvironmentVariable(_T("__SYSDIR"), theApp.m_csSysDir);
		SetEnvironmentVariable(_T("__INETSRV"), theApp.m_csPathInetsrv);

		err = (INT)RegisterOLEControlsFromInfSection(theApp.m_hInfHandle[MC_IMS], 
												_T("SMTP_REGISTER"), 
												TRUE);

		SetEnvironmentVariable(_T("__SYSDIR"), NULL);
		SetEnvironmentVariable(_T("__INETSRV"), NULL);

		// Create program group, the old group would be removed by IIS setup
		CreateInternetShortcut(MC_IMS, 
						IDS_PROGITEM_MAIL_SMTP_WEBADMIN, 
						IDS_ITEMPATH_MAIL_SMTP_WEBADMIN,
						theApp.m_fIsMcis);
		CreateInternetShortcut(MC_IMS, 
						theApp.m_fIsMcis?
						IDS_PROGITEM_MCIS_MAIL_README:
						IDS_PROGITEM_MAIL_README, 
						IDS_ITEMPATH_MAIL_README,
						theApp.m_fIsMcis);

		if (!theApp.m_fMailGroupInstalled)
		{
			// Set up the uninstall entries for MCIS
			if (theApp.m_fIsMcis)
				CreateUninstallEntries(SZ_IMS_INF_FILE, SZ_IMS_DISPLAY_NAME);

			theApp.m_fMailGroupInstalled = TRUE;
		}

    } while ( 0 );

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\stdafx.cxx ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by C:\stacks\lang\usa\setup.rc
//
#define VER_FF_PATCHED                  0
#define IDS_MD_COM_DISPLAYNAME          1
#define IDS_PROGGROUP_OLD_IIS           2
#define IDS_PROGGROUP_OLD_PWS           3
#define IDS_PROGGROUP_OLD_PWS_W95       4
#define IDS_PROGITEM_SETUP_PWS          5
#define IDS_PROGITEM_SETUP_IIS          6
#define IDS_CTRLPANEL_TITLE             7
#define IDS_CANNOT_LOAD_ODBCCP32DLL     8
#define IDS_PROGITEM_PWSITE             10
#define IDS_NS_IIS_ICONTITLE            12
#define IDS_CANNOT_GET_MACHINE_NAME     13
#define IDS_OS_NOT_SUPPORT              14
#define IDS_CANNOT_DETECT_OS_TYPE       15
#define IDS_ERROR_DEGRADE               16
#define IDS_PWS                         17
#define IDS_IIS                         18
#define IDS_OS_VERSION_NOT_SUPPORTED    20
#define IDS_GUEST_NAME                  21
#define IDS_NO_TCPIP                    22
#define IDS_NO_SUPPORT_ON_K2PDC         23
#define IDS_USER_COMMENT                24
#define IDS_USER_FULLNAME               25
#define IDS_PROGITEM_INETMGR            26
#define IDS_PROGITEM_KEYRING            27
#define IDS_PROGITEM_PRODDOC            28
#define IDS_PERF_MON_FILE               29
#define IDS_WWWDISPLAYNAME              30
#define IDS_SPUDDISPLAYNAME             31
#define IDS_ACCESSDENIED                32
#define IDS_FTPDISPLAYNAME              33
#define IDS_REMOVE_GOPHER               34
#define IDS_PROGITEM_HTMLA              35
#define IDS_CREATEUSER_FAIL             36
#define IDS_EULA_ACCEPTED               37
#define IDS_EULA_DECLINED               38
#define IDS_VERSION_STRING              39
#define IDS_SELECT_DIR                  40
#define IDS_NOT_ADMINISTRATOR           41
#define IDS_NO_SUPPORT_ON_PWS10         42
#define IDS_NO_SUPPORT_ON_FRONTPG       43
#define IDS_NT4_SP3_NEEDED              44
#define IDS_NT4_SP3_RISK_WARNING        45
#define IDS_NO_SUPPORT_ON_PREVIIS       46
#define IDS_NT_SERVER_REQUIRED          47
#define IDS_IIS_REQUIRED                48
#define IDS_PREVIOUS_MCIS_DETECTED      49
#define IDS_SMTPDISPLAYNAME             50
#define IDS_POP3DISPLAYNAME             51
#define IDS_IMAPDISPLAYNAME             52
#define IDS_NNTPDISPLAYNAME             53
#define IDS_INVALID_MAILROOT            54
#define IDS_CONFIRM_CREATE_MAILROOT     55
#define IDS_DISK_NOT_NTFS               56
#define IDS_INVALID_DEFAULT_DOMAIN      57
#define IDS_CANT_CREATE_MAILROOT        58
#define IDS_MAILROOT_NOT_DIRECTORY      59
#define IDS_MAILROOT_NOT_FIXED          60
#define IDS_CONFIRM_REMOVE_ALL_IMS      61
#define IDS_PROGGROUP_NEWS              62
#define IDS_PROGITEM_NEWS_WEBADMIN      63
#define IDS_PROGITEM_NEWS_DOCS          64
#define IDS_PROGGROUP_ADMINTOOLS        65
#define IDS_PROGITEM_NEWS_README        66
#define IDS_ITEMPATH_NEWS_WEBADMIN      67
#define IDS_ITEMPATH_NEWS_DOCS          68
#define IDS_ITEMPATH_NEWS_README        70
#define IDS_IEXPLORE                    71
#define IDS_PROGGROUP_MAIL              72
#define IDS_PROGITEM_MAIL_SMTP_WEBADMIN 73
#define IDS_PROGITEM_MAIL_POP3_WEBADMIN 74
#define IDS_PROGITEM_MAIL_IMAP_WEBADMIN 75
#define IDS_PROGITEM_MAIL_DOCS          76
#define IDS_PROGITEM_MAIL_README        77
#define IDS_ITEMPATH_MAIL_SMTP_WEBADMIN 78
#define IDS_ITEMPATH_MAIL_POP3_WEBADMIN 79
#define IDS_ITEMPATH_MAIL_IMAP_WEBADMIN 80
#define IDS_ITEMPATH_MAIL_DOCS          81
#define IDS_ITEMPATH_MAIL_README        82
#define IDS_CANT_CREATE_NNTPFILE        83
#define IDS_NNTPFILE_NOT_DIRECTORY      84
#define IDS_NNTPFILE_NOT_FIXED          85
#define IDS_INVALID_NNTPFILE            86
#define IDS_CONFIRM_CREATE_NNTPFILE     87
#define IDS_CONFIRM_REMOVE_MCIS10_POP3  88
#define IDS_CANNOT_CONTINUE_WITH_POP3   89
#define IDS_CANNOT_CHECK_SMTP_WO_NTFS   90
#define IDS_MAIL_AND_NEWS               91
#define IDS_MAIL_ONLY                   92
#define IDS_NEWS_ONLY                   93
#define IDS_CONFIRM_REMOVE_ALL_INS      94
#define IDS_DEFAULT_IIS_PROGRAM_GROUP   95
#define IDS_DEFAULT_NT_PROGRAM_GROUP    96
#define IDS_PROGGROUP_MCIS10_NEWS       97
#define IDS_PROGITEM_MCIS10_NEWS_WEBADMIN 98
#define IDS_PROGITEM_MCIS10_NEWS_STARTPAGE 99
#define IDS_PROGGROUP_MCIS10_MAIL       100
#define IDS_PROGITEM_MCIS10_MAIL_WEBADMIN 101
#define IDS_PROGITEM_MCIS10_MAIL_STARTPAGE 102
#define IDS_CONFIRMATION_TEXT           103
#define IDS_MESSAGEBOX_TEXT             104
#define IDS_SUPPRESS_SMTP               105
#define IDS_INVALID_DSA_ENTERPRISE      106
#define IDS_DSA_ERROR_SERVERINSTALL     107
#define IDS_DSA_ERROR_DAPI_NOLOAD       108
#define IDS_DSA_ERROR_DAPI_FCTN_NOLOAD  109
#define IDS_DSA_NOHANDLE                110
#define IDS_DSADISPLAYNAME              111
#define IDS_DSA_ERROR_CHKDISK           112
#define IDS_DSA_USERPASS_INVALID        113
#define IDS_DSA_WARNING_FAILED_POSTMASTER 114
#define IDS_IIS_CORRUPT                 115
#define IDS_ADSI_REQUEST                116
#define IDS_ADSI_REQUIRED_ERR           117
#define IDS_ADSI_INSTALL_FAILED         118
#define IDS_NO_K2_SMTP                  119
#define IDS_EXCHANGE_DS_EXISTS          120
#define IDS_CONFIRM_REMOVE_ALL_MCIS_MAIL 121
#define IDS_NNTP_DEFAULT_SITE_NAME      122
#define IDS_NNTP_SERVICE_NAME           123
#define IDS_NNTP_DEFAULT_ADMIN_NAME     124
#define IDS_NNTP_DEFAULT_ADMIN_EMAIL    125
#define IDB_BITMAP1                     126
//#define IDS_NNTP_LOG_FILE_FORMATS       127
#define IDS_SMTP_DEFAULT_SITE_NAME      128
#define IDS_POP3_DEFAULT_SITE_NAME      129
#define IDS_IMAP_DEFAULT_SITE_NAME      130
//#define IDS_SMTP_LOG_FILE_FORMATS       131
#define IDS_BITMAP_NTOP                 132
#define IDS_BITMAP_SMTP                 133
#define IDS_BITMAP_NNTP                 134
#define IDS_BITMAP_MCIS_MAIL            135
#define IDS_BITMAP_MCIS_NEWS            136
#define IDS_BITMAP_MAIL_SERVER          137
#define IDS_BITMAP_MS                   138
#define IDS_BITMAP_NEWS_SERVER          139
#define IDS_CONFIRM_REMOVE_ALL_MCIS_NEWS 140
#define IDS_CONFIRM_REMOVE_MCIS_SMTP    141
#define IDS_DSA_WARNING_FAILED_SECURITY 142
#define IDS_PROGGROUP_MCIS_MAIL_AND_NEWS 143
#define IDS_PROGITEM_MCIS_MAIL_DOCS		144
#define IDS_PROGITEM_MCIS_MAIL_README	145
#define IDS_PROGITEM_ISM				146
#define IDS_ITEMPATH_ISM				147
#define IDS_MMC							148
#define IDS_MCIS_MAIL_ONLY              149
#define IDS_MCIS_NEWS_ONLY              150
#define IDS_ROUTE_THRU_DISABLED			151
#define IDS_PROGITEM_MCIS_NEWS_DOCS		152
#define IDS_PROGITEM_MCIS_NEWS_README	153
#define IDS_NT_REQUIRED					154
#define IDS_CANNOT_ADMIN_MCIS_MMC		155
#define IDS_CONFIRM_REMOVE_ALL_RK		156
#define IDS_MMC_REQUIRED				157
#define IDS_MCIS_2_0					158
#define IDS_DSA_ADMINISTRATORS			159
#define IDS_DSA_LOGON_FAILURE			160
#define IDS_MAIL_AND_NEWS_SETUP			161
#define IDS_MAIL_ONLY_SETUP             162
#define IDS_NEWS_ONLY_SETUP             163
#define IDS_MCIS_MAIL_ONLY_SETUP        164
#define IDS_MCIS_NEWS_ONLY_SETUP        165
#define IDS_RETRY                       166
#define IDS_PROGITEM_NEWS_README_K2     167
#define IDS_PROGITEM_MAIL_README_K2     168
#define IDS_NNTPDESCRIPTION				169
#define IDS_SMTPDESCRIPTION				170

#define	idsRegLicenseInfoKey			400
#define	idsRegDisplayName				401
#define	idsRegMode						402
#define	idsProdFamilyName				403	
#define	idsProdName						404
#define	idsMDBShortName					405

#define LANGID_US                       0409
#define IDD_PROPPAGE_WELCOME            501
#define IDD_PROPPAGE_PUBLISH_DIR        502
#define IDD_PROPPAGE_END                503
#define IDD_PROPPAGE_EULA               504
#define IDD_BROWSEDIRECTORY             505
#define IDD_PROPPAGE_MODE_MAINTANENCE   506
#define IDD_PROPPAGE_MODE_FRESH         507
#define IDD_PROPPAGE_MODE_UPGRADE       508
#define IDD_PROPPAGE_DEFAULT_DOMAIN     509
#define IDD_PROPPAGE_MAILROOT_DIR       510
#define IDD_PROPPAGE_DSA_ACCOUNT        511
#define IDD_PROPPAGE_NNTPFILE_DIR       512
#define IDD_PROPPAGE_NNTPROOT_DIR       513
#define IDD_PROPPAGE_DSA                514
#define IDB_WELCOMESMTP                 600
#define IDB_WELCOMENNTP                 601
#define IDB_BANNER                      602
#define IDB_NNTP                        603
#define IDB_SMTP                        604
//#define IDB_POP3                        605
//#define IDB_IMAP                        606
#define IDB_DOCS                        607
//#define IDB_DSA                         608
//#define IDB_MMC                         609
#define IDC_LICENSE_TEXT                1000
#define IDC_EULA_ACCEPT                 1001
#define IDC_EULA_DECLINE                1002
#define IDC_WWW_PUB_GROUP               1003
#define IDC_FTP_PUB_GROUP               1004
#define IDC_WWW_PUB_EDIT                1005
#define IDC_FTP_PUB_EDIT                1006
#define IDC_WWW_PUB_BROWSE              1007
#define IDC_FTP_PUB_BROWSE              1008
#define IDC_ADDREMOVE                   1009
#define IDC_REINSTALL                   1010
#define IDC_REMOVEALL                   1011
#define IDC_MINIMUM                     1012
#define IDC_TYPICAL                     1013
#define IDC_CUSTOM                      1014
#define IDC_UPGRADEONLY                 1015
#define IDC_ADDEXTRACOMPS               1016
#define IDC_FRAME_WELCOME               1017
#define IDC_FRAME_BANNER                1018
#define IDC_DEFAULT_DOMAIN_EDIT         1019
#define IDC_DEFAULT_DOMAIN_GROUP        1020
#define IDC_MAILROOT_DIR_GROUP          1021
#define IDC_MAILROOT_DIR_EDIT           1022
#define IDC_MAILROOT_DIR_BROWSE         1023
#define IDC_NNTPROOT_DIR_GROUP          1024
#define IDC_NNTPROOT_DIR_EDIT           1025
#define IDC_NNTPROOT_DIR_BROWSE         1026
#define IDC_NNTPFILE_DIR_GROUP          1027
#define IDC_NNTPFILE_DIR_EDIT           1028
#define IDC_NNTPFILE_DIR_BROWSE         1029
#define IDC_DSA_ENTERPRISE_GROUP        1030
#define IDC_DSA_SITE_GROUP              1031
#define IDC_DSA_ENTERPRISE_EDIT         1032
#define IDC_DSA_SITE_EDIT               1033
#define IDC_stc1                        1034
#define IDC_stc2                        1035
#define IDC_stc3                        1036
#define IDC_stc4                        1037
#define IDC_lst1                        1038
#define IDC_lst2                        1039
#define IDC_cmb1                        1040
#define IDC_cmb2                        1041
#define IDC_edt1                        1042
#define IDC_DSA_PASSWORD_GROUP          1043
#define IDC_DSA_ACCOUNT_GROUP           1044
#define IDC_DSA_ACCOUNT_EDIT            1045
#define IDC_DSA_PASSWORD_EDIT           1046
#define IDC_FRAME_BANNER_MS             2009
#define IDC_FRAME_BANNER_TITLE          2010
#define IDC_FRAME_BANNER_DSA_PASS       2011

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1024
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\svc.cpp ===
#include "stdafx.h"
#include <winsvc.h>
#include <winsock2.h>
#include <nspapi.h>
#include "w3svc.h"
#include <inetsvcs.h>

#define PROCESS_SIZE    16

TCHAR gServicesWhichMustBeRestarted[20][PROCESS_SIZE];
int gServicesWhichMustBeRestarted_nextuse;
int gServicesWhichMustBeRestarted_total;

int ServicesRestartList_EntryExists(LPCTSTR szServiceName)
{
    int iFoundMatch = FALSE;

    // loop thru the whole list
    for(int i=0; i < gServicesWhichMustBeRestarted_total;i++)
    {
        if (_tcsicmp(gServicesWhichMustBeRestarted[i], szServiceName) == 0)
        {
            iFoundMatch = TRUE;
            break;
        }
    }

    return iFoundMatch;
}


int ServicesRestartList_Add(LPCTSTR szServiceName)
{
    DebugOutput(_T("ServicesRestartList_Add() on Service %s"), szServiceName);

    // check if this value already exists in the globalarary
    if (ServicesRestartList_EntryExists(szServiceName)) {return FALSE;}
    
    // move info into global array
    if (gServicesWhichMustBeRestarted_nextuse <= 20)
    {
        _tcscpy(gServicesWhichMustBeRestarted[gServicesWhichMustBeRestarted_nextuse],szServiceName);
        // increment counter to array
        // increment next use space
        ++gServicesWhichMustBeRestarted_total;
        ++gServicesWhichMustBeRestarted_nextuse;
    }
    return TRUE;
}

int ServicesRestartList_RestartServices(void)
{
    int iReturn = FALSE;
    INT err = 0;

    // loop thru the whole list and restart the services in reverse
    // order from how they were entered?
    if (gServicesWhichMustBeRestarted_total >= 1)
    {
        DebugOutput(_T("RestartServices() Start."));
        for(int i=0; i < gServicesWhichMustBeRestarted_total;i++)
        {
            err = InetStartService(gServicesWhichMustBeRestarted[i]);
            DebugOutput(_T("Start service %s. err=%x"), gServicesWhichMustBeRestarted[i], err);
        }
        DebugOutput(_T("RestartServices()  End."));
    }

    return iReturn;
}


INT InetDisableService( LPCTSTR lpServiceName )
{
    INT err = 0;
    const DWORD dwSvcSleepInterval = 500 ;
    const DWORD dwSvcMaxSleep = 180000 ;
    DWORD dwSleepTotal;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    do {
        if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        // if the service is running, stop it
        SERVICE_STATUS svcStatus;
        if ( QueryServiceStatus( hService, &svcStatus ))
        {
            if (( svcStatus.dwCurrentState == SERVICE_RUNNING ))
            {
                if ( !ControlService( hService, SERVICE_CONTROL_STOP, &svcStatus ))
                {
                    err = GetLastError();
                    break;
                }
                for ( dwSleepTotal = 0 ;
                    dwSleepTotal < dwSvcMaxSleep
                    && (QueryServiceStatus( hService, & svcStatus ))
                    && svcStatus.dwCurrentState == SERVICE_STOP_PENDING ;
                    dwSleepTotal += dwSvcSleepInterval )
                {
                    ::Sleep( dwSvcSleepInterval ) ;
                }
            }
        }

        err = ::ChangeServiceConfig( hService, SERVICE_NO_CHANGE, SERVICE_DISABLED,
            SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, NULL, NULL, NULL );

    } while ( FALSE );

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);

    return(err);
}

INT InetStartService( LPCTSTR lpServiceName )
{
    INT err = 0;
    const DWORD dwSvcSleepInterval = 500 ;
    const DWORD dwSvcMaxSleep = 180000 ;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    DebugOutput(_T("Starting %s service..."), lpServiceName);

    do {
        // set up the service first
        if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        SERVICE_STATUS svcStatus;
        if ( !QueryServiceStatus( hService, &svcStatus ))
        {
            err = ::GetLastError();
            break;
        }

        if ( svcStatus.dwCurrentState == SERVICE_RUNNING )
            break; // service already started and running

        if ( !::StartService( hService, 0, NULL ))
        {
            err = ::GetLastError();
            break;
        }

        //  Wait for the service to attain "running" status; but
        //  wait no more than 3 minute.
        DWORD dwSleepTotal;
        for ( dwSleepTotal = 0 ; dwSleepTotal < dwSvcMaxSleep
            && (QueryServiceStatus( hService, &svcStatus ))
            //&& svcStatus.dwCurrentState == SERVICE_START_PENDING ;
            && svcStatus.dwCurrentState != SERVICE_RUNNING ;
            dwSleepTotal += dwSvcSleepInterval )
        {
            ::Sleep( dwSvcSleepInterval ) ;
        }

        if ( svcStatus.dwCurrentState != SERVICE_RUNNING )
        {
            err = dwSleepTotal > dwSvcMaxSleep ?
                ERROR_SERVICE_REQUEST_TIMEOUT :
                svcStatus.dwWin32ExitCode;
            break;
        }

    } while ( FALSE );

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);
    
    DebugOutput(_T("Service started with 0x%x"), err);

    return(err);
}

DWORD InetQueryServiceStatus( LPCTSTR lpServiceName )
{
    DWORD dwStatus = 0;
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS svcStatus;

    DebugOutputSafe(_T("InetQueryServiceStatus() on %1!s!\n"), lpServiceName);

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL ||
            !::QueryServiceStatus( hService, &svcStatus ) )
        {
            err = GetLastError();
            DebugOutputSafe(_T("InetQueryServiceStatus() failed: err=%1!d!\n"), err);
            break;
        }

        dwStatus = svcStatus.dwCurrentState;

    } while (0);

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);

    DebugOutputSafe(_T("InetQueryServiceStatus() return: dwStatus=%1!d!\n"), dwStatus);

    return( dwStatus );
}

INT InetStopService( LPCTSTR lpServiceName )
{
    INT err = 0;
    const DWORD dwSvcSleepInterval = 500 ;
    const DWORD dwSvcMaxSleep = 180000 ;
    DWORD dwSleepTotal;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    DebugOutputSafe(_T("Stopping %1!s! service...\n"), lpServiceName);

    do {
        if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        SERVICE_STATUS svcStatus;
        if ( !QueryServiceStatus( hService, &svcStatus ))
        {
            err = ::GetLastError();
            break;
        }

        if ( svcStatus.dwCurrentState == SERVICE_STOPPED )
		{
			err = ERROR_SERVICE_NOT_ACTIVE;
            break; // service already stopped
		}

         if (( svcStatus.dwCurrentState == SERVICE_RUNNING ))
        {
            if ( !ControlService( hService, SERVICE_CONTROL_STOP, &svcStatus ))
            {
                err = GetLastError();
                break;
            }
            for ( dwSleepTotal = 0 ;
                dwSleepTotal < dwSvcMaxSleep
                && (QueryServiceStatus( hService, & svcStatus ))
                //&& svcStatus.dwCurrentState == SERVICE_STOP_PENDING ;
                && svcStatus.dwCurrentState != SERVICE_STOPPED ;
                dwSleepTotal += dwSvcSleepInterval )
            {
                ::Sleep( dwSvcSleepInterval ) ;
            }
        }

        if ( svcStatus.dwCurrentState != SERVICE_STOPPED )
        {
            err = dwSleepTotal > dwSvcMaxSleep ?
                ERROR_SERVICE_REQUEST_TIMEOUT :
                svcStatus.dwWin32ExitCode;
            break;
        }

    } while ( FALSE );

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);

    DebugOutput(_T("Service stopped with 0x%x"), err);

    return(err);
}

INT InetDeleteService( LPCTSTR lpServiceName )
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    /*
    The DeleteService function marks a service for deletion from the service control manager database.
    The database entry is not removed until all open handles to the service have been closed by calls
    to the CloseServiceHandle function, and the service is not running. A running service is stopped
    by a call to the ControlService function with the SERVICE_CONTROL_STOP control code.
    If the service cannot be stopped, the database entry is removed when the system is restarted.
    The service control manager deletes the service by deleting the service key and its subkeys from
    the registry.
    */
    // To delete service immediately, we need to stop service first
    InetStopService(lpServiceName);

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL ||
            !::DeleteService( hService ) )
        {
            err = GetLastError();
            break;
        }
    } while (0);

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);

    return(err);
}

INT InetCreateDriver(LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, DWORD dwStartType)
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    do {
        if ( (hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        hService = ::CreateService( hScManager, lpServiceName, lpDisplayName,
                GENERIC_ALL, SERVICE_KERNEL_DRIVER, dwStartType,
                SERVICE_ERROR_NORMAL, lpBinaryPathName, NULL, NULL,
                NULL, NULL, NULL );
        if ( !hService )
        {
            err = GetLastError();
            break;
        }

    } while ( FALSE );

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);

    return(err);
}

INT InetCreateService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName,
    LPCTSTR lpBinaryPathName, DWORD dwStartType, LPCTSTR lpDependencies, 
    LPCTSTR lpServiceDescription)
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    do {
        if ( (hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        hService = ::CreateService( hScManager, lpServiceName, lpDisplayName,
                GENERIC_ALL, SERVICE_WIN32_SHARE_PROCESS, dwStartType,
                SERVICE_ERROR_NORMAL, lpBinaryPathName, NULL, NULL,
                lpDependencies, _T("LocalSystem"), NULL );
        if ( !hService )
        {
            err = GetLastError();
            break;
        }

        if (lpServiceDescription) {
            SERVICE_DESCRIPTION desc;
            desc.lpDescription = (LPTSTR)lpServiceDescription;
            if (!ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &desc)) {
                err = GetLastError();
                break;
            }
        }

    } while ( FALSE );

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);

    return(err);
}

INT InetConfigService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName,
    LPCTSTR lpBinaryPathName, LPCTSTR lpDependencies,
    LPCTSTR lpServiceDescription)
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        if ( !::ChangeServiceConfig(hService, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE,
                lpBinaryPathName, NULL, NULL, lpDependencies, _T("LocalSystem"), NULL, lpDisplayName) )
        {
            err = GetLastError();
            break;
        }

        if (lpServiceDescription) {
            SERVICE_DESCRIPTION desc;
            desc.lpDescription = (LPTSTR)lpServiceDescription;
            if (!ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &desc)) {
                err = GetLastError();
                break;
            }
        }

    } while ( FALSE );

    if (hService)
        CloseServiceHandle(hService);
    if (hScManager)
        CloseServiceHandle(hScManager);

    return(err);
}

# define SetServiceTypeValues( pSvcTypeValue, dwNS, dwType, dwSize, lpValName, lpVal)   \
       ( pSvcTypeValue)->dwNameSpace = ( dwNS);          \
       ( pSvcTypeValue)->dwValueType = ( dwType);        \
       ( pSvcTypeValue)->dwValueSize = ( dwSize);        \
       ( pSvcTypeValue)->lpValueName = ( lpValName);     \
       ( pSvcTypeValue)->lpValue     = (PVOID ) ( lpVal); \

# define SetServiceTypeValuesDword( pSvcTypeValue, dwNS, lpValName, lpVal) \
   SetServiceTypeValues( (pSvcTypeValue), (dwNS), REG_DWORD, sizeof( DWORD), \
                         ( lpValName), ( lpVal))

BOOL InetRegisterService( LPCTSTR pszMachine, LPCTSTR   pszServiceName,
                   GUID *pGuid, DWORD SapId, DWORD TcpPort, BOOL fAdd )
{
    int err;

    WSADATA  WsaData;

    SERVICE_INFO serviceInfo;
    LPSERVICE_TYPE_INFO_ABS lpServiceTypeInfo ;
    LPSERVICE_TYPE_VALUE_ABS lpServiceTypeValues ;
    BYTE serviceTypeInfoBuffer[sizeof(SERVICE_TYPE_INFO) + 1024];
             // Buffer large enough for 3 values ( SERVICE_TYPE_VALUE_ABS)

    DWORD Value1 = 1 ;
    DWORD SapValue = SapId;
    DWORD TcpPortValue = TcpPort;
    DWORD statusFlags;

    //
    // Initialize Windows Sockets DLL
    //

    err = WSAStartup( 0x0101, & WsaData);
    if ( err == SOCKET_ERROR) {

        return ( FALSE);
    }


    //
    // Setup the service information to be passed to SetService() for adding
    //   or deleting this service. Most of the SERVICE_INFO fields are not
    //   required for add or delete operation. The main things of interests are
    //  GUIDs and ServiceSpecificInfo structure.
    //

    memset( (PVOID ) & serviceInfo, 0, sizeof( serviceInfo)); //null all fields

    serviceInfo.lpServiceType     =  pGuid;
    serviceInfo.lpMachineName     =  (LPTSTR)pszMachine;

    //
    // The "Blob" will contain the service specific information.
    // In this case, fill it with a SERVICE_TYPE_INFO_ABS structure
    //  and associated information.
    //
    serviceInfo.ServiceSpecificInfo.pBlobData = serviceTypeInfoBuffer;
    serviceInfo.ServiceSpecificInfo.cbSize    = sizeof( serviceTypeInfoBuffer);


    lpServiceTypeInfo = (LPSERVICE_TYPE_INFO_ABS ) serviceTypeInfoBuffer;

    //
    //  There are totally 3 values associated with this service if we're doing
    //  both SPX and TCP, there's only one value if TCP.
    //

    if ( SapId )
    {
        lpServiceTypeInfo->dwValueCount = 3;
    } else
    {
        lpServiceTypeInfo->dwValueCount = 1;
    }
    lpServiceTypeInfo->lpTypeName   = (LPTSTR)pszServiceName;

    lpServiceTypeValues = lpServiceTypeInfo->Values;

    if ( SapId )
    {
        //
        // 1st value: tells the SAP that this is a connection oriented service.
        //

        SetServiceTypeValuesDword( ( lpServiceTypeValues + 0),
                                  NS_SAP,                    // Name Space
                                  SERVICE_TYPE_VALUE_CONN,   // ValueName
                                  &Value1                    // actual value
                                  );

        //
        // 2nd Value: tells SAP about object type to be used for broadcasting
        //   the service name.
        //

        SetServiceTypeValuesDword( ( lpServiceTypeValues + 1),
                                  NS_SAP,
                                  SERVICE_TYPE_VALUE_SAPID,
                                  &SapValue);

        //
        // 3rd value: tells TCPIP name-space provider about TCP/IP port to be used.
        //
        SetServiceTypeValuesDword( ( lpServiceTypeValues + 2),
                                  NS_DNS,
                                  SERVICE_TYPE_VALUE_TCPPORT,
                                  &TcpPortValue);

    } else
    {
        SetServiceTypeValuesDword( ( lpServiceTypeValues + 0),
                                    NS_DNS,
                                    SERVICE_TYPE_VALUE_TCPPORT,
                                    &TcpPortValue);
    }
    //
    // Finally, call SetService to actually perform the operation.
    //

    err = SetService(
                     NS_DEFAULT,             // all default name spaces
                     ( fAdd ) ? SERVICE_ADD_TYPE : SERVICE_DELETE_TYPE,       // either ADD or DELETE
                     0,                      // dwFlags not used
                     &serviceInfo,           // the service info structure
                     NULL,                   // lpServiceAsyncInfo
                     &statusFlags            // additional status information
                     );

    if ( err == SOCKET_ERROR)
	{
		Value1 = GetLastError();
		return(FALSE);
	}
	return(TRUE);

} // InetRegisterService()

//
//Routine Description:
//    Stop the named service and all those services which depend upon it.
//    And if the service is hung and can't be stopped, then kill the darn thing.
//
//Arguments:
//    ServiceName (Name of service to stop)
//
//Return Status:
//    TRUE - Indicates service successfully stopped
//    FALSE - Timeout occurred.
//
int StopServiceAndDependencies(LPCTSTR ServiceName, int AddToRestartList)
{
    DebugOutput(_T("StopServiceAndDependencies():%s Service"), ServiceName);

    int Err = 0;
    int iBeforeServiceStatus = 0;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    DWORD Timeout;
	int iReturn = FALSE;

    //
    // Open a handle to the Service.
    //
    ScManagerHandle = OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT );
    if (ScManagerHandle == NULL) 
	{
        Err = GetLastError();
		DebugOutput(_T("StopServiceAndDependencies():OpenSCManager: Err on Service %s Err=0x%x FAILED"), ServiceName, Err);
        goto Cleanup;
    }

    ServiceHandle = OpenService(ScManagerHandle,ServiceName,SERVICE_QUERY_STATUS | SERVICE_INTERROGATE | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_STOP | SERVICE_QUERY_CONFIG );
    if ( ServiceHandle == NULL ) 
	{
        Err = GetLastError();
        if (Err == ERROR_SERVICE_DOES_NOT_EXIST)
        {
             iReturn = TRUE;
             DebugOutput(_T("StopServiceAndDependencies():%s Service does not exist."), ServiceName);
        }
        else
        {
             DebugOutput(_T("StopServiceAndDependencies():OpenService: Err on Service %s Err=0x%x FAILED"), ServiceName, Err);
        }
        goto Cleanup;
    }

    // Get the before service status.
    if (QueryServiceStatus(ServiceHandle, &ServiceStatus)) 
    {
        iBeforeServiceStatus = ServiceStatus.dwCurrentState;
    }

    //
    // Ask the service to stop.
    //
    if ( !ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus) ) 
	{
        Err = GetLastError();
        // If there are dependent services running,
        //  determine their names and stop them.
        if ( Err == ERROR_DEPENDENT_SERVICES_RUNNING ) 
		{
            BYTE ConfigBuffer[4096];
            LPENUM_SERVICE_STATUS ServiceConfig = (LPENUM_SERVICE_STATUS) &ConfigBuffer;
            DWORD BytesNeeded;
            DWORD ServiceCount;
            DWORD ServiceIndex;

            //
            // Get the names of the dependent services.
            //
            if ( !EnumDependentServices( ServiceHandle,SERVICE_ACTIVE,ServiceConfig,sizeof(ConfigBuffer),&BytesNeeded,&ServiceCount ) ) 
			{
                Err = GetLastError();
                DebugOutput(_T("StopServiceAndDependencies():EnumDependentServices: Err on Service %s Err=0x%x FAILED"), ServiceName, Err);
                goto Cleanup;
            }

            //
            // Stop those services.
            //
            for ( ServiceIndex=0; ServiceIndex<ServiceCount; ServiceIndex++ ) 
			{
                StopServiceAndDependencies( ServiceConfig[ServiceIndex].lpServiceName, AddToRestartList);
            }

            //
            // Ask the original service to stop.
            //
            if ( !ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus) ) 
			{
                Err = GetLastError();

				// check if the service is already stopped..
				if ( Err == ERROR_SERVICE_CANNOT_ACCEPT_CTRL || Err == ERROR_SERVICE_NOT_ACTIVE) 
				{
					// check if the service is alread stopped.
					if (QueryServiceStatus( ServiceHandle, &ServiceStatus )) 
					{
						if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED || ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) 
							{
                            iReturn = TRUE;
                            goto Cleanup;
                            }
					}
				}
				else
				{
                    // The service must be in a hung mode.  Let's kill it.
                    // Todo: NYI
                    DebugOutput(_T("StopServiceAndDependencies():'%s' Service must be in a hung mode.  Let's kill it."), ServiceName);
                    //KillService(ServiceHandle);
                    //goto WaitLoop;
				}
			
                goto Cleanup;
            }

        }
		else 
		{
			// check if the service is already stopped..
			if ( Err == ERROR_SERVICE_CANNOT_ACCEPT_CTRL || Err == ERROR_SERVICE_NOT_ACTIVE) 
			{
				// check if the service is alread stopped.
				if (QueryServiceStatus( ServiceHandle, &ServiceStatus )) 
				{
					if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED || ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) 
						{
                        Err = ServiceStatus.dwCurrentState;
                        iReturn = TRUE;
                        goto Cleanup;
                        }
				}
			}
			else
			{
					// The service must be in a hung mode.  Let's kill it.
					DebugOutput(_T("StopServiceAndDependencies():'%s' Service must be in a hung mode.  Let's kill it."), ServiceName);
					//KillService(ServiceHandle);
					//goto WaitLoop;
			}
		
            goto Cleanup;
        }
    }
    else
    {
        // We successfully asked the service to stop...
    }


    // Loop waiting for the service to stop.
    for ( Timeout=0; Timeout<45; Timeout++ ) 
    {
        // Return or continue waiting depending on the state of the service.
        if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED ) 
		{
			// The service successfully stopped.
            DebugOutput(_T("StopServiceAndDependencies(): %s Service stopped."), ServiceName);
			iReturn = TRUE;
            goto Cleanup;
        }

        // Wait a second for the service to finish stopping.
        Sleep( 1000 );

        // Query the status of the service again.
        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus ))
		{
            Err = GetLastError();
			DebugOutput(_T("StopServiceAndDependencies():QueryServiceStatus: Err on Service %s Err=0x%x FAILED"), ServiceName, Err);
            goto Cleanup;
        }

#if 0
        // if the service we are trying to stop is a driver,
        // then heck we should just get out of here..
        if (TRUE == IsThisServiceADriver(ServiceName))
        {
            DebugOutput(_T("StopServiceAndDependencies(): %s service is a driver, and can only be removed upon reboot."), ServiceName);
            goto Cleanup;
        }
#endif
    }

    // if we get here then the service failed to stop.
    DebugOutput(_T("StopServiceAndDependencies(): failed to stop %s service."), ServiceName);

Cleanup:
    if ( ScManagerHandle != NULL )  {(VOID) CloseServiceHandle(ScManagerHandle);}
	if ( ServiceHandle != NULL ) {(VOID) CloseServiceHandle(ServiceHandle);}

    // if we successfully stopped this service, then
    // add it to the restart service list
    if (iReturn == TRUE)
    {
        if (iBeforeServiceStatus == SERVICE_RUNNING)
        {
            if (AddToRestartList) {ServicesRestartList_Add(ServiceName);}
        }
    }
    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\utils.cpp ===
#include "stdafx.h"

#include "userenv.h"
#include "userenvp.h"

#include "shlobj.h"
#include "utils.h"

#include "mddefw.h"
#include "mdkey.h"

#include "wizpages.h"

#include "ocmanage.h"
#include "setupapi.h"
#include "k2suite.h"

#include "ndmgr.h"
#include "mycomput.h"

extern OCMANAGER_ROUTINES gHelperRoutines;

// This function provides StrChr functionality
LPTSTR MyStrChr(LPCTSTR szString, TCHAR tcChar)
{
	while (*szString != _T('\0'))
	{
		if (*szString == tcChar)
			return((LPTSTR)szString);
		szString++;
	}
	return(NULL);
}

// This function finds the first non-whitespace
LPTSTR NextNonSpace(LPTSTR szString)
{
	while ((*szString == _T(' ')) || (*szString == _T('\t')))
	{
		if (!*szString)
			return(NULL);
		*szString++;
	}
	return(szString);
}

// This function finds the first whitespace
LPTSTR NextSpace(LPTSTR szString)
{
	while ((*szString != _T(' ')) && (*szString != _T('\t')) &&
			(*szString != _T('\0')))
	{
		*szString++;
	}
	return(szString);
}

BOOL ParseInfLineArguments(LPCTSTR szLine, LPTSTR szAttribute, LPTSTR szValue)
{
	LPTSTR	pEqual, pAttrStart, pValueStart;
	TCHAR	tcTemp;

	pAttrStart = NextNonSpace((LPTSTR)szLine);
	if (!pAttrStart)
		return(FALSE);

	pEqual = MyStrChr(szLine, _T('='));
	if (pEqual)
	{
		// Found equal sign
		if (pAttrStart >= pEqual)
			return(FALSE);

		pValueStart = NextNonSpace(pEqual + 1);
		if (pValueStart)
			lstrcpy(szValue, pValueStart);
	}
	else
		*szValue = _T('\0');

	// Find the end of the attribute name
	pValueStart = NextSpace(pAttrStart);
	tcTemp = *pValueStart;
	*pValueStart = _T('\0');
	lstrcpy(szAttribute, pAttrStart);
	*pValueStart = tcTemp;

	return(TRUE);
}

// This function obtains the root directory of a directory
BOOL GetRootDirectory(LPCTSTR szDirectory, LPTSTR szRootDir, DWORD cbLength)
{
	DWORD dwLen = lstrlen(szDirectory);

	SetLastError(ERROR_INVALID_PARAMETER);

	if (dwLen < 2)
		return(FALSE);

	if (szDirectory[0] == _T('\\') &&
		szDirectory[1] == _T('\\'))
	{
		LPTSTR lpTemp;

		// This is a UNC, get the share name. We find the 4th
		// backslash and take everything before that.
		lpTemp = MyStrChr(szDirectory + 2, _T('\\'));
		if (!lpTemp)
			return(FALSE);

		lpTemp = MyStrChr(lpTemp + 1, _T('\\'));
		if (!lpTemp)
			return(FALSE);
	
		// Get how many bytes to copy
		dwLen = (DWORD)(lpTemp - szDirectory + 1);
		if (cbLength < dwLen)
		{
			SetLastError(ERROR_MORE_DATA);
			return(FALSE);
		}

		lstrcpyn(szRootDir, szDirectory, dwLen);
	}
	else
	{
		if (cbLength < 4)
		{
			SetLastError(ERROR_MORE_DATA);
			return(FALSE);
		}

		// This is a drive specification
		if (szDirectory[1] != _T(':'))
			return(FALSE);

		if (dwLen == 2)
		{
			lstrcpy(szRootDir, szDirectory);
			lstrcat(szRootDir, _T("\\"));
		}
		else
		{
			if (szDirectory[2] != _T('\\'))
				return(FALSE);

			lstrcpyn(szRootDir, szDirectory, 4);
		}
	}

	return(TRUE);
}

// This function uses a WIN32 function to check for bad directory names
// Hacky, but works  :-)
BOOL IsDirectoryLexicallyValid(LPCTSTR szPath)
{
	HANDLE hDir;
	BOOL fRet = FALSE;

	hDir = FindFirstChangeNotification(szPath, FALSE, FILE_NOTIFY_CHANGE_SECURITY);
	if (hDir == INVALID_HANDLE_VALUE || hDir == NULL)
	{
		DWORD dwErr = GetLastError();
	}
	else
	{
		fRet = TRUE;
		FindCloseChangeNotification(hDir);
	}

	return(fRet);
}

// This funciton determines if a volume is NTFS
BOOL IsVolumeNtfs(LPCTSTR szDisk)
{
	TCHAR szVolume[MAX_PATH];
	TCHAR szFileSystem[MAX_PATH];
	DWORD lSerial, lMaxLen, lFlags;

	if (GetVolumeInformation(szDisk, szVolume, MAX_PATH,
							&lSerial, &lMaxLen, &lFlags,
							szFileSystem, MAX_PATH))
	{
		if(!lstrcmpi(szFileSystem, _T("NTFS")))
			return(TRUE);
	}

	return(FALSE);	
}

// This funciton determines if a the local machine constains at
// least one NTFS volume
BOOL AnyNtfsVolumesOnLocalMachine(LPTSTR szFirstNtfsVolume)
{
	TCHAR szDrives[256];
	TCHAR *lpCurrentDrive;
	DWORD dwLength, dwType;

	*szFirstNtfsVolume = _T('\0');

	dwLength = GetLogicalDriveStrings(256, szDrives);
	if (dwLength)
	{
		lpCurrentDrive = szDrives;

		while (*lpCurrentDrive != _T('\0'))
		{
			// Make sure this is not removable media
			dwType = GetDriveType(lpCurrentDrive);
			if (dwType & DRIVE_FIXED)
			{
				// Fixed media, see if it is NTFS ...
				if (IsVolumeNtfs(lpCurrentDrive))
				{
					lstrcpy(szFirstNtfsVolume, lpCurrentDrive);
					return(TRUE);
				}
			}

			// Next drive
			lpCurrentDrive += (lstrlen(lpCurrentDrive) + 1);
		}
	}
	return(FALSE);	
}

DWORD GetUnattendedMode(HANDLE hUnattended, LPCTSTR szSubcomponent)
{
	BOOL		b = FALSE;
	TCHAR		szLine[1024];
	DWORD		dwMode = SubcompUseOcManagerDefault;
	CString		csMsg;

	csMsg = _T("GetUnattendedMode ");
	csMsg += szSubcomponent;
	csMsg += _T("\n");
	DebugOutput((LPCTSTR)csMsg);

	// Try to get the line of interest
	if (hUnattended && (hUnattended != INVALID_HANDLE_VALUE))
	{
		b = SetupGetLineText(NULL, hUnattended, _T("Components"),
							 szSubcomponent, szLine, sizeof(szLine), NULL);
		if (b)
		{
			csMsg = szSubcomponent;
			csMsg += _T(" = ");
			csMsg += szLine;
			csMsg += _T("\n");
			DebugOutput((LPCTSTR)csMsg);

			// Parse the line
			if (!lstrcmpi(szLine, _T("on")))
			{
				dwMode = SubcompOn;
			}
			else if (!lstrcmpi(szLine, _T("off")))
			{
				dwMode = SubcompOff;
			}
			else if (!lstrcmpi(szLine, _T("default")))
			{
				dwMode = SubcompUseOcManagerDefault;
			}
		}
		else
			DebugOutput(_T("SetupGetLineText failed.\n"));
	}

	return(dwMode);
}

DWORD GetUnattendedModeFromSetupMode(
			HANDLE	hUnattended,
			DWORD	dwComponent,
			LPCTSTR	szSubcomponent)
{
	BOOL		b = FALSE;
	TCHAR		szProperty[64];
	TCHAR		szLine[1024];
	DWORD		dwMode = SubcompUseOcManagerDefault;
	DWORD		dwSetupMode;

	DebugOutput(_T("GetUnattendedModeFromSetupMode %s"), szSubcomponent);

	// Try to get the line of interest
	if (hUnattended && (hUnattended != INVALID_HANDLE_VALUE))
	{
		dwSetupMode = GetIMSSetupMode();
		switch (dwSetupMode)
		{
		case IIS_SETUPMODE_MINIMUM:
		case IIS_SETUPMODE_TYPICAL:
		case IIS_SETUPMODE_CUSTOM:
			// One of the fresh modes
			lstrcpy(szProperty, _T("FreshMode"));
			break;

		case IIS_SETUPMODE_UPGRADEONLY:
		case IIS_SETUPMODE_ADDEXTRACOMPS:
			// One of the upgrade modes
			lstrcpy(szProperty, _T("UpgradeMode"));
			break;

		case IIS_SETUPMODE_ADDREMOVE:
		case IIS_SETUPMODE_REINSTALL:
		case IIS_SETUPMODE_REMOVEALL:
			// One of the maintenance modes
			lstrcpy(szProperty, _T("MaintanenceMode"));
			break;

		default:
			// Error! Use defaults
			return(SubcompUseOcManagerDefault);
		}

		// Get the specified line
		b = SetupGetLineText(
					NULL,
					hUnattended,
					_T("Global"),
					szProperty,
					szLine,
					sizeof(szLine),
					NULL);
		if (b)
		{
			DWORD dwOriginalMode;

			DebugOutput(_T("%s = %s\n"), szProperty, szLine);

			// See which setup mode we will end up with
			if (!lstrcmpi(szLine, _T("Minimal")))
				dwSetupMode = IIS_SETUPMODE_MINIMUM;
			else if (!lstrcmpi(szLine, _T("Typical")))
				dwSetupMode = IIS_SETUPMODE_TYPICAL;
			else if (!lstrcmpi(szLine, _T("Custom")))
				dwSetupMode = IIS_SETUPMODE_CUSTOM;
			else if (!lstrcmpi(szLine, _T("AddRemove")))
				dwSetupMode = IIS_SETUPMODE_ADDREMOVE;
			else if (!lstrcmpi(szLine, _T("RemoveAll")))
				dwSetupMode = IIS_SETUPMODE_REMOVEALL;
			else if (!lstrcmpi(szLine, _T("UpgradeOnly")))
				dwSetupMode = IIS_SETUPMODE_UPGRADEONLY;
			else if (!lstrcmpi(szLine, _T("AddExtraComps")))
				dwSetupMode = IIS_SETUPMODE_ADDEXTRACOMPS;
			else
				return(SubcompUseOcManagerDefault);

			// Get the custom unattended setting
			dwMode = GetUnattendedMode(hUnattended, szSubcomponent);

			// Do the right thing based on the setup mode
			SetIMSSetupMode(dwSetupMode);
			switch (dwSetupMode)
			{
			case IIS_SETUPMODE_MINIMUM:
			case IIS_SETUPMODE_TYPICAL:
				// Minimum & typical means the same:
				// Install all for SMTP, none for NNTP
				DebugOutput(_T("Unattended mode is MINIMUM/TYPICAL"));
				if (dwComponent == MC_IMS)
					dwMode = SubcompOn;
				else
					dwMode = SubcompOff;
				break;

			case IIS_SETUPMODE_CUSTOM:
				// For custom we use the custom setting
				DebugOutput(_T("Unattended mode is CUSTOM"));
				break;

			case IIS_SETUPMODE_UPGRADEONLY:
				// Return the original state
				DebugOutput(_T("Unattended mode is UPGRADEONLY"));
				dwMode = gHelperRoutines.QuerySelectionState(
						 gHelperRoutines.OcManagerContext,
						 szSubcomponent,
						 OCSELSTATETYPE_ORIGINAL) ? SubcompOn : SubcompOff;
				break;

			case IIS_SETUPMODE_ADDEXTRACOMPS:
				// Turn it on only if the old state is off and the
				// custom state is on
				DebugOutput(_T("Unattended mode is ADDEXTRACOMPS"));
				dwOriginalMode = gHelperRoutines.QuerySelectionState(
						 gHelperRoutines.OcManagerContext,
						 szSubcomponent,
						 OCSELSTATETYPE_ORIGINAL) ? SubcompOn : SubcompOff;
				if (dwOriginalMode == SubcompOff &&
					dwMode == SubcompOn)
					dwMode = SubcompOn;
				else
					dwMode = dwOriginalMode;
				break;

			case IIS_SETUPMODE_ADDREMOVE:
				// Return the custom setting
				DebugOutput(_T("Unattended mode is ADDREMOVE"));
				break;

			case IIS_SETUPMODE_REMOVEALL:
				// Kill everything
				DebugOutput(_T("Unattended mode is REMOVEALL"));
				dwMode = SubcompOff;
				break;
			}

			DebugOutput(_T("Unattended state for %s is %s"),
					szSubcomponent,
					(dwMode == SubcompOn)?_T("ON"):_T("OFF"));
		}
		else
			DebugOutput(_T("SetupGetLineText failed (%u).\n"), GetLastError());
	}

	return(dwMode);
}

BOOL DetectExistingSmtpServers()
{
    // Detect other mail servers
    CRegKey regMachine = HKEY_LOCAL_MACHINE;

    // System\CurrentControlSet\Services\MsExchangeIMC\Parameters
    CRegKey regSMTPParam( regMachine, REG_EXCHANGEIMCPARAMETERS, KEY_READ );
    if ((HKEY) regSMTPParam )
	{
		CString csCaption;

		DebugOutput(_T("IMC detected, suppressing SMTP"));

		if (!theApp.m_fIsUnattended && !theApp.m_fNTGuiMode)
		{
			MyLoadString(IDS_MESSAGEBOX_TEXT, csCaption);
			PopupOkMessageBox(IDS_SUPPRESS_SMTP, csCaption);
		}

		return(TRUE);
	}

	DebugOutput(_T("No other SMTP servers detected, installing IMS."));
	return(FALSE);
}

BOOL DetectExistingIISADMIN()
{
    //
    //  Detect is IISADMIN service exists
    //
    //  This is to make sure we don't do any metabase operation if
    //  IISADMIN doesn't exists, especially in the uninstall cases.
    //
    DWORD dwStatus = 0;
    dwStatus = InetQueryServiceStatus(SZ_MD_SERVICENAME);
    if (0 == dwStatus)
    {
        // some kind of error occur during InetQueryServiceStatus.
        DebugOutput(_T("DetectExistingIISADMIN() return FALSE\n"));
        return (FALSE);
    }

    return(TRUE);
}

BOOL InsertSetupString( LPCSTR REG_PARAMETERS )
{
    // set up registry values
    CRegKey regMachine = HKEY_LOCAL_MACHINE;

    // System\CurrentControlSet\Services\NNTPSVC\Parameters
    CRegKey regParam( (LPCTSTR) REG_PARAMETERS, regMachine );
    if ((HKEY) regParam) {
        regParam.SetValue( _T("MajorVersion"), (DWORD)STAXNT5MAJORVERSION );
        regParam.SetValue( _T("MinorVersion"), (DWORD)STAXNT5MINORVERSION );
        regParam.SetValue( _T("InstallPath"), theApp.m_csPathInetsrv );

        switch (theApp.m_eNTOSType) {
        case OT_NTW:
            regParam.SetValue( _T("SetupString"), REG_SETUP_STRING_NT5WKSB3 );
            break;

        default:
            _ASSERT(!"Unknown OS type");
            // Fall through

        case OT_NTS:
        case OT_PDC_OR_BDC:
        case OT_PDC:
        case OT_BDC:
            regParam.SetValue( _T("SetupString"), REG_SETUP_STRING_NT5SRVB3 );
            break;
        }
    }

    return TRUE;
}

// Scans a multi-sz and finds the first occurrence of the
// specified string
LPTSTR ScanMultiSzForSz(LPTSTR szMultiSz, LPTSTR szSz)
{
	LPTSTR lpTemp = szMultiSz;

	do
	{
		if (!lstrcmpi(lpTemp, szSz))
			return(lpTemp);

		lpTemp += lstrlen(lpTemp);
		lpTemp++;

	} while (*lpTemp != _T('\0'));

	return(NULL);
}

// Removes the said string from a MultiSz
// This places a lot of faith in the caller!
void RemoveSzFromMultiSz(LPTSTR szSz)
{
	LPTSTR lpScan = szSz;
	TCHAR  tcLastChar;

	lpScan += lstrlen(szSz);
	lpScan++;

	tcLastChar = _T('x');
	while ((tcLastChar != _T('\0')) ||
		   (*lpScan != _T('\0')))
	{
		tcLastChar = *lpScan;
		*szSz++ = *lpScan++;
	}

	*szSz++ = _T('\0');

	// Properly terminate it if it's the last one
	if (*lpScan == _T('\0'))
		*szSz = _T('\0');
}

// This walks the multi-sz and returns a pointer between
// the last string of a multi-sz and the second terminating
// NULL
LPTSTR GetEndOfMultiSz(LPTSTR szMultiSz)
{
	LPTSTR lpTemp = szMultiSz;

	do
	{
		lpTemp += lstrlen(lpTemp);
		lpTemp++;

	} while (*lpTemp != _T('\0'));

	return(lpTemp);
}

// This appends a string to the end of a multi-sz
// The buffer must be long enough
BOOL AppendSzToMultiSz(LPTSTR szMultiSz, LPTSTR szSz, DWORD dwMaxSize)
{
	LPTSTR szTemp = szMultiSz;
	DWORD dwLength = lstrlen(szSz);

	// If the string is empty, do not append!
	if (*szMultiSz == _T('\0') &&
		*(szMultiSz + 1) == _T('\0'))
		szTemp = szMultiSz;
	else
	{
		szTemp = GetEndOfMultiSz(szMultiSz);
		dwLength += (DWORD)(szTemp - szMultiSz);
	}

	if (dwLength >= dwMaxSize)
		return(FALSE);

	lstrcpy(szTemp, szSz);
	szMultiSz += dwLength;
	*szMultiSz = _T('\0');
	*(szMultiSz + 1) = _T('\0');
	return(TRUE);
}

BOOL AddServiceToDispatchList(LPTSTR szServiceName)
{
	TCHAR szMultiSz[4096];
	DWORD dwSize = 4096;
	
	CRegKey RegInetInfo(REG_INETINFOPARAMETERS, HKEY_LOCAL_MACHINE);
	if ((HKEY)RegInetInfo)
	{
		// Default to empty string if not exists
		szMultiSz[0] = _T('\0');
		szMultiSz[1] = _T('\0');

		if (RegInetInfo.QueryValue(SZ_INETINFODISPATCH, szMultiSz, dwSize) == NO_ERROR)
		{
			// Walk the list to see if the value is already there
			if (ScanMultiSzForSz(szMultiSz, szServiceName))
				return(TRUE);
		}

		// Create the value and add it to the list
		if (!AppendSzToMultiSz(szMultiSz, szServiceName, dwSize))
			return(FALSE);

		// Get the size of the new Multi-sz
		dwSize = (DWORD)(GetEndOfMultiSz(szMultiSz) - szMultiSz) + 1;

		// Write the value back to the registry
		if (RegInetInfo.SetValue(SZ_INETINFODISPATCH, szMultiSz, dwSize * (DWORD) sizeof(TCHAR)) == NO_ERROR)
			return(TRUE);
	}

	// If the InetInfo key is not here, there isn't much we can do ...
	return(FALSE);
}

BOOL RemoveServiceFromDispatchList(LPTSTR szServiceName)
{
	TCHAR szMultiSz[4096];
	DWORD dwSize = 4096;
	LPTSTR szTemp;
	BOOL fFound = FALSE;

	CRegKey RegInetInfo(HKEY_LOCAL_MACHINE, REG_INETINFOPARAMETERS);
	if ((HKEY)RegInetInfo)
	{
		if (RegInetInfo.QueryValue(SZ_INETINFODISPATCH, szMultiSz, dwSize) == NO_ERROR)
		{
			// Walk the list to see if the value is already there
			while (szTemp = ScanMultiSzForSz(szMultiSz, szServiceName))
			{
				RemoveSzFromMultiSz(szTemp);
				fFound = TRUE;
			}
		}

		// Write the value back to the registry if necessary, note we
		// will indicate success if the string is not found
		if (!fFound)
			return(TRUE);

		// Get the size of the new Multi-sz
		dwSize = (DWORD)(GetEndOfMultiSz(szMultiSz) - szMultiSz) + 1;

		// Write the value back to the registry
		if (RegInetInfo.SetValue(SZ_INETINFODISPATCH, szMultiSz, dwSize * (DWORD) sizeof(TCHAR)) == NO_ERROR)
			return(TRUE);
	}

	// If the InetInfo key is not here, there isn't much we can do ...
	return(FALSE);
}

void GetIISProgramGroup(CString &csGroupName, BOOL fIsMcisGroup)
{
	TCHAR	szName[_MAX_PATH];
	CString csTempName;
	UINT uType, uSize;

	if (fIsMcisGroup) {
		csGroupName = "";
	} else {
		// Get the NT program group name from the private data
		uSize = _MAX_PATH * sizeof(TCHAR);
#if 0
//11/30/98 - Don't even try to do this, just get the default
		if ((gHelperRoutines.GetPrivateData(gHelperRoutines.OcManagerContext,
									_T("iis"),
									_T("NTProgramGroup"),
									(LPVOID)szName,
									&uSize,
									&uType) != NO_ERROR) ||
			(uType != REG_SZ))
#endif
		{
			// We use the default group name
			MyLoadString(IDS_DEFAULT_NT_PROGRAM_GROUP, csTempName);
			lstrcpy(szName, csTempName.GetBuffer(_MAX_PATH));
	        csTempName.ReleaseBuffer();
		}
		csGroupName = szName;
		csGroupName += _T("\\");
	
		// Get the IIS program group name from the private data
		uSize = _MAX_PATH * sizeof(TCHAR);
#if 0
//11/30/98 - Don't even try to do this, just get the default
		if ((gHelperRoutines.GetPrivateData(gHelperRoutines.OcManagerContext,
									_T("iis"),
									_T("IISProgramGroup"),
									(LPVOID)szName,
									&uSize,
									&uType) != NO_ERROR) ||
			(uType != REG_SZ))
#endif
		{
			// We use the default group name
			MyLoadString(IDS_DEFAULT_IIS_PROGRAM_GROUP, csTempName);
			lstrcpy(szName, csTempName.GetBuffer(_MAX_PATH));
	        csTempName.ReleaseBuffer();
		}
		csGroupName += szName;
	}
}
	
void MyGetGroupPath(LPCTSTR szGroupName, LPTSTR szPath);

BOOL GetFullPathToProgramGroup(DWORD dwMainComponent, CString &csGroupName, BOOL fIsMcisGroup)
{
	// add items to the program group
	CString csTemp;
	TCHAR	szPath[MAX_PATH];

	// Get the program group name from the private data
	GetIISProgramGroup(csTemp, fIsMcisGroup);

    // Get the system path to this menu item
	MyGetGroupPath((LPCTSTR)csTemp, szPath);
	csGroupName = szPath;

	// Load up the resource string for the group
	if (fIsMcisGroup)
		MyLoadString(IDS_PROGGROUP_MCIS_MAIL_AND_NEWS, csTemp);
	else
		MyLoadString(dwMainComponent == MC_IMS?IDS_PROGGROUP_MAIL:IDS_PROGGROUP_NEWS, csTemp);

	// Build the program group
	csGroupName += csTemp;

	DebugOutput(_T("Program group loaded: %s"), (LPCTSTR)csGroupName);

	return(TRUE);
}

BOOL GetFullPathToAdminGroup(DWORD dwMainComponent, CString &csGroupName)
{
	// add items to the program group
	CString csTemp;
	TCHAR	szPath[MAX_PATH];

	// Get the program group name from the private data
	MyLoadString( IDS_PROGGROUP_ADMINTOOLS, csTemp );

    // Get the system path to this menu item
	MyGetGroupPath((LPCTSTR)csTemp, szPath);
	csGroupName = szPath;

	DebugOutput(_T("Program group loaded: %s"), (LPCTSTR)csGroupName);

	return(TRUE);
}

BOOL RemoveProgramGroupIfEmpty(DWORD dwMainComponent, BOOL fIsMcisGroup)
{
	// add items to the program group
	CString csGroupName;
	CString csTemp;
	TCHAR	szPath[MAX_PATH];
	BOOL	fResult;

	// Get the program group name from the private data
	GetIISProgramGroup(csTemp, fIsMcisGroup);

    // Get the system path to this menu item
	MyGetGroupPath((LPCTSTR)csTemp, szPath);
	csGroupName = szPath;

	// Load up the resource string for the group
	if (fIsMcisGroup)
		MyLoadString(IDS_PROGGROUP_MCIS_MAIL_AND_NEWS, csTemp);
	else
		MyLoadString(dwMainComponent == MC_IMS?IDS_PROGGROUP_MAIL:IDS_PROGGROUP_NEWS, csTemp);

	// Build the program group
	csGroupName += csTemp;

	DebugOutput(_T("Removing Program group: %s"), (LPCTSTR)csGroupName);

    fResult = RemoveDirectory((LPCTSTR)csGroupName);
	if (fResult && fIsMcisGroup)
	{
		SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, (LPCTSTR)csGroupName, 0);

		csGroupName = szPath;
		MyLoadString(IDS_MCIS_2_0, csTemp);
		csGroupName += csTemp;
		fResult = RemoveDirectory((LPCTSTR)csGroupName);
	}
	if (fResult)
	{
	    SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, (LPCTSTR)csGroupName, 0);
	}

	return(fResult);
}

BOOL CreateInternetShortcut(DWORD dwMainComponent, int dwDisplayNameId, int dwUrlId, BOOL fIsMcisGroup)
{
	CString csItemPath;
	CString csDisplayName;
	CString csUrl;
	HANDLE	hShortcut;
	DWORD	dwLength, dwWritten;
	char	szBuffer[1000];
	char	szContent[1024];
	BOOL	fRet = FALSE;

	MyLoadString(dwDisplayNameId, csDisplayName);
	MyLoadString(dwUrlId, csUrl);

	// Build the full path to the program link
	GetFullPathToProgramGroup(dwMainComponent, csItemPath, fIsMcisGroup);

	// Make sure our directory is there
	CreateLayerDirectory(csItemPath);

	csItemPath += _T("\\");
	csItemPath += csDisplayName;
	csItemPath += _T(".url");

	DebugOutput(_T("Creating shortcut file: %s"), (LPCTSTR)csItemPath);

	// Create the file in the directory
	hShortcut = CreateFile((LPCTSTR)csItemPath,
								GENERIC_WRITE, 0,
								NULL, CREATE_ALWAYS,
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
								NULL);
	if (hShortcut == INVALID_HANDLE_VALUE)
	{
		DebugOutput(_T("CreateFile failed with error %u\n"), GetLastError());
		return(fRet);
	}

	// Convert the Unicode string to ANSI
	if (WideCharToMultiByte(CP_ACP, 0,
                               (LPCTSTR)csUrl,
                               -1,
                               szBuffer,
                               sizeof(szBuffer),
                               NULL, NULL))
	{
		dwLength = sprintf(szContent, "[InternetShortcut]\nURL=http://localhost/%s\n", szBuffer);
		DebugOutput(_T("	Shortcut: %s"), (LPCTSTR)csUrl);
		if (dwLength)
		{
			if (WriteFile(hShortcut, szContent, dwLength, &dwWritten, NULL) &&
				(dwWritten == dwLength))
			{
			    SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, (LPCTSTR)csItemPath, 0);
				fRet = TRUE;
			}
		}
	}
	else
	{
		DebugOutput(_T("WideCharToMultiByte failed with error %u\n"), GetLastError());
	}
	CloseHandle(hShortcut);
	return(fRet);
}

#if 0 // Dead code
BOOL CreateNt5InternetShortcut(DWORD dwMainComponent, int dwDisplayNameId, int dwUrlId)
{
	CString csItemPath;
	CString csDisplayName;
	CString csUrl;
	HANDLE	hShortcut;
	DWORD	dwLength, dwWritten;
	char	szBuffer[1000];
	char	szContent[1024];
	BOOL	fRet = FALSE;

	MyLoadString(dwDisplayNameId, csDisplayName);
	MyLoadString(dwUrlId, csUrl);

	// Build the full path to the program link
	GetFullPathToAdminGroup(dwMainComponent, csItemPath);

	// Make sure our directory is there
	CreateLayerDirectory(csItemPath);

	csItemPath += _T("\\");
	csItemPath += csDisplayName;
	csItemPath += _T(".url");

	DebugOutput(_T("Creating shortcut file: %s"), (LPCTSTR)csItemPath);

	// Create the file in the directory
	hShortcut = CreateFile((LPCTSTR)csItemPath,
								GENERIC_WRITE, 0,
								NULL, CREATE_ALWAYS,
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
								NULL);
	if (hShortcut == INVALID_HANDLE_VALUE)
	{
		DebugOutput(_T("CreateFile failed with error %u\n"), GetLastError());
		return(fRet);
	}

	// Convert the Unicode string to ANSI
	if (WideCharToMultiByte(CP_ACP, 0,
                               (LPCTSTR)csUrl,
                               -1,
                               szBuffer,
                               sizeof(szBuffer),
                               NULL, NULL))
	{
		dwLength = sprintf(szContent, "[InternetShortcut]\nURL=http://localhost/%s\n", szBuffer);
		DebugOutput(_T("	Shortcut: %s"), (LPCTSTR)csUrl);
		if (dwLength)
		{
			if (WriteFile(hShortcut, szContent, dwLength, &dwWritten, NULL) &&
				(dwWritten == dwLength))
			{
			    SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, (LPCTSTR)csItemPath, 0);
				fRet = TRUE;
			}
		}
	}
	else
	{
		DebugOutput(_T("WideCharToMultiByte failed with error %u\n"), GetLastError());
	}
	CloseHandle(hShortcut);
	return(fRet);
}
#endif

BOOL RemoveInternetShortcut(DWORD dwMainComponent, int dwDisplayNameId, BOOL fIsMcisGroup)
{
	CString csItemPath;
	CString csDisplayName;

	MyLoadString(dwDisplayNameId, csDisplayName);

	// Build the full path to the program link
	GetFullPathToProgramGroup(dwMainComponent, csItemPath, fIsMcisGroup);
	csItemPath += _T("\\");
	csItemPath += csDisplayName;
	csItemPath += _T(".url");

	DebugOutput(_T("Removing shortcut file: %s"), (LPCTSTR)csItemPath);

	DeleteFile((LPCTSTR)csItemPath);
    SHChangeNotify(SHCNE_DELETE, SHCNF_PATH, (LPCTSTR)csItemPath, 0);

	RemoveProgramGroupIfEmpty(dwMainComponent, fIsMcisGroup);
	return(TRUE);
}

BOOL RemoveNt5InternetShortcut(DWORD dwMainComponent, int dwDisplayNameId)
{
	CString csItemPath;
	CString csDisplayName;

	MyLoadString(dwDisplayNameId, csDisplayName);

	// Build the full path to the program link
	GetFullPathToAdminGroup(dwMainComponent, csItemPath);
	csItemPath += _T("\\");
	csItemPath += csDisplayName;
	csItemPath += _T(".url");

	DebugOutput(_T("Removing shortcut file: %s"), (LPCTSTR)csItemPath);

	DeleteFile((LPCTSTR)csItemPath);
    SHChangeNotify(SHCNE_DELETE, SHCNF_PATH, (LPCTSTR)csItemPath, 0);

#if 0
	RemoveProgramGroupIfEmpty(dwMainComponent,FALSE);
#endif
	return(TRUE);
}

BOOL RemoveMCIS10MailProgramGroup()
{
	CString csGroupName;
	CString csNiceName;

	MyLoadString(IDS_PROGGROUP_MCIS10_MAIL, csGroupName);

	MyLoadString(IDS_PROGITEM_MCIS10_MAIL_STARTPAGE, csNiceName);
	MyDeleteItem(csGroupName, csNiceName);

	MyLoadString(IDS_PROGITEM_MCIS10_MAIL_WEBADMIN, csNiceName);
	MyDeleteItemEx(csGroupName, csNiceName);

	return(TRUE);
}

BOOL RemoveMCIS10NewsProgramGroup()
{
	CString csGroupName;
	CString csNiceName;

    // BINLIN:
    // BUGBUG: need to figure out how to get
    // the old MCIS 1.0 program group path
	MyLoadString(IDS_PROGGROUP_MCIS10_NEWS, csGroupName);

	MyLoadString(IDS_PROGITEM_MCIS10_NEWS_STARTPAGE, csNiceName);
	MyDeleteItem(csGroupName, csNiceName);

	MyLoadString(IDS_PROGITEM_MCIS10_NEWS_WEBADMIN, csNiceName);
	MyDeleteItemEx(csGroupName, csNiceName);

	return(TRUE);
}

BOOL CreateUninstallEntries(LPCTSTR szInfFile, LPCTSTR szDisplayName)
{
	// We have one or more components installed, so we
	// will create the Add/Remove options in the control panel
	CString csUninstall;
	CString AddRemoveRegPath = REG_UNINSTALL;

	AddRemoveRegPath += _T("\\");
	AddRemoveRegPath += szInfFile;
	csUninstall = theApp.m_csSysDir + _T("\\sysocmgr.exe /i:");
	csUninstall += theApp.m_csSysDir;
	csUninstall += _T("\\setup\\");
	csUninstall += szInfFile;

	CRegKey regAddRemove(AddRemoveRegPath, HKEY_LOCAL_MACHINE);
	if ( (HKEY)regAddRemove )
	{
		regAddRemove.SetValue( _T("DisplayName"), szDisplayName );
		regAddRemove.SetValue( _T("UninstallString"), csUninstall );
	}
	else
		return(FALSE);
	return(TRUE);
}

BOOL RemoveUninstallEntries(LPCTSTR szInfFile)
{
	// All components are removed, we will have to remove
	// the Add/Remove option from the control panel
	CRegKey regUninstall( HKEY_LOCAL_MACHINE, REG_UNINSTALL);
	if ((HKEY)regUninstall)
		regUninstall.DeleteTree(szInfFile);
	else
		return(FALSE);
	return(TRUE);
}

void SetProductName()
{
    // The product name is rather complicated ...
	CString csProdName, csAppName;

	if (theApp.m_hInfHandle[MC_IMS] && theApp.m_hInfHandle[MC_INS])
	{
		MyLoadString(IDS_MAIL_AND_NEWS, csProdName);
		MyLoadString(IDS_MAIL_AND_NEWS_SETUP, csAppName);
	}
	else if (theApp.m_hInfHandle[MC_IMS])
	{
// NT5 - For SMTP, use the default K2 name
		if (theApp.m_fIsMcis)
		{
			MyLoadString(IDS_MCIS_MAIL_ONLY, csProdName);
			MyLoadString(IDS_MCIS_MAIL_ONLY_SETUP, csAppName);
		}
		else
		{
			MyLoadString(IDS_MAIL_ONLY, csProdName);
			MyLoadString(IDS_MAIL_ONLY_SETUP, csAppName);
		}
	}
	else
	{
// NT5 - Use m_eNTOSType.
// TODO: Need to figure out the name for NT5 Server and NT5 Workstation NNTP service
		if (theApp.m_eNTOSType == OT_NTS)
		{
			MyLoadString(IDS_MCIS_NEWS_ONLY, csProdName);
			MyLoadString(IDS_MCIS_NEWS_ONLY_SETUP, csAppName);
		}
		else
		{
			MyLoadString(IDS_NEWS_ONLY, csProdName);
			MyLoadString(IDS_NEWS_ONLY_SETUP, csAppName);
		}
	}

    // Setup the name for the IIS Program group
	MyLoadString(IDS_MAIL_AND_NEWS, theApp.m_csGroupName);

	theApp.m_csProdName = csProdName;
	theApp.m_csAppName = csAppName;
}

HRESULT MyCreateLink(LPCTSTR lpszPath, LPCTSTR lpszArgs, LPCTSTR lpszTarget, LPCTSTR lpszDir)
{
    HRESULT hres;
    IShellLink* pShellLink;

    CoInitialize(NULL);
    //CoInitialize must be called before this
    // Get a pointer to the IShellLink interface.
    hres = CoCreateInstance(   CLSID_ShellLink,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IShellLink,
                               (LPVOID*)&pShellLink);
    if (SUCCEEDED(hres))
    {
       IPersistFile* pPersistFile;

       // Set the path to the shortcut target, and add the description.
       pShellLink->SetPath(lpszPath);
       pShellLink->SetArguments(lpszArgs);
       pShellLink->SetWorkingDirectory(lpszDir);


       // Query IShellLink for the IPersistFile interface for saving the
       // shortcut in persistent storage.
       hres = pShellLink->QueryInterface(IID_IPersistFile, (LPVOID*)&pPersistFile);

       if (SUCCEEDED(hres))
       {
          WCHAR wsz[MAX_PATH];

#if defined(UNICODE) || defined(_UNICODE)
          lstrcpy(wsz, lpszTarget);
#else
          // Ensure that the string is WCHAR.
          MultiByteToWideChar( CP_ACP,
                               0,
                               lpszTarget,
                               -1,
                               wsz,
                               MAX_PATH);
#endif

          // Save the link by calling IPersistFile::Save.
          hres = pPersistFile->Save(wsz, TRUE);

          pPersistFile->Release();
       }

       pShellLink->Release();
    }
    CoUninitialize();
    return hres;
}

BOOL MyDeleteLink(LPTSTR lpszShortcut)
{
    TCHAR  szFile[_MAX_PATH];
    SHFILEOPSTRUCT fos;

    ZeroMemory(szFile, sizeof(szFile));
    lstrcpy(szFile, lpszShortcut);

    // only call SHFileOperation if this file/link exists
    if (0xFFFFFFFF != GetFileAttributes(szFile))
    {
        ZeroMemory(&fos, sizeof(fos));
        fos.hwnd = NULL;
        fos.wFunc = FO_DELETE;
        fos.pFrom = szFile;
        fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;
        SHFileOperation(&fos);
    }

    return TRUE;
}

void MyGetGroupPath(LPCTSTR szGroupName, LPTSTR szPath)
{
    int            nLen = 0;
    LPITEMIDLIST   pidlPrograms;

    szPath[0] = NULL;

    SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, &pidlPrograms);

    SHGetPathFromIDList(pidlPrograms, szPath);
    nLen = lstrlen(szPath);
    if (szGroupName) {
        if (nLen == 0 || szPath[nLen-1] != _T('\\'))
            lstrcat(szPath, _T("\\"));
        lstrcat(szPath, szGroupName);
    }
    return;
}

BOOL MyAddGroup(LPCTSTR szGroupName)
{
    TCHAR szPath[MAX_PATH];
	CString csPath;

    MyGetGroupPath(szGroupName, szPath);
	csPath = szPath;
    CreateLayerDirectory(csPath);
    SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, szPath, 0);

    return TRUE;
}

BOOL MyIsGroupEmpty(LPCTSTR szGroupName)
{
    TCHAR             szPath[MAX_PATH];
    TCHAR             szFile[MAX_PATH];
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    BOOL              bFindFile = TRUE;
    BOOL              fReturn = TRUE;

    MyGetGroupPath(szGroupName, szPath);

    lstrcpy(szFile, szPath);
    lstrcat(szFile, _T("\\*.*"));

    hFind = FindFirstFile(szFile, &FindData);
    if (INVALID_HANDLE_VALUE != hFind)
    {
       while (bFindFile)
       {
           if(*(FindData.cFileName) != _T('.'))
           {
               fReturn = FALSE;
               break;
           }

           //find the next file
           bFindFile = FindNextFile(hFind, &FindData);
       }

       FindClose(hFind);
    }

    return fReturn;
}

BOOL MyDeleteGroup(LPCTSTR szGroupName)
{
    TCHAR             szPath[MAX_PATH];
    TCHAR             szFile[MAX_PATH];
    SHFILEOPSTRUCT    fos;
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    BOOL              bFindFile = TRUE;
	BOOL			  fResult;

    MyGetGroupPath(szGroupName, szPath);

    //we can't remove a directory that is not empty, so we need to empty this one

    lstrcpy(szFile, szPath);
    lstrcat(szFile, _T("\\*.*"));

    ZeroMemory(&fos, sizeof(fos));
    fos.hwnd = NULL;
    fos.wFunc = FO_DELETE;
    fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;

    hFind = FindFirstFile(szFile, &FindData);
    if (INVALID_HANDLE_VALUE != hFind)
    {
       while (bFindFile)
       {
           if(*(FindData.cFileName) != _T('.'))
           {
              //copy the path and file name to our temp buffer
              lstrcpy(szFile, szPath);
              lstrcat(szFile, _T("\\"));
              lstrcat(szFile, FindData.cFileName);
              //add a second NULL because SHFileOperation is looking for this
              lstrcat(szFile, _T("\0"));

              //delete the file
              fos.pFrom = szFile;
              SHFileOperation(&fos);
          }
          //find the next file
          bFindFile = FindNextFile(hFind, &FindData);
       }
       FindClose(hFind);
    }

    fResult = RemoveDirectory(szPath);
	if (fResult)
	{
	    SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, szPath, 0);
	}

	return(fResult);
}

void MyAddItem(LPCTSTR szGroupName, LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir)
{
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    if (!IsFileExist(szPath))
        MyAddGroup(szGroupName);

    lstrcat(szPath, _T("\\"));
    lstrcat(szPath, szItemDesc);
    lstrcat(szPath, _T(".lnk"));

    MyCreateLink(szProgram, szArgs, szPath, szDir);
}

void MyDeleteItem(LPCTSTR szGroupName, LPCTSTR szAppName)
{
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    lstrcat(szPath, _T("\\"));
    lstrcat(szPath, szAppName);
    lstrcat(szPath, _T(".lnk"));

    MyDeleteLink(szPath);

    if (MyIsGroupEmpty(szGroupName))
        MyDeleteGroup(szGroupName);
}

// Use to delete files with extension other than ".lnk"
void MyDeleteItemEx(LPCTSTR szGroupName, LPCTSTR szAppName)
{
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    lstrcat(szPath, _T("\\"));
    lstrcat(szPath, szAppName);

    MyDeleteLink(szPath);

    if (MyIsGroupEmpty(szGroupName))
        MyDeleteGroup(szGroupName);
}

BOOL CreateISMLink()
{
	// add items to the program group
	CString csGroupName;
 	CString csNiceName;
 	CString csArgs;
 	CString csTemp;
	CString csMmc;

	DebugOutput(_T("Creating ISM link ..."));

	// Get the program group name from the private data
	GetIISProgramGroup(csGroupName, TRUE);

	MyLoadString(IDS_PROGGROUP_MCIS_MAIL_AND_NEWS, csTemp);
	MyLoadString(IDS_MMC, csMmc);
	MyLoadString(IDS_ITEMPATH_ISM, csArgs);

	// Build the program group
	csGroupName += csTemp;

	MyLoadString(IDS_PROGITEM_ISM, csNiceName);
	MyAddItem(csGroupName, csNiceName, csMmc, csArgs, NULL);

	return(TRUE);
}

BOOL RemoveISMLink()
{
	// add items to the program group
	CString csGroupName;
 	CString csNiceName;
 	CString csTemp;

	DebugOutput(_T("Removing ISM link ..."));

	// Get the program group name from the private data
	GetIISProgramGroup(csGroupName, TRUE);

	MyLoadString(IDS_PROGGROUP_MCIS_MAIL_AND_NEWS, csTemp);

	// Build the program group
	csGroupName += csTemp;

	MyLoadString(IDS_PROGITEM_ISM, csNiceName);
	MyDeleteItem(csGroupName, csNiceName);

	return(TRUE);
}

class CDwordQueue
{
  private:
	DWORD	dwInstances;
	DWORD	dwDequeuePtr;
	DWORD	dwMaxInstances;
	DWORD_PTR *rgdwInstanceIds;

  public:
    CDwordQueue()
	{
		dwInstances = 0;
		dwMaxInstances = 0;
		dwDequeuePtr = 0;
		rgdwInstanceIds = NULL;
	}
	~CDwordQueue()
	{
		if (rgdwInstanceIds)
		{
			LocalFree(rgdwInstanceIds);
			rgdwInstanceIds = NULL;
		}
	}

	BOOL QueueDword(DWORD_PTR dwValue);
	BOOL DequeueDword(PDWORD_PTR pdwValue);

};

BOOL CDwordQueue::QueueDword(DWORD_PTR dwValue)
{
	if (dwInstances == dwMaxInstances)
	{
		if (!dwMaxInstances)
			dwMaxInstances = 1024;
		else
			dwMaxInstances <<= 1;

		if (rgdwInstanceIds)
		{
			DWORD_PTR *pdwNew;

			pdwNew = (PDWORD_PTR)LocalReAlloc(rgdwInstanceIds,
									dwMaxInstances * sizeof(DWORD_PTR),
									0);
			if (!pdwNew)
				return(FALSE);

			rgdwInstanceIds = pdwNew;
		}
		else
		{
			rgdwInstanceIds = (PDWORD_PTR)LocalAlloc(0,
									dwMaxInstances * sizeof(DWORD_PTR));
			if (!rgdwInstanceIds)
				return(FALSE);
		}
	}
	rgdwInstanceIds[dwInstances++] = dwValue;
	return(TRUE);
}

BOOL CDwordQueue::DequeueDword(PDWORD_PTR pdwValue)
{
	if (dwDequeuePtr >= dwInstances)
		return(FALSE);
	*pdwValue = rgdwInstanceIds[dwDequeuePtr++];
	return(TRUE);
}

BOOL UpdateServiceParameters(LPCTSTR szServiceName)
{
	CString	csKeyName;
	CMDKey	mKey;
	CString		csInstance;
	CString		csParameters;
	CDwordQueue	dwqQueue;

	csKeyName = _T("LM/");
	csKeyName += szServiceName;

	mKey.OpenNode((LPCTSTR)csKeyName);
    if ( (METADATA_HANDLE)mKey )
	{
		CMDKeyIter	enumKey(mKey);

		enumKey.Reset();

		// Process all instances
		while (enumKey.Next(&csInstance) == NO_ERROR)
		{
			if (dwqQueue.QueueDword(_ttol((LPCTSTR)csInstance)))
				DebugOutput(_T("Read instance #%s"), (LPCTSTR)csInstance);
			else
				DebugOutput(_T("Error allocating buffer, skipping remaining instances"));
		}
	}

	mKey.Close();

	CMDKey	mInstKey;
	CMDKey	mParamKey;
	METADATA_RECORD	mdRec;
	DWORD_PTR i;
    DWORD dwIndex = 0;
	BYTE	pBuffer[2048];

	while (dwqQueue.DequeueDword(&i))
	{
		// Build "LM/*Svc/#"
		csInstance.Format(_T("%s/%u"),
							(LPCTSTR)csKeyName,
							(DWORD)i);

		csParameters = csInstance + _T("/Parameters");

		DebugOutput(_T("Processing %s ..."), (LPCTSTR)csParameters);

		dwIndex = 0;
		while (1)
		{
			mParamKey.OpenNode(csParameters);
			if ( (METADATA_HANDLE)mParamKey )
			{
				mdRec.dwMDIdentifier = 0;
				mdRec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
				mdRec.dwMDUserType = 0;
				mdRec.dwMDDataType = 0;
				mdRec.dwMDDataLen = sizeof(pBuffer);
				mdRec.pbMDData = pBuffer;

				// Get the next value
				if (!mParamKey.EnumData(dwIndex++, &mdRec))
				{
					mParamKey.Close();
					break;
				}
				mParamKey.Close();

				DebugOutput(_T("Read %s/%u"),
							(LPCTSTR)csParameters,
							mdRec.dwMDIdentifier);

				// Migrate the value from the parameters level
				// to instance level
				mInstKey.OpenNode(csInstance);
				if ( (METADATA_HANDLE)mInstKey )
				{
					DebugOutput(_T("Writing %s/%u"),
								(LPCTSTR)csInstance,
								mdRec.dwMDIdentifier);
					mInstKey.SetData(&mdRec);
					mInstKey.Close();
				}
				else
				{
					DebugOutput(_T("ERROR: Failed to open %s for writing"), csInstance);
				}
			}
			else
			{
				DebugOutput(_T("Failed to open %s for enumeration"), csParameters);
				break;
			}

		}
	}

	// Delete the parameters key
	mInstKey.OpenNode(csInstance);
	if ( (METADATA_HANDLE)mInstKey )
	{
		mInstKey.DeleteNode(_T("Parameters"));
		mInstKey.Close();
	}

	return(TRUE);
}

BOOL rRemapKey(CString &csBaseName, DWORD dwBase, DWORD dwRegionSize, DWORD dwNewBase)
{
	CString			csPathName;
	CMDKey			mKey;
	METADATA_RECORD	mdRec;
	DWORD			dwIndex = 0;
	DWORD_PTR		dwId;
	BYTE			pBuffer[2048];

	DebugOutput(_T("Remapping values under %s..."), (LPCTSTR)csBaseName);

	mKey.OpenNode((LPCTSTR)csBaseName);
    if (!(METADATA_HANDLE)mKey)
	{
		DebugOutput(_T("ERROR: Unable to open %s"), (LPCTSTR)csBaseName);
		return(FALSE);
	}

	// Use pre-order traversal to remap all the IDs
	{
		CDwordQueue		dwqRemap;

		while (1)
		{
			mdRec.dwMDIdentifier = 0;
			mdRec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
			mdRec.dwMDUserType = 0;
			mdRec.dwMDDataType = 0;
			mdRec.dwMDDataLen = sizeof(pBuffer);
			mdRec.pbMDData = pBuffer;

			// Get the next value
			if (!mKey.EnumData(dwIndex++, &mdRec))
				break;

			// See if this is a record that we will have to migrate
			dwId = mdRec.dwMDIdentifier;
			DebugOutput(_T("Remapping %u if necessary ..."), (DWORD)dwId);
			if ((dwId >= dwBase) &&
				((dwId - dwBase) < dwRegionSize))
			{
				DebugOutput(_T("Id %u scheduled for remapping"), (DWORD)dwId);
				dwqRemap.QueueDword(dwId);
			}
		}

		while (dwqRemap.DequeueDword(&dwId))
		{
			// Remap value
			mdRec.dwMDIdentifier = (DWORD)dwId;
			mdRec.dwMDAttributes = 0;
			mdRec.dwMDUserType = 0;
			mdRec.dwMDDataType = 0;
			mdRec.dwMDDataLen = sizeof(pBuffer);
			mdRec.pbMDData = pBuffer;
			mKey.GetData(&mdRec);

			mdRec.dwMDIdentifier = ((DWORD)dwId - dwBase) + dwNewBase;
			DebugOutput(_T("Remapping from %u to %u"), (DWORD)dwId,
							mdRec.dwMDIdentifier);
			mKey.SetData(&mdRec);

			// Delete the original data
			mKey.DeleteData((DWORD)dwId, mdRec.dwMDDataType);
		}
	}

	CMDKeyIter	enumKey(mKey);
	LPTSTR		pName;
	CDwordQueue		dwqQueue;

	enumKey.Reset();
	while(enumKey.Next(&csPathName) == NO_ERROR)
	{
		pName = (LPTSTR)LocalAlloc(0, (csPathName.GetLength() + 1) * sizeof(TCHAR));

		if (pName)
		{
			lstrcpy(pName, (LPCTSTR)csPathName);
			dwqQueue.QueueDword((DWORD_PTR)pName);
		}
	}
	mKey.Close();

	while (dwqQueue.DequeueDword((PDWORD_PTR)&pName))
	{
		csPathName = _T("/");
		csPathName += pName;
		csPathName = csBaseName + csPathName;

		// Traverse all subnodes of this tree
		rRemapKey(csPathName, dwBase, dwRegionSize, dwNewBase);

		LocalFree(pName);
	}

	return(TRUE);
}

BOOL RemapServiceParameters(LPCTSTR szServiceName, DWORD dwBase, DWORD dwRegionSize, DWORD dwNewBase)
{
	CString	csKeyName;
	CMDKey	mKey;

	csKeyName = _T("LM/");
	csKeyName += szServiceName;

	// Recursively walk the tree
	rRemapKey(csKeyName, dwBase, dwRegionSize, dwNewBase);

	return(TRUE);
}

void GetInetpubPathFromMD(CString& csPathInetpub)
{
    TCHAR   szw3root[] = _T("\\wwwroot");
    TCHAR   szPathInetpub[_MAX_PATH];

    ZeroMemory( szPathInetpub, sizeof(szPathInetpub) );

    CMDKey W3Key;
    DWORD  dwScratch;
    DWORD  dwType;
    DWORD  dwLength;

    // Get W3Root path
    W3Key.OpenNode(_T("LM/W3Svc/1/Root"));
    if ( (METADATA_HANDLE)W3Key )
    {
        dwLength = _MAX_PATH;

        if (W3Key.GetData(3001, &dwScratch, &dwScratch,
                          &dwType, &dwLength, (LPBYTE)szPathInetpub))
        {
            if (dwType == STRING_METADATA)
            {
                dwScratch = lstrlen(szw3root);
                dwLength = lstrlen(szPathInetpub);

                // If it ends with "\\wwwroot", then we copy the prefix into csPathInetpub
                if ((dwLength > dwScratch) &&
                    !lstrcmpi(szPathInetpub + (dwLength - dwScratch), szw3root))
                {
                    csPathInetpub.Empty();
                    lstrcpyn( csPathInetpub.GetBuffer(512), szPathInetpub, (dwLength - dwScratch + 1));
                    csPathInetpub.ReleaseBuffer();
                }

                // otherwise fall back to use the default...
            }
        }
        W3Key.Close();
    }

    return;

}

BOOL GetActionFromCheckboxStateOnly(LPCTSTR SubcomponentId, ACTION_TYPE *pAction)
{
	DWORD State = 0;
	DWORD OldState = 0;

    *pAction = AT_DO_NOTHING;

	// Get the check box state
	State = gHelperRoutines.QuerySelectionState(
						gHelperRoutines.OcManagerContext,
						SubcomponentId,
						OCSELSTATETYPE_CURRENT
						);
	if (GetLastError() != NO_ERROR)
	{
		DebugOutput(_T("Failed to get current state for <%s> (%u)"),
						SubcomponentId, GetLastError());
		State = 0;
	}

    // Check orignal state
    OldState = gHelperRoutines.QuerySelectionState(
						gHelperRoutines.OcManagerContext,
						SubcomponentId,
						OCSELSTATETYPE_ORIGINAL
						);
	if (GetLastError() != NO_ERROR)
	{
		DebugOutput(_T("Failed to get original state for <%s> (%u)"),
						SubcomponentId, GetLastError());
		OldState = 0;
	}

	if (State && !OldState)
	{
		// Change in state from OFF->ON = install docs
		*pAction = AT_FRESH_INSTALL;

		DebugOutput(_T("Installing subcomponent <%s>"), SubcomponentId);
	}
    else if (!State && OldState)
    {
		// Change in state from ON->OFF = uninstall docs
		*pAction = AT_REMOVE;

		DebugOutput(_T("Removing subcomponent <%s>"), SubcomponentId);
    }
	else if (State && OldState &&
			(GetIMSSetupMode() == IIS_SETUPMODE_REINSTALL))
	{
		// Reinstall if that's the current mode
		*pAction = AT_REINSTALL;

		DebugOutput(_T("Reinstalling subcomponent <%s>"), SubcomponentId);
	}

	return(TRUE);
}

enum DOMAIN_ROUTE_ACTION_TYPE
{
	SMTP_NO_ACTION,
	SMTP_DROP,
	SMTP_SMARTHOST,
	SMTP_SSL,
	SMTP_ALIAS,
	SMTP_DELIVER,
	SMTP_DEFAULT,
	LAST_SMTP_ACTION
};

const DWORD rgdwMapping[LAST_SMTP_ACTION] =
{
	0x0, 0x1, 0x2, 0x4, 0x10, 0x20, 0x40
};

const DWORD dwEtrnFlag = 0x200;

#define SMTP_MD_ID(x)			(0x9000 + (x))
#define _TAB					_T('\t')
#define _NULL					_T('\0')
#define _COMMA					_T(',')

BOOL ReformatDomainRoutingEntries(LPCTSTR szServiceName)
{
	CString	csKeyName;
	CString csDomainName;
	CString csActionType;
	CString csDomainRoute;
	CMDKey	mKey;
	METADATA_RECORD	mdRec;
	TCHAR	MultiSz[1024];
	DWORD	cbMultiSz = 1024;
	LPTSTR	Ptr;

	csKeyName = _T("LM/");
	csKeyName += szServiceName;
	csKeyName += _T("/1");

	// Open the node
	mKey.OpenNode((LPCTSTR)csKeyName);
    if (!(METADATA_HANDLE)mKey)
	{
		DebugOutput(_T("ERROR: Unable to open %s"), (LPCTSTR)csKeyName);
		return(FALSE);
	}

	// Get the domain routing MULTISZ value
	mdRec.dwMDIdentifier = SMTP_MD_ID(56);
	mdRec.dwMDAttributes = 0;
	mdRec.dwMDUserType = 0;
	mdRec.dwMDDataType = 0;
	mdRec.dwMDDataLen = cbMultiSz;
	mdRec.pbMDData = (LPBYTE)MultiSz;
	if (!mKey.GetData(&mdRec))
	{
		DebugOutput(_T("ERROR: Unable to GetData on %u. We will not migrate Domain Routes."),
					mdRec.dwMDIdentifier);
		return(FALSE);
	}

	// Close it so we can open a child later
	mKey.Close();

	DebugOutput(_T("Processing Domain routes ..."));

	// This is the base name for all domain routes
	csKeyName += _T("/Domain/");
	Ptr = MultiSz;
    while (Ptr && *Ptr)
    {
        do
        {
            TCHAR szDomainName[325];
            TCHAR szActionType[MAX_PATH + 1];
            TCHAR szValue[256];
            int i, Action, NewAction;
            BOOL UseEtrn;

            szDomainName[0] = _NULL;
            szValue[0] = _NULL;
            szActionType[0] = _NULL;

            // skip whitespace
            while( (*Ptr != _NULL) && (isspace (*Ptr) || (*Ptr == _TAB)))
                Ptr++;

            if(*Ptr == _NULL)
                break;

            //get the Action
            for (i = 0; *Ptr != 0 && *Ptr != _COMMA && i < 255; Ptr++)
            {
                szValue[i++] = *Ptr;
            }

            //null terminate
            szValue[i] = _NULL;
            Action = _wtoi(szValue);
            if( (Action == 0) || (Action >= (int) LAST_SMTP_ACTION) || (*Ptr == _NULL))
            {
                DebugOutput(_T("%d is an invalid action"), Action);

                //unknown action type
                break;
            }

			DebugOutput(_T("Action = %u"), Action);

            //skip ,
            Ptr++;

            // skip whitespace
            while( (*Ptr != _NULL) && (isspace (*Ptr) || (*Ptr == _TAB)))
                Ptr++;

            //get the Domain
            for (i = 0; *Ptr != 0 && *Ptr != _COMMA && i < 324; Ptr++)
            {
                szDomainName[i++] = *Ptr;
            }

            szDomainName[i] = _NULL;
			csDomainName = szDomainName;

            //check for bad data
            if(szDomainName[0] == _NULL)
            {
                DebugOutput(_T("Found a NULL domain. Breaking out"));
                break;
            }

			DebugOutput(_T("Domain = %s"), szDomainName);

            //skip ,
            Ptr++;

            //get the Action
            for (i = 0; Ptr != NULL && *Ptr != 0 && *Ptr != _COMMA && i < MAX_PATH; Ptr++)
            {
                szActionType[i++] = *Ptr;
            }

            szActionType[i] = _NULL;
			csActionType = szActionType;

			DebugOutput(_T("Action Type = %s"), szActionType);

            //skip ,
            Ptr++;

            // skip whitespace
            while( (*Ptr != _NULL) && (isspace (*Ptr) || (*Ptr == _TAB)))
                Ptr++;

            //get etrn
            for (i = 0; *Ptr != 0 && *Ptr != _COMMA && i < 255; Ptr++)
            {
                szValue[i++] = *Ptr;
            }

            //null terminate
            szValue[i] = _NULL;
            UseEtrn = _wtoi(szValue);

            //turn the number into a BOOL
            UseEtrn = !!UseEtrn;

			DebugOutput(_T("Use Etrn = %s"), UseEtrn?_T("TRUE"):_T("FALSE"));

            // We don't deliver, so we coerce delivery to alias
			if (Action == SMTP_DELIVER)
                Action = SMTP_ALIAS;

			// OK, we have come this far, so we can now write out the new
			// domain routing entry

			// First, remap the Action value, sinc eit had been changed.
			NewAction = rgdwMapping[Action];
			if (UseEtrn)
				NewAction |= dwEtrnFlag;

			// The Domain Name string that we get will become the new
			// key name under smtpsvc/1/Domain/"Domain Name"
			csDomainRoute = csKeyName + csDomainName;
			DebugOutput(_T("Creating %s ..."), (LPCTSTR)csDomainName);
			mKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, (LPCTSTR)csDomainRoute);
			if ( (METADATA_HANDLE)mKey )
			{
				// First set the route action DWORD
				DebugOutput(_T("Creating route action = %08x"), NewAction);
				mdRec.dwMDIdentifier = SMTP_MD_ID(82);
				mdRec.dwMDAttributes = 1;
				mdRec.dwMDUserType = 1;
				mdRec.dwMDDataType = 1;
				mdRec.dwMDDataLen = sizeof(DWORD);
				mdRec.pbMDData = (LPBYTE)&NewAction;
				mKey.SetData(&mdRec);

				// Then set the route action type string
				DebugOutput(_T("Creating route action type = %s"), (LPCTSTR)csActionType);
				mdRec.dwMDIdentifier = SMTP_MD_ID(83);
				mdRec.dwMDAttributes = 1;
				mdRec.dwMDUserType = 1;
				mdRec.dwMDDataType = 2;
				mdRec.dwMDDataLen = (lstrlen(szActionType) + 1) * sizeof(TCHAR);
				mdRec.pbMDData = (LPBYTE)szActionType;
				mKey.SetData(&mdRec);

				// Then set the KeyType
				lstrcpy(szActionType, _T("IIsSmtpDomain"));
				DebugOutput(_T("Creating Key type = %s"), szActionType);
				mdRec.dwMDIdentifier = 1002;
				mdRec.dwMDAttributes = 1;
				mdRec.dwMDUserType = 1;
				mdRec.dwMDDataType = 2;
				mdRec.dwMDDataLen = (lstrlen(szActionType) + 1) * sizeof(TCHAR);
				mdRec.pbMDData = (LPBYTE)szActionType;
				mKey.SetData(&mdRec);

				mKey.Close();
			}

        } while (0);

		// We skip to the end of the current string and process the next one
		// This makes sure we will not be in trouble when we break out in the
		// middle of parsing
		while (*Ptr++ != _NULL)
			;
    }

	return(TRUE);
}

// IIS SnapIn CLSID - {A841B6C4-7577-11d0-BB1F-00A0C922E79C}
//DEFINE_GUID(CLSID_IIS_SnapIn, 0xa841b6c4, 0x7577, 0x11d0, 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c);
const WCHAR *   wszIIS_SnapIn = _T("{A841B6C4-7577-11d0-BB1F-00A0C922E79C}");

BOOL
EnableSnapInExtension(
    IN CString      &csMMCDocFilePath,
    IN LPCWSTR      lpwszExtSnapInCLSID,
    IN BOOL         bEnable
    )
/*++

Description:

    Enable/Disable snapin extension in IIS
    NT5 - also enable our snapin under %systemroot%\system32\compmgmt.msc

Arguments:

    csMMCDocFilePath - Path to iis.msc, normally %windir%\system32\inetsrv
    ExtCLSID         - CLSID for snapin extension
    bEnable          - TRUE enable, FALSE disable

Return Value:

    TRUE - success, FALSE otherwise

--*/
{
	// -------------------------------------------------------------------------------------
	// $BUG(garypur) - removing the use of the IDocConfig interface since MMC support for it
	// has been removed
	// -------------------------------------------------------------------------------------
	return TRUE;

/*
    HRESULT     hr = S_OK;
    IDocConfig  *pIDocConfig = NULL;
    CString     csMMCDocFile = csMMCDocFilePath;
    VARIANT_BOOL    boolVal = bEnable ? VARIANT_TRUE : VARIANT_FALSE;
    BSTR        bstrMMCDocFile;
    BSTR        bstrCLSID_IIS_SnapIn;
    BSTR        bstrCLSID_Ext_SnapIn;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        DebugOutput(_T("Cannot CoInitialize()"));
        return FALSE;
    }

    bstrMMCDocFile = ::SysAllocString((LPCWSTR) csMMCDocFile);
    bstrCLSID_IIS_SnapIn = ::SysAllocString(wszIIS_SnapIn);
    bstrCLSID_Ext_SnapIn = ::SysAllocString(lpwszExtSnapInCLSID);

    //
    // Get the IDocConfig interface pointer
    //
    hr = CoCreateInstance( (REFCLSID) CLSID_MMCDocConfig,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           (REFIID) IID_IDocConfig,
                           (void**) &pIDocConfig);
    if (FAILED(hr))
        goto exit;

    //
    // Open iis.msc
    //
    hr = pIDocConfig->OpenFile( bstrMMCDocFile );
    if (FAILED(hr))
        goto exit;

    //
    // Enable the Snapin
    //
    hr = pIDocConfig->EnableSnapInExtension( bstrCLSID_IIS_SnapIn, bstrCLSID_Ext_SnapIn, boolVal );
    if (FAILED(hr))
        goto exit;

    //
    // Save the change
    //
    hr = pIDocConfig->SaveFile( bstrMMCDocFile );
    if (FAILED(hr))
        goto exit;

    //
    // Close file
    //
    hr = pIDocConfig->CloseFile();

exit:

    if (pIDocConfig)
    {
        pIDocConfig->Release();
        pIDocConfig = NULL;
    }

    ::SysFreeString(bstrMMCDocFile);
    ::SysFreeString(bstrCLSID_IIS_SnapIn);
    ::SysFreeString(bstrCLSID_Ext_SnapIn);

    CoUninitialize();

    return (S_OK == hr);
*/
}


const LPCTSTR g_cszMMCBasePath     = _T("Software\\Microsoft\\MMC");
const LPCTSTR g_cszNodeTypes       = _T("NodeTypes");
const LPCTSTR g_cszExtensions      = _T("Extensions");
const LPCTSTR g_cszNameSpace       = _T("NameSpace");
const LPCTSTR g_cszDynamicExt      = _T("Dynamic Extensions");
const LPCTSTR g_cszServerAppsLoc   = _T("System\\CurrentControlSet\\Control\\Server Applications");

BOOL
EnableCompMgmtExtension(
    IN LPCWSTR      lpwszExtSnapInCLSID,
    IN LPCWSTR      lpwszSnapInName,
    IN BOOL         bEnable
    )
/*++

Description:

    Enable/Disable snapin extension in NT5 CompMgmt

Arguments:

    ExtCLSID         - CLSID for snapin extension
    bEnable          - TRUE enable, FALSE disable

Return Value:

    TRUE - success, FALSE otherwise

--*/
{

    DebugOutput(_T("EnableCompMgmtExtension(): bEnable=%d"), bEnable);

    CString strExtKey;

    // set up registry values
    CRegKey regMachine = HKEY_LOCAL_MACHINE;

    if (bEnable)
    {
        {
            //
            // Register as a dynamic extension to computer management
            //
            strExtKey.Format(
                _T("%s\\%s\\%s\\%s"),
                g_cszMMCBasePath,
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszDynamicExt
                );

            CRegKey regMMCNodeTypes(strExtKey, regMachine);
            if ((HKEY) regMMCNodeTypes)
            {
                regMMCNodeTypes.SetValue( lpwszExtSnapInCLSID, lpwszSnapInName );
            }
        }

        {
            //
            // Register as a namespace extension to computer management
            //
            strExtKey.Format(
                _T("%s\\%s\\%s\\%s\\%s"),
                g_cszMMCBasePath,
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszExtensions,
                g_cszNameSpace
                );

            CRegKey regMMCNodeTypes(strExtKey, regMachine);
            if ((HKEY) regMMCNodeTypes)
            {
                regMMCNodeTypes.SetValue( lpwszExtSnapInCLSID, lpwszSnapInName );
            }
        }

        //
        // This key indicates that the service in question is available
        // on the local machine
        //
        CRegKey regCompMgmt(g_cszServerAppsLoc, regMachine );
        if ((HKEY) regCompMgmt)
        {
            regCompMgmt.SetValue( lpwszExtSnapInCLSID, lpwszSnapInName );
        }

    }
    else
    {
        //
        //  Disabling CompMgmt extension
        //
        {
            //
            // Unregister as a dynamic extension to computer management
            //
            strExtKey.Format(
                _T("%s\\%s\\%s\\%s"),
                g_cszMMCBasePath,
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszDynamicExt
                );

            CRegKey regMMCNodeTypes(strExtKey, regMachine);
            if ((HKEY) regMMCNodeTypes)
            {
                regMMCNodeTypes.DeleteValue( lpwszExtSnapInCLSID );
            }
        }

        {
            //
            // unregister as a namespace extension to computer management
            //
            strExtKey.Format(
                _T("%s\\%s\\%s\\%s\\%s"),
                g_cszMMCBasePath,
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszExtensions,
                g_cszNameSpace
                );

            CRegKey regMMCNodeTypes(strExtKey, regMachine);
            if ((HKEY) regMMCNodeTypes)
            {
                regMMCNodeTypes.DeleteValue( lpwszExtSnapInCLSID );
            }
        }

        //
        // This key indicates that the service in question is available
        // on the local machine.  Remove it
        //
        CRegKey regCompMgmt(g_cszServerAppsLoc, regMachine );
        if ((HKEY) regCompMgmt)
        {
            regCompMgmt.DeleteValue( lpwszExtSnapInCLSID );
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\wizpages.cpp ===
#include "stdafx.h"
#include <ole2.h>
#include "k2suite.h"
#include "ocmanage.h"

#include "setupapi.h"

#include "utils.h"

#include "abtype.h"
#include "cpool.h"

extern "C" {
#include "address.hxx"
}

extern OCMANAGER_ROUTINES gHelperRoutines;
extern HANDLE gMyModuleHandle;

DWORD	ScDoLicensing(
	HWND		hwnd,
	BOOL		fUI,
	BOOL		fRefresh,
	BOOL		fForklift,
	BOOL		fLicPerSeat,
	LPTSTR		pstrLicPerServerUserNum,
	BOOL	*	pfQuit);

BOOL IsSilentOperation(BOOL *pfForceReboot = NULL)
{
	BOOL		b = FALSE;
	BOOL		fRes = FALSE;
    INFCONTEXT	Context;
	HANDLE		hFile;
	TCHAR		szLine[1024];

	if (pfForceReboot)
		*pfForceReboot = FALSE;

	hFile = (theApp.m_hInfHandle[MC_IMS])?theApp.m_hInfHandle[MC_IMS]:
			((theApp.m_hInfHandle[MC_INS])?theApp.m_hInfHandle[MC_INS]:NULL);
	if (hFile)
	{
		DebugOutput(_T("Searching for [Upgrade]\n"));
		b = SetupFindFirstLine(hFile, _T("Upgrade"), NULL, &Context);
		while (b)
		{
			b = SetupGetLineText(&Context, NULL, NULL,
								 NULL, szLine, sizeof(szLine), NULL);
			if (b)
			{
				DebugOutput(szLine);
				DebugOutput(_T(" read\n"));

				// Parse the line
				if (!lstrcmpi(szLine, _T("Silent,on")))
				{
					fRes = TRUE;
					if (!pfForceReboot)
						break;
				}
				else if (!lstrcmpi(szLine, _T("ForceReboot,on")))
				{
					if (pfForceReboot)
						*pfForceReboot = TRUE;
				}
			}

	        b = SetupFindNextLine(&Context, &Context);
		}
	}

	wsprintf(szLine, _T("Silent upgrade mode is %s\n"), fRes?_T("ON"):_T("OFF")),
	DebugOutput(szLine);
	return(fRes);
}

HPROPSHEETPAGE CreatePage(int nID, DLGPROC pDlgProc)
{
    PROPSHEETPAGE Page;
    HPROPSHEETPAGE PageHandle = NULL;

    Page.dwSize = sizeof(PROPSHEETPAGE);
    Page.dwFlags = PSP_DEFAULT;
    Page.hInstance = (HINSTANCE)gMyModuleHandle;
    Page.pszTemplate = MAKEINTRESOURCE(nID);
    Page.pfnDlgProc = pDlgProc;

    PageHandle = CreatePropertySheetPage(&Page);

    return(PageHandle);
}

void PaintTextInRect( HDC hdc, LPCTSTR psz, RECT* pRect, COLORREF color,
                     LONG lfHeight, LONG lfWeight, BYTE lfPitchAndFamily,
					 UINT uFormat )
{
    // create the font we will use for this
    HFONT hfontDraw = CreateFont(
        lfHeight,           // logical height of font
        0,                  // logical average character width
        0,                  // angle of escapement
        0,                  // base-line orientation angle
        lfWeight,           // font weight
        FALSE,              // italic attribute flag
        FALSE,              // underline attribute flag
        FALSE,              // strikeout attribute flag
        DEFAULT_CHARSET,    // character set identifier
        OUT_DEFAULT_PRECIS, // output precision
        CLIP_DEFAULT_PRECIS,// clipping precision
        DEFAULT_QUALITY,    // output quality
        lfPitchAndFamily,   // pitch and family
        NULL                // pointer to typeface name string
        );

    // set the font into place
    HFONT   hfontOld = (HFONT)SelectObject( hdc, hfontDraw );

    // prevent the character box from being erased
    int oldBkMode = SetBkMode(hdc, TRANSPARENT);

    // set the text color
    COLORREF oldTextColor = SetTextColor( hdc, color );

    // draw the text
    DrawText(
        hdc,                // handle to device context
        psz,                // pointer to string to draw
        -1,                 // string length, in characters
        pRect,              // pointer to structure with formatting dimensions
        uFormat|DT_TOP      // text-drawing flags
        );

    // restore hdc settings
    SetBkMode( hdc, oldBkMode );
    SetTextColor( hdc, oldTextColor );
    SelectObject( hdc, hfontOld );

    // clean up the font
    DeleteObject( hfontDraw );
}

void PaintTextInFrame( HDC hdc, LPCTSTR psz, HWND hDlg, UINT nID, COLORREF color,
                      LONG lfHeight, LONG lfWeight, BYTE lfPitchAndFamily,
					  UINT uFormat )
{
    RECT    rect;
    GetWindowRect( GetDlgItem(hDlg, nID), &rect );
    MapWindowPoints( HWND_DESKTOP, hDlg, (LPPOINT)&rect, 2 );
    PaintTextInRect( hdc, psz, &rect, color, lfHeight, lfWeight, lfPitchAndFamily, uFormat );
}

HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors)
{
   LPBITMAPINFOHEADER  lpbi;
   LPLOGPALETTE     lpPal;
   HANDLE           hLogPal;
   HPALETTE         hPal = NULL;
   int              i;

   lpbi = (LPBITMAPINFOHEADER)lpbmi;
   if (lpbi->biBitCount <= 8)
       *lpiNumColors = (1 << lpbi->biBitCount);
   else
       *lpiNumColors = 0;  // No palette needed for 24 BPP DIB

   if (lpbi->biClrUsed > 0)
       *lpiNumColors = lpbi->biClrUsed;  // Use biClrUsed

   if (*lpiNumColors)
   {
      hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) +
                             sizeof (PALETTEENTRY) * (*lpiNumColors));
      lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
      lpPal->palVersion    = 0x300;
      lpPal->palNumEntries = (WORD)*lpiNumColors;

      for (i = 0;  i < *lpiNumColors;  i++)
      {
         lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
         lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
         lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
         lpPal->palPalEntry[i].peFlags = 0;
      }
      hPal = CreatePalette (lpPal);
      GlobalUnlock (hLogPal);
      GlobalFree   (hLogPal);
   }
   return hPal;
}

HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPCTSTR lpString, HPALETTE FAR* lphPalette)
{
    HRSRC  hRsrc;
    HGLOBAL hGlobal;
    HBITMAP hBitmapFinal = NULL;
    LPBITMAPINFOHEADER  lpbi;
    HDC hdc;
    int iNumColors;

    if (hRsrc = FindResource(hInstance, lpString, RT_BITMAP))
    {
       hGlobal = LoadResource(hInstance, hRsrc);
       lpbi = (LPBITMAPINFOHEADER)LockResource(hGlobal);

       hdc = GetDC(NULL);
       *lphPalette =  CreateDIBPalette ((LPBITMAPINFO)lpbi, &iNumColors);
       if (*lphPalette)
       {
          SelectPalette(hdc,*lphPalette,FALSE);
          RealizePalette(hdc);
       }

       hBitmapFinal = CreateDIBitmap(hdc,
                   (LPBITMAPINFOHEADER)lpbi,
                   (LONG)CBM_INIT,
                   (LPSTR)lpbi + lpbi->biSize + iNumColors * sizeof(RGBQUAD),
                   (LPBITMAPINFO)lpbi,
                   DIB_RGB_COLORS );

       ReleaseDC(NULL,hdc);
       UnlockResource(hGlobal);
       FreeResource(hGlobal);
    }
    return (hBitmapFinal);
}

//
// n = 0 | 1 | 2 | 3 | 4.  0 == welcome.  1 == IIS banner.  2 == NNTP banner.
// 					   3 == SMTP banner.  4 == MCIS Mail banner, 5 == MCIS News banner
void OnPaintBitmap(HWND hdlg, HDC hdc, int n, RECT *hRect)
{
	HBITMAP hBitmap,hOldBitmap;
	HPALETTE hPalette;
	HDC hMemDC;
	BITMAP bm;
	int nID;

    // Load the bitmap resource. Note we load the same base bitmap
	// for all cases except for welcome, just that we overlay different
	// text on top.
	if (n == 0)
	{
		// Mail or News greeting banner
		if (theApp.m_hInfHandle[MC_IMS] != NULL)
	        nID = IDB_WELCOMESMTP;
		else
			nID = IDB_WELCOMENNTP;
	}
	else
	{
		// Common banner
		nID = IDB_BANNER;
	}

	// Load bitmap and adjust palette
	hBitmap = LoadResourceBitmap(theApp.m_hDllHandle, MAKEINTRESOURCE(nID), &hPalette);
	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	hMemDC = CreateCompatibleDC(hdc);
	SelectPalette(hdc,hPalette,FALSE);
	RealizePalette(hdc);
	SelectPalette(hMemDC,hPalette,FALSE);
	RealizePalette(hMemDC);
	hOldBitmap = (HBITMAP)SelectObject(hMemDC,hBitmap);
	StretchBlt( hdc, 0, 0, hRect->right, hRect->bottom, hMemDC, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY );
	DeleteObject(SelectObject(hMemDC,hOldBitmap));
	DeleteDC(hMemDC);
	DeleteObject(hPalette);

	if (n != 0)
	{
		CString csMS, csTitle;
		MyLoadString(IDS_BITMAP_MS, csMS);
		PaintTextInFrame(hdc, csMS, hdlg, IDC_FRAME_BANNER_MS, 0x0, 16, FW_NORMAL, DEFAULT_PITCH | FF_DONTCARE, DT_LEFT);

		switch (n)
		{
		case 2:
			// NNTP Banner
            // Always use NNTP banner for NT5
            nID = IDS_BITMAP_NNTP;
#if 0
			if (theApp.m_eNTOSType == OT_NTS)
				nID = IDS_BITMAP_MCIS_NEWS;
			else
				nID = IDS_BITMAP_NNTP;
#endif
			break;

		case 3:
			// SMTP Banner
            // Always use SMTP banner for NT5
            nID = IDS_BITMAP_SMTP;
#if 0
			if (theApp.m_eNTOSType == OT_NTS)
				nID = IDS_BITMAP_MCIS_MAIL;
			else
				nID = IDS_BITMAP_SMTP;
#endif
			break;

		case 4:
			// MCIS Mail Banner
			nID = IDS_BITMAP_MCIS_MAIL;
			break;

		case 5:
			// MCIS News Banner
			nID = IDS_BITMAP_MCIS_NEWS;
			break;

		case 1:
		default:
			// Default to the server banner
            // Always use SMTP/NNTP banner
			if (theApp.m_hInfHandle[MC_IMS] != NULL)
			{
                nID = IDS_BITMAP_MAIL_SERVER;
#if 0
				if (theApp.m_eNTOSType == OT_NTS)
					nID = IDS_BITMAP_MCIS_MAIL;
				else
					nID = IDS_BITMAP_MAIL_SERVER;
#endif
			}
			else
			{
                nID = IDS_BITMAP_NEWS_SERVER;
#if 0
				if (theApp.m_eNTOSType == OT_NTS)
					nID = IDS_BITMAP_MCIS_NEWS;
				else
					nID = IDS_BITMAP_NEWS_SERVER;
#endif
			}
			break;
		}
		
		MyLoadString(nID, csTitle);
		PaintTextInFrame(hdc, csTitle, hdlg, IDC_FRAME_BANNER_TITLE, 0x0, 24, FW_HEAVY, DEFAULT_PITCH | FF_DONTCARE, DT_LEFT);
	}
}

void SetIMSSetupMode(DWORD dwSetupMode)
{
    gHelperRoutines.SetSetupMode(gHelperRoutines.OcManagerContext, dwSetupMode);
}

DWORD GetIMSSetupMode()
{
    return(gHelperRoutines.GetSetupMode(gHelperRoutines.OcManagerContext));
}

void PopupOkMessageBox(DWORD dwMessageId, LPCTSTR szCaption)
{
	CString csText;

	MyLoadString(dwMessageId, csText);
    MyMessageBox(NULL, csText, szCaption,
				MB_OK | MB_TASKMODAL | MB_SETFOREGROUND | MB_TOPMOST);
}

int PopupYesNoMessageBox(DWORD dwMessageId)
{
	CString csConfirmation, csText;

	MyLoadString(IDS_CONFIRMATION_TEXT, csConfirmation);
	MyLoadString(dwMessageId, csText);
    return(MessageBox(NULL, csText, csConfirmation,
				MB_YESNO | MB_TASKMODAL | MB_SETFOREGROUND | MB_TOPMOST));
}

BOOL CALLBACK pWelcomePageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL b = TRUE;
    LPNMHDR pnmh;
    HWND hSheet = NULL;

    switch(msg) {
    case WM_INITDIALOG:
        SetWindowText(GetParent(hdlg), theApp.m_csAppName);
        break;
    case WM_COMMAND:
        break;
    case WM_NOTIFY:
        pnmh = (LPNMHDR)lParam;
        hSheet = GetParent(hdlg);
        switch (pnmh->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(hSheet, PSWIZB_NEXT);

			// Skip if silent operation
			if (IsSilentOperation() || theApp.m_fIsUnattended)
	            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
            break;
        default:
            break;
        }
        break;
    case WM_PAINT:
        {
            HDC hdc;
            PAINTSTRUCT ps;
            RECT rect;
            HWND hFrame;
            hdc = BeginPaint(hdlg, &ps);
            hFrame = GetDlgItem(hdlg, IDC_FRAME_WELCOME);
            GetClientRect(hFrame, &rect);
            OnPaintBitmap(hdlg, hdc, 0, &rect);
            EndPaint(hdlg, &ps);
        }
        break;
    default:
        b = FALSE;
        break;
    }

    return(b);
}

BOOL InsertEULAText(HWND hEdit)
{
    BOOL fReturn = FALSE;
    int i;
    TCHAR tch;
    TCHAR tchBuffer[81];
    CString csFile = theApp.m_csPathSource + _T("\\license.txt");
    FILE *hFile = _tfopen((LPCTSTR)csFile, _T("r"));
    if ( hFile ) {
        do {
           for( i=0; i < 79; i++ )
           {
               tch = _fgettc(hFile);
               if (tch == _TEOF)
                   break;
               if (tch == _T('\n')) {
                   tchBuffer[i++] = _T('\r');
                   tchBuffer[i] = _T('\n');
               } else
                   tchBuffer[i] = (TCHAR)tch;
           }

           if (i<81) { // append a "null" at the end
              tchBuffer[i] = _T('\0');
           }
           // insert tchBuffer
           SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM)tchBuffer);

           if ( tch == _TEOF )
              break;
        } while (TRUE);

        fReturn = TRUE;

        fclose(hFile);
    }

    return fReturn;
}

BOOL CALLBACK pEULAPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL b = TRUE;
	//BOOL fQuit = FALSE;
	//DWORD dwErr = NO_ERROR;
    LPNMHDR pnmh;
    HWND hSheet = NULL;
    HWND hEULAText = NULL;
    HWND hEULAAccept = NULL, hEULADecline = NULL;

    switch(msg) {
    case WM_INITDIALOG:
        SetWindowText(GetParent(hdlg), theApp.m_csAppName);
        break;
    case WM_COMMAND:
        if (HIWORD(wParam) == BN_CLICKED) {
            CString csText;
            hSheet = GetParent(hdlg);
            hEULAAccept = GetDlgItem(hdlg, IDC_EULA_ACCEPT);
            hEULADecline = GetDlgItem(hdlg, IDC_EULA_DECLINE);
            EnableWindow(hEULAAccept, FALSE);
            EnableWindow(hEULADecline, FALSE);
            switch (LOWORD(wParam)) {
                case IDC_EULA_ACCEPT:
                    MyLoadString(IDS_EULA_ACCEPTED, csText);
                    SetWindowText(hEULAAccept, csText);
                    theApp.m_fEULA = TRUE;
                    PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);

					//if (theApp.m_fIsMcis && theApp.m_hInfHandle[MC_IMS] != NULL)
					//{
					//	dwErr = ScDoLicensing(hdlg, !theApp.m_fIsUnattended, FALSE, FALSE, TRUE,
					//						_T("1"), &fQuit);
					//	if (fQuit)
					//	{
					//		// cancel setup
					//		PopupOkMessageBox(IDS_EULA_DECLINED, theApp.m_csAppName);
					//		PropSheet_PressButton(hSheet, PSBTN_CANCEL);
					//	}
					//}
                    return TRUE;
                case IDC_EULA_DECLINE:
                    {
                        // cancel setup
						PopupOkMessageBox(IDS_EULA_DECLINED, theApp.m_csAppName);
                        PropSheet_PressButton(hSheet, PSBTN_CANCEL);
                    }
                    return TRUE;
                default:
                    break;
            }
        }
        break;
    case WM_NOTIFY:
        pnmh = (LPNMHDR)lParam;
        hSheet = GetParent(hdlg);
        switch (pnmh->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
            hEULAText = GetDlgItem(hdlg, IDC_LICENSE_TEXT);

			// Skip if unattended
			if (theApp.m_fIsUnattended)
			{
	            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
				break;
			}

            if (InsertEULAText(hEULAText))
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, 0);
            else
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);

            hEULAAccept = GetDlgItem(hdlg, IDC_EULA_ACCEPT);
            hEULADecline = GetDlgItem(hdlg, IDC_EULA_DECLINE);
            if (theApp.m_fEULA) {
                CString csHaveAccepted;
                MyLoadString(IDS_EULA_ACCEPTED, csHaveAccepted);
                SetWindowText(hEULAAccept, csHaveAccepted);
                EnableWindow(hEULAAccept, FALSE);
                EnableWindow(hEULADecline, FALSE);
                PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
            } else {
                EnableWindow(hEULAAccept, TRUE);
                EnableWindow(hEULADecline, TRUE);
                PropSheet_SetWizButtons(hSheet, PSWIZB_BACK);
                SetFocus(hEULAAccept);
            }
            break;
        default:
            break;
        }
        break;
    case WM_PAINT:
        {
            HDC hdc;
            PAINTSTRUCT ps;
            RECT rect;
            HWND hFrame;
            hdc = BeginPaint(hdlg, &ps);
            hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
            GetClientRect(hFrame, &rect);
            OnPaintBitmap(hdlg, hdc, 1, &rect);
            EndPaint(hdlg, &ps);
        }
        break;
    default:
        b = FALSE;
        break;
    }

    return(b);
}

BOOL CALLBACK pFreshPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL b = TRUE;
	BOOL fQuit = FALSE;
	DWORD dwErr = NO_ERROR;
    LPNMHDR pnmh;
    HWND hSheet = GetParent(hdlg);
    HWND hMinimum = NULL, hTypical = NULL, hCustom = NULL;

    switch(msg) {
    case WM_INITDIALOG:
        SetWindowText(hSheet, theApp.m_csAppName);
        hMinimum = GetDlgItem(hdlg, IDC_MINIMUM);
        hTypical = GetDlgItem(hdlg, IDC_TYPICAL);
        hCustom = GetDlgItem(hdlg, IDC_CUSTOM);

		//EnableWindow(hMinimum, FALSE);
		//EnableWindow(hTypical, FALSE);
        break;
    case WM_COMMAND:
        if (HIWORD(wParam) == BN_CLICKED) {
            switch (LOWORD(wParam)) {
                case IDC_MINIMUM:
                    // set minimum default selections
                    SetIMSSetupMode(IIS_SETUPMODE_MINIMUM);
                    PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                    PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto setup page
                    return TRUE;
                case IDC_TYPICAL:
                    // set typical default selections
                    SetIMSSetupMode(IIS_SETUPMODE_TYPICAL);
                    PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                    PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto setup page
                    return TRUE;
                case IDC_CUSTOM:
                    // set typical default selections
                    SetIMSSetupMode(IIS_SETUPMODE_CUSTOM);
                    PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                    PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto OC page
                    return TRUE;
                default:
                    break;
            }
        }
        break;
    case WM_NOTIFY:
        pnmh = (LPNMHDR)lParam;
        switch (pnmh->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(hSheet, PSWIZB_BACK);

			// NT5 - BUGBUG, we don't display any licensing in NT5
            // But for now, simply replace the m_fIsMcis with the following check
            // Will fix it later
            if (theApp.m_eNTOSType == OT_NTS &&
				!theApp.m_fEULA &&
				theApp.m_hInfHandle[MC_IMS] != NULL)
			{
				dwErr = ScDoLicensing(hdlg, !theApp.m_fIsUnattended, FALSE, FALSE, TRUE,
									_T("1"), &fQuit);
				if (fQuit)
				{
					// cancel setup
					PopupOkMessageBox(IDS_EULA_DECLINED, theApp.m_csAppName);
					PropSheet_PressButton(hSheet, PSBTN_CANCEL);
					break;
				}

				// Mark it so we don't do it again.
				theApp.m_fEULA = TRUE;
			}

			// Skip if unattended
			if (theApp.m_fIsUnattended)
			{
                SetIMSSetupMode(IIS_SETUPMODE_CUSTOM);
	            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
			}
            break;
        default:
            break;
        }
        break;
    case WM_PAINT:
        {
            HDC hdc;
            PAINTSTRUCT ps;
            RECT rect;
            HWND hFrame;
            hdc = BeginPaint(hdlg, &ps);
            hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
            GetClientRect(hFrame, &rect);
            OnPaintBitmap(hdlg, hdc, 1, &rect);
            EndPaint(hdlg, &ps);
        }
        break;
    default:
        b = FALSE;
        break;
    }

    return(b);
}

BOOL CALLBACK pMaintanencePageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL b = TRUE;
    LPNMHDR pnmh;
    HWND hSheet = GetParent(hdlg);
    HWND hAddRemove = NULL, hReinstall = NULL, hRemoveAll = NULL;
	DWORD dwMessageID;

    switch(msg) {
    case WM_INITDIALOG:
        SetWindowText(hSheet, theApp.m_csAppName);
        hAddRemove = GetDlgItem(hdlg, IDC_ADDREMOVE);
        hReinstall = GetDlgItem(hdlg, IDC_REINSTALL);
        hRemoveAll = GetDlgItem(hdlg, IDC_REMOVEALL);
        // EnableWindow(hReinstall, FALSE);
        // EnableWindow(hRemoveAll, FALSE);
        break;
    case WM_COMMAND:
        if (HIWORD(wParam) == BN_CLICKED) {
            switch (LOWORD(wParam)) {
                case IDC_ADDREMOVE:
                    // add/remove selections
                    SetIMSSetupMode(IIS_SETUPMODE_ADDREMOVE);
                    PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                    PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto OC page
                    return TRUE;
                case IDC_REINSTALL:
                    // reinstall existing components
                    SetIMSSetupMode(IIS_SETUPMODE_REINSTALL);
                    PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                    PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto setup page
                    return TRUE;
                case IDC_REMOVEALL: {
                    // remove all components, this deserves confirnation
					if (theApp.m_dwCompId == MC_INS)
					{
						// For news K2 and MCIS have different messages.
						if (theApp.m_eNTOSType == OT_NTS)
							dwMessageID = IDS_CONFIRM_REMOVE_ALL_MCIS_NEWS;
						else
							dwMessageID = IDS_CONFIRM_REMOVE_ALL_INS;
					}
					else
					{
						// NT5 - No change for Mail
                        // For mail K2 and MCIS have different messages.
						if (theApp.m_fIsMcis)
							dwMessageID = IDS_CONFIRM_REMOVE_ALL_MCIS_MAIL;
						else
							dwMessageID = IDS_CONFIRM_REMOVE_ALL_IMS;
					}
					if (PopupYesNoMessageBox(dwMessageID) == IDYES)
					{
						SetIMSSetupMode(IIS_SETUPMODE_REMOVEALL);
						PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
						PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto setup page
					}
                    return TRUE;
				}
                default:
                    break;
            }
        }
        break;
    case WM_NOTIFY:
        pnmh = (LPNMHDR)lParam;
        switch (pnmh->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(hSheet, PSWIZB_BACK);

			// Skip if unattended
			if (theApp.m_fIsUnattended)
			{
                SetIMSSetupMode(IIS_SETUPMODE_REMOVEALL);
	            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
			}

			// Skip if silent operation
			if (IsSilentOperation())
			{
				// Force reinstall
				SetIMSSetupMode(IIS_SETUPMODE_REINSTALL);

				// Skip the window immediately
				SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
			}
            break;
        default:
            break;
        }
        break;
    case WM_PAINT:
        {
            HDC hdc;
            PAINTSTRUCT ps;
            RECT rect;
            HWND hFrame;
            hdc = BeginPaint(hdlg, &ps);
            hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
            GetClientRect(hFrame, &rect);
            OnPaintBitmap(hdlg, hdc, 1, &rect);
            EndPaint(hdlg, &ps);
        }
        break;
    default:
        b = FALSE;
        break;
    }

    return(b);
}

BOOL CALLBACK pUpgradePageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL b = TRUE;
    LPNMHDR pnmh;
    HWND hSheet = GetParent(hdlg);
    HWND hUpgradeOnly = NULL, hAddExtraComps = NULL;

    switch(msg) {
    case WM_INITDIALOG:
        SetWindowText(hSheet, theApp.m_csAppName);
        hUpgradeOnly = GetDlgItem(hdlg, IDC_UPGRADEONLY);
        hAddExtraComps = GetDlgItem(hdlg, IDC_ADDEXTRACOMPS);
        // EnableWindow(hAddExtraComps, FALSE);
        break;
    case WM_COMMAND:
        if (HIWORD(wParam) == BN_CLICKED) {
            switch (LOWORD(wParam)) {
                case IDC_UPGRADEONLY:
                    // upgrade those previously installed components
                    SetIMSSetupMode(IIS_SETUPMODE_UPGRADEONLY);
                    PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                    PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto setup page
                    return TRUE;
                case IDC_ADDEXTRACOMPS:
                    // upgrade those previously installed components + add extra components
                    SetIMSSetupMode(IIS_SETUPMODE_ADDEXTRACOMPS);
                    PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                    PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto OC page
                    return TRUE;
                default:
                    break;
            }
        }
        break;
    case WM_NOTIFY:
        pnmh = (LPNMHDR)lParam;
        switch (pnmh->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(hSheet, PSWIZB_BACK);
            break;
        default:
            break;
        }
        break;
    case WM_PAINT:
        {
            HDC hdc;
            PAINTSTRUCT ps;
            RECT rect;
            HWND hFrame;
            hdc = BeginPaint(hdlg, &ps);
            hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
            GetClientRect(hFrame, &rect);
            OnPaintBitmap(hdlg, hdc, 1, &rect);
            EndPaint(hdlg, &ps);
        }
        break;
    default:
        b = FALSE;
        break;
    }

    return(b);
}

BOOL CALLBACK pEndPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL b = TRUE;
	BOOL fReboot = FALSE;
    LPNMHDR pnmh;
    HWND hSheet = NULL;
    HWND hCancel = NULL;

    switch(msg) {
    case WM_INITDIALOG:
        SetWindowText(GetParent(hdlg), theApp.m_csAppName);
        break;
    case WM_COMMAND:
        break;
    case WM_NOTIFY:
        pnmh = (LPNMHDR)lParam;
        hSheet = GetParent(hdlg);
        switch (pnmh->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(hSheet, PSWIZB_FINISH);
            hCancel = GetDlgItem(hSheet, IDCANCEL);
            if (hCancel)
                EnableWindow(hCancel, FALSE);

			// Skip if unattended
			if (theApp.m_fIsUnattended)
			{
	            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
				PropSheet_PressButton(hSheet, PSBTN_FINISH);
				break;
			}

			// Skip if silent operation
			if (IsSilentOperation(&fReboot) && fReboot)
			{
				// Do the shutdown here
				HANDLE hToken;
				TOKEN_PRIVILEGES tkp;

				if (!OpenProcessToken(GetCurrentProcess(),
						TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
				{
					TCHAR szMsg[128];
					wsprintf(szMsg, _T("Cannot OpenProcessToken (%u)\n"), GetLastError());
					DebugOutput(szMsg);
				}

				// Get the LUID for the shutdown privilege.
 				LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME,
						&tkp.Privileges[0].Luid);

				tkp.PrivilegeCount = 1;  // one privilege to set
				tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

				// Get the shutdown privilege for this process.
 				AdjustTokenPrivileges(hToken, FALSE, &tkp, 0,
						(PTOKEN_PRIVILEGES)NULL, 0);

				// Cannot test the return value of AdjustTokenPrivileges.
 				if (GetLastError() != ERROR_SUCCESS)
				{
					TCHAR szMsg[128];
					wsprintf(szMsg, _T("Cannot AdjustTokenPrivileges (%u)\n"), GetLastError());
					DebugOutput(szMsg);
				}

				// Shut down the system and force all applications to close.
 				if (!InitiateSystemShutdown(NULL, _T("Please wait while the system shuts down ..."), 20 , TRUE, TRUE))
				{
					TCHAR szMsg[128];
					wsprintf(szMsg, _T("Unable to shutdown (%u)\n"), GetLastError());
					DebugOutput(szMsg);
				}
			}
				
            break;
        default:
            break;
        }
        break;
    case WM_PAINT:
        {
            HDC hdc;
            PAINTSTRUCT ps;
            RECT rect;
            HWND hFrame;
            hdc = BeginPaint(hdlg, &ps);
            hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
            GetClientRect(hFrame, &rect);
            OnPaintBitmap(hdlg, hdc, 1, &rect);
            EndPaint(hdlg, &ps);
        }
        break;
    default:
        b = FALSE;
        break;
    }

    return(b);
}

// Clean leading & trailing spaces
// Clean trailing backslashes
BOOL CleanPathString(LPTSTR szPath)
{
    LPTSTR p = szPath;
    int i = 0;

    if (p) {
        while (*p) {
            if ( _istspace(*p) ) {
                p++;
            } else {
                break;
            }
        }

        // move p to the end
        if (p == szPath) {
            while (*p)
                p++;
        } else {
            while (*p)
                szPath[i++] = *p++;

            szPath[i] = *p;
            p = szPath + i;
        }

        // now p pointing to the end '\0'
        while ((--p >= szPath) && (_istspace(*p)) )
            ;
        *(p+1) = _T('\0');

        if ( (p > szPath) && (*p == _T('\\')) )
            *p = _T('\0');

        // szPath contains the clean path
    }

    return TRUE;
}

// C:\Inetpub\wwwroot ===> C:\Inetpub
BOOL GetParentDir(LPCTSTR szPath, LPTSTR szParentDir)
{
    LPTSTR p = (LPTSTR)szPath;
    if (!szPath || !*szPath)
		return(FALSE);

    while (*p)
        p++;

    p--;
    while (p >= szPath && *p != _T('\\'))
        p--;

    *szParentDir = _T('\0');
    if (p == szPath)
        lstrcpy(szParentDir, _T("\\"));
    else
        lstrcpyn(szParentDir, szPath, (size_t)(p - szPath + 1));

    return(TRUE);
}

// szResult = szParentDir \ szSubDir
BOOL AppendDir(LPCTSTR szParentDir, LPCTSTR szSubDir, LPTSTR szResult)
{
    LPTSTR p = (LPTSTR)szParentDir;

    if (!szParentDir ||
		!szSubDir)
		return(FALSE);

    if (!*szSubDir || *szSubDir == _T('\\'))
		return(FALSE);

    if (*szParentDir == _T('\0'))
        lstrcpy(szResult, szSubDir);

    while (*p)
        p++;

    lstrcpy(szResult, szParentDir);
    if (*(p-1) != _T('\\')) {
        *(szResult + (p - szParentDir)) = _T('\\');
        *(szResult + (p - szParentDir) + 1) = _T('\0');
    }

    lstrcat(szResult, szSubDir);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\shuttle\cdescrip.cpp ===
//#---------------------------------------------------------------
//  File:       CDescrip.cpp
//        
//  Synopsis:   This file implements the CDescriptor class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu t-alexwe
//----------------------------------------------------------------
#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE   __szTraceSourceFile

#include    <windows.h>
#include    <stdio.h>
#include    "cdescrip.h"
#include    "cobjid.h"
#include    "cpool.h"
#include    "dbgtrace.h"

static DWORD			g_dwUniqueIdFactory = 1;
static CRITICAL_SECTION	g_critFactory;
static BOOL				g_bUseUniqueIDs = FALSE;

//+---------------------------------------------------------------
//
//  Function:   InitializeUniqueIDs
//
//  Synopsis:   Called to enable unique IDs inside CDescriptor's
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
void InitializeUniqueIDs( void )
{
	InitializeCriticalSection( &g_critFactory );
	g_bUseUniqueIDs = TRUE;
}


//+---------------------------------------------------------------
//
//  Function:   TerminateUniqueIDs
//
//  Synopsis:   Called to cleanup unique IDs inside CDescriptor's
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
void TerminateUniqueIDs( void )
{
	g_bUseUniqueIDs = FALSE;
	DeleteCriticalSection( &g_critFactory );
}


//+---------------------------------------------------------------
//
//  Function:   CDescriptor
//
//  Synopsis:   constructor is never called due to virtual array alloc
//                  Rather a void * will be cast to a CDescriptor *
//  Arguments:  void
//
//  Returns:    void
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
CDescriptor::CDescriptor( DWORD dwSignature ) : m_dwSignature( dwSignature )
{
    TraceFunctEnter( "CDescriptor::CDescriptor" );

	StateTrace((LPARAM) this, "m_eState = DESCRIPTOR_INUSE");

    m_eState = DESCRIPTOR_INUSE;

	if ( g_bUseUniqueIDs == TRUE )
	{
		EnterCriticalSection( &g_critFactory );
		m_dwUniqueObjectID = g_dwUniqueIdFactory++;
		LeaveCriticalSection( &g_critFactory );
	}

    TraceFunctLeave();
}

//+---------------------------------------------------------------
//
//  Function:   ~CDescriptor
//
//  Synopsis:   destructor should never be called.  We just decommit 
//              virtual array
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
CDescriptor::~CDescriptor(
    void 
    )
{
    TraceFunctEnter( "CDescriptor::~CDescriptor" );
	_ASSERT( m_eState == DESCRIPTOR_INUSE );

	StateTrace((LPARAM) this, "m_eState = DESCRIPTOR_FREE");

    m_eState = DESCRIPTOR_FREE;
	m_dwUniqueObjectID = 0;

    TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\shuttle\cpool.cpp ===
//#---------------------------------------------------------------
//  File:       CPool.cpp
//
//  Synopsis:   This file implements the CPool class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//----------------------------------------------------------------
#ifdef  THIS_FILE
#undef  THIS_FILE
#endif
static  char        __szTraceSourceFile[] = __FILE__;
#define THIS_FILE    __szTraceSourceFile

#include    <windows.h>
#include    "cpool.h"
#include    "dbgtrace.h"
#include    <randfail.h>

#define     PREAMBLE    (BYTE)'H'
#define     POSTAMBLE   (BYTE)'C'
#define     FILLER      (BYTE)0xCC


//
// Define internal Debug structs designed to help find over/underwrites
//
#ifdef DEBUG
#ifndef DISABLE_CPOOL_DEBUG
#define	CPOOL_DEBUG
#endif
#endif

#ifdef CPOOL_DEBUG

#define	HEAD_SIGNATURE	(DWORD)'daeH'
#define	TAIL_SIGNATURE	(DWORD)'liaT'

#define	FREE_STATE		(DWORD)'eerF'
#define	USED_STATE		(DWORD)'desU'

//
// forward declaration
//
class CPoolDebugTail;

//
// Prefix for CPool instances when in debug mode
//
class CPoolDebugHead {

	public:
		//
		// declared so normal CPool free list can clobber this member
		//
		void*	m_pLink;

		CPoolDebugHead();
		~CPoolDebugHead( void );

	    void *operator new( size_t cSize, void *pInstance )
			{ return	pInstance; };

	    void operator delete (void *pInstance) {};

		//
		// Function to mark the instance in use
		//
		void MarkInUse( DWORD m_dwSignature, DWORD m_cInstanceSize );

		//
		// Function to mark the instance free
		//
		void MarkFree( DWORD m_dwSignature, DWORD m_cInstanceSize );

		//
		// class signature
		//
		DWORD	m_dwSignature;

		//
		// state; either FREE_STATE or USED_STATE
		//
		DWORD	m_dwState;

		//
		// time of allocation
		//
		SYSTEMTIME	m_time;

		//
		// ThreadID which alloc'd/free'd memory
		//
		DWORD	m_dwThreadID;

		//
		// tail pointer used to find the end
		//
		CPoolDebugTail UNALIGNED	*m_pTailDebug;

		//
		// parent CPool signature
		//
		DWORD	m_dwPoolSignature;

		//
		// parent CPool Fragment
		//
		LPVOID	m_PoolFragment;
};


//
// Suffix for CPool instances when in debug mode
//
class CPoolDebugTail {

	public:
		CPoolDebugTail();
		~CPoolDebugTail( void );

	    void *operator new( size_t cSize, void *pInstance )
			{ return	pInstance; };

	    void operator delete (void *pInstance) {};

		//
		// routine to validate the integrity of the instance
		//
		void	IsValid( DWORD dwPoolSignature, DWORD cInstanceSize );

		//
		// class signature
		//
		DWORD	m_dwSignature;

		//
		// tail pointer used to find the end
		//
		CPoolDebugHead UNALIGNED	*m_pHeadDebug;
};

//+---------------------------------------------------------------
//
//  Function:   CPoolDebugHead
//
//  Synopsis:   constructor; extra init done in def'n
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CPoolDebugHead::CPoolDebugHead( void ) :
					m_dwState( FREE_STATE ),
					m_dwSignature( HEAD_SIGNATURE ),
					m_pTailDebug( NULL )
{
	//
	// debug helpers
	//
	GetLocalTime( &m_time ) ;
	m_dwThreadID = GetCurrentThreadId();
}

//+---------------------------------------------------------------
//
//  Function:   ~CPoolDebugHead
//
//  Synopsis:   destructor; only used to assert error conditions
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CPoolDebugHead::~CPoolDebugHead( void )
{
	_ASSERT( m_dwSignature == HEAD_SIGNATURE );
}

//+---------------------------------------------------------------
//
//  Function:   CPoolDebugHead::MarkInUse
//
//  Synopsis:   Called when instance is allocated
//
//  Arguments:  DWORD dwPoolSignature: signature of parent pool
//				DWORD cInstanceSize: instance size of parent pool
//
//  Returns:    void
//
//----------------------------------------------------------------
void CPoolDebugHead::MarkInUse( DWORD dwPoolSignature, DWORD cInstanceSize )
{
	_ASSERT( m_dwSignature == HEAD_SIGNATURE );
 	_ASSERT( m_dwState == FREE_STATE );

 	m_dwState = USED_STATE;

	//
	// validate that the application portion is not tampered with
	//
	for (	LPBYTE pb = (LPBYTE)(this+1);
			pb < (LPBYTE)m_pTailDebug;
			pb++ )
	{
		_ASSERT( *pb == FILLER );
	}

	//
	// check the validity of the entire instance
	//
	m_pTailDebug->IsValid( dwPoolSignature, cInstanceSize );

	//
	// debug helpers
	//
	GetLocalTime( &m_time ) ;
	m_dwThreadID = GetCurrentThreadId();
}


//+---------------------------------------------------------------
//
//  Function:   CPoolDebugHead::MarkFree
//
//  Synopsis:   Called when instance is freed
//
//  Arguments:  DWORD dwPoolSignature: signature of parent pool
//				DWORD cInstanceSize: instance size of parent pool
//
//  Returns:    void
//
//----------------------------------------------------------------
void CPoolDebugHead::MarkFree( DWORD dwPoolSignature, DWORD cInstanceSize )
{
	_ASSERT( m_dwSignature == HEAD_SIGNATURE );

	//
	// Check and set the state
	//
 	_ASSERT( m_dwState == USED_STATE );
 	m_dwState = FREE_STATE;

	//
	// check enough to call IsValid
	//
	_ASSERT( m_pTailDebug != 0 );
	_ASSERT( (DWORD_PTR)m_pTailDebug > (DWORD_PTR)this );

	_ASSERT( m_dwThreadID != 0 ) ;

	//
	// check the validity of the entire instance
	//
	m_pTailDebug->IsValid( dwPoolSignature, cInstanceSize );

	//
	// set the application data to filler
	//
	FillMemory( (LPBYTE)(this+1),
				(DWORD)((LPBYTE)m_pTailDebug - (LPBYTE)(this+1)),
				FILLER );

	//
	// debug helpers
	//
	GetLocalTime( &m_time ) ;
	m_dwThreadID = GetCurrentThreadId();
}


//+---------------------------------------------------------------
//
//  Function:   CPoolDebugTail
//
//  Synopsis:   constructor; extra init done in def'n
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CPoolDebugTail::CPoolDebugTail( void ) :
					m_dwSignature( TAIL_SIGNATURE ),
					m_pHeadDebug( NULL )
{
}

//+---------------------------------------------------------------
//
//  Function:   ~CPoolDebugTail
//
//  Synopsis:   destructor; only used to assert error conditions
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
CPoolDebugTail::~CPoolDebugTail( void )
{
	_ASSERT( m_dwSignature == TAIL_SIGNATURE );
}


//+---------------------------------------------------------------
//
//  Function:   IsValid
//
//  Synopsis:   check validity of instance
//
//  Arguments:  DWORD dwPoolSignature: signature of parent pool
//				DWORD cInstanceSize: instance size of parent pool
//
//  Returns:    void
//
//----------------------------------------------------------------
void CPoolDebugTail::IsValid( DWORD dwPoolSignature, DWORD cInstanceSize )
{
	_ASSERT( m_dwSignature == TAIL_SIGNATURE );

	//
	// validate that the head is offset at the correct location
	//
	_ASSERT( m_pHeadDebug != NULL );
	_ASSERT( (DWORD_PTR)m_pHeadDebug == (DWORD_PTR)(this+1) - cInstanceSize );

	//
	// validate the head structure
	//
	_ASSERT( m_pHeadDebug->m_dwSignature == HEAD_SIGNATURE );
	_ASSERT( m_pHeadDebug->m_dwPoolSignature == dwPoolSignature );
	_ASSERT( m_pHeadDebug->m_pTailDebug == this );
	_ASSERT( m_pHeadDebug->m_dwState == FREE_STATE ||
			 m_pHeadDebug->m_dwState == USED_STATE );
}


#endif

//+---------------------------------------------------------------
//
//  Function:   CPool
//
//  Synopsis:   constructor
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    gordm	Created         5 Jul 1995
//
//----------------------------------------------------------------
CPool::CPool( DWORD dwSignature ) : m_dwSignature( dwSignature )
{
    TraceFunctEnter( "CPool::CPool" );

    m_pFreeList = NULL;
    m_pExtraFreeLink = NULL;

	//
	// Debug variables to help catch heap bugs
	//
	m_pLastAlloc = NULL;
	m_pLastExtraAlloc = NULL;

	m_cTotalFrees = 0;
	m_cTotalAllocs = 0;
	m_cTotalExtraAllocs = 0;

	m_cInstanceSize = 0;

	//
	// Avail + InUse should equal Committed if we're not
	// in grow/alloc or free.  Diagnostic and admin only
	// This will keep code in critsec as small as possible
	//
	m_cNumberAvail = 0;
	m_cNumberInUse = 0;
	m_cNumberCommitted = 0;

    InitializeCriticalSection( &m_PoolCriticalSection );

	//
	// initialize the fragment member variables
	//
	m_cFragmentInstances = 0;
	m_cFragments = 0;
	ZeroMemory( m_pFragments, sizeof(m_pFragments) );

    TraceFunctLeave();
}


//+---------------------------------------------------------------
//
//  Function:   ~CPool
//
//  Synopsis:   destructor
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
CPool::~CPool( void )
{
    TraceFunctEnter( "CPool::~CPool" );

    _ASSERT( m_cNumberInUse == 0 );

	for ( int i=0; i<MAX_CPOOL_FRAGMENTS; i++ )
	{
		_ASSERT( m_pFragments[i] == NULL );
	}

    DebugTrace( (LPARAM)this,
                "CPool: %x  EntryCount: %d   ContentionCount: %d, Allocs: %d, Frees: %d",
                m_dwSignature,
                GetEntryCount(),
                GetContentionCount(),
                GetTotalAllocCount(),
                GetTotalFreeCount() );

    DeleteCriticalSection( &m_PoolCriticalSection );

    TraceFunctLeave();
}


//+---------------------------------------------------------------
//
//  Function:   Alloc
//
//  Synopsis:   Allocates a new instance from the pool
//
//  Arguments:  void
//
//  Returns:    pointer to the new instance
//
//  History:    gordm		Created			5 Jul 1995
//
//----------------------------------------------------------------
void* CPool::Alloc( void )
{
#ifdef	ALLOC_TRACING
    TraceFunctEnter( "CPool::Alloc" );
#endif

    Link* pAlloc;

    IsValid();

    //
    // Randfail for debug versions
    //
#if defined( DEBUG )
    if ( fTimeToFail() ) {
        return NULL;
    }
#endif

	//
	// moved outside of the critsec because it should not be necessary
	// to protect this variable.  inc before the alloc so this var wraps
	// the actual allocation
	//
	InterlockedIncrement( (LPLONG)&m_cNumberInUse );

	//
	// check the extra pointer to avoid the critsec path if
	// possible.  big wins because we can potentially avoid
	// the extra code and the wait on semaphore
	//
	pAlloc = (Link*)InterlockedExchangePointer( (void**)&m_pExtraFreeLink, NULL );
	if ( pAlloc == NULL )
	{

    	EnterCriticalSection( &m_PoolCriticalSection );

	    //
    	// commit more memory if the list is empty
	    //
    	if ( (m_pFreeList == NULL) && (m_cNumberCommitted < m_cMaxInstances) )
	    {
			GrowPool();
		}

    	//
	    // try to allocate a Descriptor from the free list
    	//
	    if ( (pAlloc = m_pFreeList) != NULL )
		{
			m_pFreeList = pAlloc->pNext;
		}

		m_pLastAlloc = pAlloc;
	    LeaveCriticalSection( &m_PoolCriticalSection );
	}
	else
	{
		m_pLastExtraAlloc = pAlloc;
	    m_cTotalExtraAllocs++;
	}

	//
	// alloc failed
	//	
	if ( pAlloc == NULL )
	{
		InterlockedDecrement( (LPLONG)&m_cNumberInUse );
	}
	else
	{
		//
		// debug/admin use only - ok to do outside of critsec
		//
	    m_cTotalAllocs++;

#ifdef CPOOL_DEBUG
		CPoolDebugHead*	pHead = (CPoolDebugHead*)pAlloc;

		//
		// validate that the address in the range
		//
		_ASSERT( (char*)pAlloc >= pHead->m_PoolFragment );
		_ASSERT( (char*)pAlloc <  (char*)pHead->m_PoolFragment +
								  m_cNumberCommitted*m_cInstanceSize );

		pHead->MarkInUse( m_dwSignature, m_cInstanceSize );
		pAlloc = (Link*)(pHead+1);
#endif

	}

#ifdef	ALLOC_TRACING
	DebugTrace( (LPARAM)this, "Alloc: 0x%08X", pAlloc );
    TraceFunctLeave();
#endif
    return	(void*)pAlloc;
}


//+---------------------------------------------------------------
//
//  Function:   Free
//
//  Synopsis:   frees the instances
//
//  Arguments:  pInstance - a pointer to the CDescriptor
//
//  Returns:    void
//
//  History:    gordm    Created         5 Jul 1995
//
//----------------------------------------------------------------
void CPool::Free( void* pInstance )
{
#ifdef	ALLOC_TRACING
    TraceFunctEnter( "CPool::Free" );
#endif

#ifdef CPOOL_DEBUG
		CPoolDebugHead*	pHead = ((CPoolDebugHead*)pInstance) - 1;

		//
		// validate that the address in the range
		//
		_ASSERT( (char*)pInstance >=pHead->m_PoolFragment);
		_ASSERT( (char*)pInstance < (char*)pHead->m_PoolFragment +
									m_cNumberCommitted*m_cInstanceSize );

		pHead->MarkFree( m_dwSignature, m_cInstanceSize );
		pInstance = (void*)pHead;
#endif

    IsValid();

    _ASSERT(m_cNumberInUse > 0);

	pInstance = (void*)InterlockedExchangePointer( (PVOID *)&m_pExtraFreeLink, pInstance );
	//
	// free the previous extra pointer if one existed
	//
	if ( pInstance != NULL )
	{
	    EnterCriticalSection( &m_PoolCriticalSection );

		((Link*)pInstance)->pNext = m_pFreeList;
		 m_pFreeList = (Link*)pInstance;

    	LeaveCriticalSection( &m_PoolCriticalSection );
	}

	//
	// moved outside of the critsec because it should not be necessary
	// to protect this variable. We'll think this list is empty only
	// when we get to this point.  This var is inc'd before entering
	// the critsec and is dec'd if the operation fails.
	//
	InterlockedDecrement( (LPLONG)&m_cNumberInUse );

	//
	// debug/admin use only - ok to do outside of critsec - deletes don't fail
	//
    m_cTotalFrees++;

#ifdef	ALLOC_TRACING
	DebugTrace( (LPARAM)this, "Freed: 0x%08X", pInstance );
    TraceFunctLeave();
#endif
}



//
// setup a const DWORD for size manipulation
//
const DWORD	KB = 1024;

//+---------------------------------------------------------------
//
//  Function:   ReserveMemory
//
//  Synopsis:   Initializes the pool
//
//  Arguments:  NumDescriptors - the number of total descriptors in the pool
//              DescriptorSize - the size of any one descriptor
//              Signature      - object signature
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
BOOL CPool::ReserveMemory(	DWORD MaxInstances,
							DWORD InstanceSize,
							DWORD IncrementSize )
{
    TraceFunctEnter( "CPool::ReserveMemory" );

	DWORD cFragments;
	DWORD cFragmentInstances;
	DWORD cIncrementInstances;

	_ASSERT( MaxInstances != 0 );
	_ASSERT( InstanceSize >= sizeof(struct Link) );

#ifdef CPOOL_DEBUG
	InstanceSize += sizeof( CPoolDebugHead ) + sizeof( CPoolDebugTail );
#endif

	if ( IncrementSize == DEFAULT_ALLOC_INCREMENT )
	{
		//
		// ensure we go to the OS for at least 8 instances at a time
		//
		if ( InstanceSize <= 4*KB / 8 )
		{
			cIncrementInstances = 4*KB / InstanceSize;
		}
		else if ( InstanceSize <= 64*KB / 8 )
		{
			cIncrementInstances = 64*KB / InstanceSize;
		}
		else
		{
			cIncrementInstances = min( MaxInstances, 8 );
		}
	}
	else
	{
		cIncrementInstances = IncrementSize;
	}

	//
	// now calculate the number larger fragments
	//
	if ( cIncrementInstances > MaxInstances )
	{
		//
		// no need for CPool; but we shouldn't alloc more than necessary
		//
		cFragmentInstances = cIncrementInstances = MaxInstances;
		cFragments = 1;
	}
	else
	{
		//
		// Round up MaxInstances to a integral number of IncrementSize
		//
	    MaxInstances += cIncrementInstances - 1;
    	MaxInstances /= cIncrementInstances;
    	MaxInstances *= cIncrementInstances;

		//
		// as an initial attempt divide the number of instances by max frags
		//
		cFragmentInstances = (MaxInstances + MAX_CPOOL_FRAGMENTS - 1) /
						MAX_CPOOL_FRAGMENTS;

		if ( cFragmentInstances == 0 )
		{
			cFragmentInstances = MaxInstances;
			cFragments = 1;
		}
		else
		{
			//
			// round up the number of instances in a fragment to an
			// integral number of IncrementSizes
			//
			cFragmentInstances += cIncrementInstances - 1;
			cFragmentInstances /= cIncrementInstances;
			cFragmentInstances *= cIncrementInstances;

			//
			// recalculate the number of fragments required based on the integral
			// number of IncrementSizes ( last one may no longer be required )
			//
			cFragments = (MaxInstances + cFragmentInstances - 1) /
						cFragmentInstances;
		}
	}

	_ASSERT( cFragments > 0 );
	_ASSERT( cFragments*cFragmentInstances >= MaxInstances );

	m_cInstanceSize = InstanceSize;
	m_cMaxInstances = MaxInstances;
	m_cFragments    = cFragments;

	m_cFragmentInstances  = cFragmentInstances;
	m_cIncrementInstances = cIncrementInstances;

	TraceFunctLeave();
	return	TRUE;
}



//+---------------------------------------------------------------
//
//  Function:   ReleaseMemory
//
//  Synopsis:   Releases the pool
//
//  Arguments:  none
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
BOOL CPool::ReleaseMemory( void )
{
    TraceFunctEnter( "CPool::ReleaseMemory" );

	BOOL	bFree = TRUE;
	DWORD	i, cStart;

    EnterCriticalSection( &m_PoolCriticalSection );

	for ( i=cStart=0; i<m_cFragments; i++, cStart += m_cFragmentInstances )
	{
		LPVOID	pHeap = m_pFragments[i];
		if ( pHeap != NULL )
		{
			_ASSERT( cStart < m_cNumberCommitted );

			DWORD	cSize = min( m_cFragmentInstances, m_cNumberCommitted-cStart );

			_VERIFY( bFree = VirtualFree( pHeap, cSize*m_cInstanceSize, MEM_DECOMMIT ) );
			_VERIFY( bFree &=VirtualFree( pHeap, 0, MEM_RELEASE ) );

			if ( bFree == FALSE )
			{
				ErrorTrace( (LPARAM)this, "VirtualFree failed: err %d", GetLastError() );
				break;
			}	

			m_pFragments[i] = NULL;
		}
		else
		{
			break;
		}
	}
    LeaveCriticalSection( &m_PoolCriticalSection );

	//
	// zero out important data fields
	//
    m_pFreeList = NULL;
    m_pExtraFreeLink = NULL;

	m_cNumberCommitted = 0;

	return	bFree;
}

#ifdef CPOOL_DEBUG
//+---------------------------------------------------------------
//
//  Function:   InitDebugInstance
//
//  Synopsis:   sets up the appropriate debug class variables
//
//  Arguments:  void* pInstance: the new instance
//				DWORD dwPoolSignature: parent Pool signature
//				DWORD cInstanceSize: size of the enlarged instance
//
//  Returns:    void
//
//  History:    gordm		Created			11 Jan 1996
//
//----------------------------------------------------------------
void InitDebugInstance(
	char* pInstance,
	DWORD dwPoolSignature,
	DWORD cInstanceSize,
	LPVOID pPoolFragment
	)
{
	CPoolDebugHead* pHead = new( pInstance ) CPoolDebugHead();
	CPoolDebugTail* pTail = new( pInstance +
								 cInstanceSize -
								 sizeof(CPoolDebugTail) ) CPoolDebugTail();

	pHead->m_pTailDebug = pTail;
	pTail->m_pHeadDebug = pHead;

	//
	// helps with debugging to see the parent CPool signature
	//
	pHead->m_dwPoolSignature = dwPoolSignature;

	//
	// helps with asserts for valid ranges
	//
	pHead->m_PoolFragment = pPoolFragment;

	//
	// fake out the state before calling mark Free
	//
	pHead->m_dwState = USED_STATE;
	pHead->MarkFree( dwPoolSignature, cInstanceSize );
}
#endif


//+---------------------------------------------------------------
//
//  Function:   GrowPool
//
//  Synopsis:   grows the number of committed instances in the pool
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    gordm		Created			5 Jul 1995
//
//----------------------------------------------------------------
void CPool::GrowPool( void )
{
#ifdef	ALLOC_TRACING
    TraceFunctEnter( "CPool::GrowPool" );
#endif

	DWORD	cFragment = m_cNumberCommitted / m_cFragmentInstances;
	DWORD	cStart = m_cNumberCommitted % m_cFragmentInstances;
	DWORD   cbSize = (cStart+m_cIncrementInstances) * m_cInstanceSize;

#ifdef	ALLOC_TRACING
	DebugTrace( (LPARAM)this, "Expanding the pool to %d descriptors",
				cNewCommit );
#endif

	//
	// if we're starting a new fragment
	//
	if ( cStart == 0 )
	{
		//
		// if we are at a boundary of a fragment Reserve the next fragment
		m_pFragments[cFragment] = VirtualAlloc(
									NULL,
									m_cFragmentInstances*m_cInstanceSize,
									MEM_RESERVE | MEM_TOP_DOWN,
									PAGE_NOACCESS
									);

		if ( m_pFragments[cFragment] == NULL )
		{
#ifdef ALLOC_TRACING
			ErrorTrace( (LPARAM)this,
						"Could not reserve more memory: error = %d",
						GetLastError() );
#endif
			return;
		}

	}

	LPVOID	pHeap = m_pFragments[cFragment];

	if ( VirtualAlloc(  pHeap,
						cbSize,
						MEM_COMMIT,
						PAGE_READWRITE ) != NULL )
	{
        char* pStart = (char*)pHeap + cStart*m_cInstanceSize;
        char* pLast =  (char*)pHeap + cbSize - m_cInstanceSize;

		//
		// run the list joining the next pointers
		// possible because we own the critsec
		//
        for ( char* p=pStart; p<pLast; p+=m_cInstanceSize)
        {

#ifdef CPOOL_DEBUG
			InitDebugInstance( p, m_dwSignature, m_cInstanceSize, pHeap );
#endif
			//
			// statement works for CPOOL_DEBUG as well because
			// we reserve the first 4 bytes of CPoolDebugHead
			//
			((Link*)p)->pNext = (Link*)(p+m_cInstanceSize);
		}

		//
		// terminate and then set the head to beginning of new list
		//
#ifdef CPOOL_DEBUG
		InitDebugInstance( pLast, m_dwSignature, m_cInstanceSize, pHeap );
#endif

		((Link*)pLast)->pNext = NULL;
		m_pFreeList = (Link*)pStart;

		m_cNumberCommitted += m_cIncrementInstances;
	}

#ifdef	ALLOC_TRACING
	else
	{
		ErrorTrace( (LPARAM)this,
					"Could not commit another descriptor: error = %d",
					GetLastError() );
	}
    TraceFunctLeave();
#endif

}


//+---------------------------------------------------------------
//
//  Function:   GetContentionCount
//
//  Synopsis:   Returns the contention count on the alloc/free
//				critsec
//
//  Arguments:  void
//
//  Returns:    the actual count
//
//----------------------------------------------------------------
DWORD CPool::GetContentionCount( void )
{
	return	m_PoolCriticalSection.DebugInfo != NULL ?
			m_PoolCriticalSection.DebugInfo->ContentionCount :
			0 ;
}

//+---------------------------------------------------------------
//
//  Function:   GetEntryCount
//
//  Synopsis:   Returns the entry count on the alloc/free
//				critsec
//
//  Arguments:  void
//
//  Returns:    the actual count
//
//----------------------------------------------------------------
DWORD CPool::GetEntryCount( void )
{
	return	m_PoolCriticalSection.DebugInfo != NULL ?
			m_PoolCriticalSection.DebugInfo->EntryCount :
			0 ;
}



//+---------------------------------------------------------------
//
//  Function:   GetInstanceSize
//
//  Synopsis:   Returns the application's instance size
//
//  Arguments:  void
//
//  Returns:    the instance size of the app
//
//----------------------------------------------------------------
DWORD CPool::GetInstanceSize( void )
{
#ifdef CPOOL_DEBUG
	return	m_cInstanceSize - sizeof(CPoolDebugHead) - sizeof(CPoolDebugTail);
#else
	return	m_cInstanceSize;
#endif
}



#ifdef DEBUG
//+---------------------------------------------------------------
//
//  Function:   IsValid
//
//  Synopsis:   Validates the pool signature
//
//  Arguments:  void
//
//  Returns:    TRUE is success, else FALSE
//
//  History:    HowardCu    Created         8 May 1995
//
//----------------------------------------------------------------
inline void CPool::IsValid( void )
{
	_ASSERT( m_cMaxInstances != 0 );
	_ASSERT( m_cInstanceSize >= sizeof(struct Link) );
	_ASSERT( m_cIncrementInstances != 0 );
	_ASSERT( m_dwSignature != 0 );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\wizpages.h ===
#ifndef _WIZPAGES_H
#define _WIZPAGES_H

HPROPSHEETPAGE CreatePage(int nID, DLGPROC pDlgProc);

BOOL CALLBACK pWelcomePageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK pUpgradePageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK pMaintanencePageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK pEULAPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK pFreshPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK pEndPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);

void SetIMSSetupMode(DWORD dwSetupMode);
DWORD GetIMSSetupMode();

BOOL CleanPathString(LPTSTR szPath);
BOOL GetParentDir(LPCTSTR szPath, LPTSTR szParentDir);
BOOL AppendDir(LPCTSTR szParentDir, LPCTSTR szSubDir, LPTSTR szResult);

void PopupOkMessageBox(DWORD dwMessageId, LPCTSTR szCaption = NULL);
int PopupYesNoMessageBox(DWORD dwMessageId);
void OnPaintBitmap(HWND hdlg, HDC hdc, int n, RECT *hRect);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\setup\utils.h ===
#ifndef UTILS_H
#define UTILS_H

#include <stdarg.h>

BOOL ParseInfLineArguments(LPCTSTR szLine, LPTSTR szAttribute, LPTSTR szValue);

BOOL GetRootDirectory(LPCTSTR szDirectory, LPTSTR szRootDir, DWORD cbLength);
BOOL IsDirectoryLexicallyValid(LPCTSTR szPath);
BOOL IsVolumeNtfs(LPCTSTR szDisk);
BOOL AnyNtfsVolumesOnLocalMachine(LPTSTR szFirstNtfsVolume);

DWORD GetUnattendedMode(HANDLE hUnattended, LPCTSTR szSubcomponent);
DWORD GetUnattendedModeFromSetupMode(
			HANDLE	hUnattended, 
			DWORD	dwComponent,
			LPCTSTR	szSubcomponent);

BOOL DetectExistingSmtpServers();
BOOL DetectExistingIISADMIN();

BOOL AddServiceToDispatchList(LPTSTR szServiceName);
BOOL RemoveServiceFromDispatchList(LPTSTR szServiceName);

BOOL GetFullPathToProgramGroup(DWORD dwMainComponent, CString &csGroupName, BOOL fIsMcisGroup);
BOOL GetFullPathToAdminGroup(DWORD dwMainComponent, CString &csGroupName);
BOOL RemoveProgramGroupIfEmpty(DWORD dwMainComponent, BOOL fIsMcisGroup);

BOOL CreateInternetShortcut(DWORD dwMainComponent, int dwDisplayNameId, int dwUrlId, BOOL fIsMcisGroup);
BOOL RemoveInternetShortcut(DWORD dwMainComponent, int dwDisplayNameId, BOOL fIsMcisGroup);

BOOL CreateNt5InternetShortcut(DWORD dwMainComponent, int dwDisplayNameId, int dwUrlId);
BOOL RemoveNt5InternetShortcut(DWORD dwMainComponent, int dwDisplayNameId);

BOOL RemoveMCIS10MailProgramGroup();
BOOL RemoveMCIS10NewsProgramGroup();

BOOL CreateUninstallEntries(LPCTSTR szInfFile, LPCTSTR szDisplayName);
BOOL RemoveUninstallEntries(LPCTSTR szInfFile);

BOOL CreateISMLink();
BOOL RemoveISMLink();

void SetProductName();

void MyAddItem(LPCTSTR szGroupName, LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR csDir);
void MyDeleteItem(LPCTSTR szGroupName, LPCTSTR szAppName);
void MyDeleteItemEx(LPCTSTR szGroupName, LPCTSTR szAppName);

BOOL UpdateServiceParameters(LPCTSTR szServicename);
BOOL RemapServiceParameters(LPCTSTR szServicename, DWORD dwBase, DWORD dwRegionSize, DWORD dwNewBase);

void GetInetpubPathFromMD(CString& csPathInetpub);

BOOL GetActionFromCheckboxStateOnly(LPCTSTR SubcomponentId, ACTION_TYPE *pAction);

BOOL ReformatDomainRoutingEntries(LPCTSTR szServiceName);

HRESULT RegisterSEOService();
HRESULT RegisterSEOForSmtp(BOOL fSetUpSourceType);

BOOL InsertSetupString( LPCSTR REG_PARAMETERS );

HRESULT UnregisterSEOSourcesForNNTP(void);
HRESULT UnregisterSEOSourcesForSMTP(void);

BOOL EnableSnapInExtension( IN CString &csMMCDocFilePath, IN LPCWSTR lpwszExtSnapInCLSID, IN BOOL bEnable ) ;
BOOL EnableCompMgmtExtension( IN LPCWSTR lpwszExtSnapInCLSID, IN LPCWSTR lpwszSnapInName, IN BOOL bEnable );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\shuttle\cobjid.cpp ===
//#---------------------------------------------------------------
//  File:		CObjID.cpp
//        
//	Synopsis:	This file implements the CObjectID class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//----------------------------------------------------------------
#ifdef	THIS_FILE
#undef	THIS_FILE
#endif
static	char		__szTraceSourceFile[] = __FILE__;
#define	THIS_FILE	__szTraceSourceFile

#include	<windows.h>
#include	"cobjid.h"
#include	"dbgtrace.h"
//+---------------------------------------------------------------
//
//  Function:	CObjectID
//
//  Synopsis:	constructor
//
//  Arguments:	void
//
//  Returns:	void
//
//  History:	HowardCu	Created			8 May 1995
//
//----------------------------------------------------------------
CObjectID::CObjectID( void )
{
	TraceFunctEnter( "CObjectID::CObjectID" );
	m_dwObjectID = INITIALOBJECTID;
	InitializeCriticalSection( &m_ObjIDCritSect );
	TraceFunctLeave();
}

//+---------------------------------------------------------------
//
//  Function:	~CObjectID
//
//  Synopsis:	destructor
//
//  Arguments:	void
//
//  Returns:	void
//
//  History:	HowardCu	Created			8 May 1995
//
//----------------------------------------------------------------
CObjectID::~CObjectID( void )
{
	TraceFunctEnter( "CObjectID::~CObjectID" );
	DeleteCriticalSection( &m_ObjIDCritSect );
	TraceFunctLeave();
}

//+---------------------------------------------------------------
//
//  Function:	GetUniqueID
//
//  Synopsis:	generate the next object ID
//
//  Arguments:	void
//
//  Returns:	next object ID
//
//  History:	HowardCu	Created			8 May 1995
//
//----------------------------------------------------------------
DWORD 
CObjectID::GetUniqueID( 
	void
	)
{
	DWORD	dwReturnValue;

	TraceFunctEnter( "CObjectID::GetUniqueID" );
	EnterCriticalSection( &m_ObjIDCritSect );
	m_dwObjectID += OBJECTIDINCREMENT;
	if( m_dwObjectID == 0 )
	{
		m_dwObjectID = INITIALOBJECTID;
	}
	dwReturnValue = m_dwObjectID;
	LeaveCriticalSection( &m_ObjIDCritSect );
	DebugTrace( m_dwObjectID, "New object ID assigned 0x%08lx.", m_dwObjectID );
	TraceFunctLeave();
	return dwReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\shuttle\pxpacket.cpp ===
//#---------------------------------------------------------------
//  File:       pxpacket.cpp
//        
//  Synopsis:   This class contains the implementation of the 
//				CProxyPacket class.
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    t-alexwe
//----------------------------------------------------------------

#include <windows.h>
#include <winsock.h>
#include "dbgtrace.h"
#include "pxpacket.h"

//+----------------------------------------------------------------------
//
//	Function: 	PProxyPacket
//
//	Synopsis: 	constructor
//	
//	History:	t-alexwe				Created				19 July 1995
//
//-----------------------------------------------------------------------
CProxyPacket::CProxyPacket() 
{
	clear();
}

//+----------------------------------------------------------------------
//
//	Function: 	~ProxyConnector
//
//	Synopsis: 	destructor
//	
//	History:	t-alexwe				Created				19 July 1995
//
//-----------------------------------------------------------------------
CProxyPacket::~CProxyPacket()
{
	clear();
}

//+----------------------------------------------------------------------
//
//	Function: 	addMessage
//
//	Synopsis: 	Adds a message to the packet.  the message data is assumed
//				to have been written to the area returned by 
//				getNextDataPointer().  cData must be <= getAvailableSpace()
//	
//	Arguments:	wCommand	  - the message command
//				cData		  - number of bytes of data
//
//	History:	t-alexwe				Created				19 July 1995
//
//-----------------------------------------------------------------------
void CProxyPacket::addMessage(	WORD		wCommand,
								WORD		cData	)
{
	TraceFunctEnter("CProxyPacket::AddMessage");

	_ASSERT(cData <= getAvailableSpace());
	_ASSERT(cMessages < MAXMSGSPERPACKET);

	DebugTrace((LPARAM) this, "adding message: wCommand = 0x%x  cData = %i",
		wCommand, cData);

	pMessages[cMessages].wCommand = wCommand;
	pMessages[cMessages].cOffset = cLength - PACKETHDRSIZE;
	pMessages[cMessages].cData = cData;
	cLength += cData;
	cMessages++;

	TraceFunctLeave();
}

//+----------------------------------------------------------------------
//
//	Function: 	getMessage
//
//	Synopsis: 	Gets the data pointer, size of data, and command from
//				a message in a packet.  
//	
//	Arguments:	wIndex		  - the message index in the packet
//				pwCommand	  - returned: the message command
//				cData		  - returned: the size of the data buffer
//
//	Returns:	pointer to the data buffer, or NULL on error.
//
//	History:	t-alexwe				Created				19 July 1995
//
//-----------------------------------------------------------------------
PVOID CProxyPacket::getMessage(	WORD		wIndex,
								PWORD		pwCommand,
								PWORD		pcData	)
{
	TraceFunctEnter("CProxyPacket::GetMessage");
	WORD cOffset = pMessages[wIndex].cOffset;

	_ASSERT(wIndex < getMessageCount());

	*pcData = pMessages[wIndex].cData;
	//
	// make sure that the data length is valid
	//
	// algorithm:  if this is the last message then make sure that
	// the data count is the same as the amount of space left in the
	// packet data area.  if this is not the last message make sure
	// that the space in the packet data area (marked by the messages
	// cOffset and the next messages cOffset) is the same size as
	// the messages cData.
	//
	if (!(((wIndex == cMessages - 1) &&
		  (*pcData == cLength - PACKETHDRSIZE - cOffset)) ||
		 (*pcData == pMessages[wIndex + 1].cOffset - cOffset))) 
	{
		TraceFunctLeave();
		return NULL;
	} else
	{
		*pwCommand = pMessages[wIndex].wCommand;
		DebugTrace((LPARAM) this, "getting msg: wCommand = 0x%x  cData = %i",
			*pwCommand, *pcData);
		TraceFunctLeave();
		return &(pData[pMessages[wIndex].cOffset]);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\simauth2\encode.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name:
      encoded.cpp

   Abstract:
      This module is copied from IIS fcache.cxx which contains the encoding/decoding routines.


--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>

#ifdef __cplusplus
};
#endif

#include "dbgutil.h"
#include <tcpdll.hxx>
#include <inetinfo.h>
#include "simauth2.h"

#include <dbgtrace.h>

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int _pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const int _pr2six64[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr64[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

BOOL uudecode(char   * bufcoded,
              BUFFER * pbuffdecoded,
              DWORD  * pcbDecoded,
              BOOL     fBase64
             )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout;
    int nprbytes;
    int *pr2six = (int*)(fBase64 ? _pr2six64 : _pr2six);

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(pr2six[*(bufin++)] <= 63);
    nprbytes = (int)(bufin - bufcoded - 1);
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( !pbuffdecoded->Resize( nbytesdecoded + 4 ))
        return FALSE;

    bufout = (unsigned char *) pbuffdecoded->QueryPtr();

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((CHAR *)pbuffdecoded->QueryPtr())[nbytesdecoded] = '\0';

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    return TRUE;
}


//
// NOTE NOTE NOTE
// If the buffer length isn't a multiple of 3, we encode one extra byte beyond the
// end of the buffer. This garbage byte is stripped off by the uudecode code, but
// -IT HAS TO BE THERE- for uudecode to work. This applies not only our uudecode, but
// to every uudecode() function that is based on the lib-www distribution [probably
// a fairly large percentage].
//

BOOL uuencode( BYTE *   bufin,
               DWORD    nbytes,
               BUFFER * pbuffEncoded,
               BOOL     fBase64 )
{
   unsigned char *outptr;
   unsigned int i;
   char *six2pr = fBase64 ? _six2pr64 : _six2pr;
   BOOL fOneByteDiff = FALSE;
   BOOL fTwoByteDiff = FALSE;
   unsigned int iRemainder = 0;
   unsigned int iClosestMultOfThree = 0;
   //
   //  Resize the buffer to 133% of the incoming data
   //

   if ( !pbuffEncoded->Resize( nbytes + ((nbytes + 3) / 3) + 4))
        return FALSE;

   outptr = (unsigned char *) pbuffEncoded->QueryPtr();

   iRemainder = nbytes % 3; //also works for nbytes == 1, 2
   fOneByteDiff = (iRemainder == 1 ? TRUE : FALSE);
   fTwoByteDiff = (iRemainder == 2 ? TRUE : FALSE);
   iClosestMultOfThree = ((nbytes - iRemainder)/3) * 3 ;

   //
   // Encode bytes in buffer up to multiple of 3 that is closest to nbytes.
   //
   for (i=0; i< iClosestMultOfThree ; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   //
   // We deal with trailing bytes by pretending that the input buffer has been padded with
   // zeros. Expressions are thus the same as above, but the second half drops off b'cos
   // ( a | ( b & 0) ) = ( a | 0 ) = a
   //
   if (fOneByteDiff)
   {
       *(outptr++) = six2pr[*bufin >> 2]; /* c1 */
       *(outptr++) = six2pr[((*bufin << 4) & 060)]; /* c2 */

       //pad with '='
       *(outptr++) = '='; /* c3 */
       *(outptr++) = '='; /* c4 */
   }
   else if (fTwoByteDiff)
   {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074)];/*c3*/

      //pad with '='
       *(outptr++) = '='; /* c4 */
   }

   //encoded buffer must be zero-terminated
   *outptr = '\0';

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\smtpaddr\addr821.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :

        addr821.cxx

   Abstract:

        Set of functions to parse RFC 821 addresses.

   Author:

           Keith Lau		(KeithLau)		2/17/98

   Project:

          SMTP Server DLL

   Functions Exported:
   Revision History:


--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include <windows.h>
#include <dbgtrace.h>

#include <addr821.hxx>

#define MAX_EMAIL_NAME                          64
#define MAX_DOMAIN_NAME                         250
#define MAX_INTERNET_NAME                       (MAX_EMAIL_NAME + MAX_DOMAIN_NAME + 2)

// Quick and dirty string validation
static BOOL pValidateStringPtr(LPSTR lpwszString, DWORD dwMaxLength)
{
	if (IsBadStringPtr((LPCTSTR)lpwszString, dwMaxLength))
		return(FALSE);
	while (dwMaxLength--)
		if (*lpwszString++ == 0)
			return(TRUE);
	return(FALSE);
}

// ========================================================================
//
// Validation Parser stuff created by KeithLau on 2/17/98
//

static char acOpen[] =	"\"[<(";
static char acClose[] =	"\"]>)";

//
// NOTE: RFC 821 and RFC 822 versions of this function are different!!
//
// This function finds braces pairs in a given string, and returns
// pointers to the start and end of the first occurence of a
// [nested] pair of braces. The starting and ending character
// may be specified by the caller (starting and ending chars
// must be unique).
#define MAX_STATE_STACK_DEPTH		64
#define OPEN_DELIMITER				0x1
#define CLOSE_DELIMITER				0x2
#define OPEN_AND_CLOSE_DELIMITER	(OPEN_DELIMITER | CLOSE_DELIMITER)

typedef struct _BYTE_BUCKET
{
	char	cClosingDelimiter;	// If this is an open delimiter,
								// this stores the correesponding closing
								// delimiter. Not used otherwise
	BYTE	fFlags;				// Flags, whether it is a delimiter

} BYTE_BUCKET;

static char *pFindNextUnquotedOccurrence(char		*lpszString,
										 DWORD		dwStringLength,
										 char		cSearch,
										 char		*lpszOpenDelimiters,
										 char		*lpszCloseDelimiters,
										 LPBOOL		lpfNotFound)
{
	char	rgcState[MAX_STATE_STACK_DEPTH];
	DWORD_PTR	dwState = 0;
	DWORD	dwDelimiters = 0;
	DWORD	i;
	char	ch;
	char	*lpStart = lpszString;
	BOOL	fFallThru;

	BYTE_BUCKET	rgbBucket[128];

	TraceFunctEnter("pFindNextUnquotedOccurrence");

	if (cSearch > 127)
		return(NULL);

	*lpfNotFound = FALSE;

	dwDelimiters = lstrlen(lpszOpenDelimiters);
	if (dwDelimiters != (DWORD)lstrlen(lpszCloseDelimiters))
		return(NULL);

	// Populate the bit bucket
	ZeroMemory(rgbBucket, 128 * sizeof(BYTE_BUCKET));
	for (i = 0; i < dwDelimiters; i++)
	{
		rgbBucket[lpszOpenDelimiters[i]].cClosingDelimiter = lpszCloseDelimiters[i];
		rgbBucket[lpszOpenDelimiters[i]].fFlags |= OPEN_DELIMITER;
		rgbBucket[lpszCloseDelimiters[i]].fFlags |= CLOSE_DELIMITER;
	}

	// dwState is the stack of unmatched open delimiters
	while (ch = *lpStart)
	{
		if (!dwStringLength)
			break;

		// Track the length
		dwStringLength--;

		// See if valid ASCII
		if (ch > 127)
			return(NULL);

		// If we are not in any quotes, and the char is found,
		// then we are done!
		if (!dwState && (ch == cSearch))
		{
			DebugTrace((LPARAM)0, "Found %c at %p", ch, lpStart);
			return(lpStart);
		}

		// If it is a quoted char, we can skip it and the following
		// char right away ... If the char following a quote '\' is
		// the terminating NULL, we have an error.
		if (ch == '\\')
		{
			lpStart++;
			if (!*lpStart)
				return(NULL);

			dwStringLength--;
		}
		else
		{
			// Check the close case, too
			fFallThru = TRUE;

			// See if we have an opening quote of any sort
			if (rgbBucket[ch].fFlags & OPEN_DELIMITER)
			{
				// This is used to take care of the case when the
				// open and close delimiters are the same. If it is
				// an open delimiter, we do not check the close
				// case unless the close delimiter is the same.
				fFallThru = FALSE;

				// Special case for open = close
				if (dwState &&
					rgcState[dwState-1] == ch &&
					(rgbBucket[ch].fFlags & OPEN_AND_CLOSE_DELIMITER) == OPEN_AND_CLOSE_DELIMITER)
				{
					// Stack is not empty, top of stack contains the same
					// quote, and open quote == close, this is actually a
					// close quote in disguise.
					fFallThru = TRUE;
				}
				else
				{
					// Push the new open quote in the stack
					if (dwState == MAX_STATE_STACK_DEPTH)
						return(FALSE);

					DebugTrace((LPARAM)0, "Push[%u]: %c, looking for %c",
							dwState, ch, rgbBucket[ch].cClosingDelimiter);
					rgcState[dwState++] = rgbBucket[ch].cClosingDelimiter;
				}
			}

			// See if we have a closing quote of any sort
			if (fFallThru && (rgbBucket[ch].fFlags & CLOSE_DELIMITER))
			{
				if (dwState)
				{
					// If we are closing the correct kind of quote,
					// pop the stack
					if (rgcState[dwState-1] == ch)
					{
						dwState--;
						DebugTrace((LPARAM)0, "Pop[%u] %c", dwState, ch);

						// Do a second check, in case we are looking
						// for a close quote
						if (!dwState && ch == cSearch)
						{
							DebugTrace((LPARAM)0, "Found %c at %p", ch, lpStart);
							return(lpStart);
						}
					}
					else
					{
						// Completely wrong closing brace.
						return(FALSE);
					}
				}
				else
				{
					// We are not in any quotes but we still see a
					// closing quote, so we have reached the end of our
					// current search scope!
					// Note that this is considered as not found
					// instead of an error
					*lpfNotFound = TRUE;
					return(NULL);
				}
			}
		}
	
		lpStart++;
	}

	*lpfNotFound = TRUE;

	TraceFunctLeave();
	return(NULL);
}

static inline BOOL IsCrOrLf(char ch)
{
	return(ch == '\r' || ch == '\n');
}

static inline BOOL IsControl(char ch)
{
	return( ((ch >= 0) && (ch <= 31)) || (ch == 127) );
}

//
//    <special> ::= "<" | ">" | "(" | ")" | "[" | "]" | "\" | "."
//              | "," | ";" | ":" | "@"  """ | the control
//              characters (ASCII codes 0 through 31 inclusive and
//              127)
//
static BOOL IsSpecial(char ch)
{
	switch (ch)
	{
	case '(':
	case ')':
	case '<':
	case '>':
	case '@':
	case ',':
	case ':':
	case ';':
	case '\\':
	case '\"':
	case '.':
	case '[':
	case ']':
		return(TRUE);
	default:
		return(IsControl(ch));
	}
}

static BOOL pIsSpecialOrSpace(char ch)
{
	return((ch == ' ') || (ch == '\t') || (ch == '\0') || IsSpecial(ch));
		
}

//
//    <x> ::= any one of the 128 ASCII characters (no exceptions)
//
static inline BOOL pIsX(char ch)
{
	return(TRUE);
}

//
//    <a> ::= any one of the 52 alphabetic characters A through Z
//              in upper case and a through z in lower case
//
static inline BOOL pIsA(char ch)
{
	return(((ch < 'A' || ch > 'z') || (ch > 'Z' && ch < 'a'))?FALSE:TRUE);
}

//
//    <d> ::= any one of the ten digits 0 through 9
//
static inline BOOL pIsD(char ch)
{
	return((ch < '0' || ch > '9')?FALSE:TRUE);
}

//
//    <c> ::= any one of the 128 ASCII characters, but not any
//              <special> or <SP>
//
static inline BOOL pIsC(char ch)
{
	return((ch == ' ' || IsSpecial(ch))?FALSE:TRUE);
}

//
//    <q> ::= any one of the 128 ASCII characters except <CR>,
//              <LF>, quote ("), or backslash (\)
//
static inline BOOL pIsQ(char ch)
{
	return((ch == '\"' || ch == '\\' || IsCrOrLf(ch))?FALSE:TRUE);
}

//
//    <number> ::= <d> | <d> <number>
//
static BOOL pValidateNumber(char *lpszStart, DWORD dwLength)
{
	if (!dwLength)
		return(FALSE);

	while (dwLength--)
	{
		if (!pIsD(*lpszStart++))
			return(FALSE);
	}
	return(TRUE);
}

//
//    <dotnum> ::= <snum> "." <snum> "." <snum> "." <snum>
//    <snum> ::= one, two, or three digits representing a decimal
//                 integer value in the range 0 through 255
//
static BOOL pValidateDotnum(char *lpszStart, DWORD dwLength)
{
	char	ch;
	DWORD	dwSnums = 0;
	DWORD	dwNumLength = 0;
	DWORD	dwValue = 0;

	if (!dwLength || dwLength > 15)
		return(FALSE);

	while (dwLength--)
	{
		ch = *lpszStart++;

		if (pIsD(ch))
		{
			// Do each digit and calculate running total
			dwValue *= 10;
			dwValue += (ch - '0');
			dwNumLength++;
		}
		else if (ch == '.')
		{
			// There must be a number before each dot and
			// the running total must be between 0 and 255
			if (!dwNumLength)
				return(FALSE);
			if (dwValue > 255)
				return(FALSE);

			// Reset the counter
			dwSnums++;
			dwValue = 0;
			dwNumLength = 0;
		}
		else
			return(FALSE);
	}

	// Do the last snum
	if (!dwNumLength)
		return(FALSE);
	if (dwValue > 255)
		return(FALSE);
	dwSnums++;

	// Each IP address must have 4 snums
	if (dwSnums != 4)
		return(FALSE);
	return(TRUE);
}

//
//    <quoted-string> ::=  """ <qtext> """
//    <qtext> ::=  "\" <x> | "\" <x> <qtext> | <q> | <q> <qtext>
//
static BOOL pValidateQuotedString(char *lpszStart, DWORD dwLength)
{
	char	ch;

	// At least 3 chars
	if (dwLength < 3)
		return(FALSE);
	
	// Must begin and end with double quotes
	if (lpszStart[0] != '\"' || lpszStart[dwLength-1] != '\"')
		return(FALSE);

	// Factor out the quotes
	dwLength -= 2;
	lpszStart++;

	// The inside must be <qtext>
	while (dwLength--)
	{
		ch = *lpszStart++;

		// Each character must be either an escape pair or <q>
		if (ch == '\\')
		{
			if (!dwLength)
				return(FALSE);
			dwLength--;
			lpszStart++;
		}
		else if (!pIsQ(ch))
			return(FALSE);
	}
	return(TRUE);
}

//
//    <dot-string> ::= <string> | <string> "." <dot-string>
//    <string> ::= <char> | <char> <string>
//    <char> ::= <c> | "\" <x>
//
static BOOL pValidateDotString(char *lpszStart, DWORD dwLength)
{
	char	ch;
	BOOL	fChar = FALSE;

	if (!dwLength)
		return(FALSE);
	
	while (dwLength--)
	{
		ch = *lpszStart++;

		if (ch == '\\')
		{
			// Escape pair
			if (!dwLength)
				return(FALSE);
			dwLength--;
			lpszStart++;
			fChar = TRUE;
		}
		else if (ch == '.')
		{
			// 1) Must not start with a dot,
			// 2) Consecutive dots are not allowed
			if (!fChar)
				return(FALSE);

			// Reset the flag
			fChar = FALSE;
		}
		else if (pIsC(ch))
			fChar = TRUE;
		else
			return(FALSE);
	}

	// Cannot end with a dot
	if (ch == '.')
		return(FALSE);
	return(TRUE);
}

//
// Note: Original RFC 821:
//    <name> ::= <a> <ldh-str> <let-dig>
//    <ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>
//    <let-dig> ::= <a> | <d>
//    <let-dig-hyp> ::= <a> | <d> | "-"
//
// Our implementation:
//    <name> ::= <let-dig-hyp-und> | <let-dig-hyp-und> <name>
//    <let-dig-hyp-und> ::= <a> | <d> | "-" | "_"
//
// Reasons:
// 1) 3COM start their domains with a digit
// 2) Some customers start their domain names with underscores,
//    and some comtain underscores.
//
static BOOL pValidateName(char *lpszStart, DWORD dwLength)
{
	char	ch;

	if (!dwLength)
		return(FALSE);
	
	while (dwLength--)
	{
		ch = *lpszStart++;

		if (pIsA(ch) || pIsD(ch) || ch == '-' || ch == '_')
			;
		else
			return(FALSE);
	}
	return(TRUE);
}

//
//    <local-part> ::= <dot-string> | <quoted-string>
//
static BOOL pValidateLocalPart(char *lpszStart, DWORD dwLength)
{
	if (!dwLength)
		return(FALSE);
	
	return(pValidateDotString(lpszStart, dwLength) ||
			pValidateQuotedString(lpszStart, dwLength));
}

//
//    <element> ::= <name> | "#" <number> | "[" <dotnum> "]"
//
static BOOL pValidateElement(char *lpszStart, DWORD dwLength)
{
	char	ch;

	if (!dwLength)
		return(FALSE);

	ch = *lpszStart;
	if (ch == '#')
		// This is the # <number> form
		return(pValidateNumber(lpszStart+1, dwLength-1));
	else if (ch == '[')
	{
		if (lpszStart[dwLength-1] != ']')
			return(FALSE);

		// This is a domain literal
		return(pValidateDotnum(lpszStart+1, dwLength-2));
	}

	// Validate as a name
	return(pValidateName(lpszStart, dwLength));
}

//
//  sub-domain ::= let-dig *(ldh-str)
//  ldh-str = *( Alpha / Digit / "-" ) let-dig
//	let-dig = Alpha / Digit
//
static BOOL pValidateDRUMSSubDomain(char *lpszStart, DWORD dwLength)
{
	unsigned char	ch;
    DWORD ec;
	if (!dwLength)
		return(FALSE);

	// validate all of the characters in the name
	while (dwLength--)
	{
		ch = (unsigned char) *lpszStart++;
        // this list of characters comes from NT, dnsvldnm.doc.  we
        // also allow #, [, and ]
        if ((ch >= 1 && ch <= 34) ||
            (ch >= 36 && ch <= 41) ||
            (ch == 43) ||
            (ch == 44) ||
            (ch == 47) ||
            (ch >= 58 && ch <= 64) ||
            (ch == 92) ||
            (ch == 94) ||
            (ch == 96) ||
            (ch >= 123))
        {
            return FALSE;
        }
	} //while

	//We have a valid subdomain
	return (TRUE);
}

//
// ======================================================
//

BOOL FindNextUnquotedOccurrence(char	*lpszString,
                                DWORD	dwStringLength,	
                                char	cSearch,
                                char	**ppszLocation)
{
    BOOL fNotFound = FALSE;
    *ppszLocation = pFindNextUnquotedOccurrence(lpszString,
                                    dwStringLength,cSearch, acOpen,acClose, &fNotFound);

    if (!*ppszLocation)
    {
            // If failed but not because of not found, then bad line
            if (!fNotFound)
            {
                SetLastError(ERROR_INVALID_DATA);
                return FALSE;
            }
    }
    return TRUE;

}

//
// This function extracts an email address from the given command line
// and returns the tail of the line after the address. Any angle braces
// present will be included as part of the 821 address. The returned
// address is not validated at all.
//
BOOL Extract821AddressFromLine(	char	*lpszLine,
								char	**ppszAddress,
								DWORD	*pdwAddressLength,
								char	**ppszTail)
{
	DWORD	dwAddressLength = 0;
	char	*pAddressEnd;
	BOOL	fNotFound;

    TraceFunctEnter("Extract821AddressFromLine");

	_ASSERT(lpszLine);
	_ASSERT(ppszAddress);
	_ASSERT(pdwAddressLength);
	_ASSERT(ppszTail);

	// Initialize
	*ppszAddress = lpszLine;
	*pdwAddressLength = 0;
	*ppszTail = lpszLine;

	// Routine checking
	if (!lpszLine ||
		!pValidateStringPtr(lpszLine, MAX_INTERNET_NAME+1) ||
		!ppszAddress ||
		IsBadWritePtr(ppszAddress, sizeof(char *)) ||
		!ppszTail ||
		IsBadWritePtr(ppszTail, sizeof(char *)) ||
		!pdwAddressLength ||
		IsBadWritePtr(pdwAddressLength, sizeof(DWORD)))
	{
		SetLastError(ERROR_INVALID_DATA);
		TraceFunctLeave();
		return(FALSE);		
	}

	// Skip all leading spaces
	while (*lpszLine == ' ')
		lpszLine++;

	// The first unquoted space indicates the end of the address
	pAddressEnd = pFindNextUnquotedOccurrence(lpszLine,
						lstrlen(lpszLine), ' ', acOpen, acClose, &fNotFound);
	if (!pAddressEnd)
	{
		// If failed but not because of not found, then bad line
		if (!fNotFound)
			return(FALSE);

		// Space not found, the entire line is the address
		dwAddressLength = lstrlen(lpszLine);
		pAddressEnd = lpszLine + dwAddressLength;
		*ppszTail = pAddressEnd;
	}
	else
	{
		// Calculate the length
		dwAddressLength = (DWORD)(pAddressEnd - lpszLine);

		// Get the start of the tail, after all the spaces
		while (*pAddressEnd == ' ')
			pAddressEnd++;
		*ppszTail = pAddressEnd;
	}

	if (dwAddressLength < 1)
		return(FALSE);

	*ppszAddress = lpszLine;
	*pdwAddressLength = dwAddressLength;

	DebugTrace((LPARAM)0, "Extracted \"%*s\"", dwAddressLength, lpszLine);

	TraceFunctLeave();
	return(TRUE);
}

//
// This function takes in a RFC 821 address with optional angle braces
// and extracts the canonical form of the address. All at-domain-list
// entries are removed. Angle braces will be matched and removed.
// Mismatched angle braces are considered invalid. The returned address
// will be in the <local-part> "@" <domain> form.
//
// There must be no leading or trailing spaces included.
//
// jstamerj 1999/01/13 14:02:13: Modified to remove a trailing '.' from the <domain> portion of the address
//
BOOL ExtractCanonical821Address(	char	*lpszAddress,
									DWORD	dwAddressLength,
									char	**ppszCanonicalAddress,
									DWORD	*pdwCanonicalAddressLength)
{
	char	*pAddressStart;
	BOOL	fNotFound;

    TraceFunctEnter("ExtractCanonical821Address");

	_ASSERT(lpszAddress);
	_ASSERT(ppszCanonicalAddress);
	_ASSERT(pdwCanonicalAddressLength);

	// Initialize
	*ppszCanonicalAddress = lpszAddress;
	*ppszCanonicalAddress = 0;

	// Routine checking
	if (!lpszAddress ||
		!pValidateStringPtr(lpszAddress, MAX_INTERNET_NAME+1) ||
		!ppszCanonicalAddress ||
		IsBadWritePtr(ppszCanonicalAddress, sizeof(char *)) ||
		!pdwCanonicalAddressLength ||
		IsBadWritePtr(pdwCanonicalAddressLength, sizeof(DWORD)))
	{
		SetLastError(ERROR_INVALID_DATA);
		TraceFunctLeave();
		return(FALSE);		
	}

	// See how many layers of nesting we have, and match
	// each pair of angle braces
	while (*lpszAddress == '<')
	{
		if (!dwAddressLength--)
			return(FALSE);

		if (lpszAddress[dwAddressLength] != '>')
			return(FALSE);

		if (!dwAddressLength--)
			return(FALSE);

		lpszAddress++;
	}


	// Next, skip all at-domain-list entries and get to
	// the meat of the address
	do
	{
		// Skip all leading spaces
		while (*lpszAddress == ' ')
		{
			lpszAddress++;
			if (!dwAddressLength--)
				return(FALSE);
		}

		//skip all the trailing spaces
		while (*(lpszAddress + dwAddressLength - 1) == ' ')
		{
			if (!dwAddressLength--)
				return(FALSE);
		}


		// Initialize lest it falls through right away
		pAddressStart = lpszAddress;

		if (*lpszAddress == '@')
		{
			// Yep, there's a domain route there ...
			// Skip it ...
			pAddressStart = pFindNextUnquotedOccurrence(lpszAddress,
								dwAddressLength, ',', acOpen, acClose, &fNotFound);
			if (!pAddressStart)
			{
				if (!fNotFound)
					return(FALSE);

				// No comma, now see if we get a semicolon
				pAddressStart = pFindNextUnquotedOccurrence(lpszAddress,
									dwAddressLength, ':', acOpen, acClose, &fNotFound);
				if (!pAddressStart)
				{
					// No semicolon either, this is a bad address
					return(FALSE);
				}

				// This is a semicolon, so we break out
				pAddressStart++;
				dwAddressLength -= (DWORD)(pAddressStart - lpszAddress);
				break;
			}

			// We have a comma, we let it iterate
			pAddressStart++;
			dwAddressLength -= (DWORD)(pAddressStart - lpszAddress);

			lpszAddress = pAddressStart;
		}
		else
			break;

	} while (dwAddressLength);

	// Skip all leading spaces
	while (*pAddressStart == ' ')
	{
		pAddressStart++;
		if (!dwAddressLength--)
			return(FALSE);
	}
    if((dwAddressLength > 1) && // Must be at least 2 for the address "@."
       (pAddressStart[dwAddressLength-1] == '.')) {
        //
        // jstamerj 1999/01/13 14:05:39:
        //  If the domain part of the address has a trailing '.', do
        //  not count it in the canonical length
        //
        LPSTR pDomain;
        BOOL fNotFound;
        // Find the domain
        pDomain = pFindNextUnquotedOccurrence(
            pAddressStart,
            dwAddressLength - 1, 
            '@', 
            acOpen, 
            acClose, 
            &fNotFound);
        //
        // If we found the '@' and the '.' is after the '@' (it must
        // be if we really found it), then shorten the canonical
        // address so that it doesn't include '.'
        //
        if((fNotFound == FALSE) &&
           (&(pAddressStart[dwAddressLength]) > pDomain))
            dwAddressLength--;
    }

	// Fill in the output
	*ppszCanonicalAddress = pAddressStart;
	*pdwCanonicalAddressLength = dwAddressLength;

	DebugTrace((LPARAM)0, "Extracted \"%*s\"", dwAddressLength, pAddressStart);

	TraceFunctLeave();
	return(TRUE);		
}

//
// This function takes in a RFC 821 domain in canonical form
// and validates it according to the RFC 821 grammar
// (some modifications for real-life scenarios)
//
// <domain> ::=  <element> | <element> "." <domain>
//
BOOL Validate821Domain(	char	*lpszDomain,
						DWORD	dwDomainLength)
{
	char	*pSubdomainOffset;
	DWORD	dwSubdomainLength;
	BOOL	fNotFound;

    TraceFunctEnter("Validate821Domain");

	_ASSERT(lpszDomain);

	// Routine checking
	if (!lpszDomain ||
		!pValidateStringPtr(lpszDomain, MAX_INTERNET_NAME+1))
	{
		SetLastError(ERROR_INVALID_DATA);
		TraceFunctLeave();
		return(FALSE);		
	}

	// Find each subdomain
	do
	{
		pSubdomainOffset = pFindNextUnquotedOccurrence(lpszDomain,
							dwDomainLength,  '.', acOpen, acClose, &fNotFound);
		if (!pSubdomainOffset)
		{
			if (!fNotFound)
			{
				SetLastError(ERROR_INVALID_DATA);
				return(FALSE);
			}

			// Not found and nothing left, domain ends with a dot, invalid.
			if (!dwDomainLength)
			{
				SetLastError(ERROR_INVALID_DATA);
				return(FALSE);
			}

			// No domain, so email alias is all there is
			dwSubdomainLength = dwDomainLength;
		}
		else
		{
			// Calculate domain parameters
			dwSubdomainLength = (DWORD)(pSubdomainOffset - lpszDomain);

			// Adjust for the dot
			dwDomainLength--;
		}

		// Cannot allow leading dot or consecutive dots
		if (!dwSubdomainLength)
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		// Check each subdomain as an element
		if (!pValidateElement(lpszDomain, dwSubdomainLength))
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		// Adjust the length and pointers
		dwDomainLength -= dwSubdomainLength;

		// Skip past dot and scan again
		lpszDomain = pSubdomainOffset + 1;

	} while (dwDomainLength);

	// Make sure no dot's found, either
	if (!fNotFound)
	{
		// If a dot's found, the domain ends with a dot and it's uncool.
		SetLastError(ERROR_INVALID_DATA);
		return(FALSE);
	}

	TraceFunctLeave();
	return(TRUE);
}

//
// This function takes in a DRUMS domain in canonical form
// and validates it strictly, according to the DRUMS grammar
//
// Domain ::= sub-domain 1*("." sub-domain) | address-literal
//   address-literal ::= "[" IPv4-address-literal |
//                  IPv6-address-literal | General-address-literal "]"
//   IPv4-address-literal ::= snum 3("." snum)
//   IPv6-address-literal ::= "IPv6" SP <<what did we finally decide on?>>
//   General-address-literal ::= Standardized-tag SP String
//   Standardized-tag ::= String (Specified in a standards-track RFC
//                                and registered with IANA)
//   snum = one, two, or three digits representing a decimal
//     integer value in the range 0 through 255

BOOL ValidateDRUMSDomain(	char	*lpszDomain, 
                            DWORD   dwDomainLength) 	
{

	char	*pSubdomainOffset;
	DWORD	dwSubdomainLength;
	BOOL	fNotFound;
	char    *szEndofString;

    TraceFunctEnter("Validate821Domain");

	_ASSERT(lpszDomain);

	// Routine checking
	if (!dwDomainLength || dwDomainLength > MAX_INTERNET_NAME)
			return(FALSE);

	if (!lpszDomain ||
		!pValidateStringPtr(lpszDomain, MAX_INTERNET_NAME+1))
	{
		SetLastError(ERROR_INVALID_DATA);
		TraceFunctLeave();
		return(FALSE);		
	}

	// Skip all leading spaces
	while (*lpszDomain == ' ')
        lpszDomain++;

	//It has to be either in address-literal format or subdomain format
	//
	if (*lpszDomain == '[')
	{
		//It is an Address literal
		//Skip trailing white space
		szEndofString = &lpszDomain[lstrlen(lpszDomain) - 1];
		while(*szEndofString == ' ')
			szEndofString--;

		if (*szEndofString != ']')
			return(FALSE);

		// This is a domain literal
		return(pValidateDotnum(lpszDomain+1, dwDomainLength-2));
	}
	else
	{
		//This is in subdomain format
		do
		{
			pSubdomainOffset = pFindNextUnquotedOccurrence(lpszDomain,
								dwDomainLength,  '.', acOpen, acClose, &fNotFound);
			if (!pSubdomainOffset)
			{
				if (!fNotFound)
				{
					SetLastError(ERROR_INVALID_DATA);
					return(FALSE);
				}

				// Not found and nothing left, domain ends with a dot, invalid.
				if (!dwDomainLength)
				{
					SetLastError(ERROR_INVALID_DATA);
					return(FALSE);
				}

				// No domain, so email alias is all there is
				dwSubdomainLength = dwDomainLength;
			}
			else
			{
				// Calculate domain parameters
				dwSubdomainLength = (DWORD)(pSubdomainOffset - lpszDomain);

				// Adjust for the dot
				//NimishK : **Check with Keith if this should be subdomain.
				dwDomainLength--;
			}

			// Cannot allow leading dot or consecutive dots
			if (!dwSubdomainLength)
			{
				SetLastError(ERROR_INVALID_DATA);
				return(FALSE);
			}

			// Check each subdomain
			if (!pValidateDRUMSSubDomain(lpszDomain, dwSubdomainLength))
			{
				SetLastError(ERROR_INVALID_DATA);
				return(FALSE);
			}

			// Adjust the length and pointers
			dwDomainLength -= dwSubdomainLength;

			// Skip past dot and scan again
			lpszDomain = pSubdomainOffset + 1;

		} while (dwDomainLength);

		// Make sure no dot's found, either
		if (!fNotFound)
		{
			// If a dot's found, the domain ends with a dot and it's uncool.
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		TraceFunctLeave();
		return(TRUE);

	}

	TraceFunctLeave();
	return(TRUE);
}


//
// This function takes in a RFC 821 address in canonical form
// (<local-part> ["@" <domain>]) and validates it according to the
// RFC 821 grammar (some modifications for real-life scenarios)
//
BOOL Validate821Address(	char	*lpszAddress,
							DWORD	dwAddressLength)
{
	char	*pDomainOffset;
	DWORD	dwEmailLength;
	DWORD	dwDomainLength;
	BOOL	fNotFound;

    TraceFunctEnter("Validate821Address");

	_ASSERT(lpszAddress);

	// Routine checking
	if (!lpszAddress ||
		!pValidateStringPtr(lpszAddress, MAX_INTERNET_NAME+1))
	{
		SetLastError(ERROR_INVALID_DATA);
		TraceFunctLeave();
		return(FALSE);		
	}

	// Find the domain
	pDomainOffset = pFindNextUnquotedOccurrence(lpszAddress,
						dwAddressLength, '@', acOpen, acClose, &fNotFound);
	if (!pDomainOffset)
	{
		if (!fNotFound)
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		// No domain, so email alias is all there is
		dwEmailLength = dwAddressLength;
	}
	else
	{
		// Calculate domain parameters
		dwEmailLength = (DWORD)(pDomainOffset - lpszAddress);
		dwDomainLength = dwAddressLength - dwEmailLength - 1;
		pDomainOffset++;
	}

	// Do the check for email name
	if (!pValidateLocalPart(lpszAddress, dwEmailLength))
	{
		SetLastError(ERROR_INVALID_DATA);
		return(FALSE);
	}

	// Now check domain, if applicable
	if (pDomainOffset)
	{
		return(Validate821Domain(pDomainOffset, dwDomainLength));
	}

	TraceFunctLeave();
	return(TRUE);
}

//
// This function takes in a RFC 821 address in canonical form
// (<local-part> ["@" <domain>]) and extracts the domain part
//
BOOL Get821AddressDomain(	char	*lpszAddress,
							DWORD	dwAddressLength,
							char	**ppszDomain)
{
	char	*pDomainOffset;
	BOOL	fNotFound;

    TraceFunctEnter("Get821AddressDomain");

	_ASSERT(lpszAddress);

	// Find the domain
	pDomainOffset = pFindNextUnquotedOccurrence(lpszAddress,
						dwAddressLength, '@', acOpen, acClose, &fNotFound);
	if (!pDomainOffset && !fNotFound)
	{
		SetLastError(ERROR_INVALID_DATA);
		TraceFunctLeave();
		return(FALSE);
	}
	
	if (fNotFound)
		*ppszDomain = NULL;
	else
		*ppszDomain = pDomainOffset + 1;
	return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\smtpaddr\address.cxx ===
/*
 * Copyright (c) 1985 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted provided
 * that: (1) source distributions retain this entire copyright notice and
 * comment, and (2) distributions including binaries display the following
 * acknowledgement:  ``This product includes software developed by the
 * University of California, Berkeley and its contributors'' in the
 * documentation or other materials provided with the distribution and in
 * all advertising materials mentioning features or use of this software.
 * Neither the name of the University nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        address.cxx

   Abstract:

        This module defines the module for the address (CAddr)
		class.

   Author:

           Rohan Phillips    ( Rohanp )    11-Dec-1995

   Project:

          SMTP Server DLL

   Functions Exported:
   Revision History:


--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include <windows.h>
#include <dbgtrace.h>
#include <cpool.h>
#include <string.h>
#include <listmacr.h>
#include <abtype.h>
#include <abook.h>
#include <address.hxx>

//initialize the pool
CPool  CAddr::Pool(ADDRESS_SIGNATURE_VALID);
#if defined(TDC)
LPFNAB_FREE_MEMORY CAddr::pfnABFreeMemory = NULL;
#endif

//
// Statics
//
static BOOL pStripAddrQuotes( char *lpszAddress, char **lpDomain );
static BOOL pStripAddrSpaces(char *lpszAddress);

// Quick and dirty string validation
static BOOL pValidateStringPtr(LPSTR lpwszString, DWORD dwMaxLength)
{
	if (IsBadStringPtr((LPCTSTR)lpwszString, dwMaxLength))
		return(FALSE);
	while (dwMaxLength--)
		if (*lpwszString++ == 0)
			return(TRUE);
	return(FALSE);
}


//This routine scans an address for illegal characters
//in a name
BOOL IsInvalidAddr(char *Address)
{
	char * addr = Address;

    for (; *addr != '\0'; addr++)
    {
        if ((*addr & 0340) == 0200)
            break;
    }
    if (*addr == '\0')
    {
        return FALSE;
    }

	SetLastError (ERROR_INVALID_DATA);
    return TRUE;
}

// Forward declaration of pValidateLocalPartOrDomain
BOOL pValidateLocalPartOrDomain(char *lpszStart,
								DWORD dwLength,
								BOOL fLocalPart);


/*++
	Name :
	  CAddr:CAddr

    Description:
      This is the default constructor for this class.
	  It just initializes the member variables.

    Arguments:	None

    Returns:

      nothing

    Limitations:

--*/
CAddr::CAddr(void)
{
   m_Signature = ADDRESS_SIGNATURE_VALID;
   m_Flags = ADDRESS_NO_DOMAIN;
   m_PlainAddrSize = 0;
   m_DomainOffset = NULL;
   m_HashInfo = NULL;
   m_Error = 0;
   m_listEntry.Flink = NULL;
   m_listEntry.Blink = NULL;
}

CAddr::~CAddr(VOID)
{		
	m_Signature = ADDRESS_SIGNATURE_FREE;
	m_Flags = 0;
	m_listEntry.Flink = NULL;
	m_listEntry.Blink = NULL;
	m_HashInfo = NULL;
}

/*++
	Name :
	  CAddr:CAddr(char * address)

    Description:
      This is the default constructor for this class.
	  It just initializes the member variables.

    Arguments:	None

    Returns:

      nothing

    Limitations:

--*/
CAddr::CAddr(char * Address)
{
   m_Signature = ADDRESS_SIGNATURE_VALID;
   m_Flags = ADDRESS_NO_DOMAIN;
   m_PlainAddrSize = 0;
   m_DomainOffset = NULL;
   m_HashInfo= NULL;
   m_Error = 0;
   m_listEntry.Flink = NULL;
   m_listEntry.Blink = NULL;


   if(Address == NULL)
   {
	  SetLastError(ERROR_INVALID_DATA);
	  return;
   }

   // This is an email name, extract its clean representation
   ExtractCleanEmailName(	m_PlainAddress,
							&m_DomainOffset,
							&m_PlainAddrSize,
							Address);

   if (m_PlainAddrSize > MAX_INTERNET_NAME)
   {
      m_PlainAddrSize = 0;
	  SetLastError (ERROR_INVALID_DATA);
   }
   else
   {
	  if(m_DomainOffset)	
		m_Flags &= (DWORD) ~ADDRESS_NO_DOMAIN; //turn off the no domain flag.
   }
}

/*++
	Name :
	CAddr::InitializeAddress

    Description:
	This function parses an RFC address, stripping out
	all comments, and gets back an internet address

    Arguments:	
	Address - RCF address from client
	ADDRTYPE - specify if address came from FROM or RCPT command

    Returns:

    TRUE if the RFC addressed was correctly parsed.
	FALSE otherwise.

--*/
BOOL CAddr::InitializeAddress(char * Address, ADDRTYPE NameType)
{

	if(::IsInvalidAddr(Address))
		return(FALSE);

	m_PlainAddress[0] = '\0';
	m_DomainOffset = NULL;
	m_PlainAddrSize = 0;

	// We have a special case for domains treated as addresses
	if (NameType == CLEANDOMAIN)
	{
		DWORD AddressSize = 0;
		char  szCleanAddress[MAX_DOMAIN_NAME+1];

		AddressSize = lstrlen(Address);

		if (AddressSize > MAX_DOMAIN_NAME)
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		// We want an ABSOLUTELY clean domain name, but we will strip
		// out leading and trailing spaces for them
		lstrcpy(szCleanAddress, Address);
		if (!pStripAddrSpaces(szCleanAddress))
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}
		AddressSize = lstrlen(szCleanAddress);
		if (!pValidateLocalPartOrDomain(szCleanAddress, AddressSize, FALSE))
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		// This is a clean domain name, fill in the fields, and
		// return a positively
		lstrcpy(m_PlainAddress, szCleanAddress);
		m_PlainAddrSize = lstrlen(szCleanAddress);
		m_Flags &= (DWORD) ~ADDRESS_NO_DOMAIN;
		return(TRUE);			
	}

	// This is an email name, extract its clean representation
	if (!ExtractCleanEmailName(	m_PlainAddress,
								&m_DomainOffset,
								&m_PlainAddrSize,
								Address))
		return(FALSE);

	// Take care of the flag
	if (!m_DomainOffset)
		m_Flags &= (DWORD) ~ADDRESS_NO_DOMAIN;

	// Further, we validate the whole local-part[@domain] email name
	// Special case: if the address is <>, then we skip the validation
	if (strcmp(m_PlainAddress, "<>"))
	{
		if (!ValidateCleanEmailName(m_PlainAddress, m_DomainOffset))
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}
	}
	else if (NameType != FROMADDR)
	{
		SetLastError(ERROR_INVALID_DATA);
		return(FALSE);
	}

	// Take care of other anomalies ...
	if (m_DomainOffset)
	{
		// Make sure there is a local-part
		if (m_DomainOffset <= m_PlainAddress)
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		// EMPIRE WTOP Bug 47233: Need to accept longer email names if they add up
		// to less than MAX_INTERNET_NAME. This is for replication of users across
		// a site connector. Due to this reason, we removed the user name check to
		// make sure it is less than MAX_EMAIL_NAME.
	}
	else
	{
		// We have no domain, make sure it is not an empty string
		if (m_PlainAddress[0] == '\0')
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		// EMPIRE WTOP Bug 47233: Need to accept longer email names if they add up
		// to less than MAX_INTERNET_NAME. This is for replication of users across
		// a site connector. Due to this reason, we removed the user name check to
		// make sure it is less than MAX_EMAIL_NAME.
	}
	return(TRUE);
}

/*++
	Name :
	CAddr::CreateAddress

    Description:
	This function allocates memory for a CAddr
	class and calls StripAddrComments to

    Arguments:	
	pszDest - Destination where new address should go
	pszSrc  - Source buffer of address to strip comments from

    Returns:

      a pointer to a CAddr if comments were stripped and the format
	  of the address is legal.
	  NULL otherwise

--*/
CAddr * CAddr::CreateAddress(char * Address, ADDRTYPE NameType)
{
    CAddr * NewAddress;

	//create the memory for the address
	NewAddress = new CAddr ();
	if (!NewAddress)
	 {
	    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
	    return NULL;
	 }

	//now initialize it
    if (!NewAddress->InitializeAddress(Address, NameType))
	{
		delete NewAddress;
		return NULL;
	}

	//we have a good address...or so we think
	return NewAddress;
}

/*++
	Name :
	CAddr::CreateKnownAddress

    Description:
	This function allocates memory for a CAddr
	class and sets "Address" as the internet
	address for this class.  No error checking
	is done.  It is assumed that the caller
	performed all necessary error checking

    Arguments:	
	Address - Internet Address to initialize
	the class with

    Returns:
	  a pointer to a CAddr if memory could be allocated
	  NULL otherwise

--*/
CAddr * CAddr::CreateKnownAddress(char * Address)
{
    CAddr * NewAddress = NULL;
		
	//create the memory for the address
	NewAddress = new CAddr (Address);
	if (!NewAddress)
	 {
	    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
	    return NULL;
	 }

	if(!NewAddress->GetAddrSize())
	{
	  delete NewAddress;
	  NewAddress = NULL;
	}

	return NewAddress;
}


/*++
	Name :
	CAddr::ReplaceAddress

    Description:
		Replaces the address stored in this
		CAddr with the one passed in
    Arguments:	
		Address - new address

    Returns:
		TRUE if the address could be replaced.
		FALSE if we run out of memory, the new
		address is NULL, or the size of the
		address is zero

--*/
BOOL CAddr::ReplaceAddress(const char * Address)
{
	_ASSERT(IsValid());

	if(Address == NULL)
	{
		SetLastError(ERROR_INVALID_DATA);
		return FALSE;
	}

	ExtractCleanEmailName(	m_PlainAddress,
							&m_DomainOffset,
							&m_PlainAddrSize,
							(char *)Address);

	if (m_PlainAddrSize > MAX_INTERNET_NAME)
	{
		SetLastError(ERROR_INVALID_DATA);
		return FALSE;
	}

	if(m_DomainOffset)
		m_Flags &= (DWORD) ~ADDRESS_NO_DOMAIN; //turn off the no domain flag.
	
	return TRUE;
}


/*++

    Name :
        CAddr::CAddr

    Description:
        returns a pointer to the 1st CAddr in the local list

    Arguments:
        a pointer to a PLIST_ENTRY

    Returns:

--*/
CAddr * CAddr::GetFirstAddress(PLIST_ENTRY HeadOfList, PLIST_ENTRY * AddressLink)
{
  PLIST_ENTRY ListEntry = NULL;
  CAddr * FirstAddress = NULL;

  //if the list is not empty, get the first address
  if(!IsListEmpty (HeadOfList))
  {
    ListEntry = HeadOfList->Flink;
    FirstAddress = CONTAINING_RECORD( ListEntry, CAddr, m_listEntry);
	_ASSERT(FirstAddress->IsValid());

    *AddressLink = ListEntry->Flink;      //get the next link
  }

  return FirstAddress;
}

/*++

    Name :
        CAddr::GetNextAddress

    Description:
        returns a pointer to the next CAddr in the local list

    Arguments:
        a pointer to a PLIST_ENTRY

    Returns:

--*/
CAddr * CAddr::GetNextAddress(PLIST_ENTRY HeadOfList, PLIST_ENTRY * AddressLink)
{
  CAddr * NextAddress = NULL;

  //make sure we are not at the end of the list
  if((*AddressLink) != HeadOfList)
  {
    NextAddress = CONTAINING_RECORD(*AddressLink, CAddr, m_listEntry);
	_ASSERT(NextAddress->IsValid());
    *AddressLink = (*AddressLink)->Flink;
  }

  return NextAddress;
}



/*++

    Name :
		CAddr::RemoveAllAddrs

    Description:
        Deletes all address from a CAddr list

    Arguments:
        a pointer to the head of the list

    Returns:

--*/
void CAddr::RemoveAllAddrs(PLIST_ENTRY HeadOfList)
{
  PLIST_ENTRY  pEntry;
  CAddr  * pAddr;

  // Remove all addresses
  while (!IsListEmpty (HeadOfList))
  {
    pEntry = RemoveHeadList(HeadOfList);
    pAddr = CONTAINING_RECORD( pEntry, CAddr, m_listEntry);
    delete pAddr;
  }

}

/*++

	Name :
		CAddr::RemoveAddress

    Description:
		removes an address from a list

    Arguments:
		a pointer to a PLIST_ENTRY

    Returns:

--*/
void CAddr::RemoveAddress(IN OUT CAddr * pEntry)
{
	if(pEntry != NULL)
	{
	  _ASSERT(pEntry->IsValid());

	  //Remove from list of addresses
	  RemoveEntryList( &pEntry->QueryListEntry());
	}
}


/*++

	Name :
		CAddr::InsertAddrHeadList

    Description:
		insert an address into the head of a list

    Arguments:
		a pointer to a PLIST_ENTRY

    Returns:

--*/

void CAddr::InsertAddrHeadList(PLIST_ENTRY HeadOfList, CAddr *pEntry)
{
	_ASSERT(pEntry);
	_ASSERT(pEntry->IsValid());

	InsertHeadList(HeadOfList, &pEntry->QueryListEntry());
}

/*++

	Name :
		CAddr::InsertAddrTailList

    Description:
		insert an address into the head of a list

    Arguments:
		a pointer to a PLIST_ENTRY

    Returns:

--*/

void CAddr::InsertAddrTailList(PLIST_ENTRY HeadOfList, CAddr *pEntry)
{
	_ASSERT(pEntry);
	_ASSERT(pEntry->IsValid());

	InsertTailList(HeadOfList, &pEntry->QueryListEntry());
}

// ========================================================================
//
// Validation Parser stuff added by KeithLau on 7/25/96
//

#define	QUOTE_SQUARE			0x1
#define	QUOTE_ANGLE				0x2
#define	QUOTE_QUOTES			0x4
#define QUOTE_PARENTHESES		0x8
#define	MAX_QUOTE_TYPES			3

static char acOpen[MAX_QUOTE_TYPES] = { '[', '<', '\"' };
static char acClose[MAX_QUOTE_TYPES] = { ']', '>', '\"' };

static char *pFindNextUnquotedOccurrence(char		*lpszString,
										 char		cSearch,
										 LPBOOL		lpfNotFound,
										 DWORD		dwDefaultState);

static inline BOOL IsControl(char ch)
{
	return( ((ch >= 0) && (ch <= 31)) || (ch == 127) );
}

static BOOL IsSpecial(char ch)
{
	switch (ch)
	{
	case '(':
	case ')':
	case '<':
	case '>':
	case '@':
	case ',':
	case ':':
	case ';':
	case '\\':
	case '\"':
	case '.':
	case '[':
	case ']':
		return(TRUE);
	default:
		return(FALSE);
	}
}

static BOOL pIsSpecialOrSpace(char ch)
{
	return((ch == ' ') || (ch == '\t') || (ch == '\0') || IsSpecial(ch));
		
}

static BOOL pValidateAsciiString(char *lpszString)
{
	// Verifies that a string only contains ASCII chars (0-127)
	// Relies totally on upstream pointer checking
	_ASSERT(lpszString);
	if (!lpszString)
		return(FALSE);

	while (*lpszString)
	{
		if ((*lpszString >= 0) && (*lpszString <= 127))
			lpszString++;
		else
			return(FALSE);
	}
	return(TRUE);
}

static BOOL pValidateAtom(char *lpszStart, DWORD dwLength)
{
	// Atoms can be any ASCII char, except specials, controls, and spaces
	// Note zero-length atom is invalid
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	if (!dwLength)
		return(FALSE);

	while (dwLength)
	{
		dwLength--;
		if ((*lpszStart == ' ') ||
			(IsSpecial(*lpszStart)) ||
			(IsControl(*lpszStart))
			)
		{
			// Process quoted (escape) char
			if (*lpszStart == '\\')
			{
				if (!dwLength)
					return(FALSE);
				else
				{
					lpszStart++;
					dwLength--;
				}
			}
			else
				return(FALSE);
		}

		lpszStart++;
	}
	return(TRUE);
}

static BOOL pValidateAtomNoWildcard(char *lpszStart, DWORD dwLength)
{
	// Atoms can be any ASCII char, except specials, controls, and spaces
	// Note zero-length atom is invalid
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	if (!dwLength)
		return(FALSE);

	while (dwLength)
	{
		// Apart from the usual, we also dislike the asterisk wildcard character.
		// This is just for domains.
		dwLength--;
		if ((*lpszStart == ' ') ||
			(*lpszStart == '*') ||
			(IsSpecial(*lpszStart)) ||
			(IsControl(*lpszStart))
			)
			return(FALSE);
		lpszStart++;
	}
	return(TRUE);
}

static BOOL pValidateQtext(char *lpszStart, DWORD dwLength)
{
	// Qtext can be any ASCII char, except '\"', '\\', and CR
	// Note zero-length is valid
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	while (dwLength)
	{
		dwLength--;
		if ((*lpszStart == '\"') ||
			(*lpszStart == '\r')
			)
			return(FALSE);

		// Process quoted (escape) char
		if (*lpszStart == '\\')
		{
			if (!dwLength)
				return(FALSE);
			else
			{
				lpszStart++;
				dwLength--;
			}
		}
			
		lpszStart++;
	}
	return(TRUE);
}

static BOOL pValidateDtext(char *lpszStart, DWORD dwLength)
{
	// Dtext can be any ASCII char, except '\"', '\\', and CR
	// Note zero-length is valid
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	while (dwLength)
	{
		dwLength--;
		if ((*lpszStart == '[') ||
			(*lpszStart == ']') ||
			(*lpszStart == '\r')
			)
			return(FALSE);

		// Process quoted (escape) char
		if (*lpszStart == '\\')
		{
			if (!dwLength)
				return(FALSE);
			else
			{
				lpszStart++;
				dwLength--;
			}
		}
			
		lpszStart++;
	}
	return(TRUE);
}

static BOOL pValidateQuotedString(char *lpszStart, DWORD dwLength)
{
	// Quoted-stirngs are quotes between Qtext
	// an empty Qtext is valid
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	if (dwLength < 2)
		return(FALSE);

	if ((*lpszStart != '\"') ||
		(lpszStart[dwLength-1] != '\"'))
		return(FALSE);

	return(pValidateQtext(lpszStart + 1, dwLength - 2));
}

static BOOL pValidateDomainLiteral(char *lpszStart, DWORD dwLength)
{
	// Domain-literals are square braces between Dtext
	// an empty Dtext is valid
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	if (dwLength < 2)
		return(FALSE);

	if ((*lpszStart != '[') ||
		(lpszStart[dwLength-1] != ']'))
		return(FALSE);

	return(pValidateDtext(lpszStart + 1, dwLength - 2));
}

static BOOL pValidateWord(char *lpszStart, DWORD dwLength)
{
	// A word is any sequence of atoms and quoted-strings
	// words may not be zero-length by inheritance
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	if ((pValidateAtom(lpszStart, dwLength)) ||
		(pValidateQuotedString(lpszStart, dwLength)))
		return(TRUE);

	return(FALSE);
}

static BOOL pValidateSubdomain(char *lpszStart, DWORD dwLength)
{
	// A subdomain may be an atom or domain-literal
	// words may not be zero-length by inheritance
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	if ((pValidateAtomNoWildcard(lpszStart, dwLength)) ||
		(pValidateDomainLiteral(lpszStart, dwLength)))
		return(TRUE);

	return(FALSE);
}

//
// Since validating the local part is so similar to validating the
// domain part, we write one function to do both. If fLocalPart
// is TRUE, we treat it as the local part of an email address, if
// it is FALSE, we treat it as the domain part.
//
static BOOL pValidateLocalPartOrDomain(char *lpszStart, DWORD dwLength, BOOL fLocalPart)
{
	// A domain is one or more dot-delimited sub-domains, where a local-part
	// is one or more dot-delimited words
	// We rely on upstream calls to make sure the string is properly
	// NULL-terminated
	char *lpszBegin, *lpszEnd;
	BOOL  fNotFound;

	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	lpszBegin = lpszStart;
	lpszEnd = (char *)NULL;

	while (lpszEnd = pFindNextUnquotedOccurrence(lpszBegin, '.', &fNotFound, 0))
	{
		// If it starts with a dot or has 2 dots in a row, we fail!
		if (lpszBegin == lpszEnd)
			return(FALSE);

		// Now, check if the chunk is indeed a valid token
		if (fLocalPart)
		{
			if (!pValidateWord(lpszBegin, (DWORD)(lpszEnd - lpszBegin)))
				return(FALSE);
		}
		else
		{
			if (!pValidateSubdomain(lpszBegin, (DWORD)(lpszEnd - lpszBegin)))
				return(FALSE);
		}

		// Allright, go to the next guy
		lpszBegin = lpszEnd + 1;
	}

	if (!fNotFound)
		return(FALSE);

	// If it ends with a dot, it's also bad
	lpszEnd = lpszStart + dwLength;
	if (lpszEnd == lpszBegin)
		return(FALSE);

	// Don't forget the last chunk
	if (fLocalPart)
		return(pValidateWord(lpszBegin, (DWORD)(lpszEnd - lpszBegin)));
	else
		return(pValidateSubdomain(lpszBegin, (DWORD)(lpszEnd - lpszBegin)));
}

static BOOL pValidatePhrase(char *lpszStart, DWORD dwLength)
{
	// A phrase is a collection of words, possibly separated
	// by spaces
	// We don't validate for now ...
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	return(TRUE);
}


//
// The following functions attempt to extract a clean addr-spec
// in the form of local-part[@domain] from a generic address
// Note that groups are not supported at this point
//
static BOOL pExtractAddressFromRouteAddress(char	*lpszStart,
											DWORD	dwLength,
											char	*lpCleanAddress)
{
	// A route address is in the form:
	// phrase < [1#(@ domain) :] addr-spec >
	char *lpMarker;
	char *lpRoute;
	BOOL fNotFound;

	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	// First, find the opening angle brace
	lpMarker = pFindNextUnquotedOccurrence(lpszStart, '<', &fNotFound, 0);
	if (!lpMarker)
		return(FALSE);

	// Between lpStart and lpMarker is the phrase
	_ASSERT(lpMarker >= lpszStart);
	if (!pValidatePhrase(lpszStart, (DWORD)(lpMarker - lpszStart)))
		return(FALSE);

	// Now, find the closing angle bracket
	_ASSERT(*lpMarker == '<');
	lpszStart = lpMarker + 1;
	lpMarker = pFindNextUnquotedOccurrence(lpszStart, '>',
					&fNotFound, QUOTE_ANGLE);
	if (!lpMarker)
		return(FALSE);

	_ASSERT(*lpMarker == '>');

	// There should be nothing but white space after the closing brace
	//Trim the whitespace or flag an error
	char * lpTemp = lpMarker;
	while(*++lpTemp != '\0')
	{
		if(*lpTemp != ' ' && *lpTemp != '\t')
			return(FALSE);
	}
	*(lpMarker + 1) = '\0';

	// The special address <> is reserved for NDR, and should be
	// allowed
	if (lpszStart == lpMarker)
	{
		lpCleanAddress[0] = '<';
		lpCleanAddress[1] = '>';
		lpCleanAddress[2] = '\0';
		return(TRUE);
	}

	// The stuff enclosed in the angle braces is an addr-spec, and
	// optionally preceded by route specifiers. We don't care about
	// route specifiers, but we have to skip them.
	lpRoute = pFindNextUnquotedOccurrence(lpszStart, ':',  &fNotFound, 0);

	if (!lpRoute)
	{
		// If we have no colon, then the whole lump should be the
		// addr-spec
		_ASSERT(lpMarker >= lpszStart);
		*lpMarker++ = '\0';
		lstrcpyn(lpCleanAddress, lpszStart, (DWORD)(lpMarker - lpszStart));
		return(TRUE);
	}
	else
	{
		// We found a colon, the stuff to its right should be the
		// addr-spec. As usual, we don't validate the route specifiers
		lpRoute++;
		_ASSERT(lpMarker >= lpRoute);
		*lpMarker++ = '\0';
		lstrcpyn(lpCleanAddress, lpRoute, (DWORD)(lpMarker - lpRoute));
		return(TRUE);
	}
}

static BOOL pExtractAddressFromMailbox(	char	*lpszStart,
										DWORD	dwLength,
										char	*lpCleanAddress)
{
	// A mailbox can either be an addr-spec, or a route address
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	if (pExtractAddressFromRouteAddress(lpszStart, dwLength, lpCleanAddress))
		return(TRUE);

	// If it's not a route address, trhen it should ba an addr-spec
	lstrcpyn(lpCleanAddress, lpszStart, dwLength + 1);
	return(TRUE);
}

static BOOL pExtractAddressFromGroup(	char	*lpszStart,
										DWORD	dwLength,
										char	*lpCleanAddress)
{
	// We always return false
	return(FALSE);

	/*
	// A group is in the form:
	// phrase : [#mailbox] ;
	char *lpMarker;
	char *lpSemiColon;
	BOOL fNotFound;

	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	// First, find the opening angle brace
	lpMarker = pFindNextUnquotedOccurrence(lpszStart, ':', &fNotFound, 0);
	if (!lpMarker || fNotFound)
		return(FALSE);

	// Between lpStart and lpMarker is the phrase
	_ASSERT(lpMarker >= lpszStart);
	if (!pValidatePhrase(lpszStart, (DWORD)(lpMarker - lpszStart)))
		return(FALSE);

	// Between the colon
	lpMarker++;	
	lpSemiColon = pFindNextUnquotedOccurrence(lpMarker, ';', &fNotFound, 0);
	if (!lpSemiColon || fNotFound)
		return(FALSE);

	_ASSERT(lpSemiColon >= lpMarker);
	if (lpSemiColon == lpMarker)
		;
	 */
}

static BOOL pExtractAddress(	char	*lpszStart,
								DWORD	dwLength,
								char	*lpCleanAddress)
{
	// A address is either an mailbox, or a group
	_ASSERT(!IsBadStringPtr(lpszStart, dwLength));

	*lpCleanAddress = '\0';
	if (pExtractAddressFromMailbox(lpszStart, dwLength, lpCleanAddress) ||
		pExtractAddressFromGroup(lpszStart, dwLength, lpCleanAddress))
		return(TRUE);
	return(FALSE);
}


// This function finds braces pairs in a given string, and returns
// pointers to the start and end of the first occurence of a
// [nested] pair of braces. The starting and ending character
// may be specified by the caller (starting and ending chars
// must be unique).
static char *pFindNextUnquotedOccurrence(char		*lpszString,
										 char		cSearch,
										 LPBOOL		lpfNotFound,
										 DWORD		dwDefaultState)
{
	DWORD	dwState = dwDefaultState;
	DWORD	i;
	char	ch;
	char	*lpStart = lpszString;
	BOOL	fFallThru;

	*lpfNotFound = FALSE;

	// If dwState is 0, then we are not inside any kind of quotes
	while (ch = *lpStart)
	{
		// If we are not in any quotes, and the char is found,
		// then we are done!
		if (!dwState && (ch == cSearch))
			return(lpStart);

		// Another disgusting kludge, BUT WORKS!!
		// For closing parentheses, we don't it in the
		// acClose[] set, so we have to explicitly check for them
		// here, since pMatchParentheses is very dependent on this.
		// For open parentheses, similar case: since parentheses
		// nest, we allow multiple open braces
		if (dwState == QUOTE_PARENTHESES)
		{
			if (((cSearch == ')') || (cSearch == '(')) &&
				(ch == cSearch))
				return(lpStart);
		}

		// If it is a quoted char, we can skip it and the following
		// char right away ... If the char following a quote '\' is
		// the terminating NULL, we have an error.
		if (ch == '\\')
		{
			lpStart++;
			if (!*lpStart)
				return(NULL);

			// Quoted pairs not allowed outside quotes!
			// if (!dwState)
			//	return(NULL);
		}
		else
		{
			// See if we have a state change ...
			for (i = 0; i < MAX_QUOTE_TYPES; i++)
			{
				// Check the close case, too
				fFallThru = TRUE;

				// See if we have an opening quote of any sort
				if (ch == acOpen[i])
				{
					// If it is an open brace, it shouldn't be a close brace
					// EXCEPT: quotes.
					fFallThru = FALSE;

					// Special case for quotes: open = close
					if (dwState & (1 << i))
					{
						// This is not a quoted pair, error!
						// If it is a quote, and if the current state is
						// inside quotes, then we let it
						if ((ch == '\"') && (dwState == QUOTE_QUOTES))
							fFallThru = TRUE;
						else
							return(NULL);
					}
					else if (!dwState)
					{
						// We are not in any quotes, so we can safely
						// claim we are now inside quotes
						dwState |= (1 << i);
					}
				}

				// See if we have an closing quote of any sort
				if (fFallThru && (ch == acClose[i]))
				{
					if (dwState & (1 << i))
					{
						// We are closing the correct kind of quote,
						// so we cancel it ...
						dwState = 0;

						// Do a second check, in case we are looking
						// for a close quote
						if (ch == cSearch)
							return(lpStart);
					}
					else if (!dwState)
					{
						// We are not in any quotes, so we have
						// unmatched quotes!
						return(NULL);
					}
				}
			}
		}
	
		lpStart++;
	}

	*lpfNotFound = TRUE;
	return(NULL);
}

static BOOL pMatchParentheses(	char		**ppszStart,
								char		**ppszEnd,
								LPDWORD		lpdwPairs)
{
	DWORD	dwIteration	= 0;
	DWORD	dwState = 0;
	char	*lpszString	= *ppszStart;
	char	*lpStart;
	char	*lpEnd;
	BOOL	fNotFound = FALSE;

	*lpdwPairs = 0;
	lpStart	= *ppszStart;
	lpEnd	= *ppszEnd;
	
	for (;;)
	{
		// Find open brace
		if (!(lpStart = pFindNextUnquotedOccurrence(lpStart, '(', &fNotFound, dwState)))
		{
			// If it's not found, we're done, else it's a format error!
			if (fNotFound)
				break;
			else
				return(FALSE);
		}

		// Save the start position, and since we are inside the first open
		// parenthesis, we force suppress all quotes mode in subsequent
		// open parenthesis searches
		if (!dwIteration)
		{
			*ppszStart = lpStart;
			dwState = QUOTE_PARENTHESES;
		}
		
		// If iteration > 0 and the start pointer surpasses
		// the end pointer, we have the end of the first set
		// of [nested] braces
		if (dwIteration && (lpStart > lpEnd))
			break;

		// Find close brace
		if (!(lpEnd = pFindNextUnquotedOccurrence(lpEnd, ')',
						&fNotFound, QUOTE_PARENTHESES)))
			return(FALSE);

		// Open brace pointer must always be in front of close
		// brace.
		if (lpStart > lpEnd)
			return(FALSE);

		// Next iteration
		lpStart++;
		lpEnd++;
		dwIteration++;
	}

	// Fill in the end pointer and leave (start ptr already
	// filled in)
	if (dwIteration)
		lpEnd--;
	*lpdwPairs = dwIteration;
	*ppszEnd = lpEnd;
	return(TRUE);
}


/*++
	Name :
	  pStripAddrComments

    Description:
	This function strips comments from an RFC address

    Arguments:	
	lpszAddress - Original address comes in, and clean addres comes out

    Returns:

      TRUE if comments were stripped and the format
	  of the address is legal.
	  FALSE otherwise

--*/
static BOOL pStripAddrComments(char *lpszAddress)
{

	char		*lpCopyStart;
	char		*lpStart, *lpEnd;
	DWORD		dwPairs;
	DWORD		dwCopyLen;

	// First, we strip the comments
	// We call the function above to find matching parenthesis pairs
	lpStart = lpszAddress;
	lpEnd	= lpszAddress;
	do
	{
		// Mark the actual start
		lpCopyStart = lpEnd;

		if (!pMatchParentheses(&lpStart, &lpEnd, &dwPairs))
		{
			// Failed!
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}

		if (dwPairs)
		{
			// If fFound, then we found some comments
			_ASSERT(*lpStart == '(');
			_ASSERT(*lpEnd == ')');

			// Copy the stuff over, excluding comments
			_ASSERT(lpStart >= lpCopyStart);
			dwCopyLen = (DWORD)(lpStart - lpCopyStart);
			
			// Reset the pointer, and match again ...
			lpEnd++;
			lpStart = lpEnd;
		}
		else
		{
			dwCopyLen = lstrlen(lpCopyStart);
		}

		while (dwCopyLen--)
		{
			*lpszAddress++ = *lpCopyStart++;
		}

	} while (dwPairs);

	// Terminate the string
	*lpszAddress = '\0';

	return(TRUE);
}

/*++
	Name :
	  pStripAddrSpaces

    Description:
	This function strips extraneous spaces from an RFC address
	An extraneous space is one that is not in a quoted pair, and
	not inside any quoting pairs

    Arguments:	
	lpszAddress - Original address comes in, and clean addres comes out

    Returns:

      TRUE if spaces were stripped
	  FALSE if any quotes/braces mismatch, or parameter error

--*/
static BOOL pStripAddrSpaces(char *lpszAddress)
{
	char *lpszWrite;
	char *lpszCopyStart;
	char *lpszSearch;
	DWORD dwCopyLen, i;
	BOOL fNotFound;
	BOOL fValidSpace;
	char cSet[2] = { ' ', '\t' };

	// First, get rid of spaces, then TABs
	for (i = 0; i < 2; i++)
	{
		lpszWrite = lpszAddress;
		lpszCopyStart = lpszAddress;
		lpszSearch = lpszAddress;

		do
		{
			lpszCopyStart = lpszSearch;

			// Find unquoted space
			lpszSearch = pFindNextUnquotedOccurrence(lpszSearch,
								cSet[i], &fNotFound, 0);

			// We cannot just allow casual spaces; An unquoted space
			// must satisfy one or more of the following:
			// 1) Leading space
			// 2) Trailiing space
			// 3) A space or TAB is in either side or both sides of the space
			// 4) A special character is on either or both sides of the space
			if (lpszSearch)
			{
				// Make sure it satisfies the above
				fValidSpace = FALSE;
				if (lpszSearch > lpszAddress)
				{
					if (pIsSpecialOrSpace(*(lpszSearch - 1)))
						fValidSpace = TRUE;
				}
				else
					fValidSpace = TRUE;
				if (pIsSpecialOrSpace(*(lpszSearch + 1)))
					fValidSpace = TRUE;

				if (!fValidSpace)
				{
					SetLastError(ERROR_INVALID_DATA);
					return(FALSE);
				}

				_ASSERT(lpszSearch >= lpszCopyStart);
				dwCopyLen = (DWORD)(lpszSearch - lpszCopyStart);
				lpszSearch++;
			}
			else
				dwCopyLen = lstrlen(lpszCopyStart);

			// 1) Leading spaces are automatically stripped!
			while (dwCopyLen--)
			{
				*lpszWrite++ = *lpszCopyStart++;
			}

		} while (lpszSearch);

		// If the reason it failed is not because it cannot find one,
		// we have a formatting error here!
		if (!fNotFound)
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}
		*lpszWrite = '\0';
	}

	return(TRUE);
}

/*++
	Name :
	  pStripAddrQuotes

    Description:
	This function strips all quotes in the local part of an address.
	All quotes pairs within quotes are also collapsed.

    Arguments:	
	lpszLocalPart - Local part comes in, and comes out without quotes

    Returns:

      TRUE if quotes were stripped
	  FALSE if any quotes/braces mismatch, or parameter error

--*/
static BOOL pStripAddrQuotes(char *lpszLocalPart, char **lpDomain)
{
	char *lpszWrite;
	char *lpszCopyStart;
	char *lpszSearch;
	DWORD dwCopyLen;
	DWORD dwState = 0;
	BOOL fNotFound;

	_ASSERT(lpDomain);
	
	// First, get rid of quotes
	lpszWrite = lpszLocalPart;
	lpszCopyStart = lpszLocalPart;
	lpszSearch = lpszLocalPart;

	do
	{
		lpszCopyStart = lpszSearch;

		// Find next quote
		lpszSearch = pFindNextUnquotedOccurrence(lpszSearch,
							'\"', &fNotFound, dwState);
		if (lpszSearch)
		{
			// Toggle the state
			dwState = (dwState)?0:QUOTE_QUOTES;

			// Found a quote, copy all the stuff before the space
			_ASSERT(lpszSearch >= lpszCopyStart);
			dwCopyLen = (DWORD)(lpszSearch - lpszCopyStart);
			lpszSearch++;

			// Move the domain offset back each time we find
			// an unquoted quote
			if (*lpDomain)
				(*lpDomain)--;
		}
		else
			dwCopyLen = lstrlen(lpszCopyStart);

		while (dwCopyLen--)
		{
			// Another caveat: since we are stripping out the
			// quotes, we must also take care of the quoted
			// pairs. That is, we must remove the backslash
			// delimiting each quoted pair.
			if (*lpszCopyStart == '\\')
			{
				// If the last char of the string is a backslash, or
				// if the backslash is not within quotes, error!
				// CAUTION: if dwState == QUOTE_QUOTES, this means
				// that the stuff we are copying is OUTSIDE of the quote,
				// since we are copying stuff before the found quote
				if ((dwState == QUOTE_QUOTES) || !dwCopyLen)
				{
					SetLastError(ERROR_INVALID_DATA);
					return(FALSE);
				}
				lpszCopyStart++;
				dwCopyLen--;
			}
			*lpszWrite++ = *lpszCopyStart++;
		}

	} while (lpszSearch);

	*lpszWrite = '\0';

	// If the reason it failed is not because it cannot find one,
	// we have a formatting error here!
	if (!fNotFound)
	{
		SetLastError(ERROR_INVALID_DATA);
		return(FALSE);
	}

	// If we are left with no closing quote, then we also have an error
	if (dwState == QUOTE_QUOTES)
	{
		SetLastError(ERROR_INVALID_DATA);
		return(FALSE);
	}
		
	return(TRUE);
}


/*++
	Name :
	  pStripUucpRoutes

    Description:
	This function strips all UUCP routing paths

    Arguments:	
	lpszAddress - lpszAddress comes in, and comes out without UUCP paths

    Returns:

      TRUE if UUCP routes were stripped
	  FALSE if any quotes/braces mismatch, or parameter error

--*/
static BOOL pStripUucpRoutes(char *lpszAddress)
{
	char *lpszDomainOffset;
	char *lpszCopyStart;
	char *lpszSearch;
	BOOL fNotFound;

	if (!(lpszDomainOffset = pFindNextUnquotedOccurrence(lpszAddress, '@', &fNotFound, 0)))
		if (!fNotFound)
			return(FALSE);
	
	lpszSearch = lpszAddress;
	lpszCopyStart = NULL;

	// Find the last BANG
	while (lpszSearch = pFindNextUnquotedOccurrence(lpszSearch, '!', &fNotFound, 0))
	{
		// If an unquoted bang occurs after the @ sign, we will return error
		if (lpszDomainOffset && (lpszSearch > lpszDomainOffset))
		{
			SetLastError(ERROR_INVALID_DATA);
			return(FALSE);
		}
		lpszCopyStart = lpszSearch++;
	}

	// If the reason is other than not found, we have an error
	if (!fNotFound)
	{
		SetLastError(ERROR_INVALID_DATA);
		return(FALSE);
	}
		
	if (lpszCopyStart)
	{
		lpszCopyStart++;
		while (*lpszCopyStart)
			*lpszAddress++ = *lpszCopyStart++;
		*lpszAddress = '\0';
	}

	return(TRUE);
}


/*++

	Name :
		CAddr::ValidateDomainName

    Description:
		Determines whether a specified domain name is valid

    Arguments:
		lpszDomainName - ANSI domain name string to validate

    Returns:
		TRUE if valid, FALSE if not

--*/
BOOL CAddr::ValidateDomainName(char *lpszDomainName)
{
	char szClean[MAX_INTERNET_NAME+1];

	_ASSERT(lpszDomainName);

	// Routine checking
	if ((!lpszDomainName) ||
		(!pValidateStringPtr(lpszDomainName, MAX_INTERNET_NAME+1)))
		return(FALSE);

	if (!pValidateAsciiString(lpszDomainName))
		return(FALSE);

	// Strip all comments
	lstrcpy(szClean, lpszDomainName);

	if (!pStripAddrComments(szClean))
		return(FALSE);

	if (!pStripAddrSpaces(szClean))
		return(FALSE);

	// Call our appropriate private
	return(pValidateLocalPartOrDomain(szClean, lstrlen(szClean), FALSE));
}

/*++

	Name :
		CAddr::ExtractCleanEmailName

    Description:
		Extracts an absolutely clean email name from an address, quotes
		are NOT stripped for the local part.

    Arguments:
		lpszCleanEmail - Pre allocated buffer to return the clean address
		ppszDomainOffset - Pointer to '@' symbol separating the local-part
		                   and the domain; NULL if not domain is specified
						   in the address.
		lpdwCleanEmailLength - Length of the whole clean email returned
		lpszSource - Source address to clean up

    Returns:
		TRUE if valid, FALSE if not

--*/
BOOL CAddr::ExtractCleanEmailName(	char	*lpszCleanEmail,
									char	**ppszDomainOffset,
									DWORD	*lpdwCleanEmailLength,
									char	*lpszSource)
{
	char szClean[MAX_INTERNET_NAME+1];
	char *lpDomainOffset;
	BOOL fNotFound;

    TraceFunctEnter("CAddr::ExtractCleanEmailName");

	_ASSERT(lpszSource);
	_ASSERT(lpszCleanEmail);
	_ASSERT(ppszDomainOffset);
	_ASSERT(lpdwCleanEmailLength);

	// Routine checking
	if (!lpszSource ||
		!pValidateStringPtr(lpszSource, MAX_INTERNET_NAME+1) ||
		!lpszCleanEmail ||
		IsBadWritePtr(lpszCleanEmail, MAX_INTERNET_NAME+1) ||
		!ppszDomainOffset ||
		IsBadWritePtr(ppszDomainOffset, sizeof(char *)) ||
		!lpdwCleanEmailLength ||
		IsBadWritePtr(lpdwCleanEmailLength, sizeof(DWORD)))
	{
		SetLastError(ERROR_INVALID_DATA);
		goto LeaveWithError;
	}

	szClean[0] = '\0';
	if (!pValidateAsciiString(lpszSource)) {
		SetLastError(ERROR_INVALID_DATA);
		goto LeaveWithError;
    }

	// Strip all comments and spaces
	lstrcpy(szClean, lpszSource);

	StateTrace(0, "  Source: %s", szClean);

	if (!pStripAddrComments(szClean))
		goto LeaveWithError;

	StateTrace(0, "  Comments stripped: %s", szClean);

	// Extract the clean email name in a simple local-part@domain
	// form. However, the local part may still have UUCP headers
	if (!pExtractAddress(szClean, lstrlen(szClean), lpszCleanEmail))
	{
		SetLastError(ERROR_INVALID_DATA);
		goto LeaveWithError;
	}

	StateTrace(0, "  Address: %s", lpszCleanEmail);

	// Strip comments again ...
	if (!pStripAddrComments(lpszCleanEmail)) {
		SetLastError(ERROR_INVALID_DATA);
		goto LeaveWithError;
    }

	StateTrace(0, "  Comments stripped (2): %s", lpszCleanEmail);

	if (!pStripAddrSpaces(lpszCleanEmail)) {
		SetLastError(ERROR_INVALID_DATA);
		goto LeaveWithError;
    }

	StateTrace(0, "  Spaces stripped: %s", lpszCleanEmail);

	// Now we examine the clean address, and try to locate the
	// local-part and the domain
	lpDomainOffset = pFindNextUnquotedOccurrence(lpszCleanEmail,
							'@', &fNotFound, 0);
	if (lpDomainOffset)
	{
		_ASSERT(lpDomainOffset >= lpszCleanEmail);
		if (lpDomainOffset == lpszCleanEmail)
		{
			// First char cannot be '@'
			SetLastError(ERROR_INVALID_DATA);
			goto LeaveWithError;
		}
	}
	else
	{
		// If it's not found, we assume there's no domain
		if (!fNotFound)
		{
			SetLastError(ERROR_INVALID_DATA);
			goto LeaveWithError;
		}
	}

	*lpdwCleanEmailLength = lstrlen(lpszCleanEmail);
	*ppszDomainOffset = lpDomainOffset;
	TraceFunctLeave();
	return(TRUE);

LeaveWithError:
	ErrorTrace(0, "CAddr::ExtractCleanEmailName failed");
	TraceFunctLeave();
	return(FALSE);
}

/*++

	Name :
		CAddr::ValidateCleanEmailName

    Description:
		Determines whether a specified email name is valid.
		The input email name must be clean, i.e. no comments,
		spaces, routing specifiers, etc.

    Arguments:
		lpszCleanEmailName - ANSI email name string to validate
		lpszDomainOffset - Pointer to '@' sign in email string

    Returns:
		TRUE if valid, FALSE if not

--*/
BOOL CAddr::ValidateCleanEmailName(	char	*lpszCleanEmailName,
									char	*lpszDomainOffset)
{
	DWORD	dwLength, dwDomainLength;

    TraceFunctEnterEx(0, "CAddr::ValidateCleanEmailName");

	_ASSERT(lpszCleanEmailName);

	if (!lpszCleanEmailName ||
		!pValidateStringPtr(lpszCleanEmailName, MAX_INTERNET_NAME+1))
	{
		SetLastError(ERROR_INVALID_DATA);
		goto LeaveWithError;
	}

	if (lpszDomainOffset)
	{
		_ASSERT(*lpszDomainOffset == '@');
		_ASSERT(lpszDomainOffset > lpszCleanEmailName);
		dwLength = (DWORD)(lpszDomainOffset - lpszCleanEmailName);
		dwDomainLength = lstrlen(lpszCleanEmailName) - dwLength - 1;
		*lpszDomainOffset++ = '\0';
	}
	else
		dwLength = lstrlen(lpszCleanEmailName);

	StateTrace(0, "  Local-part: %s", lpszCleanEmailName);

	if (!pValidateLocalPartOrDomain(lpszCleanEmailName,
									dwLength,
									TRUE))
	{
		ErrorTrace(0, "Invalid local part");
		goto LeaveWithError;
	}

	if (lpszDomainOffset)
	{
		StateTrace(0, "  Domain: %s", lpszDomainOffset);
		if (!pValidateLocalPartOrDomain(lpszDomainOffset,
									    dwDomainLength, FALSE))
		{
			ErrorTrace(0, "Invalid domain");
			goto LeaveWithError;
		}
	}

	// Restore the string ...
	if (lpszDomainOffset)
		*--lpszDomainOffset = '@';
	TraceFunctLeave();
	return(TRUE);

LeaveWithError:
	if (lpszDomainOffset)
		if (*--lpszDomainOffset == '\0')
			*lpszDomainOffset = '@';
	ErrorTrace(0, "CAddr::ValidateCleanEmailName failed");
	TraceFunctLeave();
	return(FALSE);
}


/*++

	Name :
		CAddr::ValidateEmailName

    Description:
		Determines whether a specified email name is valid

    Arguments:
		lpszEmailName - ANSI email name string to validate
		fDomainOptional - TRUE if domain is optional, FLASE forces
		                  a domain to be included.

    Returns:
		TRUE if valid, FALSE if not

--*/
BOOL CAddr::ValidateEmailName(	char	*lpszEmailName,
								BOOL	fDomainOptional)
{
	char	szSource[MAX_INTERNET_NAME+1];
	char	*lpDomainOffset;
	DWORD	dwLength;

	szSource[0] = '\0';
	if (!ExtractCleanEmailName(	szSource,
								&lpDomainOffset,
								&dwLength,
								lpszEmailName))
		return(FALSE);

	if (!fDomainOptional &&	!lpDomainOffset)
		return(FALSE);

	return(ValidateCleanEmailName(szSource, lpDomainOffset));
}

/*++

	Name :
		CAddr::FindStartOfDomain

    Description:
		Finds the start of the domain part from a CLEAN email
		address. The clean address may not contain
		any comments, routing specifications, UUCP addresses,
		and the such. No validation is done for the "clean
		address".

    Arguments:
		lpszCleanEmail - ANSI CLEAN email name string whose local
						 part to extract

    Returns:
		A pointer to the '@' sign separating the local part and
		the domain. NULL if the '@' sign is not found. Note that
		'@' signs enclosed in quotes or in a proper quoted pair
		are skipped.

--*/
CHAR * CAddr::FindStartOfDomain(CHAR *lpszCleanEmail)
{
	BOOL fNotFound;

	return(pFindNextUnquotedOccurrence(lpszCleanEmail,
							'@', &fNotFound, 0));
}


//---[ CAddr::GetRFC822AddressCount ]------------------------------------------
//
//
//  Description: 
//      Counts the number of addresses in a RFC822 list of addresses.
//  Parameters:
//      IN  szAddressList       List of addresses to count
//  Returns:
//      # of recipients in list
//  History:
//      2/17/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
DWORD CAddr::GetRFC822AddressCount(char *szAddressList)
{
    DWORD   cRecips = 0;
    LPSTR   szCommentStart = szAddressList;
    LPSTR   szCommentEnd = szAddressList;
    LPSTR   szSearchStart = szAddressList;
    LPSTR   szSearchDelimiter = NULL; //ptr to delimiter
    LPSTR   szLastDelimiter = NULL; //ptr to last delimiter found
    BOOL    fSeenAlphaNum = FALSE;
    BOOL    fInQuote = TRUE;
	DWORD   dwPairs = 0;
    CHAR    chSaved = '\0';
    CHAR    *pchChanged = NULL;
    BOOL    fDelimiterNotFound = TRUE;
    CHAR    rgchDelimiters[] = {',', ';', '\0'};


    //We look for RFC822 delimiters (, or ;) that are not in comments (which 
    //are delimited by ()'s or which are in quotes.

    //No string... no recips
    if (!szAddressList)
        goto Exit;
        
    //If we have any string... we start out with 1 recip
    cRecips++;

	// First, we strip the comments
	// We call the function above to find matching parenthesis pairs
	do
	{
        //Set start of search to start of string being scanned for ()'s
        szSearchStart = szCommentStart;

		if (!pMatchParentheses(&szCommentStart, &szCommentEnd, &dwPairs))
		{
			// Failed!
            cRecips = 0;
            goto Exit;
		}
        
		if (dwPairs) //we have comments
		{
			//We found some comments
			_ASSERT(*szCommentStart == '(');
			_ASSERT(*szCommentEnd == ')');

            //If the first character of our search was a '('... then we
            //should not bother searching for delimiters
            if (szSearchStart == szCommentStart)
            {
    			szCommentStart = szCommentEnd + 1;
                continue;
            }

            //Set the end of our search for delimiters & set to NULL character
            pchChanged = szCommentStart;
            chSaved = *szCommentStart;
            *szCommentStart = '\0';

			// Reset the pointers, and match again ...
			szCommentEnd++;
			szCommentStart = szCommentEnd;
		}
		else
		{
            //We found no further comments... there is no need to save a character
            chSaved = '\0';
            pchChanged = NULL;
		}

        
        //Now we will search for unqoted delimiters in this uncommented section

        //Iterate over all the delimiters we have
        for (CHAR *pchDelimiter = rgchDelimiters; *pchDelimiter; pchDelimiter++)
        {
            szSearchDelimiter = szSearchStart;
            do
            {
                szSearchDelimiter = pFindNextUnquotedOccurrence(
                                        szSearchDelimiter, *pchDelimiter,
                                        &fDelimiterNotFound, 0);

                if (!fDelimiterNotFound)
                {
                    _ASSERT(*pchDelimiter == *szSearchDelimiter);
                    cRecips++;

                    if (szSearchDelimiter && (szSearchDelimiter > szLastDelimiter))
                        szLastDelimiter = szSearchDelimiter;
                }
                else 
                {
                    //We know we won't find anymore in this section
                    break;
                }

            //Keep on looping while we are still finding delimiters and we are not
            //at the end of the string
            } while (!fDelimiterNotFound && 
                     szSearchDelimiter && *szSearchDelimiter &&
                     *(++szSearchDelimiter));
        }

        //Restore changed character
        if (pchChanged && ('\0' != chSaved))
            *pchChanged = chSaved;

	} while (dwPairs);

    //Make sure the last delimiter was not at the end of the buffer
    if (szLastDelimiter && cRecips && *szLastDelimiter)
    {
        while (*(++szLastDelimiter))
        {
            //if it is not a space... count it as a recipient
            if (!isspace(*szLastDelimiter))
                goto Exit;
        }
        //Only whitespace after last delimiter... we have counted 1 too many recips
        cRecips--;
    }

  Exit:
	return cRecips;
}


//---[ IsRecipientInRFC822AddressList ]----------------------------------------
//
//
//  Description: 
//      Determines if a given recipient is in the given RFC822 formatted 
//      recipient list.
//  Parameters:
//      IN  szAddressList       Address list to check in
//      IN  szRecip             Recipient Address to check for
//  Returns:
//      TRUE if there was a match
//      FALSE if there was no match
//  History:
//      2/17/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CAddr::IsRecipientInRFC822AddressList(char *szAddressList, char *szRecip)
{
    LPSTR   szRecipEnd = NULL;
    CHAR    chSaved    = '\0';
    LPSTR   szCurrentAddress = szAddressList;
    BOOL    fFound = FALSE;
    DWORD   cbAddress;       

    if (!szAddressList || !szRecip)
        goto Exit;

    //Convert everything to lower case so we match correctly
    szCurrentAddress = szAddressList;
    do
    {
        *szCurrentAddress = (CHAR) tolower(*szCurrentAddress);
    } while(*(++szCurrentAddress));

    szCurrentAddress = szRecip;
    do 
    {
        *szCurrentAddress = (CHAR) tolower(*szCurrentAddress);
    } while(*(++szCurrentAddress));
  
    //skip past white space in recipient
    while (*szRecip && isspace(*szRecip))
            szRecip++;

    //Find and skip past extranious trailing whitespace
    cbAddress = strlen(szRecip);
    szRecipEnd = szRecip + cbAddress/sizeof(CHAR);
    szRecipEnd--;

    while (isspace(*szRecipEnd))
    {
        cbAddress--;
        szRecipEnd--;
    }

    //Make szRecipEnd point to last space
    szRecipEnd++;

    //Null terminate before trailing whitespace
    chSaved = *szRecipEnd;
    *szRecipEnd = '\0';

    //Search for addresss as substring, and see if it looks like a lone address
    for (szCurrentAddress = strstr(szAddressList, szRecip);
         szCurrentAddress && !fFound;
         szCurrentAddress = strstr(++szCurrentAddress, szRecip))
    {
        //look for surrounding characters to not match partial addresses
        //We don't want "user" to match "user1" or "user@foo" or "foo@user"
        if ((szCurrentAddress != szAddressList))
        {
            if (!pIsSpecialOrSpace(*(szCurrentAddress-1)) || 
                ('@' == *(szCurrentAddress-1)))
                continue;
        }


        if (szCurrentAddress[cbAddress/sizeof(CHAR)])
        {
            if (!pIsSpecialOrSpace(szCurrentAddress[cbAddress/sizeof(CHAR)]) ||
                ('@' == szCurrentAddress[cbAddress/sizeof(CHAR)]))
               continue;
        }

        //The address looks like a match
        fFound = TRUE;
        break;
           
    }
         
  Exit:

    //Restore saved space
    if (szRecipEnd && chSaved)
        *szRecipEnd = chSaved;

    return fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\simssl2\credcach.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    credcach.cxx

Abstract:

    This module contains the code to associate and cache SSPI credential
    handles with local server addresses

Author:

Comments :

This is a two-level cache : the first level is at the instance level [INSTANCE_CACHE_ITEM]
and just contains a pointer to the actual item holding the credential handles. The second level
[CRED_CACHE_ITEM] holds the actual credential handles, as well as pointers to the mappers.

An INSTANCE_CACHE_ITEM points to a CRED_CACHE_ITEM, with a single CRED_CACHE_ITEM potentially
being referenced by several INSTANCE_CACHE_ITEMS, if several instances share the relevant data.

      Each instance has 3 SSL-related components : the server certificate for the instance, the
certificate mappers for the instance and the trusted issuers for the instance [a combination of
the certificates in the ROOT store and the Certificate Trust List associated with the server]. Two
instances can share a CRED_CACHE_ITEM under the following circumstances :

1. The same server certificate
2. No/Same CTL
3. No mappers

The INSTANCE_CACHE_ITEM entries are keyed off "<instance ptr>"; the CRED_CACHE_ITEM
entries are keyed off an "SSL info" blob which can be used to uniquely distinguish between
credential sets that don't fulfill the criteria listed above. The SSL info blob is obtained by
querying the instance and consists of "<SHA1 hash of server cert>:<SHA1 hash of CTL>",
which has the advantage of being fixed length [20 bytes for cert hash, 20 bytes for CTL hash,
1 byte for ':']. If there is no CTL, the length is still 41, but everything after the CERT has is
zeroed out

Revision History:

	Nimish Khanolkar		FEB'98		Changes related to having one cert per instance
--*/

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <wincrypt.h>
#include <stdlib.h>

}

#include <dbgutil.h>
#include <buffer.hxx>
#include <ole2.h>
#include <imd.h>
#include <iadm.h>
#include <mb.hxx>
#include <iiscnfg.h>
//#include <iiscnfgp.h>
#include <refb.hxx>

#include <cmnull.hxx>
#include <iiscrmap.hxx>

#include "iistypes.hxx"

extern "C" {
#define SECURITY_WIN32
#include <sspi.h>
#include <ntsecapi.h>
#include <spseal.h>
#include <schnlsp.h>
#include ".\credcach.hxx"
#include <w3svc.h>
}

#include "iiscert.hxx"
#include "iisctl.hxx"
#include "capiutil.hxx"


#if DBG
#define PRINTF( x )     { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define PRINTF( x )
#endif

#ifdef  UNIT_TEST
DEBUG_PRINTS  *  g_pDebug = 0;
#endif

#define SSPIFILT_CERT_MAP_LIST  "CertMapList"
#define SSPIFILT_INIT_MAP       "CreateInstance"
#define SSPIFILT_TERM_MAP       "TerminateMapper"

//
//  Globals
//

LIST_ENTRY CredCacheList;
LIST_ENTRY InstanceCacheList;
CRED_CACHE_ITEM* g_pcciClient = NULL;

IMDCOM*    pMDObject;

IMSAdminBaseW* pAdminObject;


//
//  Prototypes
//

BOOL
LoadKeys(
    IN  IIS_SSL_INFO *pSSLInfo,
	IN	PVOID		 pvInstance,
    IN  HMAPPER**    ppMappers,
    IN  DWORD        cNbMappers,
    OUT CredHandle * phCreds,
    OUT DWORD *      pcCred,
    OUT CredHandle * phCredsMap,
    OUT DWORD *      pcCredMap,
	IN  LPSTR        pszMdPath
    );

BOOL
AddFullyQualifiedItem(
    IN  WCHAR *             pwszServerPrefix,
    CHAR *                  pszId,
    IN  UINT                cId,
    CHAR *                  pszAddress,
    IN  CHAR *              pszPort,
    IN  LPVOID              pvInstanceId,
    IN  PVOID               pvsmc,
    IN  DWORD               dwInstanceId
    );

BOOL
AddItem(
    CHAR *				pszAddress,
    LPVOID				pvInstanceId,
    RefBlob*			pCert11,
    RefBlob*			pCertW,
    IIS_SSL_INFO		*pSSLInfo,
    CRED_CACHE_ITEM**	ppcci,
    DWORD				dwInstanceId,
	LPSTR				pszMdPath
    );

BOOL
LookupCredential(
    IN  CHAR *              pszAddress,
    IN  LPVOID              pvInstanceId,
    OUT CRED_CACHE_ITEM * * ppCCI
    );

BOOL
InitializeCertMapping(
    LPVOID      pCert11,
    LPVOID      pCertW,
	LPVOID		pSslInfo,
    HMAPPER***  pppMappers,
    LPDWORD     pdwMappers,
    DWORD       dwInstanceId
    );


VOID WINAPI NotifySslChanges(
    DWORD                         dwNotifyType,
    LPVOID                        pInstance
    );


BOOL GenerateSSLIdBlob( IIS_SSL_INFO *pSSLInfoObj,
                         PBYTE pbBlob );



VOID
InitCredCache(
    VOID
    )
/*++

Routine Description:

    Initializes the credential cache

--*/
{
    InitializeListHead( &CredCacheList );
    InitializeListHead( &InstanceCacheList );
}


VOID
FreeCredCache(
    VOID
    )
/*++

Routine Description:

    Releases all of the memory associated with the credential cache

--*/
{
    //LIST_ENTRY * pEntry;
    CRED_CACHE_ITEM * pcci;
    INSTANCE_CACHE_ITEM * pici;

    while ( !IsListEmpty( &InstanceCacheList ))
    {
        pici = CONTAINING_RECORD( InstanceCacheList.Flink,
                                  INSTANCE_CACHE_ITEM,
                                  m_ListEntry );

        RemoveEntryList( &pici->m_ListEntry );

        delete pici;
    }

    while ( !IsListEmpty( &CredCacheList ))
    {
        pcci = CONTAINING_RECORD( CredCacheList.Flink,
                                  CRED_CACHE_ITEM,
                                  m_ListEntry );

        RemoveEntryList( &pcci->m_ListEntry );

        pcci->Release();
    }

    if ( g_pcciClient != NULL )
    {
        g_pcciClient->Release();
        g_pcciClient = NULL;
    }
}


BOOL
LookupFullyQualifiedCredential(
    IN  WCHAR *             pwszServerPrefix,
    IN  CHAR *              pszIpAddress,
    IN  DWORD               cbAddress,
    IN  CHAR *              pszPort,
    IN  DWORD               cbPort,
    IN  LPVOID              pvInstanceId,
    OUT CRED_CACHE_ITEM * * ppCCI,
    IN  PVOID               pvsmc,
    IN  DWORD               dwInstanceId
    )
/*++

Routine Description:

    Finds an entry in the credential cache or creates one if it's not found

Arguments:

    pszIpAddress - Address name for this credential
    cbAddress - Number of bytes (including '\0') of pszIpAddress
    pszPort - Port ID for this credential
    cbPort - Number of bytes ( including '\0') of pszPort
    pvInstanceId - ptr to be used as w3 instance ID for this credential
    ppCCI - Receives pointer to a Credential Cache Item
    pvsmc - ptr to map context using the instance specified in pvInstanceId
    dwInstanceId - w3 instance Id

Returns:

    TRUE on success, FALSE on failure.  If this item's key couldn't be found,
    then ERROR_INVALID_NAME is returned.

--*/
{
    INSTANCE_CACHE_ITEM *   pcci;
    LIST_ENTRY *            pEntry;
    CHAR                    achId[MAX_ADDRESS_LEN];
//    LPSTR                   p = achId;
    UINT                    cId = 0;

/*NimishK : not needed
    //
    // build ID of this credential request : IP address + port + instance
    //

    memcpy( p, pszIpAddress, cbAddress );
    p += cbAddress;
    *p++ = ':';
    memcpy( p, pszPort, cbPort );
    p += cbPort;
    *p++ = ':';

	// An INSTANCE_CACHE_ITEM is keyed of Instance ptr
//    *(LPVOID*)p = pvInstanceId;
//    cId = sizeof(LPVOID);
*/

RescanList:

    for ( pEntry  = InstanceCacheList.Flink;
          pEntry != &InstanceCacheList;
          pEntry  = pEntry->Flink )
    {
        pcci = CONTAINING_RECORD( pEntry, INSTANCE_CACHE_ITEM, m_ListEntry );

		// An INSTANCE_CACHE_ITEM is keyed of Instance ptr. Compare it.
        if ( pcci->m_pvInstanceId == pvInstanceId )
        {
            //
            //  If this is an item we failed to find previously, then return
            //  an error
            //

            if ( pcci->m_fValid )
            {
                *ppCCI = pcci->m_pcci;
                pcci->m_pcci->AddRef();
                return TRUE;
            }

            SetLastError( ERROR_INVALID_NAME );
            *ppCCI = NULL;
            return FALSE;
        }
    }

    //
    //  This address isn't in the list, try getting it credential cache then
    //  rescan the list for the new item.  Note we leave the list locked
    //  while we try and get the item.  This prevents multiple threads from
    //  trying to create the same item
    //

    if ( !AddFullyQualifiedItem( pwszServerPrefix, achId, cId, pszIpAddress, pszPort, pvInstanceId, pvsmc, dwInstanceId ))
    {
        return FALSE;
    }

    goto RescanList;
}


VOID
ReleaseCredential(
    CRED_CACHE_ITEM * pcci
    )
/*++

Routine Description:

    Release a credential acquired via LookupFullyQualifiedCredential()

Arguments:

    pCCI - pointer to a Credential Cache Item

Returns:

    Nothing

--*/
{
    if ( pcci )
    {
        pcci->Release();
    }
}

//
// Secret value names. Each value exist in 4 variants,
// used to access the Lsa secret, the 1st one using IP + port
// the 2nd one IP only, the 3rd one port only
// The 4th entry specify designate the default value ( common to all address and ports )
//

LPSTR SecretTableA[4] =
{
    "%s:%s", "%s", "%0.0s%s", "default",
};

LPWSTR SecretTableW[4] =
{
    L"%S:%S", L"%S", L"%0.0S%S", L"default",
};

BOOL
GetMDSecret(
    MB*             pMB,
    LPSTR           pszObj,
    DWORD           dwId,
    UNICODE_STRING**ppusOut
    )
{
    DWORD           dwL = 0;
    PUNICODE_STRING pusOut = NULL;

    if ( pMB->GetData( pszObj,
                       dwId,
                       IIS_MD_UT_SERVER,
                       BINARY_METADATA,
                       NULL,
                       &dwL,
                       METADATA_SECURE ) || GetLastError() == ERROR_INSUFFICIENT_BUFFER )
    {
        if ( (pusOut = (PUNICODE_STRING)LocalAlloc( LMEM_FIXED, sizeof(UNICODE_STRING) )) &&
             (pusOut->Buffer = (WORD*)LocalAlloc( LMEM_FIXED, dwL )) )
        {
            if ( pMB->GetData( pszObj,
                               dwId,
                               IIS_MD_UT_SERVER,
                               BINARY_METADATA,
                               pusOut->Buffer,
                               &dwL,
                               METADATA_SECURE ) )
            {
                pusOut->Length = pusOut->MaximumLength = (WORD)dwL;
                *ppusOut = pusOut;
                return TRUE;
            }
        }

        if (pusOut) {
            if (pusOut->Buffer) {
                LocalFree( pusOut->Buffer );
            }
            LocalFree( pusOut );
        }
    }

    return FALSE;
}


BOOL
GetAdminSecret(
    WCHAR *         pwszServerPrefix,
    IMSAdminBaseW*  pAdminObj,
    LPWSTR          pszObj,
    DWORD           dwId,
    UNICODE_STRING**ppusOut
    )
{
    DWORD           dwL = 0;
    DWORD           dwErr = 0;
    PUNICODE_STRING pusOut;
    HRESULT hRes = S_OK;
    METADATA_HANDLE RootHandle;
    METADATA_RECORD mdRecord;
    WCHAR           wszMetabaseRoot[256] ;

    wsprintfW( wszMetabaseRoot, SSL_SERVICE_KEYS_MD_PATH_W, pwszServerPrefix ) ;

    hRes = pAdminObject->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                wszMetabaseRoot,
                METADATA_PERMISSION_READ,
                100,
                &RootHandle
                );

    if (FAILED(hRes)) {
        return FALSE ;
    }

    mdRecord.dwMDIdentifier = dwId;
    mdRecord.dwMDAttributes = METADATA_SECURE;
    mdRecord.dwMDUserType   = IIS_MD_UT_SERVER;
    mdRecord.dwMDDataType   = BINARY_METADATA;
    mdRecord.dwMDDataLen    = dwL;
    mdRecord.pbMDData       = NULL;

    hRes = pAdminObj->GetData(  RootHandle,
                                pszObj,
                                &mdRecord,
                                &dwL ) ;

    if( FAILED(hRes) && (HRESULTTOWIN32( hRes ) == ERROR_INSUFFICIENT_BUFFER) )
    {
        if ( (pusOut = (PUNICODE_STRING)LocalAlloc( LMEM_FIXED, sizeof(UNICODE_STRING) )) &&
             (pusOut->Buffer = (WORD*)LocalAlloc( LMEM_FIXED, dwL )) )
        {
            mdRecord.dwMDIdentifier = dwId;
            mdRecord.dwMDAttributes = METADATA_SECURE;
            mdRecord.dwMDUserType   = IIS_MD_UT_SERVER;
            mdRecord.dwMDDataType   = BINARY_METADATA;
            mdRecord.dwMDDataLen    = dwL;
            mdRecord.pbMDData       = (PBYTE)pusOut->Buffer;

            hRes = pAdminObj->GetData(  RootHandle,
                                        pszObj,
                                        &mdRecord,
                                        &dwL );
            if( SUCCEEDED( hRes ) )
            {
                pusOut->Length = pusOut->MaximumLength = (WORD)mdRecord.dwMDDataLen;
                *ppusOut = pusOut;
                pAdminObject->CloseKey(RootHandle);
                return TRUE;
            }
            dwErr = GetLastError();
        }

        if (pusOut) {
            if (pusOut->Buffer) {
                LocalFree( pusOut->Buffer );
            }
            LocalFree( pusOut );
        }
    }

    pAdminObject->CloseKey(RootHandle);
    return FALSE;
}

BOOL
AddFullyQualifiedItem(
    IN  WCHAR *             pwszServerPrefix,
    IN  CHAR *              pszId,
    IN  UINT                cId,
    IN  CHAR *              pszAddress,
    IN  CHAR *              pszPort,
    IN  LPVOID              pvInstanceId,
    IN  PVOID               pvsmc,
    IN  DWORD               dwInstanceId
    )
/*++

Routine Description:

    Creates a new item in the credential cache and adds it to the list

    pszAddress must be a simple string that has no odd unicode mappings

    This routine must be single threaded

Arguments:

    pszId - ID of cache entry to add
    pszAddress - Address name for this credential
    pszPort - port for this credential
    pvInstanceId - ptr to be used as service instance ID for this credential
    pvsmc - ptr to map context using the instance specified in pvInstanceId
    dwInstanceId - w3 instance Id

Returns:

    TRUE on success, FALSE on failure

--*/
{

    CHAR              achSecretNameA[MAX_SECRET_NAME+1];
/*	// NimishK : I don't think these are used anymore
	//WCHAR             achSecretName[MAX_SECRET_NAME+1];
    //UNICODE_STRING *  SecretValue[3];
    //DWORD             i;
    //DWORD             j;
*/
    BOOL              fRet = TRUE;
    INSTANCE_CACHE_ITEM * pcci;
    RefBlob*          pBlob11 = NULL;
    RefBlob*          pBlobW = NULL;
    CRED_CACHE_ITEM * pci;

	//Added for CAPI stuff
	IIS_SSL_INFO      *pSSLInfoObj = NULL;
	PBYTE             pbSSLBlob = NULL;

    PSERVICE_MAPPING_CONTEXT psmc = (PSERVICE_MAPPING_CONTEXT)pvsmc;

	//Need to clean this up with pvInstanceId->QueryMDPath()
	CHAR   szMDPath[256] ;
	wsprintf( szMDPath, "/LM/%S/%d", pwszServerPrefix,dwInstanceId ) ;

/*
// Nimishk : I dont think this is needed

    MB                mb( pMDObject );

    CHAR              szMetabaseRoot[256] ;

    wsprintf( szMetabaseRoot, SSL_SERVICE_KEYS_MD_PATH, pwszServerPrefix ) ;

    if ( !mb.Open( szMetabaseRoot ))
    {
        return FALSE;
    }
*/
/* NimishK cId is no longer used

    if ( cId > MAX_ADDRESS_LEN )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
*/

    //
    //  Create and initialize the context item
    //

    pcci = new INSTANCE_CACHE_ITEM;

    if ( !pcci )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

//    memcpy( pcci->m_achId, pszId, cId );
//    pcci->m_cbId = cId;
    pcci->m_pvInstanceId = pvInstanceId;

    pcci->m_fValid = FALSE;
    pcci->m_pcci = NULL;

    InsertTailList( &InstanceCacheList, &pcci->m_ListEntry );

/*Nimishk : Dont need this anymore
    //
    //  Retrieve the secret from the registry
    //

    fRet = FALSE;

    memset( SecretValue, 0, sizeof( SecretValue ));
*/

	//
	// Get the "SSL id" blob used to locate the CRED_CACHE_ITEM for this instance
	//
	if ( pvInstanceId )
	{
		IIS_SERVER_INSTANCE *pIISInstance = (IIS_SERVER_INSTANCE *) pvInstanceId;


		if ( ( pSSLInfoObj = pIISInstance->QueryAndReferenceSSLInfoObj()) &&
			 GenerateSSLIdBlob( pSSLInfoObj,
								(PBYTE) achSecretNameA ) )
		{
			fRet = TRUE ;
		}
	}

	if ( fRet )
    {
        if( psmc )
        {
            //
            // Retrieve blobs pointing to cert 1:1 mapper & cert wildcard mapper
            //

            if ( !psmc->ServerSupportFunction(  pvInstanceId,
                                                (LPVOID)&pBlob11,
                                                SIMSSL_PROPERTY_MTCERT11 ) )
            {
                pBlob11 = NULL;
            }

            if ( !psmc->ServerSupportFunction(  pvInstanceId,
                                                (LPVOID)&pBlobW,
                                                SIMSSL_PROPERTY_MTCERTW ) )
            {
                pBlobW = NULL;
            }
        }

        //
        // All instances w/o mappers maps to NULL, so that they share a CRED_CACHE_ENTRY
        //

        if ( pBlob11 == NULL && pBlobW == NULL )
        {
            pvInstanceId = NULL;
        }

        //
        // try fo find it in cache
        // returned cache entry's refcount is incremented by LookupCredential or AddItem
        // if successfull
        //

        if ( !LookupCredential( (LPSTR)achSecretNameA, pvInstanceId, &pci ) )
        {
            if ( GetLastError() == ERROR_NO_MORE_ITEMS )
            {
                //
                //  This address isn't in the list, try getting it from the lsa then
                //  rescan the list for the new item.  Note we leave the list locked
                //  while we try and get the item.  This prevents multiple threads from
                //  trying to create the same item
                //

                if ( AddItem( (LPSTR)achSecretNameA,
								pvInstanceId,
								pBlob11,
								pBlobW,
								pSSLInfoObj,
								&pci,
								dwInstanceId,
								(LPSTR)szMDPath ) )
                {
                    pcci->m_pcci = pci;
                    pcci->m_fValid = TRUE;
                }
            }
        }
        else
        {
            pcci->m_pcci = pci;
            pcci->m_fValid = TRUE;
        }
    }

    //
    //  Return TRUE to indicate we added the item to the list.  If the item
    //  wasn't found, then it's a place holder for that particular address
    //
/* Not needed anymore

    for ( i = 0; i < 3; i++ )
    {
        if( SecretValue[i] != NULL )
        {
            LocalFree( SecretValue[i]->Buffer );
            LocalFree( SecretValue[i] );
        }
    }
*/
    //
    // Release blob now. CRED_CACHE_ITEM added a reference to them
    // if entry created
    //

    if ( pBlob11 != NULL )
    {
        pBlob11->Release();
    }
    if ( pBlobW != NULL )
    {
        pBlobW->Release();
    }

	//
	// Release IIS_SSL_INFO object, since we're done with it
	//
	if ( pSSLInfoObj )
	{
		IIS_SSL_INFO::Release( pSSLInfoObj );
	}

    return TRUE;
}


BOOL
LookupCredential(
    IN  CHAR *              pszAddress,
    IN  LPVOID              pvInstanceId,
    OUT CRED_CACHE_ITEM * * ppCCI
    )
/*++

Routine Description:

    Finds an entry in the credential cache or creates one if it's not found

Arguments:

    pszAddress - Address name for this credential
    pvInstanceId - ptr to be used as w3 instance ID for this credential
    ppCCI - Receives pointer to a Credential Cache Item

Returns:

    TRUE on success, FALSE on failure.  If this item's key couldn't be found,
    then ERROR_NO_MORE_ITEMS is returned.
    If key exist but entry invalid then ERROR_INVALID_NAME is returned.

--*/
{
    CRED_CACHE_ITEM * pcci;
    LIST_ENTRY *      pEntry;

    for ( pEntry  = CredCacheList.Flink;
          pEntry != &CredCacheList;
          pEntry  = pEntry->Flink )
    {
        pcci = CONTAINING_RECORD( pEntry, CRED_CACHE_ITEM, m_ListEntry );

        if ( !memcmp( pcci->m_achSSLIdBlob, pszAddress, MAX_SSL_ID_LEN ) &&
             pcci->m_pvInstanceId == pvInstanceId )
        {
            //
            //  If this is an item we failed to find previously, then return
            //  an error
            //

            if ( pcci->m_fValid )
            {
                *ppCCI = pcci;
                pcci->AddRef();
                return TRUE;
            }

            SetLastError( ERROR_INVALID_NAME );

            return FALSE;
        }
    }

    SetLastError( ERROR_NO_MORE_ITEMS );

    return FALSE;
}


BOOL
AddItem(
    CHAR * pszAddress,
    LPVOID pvInstanceId,
    RefBlob* pCert11,
    RefBlob* pCertW,
    IIS_SSL_INFO *pSSLInfoObj,
    CRED_CACHE_ITEM** ppcci,
    DWORD             dwInstanceId,
	LPSTR             pszMdPath
    )
/*++

Routine Description:

    Creates a new item in the credential cache and adds it to the list

    pszAddress must be a simple string that has no odd unicode mappings

    This routine must be single threaded

Arguments:

    pszAddress - Address name for this credential
    pvInstanceId - ptr to be used as service instance ID for this credential
    pCert11 - ptr to blob storing cert 1:1 mapper or NULL if no mapper
    pCertW - ptr to blob storing cert wildcard mapper or NULL if no mapper
    pSSLInfObj - pointer to SSL info to be used for this item
    ppCCI - Receives pointer to a Credential Cache Item
    dwInstanceId - w3 instance ID

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL              fRet = TRUE;
    BOOL              fRetM;
    BOOL              fRetL;
    CRED_CACHE_ITEM * pcci;

    //
    //  Create and initialize the context item
    //

    pcci = new CRED_CACHE_ITEM;

    if ( !pcci )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    memcpy( pcci->m_achSSLIdBlob, pszAddress, MAX_SSL_ID_LEN );
    pcci->m_pvInstanceId = pvInstanceId;

    memset( pcci->m_ahCred, 0, sizeof( pcci->m_ahCred ));
    memset( pcci->m_ahCredMap, 0, sizeof( pcci->m_ahCredMap ));
    memset( pcci->m_acbTrailer, 0, sizeof( pcci->m_acbTrailer ));
    memset( pcci->m_acbHeader, 0, sizeof( pcci->m_acbHeader ));

    InsertTailList( &CredCacheList, &pcci->m_ListEntry );

    //
    // build cert mapper DLLs array
    //

    if ( fRetM = InitializeCertMapping( pCert11 ? pCert11->QueryPtr() : NULL,
                                        pCertW ? pCertW->QueryPtr() : NULL,
										pSSLInfoObj ? (LPVOID) pSSLInfoObj : NULL,
                                        &pcci->m_ppMappers,
                                        &pcci->m_cNbMappers,
                                        dwInstanceId ) )
    {
        //
        //  LoadKeys will zero out these values on success or failure.  Note
        //  the password is stored as an ansi string because the SSL
        //  security structure is expecting an ANSI string
        //

        fRetL = LoadKeys( pSSLInfoObj,
						  pvInstanceId,
                          pcci->m_ppMappers,
                          pcci->m_cNbMappers,
                          pcci->m_ahCred,
                          &pcci->m_cCred,
                          pcci->m_ahCredMap,
                          &pcci->m_cCredMap,
						  pszMdPath );
    }
    else
    {
        fRetL = FALSE;
    }

    //
    //  Indicate the credential handle is valid on this address if we
    //  succeeded
    //

    if ( fRetL && fRetM )
    {
        pcci->m_fValid = TRUE;
    }
    else
    {
        pCert11 = NULL;
        pCertW = NULL;

        if ( fRetM && !fRetL )
        {
            TerminateCertMapping( pcci->m_ppMappers, pcci->m_cNbMappers );
            pcci->m_ppMappers = NULL;
            pcci->m_cNbMappers = 0;
        }
    }

    //
    // Store reference to mappers
    //

    if ( pcci->m_pBlob11 = pCert11 )
    {
        pCert11->AddRef();
    }

    if ( pcci->m_pBlobW = pCertW )
    {
        pCertW->AddRef();
    }

	//
	// Store reference to SSL info
	//
	if ( pcci->m_pSslInfo = pSSLInfoObj )
	{
		pSSLInfoObj->Reference();
	}

    //
    // Add ref, as will be referenced by *ppcci
    //

    pcci->AddRef();

    *ppcci = pcci;

    //
    //  Return TRUE to indicate we added the item to the list.  If the item
    //  wasn't found, then it's a place holder for that particular address
    //

    return TRUE;
}


BOOL
LoadKeys(
    IN IIS_SSL_INFO *pSSLInfoObj,
	IN	PVOID		 pvInstance,
    IN  HMAPPER**    ppMappers,
    IN  DWORD        cNbMappers,
    OUT CredHandle * phCreds,
    OUT DWORD *      pcCred,
    OUT CredHandle * phCredsMap,
    OUT DWORD *      pcCredMap,
	IN  LPSTR        pszMdPath
    )
/*++

Routine Description:

    Finds an entry in the credential cache or creates one if it's not found

Arguments:

    pSSLInfoObj - object containing SSL info to be used for this credential set
    ppMappers - ptr to array of mapper DLLs
    cNbMappers - number of entry in ppMappers
    phCreds - ptr to array where to store credential handles w/o cert mapping
    pcCred - ptr to counter where to store number of entry in phCreds
    phCredsMap - ptr to array where to store credential handles w/ cert mapping
    pcCredMap - ptr to counter where to store number of entry in phCredsMap
	pszMdPath - path to metabase properties

Returns:

    TRUE on success, FALSE on failure.

--*/
{
    ASSERT( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) );

    //SCH_CRED                    creds;
	// CAPI stuff
	SCHANNEL_CRED               xcreds;
    HCERTSTORE hRootStore;

/*NimishK
//		SCH_CRED_SECRET_CAPI        scsp;
//  	SCH_CRED_PUBLIC_CERTCHAIN   scpc;
*/

	SECURITY_STATUS             scRet;
    SECURITY_STATUS             scRetM;
    TimeStamp                   tsExpiry;
    DWORD                       i;

/*NimishK
//    LPVOID                      ascsp[1];
//    LPVOID                      ascpc[1];
//    DWORD                       dwV;
//		MB                          mb( pMDObject );
//		BUFFER                      buAlg;
*/

	// Added for CAPI stuff
    PCCERT_CONTEXT              pcCert = NULL;
    LPVOID                      pcreds;

    *pcCred             = 0;
    *pcCredMap          = 0;

    memset(&xcreds, 0, sizeof(xcreds));
    xcreds.dwVersion = SCHANNEL_CRED_VERSION;
    xcreds.cCreds = 1;

	if ( pSSLInfoObj->GetCertificate() &&
		pSSLInfoObj->GetCertificate()->IsValid() )
	{
		xcreds.paCred = pSSLInfoObj->GetCertificate()->QueryCertContextAddr();
	}
    xcreds.cMappers = cNbMappers ;
    xcreds.aphMappers = ppMappers;

	if (pSSLInfoObj->GetTrustedIssuerStore( &hRootStore ))
	{
		xcreds.hRootStore = hRootStore;
	}
	else
	{
		xcreds.hRootStore = NULL;
	}

    pcreds = (LPVOID) &xcreds;

    for ( i = 0; pEncProviders[i].pszName && i < MAX_PROVIDERS; i++ )
    {
        if ( !pEncProviders[i].fEnabled )
        {
            continue;
        }

        //creds.cMappers = 0;
		//CAPI
		// Credentials with no client cert mapping at all
		//
		((SCHANNEL_CRED*)pcreds)->cMappers = 0;
		((SCHANNEL_CRED*)pcreds)->dwFlags = SCH_CRED_NO_SYSTEM_MAPPER;

        ASSERT( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) );

        scRet = g_AcquireCredentialsHandle(  NULL,               // My name (ignored)
                                            pEncProviders[i].pszName, // Package
                                            SECPKG_CRED_INBOUND,// Use
                                            NULL,               // Logon Id (ign.)
                                            pcreds,             // auth data
                                            NULL,               // dce-stuff
                                            NULL,               // dce-stuff
                                            &phCreds[*pcCred],  // Handle
                                            &tsExpiry );

        PRINTF((buff, "Cred %08x:%08x : mapper %08x\n", phCreds[*pcCred], NULL ));

		//
		// DS mapper only - no mappers passed to AcquireCredentialsHandle(), clear the flag
		// telling Schannel not to use the DS mapper
		//
		if ( pSSLInfoObj->UseDSMapper() )
		{
			((SCHANNEL_CRED*)pcreds)->cMappers = 0;
			((SCHANNEL_CRED*)pcreds)->dwFlags = 0;
//			DBGPRINTF((DBG_CONTEXT,
//					   "[SSPIFILT] Using DS mapper \n"));

		}
		//
		// IIS mappers only - pass mappers to AcquireCredentialsHandle(), set flag in each one
		// indicating that only IIS mappers are to be called, keep flag telling Schannel
		// not to use DS mapper [set to SCH_CRED_NO_SYSTEM_MAPPER above]
		//
		else
		{
			((SCHANNEL_CRED*)pcreds)->cMappers = cNbMappers;
			for ( DWORD dwI = 0; dwI < cNbMappers; dwI++ )
			{
				((SCHANNEL_CRED*)pcreds)->aphMappers[dwI]->m_dwFlags = SCH_FLAG_DEFAULT_MAPPER;

			}
//			DebugTrace(NULL,
//					   "[SSPIFILT] Using IIS mappers \n"));
		}

        //creds.cMappers = cNbMappers;

        ASSERT( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) );

        scRetM = g_AcquireCredentialsHandle( NULL,               // My name (ignored)
                                            pEncProviders[i].pszName, // Package
                                            SECPKG_CRED_INBOUND,// Use
                                            NULL,               // Logon Id (ign.)
                                            pcreds,             // auth data
                                            NULL,               // dce-stuff
                                            NULL,               // dce-stuff
                                            &phCredsMap[*pcCredMap],  // Handle
                                            &tsExpiry );

        //PRINTF((buff, "Cred %08x:%08x : mapper %08x\n", phCredsMap[*pcCredMap], creds.aphMappers ));
        // Null out creds, it doesn't seem to be used
        PRINTF( (buff, "Cred %08x:%08x ", phCredsMap[*pcCredMap] ));

        ASSERT( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) );

        if ( !FAILED( scRetM ) && !FAILED( scRet ) )
        {
            *pcCred += 1;
            *pcCredMap += 1;
        }
    }

	if ( xcreds.hRootStore )
	{
		CertCloseStore( xcreds.hRootStore,
						0 );
	}
    //
    // Tell the caller about it.
    //

    if ( !*pcCred && FAILED( scRet ))
    {
        SetLastError( scRet );

        return FALSE;
    }

    return TRUE;
}


BOOL
GetSecretW(
    WCHAR *            pszSecretName,
    UNICODE_STRING * * ppSecretValue
    )
/*++
    Description:

        Retrieves the specified unicode secret

    Arguments:

        pszSecretName - LSA Secret to retrieve
        ppSecretValue - Receives pointer to secret value.  Memory should be
            freed by calling LsaFreeMemory

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    BOOL                  fResult;
    NTSTATUS              ntStatus;
    LSA_UNICODE_STRING    unicodeSecret;
    LSA_HANDLE            hPolicy;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;


    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
    {
        SetLastError( LsaNtStatusToWinError( ntStatus ) );
        return FALSE;
    }

    unicodeSecret.Buffer        = pszSecretName;
    unicodeSecret.Length        = wcslen( pszSecretName ) * sizeof(WCHAR);
    unicodeSecret.MaximumLength = unicodeSecret.Length + sizeof(WCHAR);

    //
    //  Query the secret value.
    //

    ntStatus = LsaRetrievePrivateData( hPolicy,
                                       &unicodeSecret,
                                       (PLSA_UNICODE_STRING *) ppSecretValue );

    fResult = NT_SUCCESS(ntStatus);

    //
    //  Cleanup & exit.
    //

    LsaClose( hPolicy );

    if ( !fResult )
        SetLastError( LsaNtStatusToWinError( ntStatus ));

    return fResult;

}   // GetSecretW


BOOL
InitializeCertMapping(
    LPVOID      pCert11,
    LPVOID      pCertW,
	LPVOID      pSslInfo,
    HMAPPER***  pppMappers,
    LPDWORD     pdwMappers,
    DWORD       dwInstanceId
    )
/*++
    Description:

        Initialize the cert mapping DLL list

    Arguments:

        None

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    HKEY                hKey;
    DWORD               dwType;
    DWORD               cbData;
    BOOL                fSt = TRUE;
    LPSTR               pszMapList = NULL;
    LPSTR               p;
    LPSTR               pDll;
    UINT                cMaxMap;
    PFN_INIT_CERT_MAP   pfnInit;
    HINSTANCE           hInst;
    PMAPPER_VTABLE      pVT;
    DWORD               cNbMappers = 0;
    HMAPPER**           ppMappers = NULL;
    IisMapper*          pIM;

    if ( pCert11 == NULL && pCertW == NULL )
    {
        *pppMappers = NULL;
        *pdwMappers = 0;

        return TRUE;
    }

    //
    // Open reg, count # mappers, allocate array, populate array
    //

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMETERS_KEY,
                       0,
                       KEY_ALL_ACCESS,
                       &hKey ) == NO_ERROR )
    {

        if ( RegQueryValueEx( hKey,
                              SSPIFILT_CERT_MAP_LIST,
                              NULL,
                              &dwType,
                              NULL,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_SZ &&
             (pszMapList = (LPSTR)LocalAlloc( LMEM_FIXED, cbData )) &&
             RegQueryValueEx( hKey,
                              SSPIFILT_CERT_MAP_LIST,
                              NULL,
                              &dwType,
                              (LPBYTE)pszMapList,
                              &cbData ) == ERROR_SUCCESS )
        {
            //
            // Count mappers, allocate structures
            //

            for ( cMaxMap = 1, p = pszMapList ;
                  p = strchr( p, ',' ) ;
                  ++p, ++cMaxMap )
            {
            }

            if ( !(ppMappers = (HMAPPER**)LocalAlloc( LMEM_FIXED,
                    sizeof(HMAPPER*) * cMaxMap )) )
            {
                fSt = FALSE;
                goto cleanup;
            }

            //
            // Load libraries, call init entry point
            //

            for ( pDll = pszMapList, cNbMappers = 0 ;
                  *pDll ;
                )
            {
                p = strchr( pDll, ',' );
                if ( p )
                {
                    *p = '\0';
                }

                if ( (hInst = LoadLibrary( pDll )) )
                {
                    //
                    // Use CreateInstance() entry point if present
                    //

                    if ( (pfnInit = (PFN_INIT_CERT_MAP)GetProcAddress(
                                hInst,
                                SSPIFILT_INIT_MAP )) )
                    {
                        if ( SEC_E_OK != (pfnInit)( (HMAPPER**)&pIM ) )
                        {
                            FreeLibrary( hInst );
                            goto next;
                        }

                        //
                        // Mapper handle its own HMAPPER allocation,
                        // will be freed when refcount drops to zero.
                        // Initial refcount is 1
                        //

                        ppMappers[cNbMappers] = (HMAPPER*)pIM;
                        pIM->pCert11Mapper = pCert11;
                        pIM->pCertWMapper = pCertW;
						pIM->pvInfo = pSslInfo;
						//Nimishk : Not sure if this is needed
						pIM->dwInstanceId = dwInstanceId;
                    }
                    else
                    {
                        pIM = (IisMapper*)LocalAlloc( LMEM_FIXED, sizeof(IisMapper) );
                        ppMappers[cNbMappers] = (HMAPPER*)pIM;

                        pIM->hMapper.m_vtable = pVT = &pIM->mvtEntryPoints;
                        pIM->hMapper.m_dwMapperVersion = MAPPER_INTERFACE_VER;
                        pIM->hMapper.m_Reserved1 = NULL;

                        pIM->hInst = hInst;
                        pIM->lRefCount = 0;
                        pIM->fIsIisCompliant = FALSE;
                        pIM->pCert11Mapper = pCert11;
                        pIM->pCertWMapper = pCertW;
						pIM->pvInfo = pSslInfo;
                        pIM->dwInstanceId = dwInstanceId;

                        if ( !(pVT->ReferenceMapper
                                = (REF_MAPPER_FN)GetProcAddress(
                                        hInst,
                                        "ReferenceMapper" )) ||
                             !(pVT->DeReferenceMapper
                                = (DEREF_MAPPER_FN)GetProcAddress(
                                        hInst,
                                        "DeReferenceMapper" )) ||
                             !(pVT->GetIssuerList
                                = (GET_ISSUER_LIST_FN)GetProcAddress(
                                        hInst,
                                        "GetIssuerList" )) ||
                             !(pVT->GetChallenge
                                = (GET_CHALLENGE_FN)GetProcAddress(
                                        hInst,
                                        "GetChallenge" )) ||
                             !(pVT->MapCredential
                                = (MAP_CREDENTIAL_FN)GetProcAddress(
                                        hInst,
                                        "MapCredential" )) ||
                             !(pVT->GetAccessToken
                                = (GET_ACCESS_TOKEN_FN)GetProcAddress(
                                        hInst,
                                        "GetAccessToken" )) ||
                             !(pVT->CloseLocator
                                = (CLOSE_LOCATOR_FN)GetProcAddress(
                                        hInst,
                                        "CloseLocator" ))
                            )
                        {
                            LocalFree( pIM );
                            FreeLibrary( hInst );
                            goto next;
                        }

						//
                        // optional functions
                        //

                        if ( !(pVT->QueryMappedCredentialAttributes
                                = (QUERY_MAPPED_CREDENTIAL_ATTRIBUTES_FN)GetProcAddress(
                                        hInst,
                                        "QueryMappedCredentialAttributes" )) )
                        {
                            pVT->QueryMappedCredentialAttributes = NullQueryMappedCredentialAttributes;
                        }
                    }

                    //
                    // Valid mapper. Store reference
                    //

                    ++cNbMappers;
                }
next:
                if ( p )
                {
                    pDll = p + 1;
                }
                else
                {
                    break;
                }
            }
        }
        else
        {
            fSt = FALSE;
        }

        RegCloseKey( hKey );
    }


cleanup:
    if ( fSt == FALSE )
    {
        if ( ppMappers != NULL )
        {
            LocalFree( ppMappers );
        }
    }
    else
    {
        *pppMappers = ppMappers;
        *pdwMappers = cNbMappers;
    }

    if ( pszMapList != NULL )
    {
        LocalFree( pszMapList );
    }

    return fSt;
}


VOID
SetMapperToEmpty(
    UINT        cMappers,
    HMAPPER**   pMappers
    )
/*++
    Description:

        Set ptr to Null mapper ( fail Mapping requests )

    Arguments:

        cMappers - mapper count in pCertMapDlls, pMappers
        pMappers - ptr to array of mappers

    Returns:
        Nothing

--*/
{
    PMAPPER_VTABLE  pTbl;

    while ( cMappers-- )
    {
        if ( (*(IisMapper**)pMappers)->fIsIisCompliant )
        {
            pTbl = (*pMappers)->m_vtable;

            //
            // switch to infocomm-embedded mapper, so we can FreeLibrary the
            // mapper DLL. refcount is decremented, because we now longer
            // have a reference to the HMAPPER struct.
            //

            pTbl->ReferenceMapper = NullReferenceMapper;
            pTbl->DeReferenceMapper = NullDeReferenceMapper;
            pTbl->GetIssuerList = NullGetIssuerList;
            pTbl->GetChallenge = NullGetChallenge;
            pTbl->MapCredential = NullMapCredential;
            pTbl->GetAccessToken = NullGetAccessToken;
            pTbl->CloseLocator = NullCloseLocator;
			pTbl->QueryMappedCredentialAttributes = NullQueryMappedCredentialAttributes;

            if ( (*(IisMapper**)pMappers)->hInst != NULL )
            {
                FreeLibrary( (*(IisMapper**)pMappers)->hInst );
            }

            (pTbl->DeReferenceMapper)( *pMappers );
        }

        ++pMappers;
    }
}


BOOL
TerminateCertMapping(
    HMAPPER** ppMappers,
    DWORD cNbMappers
    )
/*++
    Description:

        Terminate access to cert mapping DLL list

    Arguments:

        None

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    //
    // call terminate mapper for all DLLs, FreeLibrary
    //

    if ( ppMappers != NULL )
    {
        SetMapperToEmpty( cNbMappers, ppMappers );
        LocalFree( ppMappers );
    }

    return TRUE;
}


CRED_CACHE_ITEM::~CRED_CACHE_ITEM(
    )
{
    if ( m_fValid )
    {
        DWORD i;

        for ( i = 0; i < m_cCred; i++ )
        {
            g_FreeCredentialsHandle( &m_ahCred[i] );
        }
        for ( i = 0; i < m_cCredMap; i++ )
        {
            g_FreeCredentialsHandle( &m_ahCredMap[i] );
        }

        TerminateCertMapping( m_ppMappers, m_cNbMappers );

        if ( m_pBlob11 )
        {
            m_pBlob11->Release();
        }
        if ( m_pBlobW )
        {
            m_pBlobW->Release();
        }
		if ( m_pSslInfo )
		{
			IIS_SSL_INFO::Release( m_pSslInfo );
		}
    }
}

BOOL
LookupClientCredential(
    IN  WCHAR*  pwszServerPrefix,
    IN  BOOL    fUseCertificate,
    OUT CRED_CACHE_ITEM** ppCCI
    )
/*++

Routine Description:

    Finds an entry in the credential cache or creates one if it's not found

Arguments:

    fUseCertificate - if TRUE, binds client certificate to cred handle
    ppCCI - Receives pointer to a Credential Cache Item

Returns:

    TRUE on success, FALSE on failure.  If this item's key couldn't be found,
    then ERROR_INVALID_NAME is returned.

--*/
{
    TimeStamp       tsExpiry;
    DWORD           i, j;
    CredHandle*     phCreds;
    DWORD*          pcCred;
    BOOL            fCertSet = FALSE;
    WCHAR           achSecretName[MAX_SECRET_NAME+1];
    //CHAR            achSecretNameA[MAX_SECRET_NAME+1];
    UNICODE_STRING* SecretValue[3];
    PVOID           pvPublicKey;
    DWORD           cbPublicKey;
    PVOID           pvPrivateKey;
    DWORD           cbPrivateKey;
    CHAR *          pszPassword;
    SCH_CRED                    creds;
    SCH_CRED_SECRET_PRIVKEY     scsp;
    SCH_CRED_PUBLIC_CERTCHAIN   scpc;
    SECURITY_STATUS             scRet;
    //SECURITY_STATUS             scRetM;
    LPVOID                      ascsp[1];
    LPVOID                      ascpc[1];

    //TraceFunctEnter( "LookupClientCredential" );

    *ppCCI = NULL;

    //
    // first time thru allocate the single cache entry
    //
    if ( g_pcciClient == NULL )
    {
        g_pcciClient = new CRED_CACHE_ITEM;

        if ( g_pcciClient == NULL )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }


        //pcciClient->m_cbAddr = 0;

        g_pcciClient->m_cCred  = 0;
        g_pcciClient->m_cCredMap = 0;
        g_pcciClient->m_fValid = FALSE;
        g_pcciClient->m_cNbMappers = 0;
        g_pcciClient->m_ppMappers = NULL;
        g_pcciClient->m_pBlob11 = NULL;
        g_pcciClient->m_pBlobW = NULL;

        memset( g_pcciClient->m_ahCred, 0, sizeof( g_pcciClient->m_ahCred ));
        memset( g_pcciClient->m_ahCredMap, 0, sizeof( g_pcciClient->m_ahCredMap ));
        memset( g_pcciClient->m_acbTrailer, 0, sizeof( g_pcciClient->m_acbTrailer ));
        memset( g_pcciClient->m_acbHeader, 0, sizeof( g_pcciClient->m_acbHeader ));
        memset( g_pcciClient->m_acbBlockSize, 0, sizeof( g_pcciClient->m_acbBlockSize ));

        //
        // only the provider name is required for OUTBOUND connections
        //

        phCreds = g_pcciClient->m_ahCred;
        pcCred = &g_pcciClient->m_cCred;
        memset( SecretValue, 0, sizeof( SecretValue ));

        if( fUseCertificate )
        {
            //
            // get certificate from metabase and fill in SCH_CRED struct
            //

            //
            // Try the 4 possible secret names
            //

            for ( j = 0 ; j < 4 ; ++j )
            {
                wsprintfW(  achSecretName,
                            SecretTableW[j],
                            L"127.0.0.1", L"563" );

                if ( GetAdminSecret( pwszServerPrefix,
                                     pAdminObject,
                                     achSecretName,
                                     MD_SSL_PUBLIC_KEY,
                                     &SecretValue[0] ) &&
                    GetAdminSecret(  pwszServerPrefix,
                                     pAdminObject,
                                     achSecretName,
                                     MD_SSL_PRIVATE_KEY,
                                     &SecretValue[1] ) &&
                    GetAdminSecret(  pwszServerPrefix,
                                     pAdminObject,
                                     achSecretName,
                                     MD_SSL_KEY_PASSWORD,
                                     &SecretValue[2] ) )
                {
                    fCertSet = TRUE;
                    pvPublicKey  = SecretValue[0]->Buffer;
                    cbPublicKey  = SecretValue[0]->Length;
                    pvPrivateKey = SecretValue[1]->Buffer;
                    cbPrivateKey = SecretValue[1]->Length;
                    pszPassword  = (char*) SecretValue[2]->Buffer;
                    break;
                }
            }

            if( fCertSet )
            {
                //*pcCred             = 0;
                scsp.dwType         = SCHANNEL_SECRET_PRIVKEY;
                scsp.pPrivateKey    = ((PBYTE)pvPrivateKey);
                scsp.cbPrivateKey   = cbPrivateKey;
                scsp.pszPassword    = pszPassword;

                scpc.dwType         = SCH_CRED_X509_CERTCHAIN;
                scpc.cbCertChain    = cbPublicKey - CERT_DER_PREFIX;
                scpc.pCertChain     = ((PBYTE) pvPublicKey) + CERT_DER_PREFIX;

                creds.dwVersion     = SCH_CRED_VERSION;
                ascsp[0]            = (LPVOID)&scsp;
                ascpc[0]            = (LPVOID)&scpc;
                creds.paSecret      = (LPVOID*)&ascsp;
                creds.paPublic      = (LPVOID*)&ascpc;
                creds.cCreds        = 1;
                creds.cMappers      = 0;
            }
        }

        for ( i = 0; pEncProviders[i].pszName && i < MAX_PROVIDERS; i++ )
        {
            if ( !pEncProviders[i].fEnabled )
            {
                //DebugTrace( 0, "%s disabled", EncProviders[i].pszName );
                continue;
            }

            scRet = g_AcquireCredentialsHandle( NULL,                       // My name (ignored)
                                                pEncProviders[i].pszName,   // Package
                                                SECPKG_CRED_OUTBOUND,       // Use
                                                NULL,                       // Logon Id (ign.)
                                                fCertSet ? &creds : NULL,   // auth data
                                                NULL,                       // dce-stuff
                                                NULL,                       // dce-stuff
                                                &phCreds[*pcCred],          // Handle
                                                &tsExpiry );

            if ( !FAILED( scRet ))
            {
                //DebugTrace( 0, "%s credential: 0x%08X",
                //          EncProviders[i].pszName,
                //          phCreds[*pcCred] );

                *pcCred += 1;
            }
        }

        if( fCertSet )
        {
            //
            // Zero out and free the key data memory, on success or fail
            //

            ZeroMemory( scsp.pPrivateKey, scsp.cbPrivateKey );
            ZeroMemory( scpc.pCertChain, scpc.cbCertChain );
            ZeroMemory( pszPassword, strlen( pszPassword ));
        }

        for ( i = 0; i < 3; i++ )
        {
            if( SecretValue[i] != NULL )
            {
                LocalFree( SecretValue[i]->Buffer );
                LocalFree( SecretValue[i] );
            }
        }

        //
        // Tell the caller about it.
        //

        if ( !*pcCred && FAILED( scRet ))
        {
            SetLastError( scRet );
            return FALSE;
        }
        else
        {
            g_pcciClient->m_fValid = TRUE;
            g_pcciClient->AddRef();
            *ppCCI = g_pcciClient;
            return TRUE;
        }
    }
    else if ( g_pcciClient->m_fValid == FALSE )
    {
        //
        // cache was allocated but the initialization failed
        //
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
    }
    else
    {
        //
        // cache was successfully allocated and initialized on a previous call
        //
        g_pcciClient->AddRef();
        *ppCCI = g_pcciClient;
        return TRUE;
    }
}

BOOL GenerateSSLIdBlob( IIS_SSL_INFO *pSSLInfoObj,
                         PBYTE pbBlob )
/*++

   Description

       Function called to get blob of data that uniquely identifies this set of SSL info

   Arguments:

        pSSLInfoObj - object containing SSL info to be used to generate the blob
        pbBlob - buffer that gets updated with blob

   Returns:

        True on success, FALSE on failure

--*/
{
    //
    // If we haven't loaded the info yet, do so now
    //
    IIS_SERVER_CERT *pCert = pSSLInfoObj->GetCertificate();

    IIS_CTL *pCTL = pSSLInfoObj->GetCTL();

    //
    // Definitely need a certificate
    //
    if ( !pCert || !pCert->IsValid())
    {
        return FALSE;
    }

    DWORD dwSize = MAX_SSL_ID_LEN;
    PBYTE pbCurrent = pbBlob;

    //
    // Clear out old crud
    //
    memset( pbBlob, 0, MAX_SSL_ID_LEN );

    //
    //Try to get the cert hash
    //
	if ( !CertGetCertificateContextProperty( pCert->QueryCertContext(),
                                             CERT_SHA1_HASH_PROP_ID,
                                             (PVOID) pbCurrent,
                                             &dwSize ) )
    {
        return FALSE;
    }

    ASSERT( dwSize == SHA1_HASH_LEN );

    pbCurrent += dwSize;
    dwSize = MAX_SSL_ID_LEN - dwSize - 1;


    //
    // Get and append the CTL hash, if there is one
    //
    if (  pCTL && pCTL->IsValid() )
    {
        if ( !CertGetCTLContextProperty( pCTL->QueryCTLContext(),
                                         CERT_SHA1_HASH_PROP_ID,
                                         (PVOID) pbCurrent,
                                         &dwSize ) )
        {
            return FALSE;
        }

        ASSERT( dwSize == SHA1_HASH_LEN );

        pbBlob[SHA1_HASH_LEN] = ':';
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\simauth2\simauth.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    simauth.cpp

Abstract:

    This module contains definition for the CSecurityCtx class.

Revision History:

--*/

#if !defined(dllexp)
#define dllexp  __declspec( dllexport )
#endif  // !defined( dllexp )

#ifdef __cplusplus
extern "C" {
#endif

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>

#ifdef __cplusplus
};
#endif

#include <dbgutil.h>
#include <tcpdll.hxx>
#include <inetinfo.h>

#include <simauth2.h>
#include <dbgtrace.h>

//
// SSL and SSPI related include files
//
extern "C" {
#include <rpc.h>
#define SECURITY_WIN32
#include <sspi.h>
#include <issperr.h>
#include <ntlmsp.h>
#include <ntdsapi.h>
}


//
// try/finally macros
//

#define START_TRY               __try {
#define END_TRY                 }
#define TRY_EXCEPT              } __except(EXCEPTION_EXECUTE_HANDLER) {
#define START_FINALLY           } __finally {

//
// tracing
//

#define ENTER( _x_ )            TraceFunctEnter( _x_ );
#define LEAVE                   TraceFunctLeave( );

//
// Points to protocol blocks
//

extern BOOL uuencode( BYTE *   bufin,
               DWORD    nbytes,
               BUFFER * pbuffEncoded,
               BOOL     fBase64 );

//
// critsec protecting the following three items
//
CRITICAL_SECTION    critProviderPackages;
inline void LockPackages( void ) { EnterCriticalSection( &critProviderPackages ); }
inline void UnlockPackages( void ) { LeaveCriticalSection( &critProviderPackages ); }

//
// "installed" packages the server should support
//
PAUTH_BLOCK ProviderPackages = NULL;

//
// count of "installed" packages the server should support
//
DWORD       cProviderPackages = 0;

//
// memory for names of "installed" packages the server should support
//
LPSTR       ProviderNames = NULL;

//
// Global gibraltar object and allow guest flag
//

BOOL        CSecurityCtx::m_AllowGuest = TRUE;
BOOL        CSecurityCtx::m_StartAnonymous = TRUE;


inline BOOL
IsExperimental(
            LPSTR   Protocol
            )
/*++

Routine Description:

    determines if the security package is marked as experimental ( ie X- )

Arguments:

    LPSTR: name of the protocol or authentication package

Return Value:

    BOOL: TRUE if starts with X-

--*/
{
    return  (Protocol[0] == 'X' || Protocol[0] == 'x') && Protocol[1] == '-';
}

inline LPSTR
PackageName(
            LPSTR   Protocol
            )
/*++

Routine Description:

    returns the core security package name stripping X- if necessary

Arguments:

    LPSTR: name of the protocol or authentication package

Return Value:

    LPSTR: package name

--*/
{
    return  IsExperimental( Protocol ) ? Protocol + 2 : Protocol ;
}


BOOL
CSecurityCtx::Initialize(
            BOOL                    fAllowGuest,
            BOOL                    fStartAnonymous
            )
/*++

Routine Description:

    Activates the security package

Arguments:

    PIIS_SERVER_INSTANCE is a ptr to a virtual server instance

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{
    ENTER("CSecurityCtx::Initialize")

    m_AllowGuest = fAllowGuest;
    m_StartAnonymous = fStartAnonymous;


    InitializeCriticalSection( &critProviderPackages );

    LEAVE
    return(TRUE);

} // Initialize

VOID
CSecurityCtx::Terminate(
            VOID
            )
/*++

Routine Description:

    Terminates the security package

Arguments:

    None.

Return Value:

    None.

--*/
{
    ENTER("CSecurityCtx::Terminate")

    //
    // Close cached credential handles
    //

    if ( ProviderPackages != NULL )
    {
        LocalFree( (PVOID)ProviderPackages );
        ProviderPackages = NULL;
    }

    if ( ProviderNames != NULL )
    {
        LocalFree( (PVOID)ProviderNames );
        ProviderNames = NULL;
    }

    DeleteCriticalSection( &critProviderPackages );

    LEAVE
    return;

} // Terminate

CSecurityCtx::CSecurityCtx(
    PIIS_SERVER_INSTANCE pIisInstance,
    DWORD AuthFlags,
    DWORD InstanceAuthFlags,
    TCP_AUTHENT_INFO *pTcpAuthInfo
    ) :
        TCP_AUTHENT( AuthFlags ),
        m_IsAuthenticated( FALSE ),
        m_IsAnonymous( FALSE ),
        m_IsClearText( FALSE ),
        m_IsGuest( FALSE ),
        m_LoginName( NULL ),
        m_PackageName( NULL ),
        m_dwInstanceAuthFlags(InstanceAuthFlags),
        m_ProviderNames(NULL),
        m_ProviderPackages(NULL),
        m_cProviderPackages(0),
        m_fBase64((AuthFlags & TCPAUTH_BASE64) ? TRUE : FALSE)
/*++

Routine Description:

    Class constructor

Arguments:

    None.

Return Value:

    None

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CSecurityCtx::CSecurityCtx");

    m_szCleartextPackageName[0] = '\0';
    m_szMembershipBrokerName[0] = '\0';

    //
    //  The instance will cache this info from the metabase
    //  and pass it in on the constructor.
    //

    if ( pTcpAuthInfo )
    {
        m_TCPAuthentInfo.strAnonUserName.Copy(pTcpAuthInfo->strAnonUserName);
        m_TCPAuthentInfo.strAnonUserPassword.Copy(pTcpAuthInfo->strAnonUserPassword);
        m_TCPAuthentInfo.strDefaultLogonDomain.Copy(pTcpAuthInfo->strDefaultLogonDomain);
        m_TCPAuthentInfo.dwLogonMethod = pTcpAuthInfo->dwLogonMethod;
        m_TCPAuthentInfo.fDontUseAnonSubAuth = pTcpAuthInfo->fDontUseAnonSubAuth;
    }

    if ( m_StartAnonymous )
    {
        //
        //  m_dwInstanceAuthFlags is set at class's ctor
        //

        //
        // if Anonymous logon is not allowed return immediately
        //
        if ( m_dwInstanceAuthFlags & INET_INFO_AUTH_ANONYMOUS )
        {
            BOOL    fRet;

            fRet = ClearTextLogon(  "",
                                    "",
                                    &m_IsGuest,
                                    &m_IsAnonymous,
                                    pIisInstance,
                                    &m_TCPAuthentInfo); 

            if ( fRet )
            {
                m_IsAuthenticated = m_IsGuest == FALSE ||
                                    m_AllowGuest == TRUE;

                //
                // if we successfully authenticated then mark cleartext TRUE
                //
                if ( m_IsAuthenticated == TRUE )
                {
                    m_IsClearText = TRUE;
                }
            }
            else
            {
                ErrorTrace( (LPARAM)this,
                            "Anonymous ClearTextLogon failed",
                            GetLastError() );
            }
        }
    }
} // CSecurityCtx

CSecurityCtx::~CSecurityCtx(
                VOID
                )
/*++

Routine Description:

    Class destructor

Arguments:

    None.

Return Value:

    None

--*/
{
    //
    // no reason to do the remainder of Reset()
    //
    if ( m_LoginName != NULL )
    {
        LocalFree( (PVOID)m_LoginName);
        m_LoginName = NULL;
    }

    if ( m_PackageName != NULL )
    {
        LocalFree( (PVOID)m_PackageName);
        m_PackageName = NULL;
    }
} // ~CSecurityCtx

VOID
CSecurityCtx::Reset(
                VOID
                )
/*++

Routine Description:

    resets the instance to reauth user

Arguments:

    None.

Return Value:

    None

--*/
{
    if ( m_LoginName != NULL )
    {
        LocalFree( (PVOID)m_LoginName);
        m_LoginName = NULL;
    }

    if ( m_PackageName != NULL )
    {
        LocalFree( (PVOID)m_PackageName);
        m_PackageName = NULL;
    }

    m_IsAuthenticated = FALSE;
    m_IsAnonymous = FALSE;
    m_IsGuest = FALSE;

    TCP_AUTHENT::Reset();

} // Reset

VOID
CSecurityCtx::SetCleartextPackageName(
                LPSTR           szCleartextPackageName,
                LPSTR           szMembershipBrokerName
                )
/*++

Routine Description:

    Sets the cleartext auth package name

Arguments:

    szCleartextPackageName - Name of package

Return Value:

    None

--*/
{
    TraceFunctEnter("SetCleartextPackageName");

    if (szCleartextPackageName)
        lstrcpy(m_szCleartextPackageName, szCleartextPackageName);
    else
        m_szCleartextPackageName[0] = '\0';

    if (szMembershipBrokerName)
        lstrcpy(m_szMembershipBrokerName, szMembershipBrokerName);
    else
        m_szMembershipBrokerName[0] = '\0';

    DebugTrace(0,"CleartextPackageName is %s MembershipBrokerName is %s", m_szCleartextPackageName, m_szMembershipBrokerName);
}

BOOL
CSecurityCtx::SetInstanceAuthPackageNames(
    DWORD cProviderPackages,
    LPSTR ProviderNames,
    PAUTH_BLOCK ProviderPackages)
/*++
Routine Description:

    set the supported SSPI packages per instance basis

--*/
{
    TraceFunctEnter( "CSecurityCtx::SetInstanceAuthPackageNames" );

    if (cProviderPackages == 0 || ProviderNames == NULL || ProviderPackages == NULL)
    {
        ErrorTrace( 0, "Invalid Parameters");

        return FALSE;
    }

    m_cProviderPackages = cProviderPackages;
    m_ProviderNames = ProviderNames;
    m_ProviderPackages = ProviderPackages;

    return TRUE;
}

BOOL
CSecurityCtx::GetInstanceAuthPackageNames(
                OUT LPBYTE      ReplyString,
                IN OUT PDWORD   ReplySize,
                IN PKG_REPLY_FMT    PkgFmt
                )
/*++

Routine Description:

    get the supported SSPI packages per instance basis.

    different than set in that the packages are returned using various
    delimeters to make it easier for the client to format the buffer.

Arguments:

    ReplyString - Reply to be sent to client.
    ReplySize - Size of the reply.
    PkgFmt - Format of the reply string.

Return Value:

    BOOL: successful ??

--*/
{
    TraceFunctEnter( "CSecurityCtx::GetInstanceAuthPackageNames" );

    LPSTR   pszNext = (LPSTR)ReplyString;
    DWORD   cbReply = 0;
    DWORD   cbDelim;
    LPSTR   pbDelim;

    _ASSERT(PkgFmt == PkgFmtSpace || PkgFmt == PkgFmtCrLf);

    switch (PkgFmt)
    {
    case PkgFmtCrLf:
        {
            pbDelim = "\r\n";
            cbDelim = 2;
            break;
        }

    case PkgFmtSpace:
    default:
        {
            pbDelim = " ";
            cbDelim = 1;
            break;
        }
    }

    //
    // while in this loop ensure the contents dont change
    //

    for ( DWORD i=0; i < m_cProviderPackages; i++ )
    {
        LPSTR   pszName = m_ProviderPackages[i].Name;
        DWORD   cbName = lstrlen( pszName );

        //
        // +1 is for trailing space
        //
        if ( cbReply + cbName + cbDelim > *ReplySize )
        {
            break;
        }
        else
        {
            CopyMemory( pszNext, pszName, cbName );

            //
            // add the space separator
            //
            CopyMemory(pszNext + cbName, pbDelim, cbDelim);

            //
            // inc for loop pass
            //
            cbReply += cbName + cbDelim;
            pszNext += cbName + cbDelim;
        }
    }

    //
    // stamp the final trailing space with a NULL char
    //
    if ( cbReply > 0 && PkgFmt == PkgFmtSpace)
    {
        cbReply--;

        ReplyString[ cbReply ] = '\0';

        DebugTrace( 0, "Protocols: %s", ReplyString );
    }

    *ReplySize = cbReply;

    return  TRUE;
}

BOOL
CSecurityCtx::SetAuthPackageNames(
                LPSTR lpMultiSzProviders,
                DWORD cchMultiSzProviders
                )
/*++

Routine Description:

    set the supported SSPI packages

Arguments:

    lpMultiSzProviders is the same format as returned by
    RegQueryValueEx for REG_MULTI_SZ values

Return Value:

    BOOL: successful ??

--*/
{
    TraceFunctEnter( "CSecurityCtx::SetAuthPackageNames" );

    LPSTR   psz, pszCopy = NULL;
    DWORD   i, cProviders;

    PAUTH_BLOCK pBlock = NULL;

    if ( lpMultiSzProviders == NULL || cchMultiSzProviders == 0 )
    {
        ErrorTrace( 0, "Invalid Parameters: 0x%08X, %d",
                    lpMultiSzProviders, cchMultiSzProviders );

        goto    error;
    }

    pszCopy = (LPSTR)LocalAlloc( 0, cchMultiSzProviders );
    if ( pszCopy == NULL )
    {
        ErrorTrace( 0, "LocalAlloc failed: %d", GetLastError() );
        goto    error;
    }

    CopyMemory( pszCopy, lpMultiSzProviders, cchMultiSzProviders );

    //
    // cchMultiSzProviders-1 is to avoid adding an additional provider
    // for the terminating NULL char
    //
    for ( i=0, cProviders=0, psz=pszCopy; i<cchMultiSzProviders-1; i++, psz++ )
    {
        if ( *psz == '\0' )
        {
            cProviders++;
        }
    }

    //
    // ensure we're at the end and hence at the second terminating NULL char
    //
    _ASSERT( *psz == '\0' );

    if ( cProviders < 1 )
    {
        ErrorTrace( 0, "No valid providers were found" );
        goto    error;
    }


    pBlock = (PAUTH_BLOCK)LocalAlloc( 0, cProviders * sizeof(AUTH_BLOCK) );
    if ( pBlock == NULL )
    {
        ErrorTrace( 0, "AUTH_BLOCK LocalAlloc failed: %d", GetLastError() );
        goto    error;
    }

    //
    // start at 1 since 0 indicates the Invalid protocol
    //
    for ( i=0, psz=pszCopy; i<cProviders; i++ )
    {
        //
        // this would be the place to check whether the package was valid
        //
        DebugTrace( 0, "Protocol: %s, Package: %s", psz, PackageName(psz) );

        pBlock[i].Name = psz;

        psz += lstrlen(psz) + 1;
    }

    //
    // set global to new value; autoupdate will require critsec and mem free
    //

    LockPackages();

    //
    // if we're replacing already set packages; free their memory
    //
    if ( ProviderPackages != NULL )
    {
        LocalFree( (PVOID)ProviderPackages );
        ProviderPackages = NULL;
    }

    if ( ProviderNames != NULL )
    {
        LocalFree( (PVOID)ProviderNames );
        ProviderNames = NULL;
    }

    ProviderPackages = pBlock;
    cProviderPackages = cProviders;
    ProviderNames = pszCopy;

    UnlockPackages();


    return  TRUE;

error:

    if ( pszCopy != NULL )
    {
        DebugTrace( 0, "Cleaning up pszCopy" );
        _VERIFY( LocalFree( (LPVOID)pszCopy ) == NULL );
    }

    if ( pBlock != NULL )
    {
        DebugTrace( 0, "Cleaning up pBlock" );
        _VERIFY( LocalFree( (LPVOID)pBlock ) == NULL );
    }
    return  FALSE;

} // SetAuthPackageNames

BOOL
CSecurityCtx::GetAuthPackageNames(
                OUT LPBYTE      ReplyString,
                IN OUT PDWORD   ReplySize,
                IN PKG_REPLY_FMT    PkgFmt
                )
/*++

Routine Description:

    get the supported SSPI packages

    different than set in that the packages are returned using various
    delimeters to make it easier for the client to format the buffer.

Arguments:

    ReplyString - Reply to be sent to client.
    ReplySize - Size of the reply.
    PkgFmt - Format of the reply string.

Return Value:

    BOOL: successful ??

--*/
{
    TraceFunctEnter( "CSecurityCtx::GetAuthPackageNames" );

    LPSTR   pszNext = (LPSTR)ReplyString;
    DWORD   cbReply = 0;
    DWORD   cbDelim;
    LPSTR   pbDelim;

    _ASSERT(PkgFmt == PkgFmtSpace || PkgFmt == PkgFmtCrLf);

    switch (PkgFmt)
    {
    case PkgFmtCrLf:
        {
            pbDelim = "\r\n";
            cbDelim = 2;
            break;
        }

    case PkgFmtSpace:
    default:
        {
            pbDelim = " ";
            cbDelim = 1;
            break;
        }
    }

    //
    // while in this loop ensure the contents dont change
    //
    LockPackages();

    for ( DWORD i=0; i<cProviderPackages; i++ )
    {
        LPSTR   pszName = ProviderPackages[i].Name;
        DWORD   cbName = lstrlen( pszName );

        //
        // +1 is for trailing space
        //
        if ( cbReply + cbName + cbDelim > *ReplySize )
        {
            break;
        }
        else
        {
            CopyMemory( pszNext, pszName, cbName );

            //
            // add the space separator
            //
            CopyMemory(pszNext + cbName, pbDelim, cbDelim);

            //
            // inc for loop pass
            //
            cbReply += cbName + cbDelim;
            pszNext += cbName + cbDelim;
        }
    }

    //
    // free access to the list
    //
    UnlockPackages();

    //
    // stamp the final trailing space with a NULL char
    //
    if ( cbReply > 0 && PkgFmt == PkgFmtSpace)
    {
        cbReply--;

        ReplyString[ cbReply ] = '\0';

        DebugTrace( 0, "Protocols: %s", ReplyString );
    }

    *ReplySize = cbReply;

    return  TRUE;
} // GetAuthPackageNames

BOOL
CSecurityCtx::ProcessUser(
    IN PIIS_SERVER_INSTANCE pIisInstance,
    IN LPSTR        pszUser,
    OUT REPLY_LIST* pReply
    )
/*++

Routine Description:

    Process AUTHINFO user command

Arguments:

    pszUser -   user name
    pReply -    ptr to reply string id

Return Value:

    successful

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CSecurityCtx::ProcessUser");

    DWORD   nameLen;


    //
    // if we're already logged on reset the user credentials
    //
    if ( m_IsAuthenticated )
    {
        Reset();
    }

    //
    // Don't allow user to overwrite the existing name.
    //

    if ( m_LoginName != NULL  )
    {
        *pReply = SecSyntaxErr;
        return  FALSE;
    }

    if ( (m_dwInstanceAuthFlags & INET_INFO_AUTH_CLEARTEXT) == 0 )
    {
        *pReply = SecPermissionDenied;
        return  FALSE;
    }

    if ( pszUser == NULL )
    {
        *pReply = SecSyntaxErr;
        return  FALSE;
    }

    nameLen = lstrlen( pszUser ) + 1;


    //
    // if anonymous is not allowed; fail a zero length user name
    //
    if ( nameLen <= 1 &&
        (m_dwInstanceAuthFlags & INET_INFO_AUTH_ANONYMOUS) == 0 )
    {
        *pReply = SecPermissionDenied;
        return  FALSE;
    }


    m_LoginName = (PCHAR)LocalAlloc( 0, nameLen );
    if ( m_LoginName == NULL )
    {
        *pReply = SecInternalErr;
        return  FALSE;
    }

    CopyMemory( m_LoginName, pszUser, nameLen );

    //
    // Tell client to send the password
    //
    *pReply = SecNeedPwd;
    return  TRUE;
}

BOOL
CSecurityCtx::ShouldUseMbs( void )
/*++

Routine Description:

    Determines if MBS_BASIC is being used.

Arguments:

Return Value:

    TRUE if successful

--*/
{
    CHAR *pszCtPackage;

    //
    // Simple heuristics: if we have a cleartext package
    // name, we will use MBS if the current package name
    // is NULL,
    //

    pszCtPackage = PackageName(m_szCleartextPackageName);
    if (pszCtPackage[0] != '\0' && !m_PackageName)
    {
        return(TRUE);
    }

    return(FALSE);
}

#define __STRCPYX(s, cs, len) \
    lstrcpy((s), (cs)); (s) += (len)

BOOL
CSecurityCtx::MbsBasicLogon(
    IN LPSTR        pszUser,
    IN LPSTR        pszPass,
    OUT BOOL        *pfAsGuest,
    OUT BOOL        *pfAsAnonymous
    )
/*++

Routine Description:

    Perform a MBS Basic logon sequence

Arguments:

    pszUser         - Username, can be NULL
    pszPass         - Password, may be NULL
    pfAsGuest       - Returns TRUE is logged on as guest
    pfAsAnonymous   - Returns TRUE is anonymous account used
    pReply          - Pointer to reply string id
    psi             - Server information block

Return Value:

    successful

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CSecurityCtx::MbsBasicLogon");

    BYTE        pbBlob[MAX_ACCT_DESC_LEN];
    DWORD       dwBlobLength;
    BUFFER      OutBuf;
    DWORD       dwOutBufSize;
    BOOL        fMoreData;
    BOOL        fRet;
    CHAR        *pTemp;
    SecBuffer   InSecBuff[2];
    SecBufferDesc InSecBuffDesc;

    // PU2_BASIC_AUTHENTICATE_MSG   pAuthMsg = (PU2_BASIC_AUTHENTICATE_MSG)pbBlob;

    _ASSERT(pfAsGuest);
    _ASSERT(pfAsAnonymous);

    if (!pszUser || !pszPass || !pfAsGuest || !pfAsAnonymous)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        ErrorTrace((LPARAM)this, "Input parameters NULL");
        return(FALSE);
    }

    *pfAsGuest = FALSE;
    *pfAsAnonymous = FALSE;

    if (lstrlen(pszUser) > UNLEN)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        ErrorTrace((LPARAM)this, "Username too long");
        return(FALSE);
    }

    if (lstrlen(pszPass) > PWLEN)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        ErrorTrace((LPARAM)this, "Password too long");
        return(FALSE);
    }

    //
    // With all the user name and password information, we will
    // build up a BLOB and then simply call Converse()
    //
    // The BLOB contains credential string of the format:
    // user:password\0
    //
    pTemp = (CHAR *)pbBlob;
    // __STRCPYX(pTemp, psi->QueryServiceName(), lstrlen(psi->QueryServiceName()));
    // __STRCPYX(pTemp, ":", 1);
    __STRCPYX(pTemp, pszUser, lstrlen(pszUser));
    __STRCPYX(pTemp, ":", 1);
    __STRCPYX(pTemp, pszPass, lstrlen(pszPass));

    //
    // Get the size of everything, not just the credentials
    //
    dwBlobLength = (DWORD)(pTemp - (CHAR *)pbBlob) + 1;

    //
    // U2 now requires 2 SecBuffer for MBS_BASIC
    //
    InSecBuffDesc.ulVersion = 0;
    InSecBuffDesc.cBuffers  = 2;
    InSecBuffDesc.pBuffers  = &InSecBuff[0];

    InSecBuff[0].cbBuffer   = dwBlobLength;
    InSecBuff[0].BufferType = SECBUFFER_TOKEN;
    InSecBuff[0].pvBuffer   = pbBlob;

    DebugTrace(0,"MbsBasicLogon: cleartext is %s membership is %s", m_szCleartextPackageName, m_szMembershipBrokerName);

    BYTE            pbServer[sizeof(WCHAR)*MAX_PATH+sizeof(UNICODE_STRING)];
    UNICODE_STRING* pusU2Server = (UNICODE_STRING*)pbServer;
    WCHAR* pwszU2Server = (WCHAR*)((UNICODE_STRING*)pbServer+1);
    if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, m_szMembershipBrokerName, -1, pwszU2Server,
        MAX_PATH))
    {
        return FALSE;
    }

    pusU2Server->Length = (USHORT) (wcslen(pwszU2Server) * sizeof(WCHAR));
    pusU2Server->MaximumLength = (USHORT)(MAX_PATH * sizeof(WCHAR));
    pusU2Server->Buffer = (PWSTR)sizeof(UNICODE_STRING);

    InSecBuff[1].cbBuffer   = sizeof(pbServer);
    InSecBuff[1].BufferType = SECBUFFER_PKG_PARAMS;
    InSecBuff[1].pvBuffer   =  (PVOID)pbServer;


    //
    // Just call Converse() to do all the work!
    // We blow away tha anon password immediately after we're done.
    //

    fRet = ConverseEx(&InSecBuffDesc,
                    NULL,                       // SecBuffer is not encoded
                    &OutBuf,
                    &dwOutBufSize,
                    &fMoreData,
                    &m_TCPAuthentInfo,  
                    m_szCleartextPackageName,
                    NULL, NULL, NULL);

    //
    // Check the return values
    //
    if (fRet)
    {
        StateTrace((LPARAM)this, "Authentication succeeded");

        //
        // This is a one-shot deal, so we do not expect any more data
        //
        if (fMoreData)
        {
            SetLastError(ERROR_MORE_DATA);
            ErrorTrace((LPARAM)this, "Internal error: More data not expected");
            return(FALSE);
        }

        //
        // We should also expect zero returned buffer length
        //
        // _ASSERT(dwOutBufSize == 0);
    }

    return(fRet);
}

BOOL
CSecurityCtx::ProcessPass(
    IN PIIS_SERVER_INSTANCE pIisInstance,
    IN LPSTR        pszPass,
    OUT REPLY_LIST* pReply
    )
/*++

Routine Description:

    Process AUTHINFO user command

Arguments:

    pszPass -   password
    pReply -    ptr to reply string id

Return Value:

    successful

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CSecurityCtx::ProcessPass");
    DWORD   dwTick;
    BOOL    fRet;
    TCP_AUTHENT_INFO tai; // use default ctor

    //
    // give username first
    //
    if ( m_LoginName == NULL )
    {
        *pReply = SecNoUsername;
        return  FALSE;
    }

    if ( pszPass == NULL )
    {
        *pReply = SecSyntaxErr;
        return  FALSE;
    }

    //
    // Get tick count for tracing
    //
    dwTick = GetTickCount();

    //
    // Added for U2 BASIC authentication: We check if the current
    // package is the U2 BASIC package. If not, we do the usual 
    // ClearTextLogon() call. If so, we will call MBS
    //

    if (ShouldUseMbs())
    {
        //
        // This uses U2 BASIC
        //
        StateTrace((LPARAM)pIisInstance, "Doing Cleartext auth with package: <%s>",
                    m_szCleartextPackageName);

        fRet = MbsBasicLogon(m_LoginName,
                            pszPass,
                            &m_IsGuest,
                            &m_IsAnonymous);
    }
    else
    {
        //
        // K2_TODO: need to fill in TCP_AUTHENT_INFO !
        //
        tai.dwLogonMethod = LOGON32_LOGON_NETWORK;

        fRet = ClearTextLogon(
                            m_LoginName,
                            pszPass,
                            &m_IsGuest,
                            &m_IsAnonymous,
                            pIisInstance,
                            &tai
                            );
    }

    //
    // Trace ticks for logon
    //
    dwTick = GetTickCount() - dwTick;
    DebugTrace( (LPARAM)this,
                "ClearTextLogon took %u ticks", dwTick );

    if ( fRet )
    {

        if ( m_IsGuest && m_AllowGuest == FALSE )
        {
            ErrorTrace( (LPARAM)this, "Guest acct disallowed %s",
                        m_LoginName );
        }
        else if ( m_IsAnonymous &&
                ( m_dwInstanceAuthFlags & INET_INFO_AUTH_ANONYMOUS ) == 0 )
        {
            ErrorTrace( (LPARAM)this, "Anonymous logon disallowed %s",
                        m_LoginName );
        }
        else
        {
            *pReply = m_IsAnonymous ? SecAuthOkAnon : SecAuthOk ;
            return  m_IsAuthenticated = TRUE;
        }
    }
    else
    {
        ErrorTrace( (LPARAM)this,
                    "ClearTextLogon failed for %s: %d",
                    m_LoginName, GetLastError());

        //
        // reset the logon session to force the app to start over again
        //
        Reset();
    }

    *pReply = SecPermissionDenied;
    return  FALSE;
}

BOOL
CSecurityCtx::ProcessTransact(
    IN PIIS_SERVER_INSTANCE pIisInstance,
    IN LPSTR        Blob,
    IN OUT LPBYTE   ReplyString,
    IN OUT PDWORD   ReplySize,
    OUT REPLY_LIST* pReply,
    IN DWORD        BlobLength
    )
/*++

Routine Description:

    Process AUTHINFO user command

Arguments:

    pszPass -   password
    pReply -    ptr to reply string id

Return Value:

    successful

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CSecurityCtx::ProcessTransact");

    //
    // if we're already logged on reset the user credentials
    //
    if ( m_IsAuthenticated )
    {
        Reset();
    }


    //
    // If this is a new session, the first transact is the
    // protocol name
    //

    if ( m_PackageName == NULL )
    {
        PAUTH_BLOCK pBlock;

        LPSTR   protocol;
        DWORD   i;
        BOOL    bFound = FALSE;

        if ( (m_dwInstanceAuthFlags & INET_INFO_AUTH_NT_AUTH) == 0 )
        {
            *pReply = SecPermissionDenied;
            return  FALSE;
        }

        if ( (protocol = Blob) == NULL )
        {
            *pReply = SecSyntaxErr;
            return  FALSE;
        }

        //
        // if its an X- protocol strip the X- header
        //
        protocol = PackageName( protocol );

        //
        // See if this is a supported protocol
        // while in this loop ensure the contents dont change
        //
        LockPackages();

        for ( i=0; i < m_cProviderPackages; i++ )
        {
            pBlock = &m_ProviderPackages[i];

            //
            // get the name of the Block's package and strip any X-
            //
            LPSTR   pszPackageName = PackageName( pBlock->Name );

            if ( lstrcmpi( pszPackageName, protocol ) == 0 )
            {
                //
                // See if the package chosen was GSSAPI. If it was, then set 
                // m_PackageName to "Negotiate". This is required because the 
                // SASL GSSAPI mechanism maps to the NT Negotiate package
                //

                LPSTR pszPackageNameToUse = pszPackageName;

                if (lstrcmpi( pszPackageName, "GSSAPI") == 0)
                    pszPackageNameToUse = "Negotiate";
            
                DWORD   cb = lstrlen( pszPackageNameToUse ) + 1;

                DebugTrace( (LPARAM)this,
                            "Found: %s, Protocol %s, NT Package %s",
                            pszPackageName, pBlock->Name, pszPackageNameToUse );
                //
                // maintain a local copy of the package name in case
                // the list changes during the negotiation
                //
                m_PackageName = (PCHAR)LocalAlloc( 0, cb );
                if ( m_PackageName == NULL )
                {
                    *pReply = SecInternalErr;

                    //
                    // free access to the list
                    //
                    UnlockPackages();
                    return  FALSE;
                }

                CopyMemory( m_PackageName, pszPackageNameToUse, cb );
                bFound = TRUE;

                break;
            }
        }

        //
        // free access to the list
        //
        UnlockPackages();

        if ( bFound == FALSE )
        {
            //
            // not found
            //
            ErrorTrace( (LPARAM)this,
                        "could not find: %s", protocol );
            //
            // here's where we need to build the response string
            // app needs to call us to enum the installed packages
            // to the app can properly format the enumerated
            // "installed" packages within a protocol specific err msg
            //
            *pReply = SecProtNS;
            return  FALSE;
        }
        else
        {
            //
            // +OK response
            //
            *pReply = SecProtOk;
            return  TRUE;
        }
    }
    else
    {
        DWORD   nBuff;
        BOOL    moreData;
        BOOL    fRet;
        DWORD   dwTick;
        BUFFER  outBuff;

        if ( Blob == NULL )
        {
            *pReply = SecSyntaxErr;
            return  FALSE;
        }

        //
        // Get tick count for tracing
        //
        dwTick = GetTickCount();

        // m_PackageName must already be set by now
        _ASSERT(m_PackageName);

        if (!lstrcmpi(m_PackageName, "DPA") && m_szMembershipBrokerName && m_szMembershipBrokerName[0]) {
            SecBuffer   InSecBuff[2];
            SecBufferDesc InSecBuffDesc;
            BUFFER  DecodedBuf[2]; // scratch pad for decoding the sec buff

            DebugTrace(NULL,"DPA broker server is %s", m_szMembershipBrokerName);

            //
            //  for DPA authentication, we need to pass in 2 sec buffers
            //
            InSecBuffDesc.ulVersion = 0;
            InSecBuffDesc.cBuffers  = 2;
            InSecBuffDesc.pBuffers  = &InSecBuff[0];

            //
            // Fill in the first sec buffer
            // This contains the security blob sent by client, and is already encoded
            //
            InSecBuff[0].cbBuffer   = BlobLength ? BlobLength : lstrlen(Blob);
            InSecBuff[0].BufferType = SECBUFFER_TOKEN;
            InSecBuff[0].pvBuffer   = Blob;

            //
            // Fill in the second sec buffer, which contains the U2 broker id
            // Since ConverseEx will decode both sec buf, we need to encode
            // the second buf before calling ConverseEx
            //
            BYTE            pbServer[sizeof(WCHAR)*MAX_PATH+sizeof(UNICODE_STRING)];
            UNICODE_STRING* pusU2Server = (UNICODE_STRING*)pbServer;
            WCHAR* pwszU2Server = (WCHAR*)((UNICODE_STRING*)pbServer+1);
            BUFFER EncBuf;
            if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, m_szMembershipBrokerName, -1, pwszU2Server,
                MAX_PATH))
            {
                ErrorTrace((LPARAM)this, "MultiByteToWideChar FAILED");
                return FALSE;
            }
            pusU2Server->Length = (USHORT) (wcslen(pwszU2Server) * sizeof(WCHAR));
            pusU2Server->MaximumLength = (USHORT)(MAX_PATH * sizeof(WCHAR));
            pusU2Server->Buffer = (PWSTR)sizeof(UNICODE_STRING);
            
            DWORD dwSize = MAX_PATH + sizeof(UNICODE_STRING);

            if (!uuencode((PBYTE)pbServer, dwSize, &EncBuf, m_fBase64)) {
                ErrorTrace((LPARAM)this, "uuencode FAILED");
                return FALSE;
            }

            InSecBuff[1].cbBuffer   = EncBuf.QuerySize();
            InSecBuff[1].BufferType = SECBUFFER_PKG_PARAMS;
            InSecBuff[1].pvBuffer   =  EncBuf.QueryPtr();

            fRet = ConverseEx(&InSecBuffDesc,
                            DecodedBuf,                     
                            &outBuff,
                            &nBuff,
                            &moreData,
                            &m_TCPAuthentInfo,  
                            m_PackageName,
                            NULL, NULL, NULL);
        }
        else {
            //
            //  for non-DPA authentication (i.e. NTLM, etc)
            //

            fRet = Converse(Blob,
                            BlobLength ? BlobLength : lstrlen(Blob),
                            &outBuff,
                            &nBuff,
                            &moreData,
                            &m_TCPAuthentInfo,  
                            m_PackageName);
        }
        //
        // Trace ticks for conversing
        //
        dwTick = GetTickCount() - dwTick;
        DebugTrace((LPARAM)this, "Converse(%s) took %u ticks", m_PackageName, dwTick );

        if ( fRet )
        {
            DebugTrace( (LPARAM)this,
                        "Converse ret TRUE, nBuff: %d, moredata %d",
                        nBuff, moreData );

            if ( moreData )
            {
                _ASSERT( nBuff != 0 );

                CopyMemory( ReplyString, outBuff.QueryPtr(), nBuff );
                *ReplySize = nBuff;

                //
                // reply equals SecNull to tell the app to send
                // this buffer to remote client/server
                //
                *pReply = SecNull;
                return  TRUE;

            } else {

                STR strUser;    // was BUFFER buff pre-K2

                if ( m_IsGuest && m_AllowGuest == FALSE )
                {
                    SetLastError( ERROR_LOGON_FAILURE );
                    *pReply = SecPermissionDenied;
                    return  FALSE;
                }

                if ( TCP_AUTHENT::QueryUserName( &strUser ) )
                {
                    m_LoginName = (PCHAR)LocalAlloc( 0, strUser.QuerySize() );
                    if ( m_LoginName != NULL )
                    {
                        CopyMemory( m_LoginName,
                                    strUser.QueryPtr(),
                                    strUser.QuerySize() );

                        DebugTrace( (LPARAM)this,
                                    "Username: %s, size %d",
                                    m_LoginName, strUser.QuerySize() );

                        *pReply = SecAuthOk;
                    }
                    else
                    {
                        ErrorTrace( (LPARAM)this,
                                    "LocalAlloc failed. err: %d",
                                    GetLastError() );
                        *pReply = SecInternalErr;
                    }
                    strUser.Resize(0);
                }
                else
                {
                    ErrorTrace( (LPARAM)this,
                                "QueryUserName failed. err: %d",
                                GetLastError() );
                    *pReply = SecInternalErr;

                    //
                    // Firewall around NT bug where negotiation succeeds even though
                    // it should really have failed (when an empty buffer is passed
                    // to AcceptSecurityContext). In this case, the QueryUserName is
                    // the only valid check - gpulla.
                    //

                    return m_IsAuthenticated = FALSE;
                }
                return  m_IsAuthenticated = TRUE;
            }
        }
        else
        {
            SECURITY_STATUS ss = GetLastError();
            ErrorTrace( (LPARAM)this,
                        "Converse failed. err: 0x%08X", ss );

            *pReply = SecPermissionDenied;
        }
    }
    return  FALSE;
}

BOOL
CSecurityCtx::ProcessAuthInfo(
    IN PIIS_SERVER_INSTANCE pIisInstance,
    IN AUTH_COMMAND     Command,
    IN LPSTR            Blob,
    IN OUT LPBYTE       ReplyString,
    IN OUT PDWORD       ReplySize,
    OUT REPLY_LIST*     pReply,
    IN OPTIONAL DWORD   BlobLength
    )
/*++

Routine Description:

    Process AUTHINFO commands

Arguments:

    Command  - Authinfo command received
    Blob - Blob accompanying the command
    ReplyString - Reply to be sent to client.
    ReplySize - Size of the reply.

Return Value:

    None.

--*/
{
    //
    // transition codes to support backward compatibility
    // will be removed later when everybody has moved to new version of simauth2
    //
    if (!m_ProviderPackages) {
        m_ProviderPackages = ProviderPackages;
        m_ProviderNames = ProviderNames;
        m_cProviderPackages = cProviderPackages;
    }


    TraceFunctEnterEx( (LPARAM)this, "CSecurityCtx::ProcessAuthInfo");

    BOOL    bSuccess = FALSE;

    START_TRY

    //
    // We currently support USER, PASSWORD, and TRANSACT
    //

    switch( Command )
    {
     case AuthCommandUser:
        bSuccess = ProcessUser( pIisInstance, Blob, pReply );
        break;

     case AuthCommandPassword:
        bSuccess = ProcessPass( pIisInstance, Blob, pReply );
        break;

     case AuthCommandTransact:
        bSuccess = ProcessTransact( pIisInstance,
                                    Blob,
                                    ReplyString,
                                    ReplySize,
                                    pReply,
                                    BlobLength );
        break;
    
     default:
        if ( m_IsAuthenticated )
        {
            Reset();
        }
        *pReply = SecSyntaxErr;
    }

    TRY_EXCEPT
    END_TRY

    _ASSERT( *pReply < NUM_SEC_REPLIES );
    if ((DWORD)*pReply >= NUM_SEC_REPLIES)
        *pReply = SecInternalErr;

    return  bSuccess;

} // ProcessAuthInfo

BOOL CSecurityCtx::ClientConverse(
    IN VOID *           pBuffIn,
    IN DWORD            cbBuffIn,
    OUT BUFFER *        pbuffOut,
    OUT DWORD *         pcbBuffOut,
    OUT BOOL *          pfNeedMoreData,
    IN PTCP_AUTHENT_INFO pTAI,
    IN CHAR *           pszPackage,
    IN CHAR *           pszUser,
    IN CHAR *           pszPassword,
    IN PIIS_SERVER_INSTANCE psi)
/*++

Routine Description:

    Processes AUTH blobs for a client (ie, for an outbound connection). This is
    a simple wrapper around TCP_AUTHENT::Converse; it will map Internet protocol
    keywords to NT security package names.

Arguments:

    Same as that for TCP_AUTHENT::Converse

Return Value:

    Same as that for TCP_AUTHENT::Converse
--*/
{
    LPSTR pszPackageToUse = pszPackage;

    if (pszPackage != NULL && 
            (lstrcmpi(pszPackage, "GSSAPI") == 0) ) {
        pszPackageToUse = "Negotiate";
    }

    return( Converse( 
                pBuffIn, cbBuffIn,
                pbuffOut, pcbBuffOut, pfNeedMoreData, 
                pTAI, pszPackageToUse,
                pszUser, pszPassword,
                psi) );
}

//
// Figure out if the local machine is a member of a domain, or in a
// workgroup.  If we aren't in a domain then we don't want to call into
// ResetServicePrincipleNames.
//
// This function returns TRUE in error cases, because it is better to
// call into ResetServicePrininpleNames by mistake then it is to 
// skip calling it.
//
// Implemented using this algorithm:
// 
//   There are many ways to find out if you are in a work group.  You can
//   call LsaOpenPolicy /
//   LsaQueryInformationPolicy(PolicyDnsDomainInformation) / LsaClose, and
//   check if the SID is non-null.  That's authoritative.
// 
//   -Rich (Richard B. Ward (Exchange))
//
BOOL fInDomain() {
    TraceFunctEnter("fInDomain");
    
    LSA_HANDLE lsah;
    LSA_OBJECT_ATTRIBUTES objAttr;
    POLICY_DNS_DOMAIN_INFO *pDnsInfo;
    NTSTATUS ec;

    // cache the results of this here.  one can't join a domain without
    // rebooting, so this safe to do once
    static BOOL fDidCheck = FALSE;
    static BOOL fRet = TRUE;

    if (!fDidCheck) {
        ZeroMemory(&objAttr, sizeof(objAttr));

        ec = LsaOpenPolicy(NULL,
                           &objAttr,
                           POLICY_VIEW_LOCAL_INFORMATION,
                           &lsah);
        if (ec == ERROR_SUCCESS) {
            ec = LsaQueryInformationPolicy(lsah,
                                           PolicyDnsDomainInformation,
                                           (void **) &pDnsInfo);
            if (ec == ERROR_SUCCESS) {
                DebugTrace(0, "pDnsInfo = %x", pDnsInfo);
                // we are in a domain if there is a Sid
                if (pDnsInfo && pDnsInfo->Sid) {
                    fRet = TRUE;
                } else {
                    fRet = FALSE;
                }
                fDidCheck = TRUE;

                LsaFreeMemory(pDnsInfo);
            } else {
                DebugTrace(0, "LsaQueryInformationPolicy failed with %x", ec);
            }

            LsaClose(lsah);
        } else {
            DebugTrace(0, "LsaOpenPolicy failed with %x", ec);
        }
    }

    TraceFunctLeave();
    return fRet;
}


BOOL
CSecurityCtx::ResetServicePrincipalNames(
    IN LPCSTR szServiceClass)
/*++

Routine Description:

    Unregisters all service principal names for the given service from the
    local machine's computer account object.  

Arguments:

    szServiceClass: String identifying service class, eg. "SMTP"

Return Value:

    None.

--*/
    
{
    
    DWORD dwErr;

    if (fInDomain()) {
        dwErr = DsServerRegisterSpnA(
                    DS_SPN_DELETE_SPN_OP,
                    szServiceClass,
                    NULL);
    } else {
        dwErr = ERROR_SUCCESS;
    }

    if (dwErr != ERROR_SUCCESS) {
        SetLastError(dwErr);
        return( FALSE );
    } else {
        return( TRUE );
    }

}

BOOL
CSecurityCtx::RegisterServicePrincipalNames(
    IN LPCSTR szServiceClass,
    IN LPCSTR szFQDN)
/*++

Routine Description:

    Registers service specific SPNs for the provided FQDN. The list of SPNs is
    generated by doing a gethostbyname on the FQDN, and using the returned IP
    addresses as th SPNs.

Arguments:

    szServiceClass: String identifying service class, eg. "SMTP"
    szFQDN: The FQDN of the virtual server. It will be used to do a 
        gethostbyname and retrieve a list of IP addresses to use.

Return Value:

    None.

--*/
    
{
    DWORD dwErr, cIPAddresses;

    if (fInDomain()) {
        dwErr = DsServerRegisterSpnA(
                    DS_SPN_ADD_SPN_OP,
                    szServiceClass,
                    NULL);
    } else {
        dwErr = ERROR_SUCCESS;
    }

    if (dwErr != ERROR_SUCCESS) {
        SetLastError(dwErr);
        return( FALSE );
    } else {
        return( TRUE );
    }

}

#define MAX_SPN     260

BOOL
CSecurityCtx::SetTargetPrincipalName(
    IN LPCSTR szServiceClass,
    IN LPCSTR szTargetIPOrFQDN)
/*++

Routine Description:

    Unregisters all service principal names for the given service from the
    local machine's computer account object.  

Arguments:

    szServiceClass: String identifying service class, eg. "SMTP"

Return Value:

    None.

--*/
    
{
    DWORD dwErr, cbTargetSPN;
    CHAR szTargetSPN[MAX_SPN];

    cbTargetSPN = sizeof(szTargetSPN);

    dwErr = DsClientMakeSpnForTargetServerA(
                szServiceClass,
                szTargetIPOrFQDN,
                &cbTargetSPN,
                szTargetSPN);

    if (dwErr == ERROR_SUCCESS) {

        return( SetTargetName(szTargetSPN) );

    } else {

        SetLastError(dwErr);

        return( FALSE );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\simssl2\simssl.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    security.cpp

Abstract:

    This module contains definition for the CSecurityCtx class.

Author:

    Johnson Apacible (JohnsonA)     18-Sept-1995

Revision History:

--*/

#if !defined(dllexp)
#define dllexp  __declspec( dllexport )
#endif  // !defined( dllexp )
/*
#include <dbgutil.h>
#include <tcpdll.hxx>
#include <tcpsvcs.h>
#include <tcpdebug.h>
#include <tsvcinfo.hxx>
#include <inetdata.h>
*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <wincrypt.h>
#include <stdlib.h>
#include <dbgtrace.h>

#include <inetinfo.h>
//
// SSL and SSPI related include files
//

#include <dbgutil.h>
#include <buffer.hxx>
#include <ole2.h>
#include <imd.h>
#include <iadm.h>
#include <mb.hxx>

#define DEFINE_SIMSSL_GLOBAL

extern "C" {
#define SECURITY_WIN32
#include <sspi.h>
#include <ntsecapi.h>
#include <spseal.h>
//#include <sslsp.h>
#include <schnlsp.h>
#include ".\credcach.hxx"
}

#include <certnotf.hxx>
//#include "sslmsgs.h"

#include "simssl2.h"

#define CORE_SSL_KEY_LIST_SECRET      L"%S_KEY_LIST"



//
// try/finally macros
//

#define START_TRY               __try {
#define END_TRY                 }
#define TRY_EXCEPT              } __except(EXCEPTION_EXECUTE_HANDLER) {
#define START_FINALLY           } __finally {

//
// tracing
//

#define ENTER( _x_ )            TraceFunctEnter( _x_ );
#define LEAVE                   TraceFunctLeave( );



#define MAX_SECRET_NAME       255
#define MAX_ADDRESS_LEN       64

typedef VOID (WINAPI FAR *PFN_SCHANNEL_INVALIDATE_CACHE)(
    VOID
);

VOID WINAPI NotifySslChanges(
    DWORD                         dwNotifyType,
    LPVOID                        pInstance
    );

//
//  The list of encryption packages we support.  PCT goes first since it's a
//  superset of SSL
//

struct _ENC_PROVIDER EncProviders[] =
{
    UNISP_NAME_W,  ENC_CAPS_PCT|ENC_CAPS_SSL, FALSE,
    PCT1SP_NAME_W, ENC_CAPS_PCT, FALSE,
    SSL3SP_NAME_W, ENC_CAPS_SSL, FALSE,
    SSL2SP_NAME_W, ENC_CAPS_SSL, FALSE,

    NULL,          FALSE,         FALSE
};


struct _ENC_PROVIDER EncLsaProviders[] =
{
    UNISP_NAME_W L" X",     ENC_CAPS_PCT|ENC_CAPS_SSL, FALSE,
    PCT1SP_NAME_W L" X",    ENC_CAPS_PCT, FALSE,
    SSL3SP_NAME_W L" X",    ENC_CAPS_SSL, FALSE,
    SSL2SP_NAME_W L" X",    ENC_CAPS_SSL, FALSE,

    NULL,          FALSE,         FALSE
};

struct _ENC_PROVIDER*   pEncProviders = EncProviders;

//
// service specific string names
//

WCHAR       CEncryptCtx::wszServiceName[16];
//char      CEncryptCtx::szLsaPrefix[16];
BOOL        CEncryptCtx::m_IsSecureCapable = FALSE;

//
// hSecurity - NULL when security.dll/secur32.dll  is not loaded
//

HINSTANCE   CEncryptCtx::m_hSecurity = NULL;
HINSTANCE   CEncryptCtx::m_hLsa = NULL;
PVOID       CEncryptCtx::m_psmcMapContext = NULL;

//
// g_pSecFuncTable - Pointer to Global Structure of Pointers that are used
//  for storing the entry points into the SCHANNEL.dll
//

PSecurityFunctionTableW g_pSecFuncTableW = NULL;
HINSTANCE g_hSchannel = NULL;
//
// NB : Under NT 5, the SslEmptyCache function is no longer supported
//
PFN_SCHANNEL_INVALIDATE_CACHE g_pfnFlushSchannelCache = NULL;

#if 0
LSAOPENPOLICY           g_LsaOpenPolicy = NULL;
LSARETRIEVEPRIVATEDATA  g_LsaRetrievePrivateData = NULL;
LSACLOSE                g_LsaClose = NULL;
LSANTSTATUSTOWINERROR   g_LsaNtStatusToWinError = NULL;
LSAFREEMEMORY           g_LsaFreeMemory = NULL;
#endif

VOID
AsciiStringToUnicode(
        IN LPWSTR UnicodeString,
        IN LPSTR AsciiString
        )
{
    while ( (*UnicodeString++ = (WCHAR)*AsciiString++) != (WCHAR)'\0');

} // AsciiStringToUnicode

BOOL
CEncryptCtx::Initialize(
            LPSTR       pszServiceName,
            IMDCOM*     pImdcom,
            PVOID       psmcMapContext,
            PVOID       pvAdminBase
            //LPSTR     pszLsaPrefix
            )
/*++

Routine Description:

    Activates the security package

Arguments:

    None.

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{
    ENTER("CEncryptCtx::Initialize")

    BOOL            fSuccess = FALSE;
    DWORD           cb;
    SECURITY_STATUS ss;
    PSecPkgInfoW    pPackageInfo = NULL;
    ULONG           cPackages;
    ULONG           i;
    ULONG           fCaps;
    DWORD           dwEncFlags = ENC_CAPS_DEFAULT;
    DWORD           cProviders = 0;
#if 0
    UNICODE_STRING* punitmp;
    WCHAR           achSecretName[MAX_SECRET_NAME+1];
#endif
    OSVERSIONINFO   os;
    PSERVICE_MAPPING_CONTEXT psmc = (PSERVICE_MAPPING_CONTEXT)psmcMapContext;

    extern  IMDCOM* pMDObject ;
    extern  IMSAdminBaseW* pAdminObject ;

    pMDObject = pImdcom ;
    m_psmcMapContext = psmcMapContext ;
    pAdminObject = (IMSAdminBaseW*)pvAdminBase ;

    //
    // deal with different security packages DLL on different platforms
    //

    INITSECURITYINTERFACE pfInitSecurityInterfaceW = NULL;

    _ASSERT( m_hSecurity == NULL );
    _ASSERT( m_hLsa == NULL );

    //
    // load dll.
    //

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    _VERIFY( GetVersionEx( &os ) );

    if ( os.dwPlatformId == VER_PLATFORM_WIN32_NT )
    {
        m_hSecurity = LoadLibrary("security");
    }
    else
    {
        m_hSecurity = LoadLibrary("secur32");
    }

    if ( m_hSecurity == NULL )
    {
        ErrorTrace( 0, "LoadLibrary failed: %d", GetLastError() );
        goto quit;
    }

    //
    // only on NT get the LSA function pointers
    //
    if ( os.dwPlatformId == VER_PLATFORM_WIN32_NT )
    {
#if 0
        m_hLsa = LoadLibrary("advapi32");
        if ( m_hLsa == NULL )
        {
            ErrorTrace( 0, "LoadLibrary ADVAPI32 failed: %d", GetLastError() );
            goto quit;
        }

        g_LsaOpenPolicy = (LSAOPENPOLICY)
                        GetProcAddress( m_hLsa, "LsaOpenPolicy" );

        if ( g_LsaOpenPolicy == NULL )
        {
            ErrorTrace( 0, "LsaOpenPolicy GetProcAddress failed: %d", GetLastError() );
            goto quit;
        }

        g_LsaRetrievePrivateData = (LSARETRIEVEPRIVATEDATA)
                        GetProcAddress( m_hLsa, "LsaRetrievePrivateData" );

        if ( g_LsaRetrievePrivateData == NULL )
        {
            ErrorTrace( 0, "LsaRetrievePrivateData GetProcAddress failed: %d", GetLastError() );
            goto quit;
        }

        g_LsaClose = (LSACLOSE)
                        GetProcAddress( m_hLsa, "LsaClose" );

        if ( g_LsaClose == NULL )
        {
            ErrorTrace( 0, "LsaClose GetProcAddress failed: %d", GetLastError() );
            goto quit;
        }

        g_LsaNtStatusToWinError = (LSANTSTATUSTOWINERROR)
                        GetProcAddress( m_hLsa, "LsaNtStatusToWinError" );

        if ( g_LsaNtStatusToWinError == NULL )
        {
            ErrorTrace( 0, "LsaNtStatusToWinError GetProcAddress failed: %d", GetLastError() );
            goto quit;
        }

        g_LsaFreeMemory = (LSAFREEMEMORY)
                        GetProcAddress( m_hLsa, "LsaFreeMemory" );

        if ( g_LsaFreeMemory == NULL )
        {
            ErrorTrace( 0, "LsaFreeMemory GetProcAddress failed: %d", GetLastError() );
            goto quit;
        }
#endif
    }
    //
    // get function addresses for ansi entries.
    //

    pfInitSecurityInterfaceW = (INITSECURITYINTERFACE)
                                GetProcAddress( m_hSecurity, SECURITY_ENTRYPOINTW );

    if ( pfInitSecurityInterfaceW == NULL )
    {
        ErrorTrace( 0, "GetProcAddress failed: %d", GetLastError() );
        goto quit;
    }

    g_pSecFuncTableW = (SecurityFunctionTableW*)((*pfInitSecurityInterfaceW)());

    if ( g_pSecFuncTableW == NULL )
    {
        ErrorTrace( 0, "SecurityFunctionTable failed: %d", GetLastError() );
        goto quit;
    }

    //
    // Initialize cached credential data
    //

    InitializeCriticalSection( &csGlobalLock );
    InitCredCache();
    if ( g_hSchannel = LoadLibrary( "schannel.dll" ) )
    {
        g_pfnFlushSchannelCache = (PFN_SCHANNEL_INVALIDATE_CACHE)GetProcAddress(
                    g_hSchannel, "SslEmptyCache" );
    }

    //
    // Client implementations do not require Lsa secrets
    //

    if ( pszServiceName )
    {
        cb = lstrlen( pszServiceName ) + 1;
        if ( cb*2 > sizeof( wszServiceName ) )
        {
            ErrorTrace( 0, "szServiceName too long" );
            goto quit;
        }
        //CopyMemory( szServiceName, pszServiceName, cb );
        AsciiStringToUnicode( wszServiceName, pszServiceName );
    }


#if 0
    if ( pszLsaPrefix )
    {
        cb = lstrlen( pszLsaPrefix ) + 1;
        if ( cb > sizeof( szLsaPrefix ) )
        {
            ErrorTrace( 0, "szLsaPrefix too long" );
            goto quit;
        }
        CopyMemory( szLsaPrefix, pszLsaPrefix, cb );
    }
#endif


    //
    //  Get the list of security packages on this machine
    //

    ss = g_EnumerateSecurityPackages( &cPackages, &pPackageInfo );

    if ( ss != STATUS_SUCCESS )
    {
        ErrorTrace( 0, "g_EnumerateSecurityPackages failed: 0x%08X", ss );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto quit;
    }

    for ( i = 0; i < cPackages ; i++ )
    {
        //
        //  We'll only use the security package if it supports connection
        //  oriented security and it supports the appropriate side (client
        //  or server)
        //

        fCaps = pPackageInfo[i].fCapabilities;

        if ( fCaps & SECPKG_FLAG_STREAM )
        {
            if ( fCaps & SECPKG_FLAG_CLIENT_ONLY ||
                 !(fCaps & SECPKG_FLAG_PRIVACY ))
            {
                continue;
            }

            //
            //  Does it match one of our known packages and are we configured
            //  to use it?
            //

            for ( int j = 0; pEncProviders[j].pszName != NULL; j++ )
            {
                if ( !wcscmp( pPackageInfo[i].Name, pEncProviders[j].pszName ) &&
                     pEncProviders[j].dwFlags & dwEncFlags )
                {
                    pEncProviders[j].fEnabled = TRUE;
                    cProviders++;
                }
            }
        }
    }

    g_FreeContextBuffer( pPackageInfo );

    if ( !cProviders )
    {
        //
        //  The package wasn't found, fail this filter's load
        //

        ErrorTrace( 0, "No security packages were found" );
        SetLastError( (DWORD) SEC_E_SECPKG_NOT_FOUND );

        //
        // not a fatal error
        //
        fSuccess = TRUE;
        goto quit;
    }

#if 0
    //
    //  The package is installed.  Check to see if there are any keys
    //  installed
    //

    if ( os.dwPlatformId == VER_PLATFORM_WIN32_NT && pszLsaPrefix )
    {
        wsprintfW(  achSecretName,
                    CORE_SSL_KEY_LIST_SECRET,
                    szLsaPrefix );

        if ( !GetSecretW( achSecretName, &punitmp ) )
        {
            ErrorTrace( 0, "GetSecretW returned error %d", GetLastError() );

            //
            //  Looks like no secrets are installed, fail to load, don't log an
            //  event
            //

            SetLastError( NO_ERROR );

            //
            // not a fatal error
            //
            fSuccess = TRUE;
            goto quit;
        }
        g_LsaFreeMemory( punitmp );
    }
#endif

    if ( psmc )
    {
        if (!psmc->ServerSupportFunction(
                                        NULL,
                                        (LPVOID)NotifySslChanges,
                                        (UINT)SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED ) ||
            !psmc->ServerSupportFunction(
                                        NULL,
                                        (LPVOID)NotifySslChanges,
                                        (UINT)SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED ) ||
            !psmc->ServerSupportFunction(
                                        NULL,
                                        (LPVOID)NotifySslChanges,
                                        (UINT)SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED ))
            {
                _ASSERT( FALSE );
                fSuccess = FALSE;
                goto quit;
            }
    }

    //
    // if we got here everything is cool for secure communications
    //
    fSuccess = m_IsSecureCapable = TRUE;

quit:
    if ( fSuccess == FALSE )
    {
        if ( m_hSecurity != NULL )
        {
            FreeLibrary( m_hSecurity );
            m_hSecurity = NULL;
        }

        if ( m_hLsa != NULL )
        {
            FreeLibrary( m_hLsa );
            m_hLsa = NULL;
        }
    }

    LEAVE

    return  fSuccess;

} // Initialize

VOID
CEncryptCtx::Terminate(
            VOID
            )
/*++

Routine Description:

    Terminates the security package

Arguments:

    None.

Return Value:

    None.

--*/
{

    ENTER("CEncryptCtx::Terminate")

    PSERVICE_MAPPING_CONTEXT psmc = (PSERVICE_MAPPING_CONTEXT)m_psmcMapContext;

    //
    // Close cached credential handles
    //

    FreeCredCache();

    //
    // NB : Under NT 5, the SslEmptyCache function is no longer supported
    //
#if 0
    if ( g_pfnFlushSchannelCache )
    {
        (g_pfnFlushSchannelCache)();
    }
#endif

    if ( g_hSchannel )
    {
        FreeLibrary( g_hSchannel );
    }

    if ( psmc )
    {
        if (!psmc->ServerSupportFunction(
                                        NULL,
                                        (LPVOID)NULL,
                                        (UINT)SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED ) ||
            !psmc->ServerSupportFunction(
                                        NULL,
                                        (LPVOID)NULL,
                                        (UINT)SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED ) ||
            !psmc->ServerSupportFunction(
                                        NULL,
                                        (LPVOID)NULL,
                                        (UINT)SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED ))
            {
                _ASSERT( FALSE );
            }
    }

    DeleteCriticalSection( &csGlobalLock );

    if ( m_hSecurity != NULL )
    {
        FreeLibrary( m_hSecurity );
        m_hSecurity = NULL;
    }

    if ( m_hLsa != NULL )
    {
        FreeLibrary( m_hLsa );
        m_hLsa = NULL;
    }

    LEAVE
    return;

} // Terminate


CEncryptCtx::CEncryptCtx( BOOL IsClient, DWORD dwSslAccessPerms ) :
    m_IsClient( IsClient ),
    m_haveSSLCtxtHandle( FALSE ),
    m_cbSealHeaderSize( 0 ),
    m_cbSealTrailerSize( 0 ),
    m_IsAuthenticated( FALSE ),
    m_IsNewSSLSession( TRUE ),
    m_IsEncrypted( FALSE ),
    m_phCredInUse( NULL ),
    m_iCredInUse( 0 ),
    m_phCreds( NULL ),
    m_dwSslAccessPerms( dwSslAccessPerms ),
    m_hSSPToken( NULL ),
    m_dwKeySize( 0 )


/*++

Routine Description:

    Class constructor

Arguments:

    None.

Return Value:

    None

--*/
{

    ZeroMemory( (PVOID)&m_hSealCtxt, sizeof(m_hSealCtxt) );

} // CEncryptCtx




CEncryptCtx::~CEncryptCtx(
                VOID
                )
/*++

Routine Description:

    Class destructor

Arguments:

    None.

Return Value:

    None

--*/
{
    Reset();

} // ~CEncryptCtx




VOID
CEncryptCtx::Reset(
                VOID
                )
/*++

Routine Description:

    resets the instance to reauth user

Arguments:

    None.

Return Value:

    None

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::Reset" );

    m_cbSealHeaderSize = 0;
    m_cbSealTrailerSize = 0;
    m_IsAuthenticated = FALSE;
    m_IsNewSSLSession = TRUE;
    m_IsEncrypted = FALSE;
    m_phCredInUse = NULL;
    m_iCredInUse = 0;

    if ( m_haveSSLCtxtHandle == TRUE )
    {
        g_DeleteSecurityContext( &m_hSealCtxt );
        m_haveSSLCtxtHandle = FALSE;
    }

    ZeroMemory( (PVOID)&m_hSealCtxt, sizeof(m_hSealCtxt) );

    //mikeswa 4/1/99
    //According to JBanes, it is not legal to Free the credentials
    //handle before deleting the associated security context.
    //Moving release to after delete just in case this is the
    //final release.
    if (m_phCreds != NULL) {
        ((CRED_CACHE_ITEM *) m_phCreds)->Release();
    }
    m_phCreds = NULL;

    //
    //  Close the NT token obtained during cert mapping
    //

    if( m_hSSPToken )
    {
        _ASSERT( m_dwSslAccessPerms & MD_ACCESS_MAP_CERT );
        _VERIFY( CloseHandle( m_hSSPToken ) );
        m_hSSPToken = NULL;
    }

} // ~CEncryptCtx





BOOL
CEncryptCtx::SealMessage(
                IN LPBYTE Message,
                IN DWORD cbMessage,
                OUT LPBYTE pBuffOut,
                OUT DWORD  *pcbBuffOut
                )
/*++

Routine Description:

    Encrypt message

Arguments:

    Message - message to be encrypted
    cbMessage - size of message to be encrypted

Return Value:

    Status of operation

--*/
{
    SECURITY_STATUS ss = ERROR_NOT_SUPPORTED;
    SecBufferDesc   inputBuffer;
    SecBuffer       inBuffers[3];
    DWORD           encryptedLength;
    DWORD           iBuff = 0;

    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::SealMessage");

    if ( m_haveSSLCtxtHandle ) {

        encryptedLength = cbMessage + GetSealHeaderSize() + GetSealTrailerSize();

        DebugTrace( (LPARAM)this,
                    "InBuf: 0x%08X, OutBuf: 0x%08X, in: %d, max: %d, out: %d",
                    Message, pBuffOut, cbMessage,
                    *pcbBuffOut, encryptedLength );

        //
        // don't do the MoveMemory if the app is SSL/PCT buffer aware
        //

        if ( Message != pBuffOut + GetSealHeaderSize() )
        {
            MoveMemory( pBuffOut + GetSealHeaderSize(),
                        Message,
                        cbMessage );
        }

        if ( GetSealHeaderSize() )
        {
            inBuffers[iBuff].pvBuffer = pBuffOut;
            inBuffers[iBuff].cbBuffer = GetSealHeaderSize();
            inBuffers[iBuff].BufferType = SECBUFFER_TOKEN;

            iBuff++;
        }

        inBuffers[iBuff].pvBuffer = pBuffOut + GetSealHeaderSize();
        inBuffers[iBuff].cbBuffer = cbMessage;
        inBuffers[iBuff].BufferType = SECBUFFER_DATA;

        iBuff++;

        if ( GetSealTrailerSize() )
        {
            inBuffers[iBuff].pvBuffer = pBuffOut + GetSealHeaderSize() + cbMessage;
            inBuffers[iBuff].cbBuffer = GetSealTrailerSize();
            inBuffers[iBuff].BufferType = SECBUFFER_TOKEN;

            iBuff++;
        }

        inputBuffer.cBuffers = iBuff;
        inputBuffer.pBuffers = inBuffers;
        inputBuffer.ulVersion = SECBUFFER_VERSION;

        ss = g_SealMessage(
                &m_hSealCtxt,
                0,
                &inputBuffer,
                0
                );

        *pcbBuffOut = encryptedLength;

        DebugTrace( (LPARAM)this, "SealMessage returned: %d, 0x%08X", ss, ss );
    }

    SetLastError(ss);
    return (ss == STATUS_SUCCESS);

} // SealMessage



BOOL
CEncryptCtx::UnsealMessage(
                IN LPBYTE Message,
                IN DWORD cbMessage,
                OUT LPBYTE *DecryptedMessage,
                OUT PDWORD DecryptedMessageSize,
                OUT PDWORD ExpectedMessageSize,
                OUT LPBYTE *NextSealMessage
                )
/*++

Routine Description:

    Decrypt message

Arguments:

    Message - message to be encrypted
    cbMessage - size of message to be encrypted

Return Value:

    Status of operation

--*/
{

    SECURITY_STATUS ss;
    SecBufferDesc   inputBuffer;
    SecBuffer       inBuffers[4];
    DWORD qOP;

    //
    // if the app wants to know the start of the next seal msg init to NULL
    //
    if ( NextSealMessage != NULL )
    {
        *NextSealMessage = NULL;
    }


    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::UnsealMessage");

    DebugTrace( (LPARAM)this,
                "initial ptr: 0x%08X, count: %d",
                Message, cbMessage );

    if ( m_haveSSLCtxtHandle ) {

        inBuffers[0].pvBuffer = Message;
        inBuffers[0].cbBuffer = cbMessage;
        inBuffers[0].BufferType = SECBUFFER_DATA;

        inBuffers[1].pvBuffer = NULL;
        inBuffers[1].cbBuffer = 0;
        inBuffers[1].BufferType = SECBUFFER_EMPTY;

        inBuffers[2].pvBuffer = NULL;
        inBuffers[2].cbBuffer = 0;
        inBuffers[2].BufferType = SECBUFFER_EMPTY;

        inBuffers[3].pvBuffer = NULL;
        inBuffers[3].cbBuffer = 0;
        inBuffers[3].BufferType = SECBUFFER_EMPTY;

        //
        // one for the data and one for the head and/or tail
        //
        inputBuffer.cBuffers = 4;
//      if ( GetSealHeaderSize() )  inputBuffer.cBuffers++;
//      if ( GetSealTrailerSize() ) inputBuffer.cBuffers++;
//      if ( NextSealMessage )      inputBuffer.cBuffers++;

        inputBuffer.pBuffers = inBuffers;
        inputBuffer.ulVersion = SECBUFFER_VERSION;

        ss = g_UnsealMessage(
                &m_hSealCtxt,
                &inputBuffer,
                0,
                &qOP
                );

        if ( NT_SUCCESS(ss) )
        {
            for (DWORD i=0;i<inputBuffer.cBuffers;i++)
            {
                if ( inBuffers[i].BufferType == SECBUFFER_DATA )
                {
                    *DecryptedMessage = (LPBYTE)inBuffers[i].pvBuffer;
                    *DecryptedMessageSize = inBuffers[i].cbBuffer;

                    DebugTrace( (LPARAM)this,
                                "unsealed ptr: 0x%08X, count: %d",
                                *DecryptedMessage, *DecryptedMessageSize );

                    //
                    // if the app wants to know the start of the next seal msg
                    //
                    if ( NextSealMessage != NULL )
                    {
                        for ( ;i<inputBuffer.cBuffers;i++ )
                        {
                            if ( inBuffers[i].BufferType == SECBUFFER_EXTRA )
                            {
                                *NextSealMessage = (LPBYTE)inBuffers[i].pvBuffer;
                                DebugTrace( (LPARAM)this,
                                            "Found extra buffer: 0x%08X",
                                            *NextSealMessage );
                                break;
                            }
                        }
                    }

                    return  TRUE;
                }
            }
            return  FALSE;
        }
        else if( ss == SEC_E_INCOMPLETE_MESSAGE )
        {
            for( DWORD i=0; i<inputBuffer.cBuffers;i++ )
            {
                if( inBuffers[i].BufferType == SECBUFFER_MISSING )
                {
                    *ExpectedMessageSize = inBuffers[i].cbBuffer;
                }
            }
        }
        SetLastError(ss);
    }
    return  FALSE;
} // UnsealMessage


//
// set this define to allow schannel to allocate responses in InitializeSecurityContext
//
#define SSPI_ALLOCATE_MEMORY


DWORD
CEncryptCtx::EncryptConverse(
                IN PVOID        InBuffer,
                IN DWORD        InBufferSize,
                OUT LPBYTE      OutBuffer,
                IN OUT PDWORD   OutBufferSize,
                OUT PBOOL       MoreBlobsExpected,
                IN CredHandle*  pCredHandle,
                OUT PULONG      pcbExtra
                )
{
/*++

Routine Description:

    Internal private routine for attempting to use a given protocol

Arguments:

  InBuffer: ptr to apps input buffer
  InBufferSize: count of input buffer
  OutBuffer: ptr to apps output buffer
  OutBuffer: ptr to apps max size of output buffer and resultant output count
  MoreBlobsExpected: expect more data from the client ?
  pCredHandle: ptr to the credential handle to use
  pcbExtra: Sometimes, even after the handshake succeeds, all the data in InBuffer
    may not be used up. This is because the other side may have started sending
    non-handshake (application) data. The param returns the length of this unprocessed
    "tail" which should be processed using Decrypt functions.

Return Value:

  TRUE if negotiation succeeded.
  FALSE if negotiation failed.

--*/
    SECURITY_STATUS     ss;
    DWORD               error = NO_ERROR;
    SecBufferDesc       inBuffDesc;
    SecBuffer           inSecBuff[2];
    SecBufferDesc       outBuffDesc;
    SecBuffer           outSecBuff;
    PCtxtHandle         pCtxtHandle;
    DWORD               contextAttributes = 0 ;
    TimeStamp           lifeTime;
    DWORD               dwMaxBuffer = *OutBufferSize;
    SECURITY_STATUS     sc;
    SECURITY_STATUS     scR;
    HANDLE              hSSPToken = NULL;
    PCCERT_CONTEXT pClientCert = NULL;

    // Init vars used to check/return the number of bytes unprocessed by SSL handshake
    _ASSERT (pcbExtra);
    inSecBuff[1].BufferType = SECBUFFER_EMPTY;
    *pcbExtra = 0;

    BOOL                fCert = TRUE;
    SecPkgContext_StreamSizes   sizes;
#ifdef DEBUG
    SecPkgContext_ProtoInfo spcPInfo;
    SECURITY_STATUS     ssProto;
#endif
    SecPkgContext_KeyInfo spcKInfo;
    SECURITY_STATUS     ssInfo;

    //
    // See if we have enough data
    //

    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::EncryptConverse");

    pCtxtHandle = &m_hSealCtxt;

    _ASSERT(OutBuffer != NULL && "Must pass in an OutBuffer");
    if(NULL == OutBuffer) {
        ss = E_INVALIDARG;
        goto error_exit;
    }

ScanNextPacket:
    outBuffDesc.ulVersion = 0;
    outBuffDesc.cBuffers  = 1;
    outBuffDesc.pBuffers  = &outSecBuff;

    //
    // need to set cbBuffer to zero because sslsspi will leave it
    // uninitialized when the converse completes
    //
    outSecBuff.cbBuffer   = dwMaxBuffer;
    outSecBuff.BufferType = SECBUFFER_TOKEN;
    outSecBuff.pvBuffer   = OutBuffer;

    //
    //  Prepare our Input buffer - Note the server is expecting the client's
    //  negotiation packet on the first call
    //

    if ( ARGUMENT_PRESENT(InBuffer) )
    {
        inBuffDesc.ulVersion = 0;
        inBuffDesc.cBuffers  = 2;
        inBuffDesc.pBuffers  = &inSecBuff[0];

        inSecBuff[0].cbBuffer   = InBufferSize;
        inSecBuff[0].BufferType = SECBUFFER_TOKEN;
        inSecBuff[0].pvBuffer   = InBuffer;

        inSecBuff[1].cbBuffer   = 0;
        inSecBuff[1].BufferType = SECBUFFER_EMPTY;
        inSecBuff[1].pvBuffer   = NULL;
    }

    if ( m_IsClient ) {

        DWORD   contextAttributes;
        LPVOID  pvBuffer;
        DWORD   cbBuffer;

        //
        //  Note the client will return success when its done but we still
        //  need to send the out buffer if there are bytes to send
        //

#ifdef SSPI_ALLOCATE_MEMORY
        pvBuffer = outSecBuff.pvBuffer;
        cbBuffer = outSecBuff.cbBuffer;

        outSecBuff.pvBuffer = NULL;
        outSecBuff.cbBuffer = 0;
#endif

        DWORD dwIscReq =    ISC_REQ_STREAM |
                            ISC_REQ_SEQUENCE_DETECT |
                            ISC_REQ_REPLAY_DETECT   |
                            ISC_REQ_EXTENDED_ERROR  |
                            ISC_REQ_MANUAL_CRED_VALIDATION |  // to remove implicit call to WinVerifyTRust
#ifdef SSPI_ALLOCATE_MEMORY
                            ISC_REQ_ALLOCATE_MEMORY |
#endif
                            ISC_REQ_CONFIDENTIALITY;

        if( ( m_dwSslAccessPerms & MD_ACCESS_NEGO_CERT )   ||
            ( m_dwSslAccessPerms & MD_ACCESS_REQUIRE_CERT) ||
            ( m_dwSslAccessPerms & MD_ACCESS_MAP_CERT )  ) {
            dwIscReq |= ISC_REQ_MUTUAL_AUTH;
        }

        if (m_IsNewSSLSession) {
            dwIscReq |= ISC_REQ_USE_SUPPLIED_CREDS;
        }

        ss = g_InitializeSecurityContext(
                                    pCredHandle,
                                    m_IsNewSSLSession ? NULL : pCtxtHandle,
                                    wszServiceName,
                                    dwIscReq,
                                    0,
                                    SECURITY_NATIVE_DREP,
                                    m_IsNewSSLSession ? NULL : &inBuffDesc,
                                    0,
                                    pCtxtHandle,
                                    &outBuffDesc,
                                    &contextAttributes,
                                    &lifeTime
                                    );

#ifdef SSPI_ALLOCATE_MEMORY
        if ( NT_SUCCESS( ss ) && outSecBuff.pvBuffer )
        {
            DebugTrace( (LPARAM)this,
                        "Output %d bytes, Maximum %d bytes",
                        outSecBuff.cbBuffer,
                        cbBuffer );

            if ( outSecBuff.cbBuffer <= cbBuffer )
            {
                CopyMemory( pvBuffer, outSecBuff.pvBuffer, outSecBuff.cbBuffer );
            }
            else
            {
                ss = SEC_E_INSUFFICIENT_MEMORY;
            }

            g_FreeContextBuffer( outSecBuff.pvBuffer );
        }
#endif

    } else {

        //
        //  This is the server side
        //

        DWORD dwAscReq = ASC_REQ_STREAM |
                         ASC_REQ_CONFIDENTIALITY |
                         ASC_REQ_EXTENDED_ERROR  |
                         ASC_REQ_SEQUENCE_DETECT |
                         ASC_REQ_REPLAY_DETECT;

        //
        //  Set the mutual auth attribute if we are configured
        //  to negotiate, require or map client certs
        //

        if( ( m_dwSslAccessPerms & MD_ACCESS_NEGO_CERT )   ||
            ( m_dwSslAccessPerms & MD_ACCESS_REQUIRE_CERT) ||
            ( m_dwSslAccessPerms & MD_ACCESS_MAP_CERT )  ) {
            dwAscReq |= ASC_REQ_MUTUAL_AUTH;
        }

        ss = g_AcceptSecurityContext(
                                pCredHandle,
                                m_IsNewSSLSession ? NULL : pCtxtHandle,
                                &inBuffDesc,
                                dwAscReq,
                                SECURITY_NATIVE_DREP,
                                pCtxtHandle,
                                &outBuffDesc,
                                &contextAttributes,
                                &lifeTime
                                );

        DebugTrace((LPARAM)this,
            "AcceptSecurityContext returned win32 error %d (%x)",
            ss, ss);

        if( outSecBuff.pvBuffer != OutBuffer && outSecBuff.cbBuffer ) {
            //
            //  SSPI workaround - if the buffer got allocated by SSPI
            //  copy it over and free it..
            //

            if ( outSecBuff.cbBuffer <= dwMaxBuffer )
            {
                CopyMemory( OutBuffer, outSecBuff.pvBuffer, outSecBuff.cbBuffer );
            }
            else
            {
                ss = SEC_E_INSUFFICIENT_MEMORY;
            }

            g_FreeContextBuffer( outSecBuff.pvBuffer );
        }

    }

    //
    //  Negotiation succeeded, there is extra stuff left in the buffer
    //  Return the number of the unused bytes.
    //
    if( ss == SEC_E_OK && inSecBuff[1].BufferType == SECBUFFER_EXTRA ) {
        *pcbExtra = inSecBuff[1].cbBuffer;

    } else if( ss == SEC_I_CONTINUE_NEEDED && inBuffDesc.pBuffers[1].cbBuffer ) {
        //
        //  Need to process next SSL packet by calling Init/AcceptSecurityContext again
        //  Should ASSERT that InBuffer <= OrigInBuffer + OrigInBufferSize
        //
        _ASSERT( !outSecBuff.cbBuffer );
        InBuffer = (LPSTR)InBuffer + InBufferSize - inBuffDesc.pBuffers[1].cbBuffer;
        InBufferSize = inBuffDesc.pBuffers[1].cbBuffer;
        goto ScanNextPacket;

    } else if ( ss == SEC_E_INCOMPLETE_MESSAGE ) {
        //
        //  Not enough data from server... need to read more before proceeding
        //  If there is unconsumed data, the new data is to be appended to it
        //
        *pcbExtra = InBufferSize;

    } else if ( !NT_SUCCESS( ss ) ) {

        ErrorTrace( (LPARAM)this,"%s failed with %x\n",
                    m_IsClient ?
                    "InitializeSecurityContext" :
                    "AcceptSecurityContext",
                    ss );

        if ( ss == SEC_E_LOGON_DENIED ) {
            ss = ERROR_LOGON_FAILURE;
        }
        goto error_exit;
    }

    //
    // Only query the context attributes if this is a new session, and the
    // Accept/Initialize have returned SEC_E_OK (ie, the channel has been fully
    // established)
    //
    if( ss == SEC_E_OK ) {

        ssInfo = g_QueryContextAttributes(
                            pCtxtHandle,
                            SECPKG_ATTR_KEY_INFO,
                            &spcKInfo
                            );

        if ( ssInfo != SEC_E_OK ) {
            ErrorTrace( (LPARAM)this,
                        "Cannot get SSL\\PCT Key Info. Err %x",ssInfo );
            //goto error_exit;
        } else {
            //  Note the key size
            m_dwKeySize = spcKInfo.KeySize;
            if ( spcKInfo.sSignatureAlgorithmName )
                g_FreeContextBuffer( spcKInfo.sSignatureAlgorithmName );
            if ( spcKInfo.sEncryptAlgorithmName )
                g_FreeContextBuffer( spcKInfo.sEncryptAlgorithmName );
        }
    }

    m_haveSSLCtxtHandle = TRUE;

    //
    //  Now we just need to complete the token (if requested) and prepare
    //  it for shipping to the other side if needed
    //

    if ( (ss == SEC_I_COMPLETE_NEEDED) ||
         (ss == SEC_I_COMPLETE_AND_CONTINUE) ) {

        ss = g_CompleteAuthToken( pCtxtHandle, &outBuffDesc );

        if ( !NT_SUCCESS( ss )) {
            ErrorTrace( (LPARAM)this,
                        "CompleteAuthToken failed. Err %x",ss );
            goto error_exit;
        }
    }

    *OutBufferSize = outSecBuff.cbBuffer;

    *MoreBlobsExpected= (ss == SEC_I_CONTINUE_NEEDED) ||
                        (ss == SEC_I_COMPLETE_AND_CONTINUE) ||
                        (ss == SEC_E_INCOMPLETE_MESSAGE);

    if ( *MoreBlobsExpected == FALSE )
    {

        //
        // HACK: SSLSSPI leaves outSecBuff.cbBuffer uninitialized
        // after final successful call for client side connections
        //
        if ( m_IsClient && *OutBufferSize == dwMaxBuffer )
        {
            *OutBufferSize = 0;
        }

        //
        // we're done so get the SSPI header/trailer sizes for SealMessage
        //
        ss = g_QueryContextAttributes(
                            pCtxtHandle,
                            SECPKG_ATTR_STREAM_SIZES,
                            &sizes
                            );

        if ( ss != SEC_E_OK ) {
            ErrorTrace( (LPARAM)this,
                        "Cannot get SSL\\PCT Header Length. Err %x",ss );
            goto error_exit;
        }

        m_cbSealHeaderSize = sizes.cbHeader;
        m_cbSealTrailerSize = sizes.cbTrailer;

        DebugTrace( (LPARAM)this, "Header: %d, Trailer: %d",
                    m_cbSealHeaderSize, m_cbSealTrailerSize );

        if(!m_IsClient)
        {
            scR = g_QueryContextAttributes( pCtxtHandle,
                                          SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                          &pClientCert );

            if ( !NT_SUCCESS( scR ) || !pClientCert )
            {
                fCert = FALSE;
            }
            else
            {
                CertFreeCertificateContext( pClientCert);
                DebugTrace((LPARAM)this, "[OnAuthorizationInfo] Certificate available!\n");
            }

            //
            // check if client authentication available
            //

            if ( 1 /*|| pssc->IsMap()*/ )
            {
                sc = g_QuerySecurityContextToken(   pCtxtHandle,
                                                    &hSSPToken );

                if ( !NT_SUCCESS( sc ) || (hSSPToken == (HANDLE)0x00000001) )
                {
                    hSSPToken = NULL;
                }
            }

            if ( !fCert && hSSPToken != NULL )
            {
                CloseHandle( hSSPToken );
                hSSPToken = NULL;
            }

            if( !(m_dwSslAccessPerms & MD_ACCESS_MAP_CERT) && hSSPToken != NULL )
            {
                DebugTrace( (LPARAM)this,"NT token not required - closing");
                CloseHandle( hSSPToken );
                hSSPToken = NULL;
            }

            if( (m_dwSslAccessPerms & MD_ACCESS_REQUIRE_CERT) && !fCert )
            {
                //
                //  We require client cert - bail !
                //  Converse will return ERROR_ACCESS_DENIED
                //
                _ASSERT( !hSSPToken );
                return FALSE;
            }

            if( hSSPToken )
            {
                _ASSERT( fCert );
                m_hSSPToken = hSSPToken;
                m_IsAuthenticated = TRUE;
            } else if(m_dwSslAccessPerms & MD_ACCESS_MAP_CERT) {
                //
                //  We need to map cert to token - but token is NULL
                //
                return FALSE;
            }
        }
    }

    return TRUE;

error_exit:

    SetLastError(ss);
    return FALSE;

} // EncryptConverse


DWORD
CEncryptCtx::Converse(
                IN PVOID    InBuffer,
                IN DWORD    InBufferSize,
                OUT LPBYTE  OutBuffer,
                OUT PDWORD  OutBufferSize,
                OUT PBOOL   MoreBlobsExpected,
                IN LPSTR    LocalIpAddr,
                IN LPSTR    LocalPort,
                IN LPVOID   lpvInstance,
                IN DWORD    dwInstance,
                OUT PULONG  pcbExtra
                )
/*++

Routine Description:

    Internal private routine for attempting to use a given protocol

Arguments:

  InBuffer: ptr to apps input buffer
  InBufferSize: count of input buffer
  OutBuffer: ptr to apps output buffer
  OutBuffer: ptr to apps max size of output buffer and resultant output count
  MoreBlobsExpected: expect more data from the client ?
  LocalIpAddr: stringized local IP addr for the connection
  pcbExtra: See description of EncryptConverse
                
Return Value:

    Win32/SSPI error code

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::Converse");

    DWORD               dwMaxBuffer = *OutBufferSize;
    DWORD               i, cbCreds;
    CredHandle*         pCredArray = NULL;

    if ( m_IsNewSSLSession )
    {
        if ( m_IsClient )
        {
            //
            //  Get the credentials for the client
            //

            LockGlobals();
            if ( !LookupClientCredential(
                                    wszServiceName,
                                    (BOOL)m_dwSslAccessPerms,
                                    (CRED_CACHE_ITEM**)&m_phCreds ) )
            {
                ErrorTrace( (LPARAM)this,
                            "LookupClientCredential failed, error 0x%lx",
                            GetLastError() );

                UnlockGlobals();
                goto error_exit;
            }
            UnlockGlobals();
        }
        else
        {
            DebugTrace( (LPARAM)this,
                        "LookupCredential for %S on %s",
                        wszServiceName, LocalIpAddr );

            //
            //  Get the credentials for this IP address
            //

            LockGlobals();
            if ( !LookupFullyQualifiedCredential(
                                    wszServiceName,
                                    LocalIpAddr,
                                    lstrlen(LocalIpAddr),
                                    LocalPort,
                                    lstrlen(LocalPort),
                                    lpvInstance,
                                    (CRED_CACHE_ITEM**)&m_phCreds,
                                    m_psmcMapContext,
                                    dwInstance ))
            {
                ErrorTrace( (LPARAM)this,
                            "LookupCredential failed, error 0x%lx",
                            GetLastError() );

                UnlockGlobals();
                goto error_exit;
            }
            UnlockGlobals();

        }

        //
        // run thru all initialized credentials look for a package which
        // will accept this connection
        //
        CRED_CACHE_ITEM*    phCreds = (CRED_CACHE_ITEM*)m_phCreds;

        //
        //  For server: Need to use SSL access perms
        //  to figure out whether to use CredMap or Cred
        //

        if( !m_IsClient && (m_dwSslAccessPerms & MD_ACCESS_MAP_CERT) )
        {
            cbCreds = phCreds->m_cCredMap;
            pCredArray = phCreds->m_ahCredMap;
        } else {
            cbCreds = phCreds->m_cCred;
            pCredArray = phCreds->m_ahCred;
        }
    }
    else
    {
        //
        // hack to only allow one pass thru the loop
        //
        cbCreds = 1;
        pCredArray = m_phCredInUse;
    }

    //
    // Do the conversation
    //

    for ( i=0; i<cbCreds; i++, pCredArray++ )
    {
        if ( EncryptConverse(InBuffer,
                            InBufferSize,
                            OutBuffer,
                            OutBufferSize,
                            MoreBlobsExpected,
                            pCredArray,
                            pcbExtra ) )
        {
            if ( m_IsNewSSLSession )
            {
                //
                // if the first time remember which credential succeeded.
                //
                m_phCredInUse = pCredArray;
                m_iCredInUse = i;

                m_IsNewSSLSession = FALSE;
            }
            return  NO_ERROR;
        }
    }

    //
    // We failed
    //

error_exit:

    if(OutBuffer)
        *OutBuffer = 0;

    if(OutBufferSize)
        *OutBufferSize = 0;

    DWORD   error = GetLastError();

    if ( error == NO_ERROR ) {
        error = ERROR_ACCESS_DENIED;
    }
    return  error;

} // Converse



//+---------------------------------------------------------------
//
//  Function:   DecryptInputBuffer
//
//  Synopsis:   decrypted input read from the client
//
//  Arguments:  pBuffer:        ptr to the input/output buffer
//              cbInBuffer:     initial input length of the buffer
//              pcbOutBuffer:   total length of decrypted/remaining
//                              data. pcbOutBuffer - pcbParsable is
//                              the length of offset for next read
//              pcbParsable:    length of decrypted data
//              pcbExpected:    length of remaining unread data for
//                              full SSL message
//
//  Returns:    DWORD   Win32/SSPI error core
//
//----------------------------------------------------------------
DWORD CEncryptCtx::DecryptInputBuffer(
                IN LPBYTE   pBuffer,
                IN DWORD    cbInBuffer,
                OUT DWORD*  pcbOutBuffer,
                OUT DWORD*  pcbParsable,
                OUT DWORD*  pcbExpected
            )
{
    LPBYTE  pDecrypted;
    DWORD   cbDecrypted;
    DWORD   cbParsable = 0;
    LPBYTE  pNextSeal;
    LPBYTE  pStartBuffer = pBuffer;
    BOOL    fRet;

    //
    // initialize to zero so app does not inadvertently post large read
    //
    *pcbExpected = 0;

    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::DecryptInputBuffer" );

    while( fRet = UnsealMessage(pBuffer,
                                cbInBuffer,
                                &pDecrypted,
                                &cbDecrypted,
                                pcbExpected,
                                &pNextSeal ) )
    {
        DebugTrace( (LPARAM)this,
                    "Decrypted %d bytes at offset %d",
                    cbDecrypted,
                    pDecrypted - pStartBuffer );

        //
        // move the decrypted data to the front of buffer
        //
        MoveMemory( pStartBuffer + cbParsable,
                    pDecrypted,
                    cbDecrypted );

        //
        // increment where the next parsing should take place
        //
        cbParsable += cbDecrypted;

        //
        // move to the next potential seal buffer
        //
        if ( pNextSeal != NULL )
        {
            _ASSERT( pNextSeal >= pStartBuffer );
            _ASSERT( pNextSeal <= pBuffer + cbInBuffer );
            //
            // remove header, body and trailer from input buffer length
            //
            cbInBuffer -= (DWORD)(pNextSeal - pBuffer);
            pBuffer = pNextSeal;
        }
        else
        {
            //
            // in this case we received a seal message at the boundary
            // of the IO buffer
            //
            cbInBuffer = 0;
            break;
        }
    }

    *pcbParsable = cbParsable;
    *pcbOutBuffer= cbParsable + cbInBuffer;

    if ( fRet == FALSE )
    {
        DWORD   dwError = GetLastError();

        DebugTrace( (LPARAM)this,
                    "UnsealMessage returned: 0x%08X",
                    GetLastError() );

        //
        // deal with seal fragments at the end of the IO buffer
        //
        if ( dwError == SEC_E_INCOMPLETE_MESSAGE )
        {
            _ASSERT( cbInBuffer != 0 );

            //
            // move the remaining memory forward
            //
            MoveMemory( pStartBuffer + cbParsable,
                        pBuffer,
                        cbInBuffer );

            DebugTrace( (LPARAM)this,
                        "Seal fragment remaining: %d bytes",
                        cbInBuffer );
        }
        else
        {
            return  dwError;
        }
    }

    return  NO_ERROR;
}



//+---------------------------------------------------------------
//
//  Function:   IsEncryptionPermitted
//
//  Synopsis:   This routine checks whether encryption is getting
//              the system default LCID and checking whether the
//              country code is CTRY_FRANCE.
//
//  Arguments:  void
//
//  Returns:    BOOL: supported
//
//----------------------------------------------------------------
BOOL
IsEncryptionPermitted(void)
{
    LCID    DefaultLcid;
    CHAR    CountryCode[10];
    CHAR    FranceCode[10];

    DefaultLcid = GetSystemDefaultLCID();

    //
    // Check if the default language is Standard French
    //

    if ( LANGIDFROMLCID( DefaultLcid ) == 0x40c )
    {
        return  FALSE;
    }

    //
    // Check if the users's country is set to FRANCE
    //

    if ( GetLocaleInfo( DefaultLcid,
                        LOCALE_ICOUNTRY,
                        CountryCode,
                        sizeof(CountryCode) ) == 0 )
    {
        return  FALSE;
    }

    wsprintf( FranceCode, "%d", CTRY_FRANCE );

    //
    // if the country codes matches France return FALSE
    //
    return  lstrcmpi( CountryCode, FranceCode ) == 0 ? FALSE : TRUE ;
}



//+---------------------------------------------------------------
//
//  Function:   GetAdminInfoEncryptCaps
//
//  Synopsis:   sets the magical buts to send the IIS admin program
//
//  Arguments:  PDWORD: ptr to the dword bitmask
//
//  Returns:    void
//
//----------------------------------------------------------------
VOID CEncryptCtx::GetAdminInfoEncryptCaps( PDWORD pdwEncCaps )
{
    *pdwEncCaps = 0;

    if ( m_IsSecureCapable == FALSE )
    {
        *pdwEncCaps |= (IsEncryptionPermitted() ?
                        ENC_CAPS_NOT_INSTALLED :
                        ENC_CAPS_DISABLED );
    }
    else
    {
        //
        // for all enabled encryption providers set the flags bit
        //
        for ( int j = 0; EncProviders[j].pszName != NULL; j++ )
        {
            if ( TRUE == EncProviders[j].fEnabled )
            {
                *pdwEncCaps |= EncProviders[j].dwFlags;
            }
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// From here to the end of the file is code stolen from the Athena group from
// the file called thorsspi.cpp
//
// minor mods have been made to incorporate msntrace functionality and to
// fit in the CEncryptCtx class definition
//

/////////////////////////////////////////////////////////////////////////////
//
// CompareDNStoCommonName()
//
// Description:
//  Compare a DNS name to a common name field value
//
// Parameters:
//  pDNS - string containing DNS name - *WARNING* will be munged
//  pCN  - string containing common name field value
//
// Return:
//  TRUE if they match
//
// Comments:
//  There are two ways for these two strings to match. The first is that
//  they contain exactly the same characters. The second involved the use
//  of a single wildcard character in the common name field value. This
//  wildcard character ('*') can only be used once, and if used must be
//  the first character of the field.
//
// ASSUMES: the caller will allow pDNS and pCN to be uppercased and changed.
//
BOOL CompareDNStoCommonName(LPSTR pDNS, LPSTR pCN)
{
    int nCountPeriods = 1;  // start of DNS amount to virtual '.' as prefix
    BOOL fExactMatch = TRUE;
    LPSTR pBakDNS = pDNS;
    LPSTR pBakCN = pCN;

    _ASSERT(pDNS);
    _ASSERT(pCN);

    CharUpper(pDNS);
    CharUpper(pCN);

    while ((*pDNS == *pCN || *pCN == '*') && *pDNS && *pCN)
        {
        if (*pDNS != *pCN)
            fExactMatch = FALSE;

        if (*pCN == '*')
            {
            nCountPeriods = 0;
            if (*pDNS == '.')
                pCN++;
            else
                pDNS++;
            }
        else
            {
            if (*pDNS == '.')
                nCountPeriods++;
            pDNS++;
            pCN++;
            }
        }

    // if they are sized 0, we make sure not to say they match.
    if (pBakDNS == pDNS || pBakCN == pCN)
        fExactMatch = FALSE;

    return (*pDNS == 0) && (*pCN == 0) && ((nCountPeriods >= 2) || fExactMatch);
}

/////////////////////////////////////////////////////////////////////////////
//
// CompareDNStoMultiCommonName()
//
// Description:
//  Compare a DNS name to a comma delimited list of common name fields.
//
// Parameters:
//  pDNS - string containing DNS name - *WARNING* will munge
//  pCN  - string containing common name field value - *WARNING* will munge
//
// Return:
//  TRUE if they match
//
// ASSUMES: the caller will allow pDNS and pCN to be uppercased and changed.
//
BOOL CompareDNStoMultiCommonName(LPSTR pDNS, LPSTR pCN)
{
    LPSTR pComma;
    LPSTR lpszCommonName;
    BOOL retval = FALSE;    // assume we won't find a match
    BOOL done = FALSE;      // assume we're not done

    lpszCommonName = pCN;

    do {
        // If there is a space, turn it into a null terminator to isolate the first
        // DNS name in the string
        lpszCommonName = strstr(lpszCommonName, "CN=");

        if (lpszCommonName)
            {
            // jump past "CN=" string
            lpszCommonName += 3;

            pComma = strchr(lpszCommonName, ',');
            if (pComma)
                *pComma = 0;

            // See if this component is a match
            retval = CompareDNStoCommonName(pDNS, lpszCommonName);

            // Now restore the comma (if any) that was overwritten
            if (pComma)
                {
                *pComma = ',';
                lpszCommonName = pComma + 1;
                }
            else
                {
                // If there were no more commas, then we're done
                done = TRUE;
                }
            }
        } while (!retval && !done && lpszCommonName && *lpszCommonName);

    return retval;
}

//-----------------------------------------------------------------------------
//  Description:
//      This function checks if pDns is a subdomain of pCn.
//      Basic rule: A wildcard character '*' at the beginning of a DNS name
//      matches any number of components. i.e. a wildcard implies that we will
//      match all subdomains of a given domain.
//
//          microsoft.com == microsoft.com
//          *.microsoft.com == microsoft.com
//          *.microsoft.com == foo.microsoft.com
//          *.microsoft.com == foo.bar.microsoft.com
//
//      Note that the arguments are modified (converted to uppercase).
//  Arguments:
//      pDns - DNS name to which we are trying to connect
//      pCn - Common name in certificate
//  Returns:
//      TRUE if subdomain, FALSE otherwise
//-----------------------------------------------------------------------------
BOOL MatchSubDomain (LPSTR pDns, LPSTR pCn)
{
    LPSTR pCnBegin = NULL;
    int cbDns = 0;
    int cbCn = 0;

    _ASSERT (pDns);
    _ASSERT (pCn);

    CharUpper(pDns);
    CharUpper(pCn);

    cbDns = lstrlen (pDns);
    cbCn = lstrlen (pCn);

    //  check if we have an initial wildcard: this is only allowed as "*.restofdomain"
    if (cbCn >= 2 && *pCn == '*') {
        pCn++;  //  we have a wildcard, try to get parent domain
        if (*pCn != '.')
            return FALSE;   //  Bad syntax, '.' must follow wildcard
        else
            pCn++;  //  Skip wildcard, get to parent domain part

        cbCn -= 2;  //  Update string length
    }

    if (cbDns < cbCn)   //  subdomains must be >= parent domains in length
        return FALSE;

    //
    //  If subdomain is > parent domain, verify that there is a '.' between
    //  the subdomain part and parent domain part. This is to guard from matching
    //  *.microsoft.com with foobarmicrosoft.com since all we do after this
    //  line of code is check that the parent is a substring of the subdomain
    //  at the end.
    //
    if (cbDns != cbCn && pDns[cbDns - cbCn - 1] != '.')
        return FALSE;

    pCnBegin = pCn;
    pCn += cbCn;
    pDns += cbDns;

    //  Walk backwards doing matching
    for (; pCnBegin <= pCn && *pCn == *pDns; pCn--, pDns--);

    //
    //  Check if we terminated without a mismatch,
    //
    return (pCnBegin > pCn);
}

#define CompareCertTime(ft1, ft2)   (((*(LONGLONG *)&ft1) > (*(LONGLONG *)&ft2))                    \
                                        ? 1                                                         \
                                        : (((*(LONGLONG *)&ft1) == (*(LONGLONG *)&ft2)) ? 0 : -1 ))



//+---------------------------------------------------------------
//
//  Function:   CheckCertificateCommonName
//
//  Synopsis:   verifies the intended host name matches the
//              the name contained in the certificate
//  This function, checks a given hostname against the current certificate
//  stored in an active SSPI Context Handle. If the certificate containts
//  a common name, and it matches the passed in hostname, this function
//  will return TRUE
//
//  Arguments:  IN LPSTR: DNS host name
//
//  Returns:    BOOL
//
//----------------------------------------------------------------
BOOL CEncryptCtx::CheckCertificateCommonName( IN LPSTR pszHostName )
{
    DWORD               dwErr;
    BOOL                fIsCertGood = FALSE;
    SecPkgContext_Names CertNames;

    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::CheckCertificateCommonName" );

    CertNames.sUserName = NULL;

    if ( !pszHostName )
    {
        goto quit;
    }

    dwErr = g_QueryContextAttributes(&m_hSealCtxt,
                                    SECPKG_ATTR_NAMES,
                                    (PVOID)&CertNames);
    if (dwErr != ERROR_SUCCESS)
    {
        ErrorTrace( (LPARAM)this,
                    "QueryContextAttributes failed to retrieve CN, returned %#x",
                    dwErr );
        goto quit;
    }

    DebugTrace( (LPARAM)this,
                "QueryContextAttributes returned CN=%.200s",
                CertNames.sUserName );

    fIsCertGood = CompareDNStoMultiCommonName(pszHostName, CertNames.sUserName);

quit:
    if ( CertNames.sUserName )
    {
        LocalFree( CertNames.sUserName );
    }

    return fIsCertGood;
}


//-------------------------------------------------------------------------
//  Description:
//      Verifies that the subject of the certificate matches the FQDN of
//      the server we are talking to. Does some wildcard matching if there
//      are '*' characters at the beginning of the cert subject.
//  Arguments:
//      pCtxtHandle The context of an established SSL connection
//      pszServerFqdn FQDN of server to which we are talking (from who we
//          received the certificate).
//  Returns:
//      TRUE match found, FALSE unmatched
//-------------------------------------------------------------------------
BOOL CEncryptCtx::CheckCertificateSubjectName (IN LPSTR pszServerFqdn)
{
    CHAR pszSubjectStackBuf[256];
    LPSTR pszSubject = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cSize = 0;
    DWORD cSubject = 0;
    BOOL fRet = FALSE;

    TraceFunctEnterEx ((LPARAM) this, "CEncryptCtx::VerifySubject");

    _ASSERT (pszServerFqdn);

    dwErr = g_QueryContextAttributes(
                        &m_hSealCtxt,
                        SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                        &pCertContext);

    if (dwErr != SEC_E_OK) {
        StateTrace ((LPARAM) this, "Cannot get Context Handle %x", dwErr);
        goto Exit;
    }

    //
    //  Check the size of the buffer needed, if it's small enough we'll
    //  just use the fixed size stack buffer, otherwise allocate on heap.
    //

    cSize = CertGetNameString (
                    pCertContext,
                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                    0,
                    NULL,
                    NULL,
                    0);

    if (cSize <= sizeof(pszSubjectStackBuf)) {

        pszSubject = pszSubjectStackBuf;
        cSubject = sizeof (pszSubjectStackBuf);

    } else {

        pszSubject = new CHAR [cSize];
        if (NULL == pszSubject) {
            ErrorTrace ((LPARAM) this, "No memory to alloc subject string.");
            goto Exit;
        }
        cSubject = cSize;
    }

    //
    //  Get the subject of the certificate
    //

    cSize = CertGetNameString (
                pCertContext,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                0,
                NULL,
                pszSubject,
                cSubject);

    if (cSize == 1 && pszSubject[0] == '\0') {
        //
        //  If the CERT_NAME_SIMPLE_DISPLAY_TYPE could not be found in the cert,
        //  the API returns a zero length NULL terminated string.
        //
        StateTrace ((LPARAM) this, "Certificate subject not found");
        goto Exit;
    }

    StateTrace ((LPARAM) this, "Certificate subject: %s, FQDN: %s",
        pszSubject, pszServerFqdn);

    if (MatchSubDomain(pszServerFqdn, pszSubject)) {
        //
        //  Certificate matches the server FQDN we're talking to
        //
        fRet = TRUE;
    }

Exit:

    //
    // Delete the Subject buffer if we were using the heap
    //

    if (pszSubject != pszSubjectStackBuf)
        delete [] pszSubject;

    if (pCertContext)
        CertFreeCertificateContext (pCertContext);

    StateTrace ((LPARAM) this, "Returning: %s", fRet ? "TRUE" : "FALSE");
    TraceFunctLeaveEx ((LPARAM) this);
    return fRet;

}

//---------------------------------------------------------------------
//  Description:
//      Checks if the certificate for this CEncryptCtx chains up to a
//      trusted CA.
//  Returns:
//      TRUE if certificate is trusted.
//      FALSE if the certificate is untrusted or if trust could not be
//          verified (temporary errors can cause this).
//  Source:
//      MSDN sample
//---------------------------------------------------------------------
BOOL CEncryptCtx::CheckCertificateTrust ()
{
    BOOL fRet = FALSE;
    DWORD dwErr = SEC_E_OK;
    DWORD dwFlags = 0;
    PCCERT_CONTEXT pCertContext = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    CERT_ENHKEY_USAGE EnhkeyUsage;
    CERT_USAGE_MATCH CertUsage;
    CERT_CHAIN_PARA ChainPara;

    TraceFunctEnterEx ((LPARAM) this, "CEncryptCtx::CheckCertificateTrust");

    dwErr = g_QueryContextAttributes (
                            &m_hSealCtxt,
                            SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                            &pCertContext);


    if (SEC_E_OK != dwErr) {
        ErrorTrace ((LPARAM) this, "g_QueryContextAttributes failed, err - %8x", dwErr);
        fRet = FALSE;
        goto Exit;
    }

    //
    //  ChainPara is a struct used to match specific certificates using OIDs
    //  We don't need this and initialize it to empty (no OIDs)
    //
    EnhkeyUsage.cUsageIdentifier = 0;
    EnhkeyUsage.rgpszUsageIdentifier = NULL;
    CertUsage.dwType = USAGE_MATCH_TYPE_AND;
    CertUsage.Usage  = EnhkeyUsage;
    ChainPara.cbSize = sizeof(CERT_CHAIN_PARA);
    ChainPara.RequestedUsage = CertUsage;

    dwFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN | CERT_CHAIN_CACHE_END_CERT;

    fRet = CertGetCertificateChain (
                            NULL,           //  Use the default chaining engine
                            pCertContext,   //  The end certificate to be checked
                            NULL,           //  Expiration checking... use currenttime
                            NULL,           //  Additional cert stores: none
                            &ChainPara,     //  Chaining criteria: none, this is an empty struct
                            dwFlags,        //  Options: how to check chain
                            NULL,           //  reserved param
                            &pChainContext);//  Returned chain context


    if (!fRet) {
        dwErr = GetLastError ();
        ErrorTrace ((LPARAM) this, "Unable to create certificate chain, err - %8x", dwErr);
        goto Exit;
    }

    DebugTrace ((LPARAM) this, "Status of certificate chain - %8x",
        pChainContext->TrustStatus.dwErrorStatus);

    if (CERT_TRUST_NO_ERROR == pChainContext->TrustStatus.dwErrorStatus) {
        DebugTrace ((LPARAM) this, "Certificate trust verified");
        fRet = TRUE;
    } else {
        ErrorTrace ((LPARAM) this, "Certificate is untrusted, status - %8x",
            pChainContext->TrustStatus.dwErrorStatus);
        fRet = FALSE;
    }

Exit:
    if (pCertContext)
        CertFreeCertificateContext (pCertContext);

    if (pChainContext)
        CertFreeCertificateChain (pChainContext);

    TraceFunctLeaveEx ((LPARAM) this);
    return fRet;
}

//+---------------------------------------------------------------
//
//  Function:   CheckCertificateExpired
//
//  Synopsis:   verifies the ccertificate has not expired
//              returns TRUE if the cert is valid
//
//  Arguments:  void
//
//  Returns:    BOOL cert is good
//
//----------------------------------------------------------------
BOOL CEncryptCtx::CheckCertificateExpired( void )
{
    SYSTEMTIME  st;
    FILETIME    ftCurTime;
    DWORD       dwErr;

    SecPkgContext_Lifespan CertLifeSpan;

    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::CheckCertificateExpired" );

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ftCurTime);

    dwErr = g_QueryContextAttributes(&m_hSealCtxt,
                                    SECPKG_ATTR_LIFESPAN,
                                    (PVOID)&CertLifeSpan);
    if ( dwErr != ERROR_SUCCESS )
    {
        ErrorTrace( (LPARAM)this,
                    "QueryContextAttributes failed to retrieve cert lifespan, returned %#x",
                    dwErr);
        return  FALSE;
    }

    return  CompareCertTime( CertLifeSpan.tsStart, ftCurTime ) < 0 &&
            CompareCertTime( CertLifeSpan.tsExpiry, ftCurTime) > 0 ;
}

//+----------------------------------------------------------------------------
//
//  Function:   CheckServerCert
//
//  Synopsis:   Checks to see if a server cert has been installed.
//
//  Arguments:  [LocalIpAddr] -- IP Address of virtual server
//              [LocalPort] -- Port of virtual server
//              [lpvInstance] -- Pointer to IIS_SERVER_INSTANCE object
//              [dwInstance] -- Virtual server id
//
//  Returns:    TRUE if there is a cert for this virtual server
//
//-----------------------------------------------------------------------------

BOOL CEncryptCtx::CheckServerCert(
            IN LPSTR    LocalIpAddr,
            IN LPSTR    LocalPort,
            IN LPVOID   lpvInstance,
            IN DWORD    dwInstance)
{
    TraceFunctEnterEx( (LPARAM)this, "CEncryptCtx::CheckServerCert" );

    BOOL fRet = FALSE;
    CRED_CACHE_ITEM *pCCI;

    DebugTrace( (LPARAM)this,
                "CheckServerCert for %S on %s",
                wszServiceName, LocalIpAddr );

    //
    //  Get the credentials for this IP address
    //

    LockGlobals();
    if ( fRet = LookupFullyQualifiedCredential(
                            wszServiceName,
                            LocalIpAddr,
                            lstrlen(LocalIpAddr),
                            LocalPort,
                            lstrlen(LocalPort),
                            lpvInstance,
                            &pCCI,
                            m_psmcMapContext,
                            dwInstance ))
    {
        IIS_SERVER_CERT *pCert = pCCI->m_pSslInfo->GetCertificate();
        // Log the status of the cert if we got one
        if ( pCert )
        {
             fRet = TRUE;
        }
        else
            fRet = FALSE;

        pCCI->Release();

    } else {

        ErrorTrace( (LPARAM)this,
                    "LookupCredential failed, error 0x%lx",
                    GetLastError() );

    }

    UnlockGlobals();

    TraceFunctLeave();

    return( fRet );
}

//+---------------------------------------------------------------
//
//  Function:   NotifySslChanges
//
//  Synopsis:   This is called when SSL settings change
//
//  Arguments:  dwNotifyType
//              pInstance
//
//  Returns:    VOID
//
//----------------------------------------------------------------

VOID WINAPI NotifySslChanges(
    DWORD                         dwNotifyType,
    LPVOID                        pInstance
    )
{
    LockGlobals();

    if ( dwNotifyType == SIMSSL_NOTIFY_MAPPER_SSLKEYS_CHANGED )
    {
        FreeCredCache();

        //
        // NB : Under NT 5, the SslEmptyCache function is no longer supported
        //
#if 0
        if ( g_pfnFlushSchannelCache )
        {
            (g_pfnFlushSchannelCache)();
        }
#endif
    }
    else if ( dwNotifyType == SIMSSL_NOTIFY_MAPPER_CERT11_CHANGED ||
              dwNotifyType == SIMSSL_NOTIFY_MAPPER_CERTW_CHANGED )
    {
        FreeCredCache();
    }
    else if ( dwNotifyType == SIMSSL_NOTIFY_MAPPER_CERT11_TOUCHED )
    {
        //
        // NB : Under NT 5, the SslEmptyCache function is no longer supported
        //
#if 0
        if ( g_pfnFlushSchannelCache )
        {
            (g_pfnFlushSchannelCache)();
        }
#endif
        //SSPI_FILTER_CONTEXT::FlushOnDelete();
    }
    else
    {
        _ASSERT( FALSE );
    }

    UnlockGlobals();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\snprfdll\exprfdll.h ===
/*==========================================================================*\

    Module:        exprfdll.h

    Copyright Microsoft Corporation 1998, All Rights Reserved.

    Author:        WayneC

    Descriptions:  This is the declaration for exprfdll, a perf dll. This
                   is for the dll that runs in perfmon. It supports multiple
                   libraries (monitored services.)
    
\*==========================================================================*/

#ifndef _exprfdll_h_
#define _exprfdll_h_

#include "snprflib.h"

///////////////////////////////////////////////////////////////////////////////
//
// Misc defines
//
///////////////////////////////////////////////////////////////////////////////
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
#define QWORD_MULTIPLE(x) (((x+sizeof(QWORD)-1)/sizeof(QWORD))*sizeof(QWORD))
#define MAX_PERF_LIBS 8

#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4


///////////////////////////////////////////////////////////////////////////////
//
// Declare utility functions
//
///////////////////////////////////////////////////////////////////////////////

//
// Figure out the query type of the perf request
//
DWORD GetQueryType (LPWSTR lpValue);

//
// Determines if a number is in a space delimited unicode string.
//   this is used to parse the request to see which object counters are
//   asked for.
//
BOOL IsNumberInUnicodeList (DWORD dwNumber, LPCWSTR lpwszUnicodeList);


///////////////////////////////////////////////////////////////////////////////
//
// PerfObjectData defines the data retrieved from the shared memory for
//      each perf object exposed by a library (see PerfLibraryData below)
//
///////////////////////////////////////////////////////////////////////////////
class PerfObjectData
{   
private:
    //
    // Internal variables
    //
    BOOL                        m_fObjectRequested;
    DWORD                       m_dwSpaceNeeded;
    
    //
    // These are pointers to things inside the shared memory...
    //
    // First the object definition
    PERF_OBJECT_TYPE*           m_pObjType;

    // Array of counter defintions
    PERF_COUNTER_DEFINITION*    m_prgCounterDef;

    // Pointer to a dword that tells the size of the counter data
    //   (PERF_COUNTER_BLOCK + all the counter values)
    DWORD*                      m_pdwCounterData;

    // The following point to the actual data for the counters...
    //   use pCounterBlock for numInst == -1, else use m_pbCounterBlockTotal for
    //   the first instanced counters (_Total)
    PERF_COUNTER_BLOCK*         m_pCounterBlock;
    PBYTE                       m_pbCounterBlockTotal;

    // This points to the first shared memory mapping.
    SharedMemorySegment*        m_pSMS;

    // These tell us how many instances can be stored in each mapping.
    DWORD                       m_dwInstancesPerMapping;
    DWORD                       m_dwInstances1stMapping;

    // This is the length of the object definition in the first mapping.
    DWORD                       m_dwDefinitionLength;

    // Keep the object name around to create more named mappings when needed.
    WCHAR                       m_wszObjectName[MAX_OBJECT_NAME];
    
public:
    PerfObjectData();
    ~PerfObjectData();

    BOOL GetPerformanceStatistics (LPCWSTR pcwstrObjectName);
    DWORD SpaceNeeded (DWORD, LPCWSTR pcwstrObjects);
    void SavePerformanceData (VOID**, DWORD*, DWORD*);
    void ResetTotal (void);
    void AddToTotal (PBYTE pbCounterBlock);
    void Close (void);
};


///////////////////////////////////////////////////////////////////////////////
//
// PerfLibraryData is data from the shared memory about a single perf library.
//
///////////////////////////////////////////////////////////////////////////////
class PerfLibraryData
{
private:    
    //
    // Handle and pointer for the shared memory
    //
    HANDLE              m_hShMem;
    PBYTE               m_pbShMem;

    // Data from the shared memory
    DWORD               m_dwObjects;
    OBJECTNAME*         m_prgObjectNames;

    // Data for each of the objects exposed by the library
    PerfObjectData      m_rgObjectData[MAX_PERF_OBJECTS];

    
public: 
    // Methods for dealing with the library data
    PerfLibraryData();
    ~PerfLibraryData();
    
    BOOL GetPerformanceStatistics (LPCWSTR pcwstrLibrary);
    DWORD SpaceNeeded (DWORD, LPCWSTR pcwstrObjects);
    void SavePerformanceData (VOID**, DWORD*, DWORD*);
    void Close (void);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\snprfdll\exprfdll.cpp ===
/*==========================================================================*\

    Module:        exprfdll.cpp

    Copyright Microsoft Corporation 1998, All Rights Reserved.

    Author:        WayneC

    Descriptions:  This is the implementation for exprfdll, a perf dll. This
                   is for the dll that runs in perfmon. It supports multiple
                   libraries (monitored services.)
    
\*==========================================================================*/

///////////////////////////////////////////////////////////////////////////////
//
// Includes
//
///////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <winperf.h>

#include "snprflib.h"
#include "exprfdll.h"
#include <stdlib.h>
#include "exchmem.h"

///////////////////////////////////////////////////////////////////////////////
//
// Declare Global variables
//
///////////////////////////////////////////////////////////////////////////////
LPCWSTR g_wszPrefixGlobal = L"Global\\";
WCHAR   g_rgszLibraries[MAX_PERF_LIBS][MAX_PERF_NAME];  // Names of the libraries we are monitoring
BOOL    g_rgfInitOk[MAX_PERF_LIBS] = {FALSE};           // Flags to indicate if initialization was a success

// index for g_rgszLibraries & g_rgfInitOk
enum LibIndex
{
    LIB_NTFSDRV = 0
};


///////////////////////////////////////////////////////////////////////////////
//
// Forward declaration of shared memory functions.
//
///////////////////////////////////////////////////////////////////////////////
BOOL FOpenFileMapping (SharedMemorySegment * pSMS,
                       LPCWSTR pcwstrInstanceName,
                       DWORD   dwIndex);

void CloseFileMapping (SharedMemorySegment * pSMS);


///////////////////////////////////////////////////////////////////////////////
//
// PerfLibraryData class implementation
//
///////////////////////////////////////////////////////////////////////////////
PerfLibraryData::PerfLibraryData()
{
    m_hShMem    = 0;
    m_pbShMem   = 0;
    m_dwObjects = 0;
}

PerfLibraryData::~PerfLibraryData()
{
    Close();
}

BOOL PerfLibraryData::GetPerformanceStatistics (LPCWSTR pcwstrLibrary)
{
    BOOL  fRet = FALSE;
    DWORD i = 0;

    //
    // Open the mapping for the perf library information
    //
    m_hShMem = OpenFileMappingW (FILE_MAP_READ, FALSE, pcwstrLibrary);
    if (!m_hShMem)
        goto Exit;

    m_pbShMem = (BYTE*) MapViewOfFile (m_hShMem, FILE_MAP_READ, 0, 0, 0);
    if (!m_pbShMem)
        goto Exit;

    //
    // Get the number of objects in the shared memory
    //
    m_dwObjects = *(DWORD*) m_pbShMem;
    m_prgObjectNames = (OBJECTNAME*) (m_pbShMem + sizeof(DWORD));

    //
    // Loop through objects and get perf data for each
    //
    for (i = 0; i < m_dwObjects; i++)
        m_rgObjectData[i].GetPerformanceStatistics (m_prgObjectNames[i]);

    fRet = TRUE;

Exit:
    if (!fRet)
    {
        if (m_pbShMem)
        {
            UnmapViewOfFile ((PVOID)m_pbShMem);
            m_pbShMem = NULL;
        }

        if (m_hShMem)
        {
            CloseHandle (m_hShMem);
            m_hShMem = NULL;
        }
    }

    return fRet;
}

VOID PerfLibraryData::Close (VOID)
{
    if (m_pbShMem)
    {
        UnmapViewOfFile ((PVOID) m_pbShMem);
        m_pbShMem = 0;
    }
    
    if (m_hShMem)
    {
        CloseHandle (m_hShMem);
        m_hShMem = 0;
    }
    
    for (DWORD i = 0; i < m_dwObjects; i++)
        m_rgObjectData[i].Close();
}

DWORD PerfLibraryData::SpaceNeeded (DWORD dwQueryType, LPCWSTR lpwstrObjects)
{
    DWORD dwSpaceNeeded = 0;

    for (DWORD i = 0; i < m_dwObjects; i++)
        dwSpaceNeeded += m_rgObjectData[i].SpaceNeeded (dwQueryType, lpwstrObjects);

    return dwSpaceNeeded;
}

VOID PerfLibraryData::SavePerformanceData (PVOID* ppv, DWORD* pdwBytes, DWORD* pdwObjects )
{
    for (DWORD i = 0; i < m_dwObjects; i++)
        m_rgObjectData[i].SavePerformanceData (ppv, pdwBytes, pdwObjects);
}


///////////////////////////////////////////////////////////////////////////////
//
// PerfObjectData class implementation
//
///////////////////////////////////////////////////////////////////////////////
PerfObjectData::PerfObjectData()
{
    m_fObjectRequested = FALSE;
    m_dwSpaceNeeded = 0;
    m_pSMS = NULL;
    m_wszObjectName[0] = L'\0';
}

PerfObjectData::~PerfObjectData()
{
    Close();
}

BOOL PerfObjectData::GetPerformanceStatistics (LPCWSTR pcwstrObjectName)
{
    DWORD dwPerInstanceData  = 0;
    DWORD dwShmemMappingSize = SHMEM_MAPPING_SIZE;
    BOOL  fSuccess = FALSE;

    // Remember the object name
    wcsncpy (m_wszObjectName, pcwstrObjectName, MAX_OBJECT_NAME);
    m_wszObjectName[MAX_OBJECT_NAME-1] = L'\0';     // Ensure NULL Terminated

    // Open the 1st shared memory segment
    m_pSMS = new SharedMemorySegment;
    if (!m_pSMS)
        goto Exit;

    if (!FOpenFileMapping (m_pSMS, pcwstrObjectName, 0))
        goto Exit;

    // First in the shared memory is the PERF_OBJECT_TYPE
    m_pObjType = (PERF_OBJECT_TYPE*) m_pSMS->m_pbMap;
    
    // Then an array of PERF_COUNTER_DEFINITION
    m_prgCounterDef = (PERF_COUNTER_DEFINITION*) (m_pObjType + 1);

    // Then a DWORD that tells the size of each counter block
    m_pdwCounterData = (DWORD*) (m_pSMS->m_pbMap + sizeof(PERF_OBJECT_TYPE) +
                                (m_pObjType->NumCounters * sizeof(PERF_COUNTER_DEFINITION)));

    if (m_pObjType->NumInstances == PERF_NO_INSTANCES)
    {
        m_pCounterBlock = (PERF_COUNTER_BLOCK*) (m_pdwCounterData+1);
        m_pbCounterBlockTotal = NULL;
    }
    else
    {
        m_pCounterBlock = NULL;
        m_pbCounterBlockTotal = (PBYTE)(m_pdwCounterData+1) + sizeof(INSTANCE_DATA);
    }

    // Compute the size of per instance data & object definition.
    dwPerInstanceData = sizeof(INSTANCE_DATA) + *m_pdwCounterData;
    m_dwDefinitionLength = sizeof(PERF_OBJECT_TYPE) + 
                           m_pObjType->NumCounters * sizeof(PERF_COUNTER_DEFINITION) + sizeof(DWORD);

    // Make sure our memory mapping is large enough.
    while (dwShmemMappingSize < dwPerInstanceData || dwShmemMappingSize < m_dwDefinitionLength)
        dwShmemMappingSize *= 2;

    // Compute the number of instances can be stored in one shmem mapping.
    m_dwInstancesPerMapping = (DWORD)(dwShmemMappingSize / dwPerInstanceData);
    m_dwInstances1stMapping = (DWORD)((dwShmemMappingSize - m_dwDefinitionLength) / dwPerInstanceData);

    fSuccess = TRUE;

Exit:
    if (!fSuccess && m_pSMS)
    {
        CloseFileMapping (m_pSMS);
        delete m_pSMS;
        m_pSMS = NULL;
    }

    return fSuccess;
}

VOID PerfObjectData::Close (VOID)
{
    SharedMemorySegment *pSMS, *pSMSNext;

    pSMS = m_pSMS;
    m_pSMS = NULL;

    while (pSMS)
    {
        pSMSNext = pSMS->m_pSMSNext;
        CloseFileMapping (pSMS);
        delete pSMS;
        pSMS = pSMSNext;
    }
}

DWORD PerfObjectData::SpaceNeeded (DWORD dwQueryType, LPCWSTR lpwstrObjects)
{
    DWORD dwSpaceNeeded = 0;
    
    if (dwQueryType == QUERY_GLOBAL ||
        IsNumberInUnicodeList (m_pObjType->ObjectNameTitleIndex, lpwstrObjects))
    {
        // Remember for later that this object was requested. 
        m_fObjectRequested = TRUE;

        // Compute space needed... always need enough for the object def. and
        // all the counter defs
        dwSpaceNeeded = sizeof(PERF_OBJECT_TYPE) + (m_pObjType->NumCounters * sizeof(PERF_COUNTER_DEFINITION));

        // It is a bit different depending on if there are multiple instances
        if( m_pObjType->NumInstances != PERF_NO_INSTANCES )
        {
            // If multi-instance, we have one instance def, one instance name
            // plus the counter data for each instance
            dwSpaceNeeded += m_pObjType->NumInstances * (sizeof(PERF_INSTANCE_DEFINITION) + 
                sizeof(INSTANCENAME) + *m_pdwCounterData);
        }
        else
        {
            // Else we just have the counter data
            dwSpaceNeeded += *m_pdwCounterData;
        }
    }

    m_dwSpaceNeeded = dwSpaceNeeded;
    
    return dwSpaceNeeded;
}

void PerfObjectData::SavePerformanceData (VOID** ppv, DWORD* pdwBytes, DWORD* pdwObjects)
{
    BYTE*                pb;
    INSTANCE_DATA*       pInst;
    DWORD                dwBytes = 0;
    PERF_OBJECT_TYPE*    pobj;
    PERF_COUNTER_BLOCK*  pcb;
    SharedMemorySegment* pSMS        = NULL;
    SharedMemorySegment* pSMSNext    = NULL;
    DWORD                dwMapping   = 0;
    DWORD                dwInstances = 0;
    DWORD                dwInstIndex = 0;
    BYTE*                pbTotal     = NULL;
    INSTANCE_DATA*       pInstTotal  = NULL;
    DWORD                dwInstancesCopied = 0;
    
    //
    // If this object wasn't requested (as determined by SpaceNeeded()), then
    // we don't do anything.
    //
    if (!m_fObjectRequested)
        return;

    // Get pointer to output buffer
    pb = (BYTE*) *ppv ;

    //
    // Copy the performance data to the output buffer
    //

    // Copy a PERF_OBJECT_TYPE structure
    CopyMemory (pb, m_pObjType, sizeof(PERF_OBJECT_TYPE));
    pobj = (PERF_OBJECT_TYPE*) pb;

    pb += sizeof(PERF_OBJECT_TYPE);
    dwBytes += sizeof(PERF_OBJECT_TYPE);

    // Copy the counter definitions
    CopyMemory (pb, m_prgCounterDef, pobj->NumCounters * sizeof(PERF_COUNTER_DEFINITION));
    
    pb += pobj->NumCounters * sizeof(PERF_COUNTER_DEFINITION) ;
    dwBytes += pobj->NumCounters * sizeof(PERF_COUNTER_DEFINITION) ;

    if (pobj->NumInstances == PERF_NO_INSTANCES)
    {
        // Copy the counter block
        CopyMemory (pb, m_pCounterBlock, *m_pdwCounterData);

        // Fixup the length, because when no instances have been created it
        //  will not be correct.
        pcb = (PERF_COUNTER_BLOCK*) pb;
        pcb->ByteLength = *m_pdwCounterData;
        
        pb += *m_pdwCounterData;
        dwBytes += *m_pdwCounterData;
    }
    else
    {
        // Reset the counters in _Total
        ResetTotal ();

        // Enumerate through all the instances and copy them out
        pSMS = m_pSMS;
        dwInstancesCopied = 0;

        for (dwMapping = 0; ; dwMapping++)
        {
            if (0 == dwMapping)
            {
                //
                // If this is the 1st mapping, we have to offset pInst by m_dwDefinitionLength.
                //
                pInst = (INSTANCE_DATA*)((char *)(pSMS->m_pbMap) + m_dwDefinitionLength);
                dwInstances = m_dwInstances1stMapping;
            }
            else
            {
                //
                // Otherwise, open the next memory mapping and point pInst to the begging of that mapping.
                //
                pSMSNext = new SharedMemorySegment;
                if (!pSMSNext)
                    goto Exit;

                if (!FOpenFileMapping (pSMSNext, m_wszObjectName, dwMapping))
                    goto Exit;

                pSMS->m_pSMSNext = pSMSNext;
                pSMS = pSMSNext;

                pInst = (INSTANCE_DATA*)(pSMS->m_pbMap);
                dwInstances = m_dwInstancesPerMapping;
            }

            for (dwInstIndex = 0;
                 dwInstIndex < dwInstances && dwInstancesCopied < (DWORD) (pobj->NumInstances);
                 dwInstIndex++)
            {
                if (pInst->fActive)
                {
                    //
                    // Sum up the each counter and store it in _Total
                    //
                    if (0 == dwInstancesCopied)
                    {
                        // If this is _Total, simply remember the pointers without adding to itself.
                        pbTotal = pb;
                        pInstTotal = pInst;
                    }
                    else
                    {
                        // Otherwise, add the counter value to _Total.
                        AddToTotal ((PBYTE)pInst + sizeof(INSTANCE_DATA));
                        CopyMemory (pb, ((char*)pInst) + sizeof(BOOL),
                                    sizeof(PERF_INSTANCE_DEFINITION) +
                                    sizeof(INSTANCENAME) + *m_pdwCounterData);
                    }

                    
                    pb += sizeof(PERF_INSTANCE_DEFINITION) +
                        sizeof(INSTANCENAME) + *m_pdwCounterData;

                    dwBytes += sizeof(PERF_INSTANCE_DEFINITION) +
                        sizeof(INSTANCENAME) + *m_pdwCounterData;

                    dwInstancesCopied++;
                }

                pInst = (INSTANCE_DATA*)(((char*)pInst) + sizeof(INSTANCE_DATA) + *m_pdwCounterData);
            }

            //
            // After copying all the instances, copy the _Total instance.
            //
            if (dwInstancesCopied >= (DWORD) (pobj->NumInstances) && pbTotal && pInstTotal)
            {
                CopyMemory (pbTotal, ((char*)pInstTotal + sizeof(BOOL)),
                            sizeof(PERF_INSTANCE_DEFINITION) +
                            sizeof(INSTANCENAME) + *m_pdwCounterData);
                break;
            }
        }
    }

    // Update parameters in the output buffer
    pobj->TotalByteLength = dwBytes;

Exit:
    // Update buffer pointer, count of bytes and count of objects.
    *ppv = (void*) pb;
    *pdwBytes += dwBytes;
    (*pdwObjects)++;
}

void PerfObjectData::ResetTotal (void)
{
    ZeroMemory ((PVOID)(m_pbCounterBlockTotal + sizeof(PERF_COUNTER_BLOCK)), *m_pdwCounterData - sizeof(PERF_COUNTER_BLOCK));
}

void PerfObjectData::AddToTotal (PBYTE pbCounterData)
{
    DWORD i;
    PBYTE pbTotalCounter = m_pbCounterBlockTotal + sizeof(PERF_COUNTER_BLOCK);
    PBYTE pbInstCounter  = pbCounterData + sizeof(PERF_COUNTER_BLOCK);

    for (i = 0; i < m_pObjType->NumCounters; i++)
    {
        // Offset pointers to the first byte of the actual counter
        pbTotalCounter = m_pbCounterBlockTotal + m_prgCounterDef[i].CounterOffset;
        pbInstCounter = pbCounterData + m_prgCounterDef[i].CounterOffset;

        // If this is a 'rate' counter, it is referencing some other 'raw' counter.
        // In this case, we should not add that raw counter again.
        if ((m_prgCounterDef[i].CounterType & PERF_TYPE_COUNTER) &&
            (m_prgCounterDef[i].CounterType & PERF_COUNTER_RATE))
            continue;

        /* we only have LARGE_INTEGER and DWORD counters as of PT 3728 */
        if ((m_prgCounterDef[i].CounterType & PERF_TYPE_NUMBER) &&
            (m_prgCounterDef[i].CounterType & PERF_SIZE_LARGE))
        {
            ((LARGE_INTEGER*)pbTotalCounter)->LowPart  += ((LARGE_INTEGER*)pbInstCounter)->LowPart;
            ((LARGE_INTEGER*)pbTotalCounter)->HighPart += ((LARGE_INTEGER*)pbInstCounter)->LowPart;
        }
        else
        {
            *(DWORD*)pbTotalCounter += *(DWORD*)pbInstCounter;
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// Shared Memory Functions
//
///////////////////////////////////////////////////////////////////////////////

BOOL FOpenFileMapping (SharedMemorySegment * pSMS,
                       LPCWSTR pcwstrInstanceName,
                       DWORD   dwIndex)
{
    WCHAR  pwstrShMem[MAX_PATH];
    WCHAR  pwstrIndex[MAX_PATH];
    HANDLE hMap     = NULL;
    PVOID  pvMap    = NULL;
    BOOL   fSuccess = FALSE;

    if (!pSMS)
        goto Exit;

    pSMS->m_hMap     = NULL;
    pSMS->m_pbMap    = NULL;
    pSMS->m_pSMSNext = NULL;

    _ultow (dwIndex, pwstrIndex, 16);

    if (wcslen (g_wszPrefixGlobal) + wcslen (pcwstrInstanceName) + wcslen (pwstrIndex) >= MAX_PATH)
        goto Exit;

    wcscpy (pwstrShMem, g_wszPrefixGlobal);
    wcscat (pwstrShMem, pcwstrInstanceName);
    wcscat (pwstrShMem, pwstrIndex);

    hMap = OpenFileMappingW (FILE_MAP_WRITE, FALSE, pwstrShMem);
    if (!hMap)
        goto Exit;

    pvMap = MapViewOfFile (hMap, FILE_MAP_WRITE, 0, 0, 0);
    if (!pvMap)
        goto Exit;

    pSMS->m_hMap  = hMap;
    pSMS->m_pbMap = (BYTE *)pvMap;

    fSuccess = TRUE;

Exit:
    if (!fSuccess)
    {
        if (pvMap)
            UnmapViewOfFile (pvMap);

        if (hMap)
            CloseHandle (hMap);
    }

    return fSuccess;
}


void CloseFileMapping (SharedMemorySegment * pSMS)
{
    if (pSMS)
    {
        if (pSMS->m_pbMap)
        {
            UnmapViewOfFile ((PVOID)pSMS->m_pbMap);
            pSMS->m_pbMap = NULL;
        }

        if (pSMS->m_hMap)
        {
            CloseHandle (pSMS->m_hMap);
            pSMS->m_hMap = NULL;
        }

        pSMS->m_pSMSNext = NULL;
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// Utility Functions
//
///////////////////////////////////////////////////////////////////////////////
//
// IsPrefix()
//      returns TRUE if s1 is a prefix of s2
//
BOOL
IsPrefix (WCHAR* s1, WCHAR* s2)
{
    while (*s1 && *s2)
    {
        if (*s1++ != *s2++)
        {
            return FALSE;
        }
    }

    return (*s1 == 0);
}



//
// GetQueryType()
//
//    returns the type of query described in the lpValue string so that
//    the appropriate processing method may be used
//
// Return Value
// 
//     QUERY_GLOBAL
//         if lpValue == 0 (null pointer)
//            lpValue == pointer to Null string
//            lpValue == pointer to "Global" string
// 
//     QUERY_FOREIGN
//         if lpValue == pointer to "Foreign" string
// 
//     QUERY_COSTLY
//         if lpValue == pointer to "Costly" string
// 
//     otherwise:
// 
//     QUERY_ITEMS
//
DWORD GetQueryType (LPWSTR lpValue)
{
    if (lpValue == 0 || *lpValue == 0 || IsPrefix( L"Global", lpValue))
        return QUERY_GLOBAL;
    else if (IsPrefix (L"Foreign", lpValue))
        return QUERY_FOREIGN;
    else if (IsPrefix (L"Costly" , lpValue))
        return QUERY_COSTLY;
    else
        return QUERY_ITEMS;
}


int inline EvalThisChar (WCHAR c, WCHAR d)
{
    if (c == d || c == L'\0')
        return DELIMITER;
    else if (L'0' <= c && c <= L'9')
        return DIGIT;
    else
        return INVALID;
}


BOOL IsNumberInUnicodeList (DWORD dwNumber, LPCWSTR lpwszUnicodeList)
{
    DWORD   dwThisNumber = 0;
    const WCHAR* pwcThisChar = lpwszUnicodeList;
    BOOL    bValidNumber = FALSE;
    BOOL    bNewItem = TRUE;
    WCHAR   wcDelimiter = L' ';

    // If null pointer, number not found
    if (lpwszUnicodeList == 0)
        return FALSE;

    //
    // Loop until done...
    //
    for(;;)
    {
        switch (EvalThisChar(*pwcThisChar, wcDelimiter))
        {           
        case DIGIT:         
            //
            // If this is the first digit after a delimiter, then 
            // set flags to start computing the new number
            //
            if (bNewItem)
            {
                bNewItem = FALSE;
                bValidNumber = TRUE;
            }
            if (bValidNumber) 
            {
                dwThisNumber *= 10;
                dwThisNumber += (*pwcThisChar - L'0');
            }
            break;

        case DELIMITER:         
            //
            // A delimiter is either the delimiter character or the 
            // end of the string ('\0') if when the delimiter has been
            // reached a valid number was found, then compare it to the
            // number from the argument list. if this is the end of the
            // string and no match was found, then return.
            //
            if (bValidNumber)
            {
                if (dwThisNumber == dwNumber)
                    return TRUE;
                bValidNumber = FALSE;
            }
            
            if (*pwcThisChar == 0)
            {
                return FALSE;
            }
            else
            {
                bNewItem = TRUE;
                dwThisNumber = 0;
            }
            
            break;
            
        case INVALID:
            //
            // If an invalid character was encountered, ignore all
            // characters up to the next delimiter and then start fresh.
            // the invalid number is not compared.
            //          
            bValidNumber = FALSE;
            break;
            
        default:
            break;          
        }
        
        pwcThisChar++;
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// Utility functions called by the exported perfmon APIs
//
///////////////////////////////////////////////////////////////////////////////

DWORD Open (LibIndex iLib, LPCWSTR  pcwstrLib)
{
    HANDLE hMHeap = NULL;

    hMHeap = ExchMHeapCreate (0, 0, 100 * 1024, 0);
    if (NULL == hMHeap)
        goto Exit;

    lstrcpyW (g_rgszLibraries[iLib], g_wszPrefixGlobal);
    lstrcatW (g_rgszLibraries[iLib], pcwstrLib);
    g_rgfInitOk[iLib] = TRUE;

Exit:
    return ERROR_SUCCESS;
}

DWORD Collect (LibIndex iLib,
               LPWSTR lpwszValue,
               void** ppdata,
               DWORD* pdwBytes,
               DWORD* pdwObjectTypes)
{
    DWORD               dwQueryType;
    DWORD               dwBytesIn;
    DWORD               dwSpaceNeeded = 0;      // Space needed for counters
    DWORD               dwRet = ERROR_SUCCESS;  // Our return value
    PerfLibraryData     rgld;
    
    //
    // Save the number of bytes in before overwriting it
    //
    dwBytesIn = *pdwBytes;
    
    //
    // Set up the out parameters to indicate an error. We will change them
    //  later upon success
    //
    *pdwBytes = 0;
    *pdwObjectTypes = 0;
    
    if (!g_rgfInitOk[iLib])
    {
        //
        // Only acceptable error return is ERROR_MORE_DATA.  anything else
        // should return ERROR_SUCCESS, but set the out parameters to indicate
        // that no data is being returned
        //
        goto Exit;
    }

    dwQueryType = GetQueryType (lpwszValue);        
    if (dwQueryType == QUERY_FOREIGN)
    {
        //
        // This routine does not service requests for data from
        // Non-NT computers.
        //
        goto Exit;
    }

    //
    // Enumerate through all the libraries we know of and get their
    //  performance statistices
    //
    if (!rgld.GetPerformanceStatistics (g_rgszLibraries[iLib]))
        goto Exit;

    //
    // Compute the space needed
    //
    dwSpaceNeeded = rgld.SpaceNeeded (dwQueryType, lpwszValue);

    // Round up to a multiple of 4.
    dwSpaceNeeded = QWORD_MULTIPLE (dwSpaceNeeded);


    //
    // See if the caller-provided buffer is large enough
    //
    if (dwBytesIn < dwSpaceNeeded)
    {
        //
        // Not enough space was provided by the caller
        //
        dwRet = ERROR_MORE_DATA;
        goto Exit;
    }

    //
    // Copy the performance data into the buffer
    //
    rgld.SavePerformanceData (ppdata, pdwBytes, pdwObjectTypes); 
    
Exit:
    return dwRet;
}

DWORD Close (LibIndex iLib)
{
    if (g_rgfInitOk[iLib])
    {
        //
        // Release the reference to the global ExchMHeap.
        //
        ExchMHeapDestroy ();
    }

    return ERROR_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////
// PerfMon API functions
//      the following functions are exported from this DLL as the entry points
//      for a performance monitoring application
///////////////////////////////////////////////////////////////////////////////
//
// XXXXOpen
//      Called by performance monitor to initialize performance gathering.
//      The LPWSTR parameter contains the names of monitored devices.  This
//      is for device driver performance DLL's and is not used by our DLL.
//
// XXXXXCollect
//      Called by the performance monitor to retrieve a block of performance
//      statistics.
//
// XXXXClose
//      Called by the performance monitor to terminate performance gathering
//

/* NTFSDrv */
EXTERN_C
DWORD APIENTRY NTFSDrvOpen (LPWSTR)
{
    return Open (LIB_NTFSDRV, L"NTFSDrv");
}

EXTERN_C
DWORD APIENTRY NTFSDrvCollect (LPWSTR lpwszValue,
                             void** ppdata,
                             DWORD* pdwBytes,
                             DWORD* pdwObjectTypes)
{
    return Collect (LIB_NTFSDRV, lpwszValue, ppdata, pdwBytes, pdwObjectTypes);
}

EXTERN_C
DWORD APIENTRY NTFSDrvClose (void)
{
    return Close (LIB_NTFSDRV);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\snprflib\exprflib.cpp ===
/*==========================================================================*\

    Module:        exprflib.cpp

    Copyright Microsoft Corporation 1998, All Rights Reserved.

    Author:        WayneC

    Descriptions:  This is the implentation for exprflib, a perf library. This
                   is the code that runs in the app exporting the counters.

\*==========================================================================*/
#include "stdlib.h"
#include "snprflib.h"

DWORD InitializeBasicSecurityDescriptor (PSECURITY_DESCRIPTOR *ppSd);

///////////////////////////////////////////////////////////////////////////////
//
// Forward declaration of shared memory functions.
//
///////////////////////////////////////////////////////////////////////////////

BOOL FCreateFileMapping (SharedMemorySegment * pSMS,
                         LPCWSTR pcwstrInstanceName,
                         DWORD   dwIndex,
                         DWORD   cbSize);

void CloseFileMapping (SharedMemorySegment * pSMS);


///////////////////////////////////////////////////////////////////////////////
//
// PerfLibrary class declaration. There is one perf library instance per linkee.
//
///////////////////////////////////////////////////////////////////////////////

PerfLibrary::PerfLibrary (LPCWSTR pcwstrPerfName)
{
    wcsncpy (m_wszPerfName, pcwstrPerfName, MAX_PERF_NAME);

    m_wszPerfName[MAX_PERF_NAME-1] = L'\0';     // Ensure NULL termination

    ZeroMemory (m_rgpObjDef, sizeof (m_rgpObjDef));
    m_dwObjDef = 0;
    m_hMap = 0;
    m_pbMap = 0;
}

PerfLibrary::~PerfLibrary (void)
{
    DeInit ();
}

void
PerfLibrary::DeInit (void)
{
    DWORD i;

    // Destroy the PerfObjectDefinition's we owned.
    for (i = 0; i < m_dwObjDef; i++)
    {
        delete m_rgpObjDef[i];
        m_rgpObjDef[i] = NULL;
    }

    m_dwObjDef = 0;

    // Destroy our shared memory mapping.
    if (m_pbMap)
    {
        UnmapViewOfFile ((void*) m_pbMap);
        m_pbMap = 0;
    }

    if (m_hMap)
    {
        CloseHandle (m_hMap);
        m_hMap = 0;
    }
}

PerfObjectDefinition*
PerfLibrary::AddPerfObjectDefinition (LPCWSTR pcwstrObjectName,
                                      DWORD dwObjectNameIndex,
                                      BOOL fInstances)
{
    PerfObjectDefinition* ppod = NULL;

    if (m_dwObjDef < MAX_PERF_OBJECTS)
    {
        ppod = new PerfObjectDefinition (pcwstrObjectName,
                                         dwObjectNameIndex,
                                         fInstances);
        if (NULL == ppod)
            goto Exit;

        m_rgpObjDef[m_dwObjDef++] = ppod;
    }

Exit:
    return ppod;
}

BOOL
PerfLibrary::Init (void)
{
    DWORD i = 0;
    WCHAR wszPerformanceKey[256] = {L'\0'};
    HKEY hKey = NULL;
    LONG status = 0;
    DWORD size, type = 0;
    BOOL fRet = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pSd = NULL;
    SECURITY_ATTRIBUTES sa;

    //
    // Get counter and help index base values from registry and
    // update static data structures by adding base to offset values
    // that are statically defined in the structure initialization
    //
    swprintf (wszPerformanceKey,
               L"SYSTEM\\CurrentControlSet\\Services\\%s\\Performance",
               m_wszPerfName );

    status = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
                            wszPerformanceKey,
                            0L,
                            KEY_READ,
                            &hKey);
    if (status != ERROR_SUCCESS)
        goto Exit;

    //
    // Get FirstCounter RegValue
    //
    size = sizeof(DWORD);
    status = RegQueryValueEx (hKey,
                              "First Counter",
                              0L,
                              &type,
                              (LPBYTE)&m_dwFirstCounter,
                              &size);
    if (status != ERROR_SUCCESS)
        goto Exit;


    //
    // Get FirstHelp RegValue
    //
    size = sizeof(DWORD);
    status = RegQueryValueEx( hKey,
                              "First Help",
                              0L,
                              &type,
                              (LPBYTE)&m_dwFirstHelp,
                              &size);
    if (status != ERROR_SUCCESS)
        goto Exit;

    //
    //  Initialize the security descriptor with completely open access
    //
    dwErr = InitializeBasicSecurityDescriptor (&pSd);
    if (dwErr) {
        fRet = FALSE;
        goto Exit;
    }

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = pSd;
    sa.bInheritHandle = TRUE;
    //
    // Create the shared memory object for the list of object names.
    //  Return error if it already exists as we cannot operate if this
    //  is the second instance of the app.
    //
    m_hMap = CreateFileMappingW (INVALID_HANDLE_VALUE,
                                 &sa,
                                 PAGE_READWRITE,
                                 0,
                                 (MAX_PERF_OBJECTS * MAX_OBJECT_NAME *
                                   sizeof (WCHAR) + sizeof (DWORD)),
                                 m_wszPerfName);
    if (m_hMap == NULL || GetLastError() == ERROR_ALREADY_EXISTS)
        goto Exit;

    //
    // Map the file into memory
    //
    m_pbMap = (BYTE*) MapViewOfFile (m_hMap, FILE_MAP_WRITE, 0, 0, 0);
    if (!m_pbMap)
        goto Exit;

    //
    // Assign pointers into the shared memory region
    //
    m_pdwObjectNames = (DWORD*) m_pbMap;
    m_prgObjectNames = (OBJECTNAME*) (m_pbMap+sizeof(DWORD));

    //
    // Copy the object names into the shared memory
    //
    *m_pdwObjectNames = m_dwObjDef;

    for (i = 0; i < m_dwObjDef; i++)
    {
        if (m_rgpObjDef[i]->Init( this ))
            wcscpy (m_prgObjectNames[i], m_rgpObjDef[i]->m_wszObjectName);
    }

    fRet = TRUE;

Exit:
    if (hKey)
        RegCloseKey (hKey);

    if (!fRet)
    {
        if (m_pbMap)
        {
            UnmapViewOfFile ((PVOID)m_pbMap);
            m_pbMap = 0;
        }

        if (m_hMap)
        {
            CloseHandle (m_hMap);
            m_hMap = 0;
        }
    }

    if (pSd)
        delete [] (BYTE *) pSd;

    return fRet;
}


///////////////////////////////////////////////////////////////////////////////
//
// PerfObjectDefinition class implementation. There is one of these for each
//  perfmon object exported. Generally there is just one, but not neccessarily.
//
///////////////////////////////////////////////////////////////////////////////


PerfObjectDefinition::PerfObjectDefinition (LPCWSTR pcwstrObjectName,
                                            DWORD dwObjectNameIndex,
                                            BOOL  fInstances) :
    m_dwObjectNameIndex (dwObjectNameIndex),
    m_fInstances (fInstances),
    m_dwCounters (0)
{
    wcsncpy (m_wszObjectName, pcwstrObjectName, MAX_OBJECT_NAME);
    m_wszObjectName[MAX_OBJECT_NAME-1] = L'\0';     // Ensure NULL Terminated

    ZeroMemory (m_rgpCounterDef, sizeof(m_rgpCounterDef));
    m_dwActiveInstances  = 0;
    m_pSMS               = NULL;
    m_dwShmemMappingSize = SHMEM_MAPPING_SIZE;
    m_fCSInit            = FALSE;
    m_pPoiTotal          = NULL;
    m_pPerfObjectType    = NULL;
}

PerfObjectDefinition::~PerfObjectDefinition (void)
{
    DeInit();
}

void
PerfObjectDefinition::DeInit (void)
{
    SharedMemorySegment *pSMS, *pSMSNext;
    DWORD i;

    // First destroy the _Total instance.
    if (m_pPoiTotal)
    {
        delete m_pPoiTotal;
        m_pPoiTotal = NULL;
    }

    //
    // Reset these values in the shared memory so that before we unmap the memory,
    // perfmon won't think that we still have instances & counters running.
    //
    if (m_pPerfObjectType)
    {
        m_pPerfObjectType->NumCounters  = 0;
        m_pPerfObjectType->NumInstances = 0;
    }

    // Destroy the PerfCounterDefinition's we owned.
    for (i = 0; i < m_dwCounters; i++)
    {
        delete m_rgpCounterDef[i];
        m_rgpCounterDef[i] = NULL;
    }

    pSMS = m_pSMS;
    m_pSMS = NULL;

    // Enumerate through all the memory mappings we created and destroy them.
    while (pSMS)
    {
        pSMSNext = pSMS->m_pSMSNext;
        CloseFileMapping (pSMS);
        delete (pSMS);
        pSMS = pSMSNext;
    }

    // Destroy the critical section.
    if (m_fCSInit)
    {
        m_fCSInit = FALSE;
        DeleteCriticalSection (&m_csPerfObjInst);
    }
}

PerfCounterDefinition*
PerfObjectDefinition::AddPerfCounterDefinition (
                                    DWORD dwCounterNameIndex,
                                    DWORD dwCounterType,
                                    LONG lDefaultScale)
{
    PerfCounterDefinition* ppcd = NULL;

    if (m_dwCounters < MAX_OBJECT_COUNTERS)
    {
        ppcd = new PerfCounterDefinition (dwCounterNameIndex,
                                          dwCounterType,
                                          lDefaultScale);
        if (NULL == ppcd)
            goto Exit;

        m_rgpCounterDef[m_dwCounters++] = ppcd;
    }

Exit:
    return ppcd;
}

PerfCounterDefinition*
PerfObjectDefinition::AddPerfCounterDefinition (
                                    PerfCounterDefinition* pCtrRef,
                                    DWORD dwCounterNameIndex,
                                    DWORD dwCounterType,
                                    LONG lDefaultScale)
{
    PerfCounterDefinition* ppcd = NULL;

    if (m_dwCounters < MAX_OBJECT_COUNTERS)
    {
        ppcd = new PerfCounterDefinition (pCtrRef,
                                          dwCounterNameIndex,
                                          dwCounterType,
                                          lDefaultScale);
        if (NULL == ppcd)
            goto Exit;

        m_rgpCounterDef[m_dwCounters++] = ppcd;
    }

Exit:
    return ppcd;
}

BOOL
PerfObjectDefinition::Init (PerfLibrary* pPerfLib)
{
    DWORD  i                 = 0;
    DWORD  dwOffset          = 0;
    DWORD  dwDefinitionLength= 0;
    BOOL   fRet              = FALSE;

    //
    // Compute the size of the shared memory for this object definition
    //

    // Start with the basics:
    //  we need a PERF_OBJECT_TYPE for the object information and
    //  we need a PERF_COUNTER_DEFINITION for each counter in the object
    dwDefinitionLength = (sizeof(PERF_OBJECT_TYPE) +
                           m_dwCounters * sizeof(PERF_COUNTER_DEFINITION));
    // We also keep a DWORD in the shared memory to give the DLL
    //   our pre-computed value for m_dwCounterData
    m_dwDefinitionLength = dwDefinitionLength + sizeof(DWORD);

    // Compute the counter data space
    m_dwCounterData = sizeof(PERF_COUNTER_BLOCK);
    for (i = 0; i < m_dwCounters; i++)
    {
        m_dwCounterData += m_rgpCounterDef[i]->m_dwCounterSize;
    }

    // Compute the per instance space
    m_dwPerInstanceData = (sizeof(INSTANCE_DATA) + m_dwCounterData);

    // Make sure our memory mapping is large enough
    while (m_dwShmemMappingSize < m_dwDefinitionLength || m_dwShmemMappingSize < m_dwPerInstanceData)
        m_dwShmemMappingSize *= 2;

    // Compute the number of instances can be stored in one shmem mapping.
    m_dwInstancesPerMapping = (DWORD)(m_dwShmemMappingSize / m_dwPerInstanceData);
    m_dwInstances1stMapping = (DWORD)((m_dwShmemMappingSize - m_dwDefinitionLength) / m_dwPerInstanceData);

    //
    // Create the shared memory object for the list of object names. If it
    //  already exists, abort!
    //
    m_pSMS = new SharedMemorySegment;
    if (!m_pSMS)
        goto Exit;

    if (!FCreateFileMapping (m_pSMS, m_wszObjectName, 0, m_dwShmemMappingSize))
        goto Exit;

    //
    // Set the pointers to the PERF API structures
    //
    m_pPerfObjectType = (PERF_OBJECT_TYPE*) m_pSMS->m_pbMap;
    m_rgPerfCounterDefinition =
        (PERF_COUNTER_DEFINITION*) (m_pPerfObjectType+1);

    //
    // Initialize the PERF API structures
    //
    m_pPerfObjectType->TotalByteLength          = dwDefinitionLength;
    m_pPerfObjectType->DefinitionLength         = dwDefinitionLength;
    m_pPerfObjectType->HeaderLength             = sizeof (PERF_OBJECT_TYPE);
    m_pPerfObjectType->ObjectNameTitleIndex     = m_dwObjectNameIndex +
                                                  pPerfLib->m_dwFirstCounter ;
    m_pPerfObjectType->ObjectNameTitle          = 0;
    m_pPerfObjectType->ObjectHelpTitleIndex     = m_dwObjectNameIndex +
                                                  pPerfLib->m_dwFirstHelp;
    m_pPerfObjectType->ObjectHelpTitle          = 0;
    m_pPerfObjectType->DetailLevel              = PERF_DETAIL_NOVICE;
    m_pPerfObjectType->NumCounters              = m_dwCounters;
    m_pPerfObjectType->CodePage                 = (DWORD) 0xffffffff;
    m_pPerfObjectType->DefaultCounter           = 0;
    if( !m_fInstances )
        m_pPerfObjectType->NumInstances         = PERF_NO_INSTANCES;
    else
        m_pPerfObjectType->NumInstances         = 0;

    //
    // Have all of the PerfCounterDefinition's in this object intialize their
    //  PERF_COUNTER_DEFINITION structures in the shared memory
    //
    dwOffset = sizeof (PERF_COUNTER_BLOCK);
    for (i = 0; i < m_dwCounters; i++)
        m_rgpCounterDef[i]->Init(pPerfLib, m_rgPerfCounterDefinition + i, &dwOffset);

    // Save value for dwCounterData in shared memory for DLL
    *((DWORD*) (m_pSMS->m_pbMap + dwDefinitionLength)) = m_dwCounterData;

    //
    // Initialzie the critical section to protects the creation/deletion of
    // perf object instances.  Use AndSpinCount variation to avoid exception
    // handling.
    //
    if (!InitializeCriticalSectionAndSpinCount(&m_csPerfObjInst, 0x80000000))
        goto Exit;

    m_fCSInit = TRUE;

    // Create the _Total instance as the 1st instance if there will be multiple instances
    if (m_fInstances)
    {
        m_pPoiTotal = AddPerfObjectInstance (L"_Total");
        if (!m_pPoiTotal)
            goto Exit;
    }

    fRet = TRUE;

Exit:
    if (!fRet)
    {
        if (m_pPoiTotal)
        {
            delete m_pPoiTotal;
            m_pPoiTotal = NULL;
        }

        if (m_fCSInit)
        {
            DeleteCriticalSection (&m_csPerfObjInst);
            m_fCSInit = FALSE;
        }

        if (m_pSMS)
        {
            CloseFileMapping (m_pSMS);
            delete (m_pSMS);
            m_pSMS = NULL;
        }
    }

    return fRet;
}

DWORD
PerfObjectDefinition::GetCounterOffset (DWORD dwId)
{
    for (DWORD i = 0; i < m_dwCounters; i++)
        if (m_rgpCounterDef[i]->m_dwCounterNameIndex == dwId)
            return m_rgpCounterDef[i]->m_dwOffset;

    return 0;
}

PerfObjectInstance*
PerfObjectDefinition::AddPerfObjectInstance (LPCWSTR pwcstrInstanceName)
{
    PerfObjectInstance*  ppoi     = NULL;
    char* pCounterData            = NULL;
    INSTANCE_DATA* pInstData      = 0;
    LONG  lID                     = 0;
    SharedMemorySegment* pSMS     = NULL;
    SharedMemorySegment* pSMSPrev = NULL;
    SharedMemorySegment* pSMSNew  = NULL;
    DWORD dwInstances             = 0;
    DWORD dwInstIndex             = 0;
    DWORD dwSMS                   = 0;
    BOOL  fCSEntered              = FALSE;
    BOOL  fSuccess                = FALSE;

    //
    // Make sure we've been initialized
    //
    if (!m_pSMS || !m_fCSInit)
        goto Exit;

    //
    // Instances may be created in different threads. Need to protect the following code.
    //
    EnterCriticalSection (&m_csPerfObjInst);
    fCSEntered = TRUE;

    if (!m_fInstances)
    {
        // See if we have already created the single instance of this object
        if (m_dwActiveInstances != 0)
            goto Exit;

        pCounterData = (char *)(m_pSMS->m_pbMap) + m_dwDefinitionLength;
    }
    else
    {
        //
        // Find a free instance in current mapped segments.
        //
        pSMS = m_pSMS;
        lID  = 0;

        while (pSMS)
        {
            if (0 == dwSMS++)
            {
                //
                // If this is the first mapping, offset pCounterData by m_dwDefinitionLength.
                //
                pCounterData = (char *)(pSMS->m_pbMap) + m_dwDefinitionLength;
                dwInstances  = m_dwInstances1stMapping;
            }
            else
            {
                //
                // Otherwise, pCounterData starts from the 1st byte of the mapping.
                //
                pCounterData = (char *)(pSMS->m_pbMap);
                dwInstances  = m_dwInstancesPerMapping;
            }

            for (dwInstIndex = 0;
                 dwInstIndex < dwInstances;
                 pCounterData += sizeof (INSTANCE_DATA) + m_dwCounterData, dwInstIndex++)
            {
                if (!((INSTANCE_DATA*) pCounterData)->fActive)
                {
                    pInstData    = (INSTANCE_DATA*) pCounterData;
                    pCounterData = pCounterData + sizeof (INSTANCE_DATA);
                    goto Found;
                }

                lID++;
            }

            pSMSPrev = pSMS;
            pSMS     = pSMS->m_pSMSNext;
        }

        //
        // If cannot find a free instance, create a new segment.
        //
        pSMSNew = new SharedMemorySegment;
        if (!pSMSNew)
            goto Exit;

        if (!FCreateFileMapping (pSMSNew, m_wszObjectName, dwSMS, m_dwShmemMappingSize))
            goto Exit;

        pInstData    = (INSTANCE_DATA*) (pSMSNew->m_pbMap);
        pCounterData = (char*) (pSMSNew->m_pbMap) + sizeof (INSTANCE_DATA);

        //
        // Add the new segment to our segment linked list.
        //
        pSMSPrev->m_pSMSNext = pSMSNew;
    }

Found:
    //
    // We successfully found a free space for new instance.
    //
    ppoi = new PerfObjectInstance (this, pwcstrInstanceName);
    if (!ppoi)
        goto Exit;

    ppoi->Init(pCounterData, pInstData, lID);

    m_pPerfObjectType->NumInstances++;
    m_dwActiveInstances++;
    fSuccess = TRUE;

Exit:
    if (fCSEntered)
        LeaveCriticalSection (&m_csPerfObjInst);

    if (!fSuccess)
    {
        if (pSMSNew)
        {
            CloseFileMapping (pSMSNew);
            delete (pSMSNew);
        }

        if (ppoi)
        {
            delete ppoi;
            ppoi = NULL;
        }
    }

    return ppoi;
}


void PerfObjectDefinition::DeletePerfObjectInstance ()
{
    EnterCriticalSection (&m_csPerfObjInst);

    m_dwActiveInstances--;
    m_pPerfObjectType->NumInstances--;

    LeaveCriticalSection (&m_csPerfObjInst);
}


///////////////////////////////////////////////////////////////////////////////
//
// PerfCounterDefinition class declaration. There is one of these per counter.
//
///////////////////////////////////////////////////////////////////////////////


PerfCounterDefinition::PerfCounterDefinition (DWORD dwCounterNameIndex,
                                              DWORD dwCounterType,
                                              LONG lDefaultScale) :
    m_pCtrRef (NULL),
    m_dwCounterNameIndex (dwCounterNameIndex),
    m_lDefaultScale (lDefaultScale),
    m_dwCounterType (dwCounterType)
{
    if (m_dwCounterType & PERF_SIZE_LARGE)
        m_dwCounterSize = sizeof (LARGE_INTEGER);
    else
        m_dwCounterSize = sizeof (DWORD);
}


PerfCounterDefinition::PerfCounterDefinition (PerfCounterDefinition* pCtrRef,
                                              DWORD dwCounterNameIndex,
                                              DWORD dwCounterType,
                                              LONG lDefaultScale) :
    m_pCtrRef (pCtrRef),
    m_dwCounterNameIndex (dwCounterNameIndex),
    m_lDefaultScale (lDefaultScale),
    m_dwCounterType (dwCounterType),
    m_dwCounterSize (0)
{
}

void
PerfCounterDefinition::Init (PerfLibrary* pPerfLib,
                             PERF_COUNTER_DEFINITION* pdef, PDWORD pdwOffset)
{
    pdef->ByteLength                    = sizeof (PERF_COUNTER_DEFINITION);
    pdef->CounterNameTitleIndex         = m_dwCounterNameIndex +
                                          pPerfLib->m_dwFirstCounter ;
    pdef->CounterNameTitle              = 0;
    pdef->CounterHelpTitleIndex         = m_dwCounterNameIndex +
                                          pPerfLib->m_dwFirstHelp ;
    pdef->CounterHelpTitle              = 0;
    pdef->DefaultScale                  = m_lDefaultScale;
    pdef->DetailLevel                   = PERF_DETAIL_NOVICE;
    pdef->CounterType                   = m_dwCounterType;

    if (m_pCtrRef)
    {
        //
        // This counter uses the data of another counter.
        //
        pdef->CounterSize               = m_pCtrRef->m_dwCounterSize;
        pdef->CounterOffset             = m_pCtrRef->m_dwOffset;
    }
    else
    {
        //
        // This counter has its own data.
        //
        pdef->CounterSize               = m_dwCounterSize;
        pdef->CounterOffset             = *pdwOffset;

        // Save offset
        m_dwOffset = *pdwOffset;

        // Increment offset for next counter definition
        *pdwOffset += m_dwCounterSize;
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// PerfObjectInstance class implementation. There is one of these per instance
//  of an object. There is one if there are no instances (the global instance.)
//
///////////////////////////////////////////////////////////////////////////////
PerfObjectInstance::PerfObjectInstance (PerfObjectDefinition* pObjDef,
                                        LPCWSTR pcwstrInstanceName)
{
    m_pObjDef = pObjDef;

    if (pcwstrInstanceName)
    {
        wcsncpy (m_wszInstanceName, pcwstrInstanceName, MAX_INSTANCE_NAME);
        m_wszInstanceName[MAX_INSTANCE_NAME-1] = L'\0';     // Ensure NULL termination!
    }
    else
        *m_wszInstanceName = L'\0';

    m_fInitialized = FALSE;
}

void
PerfObjectInstance::Init (char* pCounterData, INSTANCE_DATA* pInstData, LONG lID)
{
    m_pCounterData  = pCounterData;
    m_pInstanceData = pInstData;

    // Clear all the counter data
    ZeroMemory( m_pCounterData, m_pObjDef->m_dwCounterData );

    // Set the counter block length
    ((PERF_COUNTER_BLOCK*)m_pCounterData)->ByteLength =
        m_pObjDef->m_dwCounterData;

    if (m_pInstanceData)
    {
        m_pInstanceData->perfInstDef.ByteLength =
            sizeof (PERF_INSTANCE_DEFINITION) + sizeof (INSTANCENAME);
        m_pInstanceData->perfInstDef.ParentObjectTitleIndex = 0;
        m_pInstanceData->perfInstDef.ParentObjectInstance = 0;
        m_pInstanceData->perfInstDef.UniqueID = PERF_NO_UNIQUE_ID;
        m_pInstanceData->perfInstDef.NameOffset =
            sizeof (PERF_INSTANCE_DEFINITION);
        m_pInstanceData->perfInstDef.NameLength =
            (wcslen(m_wszInstanceName) * sizeof (WCHAR));

        wcsncpy( m_pInstanceData->wszInstanceName, m_wszInstanceName,
                   MAX_INSTANCE_NAME );

        m_pInstanceData->fActive = TRUE;
    }

    m_fInitialized = TRUE;
}

VOID
PerfObjectInstance::DeInit (void)
{
    if (m_fInitialized)
    {
        m_fInitialized = FALSE;
        if (m_pInstanceData)
        {
            m_pInstanceData->fActive = FALSE;
            m_pInstanceData = NULL;
        }
    }

    m_pObjDef->DeletePerfObjectInstance();
}

DWORD* PerfObjectInstance::GetDwordCounter (DWORD dwId)
{
    DWORD dwOffset;

    if (m_fInitialized)
    {
        if (dwOffset = m_pObjDef->GetCounterOffset(dwId))
            return (DWORD*) (m_pCounterData + dwOffset);
    }

    return 0;
}


LARGE_INTEGER* PerfObjectInstance::GetLargeIntegerCounter (DWORD dwId)
{
    DWORD dwOffset;

    if (m_fInitialized)
    {
        if (dwOffset = m_pObjDef->GetCounterOffset(dwId))
            return (LARGE_INTEGER*) (m_pCounterData + dwOffset);
    }

    return 0;
}

QWORD* PerfObjectInstance::GetQwordCounter (DWORD dwId)
{
    DWORD dwOffset;

    if (m_fInitialized)
    {
        if (dwOffset = m_pObjDef->GetCounterOffset(dwId))
            return (QWORD*) (m_pCounterData + dwOffset);
    }

    return 0;
}

//---------------------------------------------------------------------------
//  Description:
//      Allocates and returns a SECURITY_DESCRIPTOR structure initialized to
//      allow all users access. This security descriptor is used to set the
//      security for the shared memory objects created by snprflib.
//  Arguments:
//      OUT pSd Pass in a pointer to SECURITY_DESCRIPTOR, on success this will
//          be set to a suitably initialized SECURITY_DESCRIPTOR. Caller frees
//          memory pointed to by pSd.
//  Returns:
//      ERROR_SUCCESS on success.
//      Win32 error to indicate failure.
//---------------------------------------------------------------------------
DWORD InitializeBasicSecurityDescriptor (PSECURITY_DESCRIPTOR *ppSd)
{ 
    DWORD dwErr = ERROR_SUCCESS;
    PSID pSidWorld = NULL;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    ACL *pAcl = NULL;
    DWORD dwAclSize = 0;

    *ppSd = NULL;
    if (!AllocateAndInitializeSid (
            &WorldAuthority,
            1,
            SECURITY_WORLD_RID,
            0,0,0,0,0,0,0,
            &pSidWorld)){

        dwErr = GetLastError ();
        goto Exit;
    }

    dwAclSize = sizeof (ACL) +
                (sizeof (ACCESS_ALLOWED_ACE) - sizeof (LONG)) +
                GetLengthSid (pSidWorld) +
                (sizeof (ACCESS_DENIED_ACE) - sizeof (LONG)) +
                GetLengthSid (pSidWorld);

    //
    //  Allocate SD and ACL with a single alloc
    //

    *ppSd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH + dwAclSize];

    if (!*ppSd) {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    if (!InitializeSecurityDescriptor (*ppSd, SECURITY_DESCRIPTOR_REVISION)) {
        dwErr = GetLastError ();
        goto Exit;
    }

    pAcl = (ACL *) ((BYTE *) *ppSd + SECURITY_DESCRIPTOR_MIN_LENGTH); 

    if (!InitializeAcl (
            pAcl,
            dwAclSize,
            ACL_REVISION)) {

        dwErr = GetLastError ();
        goto Exit;
    }

    if (!AddAccessDeniedAce (
            pAcl,
            ACL_REVISION,
            WRITE_DAC | WRITE_OWNER,
            pSidWorld)
            
            ||
            
        !AddAccessAllowedAce (
            pAcl,
            ACL_REVISION,
            GENERIC_ALL,
            pSidWorld)) {

        dwErr = GetLastError ();
        goto Exit;
    }

    if (!SetSecurityDescriptorDacl (*ppSd, TRUE, pAcl, FALSE))
        dwErr = GetLastError ();

Exit:
    if (pSidWorld)
        FreeSid (pSidWorld);

    return dwErr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Shared memory management functions
//
///////////////////////////////////////////////////////////////////////////////

BOOL FCreateFileMapping (SharedMemorySegment * pSMS,
                         LPCWSTR pcwstrInstanceName,
                         DWORD   dwIndex,
                         DWORD   cbSize)
{
    WCHAR  pwstrShMem[MAX_PATH];
    WCHAR  pwstrIndex[MAX_PATH];
    PSECURITY_DESCRIPTOR pSd = NULL;
    SECURITY_ATTRIBUTES sa;
    HANDLE hMap     = NULL;
    PVOID  pvMap    = NULL;
    BOOL   fSuccess = FALSE;
    DWORD dwErr = ERROR_SUCCESS;

    //
    // Check parameter
    //
    if (!pSMS)
        goto Exit;

    pSMS->m_hMap     = NULL;
    pSMS->m_pbMap    = NULL;
    pSMS->m_pSMSNext = NULL;

    //
    // Append dwIndex to instance name.
    //
    _ultow (dwIndex, pwstrIndex, 16);

    if (wcslen (pcwstrInstanceName) + wcslen (pwstrIndex) >= MAX_PATH)
        goto Exit;

    wcscpy (pwstrShMem, pcwstrInstanceName);
    wcscat (pwstrShMem, pwstrIndex);

    dwErr = InitializeBasicSecurityDescriptor (&pSd);
    if (dwErr)
        goto Exit;

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = pSd;
    sa.bInheritHandle = TRUE;

    //
    // Create the shared memory object. If it already exists, abort!
    //
    hMap = CreateFileMappingW (INVALID_HANDLE_VALUE,
                               &sa,
                               PAGE_READWRITE,
                               0,
                               cbSize,
                               pwstrShMem);

    if (hMap == NULL || GetLastError() == ERROR_ALREADY_EXISTS)
        goto Exit;

    //
    // Map the file into memory
    //
    pvMap = MapViewOfFile (hMap, FILE_MAP_WRITE, 0, 0, 0);
    if (!pvMap)
        goto Exit;

    ZeroMemory (pvMap, cbSize);

    //
    // Succeeds. Now store the results into pSMS.
    //
    pSMS->m_hMap = hMap;
    pSMS->m_pbMap = (BYTE *)pvMap;

    fSuccess = TRUE;

Exit:
    if (!fSuccess)
    {
        if (pvMap)
            UnmapViewOfFile (pvMap);

        if (hMap)
            CloseHandle (hMap);
    }
    if (pSd)
        delete [] (BYTE *) pSd;

    return fSuccess;
}


void CloseFileMapping (SharedMemorySegment * pSMS)
{
    if (pSMS)
    {
        if (pSMS->m_pbMap)
        {
            UnmapViewOfFile ((PVOID)pSMS->m_pbMap);
            pSMS->m_pbMap = NULL;
        }

        if (pSMS->m_hMap)
        {
            CloseHandle (pSMS->m_hMap);
            pSMS->m_hMap = NULL;
        }

        pSMS->m_pSMSNext = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\staxmem\exchmem.c ===
/*
 -	E X C H M E M . C
 -
 *	Purpose:
 *		
 *
 *		
 *
 *	Copyright (C) 1995-96, Microsoft Corporation.
 */

#define _CRTIMP __declspec(dllexport)
#include <malloc.h>
#include <string.h>
#include <stdio.h>
#include <windows.h>

#ifdef DEBUG
#include <imagehlp.h>
#endif

#include <limits.h>
#include <exchmem.h>
#include "_exchmem.h"
#include "excpt.h"
#include "io.h"

#ifndef	DEBUG
#define	USEMPHEAP
#endif

#ifdef USEMPHEAP
#include <mpheap.h>
#endif

//	Global heap assigned to the process by NT

HANDLE					hProcessHeap		= NULL;
#ifdef USEMPHEAP
HANDLE					hMpHeap				= NULL;
ULONG					cRefHeap			= -1;
#else
LPHEAPTBL				pheaptbl			= NULL;
CRITICAL_SECTION		csMHeap;
#endif
DWORD					tlsiHeapHint		= 0;

//	Debug Support for leak detection and memory usage tracking.

#ifdef DEBUG

static HMODULE			hMod;
static HINSTANCE		hinstRunTime		= NULL;
static BOOL				fDbgEnable			= FALSE;
static BOOL				fCallStacks			= FALSE;
static BOOL				fSymInitialize		= FALSE;
static BOOL				fProcessIsService	= FALSE;

static LPFMALLOC		pfMalloc			= NULL;
static LPFREALLOC		pfRealloc			= NULL;
static LPFFREE			pfFree				= NULL;
static LPFCALLOC		pfCalloc			= NULL;
static LPFSTRDUP		pfStrDup			= NULL;
static LPFMEMSIZE		pfMemSize			= NULL;

static BOOL				fAssertLeaks		= FALSE;
static BOOL				fDumpLeaks			= FALSE;
static BOOL				fDumpLeaksDebugger	= FALSE;
static BOOL				fUseVirtual			= FALSE;
static ULONG			cbVirtualAlign		= 1;
static BOOL				fFailuresEnabled	= FALSE;
static BOOL				fHeapMonitorUI		= FALSE;
static BOOL				fOverwriteDetect	= FALSE;
static BOOL				fValidateMemory		= FALSE;
static BOOL				fTrackFreedMemory	= FALSE;
static DWORD			cEntriesFree		= 512;
static BOOL				fAssertValid		= FALSE;
static BOOL				fTrapOnInvalid		= FALSE;
static BOOL				fSymbolLookup		= FALSE;

static BOOL				fFillMemory			= FALSE;
static BYTE				chAllocFillByte		= chDefaultAllocFill;
static BYTE				chFreeFillByte		= chDefaultFreeFill;

static BOOL				fTrackMem			= FALSE;
static DWORD			cFrames				= 0;
static FILE *			hTrackLog			= NULL;
static CRITICAL_SECTION	csTrackLog;
static char				rgchExeName[16];
static char				rgchLogPath[MAX_PATH];
BOOL					fChangeTrackState 	= FALSE;

static ULONG			iAllocationFault	= 0;

#define NBUCKETS		8192
#define UlHash(_n)		((ULONG)(((_n & 0x000FFFF0) >> 4) % NBUCKETS))

typedef struct _symcache
{
	DWORD_PTR	dwAddress;
	DWORD_PTR	dwOffset;
	CHAR		rgchSymbol[248];
	
} SYMCACHE, * PSYMCACHE;

static PSYMCACHE		rgsymcacheHashTable = NULL;

static CRITICAL_SECTION	csHeapList;
static PHEAP			pheapList			= NULL;
CHAR * PszGetSymbolFromCache(DWORD_PTR dwAddress, DWORD_PTR * pdwOffset);
VOID AddSymbolToCache(DWORD_PTR dwAddress, DWORD_PTR dwOffset, CHAR * pszSymbol);
BOOL FTrackMem();
VOID StartTrace(BOOL fFresh);
VOID StopTrace();

typedef struct
{
	WORD wApi;
	DWORD_PTR rgdwCallStack[32];
	DWORD_PTR rgdwArgs[5];
	DWORD dwTickCount;
	DWORD dwThreadId;
} MEMTRACE;
MEMTRACE * 	rgmemtrace 			= NULL;
DWORD 		dwmemtrace 			= 0;
DWORD		dwTrackMemInMem		= 0;

#endif	// DEBUG


/*
 -	DllMain
 -
 *	Purpose:
 *		Entry point called by CRT entry point.
 *
 */

BOOL
APIENTRY
DllMain(
	HANDLE hModule,
	DWORD dwReason,
	LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		DisableThreadLibraryCalls(hModule);
#ifdef USEMPHEAP
		tlsiHeapHint = TlsAlloc();
#else
		//	Init the CS that protects access to the
		//	global Multiple Heap data structs.
		
		InitializeCriticalSection(&csMHeap);

		//	Now, if Debug build then do a lot of initialization
		//	including creating a debug process heap.  If not
		//	Debug, then just get the ProcessHeap from system.
#endif		
#ifdef DEBUG
		InitDebugExchMem(hModule);
#else
		hProcessHeap = GetProcessHeap();
#endif	
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
#ifdef USEMPHEAP
		TlsFree(tlsiHeapHint);
#else
		//	Delete the Multiple Heap CS
		
		DeleteCriticalSection(&csMHeap);
#endif		
		//	Tear-down our Debug support
		
#ifdef DEBUG
		UnInitDebugExchMem();
#endif	
	}

	return TRUE;
}


//-----------------------------------------------------------------------------
//	The Handle based ExchMem APIs
//-----------------------------------------------------------------------------

HANDLE
WINAPI
ExchHeapCreate(
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize)
{
#ifndef DEBUG
	if (dwFlags & HEAP_NO_FREE)
		dwFlags &= ~(HEAP_NO_FREE);
#endif

	return ExHeapCreate(dwFlags, dwInitialSize, dwMaxSize);
}
	
	
BOOL
WINAPI
ExchHeapDestroy(
	HANDLE	hHeap)
{
	return ExHeapDestroy(hHeap);
}
	

LPVOID
WINAPI
ExchHeapAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	DWORD	dwSize)
{
	return ExHeapAlloc(hHeap, dwFlags, dwSize);
}
	
	
LPVOID
WINAPI
ExchHeapReAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvOld,
	DWORD	dwSize)
{
	if (!pvOld)
		return ExchHeapAlloc(hHeap, dwFlags, dwSize);
		
	return ExHeapReAlloc(hHeap, dwFlags, pvOld, dwSize);
}
	
	
BOOL
WINAPI
ExchHeapFree(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvFree)
{
	return ExHeapFree(hHeap, dwFlags, pvFree);
}


SIZE_T
WINAPI
ExchHeapCompact(
	HANDLE hHeap,
	DWORD dwFlags)
{
	return ExHeapCompact(hHeap, dwFlags);
}


BOOL
WINAPI
ExchHeapLock(
	HANDLE hHeap)
{
	return ExHeapLock(hHeap);
}


BOOL
WINAPI
ExchHeapUnlock(
	HANDLE hHeap)
{
	return ExHeapUnlock(hHeap);
}


BOOL
WINAPI
ExchHeapWalk(
	HANDLE hHeap,
	LPPROCESS_HEAP_ENTRY lpEntry)
{
	return ExHeapWalk(hHeap, lpEntry);
}


SIZE_T
WINAPI
ExchHeapSize(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem)
{
	return ExHeapSize(hHeap, dwFlags, lpMem);
}


BOOL
WINAPI
ExchHeapValidate(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem)
{
	return ExHeapValidate(hHeap, dwFlags, lpMem);
}


//-----------------------------------------------------------------------------
//	The Multiple Heap APIs
//-----------------------------------------------------------------------------


HANDLE
WINAPI
ExchMHeapCreate(
	ULONG	cHeaps,
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize)
{
#ifndef	USEMPHEAP
	HANDLE		hheap0;
	HANDLE *	phHeaps;
	ULONG		iHeap;

	EnterCriticalSection(&csMHeap);
	
	//	Called twice?  The first person in gets to set the number
	//	of heaps in the table.  Subsequent calls result in an AddRef
	//	to the current table and this table is returned to the caller.

	if (pheaptbl)
	{
		pheaptbl->cRef++;
		goto ret;
	}

	//	If they didn't specify or they asked for too few then we'll set this
	
	if (cHeaps == 0)
		cHeaps = cHeapsDef;

	hheap0 = ExHeapCreate(dwFlags, dwInitialSize, dwMaxSize);

	if (!hheap0)
	{
		DebugTrace("Failed to create initial heap for MHeap APIs!\n");
		goto ret;
	}

	pheaptbl = (LPHEAPTBL)ExHeapAlloc(hheap0, 0,
			sizeof(HEAPTBL) + (cHeaps-1)*sizeof(HANDLE));

	if (!pheaptbl)
	{
		DebugTrace("Failed to allocate MHeap Table for MHeap APIs!\n");
		ExHeapDestroy(hheap0);
		goto ret;
	}

	memset(pheaptbl, 0, sizeof(HEAPTBL) + (cHeaps-1)*sizeof(HANDLE));
	
	pheaptbl->cRef			= 1;
	pheaptbl->cHeaps		= cHeaps;
	pheaptbl->rghheap[0]	= hheap0;

	//	Now, create the remaining heaps for the table.
	
	for (iHeap = 1, phHeaps = &pheaptbl->rghheap[1]; iHeap < cHeaps; iHeap++, phHeaps++)
	{
		if (!(*phHeaps = ExHeapCreate(dwFlags, dwInitialSize, dwMaxSize)))
		{
			DebugTrace("Failed to create additional heaps for MHeap APIs!\n");
			ExchMHeapDestroy();
			goto ret;
		}
	}

ret:
	LeaveCriticalSection(&csMHeap);

	return (HANDLE)pheaptbl;

#else
	//	Called twice?  The first person in gets to set the number
	//	of heaps in the table.  Subsequent calls result in an AddRef
	//	to the current table and this table is returned to the caller.

	if (InterlockedIncrement(&cRefHeap) != 0)
	{
		Assert(hMpHeap);
		return hMpHeap;
	}
	else
	{
		//
		//	NB: MpHeap doesn't support max size of heap.
		//
		return hMpHeap = MpHeapCreate(dwFlags, dwInitialSize, cHeaps);
	}
#endif
	
}
	
	
BOOL
WINAPI
ExchMHeapDestroy(void)
{
#ifndef	USEMPHEAP
	HANDLE		hHeap;
	ULONG		iHeap;

	EnterCriticalSection(&csMHeap);
	
	//	If we are called too many times, we'll complain in the
	//	Debug build, but otherwise, just return successfully!
	
	if (!pheaptbl)
	{
		DebugTrace("ExchMHeapDestroy called on invalid heap table!\n");
		goto ret;
	}
	
	//	When our RefCount goes to zero, we tear-down the MHeap Table.
	
	if (--pheaptbl->cRef == 0)
	{
		for (iHeap = pheaptbl->cHeaps-1; iHeap > 0; iHeap-- )
		{
			if (hHeap = pheaptbl->rghheap[iHeap])
				ExHeapDestroy(hHeap);
		}

		hHeap = pheaptbl->rghheap[0];
		ExHeapFree(hHeap, 0, pheaptbl);
		ExHeapDestroy(hHeap);
		pheaptbl = NULL;
	}

ret:
	LeaveCriticalSection(&csMHeap);

	return TRUE;
#else
	BOOL fRet = 1;

	if (hMpHeap)
	{
		//
		//	On last terminate blow away the heap.
		//
		if (InterlockedDecrement(&cRefHeap) < 0)
		{
			fRet = MpHeapDestroy(hMpHeap);
			hMpHeap = NULL;
		}
	}

	return fRet;
#endif
}


//DWORD GetRetAddr(void)
//{
//	DWORD *	pdwStack;	
//
//	__asm mov pdwStack, ebp
//
//	pdwStack = (DWORD *)*pdwStack;
//	pdwStack = (DWORD *)*pdwStack;
//
//	return *(pdwStack + 1);
//}


LPVOID
WINAPI
ExchMHeapAlloc(
	DWORD	dwSize)
{
#ifdef	USEMPHEAP
	return MpHeapAlloc(hMpHeap, 0, dwSize);
#else
	HANDLE		hheap;
	LPVOID		pv;

	hheap = pheaptbl->rghheap[GetCurrentThreadId() & (pheaptbl->cHeaps-1)];

	pv = ExHeapAlloc(hheap, 0, dwSize + cbMHeapHeader);
	
	if (!pv)
	{
		DebugTrace("OOM: ExchMHeapAlloc failed to allocate a new block!\n");
		return NULL;
	}

	*(HANDLE *)pv = hheap;

	return MHeapPvFromPv(pv);
#endif
}
	
LPVOID
WINAPI
ExchMHeapAllocDebug(
			   DWORD	dwSize, char *szFile, DWORD dwLine)
{
#ifdef	USEMPHEAP
	return MpHeapAlloc(hMpHeap, 0, dwSize);
#else
	HANDLE		hheap;
	LPVOID		pv;

	hheap = pheaptbl->rghheap[GetCurrentThreadId() & (pheaptbl->cHeaps-1)];

	pv = ExHeapAlloc(hheap, 0, dwSize + cbMHeapHeader);

	if (!pv)
	{
		DebugTrace("OOM: ExchMHeapAlloc failed to allocate a new block!\n");
		return NULL;
	}

	*(HANDLE *)pv = hheap;

	if (fDbgEnable)
	{
		HeapSetName2(hheap, pv, "File: %s, Line: %d", szFile, dwLine);
	}

	return MHeapPvFromPv(pv);
#endif
}


LPVOID
WINAPI
ExchMHeapReAlloc(
	LPVOID	pvOld,
	DWORD	dwSize)
{
#ifdef	USEMPHEAP
	return MpHeapReAlloc(hMpHeap, pvOld, dwSize);
#else
	LPVOID		pv;

    pv = ExHeapReAlloc(
			HandleFromMHeapPv(pvOld),
			0,
			PvFromMHeapPv(pvOld),
			dwSize + cbMHeapHeader);

	if (!pv)
	{
		DebugTrace("OOM: ExchMHeapReAlloc failed to reallocate a block!\n");
		return NULL;
	}

	return MHeapPvFromPv(pv);
#endif
}
	
LPVOID
WINAPI
ExchMHeapReAllocDebug(
				 LPVOID	pvOld,
				 DWORD	dwSize, char *szFile, DWORD dwLine)
{
#ifdef	USEMPHEAP
	return MpHeapReAlloc(hMpHeap, pvOld, dwSize);
#else
	LPVOID		pv;

	pv = ExHeapReAlloc(
					   HandleFromMHeapPv(pvOld),
					   0,
					   PvFromMHeapPv(pvOld),
					   dwSize + cbMHeapHeader);

	if (!pv)
	{
		DebugTrace("OOM: ExchMHeapReAlloc failed to reallocate a block!\n");
		return NULL;
	}

	if (fDbgEnable)
	{
		HeapSetName2(HandleFromMHeapPv(MHeapPvFromPv(pv)), pv, "File: %s, Line: %d", szFile, dwLine);
	}

	return MHeapPvFromPv(pv);
#endif
}

	
BOOL
WINAPI
ExchMHeapFree(
	LPVOID	pvFree)
{
#ifdef	USEMPHEAP
	if (pvFree)
	{
		return MpHeapFree(hMpHeap, pvFree);
	}
	else
		return FALSE;
#else
	if (pvFree)
	{
		return ExHeapFree(
				HandleFromMHeapPv(pvFree),
				0,
				PvFromMHeapPv(pvFree));
	}
	else
		return FALSE;
#endif
}


SIZE_T
WINAPI
ExchMHeapSize(
	LPVOID	pvSize)
{
	if (pvSize)
	{
#ifdef	USEMPHEAP
		return MpHeapSize(hMpHeap, 0, pvSize);
#else
		return ((ExHeapSize(
							HandleFromMHeapPv(pvSize),
							0,
							PvFromMHeapPv(pvSize))) - cbMHeapHeader);
#endif
	}
	else
		return 0;
}


//-----------------------------------------------------------------------------
//	The Heap Handle-less APIs
//-----------------------------------------------------------------------------

LPVOID
WINAPI
ExchAlloc(
	DWORD	dwSize)
{
#ifdef DEBUG
	if (!hProcessHeap)
	{
		hProcessHeap = DebugHeapCreate(0, 0, 0);
		HeapSetHeapName(hProcessHeap, "Default ExchMem Heap");
	}
#endif	// DEBUG

	return ExHeapAlloc(hProcessHeap, 0, dwSize);
}


LPVOID
WINAPI
ExchReAlloc(
	LPVOID	pvOld,
	DWORD	dwSize)
{
	if (!pvOld)
		return ExchAlloc(dwSize);
		
	return ExHeapReAlloc(hProcessHeap, 0, pvOld, dwSize);
}
	

BOOL
WINAPI
ExchFree(
	LPVOID	pvFree)
{
	return ExHeapFree(hProcessHeap, 0, pvFree);
}


SIZE_T
WINAPI
ExchSize(
	LPVOID	pv)
{
#ifdef DEBUG
	if (!hProcessHeap)
	{
		hProcessHeap = DebugHeapCreate(0, 0, 0);
		HeapSetHeapName(hProcessHeap, "Default ExchMem Heap");
	}
#endif	// DEBUG

	return ExHeapSize(hProcessHeap, 0, pv);
}


//-----------------------------------------------------------------------------
//	All debug code starts here!
//-----------------------------------------------------------------------------

#ifdef DEBUG

//-----------------------------------------------------------------------------
//	Implementaion of C-Runtimes that use malloc memory
//-----------------------------------------------------------------------------

static char szDebugIni[]			= "EXCHMEM.INI";

static char szSectionAppNames[]		= "Apps To Track";

static char szSectionHeap[]			= "Memory Management";
static char szKeyUseVirtual[]		= "VirtualMemory";
static char szKeyVirtualAlign[]		= "VirtualAlign";
static char szKeyAssertLeaks[]		= "AssertLeaks";
static char szKeyDumpLeaks[]		= "DumpLeaks";
static char szKeyDumpLeaksDebugger[]= "DumpLeaksToDebugger";
static char szKeyFillMem[]			= "FillMemory";
static char szKeyAllocFillByte[]	= "AllocFillByte";
static char szKeyFreeFillByte[]		= "FreeFillByte";
static char szKeyTrackMem[]			= "TrackMemory";
static char szKeyTrackMemInMem[]	= "TrackMemoryInMemory";
static char szKeyStackFrames[]		= "StackFrames";
static char szKeySymbolLookup[]		= "SymbolLookup";
static char szKeyOverwriteDetect[]	= "OverwriteDetect";
static char szKeyValidateMemory[]	= "ValidateMemory";
static char szKeyTrackFreedMemory[]	= "TrackFreedMemory";
static char szKeyFreedMemorySize[]	= "FreedMemorySize";
static char szKeyAssertValid[]		= "AssertValid";
static char szKeyTrapOnInvalid[]	= "TrapOnInvalid";
static char szKeySymPath[]			= "SymPath";
static char szKeyLogPath[]			= "LogPath";

static char szSectionAF[]			= "Heap Resource Failures";
static char szKeyAFEnabled[]		= "FailuresEnabled";
static char szKeyAFStart[]			= "AllocsToFirstFailure";
static char szKeyAFInterval[]		= "FailureInterval";
static char szKeyAFBufSize[]		= "FailureSize";

static char szKeyHeapMon[]			= "MonitorHeap";
static char szHeapMonDLL[]			= "GLHMON32.DLL";
static char szHeapMonEntry[]		= "HeapMonitor";
static char szGetSymNameEntry[]		= "GetSymbolName";

static char szAllocationFault[]		= "FaultingAllocationNumber";

/*
 -	InitDebugExchMem
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

BOOL InitDebugExchMem(HMODULE hModule)
{
	ULONG	cch;
	char *	pch;
	char	rgchModulePath[MAX_PATH];
	
	//	Get the executable name and search look in exchmem.ini
	//	to see if we are interested in memory tracing for this
	//	process.  The ini section looks like this:
	//
	//		[Apps To Track]
	//		store=1
	//		emsmta=0
	//		dsamain=0
	//
	//	etc.  This sample specifies that only the store is to
	//	be enabled for memory tracking.
	
	GetModuleFileName(NULL, rgchModulePath, MAX_PATH);
	RemoveExtension(rgchModulePath);

	pch = rgchModulePath + lstrlen(rgchModulePath) - 1;
	
	while (*pch != '\\' && pch >= rgchModulePath)
		pch--;

	lstrcpy(rgchExeName, ++pch);
	
	fDbgEnable = !!(BOOL)GetPrivateProfileIntA(szSectionAppNames,
				rgchExeName, 0, szDebugIni);

	//	Store module handle in global var
	
	hMod = hModule;

	if (!hinstRunTime)
	{
		hinstRunTime = LoadLibrary("msvcrt.dll");
		
		if (!hinstRunTime)
		{
			DebugTrace("EXCHMEM: Failed to load the run-time dll!\n");
			return FALSE;
		}
		
		pfMalloc = (LPFMALLOC)GetProcAddress(hinstRunTime, "malloc");
		
		if (!pfMalloc)
		{
			DebugTrace("EXCHMEM: Failed to GetProcAddress of malloc in run-time dll!\n");
			FreeLibrary(hinstRunTime);
			return FALSE;
		}
		
		pfRealloc = (LPFREALLOC)GetProcAddress(hinstRunTime, "realloc");
		
		if (!pfRealloc)
		{
			DebugTrace("EXCHMEM: Failed to GetProcAddress of realloc in run-time dll!\n");
			FreeLibrary(hinstRunTime);
			return FALSE;
		}
		
		pfFree = (LPFFREE)GetProcAddress(hinstRunTime, "free");
		
		if (!pfFree)
		{
			DebugTrace("EXCHMEM: Failed to GetProcAddress of free in run-time dll!\n");
			FreeLibrary(hinstRunTime);
			return FALSE;
		}
		
		pfCalloc = (LPFCALLOC)GetProcAddress(hinstRunTime, "calloc");
		
		if (!pfCalloc)
		{
			DebugTrace("EXCHMEM: Failed to GetProcAddress of calloc in run-time dll!\n");
			FreeLibrary(hinstRunTime);
			return FALSE;
		}
		
		pfStrDup = (LPFSTRDUP)GetProcAddress(hinstRunTime, "_strdup");
		
		if (!pfStrDup)
		{
			DebugTrace("EXCHMEM: Failed to GetProcAddress of _strdup in run-time dll!\n");
			FreeLibrary(hinstRunTime);
			return FALSE;
		}
		
		pfMemSize = (LPFMEMSIZE)GetProcAddress(hinstRunTime, "_msize");
		
		if (!pfMemSize)
		{
			DebugTrace("EXCHMEM: Failed to GetProcAddress of _msize in run-time dll!\n");
			FreeLibrary(hinstRunTime);
			return FALSE;
		}
	}
	
	//	Lookup symbols or just log addresses?

	fSymbolLookup = GetPrivateProfileIntA(szSectionHeap, szKeySymbolLookup, 0, szDebugIni);

	if (!fDbgEnable)
	{
		if (fSymbolLookup && !fSymInitialize)
		{
			char	rgchSymPath[MAX_PATH];

			rgsymcacheHashTable = VirtualAlloc(
											   NULL,
											   NBUCKETS*sizeof(SYMCACHE),
											   MEM_COMMIT,
											   PAGE_READWRITE);

			if (rgsymcacheHashTable == NULL)
			{
				return FALSE;
			}
			GetPrivateProfileString(szSectionHeap,
									szKeySymPath,
									"c:\\exchsrvr\\bin;.",
									rgchSymPath,
									MAX_PATH-1,
									szDebugIni);

			{
				DWORD	dwOptions;

				dwOptions = SymGetOptions();
				SymSetOptions(dwOptions | SYMOPT_DEFERRED_LOADS);
			}

			SymInitialize(GetCurrentProcess(), rgchSymPath, TRUE);
			fSymInitialize = TRUE;
		}
		goto ret;
	}
		
	//	This CS protects access to a list of all live heaps
	
	InitializeCriticalSection(&csHeapList);
	
	//	Initialize support for memory monitoring and leak detection
	
	fDumpLeaks = GetPrivateProfileIntA(szSectionHeap, szKeyDumpLeaks, 0, szDebugIni);
	fDumpLeaksDebugger = GetPrivateProfileIntA(szSectionHeap, szKeyDumpLeaksDebugger, 0, szDebugIni);
	fAssertLeaks = GetPrivateProfileIntA(szSectionHeap, szKeyAssertLeaks, 0, szDebugIni);
	fUseVirtual = GetPrivateProfileIntA(szSectionHeap, szKeyUseVirtual, 0, szDebugIni);
	
	if (fUseVirtual)
		cbVirtualAlign = GetPrivateProfileIntA(szSectionHeap, szKeyVirtualAlign, 1, szDebugIni);
		
	fFillMemory = GetPrivateProfileIntA(szSectionHeap, szKeyFillMem, 0, szDebugIni);

	if (fFillMemory)
	{
		char	szFillByte[8];
		
		//	Set the memory fill characters.
	
		if (GetPrivateProfileString(
				szSectionHeap,
				szKeyAllocFillByte,
				"", szFillByte,
				sizeof(szFillByte)-1,
				szDebugIni))
			chAllocFillByte = HexByteToBin(szFillByte);

		if (GetPrivateProfileString(
				szSectionHeap,
				szKeyFreeFillByte,
				"", szFillByte,
				sizeof(szFillByte)-1,
				szDebugIni))
			chFreeFillByte = HexByteToBin(szFillByte);
	}
	
//$ISSUE
	//	For now, just use virtual to detect overwrites!
	//	Maybe I'll change this later to use pads on the
	//	front and back side of a block. -RLS
	
	fOverwriteDetect = GetPrivateProfileIntA(szSectionHeap, szKeyOverwriteDetect, 0, szDebugIni);
	fValidateMemory = GetPrivateProfileIntA(szSectionHeap, szKeyValidateMemory, 0, szDebugIni);
	fTrackFreedMemory = GetPrivateProfileIntA(szSectionHeap, szKeyTrackFreedMemory, 0, szDebugIni);
	cEntriesFree = GetPrivateProfileIntA(szSectionHeap, szKeyFreedMemorySize, 512, szDebugIni);
	fAssertValid = GetPrivateProfileIntA(szSectionHeap, szKeyAssertValid, 0, szDebugIni);
	fTrapOnInvalid = GetPrivateProfileIntA(szSectionHeap, szKeyTrapOnInvalid, 0, szDebugIni);
	fHeapMonitorUI = GetPrivateProfileIntA(szSectionHeap, szKeyHeapMon, 0, szDebugIni);
	fFailuresEnabled = GetPrivateProfileIntA(szSectionAF, szKeyAFEnabled, 0, szDebugIni);



	//	Get file path to write log files into
		
	GetPrivateProfileString(szSectionHeap,
				szKeyLogPath,
				".\\",
				rgchLogPath,
				MAX_PATH-1,
				szDebugIni);
		
	cch = lstrlen(rgchLogPath);
	
	if (rgchLogPath[cch-1] != '\\')
	{
		rgchLogPath[cch]   = '\\';
		rgchLogPath[cch+1] = '\0';
	}
				
	//	Initialize support for memory usage tracking
	
	fTrackMem = GetPrivateProfileIntA(szSectionHeap, szKeyTrackMem, 0, szDebugIni);
	if (fTrackMem)
		StartTrace(TRUE);

	// This is for keeping track of the last x mem functions in a circular list in memory.
	// This doesn't slow things down as much as tracing everything to disk and can be useful
	// in finding memory problems that are timing related.
	
	dwTrackMemInMem = GetPrivateProfileIntA(szSectionHeap, szKeyTrackMemInMem, 0, szDebugIni);
	if (dwTrackMemInMem)
	{
		fTrackMem = TRUE;
		rgmemtrace = VirtualAlloc(
					   NULL,
					   dwTrackMemInMem*sizeof(MEMTRACE),
					   MEM_COMMIT,
					   PAGE_READWRITE);
	}

	//	How many Stack Frames does the user want traced?
	
	cFrames = GetPrivateProfileIntA(szSectionHeap, szKeyStackFrames, 0, szDebugIni);
	
	if (cFrames > NSTK)
		cFrames = NSTK;

	//	This is used in the debug build to determine if we will
	//	allow the HeapMonitor UI or not.  We do not allow it if
	//	the process that is attaching to us is a service.

	fProcessIsService = IsProcessRunningAsService();

	//	Initialize the symbols stuff for imagehlp.dll

	fCallStacks = (fDumpLeaks || fAssertLeaks || fTrackMem || fHeapMonitorUI || fValidateMemory);
	
	if (cFrames && fCallStacks && !fSymInitialize)
	{
		char	rgchSymPath[MAX_PATH];
		
		rgsymcacheHashTable = VirtualAlloc(
								NULL,
								NBUCKETS*sizeof(SYMCACHE),
								MEM_COMMIT,
								PAGE_READWRITE);
		
		if (rgsymcacheHashTable == NULL)
		{
			return FALSE;
		}
		GetPrivateProfileString(szSectionHeap,
				szKeySymPath,
				"c:\\exchsrvr\\bin;.",
				rgchSymPath,
				MAX_PATH-1,
				szDebugIni);

		{
			DWORD	dwOptions;

			dwOptions = SymGetOptions();
			SymSetOptions(dwOptions | SYMOPT_DEFERRED_LOADS);
		}

		SymInitialize(GetCurrentProcess(), rgchSymPath, TRUE);
		fSymInitialize = TRUE;
	}

ret:	
	return TRUE;
}


/*
 -	UnInitDebugExchMem
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

VOID UnInitDebugExchMem(VOID)
{
	PHEAP pheap = pheapList;
	
	while (pheap)
	{
		if (fDumpLeaks && (pheap->ulFlags & HEAP_NO_FREE))
			HeapDumpLeaks(pheap, TRUE);
		
		pheap = pheap->pNext;	
	}
	
	if (hProcessHeap)
		DebugHeapDestroy(hProcessHeap);
	
	if (hinstRunTime)
	{
		FreeLibrary(hinstRunTime);
		
		hinstRunTime	= NULL;
		pfMalloc		= NULL;
		pfRealloc		= NULL;
		pfFree			= NULL;
		pfCalloc		= NULL;
		pfStrDup		= NULL;
		pfMemSize		= NULL;
	}
	
	if (fDbgEnable)
	{
		if (fSymInitialize)
		{
			VirtualFree(rgsymcacheHashTable, NBUCKETS*sizeof(SYMCACHE), MEM_DECOMMIT);
			VirtualFree(rgsymcacheHashTable, 0, MEM_RELEASE);
			SymCleanup(GetCurrentProcess());
			fSymInitialize = FALSE;
		}
		
		DeleteCriticalSection(&csHeapList);
		
		StopTrace();

		if (dwTrackMemInMem)
		{
			VirtualFree(rgmemtrace, dwTrackMemInMem*sizeof(MEMTRACE), MEM_DECOMMIT);
			VirtualFree(rgmemtrace, 0, MEM_RELEASE);
		}
	}
}


/*
 -	calloc
 -
 *	Purpose:
 *		Replace the calloc() function supplied in the c-runtimes.  Like
 *		malloc() except zero fills the memory that is allocated.
 *
 *	Parameters:
 *		cStructs		Number of objects the caller wants room for
 *		cbStructs		Size of an individual object
 *
 *	Returns:
 *		pv				Pointer to zero filled memory of size: cStructs*cbStructs
 *
 */

void *
__cdecl
calloc(
	size_t cStructs,
	size_t cbStructs)
{
	void * pv;
	
	pv = pfCalloc(cStructs, cbStructs);
	
	if (fDbgEnable && FTrackMem())
	{
		DWORD_PTR	rgdwArgs[4];
		DWORD_PTR	rgdwCallers[NSTK];

		GetCallStack(rgdwCallers, cFrames);

		rgdwArgs[0] = (DWORD_PTR)0x00001000;
		rgdwArgs[1] = (DWORD_PTR)(cStructs*cbStructs);
		rgdwArgs[2] = (DWORD_PTR)pv;
		
		LogCurrentAPI(API_HEAP_ALLOC, rgdwCallers, cFrames, rgdwArgs, 3);
	}
	
	return pv;
}


/*
 -	free
 -
 *	Purpose:
 *		To free memory allocated with malloc(0, realloc(), or calloc().
 *
 *	Parameters:
 *		pv				Pointer to memory buffer to free
 *
 *	Returns:
 *		void
 *
 */

void
__cdecl
free(
	void *pv)
{
	if (fDbgEnable && FTrackMem())
	{
		DWORD_PTR	rgdwArgs[4];
		DWORD_PTR	rgdwCallers[NSTK];

		GetCallStack(rgdwCallers, cFrames);

		rgdwArgs[0] = (DWORD_PTR)0x00001000;
		rgdwArgs[1] = (DWORD_PTR)pv;
		rgdwArgs[2] = (pv ? (DWORD_PTR)pfMemSize(pv) : 0);
		
		LogCurrentAPI(API_HEAP_FREE, rgdwCallers, cFrames, rgdwArgs, 3);
	}
	
	pfFree(pv);
}


/*
 -	malloc
 -
 *	Purpose:
 *		To allocate a memory buffer of size cb.
 *
 *	Parameters:
 *		cb				Size of memory buffer to allocate
 *
 *	Returns:
 *		pv				Pointer to memory buffer
 *
 */

void *
__cdecl
malloc(
	size_t cb)
{
	void * pv;
	
	pv = pfMalloc(cb);
	
	if (fDbgEnable && FTrackMem())
	{
		DWORD_PTR	rgdwArgs[4];
		DWORD_PTR	rgdwCallers[NSTK];

		GetCallStack(rgdwCallers, cFrames);

		rgdwArgs[0] = (DWORD_PTR)0x00001000;
		rgdwArgs[1] = (DWORD_PTR)cb;
		rgdwArgs[2] = (DWORD_PTR)pv;
		
		LogCurrentAPI(API_HEAP_ALLOC, rgdwCallers, cFrames, rgdwArgs, 3);
	}

	return pv;
}


/*
 -	realloc
 -
 *	Purpose:
 *		To resize a memory buffer allocated with malloc().
 *
 *	Parameters:
 *		pv				Pointer to original memory buffer
 *		cb				New size of memory buffer to be allocated
 *
 *	Returns:
 *		pvNew			Pointer to new memory buffer
 *
 */

void *
__cdecl
realloc(
	void *pv,
	size_t cb)
{
	void * pvNew;
	DWORD dwSize;
	BOOL fTrackMem = FTrackMem();

	if (fDbgEnable && fTrackMem)
		dwSize = (pv ? pfMemSize(pv) : 0);
	
	pvNew = pfRealloc(pv, cb);
	
	if (fDbgEnable && fTrackMem)
	{
		DWORD_PTR	rgdwArgs[5];
		DWORD_PTR	rgdwCallers[NSTK];

		GetCallStack(rgdwCallers, cFrames);

		rgdwArgs[0] = (DWORD_PTR)0x00001000;
		rgdwArgs[1] = dwSize;
		rgdwArgs[2] = (DWORD_PTR)pv;
		rgdwArgs[3] = (DWORD_PTR)cb;
		rgdwArgs[4] = (DWORD_PTR)pvNew;
		
		LogCurrentAPI(API_HEAP_REALLOC, rgdwCallers, cFrames, rgdwArgs, 5);
	}

	return pvNew;
}


/*
 -	_strdup
 -
 *	Purpose:
 *		To allocate a memory buffer large enough to hold sz, copy
 *		the contents of sz into the new buffer and return the new
 *		buffer to the caller (i.e. make a copy of the string).
 *
 *	Parameters:
 *		sz				Pointer to null terminated string to copy
 *
 *	Returns:
 *		szNew			Pointer to new copy of sz
 *
 */

char *
__cdecl
_strdup(
	const char *sz)
{
	return pfStrDup(sz);
}


//-----------------------------------------------------------------------------
//	ExchMem Heap Debug Implementation
//-----------------------------------------------------------------------------


VOID
EnqueueHeap(PHEAP pheap)
{
	EnterCriticalSection(&csHeapList);
	
	if (pheapList)
		pheap->pNext = pheapList;

	pheapList = pheap;

	LeaveCriticalSection(&csHeapList);
}


VOID
DequeueHeap(PHEAP pheap)
{
	PHEAP	pheapPrev = NULL;
	PHEAP	pheapCurr;
	
	EnterCriticalSection(&csHeapList);
	
	pheapCurr = pheapList;

	while (pheapCurr)
	{
		if (pheapCurr == pheap)
			break;
		
		pheapPrev = pheapCurr;
		pheapCurr = pheapCurr->pNext;	
	}
	
	if (pheapCurr)
	{
		if (pheapPrev)
			pheapPrev->pNext = pheapCurr->pNext;
		else
			pheapList = pheapCurr->pNext;
	}

	LeaveCriticalSection(&csHeapList);
}


HANDLE
WINAPI
DebugHeapCreate(
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize)
{
	HANDLE	hDataHeap = 0;
	HANDLE	hBlksHeap = 0;
	PHEAP	pheap = NULL;
	
	if (!fDbgEnable)
		return HeapCreate(dwFlags, dwInitialSize, dwMaxSize);

	//	The first thing we must do is create a heap that we will
	//	allocate our Allocation Blocks on.  We also allocate our
	//	debug Heap object on this heap.

	hBlksHeap = HeapCreate(HEAP_NO_SERIALIZE, 0, 0);
	
	if (!hBlksHeap)
	{
		DebugTrace("HEAP_Open: Failed to create new heap!\n");
		goto ret;
	}
	
	//	Allocate the thing we hand back to the caller on this new heap.
	
	pheap = HeapAlloc(hBlksHeap, 0, sizeof(HEAP));
	
	if (!pheap)
	{
		DebugTrace("HEAP_Alloc: Failed to allocate heap handle!\n");
		HeapDestroy(hBlksHeap);
		hBlksHeap = NULL;
		goto ret;
	}
	
	//	Initialize all the goodies we store in this thing.
	//	Hook this heap into the global list of heaps we've
	//	created in this context.
	
	memset(pheap, 0, sizeof(HEAP));

	pheap->pfnSetName	= (LPHEAPSETNAME)HeapSetNameFn;
	pheap->hBlksHeap	= hBlksHeap;
	pheap->ulFlags		= HEAP_LOCAL;

	if (dwFlags & HEAP_NO_FREE)
	{
		pheap->ulFlags |= HEAP_NO_FREE;
		dwFlags &= ~(HEAP_NO_FREE);
	}
	
	InitializeCriticalSection(&pheap->cs);
	
	// VirtualMemory default is FALSE

	if (fUseVirtual)
	{
		pheap->ulFlags |= HEAP_USE_VIRTUAL;

		// We always want virtual allocations on RISC to be 4-byte aligned
		// because all our code assumes that the beginning of an allocation
		// is aligned on machine word boundaries.  On other platforms,
		// changing this behavior is non-fatal, but on RISC platforms we'll
		// get alignment faults everywhere.
		
#if defined(_X86_)
		if (cbVirtualAlign == 4)
#else
			cbVirtualAlign = 4;
#endif
			pheap->ulFlags |= HEAP_USE_VIRTUAL_4;
	}
		
	// DumpLeaks default is TRUE

	if (fDumpLeaks)
		pheap->ulFlags |= HEAP_DUMP_LEAKS;
	
	// AssertLeaks default is FALSE

	if (fAssertLeaks)
		pheap->ulFlags |= HEAP_ASSERT_LEAKS;
	
	// FillMem default is TRUE

	if (fFillMemory)
	{
		pheap->ulFlags |= HEAP_FILL_MEM;
		pheap->chFill = chAllocFillByte;
	}

	//  Set up artificial failures.  If anything is set in our ini file, then
	//  HEAP_FAILURES_ENABLED gets set.

	if (fFailuresEnabled)
	{
		pheap->ulFlags |= HEAP_FAILURES_ENABLED;

		pheap->ulFailStart = (ULONG)GetPrivateProfileInt(szSectionAF,
				szKeyAFStart, 0, szDebugIni);
		
		pheap->ulFailInterval = (ULONG)GetPrivateProfileInt(szSectionAF,
				szKeyAFInterval, 0, szDebugIni);

		pheap->ulFailBufSize = (ULONG)GetPrivateProfileInt(szSectionAF,
				szKeyAFBufSize, 0, szDebugIni);

		pheap->iAllocationFault = GetPrivateProfileIntA(szSectionAF,
				szAllocationFault, 0, szDebugIni);
	}

	//	If the user wants Heap Monitor UI, the spin a thread to manage a
	//	DialogBox that can display the status of the heap at all times.

	if (fHeapMonitorUI && !fProcessIsService)
		if (FRegisterHeap(pheap))
			pheap->ulFlags |= HEAP_HEAP_MONITOR;

	//	If we are not using virtual memory allocators, then we
	//	create another heap to allocate the users data in.
	
	if (!fUseVirtual)
	{
		hDataHeap = HeapCreate(dwFlags, dwInitialSize, dwMaxSize);

		if (!hDataHeap)
		{
			DebugTrace("HeapAlloc: Failed to allocate heap handle!\n");
			HeapDestroy(hBlksHeap);
			pheap = NULL;
			goto ret;
		}
		
		pheap->hDataHeap = hDataHeap;
	}

	//	Name heap
	
	HeapSetHeapName1(pheap, "ExchMem Heap: %08lX", pheap);

	//	Remove heap from list
	
	EnqueueHeap(pheap);

	if (FTrackMem())
	{
		DWORD_PTR	rgdwArgs[4];
		DWORD_PTR	rgdwCallers[NSTK];

		GetCallStack(rgdwCallers, cFrames);

		rgdwArgs[0] = dwInitialSize;
		rgdwArgs[1] = dwMaxSize;
		rgdwArgs[2] = (DWORD_PTR)hDataHeap;
		
		LogCurrentAPI(API_HEAP_CREATE, rgdwCallers, cFrames, rgdwArgs, 3);
	}
	
ret:
	return (HANDLE)pheap;
}	


BOOL
WINAPI
DebugHeapDestroy(
	HANDLE	hHeap)
{
	PHEAP	pheap = (PHEAP)hHeap;
	HANDLE	hDataHeap = pheap->hDataHeap;
	HANDLE	hBlksHeap = pheap->hBlksHeap;

	if (!fDbgEnable)
		return HeapDestroy(hHeap);
		
	//	Remove heap from list
	
	DequeueHeap(pheap);
	
	//	Dump memory leaks if we're supposed to.
	
	if (fDumpLeaks && !(pheap->ulFlags & HEAP_NO_FREE))
		HeapDumpLeaks(pheap, FALSE);
	
	//
	//	Free the entries in the free list.
	//
	//	This isn't totally necessary, since destroying the heap destroys the free list, but what the
	//	heck, it's cleaner to do it this way.
	//
	while (pheap->phblkFree)
	{
		PHBLK phblk = pheap->phblkFree;

		pheap->phblkFree = phblk->phblkFreeNext;

		//
		//	And now free up the block for real, it's too old.
		//

		if (fUseVirtual)
			VMFreeEx((fOverwriteDetect ? PvHeadFromPv(phblk->pv) : phblk->pv), cbVirtualAlign);
		else
			HeapFree(pheap->hDataHeap, 0,
							(fOverwriteDetect ? PvHeadFromPv(phblk->pv) : phblk->pv));
		
		HeapFree(pheap->hBlksHeap, 0, phblk);

	}

	//	Destroy the HeapMonitor thread and un-load the DLL
	
	UnRegisterHeap(pheap);
	
	if (fHeapMonitorUI && pheap->hInstHeapMon)
		FreeLibrary(pheap->hInstHeapMon);

	DeleteCriticalSection(&pheap->cs);
	
	//	Clean-up and leave.  Closing frees leaks, so we're cool!
	
	if (!fUseVirtual && hDataHeap)
	{
		HeapDestroy(hDataHeap);
	}
		
	if (hBlksHeap)
	{
		HeapFree(hBlksHeap, 0, pheap);
		HeapDestroy(hBlksHeap);
	}
	
	if (FTrackMem())
	{
		DWORD_PTR	rgdwArgs[4];
		DWORD_PTR	rgdwCallers[NSTK];

		GetCallStack(rgdwCallers, cFrames);

		rgdwArgs[0] = (DWORD_PTR)hDataHeap;
		
		LogCurrentAPI(API_HEAP_DESTROY, rgdwCallers, cFrames, rgdwArgs, 1);
	}
	
	return TRUE;
}


LPVOID
WINAPI
DebugHeapAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	DWORD	dwSize)
{
	PHEAP	pheap = (PHEAP)hHeap;
	PHBLK	phblk = NULL;
	LPVOID	pvAlloc = NULL;
	
	if (!fDbgEnable)
		return HeapAlloc(hHeap, dwFlags, dwSize);
		
	// Note:  To be consistent with other (e.g. system) allocators,
	// we have to return a valid allocation if dwSize == 0.  So, we
	// allow a dwSize of 0 to actually be allocated.  (See bug 3556 in
	// the sqlguest:exchange database.)

	EnterCriticalSection(&pheap->cs);

	if (fFailuresEnabled)
	{
		if (pheap->ulAllocNum == pheap->iAllocationFault)
		{
			DebugTrace("HeapRealloc: Allocation Fault hit\n");
			DebugBreak();
		}

		if (FForceFailure(pheap, dwSize))
		{
			DebugTrace("HeapAlloc: Artificial Failure\n");
			pvAlloc = NULL;
			pheap->ulAllocNum++;
	        LeaveCriticalSection(&pheap->cs);
			goto ret;
		}
	}

	//	We have to leave the CS before calling HeapAlloc in case the user
	//	created this heap with the HEAP_GENERATE_EXCEPTIONS flag set, which,
	//	if thrown, would cause us to exit here with our CS held - a bad thing...
	
	LeaveCriticalSection(&pheap->cs);

	if (fUseVirtual)
		pvAlloc = VMAllocEx((fOverwriteDetect ? (dwSize + 2*cbOWSection) : dwSize), cbVirtualAlign);
	else
		pvAlloc = HeapAlloc(pheap->hDataHeap, dwFlags,
				(fOverwriteDetect ? (dwSize + 2*cbOWSection) : dwSize));
	
	//	Now, re-aquire the CS and finish our work.  We do not create the
	//	BlksHeap with the HEAP_GENERATE_EXCEPTIONS flag so we're cool.
	
	EnterCriticalSection(&pheap->cs);

	if (pvAlloc)
	{
		phblk = (PHBLK)HeapAlloc(pheap->hBlksHeap, 0, sizeof(HBLK));
		
		if (phblk)
		{
			if (fOverwriteDetect)
			{
				//	Fill the Head and Tail overwrite detection
				//	blocks special fill character: 0xAB.
				
				memset(pvAlloc,
						chOWFill,
						cbOWSection);
						
				memset(PvTailFromPvHead(pvAlloc, dwSize),
						chOWFill,
						cbOWSection);
				
				//	Now, advance pvAlloc to user portion of buffer
				
				pvAlloc = PvFromPvHead(pvAlloc);		
			}
			
			phblk->pheap		= pheap;
			phblk->szName[0]	= '\0';
			phblk->ulSize		= dwSize;
			phblk->ulAllocNum	= ++pheap->ulAllocNum;
			phblk->pv			= pvAlloc;
			phblk->phblkPrev	= NULL;
			phblk->phblkNext	= NULL;
			phblk->phblkFreeNext= NULL;

			ZeroMemory(phblk->rgdwCallers, cFrames*sizeof(DWORD));
			ZeroMemory(phblk->rgdwFree, cFrames*sizeof(DWORD));

			PhblkEnqueue(phblk);

			if (fCallStacks)
				GetCallStack(phblk->rgdwCallers, cFrames);

			if (fFillMemory && !(dwFlags & HEAP_ZERO_MEMORY))
				memset(pvAlloc, pheap->chFill, (size_t)dwSize);

			if (FTrackMem())
			{
				DWORD_PTR	rgdwArgs[4];

				rgdwArgs[0] = (DWORD_PTR)pheap->hDataHeap;
				rgdwArgs[1] = dwSize;
				rgdwArgs[2] = (DWORD_PTR)pvAlloc;
		
				LogCurrentAPI(API_HEAP_ALLOC, phblk->rgdwCallers, cFrames, rgdwArgs, 3);
			}
		}
		else
		{
			if (fUseVirtual)
				VMFreeEx(pvAlloc, cbVirtualAlign);
			else
				HeapFree(pheap->hDataHeap, dwFlags, pvAlloc);
			
			pvAlloc = NULL;	
		}
	}

	LeaveCriticalSection(&pheap->cs);
	
ret:
	return pvAlloc;
}	


LPVOID
WINAPI
DebugHeapReAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvOld,
	DWORD	dwSize)
{
	PHEAP	pheap = (PHEAP)hHeap;
	LPVOID	pvNew = NULL;
	PHBLK	phblk;
	UINT	cbOld;

	if (!fDbgEnable)
		return HeapReAlloc(hHeap, dwFlags, pvOld, dwSize);
		
	if (pvOld == 0)
	{
		pvNew = DebugHeapAlloc(hHeap, dwFlags, dwSize);
	}
	else
	{
		EnterCriticalSection(&pheap->cs);

		if (fValidateMemory)
		{
			if (!HeapValidatePv(pheap, pvOld, "DebugHeapReAlloc"))
			{
				LeaveCriticalSection(&pheap->cs);
				goto ret;
			}
		}
		
		phblk	= PvToPhblk(pheap, pvOld);
		cbOld	= (UINT)CbPhblkClient(phblk);

		PhblkDequeue(phblk);

		//	We have to leave the CS before calling HeapReAlloc in case the user
		//	created this heap with the HEAP_GENERATE_EXCEPTIONS flag set, which,
		//	if thrown, would cause us to exit here with our CS held - a bad thing...
	
		LeaveCriticalSection(&pheap->cs);

		if (fFailuresEnabled && pheap->ulAllocNum >= pheap->iAllocationFault)
		{
			DebugTrace("HeapRealloc: Allocation Fault hit\n");
			DebugBreak();
		}
		else if (fFailuresEnabled && FForceFailure(pheap, dwSize) && (dwSize > cbOld))
		{
			InterlockedIncrement((LPLONG)&pheap->ulAllocNum);
			pvNew = 0;
			DebugTrace("HeapRealloc: Artificial Failure\n");
		}
		else if (fUseVirtual)
			pvNew = VMReallocEx(fOverwriteDetect ? PvHeadFromPv(pvOld) : pvOld,
								(fOverwriteDetect ? (dwSize + 2*cbOWSection) : dwSize),
								cbVirtualAlign);
		else
			pvNew = HeapReAlloc(pheap->hDataHeap, dwFlags,
					(fOverwriteDetect ? PvHeadFromPv(pvOld) : pvOld),
					(fOverwriteDetect ? (dwSize + 2*cbOWSection) : dwSize));

		//	Now, re-aquire the CS and finish our work.
		
		EnterCriticalSection(&pheap->cs);

		if (pvNew)
		{
			if (fOverwriteDetect)
			{
				//	Fill the Head and Tail overwrite detection
				//	blocks special fill character: 0xAB.
				
				memset(pvNew,
						chOWFill,
						cbOWSection);

				memset(PvTailFromPvHead(pvNew, dwSize),
						chOWFill,
						cbOWSection);

				//	Now, advance pvNew to user portion of buffer

				pvNew = PvFromPvHead(pvNew);		
			}
			
			if (fCallStacks)
				GetCallStack(phblk->rgdwCallers, cFrames);

			if (fFillMemory && (dwSize > cbOld) && !(dwFlags & HEAP_ZERO_MEMORY))
				memset((LPBYTE)pvNew + cbOld, pheap->chFill, dwSize - cbOld);

			phblk->pv			= pvNew;
			phblk->ulSize		= dwSize;
			phblk->ulAllocNum	= ++pheap->ulAllocNum;
			phblk->phblkPrev	= NULL;
			phblk->phblkNext	= NULL;
			phblk->phblkFreeNext= NULL;
		}
		else
		{
			phblk->phblkPrev	= NULL;
			phblk->phblkNext	= NULL;
			phblk->phblkFreeNext= NULL;
		}		

		PhblkEnqueue(phblk);

		if (FTrackMem())
		{
			DWORD_PTR	rgdwArgs[5];

			rgdwArgs[0] = (DWORD_PTR)pheap->hDataHeap;
			rgdwArgs[1] = (DWORD_PTR)cbOld;
			rgdwArgs[2] = (DWORD_PTR)pvOld;
			rgdwArgs[3] = dwSize;
			rgdwArgs[4] = (DWORD_PTR)pvNew;
			
			LogCurrentAPI(API_HEAP_REALLOC, phblk->rgdwCallers, cFrames, rgdwArgs, 5);
		}

   		LeaveCriticalSection(&pheap->cs);
	}

ret:	
	return pvNew;
}	

PHBLK
PhblkSearchFreeList(PHEAP pheap, LPVOID pv)
{
	PHBLK phblkT = pheap->phblkFree;

	//
	//	Walk the free list looking for this block, and if we find it, free it.
	//
	while (phblkT != NULL)
	{
		if (phblkT->pv == pv)
		{
			return phblkT;
		}
		phblkT = phblkT->phblkFreeNext;
	}
	return NULL;
}



BOOL
WINAPI
DebugHeapFree(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvFree)
{
	PHEAP	pheap = (PHEAP)hHeap;
	BOOL	fRet = TRUE;
	DWORD 	dwSize = 0;

	if (!fDbgEnable)
		return HeapFree(hHeap, dwFlags, pvFree);
		
	EnterCriticalSection(&pheap->cs);

	//
	//	If we're tracking freed memory, then we don't actually free the blocks, we remember where they
	//	are on the freed block list.
	//
	if (pvFree)
	{
		PHBLK	phblk;

		phblk = PvToPhblk(pheap, pvFree);
		dwSize = (size_t)CbPhblkClient(phblk);

		if (!fValidateMemory || HeapValidatePv(pheap, pvFree, "DebugHeapFree"))
		{
			//
			//	remove this phblk from the list of allocated blocks - as far as the heap is concerned, it's
			//	no longer allocated.
			//
			PhblkDequeue(phblk);

			//
			//	And fill the block with the free block pattern if appropriate.
			//

			if (fFillMemory)
			{

				memset(pvFree, chFreeFillByte, dwSize);

			}

			if (fTrackFreedMemory)
			{
				PHBLK phblkT;

				if (fCallStacks)
					GetCallStack(phblk->rgdwFree, cFrames);

				//
				//	Now insert this free block onto the head of the free block list
				//
				phblkT = pheap->phblkFree;
				pheap->phblkFree = phblk;
				phblk->phblkFreeNext = phblkT;

				//
				//	And then check to see if we have "too many" free entries.
				//
				if (++pheap->cEntriesFree > cEntriesFree)
				{
					PHBLK *phblkPrev = &pheap->phblkFree;

					//
					//	There are too many entries on the free list, so we need to remove the last one.
					//
					
					phblkT = pheap->phblkFree;
					
					while (phblkT->phblkFreeNext != NULL)
					{
						phblkPrev = &phblkT->phblkFreeNext;
						phblkT = phblkT->phblkFreeNext;
					}
				
					Assert(*phblkPrev);
					*phblkPrev = NULL;

					//
					//	And now free up the block for real, it's too old.
					//

					if (fUseVirtual)
						VMFreeEx((fOverwriteDetect ? PvHeadFromPv(phblkT->pv) : phblkT->pv), cbVirtualAlign);
					else
						fRet = HeapFree(pheap->hDataHeap, dwFlags,
										(fOverwriteDetect ? PvHeadFromPv(phblkT->pv) : phblkT->pv));

					HeapFree(pheap->hBlksHeap, 0, phblkT);	
				}
			}
			else	// We're not tracking freed memory, so we can really free the memory right now.
			{

				//
				//	And now free up the block for real.
				//

				if (fUseVirtual)
					VMFreeEx((fOverwriteDetect ? PvHeadFromPv(pvFree) : pvFree), cbVirtualAlign);
				else
					fRet = HeapFree(pheap->hDataHeap, dwFlags,
									(fOverwriteDetect ? PvHeadFromPv(pvFree) : pvFree));

				HeapFree(pheap->hBlksHeap, 0, phblk);	
			}
		}
	}	

	if (FTrackMem())
	{
		DWORD_PTR	rgdwArgs[4];
		DWORD_PTR	rgdwCallers[NSTK];

		GetCallStack(rgdwCallers, cFrames);

		rgdwArgs[0] = (DWORD_PTR)pheap->hDataHeap;
		rgdwArgs[1] = (DWORD_PTR)pvFree;
		rgdwArgs[2] = dwSize;
		
		LogCurrentAPI(API_HEAP_FREE, rgdwCallers, cFrames, rgdwArgs, 3);
	}

	LeaveCriticalSection(&pheap->cs);
	
	return fRet;
}


BOOL
WINAPI
DebugHeapLock(
	HANDLE hHeap)
{
	PHEAP	pheap = (PHEAP)hHeap;
	
	if (!fDbgEnable)
		return HeapLock(hHeap);
		
	EnterCriticalSection(&pheap->cs);
	
	return HeapLock(pheap->hDataHeap);
}


BOOL
WINAPI
DebugHeapUnlock(
	HANDLE hHeap)
{
	BOOL	fRet;
	PHEAP	pheap = (PHEAP)hHeap;
	
	if (!fDbgEnable)
		return HeapUnlock(hHeap);
		
	fRet = HeapUnlock(pheap->hDataHeap);
	LeaveCriticalSection(&pheap->cs);
	
	return fRet;
}


BOOL
WINAPI
DebugHeapWalk(
	HANDLE hHeap,
	LPPROCESS_HEAP_ENTRY lpEntry)
{
	BOOL	fRet;
	PHEAP	pheap = (PHEAP)hHeap;
	
	if (!fDbgEnable)
		return HeapWalk(hHeap, lpEntry);
		
	EnterCriticalSection(&pheap->cs);

	fRet = HeapWalk(pheap->hDataHeap, lpEntry);

	LeaveCriticalSection(&pheap->cs);
	
	return fRet;
}


BOOL
WINAPI
DebugHeapValidate(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem)
{
	BOOL	fRet = TRUE;
	PHEAP	pheap = (PHEAP)hHeap;
	
	if (!fDbgEnable)
		return HeapValidate(hHeap, dwFlags, lpMem);
		
	EnterCriticalSection(&pheap->cs);

	if (!fUseVirtual)
		fRet = HeapValidate(pheap->hDataHeap, dwFlags,
					(lpMem != NULL && fOverwriteDetect ? PvHeadFromPv(lpMem) : lpMem));

	LeaveCriticalSection(&pheap->cs);
	
	return fRet;
	
}


SIZE_T
WINAPI
DebugHeapSize(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem)
{
	PHEAP	pheap = (PHEAP)hHeap;
	SIZE_T	cb = 0;

	if (!fDbgEnable)
		return HeapSize(hHeap, dwFlags, lpMem);
		
	EnterCriticalSection(&pheap->cs);

	if ((fValidateMemory ? HeapValidatePv(pheap, (LPVOID)lpMem, "DebugHeapSize") : 1))
	{
		if (fUseVirtual)
		{
			cb = (UINT)VMGetSizeEx((LPVOID)lpMem, cbVirtualAlign);
		}
		else
		{
			cb = HeapSize(pheap->hDataHeap, dwFlags,
					(fOverwriteDetect ? PvHeadFromPv(lpMem) : lpMem));

		}
		if (fOverwriteDetect)
		{
			cb -= 2*cbOWSection;
		}
	}

	LeaveCriticalSection(&pheap->cs);

	return cb;
}


SIZE_T
WINAPI
DebugHeapCompact(
	HANDLE hHeap,
	DWORD dwFlags)
{
	PHEAP	pheap = (PHEAP)hHeap;
	SIZE_T	cbLargestFreeBlk = 0;

	if (!fDbgEnable)
		return HeapCompact(hHeap, dwFlags);
		
	EnterCriticalSection(&pheap->cs);

	if (!fUseVirtual)
		cbLargestFreeBlk = HeapCompact(pheap->hDataHeap, dwFlags);

	LeaveCriticalSection(&pheap->cs);

	return cbLargestFreeBlk;
}


//-----------------------------------------------------------------------------
//	Debug Support routines
//-----------------------------------------------------------------------------

/*
 -	FRegisterHeap
 -
 *	Purpose:
 *		If the user wants to monitor the Heap, then load the DLL with
 *		the HeapMonitor UI.
 */

BOOL FRegisterHeap(PHEAP pheap)
{
	HINSTANCE			hInst;
	LPHEAPMONPROC		pfnHeapMon;
	LPGETSYMNAMEPROC	pfnGetSymName;
	
	pheap->hInstHeapMon = 0;
	pheap->pfnGetSymName = NULL;

	hInst = LoadLibrary(szHeapMonDLL);
	
	if (!hInst)
	{
		DebugTrace("FRegisterHeap: Failed to LoadLibrary GLHMON32.DLL.\n");
		goto ret;
	}

	pfnHeapMon = (LPHEAPMONPROC)GetProcAddress(hInst, szHeapMonEntry);
		
	if (!pfnHeapMon)
	{
		DebugTrace("FRegisterHeap: Failed to GetProcAddress of HeapMonitor.\n");
		FreeLibrary(hInst);
		goto ret;
	}
	
	pfnGetSymName = (LPGETSYMNAMEPROC)GetProcAddress(hInst, szGetSymNameEntry);
		
	if (!pfnGetSymName)
	{
		DebugTrace("FRegisterHeap: Failed to GetProcAddress of GetSymName.\n");
	}
	
 	pheap->hInstHeapMon = hInst;
	
	if (!pfnHeapMon(pheap, HEAPMON_LOAD))
	{
		DebugTrace("FRegisterHeap: Call to HeapMonitor failed.\n");
		pheap->hInstHeapMon = 0;
		goto ret;
	}
	
 	pheap->pfnHeapMon		= pfnHeapMon;
	pheap->pfnGetSymName  = pfnGetSymName;
	
ret:
	return (pheap->hInstHeapMon ? TRUE : FALSE);
}


VOID UnRegisterHeap(PHEAP pheap)
{
	if (pheap->pfnHeapMon)
		pheap->pfnHeapMon(pheap, HEAPMON_UNLOAD);
}


/*
 -	HeapDumpLeaksHeader
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

VOID HeapDumpLeaksHeader(FILE * hf, PHEAP pheap, BOOL fNoFree)
{
	char	szDate[16];
	char	szTime[16];
	
	GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, NULL, "MMM dd yy", szDate, 16);
	GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, NULL, "hh':'mm':'ss tt", szTime, 16);
	
	fprintf(hf, "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	fprintf(hf, "DATE: %s\n", szDate);
	fprintf(hf, "TIME: %s\n\n", szTime);
	fprintf(hf, "HEAP NAME: %s\n", pheap->szHeapName);
	fprintf(hf, "MAX ALLOC: %ld\n", pheap->ulAllocNum);
	fprintf(hf, "LEAKED NO_FREE HEAP: %s\n", (fNoFree? "YES" : "NO"));
	fprintf(hf, "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n");
	fprintf(hf, "AllocNum, BlkName, Size, Address, Frame1, Frame2, Frame3, Frame4, Frame5, Frame6, Frame7, Frame8, Frame9, Frame10, Frame11, Frame12\n");

}


/*
 -	HeapDumpLeaksFooter
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

VOID HeapDumpLeaksFooter(FILE * hf, DWORD cLeaks, DWORD cbLeaked)
{
	fprintf(hf, "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	fprintf(hf, "TOTAL NUM OF LEAKS: %ld\n", cLeaks);
	fprintf(hf, "TOTAL BYTES LEAKED: %ld\n", cbLeaked);
	fprintf(hf, "END\n");
	fprintf(hf, "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\n");
}


/*
 -	HeapDumpLeakedBlock
 -
 *	Purpose:
 *		To report individual memory leaks through DebugTrace and the
 *		HeapLeakHook breakpoint function.
 */

VOID HeapDumpLeakedBlock(FILE * hf, PHEAP pheap, PHBLK phblk)
{
	char	rgchSymbols[4096];
	HANDLE	hProcess = GetCurrentProcess();

	fprintf(hf, "%ld, %s, %ld, %p",
			phblk->ulAllocNum,
			*phblk->szName ? phblk->szName : "NONAME",
			CbPhblkClient(phblk),
			PhblkToPv(phblk));

	*rgchSymbols = '\0';
	GetStackSymbols(hProcess, rgchSymbols, phblk->rgdwCallers, cFrames);

	if (hf)
		fprintf(hf, "%s\n", rgchSymbols);

	if (fDumpLeaksDebugger)
	{
		char *szSymbol = rgchSymbols;
		char *szSymbolNext = rgchSymbols;
		int iSymbol = 0;

		Trace("Block#%d, %s, %ld, %08lX:\n", phblk->ulAllocNum, *phblk->szName ? phblk->szName : "NONAME",
			  CbPhblkClient(phblk), PhblkToPv(phblk));

		while ((szSymbolNext = strchr(szSymbol, ',')) != NULL)
		{
			*szSymbolNext++ = '\0';
			if (*szSymbol != '\0' && strcmp(szSymbol, "0") != 0)
			{
				Trace("\t[%d]: %s\n", iSymbol, szSymbol);
			}
			szSymbol += strlen(szSymbol)+1;
			iSymbol += 1;
		}

		//
		//	Dump the last entry in the call stack.
		//
		if (*szSymbol != '\0' && strcmp(szSymbol, "0") != 0)
		{
			Trace("\t[%d]: %s\n", iSymbol, szSymbol);
		}
	}
}


/*
 -	HeapDumpLeaks
 -
 *	Purpose:
 *		Gets called at HeapClose time to report any memory leaks against
 *		this heap.  There are 2 reporting fascilities used by this routine:
 *
 *			=> Asserts (via TrapSz)
 *			=> Trace files
 *			=> Debug trace tags (via DebugTrace)
 *
 *		The Debug Trace is the default method if no others are specified
 *		or if the others are in-appropriate for the given platform.
 */

VOID HeapDumpLeaks(PHEAP pheap, BOOL fNoFree)
{
	PHBLK	phblk;
	BOOL	fDump = !!(pheap->ulFlags & HEAP_DUMP_LEAKS);
	BOOL	fAssert = !!(pheap->ulFlags & HEAP_ASSERT_LEAKS);
	char	szLeakLog[MAX_PATH];
	DWORD	cLeaks = 0;
	DWORD	cbLeaked = 0;
	FILE *	hLeakLog = NULL;
	
	GetLogFilePath(rgchLogPath, ".mem", szLeakLog);

	hLeakLog = fopen(szLeakLog, "a");

	if (!hLeakLog)
		goto ret;

	if (pheap->phblkHead != NULL)
	{
		if (fAssert)
		{
			AssertSz(FALSE, "Memory Leak Detected, dumping leaks");
		}

		if (!fSymInitialize)
		{
			rgsymcacheHashTable = VirtualAlloc(
											   NULL,
											   NBUCKETS*sizeof(SYMCACHE),
											   MEM_COMMIT,
											   PAGE_READWRITE);
								
			if (rgsymcacheHashTable == NULL)
			{
				return;
			}
			SymInitialize(GetCurrentProcess(), NULL, TRUE);
			fSymInitialize = TRUE;
		}

		HeapDumpLeaksHeader(hLeakLog, pheap, fNoFree);

		if (fDump)
		{
			for (phblk = pheap->phblkHead; phblk; phblk = phblk->phblkNext)
			{
				HeapDumpLeakedBlock(hLeakLog, pheap, phblk);
				cLeaks++;
				cbLeaked += phblk->ulSize;
			}
		}
	}
	HeapDumpLeaksFooter(hLeakLog, cLeaks, cbLeaked);

ret:
	if (hLeakLog)
		fclose(hLeakLog);
}


/*
 -	HeapValidatePhblk
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 *
 */

BOOL HeapValidatePhblk(PHEAP pheap, PHBLK phblk, char ** pszReason)
{
	if (IsBadWritePtr(phblk, sizeof(HBLK)))
	{
		*pszReason = "Block header cannot be written to";
		goto err;
	}

	if (phblk->pheap != pheap)
	{
		*pszReason = "Block header does not have correct pointer back to heap";
		goto err;
	}

	if (phblk->phblkNext)
	{
		if (IsBadWritePtr(phblk->phblkNext, sizeof(HBLK)))
		{
			*pszReason = "Block header has invalid next link pointer";
			goto err;
		}

		if (phblk->phblkNext->phblkPrev != phblk)
		{
			*pszReason = "Block header points to a next block which doesn't "
				"point back to it";
			goto err;
		}
	}

	if (phblk->phblkPrev)
	{
		if (IsBadWritePtr(phblk->phblkPrev, sizeof(HBLK))) {
			*pszReason = "Block header has invalid prev link pointer";
			goto err;
		}

		if (phblk->phblkPrev->phblkNext != phblk)
		{
			*pszReason = "Block header points to a prev block which doesn't "
				"point back to it";
			goto err;
		}
	}
	else if (pheap->phblkHead != phblk)
	{
		*pszReason = "Block header has a zero prev link but the heap doesn't "
			"believe it is the first block";
		goto err;
	}

	if (phblk->ulAllocNum > pheap->ulAllocNum)
	{
		*pszReason = "Block header has an invalid internal allocation number";
		goto err;
	}

	return TRUE;

err:
	return FALSE;
}


/*
 -	HeapDidAlloc
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 *
 */

BOOL HeapDidAlloc(PHEAP pheap, LPVOID pv)
{
	PHBLK	phblk;
	char *	pszReason;
	BOOL	fDidAlloc = FALSE;

	for (phblk = pheap->phblkHead; phblk; phblk = phblk->phblkNext)
	{
		AssertSz(HeapValidatePhblk(pheap, phblk, &pszReason),
				"Invalid block header in ExchMem");

		if (!HeapValidatePhblk(pheap, phblk, &pszReason))
			DebugTrace2("Block header (phblk=%08lX) is invalid\n%s", phblk, pszReason);

		if (PhblkToPv(phblk) == pv)
		{
			fDidAlloc = TRUE;
			break;
		}
	}

	return fDidAlloc;
}


/*
 -	DumpFailedValidate
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

VOID DumpFailedValidate(char * szFailed, DWORD_PTR * rgdwStack)
{
	FILE *	hLog = NULL;
	char	szValidateLog[MAX_PATH];
	char    rgchBuff[2048];

	lstrcpy(rgchBuff, "Stack Trace: ");
	
	GetStackSymbols(GetCurrentProcess(), rgchBuff, rgdwStack, cFrames);
	
	//	Create validate log file name
	
	GetLogFilePath(rgchLogPath, ".val", szValidateLog);

	//	Open the Log File and write results
		
	hLog = fopen(szValidateLog, "a");
			
	if (hLog)
	{
		fprintf(hLog, "%s", szFailed);
		fprintf(hLog, "%s\n\n", rgchBuff);
		fclose(hLog);
	}
}


/*
 -	HeapValidatePv
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 *
 */

BOOL HeapValidatePv(PHEAP pheap, LPVOID pv, char * pszFunc)
{
	PHBLK	phblk;
	char *	pszReason;
	char	szBuff[1024];
	DWORD_PTR	rgdwStack[NSTK];
	LPBYTE	pb;

	phblk = PvToPhblk(pheap, pv);
	
	if (!phblk)
	{
		//
		//	Let's see if this block is on the free list.
		//

		if (fTrackFreedMemory && (phblk = PhblkSearchFreeList(pheap, pv)))
		{
			char rgchStackFree[2048];
			char rgchStackAlloc[2048];

			strcpy(szBuff, "Attempt to free already freed memory");

			if (fAssertValid)
				AssertSz(0, szBuff);

			//
			// Dump call stack that corresponds to the earlier free.
			//

			GetStackSymbols(GetCurrentProcess(), rgchStackFree, phblk->rgdwFree, cFrames);
			GetStackSymbols(GetCurrentProcess(), rgchStackAlloc, phblk->rgdwCallers, cFrames);

			Trace("Call stack of freeing routine: \n");
			Trace("%s\n", rgchStackFree);
			
			Trace("Call stack of allocating routine: \n");
			Trace("%s\n", rgchStackAlloc);

			if (fTrapOnInvalid)
				DebugBreak();

		}
		else
		{
			wsprintf(szBuff, "%s detected a memory block (%08lX) which was either "
					 "not allocated in heap '%s' or has already been freed but is not on the free list.\n",
					 pszFunc, pv, pheap->szHeapName);

			if (fAssertValid)
				AssertSz(0, szBuff);

			if (fTrapOnInvalid)
				DebugBreak();

			GetCallStack(rgdwStack, cFrames);
			DumpFailedValidate(szBuff, rgdwStack);
			DebugTrace(szBuff);
		}
				
		return FALSE;
	}

	if (fOverwriteDetect)
	{
		pb = (LPBYTE)PvHeadFromPv(pv);
		
		if ((pb[0] != chOWFill) || (pb[1] != chOWFill) ||
			(pb[2] != chOWFill) || (pb[3] != chOWFill))
		{
			wsprintf(szBuff, "%s detected a memory block (%08lX) from heap '%s' "
					"which appears to have been under-written.\n",
					pszFunc, pv, pheap->szHeapName);
					
			if (fAssertValid)
				AssertSz(0, szBuff);
			
			if (fTrapOnInvalid)
				DebugBreak();
				
			GetCallStack(rgdwStack, cFrames);	
			DumpFailedValidate(szBuff, rgdwStack);
			DebugTrace(szBuff);

			return FALSE;
		}

		pb = (LPBYTE)PvTailFromPv(pv, phblk->ulSize);
		
		if ((pb[0] != chOWFill) || (pb[1] != chOWFill) ||
			(pb[2] != chOWFill) || (pb[3] != chOWFill))
		{
			wsprintf(szBuff, "%s detected a memory block (%08lX) from heap '%s' "
					"which appears to have been over-written.\n",
					pszFunc, pv, pheap->szHeapName);
					
			if (fAssertValid)
				AssertSz(0, szBuff);
			
			if (fTrapOnInvalid)
				DebugBreak();
				
			GetCallStack(rgdwStack, cFrames);	
			DumpFailedValidate(szBuff, rgdwStack);
			DebugTrace(szBuff);

			return FALSE;
		}
	}

	if (!HeapValidatePhblk(pheap, phblk, &pszReason))
	{
		wsprintf(szBuff, "%s detected an invalid memory block (%08lX) in heap '%s'.  %s.\n",
				pszFunc, pv, pheap->szHeapName, pszReason);
					
		if (fAssertValid)
			AssertSz(0, szBuff);
				
		if (fTrapOnInvalid)
			DebugBreak();
					
		GetCallStack(rgdwStack, cFrames);	
		DumpFailedValidate(szBuff, rgdwStack);
		DebugTrace(szBuff);

		return FALSE;
	}

	return TRUE;
}


/*
 -	PhblkEnqueue
 -
 *	Purpose:
 *		To add a newly allocated block to the allocation list hanging
 *		off the heap.  We do an InsertSorted because the HeapMonitor
 *		will need to reference the allocations ordered by their
 *		location in the heap.  Since the monitor will walk the heap
 *		often, it is more efficient to do the sort up front.
 */

VOID PhblkEnqueue(PHBLK phblk)
{
	phblk->phblkNext = phblk->pheap->phblkHead;
	
	if (phblk->phblkNext)
		phblk->phblkNext->phblkPrev = phblk;
	
	phblk->pheap->phblkHead = phblk;
	
	//	I am going to disable the InsertSorted behavior for now for performance
	//	reasons.  It is only done this way because of GLHMON which I don't believe
	//	to be widely used at this point anyway.  I'm not even sure if this is
	//	important to GLHMON since it has the ability to sort blocks by other fields.
	
/*	PHBLK	phblkCurr = NULL;
	PHBLK	phblkNext = phblk->pheap->phblkHead;
	
	while (phblkNext)
	{
		if (phblkNext > phblk)
			break;
		
		phblkCurr = phblkNext;
		phblkNext = phblkCurr->phblkNext;
	}
	
	if (phblkNext)
	{
		phblk->phblkNext		= phblkNext;
		phblk->phblkPrev		= phblkCurr;
		phblkNext->phblkPrev	= phblk;
	}
	else
	{
		phblk->phblkNext = NULL;
		phblk->phblkPrev = phblkCurr;
	}

	if (phblkCurr)
		phblkCurr->phblkNext = phblk;
	else
		phblk->pheap->phblkHead = phblk;
 */
}


/*
 -	PhblkDequeue
 -
 *	Purpose:
 *		To remove a freed block from the list of allocations hanging
 *		off the heap.
 */

VOID PhblkDequeue(PHBLK phblk)
{
	//
	//	We should never be dequeuing an already freed block.
	//
	Assert(phblk->phblkFreeNext == NULL);

	if (phblk->phblkNext)
		phblk->phblkNext->phblkPrev = phblk->phblkPrev;
	
	if (phblk->phblkPrev)
		phblk->phblkPrev->phblkNext = phblk->phblkNext;
	else
		phblk->pheap->phblkHead = phblk->phblkNext;
}


/*
 -	HexByteToBin
 -
 *	Purpose:
 *		Takes a hex string and converts the 2 msd's to a byte, ignoring
 *		the remaining digits.  This function assumes the string is
 *		formatted as: 0xnn, otherwise it simply returns 0x00.
 */

BYTE HexByteToBin(LPSTR sz)
{
	int i, n[2], nT;

	if (*sz++ != '0')
		return 0x00;

	nT = *sz++;

	if (nT != 'x' && nT != 'X')
		return 0x00;

	for (i = 0; i < 2; i++)
	{
		nT = *sz++;
		
		if (nT >= '0' && nT <= '9')
			n[i] = nT - '0';
		else if (nT >= 'A' && nT <= 'F')
			n[i] = nT - 'A' + 10;
		else if (nT >= 'a' && nT <= 'f')
			n[i] = nT - 'a' + 10;
		else
			return (BYTE)0x00;
	}	

	n[0] <<= 4;
	return (BYTE)((BYTE)n[0] | (BYTE)n[1]);
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

void __cdecl HeapSetHeapNameFn(PHEAP pheap, char *pszFormat, ...)
{
	char	sz[512];
	va_list	vl;

	if (fDbgEnable)
	{
		va_start(vl, pszFormat);
		wvsprintf(sz, pszFormat, vl);
		va_end(vl);

		lstrcpyn(pheap->szHeapName, sz, sizeof(pheap->szHeapName));
	}
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

VOID __cdecl HeapSetNameFn(PHEAP pheap, LPVOID pv, char *pszFormat, ...)
{
	char	sz[512];
	PHBLK	phblk;
	va_list	vl;

	phblk = PvToPhblk(pheap, pv);

	if (phblk)
	{
		va_start(vl, pszFormat);
		wvsprintf(sz, pszFormat, vl);
		va_end(vl);

		lstrcpyn(phblk->szName, sz, sizeof(phblk->szName));
	}
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

char * HeapGetName(PHEAP pheap, LPVOID pv)
{
	PHBLK	phblk;

	phblk = PvToPhblk(pheap, pv);

	if (phblk)
		return(phblk->szName);

	return("");
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

BOOL FForceFailure(PHEAP pheap, ULONG cb)
{
	//  First, see if we're past our start of failures point

	if (pheap->ulFailStart && (pheap->ulFailStart <= pheap->ulAllocNum))
	{
		//  If so, then are we at an interval where we should return errors?
		
		if ((pheap->ulFailInterval)
			&& ((pheap->ulAllocNum - pheap->ulFailStart)%pheap->ulFailInterval) == 0)
		{
			//  return that we should fail here

			return TRUE;
		}

		//  Check to see if the alloc size is greater than allowed

		if (pheap->ulFailBufSize && cb >= pheap->ulFailBufSize)
			return TRUE;

	}

	//  Otherwise, no error is returned for this alloc

	return FALSE;
}


/*
 -	PvToPhblk
 -
 *	Purpose:
 *		Finds the HBLK for this allocation in the heap's active list.
 */

PHBLK PvToPhblk(PHEAP pheap, LPVOID pv)
{
	PHBLK phblk;

	EnterCriticalSection(&pheap->cs);
	
	phblk = pheap->phblkHead;
	
	while (phblk)
	{
		if (phblk->pv == pv)
			break;
		
		phblk = phblk->phblkNext;	
	}
	
	LeaveCriticalSection(&pheap->cs);
	
	return phblk;
}


/*
 -	IsRunningAsService
 -
 *	Purpose:
 *		Determine if the process that attached to us is running as a
 *		service or not.
 *
 *	Parameters:
 *		VOID
 *
 *	Returns:
 *		fService		TRUE if a service, FALSE if not
 *
 */

BOOL IsProcessRunningAsService(VOID)
{
	HANDLE			hProcessToken	= NULL;
	DWORD			dwGroupLength	= 50;
    PTOKEN_GROUPS	ptokenGroupInfo	= NULL;
    PSID			psidInteractive	= NULL;
    PSID			psidService		= NULL;
    SID_IDENTIFIER_AUTHORITY siaNt	= SECURITY_NT_AUTHORITY;
	BOOL			fService		= FALSE;
    DWORD			i;


    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
		goto ret;

    ptokenGroupInfo = (PTOKEN_GROUPS)LocalAlloc(0, dwGroupLength);

    if (ptokenGroupInfo == NULL)
		goto ret;

    if (!GetTokenInformation(hProcessToken, TokenGroups, ptokenGroupInfo,
		dwGroupLength, &dwGroupLength))
	{
		if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
			goto ret;

		LocalFree(ptokenGroupInfo);
		ptokenGroupInfo = NULL;
	
		ptokenGroupInfo = (PTOKEN_GROUPS)LocalAlloc(0, dwGroupLength);
	
		if (ptokenGroupInfo == NULL)
			goto ret;
	
		if (!GetTokenInformation(hProcessToken, TokenGroups, ptokenGroupInfo,
			dwGroupLength, &dwGroupLength))
		{
			goto ret;
		}
    }

    //	We now know the groups associated with this token.  We want to look
    //	to see if the interactive group is active in the token, and if so,
    //	we know that this is an interactive process.
    //
    //  We also look for the "service" SID, and if it's present, we know
    //	we're a service.
    //
    //	The service SID will be present iff the service is running in a
    //  user account (and was invoked by the service controller).

    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID, 0, 0,
		0, 0, 0, 0, 0, &psidInteractive))
	{
		goto ret;
    }

    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0,
		0, 0, 0, 0, &psidService))
	{
		goto ret;
    }

    for (i = 0; i < ptokenGroupInfo->GroupCount ; i += 1)
	{
		PSID psid = ptokenGroupInfo->Groups[i].Sid;
	
		//	Check to see if the group we're looking at is one of
		//	the 2 groups we're interested in.
	
		if (EqualSid(psid, psidInteractive))
		{
			//	This process has the Interactive SID in its token.
			//	This means that the process is running as an EXE.

			goto ret;
		}
		else if (EqualSid(psid, psidService))
		{
			//	This process has the Service SID in its token.  This means that
			//	the process is running as a service running in a user account.

			fService = TRUE;
			goto ret;
		}
    }

    //	Neither Interactive or Service was present in the current
    //	users token.  This implies that the process is running as
    //	a service, most likely running as LocalSystem.

	fService = TRUE;

ret:

	if (psidInteractive)
		FreeSid(psidInteractive);

	if (psidService)
		FreeSid(psidService);

	if (ptokenGroupInfo)
		LocalFree(ptokenGroupInfo);

	if (hProcessToken)
		CloseHandle(hProcessToken);

    return fService;
}


/*
 -	DebugTraceFn
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

void __cdecl DebugTraceFn(char *pszFormat, ...)
{
	char	sz[4096];
	va_list	vl;

	va_start(vl, pszFormat);
	wvsprintfA(sz, pszFormat, vl);
	va_end(vl);

	OutputDebugStringA(sz);
	OutputDebugStringA("\r");
}


/*
 -	AssertFn
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

void AssertFn(char * szFile, int nLine, char * szMsg)
{
	int nRet;
	char szInfo[1024];

	wsprintf(szInfo, "File %.64s @ line %d%s%s",
			szFile,
			nLine,
			(szMsg) ? (": ") : (""),
			(szMsg) ? (szMsg) : (""));

	// OK to continue, CANCEL to break.

	nRet = MessageBox(NULL, szInfo, "ExchMem Assert", MB_OKCANCEL | MB_ICONSTOP | MB_SERVICE_NOTIFICATION | MB_TOPMOST);

	if (nRet == IDCANCEL)
		DebugBreak();
}


void
ExchmemGetCallStack(DWORD_PTR *rgdwCaller, DWORD cFind)
{
	if (fSymbolLookup)
	{
		GetCallStack(rgdwCaller, cFind);
	}
	else
	{
		ZeroMemory(rgdwCaller, cFind*sizeof(DWORD));
	}
}

BOOL FTrackMem()
{
	if (InterlockedCompareExchange(&fChangeTrackState,FALSE,TRUE))
	{
		fTrackMem = !fTrackMem;
	
		if (fTrackMem)
			StartTrace(FALSE);
		else
			StopTrace();
	}
		
	return fTrackMem;
}

void
StartTrace(BOOL fFresh)
{
	char	szTrackLog[MAX_PATH];
		
	GetLogFilePath(rgchLogPath, ".trk", szTrackLog);

	InitializeCriticalSection(&csTrackLog);
			
	//	Open the Log File
			
	hTrackLog = fopen(szTrackLog, fFresh ? "wt" : "at");
			
	if (!hTrackLog)
	{
		DeleteCriticalSection(&csTrackLog);
		fTrackMem = FALSE;
	}
}

void
StopTrace()
{
	DeleteCriticalSection(&csTrackLog);

	if (hTrackLog)
	{
		fclose(hTrackLog);
		hTrackLog = NULL;
	}

	fTrackMem = FALSE;
}

//-------------------------------------------------------------------------------------
// Description:
//      Copies szAppend to szBuf and updates szBuf to point to the terminating NULL of
//      of the copied bytes. cbMaxBuf is max chars available in szBuf. cbAppend is
//      strlen(szAppend). If cbAppend > cbMaxBuf, as many characters as possible are
//      copied to szBuf (including terminating NULL).
//-------------------------------------------------------------------------------------
#define ExchmemSafeAppend(szBuf, cbMaxBuf, szAppend, cbAppend) {					\
			int iWritten;															\
																					\
			if(NULL != lstrcpyn(szBuf, szAppend, cbMaxBuf)) {						\
				iWritten = ((int)cbMaxBuf < (int)cbAppend) ? cbMaxBuf : cbAppend;	\
				szBuf += iWritten;													\
				cbMaxBuf -= iWritten;												\
			}																		\
		}

void
ExchmemFormatSymbol(HANDLE hProcess, DWORD_PTR dwAddress, char rgchSymbol[], DWORD cbSymbol)
{
	CHAR				rgchModuleName[16];
	BOOL				fSym;
	IMAGEHLP_MODULE		mi = {0};
	PIMAGEHLP_SYMBOL	psym = NULL;
	LPSTR				pszSymName = NULL;
	CHAR				rgchLine[256];
	LPSTR				pszT = NULL;
	DWORD_PTR			dwOffset = 0;
	int 				cbAppend = 0;
	PCHAR				pchSymbol = rgchSymbol;

	mi.SizeOfStruct  = sizeof(IMAGEHLP_MODULE);

	pszSymName = pfMalloc(256);

	if (!pszSymName)
		goto ret;
	
	psym = pfMalloc(sizeof(IMAGEHLP_SYMBOL) + 256);

	if (!psym)
		goto ret;

	ZeroMemory(psym, sizeof(IMAGEHLP_SYMBOL) + 256);
	psym->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
	psym->MaxNameLength = 256;

	rgchSymbol[0] = '\0';
	if (SymGetModuleInfo(hProcess, dwAddress, &mi))
	{
		lstrcpy(rgchModuleName, mi.ModuleName);
		RemoveExtension(rgchModuleName);

		cbAppend = wsprintf(rgchLine, "(%s)", rgchModuleName);
		ExchmemSafeAppend(pchSymbol, cbSymbol, rgchLine, cbAppend);
	}
	else
		ExchmemSafeAppend(pchSymbol, cbSymbol, "none", sizeof("none") - 1);

	if (fSymbolLookup)
	{
		//
		//	Make sure we always get the address of the symbol, since the symbol lookup isn't accurate for
		//	all modules.
		//
		cbAppend = wsprintf(rgchLine, "(0x%p):", dwAddress);
		ExchmemSafeAppend(pchSymbol, cbSymbol, rgchLine, cbAppend);

		pszT = PszGetSymbolFromCache(dwAddress, &dwOffset);

		if (!pszT)
		{
			fSym = SymGetSymFromAddr(hProcess,
									 dwAddress,
									 &dwOffset,
									 psym);
			if (fSym)
			{
				if (!SymUnDName(psym, pszSymName, 248))
					lstrcpyn(pszSymName, &(psym->Name[1]), 248);

				AddSymbolToCache(dwAddress, dwOffset, pszSymName);

				pszT = pszSymName;
			}
		}

		if (pszT)
		{
			ExchmemSafeAppend(pchSymbol, cbSymbol, pszT, lstrlen(pszT));
			cbAppend = wsprintf(rgchLine, "+0x%x", dwOffset);
			ExchmemSafeAppend(pchSymbol, cbSymbol, rgchLine, cbAppend);
		}
		else
		{
			cbAppend = wsprintf(rgchLine, "(0x%08x)", dwAddress);
			ExchmemSafeAppend(pchSymbol, cbSymbol, rgchLine, cbAppend);
		}
	}
	else
	{
		cbAppend = wsprintf(rgchLine, "(0x%08x)", dwAddress);
		ExchmemSafeAppend(pchSymbol, cbSymbol, rgchLine, cbAppend);
	}

ret:	
	if (psym)
		pfFree(psym);

	if (pszSymName)
		pfFree(pszSymName);
}


/*
 -	GetCallStack
 -
 *	Purpose:
 *		Uses the imagehlp APIs to get the call stack.
 *
 *	Parameters:
 *		pdwCaller			An array of return addresses
 *		cFind				Count of stack frames to get
 *
 *	Returns:
 *		VOID
 *
 */

VOID GetCallStack(DWORD_PTR *rgdwCaller, DWORD cFind)
{
	BOOL            fMore;
	STACKFRAME      stkfrm = {0};
	CONTEXT         ctxt;
	HANDLE			hThread;
	HANDLE			hProcess;

	if (!cFind)
		return;

	hThread = GetCurrentThread();
	hProcess = GetCurrentProcess();

	ZeroMemory(&ctxt, sizeof(CONTEXT));
	ZeroMemory(rgdwCaller, cFind * sizeof(DWORD));

	ctxt.ContextFlags = CONTEXT_FULL;

	if (!GetThreadContext(hThread, &ctxt))
	{
		stkfrm.AddrPC.Offset = 0;
	}
	else
	{
#if defined(_M_IX86)
		_asm
		{
			mov stkfrm.AddrStack.Offset, esp
			mov stkfrm.AddrFrame.Offset, ebp
			mov stkfrm.AddrPC.Offset, offset DummyLabel
DummyLabel:
		}
#elif defined(_M_MRX000)
		stkfrm.AddrPC.Offset = ctxt.Fir;
		stkfrm.AddrStack.Offset = ctxt.IntSp;
		stkfrm.AddrFrame.Offset = ctxt.IntSp;
#elif defined(_M_ALPHA)
		stkfrm.AddrPC.Offset = (ULONG_PTR)ctxt.Fir;
		stkfrm.AddrStack.Offset = (ULONG_PTR)ctxt.IntSp;
		stkfrm.AddrFrame.Offset = (ULONG_PTR)ctxt.IntSp;
#elif defined(_M_PPC)
		stkfrm.AddrPC.Offset = ctxt.Iar;
		stkfrm.AddrStack.Offset = ctxt.Gpr1;
		stkfrm.AddrFrame.Offset = ctxt.Gpr1;
#else
		stkfrm.AddrPC.Offset = 0;
#endif
	}


	stkfrm.AddrPC.Mode = AddrModeFlat;
	stkfrm.AddrStack.Mode = AddrModeFlat;
	stkfrm.AddrFrame.Mode = AddrModeFlat;

	//	Eat the first one

	fMore = StackWalk(
#ifdef _M_IX86
					  IMAGE_FILE_MACHINE_I386,
#elif defined(_M_MRX000)
					  IMAGE_FILE_MACHINE_R4000,
#elif defined(_M_ALPHA)
#if !defined(_M_AXP64)
					  IMAGE_FILE_MACHINE_ALPHA,
#else
					  IMAGE_FILE_MACHINE_ALPHA64,
#endif
#elif defined(_M_PPC)
					  IMAGE_FILE_MACHINE_POWERPC,
#else
					  IMAGE_FILE_MACHINE_UNKNOWN,
#endif
					  hProcess,
					  hThread,
					  &stkfrm,
					  &ctxt,
					  (PREAD_PROCESS_MEMORY_ROUTINE)ReadProcessMemory,
					  SymFunctionTableAccess,
					  SymGetModuleBase,
					  NULL);

	while (fMore && (cFind > 0))
	{
		fMore = StackWalk(
#ifdef _M_IX86
						  IMAGE_FILE_MACHINE_I386,
#elif defined(_M_MRX000)
						  IMAGE_FILE_MACHINE_R4000,
#elif defined(_M_ALPHA)
						  IMAGE_FILE_MACHINE_ALPHA,
#elif defined(_M_AXP64)
						  IMAGE_FILE_MACHINE_ALPHA64,
#elif defined(_M_PPC)
						  IMAGE_FILE_MACHINE_POWERPC,
#else
						  IMAGE_FILE_MACHINE_UNKNOWN,
#endif
						  hProcess,
						  hThread,
						  &stkfrm,
						  &ctxt,
						  (PREAD_PROCESS_MEMORY_ROUTINE)ReadProcessMemory,
						  SymFunctionTableAccess,
						  SymGetModuleBase,
						  NULL);

		if (!fMore)
			break;

		*rgdwCaller++ = stkfrm.AddrPC.Offset;
		cFind -= 1;
	}
}


/*
 -	RemoveExtension
 -
 *	Purpose:
 *		Strips the file extension from a file path.
 *
 *	Parameters:
 *		psz				File path to strip extension from
 *
 *	Returns:
 *		void
 */

VOID RemoveExtension(LPSTR psz)
{
	LPSTR szLast = NULL;
	while (*psz)
	{
		if (*psz == '.')
		{
			szLast = psz;
		}
		psz++;
	}
	if (szLast)
	{
		*szLast = '\0';
	}
}


/*
 -	GetLogFilePath
 -
 *	Purpose:
 *		Build a log file path from a supplied path, the current
 *		executables name, and a supplied file extension.
 *
 *	Parameters:
 *		szPath			[in]  Path to new log file
 *		szExt			[in]  New log file extension
 *		szFilePath		[out] Newly constructed log file path
 *
 *	Returns:
 *		void
 */

VOID GetLogFilePath(LPSTR szPath, LPSTR szExt, LPSTR szFilePath)
{
	lstrcpy(szFilePath, szPath);
	lstrcat(szFilePath, rgchExeName);
	lstrcat(szFilePath, szExt);
}


/*
 -	PszGetSymbolFromCache
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

CHAR * PszGetSymbolFromCache(DWORD_PTR dwAddress, DWORD_PTR * pdwOffset)
{
	ULONG	ulBucket = UlHash(dwAddress);
	
	if (rgsymcacheHashTable[ulBucket].dwAddress == dwAddress)
	{
		*pdwOffset = rgsymcacheHashTable[ulBucket].dwOffset;
		return rgsymcacheHashTable[ulBucket].rgchSymbol;
	}

	return NULL;
}


/*
 -	AddSymbolToCache
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

VOID AddSymbolToCache(DWORD_PTR dwAddress, DWORD_PTR dwOffset, CHAR * pszSymbol)
{
	ULONG	ulBucket = UlHash(dwAddress);

	rgsymcacheHashTable[ulBucket].dwAddress = dwAddress;
	rgsymcacheHashTable[ulBucket].dwOffset = dwOffset;
	lstrcpy(rgsymcacheHashTable[ulBucket].rgchSymbol, pszSymbol);
}


/*
 -	GetStackSymbols
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 *
 */

VOID
GetStackSymbols(
	HANDLE hProcess,
	CHAR * rgchBuff,
	DWORD_PTR * rgdwStack,
	DWORD cFrames)
{
	DWORD				i;
	DWORD_PTR				dwAddress;
	LPSTR				pszSymName = NULL;
	
	pszSymName = pfMalloc(256);

	if (!pszSymName)
		goto ret;

	for (i = 0; i < cFrames; i++)
	{
		if ((dwAddress = rgdwStack[i]) != 0)
		{
			ExchmemFormatSymbol(hProcess, dwAddress, pszSymName, 256);

			lstrcat(rgchBuff, ",");
			lstrcat(rgchBuff, pszSymName);
		}
		else
			lstrcat(rgchBuff, ",0");
	}
	
ret:
	if (pszSymName)
		pfFree(pszSymName);
		
	return;
}


/*
 -	LogCurrentAPI
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 *
 */

VOID LogCurrentAPI(
	WORD wApi,
	DWORD_PTR *rgdwCallStack,
	DWORD cFrames,
	DWORD_PTR *rgdwArgs,
	DWORD cArgs)
{
	CHAR    rgchT[64];
	CHAR	rgchKeys[8] = "CDARF";
	CHAR    rgchBuff[8192];
	DWORD	cbWritten;

	if (dwTrackMemInMem)
	{
		long lCurr;
		
		// Instead of writing out to a file, just maintain the data in a circular memory list.
		// The overflow check is not thread safe, but if we lose an entry or two after two billion
		// memory functions, oh well.
		if (dwmemtrace == 0xefffffff)
		{
			dwmemtrace = 1;
			lCurr = 0;
		}
		else
			lCurr = (InterlockedIncrement((LONG *)&dwmemtrace) - 1) % dwTrackMemInMem;
			
		memset(&rgmemtrace[lCurr],0,sizeof(MEMTRACE));
		rgmemtrace[lCurr].wApi = wApi;
		memcpy(rgmemtrace[lCurr].rgdwCallStack,rgdwCallStack,cFrames*sizeof(DWORD_PTR));
		memcpy(rgmemtrace[lCurr].rgdwArgs,rgdwArgs,cArgs*sizeof(DWORD_PTR));
		rgmemtrace[lCurr].dwTickCount = GetTickCount();
		rgmemtrace[lCurr].dwThreadId = GetCurrentThreadId();
		return;
	}

	sprintf(rgchBuff, "%c,%lu,%lu", rgchKeys[wApi], GetTickCount(), GetCurrentThreadId());
	
	if (cFrames)
		GetStackSymbols(GetCurrentProcess(), rgchBuff, rgdwCallStack, cFrames);

	switch (wApi)
	{
	case API_HEAP_CREATE:
		sprintf(rgchT,    ",%ld",      rgdwArgs[0]);	// cbInitSize
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",%ld",      rgdwArgs[1]);	// cbMaxSize
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",0x%08X\n", rgdwArgs[2]);	// hHeap
		lstrcat(rgchBuff, rgchT);
		break;
		
	case API_HEAP_DESTROY:
		sprintf(rgchT,    ",0x%08X\n", rgdwArgs[0]);	// hHeap
		lstrcat(rgchBuff, rgchT);
		break;
		
	case API_HEAP_FREE:
		sprintf(rgchT,    ",0x%08X",   rgdwArgs[0]);	// hHeap
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",0x%08X", rgdwArgs[1]);	// pvFree
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",%ld\n",      rgdwArgs[2]);	// cbFree
		lstrcat(rgchBuff, rgchT);
		break;
		
	case API_HEAP_ALLOC:
		sprintf(rgchT,    ",0x%08X",   rgdwArgs[0]);	// hHeap
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",%ld",      rgdwArgs[1]);	// cbAlloc
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",0x%08X\n", rgdwArgs[2]);	// pvAlloc
		lstrcat(rgchBuff, rgchT);
		break;
		
	case API_HEAP_REALLOC:
		sprintf(rgchT,    ",0x%08X",   rgdwArgs[0]);	// hHeap
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",%ld",      rgdwArgs[1]);	// cbOld
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",0x%08X",   rgdwArgs[2]);	// pvOld
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",%ld",	   rgdwArgs[3]);	// cbNew
		lstrcat(rgchBuff, rgchT);
		sprintf(rgchT,    ",0x%08X\n", rgdwArgs[4]);	// pvNew
		lstrcat(rgchBuff, rgchT);
		break;
	}

	EnterCriticalSection(&csTrackLog);
	WriteFile((HANDLE)_get_osfhandle(_fileno(hTrackLog)), rgchBuff, strlen(rgchBuff), &cbWritten, NULL);
	LeaveCriticalSection(&csTrackLog);
}


//-----------------------------------------------------------------------------
//	Virtual Memory Support
//-----------------------------------------------------------------------------

#define PAGE_SIZE		4096
#define PvToVMBase(pv)	((LPVOID)((ULONG_PTR)pv & ~0xFFFF))

/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

BOOL
VMValidatePvEx(
	LPVOID	pv,
	ULONG	cbCluster)
{
	LPVOID	pvBase;
	LPBYTE	pb;

	pvBase = PvToVMBase(pv);

	pb = (BYTE *)pvBase + sizeof(ULONG);

	while (pb < (BYTE *)pv)
	{
		if (*pb++ != 0xAD)
		{
			char szBuff[1024];
			
			wsprintf(szBuff, "VMValidatePvEx(pv=%08lX): Block leader has been overwritten", pv);
			AssertSz(0, szBuff);
			return FALSE;
		}
	}

	if (cbCluster != 1)
	{
		ULONG cb = *((ULONG *)pvBase);
		ULONG cbPad = 0;

		if (cb % cbCluster)
			cbPad = (cbCluster - (cb % cbCluster));

		if (cbPad)
		{
			BYTE *pbMac;

			pb = (BYTE *)pv + cb;
			pbMac = pb + cbPad;

			while (pb < pbMac)
			{
				if (*pb++ != 0xBC)
				{
					char szBuff[1024];
					
					wsprintf(szBuff, "VMValidatePvEx(pv=%08lX): Block trailer has been overwritten", pv);
					AssertSz(0, szBuff);
					return FALSE;
				}
			}
		}
	}

	return TRUE;
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

LPVOID
WINAPI
VMAllocEx(
	ULONG	cb,
	ULONG	cbCluster)
{
	ULONG	cbAlloc;
	LPVOID	pvR;
	LPVOID	pvC;
	ULONG 	cbPad	= 0;

	// a cluster size of 0 means don't use the virtual allocator.

	AssertSz(cbCluster != 0, "Cluster size is zero.");

	if (cb > 0x400000)
		return NULL;

	if (cb % cbCluster)
		cbPad = (cbCluster - (cb % cbCluster));

	cbAlloc	= sizeof(ULONG) + cb + cbPad + PAGE_SIZE - 1;
	cbAlloc -= cbAlloc % PAGE_SIZE;
	cbAlloc	+= PAGE_SIZE;

	pvR = VirtualAlloc(0, cbAlloc, MEM_RESERVE, PAGE_NOACCESS);

	if (pvR == 0)
		return NULL;

	pvC = VirtualAlloc(pvR, cbAlloc - PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE);

	if (pvC != pvR)
	{
		VirtualFree(pvR, 0, MEM_RELEASE);
		return NULL;
	}

	*(ULONG *)pvC = cb;

	memset((BYTE *)pvC + sizeof(ULONG), 0xAD,
		(UINT) cbAlloc - cb - cbPad - sizeof(ULONG) - PAGE_SIZE);

	if (cbPad)
		memset((BYTE *)pvC + cbAlloc - PAGE_SIZE - cbPad, 0xBC,
			(UINT) cbPad);

	return ((BYTE *)pvC + (cbAlloc - cb - cbPad - PAGE_SIZE));
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

VOID
WINAPI
VMFreeEx(
	LPVOID	pv,
	ULONG	cbCluster)
{
	VMValidatePvEx(pv, cbCluster);

	if (!VirtualFree(PvToVMBase(pv), 0, MEM_RELEASE))
	{
		char szBuff[1024];
		
		wsprintf(szBuff, "VMFreeEx(pv=%08lX): VirtualFree failed (%08lX)",
				pv, GetLastError());
		AssertSz(0, szBuff);
	}
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

LPVOID
WINAPI
VMReallocEx(
	LPVOID	pv,
	ULONG	cb,
	ULONG	cbCluster)
{
	LPVOID*	pvNew = 0;
	ULONG	cbCopy;

	VMValidatePvEx(pv, cbCluster);

	cbCopy = *(ULONG *)PvToVMBase(pv);

	if (cbCopy > cb)
		cbCopy = cb;

	pvNew = VMAllocEx(cb, cbCluster);

	if (pvNew)
	{
		memcpy(pvNew, pv, cbCopy);
		VMFreeEx(pv, cbCluster);
	}

	return pvNew;
}


/*
 -	Function
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 */

ULONG
WINAPI
VMGetSizeEx(
	LPVOID	pv,
	ULONG	cbCluster)
{
	return (*(ULONG *)PvToVMBase(pv));
}

#ifdef	DEBUG
BOOL
__stdcall
FReloadSymbolsCallback(PSTR szModuleName, ULONG_PTR ulBaseOfDLL, ULONG cbSizeOfDLL, void *pvContext)
{
	if (SymGetModuleBase(GetCurrentProcess(), ulBaseOfDLL) == 0)
	{
		if (!SymLoadModule(GetCurrentProcess(),
						   NULL,
						   szModuleName,
						   NULL,
						   ulBaseOfDLL,
						   cbSizeOfDLL))
		{
			Trace("Error loading module %s: %d", szModuleName, GetLastError());
			return FALSE;
		}
	}
	return TRUE;
}


DWORD
WINAPI
ExchmemReloadSymbols(void)
{
	if (!EnumerateLoadedModules(GetCurrentProcess(), FReloadSymbolsCallback, NULL))
	{
		DWORD ec = GetLastError();
		Trace("SymEnumerateModules failed: %d", ec);
		return ec;
	}
	return 0;
}
#endif
#else	// !DEBUG
void
ExchmemGetCallStack(DWORD_PTR *rgdwCaller, DWORD cFind)
{
	//
	//	Fill the stack with 0s on a retail EXCHMEM.
	//
	ZeroMemory(rgdwCaller, cFind*sizeof(DWORD));
}

void
ExchmemFormatSymbol(HANDLE hProcess, DWORD_PTR dwCaller, char rgchSymbol[], DWORD cbSymbol)
{
	//
	//	Fill the stack with 0s on a retail EXCHMEM.
	//
	strncpy(rgchSymbol, "Unknown", cbSymbol);
}

DWORD
ExchmemReloadSymbols(void)
{
	return 0;
}

#endif	// DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\staxmem\mpheap.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mpheap.c

Abstract:

    This DLL is a wrapper that sits on top of the Win32 Heap* api.  It
    provides multiple heaps and handles all the serialization itself.

    Many multithreaded applications that use the standard memory allocation
    routines (malloc/free, LocalAlloc/LocalFree, HeapAlloc/HeapFree) suffer
    a significant a significant performance penalty when running on a
    multi-processor machine.  This is due to the serialization used by the
    default heap package.  On a multiprocessor machine, more than one
    thread may simultaneously try to allocate memory.  One thread will
    block on the critical section guarding the heap.  The other thread must
    then signal the critical section when it is finished to unblock the
    waiting thread.  The additional codepath of blocking and signalling adds
    significant overhead to the frequent memory allocation path.

    By providing multiple heaps, this DLL allows simultaneous operations on
    each heap.  A thread on processor 0 can allocate memory from one heap
    at the same time that a thread on processor 1 is allocating from a
    different heap.  The additional overhead in this DLL is compensated by
    drastically reducing the number of times a thread must wait for heap
    access.

    The basic scheme is to attempt to lock each heap in turn with the new
    TryEnterCriticalSection API.  This will enter the critical section if
    it is unowned.  If the critical section is owned by a different thread,
    TryEnterCriticalSection returns failure instead of blocking until the
    other thread leaves the critical section.

    Another trick to increase performance is the use of a lookaside list to
    satisfy frequent allocations.  By using InterlockedExchange to remove
    lookaside list entries and InterlockedCompareExchange to add lookaside
    list entries, allocations and frees can be completed without needing a
    critical section lock.

    The final trick is the use of delayed frees.  If a chunk of memory is
    being freed, and the required lock is already held by a different
    thread, the free block is simply added to a delayed free list and the
    API completes immediately.  The next thread to acquire the heap lock
    will free everything on the list.

    Every application uses memory allocation routines in different ways.
    In order to allow better tuning of this package, MpHeapGetStatistics
    allows an application to monitor the amount of contention it is
    getting.  Increasing the number of heaps increases the potential
    concurrency, but also increases memory overhead.  Some experimentation
    is recommended to determine the optimal settings for a given number of
    processors.

    Some applications can benefit from additional techniques.  For example,
    per-thread lookaside lists for common allocation sizes can be very
    effective.  No locking is required for a per-thread structure, since no
    other thread will ever be accessing it.  Since each thread reuses the
    same memory, per-thread structures also improve locality of reference.

--*/
#include <windows.h>
#include "mpheap.h"

#define MPHEAP_VALID_OPTIONS  (MPHEAP_GROWABLE                 | \
                               MPHEAP_REALLOC_IN_PLACE_ONLY    | \
                               MPHEAP_TAIL_CHECKING_ENABLED    | \
                               MPHEAP_FREE_CHECKING_ENABLED    | \
                               MPHEAP_DISABLE_COALESCE_ON_FREE | \
                               MPHEAP_ZERO_MEMORY              | \
                               MPHEAP_COLLECT_STATS)

//
// Flags that are not passed on to the Win32 heap package
//
#define MPHEAP_PRIVATE_FLAGS (MPHEAP_COLLECT_STATS | MPHEAP_ZERO_MEMORY);

//
// Define the heap header that gets tacked on the front of
// every allocation. Eight bytes is a lot, but we can't make
// it any smaller or else the allocation will not be properly
// aligned for 64-bit quantities.
//
typedef struct _MP_HEADER {
    union {
        struct _MP_HEAP_ENTRY *HeapEntry;
        PSINGLE_LIST_ENTRY Next;
    };
    ULONG LookasideIndex;
} MP_HEADER, *PMP_HEADER;
//
// Definitions and structures for lookaside list
//
#define LIST_ENTRIES 128

typedef struct _MP_HEAP_LOOKASIDE {
    PMP_HEADER Entry;
} MP_HEAP_LOOKASIDE, *PMP_HEAP_LOOKASIDE;

#define NO_LOOKASIDE 0xffffffff
#define MaxLookasideSize (8*LIST_ENTRIES-7)
#define LookasideIndexFromSize(s) ((s < MaxLookasideSize) ? ((s) >> 3) : NO_LOOKASIDE)

//
// Define the structure that describes the entire MP heap.
//
// There is one MP_HEAP_ENTRY structure for each Win32 heap
// and a MP_HEAP structure that contains them all.
//
// Each MP_HEAP structure contains a lookaside list for quick
// lock-free alloc/free of various size blocks.
//

typedef struct _MP_HEAP_ENTRY {
    HANDLE Heap;
    PSINGLE_LIST_ENTRY DelayedFreeList;
    CRITICAL_SECTION Lock;
    DWORD Allocations;
    DWORD Frees;
    DWORD LookasideAllocations;
    DWORD LookasideFrees;
    DWORD DelayedFrees;
    MP_HEAP_LOOKASIDE Lookaside[LIST_ENTRIES];
} MP_HEAP_ENTRY, *PMP_HEAP_ENTRY;


typedef struct _MP_HEAP {
    DWORD HeapCount;
    DWORD Flags;
    DWORD Hint;
    DWORD PadTo32Bytes;
    MP_HEAP_ENTRY Entry[1];     // variable size
} MP_HEAP, *PMP_HEAP;

VOID
ProcessDelayedFreeList(
    IN PMP_HEAP_ENTRY HeapEntry
    );

//
// HeapHint is a per-thread variable that offers a hint as to which heap to
// check first.  By giving each thread affinity towards a different heap,
// it is more likely that the first heap a thread picks for its allocation
// will be available.  It also improves a thread's locality of reference,
// which is very important for good MP performance
//
#define SetHeapHint(x)	TlsSetValue(tlsiHeapHint,(LPVOID)(x))
#define GetHeapHint()	(DWORD_PTR)TlsGetValue(tlsiHeapHint)

HANDLE
WINAPI
MpHeapCreate(
    DWORD flOptions,
    DWORD dwInitialSize,
    DWORD dwParallelism
    )
/*++

Routine Description:

    This routine creates an MP-enhanced heap. An MP heap consists of a
    collection of standard Win32 heaps whose serialization is controlled
    by the routines in this module to allow multiple simultaneous allocations.

Arguments:

    flOptions - Supplies the options for this heap.

        Currently valid flags are:

            MPHEAP_GROWABLE
            MPHEAP_REALLOC_IN_PLACE_ONLY
            MPHEAP_TAIL_CHECKING_ENABLED
            MPHEAP_FREE_CHECKING_ENABLED
            MPHEAP_DISABLE_COALESCE_ON_FREE
            MPHEAP_ZERO_MEMORY
            MPHEAP_COLLECT_STATS

    dwInitialSize - Supplies the initial size of the combined heaps.

    dwParallelism - Supplies the number of Win32 heaps that will make up the
        MP heap. A value of zero defaults to three + # of processors.

Return Value:

    HANDLE - Returns a handle to the MP heap that can be passed to the
             other routines in this package.

    NULL - Failure, GetLastError() specifies the exact error code.

--*/
{
    DWORD Error;
    DWORD i;
    HANDLE Heap;
    PMP_HEAP MpHeap;
    DWORD HeapSize;
    DWORD PrivateFlags;

    if (flOptions & ~MPHEAP_VALID_OPTIONS) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    flOptions |= HEAP_NO_SERIALIZE;

    PrivateFlags = flOptions & MPHEAP_PRIVATE_FLAGS;

    flOptions &= ~MPHEAP_PRIVATE_FLAGS;

    if (dwParallelism == 0) {
        SYSTEM_INFO SystemInfo;

        GetSystemInfo(&SystemInfo);
        dwParallelism = 3 + SystemInfo.dwNumberOfProcessors;
    }

    HeapSize = dwInitialSize / dwParallelism;

    //
    // The first heap is special, since the MP_HEAP structure itself
    // is allocated from there.
    //
    Heap = HeapCreate(flOptions,HeapSize,0);
    if (Heap == NULL) {
        //
        // HeapCreate has already set last error appropriately.
        //
        return(NULL);
    }

    MpHeap = HeapAlloc(Heap,0,sizeof(MP_HEAP) +
                              (dwParallelism-1)*sizeof(MP_HEAP_ENTRY));
    if (MpHeap==NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        HeapDestroy(Heap);
        return(NULL);
    }

    //
    // Initialize the MP heap structure
    //
    MpHeap->HeapCount = 1;
    MpHeap->Flags = PrivateFlags;
    MpHeap->Hint = 0;

    //
    // Initialize the first heap
    //
    MpHeap->Entry[0].Heap = Heap;
    InitializeCriticalSection(&MpHeap->Entry[0].Lock);
    MpHeap->Entry[0].DelayedFreeList = NULL;
    ZeroMemory(MpHeap->Entry[0].Lookaside, sizeof(MpHeap->Entry[0].Lookaside));

    //
    // Initialize the remaining heaps. Note that the heap has been
    // sufficiently initialized to use MpHeapDestroy for cleanup
    // if something bad happens.
    //
    for (i=1; i<dwParallelism; i++) {
        MpHeap->Entry[i].Heap = HeapCreate(flOptions, HeapSize, 0);
        if (MpHeap->Entry[i].Heap == NULL) {
            Error = GetLastError();
            MpHeapDestroy((HANDLE)MpHeap);
            SetLastError(Error);
            return(NULL);
        }
        InitializeCriticalSection(&MpHeap->Entry[i].Lock);
        MpHeap->Entry[i].DelayedFreeList = NULL;
        ZeroMemory(MpHeap->Entry[i].Lookaside, sizeof(MpHeap->Entry[i].Lookaside));
        ++MpHeap->HeapCount;
    }

    return((HANDLE)MpHeap);
}

BOOL
WINAPI
MpHeapDestroy(
    HANDLE hMpHeap
    )
{
    DWORD i;
    DWORD HeapCount;
    PMP_HEAP MpHeap;
    BOOL Success = TRUE;

    MpHeap = (PMP_HEAP)hMpHeap;
    HeapCount = MpHeap->HeapCount;

	if (HeapCount)
	{

		//
		// Lock down all the heaps so we don't end up hosing people
		// who may be allocating things while we are deleting the heaps.
		// By setting MpHeap->HeapCount = 0 we also attempt to prevent
		// people from getting hosed as soon as we delete the critical
		// sections and heaps.
		//
		MpHeap->HeapCount = 0;
		for (i=0; i<HeapCount; i++) {
			EnterCriticalSection(&MpHeap->Entry[i].Lock);
		}

		//
		// Delete the heaps and their associated critical sections.
		// Note that the order is important here. Since the MpHeap
		// structure was allocated from MpHeap->Heap[0] we must
		// delete that last.
		//
		for (i=HeapCount-1; i>0; i--) {
			DeleteCriticalSection(&MpHeap->Entry[i].Lock);
			if (!HeapDestroy(MpHeap->Entry[i].Heap)) {
				Success = FALSE;
			}
		}

		DeleteCriticalSection(&MpHeap->Entry[0].Lock);
		Success = HeapDestroy(MpHeap->Entry[0].Heap);
	}
    return(Success);
}

BOOL
WINAPI
MpHeapValidate(
    HANDLE hMpHeap,
    LPVOID lpMem
    )
{
    PMP_HEAP MpHeap;
    DWORD i;
    BOOL Success;
    PMP_HEADER Header;
    PMP_HEAP_ENTRY Entry;

    MpHeap = (PMP_HEAP)hMpHeap;

    if (lpMem == NULL) {

        //
        // Lock and validate each heap in turn.
        //
        for (i=0; i < MpHeap->HeapCount; i++) {
            Entry = &MpHeap->Entry[i];
            __try {
                EnterCriticalSection(&Entry->Lock);
                Success = HeapValidate(Entry->Heap, 0, NULL);
                LeaveCriticalSection(&Entry->Lock);
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                return(FALSE);
            }

            if (!Success) {
                return(FALSE);
            }
        }
        return(TRUE);
    } else {

        //
        // Lock and validate the given heap entry
        //
        Header = ((PMP_HEADER)lpMem) - 1;
        __try {
            EnterCriticalSection(&Header->HeapEntry->Lock);
            Success = HeapValidate(Header->HeapEntry->Heap, 0, Header);
            LeaveCriticalSection(&Header->HeapEntry->Lock);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            return(FALSE);
        }
        return(Success);
    }
}

SIZE_T
WINAPI
MpHeapCompact(
    HANDLE hMpHeap
    )
{
    PMP_HEAP MpHeap;
    DWORD i;
    SIZE_T LargestFreeSize=0;
    SIZE_T FreeSize;
    PMP_HEAP_ENTRY Entry;

    MpHeap = (PMP_HEAP)hMpHeap;

    //
    // Lock and compact each heap in turn.
    //
    for (i=0; i < MpHeap->HeapCount; i++) {
        Entry = &MpHeap->Entry[i];
        EnterCriticalSection(&Entry->Lock);
        FreeSize = HeapCompact(Entry->Heap, 0);
        LeaveCriticalSection(&Entry->Lock);

        if (FreeSize > LargestFreeSize) {
            LargestFreeSize = FreeSize;
        }
    }

    return(LargestFreeSize);

}


LPVOID
WINAPI
MpHeapAlloc(
    HANDLE hMpHeap,
    DWORD flOptions,
    DWORD dwBytes
    )
{
    PMP_HEADER Header;
    PMP_HEAP MpHeap;
    DWORD_PTR i;
    PMP_HEAP_ENTRY Entry;
    DWORD Index;
    DWORD Size;

    MpHeap = (PMP_HEAP)hMpHeap;

    flOptions |= MpHeap->Flags;

    Size = ((dwBytes + 7) & (ULONG)~7) + sizeof(MP_HEADER);
    Index=LookasideIndexFromSize(Size);

    //
    // Iterate through the heap locks looking for one
    // that is not owned.
    //
    i=GetHeapHint();
    if (i>=MpHeap->HeapCount) {
        i=0;
        SetHeapHint(0);
    }
    Entry = &MpHeap->Entry[i];
    do {
        //
        // Check the lookaside list for a suitable allocation.
        //
        if ((Index != NO_LOOKASIDE) &&
            (Entry->Lookaside[Index].Entry != NULL)) {
            if ((Header = InterlockedExchangePointer(&Entry->Lookaside[Index].Entry,
                                                          NULL)) != NULL) {
                //
                // We have a lookaside hit, return it immediately.
                //
                ++Entry->LookasideAllocations;
                if (flOptions & MPHEAP_ZERO_MEMORY) {
                    ZeroMemory(Header + 1, dwBytes);
                }
                SetHeapHint(i);
                return(Header + 1);
            }
        }

        //
        // Attempt to lock this heap without blocking.
        //
        if (TryEnterCriticalSection(&Entry->Lock)) {
            //
            // success, go allocate immediately
            //
            goto LockAcquired;
        }

        //
        // This heap is owned by another thread, try
        // the next one.
        //
        i++;
        Entry++;
        if (i==MpHeap->HeapCount) {
            i=0;
            Entry=&MpHeap->Entry[0];
        }
    } while ( i != GetHeapHint());

    //
    // All of the critical sections were owned by someone else,
    // so we have no choice but to wait for a critical section.
    //
    EnterCriticalSection(&Entry->Lock);

LockAcquired:
    ++Entry->Allocations;
    if (Entry->DelayedFreeList != NULL) {
        ProcessDelayedFreeList(Entry);
    }
    Header = HeapAlloc(Entry->Heap, 0, Size);
    LeaveCriticalSection(&Entry->Lock);
    if (Header != NULL) {
        Header->HeapEntry = Entry;
        Header->LookasideIndex = Index;
        if (flOptions & MPHEAP_ZERO_MEMORY) {
            ZeroMemory(Header + 1, dwBytes);
        }
        SetHeapHint(i);
        return(Header + 1);
    } else {
        return(NULL);
    }
}

LPVOID
WINAPI
MpHeapReAlloc(
    HANDLE hMpHeap,
    LPVOID lpMem,
    DWORD dwBytes
    )
{
    PMP_HEADER Header;
    PCRITICAL_SECTION Lock;

    Header = ((PMP_HEADER)lpMem) - 1;
    Lock = &Header->HeapEntry->Lock;
    dwBytes = ((dwBytes + 7) & (ULONG)~7) + sizeof(MP_HEADER);

    EnterCriticalSection(Lock);
    Header = HeapReAlloc(Header->HeapEntry->Heap, 0, Header, dwBytes);
    LeaveCriticalSection(Lock);

    if (Header != NULL) {
        Header->LookasideIndex = LookasideIndexFromSize(dwBytes);
        return(Header + 1);
    } else {
        return(NULL);
    }
}

BOOL
WINAPI
MpHeapFree(
    HANDLE hMpHeap,
    LPVOID lpMem
    )
{
    PMP_HEADER Header;
    PCRITICAL_SECTION Lock;
    BOOL Success;
    PMP_HEAP_ENTRY HeapEntry;
    PSINGLE_LIST_ENTRY Next;
    PMP_HEAP MpHeap;

    Header = ((PMP_HEADER)lpMem) - 1;
    HeapEntry = Header->HeapEntry;
    MpHeap = (PMP_HEAP)hMpHeap;

    SetHeapHint(HeapEntry - &MpHeap->Entry[0]);

    if (Header->LookasideIndex != NO_LOOKASIDE) {
        //
        // Try and put this back on the lookaside list
        //
        if (InterlockedCompareExchangePointer(&HeapEntry->Lookaside[Header->LookasideIndex].Entry,
                                       Header,
                                       NULL) == NULL) {
            //
            // Successfully freed to lookaside list.
            //
            ++HeapEntry->LookasideFrees;
            return(TRUE);
        }
    }
    Lock = &HeapEntry->Lock;

    if (TryEnterCriticalSection(Lock)) {
        ++HeapEntry->Frees;
        Success = HeapFree(HeapEntry->Heap, 0, Header);
        LeaveCriticalSection(Lock);
        return(Success);
    }
    //
    // The necessary heap critical section could not be immediately
    // acquired. Post this free onto the Delayed free list and let
    // whoever has the lock process it.
    //
    do {
        Next = HeapEntry->DelayedFreeList;
        Header->Next = Next;
    } while ( InterlockedCompareExchangePointer(&HeapEntry->DelayedFreeList,
                                         &Header->Next,
                                         Next) != Next);
    return(TRUE);
}


SIZE_T
WINAPI
MpHeapSize(
		   HANDLE hMpHeap,
		   DWORD ulFlags,
		   LPVOID lpMem
		  )
{
	PMP_HEADER Header;
	PCRITICAL_SECTION Lock;
	SIZE_T dwSize;

	Header = ((PMP_HEADER)lpMem) - 1;
	Lock = &Header->HeapEntry->Lock;

	EnterCriticalSection(Lock);
	dwSize = HeapSize(Header->HeapEntry->Heap, 0, Header);
	dwSize -= sizeof(MP_HEADER);			// dbb X5 bug 51663
	LeaveCriticalSection(Lock);

	return dwSize;
}


VOID
ProcessDelayedFreeList(
    IN PMP_HEAP_ENTRY HeapEntry
    )
{
    PSINGLE_LIST_ENTRY FreeList;
    PSINGLE_LIST_ENTRY Next;
    PMP_HEADER Header;

    //
    // Capture the entire delayed free list with a single interlocked exchange.
    // Once we have removed the entire list, free each entry in turn.
    //
    FreeList = (PSINGLE_LIST_ENTRY)InterlockedExchangePointer(&HeapEntry->DelayedFreeList, NULL);
    while (FreeList != NULL) {
        Next = FreeList->Next;
        Header = CONTAINING_RECORD(FreeList, MP_HEADER, Next);
        ++HeapEntry->DelayedFrees;
        HeapFree(HeapEntry->Heap, 0, Header);
        FreeList = Next;
    }
}

DWORD
MpHeapGetStatistics(
    HANDLE hMpHeap,
    LPDWORD lpdwSize,
    MPHEAP_STATISTICS Stats[]
    )
{
    PMP_HEAP MpHeap;
    PMP_HEAP_ENTRY Entry;
    DWORD i;
    DWORD RequiredSize;

    MpHeap = (PMP_HEAP)hMpHeap;
    RequiredSize = MpHeap->HeapCount * sizeof(MPHEAP_STATISTICS);
    if (*lpdwSize < RequiredSize) {
        *lpdwSize = RequiredSize;
        return(ERROR_MORE_DATA);
    }
    ZeroMemory(Stats, MpHeap->HeapCount * sizeof(MPHEAP_STATISTICS));
    for (i=0; i < MpHeap->HeapCount; i++) {
        Entry = &MpHeap->Entry[i];

        Stats[i].Contention = Entry->Lock.DebugInfo->ContentionCount;
        Stats[i].TotalAllocates = (Entry->Allocations + Entry->LookasideAllocations);
        Stats[i].TotalFrees = (Entry->Frees + Entry->LookasideFrees + Entry->DelayedFrees);
        Stats[i].LookasideAllocates = Entry->LookasideAllocations;
        Stats[i].LookasideFrees = Entry->LookasideFrees;
        Stats[i].DelayedFrees = Entry->DelayedFrees;
    }
    *lpdwSize = RequiredSize;
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\staxmem\mpheap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mpheap.h

Abstract:

    Public header file for MP heap package

Author:

    John Vert (jvert) 10-Jul-1995

Revision History:

--*/

//
// Valid heap creation options
//
#define MPHEAP_GROWABLE HEAP_GROWABLE
#define MPHEAP_REALLOC_IN_PLACE_ONLY HEAP_REALLOC_IN_PLACE_ONLY
#define MPHEAP_TAIL_CHECKING_ENABLED HEAP_TAIL_CHECKING_ENABLED
#define MPHEAP_FREE_CHECKING_ENABLED HEAP_FREE_CHECKING_ENABLED
#define MPHEAP_DISABLE_COALESCE_ON_FREE HEAP_DISABLE_COALESCE_ON_FREE
#define MPHEAP_ZERO_MEMORY HEAP_ZERO_MEMORY
#define MPHEAP_COLLECT_STATS 0x10000000

HANDLE
WINAPI
MpHeapCreate(
    DWORD flOptions,
    DWORD dwInitialSize,
    DWORD dwParallelism
    );

BOOL
WINAPI
MpHeapDestroy(
    HANDLE hMpHeap
    );

BOOL
WINAPI
MpHeapValidate(
    HANDLE hMpHeap,
    LPVOID lpMem
    );

SIZE_T
WINAPI
MpHeapCompact(
    HANDLE hMpHeap
    );

LPVOID
WINAPI
MpHeapAlloc(
    HANDLE hMpHeap,
    DWORD flOptions,
    DWORD dwBytes
    );

LPVOID
WINAPI
MpHeapReAlloc(
    HANDLE hMpHeap,
    LPVOID lpMem,
    DWORD dwBytes
    );

BOOL
WINAPI
MpHeapFree(
    HANDLE hMpHeap,
    LPVOID lpMem
    );

SIZE_T
WINAPI
MpHeapSize(
	HANDLE hMpHeap,
	DWORD ulFlags,
	LPVOID lpMem
	);
//
// Statistics structure
//
typedef struct _MPHEAP_STATISTICS {
    DWORD Contention;
    DWORD TotalAllocates;
    DWORD TotalFrees;
    DWORD LookasideAllocates;
    DWORD LookasideFrees;
    DWORD DelayedFrees;
} MPHEAP_STATISTICS, *LPMPHEAP_STATISTICS;

DWORD
MpHeapGetStatistics(
    HANDLE hMpHeap,
    LPDWORD lpdwSize,
    MPHEAP_STATISTICS Statistics[]
    );

//
// TLS index for exchmem heap selection
//
extern DWORD tlsiHeapHint;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\staxmem\_exchmem.h ===
/*
 -	_ E X C H M E M . H
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 *
 *	Copyright (C) 1995-96, Microsoft Corporation.
 */

#ifdef __cplusplus
extern "C"
{
#endif

//	Size of Multiple Heap block header

#ifdef _X86_
#define	cbMHeapHeader		sizeof(HANDLE)
//#define	cbMHeapHeader		(sizeof(HANDLE) + sizeof(LPVOID))
#else
#define	cbMHeapHeader		(2*sizeof(HANDLE))
#endif

#define HandleFromMHeapPv(pv)	(*((HANDLE *)((BYTE *)pv - cbMHeapHeader)))
#define PvFromMHeapPv(pv)		((LPVOID)((BYTE *)pv - cbMHeapHeader))
//#define PvRetFromPv(pv)		    ((LPVOID)((BYTE *)pv + (cbMHeapHeader/2)))
//#define PvRetFromMHeapPv(pv)    ((LPVOID)((BYTE *)pv - (cbMHeapHeader/2)))
#define MHeapPvFromPv(pv)		((LPVOID)((BYTE *)pv + cbMHeapHeader))

#define cHeapsDef 4

typedef struct _heaptbl
{
	ULONG	cRef;
	ULONG	cHeaps;
	HANDLE	rghheap[1];
	
} HEAPTBL, * LPHEAPTBL;


#ifdef DEBUG

//	This stuff is used for overwrite detection 
//	and block validation during free calls.

#define cbOWSection 4

#define PvFromPvHead(pv)			((LPVOID)((BYTE *)pv + cbOWSection))
#define PvHeadFromPv(pv)			((LPVOID)((BYTE *)pv - cbOWSection))
#define PvTailFromPv(pv, cb)		((LPVOID)((BYTE *)pv + cb))
#define PvTailFromPvHead(pv, cb)	((LPVOID)((BYTE *)pv + cb + cbOWSection))

#define chOWFill			((BYTE)0xAB)
#define chDefaultAllocFill	((BYTE)0xFE)
#define chDefaultFreeFill	((BYTE)0xCD)

//	Default stack frame size for tracing call stacks.

#define NSTK				128

//	Forward declarations of heap and block types

typedef struct HEAP	HEAP,	* PHEAP,	** PPHEAP;
typedef struct HBLK	HBLK,	* PHBLK,	** PPHBLK;

//	Exports from GLHMON32.DLL

typedef BOOL (APIENTRY HEAPMONPROC)(PHEAP plh, ULONG ulFlags);
typedef HEAPMONPROC FAR *LPHEAPMONPROC;
typedef BOOL (APIENTRY GETSYMNAMEPROC)(DWORD, LPSTR, LPSTR, DWORD FAR *);
typedef GETSYMNAMEPROC FAR *LPGETSYMNAMEPROC;

//	C-RunTime function pointer defs

typedef void * (__cdecl FMALLOC)(size_t);
typedef FMALLOC FAR *LPFMALLOC;
typedef void * (__cdecl FREALLOC)(void *, size_t);
typedef FREALLOC FAR *LPFREALLOC;
typedef void   (__cdecl FFREE)(void *);
typedef FFREE FAR *LPFFREE;
typedef void * (__cdecl FCALLOC)(size_t, size_t);
typedef FCALLOC FAR *LPFCALLOC;
typedef char * (__cdecl FSTRDUP)(const char *);
typedef FSTRDUP FAR *LPFSTRDUP;
typedef size_t   (__cdecl FMEMSIZE)(void *);
typedef FMEMSIZE FAR *LPFMEMSIZE;


#define HEAPMON_LOAD		((ULONG) 0x00000001)
#define HEAPMON_UNLOAD		((ULONG) 0x00000002)
#define HEAPMON_PING		((ULONG) 0x00000003)


#define HEAP_USE_VIRTUAL		((ULONG) 0x00000001)
#define HEAP_DUMP_LEAKS			((ULONG) 0x00000002)
#define HEAP_ASSERT_LEAKS		((ULONG) 0x00000004)
#define HEAP_FILL_MEM			((ULONG) 0x00000008)
#define HEAP_HEAP_MONITOR		((ULONG) 0x00000010)
#define HEAP_USE_VIRTUAL_4		((ULONG) 0x00000020)
#define HEAP_FAILURES_ENABLED	((ULONG) 0x00000040)
#define HEAP_LOCAL				((ULONG) 0x10000000)
#define HEAP_GLOBAL				((ULONG) 0x20000000)


typedef VOID (__cdecl *LPHEAPSETNAME)(LPVOID, char *, ...);

struct HBLK
{
	PHEAP		pheap;			  	// Heap this block was allocated on
	PHBLK		phblkPrev;		  	// Pointer to the prev allocation this heap
	PHBLK		phblkNext;		  	// Pointer to the next allocation this heap
	PHBLK		phblkFreeNext;		// Pointer to next free block on this heap
	char		szName[128];	  	// We can name blocks allocated on a heap
	ULONG		ulAllocNum;		  	// Allocation number (Id) for this block
	ULONG		ulSize;			  	// Number of bytes the client requested
	DWORD_PTR	rgdwCallers[NSTK];	// Call stack during this allocation
	DWORD_PTR	rgdwFree[NSTK];		// Call stack that freed this block
	LPVOID		pv;				  	// Pointer to the client data
};

struct HEAP
{
	LPHEAPSETNAME	pfnSetName;		// Pointer to HEAP_SetNameFn function
	HANDLE			hDataHeap;		// The underlying heap that we alloc data from
	HANDLE			hBlksHeap;		// The underlying heap that we alloc hblks from
	PHEAP			pNext;			// Pointer to the next heap in a list of heaps
	char			szHeapName[32];	// We can name our heaps for display purposes
	ULONG			ulAllocNum;		// Allocation number this heap since Open
	PHBLK			phblkHead;		// Link-list of allocations on this heap
	PHBLK			phblkFree;		// Link-list of freed allocations from this heap.
	ULONG			cEntriesFree;	// Number of freed allocations from the heap.
	ULONG			ulFlags;		// Combination of the HEAP_ flags above
	BYTE			chFill;			// Character to fill memory with

	HINSTANCE		hInstHeapMon;	// DLL instance of the HeapMonitor DLL
	LPHEAPMONPROC 	pfnHeapMon;		// Entry point into HeapMonitor DLL

	CRITICAL_SECTION cs;			// Critcal section to protect access to heap

	ULONG			ulFailBufSize;	// If HEAP_FAILURES_ENABLED, this is the minimum 
									// size in which failures occur.  1 means alloc's 
									// of any size fail. 0 means never fail.
	ULONG			ulFailInterval;	// If HEAP_FAILURES_ENABLED, this is the period on 
									// which the failures occur.  1 means every alloc 
									// will fail. 0 means never fail.
	ULONG			ulFailStart;	// If HEAP_FAILURES_ENABLED, this is the allocation 
									// number that the first failure will occur on.  
									// 1 means the first alloc.  0 means never 
									// start failing.	
	ULONG			iAllocationFault;

	LPGETSYMNAMEPROC pfnGetSymName;	// Resolve address to Symbol
};


PHBLK	PvToPhblk(HANDLE hlh, LPVOID pv);
#define PhblkToPv(pblk)			((LPVOID)((PHBLK)(pblk)->pv))
#define CbPhblkClient(pblk)		(((PHBLK)(pblk))->ulSize)
#define CbPvClient(hlh, pv)		(CbPhblkClient(PvToPhblk(hlh, pv)))
#define CbPvAlloc(hlh, pv)		(CbPhblkAlloc(PvToPhblk(hlh, pv)))

#define	IFHEAPNAME(x)	x

VOID __cdecl HeapSetHeapNameFn(HANDLE hlh, char *pszFormat, ...);
VOID __cdecl HeapSetNameFn(HANDLE hlh, LPVOID pv, char *pszFormat, ...);

char * HeapGetName(HANDLE hlh, LPVOID pv);


#define HeapSetHeapName(hlh,psz)					IFHEAPNAME(HeapSetHeapNameFn(hlh,psz))
#define HeapSetHeapName1(hlh,psz,a1)				IFHEAPNAME(HeapSetHeapNameFn(hlh,psz,a1))
#define HeapSetHeapName2(hlh,psz,a1,a2)				IFHEAPNAME(HeapSetHeapNameFn(hlh,psz,a1,a2))
#define HeapSetHeapName3(hlh,psz,a1,a2,a3)			IFHEAPNAME(HeapSetHeapNameFn(hlh,psz,a1,a2,a3))
#define HeapSetHeapName4(hlh,psz,a1,a2,a3,a4)		IFHEAPNAME(HeapSetHeapNameFn(hlh,psz,a1,a2,a3,a4))
#define HeapSetHeapName5(hlh,psz,a1,a2,a3,a4,a5)	IFHEAPNAME(HeapSetHeapNameFn(hlh,psz,a1,a2,a3,a4,a5))

#define HeapSetName(hlh,pv,psz)						IFHEAPNAME(HeapSetNameFn(hlh,pv,psz))
#define HeapSetName1(hlh,pv,psz,a1)					IFHEAPNAME(HeapSetNameFn(hlh,pv,psz,a1))
#define HeapSetName2(hlh,pv,psz,a1,a2)				IFHEAPNAME(HeapSetNameFn(hlh,pv,psz,a1,a2))
#define HeapSetName3(hlh,pv,psz,a1,a2,a3)			IFHEAPNAME(HeapSetNameFn(hlh,pv,psz,a1,a2,a3))
#define HeapSetName4(hlh,pv,psz,a1,a2,a3,a4)		IFHEAPNAME(HeapSetNameFn(hlh,pv,psz,a1,a2,a3,a4))
#define HeapSetName5(hlh,pv,psz,a1,a2,a3,a4,a5)		IFHEAPNAME(HeapSetNameFn(hlh,pv,psz,a1,a2,a3,a4,a5))


//	Misc. debug support functions

BOOL InitDebugExchMem(HMODULE hModule);
VOID UnInitDebugExchMem(VOID);
BOOL FForceFailure(PHEAP pheap, ULONG cb);
BOOL FRegisterHeap(PHEAP pheap);
VOID UnRegisterHeap(PHEAP pheap);
VOID HeapDumpLeaks(PHEAP pheap, BOOL fNoFree);
BOOL HeapValidatePhblk(PHEAP pheap, PHBLK pheapblk, char ** pszReason);
BOOL HeapDidAlloc(PHEAP pheap, LPVOID pv);
BOOL HeapValidatePv(PHEAP pheap, LPVOID pv, char * pszFunc);
VOID PhblkEnqueue(PHBLK pheapblk);
VOID PhblkDequeue(PHBLK pheapblk);
BYTE HexByteToBin(LPSTR sz);
BOOL IsProcessRunningAsService(VOID);
VOID GetCallStack(DWORD_PTR *rgdwCaller, DWORD cFind);
VOID RemoveExtension(LPSTR psz);
VOID GetLogFilePath(LPSTR szPath, LPSTR szExt, LPSTR szFilePath);

void __cdecl DebugTraceFn(char *pszFormat, ...);

#define	Trace	DebugTraceFn
#define DebugTrace(psz)							DebugTraceFn(psz)
#define DebugTrace1(psz, a1)					DebugTraceFn(psz, a1)
#define DebugTrace2(psz, a1, a2)				DebugTraceFn(psz, a1, a2)
#define DebugTrace3(psz, a1, a2, a3)			DebugTraceFn(psz, a1, a2, a3)
#define DebugTrace4(psz, a1, a2, a3, a4)		DebugTraceFn(psz, a1, a2, a3, a4)
#define DebugTrace5(psz, a1, a2, a3, a4, a5)	DebugTraceFn(psz, a1, a2, a3, a4, a5)


#define Assert(fCondition)			\
		((fCondition) ? (0) : AssertFn(__FILE__, __LINE__, #fCondition))
#define AssertSz(fCondition, sz)	\
		((fCondition) ? (0) : AssertFn(__FILE__, __LINE__, sz))
void AssertFn(char * szFile, int nLine, char * szMsg);


VOID GetStackSymbols(
		HANDLE hProcess, 
		CHAR * rgchBuff, 
		DWORD_PTR * rgdwStack, 
		DWORD cFrames);

VOID LogCurrentAPI(
		WORD wApi,
		DWORD_PTR *rgdwCallStack, 
		DWORD cFrames,
		DWORD_PTR *rgdwArgs, 
		DWORD cArgs);


//	Virtual Memory Support (NYI)

LPVOID
WINAPI
VMAllocEx(
	ULONG	cb, 
	ULONG	cbCluster);

VOID
WINAPI
VMFreeEx(
	LPVOID	pv, 
	ULONG	cbCluster);

LPVOID
WINAPI
VMReallocEx(
	LPVOID	pv, 
	ULONG	cb,
	ULONG	cbCluster);

ULONG 
WINAPI
VMGetSizeEx(
	LPVOID	pv, 
	ULONG	cbCluster);

BOOL 
VMValidatePvEx(
	LPVOID	pv, 
	ULONG	cbCluster);


//	Debug APIs

HANDLE
NTAPI
DebugHeapCreate(
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize);


BOOL
NTAPI
DebugHeapDestroy(
	HANDLE	hHeap);


LPVOID
NTAPI
DebugHeapAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	DWORD	dwSize);


LPVOID
NTAPI
DebugHeapReAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvOld,
	DWORD	dwSize);


BOOL
NTAPI
DebugHeapFree(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvFree);


BOOL
NTAPI
DebugHeapLock(
	HANDLE hHeap);


BOOL
NTAPI
DebugHeapUnlock(
	HANDLE hHeap);


BOOL
NTAPI
DebugHeapWalk(
	HANDLE hHeap,
	LPPROCESS_HEAP_ENTRY lpEntry);


BOOL
NTAPI
DebugHeapValidate(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem);


SIZE_T
NTAPI
DebugHeapSize(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem);


SIZE_T
NTAPI
DebugHeapCompact(
	HANDLE hHeap,
	DWORD dwFlags);

//	Macros to wrapper Heap API calls (debug)

#define ExHeapCreate(a, b, c)		DebugHeapCreate(a, b, c)
#define ExHeapDestroy(a)			DebugHeapDestroy(a)
#define ExHeapAlloc(a, b, c)		DebugHeapAlloc(a, b, c)
#define ExHeapReAlloc(a, b, c, d)	DebugHeapReAlloc(a, b, c, d)
#define ExHeapFree(a, b, c)			DebugHeapFree(a, b, c)
#define ExHeapLock(a)				DebugHeapLock(a)
#define ExHeapUnlock(a)				DebugHeapUnlock(a)
#define ExHeapWalk(a, b)			DebugHeapWalk(a, b)
#define ExHeapValidate(a, b, c)		DebugHeapValidate(a, b, c)
#define ExHeapSize(a, b, c)			DebugHeapSize(a, b, c)
#define ExHeapCompact(a, b)			DebugHeapCompact(a, b)

//	API Id for TrackMem logging

#define API_HEAP_CREATE				((WORD) 0)
#define API_HEAP_DESTROY			((WORD) 1)
#define API_HEAP_ALLOC				((WORD) 2)
#define API_HEAP_REALLOC			((WORD) 3)
#define API_HEAP_FREE				((WORD) 4)

#else

//	Macros to wrapper Heap API calls (retail)

#define ExHeapCreate(a, b, c)		HeapCreate(a, b, c)
#define ExHeapDestroy(a)			HeapDestroy(a)
#define ExHeapAlloc(a, b, c)		HeapAlloc(a, b, c)
#define ExHeapReAlloc(a, b, c, d)	HeapReAlloc(a, b, c, d)
#define ExHeapFree(a, b, c)			HeapFree(a, b, c)
#define ExHeapLock(a)				HeapLock(a)
#define ExHeapUnlock(a)				HeapUnlock(a)
#define ExHeapWalk(a, b)			HeapWalk(a, b)
#define ExHeapValidate(a, b, c)		HeapValidate(a, b, c)
#define ExHeapSize(a, b, c)			HeapSize(a, b, c)
#define ExHeapCompact(a, b)			HeapCompact(a, b)

#define Assert(fCondition)
#define AssertSz(fCondition, sz)

#define DebugTrace(psz)
#define DebugTrace1(psz, a1)
#define DebugTrace2(psz, a1, a2)
#define DebugTrace3(psz, a1, a2, a3)
#define DebugTrace4(psz, a1, a2, a3, a4)
#define DebugTrace5(psz, a1, a2, a3, a4, a5)


#endif	// DEBUG

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\sync\synconst.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

        synconst.cpp

Abstract:

        This module contains the declaration of some of the 
		synchronization costants

Author:

        Keith Lau       (keithlau@microsoft.com)

Revision History:

        keithlau        03/02/98        created

--*/

#include <tchar.h>

// Lock ranks
int				rankBlockMgr					= 0x1000;
int				rankRecipientHash				= 0x2000;
int				rankLoggingPropertyBag			= 0x4000;

// Instance names
TCHAR		 	*szBlockMgr						= _T("Blockmgr");
TCHAR			*szRecipientHash				= _T("RcptHash");
TCHAR			*szLoggingPropertyBag			= _T("LogPBag");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\sync\sync.cxx ===
#include "windows.h"
#include "sync.hxx"


//  system max spin count

int cSpinMax = 0;


//  Page Memory Allocation

void* PvPageAlloc( const size_t cbSize, void* const pv );
void PageFree( void* const pv );


#ifdef SYNC_ANALYZE_PERFORMANCE

//  Performance Data Dump

CPRINTFSYNC* pcprintfPerfData;

#endif  //  SYNC_ANALYZE_PERFORMANCE


//  Kernel Semaphore Pool

//  ctor

CKernelSemaphorePool::CKernelSemaphorePool()
	{
	}

//  dtor

CKernelSemaphorePool::~CKernelSemaphorePool()
	{
	}

//  init

const BOOL CKernelSemaphorePool::FInit()
	{
	//  semaphore pool should be terminated

	Assert( !FInitialized() );

	//  reset members

	m_cksem = 0;
	m_mpirksemrksem = 0;
	m_irksemTop = irksemNil;
	m_irksemNext = irksemUnknown;
	
	//  allocate kernel semaphore array

	if ( !( m_mpirksemrksem = (CReferencedKernelSemaphore*)PvPageAlloc( sizeof( CReferencedKernelSemaphore ) * 65536, NULL ) ) )
		{
		Term();
		return fFalse;
		}

	Assert( m_cksem == 0 );
	Assert( m_irksemTop == irksemNil );
	Assert( m_irksemNext == irksemUnknown );

	//  init successful

	return fTrue;
	}

//  term

void CKernelSemaphorePool::Term()
	{
	//  the kernel semaphore array is allocated

	if ( m_mpirksemrksem )
		{
		//  terminate all initialized kernel semaphores

		for ( m_cksem-- ; m_cksem >= 0; m_cksem-- )
			{
			m_mpirksemrksem[m_cksem].Term();
			m_mpirksemrksem[m_cksem].~CReferencedKernelSemaphore();
			}

		//  delete the kernel semaphore array
		
		PageFree( m_mpirksemrksem );
		}
	
	//  reset data members

	m_cksem = 0;
	m_mpirksemrksem = 0;
	m_irksemTop = irksemNil;
	m_irksemNext = irksemUnknown;
	}

//  Referenced Kernel Semaphore

//  ctor

CKernelSemaphorePool::CReferencedKernelSemaphore::CReferencedKernelSemaphore()
	:	CKernelSemaphore( CSyncBasicInfo( _T( "CKernelSemaphorePool::CReferencedKernelSemaphore" ) ) )
	{
	//  reset data members

	m_cReference = 0;
	m_fInUse = 0;
	m_irksemNext = irksemNil;
#ifdef DEBUG
	m_psyncobjUser = 0;
#endif  //  DEBUG
	}

//  dtor

CKernelSemaphorePool::CReferencedKernelSemaphore::~CReferencedKernelSemaphore()
	{
	}

//  init

const BOOL CKernelSemaphorePool::CReferencedKernelSemaphore::FInit()
	{
	//  reset data members

	m_cReference = 0;
	m_fInUse = 0;
	m_irksemNext = irksemNil;
#ifdef DEBUG
	m_psyncobjUser = 0;
#endif  //  DEBUG

	//  initialize the kernel semaphore
	
	return CKernelSemaphore::FInit();
	}

//  term

void CKernelSemaphorePool::CReferencedKernelSemaphore::Term()
	{
	//  terminate the kernel semaphore

	CKernelSemaphore::Term();
	
	//  reset data members

	m_cReference = 0;
	m_fInUse = 0;
	m_irksemNext = irksemNil;
#ifdef DEBUG
	m_psyncobjUser = 0;
#endif  //  DEBUG
	}


//  Global Kernel Semaphore Pool

CKernelSemaphorePool ksempoolGlobal;


//  Synchronization Object Performance:  Acquisition

//  ctor

CSyncPerfAcquire::CSyncPerfAcquire()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	m_cAcquire = 0;
	m_cContend = 0;

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  dtor

CSyncPerfAcquire::~CSyncPerfAcquire()
	{
	}


//  Semaphore

//  ctor

CSemaphore::CSemaphore( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CSemaphoreState, CSyncStateInitNull, CSyncComplexPerfInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
#ifdef SYNC_ENHANCED_STATE

	//  further init of CSyncBasicInfo

	State().SetTypeName( "CSemaphore" );
	State().SetInstance( (CSyncObject*)this );

#endif  //  SYNC_ENHANCED_STATE
	}

//  dtor

CSemaphore::~CSemaphore()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	//  dump performance data on destruction if enabled

	Dump( pcprintfPerfData );
	
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  attempts to acquire a count from the semaphore, returning fFalse if unsuccessful
//  in the time permitted.  Infinite and Test-Only timeouts are supported.

const BOOL CSemaphore::_FAcquire( const int cmsecTimeout )
	{
	//  if we spin, we will spin for the full amount recommended by the OS
	
	int cSpin = cSpinMax;

	//  we start with no kernel semaphore allocated
	
	CKernelSemaphorePool::IRKSEM irksemAlloc = CKernelSemaphorePool::irksemNil;

	//  try forever until we successfully change the state of the semaphore
	
	SYNC_FOREVER
		{
		//  read the current state of the semaphore
		
		const CSemaphoreState stateCur = (CSemaphoreState&) State();

		//  there is an available count

		if ( stateCur.FAvail() )
			{
			//  we successfully took a count
			
			if ( State().FChange( stateCur, CSemaphoreState( stateCur.CAvail() - 1 ) ) )
				{
				//  if we allocated a kernel semaphore, release it
				
				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  return success

				State().SetAcquire();
				return fTrue;
				}
			}

		//  there is no available count and we still have spins left
		
		else if ( cSpin )
			{
			//  spin once and try again
			
			cSpin--;
			continue;
			}

		//  there are no waiters and no available counts
		
		else if ( stateCur.FNoWaitAndNoAvail() )
			{
			//  allocate and reference a kernel semaphore if we haven't already
			
			if ( irksemAlloc == CKernelSemaphorePool::irksemNil )
				{
				irksemAlloc = ksempoolGlobal.Allocate( this );
				}

			//  we successfully installed ourselves as the first waiter
				
			if ( State().FChange( stateCur, CSemaphoreState( 1, irksemAlloc ) ) )
				{
				//  wait for next available count on semaphore

				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( irksemAlloc, this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
					
					ksempoolGlobal.Unreference( irksemAlloc );

					//  we successfully acquired a count

					State().SetAcquire();
					return fTrue;
					}

				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the semaphore

					SYNC_FOREVER
						{
						//  read the current state of the semaphore
						
						const CSemaphoreState stateAfterWait = (CSemaphoreState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the semaphore is not the same as the one we allocated

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != irksemAlloc )
							{
							//  the kernel semaphore we allocated is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( irksemAlloc, this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( irksemAlloc );

							//  we successfully acquired a count

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the semaphore is the same as the one we allocated

						else if ( stateAfterWait.CWait() == 1 )
							{
							Assert( stateAfterWait.FWait() );
							Assert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully changed the semaphore to have no
							//  available counts and no waiters
							
							if ( State().FChange( stateAfterWait, CSemaphoreState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully acquire a count

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the semaphore is the same as the one we allocated

						else
							{
							Assert( stateAfterWait.CWait() > 1 );
							Assert( stateAfterWait.FWait() );
							Assert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully reduced the number of waiters on the
							//  semaphore by one
							
							if ( State().FChange( stateAfterWait, CSemaphoreState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully acquire a count

								return fFalse;
								}
							}
						}
					}
				}
			}

		//  there are waiters
		
		else
			{
			Assert( stateCur.FWait() );

			//  reference the kernel semaphore already in use

			ksempoolGlobal.Reference( stateCur.Irksem() );

			//  we successfully added ourself as another waiter
			
			if ( State().FChange( stateCur, CSemaphoreState( stateCur.CWait() + 1, stateCur.Irksem() ) ) )
				{
				//  if we allocated a kernel semaphore, unreference it

				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  wait for next available count on semaphore
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( stateCur.Irksem(), this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
				
					ksempoolGlobal.Unreference( stateCur.Irksem() );

					//  we successfully acquired a count
					
					State().SetAcquire();
					return fTrue;
					}
					
				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the semaphore

					SYNC_FOREVER
						{
						//  read the current state of the semaphore
						
						const CSemaphoreState stateAfterWait = (CSemaphoreState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the semaphore is not the same as the one we waited on

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != stateCur.Irksem() )
							{
							//  the kernel semaphore we waited on is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( stateCur.Irksem() );

							//  we successfully acquired a count

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the semaphore is the same as the one we waited on

						else if ( stateAfterWait.CWait() == 1 )
							{
							Assert( stateAfterWait.FWait() );
							Assert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully changed the semaphore to have no
							//  available counts and no waiters
							
							if ( State().FChange( stateAfterWait, CSemaphoreState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully acquire a count

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the semaphore is the same as the one we waited on

						else
							{
							Assert( stateAfterWait.CWait() > 1 );
							Assert( stateAfterWait.FWait() );
							Assert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully reduced the number of waiters on the
							//  semaphore by one
							
							if ( State().FChange( stateAfterWait, CSemaphoreState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully acquire a count

								return fFalse;
								}
							}
						}
					}
				}

			//  unreference the kernel semaphore
				
			ksempoolGlobal.Unreference( stateCur.Irksem() );
			}
		}
	}

//  releases the given number of counts to the semaphore, waking the appropriate
//  number of waiters

void CSemaphore::_Release( const int cToRelease )
	{
	//  try forever until we successfully change the state of the semaphore
	
	SYNC_FOREVER
		{
		//  read the current state of the semaphore
		
		const CSemaphoreState stateCur = State();

		//  there are no waiters

		if ( stateCur.FNoWait() )
			{
			//  we successfully added the count to the semaphore
			
			if ( State().FChange( stateCur, CSemaphoreState( stateCur.CAvail() + cToRelease ) ) )
				{
				//  we're done
				
				return;
				}
			}

		//  there are waiters
		
		else
			{
			Assert( stateCur.FWait() );

			//  we are releasing more counts than waiters (or equal to)

			if ( stateCur.CWait() <= cToRelease )
				{
				//  we successfully changed the semaphore to have an available count
				//  that is equal to the specified release count minus the number of
				//  waiters to release
				
				if ( State().FChange( stateCur, CSemaphoreState( cToRelease - stateCur.CWait() ) ) )
					{
					//  release all waiters
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release( stateCur.CWait() );

					//  we're done
					
					return;
					}
				}

			//  we are releasing less counts than waiters
			
			else
				{
				Assert( stateCur.CWait() > cToRelease );

				//  we successfully reduced the number of waiters on the semaphore by
				//  the number specified
				
				if ( State().FChange( stateCur, CSemaphoreState( stateCur.CWait() - cToRelease, stateCur.Irksem() ) ) )
					{
					//  release the specified number of waiters
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release( cToRelease );

					//  we're done
					
					return;
					}
				}
			}
		}
	}


//  Auto-Reset Signal

//  ctor

CAutoResetSignal::CAutoResetSignal( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CAutoResetSignalState, CSyncStateInitNull, CSyncComplexPerfInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
#ifdef SYNC_ENHANCED_STATE

	//  further init of CSyncBasicInfo

	State().SetTypeName( "CAutoResetSignal" );
	State().SetInstance( (CSyncObject*)this );

#endif  //  SYNC_ENHANCED_STATE
	}

//  dtor

CAutoResetSignal::~CAutoResetSignal()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	//  dump performance data on destruction if enabled

	Dump( pcprintfPerfData );
	
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  waits for the signal to be set, returning fFalse if unsuccessful in the time
//  permitted.  Infinite and Test-Only timeouts are supported.

const BOOL CAutoResetSignal::_FWait( const int cmsecTimeout )
	{
	//  if we spin, we will spin for the full amount recommended by the OS
	
	int cSpin = cSpinMax;

	//  we start with no kernel semaphore allocated
	
	CKernelSemaphorePool::IRKSEM irksemAlloc = CKernelSemaphorePool::irksemNil;

	//  try forever until we successfully change the state of the signal
	
	SYNC_FOREVER
		{
		//  read the current state of the signal
		
		const CAutoResetSignalState stateCur = (CAutoResetSignalState&) State();

		//  the signal is set

		if ( stateCur.FNoWaitAndSet() )
			{
			//  we successfully changed the signal state to reset with no waiters
			
			if ( State().FChange( stateCur, CAutoResetSignalState( 0 ) ) )
				{
				//  if we allocated a kernel semaphore, release it
				
				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  return success

				State().SetAcquire();
				return fTrue;
				}
			}

		//  the signal is not set and we still have spins left
		
		else if ( cSpin )
			{
			//  spin once and try again
			
			cSpin--;
			continue;
			}

		//  the signal is not set and there are no waiters
		
		else if ( stateCur.FNoWaitAndNotSet() )
			{
			//  allocate and reference a kernel semaphore if we haven't already
			
			if ( irksemAlloc == CKernelSemaphorePool::irksemNil )
				{
				irksemAlloc = ksempoolGlobal.Allocate( this );
				}

			//  we successfully installed ourselves as the first waiter
				
			if ( State().FChange( stateCur, CAutoResetSignalState( 1, irksemAlloc ) ) )
				{
				//  wait for signal to be set
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( irksemAlloc, this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
					
					ksempoolGlobal.Unreference( irksemAlloc );

					//  we successfully waited for the signal

					State().SetAcquire();
					return fTrue;
					}

				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the signal

					SYNC_FOREVER
						{
						//  read the current state of the signal
						
						const CAutoResetSignalState stateAfterWait = (CAutoResetSignalState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the signal is not the same as the one we allocated

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != irksemAlloc )
							{
							//  the kernel semaphore we allocated is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( irksemAlloc, this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( irksemAlloc );

							//  we successfully waited for the signal

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the signal is the same as the one we allocated

						else if ( stateAfterWait.CWait() == 1 )
							{
							Assert( stateAfterWait.FWait() );
							Assert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully changed the signal to the reset with
							//  no waiters state
							
							if ( State().FChange( stateAfterWait, CAutoResetSignalState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the signal is the same as the one we allocated

						else
							{
							Assert( stateAfterWait.CWait() > 1 );
							Assert( stateAfterWait.FWait() );
							Assert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully reduced the number of waiters on the
							//  signal by one
							
							if ( State().FChange( stateAfterWait, CAutoResetSignalState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}
						}
					}
				}
			}

		//  there are waiters
		
		else
			{
			Assert( stateCur.FWait() );

			//  reference the kernel semaphore already in use

			ksempoolGlobal.Reference( stateCur.Irksem() );

			//  we successfully added ourself as another waiter
			
			if ( State().FChange( stateCur, CAutoResetSignalState( stateCur.CWait() + 1, stateCur.Irksem() ) ) )
				{
				//  if we allocated a kernel semaphore, unreference it

				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  wait for signal to be set
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( stateCur.Irksem(), this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
				
					ksempoolGlobal.Unreference( stateCur.Irksem() );

					//  we successfully waited for the signal
					
					State().SetAcquire();
					return fTrue;
					}
					
				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the signal

					SYNC_FOREVER
						{
						//  read the current state of the signal
						
						const CAutoResetSignalState stateAfterWait = (CAutoResetSignalState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the signal is not the same as the one we waited on

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != stateCur.Irksem() )
							{
							//  the kernel semaphore we waited on is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( stateCur.Irksem() );

							//  we successfully waited for the signal

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the signal is the same as the one we waited on

						else if ( stateAfterWait.CWait() == 1 )
							{
							Assert( stateAfterWait.FWait() );
							Assert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully changed the signal to the reset with
							//  no waiters state
							
							if ( State().FChange( stateAfterWait, CAutoResetSignalState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the signal is the same as the one we waited on

						else
							{
							Assert( stateAfterWait.CWait() > 1 );
							Assert( stateAfterWait.FWait() );
							Assert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully reduced the number of waiters on the
							//  signal by one
							
							if ( State().FChange( stateAfterWait, CAutoResetSignalState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}
						}
					}
				}

			//  unreference the kernel semaphore
				
			ksempoolGlobal.Unreference( stateCur.Irksem() );
			}
		}
	}

//  sets the signal, releasing up to one waiter.  if a waiter is released, then
//  the signal will be reset.  if a waiter is not released, the signal will
//  remain set

void CAutoResetSignal::_Set()
	{
	//  try forever until we successfully change the state of the signal
	
	SYNC_FOREVER
		{
		//  read the current state of the signal
		
		const CAutoResetSignalState stateCur = (CAutoResetSignalState&) State();

		//  there are no waiters

		if ( stateCur.FNoWait() )
			{
			//  we successfully changed the signal state from reset with no
			//  waiters to set or from set to set (a nop)
			
			if ( State().FSimpleSet() )
				{
				//  we're done
				
				return;
				}
			}

		//  there are waiters
		
		else
			{
			Assert( stateCur.FWait() );

			//  there is only one waiter

			if ( stateCur.CWait() == 1 )
				{
				//  we successfully changed the signal to the reset with no waiters state
				
				if ( State().FChange( stateCur, CAutoResetSignalState( 0 ) ) )
					{
					//  release the lone waiter
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release();

					//  we're done
					
					return;
					}
				}

			//  there is more than one waiter
			
			else
				{
				Assert( stateCur.CWait() > 1 );

				//  we successfully reduced the number of waiters on the signal by one
				
				if ( State().FChange( stateCur, CAutoResetSignalState( stateCur.CWait() - 1, stateCur.Irksem() ) ) )
					{
					//  release one waiter
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release();

					//  we're done
					
					return;
					}
				}
			}
		}
	}

//  resets the signal, releasing up to one waiter

void CAutoResetSignal::_Pulse()
	{
	//  try forever until we successfully change the state of the signal
	
	SYNC_FOREVER
		{
		//  read the current state of the signal
		
		const CAutoResetSignalState stateCur = (CAutoResetSignalState&) State();

		//  there are no waiters

		if ( stateCur.FNoWait() )
			{
			//  we successfully changed the signal state from set to reset with
			//  no waiters or from reset with no waiters to reset with no
			//  waiters (a nop)
			
			if ( State().FSimpleReset() )
				{
				//  we're done
				
				return;
				}
			}

		//  there are waiters
		
		else
			{
			Assert( stateCur.FWait() );

			//  there is only one waiter

			if ( stateCur.CWait() == 1 )
				{
				//  we successfully changed the signal to the reset with no waiters state
				
				if ( State().FChange( stateCur, CAutoResetSignalState( 0 ) ) )
					{
					//  release the lone waiter
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release();

					//  we're done
					
					return;
					}
				}

			//  there is more than one waiter
			
			else
				{
				Assert( stateCur.CWait() > 1 );

				//  we successfully reduced the number of waiters on the signal by one
				
				if ( State().FChange( stateCur, CAutoResetSignalState( stateCur.CWait() - 1, stateCur.Irksem() ) ) )
					{
					//  release one waiter
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release();

					//  we're done
					
					return;
					}
				}
			}
		}
	}


//  Manual-Reset Signal

//  ctor

CManualResetSignal::CManualResetSignal( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CManualResetSignalState, CSyncStateInitNull, CSyncComplexPerfInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
#ifdef SYNC_ENHANCED_STATE

	//  further init of CSyncBasicInfo

	State().SetTypeName( "CManualResetSignal" );
	State().SetInstance( (CSyncObject*)this );

#endif  //  SYNC_ENHANCED_STATE
	}

//  dtor

CManualResetSignal::~CManualResetSignal()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	//  dump performance data on destruction if enabled

	Dump( pcprintfPerfData );
	
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  waits for the signal to be set, returning fFalse if unsuccessful in the time
//  permitted.  Infinite and Test-Only timeouts are supported.

const BOOL CManualResetSignal::_FWait( const int cmsecTimeout )
	{
	//  if we spin, we will spin for the full amount recommended by the OS
	
	int cSpin = cSpinMax;

	//  we start with no kernel semaphore allocated
	
	CKernelSemaphorePool::IRKSEM irksemAlloc = CKernelSemaphorePool::irksemNil;

	//  try forever until we successfully change the state of the signal
	
	SYNC_FOREVER
		{
		//  read the current state of the signal
		
		const CManualResetSignalState stateCur = (CManualResetSignalState&) State();

		//  the signal is set

		if ( stateCur.FNoWaitAndSet() )
			{
			//  if we allocated a kernel semaphore, release it
			
			if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
				{
				ksempoolGlobal.Unreference( irksemAlloc );
				}

			//  we successfully waited for the signal

			State().SetAcquire();
			return fTrue;
			}

		//  the signal is not set and we still have spins left
		
		else if ( cSpin )
			{
			//  spin once and try again
			
			cSpin--;
			continue;
			}

		//  the signal is not set and there are no waiters
		
		else if ( stateCur.FNoWaitAndNotSet() )
			{
			//  allocate and reference a kernel semaphore if we haven't already
			
			if ( irksemAlloc == CKernelSemaphorePool::irksemNil )
				{
				irksemAlloc = ksempoolGlobal.Allocate( this );
				}

			//  we successfully installed ourselves as the first waiter
				
			if ( State().FChange( stateCur, CManualResetSignalState( 1, irksemAlloc ) ) )
				{
				//  wait for signal to be set
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( irksemAlloc, this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
					
					ksempoolGlobal.Unreference( irksemAlloc );

					//  we successfully waited for the signal

					State().SetAcquire();
					return fTrue;
					}

				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the signal

					SYNC_FOREVER
						{
						//  read the current state of the signal
						
						const CManualResetSignalState stateAfterWait = (CManualResetSignalState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the signal is not the same as the one we allocated

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != irksemAlloc )
							{
							//  the kernel semaphore we allocated is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( irksemAlloc, this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( irksemAlloc );

							//  we successfully waited for the signal

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the signal is the same as the one we allocated

						else if ( stateAfterWait.CWait() == 1 )
							{
							Assert( stateAfterWait.FWait() );
							Assert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully changed the signal to the reset with
							//  no waiters state
							
							if ( State().FChange( stateAfterWait, CManualResetSignalState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the signal is the same as the one we allocated

						else
							{
							Assert( stateAfterWait.CWait() > 1 );
							Assert( stateAfterWait.FWait() );
							Assert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully reduced the number of waiters on the
							//  signal by one
							
							if ( State().FChange( stateAfterWait, CManualResetSignalState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}
						}
					}
				}
			}

		//  there are waiters
		
		else
			{
			Assert( stateCur.FWait() );

			//  reference the kernel semaphore already in use

			ksempoolGlobal.Reference( stateCur.Irksem() );

			//  we successfully added ourself as another waiter
			
			if ( State().FChange( stateCur, CManualResetSignalState( stateCur.CWait() + 1, stateCur.Irksem() ) ) )
				{
				//  if we allocated a kernel semaphore, unreference it

				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  wait for signal to be set
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( stateCur.Irksem(), this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
				
					ksempoolGlobal.Unreference( stateCur.Irksem() );

					//  we successfully waited for the signal
					
					State().SetAcquire();
					return fTrue;
					}
					
				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the signal

					SYNC_FOREVER
						{
						//  read the current state of the signal
						
						const CManualResetSignalState stateAfterWait = (CManualResetSignalState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the signal is not the same as the one we waited on

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != stateCur.Irksem() )
							{
							//  the kernel semaphore we waited on is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( stateCur.Irksem() );

							//  we successfully waited for the signal

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the signal is the same as the one we waited on

						else if ( stateAfterWait.CWait() == 1 )
							{
							Assert( stateAfterWait.FWait() );
							Assert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully changed the signal to the reset with
							//  no waiters state
							
							if ( State().FChange( stateAfterWait, CManualResetSignalState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the signal is the same as the one we waited on

						else
							{
							Assert( stateAfterWait.CWait() > 1 );
							Assert( stateAfterWait.FWait() );
							Assert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully reduced the number of waiters on the
							//  signal by one
							
							if ( State().FChange( stateAfterWait, CManualResetSignalState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}
						}
					}
				}

			//  unreference the kernel semaphore
				
			ksempoolGlobal.Unreference( stateCur.Irksem() );
			}
		}
	}


//  Lock Object Basic Information

//  ctor

CLockBasicInfo::CLockBasicInfo( const CSyncBasicInfo& sbi, const int rank, const int subrank )
	:	CSyncBasicInfo( sbi )
	{
#ifdef SYNC_DEADLOCK_DETECTION

	m_rank			= rank;
	m_subrank		= subrank;

#endif  //  SYNC_DEADLOCK_DETECTION
	}

//  dtor

CLockBasicInfo::~CLockBasicInfo()
	{
	}
	

//  Lock Object Performance:  Hold

//  ctor

CLockPerfHold::CLockPerfHold()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	m_cHold = 0;
	m_qwHRTHoldElapsed = 0;

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  dtor

CLockPerfHold::~CLockPerfHold()
	{
	}


//  Lock Owner Record

//  ctor

COwner::COwner()
	{
#ifdef SYNC_DEADLOCK_DETECTION

	m_pclsOwner			= NULL;
	m_pownerContextNext	= NULL;
	m_plddiOwned		= NULL;
	m_pownerLockNext	= NULL;
	m_group				= 0;
	
#endif  //  SYNC_DEADLOCK_DETECTION
	}

//  dtor

COwner::~COwner()
	{
	}


//  Lock Object Deadlock Detection Information

//  ctor

CLockDeadlockDetectionInfo::CLockDeadlockDetectionInfo( const CLockBasicInfo& lbi )
#ifdef SYNC_DEADLOCK_DETECTION
	:	m_semOwnerList( (CSyncBasicInfo&) lbi )
#endif  //  SYNC_DEADLOCK_DETECTION
	{
#ifdef SYNC_DEADLOCK_DETECTION

	m_plbiParent = &lbi;
	m_semOwnerList.Release();

#endif  //  SYNC_DEADLOCK_DETECTION
	}

//  dtor

CLockDeadlockDetectionInfo::~CLockDeadlockDetectionInfo()
	{
	}


//  Critical Section (non-nestable) State

//  ctor

CCriticalSectionState::CCriticalSectionState( const CSyncBasicInfo& sbi )
	:	m_sem( sbi )
	{
	}

//  dtor

CCriticalSectionState::~CCriticalSectionState()
	{
	}


//  Critical Section (non-nestable)

//  ctor

CCriticalSection::CCriticalSection( const CLockBasicInfo& lbi )
	:	CEnhancedStateContainer< CCriticalSectionState, CSyncBasicInfo, CLockSimpleInfo, CLockBasicInfo >( (CSyncBasicInfo&) lbi, lbi )
	{
#ifdef SYNC_ENHANCED_STATE

	//  further init of CSyncBasicInfo

	State().SetTypeName( "CCriticalSection" );
	State().SetInstance( (CSyncObject*)this );

#endif  //  SYNC_ENHANCED_STATE
	
	//  release semaphore

	State().Semaphore().Release();
	}

//  dtor

CCriticalSection::~CCriticalSection()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	//  dump performance data on destruction if enabled

	Dump( pcprintfPerfData );
	
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}


//  Nestable Critical Section State

//  ctor

CNestableCriticalSectionState::CNestableCriticalSectionState( const CSyncBasicInfo& sbi )
	:	m_sem( sbi ),
		m_pclsOwner( 0 ),
		m_cEntry( 0 )
	{
	}

//  dtor

CNestableCriticalSectionState::~CNestableCriticalSectionState()
	{
	}


//  Nestable Critical Section

//  ctor

CNestableCriticalSection::CNestableCriticalSection( const CLockBasicInfo& lbi )
	:	CEnhancedStateContainer< CNestableCriticalSectionState, CSyncBasicInfo, CLockSimpleInfo, CLockBasicInfo >( (CSyncBasicInfo&) lbi, lbi )
	{
#ifdef SYNC_ENHANCED_STATE

	//  further init of CSyncBasicInfo

	State().SetTypeName( "CNestableCriticalSection" );
	State().SetInstance( (CSyncObject*)this );

#endif  //  SYNC_ENHANCED_STATE
	
	//  release semaphore

	State().Semaphore().Release();
	}

//  dtor

CNestableCriticalSection::~CNestableCriticalSection()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	//  dump performance data on destruction if enabled

	Dump( pcprintfPerfData );
	
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}


//  Gate State

//  ctor

CGateState::CGateState( const int cWait, const int irksem )
	{
	//  validate IN args
	
	Assert( cWait >= 0 );
	Assert( cWait <= 0x7FFF );
	Assert( irksem >= 0 );
	Assert( irksem <= 0xFFFE );

	//  set waiter count
	
	m_cWait = (unsigned short) cWait;

	//  set semaphore
	
	m_irksem = (unsigned short) irksem;
	}


//  Gate

//  ctor

CGate::CGate( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CGateState, CSyncStateInitNull, CSyncSimplePerfInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
#ifdef SYNC_ENHANCED_STATE

	//  further init of CSyncBasicInfo

	State().SetTypeName( "CGate" );
	State().SetInstance( (CSyncObject*)this );

#endif  //  SYNC_ENHANCED_STATE
	}

//  dtor

CGate::~CGate()
	{
	//  no one should be waiting

	Assert( State().CWait() == 0 );
	Assert( State().Irksem() == CKernelSemaphorePool::irksemNil );

#ifdef SYNC_ANALYZE_PERFORMANCE

	//  dump performance data on destruction if enabled

	Dump( pcprintfPerfData );
	
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  waits forever on the gate until released by someone else.  this function
//  expects to be called while in the specified critical section.  when the
//  function returns, the caller will NOT be in the critical section

void CGate::Wait( CCriticalSection& crit )
	{
	//  we must be in the specified critical section

	Assert( crit.FOwner() );

	//  there can not be too many waiters on the gate

	Assert( State().CWait() < 0x7FFF );
	
	//  add ourselves as a waiter

	const int cWait = State().CWait() + 1;
	State().SetWaitCount( cWait );

	//  we are the first waiter

	CKernelSemaphorePool::IRKSEM irksem;
#ifdef DEBUG
	irksem = CKernelSemaphorePool::irksemNil;
#endif  //  DEBUG
	if ( cWait == 1 )
		{
		//  allocate a semaphore for the gate and remember it before leaving
		//  the critical section

		Assert( State().Irksem() == CKernelSemaphorePool::irksemNil );
		irksem = ksempoolGlobal.Allocate( this );
		State().SetIrksem( irksem );
		}

	//  we are not the first waiter

	else
		{
		//  reference the semaphore already in the gate and remember it before
		//  leaving the critical section

		Assert( State().Irksem() != CKernelSemaphorePool::irksemNil );
		irksem = State().Irksem();
		ksempoolGlobal.Reference( irksem );
		}
	Assert( irksem != CKernelSemaphorePool::irksemNil );

	//  leave critical section, never to return

	crit.Leave();

	//  wait to be released

	State().StartWait();
	ksempoolGlobal.Ksem( irksem, this ).Acquire();
	State().StopWait();

	//  unreference the semaphore

	ksempoolGlobal.Unreference( irksem );
	}

//  releases the specified number of waiters from the gate.  this function
//  expects to be called while in the specified critical section.  when the
//  function returns, the caller will NOT be in the critical section
//
//  NOTE:  it is illegal to release more waiters than are waiting on the gate
//         and it is also illegal to release less than one waiter

void CGate::Release( CCriticalSection& crit, const int cToRelease )
	{
	//  we must be in the specified critical section

	Assert( crit.FOwner() );

	//  you must release at least one waiter

	Assert( cToRelease > 0 );
	
	//  we cannot release more waiters than are waiting on the gate

	Assert( cToRelease <= State().CWait() );

	//  reduce the waiter count

	State().SetWaitCount( State().CWait() - cToRelease );

	//  remember semaphore to release before leaving the critical section

	const CKernelSemaphorePool::IRKSEM irksem = State().Irksem();

#ifdef DEBUG

	//  we released all the waiters

	if ( State().CWait() == 0 )
		{
		//  set the semaphore to nil

		State().SetIrksem( CKernelSemaphorePool::irksemNil );
		}

#endif  //  DEBUG

	//  leave critical section, never to return

	crit.Leave();

	//  release the specified number of waiters

	ksempoolGlobal.Ksem( irksem, this ).Release( cToRelease );
	}

//  releases the specified number of waiters from the gate.  this function
//  expects to be called while in the specified critical section.  it is
//  guaranteed that the caller will remain in the critical section at all times
//
//  NOTE:  it is illegal to release more waiters than are waiting on the gate
//         and it is also illegal to release less than one waiter

void CGate::ReleaseAndHold( CCriticalSection& crit, const int cToRelease )
	{
	//  we must be in the specified critical section

	Assert( crit.FOwner() );

	//  you must release at least one waiter

	Assert( cToRelease > 0 );
	
	//  we cannot release more waiters than are waiting on the gate

	Assert( cToRelease <= State().CWait() );

	//  reduce the waiter count

	State().SetWaitCount( State().CWait() - cToRelease );

	//  remember semaphore to release before leaving the critical section

	const CKernelSemaphorePool::IRKSEM irksem = State().Irksem();

#ifdef DEBUG

	//  we released all the waiters

	if ( State().CWait() == 0 )
		{
		//  set the semaphore to nil

		State().SetIrksem( CKernelSemaphorePool::irksemNil );
		}

#endif  //  DEBUG

	//  release the specified number of waiters

	ksempoolGlobal.Ksem( irksem, this ).Release( cToRelease );
	}


//  Null Lock Object State Initializer

CLockStateInitNull lockstateNull;


//  Binary Lock State

//  ctor

CBinaryLockState::CBinaryLockState( const CSyncBasicInfo& sbi )
	:	m_cw( 0 ),
		m_cOwner( 0 ),
		m_sem1( sbi ),
		m_sem2( sbi )
	{
	}

//  dtor

CBinaryLockState::~CBinaryLockState()
	{
	}


//  Binary Lock

//  ctor

CBinaryLock::CBinaryLock( const CLockBasicInfo& lbi )
	:	CEnhancedStateContainer< CBinaryLockState, CSyncBasicInfo, CGroupLockComplexInfo< 2 >, CLockBasicInfo >( (CSyncBasicInfo&) lbi, lbi )
	{
#ifdef SYNC_ENHANCED_STATE

	//  further init of CSyncBasicInfo

	State().SetTypeName( "CBinaryLock" );
	State().SetInstance( (CSyncObject*)this );

#endif  //  SYNC_ENHANCED_STATE
	}

//  dtor
	
CBinaryLock::~CBinaryLock()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	//  dump performance data on destruction if enabled

	Dump( pcprintfPerfData );
	
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  maps an arbitrary combination of zero and non-zero components into a
//  valid state number of the invalid state number (-1)

const int mpindexstate[16] =
	{
	 0, -1, -1, -1,
	-1, -1,  1, -1,
	-1,  2, -1,  3,
	-1, -1,  4,  5,
	};

//  returns the state number of the specified control word or -1 if it is not
//  a legal state

int CBinaryLock::_StateFromControlWord( const ControlWord cw )
	{
	//  convert the control word into a state index

	int index = 0;
	index = index | ( ( cw & 0x80000000 ) ? 8 : 0 );
	index = index | ( ( cw & 0x7FFF0000 ) ? 4 : 0 );
	index = index | ( ( cw & 0x00008000 ) ? 2 : 0 );
	index = index | ( ( cw & 0x00007FFF ) ? 1 : 0 );

	//  convert the state index into a state number

	const int state = mpindexstate[index];

	//  return the computed state number

	return state;
	}

//  state transition reachability matrix (starting state is the major axis)
//
//  each entry contains bits representing valid reasons for making the
//  transition (made by oring together the valid TransitionReasons)

#define NO	CBinaryLock::trIllegal
#define E1	CBinaryLock::trEnter1
#define L1	CBinaryLock::trLeave1
#define E2	CBinaryLock::trEnter2
#define L2	CBinaryLock::trLeave2

const DWORD mpstatestatetrmask[6][6] =
	{
		{ NO, E2, E1, NO, NO, NO, },
		{ L2, E2 | L2, NO, E1, NO, NO, },
		{ L1, NO, E1 | L1, NO, E2, NO, },
		{ NO, NO, L2, E1 | L2, NO, E2, },
		{ NO, L1, NO, NO, L1 | E2, E1, },
		{ NO, NO, NO, L1, L2, E1 | L1 | E2 | L2, },
	};

#undef NO
#undef E1
#undef L1
#undef E2
#undef L2

//  returns fTrue if the specified control word is in a legal state

BOOL CBinaryLock::_FValidStateTransition( const ControlWord cwBI, const ControlWord cwAI, const TransitionReason tr )
	{
	//  convert the specified control words into state numbers

	const int stateBI = _StateFromControlWord( cwBI );
	const int stateAI = _StateFromControlWord( cwAI );

	//  if either state is invalid, the transition is invalid

	if ( stateBI < 0 || stateAI < 0 )
		{
		return fFalse;
		}

	//  verify that cOOW2 and cOOW1 only change by +1, 0, -1, or go to 0

	const long dcOOW2 = ( ( cwAI & 0x7FFF0000 ) >> 16 ) - ( ( cwBI & 0x7FFF0000 ) >> 16 );
	if ( ( dcOOW2 < -1 || dcOOW2 > 1 ) && ( cwAI & 0x7FFF0000 ) != 0 )
		{
		return fFalse;
		}

	const long dcOOW1 = ( cwAI & 0x00007FFF ) - ( cwBI & 0x00007FFF );
	if ( ( dcOOW1 < -1 || dcOOW1 > 1 ) && ( cwAI & 0x00007FFF ) != 0 )
		{
		return fFalse;
		}

	//  return the reachability of stateAI from stateBI

	Assert( tr == trEnter1 || tr == trLeave1 || tr == trEnter2 || tr == trLeave2 );
	return ( mpstatestatetrmask[stateBI][stateAI] & tr ) != 0;
	}

//  wait for ownership of the lock as a member of Group 1

void CBinaryLock::_Enter1( const ControlWord cwBIOld )
	{
	//  we just jumped from state 1 to state 3

	if ( ( cwBIOld & 0x80008000 ) == 0x00008000 )
		{
		//  update the quiesced owner count with the owner count that we displaced from
		//  the control word, possibly releasing waiters.  we update the count as if we
		//  were a member of Group 2 as members of Group 1 can be released

		_UpdateQuiescedOwnerCountAsGroup2( ( cwBIOld & 0x7FFF0000 ) >> 16 );
		}

	//  wait for ownership of the lock on our semaphore

	State().StartWait( 0 );
	State().m_sem1.Acquire();
	State().StopWait( 0 );
	}

//  wait for ownership of the lock as a member of Group 2

void CBinaryLock::_Enter2( const ControlWord cwBIOld )
	{
	//  we just jumped from state 2 to state 4

	if ( ( cwBIOld & 0x80008000 ) == 0x80000000 )
		{
		//  update the quiesced owner count with the owner count that we displaced from
		//  the control word, possibly releasing waiters.  we update the count as if we
		//  were a member of Group 1 as members of Group 2 can be released

		_UpdateQuiescedOwnerCountAsGroup1( cwBIOld & 0x00007FFF );
		}

	//  wait for ownership of the lock on our semaphore

	State().StartWait( 1 );
	State().m_sem2.Acquire();
	State().StopWait( 1 );
	}

//  updates the quiesced owner count as a member of Group 1

void CBinaryLock::_UpdateQuiescedOwnerCountAsGroup1( const DWORD cOwnerDelta )
	{
	//  update the quiesced owner count using the provided delta

	const DWORD cOwnerBI = AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
	const DWORD cOwnerAI = cOwnerBI + cOwnerDelta;

	//  our update resulted in a zero quiesced owner count

	if ( !cOwnerAI )
		{
		//  we must release the waiters for Group 2 because we removed the last
		//  quiesced owner count

		//  try forever until we successfully change the lock state

		ControlWord cwBI;
		SYNC_FOREVER
			{
			//  read the current state of the control word as our expected before image

			const ControlWord cwBIExpected = State().m_cw;

			//  compute the after image of the control word such that we jump from state
			//  state 4 to state 1 or from state 5 to state 3, whichever is appropriate

			const ControlWord cwAI =	cwBIExpected &
										( ( ( long( ( cwBIExpected + 0xFFFF7FFF ) << 16 ) >> 15 ) &
										0xFFFF0000 ) ^ 0x8000FFFF );

			//  validate the transaction

			Assert( _FValidStateTransition( cwBIExpected, cwAI, trLeave1 ) );

			//  attempt to perform the transacted state transition on the control word

			cwBI = AtomicCompareExchange( (long*)&State().m_cw, cwBIExpected, cwAI );

			//  the transaction failed because another context changed the control word

			if ( cwBI != cwBIExpected )
				{
				//  try again

				continue;
				}

			//  the transaction succeeded

			else
				{
				//  we're done

				break;
				}
			}

		//  we just jumped from state 5 to state 3

		if ( cwBI & 0x00007FFF )
			{
			//  update the quiesced owner count with the owner count that we displaced
			//  from the control word
			//
			//  NOTE:  we do not have to worry about releasing any more waiters because
			//  either this context owns one of the owner counts or at least one context
			//  that owns an owner count are currently blocked on the semaphore

			const DWORD cOwnerDelta = ( cwBI & 0x7FFF0000 ) >> 16;
			AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
			}

		//  release the waiters for Group 2 that we removed from the lock state

		State().m_sem2.Release( ( cwBI & 0x7FFF0000 ) >> 16 );
		}
	}

//  updates the quiesced owner count as a member of Group 2

void CBinaryLock::_UpdateQuiescedOwnerCountAsGroup2( const DWORD cOwnerDelta )
	{
	//  update the quiesced owner count using the provided delta

	const DWORD cOwnerBI = AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
	const DWORD cOwnerAI = cOwnerBI + cOwnerDelta;

	//  our update resulted in a zero quiesced owner count

	if ( !cOwnerAI )
		{
		//  we must release the waiters for Group 1 because we removed the last
		//  quiesced owner count

		//  try forever until we successfully change the lock state

		ControlWord cwBI;
		SYNC_FOREVER
			{
			//  read the current state of the control word as our expected before image

			const ControlWord cwBIExpected = State().m_cw;

			//  compute the after image of the control word such that we jump from state
			//  state 3 to state 2 or from state 5 to state 4, whichever is appropriate

			const ControlWord cwAI =	cwBIExpected &
										( ( ( long( cwBIExpected + 0x7FFF0000 ) >> 31 ) &
										0x0000FFFF ) ^ 0xFFFF8000 );

			//  validate the transaction

			Assert( _FValidStateTransition( cwBIExpected, cwAI, trLeave2 ) );

			//  attempt to perform the transacted state transition on the control word

			cwBI = AtomicCompareExchange( (long*)&State().m_cw, cwBIExpected, cwAI );

			//  the transaction failed because another context changed the control word

			if ( cwBI != cwBIExpected )
				{
				//  try again

				continue;
				}

			//  the transaction succeeded

			else
				{
				//  we're done

				break;
				}
			}

		//  we just jumped from state 5 to state 4

		if ( cwBI & 0x7FFF0000 )
			{
			//  update the quiesced owner count with the owner count that we displaced
			//  from the control word
			//
			//  NOTE:  we do not have to worry about releasing any more waiters because
			//  either this context owns one of the owner counts or at least one context
			//  that owns an owner count are currently blocked on the semaphore

			const DWORD cOwnerDelta = cwBI & 0x00007FFF;
			AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
			}

		//  release the waiters for Group 1 that we removed from the lock state

		State().m_sem1.Release( cwBI & 0x00007FFF );
		}
	}


//  Reader / Writer Lock State

//  ctor

CReaderWriterLockState::CReaderWriterLockState( const CSyncBasicInfo& sbi )
	:	m_cw( 0 ),
		m_cOwner( 0 ),
		m_semWriter( sbi ),
		m_semReader( sbi )
	{
	}

//  dtor

CReaderWriterLockState::~CReaderWriterLockState()
	{
	}


//  Reader / Writer Lock


//  ctor

CReaderWriterLock::CReaderWriterLock( const CLockBasicInfo& lbi )
	:	CEnhancedStateContainer< CReaderWriterLockState, CSyncBasicInfo, CGroupLockComplexInfo< 2 >, CLockBasicInfo >( (CSyncBasicInfo&) lbi, lbi )
	{
#ifdef SYNC_ENHANCED_STATE

	//  further init of CSyncBasicInfo

	State().SetTypeName( "CReaderWriterLock" );
	State().SetInstance( (CSyncObject*)this );

#endif  //  SYNC_ENHANCED_STATE
	}

//  dtor
	
CReaderWriterLock::~CReaderWriterLock()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	//  dump performance data on destruction if enabled

	Dump( pcprintfPerfData );
	
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  maps an arbitrary combination of zero and non-zero components into a
//  valid state number of the invalid state number (-1)

const int mpindexstateRW[16] =
	{
	 0, -1, -1, -1,
	-1, -1,  1, -1,
	-1,  2, -1,  3,
	-1, -1,  4,  5,
	};

//  returns the state number of the specified control word or -1 if it is not
//  a legal state

int CReaderWriterLock::_StateFromControlWord( const ControlWord cw )
	{
	//  convert the control word into a state index

	int index = 0;
	index = index | ( ( cw & 0x80000000 ) ? 8 : 0 );
	index = index | ( ( cw & 0x7FFF0000 ) ? 4 : 0 );
	index = index | ( ( cw & 0x00008000 ) ? 2 : 0 );
	index = index | ( ( cw & 0x00007FFF ) ? 1 : 0 );

	//  convert the state index into a state number

	const int state = mpindexstateRW[index];

	//  return the computed state number

	return state;
	}

//  state transition reachability matrix (starting state is the major axis)
//
//  each entry contains bits representing valid reasons for making the
//  transition (made by oring together the valid TransitionReasons)

#define NO	CReaderWriterLock::trIllegal
#define EW	CReaderWriterLock::trEnterAsWriter
#define LW	CReaderWriterLock::trLeaveAsWriter
#define ER	CReaderWriterLock::trEnterAsReader
#define LR	CReaderWriterLock::trLeaveAsReader

const DWORD mpstatestatetrmaskRW[6][6] =
	{
		{ NO, ER, EW, NO, NO, NO, },
		{ LR, ER | LR, NO, EW, NO, NO, },
		{ LW, NO, EW | LW, NO, ER, ER, },
		{ NO, NO, LR, EW | LR, NO, ER, },
		{ NO, LW, NO, NO, ER, EW, },
		{ NO, NO, NO, LW, LR, EW | ER | LR, },
	};

#undef NO
#undef EW
#undef LW
#undef ER
#undef LR

//  returns fTrue if the specified control word is in a legal state

BOOL CReaderWriterLock::_FValidStateTransition( const ControlWord cwBI, const ControlWord cwAI, const TransitionReason tr )
	{
	//  convert the specified control words into state numbers

	const int stateBI = _StateFromControlWord( cwBI );
	const int stateAI = _StateFromControlWord( cwAI );

	//  if either state is invalid, the transition is invalid

	if ( stateBI < 0 || stateAI < 0 )
		{
		return fFalse;
		}

	//  verify that cOOW2 and cOOW1 only change by +1, 0, -1, or cOOW2 can go to 0

	const long dcOOW2 = ( ( cwAI & 0x7FFF0000 ) >> 16 ) - ( ( cwBI & 0x7FFF0000 ) >> 16 );
	if ( ( dcOOW2 < -1 || dcOOW2 > 1 ) && ( cwAI & 0x7FFF0000 ) != 0 )
		{
		return fFalse;
		}

	const long dcOOW1 = ( cwAI & 0x00007FFF ) - ( cwBI & 0x00007FFF );
	if ( dcOOW1 < -1 || dcOOW1 > 1 )
		{
		return fFalse;
		}

	//  return the reachability of stateAI from stateBI

	Assert(	tr == trEnterAsWriter ||
			tr == trLeaveAsWriter ||
			tr == trEnterAsReader ||
			tr == trLeaveAsReader );
	return ( mpstatestatetrmaskRW[stateBI][stateAI] & tr ) != 0;
	}

//  wait for ownership of the lock as a writer

void CReaderWriterLock::_EnterAsWriter( const ControlWord cwBIOld )
	{
	//  we just jumped from state 1 to state 3

	if ( ( cwBIOld & 0x80008000 ) == 0x00008000 )
		{
		//  update the quiesced owner count with the owner count that we displaced from
		//  the control word, possibly releasing a waiter.  we update the count as if we
		//  were a reader as a writer can be released

		_UpdateQuiescedOwnerCountAsReader( ( cwBIOld & 0x7FFF0000 ) >> 16 );
		}

	//  wait for ownership of the lock on our semaphore

	State().StartWait( 0 );
	State().m_semWriter.Acquire();
	State().StopWait( 0 );
	}

//  wait for ownership of the lock as a reader

void CReaderWriterLock::_EnterAsReader( const ControlWord cwBIOld )
	{
	//  we just jumped from state 2 to state 4 or from state 2 to state 5

	if ( ( cwBIOld & 0x80008000 ) == 0x80000000 )
		{
		//  update the quiesced owner count with the owner count that we displaced from
		//  the control word, possibly releasing waiters.  we update the count as if we
		//  were a writer as readers can be released

		_UpdateQuiescedOwnerCountAsWriter( 0x00000001 );
		}

	//  wait for ownership of the lock on our semaphore

	State().StartWait( 1 );
	State().m_semReader.Acquire();
	State().StopWait( 1 );
	}

//  updates the quiesced owner count as a writer

void CReaderWriterLock::_UpdateQuiescedOwnerCountAsWriter( const DWORD cOwnerDelta )
	{
	//  update the quiesced owner count using the provided delta

	const DWORD cOwnerBI = AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
	const DWORD cOwnerAI = cOwnerBI + cOwnerDelta;

	//  our update resulted in a zero quiesced owner count

	if ( !cOwnerAI )
		{
		//  we must release the waiting readers because we removed the last
		//  quiesced owner count

		//  try forever until we successfully change the lock state

		ControlWord cwBI;
		SYNC_FOREVER
			{
			//  read the current state of the control word as our expected before image

			const ControlWord cwBIExpected = State().m_cw;

			//  compute the after image of the control word such that we jump from state
			//  state 4 to state 1 or from state 5 to state 3, whichever is appropriate

			const ControlWord cwAI =	cwBIExpected &
										( ( ( long( ( cwBIExpected + 0xFFFF7FFF ) << 16 ) >> 15 ) &
										0xFFFF0000 ) ^ 0x8000FFFF );

			//  validate the transaction

			Assert( _FValidStateTransition( cwBIExpected, cwAI, trLeaveAsWriter ) );

			//  attempt to perform the transacted state transition on the control word

			cwBI = AtomicCompareExchange( (long*)&State().m_cw, cwBIExpected, cwAI );

			//  the transaction failed because another context changed the control word

			if ( cwBI != cwBIExpected )
				{
				//  try again

				continue;
				}

			//  the transaction succeeded

			else
				{
				//  we're done

				break;
				}
			}

		//  we just jumped from state 5 to state 3

		if ( cwBI & 0x00007FFF )
			{
			//  update the quiesced owner count with the owner count that we displaced
			//  from the control word
			//
			//  NOTE:  we do not have to worry about releasing any more waiters because
			//  either this context owns one of the owner counts or at least one context
			//  that owns an owner count are currently blocked on the semaphore

			const DWORD cOwnerDelta = ( cwBI & 0x7FFF0000 ) >> 16;
			AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
			}

		//  release the waiting readers that we removed from the lock state

		State().m_semReader.Release( ( cwBI & 0x7FFF0000 ) >> 16 );
		}
	}

//  updates the quiesced owner count as a reader

void CReaderWriterLock::_UpdateQuiescedOwnerCountAsReader( const DWORD cOwnerDelta )
	{
	//  update the quiesced owner count using the provided delta

	const DWORD cOwnerBI = AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
	const DWORD cOwnerAI = cOwnerBI + cOwnerDelta;

	//  our update resulted in a zero quiesced owner count

	if ( !cOwnerAI )
		{
		//  we must release a waiting writer because we removed the last
		//  quiesced owner count

		//  try forever until we successfully change the lock state

		ControlWord cwBI;
		SYNC_FOREVER
			{
			//  read the current state of the control word as our expected before image

			const ControlWord cwBIExpected = State().m_cw;

			//  compute the after image of the control word such that we jump from state
			//  state 3 to state 2, from state 5 to state 4, or from state 5 to state 5,
			//  whichever is appropriate

			const ControlWord cwAI =	cwBIExpected + ( ( cwBIExpected & 0x7FFF0000 ) ?
											0xFFFFFFFF :
											0xFFFF8000 );

			//  validate the transaction

			Assert( _FValidStateTransition( cwBIExpected, cwAI, trLeaveAsReader ) );

			//  attempt to perform the transacted state transition on the control word

			cwBI = AtomicCompareExchange( (long*)&State().m_cw, cwBIExpected, cwAI );

			//  the transaction failed because another context changed the control word

			if ( cwBI != cwBIExpected )
				{
				//  try again

				continue;
				}

			//  the transaction succeeded

			else
				{
				//  we're done

				break;
				}
			}

		//  we just jumped from state 5 to state 4 or from state 5 to state 5

		if ( cwBI & 0x7FFF0000 )
			{
			//  update the quiesced owner count with the owner count that we displaced
			//  from the control word
			//
			//  NOTE:  we do not have to worry about releasing any more waiters because
			//  either this context owns one of the owner counts or at least one context
			//  that owns an owner count are currently blocked on the semaphore

			AtomicExchangeAdd( (long*)&State().m_cOwner, 1 );
			}

		//  release the waiting writer that we removed from the lock state

		State().m_semWriter.Release();
		}
	}


//////////////////////////////////////////////////
//  Everything below this line is OS dependent


//  Global Synchronization Constants

//    wait time used for testing the state of the kernel object

const int cmsecTest = 0;

//    wait time used for infinite wait on a kernel object

const int cmsecInfinite = INFINITE;

//    maximum wait time on a kernel object before a deadlock is suspected

const int cmsecDeadlock = 600000;

//    wait time used for infinite wait on a kernel object without deadlock

const int cmsecInfiniteNoDeadlock = INFINITE - 1;


//  Page Memory Allocation

//  reserves and commits a range of virtual addresses of the specifed size,
//  returning NULL if there is insufficient address space or backing store to
//  satisfy the request.  Note that the page reserve granularity applies to
//  this range

void* PvPageAlloc( const size_t cbSize, void* const pv )
	{
	//  allocate address space and backing store of the specified size

	void* const pvRet = VirtualAlloc( pv, cbSize, MEM_COMMIT, PAGE_READWRITE );
	if ( !pvRet )
		{
		return pvRet;
		}
	Assert( !pv || pvRet == pv );

	return pvRet;
	}

//  free the reserved range of virtual addresses starting at the specified
//  address, freeing any backing store committed to this range

void PageFree( void* const pv )
	{
	if ( pv )
		{
		//  free backing store and address space for the specified range

		BOOL fMemFreed = VirtualFree( pv, 0, MEM_RELEASE );
		Assert( fMemFreed );
		}
	}


//  Context Local Storage

//  Global CLS List

CRITICAL_SECTION csClsSyncGlobal;
CLS* pclsSyncGlobal;

//  Allocated CLS Entry

DWORD dwClsSyncIndex;

//  registers the given CLS structure as the CLS for this context

void OSSyncIClsRegister( CLS* pcls )
	{
	//  we are the first to register CLS

	EnterCriticalSection( &csClsSyncGlobal );
	if ( pclsSyncGlobal == NULL )
		{
		//  allocate a new CLS entry
		
		dwClsSyncIndex = TlsAlloc();
		Assert( dwClsSyncIndex != 0xFFFFFFFF );
		}

	//  save the pointer to the given CLS

	BOOL fTLSPointerSet = TlsSetValue( dwClsSyncIndex, pcls );
	Assert( fTLSPointerSet );

	//  add this CLS into the global list

	pcls->pclsNext = pclsSyncGlobal;
	if ( pcls->pclsNext )
		{
		pcls->pclsNext->ppclsNext = &pcls->pclsNext;
		}
	pcls->ppclsNext = &pclsSyncGlobal;
	pclsSyncGlobal = pcls;
	LeaveCriticalSection( &csClsSyncGlobal );
	}

//  unregisters the given CLS structure as the CLS for this context

void OSSyncIClsUnregister( CLS* pcls )
	{
	//  there should be CLSs registered

	EnterCriticalSection( &csClsSyncGlobal );
	Assert( pclsSyncGlobal != NULL );
	
	//  remove our CLS from the global CLS list
	
	if( pcls->pclsNext )
		{
		pcls->pclsNext->ppclsNext = pcls->ppclsNext;
		}
	*( pcls->ppclsNext ) = pcls->pclsNext;

	//  we are the last to unregister our CLS

	if ( pclsSyncGlobal == NULL )
		{
		//  deallocate CLS entry

		BOOL fTLSFreed = TlsFree( dwClsSyncIndex );
		Assert( fTLSFreed );
		}
	LeaveCriticalSection( &csClsSyncGlobal );
	}
	
//  attaches to the current context, returning fFalse on failure

const BOOL FOSSyncAttach()
	{
	//  allocate memory for this context's CLS

	CLS* const pcls = (CLS*) GlobalAlloc( GMEM_ZEROINIT, sizeof( CLS ) );
	if ( !pcls )
		{
		return fFalse;
		}

	//  initialize internal CLS fields

	pcls->dwContextId = GetCurrentThreadId();

	//  register our CLS

	OSSyncIClsRegister( pcls );

	return fTrue;
	}

//  returns the pointer to the current context's local storage.  if the context
//  does not yet have CLS, allocate it.  this can happen if the context was
//  created before the subsystem was initialized

CLS* const Pcls()
	{
	CLS* pcls = reinterpret_cast<CLS *>( TlsGetValue( dwClsSyncIndex ) );
	if ( !pcls )
		{
		while ( !FOSSyncAttach() )
			{
			Sleep( 1000 );
			}
		pcls = reinterpret_cast<CLS *>( TlsGetValue( dwClsSyncIndex ) );
		}
	return pcls;
	}


//  High Resolution Timer

//    QWORDX - used for 32 bit access to a 64 bit integer

union QWORDX
	{
	QWORD	qw;
	struct
		{
		DWORD l;
		DWORD h;
		};
	};

//    High Resolution Timer Type

enum HRTType
	{
	hrttNone,
	hrttWin32,
#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )
	hrttPentium,
#endif  //  _M_IX86 && SYNC_USE_X86_ASM
	} hrttSync;

//    HRT Frequency

QWORD qwSyncHRTFreq;

#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )

//    Pentium Time Stamp Counter Fetch

#define rdtsc __asm _emit 0x0f __asm _emit 0x31

#endif  //  _MM_IX86 && SYNC_USE_X86_ASM

//  initializes the HRT subsystem

void OSTimeHRTInit()
	{
	//  if we have already been initialized, we're done

	if ( qwSyncHRTFreq )
		{
		return;
		}

#ifdef _M_ALPHA
#else  //  !_M_ALPHA

	//  Win32 high resolution counter is available

	if ( QueryPerformanceFrequency( (LARGE_INTEGER *) &qwSyncHRTFreq ) )
		{
		hrttSync = hrttWin32;
		}

	//  Win32 high resolution counter is not available
	
	else
	
#endif  //  _M_ALPHA

		{
		//  fall back on GetTickCount() (ms since Windows has started)
		
		QWORDX qwx;
		qwx.l = 1000;
		qwx.h = 0;
		qwSyncHRTFreq = qwx.qw;

		hrttSync = hrttNone;
		}

#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )

	//  this is a Pentium or compatible CPU
	
	SYSTEM_INFO siSystemConfig;
	GetSystemInfo( &siSystemConfig );
	if (	siSystemConfig.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL &&
			siSystemConfig.wProcessorLevel >= 5 )
		{
		//  use pentium TSC register, but first find clock frequency experimentally
		
		QWORDX qwxTime1a;
		QWORDX qwxTime1b;
		QWORDX qwxTime2a;
		QWORDX qwxTime2b;
		if ( hrttSync == hrttWin32 )
			{
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime1a.l,eax	//lint !e530
			__asm mov		qwxTime1a.h,edx	//lint !e530
			QueryPerformanceCounter( (LARGE_INTEGER*) &qwxTime1b.qw );
			Sleep( 50 );
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime2a.l,eax	//lint !e530
			__asm mov		qwxTime2a.h,edx	//lint !e530
			QueryPerformanceCounter( (LARGE_INTEGER*) &qwxTime2b.qw );
			qwSyncHRTFreq =	( qwSyncHRTFreq * ( qwxTime2a.qw - qwxTime1a.qw ) ) /
						( qwxTime2b.qw - qwxTime1b.qw );
			qwSyncHRTFreq = ( ( qwSyncHRTFreq + 50000 ) / 100000 ) * 100000;
			}
		else
			{
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime1a.l,eax
			__asm mov		qwxTime1a.h,edx
			qwxTime1b.l = GetTickCount();
			qwxTime1b.h = 0;
			Sleep( 2000 );
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime2a.l,eax
			__asm mov		qwxTime2a.h,edx
			qwxTime2b.l = GetTickCount();
			qwxTime2b.h = 0;
			qwSyncHRTFreq =	( qwSyncHRTFreq * ( qwxTime2a.qw - qwxTime1a.qw ) ) /
						( qwxTime2b.qw - qwxTime1b.qw );
			qwSyncHRTFreq = ( ( qwSyncHRTFreq + 500000 ) / 1000000 ) * 1000000;
			}

		hrttSync = hrttPentium;
		}
		
#endif  //  _M_IX86 && SYNC_USE_X86_ASM

	}

//  returns the current HRT frequency

QWORD QwOSTimeHRTFreq()
	{
	return qwSyncHRTFreq;
	}

//  returns the current HRT count

QWORD QwOSTimeHRTCount()
	{
	QWORDX qwx;

	switch ( hrttSync )
		{
		case hrttNone:
			qwx.l = GetTickCount();
			qwx.h = 0;
			break;

		case hrttWin32:
			QueryPerformanceCounter( (LARGE_INTEGER*) &qwx.qw );
			break;

#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )

		case hrttPentium:
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwx.l,eax
			__asm mov		qwx.h,edx
			break;
			
#endif  //  _M_IX86 && SYNC_USE_X86_ASM

		}

	return qwx.qw;
	}


//  Atomic Memory Manipulations

#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )
#elif ( defined( _M_MRX000 ) || defined( _M_ALPHA ) || ( defined( _M_PPC ) && ( _MSC_VER >= 1000 ) ) )
#else

//  returns fTrue if the given data is properly aligned for atomic modification

const BOOL IsAtomicallyModifiable( long* plTarget )
	{
	return long( plTarget ) % sizeof( long ) == 0;
	}

//  atomically compares the current value of the target with the specified
//  initial value and if equal sets the target to the specified final value.
//  the initial value of the target is returned.  the exchange is successful
//  if the value returned equals the specified initial value.  the target
//  must be aligned to a four byte boundary

const long AtomicCompareExchange( long* plTarget, const long lInitial, const long lFinal )
	{
	Assert( IsAtomicallyModifiable( plTarget ) );
	return long( InterlockedCompareExchange( (void**) plTarget, (void*) lFinal, (void*) lInitial ) );
	}

//  atomically sets the target to the specified value, returning the target's
//  initial value.  the target must be aligned to a four byte boundary

const long AtomicExchange( long* plTarget, const long lValue )
	{
	Assert( IsAtomicallyModifiable( plTarget ) );
	return InterlockedExchange( plTarget, lValue );
	}

//  atomically adds the specified value to the target, returning the target's
//  initial value.  the target must be aligned to a four byte boundary

const long AtomicExchangeAdd( long* plTarget, const long lValue )
	{
	Assert( IsAtomicallyModifiable( plTarget ) );
	return InterlockedExchangeAdd( plTarget, lValue );
	}

#endif


//  Enhanced Synchronization Object State Container

struct MemoryBlock
	{
	MemoryBlock*	pmbNext;
	MemoryBlock**	ppmbNext;
	DWORD			cAlloc;
	DWORD			ibFreeMic;
	};

DWORD				g_cbMemoryBlock;
MemoryBlock*		g_pmbRoot;
MemoryBlock			g_mbSentry;
CRITICAL_SECTION	g_csESMemory;

void* ESMemoryNew( size_t cb )
	{
	if ( !FOSSyncInit() )
		{
		return NULL;
		}
		
	cb += sizeof( long ) - 1;
	cb -= cb % sizeof( long );
	
	EnterCriticalSection( &g_csESMemory );
	
	MemoryBlock* pmb = g_pmbRoot;

	if ( pmb->ibFreeMic + cb > g_cbMemoryBlock )
		{
		if ( !( pmb = (MemoryBlock*) VirtualAlloc( NULL, g_cbMemoryBlock, MEM_COMMIT, PAGE_READWRITE ) ) )
			{
			LeaveCriticalSection( &g_csESMemory );
			OSSyncTerm();
			return pmb;
			}
			
		pmb->pmbNext	= g_pmbRoot;
		pmb->ppmbNext	= &g_pmbRoot;
		pmb->cAlloc		= 0;
		pmb->ibFreeMic	= sizeof( MemoryBlock );

		g_pmbRoot->ppmbNext = &pmb->pmbNext;
		g_pmbRoot = pmb;
		}

	void* pv = (BYTE*)pmb + pmb->ibFreeMic;
	pmb->cAlloc++;
	pmb->ibFreeMic += cb;

	LeaveCriticalSection( &g_csESMemory );
	return pv;
	}
	
void ESMemoryDelete( void* pv )
	{
	if ( pv )
		{
		EnterCriticalSection( &g_csESMemory );
		
		MemoryBlock* const pmb = (MemoryBlock*) ( (DWORD_PTR)( pv ) - (DWORD_PTR)( pv ) % g_cbMemoryBlock );
		
		if ( !( --pmb->cAlloc ) )
			{
			*pmb->ppmbNext = pmb->pmbNext;
			pmb->pmbNext->ppmbNext = pmb->ppmbNext;
			BOOL fMemFreed = VirtualFree( pmb, 0, MEM_RELEASE );
			Assert( fMemFreed );
			}

		LeaveCriticalSection( &g_csESMemory );

		OSSyncTerm();
		}
	}


//  Synchronization Object Basic Information

//  ctor

CSyncBasicInfo::CSyncBasicInfo( const _TCHAR* szInstanceName )
	{
#ifdef SYNC_ENHANCED_STATE

	m_szInstanceName	= szInstanceName;
	m_szTypeName		= NULL;
	m_psyncobj			= NULL;

#endif  //  SYNC_ENHANCED_STATE
	}

//  dtor

CSyncBasicInfo::~CSyncBasicInfo()
	{
	}
	

//  Synchronization Object Performance:  Wait Times

//  ctor

CSyncPerfWait::CSyncPerfWait()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	m_cWait = 0;
	m_qwHRTWaitElapsed = 0;

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  dtor

CSyncPerfWait::~CSyncPerfWait()
	{
	}


//  Null Synchronization Object State Initializer

CSyncStateInitNull syncstateNull;


//  Kernel Semaphore

//  ctor

CKernelSemaphore::CKernelSemaphore( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CKernelSemaphoreState, CSyncStateInitNull, CSyncSimplePerfInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
	Assert( sizeof( long ) >= sizeof( HANDLE ) );

#ifdef SYNC_ENHANCED_STATE

	//  further init of CSyncBasicInfo

	State().SetTypeName( "CKernelSemaphore" );
	State().SetInstance( (CSyncObject*)this );

#endif  //  SYNC_ENHANCED_STATE
	}

//  dtor

CKernelSemaphore::~CKernelSemaphore()
	{
	//  semaphore should not be initialized
	
	Assert( !FInitialized() );
	}

//  initialize the semaphore, returning 0 on failure

const BOOL CKernelSemaphore::FInit()
	{
	//  semaphore should not be initialized
	
	Assert( !FInitialized() );
	
	//  allocate kernel semaphore object

	State().SetHandle( (LONG_PTR)( CreateSemaphore( 0, 0, 0x7FFFFFFFL, 0 ) ) );
	
	//  semaphore should have no available counts, if allocated

	Assert( State().Handle() == 0 || FReset() );

	//  return result of init

	return State().Handle() != 0;
	}

//  terminate the semaphore

void CKernelSemaphore::Term()
	{
	//  semaphore should be initialized

	Assert( FInitialized() );
	
	//  semaphore should have no available counts

	Assert( FReset() );

#ifdef SYNC_ANALYZE_PERFORMANCE

	//  dump performance data on termination if enabled

	Dump( pcprintfPerfData );
	
#endif  //  SYNC_ANALYZE_PERFORMANCE

	//  deallocate kernel semaphore object

	int fSuccess = CloseHandle( HANDLE( State().Handle() ) );
	Assert( fSuccess );

	//  reset state
	
	State().CKernelSemaphoreState::~CKernelSemaphoreState();
	State().CKernelSemaphoreState::CKernelSemaphoreState( syncstateNull );

	//  reset information
	//  UNDONE:  clean this up (yuck!)

#ifdef SYNC_ENHANCED_STATE
	const _TCHAR* szInstanceName = State().SzInstanceName();
#else  //  !SYNC_ENHANCED_STATE
	const _TCHAR* szInstanceName = _T( "" );
#endif  //  SYNC_ENHANCED_STATE
	State().CSyncSimplePerfInfo::~CSyncSimplePerfInfo();
	State().CSyncSimplePerfInfo::CSyncSimplePerfInfo( CSyncBasicInfo( szInstanceName ) );
	}

//  acquire one count of the semaphore, waiting only for the specified interval.
//  returns 0 if the wait timed out before a count could be acquired

const BOOL CKernelSemaphore::FAcquire( const int cmsecTimeout )
	{
	//  semaphore should be initialized

	Assert( FInitialized() );

	//  wait for semaphore

	DWORD dwResult;

	State().StartWait();
	
#ifdef SYNC_DEADLOCK_DETECTION

	if ( cmsecTimeout == cmsecInfinite || cmsecTimeout > cmsecDeadlock )
		{
		while ( ( dwResult = WaitForSingleObjectEx( HANDLE( State().Handle() ), cmsecDeadlock, FALSE ) ) == WAIT_IO_COMPLETION );
		
		Assert( dwResult == WAIT_OBJECT_0 || dwResult == WAIT_TIMEOUT );
		AssertRTLSz( dwResult == WAIT_OBJECT_0, _T( "Potential Deadlock Detected" ) );

		if ( dwResult == WAIT_TIMEOUT )
			{
			dwResult = WaitForSingleObjectEx(	HANDLE( State().Handle() ),
												cmsecTimeout == cmsecInfinite ?
													cmsecInfinite :
													cmsecTimeout - cmsecDeadlock,
												FALSE );
			}
		}
	else
		{
		Assert(	cmsecTimeout == cmsecInfiniteNoDeadlock ||
				cmsecTimeout <= cmsecDeadlock );

		const int cmsecWait =	cmsecTimeout == cmsecInfiniteNoDeadlock ?
									cmsecInfinite :
									cmsecTimeout;

		while ( ( dwResult = WaitForSingleObjectEx( HANDLE( State().Handle() ), cmsecWait, FALSE ) ) == WAIT_IO_COMPLETION );
		}
#else  //  !SYNC_DEADLOCK_DETECTION

	const int cmsecWait =	cmsecTimeout == cmsecInfiniteNoDeadlock ?
								cmsecInfinite :
								cmsecTimeout;
	
	while ( ( dwResult = WaitForSingleObjectEx( HANDLE( State().Handle() ), cmsecWait, FALSE ) ) == WAIT_IO_COMPLETION );
	
#endif  //  SYNC_DEADLOCK_DETECTION

	State().StopWait();
	
	Assert( dwResult == WAIT_OBJECT_0 || dwResult == WAIT_TIMEOUT );
	return dwResult == WAIT_OBJECT_0;
	}

//  releases the given number of counts to the semaphore, waking the appropriate
//  number of waiters

void CKernelSemaphore::Release( const int cToRelease )
	{
	//  semaphore should be initialized

	Assert( FInitialized() );

	//  release semaphore
	
	const BOOL fSuccess = ReleaseSemaphore( HANDLE( State().Handle() ), cToRelease, 0 );
	Assert( fSuccess );
	}


//  performance data dumping

#include <stdio.h>

//  ================================================================
class CPRINTFFILE : public CPRINTFSYNC
//  ================================================================
	{
	public:
		CPRINTFFILE( const _TCHAR* szFile ) :
			m_szFile( szFile ),
			m_file( _tfopen( szFile, _T( "a+" ) ) )
			{
			}		
		~CPRINTFFILE() { fclose( m_file ); }
		
		void __cdecl operator()( const _TCHAR* szFormat, ... ) const
			{
			va_list arg_ptr;
			va_start( arg_ptr, szFormat );
			_vftprintf( m_file, szFormat, arg_ptr );
			va_end( arg_ptr );
			}
			
	private:
		const _TCHAR* const	m_szFile;
		FILE*				m_file;
	};


//  init sync subsystem

volatile DWORD cOSSyncInit;  //  assumed init to 0 by the loader

const BOOL FOSSyncInit()
	{
	if ( AtomicIncrement( (long*)&cOSSyncInit ) == 1 )
		{
		//  reset all pointers

#ifdef SYNC_ANALYZE_PERFORMANCE

		pcprintfPerfData = NULL;

#endif  //  SYNC_ANALYZE_PERFORMANCE
		
		//  reset global CLS list

		InitializeCriticalSection( &csClsSyncGlobal );
		pclsSyncGlobal = NULL;
		dwClsSyncIndex = 0xFFFFFFFF;
		
		//  iniitalize the HRT

		OSTimeHRTInit();
		
		//  initialize the CEnhancedState allocator

		SYSTEM_INFO sinf;
		GetSystemInfo( &sinf );
		g_cbMemoryBlock = sinf.dwAllocationGranularity;
		g_pmbRoot = &g_mbSentry;
		g_mbSentry.pmbNext = NULL;
		g_mbSentry.ppmbNext = &g_pmbRoot;
		g_mbSentry.cAlloc = 1;
		g_mbSentry.ibFreeMic = g_cbMemoryBlock;
		InitializeCriticalSection( &g_csESMemory );

		//  initialize the Kernel Semaphore Pool

		if ( !ksempoolGlobal.FInit() )
			{
			goto HandleError;
			}

	    //  cache system max spin count
	    //
	    //  NOTE:  spins heavily as WaitForSingleObject() is extremely expensive
	    //
	    //  CONSIDER:  get spin count from persistent configuration

		DWORD cProcessor;
		DWORD_PTR maskProcess;
		DWORD_PTR maskSystem;
		BOOL fGotAffinityMask;
		fGotAffinityMask = GetProcessAffinityMask(	GetCurrentProcess(),
													&maskProcess,
													&maskSystem );
		Assert( fGotAffinityMask );

		for ( cProcessor = 0; maskProcess != 0; maskProcess >>= 1 )
			{
			if ( maskProcess & 1 )
				{
				cProcessor++;
				}
			}

	    cSpinMax = cProcessor == 1 ? 0 : 256;

#ifdef SYNC_ANALYZE_PERFORMANCE

		//  initialize performance data dumping cprintf

		if ( !( pcprintfPerfData = new CPRINTFFILE( _T( "SyncPerfData.TXT" ) ) ) )
			{
			goto HandleError;
			}

#endif  //  SYNC_ANALYZE_PERFORMANCE
	    }

	return fTrue;

HandleError:
	OSSyncTerm();
	return fFalse;
	}


//  terminate sync subsystem

void OSSyncTerm()
	{
	if ( !AtomicDecrement( (long*)&cOSSyncInit ) )
		{
#ifdef SYNC_ANALYZE_PERFORMANCE

		//  terminate performance data dumping cprintf

		delete (CPRINTFFILE*)pcprintfPerfData;
		pcprintfPerfData = NULL;

#endif  //  SYNC_ANALYZE_PERFORMANCE
		
		//  terminate the Kernel Semaphore Pool

		if ( ksempoolGlobal.FInitialized() )
			{
			ksempoolGlobal.Term();
			}
		
		//  terminate the CEnhancedState allocator

		DeleteCriticalSection( &g_csESMemory );
		
		//  remove any remaining CLS allocated by contexts that were already created
		//  when the subsystem was initialized

		while ( pclsSyncGlobal )
			{
			//  get the current head of the global CLS list

			CLS* pcls = pclsSyncGlobal;
			
			//  unregister our CLS

			OSSyncIClsUnregister( pcls );

			//  free our CLS storage

			BOOL fFreedCLSOK = !GlobalFree( pcls );
			Assert( fFreedCLSOK );
			}
		DeleteCriticalSection( &csClsSyncGlobal );
		}
	}


#ifdef DEBUGGER_EXTENSION

#include <string.h>
#include <ntsdexts.h>
#include <wdbgexts.h>
#include <process.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>

#define LOCAL static


LOCAL WINDBG_EXTENSION_APIS ExtensionApis;
LOCAL BOOL fVerbose = fFalse;
LOCAL HANDLE ghDbgProcess;


//  ================================================================
class CPRINTFWINDBG : public CPRINTFSYNC
//  ================================================================
	{
	public:
		VOID __cdecl operator()( const char * szFormat, ... ) const
			{
			va_list arg_ptr;
			va_start( arg_ptr, szFormat );
			vsprintf( szBuf, szFormat, arg_ptr );
			va_end( arg_ptr );
			szBuf[sizeof(szBuf)-1] = 0;
			dprintf( "%s", szBuf );
			}

		static CPRINTFSYNC * PcprintfInstance();
		
		~CPRINTFWINDBG() {}

	private:
		CPRINTFWINDBG() {}
		static CHAR szBuf[1024];	//  WARNING: not multi-threaded safe!
	};

CHAR CPRINTFWINDBG::szBuf[1024];

//  ================================================================
CPRINTFSYNC * CPRINTFWINDBG::PcprintfInstance()
//  ================================================================
	{
	static CPRINTFWINDBG CPrintfWindbg;
	return &CPrintfWindbg;
	}


//  ================================================================
class CDUMP
//  ================================================================
	{
	public:
		CDUMP() {}
		virtual ~CDUMP() {}
		
		virtual VOID Dump( HANDLE, HANDLE, DWORD, PWINDBG_EXTENSION_APIS, INT, const CHAR * const [] ) = 0;
	};
	

//  ================================================================
template< class _STRUCT>
class CDUMPA : public CDUMP
//  ================================================================
	{
	public:		
		VOID Dump(
			    HANDLE hCurrentProcess,
			    HANDLE hCurrentThread,
			    DWORD dwCurrentPc,
			    PWINDBG_EXTENSION_APIS lpExtensionApis,
			    INT argc,
			    const CHAR * const argv[] );
		static CDUMPA	instance;
	};

template< class _STRUCT>
CDUMPA<_STRUCT> CDUMPA<_STRUCT>::instance;


//  ****************************************************************
//  PROTOTYPES
//  ****************************************************************

#define DEBUG_EXT( name )					\
	LOCAL VOID name(						\
		const HANDLE hCurrentProcess,		\
		const HANDLE hCurrentThread,		\
		const DWORD dwCurrentPc,			\
	    const PWINDBG_EXTENSION_APIS lpExtensionApis,	\
	    const INT argc,						\
	    const CHAR * const argv[]  )

DEBUG_EXT( EDBGDump );
#ifdef SYNC_DEADLOCK_DETECTION
DEBUG_EXT( EDBGLocks );
#endif  //  SYNC_DEADLOCK_DETECTION
DEBUG_EXT( EDBGHelp );
DEBUG_EXT( EDBGHelpDump );
DEBUG_EXT( EDBGVerbose );

LOCAL VOID * PvReadDBGMemory( const ULONG ulAddr, const ULONG cbSize );
LOCAL VOID FreeDBGMemory( VOID * const pv );


//  ****************************************************************
//  COMMAND DISPATCH
//  ****************************************************************


typedef VOID (*EDBGFUNC)(
	const HANDLE hCurrentProcess,
	const HANDLE hCurrentThread,
	const DWORD dwCurrentPc,
    const PWINDBG_EXTENSION_APIS lpExtensionApis,
    const INT argc,
    const CHAR * const argv[]
    );


//  ================================================================
struct EDBGFUNCMAP
//  ================================================================
	{
	const char * 	szCommand;
	EDBGFUNC		function;
	const char * 	szHelp;
	};


//  ================================================================
struct CDUMPMAP
//  ================================================================
	{
	const char * 	szCommand;
	CDUMP 	   *	pcdump;
	const char * 	szHelp;
	};


//  ================================================================
LOCAL EDBGFUNCMAP rgfuncmap[] = {
//  ================================================================

	{
		"Help",		EDBGHelp,
		"Help                       -    Print this help message"
	},
	{
		"Dump",		EDBGDump,
		"Dump <Object> <Address>    -    Dump a given synchronization object's state"
	},
#ifdef SYNC_DEADLOCK_DETECTION
	{
		"Locks",		EDBGLocks,
		"Locks [<Thread ID>]        -    List all locks owned by any thread or all locks\n\t"
		"                                owned by the thread with the specified Thread ID"
	},
#endif  //  SYNC_DEADLOCK_DETECTION
	{
		"Verbose",		EDBGVerbose,
		"Verbose                    -    Toggle verbose mode"
	},
	
	};

LOCAL const int cfuncmap = sizeof( rgfuncmap ) / sizeof( EDBGFUNCMAP );


#define DUMPA(_struct)	{ #_struct, &(CDUMPA<_struct>::instance), #_struct " <Address>" }

//  ================================================================
LOCAL CDUMPMAP rgcdumpmap[] = {
//  ================================================================

	DUMPA( CAutoResetSignal ),
	DUMPA( CBinaryLock ),
	DUMPA( CCriticalSection ),
	DUMPA( CGate ),
	DUMPA( CKernelSemaphore ),
	DUMPA( CManualResetSignal ),
	DUMPA( CNestableCriticalSection ),
	DUMPA( CReaderWriterLock ),
	DUMPA( CSemaphore ),
	};

LOCAL const int ccdumpmap = sizeof( rgcdumpmap ) / sizeof( CDUMPMAP );


//  ================================================================
LOCAL BOOL FArgumentMatch( const CHAR * const sz, const CHAR * const szCommand )
//  ================================================================
	{
	const BOOL fMatch = ( ( strlen( sz ) == strlen( szCommand ) )
			&& !( _strnicmp( sz, szCommand, strlen( szCommand ) ) ) );
	if( fVerbose )
		{
		dprintf( "FArgumentMatch( %s, %s ) = %d\n", sz, szCommand, fMatch );
		}
	return fMatch;
	}


//  ================================================================
LOCAL BOOL FUlFromArg( const CHAR * const sz, ULONG * const pul, const INT base = 16 )
//  ================================================================
	{
	if( sz && *sz )
		{
		CHAR * pchEnd;
		*pul = strtoul( sz, &pchEnd, base );
		return fTrue;
		}
	return fFalse;
	}


//  ================================================================
LOCAL BOOL FUlFromExpr( const CHAR * const sz, ULONG * const pul )
//  ================================================================
	{
	if( sz && *sz )
		{
		*pul = ULONG( GetExpression( sz ) );
		return fTrue;
		}
	return fFalse;
	}


//  ================================================================
LOCAL VOID * PvReadDBGMemory( const ULONG ulAddr, const ULONG cbSize )
//  ================================================================
	{
	if( 0 == cbSize )
		{
		return NULL;
		}
		
	if( fVerbose )
		{
		dprintf( "HeapAlloc(0x%x)\n", cbSize );
		}

    VOID * const pv = HeapAlloc( GetProcessHeap(), 0, cbSize );

    if ( NULL == pv )
	    {
        dprintf( "Memory allocation error for %x bytes\n", cbSize );
        return NULL;
	    }

	if( fVerbose )
		{
		dprintf( "ReadProcessMemory(0x%x @ %p)\n", cbSize, ulAddr );
		}

    DWORD cRead;
    if ( !ReadProcessMemory( ghDbgProcess, (VOID *)ulAddr, pv, cbSize, &cRead ) )
	    {
        FreeDBGMemory(pv);
        dprintf( "ReadProcessMemory error %x (%x@%p)\n",
               	GetLastError(),
               	cbSize,
               	ulAddr );
        return NULL;
    	}

    if ( cbSize != cRead )
	    {
        FreeDBGMemory( pv );
        dprintf( "ReadProcessMemory size error - off by %x bytes\n",
        	(cbSize > cRead) ? cbSize - cRead : cRead - cbSize );
        return NULL;
    	}

    return pv;
	}


//  ================================================================
LOCAL VOID FreeDBGMemory( VOID * const pv )
//  ================================================================
	{
    if ( fVerbose )
    	{
        dprintf( "HeapFree(%p)\n", pv );
        }

    if ( NULL != pv )
	    {
        if ( !HeapFree( GetProcessHeap(), 0, pv ) )
    	    {
            dprintf( "Error %x freeing memory at %p\n", GetLastError(), pv );
        	}
	    }
	}

//  ================================================================
LOCAL VOID DBUTLSprintHex(
	CHAR * const 		szDest,
	const BYTE * const 	rgbSrc,
	const INT 			cbSrc,
	const INT 			cbWidth,
	const INT 			cbChunk,
	const INT			cbAddress,
	const INT			cbStart)
//  ================================================================
	{
	static const CHAR rgchConvert[] =	{ '0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f' };
			
	const BYTE * const pbMax = rgbSrc + cbSrc;
	const INT cchHexWidth = ( cbWidth * 2 ) + (  cbWidth / cbChunk );

	const BYTE * pb = rgbSrc;
	CHAR * sz = szDest;
	while( pbMax != pb )
		{
		sz += ( 0 == cbAddress ) ? 0 : sprintf( sz, "%*.*lx    ", cbAddress, cbAddress, pb - rgbSrc + cbStart );
		CHAR * szHex	= sz;
		CHAR * szText	= sz + cchHexWidth;
		do
			{
			for( INT cb = 0; cbChunk > cb && pbMax != pb; ++cb, ++pb )
				{
				*szHex++ 	= rgchConvert[ *pb >> 4 ];
				*szHex++ 	= rgchConvert[ *pb & 0x0F ];
				*szText++ 	= isprint( *pb ) ? *pb : '.';
				}
			*szHex++ = ' ';
			} while( ( ( pb - rgbSrc ) % cbWidth ) && pbMax > pb );
		while( szHex != sz + cchHexWidth )
			{
			*szHex++ = ' ';
			}
		*szText++ = '\n';
		*szText = '\0';
		sz = szText;
		}
	}

//  ================================================================
LOCAL const CHAR * SzEDBGHexDump( const VOID * const pv, const INT cb )
//  ================================================================
//
//	WARNING: not multi-threaded safe
//
	{
	static CHAR rgchBuf[1024];
	rgchBuf[0] = '\n';
	rgchBuf[1] = '\0';
	
	if( NULL == pv )
		{
		if( fVerbose )
			{
			dprintf( "SzEDBGHexDump: NULL pointer\n" );
			}
		return rgchBuf;
		}

	DBUTLSprintHex(
		rgchBuf,
		(BYTE *)pv,
		cb,
		cb + 1,
		4,
		0,
		0 );
		
	return rgchBuf;
	}


//  ================================================================
DEBUG_EXT( EDBGDump )
//  ================================================================
	{
	if( argc < 2 )
		{
		EDBGHelpDump( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, argv );
		return;
		}
		
	for( int icdumpmap = 0; icdumpmap < ccdumpmap; ++icdumpmap )
		{
		if( FArgumentMatch( argv[0], rgcdumpmap[icdumpmap].szCommand ) )
			{
			(rgcdumpmap[icdumpmap].pcdump)->Dump(
				hCurrentProcess,
				hCurrentThread,
				dwCurrentPc,
				lpExtensionApis,
				argc - 1, argv + 1 );
			return;
			}
		}
	EDBGHelpDump( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, argv );
	}


//  ================================================================
DEBUG_EXT( EDBGHelp )
//  ================================================================
	{
	for( int ifuncmap = 0; ifuncmap < cfuncmap; ifuncmap++ )
		{
		dprintf( "\t%s\n", rgfuncmap[ifuncmap].szHelp );
		}
	}


//  ================================================================
DEBUG_EXT( EDBGHelpDump )
//  ================================================================
	{
	dprintf( "Supported objects:\n\n" );
	for( int icdumpmap = 0; icdumpmap < ccdumpmap; icdumpmap++ )
		{
		dprintf( "\t%s\n", rgcdumpmap[icdumpmap].szHelp );
		}
	}


//  ================================================================
DEBUG_EXT( EDBGVerbose )
//  ================================================================
	{
	if( fVerbose )
		{
		dprintf( "Changing to non-verbose mode....\n" );
		fVerbose = fFalse;
		}
	else
		{
		dprintf( "Changing to verbose mode....\n" );
		fVerbose = fTrue;
		}
	}


#ifdef SYNC_DEADLOCK_DETECTION

//  ================================================================
DEBUG_EXT( EDBGLocks )
//  ================================================================
	{
	DWORD tid = 0;
	if ( argc > 1 || ( argc == 1 && !FUlFromArg( argv[0], &tid, 10 ) ) )
		{
		printf( "Usage:  Locks [<Thread ID>]" );
		return;
		}

	BOOL fFoundLock = fFalse;

	CLS* pcls = (CLS*)GetExpression( "ESE!pclsSyncGlobal" );
	while ( pcls )
		{
		if ( !( pcls = (CLS*)PvReadDBGMemory( DWORD( pcls ), sizeof( CLS ) ) ) )
			{
			dprintf( "An error occurred while scanning Thread IDs.\n" );
			break;
			}

		if ( fVerbose )
			{
			dprintf( "Inspecting TLS for TID %d...\n", pcls->dwContextId );
			}
			
		if ( !tid || pcls->dwContextId == tid )
			{
			COwner* powner = pcls->pownerLockHead;
			while ( powner )
				{
				if ( !( powner = (COwner*)PvReadDBGMemory( DWORD( powner ), sizeof( COwner ) ) ) )
					{
					dprintf(	"An error occurred while scanning the lock chain for Thread ID %d.\n",
								pcls->dwContextId );
					break;
					}

				CLockDeadlockDetectionInfo* plddi = powner->m_plddiOwned;
				if ( !( plddi = (CLockDeadlockDetectionInfo*)PvReadDBGMemory( DWORD( plddi ), sizeof( CLockDeadlockDetectionInfo ) ) ) )
					{
					dprintf(	"An error occurred while scanning the lock chain for Thread ID %d.\n",
								pcls->dwContextId );
					break;
					}

				const CLockBasicInfo* plbi = &plddi->Info();
				if ( !( plbi = (CLockBasicInfo*)PvReadDBGMemory( DWORD( plbi ), sizeof( CLockBasicInfo ) ) ) )
					{
					dprintf(	"An error occurred while scanning the lock chain for Thread ID %d.\n",
								pcls->dwContextId );
					break;
					}

				const int cbTypeNameMax = 256;
				char* pszTypeName = (char*)plbi->SzTypeName();
				if ( !( pszTypeName = (char*)PvReadDBGMemory( DWORD( pszTypeName ), cbTypeNameMax ) ) )
					{
					dprintf(	"An error occurred while scanning the lock chain for Thread ID %d.\n",
								pcls->dwContextId );
					break;
					}
				pszTypeName[ cbTypeNameMax - 1 ] = '\0';

				const int cbInstanceNameMax = 256;
				char* pszInstanceName = (char*)plbi->SzInstanceName();
				if ( !( pszInstanceName = (char*)PvReadDBGMemory( DWORD( pszInstanceName ), cbInstanceNameMax ) ) )
					{
					dprintf(	"An error occurred while scanning the lock chain for Thread ID %d.\n",
								pcls->dwContextId );
					break;
					}
				pszInstanceName[ cbInstanceNameMax - 1 ] = '\0';

				fFoundLock = fTrue;

				dprintf(	"TID %d owns %s 0x%08x ( \"%s\", %d, %d )",
							pcls->dwContextId,
							pszTypeName,
							plbi->Instance(),
							pszInstanceName,
							plbi->Rank(),
							plbi->SubRank() );
				if ( powner->m_group != -1 )
					{
					dprintf( " as Group %d", powner->m_group );
					}
				dprintf( ".\n" );

				FreeDBGMemory( pszInstanceName );
				FreeDBGMemory( pszTypeName );
				FreeDBGMemory( (void*)plbi );
				FreeDBGMemory( plddi );
					
				COwner* pownerToFree = powner;
				powner = powner->m_pownerLockNext;
				FreeDBGMemory( pownerToFree );
				}
			}
			
		CLS* pclsToFree = pcls;
		pcls = pcls->pclsNext;
		FreeDBGMemory( pclsToFree );
		}

	if ( !fFoundLock )
		{
		if ( !tid )
			{
			dprintf( "No threads own any locks.\n" );
			}
		else
			{
			dprintf( "This thread does not own any locks.\n" );
			}
		}
	}

#endif  //  SYNC_DEADLOCK_DETECTION

//  ================================================================
template< class _STRUCT>
VOID CDUMPA<_STRUCT>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[]
    )
//  ================================================================
	{
	DWORD dwAddress;
	if( 1 != argc
		|| !FUlFromExpr( argv[0], &dwAddress ) )
		{
		printf( "Usage:  Dump <Object> <Address>" );
		return;
		}
		
	_STRUCT * const p = (_STRUCT *)PvReadDBGMemory( dwAddress, sizeof( _STRUCT ) );
	if( NULL != p )
		{
		dprintf( "0x%x bytes @ 0x%08x\n", sizeof( _STRUCT ), dwAddress );
		if ( sizeof( _STRUCT ) < p->CbEnhancedState() )
			{
			dwAddress = *((ULONG*)p);
			*((void**)p) = PvReadDBGMemory( dwAddress, p->CbEnhancedState() );
			if ( NULL == *((void**)p) )
				{
				FreeDBGMemory( p );
				return;
				}
			dprintf( "0x%x bytes @ 0x%08x [Enhanced State]\n", p->CbEnhancedState(), dwAddress );
			p->Dump( CPRINTFWINDBG::PcprintfInstance(), dwAddress - *((DWORD*)p) );
			FreeDBGMemory( *((void**)p) );
			}
		else
			{
			p->Dump( CPRINTFWINDBG::PcprintfInstance(), dwAddress - DWORD( p ) );
			}
		FreeDBGMemory( p );
		}
	}


VOID __cdecl OSSyncDebuggerExtension(	HANDLE hCurrentProcess,
										HANDLE hCurrentThread,
										DWORD dwCurrentPc,
										PWINDBG_EXTENSION_APIS lpExtensionApis,
										const INT argc,
										const CHAR * const argv[] )
	{
    ExtensionApis 	= *lpExtensionApis;	//	we can't use dprintf until this is set
    ghDbgProcess	= hCurrentProcess;

	if( argc < 1 )
		{
		EDBGHelp( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, (const CHAR **)argv );
		return;
		}

	INT ifuncmap;
	for( ifuncmap = 0; ifuncmap < cfuncmap; ifuncmap++ )
		{
		if( FArgumentMatch( argv[0], rgfuncmap[ifuncmap].szCommand ) )
			{
			(rgfuncmap[ifuncmap].function)(
				hCurrentProcess,
				hCurrentThread,
				dwCurrentPc,
				lpExtensionApis,
				argc - 1, (const CHAR **)( argv + 1 ) );
			return;
			}
		}
	EDBGHelp( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, (const CHAR **)argv );
	}


//  class and member size and offset functions

#define sizeof_class_bits( c ) ( sizeof( c ) * 8 )

#define sizeof_class_bytes( c ) ( sizeof( c ) )

LOCAL void* pvGS;
#define sizeof_member_bits( c, m ) ( \
	( (c *)( pvGS = calloc( 1, sizeof_class_bytes( c ) ) ) )->m = -1, \
	_sizeof_member_bits( (char*) pvGS, sizeof_class_bytes( c ) ) )

LOCAL inline int _sizeof_member_bits( char* pb, int cb )
	{
	for ( int ib = 0; pb[ib] == 0; ib++ );
	for ( int off = ib * 8, mask = 1; ( pb[ib] & mask ) == 0; off++, mask <<= 1 );
	for ( int ib2 = cb - 1; pb[ib2] == 0; ib2-- );
	for ( int off2 = ib2 * 8 + 7, mask2 = 128; ( pb[ib2] & mask2 ) == 0; off2--, mask2 >>= 1 );
	free( pb );
	return off2 - off + 1;
	}

#define sizeof_member_bytes( c, m ) ( ( sizeof_member_bits( c, m ) + 7 ) / 8 )


LOCAL void* pvGO;
#define offsetof_member_bits_abs( c, m ) ( \
	( (c *)( pvGO = calloc( 1, sizeof_class_bytes( c ) ) ) )->m = -1, \
	_offsetof_member_bits_abs( (char*) pvGO, sizeof_class_bytes( c ) ) )

LOCAL inline int _offsetof_member_bits_abs( char* pb, int cb )
	{
	for ( int ib = 0; pb[ib] == 0; ib++ );
	for ( int off = ib * 8, mask = 1; ( pb[ib] & mask ) == 0; off++, mask <<= 1 );
	free( pb );
	return off;
	}

#define offsetof_member_bits( c, m ) ( _offsetof_member_bits( offsetof_member_bits_abs( c, m ), sizeof_member_bits( c, m ) ) )

LOCAL inline int _offsetof_member_bits( int ibit, int cbit )
	{
	for ( int cbit2 = 8; cbit2 < cbit; cbit2 <<= 1 );
	return ibit % cbit2;
	}

#define offsetof_member_bytes( c, m ) ( ( offsetof_member_bits_abs( c, m ) - offsetof_member_bits( c, m ) ) / 8 )


#define is_member_bitfield( c, m ) ( offsetof_member_bits( c, m ) != 0 || sizeof_member_bytes( c, m ) * 8 > sizeof_member_bits( c, m ) )


//  member dumping functions

#include <stddef.h>

#define SYMBOL_LEN_MAX		15
#define VOID_CB_DUMP		8

#define FORMAT_VOID( CLASS, pointer, member, offset )	\
	"\t%*.*s <0x%08x   ,%3i>   %s", \
	SYMBOL_LEN_MAX, \
	SYMBOL_LEN_MAX, \
	#member, \
	(char*)pointer + offset + offsetof( CLASS, member ), \
	sizeof( (pointer)->member ),	\
	SzEDBGHexDump( (VOID *)(&((pointer)->member)), ( VOID_CB_DUMP > sizeof( (pointer)->member ) ) ? sizeof( (pointer)->member ) : VOID_CB_DUMP )

#define FORMAT_POINTER( CLASS, pointer, member, offset )	\
	"\t%*.*s <0x%08x   ,%3i>:  0x%08x\n", \
	SYMBOL_LEN_MAX, \
	SYMBOL_LEN_MAX, \
	#member, \
	(char*)pointer + offset + offsetof( CLASS, member ), \
	sizeof( (pointer)->member ), \
	(pointer)->member

#define FORMAT_INT( CLASS, pointer, member, offset )	\
	"\t%*.*s <0x%08x   ,%3i>:  %I64i (0x%0*I64x)\n", \
	SYMBOL_LEN_MAX, \
	SYMBOL_LEN_MAX, \
	#member, \
	(char*)pointer + offset + offsetof( CLASS, member ), \
	sizeof( (pointer)->member ), \
	(QWORD)(pointer)->member, \
	sizeof( (pointer)->member ) * 2, \
	(QWORD)(pointer)->member & ( ( (QWORD)1 << ( sizeof( (pointer)->member ) * 8 ) ) - 1 )

#define FORMAT_UINT( CLASS, pointer, member, offset )	\
	"\t%*.*s <0x%08x   ,%3i>:  %I64u (0x%0*I64x)\n", \
	SYMBOL_LEN_MAX, \
	SYMBOL_LEN_MAX, \
	#member, \
	(char*)pointer + offset + offsetof( CLASS, member ), \
	sizeof( (pointer)->member ), \
	(QWORD)(pointer)->member, \
	sizeof( (pointer)->member ) * 2, \
	(QWORD)(pointer)->member & ( ( (QWORD)1 << ( sizeof( (pointer)->member ) * 8 ) ) - 1 )

#define FORMAT_BOOL( CLASS, pointer, member, offset )	\
	"\t%*.*s <0x%08x   ,%3i>:  %s  (0x%08x)\n", \
	SYMBOL_LEN_MAX, \
	SYMBOL_LEN_MAX, \
	#member, \
	(char*)pointer + offset + offsetof( CLASS, member ), \
	sizeof( (pointer)->member ), \
	(pointer)->member ? \
		"fTrue" : \
		"fFalse", \
	(pointer)->member

#define FORMAT_INT_BF( CLASS, pointer, member, offset )	\
	"\t%*.*s <0x%08x%s%-2.*i,%3i>:  %I64i (0x%0*I64x)\n", \
	SYMBOL_LEN_MAX, \
	SYMBOL_LEN_MAX, \
	#member, \
	(char*)pointer + offset + offsetof_member_bytes( CLASS, member ), \
	is_member_bitfield( CLASS, member ) ? \
		":" : \
		" ", \
	is_member_bitfield( CLASS, member ) ? \
		1 : \
		0, \
	offsetof_member_bits( CLASS, member ), \
	is_member_bitfield( CLASS, member ) ? \
		sizeof_member_bits( CLASS, member ) : \
		sizeof_member_bytes( CLASS, member ), \
	(QWORD)(pointer)->member, \
	( sizeof_member_bits( CLASS, member ) + 3 ) / 4, \
	(QWORD)(pointer)->member & ( ( (QWORD)1 << sizeof_member_bits( CLASS, member ) ) - 1 )

#define FORMAT_UINT_BF( CLASS, pointer, member, offset )	\
	"\t%*.*s <0x%08x%s%-2.*i,%3i>:  %I64u (0x%0*I64x)\n", \
	SYMBOL_LEN_MAX, \
	SYMBOL_LEN_MAX, \
	#member, \
	(char*)pointer + offset + offsetof_member_bytes( CLASS, member ), \
	is_member_bitfield( CLASS, member ) ? \
		":" : \
		" ", \
	is_member_bitfield( CLASS, member ) ? \
		1 : \
		0, \
	offsetof_member_bits( CLASS, member ), \
	is_member_bitfield( CLASS, member ) ? \
		sizeof_member_bits( CLASS, member ) : \
		sizeof_member_bytes( CLASS, member ), \
	(QWORD)(pointer)->member, \
	( sizeof_member_bits( CLASS, member ) + 3 ) / 4, \
	(QWORD)(pointer)->member & ( ( (QWORD)1 << sizeof_member_bits( CLASS, member ) ) - 1 )

#define FORMAT_BOOL_BF( CLASS, pointer, member, offset )	\
	"\t%*.*s <0x%08x%s%-2.*i,%3i>:  %s (0x%0*I64x)\n", \
	SYMBOL_LEN_MAX, \
	SYMBOL_LEN_MAX, \
	#member, \
	(char*)pointer + offset + offsetof_member_bytes( CLASS, member ), \
	is_member_bitfield( CLASS, member ) ? \
		":" : \
		" ", \
	is_member_bitfield( CLASS, member ) ? \
		1 : \
		0, \
	offsetof_member_bits( CLASS, member ), \
	is_member_bitfield( CLASS, member ) ? \
		sizeof_member_bits( CLASS, member ) : \
		sizeof_member_bytes( CLASS, member ), \
	(pointer)->member ? \
		"fTrue" : \
		"fFalse", \
	( sizeof_member_bits( CLASS, member ) + 3 ) / 4, \
	(QWORD)(pointer)->member & ( ( (QWORD)1 << sizeof_member_bits( CLASS, member ) ) - 1 )

#endif  //  DEBUGGER_EXTENSION


void CSyncBasicInfo::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )
#ifdef SYNC_ENHANCED_STATE

	(*pcprintf)( FORMAT_POINTER( CSyncBasicInfo, this, m_szInstanceName, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSyncBasicInfo, this, m_szTypeName, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSyncBasicInfo, this, m_psyncobj, dwOffset ) );

#endif  //  SYNC_ENHANCED_STATE
#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CSyncPerfWait::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )
#ifdef SYNC_ANALYZE_PERFORMANCE

	(*pcprintf)( FORMAT_UINT( CSyncPerfWait, this, m_cWait, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSyncPerfWait, this, m_qwHRTWaitElapsed, dwOffset ) );

#endif  //  SYNC_ANALYZE_PERFORMANCE
#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CKernelSemaphoreState::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	(*pcprintf)( FORMAT_UINT( CKernelSemaphoreState, this, m_handle, dwOffset ) );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CSyncPerfAcquire::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )
#ifdef SYNC_ANALYZE_PERFORMANCE

	(*pcprintf)( FORMAT_UINT( CSyncPerfAcquire, this, m_cAcquire, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSyncPerfAcquire, this, m_cContend, dwOffset ) );

#endif  //  SYNC_ANALYZE_PERFORMANCE
#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CSemaphoreState::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	if ( FNoWait() )
		{
		(*pcprintf)( FORMAT_UINT( CSemaphoreState, this, m_cAvail, dwOffset ) );
		}
	else
		{
		(*pcprintf)( FORMAT_UINT( CSemaphoreState, this, m_irksem, dwOffset ) );
		(*pcprintf)( FORMAT_INT( CSemaphoreState, this, m_cWaitNeg, dwOffset ) );
		}

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CAutoResetSignalState::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	if ( FNoWait() )
		{
		(*pcprintf)( FORMAT_BOOL( CAutoResetSignalState, this, m_fSet, dwOffset ) );
		}
	else
		{
		(*pcprintf)( FORMAT_UINT( CAutoResetSignalState, this, m_irksem, dwOffset ) );
		(*pcprintf)( FORMAT_INT( CAutoResetSignalState, this, m_cWaitNeg, dwOffset ) );
		}

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CManualResetSignalState::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	if ( FNoWait() )
		{
		(*pcprintf)( FORMAT_BOOL( CManualResetSignalState, this, m_fSet, dwOffset ) );
		}
	else
		{
		(*pcprintf)( FORMAT_UINT( CManualResetSignalState, this, m_irksem, dwOffset ) );
		(*pcprintf)( FORMAT_INT( CManualResetSignalState, this, m_cWaitNeg, dwOffset ) );
		}

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CLockBasicInfo::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	CSyncBasicInfo::Dump( pcprintf, dwOffset );

#ifdef SYNC_DEADLOCK_DETECTION

	(*pcprintf)( FORMAT_UINT( CLockBasicInfo, this, m_rank, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CLockBasicInfo, this, m_subrank, dwOffset ) );

#endif  //  SYNC_DEADLOCK_DETECTION
#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CLockPerfHold::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )
#ifdef SYNC_ANALYZE_PERFORMANCE

	(*pcprintf)( FORMAT_UINT( CLockPerfHold, this, m_cHold, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CLockPerfHold, this, m_qwHRTHoldElapsed, dwOffset ) );

#endif  //  SYNC_ANALYZE_PERFORMANCE
#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CLockDeadlockDetectionInfo::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )
#ifdef SYNC_DEADLOCK_DETECTION

	(*pcprintf)( FORMAT_POINTER( CLockDeadlockDetectionInfo, this, m_plbiParent, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CLockDeadlockDetectionInfo, this, m_semOwnerList, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CLockDeadlockDetectionInfo, this, m_ownerHead, dwOffset ) );

#endif  //  SYNC_DEADLOCK_DETECTION
#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CCriticalSectionState::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	(*pcprintf)( FORMAT_VOID( CCriticalSectionState, this, m_sem, dwOffset ) );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CNestableCriticalSectionState::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	(*pcprintf)( FORMAT_VOID( CNestableCriticalSectionState, this, m_sem, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CNestableCriticalSectionState, this, m_pclsOwner, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CNestableCriticalSectionState, this, m_cEntry, dwOffset ) );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CGateState::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	(*pcprintf)( FORMAT_INT( CGateState, this, m_cWait, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CGateState, this, m_irksem, dwOffset ) );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CBinaryLockState::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	(*pcprintf)( FORMAT_UINT( CBinaryLockState, this, m_cw, dwOffset ) );
	(*pcprintf)( FORMAT_UINT_BF( CBinaryLockState, this, m_cOOW1, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( CBinaryLockState, this, m_fQ1, dwOffset ) );
	(*pcprintf)( FORMAT_UINT_BF( CBinaryLockState, this, m_cOOW2, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( CBinaryLockState, this, m_fQ2, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CBinaryLockState, this, m_cOwner, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CBinaryLockState, this, m_sem1, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CBinaryLockState, this, m_sem2, dwOffset ) );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CReaderWriterLockState::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	(*pcprintf)( FORMAT_UINT( CReaderWriterLockState, this, m_cw, dwOffset ) );
	(*pcprintf)( FORMAT_UINT_BF( CReaderWriterLockState, this, m_cOAOWW, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( CReaderWriterLockState, this, m_fQW, dwOffset ) );
	(*pcprintf)( FORMAT_UINT_BF( CReaderWriterLockState, this, m_cOOWR, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( CReaderWriterLockState, this, m_fQR, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CReaderWriterLockState, this, m_cOwner, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CReaderWriterLockState, this, m_semWriter, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CReaderWriterLockState, this, m_semReader, dwOffset ) );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}


void CAutoResetSignal::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	State().CAutoResetSignalState::Dump( pcprintf, dwOffset );
	State().CSyncComplexPerfInfo::Dump( pcprintf, dwOffset );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CBinaryLock::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	State().CBinaryLockState::Dump( pcprintf, dwOffset );
	State().CGroupLockComplexInfo< 2 >::Dump( pcprintf, dwOffset );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CCriticalSection::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	State().CCriticalSectionState::Dump( pcprintf, dwOffset );
	State().CLockSimpleInfo::Dump( pcprintf, dwOffset );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CGate::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	State().CGateState::Dump( pcprintf, dwOffset );
	State().CSyncSimplePerfInfo::Dump( pcprintf, dwOffset );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CKernelSemaphore::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	State().CKernelSemaphoreState::Dump( pcprintf, dwOffset );
	State().CSyncSimplePerfInfo::Dump( pcprintf, dwOffset );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CManualResetSignal::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	State().CManualResetSignalState::Dump( pcprintf, dwOffset );
	State().CSyncComplexPerfInfo::Dump( pcprintf, dwOffset );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CNestableCriticalSection::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	State().CNestableCriticalSectionState::Dump( pcprintf, dwOffset );
	State().CLockSimpleInfo::Dump( pcprintf, dwOffset );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CReaderWriterLock::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	State().CReaderWriterLockState::Dump( pcprintf, dwOffset );
	State().CGroupLockComplexInfo< 2 >::Dump( pcprintf, dwOffset );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

void CSemaphore::Dump( CPRINTFSYNC* pcprintf, DWORD dwOffset )
	{
#if defined( DEBUGGER_EXTENSION ) || defined( SYNC_ANALYZE_PERFORMANCE )

	State().CSemaphoreState::Dump( pcprintf, dwOffset );
	State().CSyncComplexPerfInfo::Dump( pcprintf, dwOffset );

#endif  //  DEBUGGER_EXTENSION || SYNC_ANALYZE_PERFORMANCE
	}

// Define Stuff for sync.hxx

void AssertFail( const _TCHAR* szMessage, const _TCHAR* szFilename, long lLine )
{
#ifdef DEBUG
	DebugBreak();
#endif
	return;
}

void EnforceFail( const _TCHAR* szMessage, const _TCHAR* szFilename, long lLine )
{
#ifdef DEBUG
	DebugBreak();
#endif
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\thrdpl2\utest\main.cpp ===
# include <windows.h>
# include <stdio.h>
# include <stdlib.h>
# include <dbgtrace.h>
# include "thrdpl2.h"
#include <xmemwrpr.h>

//
//	Unit test for thrdpl2 lib
//

//
//	WorkCompletion of this class searches for files
//
class CFileSearch : public CThreadPool
{
public:
	CFileSearch()  {}
	~CFileSearch() {}

protected:
	virtual VOID WorkCompletion( PVOID pvWorkContext);
};

//
//  Test class to be used as job context
//
class CTest
{
public:
    CTest()  {cItems = 0;}
    ~CTest() {}
    DWORD cItems;
};

CHAR szDirectory1 [MAX_PATH+1];
CHAR szDirectory2 [MAX_PATH+1];
CHAR szDirectory3 [MAX_PATH+1];
CHAR szDirectory4 [MAX_PATH+1];
FILE* fp;

void
_cdecl
main(  int argc,  char * argv[] )
{
	CFileSearch* pFS;
    CTest*       pTest;

    CreateGlobalHeap(0,0,0,0);

	InitAsyncTrace();

    pTest = XNEW CTest;
    if( !pTest ) {
        printf("Failed to allocate CTest \n");
        DestroyGlobalHeap();
        exit(0);
    }

    //
    //  Create the file search thread pool
    //
    pFS = XNEW CFileSearch;
    if( !pFS ) {
        printf("Failed to allocate thrdpool \n");
        XDELETE pTest;
        DestroyGlobalHeap();
        exit(0);
    }

    //
    //  Init the thrd pool with num worker threads
    //
    if( !pFS->Initialize( 4, 4, 2 ) ) {
        printf("Failed to init thrdpool \n");
        DestroyGlobalHeap();
        exit(0);
    }

    //
    //  Create the work request params
    //
	lstrcpy( szDirectory1, "C:\\winnt\\system32\\inetsrv\\" );
	lstrcpy( szDirectory2, "C:\\winnt\\system32\\inetsrv\\" );
	lstrcpy( szDirectory3, "C:\\public" );
	lstrcpy( szDirectory4, "C:\\public" );

    //
    //  Post the work requests to the thrdpool (2 threads)
    //
    DWORD dwStartTick = GetTickCount();
    pFS->BeginJob((PVOID)pTest);

	pFS->PostWork( (PVOID) szDirectory1 );
	pFS->PostWork( (PVOID) szDirectory2 );
	pFS->PostWork( (PVOID) szDirectory3 );
	pFS->PostWork( (PVOID) szDirectory4 );

	pFS->WaitForJob(INFINITE);
    DWORD dwEndTick = GetTickCount();

    printf("Time taken with 2 threads is %d\n", dwEndTick - dwStartTick );

    //
    //  BeginJob followed by WaitForJob should work
    //
	pFS->BeginJob(NULL);
	pFS->WaitForJob(INFINITE);
	pFS->BeginJob(NULL);
	pFS->WaitForJob(INFINITE);

    //
    //  Now, grow the thread pool by 2 threads
    //
    pFS->GrowPool( 2 );
    dwStartTick = GetTickCount();
    pFS->BeginJob((PVOID)pTest);

	pFS->PostWork( (PVOID) szDirectory1 );
	pFS->PostWork( (PVOID) szDirectory2 );
	pFS->PostWork( (PVOID) szDirectory1 );
	pFS->PostWork( (PVOID) szDirectory2 );

	pFS->WaitForJob(INFINITE);
    dwEndTick = GetTickCount();

    printf("Time taken with 4 threads is %d\n", dwEndTick - dwStartTick );

    //
    //  Now, shrink the thread pool back to 2 threads
    //
    pFS->ShrinkPool( 2 );
    dwStartTick = GetTickCount();
    pFS->BeginJob((PVOID)pTest);

	pFS->PostWork( (PVOID) szDirectory1 );
	pFS->PostWork( (PVOID) szDirectory2 );
	pFS->PostWork( (PVOID) szDirectory1 );
	pFS->PostWork( (PVOID) szDirectory2 );

	pFS->WaitForJob(INFINITE);
    dwEndTick = GetTickCount();

    printf("Time taken with 2 threads is %d\n", dwEndTick - dwStartTick );

    //
    //  Terminate the thrdpool
    //
    if( !pFS->Terminate() ) {
        printf("Failed to terminate thrdpool \n");
        DestroyGlobalHeap();
        exit(0);
    }

    //
    //  Delete the thrdpool
    //
	XDELETE pFS;
	pFS = NULL;
    XDELETE pTest;
    pTest = NULL;

	TermAsyncTrace();
    DestroyGlobalHeap();

} // main()

VOID
CFileSearch::WorkCompletion( PVOID pvWorkContext )
{
	LPSTR lpDir = (LPSTR) pvWorkContext;
    CTest* pTest = (CTest*)QueryJobContext();
    char szFile [ MAX_PATH ];
	char szPath [ MAX_PATH ];
	WIN32_FIND_DATA FileStats;
	HANDLE hFind;
	BOOL fRet = TRUE;
	szFile[0] = '\0' ;

	TraceFunctEnter("CFileSearch::WorkCompletion");

	//
	//	Build the pattern search path
	//
	lstrcpy( szFile, lpDir );
	lstrcat( szFile, "*.dll" );

	//
	//	Do a FindFirst/FindNext on this wildcard and delete any files found !

	//
	if( szFile[0] != '\0' ) 
    {
		hFind = FindFirstFile( szFile, &FileStats );

        if ( INVALID_HANDLE_VALUE == hFind )
		{
			ErrorTrace(0, " Did not find any files \n");
			fRet = TRUE;
		}
		else
		{
    		do
			{
				// build the full filename
				wsprintf( szPath, "%s\\%s", szFile, FileStats.cFileName );
				DebugTrace(0," Found file %s \n", szPath );

				DWORD dwWait = WaitForSingleObject( QueryShutdownEvent(), 100 );
				if( dwWait == WAIT_OBJECT_0 ) {
					DebugTrace(0,"shutdown signalled: bailing");
					break;
				}

                pTest = (CTest*)QueryJobContext();
                pTest->cItems++;
                Sleep( 100 );
			
			} while ( FindNextFile( hFind, &FileStats ) );

			//_ASSERT(GetLastError() == ERROR_NO_MORE_FILES);

			FindClose( hFind );
		}
	}

	printf("%s done\n", lpDir);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\thrdpool\thrdpool.cpp ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:        thrdpool.cpp
//
//  Contents:    implementation of thrdpool library
//
//	Description: See header file.
//
//  Functions:
//
//  History:     03/15/97     Rajeev Rajan (rajeevr)  Created
//
//-----------------------------------------------------------------------------
#include <windows.h>
#include <thrdpool.h>
#include <dbgtrace.h>

LONG   CWorkerThread::m_lInitCount = -1 ;
HANDLE CWorkerThread::m_hCompletionPort = NULL ;

BOOL
CWorkerThread::InitClass( DWORD dwConcurrency )
{
	TraceFunctEnter("CWorkerThread::InitClass");

	if( InterlockedIncrement( &m_lInitCount ) == 0 )
	{
		//
		//	called for the first time - go ahead with initialization
		//
		m_hCompletionPort = CreateIoCompletionPort(
											INVALID_HANDLE_VALUE,
											NULL,
											0,
											dwConcurrency
											);

		if( !m_hCompletionPort ) {
			ErrorTrace(0, "Failed to create completion port: GetLastError is %d", GetLastError());
			return FALSE ;
		}

	} else
	{
		//
		//	bogus Init or already called
		//
		InterlockedDecrement( &m_lInitCount );
		return FALSE ;
	}

	DebugTrace(0,"Created completion port 0x%x", m_hCompletionPort);
	TraceFunctLeave();

	return TRUE ;
}

BOOL
CWorkerThread::TermClass()
{
	TraceFunctEnter("CWorkerThread::TermClass");

	if( InterlockedDecrement( &m_lInitCount ) < 0 )
	{
		//
		//	Init has been called so go ahead with termination
		//
		_ASSERT( m_hCompletionPort );
		_VERIFY( CloseHandle( m_hCompletionPort ) );
		return TRUE ;
	}

	return FALSE ;
}

CWorkerThread::CWorkerThread() : m_hThread(NULL), m_hShutdownEvent( NULL )
{
	DWORD dwThreadId;

	TraceFunctEnter("CWorkerThread::CWorkerThread");

	//
	//	create shutdown event
	//
	if( !(m_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL) ) ) {
		ErrorTrace(0,"Failed to create shutdown event");
		_ASSERT( FALSE );
		return;
	}

	//
	//	create worker thread
	//
	if (!(m_hThread = ::CreateThread(
								NULL,
								0,
								ThreadDispatcher,
								this,
								CREATE_SUSPENDED,
								&dwThreadId))) {
		ErrorTrace(0,"Failed to create thread: error: %d", GetLastError());
		_ASSERT( FALSE );
	}
	else
	{
		_VERIFY( ResumeThread( m_hThread ) != 0xFFFFFFFF );
	}

	TraceFunctLeave();
	return;
}

CWorkerThread::~CWorkerThread()
{
	TraceFunctEnter("CWorkerThread::~CWorkerThread");

	_ASSERT( m_hCompletionPort );
	_ASSERT( m_hThread );
	_ASSERT( m_hShutdownEvent );

	//
	//	signal worker thread to shutdown
	//	this depends on derived class completion routines
	//	checking this event - if they dont, we will block
	//	till the thread finishes.
	//
	_VERIFY( SetEvent( m_hShutdownEvent ) );

	//
	//	post a null termination packet
	//
	if( !PostWork( NULL ) ) {
		ErrorTrace(0,"Error terminating worker thread");
		_ASSERT( FALSE );
	}

	//
	//	wait for worker thread to terminate
	//
	DWORD dwWait = WaitForSingleObject(m_hThread, INFINITE);
	if(WAIT_OBJECT_0 != dwWait) {
		ErrorTrace(0,"WFSO: returned %d", dwWait);
		_ASSERT( FALSE );
	}

	_VERIFY( CloseHandle(m_hThread) );
	_VERIFY( CloseHandle(m_hShutdownEvent) );
	m_hThread = NULL;
	m_hShutdownEvent = NULL;
}

DWORD __stdcall CWorkerThread::ThreadDispatcher(PVOID pvWorkerThread)
{
	//
	//	get pointer to this CWorkerThread object
	//
	CWorkerThread *pWorkerThread = (CWorkerThread *) pvWorkerThread;

	//
	//	call GetQueuedCompletionStatus() to get work completion
	//
	pWorkerThread->GetWorkCompletion();

	return 0;
}

VOID CWorkerThread::GetWorkCompletion(VOID)
{
	DWORD dwBytesTransferred;
	DWORD_PTR dwCompletionKey;
	DWORD dwWait;
	LPOVERLAPPED lpo;
	LPWorkContextEnv lpWCE;
	PVOID	pvWorkContext;

	TraceFunctEnter("CWorkerThread::GetWorkCompletion");

	_ASSERT( m_hThread );
	_ASSERT( m_hCompletionPort );

	do
	{
		//
		//	wait for work items to be queued
		//
		if( !GetQueuedCompletionStatus(
									m_hCompletionPort,
									&dwBytesTransferred,
									&dwCompletionKey,
									&lpo,
									INFINITE				// wait timeout
									) )
		{
			ErrorTrace(0,"GetQueuedCompletionStatus() failed: error: %d", GetLastError());
			break ;
		}

		//
		// get a hold of the work context envelope and work context
		//
		lpWCE = (LPWorkContextEnv) lpo;
		pvWorkContext = lpWCE->pvWorkContext;

		//
		//	check for termination packet
		//
		if( pvWorkContext == NULL ) {
			DebugTrace(0,"Received termination packet - bailing");
			delete lpWCE;
			lpWCE = NULL;
			break;
		}

		//
		//	check for termination signal
		//
		dwWait = WaitForSingleObject( m_hShutdownEvent, 0 );

		//
		//	call derived class method to process work completion
		//
		if( WAIT_TIMEOUT == dwWait ) {
			DebugTrace(0,"Calling WorkCompletion() routine");
			WorkCompletion( pvWorkContext );
		}

		//
		//	destroy the WorkContextEnv object allocated before PostQueuedCompletionStatus()
		//
		delete lpWCE;
		lpWCE = NULL;

	} while( TRUE );

	return;
}

BOOL CWorkerThread::PostWork(PVOID pvWorkerContext)
{
	TraceFunctEnter("CWorkerThread::PostWork");

	_ASSERT( m_hThread );
	_ASSERT( m_hCompletionPort );

	//
	//	allocate a WorkContextEnv blob - this is destroyed after GetQueuedCompletionStatus()
	//	completes ! We may want to have a pool of such blobs instead of hitting the heap !!
	//
	LPWorkContextEnv lpWCE = new WorkContextEnv;
	if( !lpWCE ) {
		ErrorTrace(0,"Failed to allocate memory");
		return FALSE ;
	}

	ZeroMemory( lpWCE, sizeof(WorkContextEnv) );
	lpWCE->pvWorkContext = pvWorkerContext;

	if( !PostQueuedCompletionStatus(
								m_hCompletionPort,
								0,
								0,
								(LPOVERLAPPED)lpWCE
								) )
	{
		ErrorTrace(0,"PostQCompletionStatus() failed: error: %d", GetLastError());
		return FALSE ;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\thrdpool\utest\main.cpp ===
# include <windows.h>
# include <stdio.h>
# include <stdlib.h>
# include <dbgtrace.h>
# include "thrdpool.h"

//
//	Unit test for thrdpool lib
//

//
//	WorkCompletion of this class searches for files
//
class CFileSearch : public CWorkerThread
{
public:
	CFileSearch()  {}
	~CFileSearch() {}

protected:
	virtual VOID WorkCompletion( PVOID pvWorkContext);
};

CHAR szDirectory1 [MAX_PATH+1];
CHAR szDirectory2 [MAX_PATH+1];
FILE* fp;

void
_CRTAPI1
main(  int argc,  char * argv[] )
{
	char c;
	CFileSearch* pFS1, *pFS2;

	InitAsyncTrace();

	if( !CWorkerThread::InitClass( 2 ) ) {
		printf(" InitClass() failed \n");
		exit(0);
	}

	pFS1 = new CFileSearch();
	if( !pFS1 ) {
		printf(" Failed to allocate object\n");
		goto err_exit;
	}

	pFS2 = new CFileSearch();
	if( !pFS2 ) {
		printf(" Failed to allocate object\n");
		goto err_exit;
	}

	lstrcpy( szDirectory1, "C:\\winnt40\\system32\\" );
	pFS1->PostWork( (PVOID) szDirectory1 );

	lstrcpy( szDirectory2, "C:\\winnt40\\system32\\inetsrv\\" );
	pFS2->PostWork( (PVOID) szDirectory2 );

	Sleep( 1000 );

	delete pFS1;
	pFS1 = NULL;

	delete pFS2;
	pFS2 = NULL;

err_exit:

	CWorkerThread::TermClass();

	TermAsyncTrace();

} // main()

VOID
CFileSearch::WorkCompletion( PVOID pvWorkContext )
{
	LPSTR lpDir = (LPSTR) pvWorkContext;
    char szFile [ MAX_PATH ];
	char szPath [ MAX_PATH ];
	WIN32_FIND_DATA FileStats;
	HANDLE hFind;
	BOOL fRet = TRUE;
	szFile[0] = '\0' ;

	TraceFunctEnter("CFileSearch::WorkCompletion");

	//
	//	Build the pattern search path
	//
	lstrcpy( szFile, lpDir );
	lstrcat( szFile, "*.dll" );

	//
	//	Do a FindFirst/FindNext on this wildcard and delete any files found !
	//
	if( szFile[0] != '\0' ) 
    {
		hFind = FindFirstFile( szFile, &FileStats );

        if ( INVALID_HANDLE_VALUE == hFind )
		{
			ErrorTrace(0, " Did not find any files \n");
			fRet = TRUE;
		}
		else
		{
    		do
			{
				// build the full filename
				wsprintf( szPath, "%s\\%s", szFile, FileStats.cFileName );
				DebugTrace(0," Found file %s \n", szPath );

				DWORD dwWait = WaitForSingleObject( QueryShutdownEvent(), 100 );
				if( dwWait == WAIT_OBJECT_0 ) {
					DebugTrace(0,"shutdown signalled: bailing");
					break;
				}
			
			} while ( FindNextFile( hFind, &FileStats ) );

			//_ASSERT(GetLastError() == ERROR_NO_MORE_FILES);

			FindClose( hFind );
		}
	}

	printf("%s done\n", lpDir);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\thrdpl2\src\thrdpool.cpp ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:        thrdpool.cpp
//
//  Contents:    implementation of thrdpool2 library
//
//	Description: See header file.
//
//  Functions:
//
//  History:     09/18/97     Rajeev Rajan (rajeevr)  Created
//
//-----------------------------------------------------------------------------
#include <windows.h>
#include <thrdpl2.h>
#include <dbgtrace.h>
#include <xmemwrpr.h>

CThreadPool::CThreadPool()
{
    m_lInitCount = -1 ;
    m_hCompletionPort = NULL ;
    m_hShutdownEvent = NULL ;
    m_rgThrdpool = NULL ;
    m_rgdwThreadId = NULL;
    m_dwMaxThreads = m_dwNumThreads = 0;
    m_lWorkItems = -1;
    m_hJobDone = NULL;
    m_pvContext = NULL;
    InitializeCriticalSection( &m_csCritItems );
}

CThreadPool::~CThreadPool()
{
    _ASSERT( m_lInitCount == -1 ) ;
    _ASSERT( m_hCompletionPort == NULL ) ;
    _ASSERT( m_hShutdownEvent == NULL ) ;
    _ASSERT( m_rgThrdpool == NULL );
    _ASSERT( m_dwMaxThreads == 0 );
    _ASSERT( m_dwNumThreads == 0 );
    _ASSERT( m_lWorkItems == -1 );
    _ASSERT( m_hJobDone == NULL );
    _ASSERT( m_pvContext == NULL );
    DeleteCriticalSection( &m_csCritItems );
}

BOOL
CThreadPool::Initialize( DWORD dwConcurrency, DWORD dwMaxThreads, DWORD dwInitThreads )
{
	TraceFunctEnter("CThreadPool::Initialize");

    _ASSERT( dwMaxThreads >= dwInitThreads);
	if( InterlockedIncrement( &m_lInitCount ) == 0 )
	{
        _ASSERT( m_hCompletionPort == NULL ) ;
        _ASSERT( m_hShutdownEvent == NULL ) ;
        _ASSERT( m_rgThrdpool == NULL );

		//
		//	called for the first time - go ahead with initialization
		//
		m_hCompletionPort = CreateIoCompletionPort(
											INVALID_HANDLE_VALUE,
											NULL,
											0,
											dwConcurrency
											);

		if( !m_hCompletionPort ) {
			ErrorTrace(0, "Failed to create completion port: GetLastError is %d", GetLastError());
			return FALSE ;
		}

    	//
	    //	create shutdown event
	    //
	    if( !(m_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL) ) ) {
		    ErrorTrace(0,"Failed to create shutdown event");
    	    goto err_exit;
	    }

        m_rgThrdpool = XNEW HANDLE [dwMaxThreads];
        if( m_rgThrdpool == NULL ) {
            ErrorTrace(0,"Failed to allocate %d HANDLEs", dwMaxThreads);
            goto err_exit;
        }

        m_rgdwThreadId = XNEW DWORD[dwMaxThreads];
        if ( NULL == m_rgdwThreadId ) {
            ErrorTrace(0, "Failed to allocate %d dwords", dwMaxThreads );
            goto err_exit;
        }

        m_dwMaxThreads = dwMaxThreads;
        ZeroMemory( (PVOID)m_rgThrdpool, dwMaxThreads*sizeof(HANDLE) );

        _VERIFY( GrowPool( dwInitThreads ) );

        //for( i=0; i<m_dwNumThreads; i++ ) {
	    //    _VERIFY( ResumeThread( m_rgThrdpool[i] ) != 0xFFFFFFFF );
        //}

	} else
	{
		//
		//	bogus Init or already called
		//
		InterlockedDecrement( &m_lInitCount );
		return FALSE ;
	}

	DebugTrace(0,"Created completion port 0x%x", m_hCompletionPort);
	TraceFunctLeave();

	return TRUE ;

err_exit:

    //
    //  Failed init - cleanup partial stuff
    //

    _VERIFY( Terminate( TRUE ) );
    return FALSE;
}

BOOL
CThreadPool::Terminate( BOOL fFailedInit, BOOL fShrinkPool )
{
    DWORD i;
	TraceFunctEnter("CThreadPool::Terminate");

	if( InterlockedDecrement( &m_lInitCount ) < 0 )
	{
		//
		//	Init has been called so go ahead with termination
        //
        if( !fFailedInit ) {
		    //  Signal worker threads to stop and wait for them..
    	    //	this depends on derived class completion routines
	        //	checking this event - if they dont, we will block
	        //	till the thread finishes.
	        //
    	    _VERIFY( SetEvent( m_hShutdownEvent ) );
            if ( fShrinkPool ) ShrinkPool( m_dwNumThreads );

            DWORD dwNumHandles = 0;
            for(i=0;i<m_dwMaxThreads;i++) {
                if( m_rgThrdpool[i] ) dwNumHandles++;
            }

#ifdef DEBUG
            for( i=0; i<dwNumHandles;i++) {
                _ASSERT( m_rgThrdpool[i] != NULL );
            }
            for( i=dwNumHandles;i<m_dwMaxThreads;i++) {
                _ASSERT( m_rgThrdpool[i] == NULL );
            }
#endif
            //
            // Before wait for multiple object, I should make sure that
            // I am not waiting on myself
            //
            DWORD dwThreadId = GetCurrentThreadId();
            DWORD dwTemp;
            HANDLE hTemp;
            for ( DWORD i = 0; i < dwNumHandles; i++ ) {
                if ( m_rgdwThreadId[i] == dwThreadId ) {
                    dwTemp = m_rgdwThreadId[i];
                    hTemp = m_rgThrdpool[i];
                    m_rgdwThreadId[i] = m_rgdwThreadId[dwNumHandles-1];
                    m_rgThrdpool[i] = m_rgThrdpool[dwNumHandles-1];
                    m_rgdwThreadId[dwNumHandles-1] = dwTemp;
                    m_rgThrdpool[dwNumHandles-1] = hTemp;
                    dwNumHandles--;
                    break;
                }
            }

	        //
	        //	wait for worker threads to terminate
	        //
	        if ( dwNumHandles > 0 ) {
	            DWORD dwWait = WaitForMultipleObjects( dwNumHandles, m_rgThrdpool, TRUE, INFINITE);
	            if(WAIT_FAILED == dwWait) {
		            ErrorTrace(0,"WFMO: returned %d: error is %d", dwWait, GetLastError());
		            _ASSERT( FALSE );
	            }
	        }
        }

        //
        //  Release stuff
        //
        if( m_hCompletionPort ) {
		    _VERIFY( CloseHandle( m_hCompletionPort ) );
            m_hCompletionPort = NULL;
        }

        if( m_hShutdownEvent ) {
            _VERIFY( CloseHandle( m_hShutdownEvent ) );
            m_hShutdownEvent = NULL;
        }

        if( m_hJobDone ) {
            _VERIFY( CloseHandle( m_hJobDone ) );
            m_hJobDone = NULL;
        }

        if( m_rgThrdpool ) {
            for( i=0; i<m_dwMaxThreads; i++) {
                if( m_rgThrdpool[i] ) {
	                _VERIFY( CloseHandle(m_rgThrdpool[i]) );
                    m_rgThrdpool[i] = NULL;
                }
            }

            XDELETE [] m_rgThrdpool;
            XDELETE [] m_rgdwThreadId;
            m_rgThrdpool = NULL;
            m_dwNumThreads = m_dwMaxThreads = 0;
        }

	    return TRUE ;
    }

	return FALSE ;
}

DWORD __stdcall CThreadPool::ThreadDispatcher(PVOID pvThrdPool)
{
	DWORD dwBytesTransferred;
	DWORD_PTR dwCompletionKey;
	DWORD dwWait;
	LPOVERLAPPED lpo;

	//
	//	get pointer to this CThreadPool object
	//
	CThreadPool *pThrdPool = (CThreadPool *) pvThrdPool;

	TraceFunctEnter("CThreadPool::ThreadDispatcher");

	do
	{
		//
		//	wait for work items to be queued
		//
		if( !GetQueuedCompletionStatus(
									pThrdPool->QueryCompletionPort(),
									&dwBytesTransferred,
									&dwCompletionKey,
									&lpo,
									INFINITE				// wait timeout
									) )
		{
			ErrorTrace(0,"GetQueuedCompletionStatus() failed: error: %d", GetLastError());
			_ASSERT( FALSE );
		}

		//
		//	check for termination packet
		//
		if( dwCompletionKey == NULL ) {
			DebugTrace(0,"Received termination packet - bailing");
            //
            //  reduce the thread count
            //
            pThrdPool->m_dwNumThreads--;

            //
            // If I am the last thread to be shutdown, call the auto-shutdown
            // interface.  Some users of thread pool may not care about this
            //
            if ( pThrdPool->m_dwNumThreads == 0 )
                pThrdPool->AutoShutdown();

			break;
		}

		//
		//	check for termination signal
		//
		dwWait = WaitForSingleObject( pThrdPool->QueryShutdownEvent(), 0 );

		if( WAIT_TIMEOUT == dwWait ) {
			DebugTrace(0,"Calling WorkCompletion() routine");

    		//
	    	//	call derived class method to process work completion
		    //
			pThrdPool->WorkCompletion( (PVOID)dwCompletionKey );
		}

        //  If we are done with all work items, release any threads waiting on this job
        EnterCriticalSection( &pThrdPool->m_csCritItems );
        if( InterlockedDecrement( &pThrdPool->m_lWorkItems ) < 0 ) {
            //DebugTrace(0,"Setting job event: count is %d", pThrdPool->m_lWorkItems );
            _VERIFY( SetEvent( pThrdPool->m_hJobDone ) );
        }
        LeaveCriticalSection( &pThrdPool->m_csCritItems );

	} while( TRUE );

	return 0;
}

BOOL CThreadPool::PostWork(PVOID pvWorkerContext)
{
	TraceFunctEnter("CThreadPool::PostWork");

	_ASSERT( m_rgThrdpool );
	_ASSERT( m_hCompletionPort );

    if( pvWorkerContext != NULL ) {
        //  Bump count of work items since this job began
        EnterCriticalSection( &m_csCritItems );
        if( InterlockedIncrement( (LPLONG)&m_lWorkItems ) == 0 ) {
            //DebugTrace(0,"Resetting job event: count is %d", m_lWorkItems );
            ResetEvent( m_hJobDone );
        }
        LeaveCriticalSection( &m_csCritItems );
    }

	if( !PostQueuedCompletionStatus(
								m_hCompletionPort,
								0,
								(DWORD_PTR)pvWorkerContext,
								NULL
								) )
	{
        if( pvWorkerContext != NULL ) {
            //  Compensate for the increment....
            //  Last guy out releases the thread waiting on this job.
            if( InterlockedDecrement( (LPLONG)&m_lWorkItems ) < 0 ) {
                //DebugTrace(0,"Setting job event: count is %d", m_lWorkItems );
                _VERIFY( SetEvent( m_hJobDone ) );
            }
        }

		ErrorTrace(0,"PostQCompletionStatus() failed: error: %d", GetLastError());
		return FALSE ;
	}

	return TRUE;
}	

BOOL CThreadPool::ShrinkPool( DWORD dwNumThreads )
{
    TraceFunctEnter("CThreadPool::ShrinkPool");

    if( dwNumThreads >= m_dwNumThreads ) {
        dwNumThreads = m_dwNumThreads;
    }

    for( DWORD i=0; i<dwNumThreads; i++ ) {
        _VERIFY( PostWork( NULL ) );
    }

    return TRUE;
}

VOID CThreadPool::ShrinkAll()
{
    TraceFunctEnter( "CThreadPool::ShrinkAll" );
    ShrinkPool( m_dwNumThreads );
    TraceFunctLeave();
}

BOOL CThreadPool::GrowPool( DWORD dwNumThreads )
{
    TraceFunctEnter("CThreadPool::GrowPool");

    if( dwNumThreads > m_dwMaxThreads ) {
        dwNumThreads = m_dwMaxThreads;
    }

    //
    //  We will try and grow the pool by dwNumThreads.
    //  Scan the handle list and create a thread for
    //  every available slot we have.
    //

    DebugTrace(0,"Attempting to grow pool by %d threads", dwNumThreads);
    for( DWORD i=0; i<m_dwMaxThreads && dwNumThreads != 0; i++) {
        //
        //  If current slot is non-NULL, handle in slot may be
        //  signalled, so close it and grab the slot.
        //
        if( m_rgThrdpool[i] ) {
            DWORD dwWait = WaitForSingleObject( m_rgThrdpool[i], 0 );
            if( dwWait == WAIT_OBJECT_0 ) {
                DebugTrace(0,"Thread %d has terminated: closing handle", i+1);
                _VERIFY( CloseHandle(m_rgThrdpool[i]) );
                m_rgThrdpool[i] = NULL;
            }
        }

        //
        //  If current slot is NULL, it is available for a new thread
        //
        if( m_rgThrdpool[i] == NULL ) {
	        //DWORD dwThreadId;
	        if (!(m_rgThrdpool[i] = ::CreateThread(
                                                NULL,
			        					        0,
				        				        ThreadDispatcher,
					            		        this,
							        	        0, //CREATE_SUSPENDED,
								                &m_rgdwThreadId[i]))) {
		        ErrorTrace(0,"Failed to create thread: error: %d", GetLastError());
                _ASSERT( FALSE );
	        }
            dwNumThreads--;
            m_dwNumThreads++;
        }
    }

    if( dwNumThreads )
        DebugTrace(0,"Failed to create %d threads", dwNumThreads );

    return TRUE;
}

VOID
CThreadPool::BeginJob( PVOID pvContext )
{
    TraceFunctEnter("CThreadPool::BeginJob");

    if( m_hJobDone == NULL ) {
        m_hJobDone = CreateEvent( NULL, FALSE, TRUE, NULL );
        _ASSERT( m_hJobDone );
    } else {
        SetEvent( m_hJobDone );
    }

    m_lWorkItems = -1;
    m_pvContext  = pvContext;
}

DWORD
CThreadPool::WaitForJob( DWORD dwTimeout )
{
    TraceFunctEnter("CThreadPool::WaitForJob");
    DWORD dwWait = WaitForSingleObject( m_hJobDone, dwTimeout );
    if( WAIT_OBJECT_0 == dwWait ) {
        m_pvContext = NULL;
    }
    return dwWait;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\trace\asynctrc.c ===
/*----------------------------------------------------------------------
    ASYNCTRC.C
        Implementation of the async tracing library

    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        gordm          Gord Mangione

    History:
        01/30/95 gordm      Created.
----------------------------------------------------------------------*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#define _DBGTRACE_DLL_IMPLEMENTATION

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

//
// #define  TRACE_ENABLED
//
#include "traceint.h"
#include "randint.h"

//
// Per Process global variables
//
PENDQ   PendQ;
BOOL    fInitialized;
HANDLE  hShutdownEvent;
DWORD   dwInitializations = 0;

CHAR    mszModules[MODULES_BUFFER_SIZE] = {0};

// critical section to protect against the race condition
// where one service is starting and a second service is
// terminating.
CRITICAL_SECTION g_csInitialize;

//
// critical section to protect reentracy on Write routine
// Also used by the signal thread to ensure that no threads
// are using hFile as it dynamically opens and closes trace file.
// During Async mode the background thread will be able to grab
// this critSec each time without waiting unless we're in the
// process of shutting down.
//
CRITICAL_SECTION critSecWrite;


//
// critical section to protect reentracy on Flush routine
//
CRITICAL_SECTION critSecFlush;


//
// exported trace flag used by trace macros to determine if the trace
// statement should be executed
//
DbgTraceDLL DWORD   __dwEnabledTraces;

DWORD   dwMaxFileSize;
DWORD   dwNumTraces;
DWORD   dwTraceOutputType;
DWORD   dwAsyncTraceFlag;
int     nAsyncThreadPriority;
DWORD   dwIncrementSize;

DWORD   dwTlsIndex = 0xFFFFFFFF;

//
// pointer to the previous top level exception handler
//
LPTOP_LEVEL_EXCEPTION_FILTER    lpfnPreviousFilter = NULL;


//
// Internal Function to debugger tracing if DEBUG is defined.
// see traceint.h for the INT_TRACE macro which can be
// inserted at the appropriate point and has the same
// parameters as printf.
//

#ifdef TRACE_ENABLED

void CDECL InternalTrace( const char *s, ... )
{
    char    sz[256];
    va_list marker;

    va_start( marker, s );

    wvsprintf( sz, s, marker );
    OutputDebugString( sz );

    va_end( marker );
}

#endif


//+---------------------------------------------------------------
//
//  Function:   TopLevelExceptionFilter
//
//  Synopsis:   exception handler to flush the PendQ before hitting
//              the debugger
//
//  Arguments:  see Win32 help file
//
//  Returns:    always returns EXCEPTION_CONTINUE_SEARCH
//
//----------------------------------------------------------------
LONG WINAPI TopLevelExceptionFilter( EXCEPTION_POINTERS *lpExceptionInfo )
{
    DWORD   dwLastError = GetLastError();

    //
    // flush the background queue; ignore the ret code
    //
    FlushAsyncTrace();

    //
    // restore the overwritten last error code
    //
    SetLastError( dwLastError );

    //
    // chain the ret code if there is a previous exception handler
    // else continue the search
    //
    return  lpfnPreviousFilter != NULL ?
            (*lpfnPreviousFilter)( lpExceptionInfo ) :
            EXCEPTION_CONTINUE_SEARCH ;
}




//+---------------------------------------------------------------
//
//  Function:   SetTraceBufferInfo
//
//  Synopsis:   used to set the non-sprintf trace variables
//
//  Arguments:  LPTRACEBUF: target buffer
//              int:        line number of the exception
//              LPSTR:      source file of the exception
//              LPSTR:      function name of the exception
//              DWORD:      type of trace
//
//  Returns:    void
//
//----------------------------------------------------------------
__inline void SetTraceBufferInfo(
        LPTRACEBUF  lpBuf,
        int         iLine,
        LPSTR       pszFile,
        LPSTR       pszFunction,
        DWORD       dwTraceMask,
        DWORD       dwError )
{
    LPSTR   psz;
    WORD    wVariableOffset = 0;
    PFIXEDTR    pFixed = &lpBuf->Fixed;

    lpBuf->dwLastError = dwError;

    pFixed->wSignature = 0xCAFE;
    pFixed->wLength = sizeof(FIXEDTRACE);
    pFixed->wLine = LOWORD( iLine );
    pFixed->dwTraceMask = dwTraceMask;
    pFixed->dwThreadId = GetCurrentThreadId();
    pFixed->dwProcessId = PendQ.dwProcessId;

    GetLocalTime( &pFixed->TraceTime );

    if ( pszFile )
    {
        if ( (psz = strrchr( pszFile, '\\' )) != NULL )
        {
            psz++;  // fully qualified path name - strip path
        }
        else
        {
            psz = pszFile;  // simple file name
        }

        lstrcpyn( lpBuf->Buffer, psz, MAX_FILENAME_SIZE );
        pFixed->wFileNameOffset = sizeof(FIXEDTRACE) + wVariableOffset;
        wVariableOffset = lstrlen( psz ) + 1;
    }
    else
    {
        pFixed->wFileNameOffset = 0;
    }

    if ( pszFunction != NULL )
    {
        lstrcpyn( lpBuf->Buffer + wVariableOffset, pszFunction, MAX_FUNCTNAME_SIZE );

        pFixed->wFunctNameOffset = sizeof(FIXEDTRACE) + wVariableOffset;
        wVariableOffset += lstrlen( pszFunction ) + 1;
    }
    else
    {
        pFixed->wFunctNameOffset = 0;
    }

    //
    // set the current offset into the variable buffer
    //
    pFixed->wVariableLength = wVariableOffset;
}


//+---------------------------------------------------------------
//
//  Function:   CommitTraceBuffer
//
//  Synopsis:   deal with the buffer; either sync write or async queue
//
//  Arguments:  LPTRACEBUF lpBuf: the buffer to commit
//
//  Returns:    void
//
//----------------------------------------------------------------
__inline void CommitTraceBuffer( LPTRACEBUF lpBuf )
{
    DWORD   dwError = lpBuf->dwLastError;

    if ( dwAsyncTraceFlag == 0 )
    {
        WriteTraceBuffer( lpBuf );
        FreeTraceBuffer( lpBuf );
    }
    else
    {
        QueueAsyncTraceBuffer( lpBuf );
    }

    //
    // restore last error before initial Trace call
    //
    SetLastError( dwError );
}

//+---------------------------------------------------------------
//
//  Function:   GetWorldSecurityAttributes
//
//  Synopsis:   code is cut and pasted from the Win32 SDK help files
//
//  Arguments:  void
//
//  Returns:    static security attributes for Everyone access
//
//----------------------------------------------------------------
// Pragma is being used for a Temporary fix for VC 5.0 bug DS98 #828.
// Turn off when bug is fixed.

#pragma optimize ("", off)

LPSECURITY_ATTRIBUTES GetWorldSecurityAttributes()
{
static SECURITY_ATTRIBUTES SecurityAttrib;
static SECURITY_DESCRIPTOR SecurityDesc;

    FillMemory( (char*)&SecurityDesc, sizeof(SECURITY_DESCRIPTOR), 0 );

    if ( InitializeSecurityDescriptor(  &SecurityDesc,
                                        SECURITY_DESCRIPTOR_REVISION) )
    {
        //
        // Add a NULL disc. ACL to the security descriptor.
        //
        if ( SetSecurityDescriptorDacl( &SecurityDesc,
                                        TRUE,   // specifying a disc. ACL
                                        (PACL)NULL,
                                        FALSE)) // not a default disc. ACL
        {
            SecurityAttrib.nLength = sizeof(SECURITY_ATTRIBUTES);
            SecurityAttrib.lpSecurityDescriptor = &SecurityDesc;
            SecurityAttrib.bInheritHandle = FALSE;

            return  &SecurityAttrib;
        }
    }
    return  (LPSECURITY_ATTRIBUTES) NULL;
}
#pragma optimize ("", on)





//+---------------------------------------------------------------
//
//  Function:   DllEntryPoint
//
//  Synopsis:   only relevence is allocating thread local storage var
//
//  Arguments:  see Win32 SDK
//
//  Returns:    see Win32 SDK
//
//----------------------------------------------------------------
DbgTraceDLL BOOL WINAPI DllEntryPoint( HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved )
{
    //
    // InitAsyncTrace and TermAsyncTrace cannot be called from this entrypoint
    // because they create and interact with background threads
    // See CreateThread in Win32 Help file for more info
    //
    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:
            InitializeCriticalSection(&g_csInitialize);
            return  TRUE;
//          return  InitAsyncTrace();

        case DLL_THREAD_ATTACH:
            TlsSetValue( dwTlsIndex, (LPVOID)NULL );
            TlsSetValue( dwRandFailTlsIndex, (LPVOID)NULL );
            break;

        case DLL_PROCESS_DETACH:
            if (lpReserved == NULL)
                DeleteCriticalSection(&g_csInitialize);
//          TermAsyncTrace();
            return  FALSE;
    }
    return  TRUE;
}



//+---------------------------------------------------------------
//
//  Function:   SetAsyncTraceParams
//
//  Synopsis:   exported function to setup trace buffer with
//              required fields
//
//              This is the first call for a trace statement.
//              Second call is different for strings or binary
//
//  Arguments:  LPSTR:      source file of the exception
//              int:        line number of the exception
//              LPSTR:      function name of the exception
//              DWORD:      type of trace
//
//  Returns:    returns a BOOL 1 if successful; 0 on failure
//
//  Note:       Feb 24, 1999. This function obsoleted by SetAsyncTraceParamsEx.
//              This function is retained purely for code that linked with
//              this dll, but won't be rebuilt to call SetAsyncTraceParamsEx.
//
//----------------------------------------------------------------
DbgTraceDLL int WINAPI SetAsyncTraceParams( LPSTR pszFile,
                                            int iLine,
                                            LPSTR pszFunction,
                                            DWORD dwTraceMask )
{
    LPTRACEBUF  lpBuf;
    DWORD       dwError = GetLastError();

    if ( fInitialized == FALSE )
    {
        return  0;
    }

    if ( ShouldLogModule("ALL") == FALSE )
    {
        return  0;

    }

    if ( lpBuf = GetTraceBuffer() )
    {

        SetTraceBufferInfo( lpBuf, iLine, pszFile, pszFunction, dwTraceMask, dwError );
        TlsSetValue( dwTlsIndex, (LPVOID)lpBuf );

        return  1;
    }
    else    return  0;
}


//+---------------------------------------------------------------
//
//  Function:   SetAsyncTraceParamsEx
//
//  Synopsis:   exported function to setup trace buffer with
//              required fields.
//
//              This is the first call for a trace statement.
//              Second call is different for strings or binary
//
//  Arguments:  LPSTR:      module name
//              LPSTR:      source file of the exception
//              int:        line number of the exception
//              LPSTR:      function name of the exception
//              DWORD:      type of trace
//
//  Returns:    returns a BOOL 1 if successful; 0 on failure
//
//----------------------------------------------------------------
DbgTraceDLL int WINAPI SetAsyncTraceParamsEx(
                                            LPSTR pszModule,
                                            LPSTR pszFile,
                                            int iLine,
                                            LPSTR pszFunction,
                                            DWORD dwTraceMask )
{
    LPTRACEBUF  lpBuf;
    DWORD       dwError = GetLastError();

    if ( fInitialized == FALSE )
    {
        return  0;
    }

    if (ShouldLogModule(pszModule) == FALSE)
    {
        return 0;
    }

    if ( lpBuf = GetTraceBuffer() )
    {

        SetTraceBufferInfo( lpBuf, iLine, pszFile, pszFunction, dwTraceMask, dwError );
        TlsSetValue( dwTlsIndex, (LPVOID)lpBuf );

        return  1;
    }
    else    return  0;
}


//+---------------------------------------------------------------
//
//  Function:   AsyncStringTrace
//
//  Synopsis:   exported function to finish setting up trace buffer
//              with optional fields for sprintf style traces
//
//  Arguments:  LPARAM:     32bit trace param used app level filtering
//              LPCSTR:     format string
//              va_list:    marker for vsprintf functions
//
//  Returns:    returns length of the trace statement
//
//----------------------------------------------------------------
DbgTraceDLL int WINAPI AsyncStringTrace(LPARAM lParam,
                                        LPCSTR szFormat,
                                        va_list marker )
{
    LPTRACEBUF  lpBuf;
    PFIXEDTR    pFixed;
    int         iLength;
    int         iMaxLength;

    if ( fInitialized == FALSE )
    {
        return  0;
    }

    if ( (lpBuf = (LPTRACEBUF)TlsGetValue( dwTlsIndex )) != NULL )
    {
        TlsSetValue( dwTlsIndex, NULL );

        pFixed = &lpBuf->Fixed;
        iMaxLength = MAX_VARIABLE_SIZE - pFixed->wVariableLength;
        iLength =
            _vsnprintf( lpBuf->Buffer + pFixed->wVariableLength,
                        iMaxLength,
                        szFormat,
                        marker ) + 1;

        if ( iLength == 0 || iLength == iMaxLength + 1 )
        {
            iLength = iMaxLength;
            lpBuf->Buffer[MAX_VARIABLE_SIZE-1] = '\0';
        }

        _ASSERT( iLength <= iMaxLength );

        pFixed->wBinaryOffset = sizeof(FIXEDTRACE) + pFixed->wVariableLength;
        pFixed->wVariableLength += LOWORD( (DWORD)iLength );
        pFixed->wBinaryType = TRACE_STRING;
        pFixed->dwParam = (DWORD)lParam; // This is a 32-bit flag so the cast is OK

        //
        // this is a specific area where the app can overwrite
        // data.  Could have used vnsprintf to avoid the overwrite
        // but this woudl have dragged in the C runtime and
        // introduced its overhead and own critical sections
        //
        ASSERT( pFixed->wVariableLength <= MAX_VARIABLE_SIZE );

        CommitTraceBuffer( lpBuf );

        //
        // need to use dwLength since we relinquish lpBuf
        // after we return from QueueAsyncTraceBuffer which
        // cannot fail
        //
        return  iLength;
    }
    else    return  0;
}



//+---------------------------------------------------------------
//
//  Function:   AsyncBinaryTrace
//
//  Synopsis:   exported function to finish setting up trace buffer
//              with optional fields for binary traces
//
//  Arguments:  LPARAM:     32bit trace param used app level filtering
//              DWORD:      type of binary data ( ie Message, User... )
//              LPBYTE:     ptr to the data
//              DWORD:      length of the data
//
//  Returns:    returns length of the trace statement
//
//----------------------------------------------------------------
DbgTraceDLL int WINAPI AsyncBinaryTrace(LPARAM  lParam,
                                        DWORD   dwBinaryType,
                                        LPBYTE  pbData,
                                        DWORD   cbData )
{
    LPTRACEBUF  lpBuf;
    WORD        wLength;
    PFIXEDTR    pFixed;

    if ( fInitialized == FALSE )
    {
        return  0;
    }

    if ( (lpBuf = (LPTRACEBUF)TlsGetValue( dwTlsIndex )) != NULL )
    {
        TlsSetValue( dwTlsIndex, NULL );

        pFixed = &lpBuf->Fixed;

        wLength = LOWORD( min( cbData, MAX_BUFFER_SIZE ) );
        CopyMemory( lpBuf->Buffer + pFixed->wVariableLength, pbData, wLength );

        pFixed->wBinaryOffset = sizeof(FIXEDTRACE) + pFixed->wVariableLength;
        pFixed->wVariableLength += wLength;
        pFixed->wBinaryType = LOWORD( dwBinaryType );
        pFixed->dwParam = (DWORD)lParam; // This is a 32-bit flag so the cast is OK

        CommitTraceBuffer( lpBuf );

        //
        // need to use dwLength since we relinquish lpBuf
        // after we return from QueueAsyncTraceBuffer which
        // cannot fail
        //
        return  (int)wLength;
    }
    else    return  0;
}



//+---------------------------------------------------------------
//
//  Function:   FlushAsyncTrace
//
//  Synopsis:   exported function to empty the pending queue.  All
//              threads which call this function block until the
//              queue is empty
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
DllExport BOOL WINAPI FlushAsyncTrace( void )
{
static long lPendingFlushs = -1;

    if ( fInitialized == FALSE )
    {
        return  FALSE;
    }
    else
    {
        EnterCriticalSection( &critSecFlush );

        if ( PendQ.dwCount > 0 )
        {
            SetEvent( PendQ.hFlushEvent );

            if ( nAsyncThreadPriority < THREAD_PRIORITY_ABOVE_NORMAL )
            {
                SetThreadPriority(  PendQ.hWriteThread,
                                    THREAD_PRIORITY_ABOVE_NORMAL );
            }

            WaitForSingleObject( PendQ.hFlushedEvent, INFINITE );

            if ( nAsyncThreadPriority < THREAD_PRIORITY_ABOVE_NORMAL )
            {
                SetThreadPriority(  PendQ.hWriteThread,
                                    nAsyncThreadPriority );
            }
            ResetEvent( PendQ.hFlushedEvent );
        }
        LeaveCriticalSection( &critSecFlush );
        return  TRUE;
    }
}




//+---------------------------------------------------------------
//
//  Function:   InitAsyncTrace
//
//  Synopsis:   exported required function to rev things up.
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
DllExport BOOL WINAPI InitAsyncTrace( void )
{
static BOOL bInitializing = FALSE;
    BOOL    bRC = FALSE;
    DWORD   dwThreadId;

    EnterCriticalSection(&g_csInitialize);
    if ( fInitialized )
    {
        //
        // inc the count of successful initializations for this process
        //
        InterlockedIncrement( &dwInitializations );
        LeaveCriticalSection(&g_csInitialize);
        return  TRUE;
    }

    if ( InterlockedExchange( (LPLONG)&bInitializing, (LONG)TRUE )  )
    {
        //
        // inc the count of successful initializations for this process
        //
        InterlockedIncrement( &dwInitializations );
        LeaveCriticalSection(&g_csInitialize);
        return  TRUE;
    }

    // to guard against race condition when the initializing thread is about to execute
    //  'InterlockedExchange( (LPLONG)&bInitializing, (LONG)FALSE )', while
    //  there is another thread that passed the
    // if ( InterlockedExchange( (LPLONG)&bInitializing, (LONG)TRUE )) condition
    //
    if ( fInitialized)
    {
        //
        // inc the count of successful initializations for this process
        //
        InterlockedIncrement( &dwInitializations );

        InterlockedExchange( (LPLONG)&bInitializing, (LONG)FALSE );
        LeaveCriticalSection(&g_csInitialize);
        return  TRUE;
    }

    // will read from registry later
    //
    dwNumTraces = 0;

    PendQ.dwProcessId = GetCurrentProcessId();
    PendQ.hFile = INVALID_HANDLE_VALUE;
    PendQ.cbBufferEnd = 0;
    PendQ.dwThresholdCount = DEFAULT_MAX_FILE_SIZE / AVERAGE_TRACE_SIZE;

    __try {

        InitializeCriticalSection( &PendQ.critSecTail );
        InitializeCriticalSection( &critSecWrite );
        InitializeCriticalSection( &critSecFlush );

        if ( (dwTlsIndex = TlsAlloc()) == 0xFFFFFFFF )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        if ( (dwRandFailTlsIndex = TlsAlloc()) == 0xFFFFFFFF )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        if ( GetTraceFlagsFromRegistry() == FALSE )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        //
        // Initialize the pool of trace buffers
        // must happen after reading the registy
        //
        if ( InitTraceBuffers( PendQ.dwThresholdCount, dwIncrementSize ) == FALSE )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        PendQ.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if ( PendQ.hEvent == NULL )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        //
        // PendQ.hFlushedEvent is manual reset so multiple threads can wait
        //
        PendQ.hFlushedEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( PendQ.hFlushedEvent == NULL )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        PendQ.hFlushEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if ( PendQ.hFlushEvent == NULL )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        //
        // hShutdownEvent is manual reset so multiple threads can be awaken
        //
        hShutdownEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( hShutdownEvent == NULL )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }

        ASSERT( PendQ.hRegNotifyThread == NULL );

        PendQ.hRegNotifyThread =
            CreateThread(   NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)RegNotifyThread,
                            NULL,
                            0,
                            &dwThreadId );

        if ( PendQ.hRegNotifyThread == NULL )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }
        else
        {
            //
            // bumping the priority onthis almost always dorminate thread
            // ensures that trace changes are applied soon after the
            // registry changes
            //
            SetThreadPriority( PendQ.hRegNotifyThread, THREAD_PRIORITY_ABOVE_NORMAL );
        }

        ASSERT( PendQ.hWriteThread == NULL );

        PendQ.hWriteThread =
            CreateThread(   NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)WriteTraceThread,
                            NULL,
                            0,
                            &dwThreadId );

        if ( PendQ.hWriteThread == NULL )
        {
            LeaveCriticalSection(&g_csInitialize);
            return  FALSE;
        }
        else
        {
            //
            // setting the priority on this thread ensures that the
            // physical writing of the traces will not impact performance
            // of the main application task. Default is BELOW_NORMAL although
            // its controlled by a reg entry
            //
            SetThreadPriority( PendQ.hWriteThread, nAsyncThreadPriority );
        }

        PendQ.pHead = PendQ.pTail = (LPTRACEBUF)&PendQ.Special;

        //
        // set our top level exception handler
        //
        lpfnPreviousFilter = SetUnhandledExceptionFilter( TopLevelExceptionFilter );

        fInitialized = TRUE;
        InterlockedExchange( (LPLONG)&bInitializing, (LONG)FALSE );

        //
        // inc the count of successful initializations for this process
        //
        InterlockedIncrement( &dwInitializations );

        bRC = TRUE;
    }
    __finally
    {
        if ( bRC == FALSE )
        {
            DWORD   dwLastError = GetLastError();

            AsyncTraceCleanup();

            SetLastError( dwLastError );
        }
    }

    LeaveCriticalSection(&g_csInitialize);

    return  bRC;
}



//+---------------------------------------------------------------
//
//  Function:   TermAsyncTrace
//
//  Synopsis:   exported required function to wind things down.
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
DllExport BOOL WINAPI TermAsyncTrace( void )
{
    EnterCriticalSection(&g_csInitialize);

    if ( fInitialized )
    {
        if ( InterlockedDecrement( &dwInitializations ) == 0 )
        {
            BOOL fRet;

            fRet = AsyncTraceCleanup();
            LeaveCriticalSection(&g_csInitialize);

            return  fRet;
        }

        LeaveCriticalSection(&g_csInitialize);
        return  TRUE;
    }
    else
    {
        LeaveCriticalSection(&g_csInitialize);
        return  FALSE;
    }
}



//+---------------------------------------------------------------
//
//  Function:   DebugAssert
//
//  Synopsis:   exported required function for enhanced asserts
//
//  Arguments:  DWORD dwLine:       source code line of the _ASSERT
//              LPSTR lpszFunction  source code filename of the _ASSERT
//              LPSTR lpszExpression stringized version of _ASSERT param
//
//  Returns:    void
//
//----------------------------------------------------------------
char  szAssertOutput[512];
DllExport void WINAPI DebugAssert(  DWORD dwLine,
                                    LPSTR lpszFunction,
                                    LPSTR lpszExpression )
{
    DWORD   dwError = GetLastError();

    wsprintf( szAssertOutput, "\nASSERT: %s,\n File: %s,\n Line: %d\n Error: %d\n\n",
            lpszExpression, lpszFunction, dwLine, dwError );

    OutputDebugString( szAssertOutput );

    SetLastError( dwError );

    DebugBreak();
}



//+---------------------------------------------------------------
//
//  Function:   QueueAsyncTraceBuffer
//
//  Synopsis:   Routine to implement the appending of TRACEBUF to
//              the FIFO PendQ
//
//  Arguments:  LPTRACEBUF: the buffer
//
//  Returns:    void
//
//----------------------------------------------------------------
void QueueAsyncTraceBuffer( LPTRACEBUF lpBuf )
{
    LPTRACEBUF  pPrevTail;

    ASSERT( lpBuf != NULL );
    ASSERT( lpBuf->dwSignature == TRACE_SIGNATURE );

    lpBuf->pNext = NULL;

    EnterCriticalSection( &PendQ.critSecTail );

    //
    // number of buffers on the queue can only decrease while
    // in this critical section since WriteTraceThread can continue
    // to pull buffers from the queue.
    //
    // WriteAsyncThread will not write this buffer until it has
    // been appended to the queue by incrementing PendQ.dwCount
    //
    // PendQ.pTail is only modified here and in a special case on the
    // background writer thread.  The special case is when Special needs
    // to be moved from the Head of the queue to the Tail.  Only during
    // this brief special case can both the background writer and the
    // foreground appender thread be operating on the same trace buffer.
    //

    pPrevTail = PendQ.pTail;
    pPrevTail->pNext = PendQ.pTail = lpBuf;

    LeaveCriticalSection( &PendQ.critSecTail );

    InterlockedIncrement( &PendQ.dwCount );

    //
    // wake up WriteTraceThread if necessary. It may not be since
    // WriteTraceThread will always empty its queue before sleeping
    //
    SetEvent( PendQ.hEvent );
}



//+---------------------------------------------------------------
//
//  Function:   DequeueAsyncTraceBuffer
//
//  Synopsis:   Routine to dequeue the top Trace Buffer from
//              the FIFO PendQ
//
//  Arguments:  void
//
//  Returns:    LPTRACEBUF: the buffer
//
//----------------------------------------------------------------
LPTRACEBUF  DequeueAsyncTraceBuffer( void )
{
    LPTRACEBUF  lpBuf;
    LPTRACEBUF  pPrevTail;

    //
    // check to see if Special is at the head of the queue. If so, move
    // it to the end of the queue
    //
    if ( PendQ.pHead == (LPTRACEBUF)&PendQ.Special )
    {
        //
        // need to NULL Special.pNext before the Exchange so the list
        // is terminated as soon as we do the exchange.  We can lazily
        // set the old Tails next pointer since we're the only thread
        // that would dereference this pointer once its not the last
        // buffer in the FIFO
        //
        PendQ.pHead = PendQ.Special.pNext;
        PendQ.Special.pNext = NULL;

        EnterCriticalSection( &PendQ.critSecTail );
        //
        // see comment in QueueAsyncTraceBuffer to describe why we
        // to grab the Tail critical section here.  If we did not
        // include this Special buffer then we would have to grab
        // the critSec each time.
        //
        pPrevTail = PendQ.pTail;
        pPrevTail->pNext = PendQ.pTail = (LPTRACEBUF)&PendQ.Special;

        LeaveCriticalSection( &PendQ.critSecTail );
    }

    //
    // again no critical section required since we're the only thread
    // accessing these PendQ.pHead.  This needs to be remembered if we
    // were to add integratity checking to the queues at a later date
    // since this queue is effectively in a corrupt state.
    //
    lpBuf = PendQ.pHead;
    PendQ.pHead = lpBuf->pNext;
    InterlockedDecrement( &PendQ.dwCount );

    ASSERT( lpBuf != NULL );
    ASSERT( lpBuf->dwSignature == TRACE_SIGNATURE );

    return  lpBuf;
}



//+---------------------------------------------------------------
//
//  Function:   AsyncTraceCleanup
//
//  Synopsis:   internla routine to clean things up
//              the FIFO PendQ
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
BOOL AsyncTraceCleanup( void )
{
    HANDLE  hThreads[2];
    int     nObjects = 0;
    DWORD   dw;

    INT_TRACE( "AsyncTraceCleanup Enter\n" );

    if ( InterlockedExchange( &PendQ.fShutdown, TRUE ) == TRUE )
    {
        return  FALSE;
    }

    if ( dwTlsIndex != 0xFFFFFFFF )
    {
        TlsFree( dwTlsIndex );
    }

    if ( dwRandFailTlsIndex != 0xFFFFFFFF )
    {
        TlsFree( dwRandFailTlsIndex );
    }

    //
    // restore the initial Exception filter; NULL signifies use the default
    //
    SetUnhandledExceptionFilter( lpfnPreviousFilter );

    if ( hShutdownEvent != NULL )
    {
        INT_TRACE( "AsyncTraceCleanup Calling SetEvent( hShutdownEvent )\n" );
        SetEvent( hShutdownEvent );
        INT_TRACE( "AsyncTraceCleanup Called SetEvent: Error: 0x%X\n", GetLastError() );
    }

    if ( PendQ.hWriteThread != NULL )
    {
        hThreads[nObjects++] = PendQ.hWriteThread;
    }

    if ( PendQ.hRegNotifyThread != NULL )
    {
        hThreads[nObjects++] = PendQ.hRegNotifyThread;
    }

    //
    // allow background threads forever to shutdown
    //
    if ( nObjects != 0 )
    {
        INT_TRACE( "AsyncTraceCleanup Calling WFMO\n" );
        dw = WaitForMultipleObjects(nObjects,
                                    hThreads,
                                    TRUE,
                                    INFINITE );
        INT_TRACE( "AsyncTraceCleanup Called WFMO: dw: 0x%X  Error: 0x%X\n",
                    dw, GetLastError() );
    }

    if ( PendQ.hWriteThread != NULL )
    {
        CloseHandle( PendQ.hWriteThread );
        PendQ.hWriteThread = NULL;
    }

    if ( PendQ.hRegNotifyThread != NULL )
    {
        CloseHandle( PendQ.hRegNotifyThread );
        PendQ.hRegNotifyThread = NULL;
    }

    if ( PendQ.hEvent != NULL )
    {
        CloseHandle( PendQ.hEvent );
        PendQ.hEvent = NULL;
    }

    if ( PendQ.hFlushEvent != NULL )
    {
        CloseHandle( PendQ.hFlushEvent );
        PendQ.hFlushEvent = NULL;
    }

    if ( PendQ.hFlushedEvent != NULL )
    {
        CloseHandle( PendQ.hFlushedEvent );
        PendQ.hFlushedEvent = NULL;
    }

    if ( hShutdownEvent != NULL )
    {
        CloseHandle( hShutdownEvent );
        hShutdownEvent = NULL;
    }

#if FALSE

    INT_TRACE( "TailCritSec  - Contention: %d, Entry: %d\n",
                PendQ.critSecTail.DebugInfo->ContentionCount,
                PendQ.critSecTail.DebugInfo->EntryCount );

    INT_TRACE( "WriteCritSec - Contention: %d, Entry: %d\n",
                critSecWrite.DebugInfo->ContentionCount,
                critSecWrite.DebugInfo->EntryCount );

    INT_TRACE( "FlushCritSec - Contention: %d, Entry: %d\n",
                critSecFlush.DebugInfo->ContentionCount,
                critSecFlush.DebugInfo->EntryCount );
#endif

    DeleteCriticalSection( &PendQ.critSecTail );
    DeleteCriticalSection( &critSecWrite );
    DeleteCriticalSection( &critSecFlush );

    if ( PendQ.hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( PendQ.hFile );
    }

    PendQ.pHead = PendQ.pTail = (LPTRACEBUF)&PendQ.Special;
    PendQ.Special.pNext = (LPTRACEBUF)NULL;

    //
    // free up the trace buffer CPool
    //
    TermTraceBuffers();

    INT_TRACE( "Total number of traces: %d\n", dwNumTraces );

    InterlockedExchange( &PendQ.fShutdown, FALSE );
    fInitialized = FALSE;

    return TRUE;
}


//+---------------------------------------------------------------
//
//  Function:   FlushBufferedWrites
//
//  Synopsis:   internal routine to write the PendQ temporary buffer
//              to disk.  Used to avoid multiple OS calls and increase
//              the write buffers.
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
BOOL FlushBufferedWrites( void )
{
    BOOL        b = TRUE;
    DWORD       dwBytes;
    BOOL        bRetry = TRUE;

    //
    // need to lock the file since multiple process on multiple machines
    // may be tracing the same file and both writes have to complete as one.
    //

    if ( PendQ.cbBufferEnd )
    {
        DWORD dwOffset;

        ASSERT( PendQ.cbBufferEnd < MAX_WRITE_BUFFER_SIZE );

        dwOffset = SetFilePointer( PendQ.hFile, 0, 0, FILE_END );

        //
        // if the file is too big then we need to truncate it
        //
        if (dwOffset > dwMaxFileSize)
        {
            SetFilePointer(PendQ.hFile, 0, 0, FILE_BEGIN);
            SetEndOfFile(PendQ.hFile);
        }
try_again:
        b = WriteFile(  PendQ.hFile,
                        PendQ.Buffer,
                        PendQ.cbBufferEnd,
                        &dwBytes,
                        NULL );

        if ( b == FALSE || dwBytes != PendQ.cbBufferEnd )
        {
            DWORD   dwError = GetLastError();

            if( dwError && bRetry )
            {
                bRetry = FALSE;
                Sleep( 100 );
                goto try_again;
            }
//          ASSERT( FALSE );
            INT_TRACE( "Error writing to file: %d, number of bytes %d:%d\n",
                        dwError,
                        PendQ.cbBufferEnd,
                        dwBytes );
        }
    }

    PendQ.cbBufferEnd = 0;

    return  b;
}


//+---------------------------------------------------------------
//
//  Function:   WriteTraceBuffer
//
//  Synopsis:   internal routine to route the trace info to the
//              appropriate trace log
//
//  Arguments:  LPTRACEBUF: the buffer to write
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
BOOL WriteTraceBuffer( LPTRACEBUF lpBuf )
{
    ASSERT( lpBuf != NULL );
    ASSERT( lpBuf->dwSignature == TRACE_SIGNATURE );

    InterlockedIncrement( &dwNumTraces );

    EnterCriticalSection( &critSecWrite );

    if ( IsTraceFile( dwTraceOutputType ) && PendQ.hFile != INVALID_HANDLE_VALUE )
    {
        DWORD   dwWrite;

        //
        // assert must be handled inside critical section
        //
        ASSERT( PendQ.cbBufferEnd+MAX_TRACE_ENTRY_SIZE < MAX_WRITE_BUFFER_SIZE );

        CopyMemory( PendQ.Buffer + PendQ.cbBufferEnd,
                    (char *)&lpBuf->Fixed,
                    dwWrite = sizeof(FIXEDTRACE) + lpBuf->Fixed.wVariableLength );

        PendQ.cbBufferEnd += dwWrite;

        if ( PendQ.cbBufferEnd + MAX_TRACE_ENTRY_SIZE >= MAX_WRITE_BUFFER_SIZE ||
            dwAsyncTraceFlag == 0 )
        {
            FlushBufferedWrites();
        }

    }
    else if ( dwTraceOutputType & TRACE_OUTPUT_DEBUG )
    {
        char    szThread[16];
        LPSTR   lpsz;

        EnterCriticalSection( &critSecWrite );

        wsprintf( szThread, "0x%08X: ", lpBuf->Fixed.dwThreadId );
        OutputDebugString( szThread );

        switch( lpBuf->Fixed.wBinaryType )
        {
        case TRACE_STRING:
            //
            // lstrcat may appear wasteful here; but it is less expensive than an
            // additional call to OutputDebugString( "\r\n" ); which works by
            // raising an exception.
            //
            // although appending \r\n on already full buffer is even worse
            //
            lpsz = lpBuf->Buffer + lpBuf->Fixed.wBinaryOffset - sizeof(FIXEDTRACE);
            OutputDebugString( lpsz );
            OutputDebugString( "\r\n" );
            break;

        case TRACE_BINARY:
            OutputDebugString( "Binary Trace\r\n" );
            break;

        case TRACE_MESSAGE:
            OutputDebugString( "Message Trace\r\n" );
            break;
        }

        LeaveCriticalSection( &critSecWrite );
    }
    else if ( dwTraceOutputType & TRACE_OUTPUT_DISCARD )
    {
        //
        // fastest way to remove buffers. Used to find
        // deadlocks and race conditions
        //
    }
    else if ( dwTraceOutputType & TRACE_OUTPUT_INVALID )
    {
        InterlockedDecrement( &dwNumTraces );
        //
        // unknown trace output type
        //
        ASSERT( FALSE );
    }

    LeaveCriticalSection( &critSecWrite );

    return  TRUE;
}




//+---------------------------------------------------------------
//
//  Function:   FlushAsyncPendingQueue
//
//  Synopsis:   internal routine to empty the PendQ queue from the
//              background thread
//              Assumes it is not called re-entrantly: actually the
//              FIFO queue assumes only one thread dequeues buffers
//
//  Arguments:  void
//
//  Returns:    BOOL: whether it worked
//
//----------------------------------------------------------------
void FlushAsyncPendingQueue( void )
{
    LPTRACEBUF  lpBuf;

    while( PendQ.dwCount > 0 )
    {
        lpBuf = DequeueAsyncTraceBuffer();

        //
        // if we've buffered more than we'll write before
        // truncating the file then throw away the trace
        //
        if ( PendQ.dwCount < PendQ.dwThresholdCount )
        {
            WriteTraceBuffer( lpBuf );
        }
        else
        {
            INT_TRACE( "Discarding traces: %u\n", PendQ.dwCount );
        }

        FreeTraceBuffer( lpBuf );
    }
    FlushBufferedWrites();
}


#define NUM_WRITE_THREAD_OBJECTS    3

//+---------------------------------------------------------------
//
//  Function:   WriteTraceThread
//
//  Synopsis:   background thread routine for pulling and writing
//              trace buffers from PendQ FIFO queue.
//
//  Arguments:  see Win32 SDK - ignored here
//
//  Returns:    DWORD: 0 if we exitted gracefully
//
//----------------------------------------------------------------
DWORD WriteTraceThread( LPDWORD lpdw )
{
    HANDLE      Handles[NUM_WRITE_THREAD_OBJECTS];
    DWORD       dw;

    //
    // preference given to Shutdown, FlushEvent and then the
    // normal buffer event.  This ensures that provide a quick
    // response on both shutdown and to a lesser extent Flush
    // since other threads are waiting for this thread to respond.
    //
    Handles[0] = hShutdownEvent;
    Handles[1] = PendQ.hFlushEvent;
    Handles[2] = PendQ.hEvent;

    INT_TRACE( "WriteTraceThreadId 0x%X\n", GetCurrentThreadId() );

    for ( ;; )
    {
        dw = WaitForMultipleObjects(NUM_WRITE_THREAD_OBJECTS,
                                    Handles,
                                    FALSE,
                                    INFINITE );

        switch( dw )
        {
        //
        // normal signalled event
        //
        case WAIT_OBJECT_0+2:
            FlushAsyncPendingQueue();
            break;

        //
        // signalled by a foreground thread to flush our Q
        //
        case WAIT_OBJECT_0+0:
        case WAIT_OBJECT_0+1:
            FlushAsyncPendingQueue();

            if ( dw == WAIT_OBJECT_0+1 )
            {
                SetEvent( PendQ.hFlushedEvent );
            }
            else
            {
                INT_TRACE( "Exiting WriteTraceThread for hShutdownEvent\n" );
                return  0;
            }
            break;

        default:
            GetLastError();
            ASSERT( FALSE );
        }
    }
    INT_TRACE( "Exiting WriteTraceThread abnormally\n" );
}



//+---------------------------------------------------------------------------
//
//  Function:   ShouldLogModule
//
//  Synopsis:   Figures out whether a particular module is on the list of
//              modules to be logged.
//
//  Arguments:  [szModule] -- Name of module to check
//
//  Returns:    TRUE if module should log, FALSE if logging is disabled for
//              MODULE
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
ShouldLogModule(
    LPCSTR szModule)
{
    LPSTR szEntry;

    //
    // If a list of modules has not been specified, then all modules are to be
    // logged
    //

    if (mszModules[0] == 0) {
         return TRUE;
    }

    //
    // Otherwise, we check to see if the name of the module is in the list
    // mszModule is expected to be a set of NULL terminated strings, with the
    // last string double-null-terminated.
    //

    szEntry = mszModules;

    while (szEntry[0] != 0) {

        if (lstrcmpi(szEntry, szModule) == 0) {
             return TRUE;
        }

        szEntry += (strlen(szEntry) + 1);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\trace\randint.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :

    randint.h

Abstract :

    Random failure internal include file

Author :

    Sam Neely

Revision History :

--*/

#ifdef __cplusplus
extern "C" {
#endif
static const long kDontFail = 0;
extern long nFailRate;
extern DWORD dwRandFailTlsIndex;
extern LONG g_cCallStack;
extern CHAR** g_ppchCallStack;
extern LONG g_iCallStack;
extern const DWORD g_dwMaxCallStack;
extern HANDLE g_hRandFailFile;
extern HANDLE g_hRandFailMutex;
extern CHAR g_szRandFailFile[];
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\trace\registry.c ===
/*----------------------------------------------------------------------
    REGISTRY.C
        Async tracing Registry reading routines

    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        gordm          Gord Mangione

    History:
        01/30/95 gordm      Created.
----------------------------------------------------------------------*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#define _DBGTRACE_DLL_IMPLEMENTATION

#include <windows.h>
#include "traceint.h"
#include "randint.h"


char    szTraceFileName[MAX_PATH];
char    szDebugAsyncTrace[] = "SOFTWARE\\Microsoft\\MosTrace\\CurrentVersion\\DebugAsyncTrace";


extern DbgTraceDLL DWORD       __dwEnabledTraces;

__inline BOOL GetRegDword( HKEY hKey, LPSTR pszValue, LPDWORD pdw )
{
    DWORD   cbData = sizeof( DWORD );
    DWORD   dwType = REG_DWORD;

    return  RegQueryValueEx(hKey,
                            pszValue,
                            NULL,
                            &dwType,
                            (LPBYTE)pdw,
                            &cbData ) == ERROR_SUCCESS && dwType == REG_DWORD;
}



__inline BOOL GetRegString( HKEY hKey, LPSTR pszValue, LPBYTE buf, LPDWORD lpcbData )
{
    DWORD   dwType = REG_SZ;

    return  RegQueryValueEx(hKey,
                            pszValue,
                            NULL,
                            &dwType,
                            buf,
                            lpcbData ) == ERROR_SUCCESS && dwType == REG_SZ;
}


__inline BOOL GetRegMSZ( HKEY hKey, LPSTR pszValue, LPBYTE buf, LPDWORD lpcbData)
{

    DWORD   dwType = REG_MULTI_SZ;

    return  RegQueryValueEx(hKey,
                            pszValue,
                            NULL,
                            &dwType,
                            buf,
                            lpcbData ) == ERROR_SUCCESS && dwType == REG_MULTI_SZ;

}


BOOL GetTraceFlagsFromRegistry( void )
{
static char szNewTraceFileName[MAX_PATH];
static char mszNewModules[MODULES_BUFFER_SIZE];
    DWORD   dwNewEnabledTraces;
    DWORD   dwNewTraceOutputType;
    DWORD   dwNewAsyncTraceFlag;
    DWORD   dwNewHeapIncrementCount;
    int     nNewThreadPriority;
    long    nNewFailRate;
    LONG    cRandFailBuffer;
    HKEY    hkConfig = NULL;
    BOOL    bRC = FALSE;
    DWORD   cbData;
    DWORD   dwDisposition;


    __try
    {
        if ( RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szDebugAsyncTrace,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ,
                    NULL,
                    &hkConfig,
                    &dwDisposition) == ERROR_SUCCESS )
        {
            if ( GetRegDword(   hkConfig,
                                "MaxTraceFileSize",
                                &dwMaxFileSize ) == FALSE )
            {
                dwMaxFileSize = DEFAULT_MAX_FILE_SIZE;
            }

            //
            // determine threshold count based on how we can fit in the file
            //
            PendQ.dwThresholdCount = dwMaxFileSize / AVERAGE_TRACE_SIZE;
            INT_TRACE( "PendQ.dwThresholdCount: %d\n", PendQ.dwThresholdCount );

            //
            // determine the modules to log
            //
            cbData = MODULES_BUFFER_SIZE;
            ZeroMemory(mszNewModules, sizeof(mszNewModules));
            if ( GetRegMSZ( hkConfig, "Modules", mszNewModules, &cbData ) == FALSE) {
                INT_TRACE( "GetRegMSZ: Modules failed: %d\n", GetLastError());
                INT_TRACE( "\tLogging all modules" );
                ZeroMemory(mszNewModules, MODULES_BUFFER_SIZE);
            }

            if ( GetRegDword(   hkConfig,
                                "EnabledTraces",
                                &dwNewEnabledTraces ) == FALSE )
            {
                //
                // Optional reg entry
                // default is existing value of __dwEnabledTraces
                //
                INT_TRACE( "GetRegDword: EnabledTraces failed: %d\n", GetLastError() );
                dwNewEnabledTraces = __dwEnabledTraces;
            }

            if ( GetRegDword(   hkConfig,
                                "OutputTraceType",
                                &dwNewTraceOutputType ) == FALSE )
            {
                //
                // Optional reg entry
                // default is existing value of dwTraceOutputType
                //
                INT_TRACE( "GetRegDword: OutputTraceType failed: %d\n", GetLastError() );
                dwNewTraceOutputType = dwTraceOutputType;
            }

            if ( GetRegDword(   hkConfig,
                                "AsyncTraceFlag",
                                &dwNewAsyncTraceFlag ) == FALSE )
            {
                //
                // Optional reg entry
                // default is existing value of dwAsyncTraceFlag
                //
                INT_TRACE( "GetRegDword: AsyncTraceFlag failed: %d\n", GetLastError() );
                dwNewAsyncTraceFlag = dwAsyncTraceFlag;
            }

            if (GetRegDword(hkConfig,
                            "HeapIncrementCount",
                            (LPDWORD)&dwNewHeapIncrementCount ) == FALSE ||
                dwNewHeapIncrementCount == 0 )
            {
                //
                // optional reg entry
                // default is the number buffers in 64KB
                //
                dwNewHeapIncrementCount = 0x10000 / sizeof(TRACEBUF);
            }
            InterlockedExchange( (long *)&dwIncrementSize, (long)dwNewHeapIncrementCount );


            if ( GetRegDword(   hkConfig,
                                "AsyncThreadPriority",
                                (LPDWORD)&nNewThreadPriority ) == FALSE )
            {
            //
            // optional reg entry
            //
                nNewThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
            }
            else switch( nNewThreadPriority )
            {
            //
            // if successful verify the resulting value
            //
            case THREAD_PRIORITY_IDLE:
            case THREAD_PRIORITY_BELOW_NORMAL:
            case THREAD_PRIORITY_NORMAL:
            case THREAD_PRIORITY_ABOVE_NORMAL:
            case THREAD_PRIORITY_HIGHEST:
                break;

            default:
                ASSERT( FALSE );
                nNewThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
            }

            if (GetRegDword(hkConfig,
                            "FailureRate",
                            (LPDWORD)&nNewFailRate ) == FALSE)
            {
                //
                // optional reg entry
                // default is to disable failure
                //
                nNewFailRate = kDontFail;

            }

            InterlockedExchange( &nFailRate, nNewFailRate );

            cbData = MAX_PATH;
            if ( !GetRegString( hkConfig,
                                "FailureFile",
                                g_szRandFailFile,
                                &cbData ) ) {
                *g_szRandFailFile = '\0';
            }

            if ( GetRegDword(   hkConfig,
                                "FailureBuffer",
                                (LPDWORD)&cRandFailBuffer ))
            {
                g_cCallStack = cRandFailBuffer;
            } else
                g_cCallStack = 1;   // default value

            cbData = sizeof(szNewTraceFileName);
            if ( GetRegString(  hkConfig,
                                "TraceFile",
                                szNewTraceFileName,
                                &cbData ) == FALSE )
            {
                //
                // Only fail if user specifies FILE based tracing
                //
                if ( dwNewTraceOutputType & TRACE_OUTPUT_FILE )
                {
                    INT_TRACE( "GetRegString: TraceFile failed: %d\n", GetLastError() );
                    return  bRC = FALSE;
                }
            }

            bRC = TRUE;

        }

    }
    __finally
    {
        //
        // preserve the original error code
        //
        DWORD   dwLastError = GetLastError();
        BOOL    fLeaveCritSec = FALSE;

        if ( bRC == TRUE )
        {
            BOOL    bNewFileName = lstrcmpi( szNewTraceFileName, szTraceFileName ) != 0;
            BOOL    bNewTraces = dwNewEnabledTraces != __dwEnabledTraces;
            BOOL    bNewFlags = dwNewAsyncTraceFlag != dwAsyncTraceFlag;
            BOOL    bNewOutput = dwNewTraceOutputType != dwTraceOutputType;
            BOOL    bNewModules = memcmp(mszModules, mszNewModules, MODULES_BUFFER_SIZE) != 0;

            INT_TRACE( "GetTraceFlags... 0x%08X, 0x%08X, 0x%08X, %s\n",
                        dwNewAsyncTraceFlag,
                        dwNewEnabledTraces,
                        dwNewTraceOutputType,
                        szNewTraceFileName );

            INT_TRACE( "bNewFileName:%d bNewTraces:%d bNewOutput:%d bNewFlags:%d bNewModules:%d\n",
                        bNewFileName,
                        bNewTraces,
                        bNewOutput,
                        bNewFlags,
                        bNewModules );

            if ( bNewFileName || bNewTraces || bNewOutput || bNewFlags || bNewModules )
            {
                if ( __dwEnabledTraces )
                {
                    //
                    // not the initial time thru
                    //

                    fLeaveCritSec = TRUE;

                    if ( dwAsyncTraceFlag )
                    {
                        FlushAsyncTrace();
                    }
                    EnterCriticalSection( &critSecWrite );
                }

                if ( PendQ.hFile != INVALID_HANDLE_VALUE )
                {
                    //
                    // if the file name changed or tracing was disabled or the
                    // file tracing disabled, then close the currently open file
                    //
                    if( bNewFileName ||
                        dwNewEnabledTraces == 0 ||
                        IsTraceFile( dwNewTraceOutputType ) == FALSE )
                    {
                        BOOL    bSuccess;

                        EnterCriticalSection( &critSecWrite );
                        bSuccess = CloseHandle( PendQ.hFile );
                        INT_TRACE( "CloseHandle: %d, GetLastError: %d\n",
                                    bSuccess, GetLastError() );
                        PendQ.hFile = INVALID_HANDLE_VALUE;
                        LeaveCriticalSection( &critSecWrite );
                    }
                }

                if ( IsTraceFile( dwNewTraceOutputType ) )
                {
                    if (bNewFileName ||
                        IsTraceFile( dwTraceOutputType ) == FALSE ||
                        dwNewEnabledTraces != 0 &&
                        PendQ.hFile == INVALID_HANDLE_VALUE )
                    {
                        PendQ.hFile = CreateFile(szNewTraceFileName,
                                                GENERIC_WRITE,
                                                FILE_SHARE_READ|FILE_SHARE_WRITE,
                                                NULL,
                                                OPEN_ALWAYS,
                                                FILE_ATTRIBUTE_NORMAL,
                                                NULL );

                        if ( PendQ.hFile != INVALID_HANDLE_VALUE )
                        {
                            lstrcpy( szTraceFileName, szNewTraceFileName );
                        }
                        else
                        {
                            INT_TRACE( "CreateFile failed for %s 0x%X\n",
                                        szNewTraceFileName,
                                        GetLastError() );
                        }
                    }
                }

                //
                // set the new priority for the writer thread
                //
                if ( nNewThreadPriority != nAsyncThreadPriority )
                {
                    nAsyncThreadPriority = nNewThreadPriority;
                    SetThreadPriority( PendQ.hWriteThread, nAsyncThreadPriority );
                }

                //
                // set the new list of modules to log
                //
                if ( bNewModules ) {
                    memcpy(mszModules, mszNewModules, MODULES_BUFFER_SIZE);
                }

                dwTraceOutputType = dwNewTraceOutputType;
                dwAsyncTraceFlag = dwNewAsyncTraceFlag;

                InterlockedExchange( &__dwEnabledTraces, dwNewEnabledTraces );

                if ( fLeaveCritSec )
                {
                    //
                    // not the initial time thru
                    //
                    LeaveCriticalSection( &critSecWrite );
                }
            }
        }

        if ( hkConfig != NULL )
        {
            RegCloseKey( hkConfig );
        }

        SetLastError( dwLastError );

    }
    return  bRC;
}




#define NUM_REG_THREAD_OBJECTS  2

DWORD RegNotifyThread( LPDWORD lpdw )
{
    HANDLE  Handles[NUM_REG_THREAD_OBJECTS];
    HKEY       hKey;
    DWORD   dw;

    Handles[0] = hShutdownEvent;

    INT_TRACE( "RegNotifyThread 0x%X\n", GetCurrentThreadId() );

    Handles[1] = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( Handles[1] == NULL )
    {
        ASSERT( FALSE );
        INT_TRACE( "RegNotifyThread CreateEvent failed 0x%X\n", GetLastError() );
        return  1;
    }

    if ( RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                        szDebugAsyncTrace,
                        0,
                        KEY_READ,
                        &hKey ) != ERROR_SUCCESS )
    {
        INT_TRACE( "RegNotifyThread RegOpenKeyEx failed 0x%X\n", GetLastError() );
        CloseHandle( Handles[1] );
        return  1;
    }

    for ( ;; )
    {
        if ( RegNotifyChangeKeyValue(hKey,
                                    FALSE,
                                    REG_NOTIFY_CHANGE_ATTRIBUTES |
                                    REG_NOTIFY_CHANGE_LAST_SET,
                                    Handles[1],
                                    TRUE ) != ERROR_SUCCESS )
        {
            INT_TRACE( "RegNotifyThread RegNotify... failed 0x%X\n", GetLastError() );
            RegCloseKey( hKey );
            CloseHandle( Handles[1] );
            return  1;
        }

        dw = WaitForMultipleObjects(NUM_REG_THREAD_OBJECTS,
                                    Handles,
                                    FALSE,
                                    INFINITE );

        switch( dw )
        {
        //
        // normal signalled event
        //
        case WAIT_OBJECT_0:
            RegCloseKey( hKey );
            CloseHandle( Handles[1] );
            INT_TRACE( "Exiting RegNotifyThread for hShutdownEvent\n" );
            return  0;

        //
        // signalled that our registry keys have changed
        //
        case WAIT_OBJECT_0+1:
            GetTraceFlagsFromRegistry();
            break;

        default:
            INT_TRACE( "RegNotifyThread WFMO: dw: 0x%X, Error: 0x%X\n", dw, GetLastError() );
            ASSERT( FALSE );
            RegCloseKey( hKey );
            CloseHandle( Handles[1] );
            return  1;
        }
    }

    INT_TRACE( "Exiting RegNotifyThread abnormally\n" );
    RegCloseKey( hKey );
    CloseHandle( Handles[1] );

    return  2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\trace\randfail.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :

    randfail.c

Abstract :

    This module implements the initialization function for the random
	failure library, plus the code to determine if it's time to fail.

Author :

    Sam Neely

Revision History :

--*/

#include <windows.h>
#include <stdio.h>
#include "traceint.h"
#include "randint.h"
#include "exchmem.h"

static long s_nCount = 0;
long nFailRate = kDontFail;
DWORD dwRandFailTlsIndex=0xffffffff;
const DWORD g_dwMaxCallStack = 1024;

//
// Call stack buffer array
//

CHAR    **g_ppchCallStack = NULL;

//
// Randfail call stack file and its handle
//

CHAR    g_szRandFailFile[MAX_PATH+1];
HANDLE  g_hRandFailFile = INVALID_HANDLE_VALUE;
HANDLE  g_hRandFailMutex = INVALID_HANDLE_VALUE;

//
// Number of buffers allocated for randfail call stack
//

LONG   g_cCallStack = 1;

//
// Current index in the buffer array
//

LONG   g_iCallStack = 0;

VOID
DumpCallStack(  DWORD_PTR   *rgdwCall,
                DWORD       dwCallers,
                PBYTE       pbCallstack,
                DWORD&      cbCallstack )
/*++
Routine description:

    Dump call stack into the given buffer.

Arguments:

    rgdwCall    - Array of caller's address
    dwCallers   - Number of callers
    pbCallstack - The buffer to put the call stack string into
    cbCallstack - In: How big the buffer is, Out: how much stuff I have put
                    in there

Return value:

    None.
--*/
{
	DWORD	i;
	CHAR    Buffer[g_dwMaxCallStack];
	DWORD   dwLine = 0;
	DWORD   dwBufferAvail = cbCallstack - 2*sizeof(CHAR);
	PBYTE   pbStart = pbCallstack;
	DWORD   dwBytesWritten = 0;
	BOOL    fRetry = TRUE;
	char    szModuleName[MAX_PATH];
	char*   pszFileName;
	char*   pszExtension;

	_ASSERT( pbStart );
	_ASSERT( cbCallstack > 0 );

    cbCallstack = 0;

    //
    // Get the executable's filename and point past the last slash
    // in the path, if it's present.  Also, whack off the extension
    // if it's .EXE
    //
	if (GetModuleFileName(NULL, szModuleName, MAX_PATH) == 0) {
	    strcpy (szModuleName, "Unknown");
	}

	pszFileName = strrchr(szModuleName, '\\');
	if (pszFileName == NULL) {
	    pszFileName = szModuleName;
	} else {
	    pszFileName++;
	}

	pszExtension = strrchr(pszFileName, '.');
	if (pszExtension) {
	    if (_stricmp(pszExtension+1, "exe") == 0) {
	        *pszExtension = NULL;
	    }
	}

	//
	// Format a header line
    //

    dwBytesWritten = _snprintf((char*)pbStart,
        g_dwMaxCallStack,
        "*** %s, Process: %d(%#x), Thread: %d(%#x) ***\r\n",
        pszFileName,
        GetCurrentProcessId(), GetCurrentProcessId(),
        GetCurrentThreadId(), GetCurrentThreadId());

    cbCallstack += dwBytesWritten;
    pbStart += dwBytesWritten;
    dwBufferAvail -= dwBytesWritten;

    //
	// Dump call stack
	// Note that we skip the first two entries.  These are the internal
	// calls to ExchmemGetCallStack and g_TestTrace
	for (i = 2; i < dwCallers && rgdwCall[i] != 0; i++)
	{
		ExchmemFormatSymbol(
		            GetCurrentProcess(),
		            rgdwCall[i],
		            Buffer,
		            g_dwMaxCallStack );
		dwLine = strlen( Buffer );
		if ( dwLine+2 < dwBufferAvail ) {
		    CopyMemory( pbStart, Buffer, dwLine );
		    *(pbStart+dwLine) = '\r';
		    *(pbStart+dwLine+1) = '\n';
		    dwBufferAvail -= (dwLine + 2*sizeof(CHAR));
		    pbStart += (dwLine + 2*sizeof(CHAR));
		    cbCallstack +=( dwLine + 2*sizeof(CHAR));
		} else {
		    break;
		}
	}

	//
	// Add an extra \r\n at the end
	//

	*(pbCallstack + cbCallstack) = '\r';
	*(pbCallstack + cbCallstack + 1) = '\n';
	cbCallstack += 2;

	//
	// Dump it to the log file as well, if we do have a log file
	//

	if ( INVALID_HANDLE_VALUE != g_hRandFailFile &&
	    INVALID_HANDLE_VALUE != g_hRandFailMutex ) {

	    WaitForSingleObject (g_hRandFailMutex, INFINITE);

	    DWORD dwOffset = SetFilePointer( g_hRandFailFile, 0, 0, FILE_END );

        //
        // if the file is too big then we need to truncate it
        //
        if (dwOffset > dwMaxFileSize)
        {
            SetFilePointer(g_hRandFailFile, 0, 0, FILE_BEGIN);
            SetEndOfFile(g_hRandFailFile);
        }
try_again:
        BOOL b = WriteFile(
	            g_hRandFailFile,
	            pbCallstack,
	            cbCallstack,
	            &dwBytesWritten,
	            NULL );

        if ( b == FALSE || dwBytesWritten != cbCallstack )
        {
            DWORD   dwError = GetLastError();

            if( dwError && fRetry )
            {
                fRetry = FALSE;
                Sleep( 100 );
                goto try_again;
            }
            INT_TRACE( "Error writing to file: %d, number of bytes %d:%d\n",
                        dwError,
                        cbCallstack,
                        dwBytesWritten );
        }

        ReleaseMutex(g_hRandFailMutex);

    }

}

//
// See if it's time for this API to fail
//
// Note:  This routine was renamed from fTimeToFail to g_TestTrace
// to hide the symbol from someone dumping the dll
//

extern "C" __declspec(dllexport)
int
__stdcall
g_TestTrace(void) {
/*++

Routine Description:

	Check to see if it's time for an instrumented API to fail.

	Note:  This routine was renamed from fTimeToFail to g_TestTrace
	to hide the symbol from someone dumping the dll

Arguments:

	None

Return Value:

    true if it's time for us to fail, false if not or we're disabled.

--*/
    LONG    l;

	// Never fail?
	if (nFailRate == kDontFail)
		return 0;

	// Have failures been suspended?
	if (dwRandFailTlsIndex != 0xffffffff &&
	    TlsGetValue (dwRandFailTlsIndex) != NULL)
		return 0;

	// This is good enough for now..
	l = InterlockedIncrement(&s_nCount) % nFailRate;

	if ( l == 0 ) {

	    // We are going to fail
	    if ( g_ppchCallStack ) {
	        LONG i = 0;
	        const DWORD   dwMaxCallStack = 20;
	        DWORD   dwCallStackBuffer = g_dwMaxCallStack;
	        DWORD_PTR   rgdwCaller[dwMaxCallStack];

	        i = InterlockedIncrement( &g_iCallStack );
	        if ( i <= g_cCallStack ) {
	            i--;
	            if ( g_ppchCallStack[i] ) {
                    ZeroMemory( rgdwCaller, sizeof(DWORD_PTR)*dwMaxCallStack );
                    ExchmemGetCallStack(rgdwCaller, dwMaxCallStack);
                    DumpCallStack( rgdwCaller, dwMaxCallStack, (PBYTE)g_ppchCallStack[i], dwCallStackBuffer );
                }
            } else {
                InterlockedExchange( &g_iCallStack, g_cCallStack );
            }
        }

        return TRUE;
    } else
        return FALSE;
}

extern "C" __declspec(dllexport)
void
__stdcall
g_TestTraceDisable(void) {
/*++

Routine Description:

	Function to temporarily suspend g_TestTrace's ability to return a
	failure.  This is used when you want to call one of the instrumented
	APIs that you don't want to fail.  This function is nestable up to
	128(abitrary) levels deep.

Arguments:

	None

Return Value:

	None

--*/

	if (dwRandFailTlsIndex == 0xffffffff)
		return;

	SIZE_T OldValue = (SIZE_T)TlsGetValue(dwRandFailTlsIndex);
	ASSERT (OldValue <= 128);
	TlsSetValue(dwRandFailTlsIndex, (LPVOID)(OldValue+1));
}


extern "C" __declspec(dllexport)
void
__stdcall
g_TestTraceEnable(void) {
/*++

Routine Description:

	Resume g_TestTrace's normal functionality if the nesting level has
	returned to zero.

Arguments:

	None

Return Value:

	None

--*/
	if (dwRandFailTlsIndex == 0xffffffff)
		return;

	SIZE_T OldValue = (SIZE_T)TlsGetValue(dwRandFailTlsIndex);
	ASSERT (OldValue > 0 && OldValue <= 128);
	TlsSetValue(dwRandFailTlsIndex, (LPVOID)(OldValue-1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\trace\freeq.cpp ===
//#---------------------------------------------------------------
//        
//  File:       FreeQ.cpp
//        
//  Synopsis:   interface between CPool object and asynctrc.c
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    gordm
//        
//----------------------------------------------------------------

#define	_DBGTRACE_DLL_IMPLEMENTATION

#include <windows.h>
#include <cpool.h>
#include "randfail.h"
#include "traceint.h"

//
// global pointer to CPool to avoid pulling in the C runtime
// to call the con/destrustors
//
CPool*	g_pFreePool = NULL;


//+---------------------------------------------------------------
//
//  Function:   InitTraceBuffers
//
//  Synopsis:   external "C" function to init the CPool
//
//  Arguments:  DWORD: Maximum number of pending traces
//				DWORD: Increment size for the CPool
//
//  Returns:    BOOL: successful or not
//
//----------------------------------------------------------------
BOOL WINAPI InitTraceBuffers( DWORD dwThresholdCount, DWORD dwIncrement )
{
	g_pFreePool = new CPool( TRACE_SIGNATURE );

	return	g_pFreePool != NULL &&
			g_pFreePool->ReserveMemory(	dwThresholdCount,
										sizeof(TRACEBUF),
										dwIncrement );
}


//+---------------------------------------------------------------
//
//  Function:   TermTraceBuffers
//
//  Synopsis:   cleanup 
//
//  Arguments:  void
//
//  Returns:    void
//
//----------------------------------------------------------------
void WINAPI TermTraceBuffers( void )
{
	CPool*	pPool = (CPool*)InterlockedExchangePointer((void**)&g_pFreePool, NULL );
	if ( pPool != NULL )
	{
		pPool->ReleaseMemory();
		delete	pPool;
	}
}


//+---------------------------------------------------------------
//
//  Function:   GetTraceBuffer
//
//  Synopsis:   external "C" function to get a CPool buffer 
//
//  Arguments:  void
//
//  Returns:    LPTRACEBUF: allocated buffer
//
//----------------------------------------------------------------
LPTRACEBUF WINAPI GetTraceBuffer( void )
{
	LPTRACEBUF	lpBuf;

	//
	// don't let the number of traces exceed the size 
	// of the file
	//
	if ( PendQ.dwCount >= PendQ.dwThresholdCount )
	{
		INT_TRACE( "Alloc flush: %u\n", PendQ.dwCount );
		FlushAsyncTrace();
	}

	//
	// Turn off randfail for this allocation
	//
    RandFailDisable();
	lpBuf = (LPTRACEBUF)g_pFreePool->Alloc();
    RandFailEnable();
    
   	if ( lpBuf != NULL )
	{
		lpBuf->pNext = NULL;
		lpBuf->dwSignature = TRACE_SIGNATURE;
	}
	return	lpBuf;
}



//+---------------------------------------------------------------
//
//  Function:   FreeTraceBuffer
//
//  Synopsis:   external "C" function to free a CPool buffer 
//
//  Arguments:  LPTRACEBUF: the buffer to free
//
//  Returns:    void
//
//----------------------------------------------------------------
void WINAPI FreeTraceBuffer( LPTRACEBUF lpBuf )
{
	ASSERT( lpBuf != NULL );
	ASSERT( lpBuf->dwSignature == TRACE_SIGNATURE );

	g_pFreePool->Free( (void*)lpBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\vroot\src\mbchange.cpp ===
#include "stdinc.h"

CChangeNotify::CChangeNotify() :
	m_listNotify(&CMBChangeListData::m_pPrev, &CMBChangeListData::m_pNext)
{
}

HRESULT CChangeNotify::FinalConstruct() {
	HRESULT hr;

	m_pMetabaseHandle = NULL;
	m_bConnected = FALSE;

	hr = CoCreateFreeThreadedMarshaler(this, &m_pUnkMarshaler.p);
	_ASSERT(!SUCCEEDED(hr) || m_pUnkMarshaler);

	return hr;
}

void CChangeNotify::FinalRelease() {
	_ASSERT(m_pMetabaseHandle == NULL);
	m_pUnkMarshaler.Release();
}

HRESULT CChangeNotify::Initialize(IMSAdminBaseW *pMetabaseHandle) {
	HRESULT hr = S_OK;

	m_bConnected = FALSE;

	hr = CoCreateFreeThreadedMarshaler(this, &m_pUnkMarshaler.p);
	_ASSERT(!SUCCEEDED(hr) || m_pUnkMarshaler);

	_ASSERT(pMetabaseHandle != NULL);
	if (!pMetabaseHandle) return (E_POINTER);

	m_pMetabaseHandle = pMetabaseHandle;

	return (S_OK);
}

void CChangeNotify::Terminate(void) {
	_ASSERT(m_listNotify.IsEmpty());

	m_pMetabaseHandle = NULL;
	_ASSERT(!m_bConnected);
}

HRESULT CChangeNotify::AddNotify(void *pContext, PFNMB_CHANGE_NOTIFY pfnNotify) {
	HRESULT hr = S_OK;

	if (!pfnNotify) return (E_POINTER);
    if (!m_pMetabaseHandle) return (S_OK);

	CMBChangeListData *pLD = XNEW CMBChangeListData(pContext, pfnNotify);

	if (pLD == NULL) {
	    return E_OUTOFMEMORY;
	}

	m_lock.ExclusiveLock();

	m_listNotify.PushBack(pLD);

	if (!m_bConnected) {
        CComPtr<IConnectionPointContainer> pCPC;
		CComPtr<IConnectionPoint> pCP;
		CComQIPtr<IMSAdminBaseSinkW, &IID_IMSAdminBaseSink_W> pThis = this;

		m_bConnected = TRUE;
		_ASSERT(pThis);
        hr = m_pMetabaseHandle->QueryInterface(IID_IConnectionPointContainer,(LPVOID *) &pCPC);
        if (SUCCEEDED(hr)) {
    		hr = pCPC->FindConnectionPoint(IID_IMSAdminBaseSink_W,&pCP);
    		_ASSERT(SUCCEEDED(hr));
    		if (SUCCEEDED(hr)) {
    			hr = pCP->Advise(this,&m_dwCookie);
    			_ASSERT(SUCCEEDED(hr));
    		}
        }
	} 

	m_lock.ExclusiveUnlock();

	return (hr);
}

HRESULT CChangeNotify::RemoveNotify(void *pContext, PFNMB_CHANGE_NOTIFY pfnNotify) {
	HRESULT hr;

	if (!pfnNotify) return (E_POINTER);
    if (!m_pMetabaseHandle) return (S_OK);

	m_lock.ExclusiveLock();

	for (TFList<CMBChangeListData>::Iterator it(&m_listNotify); !it.AtEnd(); it.Next()) {
		if (it.Current()->m_pContext == pContext)  {
            CMBChangeListData*  p = it.RemoveItem();
            if (p) {
                XDELETE p;
                p = NULL;
            }
        }
	}

	if (m_listNotify.IsEmpty()) {
        CComPtr<IConnectionPointContainer> pCPC;
		CComPtr<IConnectionPoint> pCP;
		DWORD dwCookie = m_dwCookie;

		_ASSERT(m_bConnected);
		m_bConnected = FALSE;
        hr = m_pMetabaseHandle->QueryInterface(IID_IConnectionPointContainer,(LPVOID *) &pCPC);
        _ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr)) {
    		hr = pCPC->FindConnectionPoint(IID_IMSAdminBaseSink_W,&pCP);
    		_ASSERT(SUCCEEDED(hr));
    		if (SUCCEEDED(hr)) {
    			hr = pCP->Unadvise(dwCookie);
    			_ASSERT(SUCCEEDED(hr));
			}
		}
	} 

	m_lock.ExclusiveUnlock();

	return (S_OK);
}

HRESULT STDMETHODCALLTYPE CChangeNotify::SinkNotify(DWORD cChangeList, MD_CHANGE_OBJECT_W pcoChangeList[]) {
	_ASSERT(cChangeList && pcoChangeList);
	if (!pcoChangeList) return (E_POINTER);
	if (!cChangeList) return (S_OK);

	m_lock.ShareLock();
	if (m_listNotify.IsEmpty()) {
		m_lock.ShareUnlock();
		return (S_OK);
	}

	for (TFList<CMBChangeListData>::Iterator it(&m_listNotify); !it.AtEnd(); it.Next()) {
		PFNMB_CHANGE_NOTIFY pfnNotify = it.Current()->m_pfnNotify;
		void *pContext = it.Current()->m_pContext;

		pfnNotify(pContext, cChangeList, pcoChangeList);
	}

	m_lock.ShareUnlock();

	return (S_OK);
}


HRESULT STDMETHODCALLTYPE CChangeNotify::ShutdownNotify(void) {
	// tbd
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\trace\traceint.h ===
//
// TRACEINT.H
//
// Async tracing internal include file
//

#include "dbgtrace.h"
#include "dbgfile.h"

#ifdef __cplusplus
extern "C" {
#endif


#if !defined(DllExport)
    #define DllExport __declspec( dllexport )
#endif

#ifndef ASSERT
#define ASSERT( x )     (x) ? 1 : DebugBreak()
#endif

#define MAX_BUFFER_SIZE         200
#define MAX_FILENAME_SIZE       16
#define MAX_FUNCTNAME_SIZE      32

#define TRACE_SIGNATURE         (DWORD)'carT'

//
// +2 == potential CR+LF
//
#define MAX_VARIABLE_SIZE       (MAX_FILENAME_SIZE + MAX_FUNCTNAME_SIZE + MAX_BUFFER_SIZE)
#define MAX_TRACE_ENTRY_SIZE (sizeof(FIXEDTRACE) + MAX_VARIABLE_SIZE)

typedef struct tagSPECIALBUF
{
        DWORD   dwSignature;
        struct tagTRACEBUF *pNext;
} SPECIALBUF, * LPSPECIALBUF;


typedef struct tagTRACEBUF
{
        DWORD           dwSignature;
        struct tagTRACEBUF *pNext;
        DWORD           dwLastError;

        //
        // fixed buffer committed to permanent storage ( ie disk )
        //
#pragma pack(2)

        FIXEDTRACE      Fixed;
        char            Buffer[MAX_VARIABLE_SIZE];

#pragma pack()

} TRACEBUF, * LPTRACEBUF;

#define MAX_WRITE_BUFFER_SIZE   16*1024

typedef struct tagPENDQ
{
        LPTRACEBUF      pHead;
        LPTRACEBUF      pTail;
        SPECIALBUF      Special;
        HANDLE          hEvent;
        HANDLE          hFlushEvent;
        HANDLE          hFlushedEvent;
        DWORD           dwCount;
        DWORD           dwThresholdCount;
        DWORD           dwProcessId;
        BOOL            fShutdown;
        HANDLE          hWriteThread;
        HANDLE          hRegNotifyThread;
        HANDLE          hFile;
        CRITICAL_SECTION critSecTail;
        HANDLE          hFileMutex;
        DWORD           cbBufferEnd;
        char            Buffer[MAX_WRITE_BUFFER_SIZE];
} PENDQ, * LPPENDQ;



//
// Internal Function declarations
//

extern BOOL WINAPI InitTraceBuffers( DWORD dwThresholdCount, DWORD dwIncrement );
extern void WINAPI TermTraceBuffers( void );
extern LPTRACEBUF WINAPI GetTraceBuffer( void );
extern void WINAPI FreeTraceBuffer( LPTRACEBUF lpBuf );

extern LPTRACEBUF DequeueAsyncTraceBuffer( void );
extern void QueueAsyncTraceBuffer( LPTRACEBUF lpBuf );
extern DWORD WriteTraceThread( LPDWORD lpdw );
extern BOOL WriteTraceBuffer( LPTRACEBUF lpBuf );
extern BOOL AsyncTraceCleanup( void );

extern BOOL GetTraceFlagsFromRegistry( void );
extern DWORD RegNotifyThread( LPDWORD lpdw );
extern BOOL ShouldLogModule( LPCSTR szModule );



extern  PENDQ   PendQ;
extern  BOOL    fInitialized;
extern  HANDLE  hShutdownEvent;
extern  DWORD   dwNumTraces;
extern  DWORD   dwTraceOutputType;
extern  DWORD   dwAsyncTraceFlag;
extern  int     nAsyncThreadPriority;
extern  DWORD   dwMaxFileSize;
extern  DWORD   dwIncrementSize;

#define MODULES_BUFFER_SIZE     2048
extern  CHAR    mszModules[];

#define DEFAULT_MAX_FILE_SIZE 1024*1024*5      // 5 megabytes
#define AVERAGE_TRACE_SIZE      ( sizeof(FIXEDTRACE) + 64 )

extern  CRITICAL_SECTION critSecWrite;

#ifdef  TRACE_ENABLED

extern void CDECL InternalTrace( const char *s, ... );

        #define INT_TRACE               InternalTrace

#else

__inline void CDECL InternalTrace( const char *s, ... ) {}

        #define INT_TRACE       1 ? (void)0 : InternalTrace

#endif


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\vroot\src\mbchange.h ===
#ifndef __MBCHANGE_H__
#define __MBCHANGE_H__

//
// Metabase change notification code.  This was borrowed from SEO.
//

typedef void (*PFNMB_CHANGE_NOTIFY)(void *pContext,
									DWORD cChangeList,
									MD_CHANGE_OBJECT_W pcoChangeList[]);

/////////////////////////////////////////////////////////////////////////////
// CChangeNotify

class CMBChangeListData {
	public:
		CMBChangeListData(void *pContext, PFNMB_CHANGE_NOTIFY pfnNotify) {
			m_pContext = pContext;
			m_pfnNotify = pfnNotify;
			m_pNext = m_pPrev = NULL;
		}
		void *m_pContext;
		PFNMB_CHANGE_NOTIFY m_pfnNotify;
		CMBChangeListData *m_pNext;
		CMBChangeListData *m_pPrev;
};

class ATL_NO_VTABLE CChangeNotify :
	public CComObjectRoot,
	public IMSAdminBaseSinkW
{
	public:
		HRESULT FinalConstruct();
		HRESULT Initialize(IMSAdminBaseW *pMetabaseHandle);
		HRESULT AddNotify(void *pContext, PFNMB_CHANGE_NOTIFY pfnNotify);
		HRESULT RemoveNotify(void *pContext, PFNMB_CHANGE_NOTIFY pfnNotify);
		void Terminate(void);
		void FinalRelease();

	DECLARE_PROTECT_FINAL_CONSTRUCT();
	DECLARE_NOT_AGGREGATABLE(CChangeNotify);
	DECLARE_GET_CONTROLLING_UNKNOWN();
	BEGIN_COM_MAP(CChangeNotify)
		COM_INTERFACE_ENTRY_IID(IID_IMSAdminBaseSink_W, IMSAdminBaseSinkW)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	public:
		// IMSAdminBaseSinkW
		HRESULT STDMETHODCALLTYPE SinkNotify(DWORD dwMDNumElements, MD_CHANGE_OBJECT_W pcoChangeList[]);
		HRESULT STDMETHODCALLTYPE ShutdownNotify(void);

		CChangeNotify();

	private:
		CShareLockNH m_lock;
		DWORD m_dwCookie;
        IMSAdminBaseW *m_pMetabaseHandle;
		BOOL m_bConnected;
		CComPtr<IUnknown> m_pUnkMarshaler;
		TFList<CMBChangeListData> m_listNotify;
		LONG m_cRef;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\vroot\src\stdinc.h ===
#ifndef __STDINC_H__
#define __STDINC_H__

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <windows.h>
#include <dbgtrace.h>
#include <ole2.h>
#include <coguid.h>
#include <cguid.h>

#ifdef __VRTABLE_CPP__
#include <initguid.h>
#endif

#define _ASSERTE _ASSERT
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include <stdio.h>
#include <iadmw.h>
#include <listmacr.h>

#include <rw.h>
#include <vroot.h>
#include "mbchange.h"

#include <xmemwrpr.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\vroot\src\vroot.cpp ===
#include "stdinc.h"
#include "iiscnfg.h"

CVRoot::~CVRoot() {
	_ASSERT(m_fInit);
	m_fInit = FALSE;
	m_cchVRootName = 0;

	_ASSERT(m_pVRootTable != NULL);
#ifdef DEBUG
	m_pVRootTable->DebugExpungeVRoot( this );
#endif
	m_pVRootTable->m_lockVRootsExist.ShareUnlock();
	m_dwSig = VROOT_BAD_SIG;
}

//
// initialize this class.
//
void CVRoot::Init(LPCSTR pszVRootName, CVRootTable *pVRootTable, LPCWSTR pwszConfigPath, BOOL fUpgrade ) {
	m_fInit = TRUE;
	m_cchVRootName = strlen(pszVRootName);
	m_pVRootTable = pVRootTable;
	_ASSERT(m_cchVRootName < MAX_VROOT_PATH);
	strcpy(m_szVRootName, pszVRootName);

	lstrcpyW(m_wszConfigPath, pwszConfigPath);
	// remove trailing slashes
	DWORD l = lstrlenW(m_wszConfigPath);
	if (m_wszConfigPath[l-1] == '/') m_wszConfigPath[l-1] = 0;

	m_fUpgrade = fUpgrade;

	_ASSERT(m_pVRootTable != NULL);
	m_pVRootTable->m_lockVRootsExist.ShareLock();
#ifdef DEBUG
	m_pVRootTable->DebugPushVRoot( this );
#endif
}

HRESULT CIISVRoot::GetDWord(IMSAdminBase *pMB, 
							METADATA_HANDLE hmb,
							DWORD dwId,
							DWORD *pdw) 
{
	METADATA_RECORD mdr;
	HRESULT hr;
	DWORD dwRequiredLen;

	mdr.dwMDAttributes = METADATA_INHERIT;
	mdr.dwMDIdentifier = dwId;
	mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = DWORD_METADATA;
	mdr.dwMDDataLen = sizeof(DWORD);
	mdr.pbMDData = (BYTE *) pdw;
	mdr.dwMDDataTag = 0;

	hr = pMB->GetData(hmb, L"", &mdr, &dwRequiredLen);
	return hr;
}

HRESULT CIISVRoot::GetString(IMSAdminBase *pMB, 
							 METADATA_HANDLE hmb,
							 DWORD dwId,
							 LPWSTR szString,
							 DWORD *pcString) 
{
	METADATA_RECORD mdr;
	HRESULT hr;
	DWORD dwRequiredLen;

	mdr.dwMDAttributes = METADATA_INHERIT;
	mdr.dwMDIdentifier = dwId;
	mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = STRING_METADATA;
	mdr.dwMDDataLen = (*pcString) * sizeof(WCHAR);
	mdr.pbMDData = (BYTE *) szString;
	mdr.dwMDDataTag = 0;

	hr = pMB->GetData(hmb, L"", &mdr, &dwRequiredLen);
	if (FAILED(hr)) *pcString = dwRequiredLen;
	else *pcString  = wcslen( szString );
	return hr;
}

//
// reads the following parameters:
//
// MD_IS_CONTENT_INDEXED -> m_fIsIndexed
// MD_ACCESS_PERM -> m_dwAccess
// MD_SSL_ACCESS_PERM -> m_dwSSL
// MD_DONT_LOG -> m_fDontLog
//
HRESULT CIISVRoot::ReadParameters(IMSAdminBase *pMB, METADATA_HANDLE hmb) {
	DWORD dw = 0;

	if (FAILED(GetDWord(pMB, hmb, MD_ACCESS_PERM, &m_dwAccess))) {
		m_dwAccess = 0;
	}

	if (FAILED(GetDWord(pMB, hmb, MD_SSL_ACCESS_PERM, &m_dwSSL))) {
		m_dwSSL = 0;
	}

	if (FAILED(GetDWord(pMB, hmb, MD_IS_CONTENT_INDEXED, &dw))) dw = FALSE;
	m_fIsIndexed = dw;

	if (FAILED(GetDWord(pMB, hmb, MD_DONT_LOG, &dw))) dw = FALSE;
	m_fDontLog = dw;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\transreg\registry.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       registry.cxx
//
//  Contents:   implementations for CMyRegKey member Members
//
//  Members:    CMyRegKey::CMyRegKey - constructor for registry key object
//              CMyRegKey::CMyRegKey - constructor for registry key object
//              CMyRegKey::CreateKey - real worker for constructors
//              CMyRegKey::~CMyRegKey - destructor for registry key object
//              CMyRegKey::Delete - delete a registry key
//              CMyRegKey::EnumValues - enumerate values of a registry key
//              CMyRegKey::EnumKeys - enumerate subkeys of a registry key
//              CMyRegKey::NotifyChange - setup change notification for a key
//
//              CRegValue::GetValue - sets a registry value
//              CRegValue::SetValue - retrieves a registry value
//              CRegValue::Delete - deletes a registry value
//              CRegValue::GetTypeCode - returns the type code of the value
//
//              CRegMSZ::SetStrings - sets a multi-string registry value
//              CRegMSZ::GetStrings - retrieves a multi-string registry value
//
//  History:    09/30/92    Rickhi  Created
//
//              09/22/93    AlokS   Took out exception throwing code
//                                  and added proper return code for
//                                  each method.
//
//              07/26/94    AlokS   Made it real light weight for simple
//                                  registry set/get operations
//
//              12/09/07    Milans  Ported it over to Exchange
//
//  Notes:      see notes in registry.h
//
//----------------------------------------------------------------------------

#include    <stdlib.h>
#include    <windows.h>
#include    "registry.h"

//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::CMyRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//
//  Arguments:  [hkParent] - handle to parent key
//              [pszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal error state is set if construction fails.
//
//  Returns:    -none-
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the hkParent and pszPath are optional parameters.
//
//--------------------------------------------------------------------------

CMyRegKey::CMyRegKey (
        HKEY hkParent,
        LPCSTR pszPath,
        REGSAM samDesiredAccess,
        LPCSTR pszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr (ERROR_SUCCESS)
{
    _dwErr = CreateKey( _hkParent,
                     pszPath,
                     samDesiredAccess,
                     pszClass,
                     dwOptions,
                     pdwDisposition,
                     pSecurityAttributes );
}


//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::CMyRegKey
//
//  Synopsis:   Constructor for registry key object, using CMyRegKey for parent
//
//  Arguments:  [prkParent] - ptr to Parent CMyRegKey
//              [pszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal Error state is set if error occures during construction.
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the prkParent and pszPath are optional parameters.
//
//--------------------------------------------------------------------------

CMyRegKey::CMyRegKey (
        const CMyRegKey &crkParent,
        LPCSTR pszPath,
        REGSAM samDesiredAccess,
        LPCSTR pszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
    _dwErr = CreateKey ( _hkParent,
                      pszPath,
                      samDesiredAccess,
                      pszClass,
                      dwOptions,
                      pdwDisposition,
                      pSecurityAttributes );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::CMyRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [hkParent] - HKEY to Parent
//                              [dwErr]      - Error code returned here
//                      [pszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CMyRegKey::CMyRegKey (
        HKEY hkParent,
        DWORD *pdwErr,
        LPCSTR pszPath,
        REGSAM samDesiredAccess )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey  ( _hkParent, pszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::CMyRegKey
//
//  Synopsis:   Constructor for registry key object, using CMyRegKey for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [prkParent] - ptr to Parent CMyRegKey
//              [dwErr]           -  Error code returned here.
//                      [pszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CMyRegKey::CMyRegKey (
        const CMyRegKey  &crkParent,
        DWORD *pdwErr,
        LPCSTR pszPath,
        REGSAM   samDesiredAccess )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey ( _hkParent, pszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::~CMyRegKey, public
//
//  Synopsis:   Destructor for registry key object
//
//  Arguments:  none
//
//  Signals:    nothing
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CMyRegKey::~CMyRegKey()
{
    if (_hkThis != NULL)
        RegCloseKey(_hkThis);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::CreateKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//              [pszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CMyRegKey::CreateKey (
        HKEY hkParent,
        LPCSTR  pszPath,
        REGSAM  samDesiredAccess,
        LPCSTR  pszClass,
        DWORD   dwOptions,
        DWORD   *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
{
    DWORD   dwDisposition;
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    LPSECURITY_ATTRIBUTES lpsec = pSecurityAttributes;

    //  create/open the key
    if ((dwRc = RegCreateKeyEx(hkParent,
                           (LPSTR) pszPath,    //  path to key
                           0,                  //  title index
                           (LPSTR) pszClass,   //  class of key
                           dwOptions,          //  key options
                           samDesiredAccess,   //  desired access
                           lpsec,              //  if created
                           &_hkThis,           //  handle
                           &dwDisposition)     //  opened/created
                          )==ERROR_SUCCESS)
    {
        //  save away the name
        _cszName.Set((PCHAR) pszPath);

        //  setup the return parameters
        if (pdwDisposition != NULL)
            *pdwDisposition = dwDisposition;

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::OpenKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//                      [pszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/22/93        AlokS  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CMyRegKey::OpenKey (
        HKEY    hkParent,
        LPCSTR  pszPath,
        REGSAM  samDesiredAccess )
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;

    //  open the key
    if ((dwRc = RegOpenKeyEx(hkParent,
                         pszPath,           //  path to key
                         0,                  //  reserved
                         samDesiredAccess,   //  desired access
                         &_hkThis            //  handle
                        ))==ERROR_SUCCESS)
    {
        //  save away the name
        _cszName.Set((PCHAR) pszPath);

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::Delete, public
//
//  Synopsis:   Deletes an existing key from the registry.  Note that
//              the key object still exists, the destructor must be
//              called seperately.
//
//  Arguments:  none
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CMyRegKey::Delete(void)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD   dwRc;
    SRegKeySet *pChildren;

    dwErr = this->EnumKeys(&pChildren);

    if (dwErr == ERROR_SUCCESS) {

        ULONG i;
        DWORD dwErrDelete = ERROR_SUCCESS;

        for(i = 0; i < pChildren->cKeys; i++) {

            dwErr = pChildren->aprkKey[i]->Delete();

            if (dwErr != ERROR_SUCCESS) {

                dwErrDelete = dwErr;

            }

            delete pChildren->aprkKey[i];

        }

        if (dwErrDelete == ERROR_SUCCESS) {

            if (( dwRc= RegDeleteKey(_hkThis, NULL))!=ERROR_SUCCESS) {

                dwErr = Creg_ERROR(dwRc);

            }

        } else {

            dwErr = dwErrDelete;

        }

        delete pChildren;

    }

    return(dwErr);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::EnumValues, public
//
//  Synopsis:   Enumerates the values stored in an open registry key.
//
//  Arguments:  [pprvs] - SRegValueSet allocated and returned by this
//                                    method.  The caller is responsible for releasing
//                                    the allocated CRegValue objects via delete and the
//                                    SRegValueSet structure via CMyRegKey::MemFree.
//
//  Signals:  none
//
//  Returns:  ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      The data associated with each Value is not returned. The
//              caller may invoke the GetValue method of each CRegValue
//              returned to get it's associated data.
//
//--------------------------------------------------------------------------

DWORD CMyRegKey::EnumValues(SRegValueSet **pprvs)
{
    DWORD dwErr = ERROR_SUCCESS;

    //  figure out how many values are currently stored in this key
    //  and allocate a buffer to hold the return results.

    CHAR    szClass[MAX_PATH];
    ULONG   cbClass = sizeof(szClass);
    ULONG   cSubKeys, cbMaxSubKeyLen, cbMaxClassLen;
    ULONG   cValues, cbMaxValueIDLen, cbMaxValueLen;
    SECURITY_DESCRIPTOR SecDescriptor;
    FILETIME ft;

    DWORD dwRc = RegQueryInfoKey(_hkThis,
                               szClass,
                               &cbClass,
                               NULL,
                               &cSubKeys,
                               &cbMaxSubKeyLen,
                               &cbMaxClassLen,
                               &cValues,
                               &cbMaxValueIDLen,
                               &cbMaxValueLen,
                               (DWORD *)&SecDescriptor,
                               &ft );

    if ( dwRc == ERROR_SUCCESS )
    {
        *pprvs = (SRegValueSet *) new BYTE [ sizeof(SRegValueSet)+
                                             cValues*sizeof(CRegValue *) ];
        if ( *pprvs == NULL )
        {
            dwErr = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        //   QueryInfo failed.
        dwErr = Creg_ERROR(dwRc);
    }
    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    //  loop enumerating and creating a RegValue object for each value
    DWORD   dwIndex=0;

    do
    {
        CHAR   szValueID[MAX_PATH];
        ULONG   cbValueID = sizeof(szValueID);
        DWORD   dwTypeCode;
        CRegValue *pRegVal;

        if ((dwRc = RegEnumValue(_hkThis,         //  handle
                        dwIndex,        //  index
                        szValueID,     //  value id
                        &cbValueID,     //  length of value name
                        NULL,           //  title index
                        &dwTypeCode,    //  data type
                        NULL,           //  data buffer
                        NULL            //  size of data buffer
                      ))==ERROR_SUCCESS)
        {
            //  create the appropriate class of value object
            switch (dwTypeCode)
            {
            case REG_SZ:
                pRegVal = (CRegValue *) new CRegSZ((const CMyRegKey &)*this, szValueID);
                break;

            case REG_DWORD:
                pRegVal = (CRegValue *) new CRegDWORD((const CMyRegKey &)*this, szValueID);
                break;

            case REG_BINARY:
                pRegVal = (CRegValue *) new CRegBINARY((const CMyRegKey &)*this, szValueID);
                break;

            default:
                pRegVal = (CRegValue *) new CRegBINARY((const CMyRegKey &)*this, szValueID);
                break;
            }

            if (pRegVal == NULL) {
                dwRc = ERROR_OUTOFMEMORY;
                break;
            }

            //  save ptr to value object and count another entry
            (*pprvs)->aprvValue[dwIndex++] = pRegVal;
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cValues);


    //  finished the enumeration, check the results
    if (dwRc == ERROR_NO_MORE_ITEMS || dwRc == ERROR_SUCCESS)
    {
        //  set the return count
        (*pprvs)->cValues = dwIndex;
    }
    else
    {
        //  Cleanup and return an error
        while (dwIndex)
        {
            if ((*pprvs)->aprvValue[--dwIndex]) 
                delete (*pprvs)->aprvValue[--dwIndex];
        }

        delete [] *pprvs;

        dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CMyRegKey::EnumKeys, public
//
//  Synopsis:   Enumerates the subkeys of an open registry key.
//
//  Arguments:  [pprks] - SRegKeySet allocated and returned by this method.
//                        The caller is responsible for releasing all the
//                        allocated CMyRegKey objects and the SRegKeySet
//                        structure.
//
//  Signals:    none
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CMyRegKey::EnumKeys(SRegKeySet **pprks)
{
    //  figure out how many keys are currently stored in this key
    //  and allocate a buffer to hold the return results.

    CHAR   szClass[MAX_PATH];
    ULONG   cbClass = sizeof(szClass);
    ULONG   cSubKeys, cbMaxSubKeyLen, cbMaxClassLen;
    ULONG   cValues, cbMaxValueIDLen, cbMaxValueLen;
    SECURITY_DESCRIPTOR SecDescriptor;
    FILETIME ft;
    DWORD  dwErr = ERROR_SUCCESS;   // Error to return
    DWORD dwRc = ERROR_SUCCESS; // Error from registry APIs

    dwRc = RegQueryInfoKey(_hkThis,
                     szClass,
                     &cbClass,
                     NULL,
                     &cSubKeys,
                     &cbMaxSubKeyLen,
                     &cbMaxClassLen,
                     &cValues,
                     &cbMaxValueIDLen,
                     &cbMaxValueLen,
                     (DWORD *)&SecDescriptor,
                     &ft);

    if ( dwRc == ERROR_SUCCESS )
    {
        *pprks = (SRegKeySet*) new BYTE [sizeof(SRegKeySet)+cSubKeys*sizeof(CMyRegKey *)];
        if ( *pprks == NULL )
        {
            dwErr = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        //  QueryInfo failed..
        dwErr = Creg_ERROR(dwRc);
    }

    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }
    //  loop enumerating and creating a RegKey object for each subkey
    DWORD   dwIndex=0;

    do
    {
        CHAR   szKeyName[MAX_PATH];
        ULONG   cbKeyName = sizeof(szKeyName);
        CHAR   szClass[MAX_PATH];
        ULONG   cbClass = sizeof(szClass);
        FILETIME ft;

        if ((dwRc = RegEnumKeyEx(_hkThis,         //  handle
                                dwIndex,        //  index
                                szKeyName,     //  key name
                                &cbKeyName,     //  length of key name
                                NULL,           //  title index
                                szClass,       //  class
                                &cbClass,       //  length of class
                                &ft             //  last write time
                              ))==ERROR_SUCCESS)
        {
            //  Create a CMyRegKey object for the subkey
            CMyRegKey *pRegKey = (CMyRegKey *) new CMyRegKey((const CMyRegKey &)*this, szKeyName);
            if(pRegKey == NULL) {
                dwErr = ERROR_OUTOFMEMORY;
                break;
            }
            if (ERROR_SUCCESS != (dwErr = pRegKey->QueryErrorStatus()))
            {
                break;
            }
            (*pprks)->aprkKey[dwIndex++] = pRegKey;
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cSubKeys);


    //  finished the enumeration, check the results
    if ((dwErr == ERROR_SUCCESS) &&
        ((dwRc == ERROR_NO_MORE_ITEMS || dwRc == ERROR_SUCCESS)))
    {
        //  set the return count
        (*pprks)->cKeys = dwIndex;
    }
    else
    {
        //  Cleanup and return an error
        while (dwIndex)
        {
            delete (*pprks)->aprkKey[--dwIndex];
        }

        delete [] *pprks;

        //
        // If there was a failure in a registry API call, return that error code
        // Otherwise dwErr must have been set to a failure code (for a non-registry failure)
        //
        if(dwRc != ERROR_SUCCESS)
            dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::GetValue, public
//
//  Purpose:    Returns the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to buffer supplied by caller.
//              [cbData] - size of data buffer supplied.
//              [pdwTypeCode] - type of data returned.
//
//  Signals:
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//
//
//--------------------------------------------------------------------------

DWORD CRegValue::GetValue(LPBYTE pbData, ULONG* pcbData, DWORD *pdwTypeCode)
{
    DWORD dwRc = RegQueryValueEx(GetParentHandle(),
                                    (LPSTR)_cszValueID,    //  value id
                                    NULL,        //  title index
                                    pdwTypeCode, //  type of data returned
                                    pbData,       //  data
                                    pcbData);       // size of data
    return(dwRc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::SetValue
//
//  Purpose:    Writes the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to data to write.
//                      [cbData] - size of data to write.
//                      [dwTypeCode] - type of data to write.
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegValue::SetValue(const LPBYTE pbData, ULONG cbData, DWORD dwTypeCode)
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    if ((dwRc = RegSetValueEx(GetParentHandle(),        //  key handle
                             (LPSTR)_cszValueID,  //  value id
                              NULL,      //  title index
                              dwTypeCode,    //  type of info in buffer
                              pbData,        //  data
                              cbData)        //  size of data
                             )!= ERROR_SUCCESS)
    {
        dwErr = Creg_ERROR(dwRc);
    }
    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   DelRegKeyTree
//
//  Purpose:    Deletes a key and any of it's children. This is like
//              delnode for registry
//
//  Arguements: [hParent]      - Handle to Parent Key
//              [lpszKeyPath] - Path (relative to Parent) of the key
//
//  Signals:
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/93    AlokS  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD DelRegKeyTree ( HKEY hParent, LPSTR lpszKeyPath)
{
    DWORD dwErr = ERROR_SUCCESS;
    CMyRegKey cregKey ( hParent,
                      lpszKeyPath
                    );
    if (ERROR_SUCCESS != (dwErr = cregKey.QueryErrorStatus()))
    {
        return(dwErr);
    }

    // Enumerate the children of the key. We will
    // not propogate to the caller errors from enumeration
    SRegKeySet *pRegKeySet = NULL;
    if (ERROR_SUCCESS == (dwErr = cregKey.EnumKeys ( & pRegKeySet)))
    {
        // Now we have set of Keys which need to be deleted in depth
        // first manner
        for (ULONG i = 0; i < pRegKeySet->cKeys; i++ )
        {
            dwErr = DelRegKeyTree ( cregKey.GetHandle(),
                                    (LPSTR) pRegKeySet->aprkKey[i]->GetName()
                               );

            // Delete the key itself
            delete pRegKeySet->aprkKey[i];
        }

        // Delete the enumerator structure
        delete pRegKeySet;
    }

    // Finally delete this key
    dwErr = cregKey.Delete();

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\debug.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Contains data definitions for debug code.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DEBUG_
#define _DEBUG_

#ifdef __cplusplus
extern "C" {
#endif

//
// LOW WORD bit mask (0x0000FFFF) for low frequency debug output.
//
#define DEBUG_ERRORS            0x00000001  // hard errors.
#define DEBUG_REGISTRY          0x00000002  // debug registry calls
#define DEBUG_MISC              0x00000004  // misc info.
#define DEBUG_SCAVENGER         0x00000008  // scavenger debug info.

#define DEBUG_SORT              0x00000010  // debug B-TREE functions
#define DEBUG_CONTAINER         0x00000020  // debug container
#define DEBUG_APIS              0x00000040  // debug tcpsvcs apis
#define DEBUG_FILE_VALIDATE     0x00000080 // validate file map file
#define DEBUG_SVCLOC_MESSAGE    0x00000100  // discovery messages



//
// HIGH WORD bit mask (0x0000FFFF) for high frequency debug output.
// ie more verbose.
//

#define DEBUG_TIMESTAMP         0x00010000  // print time stamps
#define DEBUG_MEM_ALLOC         0x00020000 // memory alloc
#define DEBUG_STARTUP_BRK       0x40000000  // breakin debugger during startup.

#if DBG

#define DEBUG_PRINT OutputDebugString

//
// debug functions.
//

extern DWORD GlobalDebugFlag;
extern CRITICAL_SECTION GlobalDebugCritSect;

#define IF_DEBUG(flag) if (GlobalDebugFlag & (DEBUG_ ## flag))
#define TcpsvcsDbgPrint(_x_) TcpsvcsDbgPrintRoutine _x_

VOID
TcpsvcsDbgPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

VOID
TcpsvcsDbgAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    );

#define TcpsvcsDbgAssert(Predicate) \
    { \
        if (!(Predicate)) \
            TcpsvcsDbgAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }

#else

#define IF_DEBUG(flag) if (FALSE)

#define TcpsvcsDbgPrint(_x_)
#define TcpsvcsDbgAssert(_x_)

#endif // DBG

#if DBG
#define INLINE
#else
#define INLINE      inline
#endif

#ifdef __cplusplus
}
#endif

#endif  // _DEBUG_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\vroot\utest\testvr.cpp ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <stdio.h>
#include <windows.h>
#include <dbgtrace.h>
#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#include <listmacr.h>
#include <vroot.h>
#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <iadmw.h>
#include <atlimpl.cpp>
#include <mddef.h>
#include <iiscnfg.h>
#include <xmemwrpr.h>

// INI file keys, etc
#define INI_SECTIONNAME "testvr"
#define INI_KEY_MBPATH "MetabasePath"
#define DEF_KEY_MBPATH "/LM/testvr"
#define INI_KEY_LOOKUPTHREADS "LookupThreads"
#define DEF_KEY_LOOKUPTHREADS 10
#define INI_KEY_LOOKUPITERATIONS "LookupIterations"
#define DEF_KEY_LOOKUPITERATIONS 10000
#define INI_KEY_CHANGEPERIOD "ChangePeriod"
#define DEF_KEY_CHANGEPERIOD 500
#define INI_KEY_VROOTNAME "VRoot%i"

//
// VRoot engine unit test
//
// This test takes a section of the metabase and makes it look like a vroot
// tree, using vroot names specified in the INI file.  It then has N threads
// which make up random group names, do VRoot lookups on the group names, and
// makes sure that the groups map to the proper vroot.  Finally it creates
// another thread which periodically goes through the VRoots and either
// adds, removes, or renames vroots, to keep the vroot table on its toes.
// It does this for a given number of iterations and then finishes.
//

// path to our corner of the metabase, in ascii and unicode
WCHAR g_wszMBPath[1024];
char g_szMBPath[1024];

// the vroot table that we are testing.
typedef CIISVRootTmpl<LPCSTR> CTestVRoot;
typedef CIISVRootTable<CTestVRoot, LPCSTR> CTestVRootTable;
typedef CRefPtr2<CTestVRoot> TESTVROOTPTR;
CTestVRootTable *g_pVRTable;

// metabase pointers used by the unit test
static IMSAdminBaseW *g_pMB;

// parameters
DWORD g_cChangePeriod = DEF_KEY_CHANGEPERIOD;
DWORD g_cLookupThreads = DEF_KEY_LOOKUPTHREADS;
DWORD g_cLookupIterations = DEF_KEY_LOOKUPITERATIONS;

// this handle is signalled when the change thread needs to stop running
HANDLE g_heStop;
// our array of thread handles
HANDLE *g_rghThreads;
DWORD g_cThreads;

class CTestVRootData;

// our array of vroots, containing information read in from the INI file.
DWORD g_cVRoots;
CTestVRootData *g_rgVRData;

class CTestVRootData {
	public:
		CTestVRootData() {
			m_pszVRoot = NULL;
			m_pwszMBPath = NULL;
		}
		void Init(char *pszVRoot) {
			m_lock.ExclusiveLock();
			DWORD l = lstrlen(pszVRoot) + 1;
			DWORD l2 = wcslen(g_wszMBPath) + l + 1;
			m_fInMB = (*pszVRoot == 0) ? TRUE : FALSE;
			m_pszVRoot = new char[l];
			m_pwszMBPath = new WCHAR[l2];
			strcpy(m_pszVRoot, pszVRoot);
			_snwprintf(m_pwszMBPath, l2, L"%s%s%S",
				g_wszMBPath,
				(*m_pszVRoot == 0) ? "" : "/",
				m_pszVRoot);
			m_cchMBPath = lstrlenW(m_pwszMBPath);
			// convert all of the /'s in m_pszVRoot to .'s
			for (char *p = m_pszVRoot; *p != 0; p++) {
				if (*p == '/') *p = '.';
			}
			m_lock.ExclusiveUnlock();
		}
		~CTestVRootData() {
			if (m_pszVRoot != NULL) delete[] m_pszVRoot;
			if (m_pwszMBPath != NULL) delete[] m_pwszMBPath;
		}

		WCHAR *GetMBPath() { return m_pwszMBPath; }
		char *GetVRootName() { return m_pszVRoot; }

		//
		// this grabs the shared lock and tells the caller if this entry
		// should be in the metabase or not.  it'll stay that way until
		// they call ReadUnlock, at which point its status can change
		//
		BOOL ReadLock() {
			m_lock.ShareLock();
			return m_fInMB;
		}

		void ReadUnlock() {
			m_lock.ShareUnlock();
		}

		//
		// this set of functions will add or remove an entry from the
		// metabase, and update the status of the entry as well.
		//
		void ToggleInMB() {
			METADATA_HANDLE hmRoot;

			m_lock.ExclusiveLock();
		
			g_pMB->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   L"",
						   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
						   100,
						   &hmRoot);

			if (m_fInMB) {
				printf("removing %S from MB\n", m_pwszMBPath);

				// grab the locks on our children and mark them as not being
				// in the metabase.
				DWORD i, l = m_cchMBPath;
				for (i = 0; i < g_cVRoots; i++) {
			    	if ((_wcsnicmp(m_pwszMBPath, g_rgVRData[i].GetMBPath(), l) == 0) &&
						((g_rgVRData + i) != this))
					{
						printf("removing child %S from MB\n", g_rgVRData[i].m_pwszMBPath);
						g_rgVRData[i].m_lock.ExclusiveLock();
					}
				}

				// delete our path (and all of our subchildren)
				HRESULT hr = g_pMB->DeleteKey(hmRoot, this->GetMBPath());

				// now go release all of the locks that we grabbed
				for (i = 0; i < g_cVRoots; i++) {
			    	if ((_wcsnicmp(m_pwszMBPath, g_rgVRData[i].GetMBPath(), l) == 0) &&
						((g_rgVRData + i) != this))
					{
						if (SUCCEEDED(hr)) g_rgVRData[i].m_fInMB = FALSE;
						g_rgVRData[i].m_lock.ExclusiveUnlock();
					} 				
				}

				// do error checking
				if (FAILED(hr)) {
					//_ASSERT(SUCCEEDED(hr));
					printf("DeleteKey(\"%S\") returned %x\n", this->GetMBPath(), hr);
				} else {
					m_fInMB = FALSE;
				}
			} else {
				printf("adding %S to MB\n", m_pwszMBPath);

				// grab the locks on our parents and mark them as being
				// in the metabase.
				DWORD i;
				for (i = 0; i < g_cVRoots; i++) {
					DWORD l = g_rgVRData[i].m_cchMBPath;
			    	if ((_wcsnicmp(m_pwszMBPath, g_rgVRData[i].GetMBPath(), l) == 0) &&
						((g_rgVRData + i) != this))
					{
						printf("adding parent %S to MB\n", g_rgVRData[i].m_pwszMBPath);
						g_rgVRData[i].m_lock.ExclusiveLock();
					}
				}

				// add ourselves to the metabase
				HRESULT hr = g_pMB->AddKey(hmRoot, this->GetMBPath());

				if (SUCCEEDED(hr)) {
					WCHAR szVRPath[] = L"dummy vrpath";
					METADATA_RECORD mdrValue = {
					    MD_VR_PATH,
					    METADATA_INHERIT,
					    ALL_METADATA,
					    STRING_METADATA,
						sizeof(szVRPath),
					    (BYTE *) szVRPath,
					    0
					};
					hr = g_pMB->SetData(hmRoot, this->GetMBPath(), &mdrValue);
				}

				// release locks
				for (i = 0; i < g_cVRoots; i++) {
					DWORD l = g_rgVRData[i].m_cchMBPath;
			    	if ((_wcsnicmp(m_pwszMBPath, g_rgVRData[i].GetMBPath(), l) == 0) &&
						((g_rgVRData + i) != this))
					{
						if (SUCCEEDED(hr)) {
							HRESULT hrSet;
							WCHAR szVRPath[] = L"dummy vrpath";
							METADATA_RECORD mdrValue = {
							    MD_VR_PATH,
					    		METADATA_INHERIT,
							    ALL_METADATA,
							    STRING_METADATA,
								sizeof(szVRPath),
							    (BYTE *) szVRPath,
							    0
							};
							hrSet = g_pMB->SetData(hmRoot,
												g_rgVRData[i].GetMBPath(),
												&mdrValue);
							if (SUCCEEDED(hrSet)) g_rgVRData[i].m_fInMB = TRUE;
						}
						g_rgVRData[i].m_lock.ExclusiveUnlock();
					}
				}

				// error checking
				if (FAILED(hr)) {
					//_ASSERT(SUCCEEDED(hr));
					printf("AddKey(\"%S\") returned %x\n", this->GetMBPath(), hr);
				} else {
					m_fInMB = TRUE;
				}
			}

			g_pMB->CloseKey(hmRoot);

			m_lock.ExclusiveUnlock();
		}

		void ChangeProperty() {
			m_lock.ExclusiveLock();
			
			if (m_fInMB) {
				DWORD dwValue = rand();
				METADATA_HANDLE hm;

				printf("changing property 0 in %S to %lu\n",
					m_pwszMBPath,
					dwValue);

				g_pMB->OpenKey(METADATA_MASTER_ROOT_HANDLE,
							   m_pwszMBPath,
							   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
							   100,
							   &hm);

				METADATA_RECORD mdrValue = {
				    0,
				    METADATA_INHERIT,
				    ALL_METADATA,
				    DWORD_METADATA,
					sizeof(DWORD),
				    (BYTE *) &dwValue,
				    0
				};
				HRESULT hr = g_pMB->SetData(hm, L"", &mdrValue);
				if (FAILED(hr)) {
					printf("SetData failed with 0x%x\n", hr);
				}

				g_pMB->CloseKey(hm);
			}

			m_lock.ExclusiveUnlock();
	   	}

		BOOL InMB() { return m_fInMB; }
	private:
		char *m_pszVRoot;
		WCHAR *m_pwszMBPath;
		DWORD m_cchMBPath;
		BOOL m_fInMB;
		CShareLockNH m_lock;
};

// this is a special entry for the root.  we never add or remove the root,
// we just change properties in it
CTestVRootData g_vrRoot;

// get a DWORD from an INI file
int GetINIDWord(char *szINIFile, char *szKey, char *szSectionName, DWORD dwDefault) {
	char szBuf[MAX_PATH];

	GetPrivateProfileString(szSectionName,
							szKey,
							"default",
							szBuf,
							MAX_PATH,
							szINIFile);

	if (strcmp(szBuf, "default") == 0) {
		return dwDefault;
	} else {
		return atoi(szBuf);
	}
}

// read our parameters from the INI file.
void ReadINIFile(char *szINIFile, char *szSectionName) {
	DWORD i;
	char szBuf[1024];

	g_cLookupThreads = GetINIDWord(szINIFile, INI_KEY_LOOKUPTHREADS, szSectionName, g_cLookupThreads);
	g_cLookupIterations = GetINIDWord(szINIFile, INI_KEY_LOOKUPITERATIONS, szSectionName, g_cLookupIterations);

	// get the base metabase path
	GetPrivateProfileString(szSectionName,
							INI_KEY_MBPATH,
							DEF_KEY_MBPATH,
							szBuf,
							1024,
							szINIFile);
	mbstowcs(g_wszMBPath, szBuf, 1024);
	strcpy(g_szMBPath, szBuf);

	// get the number of vroots listed in the INI file
	for (g_cVRoots = 0; *szBuf != 0; g_cVRoots++) {
		char szKey[20];
		sprintf(szKey, INI_KEY_VROOTNAME, g_cVRoots);
		GetPrivateProfileString(szSectionName,
								szKey,
								"",
								szBuf,
								1024,
								szINIFile);
	}

	// fix off by one error
	g_cVRoots--;

	if (g_cVRoots == 0) {
		printf("At least one VRoot must be listed in the INI file\n");
		exit(1);
	}

	g_vrRoot.Init("");

	// allocate an array of vroots
	g_rgVRData = new CTestVRootData[g_cVRoots];
	for (i = 0; i < g_cVRoots; i++) {
		char szKey[20];
		sprintf(szKey, INI_KEY_VROOTNAME, i);
		GetPrivateProfileString(szSectionName,
								szKey,
								"",
								szBuf,
								1024,
								szINIFile);		
		g_rgVRData[i].Init(szBuf);
	}
}

// bring the metabase to an initial known state
void Initialize() {
	DWORD i;
	HRESULT hr;
	METADATA_HANDLE hmRoot;

	// initialize COM and create the metabase object
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	_ASSERT(SUCCEEDED(hr));

	hr = CoCreateInstance(CLSID_MSAdminBase_W, NULL, CLSCTX_ALL,
						  IID_IMSAdminBase_W, (LPVOID *) &g_pMB);
	_ASSERT(SUCCEEDED(hr));

	hr = g_pMB->OpenKey(METADATA_MASTER_ROOT_HANDLE,
				        L"",
				        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
				        100,
				        &hmRoot);
	_ASSERT(SUCCEEDED(hr));

	// first we delete whatever exists in the metabase under this path,
	// then we create a new area to play in
	g_pMB->DeleteKey(hmRoot, g_wszMBPath);
	hr = g_pMB->AddKey(hmRoot, g_wszMBPath);
	if (SUCCEEDED(hr)) {
		WCHAR szVRPath[] = L"dummy vrpath";
		METADATA_RECORD mdrValue = {
		    MD_VR_PATH,
		    METADATA_INHERIT,
		    ALL_METADATA,
		    STRING_METADATA,
			sizeof(szVRPath),
		    (BYTE *) szVRPath,
		    0
		};
		hr = g_pMB->SetData(hmRoot, g_wszMBPath, &mdrValue);
	}
	g_pMB->CloseKey(hmRoot);
	_ASSERT(SUCCEEDED(hr));

	// now we go through the list of VRoots and add each of them to the metabase
	for (i = 0; i < g_cVRoots; i++) g_rgVRData[i].ToggleInMB();

	// create the change thread stop event
	g_heStop = CreateEvent(NULL, FALSE, FALSE, NULL);
	_ASSERT(g_heStop != NULL);

	// allocate memory for our thread array
	g_cThreads = g_cLookupThreads + 1;
	g_rghThreads = new HANDLE[g_cThreads];
	_ASSERT(g_rghThreads != NULL);

	// initialize the vroot table
	g_pVRTable = new CTestVRootTable(NULL, NULL);
	hr = g_pVRTable->Initialize(g_szMBPath, FALSE);
	printf("g_pVRTable->Initialize(\"%s\") returned %x\n", g_szMBPath, hr);
	_ASSERT(SUCCEEDED(hr));
}

// clean up whatever mess we made in the metabase
void Shutdown() {
	delete g_pVRTable;

	// clean up our mess
	METADATA_HANDLE hmRoot;
	HRESULT hr;
	hr = g_pMB->OpenKey(METADATA_MASTER_ROOT_HANDLE,
				        L"",
				        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
				        100,
				        &hmRoot);
	_ASSERT(SUCCEEDED(hr));
	hr = g_pMB->DeleteKey(hmRoot, g_wszMBPath);
	_ASSERT(SUCCEEDED(hr));
	g_pMB->CloseKey(hmRoot);

	// close our metabase pointer
	g_pMB->Release();
	g_pMB = NULL;

	CoUninitialize();
}

// this thread runs and adds and removes random vroots in the metabase
DWORD WINAPI ChangeThread(LPVOID lpContext) {
	srand(GetTickCount() * GetCurrentThreadId());
	do {
		//
		// figure out if we are going to add/remove a vroot or change a
		// vroot property
		//
		// 1/3 of changes are property changes
		// 2/3 of changes are vroot additions/deletions
		//
		if ((rand() % 3) == 0) {
			DWORD iVR;
			// find a vroot that is in the metabase
			do {
				iVR = rand() % (g_cVRoots + 1);
			} while (iVR != g_cVRoots && !(g_rgVRData[iVR].InMB()));

			// write some data to its metabase path
			if (iVR == g_cVRoots) {
				g_vrRoot.ChangeProperty();
			} else {
				g_rgVRData[iVR].ChangeProperty();
			}
		} else {
			DWORD iVR = rand() % g_cVRoots;
			g_rgVRData[iVR].ToggleInMB();
		}
	} while (WaitForSingleObject(g_heStop, g_cChangePeriod) == WAIT_TIMEOUT);
	return 0;
}

// start up the change thread
void StartChangeThread(void) {
	DWORD id;
	g_rghThreads[0] = CreateThread(NULL, 0, ChangeThread, NULL, 0, &id);
	_ASSERT(g_rghThreads[0] != NULL);
}

// this thread function makes g_cLookupIterations of finding VRoots and
// doing a lookup of them in the metabase to make sure that we get the
// correct return.
DWORD WINAPI LookupThread(LPVOID lpContext) {
	DWORD cErrors = 0;
	DWORD iIteration;

	srand(GetTickCount() * GetCurrentThreadId());
	for (iIteration = 0; iIteration < g_cLookupIterations; iIteration++) {
		DWORD iVR = rand() % (g_cVRoots + 1);
		char szGroup[1024];
		char szVRootName[1024];
		WCHAR wszMBPath[1024];
		BOOL fInMB;

		// generate a randow group name
		if (iVR == g_cVRoots) {
			*szVRootName = 0;
			*szGroup = 0;
			lstrcpyW(wszMBPath, g_wszMBPath);
			fInMB = TRUE;
			DWORD j, cCharacters = (rand() % 10) + 2;
			char iCh = (char) (rand() % 26);
			for (j = 0; j < cCharacters; j++) {
				char iCh = (char) (rand() % 26);
				char ch = 'a' + iCh;
				szGroup[j] = ch;		
			}
			szGroup[j] = 0;
		} else {
			fInMB = g_rgVRData[iVR].ReadLock();
			strcpy(szVRootName, g_rgVRData[iVR].GetVRootName());
			strcpy(szGroup, g_rgVRData[iVR].GetVRootName());
			lstrcpyW(wszMBPath, g_rgVRData[iVR].GetMBPath());
			g_rgVRData[iVR].ReadUnlock();
		}
		// we will have up to 4 dots, weighted towards having 0 to 3
		char *p = &(szGroup[strlen(szGroup)]);
		_ASSERT(*p == 0);
		DWORD i, cGroupSections = (rand() % 8) % 5;
		for (i = 0; i < cGroupSections; i++) {
			DWORD j, cCharacters = (rand() % 10) + 2;
			*(p++) = '.';
			for (j = 0; j < cCharacters; j++) {
				char iCh = (char) (rand() % 26);
#if 0
				char ch = (iCh < 10) ? iCh + '0' :
					      (iCh < 36) ? iCh + 'a' :
							           iCh + 'A';
#endif
				char ch = 'a' + iCh;
				*(p++) = ch;
			}
		}
		*p = 0;

		TESTVROOTPTR pVRoot;
		HRESULT hr = g_pVRTable->FindVRoot(szGroup, &pVRoot);
		if (FAILED(hr)) {
			cErrors++;
			printf("ERROR: FindVRoot(\"%s\") failed with %x\n",
				szGroup, hr);
//			if (iVR != g_cVRoots) g_rgVRData[iVR].ReadUnlock();
			continue;
		}
		
		if (fInMB) {
			if (_wcsicmp(pVRoot->GetConfigPath(), wszMBPath) != 0) {
				cErrors++;
				printf("ERROR: looking for \"%s\" (vroot == \"%s\" \"%S\"), found vroot \"%s\" \"%S\"\n",
					szGroup,
					szVRootName,
					wszMBPath,
					pVRoot->GetVRootName(),
					pVRoot->GetConfigPath());
			}
		} else {
			DWORD l1 = wcslen(pVRoot->GetConfigPath());
			DWORD l2 = wcslen(wszMBPath);
			DWORD l = min(l1, l2);
			if ((l1 == l2) ||
			    (_wcsnicmp(pVRoot->GetConfigPath(),
						   wszMBPath,
						   l) != 0))
			{
				cErrors++;
				printf("ERROR: looking for \"%s\" (vroot != \"%s\" \"%S\"), found vroot \"%s\" \"%S\"\n",
					szGroup,
					szVRootName,
					wszMBPath,
					pVRoot->GetVRootName(),
					pVRoot->GetConfigPath());
			}
		}

//		if (iVR != g_cVRoots) g_rgVRData[iVR].ReadUnlock();
	}

	return cErrors;
}

void StartLookupThreads() {
	DWORD i;

	printf("starting %i lookup threads\n", g_cLookupThreads);
	for (i = 0; i < g_cLookupThreads; i++) {
		DWORD id;
		g_rghThreads[i+1] = CreateThread(NULL, 0, LookupThread, NULL, 0, &id);
		_ASSERT(g_rghThreads[i+1] != NULL);
	}
}

// wait for all of the lookup threads to finish.  then shutdown the
// change thread and check all of the threads for errors.
DWORD WaitForThreads() {
	DWORD i, rc = 0;

	// wait for all of the lookup threads to signal that they are done
	printf("waiting for %i threads\n", g_cThreads);
	_ASSERT(g_cThreads == g_cLookupThreads + 1);
	if (g_cThreads > 1) {
		WaitForMultipleObjects(g_cThreads-1, g_rghThreads+1, TRUE, INFINITE);
	}
	printf("all lookup threads are done, stopping change thread\n");

	// signal the stop event for the change thread and wait for it
	SetEvent(g_heStop);
	WaitForSingleObject(g_rghThreads[0], INFINITE);

	printf("change thread is done, getting error count\n");

	// check everyone's return status
	for (i = 0; i < g_cThreads; i++) {
		DWORD ec;

		_VERIFY(GetExitCodeThread(g_rghThreads[i], &ec));
		if (ec != 0) rc += ec;
	}

	return rc;
}

int _cdecl main(int argc, char **argv) {

    //
    // Initialize global heap
    //
    _VERIFY( ExchMHeapCreate( NUM_EXCHMEM_HEAPS, 0, 100 * 1024, 0 ) );

	CVRootTable::GlobalInitialize();

	_Module.Init(NULL, (HINSTANCE) INVALID_HANDLE_VALUE);

	int ec, rc;

	if (argc != 2 && argc != 3 || (strcmp(argv[0], "/help") == 0)) {
		printf("usage: testvr testfile.ini [section name]\n");
		printf("\n");
		printf("the following keys are read from the ini file (section %s):\n", INI_SECTIONNAME);
		printf("  %s - the MB path where vroots will be added and\n", INI_KEY_MBPATH);
		printf("    deleted.  this area will be trashed (default %s)\n", DEF_KEY_MBPATH);
		printf("  %s - the number of lookup threads that will be\n", INI_KEY_LOOKUPTHREADS);
		printf("    running at once (default %i)\n", DEF_KEY_LOOKUPTHREADS);
		printf("  %s - the number of lookups made by each lookup thread\n", INI_KEY_LOOKUPITERATIONS);
		printf("    before completing (default %i)\n", DEF_KEY_LOOKUPITERATIONS);
		printf("  %s - delay between changes made to the vroot\n", INI_KEY_CHANGEPERIOD);
		printf("    table, in ms (default %i)\n", DEF_KEY_CHANGEPERIOD);
		printf("  %s - list of vroot paths (like alt/binaries) that the\n", INI_KEY_VROOTNAME);
		printf("    unit test can write into the metabase\n");
		rc = -1;
	} else {
		char szDefSectionName[] = "testvr",
			 *szSectionName = (argc == 2) ? szDefSectionName : argv[2];
		ReadINIFile(argv[1], szSectionName);
		Initialize();
		StartChangeThread();
		StartLookupThreads();
		ec = WaitForThreads();
		printf("error count = %i\n", ec);
		CloseHandle(g_heStop);
		Shutdown();
	}

	//
	// if more then .01% of our finds return unexpected results then we fail
	// the test.  we have to allow for some unexpected results because there
	// are uncloseable timing holes between the changes that this unit test
	// makes and the time that the VRootTable gets updated.  closing these
	// holes would require syncronization between the unit test and
	// VRootTable.
	//
	int cMaxAllowableErrors =
		((g_cLookupIterations * g_cLookupThreads) / 1000);
	printf("Maximum allowable errors = %i (0.1%% of lookups can fail)\n",
		cMaxAllowableErrors);
	if (ec > cMaxAllowableErrors) {
		rc = ec;
		printf("too many errors!  failing test!\n");
	} else {
		rc = 0;
		printf("test passed\n");
	}

	_Module.Term();

	//
	// Terminate the global heap
	//
	_VERIFY( ExchMHeapDestroy() );


	CVRootTable::GlobalShutdown();

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\dllinit.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    accslib.h

Abstract:

    Proto type definitions for access product lib functions.

Author:

    Madan Appiah (madana) 11-Oct-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DLLINIT_
#define _DLLINIT_


DWORD
DllProcessAttachDomainFilter(
    VOID
    );

DWORD
DllProcessDetachDomainFilter(
    VOID
    );

DWORD
DllProcessAttachDiskCache(
    VOID
    );

DWORD
DllProcessDetachDiskCache(
    VOID
    );

#endif _DLLINIT_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\global.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachedef.h

Abstract:

    contains global data declerations.

Author:

    Madan Appiah (madana)  12-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _GLOBAL_
#define _GLOBAL_

#ifdef __cplusplus
extern "C" {
#endif


//
// global variables.
//

extern MEMORY *CacheHeap;


//
// svccom.cxx will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//

#ifdef  GLOBAL_SVC_DATA_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN BOOL GlobalSrvRegistered;
EXTERN MEMORY *SvclocHeap;
EXTERN EMBED_SERVER_INFO *GlobalSrvInfoObj;
EXTERN CRITICAL_SECTION GlobalSvclocCritSect;

EXTERN LPBYTE GlobalSrvRespMsg;
EXTERN DWORD GlobalSrvRespMsgLength;
EXTERN DWORD GlobalSrvAllotedRespMsgLen;

EXTERN LPBYTE GlobalSrvRecvBuf;
EXTERN DWORD GlobalSrvRecvBufLength;

EXTERN CHAR GlobalComputerName[MAX_COMPUTERNAME_LENGTH + 1 + 1];
    //
    // additional CHAR for win95, GetComputerName on win95
    // expects 16 char buffer always.
    //

//
// winsock data.
//

EXTERN WSADATA GlobalWinsockStartupData;
EXTERN BOOL GlobalWinsockStarted;
EXTERN BOOL GlobalRNRRegistered;

EXTERN HANDLE GlobalSrvListenThreadHandle;

EXTERN GUID GlobalSapGuid;
EXTERN fd_set GlobalSrvSockets;

EXTERN HANDLE GlobalCliDiscoverThreadHandle;

EXTERN LPBYTE GlobalCliQueryMsg;
EXTERN DWORD GlobalCliQueryMsgLen;

EXTERN fd_set GlobalCliSockets;
EXTERN fd_set GlobalCliNBSockets;
EXTERN SOCKET GlobalCliIpxSocket;

EXTERN LIST_ENTRY GlobalCliQueryRespList;

EXTERN HANDLE GlobalDiscoveryInProgressEvent;
EXTERN time_t GlobalLastDiscoveryTime;

EXTERN BYTE GlobalSapBroadcastAddress[];

EXTERN DWORD GlobalPlatformType;

EXTERN DWORD GlobalNumNBPendingRecvs;
EXTERN NCB *GlobalNBPendingRecvs;

EXTERN LIST_ENTRY GlobalWin31NBRespList;
EXTERN DWORD GlobalWin31NumNBResps;

#ifdef __cplusplus
}
#endif

#endif  // _GLOBAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\proto.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    contains global data declerations.

Author:

    Madan Appiah (madana)  12-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PROTO_
#define _PROTO_

#ifdef __cplusplus
extern "C" {
#endif

//
// svccom.cxx
//

DWORD
MakeSapServiceName(
    LPSTR SapNameBuffer,
    DWORD SapNameBufferLen
    );

VOID
MakeUniqueServerName(
    LPBYTE StrBuffer,
    DWORD StrBufferLen,
    LPSTR ComputerName
    );

DWORD
ComputeCheckSum(
    LPBYTE Buffer,
    DWORD BufferLength
    );

BOOL
DLLSvclocEntry(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    );

DWORD
DllProcessAttachSvcloc(
    VOID
    );

DWORD
DllProcessDetachSvcloc(
    VOID
    );

VOID
FreeServiceInfo(
    LPINET_SERVICE_INFO ServiceInfo
    );

VOID
FreeServerInfo(
    LPINET_SERVER_INFO ServerInfo
    );

VOID
FreeServersList(
    LPINET_SERVERS_LIST ServersList
    );

BOOL
GetNetBiosLana(
    PLANA_ENUM pLanas
    );

BOOL
GetEnumNBLana(
    PLANA_ENUM pLanas
    );

BOOL
MakeNBSocketForLana(
    UCHAR Lana,
    PSOCKADDR  pSocketAddress,
    SOCKET *pNBSocket
    );

//
// svccli.cxx
//

DWORD
DiscoverIpxServers(
    LPSTR ServerName
    );

DWORD
DiscoverIpServers(
    LPSTR ServerName
    );

DWORD
ProcessSvclocQueryResponse(
    SOCKET ReceivedSocket,
    LPBYTE ReceivedMessage,
    DWORD ReceivedMessageLength,
    SOCKADDR *SourcesAddress,
    DWORD SourcesAddressLength
    );

VOID
ServerDiscoverThread(
    LPVOID Parameter
    );

DWORD
MakeClientQueryMesage(
    ULONGLONG ServicesMask
    );

DWORD
CleanupOldResponses(
    VOID
    );

DWORD
GetDiscoveredServerInfo(
    LPSTR ServerName,
    IN ULONGLONG ServicesMask,
    LPINET_SERVER_INFO *ServerInfo
    );

DWORD
ProcessDiscoveryResponses(
    IN ULONGLONG ServicesMask,
    OUT LPINET_SERVERS_LIST *INetServersList
    );

DWORD
ReceiveResponses(
    WORD Timeout,
    BOOL WaitForAllResponses
    );

DWORD
DiscoverNetBiosServers(
    LPSTR ServerName
    );

DWORD
ReceiveNetBiosResponses(
    LPSVCLOC_NETBIOS_RESPONSE *NetBiosResponses,
    DWORD *NumResponses,
    DWORD TimeoutinMSecs,
    BOOL WaitForAllResponses
    );

//
// svcsrv.cxx
//

DWORD
MakeResponseBuffer(
    VOID
    );

DWORD
ServerRegisterAndListen(
    VOID
    );

DWORD
ProcessSvclocQuery(
    SOCKET ReceivedSocket,
    LPBYTE ReceivedMessage,
    DWORD ReceivedMessageLength,
    struct sockaddr *SourcesAddress,
    DWORD SourcesAddressLength
    );

VOID
SocketListenThread(
    LPVOID Parameter
    );

DWORD
ServerDeregisterAndStopListen(
    VOID
    );

#ifdef __cplusplus
}
#endif

#endif  // _PROTO_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\accslib.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    accslib.h

Abstract:

    Proto type definitions for access product lib functions.

Author:

    Madan Appiah (madana) 11-Oct-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _ACCSLIB_
#define _ACCSLIB_

#ifdef __cplusplus
extern "C" {
#endif

PVOID
MIDL_user_allocate(
    size_t Size
    );

VOID
MIDL_user_free(
    PVOID MemoryPtr
    );

#ifdef __cplusplus
}
#endif

#endif  // _ACCSLIB_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\svcdef.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachedef.h

Abstract:

    contains data definitions for cache code.

Author:

    Madan Appiah (madana)  12-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include <iisver.h>
#include <spxinfo.h>

#ifndef _SVCDEF_
#define _SVCDEF_

#ifdef __cplusplus
extern "C" {
#endif

//
// defines.
//

#define INET_MAJOR_VERSION       VER_IISMAJORVERSION
#define INET_MINOR_VERSION       VER_IISMINORVERSION

#define LOCK_SVC_GLOBAL_DATA()        EnterCriticalSection( &GlobalSvclocCritSect )
#define UNLOCK_SVC_GLOBAL_DATA()      LeaveCriticalSection( &GlobalSvclocCritSect )

#define SVCLOC_SRV_RECV_BUFFER_SIZE     0x400   // 1k buffer.
#define SVCLOC_SRV_ADDRESS_BUFFER       0x1000  // 4k buffer

#define SVCLOC_CLI_QUERY_RESP_BUF_SIZE  0x400   // 1 buffer

//
// service location thread shutdown timeout.
//

#define THREAD_TERMINATION_TIMEOUT      60000           // in msecs. 60 secs
#define RESPONSE_WAIT_TIMEOUT           60000           // in msecs. 60 secs


#define WS_VERSION_REQUIRED     MAKEWORD( 1, 1)

//
// the fields of the GUID, generated using uuidgen
//

#define ssgData1        0xa5569b20
#define ssgData2        0xabe5
#define ssgData3        0x11ce
#define ssgData41       0x9c
#define ssgData42       0xa4
#define ssgData43       0x00
#define ssgData44       0x00
#define ssgData45       0x4c
#define ssgData46       0x75
#define ssgData47       0x27
#define ssgData48       0x31

#define SERVICE_GUID_STR "A5569B20ABE511CE9CA400004C762832"

#define NETBIOS_INET_GROUP_NAME "INet~Services  \034"
#define NETBIOS_INET_GROUP_NAME_LEN \
    (sizeof(NETBIOS_INET_GROUP_NAME) - 1)

#define NETBIOS_INET_UNIQUE_NAME    "I~"
#define NETBIOS_INET_UNIQUE_NAME_LEN    \
    (sizeof(NETBIOS_INET_UNIQUE_NAME) - 1)

#define NETBIOS_INET_SERVER_UNIQUE_NAME    "IS~"
#define NETBIOS_INET_SERVER_UNIQUE_NAME_LEN    \
    (sizeof(NETBIOS_INET_SERVER_UNIQUE_NAME) - 1)

#define INET_SERVER_RESPONSE_TIMEOUT    15 * 60 // in secs.
#define INET_DISCOVERY_RETRY_TIMEOUT    5 * 60 // in secs.
#define SVCLOC_NB_RECV_TIMEOUT          2 * 60 // in secs.

#define SAP_SERVICE_NAME_LEN    (MAX_COMPUTERNAME_LENGTH + 32)
#define SAP_ADDRESS_LENGTH      15
#define IPX_ADDRESS_LENGTH      12
#define SAP_MAXRECV_LENGTH      544 // ??

//
// typedefs
//

//
// to form a list of server list.
//

typedef struct _LIST_SERVER_INFO {
    LIST_ENTRY NextEntry;
    INET_SERVER_INFO ServerInfo;
} LIST_SERVER_INFO, *LPLIST_SERVER_INFO;


typedef struct _CLIENT_QUERY_RESPONSE {
    LIST_ENTRY NextEntry;
    SOCKET ReceivedSocket;
    LPBYTE ResponseBuffer;
    DWORD ResponseBufferLength;
    SOCKADDR *SourcesAddress;
    DWORD SourcesAddressLength;
    time_t TimeStamp;
} CLIENT_QUERY_RESPONSE, *LPCLIENT_QUERY_RESPONSE;

typedef struct _CLIENT_QUERY_MESSAGE {
    DWORD MsgLength;
    DWORD MsgVersion;
    ULONGLONG ServicesMask;
    CHAR ClientName[1];    // embedded string.
} CLIENT_QUERY_MESSAGE, *LPCLIENT_QUERY_MESSAGE;

//
// Sap service query packet format
//

typedef struct _SAP_REQUEST {
    WORD QueryType;
    WORD ServerType;
} SAP_REQUEST, *PSAP_REQUEST;

//
// Sap server identification packet format
//

typedef struct _SAP_IDENT_HEADER {
    WORD ServerType;
    BYTE  ServerName[48];
    BYTE  Address[IPX_ADDRESS_LENGTH];
    WORD HopCount;
} SAP_IDENT_HEADER, *LPSAP_IDENT_HEADER;

typedef struct _SAP_ADDRESS_INFO {
    CHAR  ServerName[MAX_COMPUTERNAME_LENGTH+1];
    BYTE  Address[IPX_ADDRESS_LENGTH];
    WORD HopCount;
} SAP_ADDRESS_INFO, *LPSAP_ADDRESS_INFO;

typedef struct _SAP_ADDRESS_ENTRY {
    LIST_ENTRY Next;
    SAP_ADDRESS_INFO Address;
} SAP_ADDRESS_ENTRY, *LPSAP_ADDRESS_ENTRY;

typedef struct _SVCLOC_NETBIOS_RESPONSE {
    LPBYTE ResponseBuffer;
    DWORD ResponseBufLen;
    SOCKADDR_NB SourcesAddress;
    DWORD SourcesAddrLen;
} SVCLOC_NETBIOS_RESPONSE, *LPSVCLOC_NETBIOS_RESPONSE;

typedef struct _SVCLOC_NETBIOS_RESP_ENTRY {
    LIST_ENTRY Next;
    SVCLOC_NETBIOS_RESPONSE Resp;
} SVCLOC_NETBIOS_RESP_ENTRY, *LPSVCLOC_NETBIOS_RESP_ENTRY;

#ifdef __cplusplus
}
#endif


#endif  // _SVCDEF_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\staxcore\vroot\src\vrtable.cpp ===
#define __VRTABLE_CPP__
#include "stdinc.h"
//#include <atlimpl.cpp>
#include "iiscnfg.h"

static CComObject<CChangeNotify> *g_pMBNotify;
static IMSAdminBase *g_pMB = NULL;				// used to access the metabase
static IMSAdminBase *g_pMBN = NULL;				// used to access the metabase
static IsValidVRoot(METADATA_HANDLE hmb, WCHAR *wszPath);

//
// helper function to do a strcpy from an ansi string to an unicode string.
//
// parameters:
//   wszUnicode - the destination unicode string
//   szAnsi - the source ansi string
//   cchMaxUnicode - the size of the wszUnicode buffer, in unicode characters
//
_inline HRESULT CopyAnsiToUnicode(LPWSTR wszUnicode,
							      LPCSTR szAnsi,
							      DWORD cchMaxUnicode = MAX_VROOT_PATH)
{
	_ASSERT(wszUnicode != NULL);
	_ASSERT(szAnsi != NULL);
	if (MultiByteToWideChar(CP_ACP,
							0,
							szAnsi,
							-1,
							wszUnicode,
							cchMaxUnicode) == 0)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	} else {
		return S_OK;
	}
}

//
// helper function to do a strcpy from an unicode string to an ansi string.
//
// parameters:
//   szAnsi - the destination ansi string
//   wszUnicode - the source unicode string
//   cchMaxUnicode - the size of the szAnsi buffer, in bytes
//
_inline HRESULT CopyUnicodeToAnsi(LPSTR szAnsi,
							      LPCWSTR wszUnicode,
							      DWORD cchMaxAnsi = MAX_VROOT_PATH)
{
	_ASSERT(wszUnicode != NULL);
	_ASSERT(szAnsi != NULL);
	if (WideCharToMultiByte(CP_ACP,
							0,
							wszUnicode,
							-1,
							szAnsi,
							cchMaxAnsi,
							NULL,
							NULL) == 0)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	} else {
		return S_OK;
	}
}

//
// initialize global variables used by the VRoot objects.  this should
// be called once by the client at startup.
//
HRESULT CVRootTable::GlobalInitialize() {
	HRESULT hr;

	// initialize COM and create the metabase object
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr)) {
		_ASSERT(FALSE);
		return hr;
	}

	g_pMB = NULL;
	g_pMBN = NULL;
	hr = CoCreateInstance(CLSID_MSAdminBase_W, NULL, CLSCTX_ALL,
						  IID_IMSAdminBase_W, (LPVOID *) &g_pMBN);
	if (SUCCEEDED(hr)) {
		hr = CoCreateInstance(CLSID_MSAdminBase_W, NULL, CLSCTX_ALL,
							  IID_IMSAdminBase_W, (LPVOID *) &g_pMB);
		if (SUCCEEDED(hr)) {
			hr = CComObject<CChangeNotify>::CreateInstance(&g_pMBNotify);
			g_pMBNotify->AddRef();
			if (SUCCEEDED(hr)) {
				hr = g_pMBNotify->Initialize(g_pMBN);
			}
		}
	}
	_ASSERT(hr == S_OK);
	if (FAILED(hr)) {
		if (g_pMB) g_pMB->Release();
		if (g_pMBN) g_pMBN->Release();
		g_pMB = NULL;
		g_pMBN = NULL;
	}
	return hr;
}

//
// the opposite of GlobalInitialize.  called once by the client at shutdown.
//
void CVRootTable::GlobalShutdown() {
	// turn off MB notifications
	g_pMBNotify->Terminate();
	_ASSERT(g_pMBNotify != NULL);
	g_pMBNotify->Release();
	g_pMBNotify = NULL;

	// close the metabase
	_ASSERT(g_pMB != NULL);
	g_pMB->Release();
	g_pMB = NULL;
	_ASSERT(g_pMBN != NULL);
	g_pMBN->Release();
	g_pMBN = NULL;

	// shutdown Com
	CoUninitialize();
}

//
// our constructor.  most initialize is done by the Init method, because it
// can return error codes.
//
// parameters:
// 	pContext - the context pointer, held for the client
//  pfnCreateVRoot - a function which can create new CVRoot objects for us.
//
CVRootTable::CVRootTable(   void *pContext,
						    PFNCREATE_VROOT pfnCreateVRoot,
						    PFN_VRTABLE_SCAN_NOTIFY pfnScanNotify) :
	m_listVRoots(&CVRoot::m_pPrev, &CVRoot::m_pNext)
{
	// pContext can be NULL if thats what the user wants
	_ASSERT(pfnCreateVRoot != NULL);
	m_pContext = pContext;
	*m_wszRootPath = 0;
	m_fInit = FALSE;
	m_fShuttingDown = FALSE;
	m_pfnCreateVRoot = pfnCreateVRoot;
	InitializeCriticalSection(&m_cs);
	m_pfnScanNotify = pfnScanNotify;
#ifdef DEBUG
    InitializeListHead( &m_DebugListHead );
#endif
}

//
// our destructor.  cleans up memory
//
CVRootTable::~CVRootTable() {
	TFList<CVRoot>::Iterator it(&m_listVRoots);
    BOOL fDidRemoveNotify = FALSE;

	// tell the world that we are shutting down
	m_fShuttingDown = TRUE;

	if (m_fInit) {
		// disable metabase notifications
		g_pMBNotify->RemoveNotify((void *)this, CVRootTable::MBChangeNotify);
        fDidRemoveNotify = TRUE;
    }

	// grab the critical section so that we can empty the list
	EnterCriticalSection(&m_cs);

	// grab the lock so that we can empty the list
	m_lock.ExclusiveLock();

	if (m_fInit) {
        if (!fDidRemoveNotify&&!g_pMBNotify) {
    		// disable metabase notifications
    		g_pMBNotify->RemoveNotify((void *)this, CVRootTable::MBChangeNotify);
            fDidRemoveNotify = TRUE;
        }

		// walk the list of vroots and remove our references to them
		it.ResetHeader( &m_listVRoots );
		while (!it.AtEnd()) {
			CVRoot *pVRoot = it.Current();
			it.RemoveItem();
			pVRoot->Release();
		}

		m_lock.ExclusiveUnlock();
	
		// wait until all of the vroots references have hit zero
		this->m_lockVRootsExist.ExclusiveLock();

#ifdef DEBUG
        _ASSERT( IsListEmpty( &m_DebugListHead ) );
#endif
		// since all of the vroot objects hold a read lock on this RW lock
		// for their lifetime, we know that they are all gone once we have
		// entered the lock.  we don't need to do anything once in this
		// lock, so we just release it.
		this->m_lockVRootsExist.ExclusiveUnlock();

		m_lock.ExclusiveLock();

		// no additional vroots should have been inserted because we still
		// held onto m_cs
		_ASSERT(m_listVRoots.IsEmpty());
	
		m_fInit = FALSE;
	}

	m_lock.ExclusiveUnlock();

	LeaveCriticalSection(&m_cs);

	DeleteCriticalSection(&m_cs);
}

//
// Initialize the VRoot objects.  This does the initial scan of the metabase
// and builds all of our CVRoot objects.  It also sets up metabase
// notifications so that we are notified of changes in the metabase.
//
// parameters:
//	pszRootPath - the metabase path where our vroot table is located
//
HRESULT CVRootTable::Initialize(LPCSTR pszRootPath, BOOL fUpgrade ) {
	HRESULT hr;

	_ASSERT(g_pMBNotify != NULL);
	if (g_pMBNotify == NULL) return E_UNEXPECTED;
	_ASSERT(g_pMB != NULL);
	if (g_pMB == NULL) return E_UNEXPECTED;
	_ASSERT(!m_fInit);
	if (m_fInit) return E_UNEXPECTED;
	_ASSERT(pszRootPath != NULL);
	if (pszRootPath == NULL) return E_POINTER;
	m_cchRootPath = strlen(pszRootPath);
	if (m_cchRootPath > MAX_VROOT_PATH || m_cchRootPath == 0) return E_INVALIDARG;

	// remember our root path
	hr = CopyAnsiToUnicode(m_wszRootPath, pszRootPath);
	if (FAILED(hr)) return hr;

	// chop off the trailing / if there is one
	if (m_wszRootPath[m_cchRootPath - 1] == '/')
		m_wszRootPath[--m_cchRootPath] = 0;

	hr = g_pMBNotify->AddNotify((void *)this,
								CVRootTable::MBChangeNotify);
	if (FAILED(hr)) {
		_ASSERT(FALSE);
		return hr;
	}

	hr = ScanVRoots( fUpgrade );
	if (FAILED(hr)) {
		g_pMBNotify->RemoveNotify((void *)this,
								  CVRootTable::MBChangeNotify);
		_ASSERT(FALSE);
	}

	return hr;
}

//
// This function does most of the work required to build the list of
// vroots from the metabase.  It recursively walks the metabase, creating
// new vroot classes for each of the leaves found in the metabase.
//
// parameters:
//   hmbParent - the metabase handle for the parent object
//   pwszKey - the key name (relative to the parent handle) for this vroot
//   pszVRootName - the VRoot name (in group.group format) for this vroot
//   pwszConfigPath - the metabase path to the config data for this vroot
//
// Locking:
//   the critical section must be held when this is called.  it will grab
//   the exclusive lock when adding to the list of vroots.
//
HRESULT CVRootTable::ScanVRootsRecursive(METADATA_HANDLE hmbParent,
									     LPCWSTR pwszKey,
										 LPCSTR pszVRootName,
										 LPCWSTR pwszConfigPath,
										 BOOL fUpgrade )
{
	TraceFunctEnter("CVRootTable::ScanVRootsRecursive");

	_ASSERT(pwszKey != NULL);
	_ASSERT(pszVRootName != NULL);
	_ASSERT(pwszConfigPath != NULL);

	HRESULT hr;
	VROOTPTR pVRoot;

	//
	// get a metabase handle to this vroot.
	//
	METADATA_HANDLE hmbThis;
	DWORD i = 0;
	// sometimes the metabase doesn't open properly, so we'll try it multiple
	// times
	do {
		hr = g_pMB->OpenKey(hmbParent,
					 		pwszKey,
					 		METADATA_PERMISSION_READ,
					 		100,
					 		&hmbThis);
		if (FAILED(hr) && i++ < 5) Sleep(50);
	} while (FAILED(hr) && i < 5);
	
	if (SUCCEEDED(hr)) {
		// make sure that this vroot defines the vrpath
		METADATA_RECORD mdr;
		WCHAR c;
		DWORD dwRequiredLen;
		BOOL fInsertVRoot = TRUE;

		mdr.dwMDAttributes = 0;
		mdr.dwMDIdentifier = MD_VR_PATH;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = STRING_METADATA;
		mdr.dwMDDataLen = sizeof(c);
		mdr.pbMDData = (BYTE *) &c;
		mdr.dwMDDataTag = 0;

		hr = g_pMB->GetData(hmbThis, L"", &mdr, &dwRequiredLen);

		if (SUCCEEDED(hr) || hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
			// create and initialize a new vroot object for this vroot
			pVRoot = m_pfnCreateVRoot(m_pContext, pszVRootName, this,
									  pwszConfigPath, fUpgrade );
			if (pVRoot == NULL) {
				hr = E_OUTOFMEMORY;
			} else {
				// Insert this vroot into our list of vroots
				m_lock.ExclusiveLock();
				InsertVRoot(pVRoot);
				m_lock.ExclusiveUnlock();
				hr = S_OK;
			}
		} else {
			fInsertVRoot = FALSE;
			hr = S_OK;
		}

		if (SUCCEEDED(hr)) {
			//
			// scan across this metabase handle looking for child vroots
			//
			DWORD i;
			for (i = 0; hr == S_OK; i++) {
				WCHAR wszThisKey[ADMINDATA_MAX_NAME_LEN + 1];
		
				hr = g_pMB->EnumKeys(hmbThis, NULL, wszThisKey, i);
		
				if (hr == S_OK) {
					//
					// we found a child.
					//
					if (lstrlenW(pwszConfigPath)+lstrlenW(wszThisKey)+1 > MAX_VROOT_PATH) {
						//
						// the vroot path is too long, return an error.
						//
						_ASSERT(FALSE);
						hr = E_INVALIDARG;
					} else {
						WCHAR wszThisConfigPath[MAX_VROOT_PATH];
						char szThisVRootName[MAX_VROOT_PATH];
		
						// figure out the VRoot name and path to the config
						// data for this new VRoot.
						// sprintf is safe here because of the size check above
						swprintf(wszThisConfigPath, L"%s/%s",
							     pwszConfigPath, wszThisKey);
							if (*pszVRootName != 0) {
							sprintf(szThisVRootName, "%s.%S", pszVRootName,
									wszThisKey);
						} else {
							CopyUnicodeToAnsi(szThisVRootName, wszThisKey);
						}
		
						// now scan this vroot for child vroots.
						hr = ScanVRootsRecursive(hmbThis,
												 wszThisKey,
												 szThisVRootName,
												 wszThisConfigPath,
												 fUpgrade );
					}
				}
			}
			if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) hr = S_OK;
		}
		_VERIFY(SUCCEEDED(g_pMB->CloseKey(hmbThis)));
	}

	TraceFunctLeave();
	return hr;
}

//
// call the ReadParameters function on a vroot
//
HRESULT CVRootTable::InitializeVRoot(CVRoot *pVRoot) {
	HRESULT hr;
	METADATA_HANDLE hmbThis;

	DWORD i = 0;
	do {
		hr = g_pMB->OpenKey(METADATA_MASTER_ROOT_HANDLE,
					 		pVRoot->GetConfigPath(),
					 		METADATA_PERMISSION_READ,
					 		100,
					 		&hmbThis);
		if (FAILED(hr) && i++ < 5) Sleep(50);
	} while (FAILED(hr) && i < 5);

	if (SUCCEEDED(hr)) {
		hr = pVRoot->ReadParameters(g_pMB, hmbThis);
		_VERIFY(SUCCEEDED(g_pMB->CloseKey(hmbThis)));
	}

	return hr;
}

//
// Initialize each of the vroot objects after they have been inserted into
// the vroot table
//
HRESULT CVRootTable::InitializeVRoots() {
	TraceFunctEnter("CVRootTable::InitializeVRoots");
	
	EnterCriticalSection(&m_cs);

	TFList<CVRoot>::Iterator it(&m_listVRoots);
	HRESULT hr = S_OK;
	BOOL fInitOld = m_fInit;

	m_fInit = TRUE;

	if (m_pfnScanNotify) {
		DebugTrace((DWORD_PTR) this, "vroot table rescan, calling pfn 0x%x",
			m_pfnScanNotify);
		m_pfnScanNotify(m_pContext);
	}

	// we don't need to hold the share lock because the list can't change as
	// long as we hold the critical section.
	while (SUCCEEDED(hr) && !it.AtEnd()) {
		InitializeVRoot(it.Current());

		if (FAILED(hr)) {
			// if read parameters failed then we remove the item from the list
			// we need to grab the exclusive lock to kick any readers out of
			// the list
			m_lock.ExclusiveLock();
			it.RemoveItem();
			m_lock.ExclusiveUnlock();
		} else {
			it.Next();
		}
	}

	if (FAILED(hr)) m_fInit = fInitOld;

	LeaveCriticalSection(&m_cs);

	TraceFunctLeave();
	return hr;
}

//
// create the root vroot object, then scan the metabase for other
// vroots.
//
HRESULT CVRootTable::ScanVRoots( BOOL fUpgrade ) {
	HRESULT hr;

	EnterCriticalSection(&m_cs);

	hr = ScanVRootsRecursive(METADATA_MASTER_ROOT_HANDLE,
							 m_wszRootPath,
							 "",
							 m_wszRootPath,
							 fUpgrade );

	if (SUCCEEDED(hr)) hr = InitializeVRoots( );

	LeaveCriticalSection(&m_cs);

	return hr;
}

//
// grabs the share lock and calls FindVRootInternal
//
HRESULT CVRootTable::FindVRoot(LPCSTR pszGroup, VROOTPTR *ppVRoot) {
	HRESULT hr;

	_ASSERT(pszGroup != NULL);
	_ASSERT(ppVRoot != NULL);

	m_lock.ShareLock();
	_ASSERT(m_fInit);
	if (!m_fInit) {
		m_lock.ShareUnlock();
		return E_UNEXPECTED;
	}

	hr = FindVRootInternal(pszGroup, ppVRoot);
	m_lock.ShareUnlock();

	_ASSERT(FAILED(hr) || *ppVRoot != NULL);

	return hr;
}

//
// Find a vroot given a group name.
//
// Parameters:
//   pszGroup - the name of the group
//   ppVRoot - the vroot that best matches it
//
// The VRoot that matches is the one with these properties:
//   * strncmp(vroot, group, strlen(vroot)) == 0
//   * the vroot has the longest name that matches
//
// Locking:
//   assumes that the caller has the shared lock or exclusive lock
//
HRESULT CVRootTable::FindVRootInternal(LPCSTR pszGroup, VROOTPTR *ppVRoot) {
	_ASSERT(pszGroup != NULL);
	_ASSERT(ppVRoot != NULL);
	_ASSERT(m_fInit);
	if (!m_fInit) return E_UNEXPECTED;

	DWORD cchGroup = strlen(pszGroup);

	for (TFList<CVRoot>::Iterator it(&m_listVRoots); !it.AtEnd(); it.Next()) {
		VROOTPTR pThisVRoot(it.Current());
		DWORD cchThisVRootName;
		LPCSTR pszThisVRootName = pThisVRoot->GetVRootName(&cchThisVRootName);

		_ASSERT(pThisVRoot != NULL);

		//
		// check to see if we are at the end of the list or if we've gone
		// past the point where we can find matches.
		//
		if ((cchThisVRootName == 0) ||
		    (tolower(*pszThisVRootName) < tolower(*pszGroup)))
		{
			// everything matches the root
			*ppVRoot = m_listVRoots.GetBack();
			return S_OK;
		} else {
			//
			// this is match if this vroot has a shorter path then the group name,
			// and if the group name has a '.' at then end of the vroot name
			// (so if the group is "rec.bicycles.tech." and the vroot is "rec."
			// then this will match, but if it is "comp." then it won't), and
			// finally, if the strings match up to the length of the vroot name.
			// (so "rec." would be the vroot for "rec.bicycles.tech.", but
			// "alt." wouldn't).
			//
			if ((cchThisVRootName <= cchGroup) &&
				((pszGroup[cchThisVRootName] == '.') /*|| - Binlin - "comp" should be created under "\" instead of "\comp"
				 (pszGroup[cchThisVRootName] == 0)*/) &&
				(_strnicmp(pszThisVRootName, pszGroup, cchThisVRootName) == 0))
			{
				// we found a match
				*ppVRoot = pThisVRoot;
				return S_OK;
			}
		}
	}

	// we should always find a match
	*ppVRoot = NULL;
	return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}

//
// insert a new vroot into the vroot list.  this does an ordered insert.
//
// Parameters:
//   pNewVRoot - the new vroot to get inserted into the list
//
// Locking:
//   This method assumes that the caller holds the exclusive lock.
//
// Reference Counting:
//   This method assumes that the reference on the vroot was aquired by
//   the caller (presumably when the vroot was created).
//
void CVRootTable::InsertVRoot(VROOTPTR pNewVRoot) {
	_ASSERT(pNewVRoot != NULL);

	if (m_listVRoots.IsEmpty()) {
		// the first item to be pushed should be the "" vroot
		_ASSERT(*(pNewVRoot->GetVRootName()) == 0);
		m_listVRoots.PushFront(pNewVRoot);
	} else {
		if (*(pNewVRoot->GetVRootName()) == 0) {
			_ASSERT(*(m_listVRoots.GetBack()->GetVRootName()) != 0);
			m_listVRoots.PushBack(pNewVRoot);
		} else {
			for (TFList<CVRoot>::Iterator it(&m_listVRoots); !it.AtEnd(); it.Next()) {
				VROOTPTR pVRoot(it.Current());
				
				//
				// we want records to be sorted in this order:
				// "rec.photo"
				// "rec.bicycles"
				// "rec.arts"
				// "rec"
				// "alt.binaries"
				// "alt"
				// ""
				// (ie, reverse stricmp())
				//
				int rc = _stricmp(pVRoot->GetVRootName(),
								  pNewVRoot->GetVRootName());
				if (rc < 0) {
					it.InsertBefore(pNewVRoot);
					return;
				} else if (rc > 0) {
					// keep looking
				} else {
					// we should never be inserting a vroot that we already have
					_ASSERT(FALSE);
				}
			}
			// we should always do an insert
			_ASSERT(FALSE);
		}
	}
}

//
// convert a vroot configuration path into a vroot name
//
// assumptions:
//  * pwszConfigPath is under m_wszRootPath
//  * szVRootName is at least MAX_VROOT_PATH bytes
//
void CVRootTable::ConfigPathToVRootName(LPCWSTR pwszConfigPath, LPSTR szVRootName) {
	DWORD i;

	_ASSERT(pwszConfigPath != NULL);
	_ASSERT(szVRootName != NULL);

	_ASSERT(_wcsnicmp(pwszConfigPath, m_wszRootPath, m_cchRootPath) == 0);
	CopyUnicodeToAnsi(szVRootName, &(pwszConfigPath[m_cchRootPath + 1]));
	for (i = 0; szVRootName[i] != 0; i++) {
		if (szVRootName[i] == '/') szVRootName[i] = '.';
	}
	// remove the trailing dot if there is one
	if (i > 0) szVRootName[i - 1] = 0;
}

//
// This method is called by CChangeNotify when a metabase change occurs
//
// parameters:
//   pContext - the context we gave to CChangeNotify.  Its a this pointer for
//              a CVRootTable class.
//   cChangeList - the size of the change array
//   pcoChangeList - an array of changed items in the metabase
//
void CVRootTable::MBChangeNotify(void *pContext,
								 DWORD cChangeList,
								 MD_CHANGE_OBJECT_W pcoChangeList[])
{
	_ASSERT(pContext != NULL);


	CVRootTable *pThis = (CVRootTable *) pContext;
	DWORD i;

	if (pThis->m_fShuttingDown) return;

	for (i = 0; i < cChangeList; i++) {
		// see if anything in the change list matches our base vroot
		if (_wcsnicmp(pcoChangeList[i].pszMDPath,
					  pThis->m_wszRootPath,
					  pThis->m_cchRootPath) == 0)
		{
			// a change was found that is in our portion of the metabase.
			// figure out what type of change it is, and then call a helper
			// function to update our vroot table.

			// if the path is too long then we'll ignore it
			if (wcslen(pcoChangeList[i].pszMDPath) > MAX_VROOT_PATH) {
				_ASSERT(FALSE);
				continue;
			}

			// figure out the name for this vroot
			char szVRootName[MAX_VROOT_PATH];
			pThis->ConfigPathToVRootName(pcoChangeList[i].pszMDPath,
										 szVRootName);

			if (pThis->m_fShuttingDown) return;

			// we ignore changes to the Win32 error key because
			// they are set by the vroot
			if (pcoChangeList[i].dwMDNumDataIDs == 1 &&
			    pcoChangeList[i].pdwMDDataIDs[0] == MD_WIN32_ERROR)
            {
                return;
            }

			EnterCriticalSection(&(pThis->m_cs));

			if (pThis->m_fShuttingDown) {
				LeaveCriticalSection(&(pThis->m_cs));
				return;
			}

			switch (pcoChangeList[i].dwMDChangeType) {

//
// The current implementations of VRootAdd and VRootDelete are broken
// because they don't properly handle creating parent vroot objects or
// removing children vroot objects when entire trees are added or
// removed.  Here are explicit examples of cases that don't work.
//
// Add:
//   If there is no "alt" vroot and you create an "alt.binaries" vroot
//   then it should automatically create both the "alt.binaries" and
//   "alt" vroot objects.  The current code only creates the "alt.binaries"
//   one.
//
// Remove:
//   If there is an "alt.binaries" and an "alt" and "alt" is removed then
//   "alt.binaries" should be removed as well.  The existing code doesn't
//   automatically kill children.
//
// These operations should happen infrequently enough that doing a full
// rescan should be safe.
//
#if 0
				// a vroot was deleted
				case MD_CHANGE_TYPE_DELETE_OBJECT:
					pThis->VRootDelete(pcoChangeList[i].pszMDPath,
									   szVRootName);
					break;

				// a new vroot was added
				case MD_CHANGE_TYPE_ADD_OBJECT:
					pThis->VRootAdd(pcoChangeList[i].pszMDPath,
									szVRootName);
					break;
#endif

				// a data value was changed
				case MD_CHANGE_TYPE_SET_DATA:
				case MD_CHANGE_TYPE_DELETE_DATA:
				case MD_CHANGE_TYPE_SET_DATA | MD_CHANGE_TYPE_DELETE_DATA:
					pThis->VRootChange(pcoChangeList[i].pszMDPath,
									   szVRootName);
					break;

				// a vroot was renamed.  the pcoChangeList contains
				// the new name, but not the old, so we need to rescan
				// our entire list of vroots.
				case MD_CHANGE_TYPE_DELETE_OBJECT:
				case MD_CHANGE_TYPE_RENAME_OBJECT:
				case MD_CHANGE_TYPE_ADD_OBJECT:
				default:
					pThis->VRootRescan();
					break;
			}

			LeaveCriticalSection(&(pThis->m_cs));

		}
	}
}

//
// handles a notification that a vroot's parameters have changed.  to
// implement this we delete the vroot object and recreate it.
//
// locking: assumes critical section is held
//
void CVRootTable::VRootChange(LPCWSTR pwszConfigPath, LPCSTR pszVRootName) {
	TraceFunctEnter("CVRootTable::VRootChange");
	
	_ASSERT(pwszConfigPath != NULL);
	_ASSERT(pszVRootName != NULL);

	// make sure that we are properly initialized
	m_lock.ShareLock();
	BOOL f = m_fInit;
	m_lock.ShareUnlock();
	if (!f) return;

	// to make a change work we delete then recreate the vroot
	VRootDelete(pwszConfigPath, pszVRootName);
	VRootAdd(pwszConfigPath, pszVRootName);

	// tell the server about the change
	if (m_pfnScanNotify) {
		DebugTrace((DWORD_PTR) this, "vroot table rescan, calling pfn 0x%x",
			m_pfnScanNotify);
		m_pfnScanNotify(m_pContext);
	}

	TraceFunctLeave();
}

//
// handles a notification that there is a new vroot.
//
// locking: assumes exclusive lock is held
//
void CVRootTable::VRootAdd(LPCWSTR pwszConfigPath, LPCSTR pszVRootName) {
	_ASSERT(pwszConfigPath != NULL);
	_ASSERT(pszVRootName != NULL);

	VROOTPTR pNewVRoot;

	// make sure that we are properly initialized
	m_lock.ShareLock();
	BOOL f = m_fInit;
	m_lock.ShareUnlock();
	if (!f) return;

	//
	// get a metabase handle to this vroot.
	//
	METADATA_HANDLE hmbThis;
	HRESULT hr;
	BOOL fCloseHandle;
	DWORD i = 0;
	// sometimes the metabase doesn't open properly, so we'll try it multiple
	// times
	do {
		hr = g_pMB->OpenKey(METADATA_MASTER_ROOT_HANDLE,
					 		pwszConfigPath,
					 		METADATA_PERMISSION_READ,
					 		100,
					 		&hmbThis);
		if (FAILED(hr) && i++ < 5) Sleep(50);
	} while (FAILED(hr) && i < 5);

	if (SUCCEEDED(hr)) {
		fCloseHandle = TRUE;
		// make sure that this vroot defines the vrpath
		METADATA_RECORD mdr;
		WCHAR c;
		DWORD dwRequiredLen;
	
		mdr.dwMDAttributes = 0;
		mdr.dwMDIdentifier = MD_VR_PATH;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = STRING_METADATA;
		mdr.dwMDDataLen = sizeof(WCHAR);
		mdr.pbMDData = (BYTE *) &c;
		mdr.dwMDDataTag = 0;
	
		hr = g_pMB->GetData(hmbThis, L"", &mdr, &dwRequiredLen);
	}

	if (SUCCEEDED(hr) || hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
		// create and initialize a new vroot object for this vroot
		pNewVRoot = m_pfnCreateVRoot(m_pContext, pszVRootName, this,
								     pwszConfigPath, FALSE );
	
		// insert the new vroot into the list of vroots
		_ASSERT(pNewVRoot != NULL);
		if (pNewVRoot != NULL) {
			if (SUCCEEDED(InitializeVRoot(pNewVRoot))) {
				m_lock.ExclusiveLock();
				InsertVRoot(pNewVRoot);
				m_lock.ExclusiveUnlock();
			} else {
				//_ASSERT(FALSE);
				pNewVRoot->Release();
			}
		}
	}

	if (fCloseHandle) {
		g_pMB->CloseKey(hmbThis);
	}
}
	
//
// handles a notification that a vroot has been deleted
//
// locking: assumes critical section is held
//
void CVRootTable::VRootDelete(LPCWSTR pwszConfigPath, LPCSTR pszVRootName) {
	_ASSERT(pwszConfigPath != NULL);
	_ASSERT(pszVRootName != NULL);

	// make sure that we are properly initialized
	m_lock.ShareLock();
	BOOL f = m_fInit;
	m_lock.ShareUnlock();
	if (!f) return;

	for (TFList<CVRoot>::Iterator it(&m_listVRoots); !it.AtEnd(); it.Next()) {
		if (_stricmp(it.Current()->GetVRootName(), pszVRootName) == 0) {
			CVRoot *pVRoot = it.Current();
			m_lock.ExclusiveLock();
			it.RemoveItem();
			m_lock.ExclusiveUnlock();
			// Give derived close a chance to do any work before orphan this VRoot
			pVRoot->DispatchDropVRoot();
			pVRoot->Release();
			return;
		}
	}
}

//
// handles any other sort of notification (specifically rename).  in this
// case we aren't given all of the information necessary to just fix up
// one vroot object, so we need to recreate the entire vroot list.
//
void CVRootTable::VRootRescan(void) {
	TFList<CVRoot>::Iterator it(&m_listVRoots);
	HRESULT hr;

	m_lock.ExclusiveLock();
	// walk the list of vroots and remove our references to them
	it.ResetHeader( &m_listVRoots );
	while (!it.AtEnd()) {
		CVRoot *pVRoot = it.Current();
		it.RemoveItem();
		// Give derived close a chance to do any work before orphan this VRoot
		pVRoot->DispatchDropVRoot();
		pVRoot->Release();
	}
	m_lock.ExclusiveUnlock();

	// rescan the vroot list
	hr = ScanVRootsRecursive(METADATA_MASTER_ROOT_HANDLE,
							 m_wszRootPath,
							 "",
							 m_wszRootPath,
							 FALSE );

	_ASSERT(SUCCEEDED(hr));

	if (SUCCEEDED(hr)) hr = InitializeVRoots();

	_ASSERT(SUCCEEDED(hr));
}

//
// walk across all of the known vroots, calling a user supplied callback
// for each one.
//
// parameters:
//  pfnCallback - the function to call with the vroot
//
HRESULT CVRootTable::EnumerateVRoots(void *pEnumContext,
									 PFN_VRENUM_CALLBACK pfnCallback)
{
	if (pfnCallback == NULL) {
		_ASSERT(FALSE);
		return E_POINTER;
	}

	// lock the vroot table while we walk the list
	m_lock.ShareLock();

	if (!m_fInit) {
		m_lock.ShareUnlock();
		return E_UNEXPECTED;
	}

	// walk the list of vroots, calling the callback for each one
	
	for (TFList<CVRoot>::Iterator it(&m_listVRoots); !it.AtEnd(); it.Next())
		pfnCallback(pEnumContext, it.Current());

	// release the shared lock
	m_lock.ShareUnlock();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Contains debug functions.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/


#if DBG

#include <windows.h>
#include <winnt.h>

#include <stdlib.h>
#include <stdio.h>
#include <debug.h>

DWORD GlobalDebugFlag = 0;
CRITICAL_SECTION GlobalDebugCritSect;

VOID
TcpsvcsDbgPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length;
    static BeginningOfLine = TRUE;
    LPSTR Text;

    //
    // If we aren't debugging this functionality, just return.
    //

    if ( DebugFlag != 0 && (GlobalDebugFlag & DebugFlag) == 0 ) {
        return;
    }

    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        length += (ULONG) sprintf( &OutputBuffer[length], "[Cache] "
    );

        //
        // Put the timestamp at the begining of the line.
        //
        IF_DEBUG( TIMESTAMP ) {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &OutputBuffer[length],
                                  "%02u/%02u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        }

        //
        // Indicate the type of message on the line
        //
        switch (DebugFlag) {
        case DEBUG_ERRORS:
            Text = "ERROR";
            break;

        case DEBUG_REGISTRY:
            Text = "LEASE";
            break;

        case DEBUG_MISC:
            Text = "MISC";
            break;

        case DEBUG_SCAVENGER:
            Text = "SCAVENGER";
            break;

        case DEBUG_SORT:
            Text = "SORT";
            break;

        case DEBUG_CONTAINER:
            Text = "CONTAINER";
            break;

        case DEBUG_APIS:
            Text = "APIS";
            break;

        case DEBUG_FILE_VALIDATE:
            Text = "FILE_VALIDATE";
            break;

        case DEBUG_MEM_ALLOC:
            Text = "MEM_ALLOC";
            break;

        default:
            Text = NULL;
            break;
        }

        if ( Text != NULL ) {
            length += (ULONG) sprintf( &OutputBuffer[length], "[%s] ", Text );
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &GlobalDebugCritSect );

    va_start(arglist, Format);

    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == '\n' );

    va_end(arglist);

    TcpsvcsDbgAssert(length <= MAX_PRINTF_LEN);


    //
    // Output to the debug terminal,
    //

    (void) DEBUG_PRINT( (PCH) OutputBuffer);

    LeaveCriticalSection( &GlobalDebugCritSect );
}

VOID
TcpsvcsDbgAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{

    TcpsvcsDbgPrint(( 0, "Assert @ %s \n", FailedAssertion ));
    TcpsvcsDbgPrint(( 0, "Assert Filename, %s \n", FileName ));
    TcpsvcsDbgPrint(( 0, "Line Num. = %ld.\n", LineNumber ));
    TcpsvcsDbgPrint(( 0, "Message is %s\n", Message ));

    DebugBreak();
}

#endif // DBG

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\svccli.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    svccli.cxx

Abstract:

    Contains client side code of service location protocol.

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include <svcloc.hxx>

//
// This is the IPX address we send to
//

BYTE GlobalSapBroadcastAddress[] = {
    AF_IPX, 0,                          // Address Family
    0x00, 0x00, 0x00, 0x00,             // Dest. Net Number
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // Dest. Node Number
    0x04, 0x52,                         // Dest. Socket
    0x04                                // Packet type
};

VOID
GetNBUniqueName(
    LPSTR NBNameBuf,
    DWORD NBNameBufLen
    )
{
    LPSTR NamePtr =  NBNameBuf;
    LPSTR NameEndPtr =  NBNameBuf + NBNameBufLen;

    TcpsvcsDbgAssert( NBNameBufLen >
        sizeof(NETBIOS_INET_UNIQUE_NAME) + 1 );

    memcpy(
        NamePtr,
        NETBIOS_INET_UNIQUE_NAME,
        NETBIOS_INET_UNIQUE_NAME_LEN
        );

    NamePtr += NETBIOS_INET_UNIQUE_NAME_LEN;

    //
    // now append a random char.
    //

    DWORD RandNum;
    RandNum = (DWORD)rand();

    RandNum = RandNum % (26 + 10);  // 26 alphabets, and 10 numerics

    if( RandNum < 10 ) {
        *NamePtr = (CHAR)('0'+ RandNum);
    }
    else {
        *NamePtr = (CHAR)('A'+ RandNum - 10);
    }

    NamePtr++;

    TcpsvcsDbgAssert( GlobalComputerName[0] != '\0' );

    //
    // append computer name.
    //

    DWORD ComputerNameLen = strlen( GlobalComputerName );

    if( ComputerNameLen < (DWORD)(NameEndPtr - NamePtr) ) {

        memcpy(
            NamePtr,
            GlobalComputerName,
            ComputerNameLen );

        NamePtr += ComputerNameLen;

        //
        // fill the trailing chars with spaces.
        //

        memset( NamePtr, ' ', DIFF(NameEndPtr - NamePtr) );
    }
    else {

        memcpy(
            NamePtr,
            GlobalComputerName,
            DIFF(NameEndPtr - NamePtr) );
    }

    return;
}

DWORD
ProcessSapResponses(
    PLIST_ENTRY ResponseList,
    LPSAP_ADDRESS_INFO *SapAddresses,
    DWORD *NumSapAddresses
    )
{
    DWORD Error;
    PLIST_ENTRY Response;
    DWORD NumResponses;

    DWORD Size;
    LPSAP_ADDRESS_INFO Addresses = NULL;
    LPSAP_ADDRESS_INFO Address;

    //
    // compute number of entries in the list.
    //

    NumResponses = 0;
    for( Response = ResponseList->Flink;
            Response != ResponseList;
                Response = Response->Flink ) {
        NumResponses++;
    }

    TcpsvcsDbgAssert( NumResponses != 0 );

    if( NumResponses == 0 ) {

        *SapAddresses = NULL;
        *NumSapAddresses = 0;
        return( ERROR_SUCCESS );
    }

    //
    // allocate memory for return buffer.
    //

    Size = sizeof( SAP_ADDRESS_INFO ) * NumResponses;

    Addresses = (LPSAP_ADDRESS_INFO)
        SvclocHeap->Alloc( Size );

    if( Addresses == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    for( Address = Addresses, Response = ResponseList->Flink;
            Response != ResponseList;
                Address++, Response = Response->Flink ) {

        TcpsvcsDbgAssert( (LPBYTE)Address < (LPBYTE)Addresses + Size );

        *Address = ((LPSAP_ADDRESS_ENTRY)Response)->Address;
    }

    *SapAddresses = Addresses;
    *NumSapAddresses = NumResponses;
    Addresses = NULL;

    Error = ERROR_SUCCESS;

Cleanup:

    if( Addresses != NULL ) {
        SvclocHeap->Free( Addresses );
    }

    return( Error );
}

DWORD
ProcessSingleSapResponse(
    LPSAP_IDENT_HEADER SapResponse,
    PLIST_ENTRY ResponsesList
    )
{
    PLIST_ENTRY Response;
    CHAR ServerName[MAX_COMPUTERNAME_LENGTH + 1];
    LPSTR ServerNamePtr;
    LPBYTE ServerAddress;

    TcpsvcsDbgAssert(SapResponse->ServerType == htons(INTERNET_SERVICE_SAP_ID));

    //
    // check GUID portion of the server name.
    //

    if( memcmp(
            SapResponse->ServerName +
                MAX_COMPUTERNAME_LENGTH,
            SERVICE_GUID_STR,
            32 ) != 0 ) {

        //
        // ignore this response.
        //

        TcpsvcsDbgPrint((
            DEBUG_ERRORS,
                "GetSapAddress() received unknown (GUID) response.\n" ));

        return( ERROR_SUCCESS );
    }

    //
    // server name portion.
    //

    memcpy(
        ServerName,
        SapResponse->ServerName,
        MAX_COMPUTERNAME_LENGTH );
    ServerName[MAX_COMPUTERNAME_LENGTH] = '\0';

    //
    // chop off padding.
    //

    ServerNamePtr = ServerName;
    while ( *ServerNamePtr != '\0' ) {
        if( *ServerNamePtr == '!' ) {
            *ServerNamePtr = '\0';
            break;
        }
        ServerNamePtr++;
    }

    ServerAddress = SapResponse->Address;

    //
    // find out if the server entry is already in the existing list.
    //

    for( Response = ResponsesList->Flink;
            Response != ResponsesList;
                Response = Response->Flink ) {

        LPSAP_ADDRESS_ENTRY ResponseEntry;

        ResponseEntry = (LPSAP_ADDRESS_ENTRY)Response;

        if( memcmp(
                ResponseEntry->Address.Address,
                ServerAddress,
                IPX_ADDRESS_LENGTH ) == 0 ) {

            return( ERROR_SUCCESS );
        }

        if( strcmp(
                ResponseEntry->Address.ServerName,
                ServerName ) == 0 ) {

            return( ERROR_SUCCESS );
        }
    }

    //
    // we have unique new entry.
    //

    //
    // allocate memory for the new response.
    //

    LPSAP_ADDRESS_ENTRY NewResponse;
    NewResponse = (LPSAP_ADDRESS_ENTRY)
        SvclocHeap->Alloc( sizeof(SAP_ADDRESS_ENTRY) );

    if( NewResponse == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    strcpy( (LPSTR)NewResponse->Address.ServerName, ServerName );

    memcpy(
        NewResponse->Address.Address,
        ServerAddress,
        IPX_ADDRESS_LENGTH );

    NewResponse->Address.HopCount = ntohs(SapResponse->HopCount);

    //
    // add this new entry to the list.
    //

    InsertTailList( ResponsesList, &NewResponse->Next );

    return( ERROR_SUCCESS );
}

DWORD
GetSapAddress(
    LPSAP_ADDRESS_INFO *SapAddresses,
    DWORD *NumSapAddresses
    )
/*++

Routine Description:

    This routine discovers all IPX servers by sending sap broadcast and
    filtering responses that match our GUID.

Arguments:

    SapAddresses - pointer to a location where the pointer to the
        addresses buffer is returned. The caller should free this buffer
        after use.

    NumSapAddresses - pointer a location where the number of addresses
        returned in the above buffer is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    SOCKET SapSocket;
    SOCKADDR_IPX SapSocketAddr;
    SAP_REQUEST SapRequest;
    BYTE DestAddr[SAP_ADDRESS_LENGTH];
    LIST_ENTRY ResponsesList;

    InitializeListHead(&ResponsesList);

    //
    // create an IPX socket.
    //

    SapSocket = socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );

    if ( SapSocket == INVALID_SOCKET ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    //
    // Set the socket to non-blocking
    //

    DWORD NonBlocking;
    NonBlocking = 1;

    if ( ioctlsocket( SapSocket, FIONBIO, &NonBlocking ) ==
            SOCKET_ERROR ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }
    //
    // Allow sending of broadcasts
    //

    DWORD Value;
    Value = 1;

    if ( setsockopt( SapSocket,
                SOL_SOCKET,
                SO_BROADCAST,
                (PCHAR) &Value,
                sizeof(INT)) == SOCKET_ERROR ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    //
    // Bind the socket
    //

    memset( &SapSocketAddr, 0, sizeof( SOCKADDR_IPX));

    SapSocketAddr.sa_family = AF_IPX;
    SapSocketAddr.sa_socket = 0;      // no specific port

    if ( bind( SapSocket,
               (PSOCKADDR) &SapSocketAddr,
               sizeof( SOCKADDR_IPX)) == SOCKET_ERROR ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    //
    // Set the extended address option
    //

    Value = 1;
    if ( setsockopt( SapSocket,                     // Socket Handle
                     NSPROTO_IPX,                   // Option Level
                     IPX_EXTENDED_ADDRESS,          // Option Name
                     (PCHAR)&Value,               // Ptr to on/off flag
                     sizeof(INT)) == SOCKET_ERROR ) {
                            // Length of flag
        Error = WSAGetLastError();
        goto Cleanup;
    }

    //
    // Send the Sap query service packet
    //

    SapRequest.QueryType  = htons( 1 );  // General Service Query
    SapRequest.ServerType = htons(INTERNET_SERVICE_SAP_ID);

    //
    // Set the address to send to
    //

    memcpy( DestAddr, GlobalSapBroadcastAddress, SAP_ADDRESS_LENGTH );

    //
    // We will send out SAP requests 3 times and wait 1 sec for
    // Sap responses the first time, 1 sec the second and 3 sec the
    // third time. Once we get MAXSITES responses, we give up.
    // We also give up if after processing all replies from a send,
    // we find at least one DC in the search domain.
    //

    DWORD i;

#define SAP_DISCOVERY_RETRIES   1

    for ( i = 0; i < SAP_DISCOVERY_RETRIES; i++ ) {

        DWORD StartTickCount;
        DWORD TimeOut = (i + 1) * 1000;

        //
        // Send the packet out
        //

        if ( sendto( SapSocket,
                     (PCHAR) &SapRequest,
                     sizeof( SapRequest ),
                     0,
                     (PSOCKADDR) DestAddr,
                     SAP_ADDRESS_LENGTH ) == SOCKET_ERROR ) {
            Error = WSAGetLastError();
            goto Cleanup;
        }

        //
        // Loop for incoming packets
        //

        StartTickCount = GetTickCount();

        do {

            LPSAP_IDENT_HEADER SapResponse;
            DWORD BytesReceived;
            BYTE RecvBuffer[SAP_MAXRECV_LENGTH];

            Sleep(50);             // take a deep breath

            BytesReceived =
                recvfrom( SapSocket,
                        (PCHAR)RecvBuffer,
                        SAP_MAXRECV_LENGTH,
                        0,
                        NULL,
                        NULL );

            if ( BytesReceived == SOCKET_ERROR ) {

                Error = WSAGetLastError();

                if ( Error == WSAEWOULDBLOCK ) {

                    //
                    // no data on socket, continue looping
                    //

                    Error = ERROR_SUCCESS;
                    continue;
                }
            }

            if ( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            //
            // if socket closed, return.
            //

            if (  BytesReceived == 0 ) {
                goto ProcessResponse;
            }

            //
            // Skip over query type
            //

            BytesReceived -= sizeof(USHORT);
            SapResponse = (LPSAP_IDENT_HEADER)
                    ((LPBYTE)RecvBuffer + sizeof(USHORT));

            //
            // loop through and check all addresses.
            //

            while ( BytesReceived >= sizeof( SAP_IDENT_HEADER )) {

                Error = ProcessSingleSapResponse(
                                SapResponse,
                                &ResponsesList );

                if( Error != ERROR_SUCCESS ) {
                    goto Cleanup;
                }

                BytesReceived -= sizeof( SAP_IDENT_HEADER );
                SapResponse++;
            }

        } while((GetTickCount() - StartTickCount) < TimeOut );
    }

    //
    // Process response list.
    //

ProcessResponse :

    Error = ProcessSapResponses(
                    &ResponsesList,
                    SapAddresses,
                    NumSapAddresses );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // we are done.
    //

    Error = ERROR_SUCCESS;

Cleanup:

    closesocket( SapSocket );

    //
    // free response list if any.
    //

    while( !IsListEmpty( &ResponsesList ) ) {

        PLIST_ENTRY ListEntry;

        //
        // remove the head entry and free.
        //

        ListEntry = RemoveHeadList( &ResponsesList );
        SvclocHeap->Free( ListEntry );
    }

    return( Error );
}



DWORD
DiscoverIpxServers(
    LPSTR ServerName
    )
/*++

Routine Description:

    This routine discovers all IPX servers using RNR GetAddressByName.

    Assume : WSAStartup is called before calling this function.

Arguments:

    ServerName : if this value is set non-NULL then discover only the
        specified server otherwise diescover all.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD NumSapAddresses = 0;
    LPSAP_ADDRESS_INFO SapAddresses = NULL;
    SOCKADDR DestAddr;

    //
    // first find out all servers running IPX only.
    // performed by doing SAP broadcast.
    //

    Error  = GetSapAddress( &SapAddresses, &NumSapAddresses );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // now process returned buffer entries.
    //

    DWORD i;

    TcpsvcsDbgAssert( NumSapAddresses > 0 );

    //
    // create a IPX socket to send query message, if it is not created
    // before.
    //

    LOCK_SVC_GLOBAL_DATA();
    if( GlobalCliIpxSocket == INVALID_SOCKET ) {

        SOCKADDR_IPX IpxSocketAddr;
        DWORD Arg;

        GlobalCliIpxSocket = socket( PF_IPX, SOCK_DGRAM, NSPROTO_IPX );

        if( GlobalCliIpxSocket == INVALID_SOCKET ) {

            Error = WSAGetLastError();
            UNLOCK_SVC_GLOBAL_DATA();

            TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "socket() failed, %ld\n", Error ));

            goto Cleanup;
        }

        //
        // make this socket non blocking.
        //

        Arg = 1;
        if( (ioctlsocket( GlobalCliIpxSocket, FIONBIO, &Arg )) == SOCKET_ERROR ) {

            Error = WSAGetLastError();
            UNLOCK_SVC_GLOBAL_DATA();

            TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "ioctlsocket() failed, %ld\n", Error ));

            goto Cleanup;
        }

        //
        // Bind the socket
        //

        memset( &IpxSocketAddr, 0, sizeof( SOCKADDR_IPX));

        IpxSocketAddr.sa_family = AF_IPX;
        IpxSocketAddr.sa_socket = 0;      // no specific port

        if ( bind( GlobalCliIpxSocket,
                   (PSOCKADDR) &IpxSocketAddr,
                   sizeof( SOCKADDR_IPX)) == SOCKET_ERROR ) {

            Error = WSAGetLastError();
            UNLOCK_SVC_GLOBAL_DATA();

            TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "bind() failed, %ld\n", Error ));

            goto Cleanup;
        }

        //
        // add this socket to global list.
        //

        FD_SET( GlobalCliIpxSocket, &GlobalCliSockets );
    }
    UNLOCK_SVC_GLOBAL_DATA();

    LPSAP_ADDRESS_INFO SapAddressInfo;

    SapAddressInfo = SapAddresses;
    DestAddr.sa_family = AF_IPX;
    for( i = 0; i < (DWORD)NumSapAddresses; i++, SapAddressInfo++ ) {

        //
        // if we are asked to discover only specific server
        // check the server name first before sending the query
        // message.
        //

        if( ServerName != NULL ) {
            if( _stricmp(
                    ServerName,
                    SapAddressInfo->ServerName ) != 0 ) {
                continue;
            }
        }

        //
        // send query message to each discovered server.
        //

        memcpy(
            DestAddr.sa_data,
            SapAddressInfo->Address,
            IPX_ADDRESS_LENGTH );

        Error = sendto(
                    GlobalCliIpxSocket,
                    (LPCSTR)GlobalCliQueryMsg,
                    GlobalCliQueryMsgLen,
                    0,
                    &DestAddr,
                    2 + IPX_ADDRESS_LENGTH );

        if( Error == SOCKET_ERROR ) {
            Error = WSAGetLastError();

            TcpsvcsDbgPrint(( DEBUG_ERRORS, "sendto() failed, %ld\n", Error ));
            continue;
        }
    }

    //
    // DONE.
    //

    Error = ERROR_SUCCESS;

Cleanup:

    if( SapAddresses != NULL ) {
        SvclocHeap->Free( SapAddresses );
    }

    if( Error != ERROR_SUCCESS ) {
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "DiscoverIpxServers failed, %ld\n", Error ));
    }

    return( Error );
}

DWORD
DiscoverIpServers(
    LPSTR ServerName
    )
/*++

Routine Description:

    This function sends out a discovery message to all netbios lanas.

Arguments:

    UniqueServerName : pointer to a server name string. If this pointer is
        NULL, it uses IC group name to discover all IP servers, otherwise
        it discovers the bindings of the specified server.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    SOCKADDR_NB RemoteSocketAddress;

    LOCK_SVC_GLOBAL_DATA();
    if( GlobalCliNBSockets.fd_count == 0 ) {

        SOCKET s;
        DWORD Lana;
        SOCKADDR_NB SocketAddress;

        // make netbios source address.
        //

        memset( &SocketAddress, 0x0, sizeof(SOCKADDR_NB) );

        SocketAddress.snb_family = AF_NETBIOS;
        SocketAddress.snb_type = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

        GetNBUniqueName(
            SocketAddress.snb_name,
            sizeof(SocketAddress.snb_name) );

        //
        // enumurate lanas first.
        //

        LANA_ENUM Lanas;

        if( GetEnumNBLana( &Lanas ) ) {

            //
            // try only the lanas that are returned.
            //

            DWORD i;
            for( i = 0; i < Lanas.length; i++ ) {

                if ( MakeNBSocketForLana(
                        Lanas.lana[i],
                        (PSOCKADDR)&SocketAddress,
                        &s ) ) {

                    //
                    // successfully made another socket, add to global list.
                    //

                    FD_SET( s, &GlobalCliNBSockets );
                    FD_SET( s, &GlobalCliSockets );
                }
            }
        }
        else {

            UCHAR Lana;

            //
            // try all possible lanas and accept all valid lana sockets.
            //

            for( Lana = 0; Lana < MAX_LANA ; Lana-- ) {

                if ( MakeNBSocketForLana(
                        Lana,
                        (PSOCKADDR)&SocketAddress,
                        &s ) ) {

                    //
                    // successfully made another socket, add to global
                    // lists.
                    //

                    FD_SET( s, &GlobalCliNBSockets );
                    FD_SET( s, &GlobalCliSockets );
                }
            }
        }
    }

    UNLOCK_SVC_GLOBAL_DATA();

    if( GlobalCliNBSockets.fd_count == 0 ) {
        return( ERROR_SUCCESS );
    }

    //
    //
    // make netbios destination address.
    //

    memset( &RemoteSocketAddress, 0x0, sizeof(SOCKADDR_NB) );

    if( ServerName == NULL ) {

        //
        // if no server name is specified, then send the discovery message
        // to IC group name.
        //

        RemoteSocketAddress.snb_family = AF_NETBIOS;
        RemoteSocketAddress.snb_type = TDI_ADDRESS_NETBIOS_TYPE_GROUP;

        TcpsvcsDbgAssert(
            sizeof(RemoteSocketAddress.snb_name) >=
                NETBIOS_INET_GROUP_NAME_LEN );

        memcpy(
            RemoteSocketAddress.snb_name,
            NETBIOS_INET_GROUP_NAME,
            NETBIOS_INET_GROUP_NAME_LEN );
    }
    else {

        DWORD ServerNameLen;

        //
        // send the discovery message to the specified server.
        //

        RemoteSocketAddress.snb_family = AF_NETBIOS;
        RemoteSocketAddress.snb_type = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

        ServerNameLen = strlen(ServerName);

        TcpsvcsDbgAssert(
            ServerNameLen <=
            sizeof(RemoteSocketAddress.snb_name) );

        memcpy(
            RemoteSocketAddress.snb_name,
            ServerName,
            (ServerNameLen >= sizeof(RemoteSocketAddress.snb_name)) ?
                sizeof(RemoteSocketAddress.snb_name) :
                ServerNameLen );
    }

    //
    // send message to all lanas.
    //

    DWORD i;
    for( i = 0; i < GlobalCliNBSockets.fd_count ; i++ ) {

        //
        // now send query message.
        //

        Error = sendto(
                    GlobalCliNBSockets.fd_array[i],
                    (LPCSTR)GlobalCliQueryMsg,
                    GlobalCliQueryMsgLen,
                    0,
                    (PSOCKADDR)&RemoteSocketAddress,
                    sizeof(RemoteSocketAddress) );

        if( Error == SOCKET_ERROR ) {
            Error = WSAGetLastError();
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "sendto() failed, %ld\n", Error ));
        }
    }

    return( ERROR_SUCCESS );
}

DWORD
ProcessSvclocQueryResponse(
    SOCKET ReceivedSocket,
    LPBYTE ReceivedMessage,
    DWORD ReceivedMessageLength,
    SOCKADDR *SourcesAddress,
    DWORD SourcesAddressLength
    )
/*++

Routine Description:

    This function processes the query response message and queues them to
    the global list.

Arguments:

    ReceivedSocket - socket the message came from.

    ReceivedMessage - pointer to a message buffer.

    ReceivedMessageLength - length of the above message.

    SourcesAddress - address of the sender.

    SourcesAddressLength - length of the above address.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD NodeLength;
    LPCLIENT_QUERY_RESPONSE ResponseNode;
    PLIST_ENTRY NextResponse;
    LPBYTE EndReceiveMessage;

    //
    // validate this message.
    //

    //
    // first DWORD in the message is the length of the message.
    //

    if( *(DWORD *)ReceivedMessage != ReceivedMessageLength ) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // last DWORD is terminating char.
    //

    EndReceiveMessage = ReceivedMessage + ReceivedMessageLength;

    if( *(DWORD *) (EndReceiveMessage - sizeof(DWORD)) != 0xFFFFFFFF ) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // validate check sum.
    // last but one DWORD is check of the message.
    //

    DWORD CheckSum;

    CheckSum =  *(DWORD *) (EndReceiveMessage - 2 * sizeof(DWORD));

    DWORD ComputedCheckSum;

    ComputedCheckSum =
        ComputeCheckSum(
            ReceivedMessage + sizeof(DWORD),    // skip length field.
            ReceivedMessageLength - 3 * sizeof(DWORD) );
                // skip last 2 DWORDS too.

    if( ComputedCheckSum != CheckSum ) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // check version number.
    //

    INET_VERSION_NUM *VersionNum;

    VersionNum = (INET_VERSION_NUM *)(ReceivedMessage + sizeof(DWORD));

    if( VersionNum->Version.Major != INET_MAJOR_VERSION ) {
        return( ERROR_INVALID_PARAMETER );
    }

    LOCK_SVC_GLOBAL_DATA();

    //
    // check to see, there is already a response from this server, if so
    // update the response message, otherwise add a new entry.
    //

    for( NextResponse =  GlobalCliQueryRespList.Flink;
            NextResponse != &GlobalCliQueryRespList;
                NextResponse = NextResponse->Flink ) {

        LPCLIENT_QUERY_RESPONSE QueryResponse;

        QueryResponse = (LPCLIENT_QUERY_RESPONSE)NextResponse;

        //
        // if either the server addresses match or
        // the server names in the message field match, then this
        // must be duplicate, so replace with old one.
        //

        if(
#if 0
        //
        // this check always succeseed for group name.
        //

            ( (SourcesAddressLength == QueryResponse->SourcesAddressLength ) && (memcmp(
                    SourcesAddress,
                    QueryResponse->SourcesAddress,
                    SourcesAddressLength ) == 0 ) ) ||
#endif // 0
            ( strcmp(
                (LPSTR)ReceivedMessage + 2 * sizeof(DWORD),
                        // skip length and version DWORDS.
                (LPSTR)QueryResponse->ResponseBuffer + 2 * sizeof(DWORD) )
                    == 0 ) ) {

            //
            // free old response buffer.
            //

            SvclocHeap->Free( QueryResponse->ResponseBuffer );

            //
            // copy new response pointer.
            //

            QueryResponse->ResponseBuffer = ReceivedMessage;
            QueryResponse->ResponseBufferLength = ReceivedMessageLength;
            QueryResponse->TimeStamp = time( NULL );

            //
            // done.
            //

            Error = ERROR_SUCCESS;
            goto Cleanup;
        }
    }

    //
    // brand new response.
    //

    NodeLength = sizeof(CLIENT_QUERY_RESPONSE) + SourcesAddressLength;

    ResponseNode = (LPCLIENT_QUERY_RESPONSE)SvclocHeap->Alloc( NodeLength );

    if( ResponseNode == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // setup sock address pointer.
    //

    ResponseNode->SourcesAddress = (SOCKADDR *)(ResponseNode + 1);

    //
    // copy address data.
    //

    memcpy(
        ResponseNode->SourcesAddress,
        SourcesAddress,
        SourcesAddressLength );

    //
    // copy other fields.
    //

    ResponseNode->ReceivedSocket = ReceivedSocket;
    ResponseNode->ResponseBuffer = ReceivedMessage;
    ResponseNode->ResponseBufferLength = ReceivedMessageLength;
    ResponseNode->SourcesAddressLength = SourcesAddressLength;
    ResponseNode->TimeStamp = time( NULL );

    //
    // link this entry to global list.
    //

    InsertTailList( &GlobalCliQueryRespList, &ResponseNode->NextEntry );

    //
    // done.
    //

    Error = ERROR_SUCCESS;

Cleanup:

    UNLOCK_SVC_GLOBAL_DATA();
    return( Error );
}

DWORD
ReceiveResponses(
    WORD Timeout,
    BOOL WaitForAllResponses
    )
/*++

Routine Description:

    This routine receives responses for the query messages sent out to the
    servers.

Arguments:

    Time - Time to wait for the response messages in secs.

    WaitForAllResponses : If this flag is set TRUE, this function wait
        complete 'Time' secs for all responses to arrive. Otherwise it
        will return after a succcessful response is received.

Return Value:

    None.

--*/
{
    DWORD Error;
    struct timeval SockTimeout;
    struct timeval *pSockTimeout;
    DWORD TimeoutinMSecs = INFINITE;
    DWORD TickCountStart;

    if( Timeout != 0 ) {
        TimeoutinMSecs = Timeout * 1000;
        pSockTimeout = &SockTimeout;
    }
    else {
        pSockTimeout = NULL;
    }

    //
    // now loop for incoming messages.
    //

    //
    // remember current tick out.
    //

    TickCountStart = GetTickCount();

    for( ;; ) {

        fd_set ReadSockets;
        INT NumReadySockets;
        DWORD NumSockets;
        DWORD i;

        LOCK_SVC_GLOBAL_DATA();
        NumSockets = GlobalCliSockets.fd_count;
        UNLOCK_SVC_GLOBAL_DATA();

        if( NumSockets != 0 ) {

            //
            // select
            //

            LOCK_SVC_GLOBAL_DATA();
            memcpy( &ReadSockets, &GlobalCliSockets, sizeof(fd_set) );
            UNLOCK_SVC_GLOBAL_DATA();



            //
            // compute time out, if it is not infinity.
            //

            if( pSockTimeout != NULL ) {
                SockTimeout.tv_sec = TimeoutinMSecs / 1000;
                SockTimeout.tv_usec = TimeoutinMSecs % 1000;
            }

            NumReadySockets =
                select(
                    0,  // compatibility argument, ignored.
                    &ReadSockets, // sockets to test for readability.
                    NULL,   // no write wait
                    NULL,   // no error check.
                    pSockTimeout ); // NO timeout.

            if( NumReadySockets == SOCKET_ERROR ) {

                //
                // when all sockets are closed, we are asked to return or
                // something else has happpened which we can't handle.
                //

                Error = WSAGetLastError();
                goto Cleanup;
            }

            TcpsvcsDbgAssert( (DWORD)NumReadySockets == ReadSockets.fd_count );

            for( i = 0; i < (DWORD)NumReadySockets; i++ ) {

                DWORD ReadMessageLength;
                struct sockaddr_nb SourcesAddress;
                int SourcesAddressLength;
                LPBYTE RecvBuffer;
                DWORD RecvBufferLength;

                RecvBufferLength = SVCLOC_CLI_QUERY_RESP_BUF_SIZE;
                RecvBuffer = (LPBYTE)SvclocHeap->Alloc( RecvBufferLength );

                if( RecvBuffer == NULL ) {
                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

                //
                // read next message.
                //

                SourcesAddressLength = sizeof(SourcesAddress);

                ReadMessageLength =
                    recvfrom(
                        ReadSockets.fd_array[i],
                        (LPSTR)RecvBuffer,
                        RecvBufferLength,
                        0,
                        (struct sockaddr *)&SourcesAddress,
                        &SourcesAddressLength );

                if( ReadMessageLength == SOCKET_ERROR ) {

                    //
                    // when all sockets are closed, we are asked to return
                    // or  something else has happpened which we can't
                    // handle.
                    //

                    Error = WSAGetLastError();

                    //
                    // free receive  buffer.
                    //

                    SvclocHeap->Free( RecvBuffer );
                    RecvBuffer = NULL;

                    if( Error == WSAEMSGSIZE ) {

                        TcpsvcsDbgPrint(( DEBUG_ERRORS,
                            "recvfrom() received a too large message (%ld).\n",
                                ReadMessageLength ));

                        continue;   // process next message.
                    }

                    goto Cleanup;
                }

                TcpsvcsDbgAssert( ReadMessageLength <= RecvBufferLength );

                //
                // received a message.
                //

                TcpsvcsDbgPrint((
                    DEBUG_SVCLOC_MESSAGE,
                        "Received an query response message, %ld.\n",
                            ReadMessageLength ));

                Error = ProcessSvclocQueryResponse(
                                ReadSockets.fd_array[i],
                                RecvBuffer,
                                (DWORD)ReadMessageLength,
                                (struct sockaddr *)&SourcesAddress,
                                (DWORD)SourcesAddressLength );

                if( Error != ERROR_SUCCESS ) {

                    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "ProcessSvclocQueryResponse failed, %ld.\n", Error ));

                    //
                    // free receive buffer.
                    //

                    SvclocHeap->Free( RecvBuffer );
                    RecvBuffer = NULL;
                }
            }

        }

        //
        // otherthan NT platform, receive NetBios responses also.
        //

        if( GlobalPlatformType != VER_PLATFORM_WIN32_NT ) {

            LPSVCLOC_NETBIOS_RESPONSE NetBiosResponses = NULL;
            DWORD NumResponses;

            //
            // compute remaining time.
            //

            if( pSockTimeout != NULL ) {

                DWORD NewTickCountStart;
                DWORD Elapse;

                NewTickCountStart = GetTickCount();

                //
                // subtract elapse time.
                //

                Elapse = NewTickCountStart - TickCountStart;

                if( Elapse > TimeoutinMSecs ) {
                    TimeoutinMSecs = 0;
                }
                else {

                    TimeoutinMSecs -= Elapse;
                    TickCountStart = NewTickCountStart;
                }
            }

            //
            // receive netbios responses.
            //

            Error = ReceiveNetBiosResponses(
                        &NetBiosResponses,
                        &NumResponses,
                        TimeoutinMSecs,
                        WaitForAllResponses );

            if( Error != ERROR_SUCCESS ) {

                TcpsvcsDbgPrint(( DEBUG_ERRORS,
                    "ReceiveNetBiosResponses failed, %ld.\n", Error ));

                //
                // ignore this error and continue.
                //
            }
            else {


                LPSVCLOC_NETBIOS_RESPONSE NBResp = NetBiosResponses;

                for( i = 0; i < NumResponses; i++, NBResp++ ) {

                    Error = ProcessSvclocQueryResponse(
                                    0,
                                    NBResp->ResponseBuffer,
                                    NBResp->ResponseBufLen,
                                    (struct sockaddr *)
                                        &NBResp->SourcesAddress,
                                    NBResp->SourcesAddrLen );

                    if( Error != ERROR_SUCCESS ) {
                        TcpsvcsDbgPrint(( DEBUG_ERRORS,
                            "ProcessSvclocQueryResponse failed, %ld.\n",
                                Error ));

                        //
                        // free response receive buffer.
                        //

                        SvclocHeap->Free( NBResp->ResponseBuffer );

                        //
                        // ignore this error and continue.
                        //
                    }
                }

                //
                // free up response buffer.
                //

                if( NetBiosResponses != NULL ) {
                    SvclocHeap->Free( NetBiosResponses );
                }
            }
        }
        else {

            //
            // if we have timed out.
            //

            if( NumReadySockets == 0 ) {
                Error = ERROR_SUCCESS;
                goto Cleanup;
            }

        }

        if( WaitForAllResponses == FALSE ) {

            //
            // return after the first set of responses received.
            //

            Error = ERROR_SUCCESS;
            break;
        }

        //
        // compute remaining time.
        //

        if( pSockTimeout != NULL ) {

            DWORD NewTickCountStart;
            DWORD Elapse;

            NewTickCountStart = GetTickCount();

            //
            // subtract elapse time.
            //

            Elapse = NewTickCountStart - TickCountStart;

            if( Elapse > TimeoutinMSecs ) {
                TimeoutinMSecs = 0;
                Error = ERROR_SUCCESS;
                goto Cleanup;
            }
            else {

                TimeoutinMSecs -= Elapse;
                TickCountStart = NewTickCountStart;
            }
        }
    }

Cleanup:

    //
    // discovery is completed (successfully or not), indicate so.
    //

    LOCK_SVC_GLOBAL_DATA();
    SetEvent( GlobalDiscoveryInProgressEvent );
    GlobalLastDiscoveryTime = time( NULL );
    UNLOCK_SVC_GLOBAL_DATA();

    return( Error );
}

VOID
ServerDiscoverThread(
    LPVOID Parameter
    )
/*++

Routine Description:

    This thread waits for query responses to arrive, when they arrive it
    queues them in them in the global list.

Arguments:

    Parameter - not used..

Return Value:

    None.

--*/
{
    DWORD Error;
    Error = ReceiveResponses( RESPONSE_WAIT_TIMEOUT, TRUE );

    if( Error != ERROR_SUCCESS ) {
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "ReceiveResponses returned error (%ld) .\n", Error ));
    }

    LOCK_SVC_GLOBAL_DATA();

    //
    // close thread handle.
    //

    CloseHandle( GlobalCliDiscoverThreadHandle );
    GlobalCliDiscoverThreadHandle = NULL;

    UNLOCK_SVC_GLOBAL_DATA();

    return;
}

DWORD
MakeClientQueryMesage(
    ULONGLONG ServicesMask
    )
/*++

Routine Description:

    This function makes client query message and stores it in the global
    data buffer for future use.

    The query message format.

    1st DWORD : message length.
    2nd DWORD : message version.
    3rd ULONGLONG : services mask the client interested in.
    4th WCHAR[] : client name
    ..
    ..

    Last but one DWORD : check sum.
    LAST DWORD : terminating DWORD 0xFFFFFFFF

    Assume: Global data is locked.

Arguments:

    ServicesMask - services to query for.

Return Value:

    Windows Error Code.

--*/
{
    LPCLIENT_QUERY_MESSAGE QueryMsg;

    //
    // Test to see query message is already made.
    //

    if( GlobalCliQueryMsg == NULL ) {

        //
        // check to computer name is initilaized.
        //

        if( GlobalComputerName[0] == '\0' ) {

            DWORD ComputerNameLength =
                MAX_COMPUTERNAME_LENGTH + 1;

            //
            // read computer name.
            //

            if( !GetComputerNameA(
                    GlobalComputerName,
                    &ComputerNameLength ) ) {

                DWORD Error = GetLastError();

                TcpsvcsDbgPrint(( DEBUG_ERRORS,
                    "GetComputerNameA failed, %ld.\n", Error ));

                return( Error );
            }

            GlobalComputerName[ComputerNameLength] = '\0';
        }

        //
        // compute the space required for the query message.
        //

        DWORD MsgLen;

        MsgLen = sizeof(CLIENT_QUERY_MESSAGE) +
            strlen(GlobalComputerName)  * sizeof(CHAR);
                // note the terminating char is included as part of
                // CLIENT_QUERY_MESSAGE size.

        //
        // Ceil to next DWORD.
        //

        MsgLen = ROUND_UP_COUNT(MsgLen, ALIGN_DWORD);

        //
        // add space for checksum and terminating DWORD.
        //

        MsgLen += sizeof(DWORD);

        QueryMsg = (LPCLIENT_QUERY_MESSAGE) SvclocHeap->Alloc( MsgLen );

        if( QueryMsg == NULL ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        memset( QueryMsg, 0x0, MsgLen );

        //
        // init fields.
        //

        INET_VERSION_NUM MessageVersion;

        MessageVersion.Version.Major = INET_MAJOR_VERSION;
        MessageVersion.Version.Minor = INET_MINOR_VERSION;

        QueryMsg->MsgLength = MsgLen;
        QueryMsg->MsgVersion = MessageVersion.VersionNumber;
        QueryMsg->ServicesMask = ServicesMask;
        strcpy( QueryMsg->ClientName, GlobalComputerName );

        //
        // compute check sum.
        //

        DWORD Checksum;

        Checksum  = ComputeCheckSum(
                                (LPBYTE)QueryMsg + sizeof(DWORD), // skip length field.
                                MsgLen - 3 * sizeof(DWORD) );

        *(LPDWORD)((LPBYTE)QueryMsg + MsgLen - 2 * sizeof(DWORD)) = Checksum;
        *(LPDWORD)((LPBYTE)QueryMsg + MsgLen - sizeof(DWORD)) = 0xFFFFFFFF;

        GlobalCliQueryMsg = (LPBYTE)QueryMsg;
        GlobalCliQueryMsgLen = MsgLen;
    }
    else {

        //
        // set the requested service mask in the message.
        //

        QueryMsg = (LPCLIENT_QUERY_MESSAGE)GlobalCliQueryMsg;
        QueryMsg->ServicesMask |= ServicesMask;
    }

    return( ERROR_SUCCESS );
}

DWORD
CleanupOldResponses(
    VOID
    )
/*++

Routine Description:

    This function removes and deletes the server responses that are older
    than INET_SERVER_RESPONSE_TIMEOUT (15 mins).

    ASSUME : the global lock is locked.

Arguments:

    none.

Return Value:

    Windows Error Code.

--*/
{
    PLIST_ENTRY NextResponse;
    LPCLIENT_QUERY_RESPONSE QueryResponse;
    time_t CurrentTime;

    CurrentTime = time( NULL );
    NextResponse =  GlobalCliQueryRespList.Flink;

    while( NextResponse != &GlobalCliQueryRespList ) {

        QueryResponse = (LPCLIENT_QUERY_RESPONSE)NextResponse;
        NextResponse = NextResponse->Flink;

        if( CurrentTime > QueryResponse->TimeStamp +
                                    INET_SERVER_RESPONSE_TIMEOUT ) {

            RemoveEntryList( (PLIST_ENTRY)QueryResponse );

            //
            // free up resources.
            //

            //
            // free response buffer.
            //

            SvclocHeap->Free( QueryResponse->ResponseBuffer );

            //
            // free this node.
            //

            SvclocHeap->Free( QueryResponse );
        }
    }

    return( ERROR_SUCCESS );
}

DWORD
GetDiscoveredServerInfo(
    LPSTR ServerName,
    IN ULONGLONG ServicesMask,
    LPINET_SERVER_INFO *ServerInfo
    )
/*++

Routine Description:

    This function processes the responses received from the servers so far
    and returns the response received from the specified server.

    ASSUME : the global lock is locked.

Arguments:

    ServerName : name of the server whose info to be queried.

    ServicesMask : services to be queried

    INetServerInfo : pointer to a location where the pointer to a
        INET_SERVER_INFO structure is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    PLIST_ENTRY NextResponse;
    LPCLIENT_QUERY_RESPONSE QueryResponse;

    LOCK_SVC_GLOBAL_DATA();

    //
    // first clean up timeout server records.
    //

    Error = CleanupOldResponses();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // now loop through the list of responses and findout the response
    // from the specified server.
    //

    for( NextResponse =  GlobalCliQueryRespList.Flink;
            NextResponse != &GlobalCliQueryRespList;
                NextResponse = NextResponse->Flink ) {


        QueryResponse = (LPCLIENT_QUERY_RESPONSE)NextResponse;

        //
        // check to see this entry is from the specified server.
        //

        if( _stricmp(
                ServerName,
                (LPSTR)QueryResponse->ResponseBuffer + 2 * sizeof(DWORD) )
                        // skip length and version DWORDS.
                    == 0 ) {

            EMBED_SERVER_INFO *ServerInfoObj;

            ServerInfoObj = new EMBED_SERVER_INFO(
                QueryResponse->ResponseBuffer + sizeof(DWORD),    // skip length field.
                QueryResponse->ResponseBufferLength - 3 * sizeof(DWORD) );
                    // skip last 2 DWORDS too.

            if( ServerInfoObj == NULL ) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            Error =  ServerInfoObj->GetStatus();

            if( Error != ERROR_SUCCESS ) {
                delete ServerInfoObj;
                goto Cleanup;
            }

            //
            // check services quaried.
            //

            if( ServicesMask &  ServerInfoObj->GetServicesMask() ) {

                //
                // now make server info structure;
                //

                Error = ServerInfoObj->GetServerInfo( ServerInfo );
            }
            else {

                //
                // the server does not support the service(s) quaried.
                //

                Error = ERROR_BAD_NETPATH;
            }

            //
            // delete the object which we don't require anymore.
            //

            delete ServerInfoObj;

            //
            // we are done.
            //

            goto Cleanup;
        }
    }

    //
    // unable to find the specified server.
    //

    Error = ERROR_BAD_NETPATH;

Cleanup:

    UNLOCK_SVC_GLOBAL_DATA();
    return( Error );
}

DWORD
ProcessDiscoveryResponses(
    IN ULONGLONG ServicesMask,
    OUT LPINET_SERVERS_LIST *INetServersList
    )
/*++

Routine Description:

    This function processes the responses received from the servers so far
    and makes INET_SERVERS_LIST.

Arguments:

    ServicesMask : services to be queried

    INetServersList : pointer to a location where the pointer to a
        INET_SERVERS_LIST structure is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    PLIST_ENTRY NextResponse;
    LPCLIENT_QUERY_RESPONSE QueryResponse;
    DWORD NumServers;
    LPINET_SERVERS_LIST ServersList;

    LOCK_SVC_GLOBAL_DATA();

    //
    // first clean up timeout server records.
    //

    Error = CleanupOldResponses();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // compute number of responses we have.
    //

    NumServers = 0;
    for( NextResponse =  GlobalCliQueryRespList.Flink;
            NextResponse != &GlobalCliQueryRespList;
                NextResponse = NextResponse->Flink ) {
        NumServers++;
    }

    //
    // allocate memory for servers list structure.
    //

    ServersList = (LPINET_SERVERS_LIST)
        SvclocHeap->Alloc( sizeof(INET_SERVERS_LIST) );

    if( ServersList == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    ServersList->NumServers = 0;
    ServersList->Servers = NULL;

    //
    // now allocate memory for the servers info structure pointers array.
    //

    ServersList->Servers = (LPINET_SERVER_INFO *)
        SvclocHeap->Alloc(NumServers * sizeof(LPINET_SERVER_INFO) );

    if( ServersList->Servers == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // loop through the list of responses and make response structures.
    //

    for( NextResponse =  GlobalCliQueryRespList.Flink;
            NextResponse != &GlobalCliQueryRespList;
                NextResponse = NextResponse->Flink ) {

        EMBED_SERVER_INFO *ServerInfoObj;

        QueryResponse = (LPCLIENT_QUERY_RESPONSE)NextResponse;

        ServerInfoObj = new EMBED_SERVER_INFO(
            QueryResponse->ResponseBuffer + sizeof(DWORD),    // skip length field.
            QueryResponse->ResponseBufferLength - 3 * sizeof(DWORD) );
                // skip last 2 DWORDS too.

        if( ServerInfoObj == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        Error =  ServerInfoObj->GetStatus();

        if( Error != ERROR_SUCCESS ) {
            delete ServerInfoObj;
            goto Cleanup;
        }

        //
        // check services quaried.
        //

        if( ServicesMask &  ServerInfoObj->GetServicesMask() ) {

            //
            // the server has the one or more of the services quaried.
            // add an entry in the return buffer.
            //

            DWORD i;
            i = ServersList->NumServers;

            //
            // now make server info structure;
            //

            Error = ServerInfoObj->GetServerInfo( &ServersList->Servers[i] );

            if( Error != ERROR_SUCCESS ) {
                TcpsvcsDbgAssert( ServersList->Servers[i] == NULL );

                delete ServerInfoObj;
                ServerInfoObj = NULL;
                goto Cleanup;
            }

            //
            // allocate space for server address.
            //

            LPVOID ServerAddress;

            ServerAddress = SvclocHeap->Alloc( QueryResponse->SourcesAddressLength );

            if( ServerAddress != NULL ) {

                //
                // copy server address.
                //

               TcpsvcsDbgAssert( ServersList->Servers[i]->ServerAddress.BindData == NULL );
               TcpsvcsDbgAssert( ServersList->Servers[i]->ServerAddress.Length == 0 );

                memcpy(
                   ServerAddress,
                   QueryResponse->SourcesAddress,
                   QueryResponse->SourcesAddressLength );

                ServersList->Servers[i]->ServerAddress.BindData = ServerAddress;
                ServersList->Servers[i]->ServerAddress.Length =
                    QueryResponse->SourcesAddressLength;
            }

            //
            // we success fully added another server info, indicate so.
            //

            ServersList->NumServers++;
        }

        //
        // delete the object which we don't require anymore.
        //

        delete ServerInfoObj;
        ServerInfoObj = NULL;
    }

    //
    // now set up return pointer.
    //

    *INetServersList = ServersList;
    ServersList = NULL;
    Error = ERROR_SUCCESS;

Cleanup:

    UNLOCK_SVC_GLOBAL_DATA();

    if( ServersList != NULL ) {

        //
        // free server info structures first.
        //

        if( ServersList->NumServers > 0 ) {
            TcpsvcsDbgAssert( ServersList->Servers != NULL );
        }

        DWORD Index;
        for (Index = 0; Index < ServersList->NumServers; Index++) {

            TcpsvcsDbgAssert( ServersList->Servers[Index] != NULL );
            FreeServerInfo( ServersList->Servers[Index] );
        }

        if( ServersList->Servers != NULL ) {
            SvclocHeap->Free( ServersList->Servers );
        }

        SvclocHeap->Free( ServersList );
    }

    if( Error != ERROR_SUCCESS ) {
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "ProcessDiscoveryResponses returning error, %ld.", Error ));
    }

    return( Error );
}

DWORD
ProcessNcbResponse(
    NCB *Ncb,
    PLIST_ENTRY RespList,
    DWORD *NumEntries
    )
{
    LPBYTE RespBuffer;
    DWORD RespBufferLen;

    if ( Ncb->ncb_retcode ==  NRC_GOODRET ) {

        // DebugBreak();

        //
        // copy response buffer pointer.
        //

        RespBuffer = Ncb->ncb_buffer;
        RespBufferLen = Ncb->ncb_length;

        //
        // allocate a new buffer.
        //

        LPBYTE RecvBuffer;

        RecvBuffer = (LPBYTE )
            SvclocHeap->Alloc( SVCLOC_CLI_QUERY_RESP_BUF_SIZE );

        if( RecvBuffer == NULL ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        Ncb->ncb_buffer = RecvBuffer;
        Ncb->ncb_length = SVCLOC_CLI_QUERY_RESP_BUF_SIZE;

        //
        // resubmit the NCB with different buffer.
        //

        UCHAR NBErrorCode;

        NBErrorCode = Netbios( Ncb );

        if( (NBErrorCode != NRC_GOODRET) ||
            (Ncb->ncb_retcode != NRC_PENDING) ) {

            TcpsvcsDbgPrint(( DEBUG_ERRORS,
                    "Netbios() failed, %ld, %ld \n",
                        NBErrorCode, Ncb->ncb_retcode ));

            return( ERROR_BAD_NETPATH );
        }

    }
    else {

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "Netbios() failed, %ld\n", Ncb->ncb_retcode ));

        return( ERROR_BAD_NETPATH ); // ??
    }

    //
    // create a response entry and add to the list.
    //

    LPSVCLOC_NETBIOS_RESP_ENTRY RespEntry;

    RespEntry = (LPSVCLOC_NETBIOS_RESP_ENTRY)
        SvclocHeap->Alloc( sizeof(SVCLOC_NETBIOS_RESP_ENTRY) );

    if( RespEntry == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );;
    }

    RespEntry->Resp.ResponseBuffer = RespBuffer;
    RespEntry->Resp.ResponseBufLen = RespBufferLen;

    RespEntry->Resp.SourcesAddress.snb_family = AF_NETBIOS;
    RespEntry->Resp.SourcesAddress.snb_type =
        TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    memcpy(
        RespEntry->Resp.SourcesAddress.snb_name,
        Ncb->ncb_callname,
        sizeof(Ncb->ncb_callname) );

    RespEntry->Resp.SourcesAddrLen = sizeof(SOCKADDR_NB);

    (*NumEntries)++;
    InsertTailList( RespList, (PLIST_ENTRY)RespEntry );

    return( ERROR_SUCCESS );
}

VOID
NcbPostHandler(
    NCB *Ncb
    )
{
    ProcessNcbResponse(
        Ncb,
        &GlobalWin31NBRespList,
        &GlobalWin31NumNBResps
        );

    return;
}

DWORD
DiscoverNetBiosServers(
    LPSTR ServerName
    )
/*++

Routine Description:

    This function sends out discovery message over netbios NBCs

Arguments:

    ServerName : name of the specific server to discover.

Return Value:

    Windows Error Code.

--*/
{
    NCB *Ncbs = NULL;
    LANA_ENUM Lanas;
    DWORD Error = ERROR_SUCCESS;
    UCHAR NBErrorCode = NRC_GOODRET;
    UCHAR UniqueName[NCBNAMSZ];

    // DebugBreak();

    LOCK_SVC_GLOBAL_DATA();

    if( !GetNetBiosLana( &Lanas ) ) {
        return( ERROR_BAD_NETPATH );
    }

    TcpsvcsDbgAssert( Lanas.length != 0 );

    if( Lanas.length == 0 ) {
        return( ERROR_BAD_NETPATH );
    }

    Ncbs = (NCB *) SvclocHeap->Alloc( sizeof(NCB ) * Lanas.length );

    if( Ncbs == NULL ) {

        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    memset( Ncbs, 0x0, sizeof(NCB) * Lanas.length );

    GetNBUniqueName( (LPSTR)UniqueName, NCBNAMSZ );

    //
    // alloc memory for the pending recvs.
    //

#define NUM_RECV_PENDING_NCBS_PER_LANA   3

    GlobalNumNBPendingRecvs = 0;
    GlobalNBPendingRecvs = (NCB *)
        SvclocHeap->Alloc(
            sizeof(NCB ) *
                Lanas.length  *
                    NUM_RECV_PENDING_NCBS_PER_LANA );

    if( GlobalNBPendingRecvs == NULL ) {

        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    DWORD i;
    for( i = 0; i < Lanas.length; i++ ) {

        NCB *PendingRecv;
        LPBYTE RecvBuffer;
        HANDLE EventHandle;

        Ncbs[i].ncb_command = NCBADDNAME;
        memcpy( Ncbs[i].ncb_name, UniqueName, NCBNAMSZ );

        //
        // add name.
        //

        Ncbs[i].ncb_lana_num = Lanas.lana[i];

        // DebugBreak();
        NBErrorCode = Netbios( &Ncbs[i] );

        if( Ncbs[i].ncb_retcode != NRC_GOODRET ) {
            NBErrorCode = Ncbs[i].ncb_retcode;
        }

        if( NBErrorCode != NRC_GOODRET ) {
            goto Cleanup;
        }

        //
        // post pending receives.
        //

        DWORD j;

        for( j = 0; j < NUM_RECV_PENDING_NCBS_PER_LANA; j++ ) {

            TcpsvcsDbgAssert(
                GlobalNumNBPendingRecvs <
                    ( (DWORD)Lanas.length  *
                        NUM_RECV_PENDING_NCBS_PER_LANA) );

            PendingRecv =
                &GlobalNBPendingRecvs[GlobalNumNBPendingRecvs];

            memset( PendingRecv, 0x0, sizeof(NCB) );

            memcpy(
                PendingRecv->ncb_name,
                Ncbs[i].ncb_name,
                NCBNAMSZ );

            PendingRecv->ncb_lana_num = Lanas.lana[i];
            PendingRecv->ncb_command = NCBDGRECV | ASYNCH;
            PendingRecv->ncb_rto = SVCLOC_NB_RECV_TIMEOUT / 2;

            PendingRecv->ncb_num = Ncbs[i].ncb_num;

            RecvBuffer = (LPBYTE)
                SvclocHeap->Alloc( SVCLOC_CLI_QUERY_RESP_BUF_SIZE );

            if( RecvBuffer == NULL ) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            PendingRecv->ncb_buffer = RecvBuffer;
            PendingRecv->ncb_length = SVCLOC_CLI_QUERY_RESP_BUF_SIZE;

            if( GlobalPlatformType == VER_PLATFORM_WIN32s ) {

                PendingRecv->ncb_post = NcbPostHandler ;
            }
            else {

                //
                // create an event.
                //

                EventHandle = IIS_CREATE_EVENT(
                                  "NCB::ncb_event",
                                  PendingRecv,
                                  FALSE,        // automatic reset
                                  FALSE         // initial state: NOT signalled
                                  );

                if( EventHandle == NULL ) {
                    Error = GetLastError();
                    SvclocHeap->Free( RecvBuffer );
                    goto Cleanup;
                }

                PendingRecv->ncb_event = EventHandle;
            }

            // DebugBreak();
            NBErrorCode = Netbios( PendingRecv );

            if( (PendingRecv->ncb_retcode != NRC_PENDING) &&
                (PendingRecv->ncb_retcode != NRC_GOODRET) ) {
                NBErrorCode = PendingRecv->ncb_retcode;
            }

            if( NBErrorCode != NRC_GOODRET ) {
                SvclocHeap->Free( RecvBuffer );
                CloseHandle( EventHandle );
                goto Cleanup;
            }

            GlobalNumNBPendingRecvs++;
        }
    }

    //
    // send discovery message to all lanas.
    //

    for( i = 0; i < Lanas.length; i++ ) {

        Ncbs[i].ncb_command = NCBDGSEND;
        Ncbs[i].ncb_lana_num = Lanas.lana[i];
        Ncbs[i].ncb_retcode = NRC_GOODRET;

        //
        // setup sender's name.
        //

        if( ServerName == NULL ) {

            //
            // if no server name is specified, then send the discovery message
            // to IC group name.
            //

            TcpsvcsDbgAssert(
                    NETBIOS_INET_GROUP_NAME_LEN ==
                        NCBNAMSZ );

            memcpy(
                Ncbs[i].ncb_callname,
                NETBIOS_INET_GROUP_NAME,
                NETBIOS_INET_GROUP_NAME_LEN );
        }
        else {

            DWORD ServerNameLen;

            //
            // send the discovery message to the specified server.
            //

            ServerNameLen = strlen(ServerName);

            TcpsvcsDbgAssert( ServerNameLen <= NCBNAMSZ );

            memset(
                Ncbs[i].ncb_callname,
                0x0,
                NCBNAMSZ );

            memcpy(
                Ncbs[i].ncb_callname,
                ServerName,
                (ServerNameLen >= NCBNAMSZ) ? NCBNAMSZ : ServerNameLen );
        }

        //
        // setup message buffer.
        //

        Ncbs[i].ncb_buffer = GlobalCliQueryMsg;
        Ncbs[i].ncb_length = (WORD)GlobalCliQueryMsgLen;

        // DebugBreak();
        NBErrorCode = Netbios( &Ncbs[i] );

        if( Ncbs[i].ncb_retcode != NRC_GOODRET ) {
            NBErrorCode = Ncbs[i].ncb_retcode;
        }

        if( NBErrorCode != NRC_GOODRET ) {
            // DebugBreak();
            goto Cleanup;
        }
    }

Cleanup:

    if( (Error != ERROR_SUCCESS) ||
            (NBErrorCode != NRC_GOODRET) ) {


        for( i = 0; i < GlobalNumNBPendingRecvs; i++ ) {

            NCB Ncb;
            NCB *PendingEntry;
            BOOL CancelNcb;

            memset( &Ncb, 0x0, sizeof(NCB) );

            //
            // cancel pending receives and free resources.
            //

            Ncb.ncb_command = NCBCANCEL;
            Ncb.ncb_length = sizeof( NCB );

            PendingEntry = &GlobalNBPendingRecvs[i];

            CancelNcb = FALSE;
            if( GlobalPlatformType == VER_PLATFORM_WIN32s ) {

                if( PendingEntry->ncb_retcode == NRC_PENDING ) {
                    CancelNcb = TRUE;
                }
            }
            else {

                //
                // check to see the event is signalled.
                //

                DWORD Wait;

                Wait = WaitForSingleObject(
                                PendingEntry->ncb_event,
                                0 );

                    if( Wait == WAIT_TIMEOUT ) {
                        CancelNcb = TRUE;
                    }
            }

            if( CancelNcb == TRUE ) {

                UCHAR NcbError;

                Ncb.ncb_retcode = NRC_GOODRET;
                Ncb.ncb_buffer = (LPBYTE)PendingEntry;
                Ncb.ncb_lana_num = PendingEntry->ncb_lana_num;

                // DebugBreak();
                NcbError = Netbios( &Ncb );

                if( (NcbError != NRC_GOODRET) ||
                    (Ncb.ncb_retcode != NRC_GOODRET) ) {

                    TcpsvcsDbgPrint((
                        DEBUG_ERRORS,
                            "Netbios() failed, %ld, %ld \n",
                                (DWORD)NcbError,
                                (DWORD)Ncb.ncb_retcode ));
                }
            }

            //
            // free receive buffer.
            //

            SvclocHeap->Free( PendingEntry->ncb_buffer );
            CloseHandle( PendingEntry->ncb_event );
        }

        if( GlobalNBPendingRecvs != NULL ) {
            SvclocHeap->Free( GlobalNBPendingRecvs );
            GlobalNBPendingRecvs = NULL;
        }

        GlobalNumNBPendingRecvs = 0;

        UNLOCK_SVC_GLOBAL_DATA();

        TcpsvcsDbgPrint((
            DEBUG_ERRORS,
                "DiscoveryNetBiosServers failed,"
                    "NBErrorCode = %ld, Error = %ld \n",
                            (DWORD)NBErrorCode, Error ));

        return( ERROR_BAD_NETPATH );
    }

    if( Ncbs != NULL ) {
        SvclocHeap->Free(Ncbs);
    }

    UNLOCK_SVC_GLOBAL_DATA();
    return( ERROR_SUCCESS );
}

DWORD
ReceiveNetBiosResponses(
    LPSVCLOC_NETBIOS_RESPONSE *NetBiosResponses,
    DWORD *NumResponses,
    DWORD TimeoutinMSecs,
    BOOL WaitForAllResponses
    )
/*++

Routine Description:

    This function collects all responses that are received for the NetBios
    discovery.

Arguments:

    NetBiosResponses : pointer to a location where the responses buffer
        is returned.

    NumResponses : pointer to a location where the number of responses in
        the above buffer is returned

    TimeoutinMSecs : wait timeout for responses.

    WaitForAllResponses : If this flag is set TRUE, this function wait
        complete 'Time' secs for all responses to arrive. Otherwise it
        will return after a succcessful response is received.


Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD i;

    NCB *PendingRecvs;
    DWORD NumPendingRecvs;

    HANDLE *WaitHandles = NULL;

    LIST_ENTRY RespListHead;

    PLIST_ENTRY RespList;
    DWORD NumResps;

    // DebugBreak();

    *NumResponses = 0;

    //
    // init.
    //

    InitializeListHead( &RespListHead );
    RespList = &RespListHead;
    NumResps = 0;

    //
    // copy receive list.
    //

    LOCK_SVC_GLOBAL_DATA();
    PendingRecvs = GlobalNBPendingRecvs;
    NumPendingRecvs = GlobalNumNBPendingRecvs;
    GlobalNBPendingRecvs = NULL;
    GlobalNumNBPendingRecvs = 0;
    UNLOCK_SVC_GLOBAL_DATA();

    if( NumPendingRecvs == 0 ) {

        //
        // we are done.
        //

        Error =  ERROR_SUCCESS;
        goto Cleanup;
    }

    if( GlobalPlatformType == VER_PLATFORM_WIN32s ) {

        //
        // wait for responses to arrive.
        //

        Sleep( TimeoutinMSecs );

        //
        // get the list of responses that have been gathered by the
        // handler routine.
        //

        RespList = &GlobalWin31NBRespList;
        NumResps = GlobalWin31NumNBResps;
    }
    else {

        WaitHandles = (HANDLE *)
            SvclocHeap->Alloc( NumPendingRecvs * sizeof(HANDLE) );

        if( WaitHandles == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        HANDLE *WaitHandleEntry;
        WaitHandleEntry = WaitHandles;
        for( i = 0; i < NumPendingRecvs; i++ ) {

            *WaitHandleEntry = PendingRecvs[i].ncb_event;
            WaitHandleEntry++;
        }

        //
        // wait for all pending receives.
        //

        DWORD StartTime;
        StartTime = GetTickCount();

        for( ;; ) {

            DWORD Wait;
            NCB *SignalledNcb;

            Wait = WaitForMultipleObjects(
                            NumPendingRecvs,
                            WaitHandles,
                            FALSE, // wait for one.
                            TimeoutinMSecs );

            if( Wait == WAIT_FAILED ) {
                Error = GetLastError();
                goto Cleanup;
            }

            if( Wait == WAIT_TIMEOUT ) {
                break;
            }

            //
            // one of the handle has been signalled.
            //

            Wait -= WAIT_OBJECT_0; // index to the handle.

            TcpsvcsDbgAssert( Wait < NumPendingRecvs );

            SignalledNcb = &PendingRecvs[Wait];

            Error = ProcessNcbResponse(
                        &PendingRecvs[Wait],
                        RespList,
                        &NumResps );

            TcpsvcsDbgAssert(  Error == ERROR_SUCCESS );

            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            //
            // recompute wait time.
            //

            DWORD EndTime;
            DWORD Elapse;

            EndTime = GetTickCount();
            Elapse = EndTime - StartTime;

            //
            // set TIMEOUT to zero if we are asked to return after a first
            // set of responses received or if the given time elapses.
            //

            if( (WaitForAllResponses == FALSE) ||
                    (Elapse > TimeoutinMSecs) ) {

                TimeoutinMSecs = 0;
            }
            else {
                TimeoutinMSecs -= Elapse;
            }

            StartTime = EndTime;
        }
    }

    if( NumResps == 0 ) {

        //
        // we are done.
        //

        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // allocate space for return structures.
    //

    LPSVCLOC_NETBIOS_RESPONSE RetResps;

    RetResps = (LPSVCLOC_NETBIOS_RESPONSE)
        SvclocHeap->Alloc(
            NumResps * sizeof(SVCLOC_NETBIOS_RESPONSE) );

    if( RetResps == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // copy entries from list to return array.
    //

    DWORD NumRetEntries;
    PLIST_ENTRY RetEntry;

    NumRetEntries = 0;
    for( RetEntry = RespList->Flink;
            RetEntry != RespList;
                RetEntry = RetEntry->Flink ) {

        LPSVCLOC_NETBIOS_RESP_ENTRY REntry;

        REntry = (LPSVCLOC_NETBIOS_RESP_ENTRY)RetEntry;

        RetResps[NumRetEntries] = REntry->Resp;

        //
        // don't free up the returned response buffer.
        //

        REntry->Resp.ResponseBuffer = NULL;

        NumRetEntries++;
    }

    TcpsvcsDbgAssert( NumRetEntries == NumResps );

    *NumResponses = NumRetEntries;
    *NetBiosResponses = RetResps;
    Error = ERROR_SUCCESS;

Cleanup:

    if( WaitHandles != NULL ) {
        SvclocHeap->Free( WaitHandles );
    }

    //
    // free response list.
    //

    while ( !IsListEmpty(RespList) ) {

        PLIST_ENTRY Entry;

        Entry = RemoveHeadList( RespList );

        //
        // free response buffer if it is not used.
        //

        if( ((LPSVCLOC_NETBIOS_RESP_ENTRY)
                Entry)->Resp.ResponseBuffer != NULL ) {

            SvclocHeap->Free(
                ((LPSVCLOC_NETBIOS_RESP_ENTRY)
                    Entry)->Resp.ResponseBuffer );
        }

        SvclocHeap->Free( Entry );
    }

    //
    // cancel all pending recvs and delete names.
    //

    if( NumPendingRecvs != 0 ) {

        NCB Ncb;

        memset( &Ncb, 0x0, sizeof(NCB) );
        Ncb.ncb_command = NCBCANCEL;
        Ncb.ncb_length = sizeof( NCB );

        for( i = 0; i < NumPendingRecvs; i++ ) {

            NCB *PendingEntry;
            UCHAR NcbError;
            DWORD Wait;
            BOOL CancelNcb;

            PendingEntry = &PendingRecvs[i];

            CancelNcb = FALSE;
            if( GlobalPlatformType == VER_PLATFORM_WIN32s ) {

                if( PendingEntry->ncb_retcode == NRC_PENDING ) {
                    CancelNcb = TRUE;
                }
            }
            else {

                //
                // check to see the event is signalled.
                //

                DWORD Wait;

                Wait = WaitForSingleObject(
                                PendingEntry->ncb_event,
                                0 );

                    if( Wait == WAIT_TIMEOUT ) {
                        CancelNcb = TRUE;
                    }
            }

            if( CancelNcb == TRUE ) {

                Ncb.ncb_retcode = NRC_GOODRET;
                Ncb.ncb_buffer = (LPBYTE)PendingEntry;
                Ncb.ncb_length = sizeof( NCB );
                Ncb.ncb_lana_num = PendingEntry->ncb_lana_num;

                Ncb.ncb_command = NCBCANCEL;

                NcbError = Netbios( &Ncb );

                if( (NcbError != NRC_GOODRET) ||
                    (Ncb.ncb_retcode != NRC_GOODRET) ) {

                    TcpsvcsDbgPrint((
                        DEBUG_ERRORS,
                            "Netbios() failed, %ld, %ld \n",
                                (DWORD)NcbError,
                                (DWORD)Ncb.ncb_retcode ));
                }
            }

            //
            // delete name.
            //

            Ncb.ncb_retcode = NRC_GOODRET;
            memcpy(
                Ncb.ncb_name,
                PendingEntry->ncb_name,
                sizeof( Ncb.ncb_name ) );

            Ncb.ncb_lana_num = PendingEntry->ncb_lana_num;
            Ncb.ncb_command = NCBDELNAME;

            NcbError = Netbios( &Ncb );

            if( (NcbError != NRC_GOODRET) ||
                (Ncb.ncb_retcode != NRC_GOODRET) ) {

                TcpsvcsDbgPrint((
                    DEBUG_ERRORS,
                        "Netbios() failed, %ld, %ld \n",
                            (DWORD)NcbError,
                            (DWORD)Ncb.ncb_retcode ));
            }

            //
            // free receive buffer.
            //

            SvclocHeap->Free( PendingEntry->ncb_buffer );
            CloseHandle( PendingEntry->ncb_event );
        }

        SvclocHeap->Free( PendingRecvs );
    }

    return( Error  );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\reg.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    reg.cxx

Abstract:

    Contains code that implements REGISTRY_OBJ class defined in reg.hxx.

Author:

    Madan Appiah (madana)  19-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include <svcloc.hxx>

MEMORY *CacheHeap = NULL;

INLINE
DWORD
REGISTRY_OBJ::GetValueSizeAndType(
    LPWSTR ValueName,
    LPDWORD ValueSize,
    LPDWORD ValueType
    )
/*++

Routine Description:

    This function returns the size and type of a value of this key.

Arguments:

    ValueName : name of the value whose size and type returned.

    ValueSize : pointer to a location where the value size is returned.

    ValueType : pointer to a location where the value type is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegQueryValueExW(
                _RegHandle,
                ValueName,
                0,
                ValueType,
                NULL,
                ValueSize );

    return( Error );
}


REGISTRY_OBJ::REGISTRY_OBJ(
    HKEY Handle,
    DWORD Error
    )
/*++

Routine Description:

    This function is a inline function that initialize the registry
    object with given handle and status.

Arguments:

    Handle : registry object handle value.

    Error : registry object status value.

Return Value:

    None.

--*/
{
    _RegHandle = Handle;
    _Status = Error;
    _Index = 0;
    _ValIndex = 0;
    return;
};


REGISTRY_OBJ::REGISTRY_OBJ(
    HKEY ParentHandle,
    LPWSTR KeyName
    )
/*++

Routine Description:

    Initializes the registry object from its parent's registry key
    handle and this object's keyname.

Arguments:

    ParentHandle : registry handle of the parent key.

    Keyname : key name of the new registry object being created.

Return Value:

    None.

--*/
{
    _Index = 0;
    _ValIndex = 0;
    _Status = RegOpenKeyExW(
                ParentHandle,
                KeyName,
                0,
                DEFAULT_KEY_ACCESS,
                &_RegHandle );

    if( _Status != ERROR_SUCCESS ) {
        _RegHandle = NULL;
    }

    return;
}

REGISTRY_OBJ::REGISTRY_OBJ(
    REGISTRY_OBJ *ParentObj,
    LPWSTR KeyName
    )
/*++

Routine Description:

    Initializes the registry object from its parent's registry object
    and this object's keyname.

Arguments:

    ParentObj : registry object of the parent.

    Keyname : key name of the new registry object being created.

Return Value:

    None.

--*/
{
    _Index = 0;
    _ValIndex = 0;
    _Status = RegOpenKeyExW(
                ParentObj->_RegHandle,
                KeyName,
                0,
                DEFAULT_KEY_ACCESS,
                &_RegHandle );

    if( _Status != ERROR_SUCCESS ) {
        _RegHandle = NULL;
    }

    return;
}

DWORD
REGISTRY_OBJ::Create(
    LPWSTR ChildName
    )
/*++

Routine Description:

    Creates a new subkey under this key.

Arguments:

    ChildName : name of the subkey being created.

Return Value:

    Windows Error Code.

--*/
{
    HKEY ChildHandle;
    DWORD KeyDisposition;

    _Status = RegCreateKeyExW(
               _RegHandle,
               ChildName,
               0,
               DEFAULT_CLASS,
               REG_OPTION_NON_VOLATILE,
               DEFAULT_KEY_ACCESS,
               NULL,
               &ChildHandle,
               &KeyDisposition );

    if( _Status != ERROR_SUCCESS ) {
        return( _Status );
    }

    if( KeyDisposition == REG_CREATED_NEW_KEY ) {
        TcpsvcsDbgPrint(( DEBUG_REGISTRY,
           "Registry key (%ws) is created.\n", ChildName ));
    }

    //
    // close the child handle before return.
    //

    RegCloseKey( ChildHandle );
    return( ERROR_SUCCESS );
}


DWORD
REGISTRY_OBJ::Create(
    LPWSTR ChildName,
    REGISTRY_OBJ **ChildObj
    )
/*++

Routine Description:

    Creates a new subney and a new subney registry object.

Arguments:

    ChildName : name of the subkey being created.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    HKEY ChildHandle;
    DWORD KeyDisposition;

    Error = RegCreateKeyExW(
                _RegHandle,
                ChildName,
                0,
                DEFAULT_CLASS,
                REG_OPTION_NON_VOLATILE,
                DEFAULT_KEY_ACCESS,
                NULL,
                &ChildHandle,
                &KeyDisposition );


    if( Error != ERROR_SUCCESS ) {
        *ChildObj = new REGISTRY_OBJ( NULL, Error );
    }
    else {

        if( KeyDisposition == REG_CREATED_NEW_KEY ) {
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%ws) is created.\n", ChildName ));
        }

        *ChildObj = new REGISTRY_OBJ( ChildHandle, (DWORD)ERROR_SUCCESS );
    }

    return( Error );
}

DWORD
REGISTRY_OBJ::Create(
    LPWSTR ChildName,
    REGISTRY_OBJ **ChildObj,
    DWORD *KeyDisposition
    )
/*++

Routine Description:

    Creates a new subney and a new subney registry object.

Arguments:

    ChildName : name of the subkey being created.

    ChildObj : pointer to a location where the child registry object
        pointer is returned.

    KeyDisposition : pointer to a location where the child KeyDisposition
        value is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    HKEY ChildHandle;

    Error = RegCreateKeyExW(
                _RegHandle,
                ChildName,
                0,
                DEFAULT_CLASS,
                REG_OPTION_NON_VOLATILE,
                DEFAULT_KEY_ACCESS,
                NULL,
                &ChildHandle,
                KeyDisposition );


    if( Error != ERROR_SUCCESS ) {
        *ChildObj = new REGISTRY_OBJ( NULL, Error );
    }
    else {

        if( *KeyDisposition == REG_CREATED_NEW_KEY ) {
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%ws) is created.\n", ChildName ));
        }

        *ChildObj = new REGISTRY_OBJ( ChildHandle, (DWORD)ERROR_SUCCESS );
    }

    return( Error );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPWSTR ValueName,
    DWORD *Data
    )
/*++

Routine Description:

    Gets a REG_DWORD value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize = sizeof(DWORD);

    Error = RegQueryValueExW(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                (LPBYTE)Data,
                &ValueSize );

    TcpsvcsDbgAssert( ValueSize == sizeof( DWORD ) );
    TcpsvcsDbgAssert( ValueType == REG_DWORD );

    return( Error );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPWSTR ValueName,
    LPWSTR *Data,
    DWORD *NumStrings
    )
/*++

Routine Description:

    Gets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize;
    LPBYTE StringData = NULL;

    Error = GetValueSizeAndType( ValueName, &ValueSize, &ValueType );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert(
        (ValueType == REG_SZ) ||
        (ValueType == REG_EXPAND_SZ) ||
        (ValueType == REG_MULTI_SZ) );

    StringData = (LPBYTE)CacheHeap->Alloc( ValueSize );

    if( StringData == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    Error = RegQueryValueExW(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                StringData,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        CacheHeap->Free( StringData );
        return( Error );
    }

    *Data = (LPWSTR)StringData;

    if( (ValueType == REG_SZ) || (ValueType == REG_EXPAND_SZ) ) {
        *NumStrings = 1;
    }
    else {

        DWORD Strings = 0;
        LPWSTR StrPtr = (LPWSTR)StringData;
        DWORD Len;

        while( (Len = wcslen(StrPtr)) != 0 ) {
            Strings++;
            StrPtr = StrPtr + Len + 1;
        }

        *NumStrings = Strings;
    }

    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPWSTR ValueName,
    LPBYTE *Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Gets a REG_BINARY value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize;
    LPBYTE BinaryData = NULL;

    Error = GetValueSizeAndType( ValueName, &ValueSize, &ValueType );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( ValueType == REG_BINARY );

    BinaryData = (LPBYTE)CacheHeap->Alloc( ValueSize );

    if( BinaryData == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    Error = RegQueryValueExW(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                BinaryData,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        CacheHeap->Free( BinaryData );
        return( Error );
    }

    *Data = BinaryData;
    *DataLen = ValueSize;
    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPWSTR ValueName,
    LPBYTE Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Gets a REG_BINARY value.

Arguments:

    ValueName : name of the value being retrived.

    Data : pointer to a buffer where the data will be read.

    Datalen : pointer to location where length of the above buffer is
        passed. On return this location will have the length of the
        data read.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;

    Error = RegQueryValueExW(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                Data,
                DataLen );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPWSTR ValueName,
    LPDWORD Data
    )
/*++

Routine Description:

    Sets a REG_DWORD value.

Arguments:

    ValueName : name of the value being set.

    Date : pointer to a DWORD data.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueExW(
                _RegHandle,
                ValueName,
                0,
                REG_DWORD,
                (LPBYTE)Data,
                sizeof(DWORD) );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPWSTR ValueName,
    LPWSTR Data,
    DWORD StringType
    )
/*++

Routine Description:

    Sets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

    Data : pointer to STRING(s) data.

    StringType : type of string data in the above buffer, it should be
        either of the following types :
            REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueExW(
                _RegHandle,
                ValueName,
                0,
                StringType,
                (LPBYTE)Data,
                sizeof(WCHAR) * (wcslen(Data) + 1) );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPSTR ValueName,
    LPSTR Data,
    DWORD DataLen,
    DWORD StringType
    )
/*++

Routine Description:

    Sets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

    Data : pointer to STRING(s) data.

    DataLen : data length

    StringType : type of string data in the above buffer, it should be
        either of the following types :
            REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                StringType,
                (LPBYTE)Data,
                DataLen );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPWSTR ValueName,
    LPBYTE Data,
    DWORD DataLen
    )
/*++

Routine Description:

    Sets a REG_BINARY value.

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueExW(
                _RegHandle,
                ValueName,
                0,
                REG_BINARY,
                Data,
                DataLen );

    return( Error );
}

DWORD
REGISTRY_OBJ::FindNextKey(
    LPWSTR Key,
    DWORD KeySize
    )
/*++

Routine Description:

    Retrieves the Next subkey name of this key.

Arguments:

    Key - pointer to a buffer that receives the subkey name.

    KeySize - size of the above buffer in CHARS.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD KeyLength;
    FILETIME KeyLastWrite;

    KeyLength = KeySize * sizeof(WCHAR);
    Error = RegEnumKeyExW(
                _RegHandle,
                _Index,
                Key,
                &KeyLength,
                0,                  // reserved.
                NULL,               // class string not required.
                0,                  // class string buffer size.
                &KeyLastWrite );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( KeyLength <= KeySize );

    //
    // increament the index to point to the next key.
    //

    _Index++;
    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::DeleteKey(
    LPWSTR ChildKeyName
    )
/*++

Routine Description:

    Deletes a subkey node.

Arguments:

    ChildKeyName : name of the subkey to be deleted.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPWSTR GChildKeyName[MAX_KEY_SIZE];
    REGISTRY_OBJ ChildObj( _RegHandle, ChildKeyName );

    Error = ChildObj.GetStatus();

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // delete all its subkeys.
    //

    Error = ChildObj.FindFirstKey(
                (LPWSTR)GChildKeyName,
                MAX_KEY_SIZE );

    while( Error == ERROR_SUCCESS ) {

        Error = ChildObj.DeleteKey( (LPWSTR)GChildKeyName );

        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }

        Error = ChildObj.FindFirstKey(
                    (LPWSTR)GChildKeyName,
                    MAX_KEY_SIZE );
    }

    if( Error != ERROR_NO_MORE_ITEMS ) {
        return( Error );
    }

    //
    // delete this key.
    //

    Error = RegDeleteKeyW( _RegHandle, (LPWSTR)ChildKeyName );
    return( Error );
}

DWORD
REGISTRY_OBJ::FindNextValue(
    LPSTR ValueName,
    DWORD ValueSize,
    LPBYTE Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Retrieves the Next value name of this key.

Arguments:

    ValueName - pointer to a buffer that receives the Value name.

    ValueSize - size of the above buffer in CHARS.
    Data - pointer to a buffer that receives the Value data.
    DataLen - pointer to a buffer that receives data size.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueLength;
    DWORD ValueType;

    ValueLength = ValueSize * sizeof(CHAR);

    Error = RegEnumValue(
                _RegHandle,
                _ValIndex,
                ValueName,
                &ValueLength,
                NULL,                  // reserved.
                &ValueType,
                Data,
                DataLen );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( ValueLength <= ValueSize );

    //
    // increment the value index to point to the next value.
    //

    _ValIndex++;
    return( ERROR_SUCCESS );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\svccom.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    svccom.cxx

Abstract:

    Contains code that is common to both client and server side of
    the service location protocol..

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include <svcloc.hxx>

DWORD g_cInitializers = 0;

//
// include global.h one more time to alloc global data.
//

//
// to enable second time include.
//

#undef _GLOBAL_
#undef EXTERN

//
// to allocate data
//

#define GLOBAL_SVC_DATA_ALLOCATE

#include <global.h>

DWORD
MakeSapServiceName(
    LPSTR SapNameBuffer,
    DWORD SapNameBufferLen
    )
/*++

Routine Description:

    This routine generates a sap service name. The first part of the name
    is computername and last part is the string version of service guid.

Arguments:

    SapNameBuffer - pointer to a sap name buffer where sap name is
        returned.

    SapNameBufferLen - length of the above buffer.

Return Value:

    pointer to sap service name..

--*/
{
    TcpsvcsDbgAssert( SapNameBufferLen >= (SAP_SERVICE_NAME_LEN + 1));

    if( SapNameBufferLen < SAP_SERVICE_NAME_LEN + 1) {
        return( ERROR_INSUFFICIENT_BUFFER );
    }

    //
    // Get Computername.
    //


    DWORD Len = SapNameBufferLen;

    if( !GetComputerNameA( SapNameBuffer, &Len ) ) {

        DWORD Error = GetLastError();

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "GetComputerNameA failed, %ld.\n", Error ));

        return( Error );
    }

    TcpsvcsDbgAssert( Len <= MAX_COMPUTERNAME_LENGTH );

    while( Len < MAX_COMPUTERNAME_LENGTH ) {
        SapNameBuffer[Len++] = '!';
    }

    //
    // append GUID.
    //

    strcpy( SapNameBuffer + Len, SERVICE_GUID_STR );

     return( ERROR_SUCCESS );
}

VOID
MakeUniqueServerName(
    LPBYTE StrBuffer,
    DWORD StrBufferLen,
    LPSTR ComputerName
    )
/*++

Routine Description:

    This routine makes an unique name used by the server to listen to
    the client discovery requests.

Arguments:

    StrBuffer : pointer to a buffer where the unique name is returned.

    StrBufferLen : length of the above buffer.

    ComputerName : pointer to the computer that is used to form the unique
        name.

Return Value:

    none.

--*/
{
    DWORD ComputerNameLen = strlen(ComputerName);
    DWORD BufLen = StrBufferLen;
    LPBYTE Buffer = StrBuffer;

    memset( Buffer, 0x0, BufLen );

    memcpy(
        Buffer,
        NETBIOS_INET_SERVER_UNIQUE_NAME,
        NETBIOS_INET_SERVER_UNIQUE_NAME_LEN );

    BufLen -= NETBIOS_INET_SERVER_UNIQUE_NAME_LEN;
    Buffer += NETBIOS_INET_SERVER_UNIQUE_NAME_LEN;

    if( BufLen >= ComputerNameLen  ) {

        //
        // we enough space in the buffer to append computername.
        //

        memcpy( Buffer,ComputerName, ComputerNameLen );
        return;
    }

    //
    // buffer does not have enough space, chop off few chars from the
    // begining of the computername.
    //

    memcpy( Buffer, ComputerName + (ComputerNameLen - BufLen), BufLen );
    return;
}

#if 0

VOID
AppendRandomChar(
    LPSTR String
    )
/*++

Routine Description:

    This routine adds a random char to the end of the given string. It is
    assumed that the given string has a space for the new char.

Arguments:

    String : pointer to a string where a random char is added.

Return Value:

    none.

--*/
{
    CHAR RandChar;
    DWORD RandNum;

    RandNum = (DWORD)rand();

    RandNum = RandNum % (26 + 10);  // 26 alphabets, and 10 numerics

    if( RandNum < 10 ) {
        RandChar = (CHAR)('0'+ RandNum);
    }
    else {
        RandChar = (CHAR)('A'+ RandNum - 10);
    }

    DWORD Len = strlen(String);

    //
    // append random char.
    //

    String[Len] = RandChar;
    String[Len + 1] = '\0';
    return;
}

#endif //0

DWORD
ComputeCheckSum(
    LPBYTE Buffer,
    DWORD BufferLength
    )
/*++

Routine Description:

    This function computes the check sum of the given buffer by ex-or'ing
    the dwords. It is assumed that the buffer DWORD aligned and the buffer
    length is multiples of DWORD.

Arguments:

    Buffer : pointer to a buffer whose check sum to be computed.

    BufferLength : length of the above buffer.

Return Value:

    Check sum.

--*/
{
    DWORD CheckSum = 0;
    LPDWORD BufferPtr = (LPDWORD)Buffer;
    LPBYTE EndBuffer = Buffer + BufferLength;

    TcpsvcsDbgAssert( (ULONG_PTR)Buffer % sizeof(DWORD) == 0 );
        // alignment check.

    TcpsvcsDbgAssert( BufferLength % sizeof(DWORD) == 0 );
        // multiple DWORD check.

    while( (LPBYTE)BufferPtr < EndBuffer ) {
        CheckSum ^= *BufferPtr;
        BufferPtr++;
    }

    return( CheckSum );
}

BOOL
DLLSvclocEntry(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    )
/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/

{
    BOOL ok;
    DWORD error;

    UNREFERENCED_PARAMETER(DllHandle);

    //
    // perform global dll initialization, if any.
    //

    switch (Reason) {
    case DLL_PROCESS_ATTACH:

        //
        // we switch off thread library calls to avoid taking a hit for every
        // thread creation/termination that happens in this process, regardless
        // of whether Internet APIs are called in the thread.
        //
        // If a new thread does make Internet API calls that require a per-thread
        // structure then the individual API will create one
        //

        DisableThreadLibraryCalls(DllHandle);

        //
        //  Old Normandy servers that are in our process are assuming the
        //  service locator is initialized by DLL_PROCESS_ATTACH and terminated
        //  by PROCESS_DETACH.  Since the service locator has a thread we
        //  can't safely cleanup during process_detach so we do an extra
        //  loadlibrary on ourselves and remain in process.  When the Normandy
        //  servers are updated, remove this.
        //

        if ( !InitSvcLocator() ||
             !LoadLibrary( "inetsloc.dll" ))
        {
            return FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:

        break;
    }

    return (TRUE);
}

BOOL
InitSvcLocator(
    VOID
    )
{
    //
    //  We assume the caller is serializing access from multiple initializers.
    //  The callers will presumably be just infocomm.dll that does do the
    //  serialization.
    //
    //

    if ( g_cInitializers++ ) {
        return TRUE;
    }

    if ( DllProcessAttachSvcloc() != ERROR_SUCCESS ) {
        return FALSE;
    }

    return TRUE;
}

BOOL
TerminateSvcLocator(
    VOID
    )
{
    if ( --g_cInitializers )
        return TRUE;

    DllProcessDetachSvcloc();

    return TRUE;
}



DWORD
DllProcessAttachSvcloc(
    VOID
    )
/*++

Routine Description:

    This dll init function initializes service location global variables.

Arguments:

    NONE.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    //
    // initialize global variables.
    //

    // DebugBreak();

#if DBG

    //
    // initialize dbg crit sect.
    //

    INITIALIZE_CRITICAL_SECTION( &GlobalDebugCritSect );
    GlobalDebugFlag = DEBUG_ERRORS;

#endif // DBG

    INITIALIZE_CRITICAL_SECTION( &GlobalSvclocCritSect );

    LOCK_SVC_GLOBAL_DATA();
    GlobalComputerName[0] = '\0';

    GlobalSrvRegistered = FALSE;
    SvclocHeap = new MEMORY;

    if( SvclocHeap == NULL ) {
        UNLOCK_SVC_GLOBAL_DATA();
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    GlobalSrvInfoObj = NULL;

    GlobalSrvRespMsg = NULL;
    GlobalSrvRespMsgLength = 0;
    GlobalSrvAllotedRespMsgLen = 0;

    GlobalWinsockStarted = FALSE;
    GlobalRNRRegistered = FALSE;

    GlobalSrvListenThreadHandle = NULL;

    memset( &GlobalSrvSockets, 0x0, sizeof(GlobalSrvSockets) );

    GlobalCliDiscoverThreadHandle = NULL;

    GlobalCliQueryMsg = NULL;
    GlobalCliQueryMsgLen = 0;

    GlobalSapGuid.Data1 = ssgData1;
    GlobalSapGuid.Data2 = ssgData2;
    GlobalSapGuid.Data3 = ssgData3;
    GlobalSapGuid.Data4[0] = ssgData41;
    GlobalSapGuid.Data4[1] = ssgData42;
    GlobalSapGuid.Data4[2] = ssgData43;
    GlobalSapGuid.Data4[3] = ssgData44;
    GlobalSapGuid.Data4[4] = ssgData45;
    GlobalSapGuid.Data4[5] = ssgData46;
    GlobalSapGuid.Data4[6] = ssgData47;
    GlobalSapGuid.Data4[7] = ssgData48;

    InitializeListHead( &GlobalCliQueryRespList );

    memset( &GlobalCliSockets, 0x0, sizeof(GlobalCliSockets) );
    memset( &GlobalCliNBSockets, 0x0, sizeof(GlobalCliNBSockets) );
    GlobalCliIpxSocket = INVALID_SOCKET;

    GlobalDiscoveryInProgressEvent =
        IIS_CREATE_EVENT(
            "GlobalDiscoveryInProgressEvent",
            &GlobalDiscoveryInProgressEvent,
            TRUE,       // MANUAL reset
            TRUE        // initial state: signalled
            );

    if ( GlobalDiscoveryInProgressEvent == NULL ) {
        Error = GetLastError();
        UNLOCK_SVC_GLOBAL_DATA();
        return(Error);
    }

    GlobalLastDiscoveryTime = 0;

    //
    // get platform type.
    //

    OSVERSIONINFO VersionInfo;

    VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);

    if ( (GetVersionEx(&VersionInfo)) ) {
        GlobalPlatformType = VersionInfo.dwPlatformId;
    }
    else {
        UNLOCK_SVC_GLOBAL_DATA();
        return( ERROR_INSUFFICIENT_BUFFER );
    }

    GlobalNumNBPendingRecvs = 0;
    GlobalNBPendingRecvs = NULL;

    InitializeListHead( &GlobalWin31NBRespList );
    GlobalWin31NumNBResps = 0;

    UNLOCK_SVC_GLOBAL_DATA();
    srand( (unsigned)time(NULL));

    return( ERROR_SUCCESS );
}

DWORD
DllProcessDetachSvcloc(
    VOID
    )
/*++

Routine Description:

    This fundtion frees the global service location objects.

Arguments:

    NONE.

Return Value:

    Windows Error Code.

--*/
{
    LOCK_SVC_GLOBAL_DATA();

    if( GlobalSrvRegistered ) {
        ServerDeregisterAndStopListen();
    }

    if( GlobalSrvInfoObj != NULL ) {
        delete GlobalSrvInfoObj;
        GlobalSrvInfoObj = NULL;
    }

    if( GlobalSrvRespMsg != NULL ) {
        SvclocHeap->Free( GlobalSrvRespMsg );
        GlobalSrvRespMsg = NULL;
        GlobalSrvRespMsgLength = 0;
        GlobalSrvAllotedRespMsgLen = 0;
    }

    if( GlobalSrvRecvBuf != NULL ) {
        SvclocHeap->Free( GlobalSrvRecvBuf );
        GlobalSrvRecvBuf = NULL;
        GlobalSrvRecvBufLength = 0;
    }

    if( GlobalCliQueryMsg != NULL ) {
        SvclocHeap->Free( GlobalCliQueryMsg );
        GlobalCliQueryMsg = NULL;
        GlobalCliQueryMsgLen = 0;
    }

    InitializeListHead( &GlobalCliQueryRespList );

    while( !IsListEmpty( &GlobalCliQueryRespList ) ) {

        LPCLIENT_QUERY_RESPONSE QueryResponse;

        //
        // remove head entry and free it up.
        //

        QueryResponse = (LPCLIENT_QUERY_RESPONSE)
            RemoveHeadList( &GlobalCliQueryRespList );

        //
        // free response buffer.
        //

        SvclocHeap->Free( QueryResponse->ResponseBuffer );

        //
        // free this node.
        //

        SvclocHeap->Free( QueryResponse );
    }

    //
    // close client sockets.
    //

    DWORD i;

    for( i = 0; i <  GlobalCliSockets.fd_count; i++ ) {
        closesocket( GlobalCliSockets.fd_array[i] );
    }

    //
    // invalidate client handles.
    //

    memset( &GlobalCliSockets, 0x0, sizeof(GlobalCliSockets) );
    memset( &GlobalCliNBSockets, 0x0, sizeof(GlobalCliNBSockets) );
    GlobalCliIpxSocket = INVALID_SOCKET;


    //
    // stop client discovery thread.
    //

    if( GlobalCliDiscoverThreadHandle != NULL ) {

        //
        // Wait for the client discovery thread to stop, but don't wait
        // for longer than THREAD_TERMINATION_TIMEOUT msecs (60 secs)
        //

        DWORD WaitStatus =
            WaitForSingleObject(
                    GlobalCliDiscoverThreadHandle,
                    THREAD_TERMINATION_TIMEOUT );

        TcpsvcsDbgAssert( WaitStatus != WAIT_FAILED );

        if(  WaitStatus == WAIT_FAILED ) {
            TcpsvcsDbgPrint((DEBUG_ERRORS,
                "WaitForSingleObject call failed, %ld\n", GetLastError() ));
        }

        CloseHandle( GlobalCliDiscoverThreadHandle );
        GlobalCliDiscoverThreadHandle = NULL;
    }

    if( GlobalWinsockStarted ) {
        WSACleanup();
        GlobalWinsockStarted = FALSE;
    }

    TcpsvcsDbgAssert( GlobalNumNBPendingRecvs == 0)
    TcpsvcsDbgAssert( GlobalNBPendingRecvs == NULL );

    if( GlobalNBPendingRecvs != NULL ) {
        SvclocHeap->Free( GlobalNBPendingRecvs );
    }

    TcpsvcsDbgAssert( GlobalWin31NumNBResps == 0)
    TcpsvcsDbgAssert( IsListEmpty( &GlobalWin31NBRespList ) == TRUE );

    //
    // free response list.
    //

    while ( !IsListEmpty( &GlobalWin31NBRespList ) ) {

        PLIST_ENTRY Entry;

        Entry = RemoveHeadList( &GlobalWin31NBRespList );

        //
        // free response buffer if it is not used.
        //

        if( ((LPSVCLOC_NETBIOS_RESP_ENTRY)
                Entry)->Resp.ResponseBuffer != NULL ) {

            SvclocHeap->Free(
                ((LPSVCLOC_NETBIOS_RESP_ENTRY)
                    Entry)->Resp.ResponseBuffer );
        }

        SvclocHeap->Free( Entry );
    }

    if( SvclocHeap != NULL ) {
        delete SvclocHeap;
        SvclocHeap = NULL;
    }

    if( GlobalDiscoveryInProgressEvent != NULL ) {
        CloseHandle( GlobalDiscoveryInProgressEvent );
        GlobalDiscoveryInProgressEvent = NULL;
    }

    GlobalLastDiscoveryTime = 0;

    UNLOCK_SVC_GLOBAL_DATA();

    DeleteCriticalSection( &GlobalSvclocCritSect );

#if DBG

    //
    // Delete dbg crit sect.
    //

    DeleteCriticalSection( &GlobalDebugCritSect );

#endif // DBG


    return( ERROR_SUCCESS );
}

VOID
FreeServiceInfo(
    LPINET_SERVICE_INFO ServiceInfo
    )
/*++

Routine Description:

    This function frees the memory blocks consumed by the service info
    structure.

Arguments:

    ServiceInfo : pointer to a service info structure.

Return Value:

    None.

--*/
{
    TcpsvcsDbgAssert( ServiceInfo != NULL );

    if( ServiceInfo == NULL ) {
        return;
    }

    //
    // free all leaves of the tree first and then branches.
    //

    //
    // free service comment.
    //

    if( ServiceInfo->ServiceComment != NULL ) {
        SvclocHeap->Free(  ServiceInfo->ServiceComment );
    }

    if( ServiceInfo->Bindings.NumBindings ) {

        TcpsvcsDbgAssert( ServiceInfo->Bindings.BindingsInfo != NULL );

        if(  ServiceInfo->Bindings.BindingsInfo != NULL ) {
            DWORD i;

            for( i = 0; i < ServiceInfo->Bindings.NumBindings; i++ ) {

                if( ServiceInfo->Bindings.BindingsInfo[i].BindData != NULL ) {
                    SvclocHeap->Free( ServiceInfo->Bindings.BindingsInfo[i].BindData );
                }
            }

            SvclocHeap->Free(  ServiceInfo->Bindings.BindingsInfo );
        }
    }
    else {
        TcpsvcsDbgAssert( ServiceInfo->Bindings.BindingsInfo == NULL );
    }

    SvclocHeap->Free( ServiceInfo );

    return;
}

VOID
FreeServerInfo(
    LPINET_SERVER_INFO ServerInfo
    )
/*++

Routine Description:

    This function frees the memory blocks consumed by the server info
    structure.

Arguments:

    ServerInfo : pointer to a server info structure.

Return Value:

    None.

--*/
{
    DWORD i;

    if( ServerInfo != NULL ) {

        //
        // first free all service info.
        //

        if( ServerInfo->Services.NumServices > 0 ) {
            TcpsvcsDbgAssert( ServerInfo->Services.Services != NULL );
        }
        for ( i = 0; i < ServerInfo->Services.NumServices; i++) {

            FreeServiceInfo( ServerInfo->Services.Services[i] );
        }

        //
        // now free services pointer array.
        //

        if( ServerInfo->Services.Services != NULL ) {
            SvclocHeap->Free( ServerInfo->Services.Services );
        }

        //
        // free server address.
        //

        if( ServerInfo->ServerAddress.BindData != NULL ) {
            SvclocHeap->Free( ServerInfo->ServerAddress.BindData );
        }

        //
        // free server name.
        //

        if( ServerInfo->ServerName != NULL ) {
            SvclocHeap->Free( ServerInfo->ServerName );
        }

        //
        // now server info structure.
        //

        SvclocHeap->Free( ServerInfo );
    }

    return;
}

VOID
FreeServersList(
    LPINET_SERVERS_LIST ServersList
    )
/*++

Routine Description:

    This function frees the memory blocks consumed by the servers list
    structure.

Arguments:

    ServersList : pointer to a servers liststructure.

Return Value:

    None.

--*/
{
    if( ServersList != NULL ) {

        //
        // free server info structures.
        //

        if( ServersList->NumServers > 0 ) {
            TcpsvcsDbgAssert( ServersList->Servers != NULL );
        }

        DWORD i;

        for( i = 0; i < ServersList->NumServers; i++ ) {
            FreeServerInfo( ServersList->Servers[i] );
        }

        //
        // free servers info pointer array.
        //
        if( ServersList->Servers != NULL ) {
            SvclocHeap->Free( ServersList->Servers );
        }


        //
        // servers list structure.
        //

        SvclocHeap->Free( ServersList );
    }

    return;
}

BOOL
GetNetBiosLana(
    PLANA_ENUM pLanas
    )
/*++

Routine Description:

    This function enumurate all netbios lana on the system.

Arguments:

    pLanas - pointer to LANA_ENUM structure where enum is returned.

Return Value:

    TRUE - if successed.
    FALSE - otherwise.

--*/
{
    NCB NetBiosNCB;
    UCHAR NBErrorCode;

    memset( &NetBiosNCB, 0,  sizeof(NetBiosNCB) );
    NetBiosNCB.ncb_command = NCBENUM;
    NetBiosNCB.ncb_buffer = (PUCHAR)pLanas;
    NetBiosNCB.ncb_length = sizeof(LANA_ENUM);

    NBErrorCode = Netbios( &NetBiosNCB );

    if( (NBErrorCode == NRC_GOODRET) &&
        (NetBiosNCB.ncb_retcode == NRC_GOODRET) ) {

        return( TRUE );
    }

    TcpsvcsDbgPrint(( DEBUG_ERRORS, "NetBios() failed, %ld, %ld \n",
        NBErrorCode, NetBiosNCB.ncb_retcode ));

    return( FALSE );
}


BOOL
GetEnumNBLana(
    PLANA_ENUM pLanas
    )
/*++

Routine Description:

    This function enumurate all netbios lana on the system.

Arguments:

    pLanas - pointer to LANA_ENUM structure where enum is returned.

Return Value:

    TRUE - if successed.
    FALSE - otherwise.

--*/
{
    DWORD Error;
    INT ProtocolCount;
    PPROTOCOL_INFO ProtocolBuffer = NULL;
    DWORD ProtocolBufferSize = 0;

    //
    // init return value.
    //

    pLanas->length = 0;

    //
    // determine the enum buffer size required.
    //

    ProtocolCount = EnumProtocols(
                        NULL,
                        NULL,
                        &ProtocolBufferSize );

    if( ProtocolCount == SOCKET_ERROR ) {

        Error = WSAGetLastError();

        if( Error != ERROR_INSUFFICIENT_BUFFER ) {
            goto Cleanup;
        }
    }

    if( (ProtocolBufferSize == 0) || (ProtocolCount == 0) ) {

        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // allocate memory for the protocol buffer.
    //

    ProtocolBuffer =
        (PPROTOCOL_INFO)SvclocHeap->Alloc( ProtocolBufferSize );

    if( ProtocolBuffer == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // now enum protocols.
    //

    ProtocolCount = EnumProtocols(
                        NULL,
                        ProtocolBuffer,
                        &ProtocolBufferSize );

    if( ProtocolCount == SOCKET_ERROR ) {

        Error = WSAGetLastError();
        goto Cleanup;
    }

    TcpsvcsDbgAssert( ProtocolCount > 0 );

    //
    // now filter net bios protcols only and get the corresponding lana
    // values.
    //

    DWORD i;
    for ( i = 0; i < (DWORD)ProtocolCount; i++ ) {

        if( ProtocolBuffer[i].iAddressFamily == AF_NETBIOS ) {

            if( pLanas->length < MAX_LANA ) {

                UCHAR Lana;
                DWORD j;

                Lana = (UCHAR)((INT)ProtocolBuffer[i].iProtocol * (-1));

                //
                // if this is a new lana add to list.
                //

                for ( j = 0; j < pLanas->length ; j++ ) {
                    if( pLanas->lana[j] == Lana ) {
                        break;
                    }
                }

                if( j >= pLanas->length ) {
                    pLanas->lana[pLanas->length] = Lana;
                    pLanas->length++;
                }
            }
        }
    }

    Error = ERROR_SUCCESS;

Cleanup:

    if( ProtocolBuffer != NULL ) {
        SvclocHeap->Free( ProtocolBuffer );
    }

    if( Error != ERROR_SUCCESS ) {
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "GetNetBiosLana failed, %ld\n", Error ));
        return( FALSE );
    }

    return( TRUE );
}


BOOL
MakeNBSocketForLana(
    UCHAR Lana,
    PSOCKADDR  pSocketAddress,
    SOCKET *pNBSocket
    )
/*++

Routine Description:

    This function possibly creates a socket for the given lana and binds
    to the given socket address.

    ASSUME : global data crit sect is locked.

Arguments:

    Lana : lana number for the new sockets.

    pSocketAddress : pointer to a socket address to bind to.

    pNBSocket : pointer to a location where the new socket is returned.

Return Value:

    TRUE : if successfully created a socket and bound to the given nb
        addresse.
    FALSE : otherwise.

--*/
{
    DWORD Error;
    SOCKET NBSocket;
    DWORD Arg = 1;

    *pNBSocket = INVALID_SOCKET;

    //
    // create a socket for this lana.
    //

    NBSocket = socket( AF_NETBIOS, SOCK_DGRAM, Lana );

    if( NBSocket == INVALID_SOCKET ) {

        Error = WSAGetLastError();
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "socket() failed, %ld\n", Error ));

        //
        // something wrong with this lana, try rest.
        //

        return( FALSE );
    }

    //
    // make this socket non blocking.
    //

    if( (ioctlsocket( NBSocket, FIONBIO, &Arg )) == SOCKET_ERROR ) {

        Error = WSAGetLastError();
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "ioctlsocket() failed, %ld\n", Error ));

        //
        // something wrong with this lana, try rest.
        //

        closesocket( NBSocket );
        return( FALSE );
    }

    //
    // bind to this socket.
    //

    if( bind(
            NBSocket,
            pSocketAddress,
            sizeof(SOCKADDR_NB) ) == SOCKET_ERROR ) {

        Error = WSAGetLastError();
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "ioctlsocket() failed, %ld\n", Error ));

        //
        // something wrong with this lana, try rest.
        //

        closesocket( NBSocket );
        return( FALSE );
    }

    *pNBSocket = NBSocket;
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\svcapis.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    svcapis.cxx

Abstract:

    Contains code that implements the service location apis.

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include <svcloc.hxx>

DWORD
WINAPI
INetDiscoverServers(
    IN ULONGLONG ServicesMask,
    IN DWORD WaitTime,
    OUT LPINET_SERVERS_LIST *ServersList
    )
/*++

Routine Description:

    This API discovers all servers on the network that support and run the
    internet services  specified.

    This API is called by the client side code, such as the internet admin
    tool or wininet.dll.

Arguments:

    SevicesMask : A bit mask that specifies to discover servers with the
        these services running.

        ex: 0x0000000E, will discovers all servers running any of the
            following services :

                1. FTP_SERVICE
                2. GOPHER_SERVICE
                3. WEB_SERVICE

    DiscoverBindings : if this flag is set, this API talks to each of the
        discovered server and queries the services and bindings
        supported. If the flag is set to FALSE, it quickly returns with
        the list of servers only.

    WaitTime : Response wait time in secs. If this value is zero, it
        returns what ever discovered so far by the previous invocation of
        this APIs, otherwise it waits for the specified secs to collect
        responses from the servers.

    ServersList : Pointer to a location where the pointer to list of
        servers info is returned. The API allocates dynamic memory for
        this return data, the caller should free it by calling
        INetFreeDiscoverServerList after it has been used.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    BOOL SvcLockLocked = FALSE;

    //
    // WSAStartup().
    //

    LOCK_SVC_GLOBAL_DATA();
    SvcLockLocked = TRUE;

    if ( !GlobalWinsockStarted ) {

        Error = WSAStartup( WS_VERSION_REQUIRED, &GlobalWinsockStartupData );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        GlobalWinsockStarted = TRUE;
    }

    //
    // make a discovery message, if it is not made before.
    //

    Error = MakeClientQueryMesage( ServicesMask );

    if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
    }

    //
    // now check to see the discovery is in progress.
    //

    DWORD EventState;
    EventState = WaitForSingleObject( GlobalDiscoveryInProgressEvent, 0 );

    switch( EventState ) {
    case WAIT_OBJECT_0:
        break;

    case WAIT_TIMEOUT:

        //
        // discovery is in progress.
        //

        if( WaitTime == 0 ) {

            //
            // the caller does not want to wait, return available data.
            //

            goto ProcessResponse;

        }

        //
        // wait until the discovery is done or the specified delay is
        // over. Release global lock before wait, otherwise it will
        // get into a dead lock.
        //

        UNLOCK_SVC_GLOBAL_DATA();
        SvcLockLocked = FALSE;

        EventState = WaitForSingleObject( GlobalDiscoveryInProgressEvent, WaitTime * 1000 );

        switch( EventState ) {
        case WAIT_OBJECT_0:
        case WAIT_TIMEOUT:

            goto ProcessResponse;

        default:

            Error = GetLastError();
            goto Cleanup;
        }

    default:
        Error = GetLastError();
        goto Cleanup;
    }


    //
    // now check to see we have done the discovery recently. if so, don't
    // do discovery again, just return the available data.
    //

    time_t CurrentTime;

    CurrentTime = time( NULL );
    if( CurrentTime <
            GlobalLastDiscoveryTime + INET_DISCOVERY_RETRY_TIMEOUT ) {

        goto ProcessResponse;
    }

    //
    // reset GlobalDiscoveryInProgressEvent to signal that discovery is in
    // progress.
    //

    if( !ResetEvent( GlobalDiscoveryInProgressEvent ) ) {
        Error = GetLastError();
        goto Cleanup;
    }

    UNLOCK_SVC_GLOBAL_DATA();
    SvcLockLocked = FALSE;

    //
    // send discovery query message to all IPX servers.
    //

    Error = DiscoverIpxServers( NULL );

    //
    // now send a message to IP servers.
    //

    DWORD Error1;

    if( GlobalPlatformType == VER_PLATFORM_WIN32_NT ) {

        Error1 = DiscoverIpServers( NULL );
            // discover using 1C group name.
    }
    else {

        Error1 = DiscoverNetBiosServers( NULL );
            // discover using 1C group name.
    }

    TcpsvcsDbgAssert( Error1 == ERROR_SUCCESS );

    //
    // if we have not successfully sent query message in either of the
    // protocol, simply bail out.
    //

    if( (Error != ERROR_SUCCESS) && (Error1 != ERROR_SUCCESS) ) {
         goto Cleanup;
    }

    if( GlobalPlatformType == VER_PLATFORM_WIN32s ) {

        //
        // for windows 3.1 we can't create thread so we discover in user
        // thread.
        //

        WaitTime = RESPONSE_WAIT_TIMEOUT;
    }

    if( WaitTime == 0 ) {

        //
        // if the client is not willing to wait, setup a thread that
        // receives query response.
        //

        LOCK_SVC_GLOBAL_DATA();
        SvcLockLocked = TRUE;

        if( GlobalCliDiscoverThreadHandle == NULL ) {

            DWORD ThreadId;

            GlobalCliDiscoverThreadHandle =
                CreateThread(
                    NULL,       // default security
                    0,          // default stack size
                    (LPTHREAD_START_ROUTINE)ServerDiscoverThread,
                    NULL,          // no parameter
                    0,          // create flag, no suspend
                    &ThreadId );

            if( GlobalCliDiscoverThreadHandle  == NULL ) {
                Error = GetLastError();
                goto Cleanup;
            }

        }

        UNLOCK_SVC_GLOBAL_DATA();
        SvcLockLocked = FALSE;
    }
    else {

        //
        // Wait for WaitTime secs for query responses
        // to arrive.
        //

        Error = ReceiveResponses( (WORD)WaitTime, TRUE );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }

ProcessResponse:

    Error = ProcessDiscoveryResponses( ServicesMask, ServersList );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // done.
    //

    Error = ERROR_SUCCESS;

Cleanup:

    if( SvcLockLocked ) {
        UNLOCK_SVC_GLOBAL_DATA();
    }

    return( Error );
}

DWORD
WINAPI
INetGetServerInfo(
    IN LPSTR ServerName,
    IN ULONGLONG ServicesMask,
    IN DWORD WaitTime,
    OUT LPINET_SERVER_INFO *ServerInfo
    )
/*++

Routine Description:

    This API returns the server info and a list of services supported by
    the server and lists of bindings supported by each of the services.

Arguments:

    ServerName : name of the server whose info to be queried.

    ServicesMask : services to be queried

    WaitTime : Time in secs to wait.

    ServerInfo : pointer to a location where the pointer to the server
        info structure will be returned. The caller should  call
        INetFreeServerInfo to free up the list after use.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    BOOL SvcLockLocked = FALSE;
    CHAR NBServerName[NETBIOS_NAME_LENGTH + 1];

    //
    // WSAStartup().
    //

    LOCK_SVC_GLOBAL_DATA();
    SvcLockLocked = TRUE;

    if ( !GlobalWinsockStarted ) {

        Error = WSAStartup( WS_VERSION_REQUIRED, &GlobalWinsockStartupData );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        GlobalWinsockStarted = TRUE;
    }

    //
    // make a discovery message, if it is not made before.
    //

    Error = MakeClientQueryMesage( ServicesMask );

    if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
    }

    //
    // now check to see the discovery is in progress.
    //

    DWORD EventState;
    EventState = WaitForSingleObject( GlobalDiscoveryInProgressEvent, 0 );

    switch( EventState ) {
    case WAIT_OBJECT_0:
        break;

    case WAIT_TIMEOUT:

        //
        // discovery is in progress.
        //

        if( WaitTime == 0 ) {

            //
            // the caller does not want to wait, return available data.
            //

            goto GetServerResponse;

        }

        //
        // wait until the discovery is done or the specified delay is
        // over. Release global lock before wait, otherwise it will
        // get into a dead lock.
        //

        UNLOCK_SVC_GLOBAL_DATA();
        SvcLockLocked = FALSE;

        EventState = WaitForSingleObject( GlobalDiscoveryInProgressEvent, WaitTime * 1000 );

        switch( EventState ) {
        case WAIT_OBJECT_0:
        case WAIT_TIMEOUT:

            goto GetServerResponse;

        default:

            Error = GetLastError();
            goto Cleanup;
        }

    default:
        Error = GetLastError();
        goto Cleanup;
    }


    //
    // now check to see we have done the discovery recently. if so, don't
    // do discovery again, just return the available data.
    //

    time_t CurrentTime;

    CurrentTime = time( NULL );
    if( CurrentTime <
            GlobalLastDiscoveryTime + INET_DISCOVERY_RETRY_TIMEOUT ) {

        goto GetServerResponse;
    }

    //
    // reset GlobalDiscoveryInProgressEvent to signal that discovery is in
    // progress.
    //

    if( !ResetEvent( GlobalDiscoveryInProgressEvent ) ) {
        Error = GetLastError();
        goto Cleanup;
    }

    UNLOCK_SVC_GLOBAL_DATA();
    SvcLockLocked = FALSE;

    //
    // upper case the server name.
    //

    _strupr( ServerName );

    //
    // make unique server name.
    //

    MakeUniqueServerName(
        (LPBYTE)NBServerName,
        NETBIOS_NAME_LENGTH,
        ServerName );

    //
    // terminate the string.
    //

    NBServerName[ NETBIOS_NAME_LENGTH ] = '\0';

    //
    // send discovery query message to all IPX servers.
    //

    Error = DiscoverIpxServers( ServerName );

    //
    // now send a message to IP servers.
    //

    DWORD Error1;

    if( GlobalPlatformType == VER_PLATFORM_WIN32_NT ) {

        Error1 = DiscoverIpServers( NBServerName );
            // discover using specified server name.
    }
    else {

        Error1 = DiscoverNetBiosServers( NBServerName );
            // discover using specified server name.
    }

    TcpsvcsDbgAssert( Error1 == ERROR_SUCCESS );

    //
    // if we have successfully sent query message in either of the
    // protocol, simply bail out.
    //

    if( (Error != ERROR_SUCCESS) && (Error1 != ERROR_SUCCESS) ) {
         goto Cleanup;
    }

    if( WaitTime == 0 ) {

        //
        // if the client is not willing to wait, setup a thread that
        // receives query response.
        //

        LOCK_SVC_GLOBAL_DATA();
        SvcLockLocked = TRUE;

        if( GlobalCliDiscoverThreadHandle == NULL ) {

            DWORD ThreadId;

            GlobalCliDiscoverThreadHandle =
                CreateThread(
                    NULL,       // default security
                    0,          // default stack size
                    (LPTHREAD_START_ROUTINE)ServerDiscoverThread,
                    NULL,          // no parameter
                    0,          // create flag, no suspend
                    &ThreadId );

            if( GlobalCliDiscoverThreadHandle  == NULL ) {
                Error = GetLastError();
                goto Cleanup;
            }

        }

        UNLOCK_SVC_GLOBAL_DATA();
        SvcLockLocked = FALSE;
    }
    else {

        //
        // Wait for WaitTime secs for query responses
        // to arrive.
        //

        Error = ReceiveResponses( (WORD)WaitTime, FALSE );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }

GetServerResponse:

    Error = GetDiscoveredServerInfo( ServerName, ServicesMask, ServerInfo );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // done.
    //

    Error = ERROR_SUCCESS;

Cleanup:

    if( SvcLockLocked ) {
        UNLOCK_SVC_GLOBAL_DATA();
    }

    return( Error );
}

VOID
WINAPI
INetFreeDiscoverServersList(
    IN OUT LPINET_SERVERS_LIST *ServersList
    )
/*++

Routine Description:

    This API frees the memory chunks that were allotted for the servers
    list by the INetDiscoverServers call.

Arguments:

    ServersList : pointer to a location where the pointer to the server
        list to be freed is stored.

Return Value:

    NONE.

--*/
{
    FreeServersList( *ServersList );
    *ServersList = NULL;
    return;
}

VOID
WINAPI
INetFreeServerInfo(
    IN OUT LPINET_SERVER_INFO *ServerInfo
    )
/*++

Routine Description:

    This API frees the memory chunks that were allotted for the server
    info structure by the INetGetServerInfo call.

Arguments:

    ServerInfo : pointer to a location where the pointer to the server
        info structure to be freed is stored.

Return Value:

    NONE.

--*/
{
    FreeServerInfo( *ServerInfo );
    *ServerInfo = NULL;
    return;
}

DWORD
WINAPI
INetRegisterService(
    IN ULONGLONG ServiceMask,
    IN INET_SERVICE_STATE ServiceState,
    IN LPSTR ServiceComment,
    IN LPINET_BINDINGS Bindings
    )
/*++

Routine Description:

    This API registers an internet service.  The service writers should
    call this API just after successfully started the service and the
    service is ready to accept incoming RPC calls.  This API accepts an
    array of RPC binding strings that the service is listening on for the
    incoming RPC connections.  This list will be distributed to the
    clients that are discovering this service.

Arguments:

    ServiceMask : service mask, such as 0x00000001 (GATEWAY_SERVICE)

    ServiceState : State of the service, INetServiceRunning and
        INetServicePaused are valid states to pass.

    ServiceComment : Service comment specified by the admin.

    Bindings : list of bindings that are supported by the service. The
        bindings can be binding strings are those returned by the
        RpcBindingToStringBinding call or the sockaddrs.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    INET_SERVICE_INFO ServiceInfo;

    //
    // if the server object is not created, do so.
    //

    LOCK_SVC_GLOBAL_DATA();

    if( GlobalSrvInfoObj ==  NULL ) {

        DWORD ComputerNameLength =  MAX_COMPUTERNAME_LENGTH + 1;

        //
        // read computer name.
        //

        if( !GetComputerNameA(
                GlobalComputerName,
                &ComputerNameLength ) ) {

            Error = GetLastError();
            TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "GetComputerNameA failed, %ld.\n", Error ));
            goto Cleanup;
        }

        GlobalComputerName[ComputerNameLength] = '\0';

        GlobalSrvInfoObj = new EMBED_SERVER_INFO(
                                INET_MAJOR_VERSION, // major version number,
                                INET_MINOR_VERSION, // minor version number
                                GlobalComputerName );

        if( GlobalSrvInfoObj == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        Error = GlobalSrvInfoObj->GetStatus();

        if( Error != ERROR_SUCCESS ) {

            delete GlobalSrvInfoObj;
            GlobalSrvInfoObj = NULL;

            goto Cleanup;
        }
    }

    //
    // allocate memory for the receive buffer, if it is not alotted before.
    //

    if( GlobalSrvRecvBuf == NULL ) {

        GlobalSrvRecvBuf =
            (LPBYTE)SvclocHeap->Alloc( SVCLOC_SRV_RECV_BUFFER_SIZE );

        if( GlobalSrvRecvBuf == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        GlobalSrvRecvBufLength = SVCLOC_SRV_RECV_BUFFER_SIZE;
    }

    //
    // check to see the server registered its location and it is listening
    // to the client discovery. If not do so.
    //

    if( !GlobalSrvRegistered ) {
        Error = ServerRegisterAndListen();

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        GlobalSrvRegistered = TRUE;
    }

    //
    // make a new service info.
    //

    ServiceInfo.ServiceMask = ServiceMask;
    ServiceInfo.ServiceState = ServiceState;
    ServiceInfo.ServiceComment = ServiceComment;
    ServiceInfo.Bindings = *Bindings;

    //
    // add this new service to server list.
    //

    Error = GlobalSrvInfoObj->AddService( &ServiceInfo );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // make response buffer.
    //

    Error = MakeResponseBuffer();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    UNLOCK_SVC_GLOBAL_DATA();
    return( Error );
}

DWORD
WINAPI
INetDeregisterService(
    IN ULONGLONG ServiceMask
    )
/*++

Routine Description:

    This API de-registers an internet service from being announced to the
    discovering clients. The service writers should call this API just
    before shutting down the service.

Arguments:

    ServiceMask : service mask, such as 0x00000001 (GATEWAY_SERVICE)

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    INET_SERVICE_INFO ServiceInfo;

    //
    // remove the service if exists.
    //

    Error = GlobalSrvInfoObj->RemoveService( ServiceMask );

    if( Error != ERROR_SUCCESS ) {
        if( Error != ERROR_SERVICE_NOT_FOUND ) {
            return( Error );
        }

        Error = ERROR_SUCCESS;
    }

    //
    // add the service back to the list with service state set to
    // INetServiceStopped and no bindings.
    //

    ServiceInfo.ServiceMask = ServiceMask;
    ServiceInfo.ServiceState = INetServiceStopped;
    ServiceInfo.ServiceComment = NULL;
    ServiceInfo.Bindings.NumBindings = 0;
    ServiceInfo.Bindings.BindingsInfo = NULL;

    //
    // readd the service to server list.
    //

    Error = GlobalSrvInfoObj->AddService( &ServiceInfo );

    if( Error != ERROR_SUCCESS ) {

        DWORD LocalError;

        //
        // recreate response buffer.
        //

        LocalError = MakeResponseBuffer();
        TcpsvcsDbgAssert( LocalError == ERROR_SUCCESS );

        return( Error );
    }

    //
    // recreate response buffer.
    //

    Error = MakeResponseBuffer();

    return( Error );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\svcinfo.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    svcinfo.cxx

Abstract:

    contains class implementation of service location classes.

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include <svcloc.hxx>

DWORD
EMBED_SERVICE_INFO::ComputeServiceInfoSize(
    LPINET_SERVICE_INFO ServiceInfo
    )
/*++

Routine Description:

    This private member function computes the size of the embedded service
    info buffer.

Arguments:

    ServiceInfo : pointer to a service info structure.

Return Value:

    size of the embedded service info buffer.

--*/
{
    DWORD Size;
    DWORD NumBindings;
    LPINET_BIND_INFO BindingsInfo;
    DWORD i;
    DWORD ServiceCommentLen;

    if( ServiceInfo->ServiceComment != NULL) {
        ServiceCommentLen =
            ROUND_UP_COUNT(
                (strlen(ServiceInfo->ServiceComment) + 1) * sizeof(CHAR),
                            ALIGN_DWORD);
    }
    else {
        ServiceCommentLen = ROUND_UP_COUNT( 1, ALIGN_DWORD );
    }

    Size =
        sizeof(ULONGLONG) + // service mask
        sizeof(INET_SERVICE_STATE) + // service state
        ServiceCommentLen + // service comment
        sizeof(DWORD); // NumBindings

    NumBindings = ServiceInfo->Bindings.NumBindings;
    BindingsInfo = ServiceInfo->Bindings.BindingsInfo;

    if( NumBindings != 0 ) {

        TcpsvcsDbgAssert( BindingsInfo != NULL )

        for( i = 0; i < NumBindings; i++ ) {

            Size += sizeof(DWORD);

            if( BindingsInfo[i].Length != 0 ) {

                Size += ROUND_UP_COUNT(BindingsInfo[i].Length, ALIGN_DWORD);
                TcpsvcsDbgAssert( BindingsInfo[i].BindData != NULL );
            }
        }
    }

    return( Size );
}

VOID
EMBED_SERVICE_INFO::CopyServiceInfo(
    LPINET_SERVICE_INFO ServiceInfo
    )
/*++

Routine Description:

    This private member function copies service info to the embedded service info buffer.

Arguments:

    ServiceInfo : pointer to a service info structure.

Return Value:

    NONE.

--*/
{
    DWORD NumBindings;
    LPINET_BIND_INFO BindingsInfo;
    DWORD i;
    LPBYTE EndofBuffer;
    LPBYTE BufferPtr;

    NumBindings = ServiceInfo->Bindings.NumBindings;
    BindingsInfo = ServiceInfo->Bindings.BindingsInfo;

    BufferPtr = _ServiceInfoBuffer;
    EndofBuffer = _ServiceInfoBuffer + _ServiceInfoLength;

    //
    // copy header.
    //

    *(ULONGLONG UNALIGNED *)BufferPtr = ServiceInfo->ServiceMask;
    _ServiceMask = (ULONGLONG UNALIGNED *)BufferPtr;
    BufferPtr += sizeof(ULONGLONG);

    *(INET_SERVICE_STATE *)BufferPtr = ServiceInfo->ServiceState;
    _ServiceState = (INET_SERVICE_STATE *)BufferPtr;
    BufferPtr += sizeof(INET_SERVICE_STATE);

    //
    // copy service comment.
    //

    DWORD CommentLen;

    if( ServiceInfo->ServiceComment != NULL) {
        CommentLen =
            ROUND_UP_COUNT(
                (strlen(ServiceInfo->ServiceComment) + 1) * sizeof(CHAR),
                            ALIGN_DWORD);
    }
    else {
        CommentLen = ROUND_UP_COUNT( 1, ALIGN_DWORD );
    }

    TcpsvcsDbgAssert( (BufferPtr + CommentLen) < EndofBuffer );

    if( ServiceInfo->ServiceComment != NULL) {
        strcpy( (LPSTR)BufferPtr, ServiceInfo->ServiceComment );
    }
    else {
        *(LPSTR)BufferPtr = '\0';
    }

    BufferPtr += CommentLen;

    *(DWORD *)BufferPtr = ServiceInfo->Bindings.NumBindings;
    BufferPtr += sizeof(DWORD);

    //
    // copy bindings.
    //

    if( NumBindings != 0 ) {

        for( i = 0; i < NumBindings; i++ ) {

            TcpsvcsDbgAssert( BufferPtr < EndofBuffer );

            *(DWORD *)BufferPtr = BindingsInfo[i].Length;
            BufferPtr += sizeof(DWORD);

            if( BindingsInfo[i].Length != 0 ) {

                memcpy( BufferPtr, BindingsInfo[i].BindData, BindingsInfo[i].Length );
                BufferPtr += ROUND_UP_COUNT( BindingsInfo[i].Length, ALIGN_DWORD );
            }
        }
    }

    TcpsvcsDbgAssert( BufferPtr == EndofBuffer );

    return;
}

EMBED_SERVICE_INFO::EMBED_SERVICE_INFO(
    LPINET_SERVICE_INFO ServiceInfo
    )
/*++

Routine Description:

    This function constructs an embedded service info object.

    Note : embedded service info buffer layout :

    dword 1 : ServiceMask
              2 : ServiceState
              3 : NumBindings
              4 : Binding1 Length
              5 : Binding1
              6 :     ..
              7 :     ..
              8 :     ..
              9 :  Binding2 Length
              10 : Binding2
              11 : ..
              12 : ..

Arguments:

    ServiceInfo : pointer to a service info structure.

Return Value:

    NONE.

--*/
{
    DWORD Size;

    //
    // initialize the object elements.
    //

    INITIALIZE_CRITICAL_SECTION( &_ServiceObjCritSect );

    _ServiceInfoLength = 0;
    _ServiceInfoBuffer = NULL;
    _AllottedBufferSize = 0;

    _ServiceState = NULL;
    _ServiceComment = NULL;
    _ServiceMask = NULL;

    TcpsvcsDbgAssert( ServiceInfo != NULL );

    if( ServiceInfo == NULL ) {
        _Status = ERROR_INVALID_PARAMETER;
        return;
    }

    //
    // compute the embedded buffer length.
    //

    Size = ComputeServiceInfoSize( ServiceInfo );
    TcpsvcsDbgAssert( Size != 0 );

    //
    // allocate memory.
    //

    _ServiceInfoBuffer = (LPBYTE) SvclocHeap->Alloc( Size );

    if( _ServiceInfoBuffer == NULL ) {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        return;
    }

    _ServiceInfoLength = Size;
    _AllottedBufferSize = Size;

    //
    // copy service info.
    //

    CopyServiceInfo( ServiceInfo );

    _Status = ERROR_SUCCESS;
    return;
}


EMBED_SERVICE_INFO::EMBED_SERVICE_INFO(
    LPBYTE InfoBuffer,
    DWORD InfoBufferLength
    )
/*++

Routine Description:

    This function constructs an embedded service info object from a given
        embedded buffer.

Arguments:

    InfoBuffer : pointer to a embedded buffer.

    InfoBufferLength : length of the embedded buffer.

Return Value:

    NONE.

--*/
{
    TcpsvcsDbgAssert( InfoBuffer != NULL );
    TcpsvcsDbgAssert( InfoBufferLength != 0 );

    INITIALIZE_CRITICAL_SECTION( &_ServiceObjCritSect );
    _ServiceInfoLength = InfoBufferLength;
    _ServiceInfoBuffer = InfoBuffer;
    _AllottedBufferSize = 0;

    _ServiceMask = (ULONGLONG UNALIGNED *)InfoBuffer;
    _ServiceState = (INET_SERVICE_STATE *)(InfoBuffer + sizeof(ULONGLONG));
    _ServiceComment = (LPSTR)
        (InfoBuffer +
            sizeof(ULONGLONG) +
                sizeof(INET_SERVICE_STATE) );

    _Status = ERROR_SUCCESS;
}

EMBED_SERVICE_INFO::~EMBED_SERVICE_INFO(
    VOID
    )
/*++

Routine Description:

    This function destructs a embedded service info object.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    if( _AllottedBufferSize != 0 ) {

        TcpsvcsDbgAssert( _ServiceInfoBuffer != NULL );

        SvclocHeap->Free( _ServiceInfoBuffer );
    }

#if DBG

    _ServiceInfoLength = 0;
    _ServiceInfoBuffer = NULL;
    _AllottedBufferSize = 0;

    _ServiceState = NULL;
    _ServiceComment = NULL;
    _ServiceMask = NULL;

#endif // DBG

    DeleteCriticalSection( &_ServiceObjCritSect );
    _Status = ERROR_SUCCESS;
    return;
}

DWORD
EMBED_SERVICE_INFO::SetServiceInfo(
    LPINET_SERVICE_INFO ServiceInfo
    )
/*++

Routine Description:

    This member function sets the new service info to the embedded service
    info buffer.

Arguments:

    ServiceInfo : pointer to a service info structure.

Return Value:

    Windows error code.

--*/
{
    DWORD Size;

    TcpsvcsDbgAssert( ServiceInfo != NULL );

    LockServiceObj();

    if( ServiceInfo == NULL ) {
        UnlockServiceObj();
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // compute the size of the new service info buffer.
    //

    Size = ComputeServiceInfoSize( ServiceInfo ) ;

    TcpsvcsDbgAssert( Size != 0 );

    if( Size > _AllottedBufferSize ) {

        LPBYTE NewServiceInfoBuffer;

        //
        // free the old buffer and reallocate a new one.
        //

        NewServiceInfoBuffer = (LPBYTE) SvclocHeap->Alloc( Size );

        if( NewServiceInfoBuffer == NULL ) {
            UnlockServiceObj();
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        SvclocHeap->Free( _ServiceInfoBuffer );
        _ServiceInfoBuffer = NewServiceInfoBuffer;

        _AllottedBufferSize = Size;
    }

    _ServiceInfoLength = Size;

    //
    // now copy buffer.
    //

    CopyServiceInfo( ServiceInfo );

    UnlockServiceObj();
    return( ERROR_SUCCESS );
}

DWORD
EMBED_SERVICE_INFO::GetServiceInfo(
    LPINET_SERVICE_INFO *ServiceInfo
    )
/*++

Routine Description:

    This member function allocates memory for service info structure and
    copies service info from embedded service info buffer.

Arguments:

    ServiceInfo : pointer to a location where the server info structure
        pointer is returned. The caller should free the structure after
        use.

Return Value:

    Windows error code.

--*/
{
    DWORD Error;
    LPBYTE BufferPtr = _ServiceInfoBuffer;
    LPBYTE EndBufferPtr = _ServiceInfoBuffer + _ServiceInfoLength;
    DWORD NumBindings;
    DWORD i;

    LPINET_SERVICE_INFO LocalServiceInfo = NULL;

    LockServiceObj();

    //
    // allocate memory for the service info structure.
    //

    LocalServiceInfo = (LPINET_SERVICE_INFO)
        SvclocHeap->Alloc( sizeof( INET_SERVICE_INFO ) );

    if( LocalServiceInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // copy main structure first.
    //

    LocalServiceInfo->ServiceMask = *(ULONGLONG UNALIGNED *)BufferPtr;
    BufferPtr += sizeof(ULONGLONG);

    LocalServiceInfo->ServiceState = *(INET_SERVICE_STATE *)BufferPtr;
    BufferPtr += sizeof(INET_SERVICE_STATE);

    //
    // allocate memory for the service comment.
    //

    DWORD CommentLen;

    CommentLen =
        ROUND_UP_COUNT(
            (strlen((LPSTR)BufferPtr) + 1) * sizeof(CHAR),
                ALIGN_DWORD );

     LocalServiceInfo->ServiceComment = (LPSTR)
         SvclocHeap->Alloc( CommentLen );

     if( LocalServiceInfo->ServiceComment == NULL ) {
         Error = ERROR_NOT_ENOUGH_MEMORY;
         goto Cleanup;
     }

     //
     // copy service comment.
     //

     strcpy(
         LocalServiceInfo->ServiceComment,
         (LPSTR)BufferPtr );

    BufferPtr += CommentLen;

    NumBindings = *(DWORD *)BufferPtr;
    BufferPtr += sizeof(DWORD);

    LocalServiceInfo->Bindings.NumBindings = 0;
    LocalServiceInfo->Bindings.BindingsInfo =  NULL;

    if( NumBindings != 0 ) {

        LPINET_BIND_INFO Bindings;

        //
        // allocate memory for bindingsinfo array.
        //

        Bindings = (LPINET_BIND_INFO)
            SvclocHeap->Alloc( sizeof( INET_BIND_INFO )  * NumBindings );

        if( Bindings == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        LocalServiceInfo->Bindings.BindingsInfo = Bindings;

        for( i = 0; i < NumBindings; i++ ) {

            LPBYTE BindData;

            TcpsvcsDbgAssert( BufferPtr < EndBufferPtr );

            Bindings[i].Length = *(DWORD *)BufferPtr;
            BufferPtr += sizeof(DWORD);

            //
            // allocate memory for the bind data.
            //

            BindData = (LPBYTE)SvclocHeap->Alloc( Bindings[i].Length );

            if( BindData == NULL ) {

                //
                // free the bindings structure memory only if NumBindings
                // is zero, otherwise it will be freed later on along
                // with some other memory blocks.
                //

                if( LocalServiceInfo->Bindings.NumBindings == 0 ) {

                    if( LocalServiceInfo->Bindings.BindingsInfo != NULL ) {
                        SvclocHeap->Free( LocalServiceInfo->Bindings.BindingsInfo );
                        LocalServiceInfo->Bindings.BindingsInfo = NULL;
                    }
                }

                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            //
            // copy bind data.
            //

            memcpy( BindData, BufferPtr, Bindings[i].Length );
            BufferPtr += ROUND_UP_COUNT( Bindings[i].Length, ALIGN_DWORD );

            //
            // successfully copied one more bind data.
            //

            Bindings[i].BindData = BindData;
            LocalServiceInfo->Bindings.NumBindings++;
        }
    }

    //
    // all done.
    //

    *ServiceInfo = LocalServiceInfo;
    LocalServiceInfo = NULL;
    Error = ERROR_SUCCESS;

Cleanup:

    if( LocalServiceInfo != NULL ) {
        FreeServiceInfo( LocalServiceInfo );
    }

    UnlockServiceObj();
    return( Error );
}

/*---------------------------------------------------------------------*/

BOOL
EMBED_SERVER_INFO::IsServiceEntryExist(
    ULONGLONG ServiceMask,
    LPEMBED_SERVICE_ENTRY *ServiceEntry
    )
/*++

Routine Description:

    This private member function looks up a service entry in the service
    list.

Arguments:

    ServiceMask : mask of the service to look at.

    ServiceEntry : pointer to location where the service entry pointer is
        returned if found.

Return Value:

    TRUE : if the service entry is found in the service list.
    FALSE : otherwise.

--*/
{

    PLIST_ENTRY SList;
    LPEMBED_SERVICE_ENTRY SEntry;
    ULONGLONG SMask;

    //
    // Scan service list.
    //

    for( SList = _ServicesList.Flink; SList != &_ServicesList; SList = SList->Flink ) {

        SEntry = (LPEMBED_SERVICE_ENTRY)SList;

        //
        // Get Service Mask.
        //

        SMask =  (SEntry->ServiceObject)->GetServiceMask();

        if( SMask == ServiceMask ) {

            //
            // found the service entry.
            //

            *ServiceEntry = SEntry;
            return( TRUE );
        }
    }

    return( FALSE );
}

EMBED_SERVER_INFO::EMBED_SERVER_INFO(
    WORD MajorVersion,
    WORD MinorVersion,
    LPSTR ServerName
    )
/*++

Routine Description:

    This member function constructs a server info object.

Arguments:

    MajorVersion :  major version number of the server software.

    MinorVersion :  minor version number of the server software.

    ServerName : computer name of the server.

Return Value:

    None.

--*/
{
    DWORD Size;
    LPBYTE BufferPtr;
    DWORD ServerNameLen;

    //
    // init object fields.
    //

    INITIALIZE_CRITICAL_SECTION( &_ServerObjCritSect );

    _ServerInfoLength = 0;
    _ServerInfoBuffer = NULL;
    _AllottedBufferSize = 0;

    _VersionNum = NULL;
    _ServerLoad = NULL;
    _ServicesMask = NULL;
    _ServerName = NULL;
    _NumServices = NULL;

    InitializeListHead( &_ServicesList );

    //
    // compute Server Info Size.
    //

    ServerNameLen = ROUND_UP_COUNT(
                        (strlen(ServerName) + 1) * sizeof(CHAR),
                            ALIGN_DWORD);

    Size = sizeof(INET_VERSION_NUM) +   // for version number
                    ServerNameLen +     // for server name
                    sizeof(DWORD) +     // for load factor
                    sizeof(ULONGLONG) +  // for services mask.
                    sizeof(DWORD);      // for number of services.

    _ServerInfoBuffer = (LPBYTE)SvclocHeap->Alloc( Size );

    if( _ServerInfoBuffer == NULL ) {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        return;
    }

    _ServerInfoLength = Size;
    _AllottedBufferSize = Size;

    BufferPtr = _ServerInfoBuffer;

    ((INET_VERSION_NUM *)BufferPtr)->Version.Major = MajorVersion;
    ((INET_VERSION_NUM *)BufferPtr)->Version.Minor = MinorVersion;

    _VersionNum = (INET_VERSION_NUM *)BufferPtr;
    BufferPtr += sizeof(INET_VERSION_NUM);

   strcpy( (LPSTR)BufferPtr, ServerName );
    _ServerName = (LPSTR)BufferPtr;
    BufferPtr += ServerNameLen;

    *(DWORD *)BufferPtr  = 0; // load factor
    _ServerLoad = (DWORD *)BufferPtr;
    BufferPtr += sizeof(DWORD);

    *(ULONGLONG UNALIGNED *)BufferPtr  = 0; // services mask;
    _ServicesMask = (ULONGLONG UNALIGNED *)BufferPtr;
    BufferPtr += sizeof(ULONGLONG);

    *(DWORD *)BufferPtr  = 0; // num services.
    _NumServices = (DWORD *)BufferPtr;
    BufferPtr += sizeof(DWORD);

    TcpsvcsDbgAssert( BufferPtr == (_ServerInfoBuffer + _ServerInfoLength) );

    _Status = ERROR_SUCCESS;
    return;
}

EMBED_SERVER_INFO::EMBED_SERVER_INFO(
    LPBYTE ResponseBuffer,
    DWORD ResponseBufferLength
    )
/*++

Routine Description:

    This member function constructs a server info object from embedded
    server info buffer (received from the server).

Arguments:

    ResponseBuffer : pointer to the embedded server info buffer.

    ResponseBufferLength : length of the above buffer.

Return Value:

--*/
{
    LPBYTE BufferPtr;
    DWORD ServerNameLen;
    DWORD nServices;
    DWORD i;

    INITIALIZE_CRITICAL_SECTION( &_ServerObjCritSect );

    //
    // set object fields.
    //

    BufferPtr = _ServerInfoBuffer = ResponseBuffer;

    _VersionNum = (INET_VERSION_NUM *)BufferPtr;
    BufferPtr += sizeof(INET_VERSION_NUM); // skip version number.

    _ServerName = (LPSTR)BufferPtr;
    ServerNameLen =
        ROUND_UP_COUNT(
                (strlen((LPSTR)BufferPtr) + 1) * sizeof(CHAR),
                ALIGN_DWORD);

    BufferPtr += ServerNameLen;

    _ServerLoad = (DWORD *)BufferPtr;
    BufferPtr += sizeof(DWORD);

    _ServicesMask = (ULONGLONG UNALIGNED *)BufferPtr;
    BufferPtr += sizeof(ULONGLONG);

    _NumServices = (DWORD *)BufferPtr;
    BufferPtr += sizeof(DWORD);

    _ServerInfoLength = DIFF(BufferPtr - _ServerInfoBuffer);
    _AllottedBufferSize = 0;

    nServices = *_NumServices;

    InitializeListHead( &_ServicesList );

    //
    // now make service objects.
    //

    for( i = 0; i < nServices; i++) {

        DWORD ServiceBufferLength;
        LPSERVICE_OBJECT ServiceObject;
        DWORD ObjStatus;
        LPEMBED_SERVICE_ENTRY ServiceEntry;

        ServiceBufferLength = *(DWORD * )BufferPtr;
        BufferPtr += sizeof(DWORD);

        //
        // make another service object.
        //

        ServiceObject =
            new EMBED_SERVICE_INFO( BufferPtr, ServiceBufferLength );

        if( ServiceObject == NULL ) {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
            return;
        }

        ObjStatus = ServiceObject->GetStatus();

        if( ObjStatus != ERROR_SUCCESS ) {
            _Status = ObjStatus;
            delete ServiceObject;
            return;
        }

        //
        // allocate space for a new service entry.
        //

        ServiceEntry = (LPEMBED_SERVICE_ENTRY)
            SvclocHeap->Alloc( sizeof(EMBED_SERVICE_ENTRY) );

        if( ServiceEntry == NULL ) {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
            delete ServiceObject;
            return;
        }

        ServiceEntry->ServiceObject = ServiceObject;

        //
        // add this new entry to the list.
        //

        InsertTailList( &_ServicesList, &ServiceEntry->NextEntry );

        //
        // point to the next service record.
        //

        BufferPtr += ServiceBufferLength;
    }

    _Status = ERROR_SUCCESS;
    return;
}

EMBED_SERVER_INFO::~EMBED_SERVER_INFO(
    VOID
    )
/*++

Routine Description:

    This member function destructs a server info object.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    //
    // delete all service objects first.
    //

    while( !IsListEmpty( &_ServicesList ) ) {

        LPEMBED_SERVICE_ENTRY ServiceEntry;

        //
        // remove an entry from the tail of the list.
        //

        ServiceEntry =
            (LPEMBED_SERVICE_ENTRY)RemoveTailList( &_ServicesList );

        //
        // delete service object.
        //

        delete ServiceEntry->ServiceObject;

        //
        // free the entry memory.
        //

        SvclocHeap->Free( ServiceEntry );
    }

    //
    // free up server info buffer.
    //

    if( _AllottedBufferSize != 0 ) {

        TcpsvcsDbgAssert( _ServerInfoBuffer != NULL );
        SvclocHeap->Free( _ServerInfoBuffer );
    }


#if DBG

    _ServerInfoLength = 0;
    _ServerInfoBuffer = NULL;
    _AllottedBufferSize = 0;

    _VersionNum = NULL;
    _ServerLoad = NULL;
    _ServicesMask = NULL;
    _ServerName = NULL;

    _NumServices = NULL;

#endif // DBG

    DeleteCriticalSection( &_ServerObjCritSect );

    _Status = ERROR_SUCCESS;
    return;
}

DWORD
EMBED_SERVER_INFO::AddService (
    LPINET_SERVICE_INFO ServiceInfo
    )
/*++

Routine Description:

    This member function adds or replaces a service info object to the
    server info object.

Arguments:

    ServiceInfo : pointer to the service info structure.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPSERVICE_OBJECT ServiceObj;
    LPEMBED_SERVICE_ENTRY ServiceEntry = NULL;
    ULONGLONG SMask;

    LockServerObj();

    SMask = ServiceInfo->ServiceMask;

    if( IsServiceEntryExist( SMask, &ServiceEntry ) ) {

        //
        // this service already exists, so just update the content.
        //

        TcpsvcsDbgAssert( ServiceEntry != NULL );
        TcpsvcsDbgAssert( (*_ServicesMask & SMask) == SMask );

        //
        // set service info.
        //

        Error = (ServiceEntry->ServiceObject)->SetServiceInfo( ServiceInfo );

        UnlockServerObj();
        return( Error );
    }

    //
    // new entry.
    //

    TcpsvcsDbgAssert( (*_ServicesMask & SMask)  == 0 );

    //
    // make a service object.
    //

    ServiceObj = new EMBED_SERVICE_INFO( ServiceInfo );

    if( ServiceObj == NULL ) {
        UnlockServerObj();
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    Error = ServiceObj->GetStatus();

    if( Error != ERROR_SUCCESS ) {
        delete ServiceObj;
        UnlockServerObj();
        return( Error );
    }

    //
    // allocate memory for the new service entry.
    //

    ServiceEntry = (LPEMBED_SERVICE_ENTRY)
        SvclocHeap->Alloc( sizeof(EMBED_SERVICE_ENTRY) );

    if( ServiceEntry == NULL ) {
        delete ServiceObj;
        UnlockServerObj();
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    ServiceEntry->ServiceObject = ServiceObj;

    //
    // Adjust parameters.
    //

    *_ServicesMask |= SMask;
    (*_NumServices)++;

    //
    // add this entry to the service list.
    //

    InsertTailList(&_ServicesList, &ServiceEntry->NextEntry);

    UnlockServerObj();
    return( ERROR_SUCCESS );
}

DWORD
EMBED_SERVER_INFO::RemoveService(
    ULONGLONG SMask
    )
/*++

Routine Description:

    This member function removes a service info object from the server
    info object.

Arguments:

    SMask : Service mask of the service to be removed from the
        server object.

Return Value:

    Windows Error Code.

--*/
{

    LPEMBED_SERVICE_ENTRY ServiceEntry = NULL;

    LockServerObj();

    //
    // check the service is in the service list.
    //

    if( IsServiceEntryExist( SMask, &ServiceEntry )  == FALSE ) {

        TcpsvcsDbgAssert( (*_ServicesMask &  SMask) == 0);
        UnlockServerObj();
        return( ERROR_SERVICE_NOT_FOUND );
    }

    TcpsvcsDbgAssert( ServiceEntry != NULL );
    TcpsvcsDbgAssert( *_ServicesMask & SMask );

    //
    // adjust parameters.
    //

    *_ServicesMask &= ~SMask;
    (*_NumServices)--;

    //
    // remove entry from list.
    //

    RemoveEntryList( &ServiceEntry->NextEntry );

    //
    // delete service object.
    //

    delete ServiceEntry->ServiceObject;

    //
    // free entry memory.
    //

    SvclocHeap->Free( ServiceEntry );

    UnlockServerObj();
    return( ERROR_SUCCESS );
}

DWORD
EMBED_SERVER_INFO::SetServiceState(
    ULONGLONG SMask,
    INET_SERVICE_STATE ServiceState
    )
/*++

Routine Description:

    This member function sets the state of a service.

Arguments:

    SMask : Service Mask of the service whose state to be set.

    ServiceState : New state of the service.

Return Value:

    None.

--*/
{
    LPEMBED_SERVICE_ENTRY ServiceEntry = NULL;

    LockServerObj();
    //
    // check the service is in the service list.
    //

    if( IsServiceEntryExist( SMask, &ServiceEntry )  == FALSE ) {

        TcpsvcsDbgAssert( (*_ServicesMask &  SMask) == 0);
        UnlockServerObj();
        return( ERROR_SERVICE_NOT_FOUND );
    }

    TcpsvcsDbgAssert( ServiceEntry != NULL );
    TcpsvcsDbgAssert( *_ServicesMask & SMask );

    //
    // set service state.
    //

    (ServiceEntry->ServiceObject)->SetServiceState( ServiceState );

    UnlockServerObj();
    return( ERROR_SUCCESS );
}

DWORD
EMBED_SERVER_INFO::ComputeResponseLength(
    VOID
    )
/*++

Routine Description:

    This member function computes the length of the response message
    (containing server info and all services info in the embedded
    formatted)  sent to a client.

Arguments:

    None.

Return Value:

    Length of the response.

--*/
{
    DWORD Size = 0;
    PLIST_ENTRY SList;
    LPEMBED_SERVICE_ENTRY SEntry;

    LockServerObj();
    //
    // Compute response length of  the services.
    //

    for( SList = _ServicesList.Flink; SList != &_ServicesList; SList = SList->Flink ) {

        SEntry = (LPEMBED_SERVICE_ENTRY)SList;

        //
        // Get Service info buffer size.
        //

        Size +=  (SEntry->ServiceObject)->GetServiceInfoLength();
        Size += sizeof(DWORD); // for service length info itself.
    }

    //
    // server info size.
    //

    Size += _ServerInfoLength;

    UnlockServerObj();
    return( Size );
}

DWORD
EMBED_SERVER_INFO::MakeResponseMessage(
    LPBYTE MessageBuffer,
    DWORD BufferLength
    )
/*++

Routine Description:

    This member function builds a response message sent to a client.

Arguments:

    MessageBuffer : pointer to a buffer where the response message is
        built.

    BufferLength : length of the message.

Return Value:

    Windows Error Code.

--*/
{
    LPBYTE BufferPtr = MessageBuffer;
    LPBYTE EndBufferPtr = MessageBuffer + BufferLength;
    LPEMBED_SERVICE_ENTRY SEntry;
    ULONGLONG SMask;
    DWORD Error;
    DWORD RequiredBufferLength;
    PLIST_ENTRY SList;

    LockServerObj();

    RequiredBufferLength = ComputeResponseLength();

    if( RequiredBufferLength > BufferLength ) {
        UnlockServerObj();
        return( ERROR_INSUFFICIENT_BUFFER );
    }

    //
    // copy server info first.
    //

    memcpy( BufferPtr, _ServerInfoBuffer, _ServerInfoLength );
    BufferPtr += _ServerInfoLength;

    //
    // copy all service info buffers.
    //

    for( SList = _ServicesList.Flink; SList != &_ServicesList; SList = SList->Flink ) {

        DWORD *_ServiceInfoLength;

        TcpsvcsDbgAssert( BufferPtr < EndBufferPtr );

        _ServiceInfoLength = (DWORD *)BufferPtr;
        BufferPtr += sizeof(DWORD);

        SEntry = (LPEMBED_SERVICE_ENTRY)SList;

        //
        // Get Service Mask.
        //

        Error = (SEntry->ServiceObject)->GetServiceInfoBuffer(
                        BufferPtr,
                        DIFF(EndBufferPtr - BufferPtr),
                        _ServiceInfoLength );

        if( Error != ERROR_SUCCESS ) {
            UnlockServerObj();
            return( Error );
        }

        BufferPtr += *_ServiceInfoLength;
    }

    UnlockServerObj();
    return( ERROR_SUCCESS );
}

DWORD
EMBED_SERVER_INFO::GetServerInfo(
    LPINET_SERVER_INFO *ServerInfo
    )
/*++

Routine Description:

    This member function retrieves the server info structure.

Arguments:

    ServerInfo : pointer to a location where the pointer to the server
        info structure is returned. The member function allots memory for
        the structure, the caller should free the mmeory after use.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPINET_SERVER_INFO LocalServerInfo = NULL;
    LPINET_SERVICE_INFO *ServicesInfoArray = NULL;
    PLIST_ENTRY SList;
    DWORD i;

    LockServerObj();

    //
    // allocate memory for the server info structure.
    //

    LocalServerInfo = (LPINET_SERVER_INFO)SvclocHeap->Alloc(sizeof(INET_SERVER_INFO) );

    if( LocalServerInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // initialize all fields.
    //

    memset( LocalServerInfo, 0x0, sizeof(INET_SERVER_INFO) );

    //
    // fill in the fields.
    //

    //
    // server info field is fill by some one else !!
    // leave it empty for now.
    //

    LocalServerInfo->ServerAddress.Length = 0;
    LocalServerInfo->ServerAddress.BindData = NULL;

    LocalServerInfo->VersionNum = *_VersionNum;

    //
    // alloc memory for the server name.
    //

    LocalServerInfo->ServerName = (LPSTR)
        SvclocHeap->Alloc( (strlen(_ServerName) + 1) * sizeof(CHAR) );

    if( LocalServerInfo->ServerName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    strcpy( LocalServerInfo->ServerName, _ServerName );
    LocalServerInfo->LoadFactor = *_ServerLoad;
    LocalServerInfo->ServicesMask = *_ServicesMask;
    LocalServerInfo->Services.NumServices = 0;
    LocalServerInfo->Services.Services = NULL;

    //
    // allocate memory for the service struct. array pointers.
    //

    ServicesInfoArray = (LPINET_SERVICE_INFO *)
        SvclocHeap->Alloc( (*_NumServices) * sizeof(LPINET_SERVICE_INFO ) );

    if(ServicesInfoArray == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    memset( ServicesInfoArray, 0x0, (*_NumServices) * sizeof(LPINET_SERVICE_INFO) );

    //
    // now get services info.
    //

    for ( SList = _ServicesList.Flink, i = 0;
            (SList != &_ServicesList) && (i < *_NumServices);
                SList = SList->Flink, i++ ) {

        LPSERVICE_OBJECT SObj;

        SObj = ((LPEMBED_SERVICE_ENTRY)SList)->ServiceObject;

        Error = SObj->GetServiceInfo( &ServicesInfoArray[i] );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }

    TcpsvcsDbgAssert( i <= (*_NumServices) );

    LocalServerInfo->Services.NumServices = i;
    LocalServerInfo->Services.Services = ServicesInfoArray;
    ServicesInfoArray = NULL;

    *ServerInfo = LocalServerInfo;
    LocalServerInfo = NULL;

    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // Cleanup allotted data.
        //

        if( ServicesInfoArray != NULL ) {

            for ( i = 0; i < (*_NumServices) && ServicesInfoArray[i] != NULL; i++) {
                FreeServiceInfo( ServicesInfoArray[i] );
            }

            SvclocHeap->Free( ServicesInfoArray );
        }

        if( LocalServerInfo != NULL ) {

            if( LocalServerInfo->ServerName != NULL ) {

                SvclocHeap->Free( LocalServerInfo->ServerName );
            }

            SvclocHeap->Free( LocalServerInfo );
        }
    }

    UnlockServerObj();
    return( Error );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\svcsrv.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    svcsrv.cxx

Abstract:

    Contains server side code of service location protocol.

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include <svcloc.hxx>

DWORD
MakeResponseBuffer(
    VOID
    )
/*++

Routine Description:

    This function sets up the response buffer sent to the client.

Arguments:

    NONE.

Return Value:

    Windows Error Code.

--*/
{
    DWORD ReqMsgLength;

    //
    // compute space required for all services info and server info.
    //

    ReqMsgLength = GlobalSrvInfoObj->ComputeResponseLength();

    //
    // add space for the head and tail.
    //

    ReqMsgLength += (
        sizeof(DWORD) + // for message length.
        sizeof(DWORD) + // for check sum
        sizeof(DWORD)); // for termination dword.

    if( ReqMsgLength <= GlobalSrvAllotedRespMsgLen ) {

        //
        // wipe of previous response buffer content.
        //

        TcpsvcsDbgAssert(
            GlobalSrvRespMsgLength <=
                GlobalSrvAllotedRespMsgLen );

        memset( GlobalSrvRespMsg, 0x0, GlobalSrvRespMsgLength );
        GlobalSrvRespMsgLength = ReqMsgLength;
    }
    else {

        LPBYTE NewBuffer;
        DWORD NewBufferLength;

        NewBufferLength = (ReqMsgLength & ~(0x400 - 1)) + 0x400;
            // ceil in KBytes

        NewBuffer = (LPBYTE)SvclocHeap->Alloc( NewBufferLength );

        if( NewBuffer == NULL ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        //
        // free old buffer.
        //

        SvclocHeap->Free( GlobalSrvRespMsg );
        GlobalSrvRespMsg = NewBuffer;
        GlobalSrvAllotedRespMsgLen = NewBufferLength;
        GlobalSrvRespMsgLength =  ReqMsgLength;
    }

    //
    // copy server and services info.
    //

    DWORD Error;

    Error = GlobalSrvInfoObj->MakeResponseMessage(
                    GlobalSrvRespMsg + sizeof(DWORD),
                    GlobalSrvRespMsgLength - 3 * sizeof(DWORD) );

    if( Error != ERROR_SUCCESS ) {
        GlobalSrvRespMsgLength = 0;
        return( Error );
    }

    *(DWORD *)GlobalSrvRespMsg = GlobalSrvRespMsgLength;

    LPBYTE EndMessageBuffer;

    EndMessageBuffer = GlobalSrvRespMsg + GlobalSrvRespMsgLength;

    //
    // fill in check sum.
    //

    *(DWORD *)(EndMessageBuffer - 2 * sizeof(DWORD) ) =
        ComputeCheckSum(
            GlobalSrvRespMsg + sizeof(DWORD),
            GlobalSrvRespMsgLength - 3 * sizeof(DWORD) );

    *(DWORD *)(EndMessageBuffer - sizeof(DWORD) ) = 0xFFFFFFFF;

    //
    // DONE.
    //

    return( ERROR_SUCCESS );
}

DWORD
ServerRegisterAndListen(
    VOID
    )
/*++

Routine Description:

    This function call registers the server and creates a thread to listen
    to the discovery requests. Also it initializes the winsock data structures.

    ASSUME : global data crit sect is locked.

Arguments:

    none.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    SOCKET IpxSocket;
    int SocketAddressLength;

    SOCKADDR_IPX IpxSocketAddress;
    SERVICE_INFOA ServiceInfo;
    SERVICE_ADDRESSES ServiceAddresses;
    PSERVICE_ADDRESS ServiceAddr;
    DWORD StatusSetService;

    CHAR SapSvcName[SAP_SERVICE_NAME_LEN + 1];

    //
    // init winsock.
    //

    if ( !GlobalWinsockStarted ) {

        Error = WSAStartup( WS_VERSION_REQUIRED, &GlobalWinsockStartupData );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        GlobalWinsockStarted = TRUE;
    }

    //
    // cleanup global socket array.
    //

    memset( &GlobalSrvSockets, 0x0, sizeof(GlobalSrvSockets) );

    //
    // make IPX local socket address.
    //

    IpxSocket = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX);

    if( IpxSocket == INVALID_SOCKET ) {
        Error = WSAGetLastError();
        goto NBRegister;
    }

    //
    // make this socket non blocking.
    //

    DWORD Arg;
    Arg = 1;
    if( (ioctlsocket( IpxSocket, FIONBIO, &Arg )) == SOCKET_ERROR ) {

        Error = WSAGetLastError();
        closesocket( IpxSocket );
        goto NBRegister;
    }

    //
    // get socket address.
    //

    memset( &IpxSocketAddress, 0x0, sizeof(SOCKADDR_IPX) );

    IpxSocketAddress.sa_family = PF_IPX;

    if( bind(
            IpxSocket,
            (PSOCKADDR)&IpxSocketAddress,
            sizeof(SOCKADDR_IPX) ) == SOCKET_ERROR ) {

        Error = WSAGetLastError();
        closesocket( IpxSocket );
        goto NBRegister;
    }

    //
    // now query address.
    //

    SocketAddressLength = sizeof( IpxSocketAddress );

    if( getsockname(
            IpxSocket,
            (PSOCKADDR)&IpxSocketAddress,
            &SocketAddressLength ) == SOCKET_ERROR ) {

        Error = WSAGetLastError();
        closesocket( IpxSocket );
        goto NBRegister;
    }

    Error = MakeSapServiceName( SapSvcName, sizeof(SapSvcName) );

    if( Error != ERROR_SUCCESS ) {
        closesocket( IpxSocket );
        goto NBRegister;
    }

    //
    // prepare service address.
    //

    ServiceAddresses.dwAddressCount = 1;
    ServiceAddr = &ServiceAddresses.Addresses[0];

    ServiceAddr->dwAddressType = PF_IPX;
    ServiceAddr->dwAddressFlags = 0;
    ServiceAddr->dwAddressLength = SocketAddressLength;
    ServiceAddr->dwPrincipalLength = 0;
    ServiceAddr->lpAddress = (LPBYTE)&IpxSocketAddress;
    ServiceAddr->lpPrincipal = NULL;

    //
    // prepare service info.
    //

    ServiceInfo.lpServiceType = &GlobalSapGuid;
    ServiceInfo.lpServiceName = SapSvcName;
    ServiceInfo.lpComment = NULL ;
    ServiceInfo.lpLocale = 0;
    ServiceInfo.dwDisplayHint = 0;
    ServiceInfo.dwVersion =
        MAKEWORD( INET_MAJOR_VERSION, INET_MINOR_VERSION ) ;
    ServiceInfo.dwTime = 0; // ??
    ServiceInfo.lpMachineName = GlobalComputerName;
    ServiceInfo.lpServiceAddress = &ServiceAddresses;
    ServiceInfo.ServiceSpecificInfo.pBlobData = 0;
    ServiceInfo.ServiceSpecificInfo.cbSize = 0;

    //
    // register service info.
    //

    if( SetServiceA(
            NS_SAP,
            SERVICE_REGISTER,
            0,
            &ServiceInfo,
            0,
            &StatusSetService ) == SOCKET_ERROR ) {

        Error = WSAGetLastError();
        closesocket( IpxSocket );
        goto NBRegister;
    }

    if( StatusSetService != ERROR_SUCCESS ) {
        Error = StatusSetService;
        closesocket( IpxSocket );
        goto NBRegister;
    }

    GlobalRNRRegistered = TRUE;

    //
    // remember this Ipx socket in our global socket array.
    //

    FD_SET( IpxSocket, &GlobalSrvSockets );
    Error = ERROR_SUCCESS;

NBRegister:

    if( Error != ERROR_SUCCESS ) {

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "Ipx Registration failed, %ld.\n", Error ));
    }

    //
    // now create sockets for NET BIOS 1C group name and UNIQUE server
    // name.
    //

    SOCKADDR_NB NB1CSocketAddress;
    SOCKADDR_NB NBUniqueSocketAddress;
    SOCKET NBSocket;

    memset( &NB1CSocketAddress, 0x0, sizeof(SOCKADDR_NB) );
    NB1CSocketAddress.snb_family = AF_NETBIOS;
    NB1CSocketAddress.snb_type = TDI_ADDRESS_NETBIOS_TYPE_GROUP;

    TcpsvcsDbgAssert(
        sizeof(NB1CSocketAddress.snb_name) >=
            NETBIOS_INET_GROUP_NAME_LEN );

    memcpy(
        NB1CSocketAddress.snb_name,
        NETBIOS_INET_GROUP_NAME,
        NETBIOS_INET_GROUP_NAME_LEN );

    memset( &NBUniqueSocketAddress, 0x0, sizeof(SOCKADDR_NB) );
    NBUniqueSocketAddress.snb_family = AF_NETBIOS;
    NBUniqueSocketAddress.snb_type = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    TcpsvcsDbgAssert( GlobalComputerName[0] != '\0' );

    MakeUniqueServerName(
        (LPBYTE)NBUniqueSocketAddress.snb_name,
        sizeof(NBUniqueSocketAddress.snb_name),
        GlobalComputerName );

    //
    // enumurate lanas first.
    //

    LANA_ENUM Lanas;

    if( GetEnumNBLana( &Lanas ) ) {

        //
        // try only the lanas that are returned.
        //

		// removed because of bug 
        //TcpsvcsDbgAssert( Lanas.length > 0 );

        DWORD i;
        for( i = 0; i < Lanas.length; i++ ) {

            //
            // create a socket for this lana to bind with the IC name.
            //

            if ( MakeNBSocketForLana(
                    Lanas.lana[i],
                    (PSOCKADDR)&NB1CSocketAddress,
                    &NBSocket ) ) {

                //
                // add the sockets to our global list.
                //

                FD_SET( NBSocket, &GlobalSrvSockets );
            }

            //
            // now create a socket for this lana to bind with the unique
            // server name.
            //

            if ( MakeNBSocketForLana(
                    Lanas.lana[i],
                    (PSOCKADDR)&NBUniqueSocketAddress,
                    &NBSocket ) ) {

                //
                // add the sockets to our global list.
                //

                FD_SET( NBSocket, &GlobalSrvSockets );
            }
        }
    }
    else {

        UCHAR Lana;

        //
        // try all possible lanas and accept all valid lana sockets.
        //

        for( Lana = 0; Lana < MAX_LANA ; Lana-- ) {

            //
            // create a socket for this lana to bind with the IC name.
            //

            if ( MakeNBSocketForLana(
                    Lana,
                    (PSOCKADDR)&NB1CSocketAddress,
                    &NBSocket ) ) {

                //
                // add the sockets to our global list.
                //

                FD_SET( NBSocket, &GlobalSrvSockets );
            }

            //
            // now create a socket for this lana to bind with the unique
            // server name.
            //

            if ( MakeNBSocketForLana(
                    Lana,
                    (PSOCKADDR)&NBUniqueSocketAddress,
                    &NBSocket ) ) {

                //
                // add the sockets to our global list.
                //

                FD_SET( NBSocket, &GlobalSrvSockets );
            }
        }
    }

    //
    // we should have at least one socket to listen on, otherwise,
    // it is an error, return so.
    //

    if( GlobalSrvSockets.fd_count == 0 ) {
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "Failed to get any Lanas, Service locator disabled\n" ));
        Error = ERROR_NO_NETWORK;
        goto Cleanup;
    }

    //
    // create listen thread.
    //

    DWORD ThreadId;

    GlobalSrvListenThreadHandle =
        CreateThread(
            NULL,       // default security
            0,          // default stack size
            (LPTHREAD_START_ROUTINE)SocketListenThread,
            NULL,          // no parameter
            0,          // creatation flag, no suspend
            &ThreadId );

    if( GlobalSrvListenThreadHandle  == NULL ) {
        Error = GetLastError();
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "ServerRegisterAndListen failed, %ld.\n", Error ));

        //
        // if we are not successful, cleanup
        // before we return.
        //

        DWORD LocalError;

        //
        //  The routine is expecting the global lock to be taken
        //

        LOCK_SVC_GLOBAL_DATA();

        LocalError = ServerDeregisterAndStopListen();

        UNLOCK_SVC_GLOBAL_DATA();

        TcpsvcsDbgAssert( LocalError == ERROR_SUCCESS );
    }

    return( Error );
}

DWORD
ProcessSvclocQuery(
    SOCKET ReceivedSocket,
    LPBYTE ReceivedMessage,
    DWORD ReceivedMessageLength,
    struct sockaddr *SourcesAddress,
    DWORD SourcesAddressLength
    )
/*++

Routine Description:

    This function processes the query message and sends response to the
    query.

    The query message format.

    1st DWORD : message length.
    2nd DWORD : message version.
    3rd DWORD : services mask the client interested in.
    4th DWORD : client name
    ..
    ..

    Last but one DWORD : check sum.
    LAST DWORD : terminating DWORD 0xFFFFFFFF

Arguments:

    ReceivedMessage - pointer to a message buffer.

    ReceivedMessageLength - length of the above message.

    SourcesAddress - address of the sender.

    SourcesAddressLength - length of the above address.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPBYTE MessagePtr;
    LPBYTE MessageEndPtr;

    MessagePtr = ReceivedMessage;
    MessageEndPtr = ReceivedMessage + ReceivedMessageLength;

    //
    // message length should be multiple of sizeof(DWORD).
    //

    if( ReceivedMessageLength % sizeof(DWORD) != 0 ) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // message length should match.
    //

    DWORD MsgLength;

    MsgLength = *(DWORD *)MessagePtr;
    MessagePtr += sizeof(DWORD);

    if( MsgLength != ReceivedMessageLength ) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // message should terminate with 0xFFFFFFFF
    //

    if( *(DWORD *)(MessageEndPtr - sizeof(DWORD)) != 0xFFFFFFFF ) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // verify checksum.
    //

    DWORD CheckSum;

    CheckSum = ComputeCheckSum(
            ReceivedMessage + sizeof(DWORD),
            ReceivedMessageLength - (3 * sizeof(DWORD)) );

    if( CheckSum != *(DWORD *)(MessageEndPtr - 2 * sizeof(DWORD)) ) {
        return( ERROR_INVALID_PARAMETER );
    }

#if 0

    // IIS5.0: We want to respond to all server discovery messages
    // since it is potentially useful to clients to find all versions
    // of IIS.  The server will send back a message specifying it's
    // own version number and it is up to the client to determine
    // if they want this server's information.

    //
    // validate version number.
    //

    INET_VERSION_NUM VersionNumber;

    VersionNumber.VersionNumber = *(DWORD *)MessagePtr;
    MessagePtr += sizeof(DWORD);

    if( (VersionNumber.Version.Major != INET_MAJOR_VERSION) ||
        (VersionNumber.Version.Minor != INET_MINOR_VERSION) ) {

        //
        // in future, we can apply different logic to reject messages with
        // differnet version number.
        //

        return( ERROR_INVALID_PARAMETER );
    }

#endif

    //
    // get services mask.
    //

    ULONGLONG ServicesMask;

    ServicesMask = *(ULONGLONG *)MessagePtr;
    MessagePtr += sizeof(ULONGLONG);

    //
    // if we aren't supporting any of the clients requested services,
    // ignore these message.
    //

    if( (ServicesMask & GlobalSrvInfoObj->GetServicesMask()) == 0) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // retrieve the computer name from the message. currently
    // it has been used just for debugging purpose. It can be used for
    // something else in future.
    //

    LPSTR ClientComputerName;
    LPSTR ComputerNamePtr;

    ClientComputerName = (LPSTR)MessagePtr;

    //
    // validate computer name.
    //

    ComputerNamePtr = ClientComputerName;
    while( (*ComputerNamePtr != '\0') &&
                ((LPBYTE)ComputerNamePtr < MessageEndPtr) ) {
        ComputerNamePtr++;
    }

    if( (LPBYTE)ComputerNamePtr >= MessageEndPtr ) {
        return( ERROR_INVALID_PARAMETER );
    }

    TcpsvcsDbgPrint((
        DEBUG_SVCLOC_MESSAGE,
            "Received a valid discovery message from, %ws.\n",
                ClientComputerName ));

    //
    // send response message to client.
    //

    LOCK_SVC_GLOBAL_DATA();

    TcpsvcsDbgAssert( GlobalSrvRespMsgLength != 0 );

    if( GlobalSrvRespMsgLength != 0 ) {
        Error = sendto(
                    ReceivedSocket,
                    (LPCSTR)GlobalSrvRespMsg,
                    GlobalSrvRespMsgLength,
                    0,
                    SourcesAddress,
                    SourcesAddressLength );


        if( Error == SOCKET_ERROR ) {

            Error = WSAGetLastError();
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "sendto failed, %ld.\n", Error ));
        }
        else {
            Error = ERROR_SUCCESS;
        }
    }
    else {

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "GlobalSrvRespMsgLength is zero.\n" ));
        Error = ERROR_INVALID_PARAMETER;
    }

    UNLOCK_SVC_GLOBAL_DATA();
    return( Error );
}

VOID
SocketListenThread(
    LPVOID Parameter
    )
/*++

Routine Description:

    This function is the main thread for the service location protocol. It
    receives messages that arrive from all sockets (that have
    been established by the ServerRegisterAndListen call) and response to
    each of the messages. This thread will stop when all sockets are
    closed by the ServerDeregisterAndStopListen call.

Arguments:

    none.

Return Value:

    none.

--*/
{

    fd_set ReadSockets;
    int NumReadySockets;
    DWORD Error;
    BOOL BoolError;

    //
    // increase the priority of this thread, so that it could handle as
    // many discovery queries as possible.
    //

    BoolError = SetThreadPriority(
                    GetCurrentThread(),
                    THREAD_PRIORITY_ABOVE_NORMAL );

    if(BoolError) {

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "SetThreadPriority, %ld.\n", GetLastError() ));
    }

    for( ;; ) {

        //
        // COMMENT
        // select on all above sockets.
        //

        //
        // copy all sockets.
        //

        LOCK_SVC_GLOBAL_DATA();
        memcpy(&ReadSockets, &GlobalSrvSockets, sizeof(GlobalSrvSockets));
        UNLOCK_SVC_GLOBAL_DATA();

        //
        // do select now.
        //

        NumReadySockets =
            select(
                0,  // compatibility argument, ignored.
                &ReadSockets, // sockets to test for readability.
                NULL,   // no write wait
                NULL,   // no error check.
                NULL ); // NO timeout.

        if( NumReadySockets == SOCKET_ERROR ) {

            //
            // ALL sockets are closed and we are asked to return or
            // something else has happpened which we can't handle.
            //

            Error = WSAGetLastError();
            goto Cleanup;
        }

        TcpsvcsDbgAssert( (DWORD)NumReadySockets == ReadSockets.fd_count );

        DWORD i;
        for( i = 0; i < (DWORD)NumReadySockets; i++ ) {

            DWORD ReadMessageLength;
            struct sockaddr_nb SourcesAddress;
            int SourcesAddressLength;

            //
            // read next message.
            //

            SourcesAddressLength = sizeof(SourcesAddress);
            ReadMessageLength =
                recvfrom(
                    ReadSockets.fd_array[i],
                    (LPSTR)GlobalSrvRecvBuf,
                    GlobalSrvRecvBufLength,
                    0,
                    (struct sockaddr *)&SourcesAddress,
                    &SourcesAddressLength );

            if( ReadMessageLength == SOCKET_ERROR ) {

                //
                // ALL sockets are closed and we are asked to return or
                // something else has happpened which we can't handle.
                //

                Error = WSAGetLastError();
                continue;
            }

            TcpsvcsDbgAssert( ReadMessageLength <= GlobalSrvRecvBufLength );

            //
            // received a message.
            //

            TcpsvcsDbgPrint((
                DEBUG_SVCLOC_MESSAGE,
                    "Received a discovery message, %ld.\n",
                        ReadMessageLength ));

            Error = ProcessSvclocQuery(
                            ReadSockets.fd_array[i],
                            GlobalSrvRecvBuf,
                            (DWORD)ReadMessageLength,
                            (struct sockaddr *)&SourcesAddress,
                            (DWORD)SourcesAddressLength );

            if( Error != ERROR_SUCCESS ) {
                TcpsvcsDbgPrint(( DEBUG_ERRORS,
                    "SendSvclocResponse failed, %ld.\n", Error ));
            }
        }
    }

Cleanup:

    TcpsvcsDbgPrint(( DEBUG_ERRORS,  "SocketListenThread returning, %ld.\n", Error ));
    return;
}

DWORD
ServerDeregisterAndStopListen(
    VOID
    )
/*++

Routine Description:

    This function call stops the discovery thread and deregisters the
    server name. Also it cleans up the winsock data structures.

    ASSUME : global data crit sect is locked.

Arguments:

    none.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD i;

    //
    // close all sockets, if any opened.
    //

    for( i = 0; i < GlobalSrvSockets.fd_count; i++ ) {

        Error = closesocket( GlobalSrvSockets.fd_array[i] );

        if( Error == SOCKET_ERROR ) {
            Error = WSAGetLastError();

            TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "closesocket call failed, %ld\n", Error ));
        }
    }

    //
    // invalidate GlobalSrvSockets count
    //

    GlobalSrvSockets.fd_count = 0;

    //
    // closing all above sockets should stop the service location thread,
    // check to see this is the case and close the thread handle.
    //

    if( GlobalSrvListenThreadHandle != NULL ) {

        //
        //  The thread may take this critical section, release it around
        //  the wait to prevent a deadlock
        //

        UNLOCK_SVC_GLOBAL_DATA();

        //
        // Wait for the service location thread to stop, but don't wait
        // for longer than THREAD_TERMINATION_TIMEOUT msecs (60 secs)
        //

        DWORD WaitStatus =
            WaitForSingleObject(
                    GlobalSrvListenThreadHandle,
                    30000
                    );

        TcpsvcsDbgAssert( WaitStatus != WAIT_FAILED );

        if(  WaitStatus == WAIT_FAILED ) {
            TcpsvcsDbgPrint((DEBUG_ERRORS,
                "WaitForSingleObject call failed, %ld\n", GetLastError() ));
        }

        CloseHandle( GlobalSrvListenThreadHandle );
        GlobalSrvListenThreadHandle = NULL;

        LOCK_SVC_GLOBAL_DATA();


    }

    //
    // deregister rnr.
    //

    if( GlobalRNRRegistered ) {

        SOCKADDR_IPX IpxSocketAddress;
        SERVICE_INFO ServiceInfo;
        SERVICE_ADDRESSES ServiceAddresses;
        PSERVICE_ADDRESS ServiceAddr;
        DWORD StatusSetService;
        CHAR SapSvcName[SAP_SERVICE_NAME_LEN + 1];
        CHAR *SapSvcNamePtr;

        Error = MakeSapServiceName( SapSvcName, sizeof(SapSvcName) );

        if( Error != ERROR_SUCCESS ) {
            SapSvcNamePtr = NULL;
        }
        else {
            SapSvcNamePtr = SapSvcName;
        }

        //
        // prepare service address.
        //

        ServiceAddresses.dwAddressCount = 1;
        ServiceAddr = &ServiceAddresses.Addresses[0];

        memset( &IpxSocketAddress, 0x0, sizeof(IpxSocketAddress) );

        ServiceAddr->dwAddressType = PF_IPX;
        ServiceAddr->dwAddressFlags = 0;
        ServiceAddr->dwAddressLength = sizeof( IpxSocketAddress );
        ServiceAddr->dwPrincipalLength = 0;
        ServiceAddr->lpAddress = (LPBYTE)&IpxSocketAddress;
        ServiceAddr->lpPrincipal = NULL;

        //
        // prepare service info.
        //

        ServiceInfo.lpServiceType = &GlobalSapGuid;
        ServiceInfo.lpServiceName = SapSvcNamePtr;
        ServiceInfo.lpComment = NULL ;
        ServiceInfo.lpLocale = 0;
        ServiceInfo.dwDisplayHint = 0;
        ServiceInfo.dwVersion =
            MAKEWORD( INET_MAJOR_VERSION, INET_MINOR_VERSION ) ;
        ServiceInfo.dwTime = 0; // ??
        ServiceInfo.lpMachineName = GlobalComputerName;
        ServiceInfo.lpServiceAddress = &ServiceAddresses;
        ServiceInfo.ServiceSpecificInfo.pBlobData = 0;
        ServiceInfo.ServiceSpecificInfo.cbSize = 0;

        //
        // register service info.
        //

        if( SetServiceA(
                NS_SAP,
                SERVICE_DEREGISTER,
                0,
                &ServiceInfo,
                0,
                &StatusSetService ) == SOCKET_ERROR ) {

            Error = WSAGetLastError();
            TcpsvcsDbgPrint(( DEBUG_ERRORS,
                "SetServiceW call failed, %ld\n", Error ));
        }

        GlobalRNRRegistered = FALSE;
    }

    //
    // DONE.
    //

     return( ERROR_SUCCESS );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\util.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Contains the class implementation of UTILITY classes.

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

    MuraliK 20-March-1996 modularize within svcloc

--*/


#include <svcloc.hxx>


MEMORY * CacheHeap = NULL;


PVOID
MEMORY::Alloc(
    DWORD Size
    )
/*++

Routine Description:

    This member function allocates memory from the local heap. In debug
    build this function also keeps track of the memory allocations and
    fills up the memory with a known pattern that helps to debug memory
    corruptions.

Arguments:

    Size : size of the memory block in bytes requested.

Return Value:

    Pointer to the alloted memory block. If there is no memory
    available, this pointer will be set to NULL.

--*/
{
    PVOID MemoryPtr;

    MemoryPtr = LocalAlloc(
                    LMEM_FIXED | LMEM_ZEROINIT,
                    Size );

#if DBG

    TcpsvcsDbgAssert( MemoryPtr != NULL );

    _Count++;
    _TotalSize += Size;
    memset( MemoryPtr, 0xAA, Size );

    TcpsvcsDbgPrint(( DEBUG_MEM_ALLOC,
        "MEMORY::Alloc, _Count = %ld, _TotalSize = %ld.\n",
            _Count, _TotalSize ));

#endif // DBG

    return( MemoryPtr );
}

PVOID
MEMORY::ReAlloc(
    PVOID OldMemory,
    DWORD NewSize
    )
/*++

Routine Description:

    This member function reallocates memory from the local heap. In
    debug build this function also keeps track of the memory allocations and
    fills up the memory with a known pattern that helps to debug memory
    corruptions.

Arguments:

    OldMemory - pointer to the old memory block.

    NewSize : size of the new memory block in bytes requested.

Return Value:

    Pointer to the alloted memory block. If there is no memory
    available, this pointer will be set to NULL.

--*/
{
    PVOID NewMemory;
    DWORD OldSize;

    //
    // if there is no previous memory, then alloc a new one.
    //

    if( OldMemory == NULL ) {
        return( Alloc( NewSize ) );
    }

    //
    // get old memory size.
    //

    OldSize = (DWORD)LocalSize( OldMemory );

    TcpsvcsDbgAssert( OldSize != NewSize );

    //
    // if new size is same as old size, simply return.
    //

    if( OldSize == NewSize ){
        return( OldMemory );
    }

    //
    // if the newsize is zero, free old memory and return zero.
    //

    if( NewSize == 0 ) {
        Free( OldMemory );
        return( NULL );
    }

    //
    // realloc.
    //

    NewMemory = LocalReAlloc(
                    OldMemory,
                    NewSize,
                    LMEM_FIXED | LMEM_ZEROINIT | LMEM_MOVEABLE );
                        // block move is OK.

#if DBG

    TcpsvcsDbgAssert( NewMemory != NULL );

    //
    // update total memory consumed size and fillin the extra memory
    // with pattern.
    //

    if( NewSize > OldSize ) {
        DWORD ModSize =  (NewSize - OldSize);
        _TotalSize += ModSize;
        memset( (LPBYTE)NewMemory + OldSize, 0xAA, ModSize );
    }
    else {
        _TotalSize -= (OldSize - NewSize);
    }

    TcpsvcsDbgPrint(( DEBUG_MEM_ALLOC,
        "MEMORY::Alloc, _Count = %ld, _TotalSize = %ld.\n",
            _Count, _TotalSize ));

#endif // DBG

    return( NewMemory );
}

VOID
MEMORY::Free(
    PVOID MemoryPtr
    )
/*++

Routine Description:

    This member function frees the memory block that was allocated by
    the meber function this->Alloc(). In debug build this function also
    keeps track of the memory allocations.

Arguments:

    MemoryPtr : Pointer to a memory block that is freed.

Return Value:

    None.

--*/
{
    PVOID ReturnHandle;
    DWORD Size;


    if( MemoryPtr == NULL ) {
#if DBG
        TcpsvcsDbgPrint(( DEBUG_MISC,
            "MEMORY::Free called with NULL.\n" ));
#endif // DBG
        return;
    }

#if DBG
    Size = (DWORD)LocalSize( MemoryPtr );
#endif // DBG

    ReturnHandle = LocalFree( MemoryPtr );

#if DBG

    TcpsvcsDbgAssert( ReturnHandle == NULL );

    _Count--;
    _TotalSize -= Size;

    TcpsvcsDbgPrint(( DEBUG_MEM_ALLOC,
        "MEMORY::Free, _Count = %ld, _TotalSize = %ld.\n",
            _Count, _TotalSize ));

#endif // DBG

    return;
}

#if 0

void *
operator new(
    size_t Size
    )
/*++

Routine Description:

    Private implemetation of the new operator.

Arguments:

    Size : size of the memory requested.

Return Value:

    Pointer to the alloted memory block.

--*/
{
    if( CacheHeap == NULL ) {

        PVOID MemoryPtr;

        MemoryPtr = LocalAlloc(
                        LMEM_FIXED | LMEM_ZEROINIT,
                        Size );

        return( MemoryPtr );
    }
    else {
        return( CacheHeap->Alloc( DWORD(Size) ) );
    }
}

void
operator delete(
    void *MemoryPtr
    )
/*++

Routine Description:

    Private implemetation of the free operator.

Arguments:

    MemoryPtr : Pointer to a memory block that is freed

Return Value:

    None.

--*/
{
    if( CacheHeap == NULL ) {
        LocalFree( MemoryPtr );
    }
    else {
        CacheHeap->Free( MemoryPtr );
    }

    return;
}

#endif // 0

PVOID
MIDL_user_allocate(
    size_t Size
    )
/*++

Routine Description:

    MIDL memory allocation.

Arguments:

    Size : Memory size requested.

Return Value:

    Pointer to the allocated memory block.

--*/
{
    if( CacheHeap == NULL ) {

        return LocalAlloc( LMEM_FIXED,
                           Size );
    }
    else {
        return( CacheHeap->Alloc( DWORD(Size) ) );
    }
}

VOID
MIDL_user_free(
    PVOID MemoryPtr
    )
/*++

Routine Description:

    MIDL memory allocation.

Arguments:

    MmeoryPtr : Pointer to a memory block that is freed.


Return Value:

    None.

--*/
{
    if( CacheHeap == NULL ) {
        LocalFree( MemoryPtr );
    }
    else {
        CacheHeap->Free( MemoryPtr );
    }
    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\directry\enum.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Active Directory 1.0 Sample Code
//
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       enum.cxx
//
//  Contents:   Active Drectory container enumeration
//
//
//----------------------------------------------------------------------------

#include "main.hxx"


//
// Private defines
//

#define MAX_ADS_FILTERS   10
#define MAX_ADS_ENUM      100     // number of entries to read each time


//
// Local functions
//


HRESULT
PrintLongFormat(
    IADs * pObject
    );

//
//  List contents of a container identified by the ADsPath
//

int
DoList(char * AnsiADsPath)
{
    HRESULT hr;
    int i = 0 ;
    LPWSTR pszADsPath, apszTypes[MAX_ADS_FILTERS] ;

    if (!(pszADsPath = AllocateUnicodeString(AnsiADsPath))) {

        return(1) ;
    }

    apszTypes[0] = NULL ;

    //
    //  Filter may be set as follows. For example, to get users and group:
    //
    //  apszTypes[0] = L"User" ;
    //  apszTypes[1] = L"Group" ;
    //  apszTypes[2] = NULL ;
    //

    hr = EnumObject(
             pszADsPath,
             apszTypes,
             i
             );

    return (FAILED(hr) ? 1 : 0) ;
}

//
// Enumerates the contents of a container object.
//

HRESULT
EnumObject(
    LPWSTR pszADsPath,
    LPWSTR * lppClassNames,
    DWORD dwClassNames
    )
{
    ULONG cElementFetched = 0L;
    IEnumVARIANT * pEnumVariant = NULL;
    VARIANT VarFilter, VariantArray[MAX_ADS_ENUM];

    HRESULT hr;
    IADsContainer * pADsContainer =  NULL;
    DWORD dwObjects = 0, dwEnumCount = 0, i = 0;
    BOOL  fContinue = TRUE;


    VariantInit(&VarFilter);

    hr = ADsGetObject(
                pszADsPath,
                IID_IADsContainer,
                (void **)&pADsContainer
                );

    if (FAILED(hr)) {

        printf("\"%S\" is not a valid container object.\n", pszADsPath) ;
        goto exitpoint ;
    }


    hr = ADsBuildVarArrayStr(
                lppClassNames,
                dwClassNames,
                &VarFilter
                );
    BAIL_ON_FAILURE(hr);


    hr = pADsContainer->put_Filter(VarFilter);
    BAIL_ON_FAILURE(hr);

    hr = ADsBuildEnumerator(
            pADsContainer,
            &pEnumVariant
            );
    BAIL_ON_FAILURE(hr);



    while (fContinue) {

        IADs *pObject ;

        hr = ADsEnumerateNext(
                    pEnumVariant,
                    MAX_ADS_ENUM,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;
        }

        dwEnumCount++;

        for (i = 0; i < cElementFetched; i++ ) {

            IDispatch *pDispatch = NULL;

            pDispatch = VariantArray[i].pdispVal;

            hr = pDispatch->QueryInterface(IID_IADs,
                                           (VOID **) &pObject) ;
            BAIL_ON_FAILURE(hr);

            PrintLongFormat(pObject);

            pObject->Release();
            pDispatch->Release();
        }

        memset(VariantArray, 0, sizeof(VARIANT)*MAX_ADS_ENUM);

        dwObjects += cElementFetched;

    }

    printf("Total Number of Objects enumerated is %d\n", dwObjects);

    if (pEnumVariant) {
        pEnumVariant->Release();
    }

    if (pADsContainer) {
        pADsContainer->Release();
    }

    return(S_OK);

error:
    if (FAILED(hr)) {

        printf("Unable to list contents of: %S\n", pszADsPath) ;
    }

exitpoint:

    if (pEnumVariant) {
        pEnumVariant->Release();
    }

    VariantClear(&VarFilter);


    if (pADsContainer) {
        pADsContainer->Release();
    }

    return(hr);
}

HRESULT
PrintLongFormat(IADs * pObject)
{

    HRESULT hr = S_OK;
    BSTR bstrName = NULL;
    BSTR bstrClass = NULL;
    BSTR bstrSchema = NULL;

    hr = pObject->get_Name(&bstrName) ;
    BAIL_ON_FAILURE(hr);

    hr = pObject->get_Class(&bstrClass);
    BAIL_ON_FAILURE(hr);

    // hr = pObject->get_Schema(&bstrSchema);

    printf("  %S(%S)\n", bstrName, bstrClass) ;

error:
    if (bstrClass) {
        SysFreeString(bstrClass);
    }
    if (bstrName) {
        SysFreeString(bstrName);
    }
    if (bstrSchema) {
        SysFreeString(bstrSchema);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\directry\adsiloc.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    adsiloc.cxx           

Abstract:
    Connects with servers.
Enumerates servers


Author:
    Sean Woodward (t-seanwo)    10/2/1997

Revision History:

--*/

// defined functions
//   dump: dumps the Service Elements


#include "svcloc.h"

// TODO: Filter out the non-IIS services
int
ServiceDump(char *AnsiADsPath)
{
    HRESULT hr = E_OUTOFMEMORY ;
    LPWSTR pszADsPath = NULL;
    IADs * pADs = NULL;

    //
    // Convert path to unicode and then bind to the object.
    //

    BAIL_ON_NULL(pszADsPath = AllocateUnicodeString(AnsiADsPath));

    hr = ADsGetObject(
                pszADsPath,
                IID_IADs,
                (void **)&pADs
                );

    if (FAILED(hr)) {

        printf("Failed to bind to object: %S\n", pszADsPath) ;
    }
    else {

        //
        // Dump the object
        //

        hr = DumpObject(pADs);

        if (FAILED(hr)) {

            printf("Unable to read properties of: %S\n", pszADsPath) ;
        }

        pADs->Release();
    }

error:

    FreeUnicodeString(pszADsPath);

    return (FAILED(hr) ? 1 : 0) ;
}

//
// Given an ADs pointer, dump the contents of the object
//

HRESULT
DumpObject(
    IADs * pADs
    )
{
    HRESULT hr;
    IADs * pADsProp = NULL;
    VARIANT * pVariantArray = NULL;
    VARIANT varProperty;

    DWORD dwNumProperties = 0;
    BSTR bstrPropName = NULL;
    DWORD i = 0;
    IDispatch * pDispatch = NULL;

    //
    // Access the schema for the object
    //

    hr = GetPropertyList(
                pADs,
                &pVariantArray,
                &dwNumProperties
                );
    BAIL_ON_FAILURE(hr);

    //
    // Get the information on the object
    //

    hr = pADs->GetInfo();
    BAIL_ON_FAILURE(hr);

    //
    // Loop and retrieve all properties
    //

    for (i = 0; i < dwNumProperties; i++ ) {

        pDispatch = (pVariantArray + i)->pdispVal;

        hr = pDispatch->QueryInterface(
                            IID_IADs,
                            (void **)&pADsProp
                            );
        BAIL_ON_FAILURE(hr);

        pDispatch->Release();

        hr = pADsProp->get_Name(&bstrPropName);

        pADsProp->Release();

        BAIL_ON_FAILURE(hr);

        //
        // Get a property and print it out. The HRESULT is passed to
        // PrintProperty.
        //

        hr = pADs->Get(
                bstrPropName,
                &varProperty
                );

        PrintProperty(
            bstrPropName,
            hr,
            varProperty
            );

        if (bstrPropName) {
            SysFreeString(bstrPropName);
        }

    }

error:
    free(pVariantArray);
    return(hr);
}


HRESULT
GetPropertyList(
    IADs * pADs,
    VARIANT ** ppVariant,
    PDWORD pcElementFetched
    )
{
    HRESULT hr= S_OK;
    BSTR bstrSchemaPath = NULL;
    IADsContainer * pADsContainer = NULL;
    IEnumVARIANT * pEnumVariant = NULL;
    BOOL fContinue = TRUE;
    ULONG cthisElement = 0L;
    ULONG cElementFetched = 0L;
    LPBYTE pVariantArray = NULL;
    VARIANT varProperty;
    DWORD cb = 0;

    hr = pADs->get_Schema(&bstrSchemaPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsGetObject(
                bstrSchemaPath,
                IID_IADsContainer,
                (void **)&pADsContainer
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsBuildEnumerator(
            pADsContainer,
            &pEnumVariant
            );
    BAIL_ON_FAILURE(hr);

    while (fContinue) {

        VariantInit(&varProperty);
        hr = ADsEnumerateNext(
                    pEnumVariant,
                    1,
                    &varProperty,
                    &cthisElement
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;
            break;
        }

        pVariantArray = (LPBYTE)realloc(
                                        (void *)pVariantArray,
                                        cb + sizeof(VARIANT)
                                        );

        if (!pVariantArray) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        memcpy(pVariantArray + cb, (LPBYTE)&varProperty, sizeof(VARIANT));
        cb += sizeof(VARIANT);

        cElementFetched += cthisElement;

    }

    *ppVariant = (LPVARIANT)pVariantArray;
    *pcElementFetched = cElementFetched;

error:
    if (bstrSchemaPath) {
        SysFreeString(bstrSchemaPath);
    }

    if (pADsContainer) {
        pADsContainer->Release();
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\directry\main2.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Active Directory 1.0 Sample Code
//
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       main.cxx
//
//  Contents:   Main for adscmd
//
//
//----------------------------------------------------------------------------


#include "main.hxx"


//-------------------------------------------------------------------------
//
// main
//
//-------------------------------------------------------------------------

void __cdecl
main()
{
    IADsContainer *pContainer;
    IADs *pADs;
    BSTR  bstrName;
    HRESULT hr;
#if 0

    hr = ADsGetObject(TEXT("WinNT://SEANW1"),
        IID_IADsContainer,
        (void**) &pContainer);

    BAIL_ON_FAILURE(hr);

    hr = pContainer->QueryInterface(
        IID_IADs,
        (void**) &pADs);

    BAIL_ON_FAILURE(hr);

#else

    hr = ADsGetObject(L"WinNT://SEANW2",
        IID_IADs,
        (void**) &pADs);

    BAIL_ON_FAILURE(hr);

#endif
    
    pADs->get_Name(&bstrName);
    printf("%s\n", bstrName);
    
    SysFreeString(bstrName);
    pContainer->Release();

    return;

error:
    printf("Error:\t%d\n", hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\directry\main.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Active Directory 1.0 Sample Code
//
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       main.cxx
//
//  Contents:   Main for adscmd
//
//
//----------------------------------------------------------------------------


#include "main.hxx"

GUID sapguid;

#define ssgData1        0xa5569b20
#define ssgData2        0xabe5
#define ssgData3        0x11ce
#define ssgData41       0x9c
#define ssgData42       0xa4
#define ssgData43       0x00
#define ssgData44       0x00
#define ssgData45       0x4c
#define ssgData46       0x75
#define ssgData47       0x27
#define ssgData48       0x31


//-------------------------------------------------------------------------
//
// main
//
//-------------------------------------------------------------------------

void __cdecl
main()
{
    IADsContainer *pContainer = NULL;
    IADs *pObj = NULL;
    IDispatch *pDispatch = NULL;
    IADsService  *pService = NULL;
    BSTR  bstrName;
    HRESULT hr;
    LPWSTR lpwstrPath = NULL;
    LPWSTR lpwstrService, lpwstrRelName;

    hr = CoInitialize(NULL);

    if (FAILED(hr)) {
        printf("CoInitialize failed\n");
        exit(1);
    }

char buffer[500];
scanf("%s", buffer);

//    lpwstrPath = AllocateUnicodeString("WinNT://SEANW1");
printf("%s", buffer);
    lpwstrPath = AllocateUnicodeString(buffer);
    lpwstrService = AllocateUnicodeString("user");
    lpwstrRelName = AllocateUnicodeString("IISfoo");

    BAIL_ON_NULL(lpwstrPath);
    BAIL_ON_NULL(lpwstrService);
    BAIL_ON_NULL(lpwstrRelName);

    hr = ADsGetObject(
        lpwstrPath,
        IID_IADsContainer,
        (void**) &pContainer);

    BAIL_ON_FAILURE(hr);

    // Create a services object
    hr  = pContainer->Create(lpwstrService, lpwstrRelName, &pDispatch);

    if (FAILED(hr)) {
        printf("Create failed\n");
        goto error;
    }

    IADsUser *pUser;

    pDispatch->QueryInterface(IID_IADs, (void**)&pObj);
    pDispatch->QueryInterface(IID_IADsUser, (void**)&pUser);
//    pDispatch->QueryInterface(IID_IADsService, (void**)&pService);

    // Get services obj
//    pObj->QueryInterface(IID_IADsService, (void**) &pService);

/*
    // fill in params
    VARIANT var;
    VariantInit(&var);
    var.vt = VT_BSTR;

    var.bstrVal = SysAllocString(L"0xa5569b20abe511ce9ca400004c752731");

    BSTR name;
    name = SysAllocString(L"serviceClassID");

    hr = pObj->Put(name, var);
    if (FAILED(hr)) {
        printf("Put failed");
        goto error;
    }
*/

    hr = pUser->SetInfo();

    if (FAILED(hr)) {
        printf("SetInfo failed");
        goto error;
    }

    
    pContainer->Release();
    pObj->Release();
    pService->Release();

    printf("No Error\n");
    FreeUnicodeString(lpwstrPath);
    FreeUnicodeString(lpwstrRelName);
    FreeUnicodeString(lpwstrService);

    return;


error:
    printf("Error:\t%d\n", hr);
    FreeUnicodeString(lpwstrPath);
    FreeUnicodeString(lpwstrRelName);
    FreeUnicodeString(lpwstrService);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\test\svcdisc.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    discover.c

Abstract:

    Contains code that implements the service location apis.

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:
    MuraliK    11-July-1995  Extended to discover any service besides Gateway

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <svcloc.h>

// consists of information map from service name to other details
typedef struct _SERVICE_INFO {
    LPCSTR     pszName;
    ULONGLONG  ulMask;
} SERVICE_INFO;

SERVICE_INFO  g_Services[] = {
    { "gopher",   INET_GOPHER_SERVICE},
    { "http",     INET_W3_SERVICE},
    { "w3",       INET_W3_SERVICE},
    { "ftp",      INET_FTP_SERVICE},
    { "gate",     INET_GATEWAY_SERVICE},
    { "msn",      INET_MSN_SERVICE}
};

# define NUM_SERVICES    ( sizeof(g_Services)/ sizeof( SERVICE_INFO))


ULONGLONG GetUlMaskForService( IN LPSTR pszServiceName)
{
    DWORD i;

    for ( i = 0; i < NUM_SERVICES; i++) {

        if ( !stricmp( pszServiceName, g_Services[i].pszName)) {

            return ( g_Services[i].ulMask);
        }
    }

    return ( 0);
} // GetUlMaskForService()

VOID
PrintServerInfo(
    DWORD Index,
    LPINET_SERVER_INFO ServerInfo
    )
{
    DWORD j, k;

    printf("%ld. ServerName = %s \n ", Index+1, ServerInfo->ServerName );
    printf("  ServicesMask = %lx \n", (DWORD)ServerInfo->ServicesMask );
    printf("   NumServices = %ld \n", ServerInfo->Services.NumServices );

    for( j = 0; j < ServerInfo->Services.NumServices; j++ ) {

        LPINET_SERVICE_INFO ServiceInfo;

        ServiceInfo = ServerInfo->Services.Services[j];

        printf("\n");
        printf(" %ld. ServiceMask = %ld \n",
            j+1, (DWORD)ServiceInfo->ServiceMask );

        printf("    ServiceState = %ld \n",
           (DWORD)ServiceInfo->ServiceState );

        printf("    ServiceComment = %s \n",
           (DWORD)ServiceInfo->ServiceComment );

        printf("    NumBindings  = %ld \n",
            ServiceInfo->Bindings.NumBindings );

        for( k = 0; k < ServiceInfo->Bindings.NumBindings; k++) {

            LPINET_BIND_INFO BindInfo;

            BindInfo = &ServiceInfo->Bindings.BindingsInfo[k];

            printf("     %ld. Bind (%ld) = %s\n",
                   k+1,
                   BindInfo->Length,
                   (LPWSTR)BindInfo->BindData );
        }

    }
    printf("\n");

    return;
}

VOID
PrintServersInfoList( IN LPINET_SERVERS_LIST  pServersList)
{
    DWORD i;

    for( i = 0; i < pServersList->NumServers; i++ ) {

        PrintServerInfo( i, pServersList->Servers[i] );
    }

    return;
}  // PrintServersInfoList()


VOID
PrintUsageMessage(IN LPCSTR pszProgName)
{
    int i;

    printf( "Usage: %s [ -tTimeToWait] [ -sServerName] { service-names }\n",
        pszProgName);

    printf("\t Services supported are:\n");
    for (i = 0; i < NUM_SERVICES; i++) {

        printf( "\t\t %s\n", g_Services[i].pszName);
    }

} // PrintUsageMessage()

DWORD
DiscoverServerInfo(
    LPSTR ServerName,
    ULONGLONG  ulMask,
    DWORD dwWaitTime
    )
{
    DWORD Error;
    LPINET_SERVER_INFO ServerInfo = NULL;

    if( dwWaitTime == 0 ) {

        Error = INetGetServerInfo(
                        ServerName,
                        ulMask,
                        SVC_DEFAULT_WAIT_TIME,
                        &ServerInfo );
    } else {

        Error = INetGetServerInfo(
                        ServerName,
                        ulMask,
                        0,
                        &ServerInfo );

        if( (Error != ERROR_BAD_NETPATH ) && (Error != ERROR_SUCCESS) ) {
            return( Error );
        }

        //
        // display server info if it is found.
        //

        if( ServerInfo != NULL ) {

            //
            // display server info.
            //

            PrintServerInfo( 0, ServerInfo );
            INetFreeServerInfo( &ServerInfo );
            return( ERROR_SUCCESS );
        }

        //
        // wait for server response.
        //

        Sleep( dwWaitTime * 1000 );

        Error = INetGetServerInfo(
                        ServerName,
                        ulMask,
                        0,
                        &ServerInfo );
    }

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    if( ServerInfo != NULL ) {
        PrintServerInfo( 0, ServerInfo );
    }
    else {
        printf( "INetGetServerInfo found no relevant servers\n");
    }

    //
    // free server info structure.
    //

    INetFreeServerInfo( &ServerInfo );
    return( ERROR_SUCCESS );
}

DWORD
DiscoverInetServers(
    ULONGLONG  ulMask,
    DWORD dwWaitTime
    )
{
    DWORD Error;
    LPINET_SERVERS_LIST ServersList = NULL;

    if( dwWaitTime == 0 ) {

        Error = INetDiscoverServers(
                        ulMask,
                        SVC_DEFAULT_WAIT_TIME,
                        &ServersList );
    } else {

        Error = INetDiscoverServers(
                        ulMask,
                        0,
                        &ServersList );

        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }

        //
        // ignore first enum, must have zero entry.
        //

        INetFreeDiscoverServersList( &ServersList );

        Sleep( dwWaitTime * 1000 );

        Error = INetDiscoverServers(
                        ulMask,
                        0,
                        &ServersList );
    }

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // list server info.
    //

    if ( ServersList->NumServers != 0) {

        PrintServersInfoList( ServersList );
    } else {

        printf( "INetDiscoverServers() found no relevant servers\n");
    }

    //
    // free server info structure.
    //

    INetFreeDiscoverServersList( &ServersList );
    return( ERROR_SUCCESS );
}

VOID __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD Error;
    ULONGLONG  ulMask = 0;
    int iArgs = 1;
    DWORD dwWaitTime = 0;
    LPSTR ServerName = NULL;

    while ( argv[iArgs] != NULL ){

        if( argv[iArgs][0] == '-' ) {

            switch ( argv[iArgs][1] ) {
            case 't':
                // get the wait time
                dwWaitTime = strtoul( argv[iArgs] + 2, NULL, 0);
                break;

            case 's':
                // get the server name.
                ServerName = argv[iArgs] + 2;
                break;

            default:
                PrintUsageMessage(argv[0]);
                exit(1);
            }
        }

        iArgs++; // skip one more argument
    }

    //
    // form the mask for all services
    //

    for ( iArgs = 1; iArgs < argc; iArgs++) {

        ulMask = ulMask | GetUlMaskForService( argv[iArgs]);
    } // for

    if ( ulMask == 0) {

        PrintUsageMessage(argv[0]);
        exit(1);
    }

    if( ServerName != NULL ) {
        Error = DiscoverServerInfo(  ServerName, ulMask, dwWaitTime );
    }
    else {
        Error = DiscoverInetServers(  ulMask, dwWaitTime );
    }

    if( Error != ERROR_SUCCESS ) {
        printf("%s failed with error, %ld.\n", argv[0], Error );
        return;
    }

    printf( "Command completed successfully.\n" );
    return;

} // main()

/*************************** End Of File **************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\directry\dump.cxx ===
//----------------------------------------------------------------------
//
//  Microsoft Active Directory 1.0 Sample Code
//
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       dump.cxx
//
//  Contents:   Functions for dumping the properties for an object.
//
//
//----------------------------------------------------------------------

#include "main.hxx"

//
// Given an ADsPath, bind to the object and call the DumpObject routine.
//

int
DoDump(char *AnsiADsPath)
{
 HRESULT hr = E_OUTOFMEMORY ;
 LPWSTR pszADsPath = NULL;
 IADs * pADs = NULL;

 //
 // Convert path to unicode and then bind to the object.
 //

 BAIL_ON_NULL(pszADsPath = AllocateUnicodeString(AnsiADsPath));

 hr = ADsGetObject(
             pszADsPath,
             IID_IADs,
             (void **)&pADs
             );

 if (FAILED(hr)) {

     printf("Failed to bind to object: %S\n", pszADsPath) ;
 }
 else {

     //
     // Dump the object
     //

     hr = DumpObject(pADs);

     if (FAILED(hr)) {

         printf("Unable to read properties of: %S\n", pszADsPath) ;
     }

     pADs->Release();
 }

error:

 FreeUnicodeString(pszADsPath);

 return (FAILED(hr) ? 1 : 0) ;
}

//
// Given an ADs pointer, dump the contents of the object
//

HRESULT
DumpObject(
 IADs * pADs
 )
{
 HRESULT hr;
HRESULT hrSA;
 IADs * pADsProp = NULL;
 VARIANT var;
ZeroMemory(&var,sizeof(var));
VARIANT *   pvarPropName = NULL;
 DWORD i = 0;
VARIANT varProperty;
 IDispatch * pDispatch = NULL;

 //
 // Access the schema for the object
 //

 hr = GetPropertyList(
             pADs,
             &var);
 BAIL_ON_FAILURE(hr);

 //
 // List the Properties
//
hr = SafeArrayAccessData(var.parray, (void **) &pvarPropName);
BAIL_ON_FAILURE(hr);

for (i = 0; i < var.parray->rgsabound[0].cElements; i++){

   //
     // Get a property and print it out. The HRESULT is passed to
     // PrintProperty.
     //

     hr = pADs->Get(
             pvarPropName[i].bstrVal,
             &varProperty
             );
   PrintProperty(
         pvarPropName[i].bstrVal,
         hr,
         varProperty
         );

}

hr = SafeArrayUnaccessData(var.parray);

error:
// Don't destroy hr in case we're here from BAIL_ON_FAILURE
if(var.parray) hrSA = SafeArrayDestroy(var.parray);

return(hr);
}


HRESULT
GetPropertyList(
 IADs * pADs,
 VARIANT * pvar )
{
 HRESULT hr= S_OK;
 BSTR bstrSchemaPath = NULL;
IADsClass * pADsClass = NULL;

 hr = pADs->get_Schema(&bstrSchemaPath);
 BAIL_ON_FAILURE(hr);

 hr = ADsGetObject(
             bstrSchemaPath,
             IID_IADsClass,
             (void **)&pADsClass);
 BAIL_ON_FAILURE(hr);

//Put SafeArray of bstr's into input variant struct
hr = pADsClass->get_MandatoryProperties(pvar);
BAIL_ON_FAILURE(hr);

error:
 if (bstrSchemaPath) {
     SysFreeString(bstrSchemaPath);
 }

 if (pADsClass) {
     pADsClass->Release();
 }

 return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\directry\main3.cxx ===
#include "main.hxx"

void main()
{
    IADsContainer   *pRootContainer;
    IADs      *pGlobal;
    IDispatch *pDispatchNewObject;
    IADs *pNewObject;
    HRESULT hr;


CoInitialize(NULL);

    //
    // Bind to the known container.
    //
    hr = ADsGetObject(TEXT("LDAP://RootDSE"),
    IID_IADs,
    (void**)&pGlobal);

    if (FAILED(hr)) {
            printf("GetObject failed, hr = %X\n", hr);
                return;
    } else {
            printf("Get Object Succeeded\n");

    }


    VARIANT varRootPath;
    hr = pGlobal->Get(L"defaultNamingContext", &varRootPath);

    if (FAILED(hr)) {
            printf("Get Root Path failed, hr = %X\n", hr);
                return;
    }

    WCHAR pszRootPath[500];

    wcscpy(pszRootPath, L"LDAP://");
    wcscat(pszRootPath, varRootPath.bstrVal);

    hr = ADsGetObject(pszRootPath,
            IID_IADsContainer,
            (void**)&pRootContainer);

    if (FAILED(hr)) {
            printf("Get Root Container Object failed, hr = %X\n", hr);
                return;
    }


    hr = pRootContainer->Create(L"IISServiceLocation", L"cn=TestName", &pDispatchNewObject);
    if (FAILED(hr)) {
            printf("Create new Object failed, hr = %X\n", hr);
                return;
    }

    //
    // Get IADs Interface From Container
    //
    hr = pDispatchNewObject->QueryInterface(IID_IADs, (void**)&pNewObject);

    if (FAILED(hr)) {
            printf("QI NewClass failed, hr = %X\n", hr);
                return;
    }

    hr = pNewObject->SetInfo();


    if (FAILED(hr)) {
            printf("SetInfo failed, hr = %X\n", hr);
    }


CoUninitialize();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\directry\schema.cxx ===
#include "main.hxx"

void main()
{
IADsContainer   *pGlobalContainer;
IADsContainer   *pSchemaContainer;
IDispatch        *pNewObject;
IADsUser        *pUser;
IADs      *pGlobal;
IADs *pSchema;
IDispatch *pDispatchNewClass;
IADs *pNewClass;
HRESULT hr;

CoInitialize(NULL);

//
// Bind to the known container.
//
hr = ADsGetObject(TEXT("LDAP://RootDSE"),
IID_IADsContainer,
(void**)&pGlobalContainer);

if (FAILED(hr)) {
    printf("GetObject failed, hr = %X\n", hr);
    return;
}


//
// Get IADs Interface From Container
//
hr = pGlobalContainer->QueryInterface(IID_IADs, (void**)&pGlobal);

if (FAILED(hr)) {
    printf("QI failed, hr = %X\n", hr);
    return;
}

VARIANT varSchemaPath;
hr = pGlobal->Get(L"schemaNamingContext", &varSchemaPath);

if (FAILED(hr)) {
    printf("Get Schema Path failed, hr = %X\n", hr);
    return;
}

WCHAR pszSchemaPath[500];

wcscpy(pszSchemaPath, L"LDAP://");
wcscat(pszSchemaPath, varSchemaPath.bstrVal);

hr = ADsGetObject(pszSchemaPath,
                  IID_IADsContainer,
                  (void**)&pSchemaContainer);

if (FAILED(hr)) {
    printf("Get Schema Object failed, hr = %X\n", hr);
    return;
}


hr = pSchemaContainer->Create(L"classSchema", L"cn=newClass", &pDispatchNewClass);
if (FAILED(hr)) {
    printf("Create new class failed, hr = %X\n", hr);
    return;
}

//
// Get IADs Interface From Container
//
hr = pDispatchNewClass->QueryInterface(IID_IADs, (void**)&pNewClass);

if (FAILED(hr)) {
    printf("QI NewClass failed, hr = %X\n", hr);
    return;
}

VARIANT varValue;

VariantInit(&varValue);
varValue.vt = VT_BSTR;
varValue.bstrVal = SysAllocString(L"IISServiceLocation");

hr = pNewClass->Put(L"cn", varValue);

if (FAILED(hr)) {
    printf("Put failed, hr = %X\n", hr);
}

VariantInit(&varValue);
varValue.vt = VT_BSTR;
varValue.bstrVal = SysAllocString(L"1.2.840.113556.1.5.7000.1908080808");

hr = pNewClass->Put(L"governsId", varValue);

if (FAILED(hr)) {
    printf("Put failed, hr = %X\n", hr);
}

VariantInit(&varValue);
varValue.vt = VT_I4;
varValue.lVal = 1;

hr = pNewClass->Put(L"objectClassCategory", varValue);

if (FAILED(hr)) {
    printf("Put failed, hr = %X\n", hr);
}
/*
hr = pNewClass.Put(L"subClassOf",L"device");

if (FAILED(hr)) {
    printf("Put failed, hr = %X\n", hr);
}

hr = pNewClass.Put(L"mustContain",L"networkAddress");

if (FAILED(hr)) {
    printf("Put failed, hr = %X\n", hr);
}
*/


VariantInit(&varValue);
varValue.vt = VT_BSTR;
varValue.bstrVal = SysAllocString(L"container");


hr = pNewClass->Put(L"possSuperiors", varValue);

if (FAILED(hr)) {
    printf("Put failed, hr = %X\n", hr);
}

hr = pNewClass->SetInfo();


if (FAILED(hr)) {
    printf("SetInfo failed, hr = %X\n", hr);
}

/*
//
// Create the new wrapper.
//
hr = pContainer->Create(TEXT("user"),
TEXT("Jane"),
&pNewObject);

if (FAILED(hr)) {
    printf("Create failed");
    return;
}

//
// Get the IADsUser interface from the wrapper.
//
pNewObject->QueryInterface(IID_IADsUser, (void**)&pUser);

//
// Write it back to the DS.
//
hr = pUser->SetInfo();

if (FAILED(hr)) {
    printf("SetInfo failed");
    return;
}

//
// Set Janes password.
//
hr = pUser ->SetPassword(TEXT("Argus"));
*/

CoUninitialize();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\directry\schema2.cxx ===
#include "main.hxx"


#include "main.hxx"

void main()
{
    IADsContainer   *pGlobalContainer;
    IADsContainer   *pSchemaContainer;
    IDispatch        *pNewObject;
    IADsUser        *pUser;
    IADs      *pGlobal;
    IADs *pSchema;
    IDispatch *pDispatchNewClass;
    IADs *pNewClass;
    HRESULT hr;

    CoInitialize(NULL);

    //
    // Bind to the known container.
    //
    hr = ADsGetObject(TEXT("LDAP://RootDSE"),
#ifdef USE_CONTAINER
    IID_IADsContainer,          // <--- This is presumptious, non?
    (void**)&pGlobalContainer);
#else
    IID_IADs,
    (void**)&pGlobal);
#endif

    if (FAILED(hr)) {
            printf("GetObject failed, hr = %X\n", hr);
                return;
    } else {
            printf("Get Object Succeeded\n");

    }


    //
    // Get IADs Interface From Container
    //
#ifdef USE_CONTAINER
    hr = pGlobalContainer->QueryInterface(IID_IADs, (void**)&pGlobal);

    if (FAILED(hr)) {
            printf("QI failed, hr = %X\n", hr);
                return;
    }
#else
// the preceding code was unnecessary since every ADs obj must
// implement the IADS interface.
#endif

    VARIANT varSchemaPath;
    hr = pGlobal->Get(L"schemaNamingContext", &varSchemaPath);

    if (FAILED(hr)) {
            printf("Get Schema Path failed, hr = %X\n", hr);
                return;
    }

    WCHAR pszSchemaPath[500];

    wcscpy(pszSchemaPath, L"LDAP://");
    wcscat(pszSchemaPath, varSchemaPath.bstrVal);

    hr = ADsGetObject(pszSchemaPath,
            IID_IADsContainer,
            (void**)&pSchemaContainer);

    if (FAILED(hr)) {
            printf("Get Schema Object failed, hr = %X\n", hr);
                return;
    }


    hr = pSchemaContainer->Create(L"classSchema", L"cn=IISServiceLocation", &pDispatchNewClass);
    if (FAILED(hr)) {
            printf("Create new class failed, hr = %X\n", hr);
                return;
    }

    //
    // Get IADs Interface From Container
    //
    hr = pDispatchNewClass->QueryInterface(IID_IADs, (void**)&pNewClass);

    if (FAILED(hr)) {
            printf("QI NewClass failed, hr = %X\n", hr);
                return;
    }

    VARIANT varValue;

    VariantInit(&varValue);
    varValue.vt = VT_BSTR;
    varValue.bstrVal = SysAllocString(L"IISServiceLocation");

    hr = pNewClass->Put(L"cn", varValue);

    if (FAILED(hr)) {
            printf("Put failed, hr = %X\n", hr);
    }

    VariantInit(&varValue);
    varValue.vt = VT_BSTR;
    varValue.bstrVal = SysAllocString(L"1.2.840.113556.1.5.7000.1209348");

    hr = pNewClass->Put(L"governsId", varValue);

    if (FAILED(hr)) {
            printf("Put failed, hr = %X\n", hr);
    }

    VariantInit(&varValue);
    varValue.vt = VT_I4;
    varValue.lVal = 1;

    hr = pNewClass->Put(L"objectClassCategory", varValue);

    if (FAILED(hr)) {
            printf("Put failed, hr = %X\n", hr);
    }

    VariantInit(&varValue);
    varValue.vt = VT_BSTR;
    varValue.bstrVal = SysAllocString(L"serviceAdministrationPoint");
    hr = pNewClass->Put(L"subClassOf", varValue);

    if (FAILED(hr)) {
            printf("Put failed, hr = %X\n", hr);
    }

    /*
    hr = pNewClass.Put(L"mustContain",L"networkAddress");

    if (FAILED(hr)) {
            printf("Put failed, hr = %X\n", hr);
    }
    */


    VariantInit(&varValue);
    varValue.vt = VT_BSTR;
    varValue.bstrVal = SysAllocString(L"container");


    hr = pNewClass->Put(L"possSuperiors", varValue);

    if (FAILED(hr)) {
            printf("Put failed, hr = %X\n", hr);
    }

    hr = pNewClass->SetInfo();


    if (FAILED(hr)) {
            printf("SetInfo failed, hr = %X\n", hr);
    }

    /*
    //
    // Create the new wrapper.
    //
    hr = pContainer->Create(TEXT("user"),
    TEXT("Jane"),
    &pNewObject);

    if (FAILED(hr)) {
            printf("Create failed");
                return;
    }

    //
    // Get the IADsUser interface from the wrapper.
    //
    pNewObject->QueryInterface(IID_IADsUser, (void**)&pUser);

    //
    // Write it back to the DS.
    //
    hr = pUser->SetInfo();

    if (FAILED(hr)) {
            printf("SetInfo failed");
                return;
    }

    //
    // Set Janes password.
    //
    hr = pUser ->SetPassword(TEXT("Argus"));
    */

    CoUninitialize();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\svcloc\directry\util.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Active Directory 1.0 Sample Code
//
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  util.cxx
//
//  Contents:  Ansi to Unicode conversions and misc helper functions
//
//----------------------------------------------------------------------------

#include "main.hxx"

//
// Local functions
//


int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == 0 )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    )
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == 0 ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //

    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength );
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}


LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) + sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            0
            );
    }

    return pUnicodeString;
}


void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{

    LocalFree(pUnicodeString);

    return;
}


//
// Misc helper functions for displaying data.
//


HRESULT
PrintVariant(
    VARIANT varPropData
    )
{
    HRESULT hr;
    BSTR bstrValue;

    switch (varPropData.vt) {
    case VT_I4:
        printf("%d", varPropData.lVal);
        break;
    case VT_BSTR:
        printf("%S", varPropData.bstrVal);
        break;

    case VT_BOOL:
        printf("%d", V_BOOL(&varPropData));
        break;

    case (VT_ARRAY | VT_VARIANT):
        PrintVariantArray(varPropData);
        break;

    case VT_DATE:
        hr = VarBstrFromDate(
                 varPropData.date,
                 LOCALE_SYSTEM_DEFAULT,
                 LOCALE_NOUSEROVERRIDE,
                 &bstrValue
                 );
        printf("%S", bstrValue);
        break;

    default:
        printf("Data type is %d\n", varPropData.vt);
        break;

    }
    printf("\n");
    return(S_OK);
}


HRESULT
PrintVariantArray(
    VARIANT var
    )
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;

    if(!((V_VT(&var) &  VT_VARIANT) &&  V_ISARRAY(&var))) {
        return(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }
        if (i < dwSUBound) {
            printf("%S, ", v.bstrVal);
        } else {
            printf("%S", v.bstrVal);
        }
    }
    return(S_OK);

error:
    return(hr);
}


HRESULT
PrintProperty(
    BSTR bstrPropName,
    HRESULT hRetVal,
    VARIANT varPropData
    )
{
    HRESULT hr = S_OK;

    switch (hRetVal) {

    case 0:
        printf("%-32S: ", bstrPropName);
        PrintVariant(varPropData);
        break;

    case E_ADS_CANT_CONVERT_DATATYPE:
        printf("%-32S: ", bstrPropName);
        printf("<Data could not be converted for display>\n");
        break;

    default:
        printf("%-32S: ", bstrPropName);
        printf("<Data not available>\n");
        break;

    }
    return(hr);
}

void
PrintUsage(
    void
    )
{
    printf("usage: adscmd [list|dump] <ADsPath>\n") ;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\atl\atlimpl.cpp ===
// This is a part of the ActiveX Template Library.
// Copyright (C) 1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// ActiveX Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// ActiveX Template Library product.

extern "C" {
 # include <windows.h>
};

# include "atlbase.h"
# include "atlcom.h"
# include "atlutil.h"


extern CComModule _Module;



#ifndef __ATLBASE_H__
	#error atlimpl.cpp requires atlbase.h to be included first
#endif

#pragma warning(disable: 4530) // no stack unwinding

/////////////////////////////////////////////////////////////////////////////
// CTypeInfoHolder

void CComTypeInfoHolder::AddRef()
{
	_Module.m_csTypeInfoHolder.Lock();
	m_dwRef++;
	_Module.m_csTypeInfoHolder.Unlock();
}

void CComTypeInfoHolder::Release()
{
	_Module.m_csTypeInfoHolder.Lock();
	if (--m_dwRef == 0)
	{
		if (m_pInfo)
			m_pInfo->Release();
		m_pInfo = NULL;
	}
	_Module.m_csTypeInfoHolder.Unlock();
}

HRESULT CComTypeInfoHolder::GetTI(LCID lcid, ITypeInfo** ppInfo)
{
	//If this assert occurs then most likely didn't call Init
	_ASSERTE(m_plibid != NULL && m_pguid != NULL);
	*ppInfo = m_pInfo;
	HRESULT hRes = S_OK;
	if (*ppInfo == NULL)
	{
		_Module.m_csTypeInfoHolder.Lock();
		if (m_pInfo == NULL)
		{
			CComPtr<ITypeLib> pTypeLib;
			hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
			if (SUCCEEDED(hRes))
				hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &m_pInfo);
		}
		*ppInfo = m_pInfo;
		_Module.m_csTypeInfoHolder.Unlock();
	}
	return hRes;
}

HRESULT CComTypeInfoHolder::GetTypeInfo(UINT /*itinfo*/, LCID lcid,
	ITypeInfo** pptinfo)
{
	HRESULT hRes = S_OK;
	if (pptinfo == NULL)
		hRes = E_POINTER;
	else
	{
		hRes = GetTI(lcid, pptinfo);
		if (*pptinfo)
			(*pptinfo)->AddRef();
	}
	return hRes;
}

HRESULT CComTypeInfoHolder::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
	UINT cNames, LCID lcid, DISPID* rgdispid)
{
	ITypeInfo* pInfo;;
	HRESULT hRes = GetTI(lcid, &pInfo);
	return (pInfo != NULL) ?
		pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid) : hRes;
}

HRESULT CComTypeInfoHolder::Invoke(IDispatch* p, DISPID dispidMember, REFIID /*riid*/,
	LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
	EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
	SetErrorInfo(0, NULL);
	ITypeInfo* pInfo;;
	HRESULT hRes = GetTI(lcid, &pInfo);
	return (pInfo != NULL) ?
		pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr) :
		hRes;
}
/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

HRESULT PASCAL CComObjectRoot::Error(const CLSID& clsid, HINSTANCE hInst,
	UINT nID, const IID& iid, HRESULT hRes)
{
	OLECHAR szDesc[1024];
	szDesc[0] = NULL;
	// For a valid HRESULT the id should be in the range [0x0200, 0xffff]
	_ASSERTE((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
	if (LoadStringW(hInst, nID, szDesc, 1024) == 0)
	{
		_ASSERTE(FALSE);
		wcscpy(szDesc, L"Unknown Error");
	}
	Error(clsid, szDesc, iid, hRes);
	if (hRes == 0)
		hRes = MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, nID);
	return hRes;
}

HRESULT PASCAL CComObjectRoot::Error(const CLSID& clsid, LPCSTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	USES_CONVERSION;
	return Error(clsid, A2CW(lpszDesc), iid, hRes);
}

HRESULT PASCAL CComObjectRoot::Error(const CLSID& clsid, LPCOLESTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	CComPtr<ICreateErrorInfo> pICEI;
	if (SUCCEEDED(CreateErrorInfo(&pICEI)))
	{
		CComPtr<IErrorInfo> pErrorInfo;
		pICEI->SetGUID(iid);
		LPOLESTR lpsz;
		ProgIDFromCLSID(clsid, &lpsz);
		if (lpsz != NULL)
			pICEI->SetSource(lpsz);
		CoTaskMemFree(lpsz);
		pICEI->SetDescription((LPOLESTR)lpszDesc);
		if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
			SetErrorInfo(0, pErrorInfo);
	}
	return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}

/////////////////////////////////////////////////////////////////////////////
// QI implementation

HRESULT PASCAL CComObjectRoot::InternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
{
	if (ppvObject == NULL)
		return E_POINTER;
	*ppvObject = NULL;
	if (InlineIsEqualGUID(iid, IID_IUnknown)) // use first interface
	{
		_ASSERTE(pEntries->m_flag == _ATL_INTMAP_ENTRY::offset);
			*ppvObject = (void*)((int)pThis+pEntries->dw);
			if (*ppvObject != NULL)
				((IUnknown*)(*ppvObject))->AddRef();
			return S_OK;
	}
	else
	{
		while (pEntries->piid != NULL)
		{
			if (InlineIsEqualGUID(*(pEntries->piid), iid))
			{
				switch(pEntries->m_flag)
				{
				case _ATL_INTMAP_ENTRY::offset:
					*ppvObject = (void*)((int)pThis+pEntries->dw);
					if (*ppvObject != NULL)
						((IUnknown*)(*ppvObject))->AddRef();
					return S_OK;
					break;
				case _ATL_INTMAP_ENTRY::creator:
					return ((_ATL_CREATORFUNC)pEntries->dw)((IUnknown*)pThis,
						iid, ppvObject);
					break;
				case _ATL_INTMAP_ENTRY::aggregate:
					IUnknown** p = (IUnknown**)((int)pThis + pEntries->dw);
					//if this assert fires you forgot to CoCreateInstance your aggregate
					_ASSERTE(*p != NULL);
					if (*p != NULL)
						return (*p)->QueryInterface(iid, ppvObject);
					break;
				}
			}
			pEntries++;
		}
	}
	return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// GetClassObject

void CComModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h)
{
	_ASSERTE(h != NULL);
	m_pObjMap = p;
	m_hInst = h;
	m_nLockCnt=0L;
	m_hHeap = NULL;
	_Module.m_csTypeInfoHolder.Init();
}

HRESULT CComModule::RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags)
{
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RegisterClassObject(dwClsContext, dwFlags);
		pEntry++;
	}
	return hRes;
}

HRESULT CComModule::RevokeClassObjects()
{
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RevokeClassObject();
		pEntry++;
	}
	return hRes;
}

HRESULT CComModule::GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	HRESULT hRes = S_OK;
	if (ppv == NULL)
		return E_POINTER;
	while (pEntry->pclsid != NULL)
	{
		if (InlineIsEqualGUID(rclsid, *pEntry->pclsid))
		{
			if (pEntry->pCF == NULL)
				hRes = pEntry->pFunc(NULL, riid, (LPVOID*)&pEntry->pCF);
			*ppv = pEntry->pCF;
			if (pEntry->pCF != NULL)
				hRes = pEntry->pCF->QueryInterface(riid, ppv);
			break;
		}
		pEntry++;
	}
	if (*ppv == NULL && hRes == S_OK)
		hRes = CLASS_E_CLASSNOTAVAILABLE;
	return hRes;
}

HRESULT CComModule::Term()
{
	_ASSERTE(m_hInst != NULL);
	if (m_pObjMap != NULL)
	{
		_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
		while (pEntry->pclsid != NULL)
		{
			if (pEntry->pCF != NULL)
				pEntry->pCF->Release();
			pEntry->pCF = NULL;
			pEntry++;
		}
	}
	_Module.m_csTypeInfoHolder.Term();
	if (m_hHeap != NULL)
		HeapDestroy(m_hHeap);
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT _ATL_OBJMAP_ENTRY::RegisterClassObject(DWORD dwClsContext, DWORD dwFlags)
{
	CComPtr<IUnknown> p;
	HRESULT hRes = pFunc(NULL, IID_IUnknown, (LPVOID*) &p);
	if (SUCCEEDED(hRes))
		hRes = CoRegisterClassObject(*pclsid, p, dwClsContext, dwFlags, &dwRegister);
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// CComClassFactoryBase

STDMETHODIMP CComClassFactoryBase::CreateInstance(LPUNKNOWN pUnkOuter,
	REFIID riid, void** ppvObj)
{
	if (ppvObj == NULL)
		return E_POINTER;
	*ppvObj = NULL;
	if ((pUnkOuter != NULL) && !InlineIsEqualGUID(riid, IID_IUnknown))
		return CLASS_E_NOAGGREGATION;
	else
		return implCreateInstance(pUnkOuter, riid, ppvObj);
}

STDMETHODIMP CComClassFactoryBase::LockServer(BOOL fLock)
{
	if (fLock)
		_Module.Lock();
	else
		_Module.Unlock();
	return S_OK;
}

#ifndef ATL_NOCONNPTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

BOOL CComDynamicArrayCONNECTDATA::Add(IUnknown* pUnk)
{
	if (m_nSize == 0) // no connections
	{
		m_cd.pUnk = pUnk;
		m_cd.dwCookie = (DWORD)pUnk;
		m_nSize = 1;
		return TRUE;
	}
	else if (m_nSize == 1)
	{
		//create array
		m_pCD = (CONNECTDATA*)malloc(sizeof(CONNECTDATA)*_DEFAULT_VECTORLENGTH);
		memset(m_pCD, 0, sizeof(CONNECTDATA)*_DEFAULT_VECTORLENGTH);
		m_pCD[0] = m_cd;
		m_nSize = _DEFAULT_VECTORLENGTH;
	}
	for (CONNECTDATA* p = begin();p<end();p++)
	{
		if (p->pUnk == NULL)
		{
			p->pUnk = pUnk;
			p->dwCookie = (DWORD)pUnk;
			return TRUE;
		}
	}
	int nAlloc = m_nSize*2;
	m_pCD = (CONNECTDATA*)realloc(m_pCD, sizeof(CONNECTDATA)*nAlloc);
	memset(&m_pCD[m_nSize], 0, sizeof(CONNECTDATA)*m_nSize);
	m_pCD[m_nSize].pUnk = pUnk;
	m_pCD[m_nSize].dwCookie = (DWORD)pUnk;
	m_nSize = nAlloc;
	return TRUE;
}

BOOL CComDynamicArrayCONNECTDATA::Remove(DWORD dwCookie)
{
	CONNECTDATA* p;
	if (dwCookie == NULL)
		return FALSE;
	if (m_nSize == 0)
		return FALSE;
	if (m_nSize == 1)
	{
		if (m_cd.dwCookie == dwCookie)
		{
			m_nSize = 0;
			return TRUE;
		}
		return FALSE;
	}
	for (p=begin();p<end();p++)
	{
		if (p->dwCookie == dwCookie)
		{
			p->pUnk = NULL;
			p->dwCookie = NULL;
			return TRUE;
		}
	}
	return FALSE;
}

STDMETHODIMP CComConnectionPointBase::GetConnectionInterface(IID* piid)
{
	if (piid == NULL)
		return E_POINTER;
	*piid = *m_piid;
	return S_OK;
}

STDMETHODIMP CComConnectionPointBase::GetConnectionPointContainer(IConnectionPointContainer** ppCPC)
{
	if (ppCPC == NULL)
		return E_POINTER;
	*ppCPC = m_pContainer;
	m_pContainer->AddRef();
	return S_OK;
}
#endif //!ATL_NOCONNPTS

/////////////////////////////////////////////////////////////////////////////
// statics

static UINT PASCAL AtlGetFileName(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax)
{
	_ASSERTE(lpszPathName != NULL);

	// always capture the complete file name including extension (if present)
	LPTSTR lpszTemp = (LPTSTR)lpszPathName;
	for (LPCTSTR lpsz = lpszPathName; *lpsz != '\0'; lpsz = CharNext(lpsz))
	{
		// remember last directory/drive separator
		if (*lpsz == '\\' || *lpsz == '/' || *lpsz == ':')
			lpszTemp = (LPTSTR)CharNext(lpsz);
	}

	// lpszTitle can be NULL which just returns the number of bytes
	if (lpszTitle == NULL)
		return lstrlen(lpszTemp)+1;

	// otherwise copy it into the buffer provided
	lstrcpyn(lpszTitle, lpszTemp, nMax);
	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// Object Registry Support

const TCHAR szProgID[] = _T("ProgID");
const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
const TCHAR szCLSID[] = _T("CLSID");
const TCHAR szLS32[] = _T("LocalServer32");
const TCHAR szIPS32[] = _T("InprocServer32");
const TCHAR szThreadingModel[] = _T("ThreadingModel");
const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
const TCHAR szApartment[] = _T("Apartment");
const TCHAR szBoth[] = _T("both");


static void PASCAL AtlRegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc)
{
	CRegKey keyProgID;
	keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID);
	keyProgID.SetValue(lpszUserDesc);
	keyProgID.SetKeyValue(szCLSID, lpszCLSID);
}

void _ATL_OBJMAP_ENTRY::UpdateRegistry(HINSTANCE hInst, HINSTANCE hInstResource)
{
	USES_CONVERSION;
	TCHAR szDesc[256];
	LoadString(hInstResource, nDescID, szDesc, 256);
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(hInst, szModule, _MAX_PATH);

	LPOLESTR lpOleStr;
	StringFromCLSID(*pclsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);

	AtlRegisterProgID(lpsz, lpszProgID, szDesc);
	AtlRegisterProgID(lpsz, lpszVerIndProgID, szDesc);

	CRegKey key;
	key.Open(HKEY_CLASSES_ROOT, szCLSID);
	key.Create(key, lpsz);
	if (dwFlags & CONTROLFLAG)
	{
		CRegKey x;
		x.Create(key, _T("Control"));
	}
	key.SetValue(szDesc);
	key.SetKeyValue(szProgID, lpszProgID);
	key.SetKeyValue(szVIProgID, lpszVerIndProgID);
	if ((hInst == NULL) || (hInst == GetModuleHandle(NULL))) // register as EXE
		key.SetKeyValue(szLS32, szModule);
	else
		key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32:szModule);
	DWORD dwThreadFlags = dwFlags & 3;
	if (dwThreadFlags == THREADFLAGS_APARTMENT)
		key.SetKeyValue(szIPS32, szApartment, szThreadingModel);
	else if (dwThreadFlags == THREADFLAGS_BOTH)
		key.SetKeyValue(szIPS32, szBoth, szThreadingModel);
	CoTaskMemFree(lpOleStr);
}

void _ATL_OBJMAP_ENTRY::RemoveRegistry()
{
	USES_CONVERSION;
	CRegKey key;
	key.Attach(HKEY_CLASSES_ROOT);
	key.RecurseDeleteKey(lpszProgID);
	key.RecurseDeleteKey(lpszVerIndProgID);
	LPOLESTR lpOleStr;
	StringFromCLSID(*pclsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);
	key.Open(key, szCLSID);
	key.RecurseDeleteKey(lpsz);
	CoTaskMemFree(lpOleStr);
}

/////////////////////////////////////////////////////////////////////////////
// CComModule

HRESULT CComModule::UpdateRegistry(BOOL bRegTypeLib)
{
	_ASSERTE(m_hInst != NULL);
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	while (pEntry->pclsid != NULL)
	{
		pEntry->UpdateRegistry(GetModuleInstance(), GetResourceInstance());
		pEntry++;
	}
	HRESULT hRes = S_OK;
	if (bRegTypeLib)
		hRes = RegisterTypeLib();
	return hRes;
}

HRESULT CComModule::RemoveRegistry()
{
	_ASSERTE(m_hInst != NULL);
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	while (pEntry->pclsid != NULL)
	{
		pEntry->RemoveRegistry();
		pEntry++;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// TypeLib Support

HRESULT CComModule::RegisterTypeLib()
{
	USES_CONVERSION;
	_ASSERTE(m_hInst != NULL);
	TCHAR szModule[_MAX_PATH+4];
	TCHAR szDir[_MAX_PATH];
	GetModuleFileName(GetTypeLibInstance(), szModule, _MAX_PATH);
	CComPtr<ITypeLib> pTypeLib;
	HRESULT hr = LoadTypeLib(T2OLE(szModule), &pTypeLib);
	if (!SUCCEEDED(hr))
	{
		// typelib not in module, try <module>.tlb instead
		LPTSTR lpszExt = szModule + lstrlen(szModule);
		for (LPTSTR lpsz = szModule; *lpsz != '\0'; lpsz = CharNext(lpsz))
		{
			if (*lpsz == '.')
				lpszExt = lpsz;
		}
		_ASSERTE(lpszExt != NULL);
		lstrcpy(lpszExt, _T(".tlb"));
		hr = LoadTypeLib(T2OLE(szModule), &pTypeLib);
	}
	if (SUCCEEDED(hr))
	{
		int nLen = lstrlen(szModule) - AtlGetFileName(szModule, NULL, 0);
		lstrcpy(szDir, szModule);
		szDir[nLen] = 0;
		return ::RegisterTypeLib(pTypeLib, T2OLE(szModule), T2OLE(szDir));
	}
	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CRegKey

void CRegKey::Close()
{
	if (m_hKey != NULL)
	{
		m_lLastRes = RegCloseKey(m_hKey);
		_ASSERTE(m_lLastRes == ERROR_SUCCESS);
		m_hKey = NULL;
	}
}

BOOL CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
	LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
	_ASSERTE(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey;
	m_lLastRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	Close();
	m_hKey = hKey;
	return (m_lLastRes == ERROR_SUCCESS);
}

BOOL CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
	_ASSERTE(hKeyParent != NULL);
	HKEY hKey=NULL;
	m_lLastRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	Close();
	m_hKey = hKey;
	return (m_lLastRes == ERROR_SUCCESS);
}

BOOL CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
	_ASSERTE(dwValue != NULL);
	DWORD dwType = NULL;
	DWORD dwCount = NULL;
	m_lLastRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)&dwValue, &dwCount);
	if (m_lLastRes == ERROR_SUCCESS)
	{
		_ASSERTE(dwType == REG_DWORD);
		_ASSERTE(dwCount == sizeof(DWORD));
		return TRUE;
	}
	return FALSE;
}

BOOL PASCAL CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	CRegKey key;
	if (!key.Create(hKeyParent, lpszKeyName))
		return FALSE;
	return key.SetValue(lpszValue, lpszValueName);
}

BOOL CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	CRegKey key;
	if (!key.Create(m_hKey, lpszKeyName))
		return FALSE;
	return key.SetValue(lpszValue, lpszValueName);
}

//RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
//specified key has subkeys
void CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
	CRegKey key;
	if (!key.Open(m_hKey, lpszKey))
		return;
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		key.RecurseDeleteKey(szBuffer);
		dwSize = 256;
	}
	key.Close();
	DeleteSubKey(lpszKey);
}

/////////////////////////////////////////////////////////////////////////////
// Minimize CRT
// Specify DllMain as EntryPoint
// Turn off exception handling
// Define _ATL_MINCRT

#ifdef _ATL_MINCRT
/////////////////////////////////////////////////////////////////////////////
// Heap Allocation

#ifndef _DEBUG

int _purecall()
{
	DebugBreak();
	return 0;
}

extern "C" const int _fltused = 0;

void* malloc(size_t n)
{
	if (_Module.m_hHeap == NULL)
	{
		_Module.m_hHeap = HeapCreate(0, 0, 0);
		if (_Module.m_hHeap == NULL)
			return NULL;
	}
	_ASSERTE(_Module.m_hHeap != NULL);

#ifdef _MALLOC_ZEROINIT
	void* p = HeapAlloc(_Module.m_hHeap, 0, n);
	if (p != NULL)
		memset(p, 0, n);
	return p;
#else
	return HeapAlloc(_Module.m_hHeap, 0, n);
#endif
}

void* calloc(size_t n, size_t s)
{
#ifdef _MALLOC_ZEROINIT
	return malloc(n * s);
#else
	void* p = malloc(n * s);
	if (p != NULL)
		memset(p, 0, n * s);
	return p;
#endif
}

void* realloc(void* p, size_t n)
{
	if (p == NULL)
		return malloc(n);

	_ASSERTE(_Module.m_hHeap != NULL);
	return HeapReAlloc(_Module.m_hHeap, 0, p, n);
}

void free(void* p)
{
	if (p == NULL)
		return;

	_ASSERTE(_Module.m_hHeap != NULL);
	HeapFree(_Module.m_hHeap, 0, p);
}

void* operator new(size_t n)
{
	return malloc(n);
}

void operator delete(void* p)
{
	free(p);
}

#endif

#endif //_ATL_MINCRT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\atl\atlbase.h ===
// This is a part of the ActiveX Template Library.
// Copyright (C) 1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// ActiveX Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// ActiveX Template Library product.

#ifndef __ATLBASE_H__
#define __ATLBASE_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#pragma warning(disable: 4201)  // nameless unions are part of C++
#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4512) // can't generate assignment operator (so what?)
#pragma warning(disable: 4514)  // unreferenced inlines are common
#pragma warning(disable: 4103) // pragma pack
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4237) // bool
#pragma warning(disable: 4710) // function couldn't be inlined

#include <windows.h>
#include <winnls.h>
#include <ole2.h>
#include <crtdbg.h>
#include <stddef.h>
#include <tchar.h>
#include <malloc.h>
#include <olectl.h>
#include <winreg.h>

#define _ATL_PACKING 8
#pragma pack(push, _ATL_PACKING)

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _ATL     1      // ActiveX Template Library
#define _ATL_VER 0x0100 // ActiveX Template Library version 1.00

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")
#pragma comment(lib, "olepro32.lib")
#pragma comment(lib, "uuid.lib")
#pragma comment(lib, "advapi32.lib")

class CComCriticalSection
{
public:
	void Lock() {EnterCriticalSection(&m_cs);}
	void Unlock() {LeaveCriticalSection(&m_cs);}
	void Init() {InitializeCriticalSection(&m_cs);}
	void Term() {DeleteCriticalSection(&m_cs);}
	CRITICAL_SECTION m_cs;
};

class CComFakeCriticalSection
{
public:
	void Lock() {}
	void Unlock() {}
	void Init() {}
	void Term() {}
};

class CComFreeThreadModel
{
public:
	static ULONG PASCAL Increment(LPLONG p) {return InterlockedIncrement(p);}
	static ULONG PASCAL Decrement(LPLONG p) {return InterlockedDecrement(p);}
	typedef CComCriticalSection ObjectCriticalSection;
	typedef CComCriticalSection GlobalsCriticalSection;
};

class CComApartmentThreadModel
{
public:
	static ULONG PASCAL Increment(LPLONG p) {return ++(*p);}
	static ULONG PASCAL Decrement(LPLONG p) {return --(*p);}
	typedef CComFakeCriticalSection ObjectCriticalSection;
	typedef CComCriticalSection GlobalsCriticalSection;
};

class CComSingleThreadModel
{
public:
	static ULONG PASCAL Increment(LPLONG p) {return ++(*p);}
	static ULONG PASCAL Decrement(LPLONG p) {return --(*p);}
	typedef CComFakeCriticalSection ObjectCriticalSection;
	typedef CComFakeCriticalSection GlobalsCriticalSection;
};

#if defined(_ATL_SINGLETHREAD)
	typedef CComSingleThreadModel CComThreadModel;
#elif defined(_ATL_APARTMENTTHREAD)
	typedef CComApartmentThreadModel CComThreadModel;
#else
	typedef CComFreeThreadModel CComThreadModel;
#endif

struct _ATL_OBJMAP_ENTRY;

class CComModule
{
public:
	void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h);
	LONG Lock() {return InterlockedIncrement(&m_nLockCnt);}
	LONG Unlock() {return InterlockedDecrement(&m_nLockCnt);}
	LONG GetLockCount() {return m_nLockCnt;}
	HINSTANCE GetModuleInstance() {return m_hInst;}
	HINSTANCE GetResourceInstance() {return m_hInst;}
	HINSTANCE GetTypeLibInstance() {return m_hInst;}
	HRESULT RegisterTypeLib();
	//HRESULT UnregisterTypeLib();
	HRESULT GetClassObject(REFCLSID rclsid, REFIID riid,
		LPVOID* ppv);
	HRESULT UpdateRegistry(BOOL bRegTypeLib = FALSE);
	HRESULT RemoveRegistry();
	HRESULT RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags);
	HRESULT RevokeClassObjects();
	HRESULT Term();

	HINSTANCE m_hInst;
	_ATL_OBJMAP_ENTRY* m_pObjMap;
	LONG m_nLockCnt;
	HANDLE m_hHeap;
	CComThreadModel::GlobalsCriticalSection m_csTypeInfoHolder;
};

/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
	CRegKey();
	~CRegKey();

// Attributes
public:
	operator HKEY() const;
	HKEY m_hKey;
	LONG m_lLastRes;

// Operations
public:
	BOOL SetValue(DWORD dwValue, LPCTSTR lpszValueName);
	BOOL QueryValue(DWORD& dwValue, LPCTSTR lpszValueName);
	BOOL SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	BOOL SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
	static BOOL PASCAL SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	BOOL Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPTSTR lpszClass = REG_NONE, DWORD dwOptions = REG_OPTION_NON_VOLATILE,
		REGSAM samDesired = KEY_ALL_ACCESS,
		LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
		LPDWORD lpdwDisposition = NULL);
	BOOL Open(HKEY hKeyParent, LPCTSTR lpszKeyName,
		REGSAM samDesired = KEY_ALL_ACCESS);
	void Close();
	HKEY Detach();
	void Attach(HKEY hKey);
	BOOL DeleteSubKey(LPCTSTR lpszSubKey);
	void RecurseDeleteKey(LPCTSTR lpszKey);
	BOOL DeleteValue(LPCTSTR lpszValue);
};

inline CRegKey::CRegKey()
{m_hKey = NULL;}

inline CRegKey::~CRegKey()
{Close();}

inline CRegKey::operator HKEY() const
{return m_hKey;}

inline BOOL CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
	_ASSERTE(m_hKey != NULL);
	m_lLastRes = RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
		(BYTE * const)&dwValue, sizeof(DWORD));
	return (m_lLastRes == ERROR_SUCCESS);
}

inline BOOL CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(m_hKey != NULL);
	m_lLastRes = RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
		(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
	return (m_lLastRes == ERROR_SUCCESS);
}

inline HKEY CRegKey::Detach()
{
	HKEY hKey = m_hKey;
	m_hKey = NULL;
	return hKey;
}

inline void CRegKey::Attach(HKEY hKey)
{
	_ASSERTE(m_hKey == NULL);
	m_hKey = hKey;
}

inline BOOL CRegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
	_ASSERTE(m_hKey != NULL);
	m_lLastRes = RegDeleteKey(m_hKey, lpszSubKey);
	return (m_lLastRes==ERROR_SUCCESS);
}

inline BOOL CRegKey::DeleteValue(LPCTSTR lpszValue)
{
	_ASSERTE(m_hKey != NULL);
	m_lLastRes = RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
	return (m_lLastRes==ERROR_SUCCESS);
}

// Make sure MFC's afxpriv.h hasn't already been loaded to do this
#ifndef USES_CONVERSION
#ifndef _DEBUG
#define USES_CONVERSION int _convert; _convert
#else
#define USES_CONVERSION int _convert = 0
#endif

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

inline LPWSTR PASCAL AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	_ASSERTE(lpa != NULL);
	_ASSERTE(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	return lpw;
}

inline LPSTR PASCAL AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	_ASSERTE(lpw != NULL);
	_ASSERTE(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
}

#define A2W(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : (\
		_convert = (lstrlenA(lpa)+1),\
		AtlA2WHelper((LPWSTR) alloca(_convert*2), lpa, _convert)))

#define W2A(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : (\
		_convert = (wcslen(lpw)+1)*2,\
		AtlW2AHelper((LPSTR) alloca(_convert), lpw, _convert)))

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline size_t ocslen(LPCOLESTR x) { return wcslen(x); }
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return wcscpy(dest, src); }
	inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
	inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
	inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
	inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline size_t ocslen(LPCOLESTR x) { return strlen(x); }
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return strcpy(dest, src); }
	inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
	inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
	inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
	inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
#else
	inline size_t ocslen(LPCOLESTR x) { return wcslen(x); }
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return wcscpy(dest, src); }
	#define T2COLE(lpa) A2CW(lpa)
	#define T2OLE(lpa) A2W(lpa)
	#define OLE2CT(lpo) W2CA(lpo)
	#define OLE2T(lpo) W2A(lpo)
#endif

#ifdef OLE2ANSI
	#define A2OLE(x) x
	#define W2OLE W2A
	#define OLE2A(x) x
	#define OLE2W A2W
#else
	#define A2OLE A2W
	#define W2OLE(x) (x)
	#define OLE2A W2A
	#define OLE2W(x) x
#endif

#ifdef _UNICODE
	#define T2A W2A
	#define A2T A2W
	#define T2W(x)  (x)
	#define W2T(x)  (x)
#else
	#define T2W A2W
	#define W2T W2A
	#define T2A(x)  (x)
	#define A2T(x)  (x)
#endif

#endif //!USES_CONVERSION

#pragma pack(pop)

#endif // __ATLBASE_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\atl\atlutil.h ===
// This is a part of the ActiveX Template Library.
// Copyright (C) 1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// ActiveX Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// ActiveX Template Library product.

#ifndef __ATLUTIL_H__
#define __ATLUTIL_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#pragma pack(push, _ATL_PACKING)

/////////////////////////////////////////////////////////////////////////////
// CComBSTR

class CComBSTR
{
public:
	BSTR m_str;
	CComBSTR() { m_str = NULL;}
	CComBSTR(int nSize)
	{
		m_str = ::SysAllocStringLen(NULL, nSize);
	}
	CComBSTR(LPCWSTR pSrc)
	{
		m_str = ::SysAllocString(pSrc);
	}
	CComBSTR(LPCSTR pSrc)
	{
		USES_CONVERSION;
		m_str = ::SysAllocString(A2OLE(pSrc));
	}
	CComBSTR& operator=(const CComBSTR& src)
	{
		if (this == &src)
			return *this;

		if (m_str)
			::SysFreeString(m_str);

		m_str = ::SysAllocStringLen(src.m_str, SysStringLen(src.m_str));
		return *this;
	}
	CComBSTR& operator=(LPCWSTR pSrc)
	{
		if (m_str)
			::SysFreeString(m_str);

		m_str = ::SysAllocString(pSrc);
		return *this;
	}
	CComBSTR& operator=(LPCSTR pSrc)
	{
		USES_CONVERSION;
		if (m_str)
			::SysFreeString(m_str);

		m_str = ::SysAllocString(A2OLE(pSrc));
		return *this;
	}
	~CComBSTR()
	{
		if (m_str)
			::SysFreeString(m_str);
	}
	operator BSTR()
	{
		return m_str;
	}
	BSTR Copy()
	{
		return ::SysAllocStringLen(m_str, SysStringLen(m_str));
	}
	void Attach(BSTR src)
	{
		if (m_str)
			::SysFreeString(m_str);
		m_str = src;
	}
	BSTR Detach()
	{
		BSTR s = m_str;
		m_str = NULL;
		return s;
	}
	operator int()
	{
		if (m_str)
			return ::SysStringLen(m_str);
		return 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CComVariant

class CComVariant : public tagVARIANT
{
public:
	CComVariant() {VariantInit(this);}
	~CComVariant() {VariantClear(this);}
	CComVariant(VARIANT& var)
	{
		VariantInit(this);
		VariantCopy(this, &var);
	}
	CComVariant(LPOLESTR lpsz)
	{
		VariantInit(this);
		vt = VT_BSTR;
		bstrVal = SysAllocString(lpsz);
	}
	CComVariant(const CComVariant& var)
	{
		VariantInit(this);
		VariantCopy(this, (VARIANT*)&var);
	}
	CComVariant& operator=(const CComVariant& var)
	{
		VariantCopy(this, (VARIANT*)&var);
		return *this;
	}
	CComVariant& operator=(VARIANT& var)
	{
		VariantCopy(this, &var);
		return *this;
	}
	CComVariant& operator=(LPOLESTR lpsz)
	{
		VariantClear(this);
		vt = VT_BSTR;
		bstrVal = SysAllocString(lpsz);
		return *this;
	}
};


#pragma pack(pop)

#endif // __ATLUTIL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\cisatest\cisatest.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       cisatest.cpp

   Abstract:
       This module defines the Test ISAPI DLL for driving ComIsapi
 
   Author:

       Murali R. Krishnan    ( MuraliK )     27-Aug-1996 

   Project:

       Internet Application Server DLL

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include <objbase.h>
#include <iisext.h>
#include <assert.h>
#include <vipapi.h>

#define IID_DEFINED

#include <txctx.h>
#include <txctx_i.c>

#include "cisa_i.c"
#include "cisa.h"
#include "cpecb_i.c"
#include "cpecb.h"

# include "dbgutil.h"


/************************************************************
 *     Prototypes
 ************************************************************/
HRESULT IsapiToComisapi(EXTENSION_CONTROL_BLOCK* pECB, DWORD* pdwRet);
HRESULT CreateIsapiInstance( ITransactionContextEx * *,
                             IComIsapi * *  ppComIsapi,
                             IcpECB **      ppIcpECB);

/************************************************************
 *     Variable Declarations
 ************************************************************/
# ifdef COINIT_NOEX
static DWORD g_dwTLSIndex = (DWORD)-1;    // COM initialization flag
# endif // COINIT_NOEX

BOOL   g_fComInit = FALSE;

IComIsapi * g_pComIsapi = NULL;
IcpECB    * g_pIcpECB = NULL;
ITransactionContextEx * g_pTxContext = NULL;

DECLARE_DEBUG_PRINTS_OBJECT();                  
DECLARE_DEBUG_VARIABLE();


CRITICAL_SECTION  g_csInit;
BOOL g_fInitSink = FALSE;


/************************************************************
 *     Functions
 ************************************************************/

// functions

//    DllMain
//    Note IIS thread pools so we won't reliably get DLL_THREAD_ATTACH
//    messages.  Avoid problems by acquiring all resources on
//  DLL_PROCESS_ATTACH and deallocating on DLL_PROCESS_DETACH.
//
BOOL WINAPI DllMain(
                    HINSTANCE    hinstDll,
                    DWORD        fdwReason,
                    LPVOID        lpvContext)
{
    HRESULT hr;

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH: {
        
        CREATE_DEBUG_PRINT_OBJECT( "cisatest");
        if ( !VALID_DEBUG_PRINT_OBJECT()) { 
            return ( FALSE);
        }
        SET_DEBUG_FLAGS( DEBUG_OBJECT | DEBUG_IID | DEBUG_ERROR);

        InitializeCriticalSection( & g_csInit);

#ifdef COINIT_NOEX
        // allocate thread local storage
        if ((g_dwTLSIndex = TlsAlloc()) == -1)
            return FALSE;

# else
        hr = CoInitializeEx( NULL, 
                             (COINIT_MULTITHREADED | 
                              COINIT_DISABLE_OLE1DDE |
                              COINIT_SPEED_OVER_MEMORY)
                             );
        g_fComInit = (hr == S_OK);

        DBGPRINTF(( DBG_CONTEXT, 
                    "\tCoInitializeEx( NULL, %08x) returns %08x\n",
                    (COINIT_MULTITHREADED | 
                     COINIT_DISABLE_OLE1DDE |
                     COINIT_SPEED_OVER_MEMORY),
                    hr
                    ));
# endif // ifndef COINIT_NOEX

        // IIS thread pools, we don't want thread notifications
        DisableThreadLibraryCalls(hinstDll);
        break;
    }
    
    case DLL_PROCESS_DETACH:

#ifdef COINIT_NOEX 
        if (g_dwTLSIndex != -1)
            TlsFree(g_dwTLSIndex);
# else 
        if (g_pComIsapi) {
            g_pComIsapi->Release();
        }

        if ( g_fComInit) { 
            CoUninitialize();
        }
# endif // COINIT_NOEX

        DeleteCriticalSection( & g_csInit);

        DELETE_DEBUG_PRINT_OBJECT();
        break;
    }
    
    return TRUE;
} // DllMain()




//    GetExtensionVerion
//    Standard versioning entry point from IIS.
//
BOOL WINAPI
GetExtensionVersion(HSE_VERSION_INFO* pVer)
{
    HRESULT hr;
    pVer->dwExtensionVersion = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

    strncpy(pVer->lpszExtensionDesc, "Test IsapiToComisapi", 
            HSE_MAX_EXT_DLL_NAME_LEN);

#ifdef CACHE_INSTANCE 
    
#ifdef COINIT_NOEX
    // Initialize COM
    // FIX: need to uninitialize but thread detach a problem
    if (TlsGetValue(g_dwTLSIndex) == FALSE) {
        hr = CoInitialize(NULL);
        if (!SUCCEEDED(hr)) goto Err;
        TlsSetValue(g_dwTLSIndex, (void*)TRUE);
    }
# endif // COINIT_NOEX

    hr = CreateIsapiInstance( &g_pTxContext, &g_pComIsapi, &g_pIcpECB);
    if (!SUCCEEDED(hr)) goto Err;

Err:
    DBGPRINTF(( DBG_CONTEXT,
                "g_fComInit=%d;"
                "CreateInstance returns hr=%08x;"
                "pComIsapi=%08x; pIcpECB=%08x\n"
                ,
                g_fComInit,
                hr, 
                g_pComIsapi,
                g_pIcpECB));
    
#else 
    hr = S_OK;
#endif // !CACHE_INSTANCE    

    return (hr == S_OK) ? TRUE : FALSE;
} // GetExtensionVersion()




BOOL WINAPI
TerminateExtension( IN DWORD dwFlags)
{
    DBGPRINTF(( DBG_CONTEXT, "TerminateExtension (%08x)\n", dwFlags));
    if (g_pComIsapi) {
        g_pComIsapi->Release();
        g_pComIsapi = NULL;
    }

    DBGPRINTF(( DBG_CONTEXT, "Cleaned up g_pComIsapi\n"));

    if (g_pIcpECB) {
        g_pIcpECB->Release();
        g_pIcpECB = NULL;
    }

    DBGPRINTF(( DBG_CONTEXT, "Cleaned up g_pIcpECB\n"));

#ifndef COINIT_NOEX
    if ( g_fComInit) { 
        CoUninitialize();
        g_fComInit = FALSE;
    }
# endif // COINIT_NOEX

    DBGPRINTF(( DBG_CONTEXT, "Cleaned up COM\n"));

    return ( TRUE);
} // TerminateExtension()




//    HttpExtensionProc
//    Standard invocation entry point from IIS.
//
DWORD WINAPI
HttpExtensionProc( EXTENSION_CONTROL_BLOCK* pECB)
{
    DWORD dwRet;
    
    try {
        if (!SUCCEEDED(IsapiToComisapi(pECB, &dwRet)))
            dwRet = HSE_STATUS_ERROR;                
    }
    catch(...) {
        DBG_ASSERT(FALSE);
        dwRet = HSE_STATUS_ERROR;
    }
    
    return dwRet;
} // HttpExtensionProc()



HRESULT
CreateIsapiInstance( ITransactionContextEx * * ppTxContext, 
                     IComIsapi * *  ppComIsapi,
                     IcpECB **      ppIcpECB)
{
    HRESULT hr;

# ifdef VIPER
    // Get a Viper transaction context object (should only do once)
    hr = CoCreateInstance(CLSID_TransactionContextEx, NULL,
                          CLSCTX_SERVER, 
                          IID_ITransactionContextEx, (void**)ppTxContext);
    if (!SUCCEEDED(hr)) goto Err;
# endif

    // Get the clsid for this ISAPI DLL
    CLSID clsidISAPIDLL;
    hr = CLSIDFromProgID(L"MSCISA_FOO.DLL", &clsidISAPIDLL);
    if (!SUCCEEDED(hr)) goto Err;
    
#ifndef VIPER
    hr = CoCreateInstance(clsidISAPIDLL, NULL,
                          CLSCTX_SERVER, IID_IComIsapi, 
                          (void ** ) ppComIsapi);
#else
    // Create the COMISAPI instance that wraps the ISAPI DLL
    hr = (*ppTxContext)->CreateInstance(clsidISAPIDLL, IID_IComIsapi, 
                                        (void**)ppComIsapi);
# endif NO_VIPER
    if (!SUCCEEDED(hr)) goto Err;
        
    // Wrap the ECB in a Viper context property
    hr = CoCreateInstance(CLSID_cpECB, NULL, CLSCTX_SERVER, 
                          IID_IcpECB, (void**) ppIcpECB);
    if (!SUCCEEDED(hr)) goto Err;

Err:
    if (!SUCCEEDED(hr)) {
        
#ifdef VIPER
        if (*ppTxContext) {
            (*ppTxContext)->Release();
            *ppTxContext = NULL;
        }
#endif // VIPER

        if ( *ppComIsapi) {
            (*ppComIsapi)->Release();
            *ppComIsapi = NULL;
        }

        if ( *ppIcpECB) {
            (*ppIcpECB)->Release();
            *ppIcpECB = NULL;
        }
    }

    return ( hr);
    
} // CreateIsapiInstance()



//    IsapiToComisapi
//    Invoke the ISAPI DLL as a COMISAPI component
//
HRESULT 
IsapiToComisapi(EXTENSION_CONTROL_BLOCK* pECB, DWORD* pdwRet)
{ 
    HRESULT hr = S_OK;
    IComIsapi* pComIsapi = NULL;
    ITransactionContextEx * pTxContext = NULL;
    IcpECB* pcpECB = NULL;

    IN_CISA_WIRE_ECB  ince;
    OUT_CISA_WIRE_ECB outce;
        
# ifdef COINIT_NOEX
    // Initialize COM
    // FIX: need to uninitialize but thread detach a problem
    if (TlsGetValue(g_dwTLSIndex) == FALSE) {
        hr = CoInitialize(NULL);
        if (!SUCCEEDED(hr)) goto Err;
        TlsSetValue(g_dwTLSIndex, (void*)TRUE);
    }
# endif // COINIT_NOEX

#ifdef CACHE_INSTANCE 
    DBG_ASSERT( NULL != g_pComIsapi);
    g_pComIsapi->AddRef();
    pComIsapi = g_pComIsapi;

    DBG_ASSERT( NULL != g_pIcpECB);
    g_pIcpECB->AddRef();
    pcpECB = g_pIcpECB;


# ifdef VIPER
    g_pTxContext->AddRef();
    pTxContext = g_pTxContext;
# endif 

#else 
    hr = CreateIsapiInstance( &pTxContext, &pComIsapi, &pcpECB);

#endif // CACHE_INSTANCE

    if (!SUCCEEDED(hr)) goto Err;

    // call the SetECB only for non-cached IcpECB, 
    //  provided the cached g_IcpECB is build properly
    //  NYI: The cached ECB does not have proper function pointers set
    //  so we call SetECB() now which smartly initializes only once!
    //
    hr = pcpECB->SetECB(sizeof(EXTENSION_CONTROL_BLOCK),
                        (unsigned char*)pECB);

    if (!SUCCEEDED(hr)) goto Err;


#ifdef CACHE_INSTANCE 

    if ( !g_fInitSink) {
        
        EnterCriticalSection( &g_csInit);
        if ( !g_fInitSink) {
            
            hr = pComIsapi->SetIsapiSink( pcpECB);
            g_fInitSink = ( hr == S_OK);

            DBGPRINTF(( DBG_CONTEXT,
                        " pComIsapi(%08x)->SetIsapiSink(%08x) => hr = %08x\n",
                        pComIsapi, pcpECB, hr
                        ));
        }

        LeaveCriticalSection( &g_csInit);
    }
    if (!SUCCEEDED(hr)) goto Err;

#endif // !CACHE_INSTANCE    


#ifdef WIRE_ECB 

    ince.ConnID           = (DWORD ) pECB->ConnID;
    ince.lpszMethod       = pECB->lpszMethod;
    ince.lpszQueryString  = pECB->lpszQueryString;
    ince.lpszPathInfo     = pECB->lpszPathInfo;
    ince.lpszPathXlated   = pECB->lpszPathTranslated;
    ince.lpszContentType  = pECB->lpszContentType;
    ince.cbTotalBytes     = pECB->cbTotalBytes;
    
    //
    //  Clients can send more bytes then are indicated in their
    //  Content-Length header.  Adjust byte counts so they match
    //
    
    ince.cbAvailable      = pECB->cbAvailable;
    // The following is broken for now :-( -- no additional data
    //    ince.lpbData          = pECB->lpbData;
    
    outce.dwHseStatus     = HSE_STATUS_SUCCESS;
    outce.dwHttpStatusCode= pECB->dwHttpStatusCode;
    outce.cbLogData       = 0;
    // following copy of lpchLogData is not required during invocation
    //  we will copy the contents on return
    // outce.lpchLogData     = (CHAR *) pECB->lpszLogData;
#endif // WIRE_ECB
        
    // Invoke the wrapped ISAPI DLL
    hr = pComIsapi->HttpExtensionProc(&ince,
                                      &outce);
    *pdwRet = outce.dwHseStatus;

# ifdef WIRE_ECB
    // Copy the output parameters to the ECB block 
    if ( SUCCEEDED(hr)) {

        pECB->dwHttpStatusCode = outce.dwHttpStatusCode;
        // We will not support the log data now :-(
        // memcpy( pECB->lpszLogData, outce.lpchLogData, outce.cbLogData);
    }
# endif // WIRE_ECB

        
Err:
    if ( !SUCCEEDED(hr)) {

        CHAR pchBuff[1000];
        wsprintf( pchBuff,
                  "\nCisaTest:[%d]"
                  "IsapiToComIsapi Failed. hr=%08x. pcpECB=%08x;"
                  "pComIsapi=%08x; pTxContext = %08x\n"
                  ,
                  GetCurrentThreadId(),
                  hr, pcpECB, pComIsapi, pTxContext);
        OutputDebugString(pchBuff);
    }
    // Release resources
    if (pcpECB) {
        pcpECB->Release();
    }

    if (pComIsapi) {
        pComIsapi->Release();
    }

    if (pTxContext) {
        pTxContext->Release();
    }
        
    return hr;
} // IsapiToComisapi()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\atl\atlcom.h ===
// This is a part of the ActiveX Template Library.
// Copyright (C) 1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// ActiveX Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// ActiveX Template Library product.

#ifndef __ATLCOM_H__
#define __ATLCOM_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlcom.h requires atlbase.h to be included first
#endif

#pragma pack(push, _ATL_PACKING)

inline BOOL InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
	  ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
	  ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
	  ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
	  ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}

/////////////////////////////////////////////////////////////////////////////
// Smart OLE pointers provide automatic AddRef/Release
// CComPtr<IFoo> p;

template <class T>
class CComPtr
{
public:
	CComPtr() {p=NULL;}
	CComPtr(T* p_){Init(p_);}
	~CComPtr() { Release(); }
	void Release() {if (p) p->Release();}
	void Init(LPUNKNOWN lp) {if ((p = lp) != NULL) p->AddRef();}
	LPUNKNOWN Assign(LPUNKNOWN lp);
	operator T*() { return (T*)p; }
	operator int() { return (int)p;}
	T& operator*() { _ASSERTE(p!=NULL); return *(T*)p; }
	T** operator&() {Release(); p = NULL; return (T**)&p; }
	T* operator->() { _ASSERTE(p!=NULL); return (T*)p; }
	T* operator=(T* p_) { return (T*)Assign(p_);}
protected:
	LPUNKNOWN p;
};

template <class T>
LPUNKNOWN CComPtr<T>::Assign(LPUNKNOWN lp)
{
	if (lp != NULL)
		lp->AddRef();
	if (p)
		p->Release();
	p = lp;
	return p;
}

/////////////////////////////////////////////////////////////////////////////
// COM Objects

typedef HRESULT (PASCAL *_ATL_CREATORFUNC)(LPUNKNOWN pUnk, REFIID riid, LPVOID* ppv);

template <class T1>
class CComSimpleCreator
{
public:
	static HRESULT PASCAL CreateInstance(LPUNKNOWN pUnk, REFIID riid, LPVOID* ppv)
	{
		T1* p = new T1(pUnk);
		HRESULT hRes = p->QueryInterface(riid, ppv);
		if (hRes != S_OK)
			delete p;
		return hRes;
	}
};

template <class T1>
class CComNoAggCreator
{
public:
	static HRESULT PASCAL CreateInstance(LPUNKNOWN pUnk, REFIID riid, LPVOID* ppv)
	{
		if (pUnk == NULL)
		{
			T1* p = new T1;
			HRESULT hRes = p->QueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
			return hRes;
		}
		else
		{
			*ppv = NULL;
			return CLASS_E_NOAGGREGATION;
		}
	}
};

template <class T1, class T2>
class CComAggCreator
{
public:
	static HRESULT PASCAL CreateInstance(LPUNKNOWN pUnk, REFIID riid, LPVOID* ppv)
	{
		if (pUnk == NULL)
		{
			T1* p = new T1;
			HRESULT hRes = p->QueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
			return hRes;
		}
		else
		{
			T2* p = new T2(pUnk);
			HRESULT hRes = p->QueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
			return hRes;
		}
	}
};

#define DECLARE_NOT_AGGREGATABLE(x) public:\
	typedef CComNoAggCreator< CComObject<x> > _CreatorClass;
#define DECLARE_AGGREGATABLE(x) public:\
	typedef CComAggCreator< CComObject<x>, CComAggObject<x> > _CreatorClass;

struct _ATL_INTMAP_ENTRY
{
	const IID* piid;       // the interface id (IID) (NULL for aggregate)
	DWORD dw;
	enum Flags {offset, creator, aggregate} m_flag;
};

#define BEGIN_COM_MAP(x) public:\
	typedef x _atl_classtype;\
	HRESULT _InternalQueryInterface(REFIID iid, void** ppvObject)\
	{return InternalQueryInterface(this, _GetEntries(), iid, ppvObject);}\
	const _ATL_INTMAP_ENTRY* _GetEntries() {\
	static const _ATL_INTMAP_ENTRY _entries[] = {

#define COM_INTERFACE_ENTRY(x) {&IID_##x, (DWORD)((x*)((_atl_classtype*)8))-8, _ATL_INTMAP_ENTRY::offset},
#define COM_INTERFACE_ENTRY_IID(iid, x) {&iid, (DWORD)((x*)((_atl_classtype*)8))-8, _ATL_INTMAP_ENTRY::offset},
#define COM_INTERFACE_ENTRY2(x, x2) {&IID_##x, (DWORD)((x*)(x2*)((_atl_classtype*)8))-8, _ATL_INTMAP_ENTRY::offset},
#define COM_INTERFACE_ENTRY2_IID(iid, x, x2) {&iid, (DWORD)((x*)(x2*)((_atl_classtype*)8))-8, _ATL_INTMAP_ENTRY::offset},
#define COM_INTERFACE_ENTRY_TEAR_OFF(iid, x) {&iid, (DWORD)(_ATL_CREATORFUNC)CComSimpleCreator< CComTearOffObject<x, _atl_classtype> >::CreateInstance, _ATL_INTMAP_ENTRY::creator},
#define COM_INTERFACE_ENTRY_AGGREGATE(iid, punk) {&iid, (DWORD)offsetof(_atl_classtype, punk), _ATL_INTMAP_ENTRY::aggregate},
#define END_COM_MAP()   {NULL, 0, _ATL_INTMAP_ENTRY::offset}};\
	return _entries;}

struct _ATL_OBJMAP_ENTRY
{
	const CLSID* pclsid;
	_ATL_CREATORFUNC pFunc;
	LPCTSTR lpszProgID;
	LPCTSTR lpszVerIndProgID;
	UINT nDescID;
	DWORD dwFlags;
	IClassFactory* pCF;
	DWORD dwRegister;   // cookie returned by CoRegisterClassObject
//Methods
	void UpdateRegistry(HINSTANCE hInst, HINSTANCE hInstResource);
	void RemoveRegistry();
	HRESULT RegisterClassObject(DWORD dwClsContext, DWORD dwFlags);
	HRESULT RevokeClassObject()
	{return dwRegister ? CoRevokeClassObject(dwRegister) : E_INVALIDARG;}
};

#define BEGIN_OBJECT_MAP(x) static _ATL_OBJMAP_ENTRY x[] = {
#define RAWOBJECT_ENTRY(iid, pf, p1, p2, id, dw) {&iid, pf, _T(p1), _T(p2), id, dw, NULL, (DWORD)0},
#define END_OBJECT_MAP()   {NULL, 0}};

#if defined(_WINDLL) | defined(_USRDLL)
#define OBJECT_ENTRY(iid, class, p1, p2, id, dw) {&iid, (_ATL_CREATORFUNC)&(CComNoAggCreator< CComObject< CComClassFactory<class> > >::CreateInstance), _T(p1), _T(p2), id, dw, NULL, (DWORD)0},
#define FACTORYOBJECT_ENTRY(iid, factory, p1, p2, id, dw) {&iid, (_ATL_CREATORFUNC)&(CComNoAggCreator< CComObject< factory > >::CreateInstance), _T(p1), _T(p2), id, dw, NULL, (DWORD)0},
#else
// don't let class factory refcount influence lock count
#define OBJECT_ENTRY(iid, class, p1, p2, id, dw) {&iid, (_ATL_CREATORFUNC)&(CComNoAggCreator< CComObjectNoLock< CComClassFactory<class> > >::CreateInstance), _T(p1), _T(p2), id, dw, NULL, (DWORD)0},
#define FACTORYOBJECT_ENTRY(iid, factory, p1, p2, id, dw) {&iid, (_ATL_CREATORFUNC)&(CComNoAggCreator< CComObjectNoLock< factory > >::CreateInstance), _T(p1), _T(p2), id, dw, NULL, (DWORD)0},
#endif

#define THREADFLAGS_APARTMENT 0x1
#define THREADFLAGS_BOTH 0x2
#define AUTPRXFLAG 0x4
#define CONTROLFLAG 0x8

// the functions in this class don't need to be virtual because
// they are called from CComObject
class CComObjectRoot
{
public:

	CComObjectRoot() {m_dwRef = 0L;}
	void FinalConstruct() {}

	ULONG InternalAddRef() {return CComThreadModel::Increment(&m_dwRef);}
	ULONG InternalRelease()
	{
		if (m_dwRef == 0)
			return 0;
		return CComThreadModel::Decrement(&m_dwRef);
	}
	static HRESULT PASCAL InternalQueryInterface(void* pThis,
		const _ATL_INTMAP_ENTRY* entries, REFIID iid, void** ppvObject);
//Outer funcs
	ULONG OuterAddRef() {return m_pOuterUnknown->AddRef();}
	ULONG OuterRelease() {return m_pOuterUnknown->Release();}
	HRESULT OuterQueryInterface(REFIID iid, void ** ppvObject)
	{return m_pOuterUnknown->QueryInterface(iid, ppvObject);}

	static HRESULT PASCAL Error(const CLSID& clsid, LPCOLESTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0);
	static HRESULT PASCAL Error(const CLSID& clsid, LPCSTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0);
	static HRESULT PASCAL Error(const CLSID& clsid, HINSTANCE hInst,
		UINT nID, const IID& iid, HRESULT hRes = 0);

protected:
	union
	{
		long m_dwRef;
		IUnknown* m_pOuterUnknown;
	};
};

template <const CLSID* pclsid>
class CComObjectBase : public CComObjectRoot
{
public:
	static HRESULT PASCAL Error(LPCOLESTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{return CComObjectRoot::Error(*pclsid, lpszDesc, iid, hRes);}

	static HRESULT PASCAL Error(LPCSTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{return CComObjectRoot::Error(*pclsid, lpszDesc, iid, hRes);}

	static HRESULT PASCAL Error(UINT nDescID, const IID& iid,
		HRESULT hRes = 0)
	{return CComObjectRoot::Error(*pclsid, _Module.GetModuleInstance(),
		nDescID, iid, hRes);}
};

template <const CLSID* pclsid, class Owner>
class CComTearOffObjectBase : public CComObjectBase<pclsid>
{
public:
	CComObject<Owner>* m_pOwner;
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObject : public Base
{
public:
	CComObject(LPUNKNOWN = NULL)
	{
		_Module.Lock();
		//If you get a message that this call is ambiguous then you need to
		// override it in your class and call each base class' version of this
		FinalConstruct();
	}
	~CComObject(){_Module.Unlock();}
	//If InternalAddRef or InteralRelease is undefined then your class
	//doesn't derive from CComObjectBase
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObjectNoLock : public Base
{
public:
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	CComObjectNoLock(LPUNKNOWN p = NULL){FinalConstruct();}

	//If InternalAddRef or InteralRelease is undefined then your class
	//doesn't derive from CComObjectBase
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
};

// It is possible for Base not to derive from CComObjectRoot in this case
// in order to avoid the 4 bytes for a refcount.
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectGlobal : public Base
{
public:
	CComObjectGlobal(LPUNKNOWN p = NULL){FinalConstruct();}

	STDMETHOD_(ULONG, AddRef)() {return _Module.Lock();}
	STDMETHOD_(ULONG, Release)(){return _Module.Unlock();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
//Owner is the class of object that Base is a tear-off for
template <class Base, class Owner>
class CComTearOffObject : public Base
{
public:
	CComTearOffObject(void* p)
	{
		m_pOwner = reinterpret_cast<CComObject<Owner>*>(p);
		m_pOwner->AddRef();
		//If you get a message that this call is ambiguous then you need to
		// override it in your class and call each base class' version of this
		FinalConstruct();
	}
	~CComTearOffObject(){m_pOwner->Release();}

	//If InternalAddRef or InteralRelease is undefined then your class
	//doesn't derive from CComObjectBase
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		if (InlineIsEqualGUID(iid, IID_IUnknown) ||
			FAILED(_InternalQueryInterface(iid, ppvObject)))
		{
			return m_pOwner->QueryInterface(iid, ppvObject);
		}
		return S_OK;
	}
};

template <class Base> //Base must be derived from CComObjectRoot
class CComContainedObject : public Base
{
public:
	CComContainedObject(LPUNKNOWN lpUnk) {m_pOuterUnknown = lpUnk;}

	STDMETHOD_(ULONG, AddRef)() {return OuterAddRef();}
	STDMETHOD_(ULONG, Release)() {return OuterRelease();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return OuterQueryInterface(iid, ppvObject);}

protected:
	friend class CComAggObject<Base>;
};

//contained is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class contained>
class CComAggObject : public IUnknown, public CComObjectRoot
{
public:
	CComAggObject(LPUNKNOWN lpUnk) : m_contained(lpUnk)
	{_Module.Lock();m_contained.FinalConstruct();}
	~CComAggObject(){_Module.Unlock();}

	STDMETHOD_(ULONG, AddRef)() {return CComThreadModel::Increment(&m_dwRef);}
	STDMETHOD_(ULONG, Release)()
	{
		if (m_dwRef == 0)
			return 0;
		LONG l = CComThreadModel::Decrement(&m_dwRef);
		if (l==0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		if (InlineIsEqualGUID(iid, IID_IUnknown))
		{
			*ppvObject = this;
			AddRef();
		}
		else
			return m_contained._InternalQueryInterface(iid, ppvObject);
		return NOERROR;
	}

protected:
	CComContainedObject<contained> m_contained;
};

class CComClassFactoryBase : public IClassFactory, public CComObjectRoot
{
public:
BEGIN_COM_MAP(CComClassFactoryBase)
	COM_INTERFACE_ENTRY(IClassFactory)
END_COM_MAP()

	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj);
	STDMETHOD(LockServer)(BOOL fLock);
	STDMETHOD(implCreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid,
		void** ppvObj)=0;
};

template <class impl>
class CComClassFactory : public CComClassFactoryBase
{
public:
	STDMETHOD(implCreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid,
		void** ppvObj)
	{
		return impl::_CreatorClass::CreateInstance(pUnkOuter, riid, ppvObj);
	}
};

// ATL doesn't support multiple LCID's at the same time
// Whatever LCID is queried for first is the one that is used.
class CComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	GUID* m_pguid;
	GUID* m_plibid;
	WORD m_wMajor;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;

public:
	// GetTI doesn't refcount
	HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo);

	void AddRef();
	void Release();
	HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
	HRESULT GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid);
	HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr);
};

template <class T, IID* piid, GUID* plibid, WORD wMajor = 1, WORD wMinor = 0>
class CComDualImpl : public T
{
public:
	CComDualImpl() {_tih.AddRef();}
	~CComDualImpl() {_tih.Release();}

	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{*pctinfo = 1; return S_OK;}

	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{return _tih.GetTypeInfo(itinfo, lcid, pptinfo);}

	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
		wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);}
protected:
	static CComTypeInfoHolder _tih;
	static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{return _tih.GetTI(lcid, ppInfo);}
};

template <class T, IID* piid, GUID* plibid, WORD wMajor = 1, WORD wMinor = 0>
CComTypeInfoHolder CComDualImpl<T, piid, plibid, wMajor, wMinor>::_tih =
{ piid, plibid, wMajor, wMinor, NULL, 0};


/////////////////////////////////////////////////////////////////////////////
// CISupportErrorInfo

template <const IID* piid>
class CComISupportErrorInfoImpl : public ISupportErrorInfo
{
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)\
	{return (InlineIsEqualGUID(riid,*piid)) ? S_OK : S_FALSE;}
};


/////////////////////////////////////////////////////////////////////////////
// CComEnumImpl

// These _CopyXXX classes are used with enumerators in order to control
// how enumerated items are initialized, copied, and deleted

// Default is shallow copy with no special init or cleanup
template <class T>
class _Copy
{
public:
	static void copy(T* p1, T* p2) {memcpy(p1, p2, sizeof(T));}
	static void init(T*) {}
	static void destroy(T*) {}
};

class _Copy<VARIANT>
{
public:
	static void copy(VARIANT* p1, VARIANT* p2) {VariantCopy(p1, p2);}
	static void init(VARIANT* p) {VariantInit(p);}
	static void destroy(VARIANT* p) {VariantClear(p);}
};

class _Copy<CONNECTDATA>
{
public:
	static void copy(CONNECTDATA* p1, CONNECTDATA* p2)
	{
		*p1 = *p2;
		if (p1->pUnk)
			p1->pUnk->AddRef();
	}
	static void init(CONNECTDATA* ) {}
	static void destroy(CONNECTDATA* p) {if (p->pUnk) p->pUnk->Release();}
};

template <class T>
class _CopyInterface
{
public:
	static void copy(T** p1, T** p2)
	{*p1 = *p2;if (*p1) (*p1)->AddRef();}
	static void init(T** ) {}
	static void destroy(T** p) {if (*p) (*p)->Release();}
};

template<class T>
class CComIEnum : public IUnknown
{
public:
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched) = 0;
	STDMETHOD(Skip)(ULONG celt) = 0;
	STDMETHOD(Reset)(void) = 0;
	STDMETHOD(Clone)(CComIEnum<T>** ppEnum) = 0;
};

template <class Base, IID* piid, class T, class Copy>
class CComEnumImpl : public Base
{
public:
	CComEnumImpl() {m_begin = m_end = m_iter = NULL; m_dwFlags = 0; m_pUnk = NULL;}
	~CComEnumImpl();
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)(void){m_iter = m_begin;return S_OK;}
	STDMETHOD(Clone)(Base** ppEnum);
	void Init(T* begin, T* end, IUnknown* pUnk, BOOL bCopy = FALSE,
		BOOL bNoInitialUnkAddRef = FALSE);
	IUnknown* m_pUnk;
	T* m_begin;
	T* m_end;
	T* m_iter;
	DWORD m_dwFlags;
	enum Flags
	{
		FlagCopy = 1,
		FlagNoInitialUnkAddRef = 2
	};
};

template <class Base, IID* piid, class T, class Copy>
CComEnumImpl<Base, piid, T, Copy>::~CComEnumImpl()
{
	if (m_dwFlags & FlagCopy)
	{
		for (T* p = m_begin; p != m_end; p++)
			Copy::destroy(p);
		delete [] m_begin;
	}
	if (m_pUnk && !(m_dwFlags & FlagNoInitialUnkAddRef))
		m_pUnk->Release();
}

template <class Base, IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Next(ULONG celt, T* rgelt,
	ULONG* pceltFetched)
{
	if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
		return E_POINTER;
	if (m_begin == NULL || m_end == NULL || m_iter == NULL)
		return E_FAIL;
	ULONG nRem = (ULONG)(m_end - m_iter);
	HRESULT hRes = S_OK;
	if (nRem < celt)
		hRes = S_FALSE;
	ULONG nMin = min(celt, nRem);
	if (pceltFetched != NULL)
		*pceltFetched = nMin;
	while(nMin--)
		Copy::copy(rgelt++, m_iter++);
	return hRes;
}

template <class Base, IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Skip(ULONG celt)
{
	m_iter += celt;
	if (m_iter < m_end)
		return S_OK;
	m_iter = m_end;
	return S_FALSE;
}

template <class Base, IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Clone(Base** ppEnum)
{
	typedef CComObject<CComEnum<Base, piid, T, Copy> > _class;
	HRESULT hRes = E_POINTER;
	if (ppEnum != NULL)
	{
		_class* p = new _class;
		if (p == NULL)
		{
			*ppEnum = NULL;
			hRes = E_OUTOFMEMORY;
		}
		else
		{
			p->Init(m_begin, m_end, (m_dwFlags & FlagCopy) ? this : m_pUnk);
			p->m_iter = m_iter;
			hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
			if (FAILED(hRes))
				delete p;
		}
	}
	return hRes;
}

template <class Base, IID* piid, class T, class Copy>
void CComEnumImpl<Base, piid, T, Copy>::Init(T* begin, T* end, IUnknown* pUnk,
	BOOL bCopy, BOOL bNoInitialUnkAddRef)
{
	_ASSERTE(!bNoInitialUnkAddRef || (pUnk!=NULL));
	if (bCopy)
	{
		m_begin = new T[end-begin];
		m_iter = m_begin;
		for (T* i=begin; i != end; i++)
		{
			Copy::init(m_iter);
			Copy::copy(m_iter++, i);
		}
		m_end = m_begin + (end-begin);
	}
	else
	{
		m_begin = begin;
		m_end = end;
	}
	m_pUnk = pUnk;
	if (m_pUnk && !bNoInitialUnkAddRef)
		m_pUnk->AddRef();
	m_iter = m_begin;
	if (bCopy)
		m_dwFlags = FlagCopy;
	if (bNoInitialUnkAddRef)
		m_dwFlags |= FlagNoInitialUnkAddRef;
}

template <class Base, IID* piid, class T, class Copy>
class CComEnum : public CComEnumImpl<Base, piid, T, Copy>, public CComObjectRoot
{
public:
	typedef CComEnum<Base, piid, T, Copy > _atl_classtype;
	HRESULT _InternalQueryInterface(REFIID iid, void** ppvObject)
	{
		static const _ATL_INTMAP_ENTRY _entries[] =
		{
			{piid, 0, _ATL_INTMAP_ENTRY::offset},
			{NULL, 0, _ATL_INTMAP_ENTRY::offset}
		};
		return InternalQueryInterface(this, _entries, iid, ppvObject);
	}
};

#ifndef ATL_NOCONNPTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

#define BEGIN_CONNECTION_POINT_MAP()\
	virtual const IID** _GetConnMap() {\
	static const IID* _entries[] = {
#define CONNECTION_POINT_ENTRY(x) &IID_##x,
#define END_CONNECTION_POINT_MAP() NULL}; return _entries;}

#ifndef _DEFAULT_VECTORLENGTH
#define _DEFAULT_VECTORLENGTH 4
#endif

template <unsigned int nMaxSize>
class CComStaticArrayCONNECTDATA
{
public:
	CComStaticArrayCONNECTDATA()
	{
		memset(m_arr, 0, sizeof(CONNECTDATA)*nMaxSize);
		m_pCurr = &m_arr[0];
	}
	BOOL Add(IUnknown* pUnk);
	BOOL Remove(DWORD dwCookie);
	CONNECTDATA* begin() {return &m_arr[0];}
	CONNECTDATA* end() {return &m_arr[nMaxSize];}
protected:
	CONNECTDATA m_arr[nMaxSize];
	CONNECTDATA* m_pCurr;
};

template <unsigned int nMaxSize>
inline BOOL CComStaticArrayCONNECTDATA<nMaxSize>::Add(IUnknown* pUnk)
{
	for (CONNECTDATA* p = begin();p<end();p++)
	{
		if (p->pUnk == NULL)
		{
			p->pUnk = pUnk;
			p->dwCookie = (DWORD)pUnk;
			return TRUE;
		}
	}
	return FALSE;
}

template <unsigned int nMaxSize>
inline BOOL CComStaticArrayCONNECTDATA<nMaxSize>::Remove(DWORD dwCookie)
{
	CONNECTDATA* p;
	for (p=begin();p<end();p++)
	{
		if (p->dwCookie == dwCookie)
		{
			p->pUnk = NULL;
			p->dwCookie = NULL;
			return TRUE;
		}
	}
	return FALSE;
}

class CComStaticArrayCONNECTDATA<1>
{
public:
	CComStaticArrayCONNECTDATA() {m_cd.pUnk = NULL; m_cd.dwCookie = 0;}
	BOOL Add(IUnknown* pUnk)
	{
		if (m_cd.pUnk != NULL)
			return FALSE;
		m_cd.pUnk = pUnk;
		m_cd.dwCookie = (DWORD)pUnk;
		return TRUE;
	}
	BOOL Remove(DWORD dwCookie)
	{
		if (dwCookie != m_cd.dwCookie)
			return FALSE;
		m_cd.pUnk = NULL;
		m_cd.dwCookie = 0;
		return TRUE;
	}
	CONNECTDATA* begin() {return &m_cd;}
	CONNECTDATA* end() {return (&m_cd)+1;}
protected:
	CONNECTDATA m_cd;
};

class CComDynamicArrayCONNECTDATA
{
public:
	CComDynamicArrayCONNECTDATA()
	{
		m_nSize = 0;
		m_pCD = NULL;
	}

	~CComDynamicArrayCONNECTDATA() {free(m_pCD);}
	BOOL Add(IUnknown* pUnk);
	BOOL Remove(DWORD dwCookie);
	CONNECTDATA* begin()
	{
		CONNECTDATA* p;
		switch(m_nSize)
		{
		case 0:
		case 1:
			p = &m_cd;
			p = &m_cd;
			break;
		default:
			p = m_pCD;
			break;
		}
		return p;
	}
	CONNECTDATA* end()
	{
		CONNECTDATA* p;
		switch(m_nSize)
		{
		case 0:
			p = &m_cd;
			break;
		case 1:
			p = (&m_cd)+1;
			break;
		default:
			p = &m_pCD[m_nSize];
			break;
		}
		return p;
	}
protected:
	CONNECTDATA* m_pCD;
	CONNECTDATA m_cd;
	int m_nSize;
};

class CComConnectionPointBase : public IConnectionPoint
{
	typedef CComEnum<IEnumConnections, &IID_IEnumConnections, CONNECTDATA,
		_Copy<CONNECTDATA> > CComEnumConnections;
public:
	CComConnectionPointBase(IConnectionPointContainer* pContainer,
		const IID* piid)
	{
		_ASSERTE(pContainer != NULL);
		_ASSERTE(piid != NULL);
		m_pContainer = pContainer;
		m_piid = piid;
	}

	//Connection point lifetimes are determined by the container
	STDMETHOD_(ULONG, AddRef)() {return m_pContainer->AddRef();}
	STDMETHOD_(ULONG, Release)(){return m_pContainer->Release();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		static const _ATL_INTMAP_ENTRY entries[] = {{&IID_IConnectionPoint, 0, _ATL_INTMAP_ENTRY::offset}};
		return CComObjectRoot::InternalQueryInterface(this, entries, iid, ppvObject);
	}

	STDMETHOD(GetConnectionInterface)(IID* piid);
	STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer** ppCPC);
protected:
	IConnectionPointContainer* m_pContainer;
	const IID* m_piid;
};

template <class CDV>
class CComConnectionPoint : public CComConnectionPointBase
{
	typedef CComEnum<IEnumConnections, &IID_IEnumConnections, CONNECTDATA,
		_Copy<CONNECTDATA> > CComEnumConnections;
public:
	CComConnectionPoint(IConnectionPointContainer* pContainer, const IID* piid) :
		CComConnectionPointBase(pContainer, piid)
	{m_sec.Init();}

	~CComConnectionPoint() {m_sec.Term();}
	//Connection point lifetimes are determined by the container

	STDMETHOD(Advise)(IUnknown* pUnkSink, DWORD* pdwCookie);
	STDMETHOD(Unadvise)(DWORD dwCookie);
	STDMETHOD(EnumConnections)(IEnumConnections** ppEnum);

protected:
	CComThreadModel::ObjectCriticalSection m_sec;
	CDV m_vec;
	friend class CComConnectionPointContainerImpl<CDV>;
};

template <class CDV>
STDMETHODIMP CComConnectionPoint<CDV>::Advise(IUnknown* pUnkSink,
	DWORD* pdwCookie)
{
	IUnknown* p;
	HRESULT hRes = S_OK;
	if (pUnkSink == NULL || pdwCookie == NULL)
		return E_POINTER;
	m_sec.Lock();
	if (SUCCEEDED(pUnkSink->QueryInterface(*m_piid, (void**)&p)))
	{
		*pdwCookie = (DWORD)p;
		hRes = m_vec.Add(p) ? S_OK : CONNECT_E_ADVISELIMIT;
		if (hRes != S_OK)
		{
			*pdwCookie = 0;
			p->Release();
		}
	}
	else
		hRes = CONNECT_E_CANNOTCONNECT;
	m_sec.Unlock();
	return hRes;
}

template <class CDV>
STDMETHODIMP CComConnectionPoint<CDV>::Unadvise(DWORD dwCookie)
{
	m_sec.Lock();
	HRESULT hRes = m_vec.Remove(dwCookie) ? S_OK : CONNECT_E_NOCONNECTION;
	IUnknown* p = (IUnknown*) dwCookie;
	m_sec.Unlock();
	if (hRes == S_OK && p != NULL)
		p->Release();
	return hRes;
}

template <class CDV>
STDMETHODIMP CComConnectionPoint<CDV>::EnumConnections(
	IEnumConnections** ppEnum)
{
	CComEnumConnections* pEnum = new CComObject<CComEnumConnections>;
	m_sec.Lock();
	CONNECTDATA* pcd = new CONNECTDATA[m_vec.end()-m_vec.begin()];
	CONNECTDATA* pend = pcd;
	// Copy the valid CONNECTDATA's
	for (CONNECTDATA* p = m_vec.begin();p<m_vec.end();p++)
	{
		if (p->pUnk != NULL)
		{
			p->pUnk->AddRef();
			*pend++ = *p;
		}
	}
	// don't copy the data, but transfer ownership to it
	pEnum->Init(pcd, pend, NULL, FALSE);
	pEnum->m_dwFlags |= CComEnumConnections::FlagCopy;
	m_sec.Unlock();
	*ppEnum = pEnum;
	return S_OK;
}

template <class CDV>
class CComConnectionPointContainerImpl : public IConnectionPointContainer
{
	typedef CComEnum<IEnumConnectionPoints,
		&IID_IEnumConnectionPoints, IConnectionPoint*,
		_CopyInterface<IConnectionPoint> >
		CComEnumConnectionPoints;
public:
	void FinalConstruct();
	~CComConnectionPointContainerImpl();
	STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints** ppEnum);
	STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint** ppCP);

protected:
	virtual const IID** _GetConnMap() = 0;
	CComConnectionPoint<CDV>** m_ppCP;
	int m_nCP;
};

template <class CDV>
void CComConnectionPointContainerImpl<CDV>::FinalConstruct()
{
	const IID** ppiid= _GetConnMap();
	m_nCP=0;
	while (*ppiid++ != NULL)
		m_nCP++;
	_ASSERTE(m_nCP > 0);
	m_ppCP = new CComConnectionPoint<CDV>*[m_nCP];
	CComConnectionPoint<CDV>** ppCP = m_ppCP;
	ppiid= _GetConnMap();
	for (int i=0;i<m_nCP;i++, ppiid++, ppCP++)
	{
		//don't AddRef this pointer because it will AddRef us
		*ppCP = new CComConnectionPoint<CDV>(this, *ppiid);
	}
}

template <class CDV>
CComConnectionPointContainerImpl<CDV>::~CComConnectionPointContainerImpl()
{
	_ASSERTE(m_nCP > 0);
	CComConnectionPoint<CDV>** ppCP = m_ppCP;
	for (int i=0;i<m_nCP;i++, ppCP++)
		delete *ppCP;
	delete [] m_ppCP;
}

template <class CDV>
STDMETHODIMP CComConnectionPointContainerImpl<CDV>::EnumConnectionPoints(
	IEnumConnectionPoints** ppEnum)
{
	_ASSERTE(m_nCP > 0);
	CComEnumConnectionPoints* pEnum = new CComObject<CComEnumConnectionPoints>;
	// don't copy the data but do AddRef this object
	pEnum->Init((IConnectionPoint**)&m_ppCP[0],
		(IConnectionPoint**)&m_ppCP[m_nCP], this, FALSE);
	*ppEnum = pEnum;
	return S_OK;
}

template <class CDV>
STDMETHODIMP CComConnectionPointContainerImpl<CDV>::FindConnectionPoint(
	REFIID riid, IConnectionPoint** ppCP)
{
	_ASSERTE(m_nCP > 0);
	if (ppCP == NULL)
		return E_POINTER;
	*ppCP = NULL;
	HRESULT hRes = CONNECT_E_NOCONNECTION;
	const IID** ppiid= _GetConnMap();
	for (int i=0;i<m_nCP;i++, ppiid++)
	{
		if (InlineIsEqualGUID(**ppiid, riid))
		{
			*ppCP = m_ppCP[i];
			(*ppCP)->AddRef();
			hRes = S_OK;
			break;
		}
	}
	return hRes;
}
#endif //!ATL_NOCONNPTS

#pragma pack(pop)

#endif // __ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\cisatest\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>



//
//  Define the debugging constants 
// 

# define DEBUG_INIT                (DEBUG_INIT_CLEAN) 
# define DEBUG_CLEANUP             (DEBUG_INIT_CLEAN) 

# define DEBUG_OBJECT              0x00001000
# define DEBUG_IID                 0x00002000
# define DEBUG_MISC                0x00004000


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\comisapi\cisa\cisa.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       cisa.cpp

   Abstract:
      This module defines the DLL main and additional book-keeping
      functions for ComIsapi

   Author:

       Greg Hope & Murali R. Krishnan  1-Aug-1996
   Environment:

   Project:
       Internet Application Server
--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "cisap.hxx"
#include "resource.h"
#include "initguid.h"
#include "cisa.h"
#include "cisaobj.h"

#define IID_DEFINED
#include "cisa_i.c"
# include "dbgutil.h"

/************************************************************
 *    Global Variables
 ************************************************************/

// Define the variables for ATL

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_ComIsapi, CComIsapiObject, 
                     "CISA.ComIsapiObject.1", 
                     "CISA.ComIsapiObject.1", 
                     IDS_COMISAPI_DESC, 
                     THREADFLAGS_BOTH)
END_OBJECT_MAP()

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();

/************************************************************
 *    Functions 
 ************************************************************/

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {

        CREATE_DEBUG_PRINT_OBJECT( "cisa");
        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            
            return ( FALSE);
        }
        
        SET_DEBUG_FLAGS( DEBUG_OBJECT | DEBUG_ERROR | DEBUG_IID);

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();

        DELETE_DEBUG_PRINT_OBJECT();
    }
        
    return TRUE;    // ok

} // DllMain()



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
} // DllCanUnloadNow()


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    IF_DEBUG( IID) {
        
        DBGPRINTF(( DBG_CONTEXT, "GetClassObject( %08x, %08x, %08x)\n",
                    rclsid, riid, ppv));
    }

#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    hr = _Module.GetClassObject(rclsid, riid, ppv);

    IF_DEBUG( IID) {

        DBGPRINTF(( DBG_CONTEXT, "GetClassObject() returns %08x. (ppv=%08x)\n",
                    hr, *ppv));
    }

    return ( hr);
} // DllGetClassObject()


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hRes = S_OK;
#ifdef _MERGE_PROXYSTUB
    hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    hRes = _Module.UpdateRegistry(TRUE);
    return hRes;

} // DllRegisterServer()


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hRes = S_OK;
    _Module.RemoveRegistry();
#ifdef _MERGE_PROXYSTUB
    hRes = PrxDllUnregisterServer();
#endif
    return hRes;
} // DllUnregisterServer()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\comisapi\cisa\stdafx.cpp ===
#include "cisap.hxx"

#include "atlimpl.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\comisapi\cisa\cisaobj.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      cisaobj.h 

   Abstract:
      Defines the implementation object for ComIsapi

   Author:

       Murali R. Krishnan    ( MuraliK )    1-Aug-1996

   Project:
   
       Internet Application Server DLL

--*/

# ifndef _CISAOBJ_HXX_
# define _CISAOBJ_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/

#include "resource.h"       // main symbols
#include <iisextp.h>
# include "cpECB.h"

/************************************************************
 *   Type Definitions  
 ************************************************************/

class CComIsapiObject : 
	public IComIsapi,
	public CComObjectBase<&CLSID_ComIsapi>
{
public:
	CComIsapiObject();
	~CComIsapiObject();
BEGIN_COM_MAP(CComIsapiObject)
	COM_INTERFACE_ENTRY(IComIsapi)
END_COM_MAP()
// Use DECLARE_NOT_AGGREGATABLE(CComisapiObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CComIsapiObject)

private:
    HINSTANCE m_hIsapiDll;
    DWORD (WINAPI* m_pHttpExtensionProc)(EXTENSION_CONTROL_BLOCK*);
    IcpECB   * m_pIcpECB;

    IcpECB * IcpECB( VOID)
    { return ( m_pIcpECB); }

// IComIsapi
public:
    STDMETHOD(HttpExtensionProc)(
                                 IN  IN_CISA_WIRE_ECB *  pInCisaWireEcb,
                                 IN OUT OUT_CISA_WIRE_ECB * pOutCisaWireEcb
                                 );

    STDMETHOD (SetIsapiSink) ( IN IUnknown * punkECB);

    static BOOL (WINAPI WriteClient)(HCONN, LPVOID, LPDWORD, DWORD);
};

# endif // _CISAOBJ_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\cisatest\foo.cpp ===
#include <objbase.h>
#include <httpext.h>
#include <assert.h>

#define OUTPUT	"<html>\n<h1>\nHello from foo.dll via comisapi\n</h1></html>\n"

BOOL WINAPI DllMain(
	HINSTANCE	hinstDll,
	DWORD		fdwReason,
	LPVOID		lpvContext)
{
  return TRUE;
}

BOOL WINAPI GetExtensionVersion(
	HSE_VERSION_INFO* pVer)
{
	pVer->dwExtensionVersion = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

	strncpy(pVer->lpszExtensionDesc, "Test IsapiToComisapi", HSE_MAX_EXT_DLL_NAME_LEN);
	return TRUE;
}

DWORD WINAPI HttpExtensionProc(
	EXTENSION_CONTROL_BLOCK* pECB)
{
	DWORD cchOutput = strlen(OUTPUT);
	pECB->WriteClient(pECB->ConnID, OUTPUT, &cchOutput, NULL);
	return HSE_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\comisapi\cisa\cisaobj.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       cisaobj.cpp

   Abstract:

       This module defines the functions for CComIsapi Object

   Author:

       Murali R. Krishnan    ( MuraliK )     1-Aug-1996 

   Project:

       Internet Application Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "windows.h"
# include "cisap.hxx"
# include "cisa.h"
# include "cisaobj.h"
// #include <viperr.h>
# include "assert.h"
# define INTERNAL_ERROR_CHECK(x)  assert(x)

#include <iisext.h>

#define IID_DEFINED
#include "cpECB.h"
#include "cpECB_i.c"
# include "dbgutil.h"

/************************************************************
 *    Functions 
 ************************************************************/

class CISA_ECB {

private:
    EXTENSION_CONTROL_BLOCK  m_ecb;
    HCONN      m_hConnOriginal;
    IcpECB   * m_pIcpECB;

public:
    CISA_ECB( VOID) 
        : m_pIcpECB ( NULL)
    {
        DBG_CODE( memset( &m_ecb, 0, sizeof(m_ecb)));
    }

    ~CISA_ECB( VOID)
    { 
        Cleanup();
    }

    VOID Cleanup( VOID)
    {
        m_pIcpECB = NULL;
    }

    STDMETHOD ( GetECB) ( void * pIcpECB, IN_CISA_WIRE_ECB * pince);
    STDMETHOD ( SetReturnWireEcb) ( OUT_CISA_WIRE_ECB * poutce);

    EXTENSION_CONTROL_BLOCK * IsapiECB(VOID) 
    { return ( &m_ecb); }

    IcpECB * IcpECB( VOID)
    { return ( m_pIcpECB); }

    HCONN OriginalHConn( VOID)
    { return ( m_hConnOriginal); }

};  // class CISA_ECB




STDMETHODIMP
CISA_ECB::GetECB( void * pIcpECB, IN_CISA_WIRE_ECB * pince)
{
    HRESULT hr = S_OK;

    *((void * *) &m_pIcpECB) = (void * ) pIcpECB;

    if ( SUCCEEDED( hr)) {
        int cbSize = sizeof(EXTENSION_CONTROL_BLOCK);

#ifndef WIRE_ECB 
        hr = m_pIcpECB->GetECB(&cbSize, (unsigned char*) &m_ecb);
# else // if WIRE_ECB
        DBG_ASSERT( pince != NULL);
        if ( pince == NULL) {

            return ( E_POINTER);
        }

        // extract the ECB fields from 'pince'
        m_ecb.cbSize           = sizeof(EXTENSION_CONTROL_BLOCK);
        m_ecb.dwVersion        = MAKELONG( HSE_VERSION_MINOR, 
                                         HSE_VERSION_MAJOR );
        m_ecb.dwHttpStatusCode = 200;  // the correct status code - fabricated!
        m_ecb.lpszLogData[0]   = '\0';

        // Function pointers are meaningless now!
        m_ecb.GetServerVariable= NULL;
        m_ecb.WriteClient      = NULL;
        m_ecb.ReadClient       = NULL;
        m_ecb.ServerSupportFunction = NULL;

        m_ecb.ConnID           = (HCONN ) pince->ConnID;
        m_ecb.lpszMethod       = (LPSTR ) pince->lpszMethod;
        m_ecb.lpszQueryString  = (LPSTR ) pince->lpszQueryString;
        m_ecb.lpszPathInfo     = (LPSTR ) pince->lpszPathInfo;
        m_ecb.lpszPathTranslated = (LPSTR ) pince->lpszPathXlated;
        m_ecb.lpszContentType  = (LPSTR ) pince->lpszContentType;
        m_ecb.cbTotalBytes     = pince->cbTotalBytes;

        //
        //  Clients can send more bytes then are indicated in their
        //  Content-Length header.  Adjust byte counts so they match
        //
        
        m_ecb.cbAvailable      = pince->cbAvailable;
        m_ecb.lpbData          = pince->lpbData;

        DBG_ASSERT( hr == S_OK);

# endif // WIRE_ECB
        if ( SUCCEEDED( hr)) {
            
            // cache the proper values
            m_hConnOriginal  = m_ecb.ConnID;
            
            // reset some of the internal fields to redirect the pointers
            m_ecb.ConnID = (HCONN ) this;
            m_ecb.WriteClient = CComIsapiObject::WriteClient;
        }
    }

    return ( hr);
} // CISA_ECB::GetECB()


STDMETHODIMP
CISA_ECB::SetReturnWireEcb( OUT_CISA_WIRE_ECB * poutce)
{

# ifdef WIRE_ECB

    DBG_ASSERT( poutce != NULL);
    poutce->dwHttpStatusCode = m_ecb.dwHttpStatusCode;
    poutce->cbLogData = (strlen( m_ecb.lpszLogData) + 1) * sizeof(CHAR);
    memcpy( poutce->lpchLogData, m_ecb.lpszLogData, poutce->cbLogData);
# endif 

    return ( S_OK);
} // CISA_ECB::SetReturnWireEcb()



/************************************************************
 *  Member functions of  CComIsapi
 ************************************************************/

#define HTTPEXTENSIONPROC "HttpExtensionProc"


CComIsapiObject::CComIsapiObject()
        : m_pIcpECB( NULL) 
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "creating CComIsapiObject() ==>%08x\n",
                    this));
    }

    m_hIsapiDll = LoadLibraryW(L"foo.dll");  // we need to fix this one.
    DBG_ASSERT(m_hIsapiDll != NULL);
    
    m_pHttpExtensionProc =  
        ( (PFN_HTTPEXTENSIONPROC) 
          GetProcAddress(m_hIsapiDll, HTTPEXTENSIONPROC)
          );
    DBG_ASSERT(m_pHttpExtensionProc != NULL);
    
} // CComIsapiObject::CComIsapiObject()



CComIsapiObject::~CComIsapiObject()
{
    if ( m_pIcpECB != NULL) {
        
        m_pIcpECB->Release();
        m_pIcpECB = NULL;
    }
    
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "deleting CComIsapiObject() ==>%08x\n",
                    this));
    }

    if (m_hIsapiDll)
        FreeLibrary(m_hIsapiDll);

} // CComIsapiObj::~CComIsapiObject()



STDMETHODIMP
CComIsapiObject::SetIsapiSink( IN IUnknown * punkECB)
{
    HRESULT hr;

    //
    hr = punkECB->QueryInterface(IID_IcpECB, (void**)&m_pIcpECB);
    //  Since  IcpECB is derived from IUnknown - I can just cast this object
    //   This would save us one proxy-marshalling trip to do the QI
    //
    IF_DEBUG( OBJECT) {
        DBGPRINTF(( DBG_CONTEXT, 
                    " punkECB(%08x)->QueryInterface( IID_IcpECB) ==>"
                    " pIcpECB = %08x.  hr = %08x\n"
                    ,
                    punkECB, m_pIcpECB, hr));
    }

    // *((void **) &m_pIcpECB) = (void *) punkECB;
    // hr = S_OK;

    return ( hr);
} // CComIsapiObject::SetIsapiSink()



STDMETHODIMP
CComIsapiObject::HttpExtensionProc(
    IN  IN_CISA_WIRE_ECB *  pInCisaWireEcb,
    OUT OUT_CISA_WIRE_ECB * pOutCisaWireEcb
    )
{
    HRESULT hr;
    CISA_ECB  cecb;

    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, 
                    "ComIsapi[%08x]::HEP("
                    " m_pIcpECB=%08x,"
                    " InCisaEcb=%08x,"
                    " OutCisaEcb=%08x\n"
                    ,
                    this, m_pIcpECB, pInCisaWireEcb, pOutCisaWireEcb));
    }

    if ( ( NULL == m_hIsapiDll) || 
         ( NULL == m_pHttpExtensionProc) ||
         ( NULL == m_pIcpECB)
         ){

        pOutCisaWireEcb->dwHseStatus = ERROR_PROC_NOT_FOUND;
        return ( E_FAIL);
    }
 
    hr = cecb.GetECB( IcpECB(), pInCisaWireEcb);
    if ( !SUCCEEDED(hr)) {
        pOutCisaWireEcb->dwHseStatus = hr;
        return ( hr);
    }
    
    DBG_ASSERT( hr == S_OK);
    
    IF_DEBUG( OBJECT) {
        DBGPRINTF(( DBG_CONTEXT, 
                    "%08x::Calling the HttpExtensionFunction(%08x)"
                    " with ECB=%08x. ConnID=%08x.\n",
                    this, m_pHttpExtensionProc, cecb.IsapiECB(), 
                    (cecb.IsapiECB())->ConnID));
    }
    
    pOutCisaWireEcb->dwHseStatus = (m_pHttpExtensionProc)( cecb.IsapiECB() );

    DBG_ASSERT( pOutCisaWireEcb->dwHseStatus != HSE_STATUS_PENDING);
    cecb.SetReturnWireEcb( pOutCisaWireEcb);
    cecb.Cleanup();
    
    return S_OK;
} // CComIsapiObject::HttpExtensionProc()




BOOL (WINAPI CComIsapiObject::WriteClient)(
        IN HCONN      ConnID,
        IN LPVOID     Buffer,
        IN LPDWORD    lpdwBytes,
        IN DWORD      dwReserved)
{
    HRESULT hr;
    CISA_ECB * pcecb = (CISA_ECB *) ConnID;
    
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, 
                    "CComIsapiObject::WriteClient( ConnID:%08x, "
                    " Buffer(%d bytes):%08x dwReserved:%x)\n",
                    ConnID, *lpdwBytes, Buffer, dwReserved));
    }
    
    hr = (pcecb->IcpECB())->WriteClient( (long ) pcecb->OriginalHConn(), 
                                         *(int*)lpdwBytes, 
                                         (unsigned char*)Buffer,
                                         dwReserved);
    
    return ( (SUCCEEDED(hr)) ? TRUE : FALSE);
} // CComIsapiObject::WriteClient()




/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\comisapi\cisa\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by comisapi.rc
//
#define IDS_COMISAPI_DESC	1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\comisapi\cisa\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants 
// 

# define DEBUG_INIT                (DEBUG_INIT_CLEAN)
# define DEBUG_CLEANUP             (DEBUG_INIT_CLEAN) 

# define DEBUG_OBJECT              0x00001000
# define DEBUG_IID                 0x00002000
# define DEBUG_MISC                0x00004000


# if DBG 

extern     DWORD  g_dwDebugFlags;           // Debugging Flags

# define DECLARE_DEBUG_VARIABLE()     \
             DWORD  g_dwDebugFlags

# define SET_DEBUG_FLAGS( dwFlags)         g_dwDebugFlags = dwFlags
# define GET_DEBUG_FLAGS()                 ( g_dwDebugFlags)

# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault)  \
               g_dwDebugFlags = PuLoadDebugFlagsFromReg((hkey), (dwDefault))

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)  \
               PuSaveDebugFlagsInReg((hkey), (dwDbg))

# define DEBUG_IF( arg, s)     if ( DEBUG_ ## arg & GET_DEBUG_FLAGS()) { \
                                       s \
                                } else {}

# define IF_DEBUG( arg)        if ( DEBUG_## arg & GET_DEBUG_FLAGS()) 


# else   // DBG


# define DECLARE_DEBUG_VARIABLE()                /* Do Nothing */
# define SET_DEBUG_FLAGS( dwFlags)               /* Do Nothing */
# define GET_DEBUG_FLAGS()                       ( 0)
# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault)  \
               g_dwDebugFlags = (dwDefault)

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)    /* Do Nothing */

# define DEBUG_IF( arg, s)                       /* Do Nothing */
# define IF_DEBUG( arg)                          if ( 0) 

# endif // DBG


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\comisapi\cisa\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\ecb\cpecb.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       cpecb.cpp

   Abstract:
       This module defines the DLL main and additional book-keeping 
       functions for ComIsapi
 
   Author:

       Murali R. Krishnan    ( MuraliK )     1-Aug-1996 

   Project:

       Internet Application Server DLL

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "cpecb.h"
#include "cpecbobj.h"
#include "dlldatax.h"

# define IID_DEFINED
# include "cpecb_i.c"
# include "dbgutil.h"

/************************************************************
 *    Global Variables
 ************************************************************/

// Define the variables for ATL

CComModule _Module;

BEGIN_OBJECT_MAP( ObjectMap)
    OBJECT_ENTRY( CLSID_cpECB, 
                  CcpECBObject, 
                  "CPECB.cpECBObject.1",
                  "CPECB.cpECBObject.1",
                  IDS_CPECB_DESC, 
                  THREADFLAGS_BOTH)
END_OBJECT_MAP()

DECLARE_DEBUG_PRINTS_OBJECT();                  
DECLARE_DEBUG_VARIABLE();

CRITICAL_SECTION   g_csInitLock;

/************************************************************
 *    Functions 
 ************************************************************/

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{

#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {
        
        CREATE_DEBUG_PRINT_OBJECT( "cpecb");
        if ( !VALID_DEBUG_PRINT_OBJECT()) { 
            return ( FALSE);
        }
        SET_DEBUG_FLAGS( DEBUG_OBJECT | DEBUG_IID | DEBUG_ERROR);

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        InitializeCriticalSection( & g_csInitLock);
    }
    else if (dwReason == DLL_PROCESS_DETACH) {

        _Module.Term();
        DeleteCriticalSection( & g_csInitLock);
        DELETE_DEBUG_PRINT_OBJECT();
    }
        
    return TRUE;    // ok

} // DllMain()



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
} // DllCanUnloadNow()


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    IF_DEBUG( IID) {
        
        DBGPRINTF(( DBG_CONTEXT, "GetClassObject( %08x, %08x, %08x)\n",
                    rclsid, riid, ppv));
    }

#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    hr = _Module.GetClassObject(rclsid, riid, ppv);

    IF_DEBUG( IID) {

        DBGPRINTF(( DBG_CONTEXT, "GetClassObject() returns %08x. (ppv=%08x)\n",
                    hr, *ppv));
    }

    return ( hr);
} // DllGetClassObject()


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hRes = S_OK;
#ifdef _MERGE_PROXYSTUB
    hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    hRes = _Module.UpdateRegistry(TRUE);
    return hRes;

} // DllRegisterServer()


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hRes = S_OK;
    _Module.RemoveRegistry();
#ifdef _MERGE_PROXYSTUB
    hRes = PrxDllUnregisterServer();
#endif
    return hRes;
} // DllUnregisterServer()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\ecb\dlldatax.h ===
#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\ecb\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Sou